#define DEBUG_LOCOMOTION_PANEL
using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.Serialization.Formatters.Binary;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Xml;
using AOT;
using DigitalOpus.MB.Core;
using Dreamteck.Splines;
using Dreamteck.Splines.Primitives;
using I2.Loc;
using Lightning;
using MirzaBeig.Scripting.Effects;
using NLayer;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oculus.Avatar;
using Oculus.Platform;
using Oculus.Platform.Models;
using Oculus.Spatializer.Propagation;
using ProBuilder2.Common;
using RealisticEyeMovements;
using RogoDigital.Lipsync;
using SSFS;
using SimpleJSON;
using TMPro;
using Tayx.Graphy;
using Tayx.Graphy.Advanced;
using Tayx.Graphy.Audio;
using Tayx.Graphy.Fps;
using Tayx.Graphy.Graph;
using Tayx.Graphy.Ram;
using Tayx.Graphy.UI;
using Tayx.Graphy.Utils;
using UnityEngine;
using UnityEngine.AI;
using UnityEngine.Audio;
using UnityEngine.EventSystems;
using UnityEngine.Events;
using UnityEngine.Networking;
using UnityEngine.Playables;
using UnityEngine.Profiling;
using UnityEngine.Rendering;
using UnityEngine.SceneManagement;
using UnityEngine.Serialization;
using UnityEngine.UI;
using UnityEngine.Video;
using UnityEngine.XR;
using UnityStandardAssets.CrossPlatformInput;
using UnityStandardAssets.CrossPlatformInput.PlatformSpecific;
using UnityStandardAssets.Utility;
using VRUiKits.Utils;
using YoutubeLight;

[assembly: CompilationRelaxations(8)]
[assembly: RuntimeCompatibility(WrapNonExceptionThrows = true)]
[assembly: Debuggable(DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints)]
[assembly: AssemblyVersion("0.0.0.0")]
public class ExtendedFlycam : MonoBehaviour
{
	public float cameraSensitivity = 90f;

	public float climbSpeed = 4f;

	public float normalMoveSpeed = 10f;

	public float slowMoveFactor = 0.25f;

	public float fastMoveFactor = 3f;

	private float rotationX;

	private float rotationY;

	private void Start()
	{
		Cursor.lockState = CursorLockMode.Locked;
		Cursor.visible = false;
	}

	private void Update()
	{
		if (Cursor.lockState != 0)
		{
			rotationX += Input.GetAxis("Mouse X") * cameraSensitivity * Time.deltaTime;
			rotationY += Input.GetAxis("Mouse Y") * cameraSensitivity * Time.deltaTime;
		}
		rotationY = Mathf.Clamp(rotationY, -90f, 90f);
		Quaternion b = Quaternion.AngleAxis(rotationX, Vector3.up);
		b *= Quaternion.AngleAxis(rotationY, Vector3.left);
		base.transform.localRotation = Quaternion.Lerp(base.transform.localRotation, b, Time.deltaTime * 5f);
		if (Input.GetKey(KeyCode.LeftShift) || Input.GetKey(KeyCode.RightShift))
		{
			base.transform.position += base.transform.forward * (normalMoveSpeed * fastMoveFactor) * Input.GetAxis("Vertical") * Time.deltaTime;
			base.transform.position += base.transform.right * (normalMoveSpeed * fastMoveFactor) * Input.GetAxis("Horizontal") * Time.deltaTime;
			if (Input.GetKey(KeyCode.Q))
			{
				base.transform.position += Vector3.up * climbSpeed * fastMoveFactor * Time.deltaTime;
			}
			if (Input.GetKey(KeyCode.E))
			{
				base.transform.position -= Vector3.up * climbSpeed * fastMoveFactor * Time.deltaTime;
			}
		}
		else if (Input.GetKey(KeyCode.LeftControl) || Input.GetKey(KeyCode.RightControl))
		{
			base.transform.position += base.transform.forward * (normalMoveSpeed * slowMoveFactor) * Input.GetAxis("Vertical") * Time.deltaTime;
			base.transform.position += base.transform.right * (normalMoveSpeed * slowMoveFactor) * Input.GetAxis("Horizontal") * Time.deltaTime;
			if (Input.GetKey(KeyCode.Q))
			{
				base.transform.position += Vector3.up * climbSpeed * slowMoveFactor * Time.deltaTime;
			}
			if (Input.GetKey(KeyCode.E))
			{
				base.transform.position -= Vector3.up * climbSpeed * slowMoveFactor * Time.deltaTime;
			}
		}
		else
		{
			base.transform.position += base.transform.forward * normalMoveSpeed * Input.GetAxis("Vertical") * Time.deltaTime;
			base.transform.position += base.transform.right * normalMoveSpeed * Input.GetAxis("Horizontal") * Time.deltaTime;
			if (Input.GetKey(KeyCode.Q))
			{
				base.transform.position += Vector3.up * climbSpeed * Time.deltaTime;
			}
			if (Input.GetKey(KeyCode.E))
			{
				base.transform.position -= Vector3.up * climbSpeed * Time.deltaTime;
			}
		}
		if (Input.GetKeyDown(KeyCode.End) || Input.GetKeyDown(KeyCode.Escape))
		{
			if (Cursor.lockState == CursorLockMode.None)
			{
				Cursor.lockState = CursorLockMode.Locked;
				Cursor.visible = false;
			}
			else
			{
				Cursor.lockState = CursorLockMode.None;
				Cursor.visible = true;
			}
		}
	}
}
public class ForestMaker : MonoBehaviour
{
	public GameObject m_treePrefab;

	public int m_amount;

	public GameObject m_ground;

	public float m_radiusDistance;

	private void Start()
	{
		if (m_treePrefab == null)
		{
			return;
		}
		m_ground.transform.localScale = new Vector3(m_amount * 10, 1f, (float)(m_amount * 5) * 1.866f);
		for (int i = -m_amount / 2; i <= m_amount / 2; i++)
		{
			for (int j = -m_amount / 2; j <= m_amount / 2; j++)
			{
				if (!(UnityEngine.Random.Range(0f, 1f) > 0.5f))
				{
					GameObject obj = UnityEngine.Object.Instantiate(m_treePrefab);
					Vector3 zero = Vector3.zero;
					zero.x = ((float)i + (float)j * 0.5f - (float)(int)(((j < 0) ? ((float)j - 1f) : ((float)j)) / 2f)) * 2f * m_radiusDistance;
					zero.z = (float)j * 1.866f * m_radiusDistance;
					obj.transform.position = zero;
					float num = UnityEngine.Random.Range(1f, 1.5f);
					obj.transform.localScale = Vector3.one * num;
					obj.transform.Rotate(UnityEngine.Random.Range(-10f, 10f), UnityEngine.Random.Range(-180f, 180f), UnityEngine.Random.Range(-10f, 10f));
				}
			}
		}
	}
}
public enum ImpostorType
{
	Spherical,
	Octahedron,
	HemiOctahedron
}
[Flags]
public enum DeferredBuffers
{
	AlbedoAlpha = 1,
	SpecularSmoothness = 2,
	NormalDepth = 4,
	EmissionOcclusion = 8
}
public enum NormalCompression
{
	None,
	LowQuality,
	NormalQuality,
	HighQuality
}
[CreateAssetMenu(fileName = "New Impostor", order = 85)]
public class AmplifyImpostorAsset : ScriptableObject
{
	[SerializeField]
	public Material Material;

	[SerializeField]
	public Mesh Mesh;

	[HideInInspector]
	[SerializeField]
	public int Version;

	[SerializeField]
	public ImpostorType ImpostorType = ImpostorType.Octahedron;

	[HideInInspector]
	[SerializeField]
	public bool LockedSizes = true;

	[HideInInspector]
	[SerializeField]
	public int SelectedSize = 2048;

	[SerializeField]
	public Vector2 TexSize = new Vector2(2048f, 2048f);

	[HideInInspector]
	[SerializeField]
	public bool DecoupleAxisFrames;

	[SerializeField]
	[Range(1f, 32f)]
	public int HorizontalFrames = 16;

	[SerializeField]
	[Range(1f, 33f)]
	public int VerticalFrames = 16;

	[SerializeField]
	[Range(0f, 64f)]
	public int PixelPadding = 32;

	[SerializeField]
	public DeferredBuffers BufferMask = (DeferredBuffers)(-1);

	[SerializeField]
	[Range(4f, 16f)]
	public int MaxVertices = 8;

	[SerializeField]
	[Range(0f, 0.2f)]
	public float Tolerance = 0.15f;

	[SerializeField]
	[Range(0f, 1f)]
	public float NormalScale = 0.01f;

	[SerializeField]
	public Vector2[] ShapePoints = new Vector2[8]
	{
		new Vector2(0.15f, 0f),
		new Vector2(0.85f, 0f),
		new Vector2(1f, 0.15f),
		new Vector2(1f, 0.85f),
		new Vector2(0.85f, 1f),
		new Vector2(0.15f, 1f),
		new Vector2(0f, 0.85f),
		new Vector2(0f, 0.15f)
	};

	[SerializeField]
	public NormalCompression NormalCompression = NormalCompression.NormalQuality;
}
public class ArcRenderer : MonoBehaviour
{
	public int maxPoints = 100;

	public float timeStep = 0.01f;

	public float velocity = 10f;

	public float gravity = -9.8f;

	public float floor;

	public LineRenderer line;

	public float resultZ;

	public Vector3 PlotTrajectoryAtTime(Vector3 startPos, Vector3 startVelocity, float time)
	{
		return startPos + startVelocity * time + new Vector3(0f, gravity, 0f) * time * time * 0.5f;
	}

	public void PlotTrajectoryPoints(Vector3 startPos, Vector3 startVelocity)
	{
		if (startPos.y <= floor)
		{
			UnityEngine.Debug.LogError("Can't fire an arc from below the floor");
			return;
		}
		List<Vector3> list = new List<Vector3>();
		for (int i = 0; i < maxPoints; i++)
		{
			Vector3 item = PlotTrajectoryAtTime(startPos, startVelocity, timeStep * (float)i);
			if (item.y <= floor)
			{
				resultZ = item.z;
				break;
			}
			list.Add(item);
			if (i == maxPoints - 1)
			{
				resultZ = item.z;
			}
		}
		list.Add(new Vector3(list[list.Count - 1].x, floor, resultZ));
		list.Add(new Vector3(0f, floor, resultZ));
		line.positionCount = list.Count;
		line.SetPositions(list.ToArray());
	}

	private void Start()
	{
		floor = GameManager.instance.objectRefrences.beatPoint.position.y - 1f;
	}

	private void Update()
	{
		PlotTrajectoryPoints(base.transform.position, base.transform.forward.normalized * velocity);
	}
}
public class AutoRandomSpherePoint : MonoBehaviour
{
	public Transform _object;

	public float radius;

	public Vector2 minMaxTime = new Vector2(5f, 20f);

	public bool lerp;

	[Range(0f, 1f)]
	public float lerpSpeed = 0.1f;

	private Vector3 targetPoint;

	public Vector3 scalar = Vector3.one;

	private float timer;

	private void Start()
	{
		RandomPos();
	}

	private void Update()
	{
		if (timer > 0f)
		{
			timer -= Time.deltaTime;
			if (timer <= 0f)
			{
				timer = 0f;
				RandomPos();
			}
		}
	}

	private void FixedUpdate()
	{
		if (lerp)
		{
			_object.position = Vector3.Lerp(_object.position, targetPoint, lerpSpeed);
		}
	}

	private void RandomPos()
	{
		Vector3 vector = UnityEngine.Random.insideUnitSphere * radius;
		targetPoint = vector + base.transform.position;
		targetPoint = new Vector3(targetPoint.x * scalar.x, targetPoint.y * scalar.y, targetPoint.z * scalar.z);
		if (!lerp)
		{
			_object.position = targetPoint;
		}
		timer = UnityEngine.Random.Range(minMaxTime.x, minMaxTime.y);
	}

	private void OnDrawGizmosSelected()
	{
		if (!(_object == null))
		{
			Gizmos.color = Color.white;
			Gizmos.DrawWireSphere(base.transform.position, radius);
			if (UnityEngine.Application.isPlaying)
			{
				Gizmos.color = Color.blue;
				Gizmos.DrawSphere(targetPoint, 0.2f);
				Gizmos.DrawLine(_object.position, targetPoint);
			}
		}
	}
}
[HelpURL("https://docs.google.com/document/d/1z7A_xKNa2mXhvTRJqyu-ZQsAtbV32tEZQbO1OmPS_-s/edit?usp=sharing")]
[DisallowMultipleComponent]
[ExecuteInEditMode]
public class PolyverseSkies : MonoBehaviour
{
	public GameObject sunDirection;

	public GameObject moonDirection;

	private Vector3 GlobalSunDirection = Vector3.zero;

	private Vector3 GlobalMoonDirection = Vector3.zero;

	private void Update()
	{
		if (sunDirection != null)
		{
			GlobalSunDirection = -sunDirection.transform.forward;
			Shader.SetGlobalVector("GlobalSunDirection", GlobalSunDirection);
		}
		else
		{
			GlobalSunDirection = Vector3.zero;
			Shader.SetGlobalVector("GlobalSunDirection", GlobalSunDirection);
		}
		if (moonDirection != null)
		{
			GlobalMoonDirection = -moonDirection.transform.forward;
			Shader.SetGlobalVector("GlobalMoonDirection", GlobalMoonDirection);
		}
		else
		{
			GlobalSunDirection = Vector3.zero;
			Shader.SetGlobalVector("GlobalMoonDirection", GlobalMoonDirection);
		}
	}
}
public class BPMCalculator : MonoBehaviour
{
	public float cooldownSeconds = 2f;

	public bool roundResult = true;

	public Image cooldownBar;

	public TextMeshProUGUI statusText;

	public TextMeshProUGUI currentBpmText;

	public TextMeshProUGUI resultBpmText;

	public Button setBPMButton;

	private float currentBpm;

	private float resultBpm;

	private bool recording;

	private float lastTapTime;

	private int totaltaps;

	private float avgSecondsPerTap;

	private float totalSecondsPerTap;

	private float cooldown;

	public void Tap()
	{
		cooldown = cooldownSeconds;
		if (!recording)
		{
			lastTapTime = Time.time;
			recording = true;
			totaltaps = 0;
			resultBpmText.text = "";
			setBPMButton.interactable = false;
			return;
		}
		totalSecondsPerTap += Time.time - lastTapTime;
		lastTapTime = Time.time;
		totaltaps++;
		avgSecondsPerTap = totalSecondsPerTap / (float)totaltaps;
		currentBpm = 60f / avgSecondsPerTap;
		currentBpmText.text = currentBpm.ToString("F2");
		if (totaltaps >= 10)
		{
			setBPMButton.interactable = true;
			if (roundResult)
			{
				resultBpm = Mathf.Round(currentBpm);
				resultBpmText.text = resultBpm.ToString("F0") + "bpm";
			}
			else
			{
				resultBpm = (float)Math.Round(currentBpm, 2);
				resultBpmText.text = resultBpm.ToString("F2") + "bpm";
			}
			statusText.text = "";
		}
		else
		{
			statusText.text = "Do at least " + (10 - totaltaps) + " more taps...";
		}
	}

	public void SetBPM()
	{
		EditorManager.instance.objectRefrences.songEditor.SetBPM(resultBpm);
	}

	private void Start()
	{
		Reset();
	}

	private void Update()
	{
		if (cooldown > 0f)
		{
			cooldown -= Time.deltaTime;
			if (cooldown <= 0f)
			{
				Reset();
			}
			cooldownBar.fillAmount = Mathf.InverseLerp(0f, cooldownSeconds, cooldown);
		}
	}

	private void Reset()
	{
		statusText.text = "";
		recording = false;
		currentBpm = 0f;
		cooldown = 0f;
		totaltaps = 0;
		avgSecondsPerTap = 0f;
		currentBpmText.text = "";
		cooldownBar.fillAmount = 0f;
		totalSecondsPerTap = 0f;
	}

	public void ToggleRounding(bool on)
	{
		roundResult = on;
	}
}
public class Bob : MonoBehaviour
{
	public AnimationCurve curve;

	public Vector3 axis;

	public float speed;

	private Vector3 startPos;

	private float percent;

	private void Start()
	{
		startPos = base.transform.position;
	}

	private void Update()
	{
		percent = Mathf.InverseLerp(-1f, 1f, Mathf.Sin(Time.time * speed));
		base.transform.position = Vector3.Lerp(startPos, startPos + axis, curve.Evaluate(percent));
	}

	private void OnDrawGizmos()
	{
		Gizmos.color = Color.blue;
		Gizmos.DrawLine(base.transform.position, base.transform.position + axis);
	}
}
[RequireComponent(typeof(BoxCollider))]
public class ControllerScrollArea : MonoBehaviour
{
	public enum GrabbedState
	{
		Left,
		Right,
		None
	}

	public enum GrabControl
	{
		Grip,
		Trigger,
		Button
	}

	public Transform leftController;

	public Transform rightController;

	public bool x;

	public bool y;

	public bool z;

	public float multiplier;

	public Vector3 offset;

	public Transform scrollOrigin;

	private Vector3 originStart;

	private Collider col;

	private GameManager gm;

	private Vector3 startPos;

	public GrabbedState grabState = GrabbedState.None;

	public bool scrollActive = true;

	public bool linked;

	public Vector3 autoscroll = Vector3.zero;

	public GrabControl control;

	public List<ControllerScrollArea> linkedScrollers;

	public Transform lookAtWhileGrabbed;

	public bool nodeScrollArea = true;

	public bool disableWhenSongPlaying = true;

	public bool lookAtOnStart;

	public bool leftIn;

	public bool rightIn;

	public List<ControllerScrollArea> exclusiveScrollAreas;

	public bool countInScrollAreas = true;

	private void Start()
	{
		gm = GameManager.instance;
		if (lookAtWhileGrabbed != null)
		{
			lookAtWhileGrabbed = gm.objectRefrences.oculusCenter;
		}
		col = GetComponent<Collider>();
		leftController = gm.objectRefrences.leftController.transform;
		rightController = gm.objectRefrences.rightController.transform;
		switch (control)
		{
		}
		SetOrigin();
		if (lookAtOnStart)
		{
			LookAt();
		}
	}

	public void SetOrigin()
	{
		originStart = scrollOrigin.position;
	}

	private void OnDestroy()
	{
		if (!(leftController == null) && !(rightController == null))
		{
			switch (control)
			{
			}
		}
	}

	private void LeftControlDown()
	{
		if ((GameManager.instance.songPlaying && disableWhenSongPlaying) || !scrollActive || !col.bounds.Contains(leftController.position))
		{
			return;
		}
		offset = scrollOrigin.position - leftController.position;
		startPos = leftController.position;
		grabState = GrabbedState.Left;
		if (!nodeScrollArea)
		{
			return;
		}
		foreach (SceneEditorNode selectedNode in EditorManager.instance.objectRefrences.songEditor.selectedNodes)
		{
			if (!(selectedNode.transform == base.transform.parent))
			{
				selectedNode.transform.parent = base.transform;
			}
		}
	}

	private void RightControlDown()
	{
		if ((GameManager.instance.songPlaying && disableWhenSongPlaying) || !scrollActive || !col.bounds.Contains(rightController.position))
		{
			return;
		}
		offset = scrollOrigin.position - rightController.position;
		startPos = rightController.position;
		grabState = GrabbedState.Right;
		if (!nodeScrollArea)
		{
			return;
		}
		foreach (SceneEditorNode selectedNode in EditorManager.instance.objectRefrences.songEditor.selectedNodes)
		{
			if (!(selectedNode.transform == base.transform.parent))
			{
				selectedNode.transform.parent = base.transform;
			}
		}
	}

	private void LeftControlUp()
	{
	}

	private void RightControlUp()
	{
	}

	private void Update()
	{
		if (!scrollActive)
		{
			return;
		}
		switch (grabState)
		{
		case GrabbedState.Left:
		{
			Vector3 vector2 = (leftController.position - startPos) * multiplier + offset;
			scrollOrigin.position = new Vector3(x ? (leftController.position.x + vector2.x) : scrollOrigin.position.x, y ? (leftController.position.y + vector2.y) : scrollOrigin.position.y, z ? (leftController.position.z + vector2.z) : scrollOrigin.position.z);
			if (lookAtWhileGrabbed != null)
			{
				scrollOrigin.LookAt(lookAtWhileGrabbed);
			}
			break;
		}
		case GrabbedState.Right:
		{
			Vector3 vector = (rightController.position - startPos) * multiplier + offset;
			scrollOrigin.position = new Vector3(x ? (rightController.position.x + vector.x) : scrollOrigin.position.x, y ? (rightController.position.y + vector.y) : scrollOrigin.position.y, z ? (rightController.position.z + vector.z) : scrollOrigin.position.z);
			if (lookAtWhileGrabbed != null)
			{
				scrollOrigin.LookAt(lookAtWhileGrabbed);
			}
			break;
		}
		case GrabbedState.None:
			break;
		}
	}

	public void Reset()
	{
		grabState = GrabbedState.None;
		scrollOrigin.position = originStart;
	}

	public void ScrollToLocal(Vector3 local)
	{
		grabState = GrabbedState.None;
		scrollOrigin.localPosition = local;
	}

	public void LookAt()
	{
		if (lookAtWhileGrabbed != null)
		{
			scrollOrigin.LookAt(lookAtWhileGrabbed);
		}
	}

	public void OnTriggerEnter(Collider other)
	{
		if (other.transform == leftController)
		{
			leftIn = true;
			if (countInScrollAreas)
			{
				EditorManager.instance.HandsInScrollAreas++;
			}
		}
		if (other.transform == rightController)
		{
			rightIn = true;
			if (countInScrollAreas)
			{
				EditorManager.instance.HandsInScrollAreas++;
			}
		}
		if (!countInScrollAreas || exclusiveScrollAreas.Count <= 0 || (!leftIn && !rightIn))
		{
			return;
		}
		for (int i = 0; i < exclusiveScrollAreas.Count; i++)
		{
			ControllerScrollArea controllerScrollArea = exclusiveScrollAreas[i];
			if (controllerScrollArea.grabState == GrabbedState.None)
			{
				controllerScrollArea.scrollActive = false;
			}
		}
	}

	public void OnTriggerExit(Collider other)
	{
		if (other.transform == leftController)
		{
			leftIn = false;
			if (countInScrollAreas)
			{
				EditorManager.instance.HandsInScrollAreas--;
			}
		}
		if (other.transform == rightController)
		{
			rightIn = false;
			if (countInScrollAreas)
			{
				EditorManager.instance.HandsInScrollAreas--;
			}
		}
		if (!countInScrollAreas || (!(other.transform == rightController) && !(other.transform == leftController)) || exclusiveScrollAreas.Count <= 0 || leftIn || rightIn || GameManager.instance.songPlaying)
		{
			return;
		}
		for (int i = 0; i < exclusiveScrollAreas.Count; i++)
		{
			ControllerScrollArea controllerScrollArea = exclusiveScrollAreas[i];
			if (EditorManager.instance.HandsInScrollAreas == 0)
			{
				controllerScrollArea.scrollActive = true;
			}
		}
	}
}
public class CubeBetween2Points : MonoBehaviour
{
	public Transform pointA;

	public Transform pointB;

	private void Start()
	{
	}

	private void Update()
	{
		base.transform.position = pointA.position + (pointB.position - pointA.position) * 0.5f;
		base.transform.localScale = new Vector3(pointA.position.x - pointB.position.x, pointA.position.y - pointB.position.y, pointA.position.z - pointB.position.z);
	}
}
public class CustomSongPreview : MonoBehaviour
{
	public Lobby_CustomSongSelect songselect;

	public GameObject previewGameObject;

	public TextMeshProUGUI songName;

	public int songID;

	public void UpdateState(string fileName)
	{
		if (songID < 0 || songID >= songselect.numcolliders)
		{
			previewGameObject.SetActive(value: false);
		}
		else if (songID >= 0 && songselect.numcolliders > songID)
		{
			previewGameObject.SetActive(value: true);
			songName.text = fileName;
		}
	}
}
public class Debug_Leaderboard_TExt : MonoBehaviour
{
	public TextMeshProUGUI text;

	private void Update()
	{
		text.text = "Persistence Filename: " + Persistence.instance.currentSongFilename + "\nLeaderboard current: " + OculusManager.instance.currentBoard + "\nLeaderboard displayed: " + OculusManager.instance.displayedBoard + "\n\ntop count: " + OculusManager.instance.entries_top.Count + "\nnearby count: " + OculusManager.instance.entries_nearby.Count;
	}
}
public class DisableDelay : MonoBehaviour
{
	public float delay = 5f;

	private void OnEnable()
	{
		Invoke("Hide", delay);
	}

	private void Hide()
	{
		base.gameObject.SetActive(value: false);
	}
}
public class DisableOnStart : MonoBehaviour
{
	private void Awake()
	{
		base.gameObject.SetActive(value: false);
	}
}
public class DisablePerSetting : MonoBehaviour
{
	public enum GraphicsSetting
	{
		enableEnvironments,
		enableFog
	}

	public GraphicsSetting setting;

	private void Start()
	{
		switch (setting)
		{
		case GraphicsSetting.enableEnvironments:
			if (!Persistence.instance.svMan.settingsSave.enableEnvironments)
			{
				base.gameObject.SetActive(value: false);
			}
			break;
		case GraphicsSetting.enableFog:
			if (!Persistence.instance.svMan.settingsSave.enableFog)
			{
				RenderSettings.fog = false;
				base.gameObject.SetActive(value: false);
			}
			break;
		}
	}
}
public class Editor_UI_Panel : MonoBehaviour
{
	public string panelName;

	public Vector3 spawnOffset = new Vector3(0f, -0.3f, 0.8f);

	public bool open = true;

	public bool closeOnStart;

	private void Start()
	{
		if (closeOnStart)
		{
			Close();
		}
	}

	public void Close()
	{
		if (open)
		{
			base.transform.GetChild(0).gameObject.SetActive(value: false);
			base.transform.position = Vector3.zero;
			open = false;
			EditorManager.instance.DisplayMessage("Closed " + panelName);
		}
	}

	public void Open()
	{
		if (!open)
		{
			base.transform.GetChild(0).gameObject.SetActive(value: true);
			base.transform.position = GameManager.instance.objectRefrences.oculusCenter.position + GameManager.instance.objectRefrences.oculusCenter.forward * spawnOffset.z + GameManager.instance.objectRefrences.oculusCenter.right * spawnOffset.x + new Vector3(0f, spawnOffset.y, 0f);
			GetComponent<ControllerScrollArea>().LookAt();
			open = true;
		}
	}

	public void ReOpen()
	{
		open = false;
		Open();
	}
}
public class IntroController : MonoBehaviour
{
	public PlayableDirector director;

	private bool skippable;

	public GameObject loadingText;

	public GameObject skipText;

	public List<GameObject> introObjects;

	private void Start()
	{
		StartCoroutine(WaitToSkip());
	}

	private IEnumerator WaitToSkip()
	{
		yield return new WaitForSecondsRealtime(2f);
		skippable = true;
	}

	public void Play()
	{
		director.Play();
	}

	private void Skip()
	{
		skippable = false;
		UnityEngine.Debug.Log("SKIP");
		director.Stop();
		Finish();
	}

	private void Update()
	{
		if (skippable && (OVRInput.Get(OVRInput.Button.PrimaryIndexTrigger, OVRInput.Controller.All) || OVRInput.Get(OVRInput.Button.SecondaryIndexTrigger, OVRInput.Controller.All) || OVRInput.Get(OVRInput.Button.PrimaryHandTrigger, OVRInput.Controller.All) || OVRInput.Get(OVRInput.Button.SecondaryHandTrigger, OVRInput.Controller.All)))
		{
			Skip();
		}
	}

	public void Finish()
	{
		skipText.SetActive(value: false);
		loadingText.SetActive(value: true);
		foreach (GameObject introObject in introObjects)
		{
			introObject.SetActive(value: false);
		}
		LaunchLobby();
	}

	public void LaunchLobby()
	{
		StartCoroutine(LoadScene());
	}

	private IEnumerator LoadScene(string scene = "dance collider lobby")
	{
		Persistence.instance.ToggleOverlay(toggle: true);
		UnityEngine.Application.backgroundLoadingPriority = UnityEngine.ThreadPriority.Low;
		AsyncOperation asyncLoad = SceneManager.LoadSceneAsync(scene, LoadSceneMode.Single);
		while (!asyncLoad.isDone)
		{
			yield return null;
		}
		Persistence.instance.ToggleOverlay(toggle: false);
	}
}
public class Lobby_Title : LobbyMenu_AbstractClass
{
	private void Start()
	{
		OpenWindow();
	}

	public override void OpenWindow()
	{
		base.Transition(activeState: true);
		LobbyMainMenuManager.instance.previousWindow = null;
		LobbyMainMenuManager.instance.currentWindow = this;
		LobbyMainMenuManager.instance.TurnOffAllCharacters();
		LobbyMainMenuManager.instance.backButton.gameObject.SetActive(value: false);
		LobbyMainMenuManager.instance.currentMenuDescription.transform.parent.gameObject.SetActive(value: false);
		LobbyMainMenuManager.instance.settingsButton.gameObject.SetActive(value: false);
	}

	public override void CloseWindow()
	{
		base.Transition(activeState: false);
		LobbyMainMenuManager.instance.backButton.gameObject.SetActive(value: true);
		LobbyMainMenuManager.instance.currentMenuDescription.transform.parent.gameObject.SetActive(value: true);
		LobbyMainMenuManager.instance.settingsButton.gameObject.SetActive(value: true);
	}

	public void LoadMain()
	{
		CloseWindow();
		mainMenuManager.characterSelect.OpenWindow();
	}

	public void LoadTutorial()
	{
		Persistence.instance.currentSongFilename = "Tutorial_0";
		Persistence.instance.currentDifficulty = 0;
		UnityEngine.Application.backgroundLoadingPriority = UnityEngine.ThreadPriority.High;
		Persistence.instance.builtInSong = true;
		mainMenuManager.LoadScene("Tutorial");
	}
}
public class Lobby_UrielMenu : LobbyMenu_AbstractClass
{
	public GameObject staticCrowd;

	public GameObject animatedCrowd;

	public AudioSource atmos;

	public Image LoadingBar;

	private float loadingvalue;

	private float loadingIncrease = 0.1f;

	private float timer = 1f;

	public override void CloseWindow()
	{
		base.Transition(activeState: false);
	}

	public override void OpenWindow()
	{
		base.Transition(activeState: true);
		LobbyMainMenuManager.instance.TurnOffAllCharacters();
		LobbyMainMenuManager.instance.backButton.gameObject.SetActive(value: false);
		LobbyMainMenuManager.instance.currentMenuDescription.transform.parent.gameObject.SetActive(value: false);
		LobbyMainMenuManager.instance.discordButton.SetActive(value: false);
		RenderSettings.fogColor = Color.black;
		RenderSettings.fogDensity = 0.55f;
		LobbyMainMenuManager.instance.music.Stop();
		staticCrowd.SetActive(value: false);
		animatedCrowd.SetActive(value: false);
		atmos.Stop();
	}

	private void Update()
	{
		if (loadingvalue < 1.2f)
		{
			LoadingBar.fillAmount = loadingvalue;
			loadingvalue += loadingIncrease * Time.deltaTime;
			if (timer > 0f)
			{
				timer -= Time.deltaTime;
				if (timer <= 0f)
				{
					timer = UnityEngine.Random.Range(0.1f, 0.7f);
					loadingIncrease = Mathf.Max(0f, UnityEngine.Random.Range(-0.1f, 0.2f));
				}
			}
		}
		else
		{
			Uriel_Events();
		}
	}

	private void Uriel_Events()
	{
		switch (Persistence.instance.currentDifficulty)
		{
		case 0:
			Persistence.instance.currentSongFilename = "Arcade_Uriel_1_Easy";
			break;
		case 1:
			Persistence.instance.currentSongFilename = "Arcade_Uriel_1_Normal";
			break;
		case 2:
			Persistence.instance.currentSongFilename = "Arcade_Uriel_1_Hard";
			break;
		case 3:
			Persistence.instance.currentSongFilename = "Arcade_Uriel_1_X";
			break;
		}
		Persistence.instance.nofail = false;
		Persistence.instance.builtInSong = true;
		mainMenuManager.LoadScene("Game");
	}
}
[ExecuteInEditMode]
public class MobileBloom : MonoBehaviour
{
	[Range(1f, 5f)]
	public int NumberOfPasses = 3;

	[Range(0f, 5f)]
	public float BlurAmount = 2f;

	public Color BloomColor = Color.white;

	[Range(0f, 5f)]
	public float BloomAmount = 1f;

	[Range(0f, 1f)]
	public float BloomThreshold = 0.2f;

	private static readonly int blurAmountString = Shader.PropertyToID("_BlurAmount");

	private static readonly int bloomColorString = Shader.PropertyToID("_BloomColor");

	private static readonly int blAmountString = Shader.PropertyToID("_BloomAmount");

	private static readonly int thresholdString = Shader.PropertyToID("_Threshold");

	private static readonly int bloomTexString = Shader.PropertyToID("_BloomTex");

	public Material material;

	private void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		material.SetFloat(blurAmountString, BlurAmount);
		material.SetColor(bloomColorString, BloomColor);
		material.SetFloat(blAmountString, BloomAmount);
		material.SetFloat(thresholdString, BloomThreshold);
		RenderTexture renderTexture = null;
		if (NumberOfPasses == 1 || BlurAmount == 0f)
		{
			renderTexture = RenderTexture.GetTemporary(Screen.width / 2, Screen.height / 2, 0, source.format);
			Graphics.Blit(source, renderTexture, material, 0);
		}
		else if (NumberOfPasses == 2)
		{
			renderTexture = RenderTexture.GetTemporary(Screen.width / 2, Screen.height / 2, 0, source.format);
			RenderTexture temporary = RenderTexture.GetTemporary(Screen.width / 4, Screen.height / 4, 0, source.format);
			Graphics.Blit(source, temporary, material, 0);
			Graphics.Blit(temporary, renderTexture, material, 1);
			RenderTexture.ReleaseTemporary(temporary);
		}
		else if (NumberOfPasses == 3)
		{
			renderTexture = RenderTexture.GetTemporary(Screen.width / 4, Screen.height / 4, 0, source.format);
			RenderTexture temporary2 = RenderTexture.GetTemporary(Screen.width / 8, Screen.height / 8, 0, source.format);
			Graphics.Blit(source, renderTexture, material, 0);
			Graphics.Blit(renderTexture, temporary2, material, 1);
			Graphics.Blit(temporary2, renderTexture, material, 1);
			RenderTexture.ReleaseTemporary(temporary2);
		}
		else if (NumberOfPasses == 4)
		{
			renderTexture = RenderTexture.GetTemporary(Screen.width / 8, Screen.height / 8, 0, source.format);
			RenderTexture temporary3 = RenderTexture.GetTemporary(Screen.width / 16, Screen.height / 16, 0, source.format);
			RenderTexture temporary4 = RenderTexture.GetTemporary(Screen.width / 4, Screen.height / 4, 0, source.format);
			Graphics.Blit(source, temporary4, material, 0);
			Graphics.Blit(temporary4, renderTexture, material, 1);
			Graphics.Blit(renderTexture, temporary3, material, 1);
			Graphics.Blit(temporary3, renderTexture, material, 1);
			RenderTexture.ReleaseTemporary(temporary3);
			RenderTexture.ReleaseTemporary(temporary4);
		}
		else if (NumberOfPasses == 5)
		{
			renderTexture = RenderTexture.GetTemporary(Screen.width / 4, Screen.height / 4, 0, source.format);
			RenderTexture temporary5 = RenderTexture.GetTemporary(Screen.width / 8, Screen.height / 8, 0, source.format);
			RenderTexture temporary6 = RenderTexture.GetTemporary(Screen.width / 16, Screen.height / 16, 0, source.format);
			Graphics.Blit(source, renderTexture, material, 0);
			Graphics.Blit(renderTexture, temporary5, material, 1);
			Graphics.Blit(temporary5, temporary6, material, 1);
			Graphics.Blit(temporary6, temporary5, material, 1);
			Graphics.Blit(temporary5, renderTexture, material, 1);
			RenderTexture.ReleaseTemporary(temporary5);
			RenderTexture.ReleaseTemporary(temporary6);
		}
		material.SetTexture(bloomTexString, renderTexture);
		RenderTexture.ReleaseTemporary(renderTexture);
		Graphics.Blit(source, destination, material, 2);
	}
}
public class FastList<T>
{
	public delegate int CompareFunc(T left, T right);

	public T[] array;

	public int size;

	public int Count
	{
		get
		{
			return size;
		}
		set
		{
		}
	}

	public T this[int i]
	{
		get
		{
			return array[i];
		}
		set
		{
			array[i] = value;
		}
	}

	public FastList()
	{
	}

	public FastList(int size)
	{
		if (size > 0)
		{
			this.size = 0;
			array = new T[size];
		}
		else
		{
			this.size = 0;
		}
	}

	public void Add(T item)
	{
		if (array == null || size == array.Length)
		{
			Allocate();
		}
		array[size] = item;
		size++;
	}

	public void AddUnique(T item)
	{
		if (array == null || size == array.Length)
		{
			Allocate();
		}
		if (!Contains(item))
		{
			array[size] = item;
			size++;
		}
	}

	public void AddRange(IEnumerable<T> items)
	{
		foreach (T item in items)
		{
			Add(item);
		}
	}

	public void Insert(int index, T item)
	{
		if (array == null || size == array.Length)
		{
			Allocate();
		}
		if (index < size)
		{
			for (int num = size; num > index; num--)
			{
				array[num] = array[num - 1];
			}
			array[index] = item;
			size++;
		}
		else
		{
			Add(item);
		}
	}

	public bool Remove(T item)
	{
		if (array != null)
		{
			for (int i = 0; i < size; i++)
			{
				if (item.Equals(array[i]))
				{
					size--;
					for (int j = i; j < size; j++)
					{
						array[j] = array[j + 1];
					}
					array[size] = default(T);
					return true;
				}
			}
		}
		return false;
	}

	public void RemoveAt(int index)
	{
		if (array != null && size > 0 && index < size)
		{
			size--;
			for (int i = index; i < size; i++)
			{
				array[i] = array[i + 1];
			}
			array[size] = default(T);
		}
	}

	public bool RemoveFast(T item)
	{
		if (array != null)
		{
			for (int i = 0; i < size; i++)
			{
				if (item.Equals(array[i]))
				{
					if (i < size - 1)
					{
						T val = array[size - 1];
						array[size - 1] = default(T);
						array[i] = val;
					}
					else
					{
						array[i] = default(T);
					}
					size--;
					return true;
				}
			}
		}
		return false;
	}

	public void RemoveAtFast(int index)
	{
		if (array != null && index < size && index >= 0)
		{
			if (index == size - 1)
			{
				array[index] = default(T);
			}
			else
			{
				T val = array[size - 1];
				array[index] = val;
				array[size - 1] = default(T);
			}
			size--;
		}
	}

	public bool Contains(T item)
	{
		if (array == null || size <= 0)
		{
			return false;
		}
		for (int i = 0; i < size; i++)
		{
			if (array[i].Equals(item))
			{
				return true;
			}
		}
		return false;
	}

	public int IndexOf(T item)
	{
		if (size <= 0 || array == null)
		{
			return -1;
		}
		for (int i = 0; i < size; i++)
		{
			if (item.Equals(array[i]))
			{
				return i;
			}
		}
		return -1;
	}

	public T Pop()
	{
		if (array != null && size > 0)
		{
			T result = array[size - 1];
			array[size - 1] = default(T);
			size--;
			return result;
		}
		return default(T);
	}

	public T[] ToArray()
	{
		Trim();
		return array;
	}

	public void Sort(CompareFunc comparer)
	{
		int num = 0;
		int num2 = size - 1;
		bool flag = true;
		while (flag)
		{
			flag = false;
			for (int i = num; i < num2; i++)
			{
				if (comparer(array[i], array[i + 1]) > 0)
				{
					T val = array[i];
					array[i] = array[i + 1];
					array[i + 1] = val;
					flag = true;
				}
				else if (!flag)
				{
					num = ((i != 0) ? (i - 1) : 0);
				}
			}
		}
	}

	public void InsertionSort(CompareFunc comparer)
	{
		for (int i = 1; i < size; i++)
		{
			T val = array[i];
			int num = i;
			while (num > 0 && comparer(array[num - 1], val) > 0)
			{
				array[num] = array[num - 1];
				num--;
			}
			array[num] = val;
		}
	}

	public IEnumerator<T> GetEnumerator()
	{
		if (array != null)
		{
			for (int i = 0; i < size; i++)
			{
				yield return array[i];
			}
		}
	}

	public T Find(Predicate<T> match)
	{
		if (match != null && array != null)
		{
			for (int i = 0; i < size; i++)
			{
				if (match(array[i]))
				{
					return array[i];
				}
			}
		}
		return default(T);
	}

	private void Allocate()
	{
		T[] array = ((this.array != null) ? new T[Mathf.Max(this.array.Length << 1, 32)] : new T[32]);
		if (this.array != null && size > 0)
		{
			this.array.CopyTo(array, 0);
		}
		this.array = array;
	}

	private void Trim()
	{
		if (size > 0)
		{
			T[] array = new T[size];
			for (int i = 0; i < size; i++)
			{
				array[i] = this.array[i];
			}
			this.array = array;
		}
		else
		{
			this.array = null;
		}
	}

	public void Clear()
	{
		size = 0;
	}

	public void Release()
	{
		Clear();
		array = null;
	}
}
public class InspectorNoteAttribute : PropertyAttribute
{
	public readonly string header;

	public readonly string message;

	public InspectorNoteAttribute(string header, string message = "")
	{
		this.header = header;
		this.message = message;
	}
}
public class InspectorCommentAttribute : PropertyAttribute
{
	public readonly string message;

	public InspectorCommentAttribute(string message = "")
	{
		this.message = message;
	}
}
public class OvrAvatarTestDriver : OvrAvatarDriver
{
	private Vector3 headPos = new Vector3(0f, 1.6f, 0f);

	private Quaternion headRot = Quaternion.identity;

	private float voiceAmplitude;

	private ControllerPose GetMalibuControllerPose(OVRInput.Controller controller)
	{
		ovrAvatarButton ovrAvatarButton2 = (ovrAvatarButton)0;
		if (OVRInput.Get(OVRInput.Button.PrimaryIndexTrigger, controller))
		{
			ovrAvatarButton2 |= ovrAvatarButton.One;
		}
		ControllerPose result = default(ControllerPose);
		result.buttons = ovrAvatarButton2;
		result.touches = (OVRInput.Get(OVRInput.Touch.PrimaryTouchpad) ? ovrAvatarTouch.One : ((ovrAvatarTouch)0));
		result.joystickPosition = OVRInput.Get(OVRInput.Axis2D.PrimaryTouchpad, controller);
		result.indexTrigger = 0f;
		result.handTrigger = 0f;
		result.isActive = (OVRInput.GetActiveController() & controller) != 0;
		return result;
	}

	private ControllerPose GetControllerPose(OVRInput.Controller controller)
	{
		ovrAvatarButton ovrAvatarButton2 = (ovrAvatarButton)0;
		if (OVRInput.Get(OVRInput.Button.One, controller))
		{
			ovrAvatarButton2 |= ovrAvatarButton.One;
		}
		if (OVRInput.Get(OVRInput.Button.Two, controller))
		{
			ovrAvatarButton2 |= ovrAvatarButton.Two;
		}
		if (OVRInput.Get(OVRInput.Button.Start, controller))
		{
			ovrAvatarButton2 |= ovrAvatarButton.Three;
		}
		if (OVRInput.Get(OVRInput.Button.PrimaryThumbstick, controller))
		{
			ovrAvatarButton2 |= ovrAvatarButton.Joystick;
		}
		ovrAvatarTouch ovrAvatarTouch2 = (ovrAvatarTouch)0;
		if (OVRInput.Get(OVRInput.Touch.One, controller))
		{
			ovrAvatarTouch2 |= ovrAvatarTouch.One;
		}
		if (OVRInput.Get(OVRInput.Touch.Two, controller))
		{
			ovrAvatarTouch2 |= ovrAvatarTouch.Two;
		}
		if (OVRInput.Get(OVRInput.Touch.PrimaryThumbstick, controller))
		{
			ovrAvatarTouch2 |= ovrAvatarTouch.Joystick;
		}
		if (OVRInput.Get(OVRInput.Touch.PrimaryThumbRest, controller))
		{
			ovrAvatarTouch2 |= ovrAvatarTouch.ThumbRest;
		}
		if (OVRInput.Get(OVRInput.Touch.PrimaryIndexTrigger, controller))
		{
			ovrAvatarTouch2 |= ovrAvatarTouch.Index;
		}
		if (!OVRInput.Get(OVRInput.NearTouch.PrimaryIndexTrigger, controller))
		{
			ovrAvatarTouch2 |= ovrAvatarTouch.Pointing;
		}
		if (!OVRInput.Get(OVRInput.NearTouch.PrimaryThumbButtons, controller))
		{
			ovrAvatarTouch2 |= ovrAvatarTouch.ThumbUp;
		}
		ControllerPose result = default(ControllerPose);
		result.buttons = ovrAvatarButton2;
		result.touches = ovrAvatarTouch2;
		result.joystickPosition = OVRInput.Get(OVRInput.Axis2D.PrimaryThumbstick, controller);
		result.indexTrigger = OVRInput.Get(OVRInput.Axis1D.PrimaryIndexTrigger, controller);
		result.handTrigger = OVRInput.Get(OVRInput.Axis1D.PrimaryHandTrigger, controller);
		result.isActive = (OVRInput.GetActiveController() & controller) != 0;
		return result;
	}

	private void CalculateCurrentPose()
	{
		CurrentPose = new PoseFrame
		{
			voiceAmplitude = voiceAmplitude,
			headPosition = headPos,
			headRotation = headRot,
			handLeftPosition = OVRInput.GetLocalControllerPosition(OVRInput.Controller.LTouch),
			handLeftRotation = OVRInput.GetLocalControllerRotation(OVRInput.Controller.LTouch),
			handRightPosition = OVRInput.GetLocalControllerPosition(OVRInput.Controller.RTouch),
			handRightRotation = OVRInput.GetLocalControllerRotation(OVRInput.Controller.RTouch),
			controllerLeftPose = GetControllerPose(OVRInput.Controller.LTouch),
			controllerRightPose = GetControllerPose(OVRInput.Controller.RTouch)
		};
	}

	public override void UpdateTransforms(IntPtr sdkAvatar)
	{
		CalculateCurrentPose();
		UpdateTransformsFromPose(sdkAvatar);
	}
}
public class PoseEditHelper : MonoBehaviour
{
	public Transform poseRoot;

	private void OnDrawGizmos()
	{
		if (poseRoot != null)
		{
			DrawJoints(poseRoot);
		}
	}

	private void DrawJoints(Transform joint)
	{
		Gizmos.DrawWireSphere(joint.position, 0.005f);
		for (int i = 0; i < joint.childCount; i++)
		{
			Transform child = joint.GetChild(i);
			if (!child.name.EndsWith("_grip") && !child.name.EndsWith("hand_ignore"))
			{
				Gizmos.DrawLine(joint.position, child.position);
				DrawJoints(child);
			}
		}
	}
}
public class GazeTargetSpawner : MonoBehaviour
{
	public GameObject GazeTargetPrefab;

	public int NumberOfDummyTargets = 100;

	public int RadiusMultiplier = 3;

	[SerializeField]
	private bool isVisible;

	public bool IsVisible
	{
		get
		{
			return isVisible;
		}
		set
		{
			isVisible = value;
			GazeTarget[] componentsInChildren = base.gameObject.GetComponentsInChildren<GazeTarget>();
			for (int i = 0; i < componentsInChildren.Length; i++)
			{
				MeshRenderer component = componentsInChildren[i].GetComponent<MeshRenderer>();
				if (component != null)
				{
					component.enabled = isVisible;
				}
			}
		}
	}

	private void Start()
	{
		for (int i = 0; i < NumberOfDummyTargets; i++)
		{
			GameObject obj = UnityEngine.Object.Instantiate(GazeTargetPrefab, base.transform);
			obj.name = obj.name + "_" + i;
			obj.transform.localPosition = UnityEngine.Random.insideUnitSphere * RadiusMultiplier;
			obj.transform.rotation = Quaternion.identity;
			obj.GetComponent<MeshRenderer>().enabled = IsVisible;
		}
	}

	private void OnValidate()
	{
		IsVisible = isVisible;
	}
}
public class RemoteLoopbackManager : MonoBehaviour
{
	private class PacketLatencyPair
	{
		public byte[] PacketData;

		public float FakeLatency;
	}

	[Serializable]
	public class SimulatedLatencySettings
	{
		[Range(0f, 0.5f)]
		public float FakeLatencyMax = 0.25f;

		[Range(0f, 0.5f)]
		public float FakeLatencyMin = 0.002f;

		[Range(0f, 1f)]
		public float LatencyWeight = 0.25f;

		[Range(0f, 10f)]
		public int MaxSamples = 4;

		internal float AverageWindow;

		internal float LatencySum;

		internal LinkedList<float> LatencyValues = new LinkedList<float>();

		public float NextValue()
		{
			AverageWindow = LatencySum / (float)LatencyValues.Count;
			float num = UnityEngine.Random.Range(FakeLatencyMin, FakeLatencyMax);
			float num2 = AverageWindow * (1f - LatencyWeight) + LatencyWeight * num;
			if (LatencyValues.Count >= MaxSamples)
			{
				LatencySum -= LatencyValues.First.Value;
				LatencyValues.RemoveFirst();
			}
			LatencySum += num2;
			LatencyValues.AddLast(num2);
			return num2;
		}
	}

	public OvrAvatar LocalAvatar;

	public OvrAvatar LoopbackAvatar;

	public SimulatedLatencySettings LatencySettings = new SimulatedLatencySettings();

	private int PacketSequence;

	private LinkedList<PacketLatencyPair> packetQueue = new LinkedList<PacketLatencyPair>();

	private void Start()
	{
		LocalAvatar.RecordPackets = true;
		OvrAvatar localAvatar = LocalAvatar;
		localAvatar.PacketRecorded = (EventHandler<OvrAvatar.PacketEventArgs>)Delegate.Combine(localAvatar.PacketRecorded, new EventHandler<OvrAvatar.PacketEventArgs>(OnLocalAvatarPacketRecorded));
		float num = UnityEngine.Random.Range(LatencySettings.FakeLatencyMin, LatencySettings.FakeLatencyMax);
		LatencySettings.LatencyValues.AddFirst(num);
		LatencySettings.LatencySum += num;
	}

	private void OnLocalAvatarPacketRecorded(object sender, OvrAvatar.PacketEventArgs args)
	{
		using MemoryStream memoryStream = new MemoryStream();
		BinaryWriter binaryWriter = new BinaryWriter(memoryStream);
		if (LocalAvatar.UseSDKPackets)
		{
			uint num = Oculus.Avatar.CAPI.ovrAvatarPacket_GetSize(args.Packet.ovrNativePacket);
			byte[] buffer = new byte[num];
			Oculus.Avatar.CAPI.ovrAvatarPacket_Write(args.Packet.ovrNativePacket, num, buffer);
			binaryWriter.Write(PacketSequence++);
			binaryWriter.Write(num);
			binaryWriter.Write(buffer);
		}
		else
		{
			binaryWriter.Write(PacketSequence++);
			args.Packet.Write(memoryStream);
		}
		SendPacketData(memoryStream.ToArray());
	}

	private void Update()
	{
		if (packetQueue.Count <= 0)
		{
			return;
		}
		List<PacketLatencyPair> list = new List<PacketLatencyPair>();
		foreach (PacketLatencyPair item in packetQueue)
		{
			item.FakeLatency -= Time.deltaTime;
			if (item.FakeLatency < 0f)
			{
				ReceivePacketData(item.PacketData);
				list.Add(item);
			}
		}
		foreach (PacketLatencyPair item2 in list)
		{
			packetQueue.Remove(item2);
		}
	}

	private void SendPacketData(byte[] data)
	{
		PacketLatencyPair packetLatencyPair = new PacketLatencyPair();
		packetLatencyPair.PacketData = data;
		packetLatencyPair.FakeLatency = LatencySettings.NextValue();
		packetQueue.AddLast(packetLatencyPair);
	}

	private void ReceivePacketData(byte[] data)
	{
		using MemoryStream memoryStream = new MemoryStream(data);
		BinaryReader binaryReader = new BinaryReader(memoryStream);
		int sequence = binaryReader.ReadInt32();
		OvrAvatarPacket packet;
		if (LoopbackAvatar.UseSDKPackets)
		{
			int count = binaryReader.ReadInt32();
			byte[] buffer = binaryReader.ReadBytes(count);
			IntPtr ovrNativePacket = Oculus.Avatar.CAPI.ovrAvatarPacket_Read((uint)data.Length, buffer);
			packet = new OvrAvatarPacket
			{
				ovrNativePacket = ovrNativePacket
			};
		}
		else
		{
			packet = OvrAvatarPacket.Read(memoryStream);
		}
		LoopbackAvatar.GetComponent<OvrAvatarRemoteDriver>().QueuePacket(sequence, packet);
	}
}
public class P2PManager
{
	private enum MessageType : byte
	{
		Update = 1
	}

	public P2PManager()
	{
		Net.SetPeerConnectRequestCallback(PeerConnectRequestCallback);
		Net.SetConnectionStateChangedCallback(ConnectionStateChangedCallback);
	}

	public void ConnectTo(ulong userID)
	{
		if (SocialPlatformManager.MyID < userID)
		{
			Net.Connect(userID);
			SocialPlatformManager.LogOutput("P2P connect to " + userID);
		}
	}

	public void Disconnect(ulong userID)
	{
		if (userID != 0L)
		{
			Net.Close(userID);
			RemotePlayer remoteUser = SocialPlatformManager.GetRemoteUser(userID);
			if (remoteUser != null)
			{
				remoteUser.p2pConnectionState = PeerConnectionState.Unknown;
			}
		}
	}

	private void PeerConnectRequestCallback(Message<NetworkingPeer> msg)
	{
		SocialPlatformManager.LogOutput("P2P request from " + msg.Data.ID);
		if (SocialPlatformManager.GetRemoteUser(msg.Data.ID) != null)
		{
			SocialPlatformManager.LogOutput("P2P request accepted from " + msg.Data.ID);
			Net.Accept(msg.Data.ID);
		}
	}

	private void ConnectionStateChangedCallback(Message<NetworkingPeer> msg)
	{
		SocialPlatformManager.LogOutput("P2P state to " + msg.Data.ID + " changed to  " + msg.Data.State);
		RemotePlayer remoteUser = SocialPlatformManager.GetRemoteUser(msg.Data.ID);
		if (remoteUser != null)
		{
			remoteUser.p2pConnectionState = msg.Data.State;
			if (msg.Data.State == PeerConnectionState.Timeout && SocialPlatformManager.MyID < msg.Data.ID)
			{
				Net.Connect(msg.Data.ID);
				SocialPlatformManager.LogOutput("P2P re-connect to " + msg.Data.ID);
			}
		}
	}

	public void SendAvatarUpdate(ulong userID, Transform rootTransform, uint sequence, byte[] avatarPacket)
	{
		byte[] array = new byte[avatarPacket.Length + 41];
		int offset = 0;
		PackByte(1, array, ref offset);
		PackULong(SocialPlatformManager.MyID, array, ref offset);
		PackFloat(rootTransform.position.x, array, ref offset);
		PackFloat(0f, array, ref offset);
		PackFloat(rootTransform.position.z, array, ref offset);
		PackFloat(rootTransform.rotation.x, array, ref offset);
		PackFloat(rootTransform.rotation.y, array, ref offset);
		PackFloat(rootTransform.rotation.z, array, ref offset);
		PackFloat(rootTransform.rotation.w, array, ref offset);
		PackUInt32(sequence, array, ref offset);
		Buffer.BlockCopy(avatarPacket, 0, array, offset, avatarPacket.Length);
		Net.SendPacket(userID, array, SendPolicy.Unreliable);
	}

	public void GetRemotePackets()
	{
		Packet packet;
		while ((packet = Net.ReadPacket()) != null)
		{
			byte[] packet2 = new byte[packet.Size];
			packet.ReadBytes(packet2);
			int offset = 0;
			MessageType messageType = (MessageType)ReadByte(packet2, ref offset);
			ulong userID = ReadULong(packet2, ref offset);
			RemotePlayer remoteUser = SocialPlatformManager.GetRemoteUser(userID);
			if (remoteUser == null)
			{
				SocialPlatformManager.LogOutput("Unknown remote player: " + userID);
			}
			else if (messageType == MessageType.Update)
			{
				processAvatarPacket(remoteUser, ref packet2, ref offset);
			}
			else
			{
				SocialPlatformManager.LogOutput("Invalid packet type: " + packet.Size);
			}
		}
	}

	public void processAvatarPacket(RemotePlayer remote, ref byte[] packet, ref int offset)
	{
		if (remote != null)
		{
			remote.receivedRootPositionPrior = remote.receivedRootPosition;
			remote.receivedRootPosition.x = ReadFloat(packet, ref offset);
			remote.receivedRootPosition.y = ReadFloat(packet, ref offset);
			remote.receivedRootPosition.z = ReadFloat(packet, ref offset);
			remote.receivedRootRotationPrior = remote.receivedRootRotation;
			remote.receivedRootRotation.x = ReadFloat(packet, ref offset);
			remote.receivedRootRotation.y = ReadFloat(packet, ref offset);
			remote.receivedRootRotation.z = ReadFloat(packet, ref offset);
			remote.receivedRootRotation.w = ReadFloat(packet, ref offset);
			remote.RemoteAvatar.transform.position = remote.receivedRootPosition;
			remote.RemoteAvatar.transform.rotation = remote.receivedRootRotation;
			int sequence = (int)ReadUInt32(packet, ref offset);
			byte[] array = new byte[packet.Length - offset];
			Buffer.BlockCopy(packet, offset, array, 0, array.Length);
			IntPtr ovrNativePacket = Oculus.Avatar.CAPI.ovrAvatarPacket_Read((uint)array.Length, array);
			OvrAvatarPacket packet2 = new OvrAvatarPacket
			{
				ovrNativePacket = ovrNativePacket
			};
			remote.RemoteAvatar.GetComponent<OvrAvatarRemoteDriver>().QueuePacket(sequence, packet2);
		}
	}

	private void PackByte(byte b, byte[] buf, ref int offset)
	{
		buf[offset] = b;
		offset++;
	}

	private byte ReadByte(byte[] buf, ref int offset)
	{
		byte result = buf[offset];
		offset++;
		return result;
	}

	private void PackFloat(float f, byte[] buf, ref int offset)
	{
		Buffer.BlockCopy(BitConverter.GetBytes(f), 0, buf, offset, 4);
		offset += 4;
	}

	private float ReadFloat(byte[] buf, ref int offset)
	{
		float result = BitConverter.ToSingle(buf, offset);
		offset += 4;
		return result;
	}

	private void PackULong(ulong u, byte[] buf, ref int offset)
	{
		Buffer.BlockCopy(BitConverter.GetBytes(u), 0, buf, offset, 8);
		offset += 8;
	}

	private ulong ReadULong(byte[] buf, ref int offset)
	{
		ulong result = BitConverter.ToUInt64(buf, offset);
		offset += 8;
		return result;
	}

	private void PackUInt32(uint u, byte[] buf, ref int offset)
	{
		Buffer.BlockCopy(BitConverter.GetBytes(u), 0, buf, offset, 4);
		offset += 4;
	}

	private uint ReadUInt32(byte[] buf, ref int offset)
	{
		uint result = BitConverter.ToUInt32(buf, offset);
		offset += 4;
		return result;
	}
}
public class PlayerController : SocialPlatformManager
{
	public Camera spyCamera;

	private GameObject cameraRig;

	private bool showUI = true;

	public override void Awake()
	{
		base.Awake();
		cameraRig = localPlayerHead.gameObject;
	}

	public override void Start()
	{
		base.Start();
		spyCamera.enabled = false;
	}

	public override void Update()
	{
		base.Update();
		checkInput();
	}

	private void checkInput()
	{
		if (UnityEngine.Application.platform == RuntimePlatform.Android)
		{
			if (OVRInput.GetDown(OVRInput.Button.Back))
			{
				Rooms.LaunchInvitableUserFlow(roomManager.roomID);
			}
			if (OVRInput.GetDown(OVRInput.Button.PrimaryTouchpad))
			{
				ToggleCamera();
			}
			if (OVRInput.GetDown(OVRInput.Button.PrimaryIndexTrigger))
			{
				ToggleUI();
			}
		}
		else
		{
			if (OVRInput.GetDown(OVRInput.Button.Three))
			{
				Rooms.LaunchInvitableUserFlow(roomManager.roomID);
			}
			if (OVRInput.GetDown(OVRInput.Button.Four))
			{
				ToggleCamera();
			}
			if (OVRInput.GetDown(OVRInput.Button.PrimaryThumbstick))
			{
				ToggleUI();
			}
		}
	}

	private void ToggleCamera()
	{
		spyCamera.enabled = !spyCamera.enabled;
		localAvatar.ShowThirdPerson = !localAvatar.ShowThirdPerson;
		cameraRig.SetActive(!cameraRig.activeSelf);
	}

	private void ToggleUI()
	{
		showUI = !showUI;
		helpPanel.SetActive(showUI);
		localAvatar.ShowLeftController(showUI);
	}
}
public class RemotePlayer
{
	public ulong remoteUserID;

	public bool stillInRoom;

	public PeerConnectionState p2pConnectionState;

	public PeerConnectionState voipConnectionState;

	public OvrAvatar RemoteAvatar;

	public Vector3 receivedRootPosition;

	public Vector3 receivedRootPositionPrior;

	public Quaternion receivedRootRotation;

	public Quaternion receivedRootRotationPrior;

	public VoipAudioSourceHiLevel voipSource;
}
public class RoomManager
{
	public ulong roomID;

	private ulong invitedRoomID;

	private bool amIServer;

	private bool startupDone;

	public RoomManager()
	{
		amIServer = false;
		startupDone = false;
		Rooms.SetRoomInviteAcceptedNotificationCallback(AcceptingInviteCallback);
		Rooms.SetUpdateNotificationCallback(RoomUpdateCallback);
	}

	private void AcceptingInviteCallback(Message<string> msg)
	{
		if (msg.IsError)
		{
			SocialPlatformManager.TerminateWithError(msg);
			return;
		}
		SocialPlatformManager.LogOutput("Launched Invite to join Room: " + msg.Data);
		invitedRoomID = Convert.ToUInt64(msg.GetString());
		if (startupDone)
		{
			CheckForInvite();
		}
	}

	public bool CheckForInvite()
	{
		startupDone = true;
		if (invitedRoomID != 0L)
		{
			JoinExistingRoom(invitedRoomID);
			return true;
		}
		return false;
	}

	public void CreateRoom()
	{
		Rooms.CreateAndJoinPrivate(RoomJoinPolicy.FriendsOfOwner, 4u, subscribeToUpdates: true).OnComplete(CreateAndJoinPrivateRoomCallback);
	}

	private void CreateAndJoinPrivateRoomCallback(Message<Room> msg)
	{
		if (msg.IsError)
		{
			SocialPlatformManager.TerminateWithError(msg);
			return;
		}
		roomID = msg.Data.ID;
		if (msg.Data.OwnerOptional != null && msg.Data.OwnerOptional.ID == SocialPlatformManager.MyID)
		{
			amIServer = true;
		}
		else
		{
			amIServer = false;
		}
		SocialPlatformManager.TransitionToState(SocialPlatformManager.State.WAITING_IN_A_ROOM);
		SocialPlatformManager.SetFloorColorForState(amIServer);
	}

	private void OnLaunchInviteWorkflowComplete(Message msg)
	{
		if (msg.IsError)
		{
			SocialPlatformManager.TerminateWithError(msg);
		}
	}

	public void JoinExistingRoom(ulong roomID)
	{
		SocialPlatformManager.TransitionToState(SocialPlatformManager.State.JOINING_A_ROOM);
		Rooms.Join(roomID, subscribeToUpdates: true).OnComplete(JoinRoomCallback);
	}

	private void JoinRoomCallback(Message<Room> msg)
	{
		if (!msg.IsError)
		{
			string text = ((msg.Data.OwnerOptional != null) ? msg.Data.OwnerOptional.OculusID : "null");
			int num = ((msg.Data.UsersOptional != null) ? msg.Data.UsersOptional.Count : 0);
			SocialPlatformManager.LogOutput("Joined Room " + msg.Data.ID + " owner: " + text + " count: " + num);
			roomID = msg.Data.ID;
			ProcessRoomData(msg);
		}
	}

	private void RoomUpdateCallback(Message<Room> msg)
	{
		if (msg.IsError)
		{
			SocialPlatformManager.TerminateWithError(msg);
			return;
		}
		string text = ((msg.Data.OwnerOptional != null) ? msg.Data.OwnerOptional.OculusID : "null");
		int num = ((msg.Data.UsersOptional != null) ? msg.Data.UsersOptional.Count : 0);
		SocialPlatformManager.LogOutput("Room Update " + msg.Data.ID + " owner: " + text + " count: " + num);
		ProcessRoomData(msg);
	}

	public void LeaveCurrentRoom()
	{
		if (roomID != 0L)
		{
			Rooms.Leave(roomID);
			roomID = 0uL;
		}
		SocialPlatformManager.TransitionToState(SocialPlatformManager.State.LEAVING_A_ROOM);
	}

	private void ProcessRoomData(Message<Room> msg)
	{
		if (msg.Data.OwnerOptional != null && msg.Data.OwnerOptional.ID == SocialPlatformManager.MyID)
		{
			amIServer = true;
		}
		else
		{
			amIServer = false;
		}
		if (msg.Data.UsersOptional != null && msg.Data.UsersOptional.Count == 1)
		{
			SocialPlatformManager.TransitionToState(SocialPlatformManager.State.WAITING_IN_A_ROOM);
		}
		else
		{
			SocialPlatformManager.TransitionToState(SocialPlatformManager.State.CONNECTED_IN_A_ROOM);
		}
		SocialPlatformManager.MarkAllRemoteUsersAsNotInRoom();
		if (msg.Data.UsersOptional != null)
		{
			foreach (User item in msg.Data.UsersOptional)
			{
				if (item.ID != SocialPlatformManager.MyID)
				{
					if (!SocialPlatformManager.IsUserInRoom(item.ID))
					{
						SocialPlatformManager.AddRemoteUser(item.ID);
					}
					else
					{
						SocialPlatformManager.MarkRemoteUserInRoom(item.ID);
					}
				}
			}
		}
		SocialPlatformManager.ForgetRemoteUsersNotInRoom();
		SocialPlatformManager.SetFloorColorForState(amIServer);
	}
}
public class SocialPlatformManager : MonoBehaviour
{
	public enum State
	{
		INITIALIZING,
		CHECKING_LAUNCH_STATE,
		CREATING_A_ROOM,
		WAITING_IN_A_ROOM,
		JOINING_A_ROOM,
		CONNECTED_IN_A_ROOM,
		LEAVING_A_ROOM,
		SHUTDOWN
	}

	private static readonly Vector3 START_ROTATION_ONE = new Vector3(0f, 180f, 0f);

	private static readonly Vector3 START_POSITION_ONE = new Vector3(0f, 4f, 5f);

	private static readonly Vector3 START_ROTATION_TWO = new Vector3(0f, 0f, 0f);

	private static readonly Vector3 START_POSITION_TWO = new Vector3(0f, 4f, -5f);

	private static readonly Vector3 START_ROTATION_THREE = new Vector3(0f, 270f, 0f);

	private static readonly Vector3 START_POSITION_THREE = new Vector3(5f, 4f, 0f);

	private static readonly Vector3 START_ROTATION_FOUR = new Vector3(0f, 90f, 0f);

	private static readonly Vector3 START_POSITION_FOUR = new Vector3(-5f, 4f, 0f);

	private static readonly Color BLACK = new Color(0f, 0f, 0f);

	private static readonly Color WHITE = new Color(1f, 1f, 1f);

	private static readonly Color CYAN = new Color(0f, 1f, 1f);

	private static readonly Color BLUE = new Color(0f, 0f, 1f);

	private static readonly Color GREEN = new Color(0f, 1f, 0f);

	private float voiceCurrent;

	private uint packetSequence;

	public OvrAvatar localAvatarPrefab;

	public OvrAvatar remoteAvatarPrefab;

	public GameObject helpPanel;

	protected MeshRenderer helpMesh;

	public Material riftMaterial;

	public Material gearMaterial;

	protected OvrAvatar localAvatar;

	protected GameObject localTrackingSpace;

	protected GameObject localPlayerHead;

	protected Dictionary<ulong, RemotePlayer> remoteUsers = new Dictionary<ulong, RemotePlayer>();

	public GameObject roomSphere;

	protected MeshRenderer sphereMesh;

	public GameObject roomFloor;

	protected MeshRenderer floorMesh;

	protected State currentState;

	protected static SocialPlatformManager s_instance = null;

	protected RoomManager roomManager;

	protected P2PManager p2pManager;

	protected VoipManager voipManager;

	protected ulong myID;

	protected string myOculusID;

	public static readonly float VOIP_SCALE = 2f;

	public static State CurrentState => s_instance.currentState;

	public static ulong MyID
	{
		get
		{
			if (s_instance != null)
			{
				return s_instance.myID;
			}
			return 0uL;
		}
	}

	public static string MyOculusID
	{
		get
		{
			if (s_instance != null && s_instance.myOculusID != null)
			{
				return s_instance.myOculusID;
			}
			return string.Empty;
		}
	}

	public virtual void Update()
	{
		p2pManager.GetRemotePackets();
		foreach (KeyValuePair<ulong, RemotePlayer> remoteUser in remoteUsers)
		{
			if (remoteUser.Value.voipSource == null && remoteUser.Value.RemoteAvatar.MouthAnchor != null)
			{
				remoteUser.Value.voipSource = remoteUser.Value.RemoteAvatar.MouthAnchor.AddComponent<VoipAudioSourceHiLevel>();
				remoteUser.Value.voipSource.senderID = remoteUser.Value.remoteUserID;
			}
			if (remoteUser.Value.voipSource != null)
			{
				float voiceAmplitude = Mathf.Clamp(remoteUser.Value.voipSource.peakAmplitude * VOIP_SCALE, 0f, 1f);
				remoteUser.Value.RemoteAvatar.VoiceAmplitude = voiceAmplitude;
			}
		}
		if (localAvatar != null)
		{
			localAvatar.VoiceAmplitude = Mathf.Clamp(voiceCurrent * VOIP_SCALE, 0f, 1f);
		}
		Request.RunCallbacks();
	}

	public virtual void Awake()
	{
		LogOutputLine("Start Log.");
		helpMesh = helpPanel.GetComponent<MeshRenderer>();
		sphereMesh = roomSphere.GetComponent<MeshRenderer>();
		floorMesh = roomFloor.GetComponent<MeshRenderer>();
		localTrackingSpace = base.transform.Find("OVRCameraRig/TrackingSpace").gameObject;
		localPlayerHead = base.transform.Find("OVRCameraRig/TrackingSpace/CenterEyeAnchor").gameObject;
		if (s_instance != null)
		{
			UnityEngine.Object.Destroy(base.gameObject);
			return;
		}
		s_instance = this;
		UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
		TransitionToState(State.INITIALIZING);
		Core.AsyncInitialize().OnComplete(InitCallback);
		roomManager = new RoomManager();
		p2pManager = new P2PManager();
		voipManager = new VoipManager();
	}

	private void InitCallback(Message<PlatformInitialize> msg)
	{
		if (msg.IsError)
		{
			TerminateWithError(msg);
			return;
		}
		LaunchDetails launchDetails = ApplicationLifecycle.GetLaunchDetails();
		LogOutput("App launched with LaunchType " + launchDetails.LaunchType);
		Entitlements.IsUserEntitledToApplication().OnComplete(IsEntitledCallback);
	}

	public virtual void Start()
	{
	}

	private void IsEntitledCallback(Message msg)
	{
		if (msg.IsError)
		{
			TerminateWithError(msg);
		}
		else
		{
			Users.GetLoggedInUser().OnComplete(GetLoggedInUserCallback);
		}
	}

	private void GetLoggedInUserCallback(Message<User> msg)
	{
		if (msg.IsError)
		{
			TerminateWithError(msg);
			return;
		}
		myID = msg.Data.ID;
		myOculusID = msg.Data.OculusID;
		localAvatar = UnityEngine.Object.Instantiate(localAvatarPrefab);
		localAvatar.CanOwnMicrophone = false;
		localTrackingSpace = base.transform.Find("OVRCameraRig/TrackingSpace").gameObject;
		localAvatar.transform.SetParent(localTrackingSpace.transform, worldPositionStays: false);
		localAvatar.transform.localPosition = new Vector3(0f, 0f, 0f);
		localAvatar.transform.localRotation = Quaternion.identity;
		if (UnityEngine.Application.platform == RuntimePlatform.Android)
		{
			helpPanel.transform.SetParent(localAvatar.transform.Find("body"), worldPositionStays: false);
			helpPanel.transform.localPosition = new Vector3(0f, 1f, 1f);
			helpMesh.material = gearMaterial;
		}
		else
		{
			helpPanel.transform.SetParent(localAvatar.transform.Find("hand_left"), worldPositionStays: false);
			helpPanel.transform.localPosition = new Vector3(0f, 0.2f, 0.2f);
			helpMesh.material = riftMaterial;
		}
		localAvatar.oculusUserID = myID.ToString();
		localAvatar.RecordPackets = true;
		OvrAvatar ovrAvatar = localAvatar;
		ovrAvatar.PacketRecorded = (EventHandler<OvrAvatar.PacketEventArgs>)Delegate.Combine(ovrAvatar.PacketRecorded, new EventHandler<OvrAvatar.PacketEventArgs>(OnLocalAvatarPacketRecorded));
		localAvatar.EnableMouthVertexAnimation = true;
		Quaternion identity = Quaternion.identity;
		switch (UnityEngine.Random.Range(0, 4))
		{
		case 0:
			identity.eulerAngles = START_ROTATION_ONE;
			base.transform.localPosition = START_POSITION_ONE;
			base.transform.localRotation = identity;
			break;
		case 1:
			identity.eulerAngles = START_ROTATION_TWO;
			base.transform.localPosition = START_POSITION_TWO;
			base.transform.localRotation = identity;
			break;
		case 2:
			identity.eulerAngles = START_ROTATION_THREE;
			base.transform.localPosition = START_POSITION_THREE;
			base.transform.localRotation = identity;
			break;
		default:
			identity.eulerAngles = START_ROTATION_FOUR;
			base.transform.localPosition = START_POSITION_FOUR;
			base.transform.localRotation = identity;
			break;
		}
		TransitionToState(State.CHECKING_LAUNCH_STATE);
		if (!roomManager.CheckForInvite())
		{
			LogOutput("No invite on launch, looking for a friend to join.");
			Users.GetLoggedInUserFriendsAndRooms().OnComplete(GetLoggedInUserFriendsAndRoomsCallback);
		}
		Voip.SetMicrophoneFilterCallback(MicFilter);
	}

	private void GetLoggedInUserFriendsAndRoomsCallback(Message<UserAndRoomList> msg)
	{
		if (msg.IsError)
		{
			return;
		}
		foreach (UserAndRoom datum in msg.Data)
		{
			if (datum.User != null && datum.RoomOptional != null && !datum.RoomOptional.IsMembershipLocked && datum.RoomOptional.Joinability == RoomJoinability.CanJoin && datum.RoomOptional.JoinPolicy != 0)
			{
				LogOutput("Trying to join room " + datum.RoomOptional.ID + ", friend " + datum.User.OculusID);
				roomManager.JoinExistingRoom(datum.RoomOptional.ID);
				return;
			}
		}
		LogOutput("No friend to join. Creating my own room.");
		roomManager.CreateRoom();
		TransitionToState(State.CREATING_A_ROOM);
	}

	public void OnLocalAvatarPacketRecorded(object sender, OvrAvatar.PacketEventArgs args)
	{
		uint num = Oculus.Avatar.CAPI.ovrAvatarPacket_GetSize(args.Packet.ovrNativePacket);
		byte[] array = new byte[num];
		Oculus.Avatar.CAPI.ovrAvatarPacket_Write(args.Packet.ovrNativePacket, num, array);
		foreach (KeyValuePair<ulong, RemotePlayer> remoteUser in remoteUsers)
		{
			p2pManager.SendAvatarUpdate(remoteUser.Key, localTrackingSpace.transform, packetSequence, array);
		}
		packetSequence++;
	}

	public void OnApplicationQuit()
	{
		roomManager.LeaveCurrentRoom();
		foreach (KeyValuePair<ulong, RemotePlayer> remoteUser in remoteUsers)
		{
			p2pManager.Disconnect(remoteUser.Key);
			voipManager.Disconnect(remoteUser.Key);
		}
		LogOutputLine("End Log.");
	}

	public void AddUser(ulong userID, ref RemotePlayer remoteUser)
	{
		remoteUsers.Add(userID, remoteUser);
	}

	public void LogOutputLine(string line)
	{
		UnityEngine.Debug.Log(Time.time + ": " + line);
	}

	public static void TerminateWithError(Message msg)
	{
		s_instance.LogOutputLine("Error: " + msg.GetError().Message);
		UnityEngine.Application.Quit();
	}

	public static void TransitionToState(State newState)
	{
		if ((bool)s_instance)
		{
			s_instance.LogOutputLine("State " + s_instance.currentState.ToString() + " -> " + newState);
		}
		if ((bool)s_instance && s_instance.currentState != newState)
		{
			s_instance.currentState = newState;
			if (newState == State.SHUTDOWN)
			{
				s_instance.OnApplicationQuit();
			}
		}
		SetSphereColorForState();
	}

	private static void SetSphereColorForState()
	{
		switch (s_instance.currentState)
		{
		case State.INITIALIZING:
		case State.SHUTDOWN:
			s_instance.sphereMesh.material.color = BLACK;
			break;
		case State.WAITING_IN_A_ROOM:
			s_instance.sphereMesh.material.color = WHITE;
			break;
		case State.CONNECTED_IN_A_ROOM:
			s_instance.sphereMesh.material.color = CYAN;
			break;
		}
	}

	public static void SetFloorColorForState(bool host)
	{
		if (host)
		{
			s_instance.floorMesh.material.color = BLUE;
		}
		else
		{
			s_instance.floorMesh.material.color = GREEN;
		}
	}

	public static void MarkAllRemoteUsersAsNotInRoom()
	{
		foreach (KeyValuePair<ulong, RemotePlayer> remoteUser in s_instance.remoteUsers)
		{
			remoteUser.Value.stillInRoom = false;
		}
	}

	public static void MarkRemoteUserInRoom(ulong userID)
	{
		RemotePlayer value = new RemotePlayer();
		if (s_instance.remoteUsers.TryGetValue(userID, out value))
		{
			value.stillInRoom = true;
		}
	}

	public static void ForgetRemoteUsersNotInRoom()
	{
		List<ulong> list = new List<ulong>();
		foreach (KeyValuePair<ulong, RemotePlayer> remoteUser in s_instance.remoteUsers)
		{
			if (!remoteUser.Value.stillInRoom)
			{
				list.Add(remoteUser.Key);
			}
		}
		foreach (ulong item in list)
		{
			RemoveRemoteUser(item);
		}
	}

	public static void LogOutput(string line)
	{
		s_instance.LogOutputLine(Time.time + ": " + line);
	}

	public static bool IsUserInRoom(ulong userID)
	{
		return s_instance.remoteUsers.ContainsKey(userID);
	}

	public static void AddRemoteUser(ulong userID)
	{
		RemotePlayer remoteUser = new RemotePlayer();
		remoteUser.RemoteAvatar = UnityEngine.Object.Instantiate(s_instance.remoteAvatarPrefab);
		remoteUser.RemoteAvatar.oculusUserID = userID.ToString();
		remoteUser.RemoteAvatar.ShowThirdPerson = true;
		remoteUser.RemoteAvatar.EnableMouthVertexAnimation = true;
		remoteUser.p2pConnectionState = PeerConnectionState.Unknown;
		remoteUser.voipConnectionState = PeerConnectionState.Unknown;
		remoteUser.stillInRoom = true;
		remoteUser.remoteUserID = userID;
		s_instance.AddUser(userID, ref remoteUser);
		s_instance.p2pManager.ConnectTo(userID);
		s_instance.voipManager.ConnectTo(userID);
		s_instance.LogOutputLine("Adding User " + userID);
	}

	public static void RemoveRemoteUser(ulong userID)
	{
		RemotePlayer value = new RemotePlayer();
		if (s_instance.remoteUsers.TryGetValue(userID, out value))
		{
			UnityEngine.Object.Destroy(value.RemoteAvatar.MouthAnchor.GetComponent<VoipAudioSourceHiLevel>(), 0f);
			UnityEngine.Object.Destroy(value.RemoteAvatar.gameObject, 0f);
			s_instance.remoteUsers.Remove(userID);
			s_instance.LogOutputLine("Removing User " + userID);
		}
	}

	public void UpdateVoiceData(short[] pcmData, int numChannels)
	{
		if (localAvatar != null)
		{
			localAvatar.UpdateVoiceData(pcmData, numChannels);
		}
		float num = 0f;
		float[] array = new float[pcmData.Length];
		for (int i = 0; i < pcmData.Length; i++)
		{
			float num2 = (array[i] = (float)pcmData[i] / 32767f);
			if (num2 > num)
			{
				num = num2;
			}
		}
		voiceCurrent = num;
	}

	[MonoPInvokeCallback(typeof(Oculus.Platform.CAPI.FilterCallback))]
	public static void MicFilter(short[] pcmData, UIntPtr pcmDataLength, int frequency, int numChannels)
	{
		s_instance.UpdateVoiceData(pcmData, numChannels);
	}

	public static RemotePlayer GetRemoteUser(ulong userID)
	{
		RemotePlayer value = new RemotePlayer();
		if (s_instance.remoteUsers.TryGetValue(userID, out value))
		{
			return value;
		}
		return null;
	}
}
public class VoipManager
{
	public VoipManager()
	{
		Voip.SetVoipConnectRequestCallback(VoipConnectRequestCallback);
		Voip.SetVoipStateChangeCallback(VoipStateChangedCallback);
	}

	public void ConnectTo(ulong userID)
	{
		if (SocialPlatformManager.MyID < userID)
		{
			Voip.Start(userID);
			SocialPlatformManager.LogOutput("Voip connect to " + userID);
		}
	}

	public void Disconnect(ulong userID)
	{
		if (userID != 0L)
		{
			Voip.Stop(userID);
			RemotePlayer remoteUser = SocialPlatformManager.GetRemoteUser(userID);
			if (remoteUser != null)
			{
				remoteUser.voipConnectionState = PeerConnectionState.Unknown;
			}
		}
	}

	private void VoipConnectRequestCallback(Message<NetworkingPeer> msg)
	{
		SocialPlatformManager.LogOutput("Voip request from " + msg.Data.ID);
		if (SocialPlatformManager.GetRemoteUser(msg.Data.ID) != null)
		{
			SocialPlatformManager.LogOutput("Voip request accepted from " + msg.Data.ID);
			Voip.Accept(msg.Data.ID);
		}
	}

	private void VoipStateChangedCallback(Message<NetworkingPeer> msg)
	{
		SocialPlatformManager.LogOutput("Voip state to " + msg.Data.ID + " changed to  " + msg.Data.State);
		RemotePlayer remoteUser = SocialPlatformManager.GetRemoteUser(msg.Data.ID);
		if (remoteUser != null)
		{
			remoteUser.voipConnectionState = msg.Data.State;
			if (msg.Data.State == PeerConnectionState.Timeout && SocialPlatformManager.MyID < msg.Data.ID)
			{
				Voip.Start(msg.Data.ID);
				SocialPlatformManager.LogOutput("Voip re-connect to " + msg.Data.ID);
			}
		}
	}
}
public class GazeTarget : MonoBehaviour
{
	public ovrAvatarGazeTargetType Type;

	private static ovrAvatarGazeTargets RuntimeTargetList;

	static GazeTarget()
	{
		RuntimeTargetList.targets = new ovrAvatarGazeTarget[128];
		RuntimeTargetList.targetCount = 1u;
	}

	private void Start()
	{
		UpdateGazeTarget();
		base.transform.hasChanged = false;
	}

	private void Update()
	{
		if (base.transform.hasChanged)
		{
			base.transform.hasChanged = false;
			UpdateGazeTarget();
		}
	}

	private void OnDestroy()
	{
		Oculus.Avatar.CAPI.ovrAvatar_RemoveGazeTargets(1u, new uint[1] { (uint)base.transform.GetInstanceID() });
	}

	private void UpdateGazeTarget()
	{
		ovrAvatarGazeTarget ovrAvatarGazeTarget2 = CreateOvrGazeTarget((uint)base.transform.GetInstanceID(), base.transform.position, Type);
		RuntimeTargetList.targets[0] = ovrAvatarGazeTarget2;
		Oculus.Avatar.CAPI.ovrAvatar_UpdateGazeTargets(RuntimeTargetList);
	}

	private ovrAvatarGazeTarget CreateOvrGazeTarget(uint targetId, Vector3 targetPosition, ovrAvatarGazeTargetType targetType)
	{
		ovrAvatarGazeTarget result = default(ovrAvatarGazeTarget);
		result.id = targetId;
		result.worldPosition = new Vector3(targetPosition.x, targetPosition.y, 0f - targetPosition.z);
		result.type = targetType;
		return result;
	}
}
[Serializable]
public class AvatarLayer
{
	public int layerIndex;
}
[Serializable]
public class PacketRecordSettings
{
	internal bool RecordingFrames;

	public float UpdateRate = 1f / 30f;

	internal float AccumulatedTime;
}
public class OvrAvatar : MonoBehaviour
{
	public class PacketEventArgs : EventArgs
	{
		public readonly OvrAvatarPacket Packet;

		public PacketEventArgs(OvrAvatarPacket packet)
		{
			Packet = packet;
		}
	}

	public enum HandType
	{
		Right,
		Left,
		Max
	}

	public enum HandJoint
	{
		HandBase,
		IndexBase,
		IndexTip,
		ThumbBase,
		ThumbTip,
		Max
	}

	[Header("Avatar")]
	public IntPtr sdkAvatar = IntPtr.Zero;

	public string oculusUserID;

	public OvrAvatarDriver Driver;

	[Header("Capabilities")]
	public bool EnableBody = true;

	public bool EnableHands = true;

	public bool EnableBase = true;

	public bool EnableExpressive;

	[Header("Network")]
	public bool RecordPackets;

	public bool UseSDKPackets = true;

	public PacketRecordSettings PacketSettings = new PacketRecordSettings();

	[Header("Visibility")]
	public bool StartWithControllers;

	public AvatarLayer FirstPersonLayer;

	public AvatarLayer ThirdPersonLayer;

	public bool ShowFirstPerson = true;

	public bool ShowThirdPerson;

	internal ovrAvatarCapabilities Capabilities = ovrAvatarCapabilities.Body;

	[Header("Performance")]
	[Tooltip("LOD mesh complexity and texture resolution. Highest LOD recommended on PC and simple mobile apps. Medium LOD recommended on mobile devices or for background characters on PC. Lowest LOD recommended for background characters on mobile.")]
	[SerializeField]
	internal ovrAvatarAssetLevelOfDetail LevelOfDetail = ovrAvatarAssetLevelOfDetail.Medium;

	[Tooltip("Enable to use combined meshes to reduce draw calls. Currently only available on mobile devices. Will be forced to false on PC.")]
	private bool CombineMeshes = true;

	[Tooltip("Enable to use transparent queue, disable to use geometry queue. Requires restart to take effect.")]
	public bool UseTransparentRenderQueue = true;

	[Header("Shaders")]
	public Shader Monochrome_SurfaceShader;

	public Shader Monochrome_SurfaceShader_SelfOccluding;

	public Shader Monochrome_SurfaceShader_PBS;

	public Shader Skinshaded_SurfaceShader_SingleComponent;

	public Shader Skinshaded_VertFrag_SingleComponent;

	public Shader Skinshaded_VertFrag_CombinedMesh;

	public Shader Skinshaded_Expressive_SurfaceShader_SingleComponent;

	public Shader Skinshaded_Expressive_VertFrag_SingleComponent;

	public Shader Skinshaded_Expressive_VertFrag_CombinedMesh;

	public Shader Loader_VertFrag_CombinedMesh;

	public Shader EyeLens;

	public Shader ControllerShader;

	[Header("Other")]
	public bool CanOwnMicrophone = true;

	[Tooltip("Enable laughter detection and animation as part of OVRLipSync.")]
	public bool EnableLaughter = true;

	public GameObject MouthAnchor;

	public Transform LeftHandCustomPose;

	public Transform RightHandCustomPose;

	private HashSet<ulong> assetLoadingIds = new HashSet<ulong>();

	private bool assetsFinishedLoading;

	private OvrAvatarMaterialManager materialManager;

	private bool waitingForCombinedMesh;

	private static bool doneExpressiveGlobalInit;

	private Vector4 clothingAlphaOffset = new Vector4(0f, 0f, 0f, 1f);

	private ulong clothingAlphaTexture;

	private OVRLipSyncMicInput micInput;

	private OVRLipSyncContext lipsyncContext;

	private OVRLipSync.Frame currentFrame = new OVRLipSync.Frame();

	private float[] visemes = new float[16];

	private AudioSource audioSource;

	private ONSPAudioSource spatializedSource;

	private List<float[]> voiceUpdates = new List<float[]>();

	private static ovrAvatarVisemes RuntimeVisemes;

	private Transform cachedLeftHandCustomPose;

	private Transform[] cachedCustomLeftHandJoints;

	private ovrAvatarTransform[] cachedLeftHandTransforms;

	private Transform cachedRightHandCustomPose;

	private Transform[] cachedCustomRightHandJoints;

	private ovrAvatarTransform[] cachedRightHandTransforms;

	private bool showLeftController;

	private bool showRightController;

	private const bool USE_MOBILE_TEXTURE_FORMAT = true;

	private static readonly Vector3 MOUTH_HEAD_OFFSET;

	private const string MOUTH_HELPER_NAME = "MouthAnchor";

	private const int VISEME_COUNT = 16;

	private const float ACTION_UNIT_ONSET_SPEED = 30f;

	private const float ACTION_UNIT_FALLOFF_SPEED = 20f;

	private const float VISEME_LEVEL_MULTIPLIER = 1.5f;

	internal ulong oculusUserIDInternal;

	internal OvrAvatarBase Base;

	internal OvrAvatarTouchController ControllerLeft;

	internal OvrAvatarTouchController ControllerRight;

	internal OvrAvatarBody Body;

	internal OvrAvatarHand HandLeft;

	internal OvrAvatarHand HandRight;

	internal ovrAvatarLookAndFeelVersion LookAndFeelVersion = ovrAvatarLookAndFeelVersion.Two;

	internal ovrAvatarLookAndFeelVersion FallbackLookAndFeelVersion = ovrAvatarLookAndFeelVersion.Two;

	private OvrAvatarPacket CurrentUnityPacket;

	public EventHandler<PacketEventArgs> PacketRecorded;

	private static string[,] HandJoints;

	private static Vector3 MOUTH_POSITION_OFFSET;

	private static string VOICE_PROPERTY;

	private static string MOUTH_POSITION_PROPERTY;

	private static string MOUTH_DIRECTION_PROPERTY;

	private static string MOUTH_SCALE_PROPERTY;

	private static float MOUTH_SCALE_GLOBAL;

	private static float MOUTH_MAX_GLOBAL;

	private static string NECK_JONT;

	public float VoiceAmplitude;

	public bool EnableMouthVertexAnimation;

	private static ovrAvatarLights ovrLights;

	static OvrAvatar()
	{
		doneExpressiveGlobalInit = false;
		MOUTH_HEAD_OFFSET = new Vector3(0f, -0.085f, 0.09f);
		HandJoints = new string[2, 5]
		{
			{ "hands:r_hand_world", "hands:r_hand_world/hands:b_r_hand/hands:b_r_index1", "hands:r_hand_world/hands:b_r_hand/hands:b_r_index1/hands:b_r_index2/hands:b_r_index3/hands:b_r_index_ignore", "hands:r_hand_world/hands:b_r_hand/hands:b_r_thumb1/hands:b_r_thumb2", "hands:r_hand_world/hands:b_r_hand/hands:b_r_thumb1/hands:b_r_thumb2/hands:b_r_thumb3/hands:b_r_thumb_ignore" },
			{ "hands:l_hand_world", "hands:l_hand_world/hands:b_l_hand/hands:b_l_index1", "hands:l_hand_world/hands:b_l_hand/hands:b_l_index1/hands:b_l_index2/hands:b_l_index3/hands:b_l_index_ignore", "hands:l_hand_world/hands:b_l_hand/hands:b_l_thumb1/hands:b_l_thumb2", "hands:l_hand_world/hands:b_l_hand/hands:b_l_thumb1/hands:b_l_thumb2/hands:b_l_thumb3/hands:b_l_thumb_ignore" }
		};
		MOUTH_POSITION_OFFSET = new Vector3(0f, -0.018f, 0.1051f);
		VOICE_PROPERTY = "_Voice";
		MOUTH_POSITION_PROPERTY = "_MouthPosition";
		MOUTH_DIRECTION_PROPERTY = "_MouthDirection";
		MOUTH_SCALE_PROPERTY = "_MouthEffectScale";
		MOUTH_SCALE_GLOBAL = 0.007f;
		MOUTH_MAX_GLOBAL = 0.007f;
		NECK_JONT = "root_JNT/body_JNT/chest_JNT/neckBase_JNT/neck_JNT";
		ovrLights = default(ovrAvatarLights);
		RuntimeVisemes.visemeParams = new float[32];
		RuntimeVisemes.visemeParamCount = 16u;
	}

	private void OnDestroy()
	{
		if (sdkAvatar != IntPtr.Zero)
		{
			Oculus.Avatar.CAPI.ovrAvatar_Destroy(sdkAvatar);
		}
	}

	public void AssetLoadedCallback(OvrAvatarAsset asset)
	{
		assetLoadingIds.Remove(asset.assetID);
	}

	public void CombinedMeshLoadedCallback(IntPtr assetPtr)
	{
		if (waitingForCombinedMesh)
		{
			ulong[] array = Oculus.Avatar.CAPI.ovrAvatarAsset_GetCombinedMeshIDs(assetPtr);
			foreach (ulong item in array)
			{
				assetLoadingIds.Remove(item);
			}
			Oculus.Avatar.CAPI.ovrAvatar_GetCombinedMeshAlphaData(sdkAvatar, ref clothingAlphaTexture, ref clothingAlphaOffset);
			waitingForCombinedMesh = false;
		}
	}

	private OvrAvatarSkinnedMeshRenderComponent AddSkinnedMeshRenderComponent(GameObject gameObject, ovrAvatarRenderPart_SkinnedMeshRender skinnedMeshRender)
	{
		OvrAvatarSkinnedMeshRenderComponent ovrAvatarSkinnedMeshRenderComponent = gameObject.AddComponent<OvrAvatarSkinnedMeshRenderComponent>();
		ovrAvatarSkinnedMeshRenderComponent.Initialize(skinnedMeshRender, Monochrome_SurfaceShader, Monochrome_SurfaceShader_SelfOccluding, ThirdPersonLayer.layerIndex, FirstPersonLayer.layerIndex);
		return ovrAvatarSkinnedMeshRenderComponent;
	}

	private OvrAvatarSkinnedMeshRenderPBSComponent AddSkinnedMeshRenderPBSComponent(GameObject gameObject, ovrAvatarRenderPart_SkinnedMeshRenderPBS skinnedMeshRenderPBS)
	{
		OvrAvatarSkinnedMeshRenderPBSComponent ovrAvatarSkinnedMeshRenderPBSComponent = gameObject.AddComponent<OvrAvatarSkinnedMeshRenderPBSComponent>();
		ovrAvatarSkinnedMeshRenderPBSComponent.Initialize(skinnedMeshRenderPBS, Monochrome_SurfaceShader_PBS, ThirdPersonLayer.layerIndex, FirstPersonLayer.layerIndex);
		return ovrAvatarSkinnedMeshRenderPBSComponent;
	}

	private OvrAvatarSkinnedMeshPBSV2RenderComponent AddSkinnedMeshRenderPBSV2Component(IntPtr renderPart, GameObject go, ovrAvatarRenderPart_SkinnedMeshRenderPBS_V2 skinnedMeshRenderPBSV2, bool isBodyPartZero, bool isControllerModel)
	{
		OvrAvatarSkinnedMeshPBSV2RenderComponent ovrAvatarSkinnedMeshPBSV2RenderComponent = go.AddComponent<OvrAvatarSkinnedMeshPBSV2RenderComponent>();
		ovrAvatarSkinnedMeshPBSV2RenderComponent.Initialize(renderPart, skinnedMeshRenderPBSV2, materialManager, ThirdPersonLayer.layerIndex, FirstPersonLayer.layerIndex, isBodyPartZero && CombineMeshes, LevelOfDetail, isBodyPartZero && EnableExpressive, this, isControllerModel);
		return ovrAvatarSkinnedMeshPBSV2RenderComponent;
	}

	public static IntPtr GetRenderPart(ovrAvatarComponent component, uint renderPartIndex)
	{
		return Marshal.ReadIntPtr(component.renderParts, Marshal.SizeOf(typeof(IntPtr)) * (int)renderPartIndex);
	}

	private static string GetRenderPartName(ovrAvatarComponent component, uint renderPartIndex)
	{
		string text = component.name;
		int num = (int)renderPartIndex;
		return text + "_renderPart_" + num;
	}

	internal static void ConvertTransform(float[] transform, ref ovrAvatarTransform target)
	{
		target.position.x = transform[0];
		target.position.y = transform[1];
		target.position.z = transform[2];
		target.orientation.x = transform[3];
		target.orientation.y = transform[4];
		target.orientation.z = transform[5];
		target.orientation.w = transform[6];
		target.scale.x = transform[7];
		target.scale.y = transform[8];
		target.scale.z = transform[9];
	}

	internal static void ConvertTransform(ovrAvatarTransform transform, Transform target)
	{
		Vector3 position = transform.position;
		position.z = 0f - position.z;
		Quaternion orientation = transform.orientation;
		orientation.x = 0f - orientation.x;
		orientation.y = 0f - orientation.y;
		target.localPosition = position;
		target.localRotation = orientation;
		target.localScale = transform.scale;
	}

	public static ovrAvatarTransform CreateOvrAvatarTransform(Vector3 position, Quaternion orientation)
	{
		ovrAvatarTransform result = default(ovrAvatarTransform);
		result.position = new Vector3(position.x, position.y, 0f - position.z);
		result.orientation = new Quaternion(0f - orientation.x, 0f - orientation.y, orientation.z, orientation.w);
		result.scale = Vector3.one;
		return result;
	}

	private static ovrAvatarGazeTarget CreateOvrGazeTarget(uint targetId, Vector3 targetPosition, ovrAvatarGazeTargetType targetType)
	{
		ovrAvatarGazeTarget result = default(ovrAvatarGazeTarget);
		result.id = targetId;
		result.worldPosition = new Vector3(targetPosition.x, targetPosition.y, 0f - targetPosition.z);
		result.type = targetType;
		return result;
	}

	private void BuildRenderComponents()
	{
		ovrAvatarBaseComponent component = default(ovrAvatarBaseComponent);
		ovrAvatarHandComponent component2 = default(ovrAvatarHandComponent);
		ovrAvatarHandComponent component3 = default(ovrAvatarHandComponent);
		ovrAvatarControllerComponent component4 = default(ovrAvatarControllerComponent);
		ovrAvatarControllerComponent component5 = default(ovrAvatarControllerComponent);
		ovrAvatarBodyComponent component6 = default(ovrAvatarBodyComponent);
		ovrAvatarComponent component7 = default(ovrAvatarComponent);
		if (Oculus.Avatar.CAPI.ovrAvatarPose_GetLeftHandComponent(sdkAvatar, ref component2))
		{
			Oculus.Avatar.CAPI.ovrAvatarComponent_Get(component2.renderComponent, includeName: true, ref component7);
			AddAvatarComponent(ref HandLeft, component7);
			HandLeft.isLeftHand = true;
		}
		if (Oculus.Avatar.CAPI.ovrAvatarPose_GetRightHandComponent(sdkAvatar, ref component3))
		{
			Oculus.Avatar.CAPI.ovrAvatarComponent_Get(component3.renderComponent, includeName: true, ref component7);
			AddAvatarComponent(ref HandRight, component7);
			HandRight.isLeftHand = false;
		}
		if (Oculus.Avatar.CAPI.ovrAvatarPose_GetBodyComponent(sdkAvatar, ref component6))
		{
			Oculus.Avatar.CAPI.ovrAvatarComponent_Get(component6.renderComponent, includeName: true, ref component7);
			AddAvatarComponent(ref Body, component7);
		}
		if (Oculus.Avatar.CAPI.ovrAvatarPose_GetLeftControllerComponent(sdkAvatar, ref component4))
		{
			Oculus.Avatar.CAPI.ovrAvatarComponent_Get(component4.renderComponent, includeName: true, ref component7);
			AddAvatarComponent(ref ControllerLeft, component7);
			ControllerLeft.isLeftHand = true;
		}
		if (Oculus.Avatar.CAPI.ovrAvatarPose_GetRightControllerComponent(sdkAvatar, ref component5))
		{
			Oculus.Avatar.CAPI.ovrAvatarComponent_Get(component5.renderComponent, includeName: true, ref component7);
			AddAvatarComponent(ref ControllerRight, component7);
			ControllerRight.isLeftHand = false;
		}
		if (Oculus.Avatar.CAPI.ovrAvatarPose_GetBaseComponent(sdkAvatar, ref component))
		{
			Oculus.Avatar.CAPI.ovrAvatarComponent_Get(component.renderComponent, includeName: true, ref component7);
			AddAvatarComponent(ref Base, component7);
		}
	}

	private void AddAvatarComponent<T>(ref T root, ovrAvatarComponent nativeComponent) where T : OvrAvatarComponent
	{
		GameObject gameObject = new GameObject();
		gameObject.name = nativeComponent.name;
		gameObject.transform.SetParent(base.transform);
		root = gameObject.AddComponent<T>();
		root.SetOvrAvatarOwner(this);
		AddRenderParts(root, nativeComponent, gameObject.transform);
	}

	private void UpdateCustomPoses()
	{
		if (UpdatePoseRoot(LeftHandCustomPose, ref cachedLeftHandCustomPose, ref cachedCustomLeftHandJoints, ref cachedLeftHandTransforms) && cachedLeftHandCustomPose == null && sdkAvatar != IntPtr.Zero)
		{
			Oculus.Avatar.CAPI.ovrAvatar_SetLeftHandGesture(sdkAvatar, ovrAvatarHandGesture.Default);
		}
		if (UpdatePoseRoot(RightHandCustomPose, ref cachedRightHandCustomPose, ref cachedCustomRightHandJoints, ref cachedRightHandTransforms) && cachedRightHandCustomPose == null && sdkAvatar != IntPtr.Zero)
		{
			Oculus.Avatar.CAPI.ovrAvatar_SetRightHandGesture(sdkAvatar, ovrAvatarHandGesture.Default);
		}
		if (sdkAvatar != IntPtr.Zero)
		{
			if (cachedLeftHandCustomPose != null && UpdateTransforms(cachedCustomLeftHandJoints, cachedLeftHandTransforms))
			{
				Oculus.Avatar.CAPI.ovrAvatar_SetLeftHandCustomGesture(sdkAvatar, (uint)cachedLeftHandTransforms.Length, cachedLeftHandTransforms);
			}
			if (cachedRightHandCustomPose != null && UpdateTransforms(cachedCustomRightHandJoints, cachedRightHandTransforms))
			{
				Oculus.Avatar.CAPI.ovrAvatar_SetRightHandCustomGesture(sdkAvatar, (uint)cachedRightHandTransforms.Length, cachedRightHandTransforms);
			}
		}
	}

	private static bool UpdatePoseRoot(Transform poseRoot, ref Transform cachedPoseRoot, ref Transform[] cachedPoseJoints, ref ovrAvatarTransform[] transforms)
	{
		if (poseRoot == cachedPoseRoot)
		{
			return false;
		}
		if (!poseRoot)
		{
			cachedPoseRoot = null;
			cachedPoseJoints = null;
			transforms = null;
		}
		else
		{
			List<Transform> list = new List<Transform>();
			OrderJoints(poseRoot, list);
			cachedPoseRoot = poseRoot;
			cachedPoseJoints = list.ToArray();
			transforms = new ovrAvatarTransform[list.Count];
		}
		return true;
	}

	private static bool UpdateTransforms(Transform[] joints, ovrAvatarTransform[] transforms)
	{
		bool result = false;
		for (int i = 0; i < joints.Length; i++)
		{
			Transform transform = joints[i];
			ovrAvatarTransform ovrAvatarTransform2 = CreateOvrAvatarTransform(transform.localPosition, transform.localRotation);
			if (ovrAvatarTransform2.position != transforms[i].position || ovrAvatarTransform2.orientation != transforms[i].orientation)
			{
				transforms[i] = ovrAvatarTransform2;
				result = true;
			}
		}
		return result;
	}

	private static void OrderJoints(Transform transform, List<Transform> joints)
	{
		joints.Add(transform);
		for (int i = 0; i < transform.childCount; i++)
		{
			OrderJoints(transform.GetChild(i), joints);
		}
	}

	private void AvatarSpecificationCallback(IntPtr avatarSpecification)
	{
		sdkAvatar = Oculus.Avatar.CAPI.ovrAvatar_Create(avatarSpecification, Capabilities);
		ShowLeftController(showLeftController);
		ShowRightController(showRightController);
		if (Driver != null)
		{
			Driver.UpdateTransformsFromPose(sdkAvatar);
		}
		uint num = Oculus.Avatar.CAPI.ovrAvatar_GetReferencedAssetCount(sdkAvatar);
		for (uint num2 = 0u; num2 < num; num2++)
		{
			ulong num3 = Oculus.Avatar.CAPI.ovrAvatar_GetReferencedAsset(sdkAvatar, num2);
			if (OvrAvatarSDKManager.Instance.GetAsset(num3) == null)
			{
				OvrAvatarSDKManager.Instance.BeginLoadingAsset(num3, LevelOfDetail, AssetLoadedCallback);
				assetLoadingIds.Add(num3);
			}
		}
		if (CombineMeshes)
		{
			OvrAvatarSDKManager.Instance.RegisterCombinedMeshCallback(sdkAvatar, CombinedMeshLoadedCallback);
		}
	}

	private void Start()
	{
		if (!(OvrAvatarSDKManager.Instance == null))
		{
			materialManager = base.gameObject.AddComponent<OvrAvatarMaterialManager>();
			try
			{
				oculusUserIDInternal = ulong.Parse(oculusUserID);
			}
			catch (Exception)
			{
				oculusUserIDInternal = 0uL;
			}
			if (oculusUserIDInternal == 0L)
			{
				CombineMeshes = false;
			}
			Capabilities = (ovrAvatarCapabilities)0;
			if (EnableBody)
			{
				Capabilities |= ovrAvatarCapabilities.Body;
			}
			if (EnableHands)
			{
				Capabilities |= ovrAvatarCapabilities.Hands;
			}
			if (EnableBase && EnableBody)
			{
				Capabilities |= ovrAvatarCapabilities.Base;
			}
			if (EnableExpressive)
			{
				Capabilities |= ovrAvatarCapabilities.Expressive;
			}
			if (OVRPlugin.positionSupported)
			{
				Capabilities |= ovrAvatarCapabilities.BodyTilt;
			}
			ShowLeftController(StartWithControllers);
			ShowRightController(StartWithControllers);
			OvrAvatarSDKManager.AvatarSpecRequestParams avatarSpecRequest = new OvrAvatarSDKManager.AvatarSpecRequestParams(oculusUserIDInternal, AvatarSpecificationCallback, CombineMeshes, LevelOfDetail, forceMobileTextureFormat: true, LookAndFeelVersion, FallbackLookAndFeelVersion, EnableExpressive);
			OvrAvatarSDKManager.Instance.RequestAvatarSpecification(avatarSpecRequest);
			OvrAvatarSDKManager.Instance.AddLoadingAvatar(GetInstanceID());
			waitingForCombinedMesh = CombineMeshes;
			if (Driver != null)
			{
				Driver.Mode = ((!UseSDKPackets) ? OvrAvatarDriver.PacketMode.Unity : OvrAvatarDriver.PacketMode.SDK);
			}
		}
	}

	private void Update()
	{
		if (!OvrAvatarSDKManager.Instance || sdkAvatar == IntPtr.Zero || materialManager == null)
		{
			return;
		}
		if (Driver != null)
		{
			Driver.UpdateTransforms(sdkAvatar);
			foreach (float[] voiceUpdate in voiceUpdates)
			{
				Oculus.Avatar.CAPI.ovrAvatarPose_UpdateVoiceVisualization(sdkAvatar, voiceUpdate);
			}
			voiceUpdates.Clear();
			Oculus.Avatar.CAPI.ovrAvatarPose_Finalize(sdkAvatar, Time.deltaTime);
		}
		if (RecordPackets)
		{
			RecordFrame();
		}
		if (assetLoadingIds.Count != 0)
		{
			return;
		}
		if (!assetsFinishedLoading)
		{
			try
			{
				BuildRenderComponents();
			}
			catch (Exception ex)
			{
				assetsFinishedLoading = true;
				throw ex;
			}
			InitPostLoad();
			assetsFinishedLoading = true;
			OvrAvatarSDKManager.Instance.RemoveLoadingAvatar(GetInstanceID());
		}
		UpdateVoiceBehavior();
		UpdateCustomPoses();
		if (EnableExpressive)
		{
			UpdateExpressive();
		}
	}

	public static ovrAvatarHandInputState CreateInputState(ovrAvatarTransform transform, OvrAvatarDriver.ControllerPose pose)
	{
		ovrAvatarHandInputState result = default(ovrAvatarHandInputState);
		result.transform = transform;
		result.buttonMask = pose.buttons;
		result.touchMask = pose.touches;
		result.joystickX = pose.joystickPosition.x;
		result.joystickY = pose.joystickPosition.y;
		result.indexTrigger = pose.indexTrigger;
		result.handTrigger = pose.handTrigger;
		result.isActive = pose.isActive;
		return result;
	}

	public void ShowControllers(bool show)
	{
		ShowLeftController(show);
		ShowRightController(show);
	}

	public void ShowLeftController(bool show)
	{
		if (sdkAvatar != IntPtr.Zero)
		{
			Oculus.Avatar.CAPI.ovrAvatar_SetLeftControllerVisibility(sdkAvatar, show);
		}
		showLeftController = show;
	}

	public void ShowRightController(bool show)
	{
		if (sdkAvatar != IntPtr.Zero)
		{
			Oculus.Avatar.CAPI.ovrAvatar_SetRightControllerVisibility(sdkAvatar, show);
		}
		showRightController = show;
	}

	public void UpdateVoiceVisualization(float[] voiceSamples)
	{
		voiceUpdates.Add(voiceSamples);
	}

	private void RecordFrame()
	{
		if (UseSDKPackets)
		{
			RecordSDKFrame();
		}
		else
		{
			RecordUnityFrame();
		}
	}

	private void RecordUnityFrame()
	{
		float num = Time.deltaTime;
		OvrAvatarDriver.PoseFrame currentPose = Driver.GetCurrentPose();
		if (CurrentUnityPacket == null)
		{
			CurrentUnityPacket = new OvrAvatarPacket(currentPose);
			num = 0f;
		}
		float num2 = 0f;
		while (num2 < num)
		{
			float num3 = num - num2;
			float num4 = PacketSettings.UpdateRate - CurrentUnityPacket.Duration;
			if (num3 < num4)
			{
				CurrentUnityPacket.AddFrame(currentPose, num3);
				num2 += num3;
				continue;
			}
			OvrAvatarDriver.PoseFrame finalFrame = CurrentUnityPacket.FinalFrame;
			OvrAvatarDriver.PoseFrame b = currentPose;
			float t = num4 / num3;
			OvrAvatarDriver.PoseFrame poseFrame = OvrAvatarDriver.PoseFrame.Interpolate(finalFrame, b, t);
			CurrentUnityPacket.AddFrame(poseFrame, num4);
			num2 += num4;
			if (PacketRecorded != null)
			{
				PacketRecorded(this, new PacketEventArgs(CurrentUnityPacket));
			}
			CurrentUnityPacket = new OvrAvatarPacket(poseFrame);
		}
	}

	private void RecordSDKFrame()
	{
		if (sdkAvatar == IntPtr.Zero)
		{
			return;
		}
		if (!PacketSettings.RecordingFrames)
		{
			Oculus.Avatar.CAPI.ovrAvatarPacket_BeginRecording(sdkAvatar);
			PacketSettings.AccumulatedTime = 0f;
			PacketSettings.RecordingFrames = true;
		}
		PacketSettings.AccumulatedTime += Time.deltaTime;
		if (PacketSettings.AccumulatedTime >= PacketSettings.UpdateRate)
		{
			PacketSettings.AccumulatedTime = 0f;
			IntPtr intPtr = Oculus.Avatar.CAPI.ovrAvatarPacket_EndRecording(sdkAvatar);
			Oculus.Avatar.CAPI.ovrAvatarPacket_BeginRecording(sdkAvatar);
			if (PacketRecorded != null)
			{
				PacketRecorded(this, new PacketEventArgs(new OvrAvatarPacket
				{
					ovrNativePacket = intPtr
				}));
			}
			Oculus.Avatar.CAPI.ovrAvatarPacket_Free(intPtr);
		}
	}

	private void AddRenderParts(OvrAvatarComponent ovrComponent, ovrAvatarComponent component, Transform parent)
	{
		bool flag = ovrComponent.name == "body";
		bool flag2 = ovrComponent.name == "controller_left";
		bool flag3 = ovrComponent.name == "controller_right";
		for (uint num = 0u; num < component.renderPartCount; num++)
		{
			GameObject gameObject = new GameObject();
			gameObject.name = GetRenderPartName(component, num);
			gameObject.transform.SetParent(parent);
			IntPtr renderPart = GetRenderPart(component, num);
			ovrAvatarRenderPartType ovrAvatarRenderPartType2 = Oculus.Avatar.CAPI.ovrAvatarRenderPart_GetType(renderPart);
			OvrAvatarRenderComponent ovrAvatarRenderComponent = null;
			switch (ovrAvatarRenderPartType2)
			{
			case ovrAvatarRenderPartType.SkinnedMeshRender:
				ovrAvatarRenderComponent = AddSkinnedMeshRenderComponent(gameObject, Oculus.Avatar.CAPI.ovrAvatarRenderPart_GetSkinnedMeshRender(renderPart));
				break;
			case ovrAvatarRenderPartType.SkinnedMeshRenderPBS:
				ovrAvatarRenderComponent = AddSkinnedMeshRenderPBSComponent(gameObject, Oculus.Avatar.CAPI.ovrAvatarRenderPart_GetSkinnedMeshRenderPBS(renderPart));
				break;
			case ovrAvatarRenderPartType.SkinnedMeshRenderPBS_V2:
				ovrAvatarRenderComponent = AddSkinnedMeshRenderPBSV2Component(renderPart, gameObject, Oculus.Avatar.CAPI.ovrAvatarRenderPart_GetSkinnedMeshRenderPBSV2(renderPart), flag && num == 0, flag2 || flag3);
				break;
			}
			if (ovrAvatarRenderComponent != null)
			{
				ovrComponent.RenderParts.Add(ovrAvatarRenderComponent);
			}
		}
	}

	public void RefreshBodyParts()
	{
		if (!(Body != null))
		{
			return;
		}
		foreach (OvrAvatarRenderComponent renderPart in Body.RenderParts)
		{
			UnityEngine.Object.Destroy(renderPart.gameObject);
		}
		Body.RenderParts.Clear();
		ovrAvatarComponent? nativeAvatarComponent = Body.GetNativeAvatarComponent();
		if (nativeAvatarComponent.HasValue)
		{
			AddRenderParts(Body, nativeAvatarComponent.Value, Body.gameObject.transform);
		}
	}

	public ovrAvatarBodyComponent? GetBodyComponent()
	{
		if (Body != null)
		{
			Oculus.Avatar.CAPI.ovrAvatarPose_GetBodyComponent(sdkAvatar, ref Body.component);
			return Body.component;
		}
		return null;
	}

	public Transform GetHandTransform(HandType hand, HandJoint joint)
	{
		if (hand >= HandType.Max || joint >= HandJoint.Max)
		{
			return null;
		}
		OvrAvatarHand ovrAvatarHand = ((hand == HandType.Left) ? HandLeft : HandRight);
		if (ovrAvatarHand != null)
		{
			OvrAvatarComponent component = ovrAvatarHand.GetComponent<OvrAvatarComponent>();
			if (component != null && component.RenderParts.Count > 0)
			{
				return component.RenderParts[0].transform.Find(HandJoints[(int)hand, (int)joint]);
			}
		}
		return null;
	}

	public void GetPointingDirection(HandType hand, ref Vector3 forward, ref Vector3 up)
	{
		Transform handTransform = GetHandTransform(hand, HandJoint.HandBase);
		if (handTransform != null)
		{
			forward = handTransform.forward;
			up = handTransform.up;
		}
	}

	private void UpdateVoiceBehavior()
	{
		if (EnableMouthVertexAnimation && Body != null)
		{
			OvrAvatarComponent component = Body.GetComponent<OvrAvatarComponent>();
			VoiceAmplitude = Mathf.Clamp(VoiceAmplitude, 0f, 1f);
			if (component.RenderParts.Count > 0)
			{
				Material sharedMaterial = component.RenderParts[0].mesh.sharedMaterial;
				Transform transform = component.RenderParts[0].mesh.transform.Find(NECK_JONT);
				Vector3 vector = transform.TransformPoint(Vector3.up) - transform.position;
				sharedMaterial.SetFloat(MOUTH_SCALE_PROPERTY, vector.magnitude);
				sharedMaterial.SetFloat(VOICE_PROPERTY, Mathf.Min(vector.magnitude * MOUTH_MAX_GLOBAL, vector.magnitude * VoiceAmplitude * MOUTH_SCALE_GLOBAL));
				sharedMaterial.SetVector(MOUTH_POSITION_PROPERTY, transform.TransformPoint(MOUTH_POSITION_OFFSET));
				sharedMaterial.SetVector(MOUTH_DIRECTION_PROPERTY, transform.up);
			}
		}
	}

	private bool IsValidMic()
	{
		return true;
	}

	private void InitPostLoad()
	{
		ExpressiveGlobalInit();
		ConfigureHelpers();
		if (GetComponent<OvrAvatarLocalDriver>() != null)
		{
			lipsyncContext.audioLoopback = false;
			if (CanOwnMicrophone && IsValidMic())
			{
				micInput = MouthAnchor.gameObject.AddComponent<OVRLipSyncMicInput>();
				micInput.enableMicSelectionGUI = false;
				micInput.MicFrequency = 44100f;
				micInput.micControl = OVRLipSyncMicInput.micActivation.ConstantSpeak;
			}
			Oculus.Avatar.CAPI.ovrAvatar_SetActionUnitOnsetSpeed(sdkAvatar, 30f);
			Oculus.Avatar.CAPI.ovrAvatar_SetActionUnitFalloffSpeed(sdkAvatar, 20f);
			Oculus.Avatar.CAPI.ovrAvatar_SetVisemeMultiplier(sdkAvatar, 1.5f);
		}
	}

	private static void ExpressiveGlobalInit()
	{
		if (!doneExpressiveGlobalInit)
		{
			doneExpressiveGlobalInit = true;
			ovrLights.lights = new ovrAvatarLight[16];
			InitializeLights();
		}
	}

	private static void InitializeLights()
	{
		ovrLights.ambientIntensity = RenderSettings.ambientLight.grayscale * 0.5f;
		Light[] array = UnityEngine.Object.FindObjectsOfType(typeof(Light)) as Light[];
		int num = 0;
		for (num = 0; num < array.Length && num < ovrLights.lights.Length; num++)
		{
			Light light = array[num];
			if ((bool)light && light.enabled)
			{
				uint instanceID = (uint)light.transform.GetInstanceID();
				switch (light.type)
				{
				case LightType.Directional:
					CreateLightDirectional(instanceID, light.transform.forward, light.intensity, ref ovrLights.lights[num]);
					break;
				case LightType.Point:
					CreateLightPoint(instanceID, light.transform.position, light.range, light.intensity, ref ovrLights.lights[num]);
					break;
				case LightType.Spot:
					CreateLightSpot(instanceID, light.transform.position, light.transform.forward, light.spotAngle, light.range, light.intensity, ref ovrLights.lights[num]);
					break;
				}
			}
		}
		ovrLights.lightCount = (uint)num;
		Oculus.Avatar.CAPI.ovrAvatar_UpdateLights(ovrLights);
	}

	private static ovrAvatarLight CreateLightDirectional(uint id, Vector3 direction, float intensity, ref ovrAvatarLight light)
	{
		light.id = id;
		light.type = ovrAvatarLightType.Direction;
		light.worldDirection = new Vector3(direction.x, direction.y, 0f - direction.z);
		light.intensity = intensity;
		return light;
	}

	private static ovrAvatarLight CreateLightPoint(uint id, Vector3 position, float range, float intensity, ref ovrAvatarLight light)
	{
		light.id = id;
		light.type = ovrAvatarLightType.Point;
		light.worldPosition = new Vector3(position.x, position.y, 0f - position.z);
		light.range = range;
		light.intensity = intensity;
		return light;
	}

	private static ovrAvatarLight CreateLightSpot(uint id, Vector3 position, Vector3 direction, float spotAngleDeg, float range, float intensity, ref ovrAvatarLight light)
	{
		light.id = id;
		light.type = ovrAvatarLightType.Spot;
		light.worldPosition = new Vector3(position.x, position.y, 0f - position.z);
		light.worldDirection = new Vector3(direction.x, direction.y, 0f - direction.z);
		light.spotAngleDeg = spotAngleDeg;
		light.range = range;
		light.intensity = intensity;
		return light;
	}

	private void UpdateExpressive()
	{
		ovrAvatarTransform ovrAvatarTransform2 = CreateOvrAvatarTransform(base.transform.position, base.transform.rotation);
		Oculus.Avatar.CAPI.ovrAvatar_UpdateWorldTransform(sdkAvatar, ovrAvatarTransform2);
		UpdateFacewave();
	}

	private void ConfigureHelpers()
	{
		Transform transform = base.transform.Find("body/body_renderPart_0/root_JNT/body_JNT/chest_JNT/neckBase_JNT/neck_JNT/head_JNT");
		if (transform == null)
		{
			transform = base.transform;
		}
		if (MouthAnchor == null)
		{
			MouthAnchor = CreateHelperObject(transform, MOUTH_HEAD_OFFSET, "MouthAnchor");
		}
		if (GetComponent<OvrAvatarLocalDriver>() != null)
		{
			if (audioSource == null)
			{
				audioSource = MouthAnchor.gameObject.AddComponent<AudioSource>();
			}
			spatializedSource = MouthAnchor.GetComponent<ONSPAudioSource>();
			if (spatializedSource == null)
			{
				spatializedSource = MouthAnchor.gameObject.AddComponent<ONSPAudioSource>();
			}
			spatializedSource.UseInvSqr = true;
			spatializedSource.EnableRfl = false;
			spatializedSource.EnableSpatialization = true;
			spatializedSource.Far = 100f;
			spatializedSource.Near = 0.1f;
			lipsyncContext = MouthAnchor.GetComponent<OVRLipSyncContext>();
			if (lipsyncContext == null)
			{
				lipsyncContext = MouthAnchor.gameObject.AddComponent<OVRLipSyncContext>();
			}
			lipsyncContext.provider = ((!EnableLaughter) ? OVRLipSync.ContextProviders.Enhanced : OVRLipSync.ContextProviders.Enhanced_with_Laughter);
			lipsyncContext.skipAudioSource = !CanOwnMicrophone;
			StartCoroutine(WaitForMouthAudioSource());
		}
		if (GetComponent<OvrAvatarRemoteDriver>() != null)
		{
			transform.gameObject.AddComponent<GazeTarget>().Type = ovrAvatarGazeTargetType.AvatarHead;
			Transform transform2 = base.transform.Find("hand_left");
			if (!(transform2 == null))
			{
				transform2.gameObject.AddComponent<GazeTarget>().Type = ovrAvatarGazeTargetType.AvatarHand;
			}
			transform2 = base.transform.Find("hand_right");
			if (!(transform2 == null))
			{
				transform2.gameObject.AddComponent<GazeTarget>().Type = ovrAvatarGazeTargetType.AvatarHand;
			}
		}
	}

	private IEnumerator WaitForMouthAudioSource()
	{
		while (MouthAnchor.GetComponent<AudioSource>() == null)
		{
			yield return new WaitForSeconds(0.1f);
		}
		AudioSource component = MouthAnchor.GetComponent<AudioSource>();
		component.minDistance = 0.3f;
		component.maxDistance = 4f;
		component.rolloffMode = AudioRolloffMode.Logarithmic;
		component.loop = true;
		component.playOnAwake = true;
		component.spatialBlend = 1f;
		component.spatialize = true;
		component.spatializePostEffects = true;
	}

	public void DestroyHelperObjects()
	{
		if ((bool)MouthAnchor)
		{
			UnityEngine.Object.DestroyImmediate(MouthAnchor.gameObject);
		}
	}

	public GameObject CreateHelperObject(Transform parent, Vector3 localPositionOffset, string helperName, string helperTag = "")
	{
		GameObject gameObject = new GameObject();
		gameObject.name = helperName;
		if (helperTag != "")
		{
			gameObject.tag = helperTag;
		}
		gameObject.transform.SetParent(parent);
		gameObject.transform.localRotation = Quaternion.identity;
		gameObject.transform.localPosition = localPositionOffset;
		return gameObject;
	}

	public void UpdateVoiceData(short[] pcmData, int numChannels)
	{
		if (lipsyncContext != null && micInput == null)
		{
			lipsyncContext.ProcessAudioSamplesRaw(pcmData, numChannels);
		}
	}

	public void UpdateVoiceData(float[] pcmData, int numChannels)
	{
		if (lipsyncContext != null && micInput == null)
		{
			lipsyncContext.ProcessAudioSamplesRaw(pcmData, numChannels);
		}
	}

	private void UpdateFacewave()
	{
		if (!(lipsyncContext != null) || (!(micInput != null) && CanOwnMicrophone))
		{
			return;
		}
		currentFrame = lipsyncContext.GetCurrentPhonemeFrame();
		if (currentFrame.Visemes.Length != 15)
		{
			UnityEngine.Debug.LogError("Unexpected number of visemes " + currentFrame.Visemes);
			return;
		}
		currentFrame.Visemes.CopyTo(visemes, 0);
		visemes[15] = (EnableLaughter ? currentFrame.laughterScore : 0f);
		for (int i = 0; i < 16; i++)
		{
			RuntimeVisemes.visemeParams[i] = visemes[i];
		}
		Oculus.Avatar.CAPI.ovrAvatar_SetVisemes(sdkAvatar, RuntimeVisemes);
	}
}
public class OvrAvatarAsset
{
	public ulong assetID;
}
public class OvrAvatarAssetMesh : OvrAvatarAsset
{
	public Mesh mesh;

	private ovrAvatarSkinnedMeshPose skinnedBindPose;

	public string[] jointNames;

	public OvrAvatarAssetMesh(ulong _assetId, IntPtr asset, ovrAvatarAssetType meshType)
	{
		assetID = _assetId;
		mesh = new Mesh();
		mesh.name = "Procedural Geometry for asset " + _assetId;
		SetSkinnedBindPose(asset, meshType);
		long vertexCount = 0L;
		IntPtr vertexBuffer = IntPtr.Zero;
		uint indexCount = 0u;
		IntPtr indexBuffer = IntPtr.Zero;
		GetVertexAndIndexData(asset, meshType, out vertexCount, out vertexBuffer, out indexCount, out indexBuffer);
		Vector3[] array = new Vector3[vertexCount];
		Vector3[] array2 = new Vector3[vertexCount];
		Vector4[] array3 = new Vector4[vertexCount];
		Vector2[] array4 = new Vector2[vertexCount];
		Color[] array5 = new Color[vertexCount];
		BoneWeight[] array6 = new BoneWeight[vertexCount];
		long num = vertexBuffer.ToInt64();
		switch (meshType)
		{
		case ovrAvatarAssetType.Mesh:
		{
			long num5 = Marshal.SizeOf(typeof(ovrAvatarMeshVertex));
			for (long num6 = 0L; num6 < vertexCount; num6++)
			{
				long num7 = num5 * num6;
				ovrAvatarMeshVertex ovrAvatarMeshVertex2 = (ovrAvatarMeshVertex)Marshal.PtrToStructure(new IntPtr(num + num7), typeof(ovrAvatarMeshVertex));
				array[num6] = new Vector3(ovrAvatarMeshVertex2.x, ovrAvatarMeshVertex2.y, 0f - ovrAvatarMeshVertex2.z);
				array2[num6] = new Vector3(ovrAvatarMeshVertex2.nx, ovrAvatarMeshVertex2.ny, 0f - ovrAvatarMeshVertex2.nz);
				array3[num6] = new Vector4(ovrAvatarMeshVertex2.tx, ovrAvatarMeshVertex2.ty, 0f - ovrAvatarMeshVertex2.tz, ovrAvatarMeshVertex2.tw);
				array4[num6] = new Vector2(ovrAvatarMeshVertex2.u, ovrAvatarMeshVertex2.v);
				array5[num6] = new Color(0f, 0f, 0f, 1f);
				array6[num6].boneIndex0 = ovrAvatarMeshVertex2.blendIndices[0];
				array6[num6].boneIndex1 = ovrAvatarMeshVertex2.blendIndices[1];
				array6[num6].boneIndex2 = ovrAvatarMeshVertex2.blendIndices[2];
				array6[num6].boneIndex3 = ovrAvatarMeshVertex2.blendIndices[3];
				array6[num6].weight0 = ovrAvatarMeshVertex2.blendWeights[0];
				array6[num6].weight1 = ovrAvatarMeshVertex2.blendWeights[1];
				array6[num6].weight2 = ovrAvatarMeshVertex2.blendWeights[2];
				array6[num6].weight3 = ovrAvatarMeshVertex2.blendWeights[3];
			}
			break;
		}
		case ovrAvatarAssetType.CombinedMesh:
		{
			long num2 = Marshal.SizeOf(typeof(ovrAvatarMeshVertexV2));
			for (long num3 = 0L; num3 < vertexCount; num3++)
			{
				long num4 = num2 * num3;
				ovrAvatarMeshVertexV2 ovrAvatarMeshVertexV3 = (ovrAvatarMeshVertexV2)Marshal.PtrToStructure(new IntPtr(num + num4), typeof(ovrAvatarMeshVertexV2));
				array[num3] = new Vector3(ovrAvatarMeshVertexV3.x, ovrAvatarMeshVertexV3.y, 0f - ovrAvatarMeshVertexV3.z);
				array2[num3] = new Vector3(ovrAvatarMeshVertexV3.nx, ovrAvatarMeshVertexV3.ny, 0f - ovrAvatarMeshVertexV3.nz);
				array3[num3] = new Vector4(ovrAvatarMeshVertexV3.tx, ovrAvatarMeshVertexV3.ty, 0f - ovrAvatarMeshVertexV3.tz, ovrAvatarMeshVertexV3.tw);
				array4[num3] = new Vector2(ovrAvatarMeshVertexV3.u, ovrAvatarMeshVertexV3.v);
				array5[num3] = new Color(ovrAvatarMeshVertexV3.r, ovrAvatarMeshVertexV3.g, ovrAvatarMeshVertexV3.b, ovrAvatarMeshVertexV3.a);
				array6[num3].boneIndex0 = ovrAvatarMeshVertexV3.blendIndices[0];
				array6[num3].boneIndex1 = ovrAvatarMeshVertexV3.blendIndices[1];
				array6[num3].boneIndex2 = ovrAvatarMeshVertexV3.blendIndices[2];
				array6[num3].boneIndex3 = ovrAvatarMeshVertexV3.blendIndices[3];
				array6[num3].weight0 = ovrAvatarMeshVertexV3.blendWeights[0];
				array6[num3].weight1 = ovrAvatarMeshVertexV3.blendWeights[1];
				array6[num3].weight2 = ovrAvatarMeshVertexV3.blendWeights[2];
				array6[num3].weight3 = ovrAvatarMeshVertexV3.blendWeights[3];
			}
			break;
		}
		default:
			throw new Exception("Bad Mesh Asset Type");
		}
		mesh.vertices = array;
		mesh.normals = array2;
		mesh.uv = array4;
		mesh.tangents = array3;
		mesh.boneWeights = array6;
		mesh.colors = array5;
		LoadBlendShapes(asset, vertexCount);
		LoadSubmeshes(asset, indexBuffer, indexCount);
		uint jointCount = skinnedBindPose.jointCount;
		jointNames = new string[jointCount];
		for (uint num8 = 0u; num8 < jointCount; num8++)
		{
			jointNames[num8] = Marshal.PtrToStringAnsi(skinnedBindPose.jointNames[num8]);
		}
	}

	private void LoadSubmeshes(IntPtr asset, IntPtr indexBufferPtr, ulong indexCount)
	{
		uint num = Oculus.Avatar.CAPI.ovrAvatarAsset_GetSubmeshCount(asset);
		short[] array = new short[indexCount];
		Marshal.Copy(indexBufferPtr, array, 0, (int)indexCount);
		mesh.subMeshCount = (int)num;
		uint num2 = 0u;
		for (uint num3 = 0u; num3 < num; num3++)
		{
			uint num4 = Oculus.Avatar.CAPI.ovrAvatarAsset_GetSubmeshLastIndex(asset, num3);
			uint num5 = num4 - num2;
			int[] array2 = new int[num5];
			int num6 = 0;
			for (ulong num7 = num2; num7 < num4; num7 += 3)
			{
				array2[num6 + 2] = array[num7];
				array2[num6 + 1] = array[num7 + 1];
				array2[num6] = array[num7 + 2];
				num6 += 3;
			}
			num2 += num5;
			mesh.SetIndices(array2, MeshTopology.Triangles, (int)num3);
		}
	}

	private void LoadBlendShapes(IntPtr asset, long vertexCount)
	{
		uint num = Oculus.Avatar.CAPI.ovrAvatarAsset_GetMeshBlendShapeCount(asset);
		IntPtr intPtr = Oculus.Avatar.CAPI.ovrAvatarAsset_GetMeshBlendShapeVertices(asset);
		if (!(intPtr != IntPtr.Zero))
		{
			return;
		}
		long num2 = 0L;
		long num3 = Marshal.SizeOf(typeof(ovrAvatarBlendVertex));
		long num4 = intPtr.ToInt64();
		for (uint num5 = 0u; num5 < num; num5++)
		{
			Vector3[] array = new Vector3[vertexCount];
			Vector3[] array2 = new Vector3[vertexCount];
			Vector3[] array3 = new Vector3[vertexCount];
			for (long num6 = 0L; num6 < vertexCount; num6++)
			{
				ovrAvatarBlendVertex ovrAvatarBlendVertex2 = (ovrAvatarBlendVertex)Marshal.PtrToStructure(new IntPtr(num4 + num2), typeof(ovrAvatarBlendVertex));
				array[num6] = new Vector3(ovrAvatarBlendVertex2.x, ovrAvatarBlendVertex2.y, 0f - ovrAvatarBlendVertex2.z);
				array2[num6] = new Vector3(ovrAvatarBlendVertex2.nx, ovrAvatarBlendVertex2.ny, 0f - ovrAvatarBlendVertex2.nz);
				array3[num6] = new Vector4(ovrAvatarBlendVertex2.tx, ovrAvatarBlendVertex2.ty, 0f - ovrAvatarBlendVertex2.tz);
				num2 += num3;
			}
			string shapeName = Marshal.PtrToStringAnsi(Oculus.Avatar.CAPI.ovrAvatarAsset_GetMeshBlendShapeName(asset, num5));
			mesh.AddBlendShapeFrame(shapeName, 100f, array, array2, array3);
		}
	}

	private void SetSkinnedBindPose(IntPtr asset, ovrAvatarAssetType meshType)
	{
		switch (meshType)
		{
		case ovrAvatarAssetType.Mesh:
			skinnedBindPose = Oculus.Avatar.CAPI.ovrAvatarAsset_GetMeshData(asset).skinnedBindPose;
			break;
		case ovrAvatarAssetType.CombinedMesh:
			skinnedBindPose = Oculus.Avatar.CAPI.ovrAvatarAsset_GetCombinedMeshData(asset).skinnedBindPose;
			break;
		}
	}

	private void GetVertexAndIndexData(IntPtr asset, ovrAvatarAssetType meshType, out long vertexCount, out IntPtr vertexBuffer, out uint indexCount, out IntPtr indexBuffer)
	{
		vertexCount = 0L;
		vertexBuffer = IntPtr.Zero;
		indexCount = 0u;
		indexBuffer = IntPtr.Zero;
		switch (meshType)
		{
		case ovrAvatarAssetType.Mesh:
			vertexCount = Oculus.Avatar.CAPI.ovrAvatarAsset_GetMeshData(asset).vertexCount;
			vertexBuffer = Oculus.Avatar.CAPI.ovrAvatarAsset_GetMeshData(asset).vertexBuffer;
			indexCount = Oculus.Avatar.CAPI.ovrAvatarAsset_GetMeshData(asset).indexCount;
			indexBuffer = Oculus.Avatar.CAPI.ovrAvatarAsset_GetMeshData(asset).indexBuffer;
			break;
		case ovrAvatarAssetType.CombinedMesh:
			vertexCount = Oculus.Avatar.CAPI.ovrAvatarAsset_GetCombinedMeshData(asset).vertexCount;
			vertexBuffer = Oculus.Avatar.CAPI.ovrAvatarAsset_GetCombinedMeshData(asset).vertexBuffer;
			indexCount = Oculus.Avatar.CAPI.ovrAvatarAsset_GetCombinedMeshData(asset).indexCount;
			indexBuffer = Oculus.Avatar.CAPI.ovrAvatarAsset_GetCombinedMeshData(asset).indexBuffer;
			break;
		}
	}

	public SkinnedMeshRenderer CreateSkinnedMeshRendererOnObject(GameObject target)
	{
		SkinnedMeshRenderer skinnedMeshRenderer = target.AddComponent<SkinnedMeshRenderer>();
		skinnedMeshRenderer.sharedMesh = mesh;
		mesh.name = "AvatarMesh_" + assetID;
		uint jointCount = skinnedBindPose.jointCount;
		GameObject[] array = new GameObject[jointCount];
		Transform[] array2 = new Transform[jointCount];
		Matrix4x4[] array3 = new Matrix4x4[jointCount];
		for (uint num = 0u; num < jointCount; num++)
		{
			array[num] = new GameObject();
			array2[num] = array[num].transform;
			array[num].name = jointNames[num];
			int num2 = skinnedBindPose.jointParents[num];
			if (num2 == -1)
			{
				array[num].transform.parent = skinnedMeshRenderer.transform;
				skinnedMeshRenderer.rootBone = array[num].transform;
			}
			else
			{
				array[num].transform.parent = array[num2].transform;
			}
			Vector3 position = skinnedBindPose.jointTransform[num].position;
			position.z = 0f - position.z;
			array[num].transform.localPosition = position;
			Quaternion orientation = skinnedBindPose.jointTransform[num].orientation;
			orientation.x = 0f - orientation.x;
			orientation.y = 0f - orientation.y;
			array[num].transform.localRotation = orientation;
			array[num].transform.localScale = skinnedBindPose.jointTransform[num].scale;
			array3[num] = array[num].transform.worldToLocalMatrix * skinnedMeshRenderer.transform.localToWorldMatrix;
		}
		skinnedMeshRenderer.bones = array2;
		mesh.bindposes = array3;
		return skinnedMeshRenderer;
	}
}
public class OvrAvatarAssetTexture : OvrAvatarAsset
{
	public Texture2D texture;

	private const int ASTCHeaderSize = 16;

	public OvrAvatarAssetTexture(ulong _assetId, IntPtr asset)
	{
		assetID = _assetId;
		ovrAvatarTextureAssetData ovrAvatarTextureAssetData2 = Oculus.Avatar.CAPI.ovrAvatarAsset_GetTextureData(asset);
		IntPtr data = ovrAvatarTextureAssetData2.textureData;
		int num = (int)ovrAvatarTextureAssetData2.textureDataSize;
		TextureFormat textureFormat;
		switch (ovrAvatarTextureAssetData2.format)
		{
		case ovrAvatarTextureFormat.RGB24:
			textureFormat = TextureFormat.RGB24;
			break;
		case ovrAvatarTextureFormat.DXT1:
			textureFormat = TextureFormat.DXT1;
			break;
		case ovrAvatarTextureFormat.DXT5:
			textureFormat = TextureFormat.DXT5;
			break;
		case ovrAvatarTextureFormat.ASTC_RGB_6x6:
			textureFormat = TextureFormat.ASTC_6x6;
			data = new IntPtr(data.ToInt64() + 16);
			num -= 16;
			break;
		case ovrAvatarTextureFormat.ASTC_RGB_6x6_MIPMAPS:
			textureFormat = TextureFormat.ASTC_6x6;
			break;
		default:
			throw new NotImplementedException($"Unsupported texture format {ovrAvatarTextureAssetData2.format.ToString()}");
		}
		texture = new Texture2D((int)ovrAvatarTextureAssetData2.sizeX, (int)ovrAvatarTextureAssetData2.sizeY, textureFormat, ovrAvatarTextureAssetData2.mipCount > 1, (QualitySettings.activeColorSpace != 0) ? true : false)
		{
			filterMode = FilterMode.Trilinear,
			anisoLevel = 4
		};
		texture.LoadRawTextureData(data, num);
		texture.Apply(updateMipmaps: true, makeNoLongerReadable: false);
	}
}
public class OvrAvatarBase : OvrAvatarComponent
{
	private ovrAvatarBaseComponent component;

	private void Update()
	{
		if (!(owner == null))
		{
			if (Oculus.Avatar.CAPI.ovrAvatarPose_GetBaseComponent(owner.sdkAvatar, ref component))
			{
				UpdateAvatar(component.renderComponent);
				return;
			}
			owner.Base = null;
			UnityEngine.Object.Destroy(this);
		}
	}
}
public class OvrAvatarBody : OvrAvatarComponent
{
	public ovrAvatarBodyComponent component;

	public ovrAvatarComponent? GetNativeAvatarComponent()
	{
		if (owner == null)
		{
			return null;
		}
		if (Oculus.Avatar.CAPI.ovrAvatarPose_GetBodyComponent(owner.sdkAvatar, ref component))
		{
			Oculus.Avatar.CAPI.ovrAvatarComponent_Get(component.renderComponent, includeName: true, ref nativeAvatarComponent);
			return nativeAvatarComponent;
		}
		return null;
	}

	private void Update()
	{
		if (!(owner == null))
		{
			if (Oculus.Avatar.CAPI.ovrAvatarPose_GetBodyComponent(owner.sdkAvatar, ref component))
			{
				UpdateAvatar(component.renderComponent);
				return;
			}
			owner.Body = null;
			UnityEngine.Object.Destroy(this);
		}
	}
}
public class OvrAvatarComponent : MonoBehaviour
{
	public static readonly string[] LayerKeywords = new string[9] { "LAYERS_0", "LAYERS_1", "LAYERS_2", "LAYERS_3", "LAYERS_4", "LAYERS_5", "LAYERS_6", "LAYERS_7", "LAYERS_8" };

	public static readonly string[] LayerSampleModeParameters = new string[8] { "_LayerSampleMode0", "_LayerSampleMode1", "_LayerSampleMode2", "_LayerSampleMode3", "_LayerSampleMode4", "_LayerSampleMode5", "_LayerSampleMode6", "_LayerSampleMode7" };

	public static readonly string[] LayerBlendModeParameters = new string[8] { "_LayerBlendMode0", "_LayerBlendMode1", "_LayerBlendMode2", "_LayerBlendMode3", "_LayerBlendMode4", "_LayerBlendMode5", "_LayerBlendMode6", "_LayerBlendMode7" };

	public static readonly string[] LayerMaskTypeParameters = new string[8] { "_LayerMaskType0", "_LayerMaskType1", "_LayerMaskType2", "_LayerMaskType3", "_LayerMaskType4", "_LayerMaskType5", "_LayerMaskType6", "_LayerMaskType7" };

	public static readonly string[] LayerColorParameters = new string[8] { "_LayerColor0", "_LayerColor1", "_LayerColor2", "_LayerColor3", "_LayerColor4", "_LayerColor5", "_LayerColor6", "_LayerColor7" };

	public static readonly string[] LayerSurfaceParameters = new string[8] { "_LayerSurface0", "_LayerSurface1", "_LayerSurface2", "_LayerSurface3", "_LayerSurface4", "_LayerSurface5", "_LayerSurface6", "_LayerSurface7" };

	public static readonly string[] LayerSampleParametersParameters = new string[8] { "_LayerSampleParameters0", "_LayerSampleParameters1", "_LayerSampleParameters2", "_LayerSampleParameters3", "_LayerSampleParameters4", "_LayerSampleParameters5", "_LayerSampleParameters6", "_LayerSampleParameters7" };

	public static readonly string[] LayerMaskParametersParameters = new string[8] { "_LayerMaskParameters0", "_LayerMaskParameters1", "_LayerMaskParameters2", "_LayerMaskParameters3", "_LayerMaskParameters4", "_LayerMaskParameters5", "_LayerMaskParameters6", "_LayerMaskParameters7" };

	public static readonly string[] LayerMaskAxisParameters = new string[8] { "_LayerMaskAxis0", "_LayerMaskAxis1", "_LayerMaskAxis2", "_LayerMaskAxis3", "_LayerMaskAxis4", "_LayerMaskAxis5", "_LayerMaskAxis6", "_LayerMaskAxis7" };

	private Dictionary<Material, ovrAvatarMaterialState> materialStates = new Dictionary<Material, ovrAvatarMaterialState>();

	public List<OvrAvatarRenderComponent> RenderParts = new List<OvrAvatarRenderComponent>();

	protected OvrAvatar owner;

	protected ovrAvatarComponent nativeAvatarComponent;

	public void SetOvrAvatarOwner(OvrAvatar ovrAvatarOwner)
	{
		owner = ovrAvatarOwner;
	}

	public void UpdateAvatar(IntPtr nativeComponent)
	{
		Oculus.Avatar.CAPI.ovrAvatarComponent_Get(nativeComponent, includeName: false, ref nativeAvatarComponent);
		OvrAvatar.ConvertTransform(nativeAvatarComponent.transform, base.transform);
		for (uint num = 0u; num < nativeAvatarComponent.renderPartCount && RenderParts.Count > num; num++)
		{
			OvrAvatarRenderComponent ovrAvatarRenderComponent = RenderParts[(int)num];
			IntPtr renderPart = OvrAvatar.GetRenderPart(nativeAvatarComponent, num);
			switch (Oculus.Avatar.CAPI.ovrAvatarRenderPart_GetType(renderPart))
			{
			case ovrAvatarRenderPartType.SkinnedMeshRender:
				((OvrAvatarSkinnedMeshRenderComponent)ovrAvatarRenderComponent).UpdateSkinnedMeshRender(this, owner, renderPart);
				break;
			case ovrAvatarRenderPartType.SkinnedMeshRenderPBS:
				((OvrAvatarSkinnedMeshRenderPBSComponent)ovrAvatarRenderComponent).UpdateSkinnedMeshRenderPBS(owner, renderPart, ovrAvatarRenderComponent.mesh.sharedMaterial);
				break;
			case ovrAvatarRenderPartType.SkinnedMeshRenderPBS_V2:
				((OvrAvatarSkinnedMeshPBSV2RenderComponent)ovrAvatarRenderComponent).UpdateSkinnedMeshRender(this, owner, renderPart);
				break;
			}
		}
	}

	protected void UpdateActive(OvrAvatar avatar, ovrAvatarVisibilityFlags mask)
	{
		bool flag = avatar.ShowFirstPerson && (mask & ovrAvatarVisibilityFlags.FirstPerson) != 0;
		flag |= avatar.ShowThirdPerson && (mask & ovrAvatarVisibilityFlags.ThirdPerson) != 0;
		base.gameObject.SetActive(flag);
	}

	public void UpdateAvatarMaterial(Material mat, ovrAvatarMaterialState matState)
	{
		mat.SetColor("_BaseColor", matState.baseColor);
		mat.SetInt("_BaseMaskType", (int)matState.baseMaskType);
		mat.SetVector("_BaseMaskParameters", matState.baseMaskParameters);
		mat.SetVector("_BaseMaskAxis", matState.baseMaskAxis);
		if (matState.alphaMaskTextureID != 0L)
		{
			mat.SetTexture("_AlphaMask", GetLoadedTexture(matState.alphaMaskTextureID));
			mat.SetTextureScale("_AlphaMask", new Vector2(matState.alphaMaskScaleOffset.x, matState.alphaMaskScaleOffset.y));
			mat.SetTextureOffset("_AlphaMask", new Vector2(matState.alphaMaskScaleOffset.z, matState.alphaMaskScaleOffset.w));
		}
		if (matState.normalMapTextureID != 0L)
		{
			mat.EnableKeyword("NORMAL_MAP_ON");
			mat.SetTexture("_NormalMap", GetLoadedTexture(matState.normalMapTextureID));
			mat.SetTextureScale("_NormalMap", new Vector2(matState.normalMapScaleOffset.x, matState.normalMapScaleOffset.y));
			mat.SetTextureOffset("_NormalMap", new Vector2(matState.normalMapScaleOffset.z, matState.normalMapScaleOffset.w));
		}
		if (matState.parallaxMapTextureID != 0L)
		{
			mat.SetTexture("_ParallaxMap", GetLoadedTexture(matState.parallaxMapTextureID));
			mat.SetTextureScale("_ParallaxMap", new Vector2(matState.parallaxMapScaleOffset.x, matState.parallaxMapScaleOffset.y));
			mat.SetTextureOffset("_ParallaxMap", new Vector2(matState.parallaxMapScaleOffset.z, matState.parallaxMapScaleOffset.w));
		}
		if (matState.roughnessMapTextureID != 0L)
		{
			mat.EnableKeyword("ROUGHNESS_ON");
			mat.SetTexture("_RoughnessMap", GetLoadedTexture(matState.roughnessMapTextureID));
			mat.SetTextureScale("_RoughnessMap", new Vector2(matState.roughnessMapScaleOffset.x, matState.roughnessMapScaleOffset.y));
			mat.SetTextureOffset("_RoughnessMap", new Vector2(matState.roughnessMapScaleOffset.z, matState.roughnessMapScaleOffset.w));
		}
		mat.EnableKeyword(LayerKeywords[matState.layerCount]);
		for (ulong num = 0uL; num < matState.layerCount; num++)
		{
			ovrAvatarMaterialLayerState ovrAvatarMaterialLayerState2 = matState.layers[num];
			mat.SetInt(LayerSampleModeParameters[num], (int)ovrAvatarMaterialLayerState2.sampleMode);
			mat.SetInt(LayerBlendModeParameters[num], (int)ovrAvatarMaterialLayerState2.blendMode);
			mat.SetInt(LayerMaskTypeParameters[num], (int)ovrAvatarMaterialLayerState2.maskType);
			mat.SetColor(LayerColorParameters[num], ovrAvatarMaterialLayerState2.layerColor);
			if (ovrAvatarMaterialLayerState2.sampleMode != 0)
			{
				string text = LayerSurfaceParameters[num];
				mat.SetTexture(text, GetLoadedTexture(ovrAvatarMaterialLayerState2.sampleTexture));
				mat.SetTextureScale(text, new Vector2(ovrAvatarMaterialLayerState2.sampleScaleOffset.x, ovrAvatarMaterialLayerState2.sampleScaleOffset.y));
				mat.SetTextureOffset(text, new Vector2(ovrAvatarMaterialLayerState2.sampleScaleOffset.z, ovrAvatarMaterialLayerState2.sampleScaleOffset.w));
			}
			if (ovrAvatarMaterialLayerState2.sampleMode == ovrAvatarMaterialLayerSampleMode.Parallax)
			{
				mat.EnableKeyword("PARALLAX_ON");
			}
			mat.SetColor(LayerSampleParametersParameters[num], ovrAvatarMaterialLayerState2.sampleParameters);
			mat.SetColor(LayerMaskParametersParameters[num], ovrAvatarMaterialLayerState2.maskParameters);
			mat.SetColor(LayerMaskAxisParameters[num], ovrAvatarMaterialLayerState2.maskAxis);
		}
		materialStates[mat] = matState;
	}

	public static Texture2D GetLoadedTexture(ulong assetId)
	{
		return ((OvrAvatarAssetTexture)OvrAvatarSDKManager.Instance.GetAsset(assetId))?.texture;
	}
}
public abstract class OvrAvatarDriver : MonoBehaviour
{
	public enum PacketMode
	{
		SDK,
		Unity
	}

	public struct ControllerPose
	{
		public ovrAvatarButton buttons;

		public ovrAvatarTouch touches;

		public Vector2 joystickPosition;

		public float indexTrigger;

		public float handTrigger;

		public bool isActive;

		public static ControllerPose Interpolate(ControllerPose a, ControllerPose b, float t)
		{
			ControllerPose result = default(ControllerPose);
			result.buttons = ((t < 0.5f) ? a.buttons : b.buttons);
			result.touches = ((t < 0.5f) ? a.touches : b.touches);
			result.joystickPosition = Vector2.Lerp(a.joystickPosition, b.joystickPosition, t);
			result.indexTrigger = Mathf.Lerp(a.indexTrigger, b.indexTrigger, t);
			result.handTrigger = Mathf.Lerp(a.handTrigger, b.handTrigger, t);
			result.isActive = ((t < 0.5f) ? a.isActive : b.isActive);
			return result;
		}
	}

	public struct PoseFrame
	{
		public Vector3 headPosition;

		public Quaternion headRotation;

		public Vector3 handLeftPosition;

		public Quaternion handLeftRotation;

		public Vector3 handRightPosition;

		public Quaternion handRightRotation;

		public float voiceAmplitude;

		public ControllerPose controllerLeftPose;

		public ControllerPose controllerRightPose;

		public static PoseFrame Interpolate(PoseFrame a, PoseFrame b, float t)
		{
			PoseFrame result = default(PoseFrame);
			result.headPosition = Vector3.Lerp(a.headPosition, b.headPosition, t);
			result.headRotation = Quaternion.Slerp(a.headRotation, b.headRotation, t);
			result.handLeftPosition = Vector3.Lerp(a.handLeftPosition, b.handLeftPosition, t);
			result.handLeftRotation = Quaternion.Slerp(a.handLeftRotation, b.handLeftRotation, t);
			result.handRightPosition = Vector3.Lerp(a.handRightPosition, b.handRightPosition, t);
			result.handRightRotation = Quaternion.Slerp(a.handRightRotation, b.handRightRotation, t);
			result.voiceAmplitude = Mathf.Lerp(a.voiceAmplitude, b.voiceAmplitude, t);
			result.controllerLeftPose = ControllerPose.Interpolate(a.controllerLeftPose, b.controllerLeftPose, t);
			result.controllerRightPose = ControllerPose.Interpolate(a.controllerRightPose, b.controllerRightPose, t);
			return result;
		}
	}

	public PacketMode Mode;

	protected PoseFrame CurrentPose;

	private ovrAvatarControllerType ControllerType = ovrAvatarControllerType.Quest;

	public PoseFrame GetCurrentPose()
	{
		return CurrentPose;
	}

	public abstract void UpdateTransforms(IntPtr sdkAvatar);

	private void Start()
	{
		switch (OVRPlugin.GetSystemHeadsetType())
		{
		case OVRPlugin.SystemHeadset.Oculus_Quest:
		case OVRPlugin.SystemHeadset.Rift_S:
			ControllerType = ovrAvatarControllerType.Quest;
			break;
		default:
			ControllerType = ovrAvatarControllerType.Touch;
			break;
		}
	}

	public void UpdateTransformsFromPose(IntPtr sdkAvatar)
	{
		if (sdkAvatar != IntPtr.Zero)
		{
			ovrAvatarTransform headPose = OvrAvatar.CreateOvrAvatarTransform(CurrentPose.headPosition, CurrentPose.headRotation);
			ovrAvatarHandInputState inputStateLeft = OvrAvatar.CreateInputState(OvrAvatar.CreateOvrAvatarTransform(CurrentPose.handLeftPosition, CurrentPose.handLeftRotation), CurrentPose.controllerLeftPose);
			ovrAvatarHandInputState inputStateRight = OvrAvatar.CreateInputState(OvrAvatar.CreateOvrAvatarTransform(CurrentPose.handRightPosition, CurrentPose.handRightRotation), CurrentPose.controllerRightPose);
			Oculus.Avatar.CAPI.ovrAvatarPose_UpdateBody(sdkAvatar, headPose);
			Oculus.Avatar.CAPI.ovrAvatarPose_UpdateHandsWithType(sdkAvatar, inputStateLeft, inputStateRight, ControllerType);
		}
	}

	public static bool GetIsTrackedRemote()
	{
		return false;
	}
}
public class OvrAvatarHand : OvrAvatarComponent
{
	public bool isLeftHand = true;

	private ovrAvatarHandComponent component;

	private void Update()
	{
		if (owner == null)
		{
			return;
		}
		bool flag = false;
		if ((!isLeftHand) ? Oculus.Avatar.CAPI.ovrAvatarPose_GetRightHandComponent(owner.sdkAvatar, ref component) : Oculus.Avatar.CAPI.ovrAvatarPose_GetLeftHandComponent(owner.sdkAvatar, ref component))
		{
			UpdateAvatar(component.renderComponent);
			return;
		}
		if (isLeftHand)
		{
			owner.HandLeft = null;
		}
		else
		{
			owner.HandRight = null;
		}
		UnityEngine.Object.Destroy(this);
	}
}
public class OvrAvatarLocalDriver : OvrAvatarDriver
{
	private Vector3 centerEyePosition = Vector3.zero;

	private Quaternion centerEyeRotation = Quaternion.identity;

	private float voiceAmplitude;

	private ControllerPose GetMalibuControllerPose(OVRInput.Controller controller)
	{
		ovrAvatarButton ovrAvatarButton2 = (ovrAvatarButton)0;
		if (OVRInput.Get(OVRInput.Button.PrimaryIndexTrigger, controller))
		{
			ovrAvatarButton2 |= ovrAvatarButton.One;
		}
		ControllerPose result = default(ControllerPose);
		result.buttons = ovrAvatarButton2;
		result.touches = (OVRInput.Get(OVRInput.Touch.PrimaryTouchpad) ? ovrAvatarTouch.One : ((ovrAvatarTouch)0));
		result.joystickPosition = OVRInput.Get(OVRInput.Axis2D.PrimaryTouchpad, controller);
		result.indexTrigger = 0f;
		result.handTrigger = 0f;
		result.isActive = (OVRInput.GetActiveController() & controller) != 0;
		return result;
	}

	private ControllerPose GetControllerPose(OVRInput.Controller controller)
	{
		ovrAvatarButton ovrAvatarButton2 = (ovrAvatarButton)0;
		if (OVRInput.Get(OVRInput.Button.One, controller))
		{
			ovrAvatarButton2 |= ovrAvatarButton.One;
		}
		if (OVRInput.Get(OVRInput.Button.Two, controller))
		{
			ovrAvatarButton2 |= ovrAvatarButton.Two;
		}
		if (OVRInput.Get(OVRInput.Button.Start, controller))
		{
			ovrAvatarButton2 |= ovrAvatarButton.Three;
		}
		if (OVRInput.Get(OVRInput.Button.PrimaryThumbstick, controller))
		{
			ovrAvatarButton2 |= ovrAvatarButton.Joystick;
		}
		ovrAvatarTouch ovrAvatarTouch2 = (ovrAvatarTouch)0;
		if (OVRInput.Get(OVRInput.Touch.One, controller))
		{
			ovrAvatarTouch2 |= ovrAvatarTouch.One;
		}
		if (OVRInput.Get(OVRInput.Touch.Two, controller))
		{
			ovrAvatarTouch2 |= ovrAvatarTouch.Two;
		}
		if (OVRInput.Get(OVRInput.Touch.PrimaryThumbstick, controller))
		{
			ovrAvatarTouch2 |= ovrAvatarTouch.Joystick;
		}
		if (OVRInput.Get(OVRInput.Touch.PrimaryThumbRest, controller))
		{
			ovrAvatarTouch2 |= ovrAvatarTouch.ThumbRest;
		}
		if (OVRInput.Get(OVRInput.Touch.PrimaryIndexTrigger, controller))
		{
			ovrAvatarTouch2 |= ovrAvatarTouch.Index;
		}
		if (!OVRInput.Get(OVRInput.NearTouch.PrimaryIndexTrigger, controller))
		{
			ovrAvatarTouch2 |= ovrAvatarTouch.Pointing;
		}
		if (!OVRInput.Get(OVRInput.NearTouch.PrimaryThumbButtons, controller))
		{
			ovrAvatarTouch2 |= ovrAvatarTouch.ThumbUp;
		}
		ControllerPose result = default(ControllerPose);
		result.buttons = ovrAvatarButton2;
		result.touches = ovrAvatarTouch2;
		result.joystickPosition = OVRInput.Get(OVRInput.Axis2D.PrimaryThumbstick, controller);
		result.indexTrigger = OVRInput.Get(OVRInput.Axis1D.PrimaryIndexTrigger, controller);
		result.handTrigger = OVRInput.Get(OVRInput.Axis1D.PrimaryHandTrigger, controller);
		result.isActive = (OVRInput.GetActiveController() & controller) != 0;
		return result;
	}

	private void CalculateCurrentPose()
	{
		OVRNodeStateProperties.GetNodeStatePropertyVector3(XRNode.CenterEye, NodeStatePropertyType.Position, OVRPlugin.Node.EyeCenter, OVRPlugin.Step.Render, out centerEyePosition);
		OVRNodeStateProperties.GetNodeStatePropertyQuaternion(XRNode.CenterEye, NodeStatePropertyType.Orientation, OVRPlugin.Node.EyeCenter, OVRPlugin.Step.Render, out centerEyeRotation);
		CurrentPose = new PoseFrame
		{
			voiceAmplitude = voiceAmplitude,
			headPosition = centerEyePosition,
			headRotation = centerEyeRotation,
			handLeftPosition = OVRInput.GetLocalControllerPosition(OVRInput.Controller.LTouch),
			handLeftRotation = OVRInput.GetLocalControllerRotation(OVRInput.Controller.LTouch),
			handRightPosition = OVRInput.GetLocalControllerPosition(OVRInput.Controller.RTouch),
			handRightRotation = OVRInput.GetLocalControllerRotation(OVRInput.Controller.RTouch),
			controllerLeftPose = GetControllerPose(OVRInput.Controller.LTouch),
			controllerRightPose = GetControllerPose(OVRInput.Controller.RTouch)
		};
	}

	public override void UpdateTransforms(IntPtr sdkAvatar)
	{
		CalculateCurrentPose();
		UpdateTransformsFromPose(sdkAvatar);
	}
}
public class OvrAvatarMaterialManager : MonoBehaviour
{
	public enum TextureType
	{
		DiffuseTextures,
		NormalMaps,
		RoughnessMaps,
		Count
	}

	public struct AvatarComponentMaterialProperties
	{
		public ovrAvatarBodyPartType TypeIndex;

		public Color Color;

		public Texture2D[] Textures;

		public float DiffuseIntensity;

		public float RimIntensity;

		public float ReflectionIntensity;
	}

	public struct AvatarTextureArrayProperties
	{
		public Texture2D[] Textures;

		public Texture2DArray TextureArray;
	}

	public struct AvatarMaterialPropertyBlock
	{
		public Vector4[] Colors;

		public float[] DiffuseIntensities;

		public float[] RimIntensities;

		public float[] ReflectionIntensities;
	}

	[Serializable]
	public class AvatarMaterialConfig
	{
		public AvatarComponentMaterialProperties[] ComponentMaterialProperties;

		public AvatarMaterialPropertyBlock MaterialPropertyBlock;
	}

	private Renderer TargetRenderer;

	private AvatarTextureArrayProperties[] TextureArrays;

	private readonly string[] TextureTypeToShaderProperties = new string[3] { "_MainTex", "_NormalMap", "_RoughnessMap" };

	public AvatarMaterialConfig LocalAvatarConfig = new AvatarMaterialConfig();

	public List<ReflectionProbeBlendInfo> ReflectionProbes = new List<ReflectionProbeBlendInfo>();

	private Shader CombinedShader;

	public static string AVATAR_SHADER_LOADER = "OvrAvatar/Avatar_Mobile_Loader";

	public static string AVATAR_SHADER_MAINTEX = "_MainTex";

	public static string AVATAR_SHADER_NORMALMAP = "_NormalMap";

	public static string AVATAR_SHADER_ROUGHNESSMAP = "_RoughnessMap";

	public static string AVATAR_SHADER_COLOR = "_BaseColor";

	public static string AVATAR_SHADER_DIFFUSEINTENSITY = "_DiffuseIntensity";

	public static string AVATAR_SHADER_RIMINTENSITY = "_RimIntensity";

	public static string AVATAR_SHADER_REFLECTIONINTENSITY = "_ReflectionIntensity";

	public static string AVATAR_SHADER_CUBEMAP = "_Cubemap";

	public static string AVATAR_SHADER_ALPHA = "_Alpha";

	public static string AVATAR_SHADER_LOADING_DIMMER = "_LoadingDimmer";

	public static string AVATAR_SHADER_IRIS_COLOR = "_MaskColorIris";

	public static string AVATAR_SHADER_LIP_COLOR = "_MaskColorLips";

	public static string AVATAR_SHADER_BROW_COLOR = "_MaskColorBrows";

	public static string AVATAR_SHADER_LASH_COLOR = "_MaskColorLashes";

	public static string AVATAR_SHADER_SCLERA_COLOR = "_MaskColorSclera";

	public static string AVATAR_SHADER_GUM_COLOR = "_MaskColorGums";

	public static string AVATAR_SHADER_TEETH_COLOR = "_MaskColorTeeth";

	public static string AVATAR_SHADER_LIP_SMOOTHNESS = "_LipSmoothness";

	public static float[] DiffuseIntensities = new float[5] { 0.3f, 0.1f, 0f, 0.15f, 0.15f };

	public static float[] RimIntensities = new float[5] { 5f, 2f, 2.84f, 4f, 4f };

	public static float[] ReflectionIntensities = new float[5] { 0f, 0.3f, 0.4f, 0f, 0f };

	private const float LOADING_ANIMATION_AMPLITUDE = 0.5f;

	private const float LOADING_ANIMATION_PERIOD = 0.35f;

	private const float LOADING_ANIMATION_CURVE_SCALE = 0.25f;

	private const float LOADING_ANIMATION_DIMMER_MIN = 0.3f;

	public void CreateTextureArrays()
	{
		LocalAvatarConfig.ComponentMaterialProperties = new AvatarComponentMaterialProperties[5];
		LocalAvatarConfig.MaterialPropertyBlock.Colors = new Vector4[5];
		LocalAvatarConfig.MaterialPropertyBlock.DiffuseIntensities = new float[5];
		LocalAvatarConfig.MaterialPropertyBlock.RimIntensities = new float[5];
		LocalAvatarConfig.MaterialPropertyBlock.ReflectionIntensities = new float[5];
		for (int i = 0; i < LocalAvatarConfig.ComponentMaterialProperties.Length; i++)
		{
			LocalAvatarConfig.ComponentMaterialProperties[i].Textures = new Texture2D[3];
		}
		TextureArrays = new AvatarTextureArrayProperties[3];
	}

	public void SetRenderer(Renderer renderer)
	{
		TargetRenderer = renderer;
		TargetRenderer.GetClosestReflectionProbes(ReflectionProbes);
	}

	public void OnCombinedMeshReady()
	{
		InitTextureArrays();
		SetMaterialPropertyBlock();
		StartCoroutine(RunLoadingAnimation(DeleteTextureSet));
	}

	public void AddTextureIDToTextureManager(ulong assetID, bool isSingleComponent)
	{
		OvrAvatarSDKManager.Instance.GetTextureCopyManager().AddTextureIDToTextureSet(GetInstanceID(), assetID, isSingleComponent);
	}

	private void DeleteTextureSet()
	{
		OvrAvatarSDKManager.Instance.GetTextureCopyManager().DeleteTextureSet(GetInstanceID());
	}

	public void InitTextureArrays()
	{
		AvatarComponentMaterialProperties avatarComponentMaterialProperties = LocalAvatarConfig.ComponentMaterialProperties[0];
		for (int i = 0; i < TextureArrays.Length && i < avatarComponentMaterialProperties.Textures.Length; i++)
		{
			TextureArrays[i].TextureArray = new Texture2DArray(avatarComponentMaterialProperties.Textures[0].height, avatarComponentMaterialProperties.Textures[0].width, LocalAvatarConfig.ComponentMaterialProperties.Length, avatarComponentMaterialProperties.Textures[0].format, mipChain: true, (QualitySettings.activeColorSpace != 0) ? true : false)
			{
				filterMode = FilterMode.Trilinear,
				anisoLevel = ((i == 2) ? 16 : 4)
			};
			TextureArrays[i].TextureArray.name = $"Texture Array Type: {(TextureType)i}";
			TextureArrays[i].Textures = new Texture2D[LocalAvatarConfig.ComponentMaterialProperties.Length];
			for (int j = 0; j < LocalAvatarConfig.ComponentMaterialProperties.Length; j++)
			{
				TextureArrays[i].Textures[j] = LocalAvatarConfig.ComponentMaterialProperties[j].Textures[i];
				TextureArrays[i].Textures[j].name = $"Texture Type: {(TextureType)i} Component: {j}";
			}
			ProcessTexturesWithMips(TextureArrays[i].Textures, avatarComponentMaterialProperties.Textures[i].height, TextureArrays[i].TextureArray);
		}
	}

	private void ProcessTexturesWithMips(Texture2D[] textures, int texArrayResolution, Texture2DArray texArray)
	{
		for (int i = 0; i < textures.Length; i++)
		{
			int num = texArrayResolution;
			for (int num2 = textures[i].mipmapCount - 1; num2 >= 0; num2--)
			{
				int mipSize = texArrayResolution / num;
				OvrAvatarSDKManager.Instance.GetTextureCopyManager().CopyTexture(textures[i], texArray, num2, mipSize, i, useQueue: false);
				num /= 2;
			}
		}
	}

	private void SetMaterialPropertyBlock()
	{
		if (TargetRenderer != null)
		{
			for (int i = 0; i < LocalAvatarConfig.ComponentMaterialProperties.Length; i++)
			{
				LocalAvatarConfig.MaterialPropertyBlock.Colors[i] = LocalAvatarConfig.ComponentMaterialProperties[i].Color;
				LocalAvatarConfig.MaterialPropertyBlock.DiffuseIntensities[i] = DiffuseIntensities[i];
				LocalAvatarConfig.MaterialPropertyBlock.RimIntensities[i] = RimIntensities[i];
				LocalAvatarConfig.MaterialPropertyBlock.ReflectionIntensities[i] = ReflectionIntensities[i];
			}
		}
	}

	private void ApplyMaterialPropertyBlock()
	{
		MaterialPropertyBlock materialPropertyBlock = new MaterialPropertyBlock();
		materialPropertyBlock.SetVectorArray(AVATAR_SHADER_COLOR, LocalAvatarConfig.MaterialPropertyBlock.Colors);
		materialPropertyBlock.SetFloatArray(AVATAR_SHADER_DIFFUSEINTENSITY, LocalAvatarConfig.MaterialPropertyBlock.DiffuseIntensities);
		materialPropertyBlock.SetFloatArray(AVATAR_SHADER_RIMINTENSITY, LocalAvatarConfig.MaterialPropertyBlock.RimIntensities);
		materialPropertyBlock.SetFloatArray(AVATAR_SHADER_REFLECTIONINTENSITY, LocalAvatarConfig.MaterialPropertyBlock.ReflectionIntensities);
		TargetRenderer.GetClosestReflectionProbes(ReflectionProbes);
		if (ReflectionProbes != null && ReflectionProbes.Count > 0 && ReflectionProbes[0].probe.texture != null)
		{
			materialPropertyBlock.SetTexture(AVATAR_SHADER_CUBEMAP, ReflectionProbes[0].probe.texture);
		}
		for (int i = 0; i < TextureArrays.Length; i++)
		{
			materialPropertyBlock.SetTexture(TextureTypeToShaderProperties[i], TextureArrays[i].TextureArray);
		}
		TargetRenderer.SetPropertyBlock(materialPropertyBlock);
	}

	public static ovrAvatarBodyPartType GetComponentType(string objectName)
	{
		if (objectName.Contains("0"))
		{
			return ovrAvatarBodyPartType.Body;
		}
		if (objectName.Contains("1"))
		{
			return ovrAvatarBodyPartType.Clothing;
		}
		if (objectName.Contains("2"))
		{
			return ovrAvatarBodyPartType.Eyewear;
		}
		if (objectName.Contains("3"))
		{
			return ovrAvatarBodyPartType.Hair;
		}
		if (objectName.Contains("4"))
		{
			return ovrAvatarBodyPartType.Beard;
		}
		return ovrAvatarBodyPartType.Count;
	}

	private ulong GetTextureIDForType(ovrAvatarPBSMaterialState materialState, TextureType type)
	{
		return type switch
		{
			TextureType.DiffuseTextures => materialState.albedoTextureID, 
			TextureType.NormalMaps => materialState.normalTextureID, 
			TextureType.RoughnessMaps => materialState.metallicnessTextureID, 
			_ => 0uL, 
		};
	}

	public void ValidateTextures(ovrAvatarPBSMaterialState[] materialStates)
	{
		AvatarComponentMaterialProperties[] componentMaterialProperties = LocalAvatarConfig.ComponentMaterialProperties;
		int[] array = new int[3];
		TextureFormat[] array2 = new TextureFormat[3];
		for (int i = 0; i < componentMaterialProperties.Length; i++)
		{
			for (int j = 0; j < componentMaterialProperties[i].Textures.Length; j++)
			{
				if (componentMaterialProperties[i].Textures[j] == null)
				{
					string text = componentMaterialProperties[i].TypeIndex.ToString();
					TextureType textureType = (TextureType)j;
					throw new Exception(text + "Invalid: " + textureType);
				}
				array[j] = componentMaterialProperties[i].Textures[j].height;
				array2[j] = componentMaterialProperties[i].Textures[j].format;
			}
		}
		for (int k = 0; k < 3; k++)
		{
			for (int l = 1; l < componentMaterialProperties.Length; l++)
			{
				if (componentMaterialProperties[l - 1].Textures[k].height != componentMaterialProperties[l].Textures[k].height)
				{
					string[] obj = new string[12]
					{
						componentMaterialProperties[l].TypeIndex.ToString(),
						" Mismatching Resolutions: ",
						null,
						null,
						null,
						null,
						null,
						null,
						null,
						null,
						null,
						null
					};
					TextureType textureType = (TextureType)k;
					obj[2] = textureType.ToString();
					obj[3] = " ";
					obj[4] = componentMaterialProperties[l - 1].Textures[k].height.ToString();
					obj[5] = " (ID: ";
					obj[6] = GetTextureIDForType(materialStates[l - 1], (TextureType)k).ToString();
					obj[7] = ") vs ";
					obj[8] = componentMaterialProperties[l].Textures[k].height.ToString();
					obj[9] = " (ID: ";
					obj[10] = GetTextureIDForType(materialStates[l], (TextureType)k).ToString();
					obj[11] = ") Ensure you are using ASTC texture compression on Android or turn off CombineMeshes";
					throw new Exception(string.Concat(obj));
				}
				if (componentMaterialProperties[l - 1].Textures[k].format != componentMaterialProperties[l].Textures[k].format)
				{
					string[] obj2 = new string[12]
					{
						componentMaterialProperties[l].TypeIndex.ToString(),
						" Mismatching Formats: ",
						null,
						null,
						null,
						null,
						null,
						null,
						null,
						null,
						null,
						null
					};
					TextureType textureType = (TextureType)k;
					obj2[2] = textureType.ToString();
					obj2[3] = " ";
					obj2[4] = componentMaterialProperties[l - 1].Textures[k].format.ToString();
					obj2[5] = " (ID: ";
					obj2[6] = GetTextureIDForType(materialStates[l - 1], (TextureType)k).ToString();
					obj2[7] = ") vs ";
					obj2[8] = componentMaterialProperties[l].Textures[k].format.ToString();
					obj2[9] = " (ID: ";
					obj2[10] = GetTextureIDForType(materialStates[l], (TextureType)k).ToString();
					obj2[11] = ") Ensure you are using ASTC texture compression on Android or turn off CombineMeshes";
					throw new Exception(string.Concat(obj2));
				}
			}
		}
	}

	private IEnumerator RunLoadingAnimation(Action callBack)
	{
		CombinedShader = TargetRenderer.sharedMaterial.shader;
		int srcBlend = TargetRenderer.sharedMaterial.GetInt("_SrcBlend");
		int dstBlend = TargetRenderer.sharedMaterial.GetInt("_DstBlend");
		string lightModeTag = TargetRenderer.sharedMaterial.GetTag("LightMode", searchFallbacks: false);
		string renderTypeTag = TargetRenderer.sharedMaterial.GetTag("RenderType", searchFallbacks: false);
		string renderQueueTag = TargetRenderer.sharedMaterial.GetTag("Queue", searchFallbacks: false);
		string ignoreProjectorTag = TargetRenderer.sharedMaterial.GetTag("IgnoreProjector", searchFallbacks: false);
		int renderQueue = TargetRenderer.sharedMaterial.renderQueue;
		bool transparentQueue = TargetRenderer.sharedMaterial.IsKeywordEnabled("_ALPHATEST_ON");
		TargetRenderer.sharedMaterial.shader = Shader.Find(AVATAR_SHADER_LOADER);
		TargetRenderer.sharedMaterial.SetColor(AVATAR_SHADER_COLOR, Color.white);
		while (OvrAvatarSDKManager.Instance.GetTextureCopyManager().GetTextureCount() > 0)
		{
			float value = (0.5f * Mathf.Sin(Time.timeSinceLevelLoad / 0.35f) + 0.5f) * 0.25f + 0.3f;
			TargetRenderer.sharedMaterial.SetFloat(AVATAR_SHADER_LOADING_DIMMER, value);
			yield return null;
		}
		TargetRenderer.sharedMaterial.SetFloat(AVATAR_SHADER_LOADING_DIMMER, 1f);
		TargetRenderer.sharedMaterial.shader = CombinedShader;
		TargetRenderer.sharedMaterial.SetInt("_SrcBlend", srcBlend);
		TargetRenderer.sharedMaterial.SetInt("_DstBlend", dstBlend);
		TargetRenderer.sharedMaterial.SetOverrideTag("LightMode", lightModeTag);
		TargetRenderer.sharedMaterial.SetOverrideTag("RenderType", renderTypeTag);
		TargetRenderer.sharedMaterial.SetOverrideTag("Queue", renderQueueTag);
		TargetRenderer.sharedMaterial.SetOverrideTag("IgnoreProjector", ignoreProjectorTag);
		if (transparentQueue)
		{
			TargetRenderer.sharedMaterial.EnableKeyword("_ALPHATEST_ON");
			TargetRenderer.sharedMaterial.EnableKeyword("_ALPHABLEND_ON");
			TargetRenderer.sharedMaterial.EnableKeyword("_ALPHAPREMULTIPLY_ON");
		}
		else
		{
			TargetRenderer.sharedMaterial.DisableKeyword("_ALPHATEST_ON");
			TargetRenderer.sharedMaterial.DisableKeyword("_ALPHABLEND_ON");
			TargetRenderer.sharedMaterial.DisableKeyword("_ALPHAPREMULTIPLY_ON");
		}
		TargetRenderer.sharedMaterial.renderQueue = renderQueue;
		ApplyMaterialPropertyBlock();
		callBack?.Invoke();
	}
}
public class OvrAvatarPacket
{
	public IntPtr ovrNativePacket = IntPtr.Zero;

	private List<float> frameTimes = new List<float>();

	private List<OvrAvatarDriver.PoseFrame> frames = new List<OvrAvatarDriver.PoseFrame>();

	private List<byte[]> encodedAudioPackets = new List<byte[]>();

	public float Duration => frameTimes[frameTimes.Count - 1];

	public OvrAvatarDriver.PoseFrame FinalFrame => frames[frames.Count - 1];

	public OvrAvatarPacket()
	{
	}

	public OvrAvatarPacket(OvrAvatarDriver.PoseFrame initialPose)
	{
		frameTimes.Add(0f);
		frames.Add(initialPose);
	}

	private OvrAvatarPacket(List<float> frameTimes, List<OvrAvatarDriver.PoseFrame> frames, List<byte[]> audioPackets)
	{
		this.frameTimes = frameTimes;
		this.frames = frames;
	}

	public void AddFrame(OvrAvatarDriver.PoseFrame frame, float deltaSeconds)
	{
		frameTimes.Add(Duration + deltaSeconds);
		frames.Add(frame);
	}

	public OvrAvatarDriver.PoseFrame GetPoseFrame(float seconds)
	{
		if (frames.Count == 1)
		{
			return frames[0];
		}
		int i;
		for (i = 1; i < frameTimes.Count && frameTimes[i] < seconds; i++)
		{
		}
		OvrAvatarDriver.PoseFrame a = frames[i - 1];
		OvrAvatarDriver.PoseFrame b = frames[i];
		float num = frameTimes[i - 1];
		float num2 = frameTimes[i];
		float t = (seconds - num) / (num2 - num);
		return OvrAvatarDriver.PoseFrame.Interpolate(a, b, t);
	}

	public static OvrAvatarPacket Read(Stream stream)
	{
		BinaryReader binaryReader = new BinaryReader(stream);
		int num = binaryReader.ReadInt32();
		List<float> list = new List<float>(num);
		for (int i = 0; i < num; i++)
		{
			list.Add(binaryReader.ReadSingle());
		}
		List<OvrAvatarDriver.PoseFrame> list2 = new List<OvrAvatarDriver.PoseFrame>(num);
		for (int j = 0; j < num; j++)
		{
			list2.Add(binaryReader.ReadPoseFrame());
		}
		int num2 = binaryReader.ReadInt32();
		List<byte[]> list3 = new List<byte[]>(num2);
		for (int k = 0; k < num2; k++)
		{
			int count = binaryReader.ReadInt32();
			byte[] item = binaryReader.ReadBytes(count);
			list3.Add(item);
		}
		return new OvrAvatarPacket(list, list2, list3);
	}

	public void Write(Stream stream)
	{
		BinaryWriter binaryWriter = new BinaryWriter(stream);
		int count = frameTimes.Count;
		binaryWriter.Write(count);
		for (int i = 0; i < count; i++)
		{
			binaryWriter.Write(frameTimes[i]);
		}
		for (int j = 0; j < count; j++)
		{
			OvrAvatarDriver.PoseFrame frame = frames[j];
			binaryWriter.Write(frame);
		}
		int count2 = encodedAudioPackets.Count;
		binaryWriter.Write(count2);
		for (int k = 0; k < count2; k++)
		{
			byte[] array = encodedAudioPackets[k];
			binaryWriter.Write(array.Length);
			binaryWriter.Write(array);
		}
	}
}
internal static class BinaryWriterExtensions
{
	public static void Write(this BinaryWriter writer, OvrAvatarDriver.PoseFrame frame)
	{
		writer.Write(frame.headPosition);
		writer.Write(frame.headRotation);
		writer.Write(frame.handLeftPosition);
		writer.Write(frame.handLeftRotation);
		writer.Write(frame.handRightPosition);
		writer.Write(frame.handRightRotation);
		writer.Write(frame.voiceAmplitude);
		writer.Write(frame.controllerLeftPose);
		writer.Write(frame.controllerRightPose);
	}

	public static void Write(this BinaryWriter writer, Vector3 vec3)
	{
		writer.Write(vec3.x);
		writer.Write(vec3.y);
		writer.Write(vec3.z);
	}

	public static void Write(this BinaryWriter writer, Vector2 vec2)
	{
		writer.Write(vec2.x);
		writer.Write(vec2.y);
	}

	public static void Write(this BinaryWriter writer, Quaternion quat)
	{
		writer.Write(quat.x);
		writer.Write(quat.y);
		writer.Write(quat.z);
		writer.Write(quat.w);
	}

	public static void Write(this BinaryWriter writer, OvrAvatarDriver.ControllerPose pose)
	{
		writer.Write((uint)pose.buttons);
		writer.Write((uint)pose.touches);
		writer.Write(pose.joystickPosition);
		writer.Write(pose.indexTrigger);
		writer.Write(pose.handTrigger);
		writer.Write(pose.isActive);
	}
}
internal static class BinaryReaderExtensions
{
	public static OvrAvatarDriver.PoseFrame ReadPoseFrame(this BinaryReader reader)
	{
		OvrAvatarDriver.PoseFrame result = default(OvrAvatarDriver.PoseFrame);
		result.headPosition = reader.ReadVector3();
		result.headRotation = reader.ReadQuaternion();
		result.handLeftPosition = reader.ReadVector3();
		result.handLeftRotation = reader.ReadQuaternion();
		result.handRightPosition = reader.ReadVector3();
		result.handRightRotation = reader.ReadQuaternion();
		result.voiceAmplitude = reader.ReadSingle();
		result.controllerLeftPose = reader.ReadControllerPose();
		result.controllerRightPose = reader.ReadControllerPose();
		return result;
	}

	public static Vector2 ReadVector2(this BinaryReader reader)
	{
		Vector2 result = default(Vector2);
		result.x = reader.ReadSingle();
		result.y = reader.ReadSingle();
		return result;
	}

	public static Vector3 ReadVector3(this BinaryReader reader)
	{
		Vector3 result = default(Vector3);
		result.x = reader.ReadSingle();
		result.y = reader.ReadSingle();
		result.z = reader.ReadSingle();
		return result;
	}

	public static Quaternion ReadQuaternion(this BinaryReader reader)
	{
		Quaternion result = default(Quaternion);
		result.x = reader.ReadSingle();
		result.y = reader.ReadSingle();
		result.z = reader.ReadSingle();
		result.w = reader.ReadSingle();
		return result;
	}

	public static OvrAvatarDriver.ControllerPose ReadControllerPose(this BinaryReader reader)
	{
		OvrAvatarDriver.ControllerPose result = default(OvrAvatarDriver.ControllerPose);
		result.buttons = (ovrAvatarButton)reader.ReadUInt32();
		result.touches = (ovrAvatarTouch)reader.ReadUInt32();
		result.joystickPosition = reader.ReadVector2();
		result.indexTrigger = reader.ReadSingle();
		result.handTrigger = reader.ReadSingle();
		result.isActive = reader.ReadBoolean();
		return result;
	}
}
public class OvrAvatarRemoteDriver : OvrAvatarDriver
{
	private Queue<OvrAvatarPacket> packetQueue = new Queue<OvrAvatarPacket>();

	private IntPtr CurrentSDKPacket = IntPtr.Zero;

	private float CurrentPacketTime;

	private const int MinPacketQueue = 1;

	private const int MaxPacketQueue = 4;

	private int CurrentSequence = -1;

	private bool isStreaming;

	private OvrAvatarPacket currentPacket;

	public void QueuePacket(int sequence, OvrAvatarPacket packet)
	{
		if (sequence > CurrentSequence)
		{
			CurrentSequence = sequence;
			packetQueue.Enqueue(packet);
		}
	}

	public override void UpdateTransforms(IntPtr sdkAvatar)
	{
		switch (Mode)
		{
		case PacketMode.SDK:
			UpdateFromSDKPacket(sdkAvatar);
			break;
		case PacketMode.Unity:
			UpdateFromUnityPacket(sdkAvatar);
			break;
		}
	}

	private void UpdateFromSDKPacket(IntPtr sdkAvatar)
	{
		if (CurrentSDKPacket == IntPtr.Zero && packetQueue.Count >= 1)
		{
			CurrentSDKPacket = packetQueue.Dequeue().ovrNativePacket;
		}
		if (!(CurrentSDKPacket != IntPtr.Zero))
		{
			return;
		}
		float num = Oculus.Avatar.CAPI.ovrAvatarPacket_GetDurationSeconds(CurrentSDKPacket);
		Oculus.Avatar.CAPI.ovrAvatar_UpdatePoseFromPacket(sdkAvatar, CurrentSDKPacket, Mathf.Min(num, CurrentPacketTime));
		CurrentPacketTime += Time.deltaTime;
		if (CurrentPacketTime > num)
		{
			Oculus.Avatar.CAPI.ovrAvatarPacket_Free(CurrentSDKPacket);
			CurrentSDKPacket = IntPtr.Zero;
			CurrentPacketTime -= num;
			while (packetQueue.Count > 4)
			{
				packetQueue.Dequeue();
			}
		}
	}

	private void UpdateFromUnityPacket(IntPtr sdkAvatar)
	{
		if (!isStreaming && packetQueue.Count > 1)
		{
			currentPacket = packetQueue.Dequeue();
			isStreaming = true;
		}
		if (!isStreaming)
		{
			return;
		}
		CurrentPacketTime += Time.deltaTime;
		while (CurrentPacketTime > currentPacket.Duration)
		{
			if (packetQueue.Count == 0)
			{
				CurrentPose = currentPacket.FinalFrame;
				CurrentPacketTime = 0f;
				currentPacket = null;
				isStreaming = false;
				return;
			}
			while (packetQueue.Count > 4)
			{
				packetQueue.Dequeue();
			}
			CurrentPacketTime -= currentPacket.Duration;
			currentPacket = packetQueue.Dequeue();
		}
		CurrentPose = currentPacket.GetPoseFrame(CurrentPacketTime);
		UpdateTransformsFromPose(sdkAvatar);
	}
}
public class OvrAvatarRenderComponent : MonoBehaviour
{
	private bool firstSkinnedUpdate = true;

	public SkinnedMeshRenderer mesh;

	public Transform[] bones;

	private bool isBodyComponent;

	protected void UpdateActive(OvrAvatar avatar, ovrAvatarVisibilityFlags mask)
	{
		if (isBodyComponent && avatar.EnableExpressive && avatar.ShowFirstPerson && !avatar.ShowThirdPerson)
		{
			bool num = (mask & ovrAvatarVisibilityFlags.FirstPerson) != 0;
			bool flag = (mask & ovrAvatarVisibilityFlags.ThirdPerson) != 0;
			base.gameObject.SetActive(flag || flag);
			if (!num)
			{
				mesh.enabled = false;
			}
		}
		else
		{
			bool flag2 = avatar.ShowFirstPerson && (mask & ovrAvatarVisibilityFlags.FirstPerson) != 0;
			flag2 |= avatar.ShowThirdPerson && (mask & ovrAvatarVisibilityFlags.ThirdPerson) != 0;
			base.gameObject.SetActive(flag2);
			mesh.enabled = flag2;
		}
	}

	protected SkinnedMeshRenderer CreateSkinnedMesh(ulong assetID, ovrAvatarVisibilityFlags visibilityMask, int thirdPersonLayer, int firstPersonLayer)
	{
		isBodyComponent = base.name.Contains("body");
		OvrAvatarAssetMesh obj = ((OvrAvatarAssetMesh)OvrAvatarSDKManager.Instance.GetAsset(assetID)) ?? throw new Exception("Couldn't find mesh for asset " + assetID);
		if ((visibilityMask & ovrAvatarVisibilityFlags.ThirdPerson) != 0)
		{
			base.gameObject.layer = thirdPersonLayer;
		}
		else
		{
			base.gameObject.layer = firstPersonLayer;
		}
		SkinnedMeshRenderer skinnedMeshRenderer = obj.CreateSkinnedMeshRendererOnObject(base.gameObject);
		skinnedMeshRenderer.quality = SkinQuality.Bone2;
		skinnedMeshRenderer.updateWhenOffscreen = true;
		if ((visibilityMask & ovrAvatarVisibilityFlags.SelfOccluding) == 0)
		{
			skinnedMeshRenderer.shadowCastingMode = ShadowCastingMode.Off;
		}
		base.gameObject.SetActive(value: false);
		return skinnedMeshRenderer;
	}

	protected void UpdateSkinnedMesh(OvrAvatar avatar, Transform[] bones, ovrAvatarTransform localTransform, ovrAvatarVisibilityFlags visibilityMask, IntPtr renderPart)
	{
		UpdateActive(avatar, visibilityMask);
		OvrAvatar.ConvertTransform(localTransform, base.transform);
		ovrAvatarRenderPartType ovrAvatarRenderPartType2 = Oculus.Avatar.CAPI.ovrAvatarRenderPart_GetType(renderPart);
		ulong num = ovrAvatarRenderPartType2 switch
		{
			ovrAvatarRenderPartType.SkinnedMeshRender => Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRender_GetDirtyJoints(renderPart), 
			ovrAvatarRenderPartType.SkinnedMeshRenderPBS => Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRenderPBS_GetDirtyJoints(renderPart), 
			ovrAvatarRenderPartType.SkinnedMeshRenderPBS_V2 => Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRenderPBSV2_GetDirtyJoints(renderPart), 
			_ => throw new Exception("Unhandled render part type: " + ovrAvatarRenderPartType2), 
		};
		for (uint num2 = 0u; num2 < 64; num2++)
		{
			ulong num3 = (ulong)(1L << (int)num2);
			if ((firstSkinnedUpdate && num2 < bones.Length) || (num3 & num) != 0L)
			{
				Transform target = bones[num2];
				OvrAvatar.ConvertTransform(ovrAvatarRenderPartType2 switch
				{
					ovrAvatarRenderPartType.SkinnedMeshRender => Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRender_GetJointTransform(renderPart, num2), 
					ovrAvatarRenderPartType.SkinnedMeshRenderPBS => Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRenderPBS_GetJointTransform(renderPart, num2), 
					ovrAvatarRenderPartType.SkinnedMeshRenderPBS_V2 => Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRenderPBSV2_GetJointTransform(renderPart, num2), 
					_ => throw new Exception("Unhandled render part type: " + ovrAvatarRenderPartType2), 
				}, target);
			}
		}
		firstSkinnedUpdate = false;
	}

	protected Material CreateAvatarMaterial(string name, Shader shader)
	{
		if (shader == null)
		{
			throw new Exception("No shader provided for avatar material.");
		}
		return new Material(shader)
		{
			name = name
		};
	}
}
[Flags]
public enum ovrAvatarCapabilities
{
	Body = 1,
	Hands = 2,
	Base = 4,
	BodyTilt = 0x10,
	Expressive = 0x20,
	All = -1
}
public enum ovrAvatarMessageType
{
	AvatarSpecification,
	AssetLoaded,
	Count
}
public struct ovrAvatarMessage_AvatarSpecification
{
	public IntPtr avatarSpec;

	public ulong oculusUserID;
}
public struct ovrAvatarMessage_AssetLoaded
{
	public ulong assetID;

	public IntPtr asset;
}
public enum ovrAvatarAssetType
{
	Mesh,
	Texture,
	Pose,
	Material,
	CombinedMesh,
	PBSMaterial,
	FailedLoad,
	Count
}
public struct ovrAvatarMeshVertex
{
	public float x;

	public float y;

	public float z;

	public float nx;

	public float ny;

	public float nz;

	public float tx;

	public float ty;

	public float tz;

	public float tw;

	public float u;

	public float v;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 4)]
	public byte[] blendIndices;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 4)]
	public float[] blendWeights;
}
public struct ovrAvatarMeshVertexV2
{
	public float x;

	public float y;

	public float z;

	public float nx;

	public float ny;

	public float nz;

	public float tx;

	public float ty;

	public float tz;

	public float tw;

	public float u;

	public float v;

	public float r;

	public float g;

	public float b;

	public float a;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 4)]
	public byte[] blendIndices;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 4)]
	public float[] blendWeights;
}
public struct ovrAvatarBlendVertex
{
	public float x;

	public float y;

	public float z;

	public float nx;

	public float ny;

	public float nz;

	public float tx;

	public float ty;

	public float tz;
}
public struct ovrAvatarMeshAssetData
{
	public uint vertexCount;

	public IntPtr vertexBuffer;

	public uint indexCount;

	public IntPtr indexBuffer;

	public ovrAvatarSkinnedMeshPose skinnedBindPose;
}
public struct ovrAvatarMeshAssetDataV2
{
	public uint vertexCount;

	public IntPtr vertexBuffer;

	public uint indexCount;

	public IntPtr indexBuffer;

	public ovrAvatarSkinnedMeshPose skinnedBindPose;
}
public enum ovrAvatarTextureFormat
{
	RGB24,
	DXT1,
	DXT5,
	ASTC_RGB_6x6,
	ASTC_RGB_6x6_MIPMAPS,
	Count
}
public struct ovrAvatarTextureAssetData
{
	public ovrAvatarTextureFormat format;

	public uint sizeX;

	public uint sizeY;

	public uint mipCount;

	public ulong textureDataSize;

	public IntPtr textureData;
}
public enum ovrAvatarRenderPartType
{
	SkinnedMeshRender,
	SkinnedMeshRenderPBS,
	ProjectorRender,
	SkinnedMeshRenderPBS_V2,
	Count
}
public enum ovrAvatarLogLevel
{
	Unknown,
	Default,
	Verbose,
	Debug,
	Info,
	Warn,
	Error,
	Fatal,
	Silent
}
public struct ovrAvatarTransform
{
	public Vector3 position;

	public Quaternion orientation;

	public Vector3 scale;
}
[Flags]
public enum ovrAvatarButton
{
	One = 1,
	Two = 2,
	Three = 4,
	Joystick = 8
}
[Flags]
public enum ovrAvatarTouch
{
	One = 1,
	Two = 2,
	Joystick = 4,
	ThumbRest = 8,
	Index = 0x10,
	Pointing = 0x40,
	ThumbUp = 0x80
}
public struct ovrAvatarHandInputState
{
	public ovrAvatarTransform transform;

	public ovrAvatarButton buttonMask;

	public ovrAvatarTouch touchMask;

	public float joystickX;

	public float joystickY;

	public float indexTrigger;

	public float handTrigger;

	[MarshalAs(UnmanagedType.I1)]
	public bool isActive;
}
public struct ovrAvatarComponent
{
	public ovrAvatarTransform transform;

	public uint renderPartCount;

	public IntPtr renderParts;

	[MarshalAs(UnmanagedType.LPStr)]
	public string name;
}
[StructLayout(LayoutKind.Sequential, Size = 1)]
internal struct ovrAvatarComponent_Offsets
{
	public static long transform = Marshal.OffsetOf(typeof(ovrAvatarComponent), "transform").ToInt64();

	public static int renderPartCount = Marshal.OffsetOf(typeof(ovrAvatarComponent), "renderPartCount").ToInt32();

	public static int renderParts = Marshal.OffsetOf(typeof(ovrAvatarComponent), "renderParts").ToInt32();

	public static int name = Marshal.OffsetOf(typeof(ovrAvatarComponent), "name").ToInt32();
}
public struct ovrAvatarBaseComponent
{
	public Vector3 basePosition;

	public IntPtr renderComponent;
}
public struct ovrAvatarBodyComponent
{
	public ovrAvatarTransform leftEyeTransform;

	public ovrAvatarTransform rightEyeTransform;

	public ovrAvatarTransform centerEyeTransform;

	public IntPtr renderComponent;
}
[StructLayout(LayoutKind.Sequential, Size = 1)]
public struct ovrAvatarBodyComponent_Offsets
{
	public static long leftEyeTransform = Marshal.OffsetOf(typeof(ovrAvatarBodyComponent), "leftEyeTransform").ToInt64();

	public static long rightEyeTransform = Marshal.OffsetOf(typeof(ovrAvatarBodyComponent), "rightEyeTransform").ToInt64();

	public static long centerEyeTransform = Marshal.OffsetOf(typeof(ovrAvatarBodyComponent), "centerEyeTransform").ToInt64();

	public static long renderComponent = Marshal.OffsetOf(typeof(ovrAvatarBodyComponent), "renderComponent").ToInt64();
}
public struct ovrAvatarControllerComponent
{
	public ovrAvatarHandInputState inputState;

	public IntPtr renderComponent;
}
public struct ovrAvatarHandComponent
{
	public ovrAvatarHandInputState inputState;

	public IntPtr renderComponent;
}
public enum ovrAvatarMaterialLayerBlendMode
{
	Add,
	Multiply,
	Count
}
public enum ovrAvatarMaterialLayerSampleMode
{
	Color,
	Texture,
	TextureSingleChannel,
	Parallax,
	Count
}
public enum ovrAvatarMaterialMaskType
{
	None,
	Positional,
	ViewReflection,
	Fresnel,
	Pulse,
	Count
}
public enum ovrAvatarControllerType
{
	Touch,
	Malibu,
	Go,
	Quest,
	Count
}
public enum ovrAvatarAssetLevelOfDetail
{
	Lowest = 1,
	Medium = 3,
	Highest = 5
}
public enum ovrAvatarLookAndFeelVersion
{
	Unknown = -1,
	One,
	Two
}
public struct ovrAvatarMaterialLayerState
{
	public ovrAvatarMaterialLayerBlendMode blendMode;

	public ovrAvatarMaterialLayerSampleMode sampleMode;

	public ovrAvatarMaterialMaskType maskType;

	public Vector4 layerColor;

	public Vector4 sampleParameters;

	public ulong sampleTexture;

	public Vector4 sampleScaleOffset;

	public Vector4 maskParameters;

	public Vector4 maskAxis;

	private static bool VectorEquals(Vector4 a, Vector4 b)
	{
		if (a.x == b.x && a.y == b.y && a.z == b.z)
		{
			return a.w == b.w;
		}
		return false;
	}

	public override bool Equals(object obj)
	{
		if (!(obj is ovrAvatarMaterialLayerState ovrAvatarMaterialLayerState2))
		{
			return false;
		}
		if (blendMode != ovrAvatarMaterialLayerState2.blendMode)
		{
			return false;
		}
		if (sampleMode != ovrAvatarMaterialLayerState2.sampleMode)
		{
			return false;
		}
		if (maskType != ovrAvatarMaterialLayerState2.maskType)
		{
			return false;
		}
		if (!VectorEquals(layerColor, ovrAvatarMaterialLayerState2.layerColor))
		{
			return false;
		}
		if (!VectorEquals(sampleParameters, ovrAvatarMaterialLayerState2.sampleParameters))
		{
			return false;
		}
		if (sampleTexture != ovrAvatarMaterialLayerState2.sampleTexture)
		{
			return false;
		}
		if (!VectorEquals(sampleScaleOffset, ovrAvatarMaterialLayerState2.sampleScaleOffset))
		{
			return false;
		}
		if (!VectorEquals(maskParameters, ovrAvatarMaterialLayerState2.maskParameters))
		{
			return false;
		}
		if (!VectorEquals(maskAxis, ovrAvatarMaterialLayerState2.maskAxis))
		{
			return false;
		}
		return true;
	}

	public override int GetHashCode()
	{
		return blendMode.GetHashCode() ^ sampleMode.GetHashCode() ^ maskType.GetHashCode() ^ layerColor.GetHashCode() ^ sampleParameters.GetHashCode() ^ sampleTexture.GetHashCode() ^ sampleScaleOffset.GetHashCode() ^ maskParameters.GetHashCode() ^ maskAxis.GetHashCode();
	}
}
public struct ovrAvatarMaterialState
{
	public Vector4 baseColor;

	public ovrAvatarMaterialMaskType baseMaskType;

	public Vector4 baseMaskParameters;

	public Vector4 baseMaskAxis;

	public ovrAvatarMaterialLayerSampleMode sampleMode;

	public ulong alphaMaskTextureID;

	public Vector4 alphaMaskScaleOffset;

	public ulong normalMapTextureID;

	public Vector4 normalMapScaleOffset;

	public ulong parallaxMapTextureID;

	public Vector4 parallaxMapScaleOffset;

	public ulong roughnessMapTextureID;

	public Vector4 roughnessMapScaleOffset;

	public uint layerCount;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 8)]
	public ovrAvatarMaterialLayerState[] layers;

	private static bool VectorEquals(Vector4 a, Vector4 b)
	{
		if (a.x == b.x && a.y == b.y && a.z == b.z)
		{
			return a.w == b.w;
		}
		return false;
	}

	public override bool Equals(object obj)
	{
		if (!(obj is ovrAvatarMaterialState ovrAvatarMaterialState2))
		{
			return false;
		}
		if (!VectorEquals(baseColor, ovrAvatarMaterialState2.baseColor))
		{
			return false;
		}
		if (baseMaskType != ovrAvatarMaterialState2.baseMaskType)
		{
			return false;
		}
		if (!VectorEquals(baseMaskParameters, ovrAvatarMaterialState2.baseMaskParameters))
		{
			return false;
		}
		if (!VectorEquals(baseMaskAxis, ovrAvatarMaterialState2.baseMaskAxis))
		{
			return false;
		}
		if (sampleMode != ovrAvatarMaterialState2.sampleMode)
		{
			return false;
		}
		if (alphaMaskTextureID != ovrAvatarMaterialState2.alphaMaskTextureID)
		{
			return false;
		}
		if (!VectorEquals(alphaMaskScaleOffset, ovrAvatarMaterialState2.alphaMaskScaleOffset))
		{
			return false;
		}
		if (normalMapTextureID != ovrAvatarMaterialState2.normalMapTextureID)
		{
			return false;
		}
		if (!VectorEquals(normalMapScaleOffset, ovrAvatarMaterialState2.normalMapScaleOffset))
		{
			return false;
		}
		if (parallaxMapTextureID != ovrAvatarMaterialState2.parallaxMapTextureID)
		{
			return false;
		}
		if (!VectorEquals(parallaxMapScaleOffset, ovrAvatarMaterialState2.parallaxMapScaleOffset))
		{
			return false;
		}
		if (roughnessMapTextureID != ovrAvatarMaterialState2.roughnessMapTextureID)
		{
			return false;
		}
		if (!VectorEquals(roughnessMapScaleOffset, ovrAvatarMaterialState2.roughnessMapScaleOffset))
		{
			return false;
		}
		if (layerCount != ovrAvatarMaterialState2.layerCount)
		{
			return false;
		}
		for (int i = 0; i < layerCount; i++)
		{
			if (!layers[i].Equals(ovrAvatarMaterialState2.layers[i]))
			{
				return false;
			}
		}
		return true;
	}

	public override int GetHashCode()
	{
		int num = 0;
		num ^= baseColor.GetHashCode();
		num ^= baseMaskType.GetHashCode();
		num ^= baseMaskParameters.GetHashCode();
		num ^= baseMaskAxis.GetHashCode();
		num ^= sampleMode.GetHashCode();
		num ^= alphaMaskTextureID.GetHashCode();
		num ^= alphaMaskScaleOffset.GetHashCode();
		num ^= normalMapTextureID.GetHashCode();
		num ^= normalMapScaleOffset.GetHashCode();
		num ^= parallaxMapTextureID.GetHashCode();
		num ^= parallaxMapScaleOffset.GetHashCode();
		num ^= roughnessMapTextureID.GetHashCode();
		num ^= roughnessMapScaleOffset.GetHashCode();
		num ^= layerCount.GetHashCode();
		for (int i = 0; i < layerCount; i++)
		{
			num ^= layers[i].GetHashCode();
		}
		return num;
	}
}
public struct ovrAvatarExpressiveParameters
{
	public Vector4 irisColor;

	public Vector4 scleraColor;

	public Vector4 lashColor;

	public Vector4 browColor;

	public Vector4 lipColor;

	public Vector4 teethColor;

	public Vector4 gumColor;

	public float browLashIntensity;

	public float lipSmoothness;

	private static bool VectorEquals(Vector4 a, Vector4 b)
	{
		if (a.x == b.x && a.y == b.y && a.z == b.z)
		{
			return a.w == b.w;
		}
		return false;
	}

	public override bool Equals(object obj)
	{
		if (!(obj is ovrAvatarExpressiveParameters ovrAvatarExpressiveParameters2))
		{
			return false;
		}
		if (!VectorEquals(irisColor, ovrAvatarExpressiveParameters2.irisColor))
		{
			return false;
		}
		if (!VectorEquals(scleraColor, ovrAvatarExpressiveParameters2.scleraColor))
		{
			return false;
		}
		if (!VectorEquals(lashColor, ovrAvatarExpressiveParameters2.lashColor))
		{
			return false;
		}
		if (!VectorEquals(browColor, ovrAvatarExpressiveParameters2.browColor))
		{
			return false;
		}
		if (!VectorEquals(lipColor, ovrAvatarExpressiveParameters2.lipColor))
		{
			return false;
		}
		if (!VectorEquals(teethColor, ovrAvatarExpressiveParameters2.teethColor))
		{
			return false;
		}
		if (!VectorEquals(gumColor, ovrAvatarExpressiveParameters2.gumColor))
		{
			return false;
		}
		if (browLashIntensity != ovrAvatarExpressiveParameters2.browLashIntensity)
		{
			return false;
		}
		if (lipSmoothness != ovrAvatarExpressiveParameters2.lipSmoothness)
		{
			return false;
		}
		return true;
	}

	public override int GetHashCode()
	{
		return irisColor.GetHashCode() ^ scleraColor.GetHashCode() ^ lashColor.GetHashCode() ^ browColor.GetHashCode() ^ lipColor.GetHashCode() ^ teethColor.GetHashCode() ^ gumColor.GetHashCode() ^ browLashIntensity.GetHashCode() ^ lipSmoothness.GetHashCode();
	}
}
public struct ovrAvatarPBSMaterialState
{
	public Vector4 baseColor;

	public ulong albedoTextureID;

	public Vector4 albedoMultiplier;

	public ulong metallicnessTextureID;

	public float glossinessScale;

	public ulong normalTextureID;

	public ulong heightTextureID;

	public ulong occlusionTextureID;

	public ulong emissionTextureID;

	public Vector4 emissionMultiplier;

	public ulong detailMaskTextureID;

	public ulong detailAlbedoTextureID;

	public ulong detailNormalTextureID;

	private static bool VectorEquals(Vector4 a, Vector4 b)
	{
		if (a.x == b.x && a.y == b.y && a.z == b.z)
		{
			return a.w == b.w;
		}
		return false;
	}

	public override bool Equals(object obj)
	{
		if (!(obj is ovrAvatarPBSMaterialState ovrAvatarPBSMaterialState2))
		{
			return false;
		}
		if (!VectorEquals(baseColor, ovrAvatarPBSMaterialState2.baseColor))
		{
			return false;
		}
		if (albedoTextureID != ovrAvatarPBSMaterialState2.albedoTextureID)
		{
			return false;
		}
		if (!VectorEquals(albedoMultiplier, ovrAvatarPBSMaterialState2.albedoMultiplier))
		{
			return false;
		}
		if (metallicnessTextureID != ovrAvatarPBSMaterialState2.metallicnessTextureID)
		{
			return false;
		}
		if (glossinessScale != ovrAvatarPBSMaterialState2.glossinessScale)
		{
			return false;
		}
		if (normalTextureID != ovrAvatarPBSMaterialState2.normalTextureID)
		{
			return false;
		}
		if (heightTextureID != ovrAvatarPBSMaterialState2.heightTextureID)
		{
			return false;
		}
		if (occlusionTextureID != ovrAvatarPBSMaterialState2.occlusionTextureID)
		{
			return false;
		}
		if (emissionTextureID != ovrAvatarPBSMaterialState2.emissionTextureID)
		{
			return false;
		}
		if (!VectorEquals(emissionMultiplier, ovrAvatarPBSMaterialState2.emissionMultiplier))
		{
			return false;
		}
		if (detailMaskTextureID != ovrAvatarPBSMaterialState2.detailMaskTextureID)
		{
			return false;
		}
		if (detailAlbedoTextureID != ovrAvatarPBSMaterialState2.detailAlbedoTextureID)
		{
			return false;
		}
		if (detailNormalTextureID != ovrAvatarPBSMaterialState2.detailNormalTextureID)
		{
			return false;
		}
		return true;
	}

	public override int GetHashCode()
	{
		return baseColor.GetHashCode() ^ albedoTextureID.GetHashCode() ^ albedoMultiplier.GetHashCode() ^ metallicnessTextureID.GetHashCode() ^ glossinessScale.GetHashCode() ^ normalTextureID.GetHashCode() ^ heightTextureID.GetHashCode() ^ occlusionTextureID.GetHashCode() ^ emissionTextureID.GetHashCode() ^ emissionMultiplier.GetHashCode() ^ detailMaskTextureID.GetHashCode() ^ detailAlbedoTextureID.GetHashCode() ^ detailNormalTextureID.GetHashCode();
	}
}
public class OvrAvatarAssetMaterial : OvrAvatarAsset
{
	public ovrAvatarMaterialState material;

	public OvrAvatarAssetMaterial(ulong id, IntPtr mat)
	{
		assetID = id;
		material = Oculus.Avatar.CAPI.ovrAvatarAsset_GetMaterialState(mat);
	}
}
public struct ovrAvatarSkinnedMeshPose
{
	public uint jointCount;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 64)]
	public ovrAvatarTransform[] jointTransform;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 64)]
	public int[] jointParents;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 64)]
	public IntPtr[] jointNames;
}
[Flags]
public enum ovrAvatarVisibilityFlags
{
	FirstPerson = 1,
	ThirdPerson = 2,
	SelfOccluding = 4
}
public struct ovrAvatarRenderPart_SkinnedMeshRender
{
	public ovrAvatarTransform localTransform;

	public ovrAvatarVisibilityFlags visibilityMask;

	public ulong meshAssetID;

	public ovrAvatarMaterialState materialState;

	public ovrAvatarSkinnedMeshPose skinnedPose;
}
public struct ovrAvatarRenderPart_SkinnedMeshRenderPBS
{
	public ovrAvatarTransform localTransform;

	public ovrAvatarVisibilityFlags visibilityMask;

	public ulong meshAssetID;

	public ulong albedoTextureAssetID;

	public ulong surfaceTextureAssetID;

	public ovrAvatarSkinnedMeshPose skinnedPose;
}
public struct ovrAvatarRenderPart_ProjectorRender
{
	public ovrAvatarTransform localTransform;

	public uint componentIndex;

	public uint renderPartIndex;

	public ovrAvatarMaterialState materialState;
}
public struct ovrAvatarRenderPart_SkinnedMeshRenderPBS_V2
{
	public ovrAvatarTransform localTransform;

	public ovrAvatarVisibilityFlags visibilityMask;

	public ulong meshAssetID;

	public ovrAvatarPBSMaterialState materialState;

	public ovrAvatarSkinnedMeshPose skinnedPose;
}
public enum ovrAvatarHandGesture
{
	Default,
	GripSphere,
	GripCube,
	Count
}
public enum ovrAvatarBodyPartType
{
	Body,
	Clothing,
	Eyewear,
	Hair,
	Beard,
	Count
}
public struct ovrAvatarBlendShapeParams
{
	public uint blendShapeParamCount;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 64)]
	public float[] blendShapeParams;
}
[StructLayout(LayoutKind.Sequential, Size = 1)]
internal struct ovrAvatarBlendShapeParams_Offsets
{
	public static int blendShapeParamCount = Marshal.OffsetOf(typeof(ovrAvatarBlendShapeParams), "blendShapeParamCount").ToInt32();

	public static long blendShapeParams = Marshal.SizeOf(typeof(uint));
}
public struct ovrAvatarVisemes
{
	public uint visemeParamCount;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 32)]
	public float[] visemeParams;
}
[StructLayout(LayoutKind.Sequential, Size = 1)]
internal struct ovrAvatarVisemes_Offsets
{
	public static int visemeParamCount = Marshal.OffsetOf(typeof(ovrAvatarVisemes), "visemeParamCount").ToInt32();

	public static long visemeParams = Marshal.SizeOf(typeof(uint));
}
public enum ovrAvatarGazeTargetType
{
	AvatarHead,
	AvatarHand,
	Object,
	ObjectStatic,
	Count
}
public struct ovrAvatarGazeTarget
{
	public uint id;

	public Vector3 worldPosition;

	public ovrAvatarGazeTargetType type;
}
[StructLayout(LayoutKind.Sequential, Size = 1)]
internal struct ovrAvatarGazeTarget_Offsets
{
	public static int id = 0;

	public static int worldPosition = Marshal.SizeOf(typeof(uint));

	public static int type = worldPosition + Marshal.SizeOf(typeof(Vector3));
}
public struct ovrAvatarGazeTargets
{
	public uint targetCount;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 128)]
	public ovrAvatarGazeTarget[] targets;
}
[StructLayout(LayoutKind.Sequential, Size = 1)]
internal struct ovrAvatarGazeTargets_Offsets
{
	public static int targetCount = Marshal.OffsetOf(typeof(ovrAvatarGazeTargets), "targetCount").ToInt32();

	public static long targets = Marshal.SizeOf(typeof(uint));
}
public enum ovrAvatarLightType
{
	Point,
	Direction,
	Spot,
	Count
}
public struct ovrAvatarLight
{
	public uint id;

	public ovrAvatarLightType type;

	public float intensity;

	public Vector3 worldDirection;

	public Vector3 worldPosition;

	public float range;

	public float spotAngleDeg;
}
[StructLayout(LayoutKind.Sequential, Size = 1)]
internal struct ovrAvatarLight_Offsets
{
	public static long id = Marshal.OffsetOf(typeof(ovrAvatarLight), "id").ToInt64();

	public static long type = Marshal.OffsetOf(typeof(ovrAvatarLight), "type").ToInt64();

	public static long intensity = Marshal.OffsetOf(typeof(ovrAvatarLight), "intensity").ToInt64();

	public static long worldDirection = Marshal.OffsetOf(typeof(ovrAvatarLight), "worldDirection").ToInt64();

	public static long worldPosition = Marshal.OffsetOf(typeof(ovrAvatarLight), "worldPosition").ToInt64();

	public static long range = Marshal.OffsetOf(typeof(ovrAvatarLight), "range").ToInt64();

	public static long spotAngleDeg = Marshal.OffsetOf(typeof(ovrAvatarLight), "spotAngleDeg").ToInt64();
}
public struct ovrAvatarLights
{
	public float ambientIntensity;

	public uint lightCount;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 16)]
	public ovrAvatarLight[] lights;
}
[StructLayout(LayoutKind.Sequential, Size = 1)]
internal struct ovrAvatarLights_Offsets
{
	public static long ambientIntensity = Marshal.OffsetOf(typeof(ovrAvatarLights), "ambientIntensity").ToInt64();

	public static long lightCount = Marshal.OffsetOf(typeof(ovrAvatarLights), "lightCount").ToInt64();

	public static long lights = Marshal.OffsetOf(typeof(ovrAvatarLights), "lights").ToInt64();
}
[Flags]
public enum ovrAvatarDebugContext : uint
{
	None = 0u,
	GazeTarget = 1u,
	Any = uint.MaxValue
}
public struct ovrAvatarDebugLine
{
	public Vector3 startPoint;

	public Vector3 endPoint;

	public Vector3 color;

	public ovrAvatarDebugContext context;

	public IntPtr text;
}
public struct ovrAvatarDebugTransform
{
	public ovrAvatarTransform transform;

	public ovrAvatarDebugContext context;

	public IntPtr text;
}
public delegate void specificationCallback(IntPtr specification);
public delegate void assetLoadedCallback(OvrAvatarAsset asset);
public delegate void combinedMeshLoadedCallback(IntPtr asset);
public class OvrAvatarSDKManager : MonoBehaviour
{
	public struct AvatarSpecRequestParams
	{
		public ulong _userId;

		public specificationCallback _callback;

		public bool _useCombinedMesh;

		public ovrAvatarAssetLevelOfDetail _lod;

		public bool _forceMobileTextureFormat;

		public ovrAvatarLookAndFeelVersion _lookVersion;

		public ovrAvatarLookAndFeelVersion _fallbackVersion;

		public bool _enableExpressive;

		public AvatarSpecRequestParams(ulong userId, specificationCallback callback, bool useCombinedMesh, ovrAvatarAssetLevelOfDetail lod, bool forceMobileTextureFormat, ovrAvatarLookAndFeelVersion lookVersion, ovrAvatarLookAndFeelVersion fallbackVersion, bool enableExpressive)
		{
			_userId = userId;
			_callback = callback;
			_useCombinedMesh = useCombinedMesh;
			_lod = lod;
			_forceMobileTextureFormat = forceMobileTextureFormat;
			_lookVersion = lookVersion;
			_fallbackVersion = fallbackVersion;
			_enableExpressive = enableExpressive;
		}
	}

	private static OvrAvatarSDKManager _instance;

	private bool initialized;

	private Dictionary<ulong, HashSet<specificationCallback>> specificationCallbacks;

	private Dictionary<ulong, HashSet<assetLoadedCallback>> assetLoadedCallbacks;

	private Dictionary<IntPtr, combinedMeshLoadedCallback> combinedMeshLoadedCallbacks;

	private Dictionary<ulong, OvrAvatarAsset> assetCache;

	private OvrAvatarTextureCopyManager textureCopyManager;

	public ovrAvatarLogLevel LoggingLevel = ovrAvatarLogLevel.Info;

	private Queue<AvatarSpecRequestParams> avatarSpecificationQueue;

	private List<int> loadingAvatars;

	private bool avatarSpecRequestAvailable = true;

	private float lastDispatchedAvatarSpecRequestTime;

	private const float AVATAR_SPEC_REQUEST_TIMEOUT = 5f;

	public static OvrAvatarSDKManager Instance
	{
		get
		{
			if (_instance == null)
			{
				_instance = UnityEngine.Object.FindObjectOfType<OvrAvatarSDKManager>();
				if (_instance == null)
				{
					GameObject gameObject = new GameObject("OvrAvatarSDKManager");
					_instance = gameObject.AddComponent<OvrAvatarSDKManager>();
					_instance.textureCopyManager = gameObject.AddComponent<OvrAvatarTextureCopyManager>();
					_instance.initialized = _instance.Initialize();
				}
			}
			if (!_instance.initialized)
			{
				return null;
			}
			return _instance;
		}
	}

	private bool Initialize()
	{
		Oculus.Avatar.CAPI.Initialize();
		string text = GetAppId();
		if (text == "")
		{
			text = "0";
		}
		Oculus.Avatar.CAPI.ovrAvatar_InitializeAndroidUnity(text);
		specificationCallbacks = new Dictionary<ulong, HashSet<specificationCallback>>();
		assetLoadedCallbacks = new Dictionary<ulong, HashSet<assetLoadedCallback>>();
		combinedMeshLoadedCallbacks = new Dictionary<IntPtr, combinedMeshLoadedCallback>();
		assetCache = new Dictionary<ulong, OvrAvatarAsset>();
		avatarSpecificationQueue = new Queue<AvatarSpecRequestParams>();
		loadingAvatars = new List<int>();
		Oculus.Avatar.CAPI.ovrAvatar_SetLoggingLevel(LoggingLevel);
		Oculus.Avatar.CAPI.ovrAvatar_RegisterLoggingCallback(Oculus.Avatar.CAPI.LoggingCallback);
		return true;
	}

	private void OnDestroy()
	{
		Oculus.Avatar.CAPI.Shutdown();
		Oculus.Avatar.CAPI.ovrAvatar_RegisterLoggingCallback(null);
		Oculus.Avatar.CAPI.ovrAvatar_Shutdown();
	}

	private void Update()
	{
		if (Instance == null)
		{
			return;
		}
		if (avatarSpecificationQueue.Count > 0 && (avatarSpecRequestAvailable || Time.time - lastDispatchedAvatarSpecRequestTime >= 5f))
		{
			avatarSpecRequestAvailable = false;
			AvatarSpecRequestParams avatarSpecRequest = avatarSpecificationQueue.Dequeue();
			DispatchAvatarSpecificationRequest(avatarSpecRequest);
			lastDispatchedAvatarSpecRequestTime = Time.time;
		}
		IntPtr intPtr = Oculus.Avatar.CAPI.ovrAvatarMessage_Pop();
		if (intPtr == IntPtr.Zero)
		{
			return;
		}
		ovrAvatarMessageType ovrAvatarMessageType2 = Oculus.Avatar.CAPI.ovrAvatarMessage_GetType(intPtr);
		switch (ovrAvatarMessageType2)
		{
		case ovrAvatarMessageType.AssetLoaded:
		{
			ovrAvatarMessage_AssetLoaded ovrAvatarMessage_AssetLoaded2 = Oculus.Avatar.CAPI.ovrAvatarMessage_GetAssetLoaded(intPtr);
			IntPtr asset = ovrAvatarMessage_AssetLoaded2.asset;
			ulong assetID = ovrAvatarMessage_AssetLoaded2.assetID;
			ovrAvatarAssetType ovrAvatarAssetType2 = Oculus.Avatar.CAPI.ovrAvatarAsset_GetType(asset);
			OvrAvatarAsset ovrAvatarAsset = null;
			IntPtr key = IntPtr.Zero;
			switch (ovrAvatarAssetType2)
			{
			case ovrAvatarAssetType.Mesh:
				ovrAvatarAsset = new OvrAvatarAssetMesh(assetID, asset, ovrAvatarAssetType.Mesh);
				break;
			case ovrAvatarAssetType.Texture:
				ovrAvatarAsset = new OvrAvatarAssetTexture(assetID, asset);
				break;
			case ovrAvatarAssetType.Material:
				ovrAvatarAsset = new OvrAvatarAssetMaterial(assetID, asset);
				break;
			case ovrAvatarAssetType.CombinedMesh:
				key = Oculus.Avatar.CAPI.ovrAvatarAsset_GetAvatar(asset);
				ovrAvatarAsset = new OvrAvatarAssetMesh(assetID, asset, ovrAvatarAssetType.CombinedMesh);
				break;
			default:
				throw new NotImplementedException($"Unsupported asset type format {ovrAvatarAssetType2.ToString()}");
			case ovrAvatarAssetType.FailedLoad:
				break;
			}
			if (ovrAvatarAssetType2 == ovrAvatarAssetType.CombinedMesh)
			{
				if (!assetCache.ContainsKey(assetID))
				{
					assetCache.Add(assetID, ovrAvatarAsset);
				}
				if (combinedMeshLoadedCallbacks.TryGetValue(key, out var value2))
				{
					value2(asset);
					combinedMeshLoadedCallbacks.Remove(key);
				}
			}
			else
			{
				if (ovrAvatarAsset == null || !assetLoadedCallbacks.TryGetValue(ovrAvatarMessage_AssetLoaded2.assetID, out var value3))
				{
					break;
				}
				assetCache.Add(assetID, ovrAvatarAsset);
				foreach (assetLoadedCallback item in value3)
				{
					item(ovrAvatarAsset);
				}
				assetLoadedCallbacks.Remove(ovrAvatarMessage_AssetLoaded2.assetID);
			}
			break;
		}
		case ovrAvatarMessageType.AvatarSpecification:
		{
			avatarSpecRequestAvailable = true;
			ovrAvatarMessage_AvatarSpecification ovrAvatarMessage_AvatarSpecification2 = Oculus.Avatar.CAPI.ovrAvatarMessage_GetAvatarSpecification(intPtr);
			if (!specificationCallbacks.TryGetValue(ovrAvatarMessage_AvatarSpecification2.oculusUserID, out var value))
			{
				break;
			}
			foreach (specificationCallback item2 in value)
			{
				item2(ovrAvatarMessage_AvatarSpecification2.avatarSpec);
			}
			specificationCallbacks.Remove(ovrAvatarMessage_AvatarSpecification2.oculusUserID);
			break;
		}
		default:
			throw new NotImplementedException("Unhandled ovrAvatarMessageType: " + ovrAvatarMessageType2);
		}
		Oculus.Avatar.CAPI.ovrAvatarMessage_Free(intPtr);
	}

	public bool IsAvatarSpecWaiting()
	{
		return avatarSpecificationQueue.Count > 0;
	}

	public bool IsAvatarLoading()
	{
		return loadingAvatars.Count > 0;
	}

	public void AddLoadingAvatar(int gameobjectID)
	{
		loadingAvatars.Add(gameobjectID);
	}

	public void RemoveLoadingAvatar(int gameobjectID)
	{
		loadingAvatars.Remove(gameobjectID);
	}

	public void RequestAvatarSpecification(AvatarSpecRequestParams avatarSpecRequest)
	{
		avatarSpecificationQueue.Enqueue(avatarSpecRequest);
	}

	private void DispatchAvatarSpecificationRequest(AvatarSpecRequestParams avatarSpecRequest)
	{
		textureCopyManager.CheckFallbackTextureSet(avatarSpecRequest._lod);
		Oculus.Avatar.CAPI.ovrAvatar_SetForceASTCTextures(avatarSpecRequest._forceMobileTextureFormat);
		if (!specificationCallbacks.TryGetValue(avatarSpecRequest._userId, out var value))
		{
			value = new HashSet<specificationCallback>();
			specificationCallbacks.Add(avatarSpecRequest._userId, value);
			IntPtr specificationRequest = Oculus.Avatar.CAPI.ovrAvatarSpecificationRequest_Create(avatarSpecRequest._userId);
			Oculus.Avatar.CAPI.ovrAvatarSpecificationRequest_SetLookAndFeelVersion(specificationRequest, avatarSpecRequest._lookVersion);
			Oculus.Avatar.CAPI.ovrAvatarSpecificationRequest_SetFallbackLookAndFeelVersion(specificationRequest, avatarSpecRequest._fallbackVersion);
			Oculus.Avatar.CAPI.ovrAvatarSpecificationRequest_SetLevelOfDetail(specificationRequest, avatarSpecRequest._lod);
			Oculus.Avatar.CAPI.ovrAvatarSpecificationRequest_SetCombineMeshes(specificationRequest, avatarSpecRequest._useCombinedMesh);
			Oculus.Avatar.CAPI.ovrAvatarSpecificationRequest_SetExpressiveFlag(specificationRequest, avatarSpecRequest._enableExpressive);
			Oculus.Avatar.CAPI.ovrAvatar_RequestAvatarSpecificationFromSpecRequest(specificationRequest);
			Oculus.Avatar.CAPI.ovrAvatarSpecificationRequest_Destroy(specificationRequest);
		}
		value.Add(avatarSpecRequest._callback);
	}

	public void BeginLoadingAsset(ulong assetId, ovrAvatarAssetLevelOfDetail lod, assetLoadedCallback callback)
	{
		if (!assetLoadedCallbacks.TryGetValue(assetId, out var value))
		{
			value = new HashSet<assetLoadedCallback>();
			assetLoadedCallbacks.Add(assetId, value);
		}
		Oculus.Avatar.CAPI.ovrAvatarAsset_BeginLoadingLOD(assetId, lod);
		value.Add(callback);
	}

	public void RegisterCombinedMeshCallback(IntPtr sdkAvatar, combinedMeshLoadedCallback callback)
	{
		if (!combinedMeshLoadedCallbacks.TryGetValue(sdkAvatar, out var _))
		{
			combinedMeshLoadedCallbacks.Add(sdkAvatar, callback);
			return;
		}
		throw new Exception("Adding second combind mesh callback for same avatar");
	}

	public OvrAvatarAsset GetAsset(ulong assetId)
	{
		if (assetCache.TryGetValue(assetId, out var value))
		{
			return value;
		}
		return null;
	}

	public void DeleteAssetFromCache(ulong assetId)
	{
		if (assetCache.ContainsKey(assetId))
		{
			assetCache.Remove(assetId);
		}
	}

	public string GetAppId()
	{
		if (UnityEngine.Application.platform != RuntimePlatform.Android)
		{
			return OvrAvatarSettings.AppID;
		}
		return OvrAvatarSettings.MobileAppID;
	}

	public OvrAvatarTextureCopyManager GetTextureCopyManager()
	{
		if (textureCopyManager != null)
		{
			return textureCopyManager;
		}
		return null;
	}
}
public sealed class OvrAvatarSettings : ScriptableObject
{
	private static OvrAvatarSettings instance;

	[SerializeField]
	private string ovrAppID = "";

	[SerializeField]
	private string ovrGearAppID = "";

	public static string AppID
	{
		get
		{
			return Instance.ovrAppID;
		}
		set
		{
			Instance.ovrAppID = value;
		}
	}

	public static string MobileAppID
	{
		get
		{
			return Instance.ovrGearAppID;
		}
		set
		{
			Instance.ovrGearAppID = value;
		}
	}

	public static OvrAvatarSettings Instance
	{
		get
		{
			if (instance == null)
			{
				instance = Resources.Load<OvrAvatarSettings>("OvrAvatarSettings");
				if (instance == null)
				{
					instance = ScriptableObject.CreateInstance<OvrAvatarSettings>();
				}
			}
			return instance;
		}
		set
		{
			instance = value;
		}
	}
}
public class OvrAvatarSkinnedMeshRenderComponent : OvrAvatarRenderComponent
{
	private Shader surface;

	private Shader surfaceSelfOccluding;

	private bool previouslyActive;

	internal void Initialize(ovrAvatarRenderPart_SkinnedMeshRender skinnedMeshRender, Shader surface, Shader surfaceSelfOccluding, int thirdPersonLayer, int firstPersonLayer)
	{
		this.surfaceSelfOccluding = ((surfaceSelfOccluding != null) ? surfaceSelfOccluding : Shader.Find("OvrAvatar/AvatarSurfaceShaderSelfOccluding"));
		this.surface = ((surface != null) ? surface : Shader.Find("OvrAvatar/AvatarSurfaceShader"));
		mesh = CreateSkinnedMesh(skinnedMeshRender.meshAssetID, skinnedMeshRender.visibilityMask, thirdPersonLayer, firstPersonLayer);
		bones = mesh.bones;
		UpdateMeshMaterial(skinnedMeshRender.visibilityMask, mesh);
	}

	public void UpdateSkinnedMeshRender(OvrAvatarComponent component, OvrAvatar avatar, IntPtr renderPart)
	{
		ovrAvatarVisibilityFlags visibilityMask = Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRender_GetVisibilityMask(renderPart);
		ovrAvatarTransform localTransform = Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRender_GetTransform(renderPart);
		UpdateSkinnedMesh(avatar, bones, localTransform, visibilityMask, renderPart);
		UpdateMeshMaterial(visibilityMask, mesh);
		bool activeSelf = base.gameObject.activeSelf;
		if (mesh != null && (Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRender_MaterialStateChanged(renderPart) || (!previouslyActive && activeSelf)))
		{
			ovrAvatarMaterialState matState = Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRender_GetMaterialState(renderPart);
			component.UpdateAvatarMaterial(mesh.sharedMaterial, matState);
		}
		previouslyActive = activeSelf;
	}

	private void UpdateMeshMaterial(ovrAvatarVisibilityFlags visibilityMask, SkinnedMeshRenderer rootMesh)
	{
		Shader shader = (((visibilityMask & ovrAvatarVisibilityFlags.SelfOccluding) != 0) ? surfaceSelfOccluding : surface);
		if (rootMesh.sharedMaterial == null || rootMesh.sharedMaterial.shader != shader)
		{
			rootMesh.sharedMaterial = CreateAvatarMaterial(base.gameObject.name + "_material", shader);
		}
	}
}
public class OvrAvatarSkinnedMeshRenderPBSComponent : OvrAvatarRenderComponent
{
	private bool isMaterialInitilized;

	internal void Initialize(ovrAvatarRenderPart_SkinnedMeshRenderPBS skinnedMeshRenderPBS, Shader shader, int thirdPersonLayer, int firstPersonLayer)
	{
		if (shader == null)
		{
			shader = Shader.Find("OvrAvatar/AvatarSurfaceShaderPBS");
		}
		mesh = CreateSkinnedMesh(skinnedMeshRenderPBS.meshAssetID, skinnedMeshRenderPBS.visibilityMask, thirdPersonLayer, firstPersonLayer);
		mesh.sharedMaterial = CreateAvatarMaterial(base.gameObject.name + "_material", shader);
		bones = mesh.bones;
	}

	internal void UpdateSkinnedMeshRenderPBS(OvrAvatar avatar, IntPtr renderPart, Material mat)
	{
		if (!isMaterialInitilized)
		{
			isMaterialInitilized = true;
			ulong assetId = Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRenderPBS_GetAlbedoTextureAssetID(renderPart);
			ulong assetId2 = Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRenderPBS_GetSurfaceTextureAssetID(renderPart);
			mat.SetTexture("_Albedo", OvrAvatarComponent.GetLoadedTexture(assetId));
			mat.SetTexture("_Surface", OvrAvatarComponent.GetLoadedTexture(assetId2));
		}
		ovrAvatarVisibilityFlags visibilityMask = Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRenderPBS_GetVisibilityMask(renderPart);
		ovrAvatarTransform localTransform = Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRenderPBS_GetTransform(renderPart);
		UpdateSkinnedMesh(avatar, bones, localTransform, visibilityMask, renderPart);
	}
}
public class OvrAvatarSkinnedMeshPBSV2RenderComponent : OvrAvatarRenderComponent
{
	private OvrAvatarMaterialManager avatarMaterialManager;

	private bool previouslyActive;

	private bool isCombinedMaterial;

	private ovrAvatarExpressiveParameters ExpressiveParameters;

	private bool EnableExpressive;

	private int blendShapeCount;

	private ovrAvatarBlendShapeParams blendShapeParams;

	private const string MAIN_MATERIAL_NAME = "main_material";

	private const string EYE_MATERIAL_NAME = "eye_material";

	private const string DEFAULT_MATERIAL_NAME = "_material";

	internal void Initialize(IntPtr renderPart, ovrAvatarRenderPart_SkinnedMeshRenderPBS_V2 skinnedMeshRender, OvrAvatarMaterialManager materialManager, int thirdPersonLayer, int firstPersonLayer, bool combinedMesh, ovrAvatarAssetLevelOfDetail lod, bool assignExpressiveParams, OvrAvatar avatar, bool isControllerModel)
	{
		avatarMaterialManager = materialManager;
		isCombinedMaterial = combinedMesh;
		mesh = CreateSkinnedMesh(skinnedMeshRender.meshAssetID, skinnedMeshRender.visibilityMask, thirdPersonLayer, firstPersonLayer);
		EnableExpressive = assignExpressiveParams;
		Shader shader = (EnableExpressive ? avatar.Skinshaded_Expressive_VertFrag_SingleComponent : avatar.Skinshaded_VertFrag_SingleComponent);
		Shader shader2 = (EnableExpressive ? avatar.Skinshaded_Expressive_VertFrag_CombinedMesh : avatar.Skinshaded_VertFrag_CombinedMesh);
		Shader shader3 = (isCombinedMaterial ? shader2 : shader);
		if (isControllerModel)
		{
			shader3 = avatar.ControllerShader;
		}
		if (EnableExpressive)
		{
			ExpressiveParameters = Oculus.Avatar.CAPI.ovrAvatar_GetExpressiveParameters(avatar.sdkAvatar);
			Shader eyeLens = avatar.EyeLens;
			Material[] array = new Material[2]
			{
				CreateAvatarMaterial(base.gameObject.name + "main_material", shader3),
				CreateAvatarMaterial(base.gameObject.name + "eye_material", eyeLens)
			};
			if (avatar.UseTransparentRenderQueue)
			{
				SetMaterialTransparent(array[0]);
			}
			else
			{
				SetMaterialOpaque(array[0]);
			}
			array[1].renderQueue = -1;
			mesh.materials = array;
		}
		else
		{
			mesh.sharedMaterial = CreateAvatarMaterial(base.gameObject.name + "_material", shader3);
			if (avatar.UseTransparentRenderQueue && !isControllerModel)
			{
				SetMaterialTransparent(mesh.sharedMaterial);
			}
			else
			{
				SetMaterialOpaque(mesh.sharedMaterial);
			}
		}
		bones = mesh.bones;
		if (isCombinedMaterial)
		{
			avatarMaterialManager.SetRenderer(mesh);
			InitializeCombinedMaterial(renderPart, (int)lod);
			avatarMaterialManager.OnCombinedMeshReady();
		}
		blendShapeParams = default(ovrAvatarBlendShapeParams);
		blendShapeParams.blendShapeParamCount = 0u;
		blendShapeParams.blendShapeParams = new float[64];
		blendShapeCount = mesh.sharedMesh.blendShapeCount;
	}

	public void UpdateSkinnedMeshRender(OvrAvatarComponent component, OvrAvatar avatar, IntPtr renderPart)
	{
		ovrAvatarVisibilityFlags visibilityMask = Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRenderPBSV2_GetVisibilityMask(renderPart);
		ovrAvatarTransform localTransform = Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRenderPBSV2_GetTransform(renderPart);
		UpdateSkinnedMesh(avatar, bones, localTransform, visibilityMask, renderPart);
		bool activeSelf = base.gameObject.activeSelf;
		if (mesh != null && !previouslyActive && activeSelf && !isCombinedMaterial)
		{
			InitializeSingleComponentMaterial(renderPart, (int)(avatar.LevelOfDetail - 1));
		}
		if (blendShapeCount > 0)
		{
			Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRender_GetBlendShapeParams(renderPart, ref blendShapeParams);
			for (uint num = 0u; num < blendShapeParams.blendShapeParamCount && num < blendShapeCount; num++)
			{
				float num2 = blendShapeParams.blendShapeParams[num];
				mesh.SetBlendShapeWeight((int)num, num2 * 100f);
			}
		}
		previouslyActive = activeSelf;
	}

	private void InitializeSingleComponentMaterial(IntPtr renderPart, int lodIndex)
	{
		ovrAvatarPBSMaterialState ovrAvatarPBSMaterialState2 = Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRenderPBSV2_GetPBSMaterialState(renderPart);
		int componentType = (int)OvrAvatarMaterialManager.GetComponentType(base.gameObject.name);
		Texture2D texture2D = OvrAvatarComponent.GetLoadedTexture(ovrAvatarPBSMaterialState2.albedoTextureID);
		Texture2D texture2D2 = OvrAvatarComponent.GetLoadedTexture(ovrAvatarPBSMaterialState2.normalTextureID);
		Texture2D texture2D3 = OvrAvatarComponent.GetLoadedTexture(ovrAvatarPBSMaterialState2.metallicnessTextureID);
		if (texture2D != null)
		{
			avatarMaterialManager.AddTextureIDToTextureManager(ovrAvatarPBSMaterialState2.albedoTextureID, isSingleComponent: true);
		}
		else
		{
			texture2D = OvrAvatarSDKManager.Instance.GetTextureCopyManager().FallbackTextureSets[lodIndex].DiffuseRoughness;
		}
		texture2D.anisoLevel = 4;
		if (texture2D2 != null)
		{
			avatarMaterialManager.AddTextureIDToTextureManager(ovrAvatarPBSMaterialState2.normalTextureID, isSingleComponent: true);
		}
		else
		{
			texture2D2 = OvrAvatarSDKManager.Instance.GetTextureCopyManager().FallbackTextureSets[lodIndex].Normal;
		}
		texture2D2.anisoLevel = 4;
		if (texture2D3 != null)
		{
			avatarMaterialManager.AddTextureIDToTextureManager(ovrAvatarPBSMaterialState2.metallicnessTextureID, isSingleComponent: true);
		}
		else
		{
			texture2D3 = OvrAvatarSDKManager.Instance.GetTextureCopyManager().FallbackTextureSets[lodIndex].DiffuseRoughness;
		}
		texture2D3.anisoLevel = 16;
		mesh.materials[0].SetTexture(OvrAvatarMaterialManager.AVATAR_SHADER_MAINTEX, texture2D);
		mesh.materials[0].SetTexture(OvrAvatarMaterialManager.AVATAR_SHADER_NORMALMAP, texture2D2);
		mesh.materials[0].SetTexture(OvrAvatarMaterialManager.AVATAR_SHADER_ROUGHNESSMAP, texture2D3);
		mesh.materials[0].SetVector(OvrAvatarMaterialManager.AVATAR_SHADER_COLOR, ovrAvatarPBSMaterialState2.albedoMultiplier);
		mesh.materials[0].SetFloat(OvrAvatarMaterialManager.AVATAR_SHADER_DIFFUSEINTENSITY, OvrAvatarMaterialManager.DiffuseIntensities[componentType]);
		mesh.materials[0].SetFloat(OvrAvatarMaterialManager.AVATAR_SHADER_RIMINTENSITY, OvrAvatarMaterialManager.RimIntensities[componentType]);
		mesh.materials[0].SetFloat(OvrAvatarMaterialManager.AVATAR_SHADER_REFLECTIONINTENSITY, OvrAvatarMaterialManager.ReflectionIntensities[componentType]);
		mesh.GetClosestReflectionProbes(avatarMaterialManager.ReflectionProbes);
		if (avatarMaterialManager.ReflectionProbes != null && avatarMaterialManager.ReflectionProbes.Count > 0)
		{
			mesh.materials[0].SetTexture(OvrAvatarMaterialManager.AVATAR_SHADER_CUBEMAP, avatarMaterialManager.ReflectionProbes[0].probe.texture);
		}
		if (EnableExpressive)
		{
			mesh.materials[0].SetVector(OvrAvatarMaterialManager.AVATAR_SHADER_IRIS_COLOR, ExpressiveParameters.irisColor);
			mesh.materials[0].SetVector(OvrAvatarMaterialManager.AVATAR_SHADER_LIP_COLOR, ExpressiveParameters.lipColor);
			mesh.materials[0].SetVector(OvrAvatarMaterialManager.AVATAR_SHADER_BROW_COLOR, ExpressiveParameters.browColor);
			mesh.materials[0].SetVector(OvrAvatarMaterialManager.AVATAR_SHADER_LASH_COLOR, ExpressiveParameters.lashColor);
			mesh.materials[0].SetVector(OvrAvatarMaterialManager.AVATAR_SHADER_SCLERA_COLOR, ExpressiveParameters.scleraColor);
			mesh.materials[0].SetVector(OvrAvatarMaterialManager.AVATAR_SHADER_GUM_COLOR, ExpressiveParameters.gumColor);
			mesh.materials[0].SetVector(OvrAvatarMaterialManager.AVATAR_SHADER_TEETH_COLOR, ExpressiveParameters.teethColor);
			mesh.materials[0].SetFloat(OvrAvatarMaterialManager.AVATAR_SHADER_LIP_SMOOTHNESS, ExpressiveParameters.lipSmoothness);
		}
	}

	private void InitializeCombinedMaterial(IntPtr renderPart, int lodIndex)
	{
		ovrAvatarPBSMaterialState[] array = Oculus.Avatar.CAPI.ovrAvatar_GetBodyPBSMaterialStates(renderPart);
		if (array.Length != 5)
		{
			return;
		}
		avatarMaterialManager.CreateTextureArrays();
		OvrAvatarMaterialManager.AvatarComponentMaterialProperties[] componentMaterialProperties = avatarMaterialManager.LocalAvatarConfig.ComponentMaterialProperties;
		for (int i = 0; i < array.Length; i++)
		{
			componentMaterialProperties[i].TypeIndex = (ovrAvatarBodyPartType)i;
			componentMaterialProperties[i].Color = array[i].albedoMultiplier;
			componentMaterialProperties[i].DiffuseIntensity = OvrAvatarMaterialManager.DiffuseIntensities[i];
			componentMaterialProperties[i].RimIntensity = OvrAvatarMaterialManager.RimIntensities[i];
			componentMaterialProperties[i].ReflectionIntensity = OvrAvatarMaterialManager.ReflectionIntensities[i];
			Texture2D loadedTexture = OvrAvatarComponent.GetLoadedTexture(array[i].albedoTextureID);
			Texture2D loadedTexture2 = OvrAvatarComponent.GetLoadedTexture(array[i].normalTextureID);
			Texture2D loadedTexture3 = OvrAvatarComponent.GetLoadedTexture(array[i].metallicnessTextureID);
			if (loadedTexture != null)
			{
				componentMaterialProperties[i].Textures[0] = loadedTexture;
				avatarMaterialManager.AddTextureIDToTextureManager(array[i].albedoTextureID, isSingleComponent: false);
			}
			else
			{
				componentMaterialProperties[i].Textures[0] = OvrAvatarSDKManager.Instance.GetTextureCopyManager().FallbackTextureSets[lodIndex].DiffuseRoughness;
			}
			componentMaterialProperties[i].Textures[0].anisoLevel = 4;
			if (loadedTexture2 != null)
			{
				componentMaterialProperties[i].Textures[1] = loadedTexture2;
				avatarMaterialManager.AddTextureIDToTextureManager(array[i].normalTextureID, isSingleComponent: false);
			}
			else
			{
				componentMaterialProperties[i].Textures[1] = OvrAvatarSDKManager.Instance.GetTextureCopyManager().FallbackTextureSets[lodIndex].Normal;
			}
			componentMaterialProperties[i].Textures[1].anisoLevel = 4;
			if (loadedTexture3 != null)
			{
				componentMaterialProperties[i].Textures[2] = loadedTexture3;
				avatarMaterialManager.AddTextureIDToTextureManager(array[i].metallicnessTextureID, isSingleComponent: false);
			}
			else
			{
				componentMaterialProperties[i].Textures[2] = OvrAvatarSDKManager.Instance.GetTextureCopyManager().FallbackTextureSets[lodIndex].DiffuseRoughness;
			}
			componentMaterialProperties[i].Textures[2].anisoLevel = 16;
		}
		if (EnableExpressive)
		{
			mesh.materials[0].SetVector(OvrAvatarMaterialManager.AVATAR_SHADER_IRIS_COLOR, ExpressiveParameters.irisColor);
			mesh.materials[0].SetVector(OvrAvatarMaterialManager.AVATAR_SHADER_LIP_COLOR, ExpressiveParameters.lipColor);
			mesh.materials[0].SetVector(OvrAvatarMaterialManager.AVATAR_SHADER_BROW_COLOR, ExpressiveParameters.browColor);
			mesh.materials[0].SetVector(OvrAvatarMaterialManager.AVATAR_SHADER_LASH_COLOR, ExpressiveParameters.lashColor);
			mesh.materials[0].SetVector(OvrAvatarMaterialManager.AVATAR_SHADER_SCLERA_COLOR, ExpressiveParameters.scleraColor);
			mesh.materials[0].SetVector(OvrAvatarMaterialManager.AVATAR_SHADER_GUM_COLOR, ExpressiveParameters.gumColor);
			mesh.materials[0].SetVector(OvrAvatarMaterialManager.AVATAR_SHADER_TEETH_COLOR, ExpressiveParameters.teethColor);
			mesh.materials[0].SetFloat(OvrAvatarMaterialManager.AVATAR_SHADER_LIP_SMOOTHNESS, ExpressiveParameters.lipSmoothness);
		}
		avatarMaterialManager.ValidateTextures(array);
	}

	private void SetMaterialTransparent(Material mat)
	{
		mat.SetOverrideTag("Queue", "Transparent");
		mat.SetOverrideTag("RenderType", "Transparent");
		mat.SetInt("_SrcBlend", 5);
		mat.SetInt("_DstBlend", 10);
		mat.EnableKeyword("_ALPHATEST_ON");
		mat.EnableKeyword("_ALPHABLEND_ON");
		mat.EnableKeyword("_ALPHAPREMULTIPLY_ON");
		mat.renderQueue = 3000;
	}

	private void SetMaterialOpaque(Material mat)
	{
		mat.SetOverrideTag("Queue", "Geometry");
		mat.SetOverrideTag("RenderType", "Opaque");
		mat.SetInt("_SrcBlend", 1);
		mat.SetInt("_DstBlend", 0);
		mat.DisableKeyword("_ALPHATEST_ON");
		mat.DisableKeyword("_ALPHABLEND_ON");
		mat.DisableKeyword("_ALPHAPREMULTIPLY_ON");
		mat.renderQueue = 2000;
	}
}
public class OvrAvatarTextureCopyManager : MonoBehaviour
{
	[Serializable]
	public struct FallbackTextureSet
	{
		public bool Initialized;

		public Texture2D DiffuseRoughness;

		public Texture2D Normal;
	}

	private struct CopyTextureParams
	{
		public Texture Src;

		public Texture Dst;

		public int Mip;

		public int SrcSize;

		public int DstElement;

		public CopyTextureParams(Texture src, Texture dst, int mip, int srcSize, int dstElement)
		{
			Src = src;
			Dst = dst;
			Mip = mip;
			SrcSize = srcSize;
			DstElement = dstElement;
		}
	}

	public struct TextureSet
	{
		public Dictionary<ulong, bool> TextureIDSingleMeshPair;

		public bool IsProcessed;

		public TextureSet(Dictionary<ulong, bool> textureIDSingleMeshPair, bool isProcessed)
		{
			TextureIDSingleMeshPair = textureIDSingleMeshPair;
			IsProcessed = isProcessed;
		}
	}

	public FallbackTextureSet[] FallbackTextureSets = new FallbackTextureSet[6];

	private Queue<CopyTextureParams> texturesToCopy;

	private Dictionary<int, TextureSet> textureSets;

	private const int TEXTURES_TO_COPY_QUEUE_CAPACITY = 256;

	private const int COPIES_PER_FRAME = 8;

	private readonly string[] FALLBACK_TEXTURE_PATHS_DIFFUSE_ROUGHNESS = new string[6] { "null", "FallbackTextures/fallback_diffuse_roughness_256", "null", "FallbackTextures/fallback_diffuse_roughness_1024", "null", "FallbackTextures/fallback_diffuse_roughness_2048" };

	private readonly string[] FALLBACK_TEXTURE_PATHS_NORMAL = new string[6] { "null", "FallbackTextures/fallback_normal_256", "null", "FallbackTextures/fallback_normal_1024", "null", "FallbackTextures/fallback_normal_2048" };

	private const string PATH_HIGHEST_DIFFUSE_ROUGHNESS = "FallbackTextures/fallback_diffuse_roughness_2048";

	private const string PATH_MEDIUM_DIFFUSE_ROUGHNESS = "FallbackTextures/fallback_diffuse_roughness_1024";

	private const string PATH_LOWEST_DIFFUSE_ROUGHNESS = "FallbackTextures/fallback_diffuse_roughness_256";

	private const string PATH_HIGHEST_NORMAL = "FallbackTextures/fallback_normal_2048";

	private const string PATH_MEDIUM_NORMAL = "FallbackTextures/fallback_normal_1024";

	private const string PATH_LOWEST_NORMAL = "FallbackTextures/fallback_normal_256";

	private const int GPU_TEXTURE_COPY_WAIT_TIME = 10;

	public OvrAvatarTextureCopyManager()
	{
		texturesToCopy = new Queue<CopyTextureParams>(256);
		textureSets = new Dictionary<int, TextureSet>();
	}

	public void Update()
	{
		if (texturesToCopy.Count == 0)
		{
			return;
		}
		lock (texturesToCopy)
		{
			for (int i = 0; i < Mathf.Min(8, texturesToCopy.Count); i++)
			{
				CopyTexture(texturesToCopy.Dequeue());
			}
		}
	}

	public int GetTextureCount()
	{
		return texturesToCopy.Count;
	}

	public void CopyTexture(Texture src, Texture dst, int mipLevel, int mipSize, int dstElement, bool useQueue = true)
	{
		CopyTextureParams copyTextureParams = new CopyTextureParams(src, dst, mipLevel, mipSize, dstElement);
		if (useQueue)
		{
			lock (texturesToCopy)
			{
				if (texturesToCopy.Count < 256)
				{
					texturesToCopy.Enqueue(copyTextureParams);
				}
				else
				{
					CopyTexture(copyTextureParams);
				}
				return;
			}
		}
		CopyTexture(copyTextureParams);
	}

	private void CopyTexture(CopyTextureParams copyTextureParams)
	{
		Graphics.CopyTexture(copyTextureParams.Src, 0, copyTextureParams.Mip, copyTextureParams.Dst, copyTextureParams.DstElement, copyTextureParams.Mip);
	}

	public void AddTextureIDToTextureSet(int gameobjectID, ulong textureID, bool isSingleMesh)
	{
		bool value2;
		if (!textureSets.ContainsKey(gameobjectID))
		{
			TextureSet value = new TextureSet(new Dictionary<ulong, bool>(), isProcessed: false);
			value.TextureIDSingleMeshPair.Add(textureID, isSingleMesh);
			textureSets.Add(gameobjectID, value);
		}
		else if (textureSets[gameobjectID].TextureIDSingleMeshPair.TryGetValue(textureID, out value2))
		{
			if (!value2 && isSingleMesh)
			{
				textureSets[gameobjectID].TextureIDSingleMeshPair[textureID] = true;
			}
		}
		else
		{
			textureSets[gameobjectID].TextureIDSingleMeshPair.Add(textureID, isSingleMesh);
		}
	}

	public void DeleteTextureSet(int gameobjectID)
	{
		if (textureSets.TryGetValue(gameobjectID, out var value) && !value.IsProcessed)
		{
			StartCoroutine(DeleteTextureSetCoroutine(value, gameobjectID));
		}
	}

	private IEnumerator DeleteTextureSetCoroutine(TextureSet textureSetToDelete, int gameobjectID)
	{
		yield return new WaitForSeconds(10f);
		while (OvrAvatarSDKManager.Instance.IsAvatarLoading())
		{
			yield return null;
		}
		foreach (KeyValuePair<ulong, bool> item in textureSetToDelete.TextureIDSingleMeshPair)
		{
			bool flag = !item.Value;
			if (flag)
			{
				foreach (KeyValuePair<int, TextureSet> textureSet in textureSets)
				{
					if (textureSet.Key == gameobjectID)
					{
						continue;
					}
					foreach (KeyValuePair<ulong, bool> item2 in textureSet.Value.TextureIDSingleMeshPair)
					{
						if (item2.Key == item.Key && (!textureSet.Value.IsProcessed || item2.Value))
						{
							flag = false;
							break;
						}
					}
					if (!flag)
					{
						break;
					}
				}
			}
			if (flag)
			{
				Texture2D loadedTexture = OvrAvatarComponent.GetLoadedTexture(item.Key);
				if (loadedTexture != null)
				{
					OvrAvatarSDKManager.Instance.DeleteAssetFromCache(item.Key);
					UnityEngine.Object.Destroy(loadedTexture);
				}
			}
		}
		textureSetToDelete.IsProcessed = true;
		textureSets.Remove(gameobjectID);
	}

	public void CheckFallbackTextureSet(ovrAvatarAssetLevelOfDetail lod)
	{
		if (!FallbackTextureSets[(int)lod].Initialized)
		{
			InitFallbackTextureSet(lod);
		}
	}

	private void InitFallbackTextureSet(ovrAvatarAssetLevelOfDetail lod)
	{
		FallbackTextureSets[(int)lod].DiffuseRoughness = (FallbackTextureSets[(int)lod].DiffuseRoughness = Resources.Load<Texture2D>(FALLBACK_TEXTURE_PATHS_DIFFUSE_ROUGHNESS[(int)lod]));
		FallbackTextureSets[(int)lod].Normal = (FallbackTextureSets[(int)lod].Normal = Resources.Load<Texture2D>(FALLBACK_TEXTURE_PATHS_NORMAL[(int)lod]));
		FallbackTextureSets[(int)lod].Initialized = true;
	}
}
public class OvrAvatarTouchController : OvrAvatarComponent
{
	public bool isLeftHand = true;

	private ovrAvatarControllerComponent component;

	private void Update()
	{
		if (owner == null)
		{
			return;
		}
		bool flag = false;
		if ((!isLeftHand) ? Oculus.Avatar.CAPI.ovrAvatarPose_GetRightControllerComponent(owner.sdkAvatar, ref component) : Oculus.Avatar.CAPI.ovrAvatarPose_GetLeftControllerComponent(owner.sdkAvatar, ref component))
		{
			UpdateAvatar(component.renderComponent);
			return;
		}
		if (isLeftHand)
		{
			owner.ControllerLeft = null;
		}
		else
		{
			owner.ControllerRight = null;
		}
		UnityEngine.Object.Destroy(this);
	}
}
public class EnableSwitch : MonoBehaviour
{
	public GameObject[] SwitchTargets;

	public bool SetActive<T>(int target) where T : MonoBehaviour
	{
		if (target < 0 || target >= SwitchTargets.Length)
		{
			return false;
		}
		for (int i = 0; i < SwitchTargets.Length; i++)
		{
			SwitchTargets[i].SetActive(value: false);
			OVRLipSyncContextMorphTarget component = SwitchTargets[i].GetComponent<OVRLipSyncContextMorphTarget>();
			if ((bool)component)
			{
				component.enabled = false;
			}
			OVRLipSyncContextTextureFlip component2 = SwitchTargets[i].GetComponent<OVRLipSyncContextTextureFlip>();
			if ((bool)component2)
			{
				component2.enabled = false;
			}
		}
		SwitchTargets[target].SetActive(value: true);
		MonoBehaviour component3 = SwitchTargets[target].GetComponent<T>();
		if (component3 != null)
		{
			component3.enabled = true;
		}
		return true;
	}
}
public class LipSyncDemo_Control : MonoBehaviour
{
	[Tooltip("Key used to rotate the demo object up to 45 degrees to the left.")]
	public KeyCode rotateLeftKey = KeyCode.LeftArrow;

	[Tooltip("Key used to rotate the demo object up to 45 degrees to the right.")]
	public KeyCode rotateRightKey = KeyCode.RightArrow;

	[Tooltip("Key used to reset demo object rotation.")]
	public KeyCode resetRotationKey = KeyCode.DownArrow;

	private float resetRotation = 180f;

	private float rotationAmount = 20f;

	private float rotationMax = 45f;

	private void Start()
	{
	}

	private void Update()
	{
		if (Input.GetKey(rotateLeftKey))
		{
			RotateObject(rotationAmount);
		}
		else if (Input.GetKey(rotateRightKey))
		{
			RotateObject(0f - rotationAmount);
		}
		else if (Input.GetKey(resetRotationKey))
		{
			RotateObject(resetRotation, absolute: true);
		}
	}

	private void RotateObject(float amountDegrees, bool absolute = false)
	{
		GameObject gameObject = GameObject.Find("LipSyncMorphTarget_Female");
		if (gameObject == null)
		{
			gameObject = GameObject.Find("RobotHead_TextureFlip");
		}
		if (!gameObject)
		{
			return;
		}
		if (absolute)
		{
			float num = amountDegrees - gameObject.transform.eulerAngles.y;
			gameObject.transform.Rotate(Vector3.up * num);
			return;
		}
		float num2 = Time.deltaTime * amountDegrees;
		if (num2 + gameObject.transform.eulerAngles.y >= resetRotation - rotationMax && num2 + gameObject.transform.eulerAngles.y <= resetRotation + rotationMax)
		{
			gameObject.transform.Rotate(Vector3.up * num2);
		}
	}
}
public class LipSyncDemo_SetCurrentTarget : MonoBehaviour
{
	public EnableSwitch[] SwitchTargets;

	private int targetSet;

	private int maxTarget = 6;

	private bool XRButtonBeingPressed;

	private void Start()
	{
		OVRTouchpad.AddListener(LocalTouchEventCallback);
		targetSet = 0;
		SwitchTargets[0].SetActive<OVRLipSyncContextMorphTarget>(0);
		SwitchTargets[1].SetActive<OVRLipSyncContextMorphTarget>(0);
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.Alpha1))
		{
			targetSet = 0;
			SetCurrentTarget();
		}
		else if (Input.GetKeyDown(KeyCode.Alpha2))
		{
			targetSet = 1;
			SetCurrentTarget();
		}
		else if (Input.GetKeyDown(KeyCode.Alpha3))
		{
			targetSet = 2;
			SetCurrentTarget();
		}
		else if (Input.GetKeyDown(KeyCode.Alpha4))
		{
			targetSet = 3;
			SetCurrentTarget();
		}
		else if (Input.GetKeyDown(KeyCode.Alpha5))
		{
			targetSet = 4;
			SetCurrentTarget();
		}
		else if (Input.GetKeyDown(KeyCode.Alpha6))
		{
			targetSet = 5;
			SetCurrentTarget();
		}
		if (Input.GetKeyDown(KeyCode.Escape))
		{
			UnityEngine.Application.Quit();
		}
		List<InputDevice> list = new List<InputDevice>();
		InputDevices.GetDevicesWithCharacteristics(InputDeviceCharacteristics.HeldInHand, list);
		bool flag = false;
		bool flag2 = false;
		foreach (InputDevice item in list)
		{
			if (item.TryGetFeatureValue(CommonUsages.primaryButton, out var value) && value)
			{
				flag = true;
			}
			if (item.TryGetFeatureValue(CommonUsages.secondaryButton, out value) && value)
			{
				flag2 = true;
			}
		}
		if (flag && !XRButtonBeingPressed)
		{
			targetSet++;
			if (targetSet >= maxTarget)
			{
				targetSet = 0;
			}
			SetCurrentTarget();
		}
		if (flag2 && !XRButtonBeingPressed)
		{
			targetSet--;
			if (targetSet < 0)
			{
				targetSet = maxTarget - 1;
			}
			SetCurrentTarget();
		}
		XRButtonBeingPressed = flag || flag2;
	}

	private void SetCurrentTarget()
	{
		switch (targetSet)
		{
		case 0:
			SwitchTargets[0].SetActive<OVRLipSyncContextMorphTarget>(0);
			SwitchTargets[1].SetActive<OVRLipSyncContextMorphTarget>(0);
			break;
		case 1:
			SwitchTargets[0].SetActive<OVRLipSyncContextTextureFlip>(0);
			SwitchTargets[1].SetActive<OVRLipSyncContextTextureFlip>(1);
			break;
		case 2:
			SwitchTargets[0].SetActive<OVRLipSyncContextMorphTarget>(1);
			SwitchTargets[1].SetActive<OVRLipSyncContextMorphTarget>(2);
			break;
		case 3:
			SwitchTargets[0].SetActive<OVRLipSyncContextTextureFlip>(1);
			SwitchTargets[1].SetActive<OVRLipSyncContextTextureFlip>(3);
			break;
		case 4:
			SwitchTargets[0].SetActive<OVRLipSyncContextMorphTarget>(2);
			SwitchTargets[1].SetActive<OVRLipSyncContextMorphTarget>(4);
			break;
		case 5:
			SwitchTargets[0].SetActive<OVRLipSyncContextTextureFlip>(2);
			SwitchTargets[1].SetActive<OVRLipSyncContextTextureFlip>(5);
			break;
		}
		OVRLipSyncDebugConsole.Clear();
	}

	private void LocalTouchEventCallback(OVRTouchpad.TouchEvent touchEvent)
	{
		switch (touchEvent)
		{
		case OVRTouchpad.TouchEvent.Left:
			targetSet--;
			if (targetSet < 0)
			{
				targetSet = maxTarget - 1;
			}
			SetCurrentTarget();
			break;
		case OVRTouchpad.TouchEvent.Right:
			targetSet++;
			if (targetSet >= maxTarget)
			{
				targetSet = 0;
			}
			SetCurrentTarget();
			break;
		}
	}
}
public class OVRLipSyncDebugConsole : MonoBehaviour
{
	public ArrayList messages = new ArrayList();

	public int maxMessages = 15;

	public Text textMsg;

	private static OVRLipSyncDebugConsole s_Instance;

	private bool clearTimeoutOn;

	private float clearTimeout;

	public static OVRLipSyncDebugConsole instance
	{
		get
		{
			if (s_Instance == null)
			{
				s_Instance = UnityEngine.Object.FindObjectOfType(typeof(OVRLipSyncDebugConsole)) as OVRLipSyncDebugConsole;
				if (s_Instance == null)
				{
					GameObject obj = new GameObject();
					obj.AddComponent<OVRLipSyncDebugConsole>();
					obj.name = "OVRLipSyncDebugConsole";
					s_Instance = UnityEngine.Object.FindObjectOfType(typeof(OVRLipSyncDebugConsole)) as OVRLipSyncDebugConsole;
				}
			}
			return s_Instance;
		}
	}

	private void Awake()
	{
		s_Instance = this;
		Init();
	}

	private void Update()
	{
		if (clearTimeoutOn)
		{
			clearTimeout -= Time.deltaTime;
			if (clearTimeout < 0f)
			{
				Clear();
				clearTimeout = 0f;
				clearTimeoutOn = false;
			}
		}
	}

	public void Init()
	{
		if (textMsg == null)
		{
			UnityEngine.Debug.LogWarning("DebugConsole Init WARNING::UI text not set. Will not be able to display anything.");
		}
		Clear();
	}

	public static void Log(string message)
	{
		instance.AddMessage(message, Color.white);
	}

	public static void Log(string message, Color color)
	{
		instance.AddMessage(message, color);
	}

	public static void Clear()
	{
		instance.ClearMessages();
	}

	public static void ClearTimeout(float timeToClear)
	{
		instance.SetClearTimeout(timeToClear);
	}

	public void AddMessage(string message, Color color)
	{
		messages.Add(message);
		if (textMsg != null)
		{
			textMsg.color = color;
		}
		Display();
	}

	public void ClearMessages()
	{
		messages.Clear();
		Display();
	}

	public void SetClearTimeout(float timeout)
	{
		clearTimeout = timeout;
		clearTimeoutOn = true;
	}

	private void Prune()
	{
		if (messages.Count > maxMessages)
		{
			int count = ((messages.Count > 0) ? (messages.Count - maxMessages) : 0);
			messages.RemoveRange(0, count);
		}
	}

	private void Display()
	{
		if (messages.Count > maxMessages)
		{
			Prune();
		}
		if (textMsg != null)
		{
			textMsg.text = "";
			for (int i = 0; i < messages.Count; i++)
			{
				textMsg.text += (string)messages[i];
				textMsg.text += "\n";
			}
		}
	}
}
public class OVRNamedArrayAttribute : PropertyAttribute
{
	public readonly string[] names;

	public OVRNamedArrayAttribute(string[] names)
	{
		this.names = names;
	}
}
public static class OVRTouchpad
{
	public enum TouchEvent
	{
		SingleTap,
		DoubleTap,
		Left,
		Right,
		Up,
		Down
	}

	public delegate void OVRTouchpadCallback<TouchEvent>(TouchEvent arg);

	private static Vector3 moveAmountMouse;

	private static float minMovMagnitudeMouse = 25f;

	public static Delegate touchPadCallbacks = null;

	private static OVRTouchpadHelper touchpadHelper = new GameObject("OVRTouchpadHelper").AddComponent<OVRTouchpadHelper>();

	public static void Create()
	{
	}

	public static void Update()
	{
		if (Input.GetMouseButtonDown(0))
		{
			moveAmountMouse = Input.mousePosition;
		}
		else if (Input.GetMouseButtonUp(0))
		{
			moveAmountMouse -= Input.mousePosition;
			HandleInputMouse(ref moveAmountMouse);
		}
	}

	public static void OnDisable()
	{
	}

	private static void HandleInputMouse(ref Vector3 move)
	{
		if ((object)touchPadCallbacks == null)
		{
			return;
		}
		OVRTouchpadCallback<TouchEvent> oVRTouchpadCallback = touchPadCallbacks as OVRTouchpadCallback<TouchEvent>;
		if (move.magnitude < minMovMagnitudeMouse)
		{
			oVRTouchpadCallback(TouchEvent.SingleTap);
			return;
		}
		move.Normalize();
		if (Mathf.Abs(move.x) > Mathf.Abs(move.y))
		{
			if (move.x > 0f)
			{
				oVRTouchpadCallback(TouchEvent.Left);
			}
			else
			{
				oVRTouchpadCallback(TouchEvent.Right);
			}
		}
		else if (move.y > 0f)
		{
			oVRTouchpadCallback(TouchEvent.Down);
		}
		else
		{
			oVRTouchpadCallback(TouchEvent.Up);
		}
	}

	public static void AddListener(OVRTouchpadCallback<TouchEvent> handler)
	{
		touchPadCallbacks = (OVRTouchpadCallback<TouchEvent>)Delegate.Combine((OVRTouchpadCallback<TouchEvent>)touchPadCallbacks, handler);
	}
}
public sealed class OVRTouchpadHelper : MonoBehaviour
{
	private void Awake()
	{
		UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
	}

	private void Start()
	{
		OVRTouchpad.AddListener(LocalTouchEventCallback);
	}

	private void Update()
	{
		OVRTouchpad.Update();
	}

	public void OnDisable()
	{
		OVRTouchpad.OnDisable();
	}

	private void LocalTouchEventCallback(OVRTouchpad.TouchEvent touchEvent)
	{
		switch (touchEvent)
		{
		}
	}
}
public class OVRLipSync : MonoBehaviour
{
	public enum Result
	{
		Success = 0,
		Unknown = -2200,
		CannotCreateContext = -2201,
		InvalidParam = -2202,
		BadSampleRate = -2203,
		MissingDLL = -2204,
		BadVersion = -2205,
		UndefinedFunction = -2206
	}

	public enum AudioDataType
	{
		S16_Mono,
		S16_Stereo,
		F32_Mono,
		F32_Stereo
	}

	public enum Viseme
	{
		sil,
		PP,
		FF,
		TH,
		DD,
		kk,
		CH,
		SS,
		nn,
		RR,
		aa,
		E,
		ih,
		oh,
		ou
	}

	public enum Signals
	{
		VisemeOn,
		VisemeOff,
		VisemeAmount,
		VisemeSmoothing,
		LaughterAmount
	}

	public enum ContextProviders
	{
		Original,
		Enhanced,
		Enhanced_with_Laughter
	}

	[Serializable]
	public class Frame
	{
		public int frameNumber;

		public int frameDelay;

		public float[] Visemes = new float[VisemeCount];

		public float laughterScore;

		public void CopyInput(Frame input)
		{
			frameNumber = input.frameNumber;
			frameDelay = input.frameDelay;
			input.Visemes.CopyTo(Visemes, 0);
			laughterScore = input.laughterScore;
		}

		public void Reset()
		{
			frameNumber = 0;
			frameDelay = 0;
			Array.Clear(Visemes, 0, VisemeCount);
			laughterScore = 0f;
		}
	}

	public static readonly int VisemeCount = Enum.GetNames(typeof(Viseme)).Length;

	public static readonly int SignalCount = Enum.GetNames(typeof(Signals)).Length;

	public const string strOVRLS = "OVRLipSync";

	private static Result sInitialized = Result.Unknown;

	public static OVRLipSync sInstance = null;

	[DllImport("OVRLipSync")]
	private static extern int ovrLipSyncDll_Initialize(int samplerate, int buffersize);

	[DllImport("OVRLipSync")]
	private static extern void ovrLipSyncDll_Shutdown();

	[DllImport("OVRLipSync")]
	private static extern IntPtr ovrLipSyncDll_GetVersion(ref int Major, ref int Minor, ref int Patch);

	[DllImport("OVRLipSync")]
	private static extern int ovrLipSyncDll_CreateContextEx(ref uint context, ContextProviders provider, int sampleRate, bool enableAcceleration);

	[DllImport("OVRLipSync")]
	private static extern int ovrLipSyncDll_CreateContextWithModelFile(ref uint context, ContextProviders provider, string modelPath, int sampleRate, bool enableAcceleration);

	[DllImport("OVRLipSync")]
	private static extern int ovrLipSyncDll_DestroyContext(uint context);

	[DllImport("OVRLipSync")]
	private static extern int ovrLipSyncDll_ResetContext(uint context);

	[DllImport("OVRLipSync")]
	private static extern int ovrLipSyncDll_SendSignal(uint context, Signals signal, int arg1, int arg2);

	[DllImport("OVRLipSync")]
	private static extern int ovrLipSyncDll_ProcessFrameEx(uint context, IntPtr audioBuffer, uint bufferSize, AudioDataType dataType, ref int frameNumber, ref int frameDelay, float[] visemes, int visemeCount, ref float laughterScore, float[] laughterCategories, int laughterCategoriesLength);

	private void Awake()
	{
		if (sInstance == null)
		{
			sInstance = this;
			if (IsInitialized() != 0)
			{
				sInitialized = Initialize();
				if (sInitialized != 0)
				{
					UnityEngine.Debug.LogWarning($"OvrLipSync Awake: Failed to init Speech Rec library");
				}
			}
			OVRTouchpad.Create();
		}
		else
		{
			UnityEngine.Debug.LogWarning($"OVRLipSync Awake: Only one instance of OVRPLipSync can exist in the scene.");
		}
	}

	private void OnDestroy()
	{
		if (sInstance != this)
		{
			UnityEngine.Debug.LogWarning("OVRLipSync OnDestroy: This is not the correct OVRLipSync instance.");
		}
	}

	public static Result Initialize()
	{
		int outputSampleRate = AudioSettings.outputSampleRate;
		AudioSettings.GetDSPBufferSize(out var bufferLength, out var _);
		UnityEngine.Debug.LogWarning($"OvrLipSync Awake: Queried SampleRate: {outputSampleRate:F0} BufferSize: {bufferLength:F0}");
		sInitialized = (Result)ovrLipSyncDll_Initialize(outputSampleRate, bufferLength);
		return sInitialized;
	}

	public static Result Initialize(int sampleRate, int bufferSize)
	{
		UnityEngine.Debug.LogWarning($"OvrLipSync Awake: Queried SampleRate: {sampleRate:F0} BufferSize: {bufferSize:F0}");
		sInitialized = (Result)ovrLipSyncDll_Initialize(sampleRate, bufferSize);
		return sInitialized;
	}

	public static void Shutdown()
	{
		ovrLipSyncDll_Shutdown();
		sInitialized = Result.Unknown;
	}

	public static Result IsInitialized()
	{
		return sInitialized;
	}

	public static Result CreateContext(ref uint context, ContextProviders provider, int sampleRate = 0, bool enableAcceleration = false)
	{
		if (IsInitialized() != 0 && Initialize() != 0)
		{
			return Result.CannotCreateContext;
		}
		return (Result)ovrLipSyncDll_CreateContextEx(ref context, provider, sampleRate, enableAcceleration);
	}

	public static Result CreateContextWithModelFile(ref uint context, ContextProviders provider, string modelPath, int sampleRate = 0, bool enableAcceleration = false)
	{
		if (IsInitialized() != 0 && Initialize() != 0)
		{
			return Result.CannotCreateContext;
		}
		return (Result)ovrLipSyncDll_CreateContextWithModelFile(ref context, provider, modelPath, sampleRate, enableAcceleration);
	}

	public static Result DestroyContext(uint context)
	{
		if (IsInitialized() != 0)
		{
			return Result.Unknown;
		}
		return (Result)ovrLipSyncDll_DestroyContext(context);
	}

	public static Result ResetContext(uint context)
	{
		if (IsInitialized() != 0)
		{
			return Result.Unknown;
		}
		return (Result)ovrLipSyncDll_ResetContext(context);
	}

	public static Result SendSignal(uint context, Signals signal, int arg1, int arg2)
	{
		if (IsInitialized() != 0)
		{
			return Result.Unknown;
		}
		return (Result)ovrLipSyncDll_SendSignal(context, signal, arg1, arg2);
	}

	public static Result ProcessFrame(uint context, float[] audioBuffer, Frame frame, bool stereo = true)
	{
		if (IsInitialized() != 0)
		{
			return Result.Unknown;
		}
		AudioDataType dataType = (stereo ? AudioDataType.F32_Stereo : AudioDataType.F32_Mono);
		uint bufferSize = (uint)(stereo ? (audioBuffer.Length / 2) : audioBuffer.Length);
		GCHandle gCHandle = GCHandle.Alloc(audioBuffer, GCHandleType.Pinned);
		int result = ovrLipSyncDll_ProcessFrameEx(context, gCHandle.AddrOfPinnedObject(), bufferSize, dataType, ref frame.frameNumber, ref frame.frameDelay, frame.Visemes, frame.Visemes.Length, ref frame.laughterScore, null, 0);
		gCHandle.Free();
		return (Result)result;
	}

	public static Result ProcessFrame(uint context, short[] audioBuffer, Frame frame, bool stereo = true)
	{
		if (IsInitialized() != 0)
		{
			return Result.Unknown;
		}
		AudioDataType dataType = (stereo ? AudioDataType.S16_Stereo : AudioDataType.S16_Mono);
		uint bufferSize = (uint)(stereo ? (audioBuffer.Length / 2) : audioBuffer.Length);
		GCHandle gCHandle = GCHandle.Alloc(audioBuffer, GCHandleType.Pinned);
		int result = ovrLipSyncDll_ProcessFrameEx(context, gCHandle.AddrOfPinnedObject(), bufferSize, dataType, ref frame.frameNumber, ref frame.frameDelay, frame.Visemes, frame.Visemes.Length, ref frame.laughterScore, null, 0);
		gCHandle.Free();
		return (Result)result;
	}
}
[RequireComponent(typeof(AudioSource))]
public class OVRLipSyncContext : OVRLipSyncContextBase
{
	[Tooltip("Allow capturing of keyboard input to control operation.")]
	public bool enableKeyboardInput;

	[Tooltip("Register a mouse/touch callback to control loopback and gain (requires script restart).")]
	public bool enableTouchInput;

	[Tooltip("Play input audio back through audio output.")]
	public bool audioLoopback;

	[Tooltip("Key to toggle audio loopback.")]
	public KeyCode loopbackKey = KeyCode.L;

	[Tooltip("Show viseme scores in an OVRLipSyncDebugConsole display.")]
	public bool showVisemes;

	[Tooltip("Key to toggle viseme score display.")]
	public KeyCode debugVisemesKey = KeyCode.D;

	[Tooltip("Skip data from the Audio Source. Use if you intend to pass audio data in manually.")]
	public bool skipAudioSource;

	[Tooltip("Adjust the linear audio gain multiplier before processing lipsync")]
	public float gain = 1f;

	private bool hasDebugConsole;

	public KeyCode debugLaughterKey = KeyCode.H;

	public bool showLaughter;

	public float laughterScore;

	private void Start()
	{
		if (enableTouchInput)
		{
			OVRTouchpad.AddListener(LocalTouchEventCallback);
		}
		OVRLipSyncDebugConsole[] array = UnityEngine.Object.FindObjectsOfType<OVRLipSyncDebugConsole>();
		if (array.Length != 0)
		{
			hasDebugConsole = array[0];
		}
	}

	private void HandleKeyboard()
	{
		if (Input.GetKeyDown(loopbackKey))
		{
			ToggleAudioLoopback();
		}
		else if (Input.GetKeyDown(debugVisemesKey))
		{
			showVisemes = !showVisemes;
			if (showVisemes)
			{
				if (hasDebugConsole)
				{
					UnityEngine.Debug.Log("DEBUG SHOW VISEMES: ENABLED");
					return;
				}
				UnityEngine.Debug.LogWarning("Warning: No OVRLipSyncDebugConsole in the scene!");
				showVisemes = false;
			}
			else
			{
				if (hasDebugConsole)
				{
					OVRLipSyncDebugConsole.Clear();
				}
				UnityEngine.Debug.Log("DEBUG SHOW VISEMES: DISABLED");
			}
		}
		else if (Input.GetKeyDown(debugLaughterKey))
		{
			showLaughter = !showLaughter;
			if (showLaughter)
			{
				if (hasDebugConsole)
				{
					UnityEngine.Debug.Log("DEBUG SHOW LAUGHTER: ENABLED");
					return;
				}
				UnityEngine.Debug.LogWarning("Warning: No OVRLipSyncDebugConsole in the scene!");
				showLaughter = false;
			}
			else
			{
				if (hasDebugConsole)
				{
					OVRLipSyncDebugConsole.Clear();
				}
				UnityEngine.Debug.Log("DEBUG SHOW LAUGHTER: DISABLED");
			}
		}
		else if (Input.GetKeyDown(KeyCode.LeftArrow))
		{
			gain -= 1f;
			if (gain < 1f)
			{
				gain = 1f;
			}
			string text = "LINEAR GAIN: ";
			text += gain;
			if (hasDebugConsole)
			{
				OVRLipSyncDebugConsole.Clear();
				OVRLipSyncDebugConsole.Log(text);
				OVRLipSyncDebugConsole.ClearTimeout(1.5f);
			}
		}
		else if (Input.GetKeyDown(KeyCode.RightArrow))
		{
			gain += 1f;
			if (gain > 15f)
			{
				gain = 15f;
			}
			string text2 = "LINEAR GAIN: ";
			text2 += gain;
			if (hasDebugConsole)
			{
				OVRLipSyncDebugConsole.Clear();
				OVRLipSyncDebugConsole.Log(text2);
				OVRLipSyncDebugConsole.ClearTimeout(1.5f);
			}
		}
	}

	private void Update()
	{
		if (enableKeyboardInput)
		{
			HandleKeyboard();
		}
		laughterScore = base.Frame.laughterScore;
		DebugShowVisemesAndLaughter();
	}

	public void PreprocessAudioSamples(float[] data, int channels)
	{
		for (int i = 0; i < data.Length; i++)
		{
			data[i] *= gain;
		}
	}

	public void PostprocessAudioSamples(float[] data, int channels)
	{
		if (!audioLoopback)
		{
			for (int i = 0; i < data.Length; i++)
			{
				data[i] *= 0f;
			}
		}
	}

	public void ProcessAudioSamplesRaw(float[] data, int channels)
	{
		lock (this)
		{
			if (base.Context != 0 && OVRLipSync.IsInitialized() == OVRLipSync.Result.Success)
			{
				OVRLipSync.Frame frame = base.Frame;
				OVRLipSync.ProcessFrame(base.Context, data, frame, channels == 2);
			}
		}
	}

	public void ProcessAudioSamplesRaw(short[] data, int channels)
	{
		lock (this)
		{
			if (base.Context != 0 && OVRLipSync.IsInitialized() == OVRLipSync.Result.Success)
			{
				OVRLipSync.Frame frame = base.Frame;
				OVRLipSync.ProcessFrame(base.Context, data, frame, channels == 2);
			}
		}
	}

	public void ProcessAudioSamples(float[] data, int channels)
	{
		if (OVRLipSync.IsInitialized() == OVRLipSync.Result.Success && !(audioSource == null))
		{
			PreprocessAudioSamples(data, channels);
			ProcessAudioSamplesRaw(data, channels);
			PostprocessAudioSamples(data, channels);
		}
	}

	private void OnAudioFilterRead(float[] data, int channels)
	{
		if (!skipAudioSource)
		{
			ProcessAudioSamples(data, channels);
		}
	}

	private void DebugShowVisemesAndLaughter()
	{
		if (!hasDebugConsole)
		{
			return;
		}
		string text = "";
		if (showLaughter)
		{
			text += "Laughter:";
			int num = (int)(50f * base.Frame.laughterScore);
			for (int i = 0; i < num; i++)
			{
				text += "*";
			}
			text += "\n";
		}
		if (showVisemes)
		{
			for (int j = 0; j < base.Frame.Visemes.Length; j++)
			{
				string text2 = text;
				OVRLipSync.Viseme viseme = (OVRLipSync.Viseme)j;
				text = text2 + viseme;
				text += ":";
				int num2 = (int)(50f * base.Frame.Visemes[j]);
				for (int k = 0; k < num2; k++)
				{
					text += "*";
				}
				text += "\n";
			}
		}
		OVRLipSyncDebugConsole.Clear();
		if (text != "")
		{
			OVRLipSyncDebugConsole.Log(text);
		}
	}

	private void ToggleAudioLoopback()
	{
		audioLoopback = !audioLoopback;
		if (hasDebugConsole)
		{
			OVRLipSyncDebugConsole.Clear();
			OVRLipSyncDebugConsole.ClearTimeout(1.5f);
			if (audioLoopback)
			{
				OVRLipSyncDebugConsole.Log("LOOPBACK MODE: ENABLED");
			}
			else
			{
				OVRLipSyncDebugConsole.Log("LOOPBACK MODE: DISABLED");
			}
		}
	}

	private void LocalTouchEventCallback(OVRTouchpad.TouchEvent touchEvent)
	{
		string text = "LINEAR GAIN: ";
		switch (touchEvent)
		{
		case OVRTouchpad.TouchEvent.SingleTap:
			ToggleAudioLoopback();
			break;
		case OVRTouchpad.TouchEvent.Up:
			gain += 1f;
			if (gain > 15f)
			{
				gain = 15f;
			}
			text += gain;
			if (hasDebugConsole)
			{
				OVRLipSyncDebugConsole.Clear();
				OVRLipSyncDebugConsole.Log(text);
				OVRLipSyncDebugConsole.ClearTimeout(1.5f);
			}
			break;
		case OVRTouchpad.TouchEvent.Down:
			gain -= 1f;
			if (gain < 1f)
			{
				gain = 1f;
			}
			text += gain;
			if (hasDebugConsole)
			{
				OVRLipSyncDebugConsole.Clear();
				OVRLipSyncDebugConsole.Log(text);
				OVRLipSyncDebugConsole.ClearTimeout(1.5f);
			}
			break;
		}
	}
}
[RequireComponent(typeof(AudioSource))]
public class OVRLipSyncContextBase : MonoBehaviour
{
	public AudioSource audioSource;

	[Tooltip("Which lip sync provider to use for viseme computation.")]
	public OVRLipSync.ContextProviders provider = OVRLipSync.ContextProviders.Enhanced;

	[Tooltip("Enable DSP offload on supported Android devices.")]
	public bool enableAcceleration = true;

	private OVRLipSync.Frame frame = new OVRLipSync.Frame();

	private uint context;

	private int _smoothing;

	public int Smoothing
	{
		get
		{
			return _smoothing;
		}
		set
		{
			switch (OVRLipSync.SendSignal(context, OVRLipSync.Signals.VisemeSmoothing, value, 0))
			{
			case OVRLipSync.Result.InvalidParam:
				UnityEngine.Debug.LogError("OVRLipSyncContextBase.SetSmoothing: A viseme smoothing parameter is invalid, it should be between 1 and 100!");
				break;
			default:
				UnityEngine.Debug.LogError("OVRLipSyncContextBase.SetSmoothing: An unexpected error occured.");
				break;
			case OVRLipSync.Result.Success:
				break;
			}
			_smoothing = value;
		}
	}

	public uint Context => context;

	protected OVRLipSync.Frame Frame => frame;

	private void Awake()
	{
		if (!audioSource)
		{
			audioSource = GetComponent<AudioSource>();
		}
		lock (this)
		{
			if (context == 0 && OVRLipSync.CreateContext(ref context, provider, 0, enableAcceleration) != 0)
			{
				UnityEngine.Debug.LogError("OVRLipSyncContextBase.Start ERROR: Could not create Phoneme context.");
			}
		}
	}

	private void OnDestroy()
	{
		lock (this)
		{
			if (context != 0 && OVRLipSync.DestroyContext(context) != 0)
			{
				UnityEngine.Debug.LogError("OVRLipSyncContextBase.OnDestroy ERROR: Could not delete Phoneme context.");
			}
		}
	}

	public OVRLipSync.Frame GetCurrentPhonemeFrame()
	{
		return frame;
	}

	public void SetVisemeBlend(int viseme, int amount)
	{
		switch (OVRLipSync.SendSignal(context, OVRLipSync.Signals.VisemeAmount, viseme, amount))
		{
		case OVRLipSync.Result.InvalidParam:
			UnityEngine.Debug.LogError("OVRLipSyncContextBase.SetVisemeBlend: Viseme ID is invalid.");
			break;
		default:
			UnityEngine.Debug.LogError("OVRLipSyncContextBase.SetVisemeBlend: An unexpected error occured.");
			break;
		case OVRLipSync.Result.Success:
			break;
		}
	}

	public void SetLaughterBlend(int amount)
	{
		if (OVRLipSync.SendSignal(context, OVRLipSync.Signals.LaughterAmount, amount, 0) != 0)
		{
			UnityEngine.Debug.LogError("OVRLipSyncContextBase.SetLaughterBlend: An unexpected error occured.");
		}
	}

	public OVRLipSync.Result ResetContext()
	{
		frame.Reset();
		return OVRLipSync.ResetContext(context);
	}
}
[RequireComponent(typeof(AudioSource))]
public class OVRLipSyncContextCanned : OVRLipSyncContextBase
{
	[Tooltip("Pre-computed viseme sequence asset. Compute from audio in Unity with Tools -> Oculus -> Generate Lip Sync Assets.")]
	public OVRLipSyncSequence currentSequence;

	private void Update()
	{
		if (audioSource.isPlaying && currentSequence != null)
		{
			OVRLipSync.Frame frameAtTime = currentSequence.GetFrameAtTime(audioSource.time);
			base.Frame.CopyInput(frameAtTime);
		}
	}
}
public class OVRLipSyncContextMorphTarget : MonoBehaviour
{
	[Tooltip("Skinned Mesh Rendered target to be driven by Oculus Lipsync")]
	public SkinnedMeshRenderer skinnedMeshRenderer;

	[Tooltip("Blendshape index to trigger for each viseme.")]
	public int[] visemeToBlendTargets = Enumerable.Range(0, OVRLipSync.VisemeCount).ToArray();

	[Tooltip("Enable using the test keys defined below to manually trigger each viseme.")]
	public bool enableVisemeTestKeys;

	[Tooltip("Test keys used to manually trigger an individual viseme - by default the QWERTY row of a US keyboard.")]
	public KeyCode[] visemeTestKeys = new KeyCode[15]
	{
		KeyCode.BackQuote,
		KeyCode.Tab,
		KeyCode.Q,
		KeyCode.W,
		KeyCode.E,
		KeyCode.R,
		KeyCode.T,
		KeyCode.Y,
		KeyCode.U,
		KeyCode.I,
		KeyCode.O,
		KeyCode.P,
		KeyCode.LeftBracket,
		KeyCode.RightBracket,
		KeyCode.Backslash
	};

	[Tooltip("Test key used to manually trigger laughter and visualise the results")]
	public KeyCode laughterKey = KeyCode.CapsLock;

	[Tooltip("Blendshape index to trigger for laughter")]
	public int laughterBlendTarget = OVRLipSync.VisemeCount;

	[Range(0f, 1f)]
	[Tooltip("Laughter probability threshold above which the laughter blendshape will be activated")]
	public float laughterThreshold = 0.5f;

	[Range(0f, 3f)]
	[Tooltip("Laughter animation linear multiplier, the final output will be clamped to 1.0")]
	public float laughterMultiplier = 1.5f;

	[Range(1f, 100f)]
	[Tooltip("Smoothing of 1 will yield only the current predicted viseme, 100 will yield an extremely smooth viseme response.")]
	public int smoothAmount = 70;

	private OVRLipSyncContextBase lipsyncContext;

	private void Start()
	{
		if (skinnedMeshRenderer == null)
		{
			UnityEngine.Debug.LogError("LipSyncContextMorphTarget.Start Error: Please set the target Skinned Mesh Renderer to be controlled!");
			return;
		}
		lipsyncContext = GetComponent<OVRLipSyncContextBase>();
		if (lipsyncContext == null)
		{
			UnityEngine.Debug.LogError("LipSyncContextMorphTarget.Start Error: No OVRLipSyncContext component on this object!");
		}
		else
		{
			lipsyncContext.Smoothing = smoothAmount;
		}
	}

	private void Update()
	{
		if (lipsyncContext != null && skinnedMeshRenderer != null)
		{
			OVRLipSync.Frame currentPhonemeFrame = lipsyncContext.GetCurrentPhonemeFrame();
			if (currentPhonemeFrame != null)
			{
				SetVisemeToMorphTarget(currentPhonemeFrame);
				SetLaughterToMorphTarget(currentPhonemeFrame);
			}
			CheckForKeys();
			if (smoothAmount != lipsyncContext.Smoothing)
			{
				lipsyncContext.Smoothing = smoothAmount;
			}
		}
	}

	private void CheckForKeys()
	{
		if (enableVisemeTestKeys)
		{
			for (int i = 0; i < OVRLipSync.VisemeCount; i++)
			{
				CheckVisemeKey(visemeTestKeys[i], i, 100);
			}
		}
		CheckLaughterKey();
	}

	private void SetVisemeToMorphTarget(OVRLipSync.Frame frame)
	{
		for (int i = 0; i < visemeToBlendTargets.Length; i++)
		{
			if (visemeToBlendTargets[i] != -1)
			{
				skinnedMeshRenderer.SetBlendShapeWeight(visemeToBlendTargets[i], frame.Visemes[i] * 100f);
			}
		}
	}

	private void SetLaughterToMorphTarget(OVRLipSync.Frame frame)
	{
		if (laughterBlendTarget != -1)
		{
			float laughterScore = frame.laughterScore;
			laughterScore = ((laughterScore < laughterThreshold) ? 0f : (laughterScore - laughterThreshold));
			laughterScore = Mathf.Min(laughterScore * laughterMultiplier, 1f);
			laughterScore *= 1f / laughterThreshold;
			skinnedMeshRenderer.SetBlendShapeWeight(laughterBlendTarget, laughterScore * 100f);
		}
	}

	private void CheckVisemeKey(KeyCode key, int viseme, int amount)
	{
		if (Input.GetKeyDown(key))
		{
			lipsyncContext.SetVisemeBlend(visemeToBlendTargets[viseme], amount);
		}
		if (Input.GetKeyUp(key))
		{
			lipsyncContext.SetVisemeBlend(visemeToBlendTargets[viseme], 0);
		}
	}

	private void CheckLaughterKey()
	{
		if (Input.GetKeyDown(laughterKey))
		{
			lipsyncContext.SetLaughterBlend(100);
		}
		if (Input.GetKeyUp(laughterKey))
		{
			lipsyncContext.SetLaughterBlend(0);
		}
	}
}
public class OVRLipSyncContextTextureFlip : MonoBehaviour
{
	public Material material;

	[Tooltip("The texture used for each viseme.")]
	[OVRNamedArray(new string[]
	{
		"sil", "PP", "FF", "TH", "DD", "kk", "CH", "SS", "nn", "RR",
		"aa", "E", "ih", "oh", "ou"
	})]
	public Texture[] Textures = new Texture[OVRLipSync.VisemeCount];

	[Range(1f, 100f)]
	[Tooltip("Smoothing of 1 will yield only the current predicted viseme,100 will yield an extremely smooth viseme response.")]
	public int smoothAmount = 70;

	private OVRLipSyncContextBase lipsyncContext;

	private OVRLipSync.Frame oldFrame = new OVRLipSync.Frame();

	private void Start()
	{
		lipsyncContext = GetComponent<OVRLipSyncContextBase>();
		if (lipsyncContext == null)
		{
			UnityEngine.Debug.LogWarning("LipSyncContextTextureFlip.Start WARNING: No lip sync context component set to object");
		}
		else
		{
			lipsyncContext.Smoothing = smoothAmount;
		}
		if (material == null)
		{
			UnityEngine.Debug.LogWarning("LipSyncContextTextureFlip.Start WARNING: Lip sync context texture flip has no material target to control!");
		}
	}

	private void Update()
	{
		if (lipsyncContext != null && material != null)
		{
			OVRLipSync.Frame currentPhonemeFrame = lipsyncContext.GetCurrentPhonemeFrame();
			if (currentPhonemeFrame != null)
			{
				if (lipsyncContext.provider == OVRLipSync.ContextProviders.Original)
				{
					for (int i = 0; i < currentPhonemeFrame.Visemes.Length; i++)
					{
						float num = (float)(smoothAmount - 1) / 100f;
						oldFrame.Visemes[i] = oldFrame.Visemes[i] * num + currentPhonemeFrame.Visemes[i] * (1f - num);
					}
				}
				else
				{
					oldFrame.Visemes = currentPhonemeFrame.Visemes;
				}
				SetVisemeToTexture();
			}
		}
		if (smoothAmount != lipsyncContext.Smoothing)
		{
			lipsyncContext.Smoothing = smoothAmount;
		}
	}

	private void SetVisemeToTexture()
	{
		int num = -1;
		float num2 = 0f;
		for (int i = 0; i < oldFrame.Visemes.Length; i++)
		{
			if (oldFrame.Visemes[i] > num2)
			{
				num = i;
				num2 = oldFrame.Visemes[i];
			}
		}
		if (num != -1 && num < Textures.Length)
		{
			Texture texture = Textures[num];
			if (texture != null)
			{
				material.SetTexture("_MainTex", texture);
			}
		}
	}
}
[RequireComponent(typeof(AudioSource))]
public class OVRLipSyncMicInput : MonoBehaviour
{
	public enum micActivation
	{
		HoldToSpeak,
		PushToSpeak,
		ConstantSpeak
	}

	[Tooltip("Manual specification of Audio Source - by default will use any attached to the same object.")]
	public AudioSource audioSource;

	[Tooltip("Enable a keypress to toggle the microphone device selection GUI.")]
	public bool enableMicSelectionGUI;

	[Tooltip("Key to toggle the microphone selection GUI if enabled.")]
	public KeyCode micSelectionGUIKey = KeyCode.M;

	[SerializeField]
	[Range(0f, 100f)]
	[Tooltip("Microphone input volume control.")]
	private float micInputVolume = 100f;

	[SerializeField]
	[Tooltip("Requested microphone input frequency")]
	private int micFrequency = 48000;

	[Tooltip("Microphone input control method. Hold To Speak and Push To Speak are driven with the Mic Activation Key.")]
	public micActivation micControl = micActivation.ConstantSpeak;

	[Tooltip("Key used to drive Hold To Speak and Push To Speak methods of microphone input control.")]
	public KeyCode micActivationKey = KeyCode.Space;

	[Tooltip("Will contain the string name of the selected microphone device - read only.")]
	public string selectedDevice;

	private bool micSelected;

	private int minFreq;

	private int maxFreq;

	private bool focused = true;

	private bool initialized;

	public float MicFrequency
	{
		get
		{
			return micFrequency;
		}
		set
		{
			micFrequency = (int)Mathf.Clamp(value, 0f, 96000f);
		}
	}

	private void Awake()
	{
		if (!audioSource)
		{
			audioSource = GetComponent<AudioSource>();
		}
		_ = (bool)audioSource;
	}

	private void Start()
	{
		audioSource.loop = true;
		audioSource.mute = false;
		InitializeMicrophone();
	}

	private void InitializeMicrophone()
	{
	}

	private void Update()
	{
	}

	private void OnApplicationFocus(bool focus)
	{
		focused = focus;
		if (!focused)
		{
			StopMicrophone();
		}
	}

	private void OnApplicationPause(bool pauseStatus)
	{
		focused = !pauseStatus;
		if (!focused)
		{
			StopMicrophone();
		}
	}

	private void OnDisable()
	{
		StopMicrophone();
	}

	private void OnGUI()
	{
		MicDeviceGUI(Screen.width / 2 - 150, Screen.height / 2 - 75, 300f, 50f, 10f, -300f);
	}

	public void MicDeviceGUI(float left, float top, float width, float height, float buttonSpaceTop, float buttonSpaceLeft)
	{
	}

	public void GetMicCaps()
	{
	}

	public void StartMicrophone()
	{
	}

	public void StopMicrophone()
	{
	}

	private float GetAveragedVolume()
	{
		return 0f;
	}
}
[Serializable]
public class OVRLipSyncSequence : ScriptableObject
{
	public List<OVRLipSync.Frame> entries = new List<OVRLipSync.Frame>();

	public float length;

	public OVRLipSync.Frame GetFrameAtTime(float time)
	{
		OVRLipSync.Frame result = null;
		if (time < length && entries.Count > 0)
		{
			float num = time / length;
			result = entries[(int)((float)entries.Count * num)];
		}
		return result;
	}
}
public class DebugUIBuilder : MonoBehaviour
{
	public delegate void OnClick();

	public delegate void OnToggleValueChange(Toggle t);

	public delegate void OnSlider(float f);

	public delegate bool ActiveUpdate();

	public const int DEBUG_PANE_CENTER = 0;

	public const int DEBUG_PANE_RIGHT = 1;

	public const int DEBUG_PANE_LEFT = 2;

	[SerializeField]
	private RectTransform buttonPrefab;

	[SerializeField]
	private RectTransform labelPrefab;

	[SerializeField]
	private RectTransform sliderPrefab;

	[SerializeField]
	private RectTransform dividerPrefab;

	[SerializeField]
	private RectTransform togglePrefab;

	[SerializeField]
	private RectTransform radioPrefab;

	[SerializeField]
	private GameObject uiHelpersToInstantiate;

	[SerializeField]
	private Transform[] targetContentPanels;

	private bool[] reEnable;

	[SerializeField]
	private List<GameObject> toEnable;

	[SerializeField]
	private List<GameObject> toDisable;

	public static DebugUIBuilder instance;

	private const float elementSpacing = 16f;

	private const float marginH = 16f;

	private const float marginV = 16f;

	private Vector2[] insertPositions;

	private List<RectTransform>[] insertedElements;

	private Vector3 menuOffset;

	private OVRCameraRig rig;

	private Dictionary<string, ToggleGroup> radioGroups = new Dictionary<string, ToggleGroup>();

	private LaserPointer lp;

	private LineRenderer lr;

	public LaserPointer.LaserBeamBehavior laserBeamBehavior;

	public void Awake()
	{
		instance = this;
		menuOffset = base.transform.position;
		base.gameObject.SetActive(value: false);
		rig = UnityEngine.Object.FindObjectOfType<OVRCameraRig>();
		for (int i = 0; i < toEnable.Count; i++)
		{
			toEnable[i].SetActive(value: false);
		}
		insertPositions = new Vector2[targetContentPanels.Length];
		for (int j = 0; j < insertPositions.Length; j++)
		{
			insertPositions[j].x = 16f;
			insertPositions[j].y = -16f;
		}
		insertedElements = new List<RectTransform>[targetContentPanels.Length];
		for (int k = 0; k < insertedElements.Length; k++)
		{
			insertedElements[k] = new List<RectTransform>();
		}
		if ((bool)uiHelpersToInstantiate)
		{
			UnityEngine.Object.Instantiate(uiHelpersToInstantiate);
		}
		lp = UnityEngine.Object.FindObjectOfType<LaserPointer>();
		if (!lp)
		{
			UnityEngine.Debug.LogError("Debug UI requires use of a LaserPointer and will not function without it. Add one to your scene, or assign the UIHelpers prefab to the DebugUIBuilder in the inspector.");
			return;
		}
		lp.laserBeamBehavior = laserBeamBehavior;
		if (!toEnable.Contains(lp.gameObject))
		{
			toEnable.Add(lp.gameObject);
		}
		GetComponent<OVRRaycaster>().pointer = lp.gameObject;
		lp.gameObject.SetActive(value: false);
	}

	public void Show()
	{
		Relayout();
		base.gameObject.SetActive(value: true);
		base.transform.position = rig.transform.TransformPoint(menuOffset);
		Vector3 eulerAngles = rig.transform.rotation.eulerAngles;
		eulerAngles.x = 0f;
		eulerAngles.z = 0f;
		base.transform.eulerAngles = eulerAngles;
		if (reEnable == null || reEnable.Length < toDisable.Count)
		{
			reEnable = new bool[toDisable.Count];
		}
		reEnable.Initialize();
		int count = toDisable.Count;
		for (int i = 0; i < count; i++)
		{
			if ((bool)toDisable[i])
			{
				reEnable[i] = toDisable[i].activeSelf;
				toDisable[i].SetActive(value: false);
			}
		}
		count = toEnable.Count;
		for (int j = 0; j < count; j++)
		{
			toEnable[j].SetActive(value: true);
		}
		int num = targetContentPanels.Length;
		for (int k = 0; k < num; k++)
		{
			targetContentPanels[k].gameObject.SetActive(insertedElements[k].Count > 0);
		}
	}

	public void Hide()
	{
		base.gameObject.SetActive(value: false);
		for (int i = 0; i < reEnable.Length; i++)
		{
			if ((bool)toDisable[i] && reEnable[i])
			{
				toDisable[i].SetActive(value: true);
			}
		}
		int count = toEnable.Count;
		for (int j = 0; j < count; j++)
		{
			toEnable[j].SetActive(value: false);
		}
	}

	private void Relayout()
	{
		for (int i = 0; i < targetContentPanels.Length; i++)
		{
			RectTransform component = targetContentPanels[i].GetComponent<RectTransform>();
			List<RectTransform> list = insertedElements[i];
			int count = list.Count;
			float x = 16f;
			float num = -16f;
			float num2 = 0f;
			for (int j = 0; j < count; j++)
			{
				RectTransform rectTransform = list[j];
				rectTransform.anchoredPosition = new Vector2(x, num);
				num -= rectTransform.rect.height + 16f;
				num2 = Mathf.Max(rectTransform.rect.width + 32f, num2);
			}
			component.SetSizeWithCurrentAnchors(RectTransform.Axis.Horizontal, num2);
			component.SetSizeWithCurrentAnchors(RectTransform.Axis.Vertical, 0f - num + 16f);
		}
	}

	private void AddRect(RectTransform r, int targetCanvas)
	{
		if (targetCanvas > targetContentPanels.Length)
		{
			UnityEngine.Debug.LogError("Attempted to add debug panel to canvas " + targetCanvas + ", but only " + targetContentPanels.Length + " panels were provided. Fix in the inspector or pass a lower value for target canvas.");
		}
		else
		{
			r.transform.SetParent(targetContentPanels[targetCanvas], worldPositionStays: false);
			insertedElements[targetCanvas].Add(r);
			if (base.gameObject.activeInHierarchy)
			{
				Relayout();
			}
		}
	}

	public RectTransform AddButton(string label, OnClick handler, int targetCanvas = 0)
	{
		RectTransform component = UnityEngine.Object.Instantiate(buttonPrefab).GetComponent<RectTransform>();
		component.GetComponentInChildren<Button>().onClick.AddListener(delegate
		{
			handler();
		});
		((Text)component.GetComponentsInChildren(typeof(Text), includeInactive: true)[0]).text = label;
		AddRect(component, targetCanvas);
		return component;
	}

	public RectTransform AddLabel(string label, int targetCanvas = 0)
	{
		RectTransform component = UnityEngine.Object.Instantiate(labelPrefab).GetComponent<RectTransform>();
		component.GetComponent<Text>().text = label;
		AddRect(component, targetCanvas);
		return component;
	}

	public RectTransform AddSlider(string label, float min, float max, OnSlider onValueChanged, bool wholeNumbersOnly = false, int targetCanvas = 0)
	{
		RectTransform rectTransform = UnityEngine.Object.Instantiate(sliderPrefab);
		Slider componentInChildren = rectTransform.GetComponentInChildren<Slider>();
		componentInChildren.minValue = min;
		componentInChildren.maxValue = max;
		componentInChildren.onValueChanged.AddListener(delegate(float f)
		{
			onValueChanged(f);
		});
		componentInChildren.wholeNumbers = wholeNumbersOnly;
		AddRect(rectTransform, targetCanvas);
		return rectTransform;
	}

	public RectTransform AddDivider(int targetCanvas = 0)
	{
		RectTransform rectTransform = UnityEngine.Object.Instantiate(dividerPrefab);
		AddRect(rectTransform, targetCanvas);
		return rectTransform;
	}

	public RectTransform AddToggle(string label, OnToggleValueChange onValueChanged, int targetCanvas = 0)
	{
		RectTransform rectTransform = UnityEngine.Object.Instantiate(togglePrefab);
		AddRect(rectTransform, targetCanvas);
		rectTransform.GetComponentInChildren<Text>().text = label;
		Toggle t = rectTransform.GetComponentInChildren<Toggle>();
		t.onValueChanged.AddListener(delegate
		{
			onValueChanged(t);
		});
		return rectTransform;
	}

	public RectTransform AddToggle(string label, OnToggleValueChange onValueChanged, bool defaultValue, int targetCanvas = 0)
	{
		RectTransform rectTransform = UnityEngine.Object.Instantiate(togglePrefab);
		AddRect(rectTransform, targetCanvas);
		rectTransform.GetComponentInChildren<Text>().text = label;
		Toggle t = rectTransform.GetComponentInChildren<Toggle>();
		t.isOn = defaultValue;
		t.onValueChanged.AddListener(delegate
		{
			onValueChanged(t);
		});
		return rectTransform;
	}

	public RectTransform AddRadio(string label, string group, OnToggleValueChange handler, int targetCanvas = 0)
	{
		RectTransform rectTransform = UnityEngine.Object.Instantiate(radioPrefab);
		AddRect(rectTransform, targetCanvas);
		rectTransform.GetComponentInChildren<Text>().text = label;
		Toggle tb = rectTransform.GetComponentInChildren<Toggle>();
		if (group == null)
		{
			group = "default";
		}
		ToggleGroup toggleGroup = null;
		bool isOn = false;
		if (!radioGroups.ContainsKey(group))
		{
			toggleGroup = tb.gameObject.AddComponent<ToggleGroup>();
			radioGroups[group] = toggleGroup;
			isOn = true;
		}
		else
		{
			toggleGroup = radioGroups[group];
		}
		tb.group = toggleGroup;
		tb.isOn = isOn;
		tb.onValueChanged.AddListener(delegate
		{
			handler(tb);
		});
		return rectTransform;
	}

	public void ToggleLaserPointer(bool isOn)
	{
		if ((bool)lp)
		{
			if (isOn)
			{
				lp.enabled = true;
			}
			else
			{
				lp.enabled = false;
			}
		}
	}
}
public class HandedInputSelector : MonoBehaviour
{
	private OVRCameraRig m_CameraRig;

	private OVRInputModule m_InputModule;

	private void Start()
	{
		m_CameraRig = UnityEngine.Object.FindObjectOfType<OVRCameraRig>();
		m_InputModule = UnityEngine.Object.FindObjectOfType<OVRInputModule>();
	}

	private void Update()
	{
		if (OVRInput.GetActiveController() == OVRInput.Controller.LTouch)
		{
			SetActiveController(OVRInput.Controller.LTouch);
		}
		else
		{
			SetActiveController(OVRInput.Controller.RTouch);
		}
	}

	private void SetActiveController(OVRInput.Controller c)
	{
		Transform rayTransform = ((c != OVRInput.Controller.LTouch) ? m_CameraRig.rightHandAnchor : m_CameraRig.leftHandAnchor);
		m_InputModule.rayTransform = rayTransform;
	}
}
public class LaserPointer : OVRCursor
{
	public enum LaserBeamBehavior
	{
		On,
		Off,
		OnWhenHitTarget
	}

	public GameObject cursorVisual;

	public float maxLength = 10f;

	private LaserBeamBehavior _laserBeamBehavior;

	private bool m_restoreOnInputAcquired;

	private Vector3 _startPoint;

	private Vector3 _forward;

	private Vector3 _endPoint;

	private bool _hitTarget;

	private LineRenderer lineRenderer;

	public LaserBeamBehavior laserBeamBehavior
	{
		get
		{
			return _laserBeamBehavior;
		}
		set
		{
			_laserBeamBehavior = value;
			if (laserBeamBehavior == LaserBeamBehavior.Off || laserBeamBehavior == LaserBeamBehavior.OnWhenHitTarget)
			{
				lineRenderer.enabled = false;
			}
			else
			{
				lineRenderer.enabled = true;
			}
		}
	}

	private void Awake()
	{
		lineRenderer = GetComponent<LineRenderer>();
	}

	private void Start()
	{
		if ((bool)cursorVisual)
		{
			cursorVisual.SetActive(value: false);
		}
		OVRManager.InputFocusAcquired += OnInputFocusAcquired;
		OVRManager.InputFocusLost += OnInputFocusLost;
	}

	public override void SetCursorStartDest(Vector3 start, Vector3 dest, Vector3 normal)
	{
		_startPoint = start;
		_endPoint = dest;
		_hitTarget = true;
	}

	public override void SetCursorRay(Transform t)
	{
		_startPoint = t.position;
		_forward = t.forward;
		_hitTarget = false;
	}

	private void LateUpdate()
	{
		lineRenderer.SetPosition(0, _startPoint);
		if (_hitTarget)
		{
			lineRenderer.SetPosition(1, _endPoint);
			UpdateLaserBeam(_startPoint, _endPoint);
			if ((bool)cursorVisual)
			{
				cursorVisual.transform.position = _endPoint;
				cursorVisual.SetActive(value: true);
			}
		}
		else
		{
			UpdateLaserBeam(_startPoint, _startPoint + maxLength * _forward);
			lineRenderer.SetPosition(1, _startPoint + maxLength * _forward);
			if ((bool)cursorVisual)
			{
				cursorVisual.SetActive(value: false);
			}
		}
	}

	private void UpdateLaserBeam(Vector3 start, Vector3 end)
	{
		if (laserBeamBehavior == LaserBeamBehavior.Off)
		{
			return;
		}
		if (laserBeamBehavior == LaserBeamBehavior.On)
		{
			lineRenderer.SetPosition(0, start);
			lineRenderer.SetPosition(1, end);
		}
		else
		{
			if (laserBeamBehavior != LaserBeamBehavior.OnWhenHitTarget)
			{
				return;
			}
			if (_hitTarget)
			{
				if (!lineRenderer.enabled)
				{
					lineRenderer.enabled = true;
					lineRenderer.SetPosition(0, start);
					lineRenderer.SetPosition(1, end);
				}
			}
			else if (lineRenderer.enabled)
			{
				lineRenderer.enabled = false;
			}
		}
	}

	private void OnDisable()
	{
		if ((bool)cursorVisual)
		{
			cursorVisual.SetActive(value: false);
		}
	}

	public void OnInputFocusLost()
	{
		if ((bool)base.gameObject && base.gameObject.activeInHierarchy)
		{
			m_restoreOnInputAcquired = true;
			base.gameObject.SetActive(value: false);
		}
	}

	public void OnInputFocusAcquired()
	{
		if (m_restoreOnInputAcquired && (bool)base.gameObject)
		{
			m_restoreOnInputAcquired = false;
			base.gameObject.SetActive(value: true);
		}
	}

	private void OnDestroy()
	{
		OVRManager.InputFocusAcquired -= OnInputFocusAcquired;
		OVRManager.InputFocusLost -= OnInputFocusLost;
	}
}
public class CharacterCameraConstraint : MonoBehaviour
{
	private const float FADE_RAY_LENGTH = 0.25f;

	private const float FADE_OVERLAP_MAXIMUM = 0.1f;

	private const float FADE_AMOUNT_MAXIMUM = 1f;

	[Tooltip("This should be a reference to the OVRCameraRig that is usually a child of the PlayerController.")]
	public OVRCameraRig CameraRig;

	[Tooltip("Collision layers to be used for the purposes of fading out the screen when the HMD is inside world geometry and adjusting the capsule height.")]
	public LayerMask CollideLayers;

	[Tooltip("Offset is added to camera's real world height, effectively treating it as though the player was taller/standing higher.")]
	public float HeightOffset;

	[Tooltip("Minimum height that the character capsule can shrink to.  To disable, set to capsule's height.")]
	public float MinimumHeight;

	[Tooltip("Maximum height that the character capsule can grow to.  To disable, set to capsule's height.")]
	public float MaximumHeight;

	private CapsuleCollider _character;

	private SimpleCapsuleWithStickMovement _simplePlayerController;

	private CharacterCameraConstraint()
	{
	}

	private void Awake()
	{
		_character = GetComponent<CapsuleCollider>();
		_simplePlayerController = GetComponent<SimpleCapsuleWithStickMovement>();
	}

	private void OnEnable()
	{
		_simplePlayerController.CameraUpdated += CameraUpdate;
	}

	private void OnDisable()
	{
		_simplePlayerController.CameraUpdated -= CameraUpdate;
	}

	private void CameraUpdate()
	{
		float result = 0f;
		if (CheckCameraOverlapped())
		{
			OVRScreenFade.instance.SetExplicitFade(1f);
		}
		else if (CheckCameraNearClipping(out result))
		{
			float t = Mathf.InverseLerp(0f, 0.1f, result);
			float explicitFade = Mathf.Lerp(0f, 1f, t);
			OVRScreenFade.instance.SetExplicitFade(explicitFade);
		}
		else
		{
			OVRScreenFade.instance.SetExplicitFade(0f);
		}
		float num = 0.25f;
		float value = CameraRig.centerEyeAnchor.localPosition.y + HeightOffset + num;
		float minimumHeight = MinimumHeight;
		minimumHeight = Mathf.Min(_character.height, minimumHeight);
		float b = MaximumHeight;
		if (Physics.SphereCast(_character.transform.position, _character.radius * 0.2f, Vector3.up, out var hitInfo, MaximumHeight - _character.transform.position.y, CollideLayers, QueryTriggerInteraction.Ignore))
		{
			b = hitInfo.point.y;
		}
		b = Mathf.Max(_character.height, b);
		_character.height = Mathf.Clamp(value, minimumHeight, b);
		float y = HeightOffset - _character.height * 0.5f - num;
		CameraRig.transform.localPosition = new Vector3(0f, y, 0f);
	}

	private bool CheckCameraOverlapped()
	{
		Camera component = CameraRig.centerEyeAnchor.GetComponent<Camera>();
		Vector3 position = _character.transform.position;
		float num = Mathf.Max(0f, _character.height * 0.5f - component.nearClipPlane - 0.01f);
		position.y = Mathf.Clamp(CameraRig.centerEyeAnchor.position.y, _character.transform.position.y - num, _character.transform.position.y + num);
		Vector3 vector = CameraRig.centerEyeAnchor.position - position;
		float magnitude = vector.magnitude;
		Vector3 direction = vector / magnitude;
		RaycastHit hitInfo;
		return Physics.SphereCast(position, component.nearClipPlane, direction, out hitInfo, magnitude, CollideLayers, QueryTriggerInteraction.Ignore);
	}

	private bool CheckCameraNearClipping(out float result)
	{
		Camera component = CameraRig.centerEyeAnchor.GetComponent<Camera>();
		Vector3[] array = new Vector3[4];
		component.CalculateFrustumCorners(new Rect(0f, 0f, 1f, 1f), component.nearClipPlane, Camera.MonoOrStereoscopicEye.Mono, array);
		Vector3 vector = CameraRig.centerEyeAnchor.position + Vector3.Normalize(CameraRig.centerEyeAnchor.TransformVector(array[0])) * 0.25f;
		Vector3 vector2 = CameraRig.centerEyeAnchor.position + Vector3.Normalize(CameraRig.centerEyeAnchor.TransformVector(array[1])) * 0.25f;
		Vector3 vector3 = CameraRig.centerEyeAnchor.position + Vector3.Normalize(CameraRig.centerEyeAnchor.TransformVector(array[2])) * 0.25f;
		Vector3 vector4 = CameraRig.centerEyeAnchor.position + Vector3.Normalize(CameraRig.centerEyeAnchor.TransformVector(array[3])) * 0.25f;
		Vector3 vector5 = (vector2 + vector4) / 2f;
		bool result2 = false;
		result = 0f;
		Vector3[] array2 = new Vector3[5] { vector, vector2, vector3, vector4, vector5 };
		foreach (Vector3 vector6 in array2)
		{
			if (Physics.Linecast(CameraRig.centerEyeAnchor.position, vector6, out var hitInfo, CollideLayers, QueryTriggerInteraction.Ignore))
			{
				result2 = true;
				result = Mathf.Max(result, Vector3.Distance(hitInfo.point, vector6));
			}
		}
		return result2;
	}
}
public class LocomotionController : MonoBehaviour
{
	public OVRCameraRig CameraRig;

	public CapsuleCollider CharacterController;

	public SimpleCapsuleWithStickMovement PlayerController;

	private void Start()
	{
		if (CameraRig == null)
		{
			CameraRig = UnityEngine.Object.FindObjectOfType<OVRCameraRig>();
		}
	}
}
public class LocomotionTeleport : MonoBehaviour
{
	public enum States
	{
		Ready,
		Aim,
		CancelAim,
		PreTeleport,
		CancelTeleport,
		Teleporting,
		PostTeleport
	}

	public enum TeleportIntentions
	{
		None,
		Aim,
		PreTeleport,
		Teleport
	}

	public enum AimCollisionTypes
	{
		Point,
		Sphere,
		Capsule
	}

	public class AimData
	{
		public RaycastHit TargetHitInfo;

		public bool TargetValid;

		public Vector3? Destination;

		public float Radius;

		public List<Vector3> Points { get; private set; }

		public AimData()
		{
			Points = new List<Vector3>();
		}

		public void Reset()
		{
			Points.Clear();
			TargetValid = false;
			Destination = null;
		}
	}

	[Tooltip("Allow linear movement prior to the teleport system being activated.")]
	public bool EnableMovementDuringReady = true;

	[Tooltip("Allow linear movement while the teleport system is in the process of aiming for a teleport target.")]
	public bool EnableMovementDuringAim = true;

	[Tooltip("Allow linear movement while the teleport system is in the process of configuring the landing orientation.")]
	public bool EnableMovementDuringPreTeleport = true;

	[Tooltip("Allow linear movement after the teleport has occurred but before the system has returned to the ready state.")]
	public bool EnableMovementDuringPostTeleport = true;

	[Tooltip("Allow rotation prior to the teleport system being activated.")]
	public bool EnableRotationDuringReady = true;

	[Tooltip("Allow rotation while the teleport system is in the process of aiming for a teleport target.")]
	public bool EnableRotationDuringAim = true;

	[Tooltip("Allow rotation while the teleport system is in the process of configuring the landing orientation.")]
	public bool EnableRotationDuringPreTeleport = true;

	[Tooltip("Allow rotation after the teleport has occurred but before the system has returned to the ready state.")]
	public bool EnableRotationDuringPostTeleport = true;

	[NonSerialized]
	public TeleportAimHandler AimHandler;

	[Tooltip("This prefab will be instantiated as needed and updated to match the current aim target.")]
	public TeleportDestination TeleportDestinationPrefab;

	[Tooltip("TeleportDestinationPrefab will be instantiated into this layer.")]
	public int TeleportDestinationLayer;

	[NonSerialized]
	public TeleportInputHandler InputHandler;

	[NonSerialized]
	public TeleportIntentions CurrentIntention;

	[NonSerialized]
	public bool IsPreTeleportRequested;

	[NonSerialized]
	public bool IsTransitioning;

	[NonSerialized]
	public bool IsPostTeleportRequested;

	private TeleportDestination _teleportDestination;

	[Tooltip("When aiming at possible destinations, the aim collision type determines which shape to use for collision tests.")]
	public AimCollisionTypes AimCollisionType;

	[Tooltip("Use the character collision radius/height/skinwidth for sphere/capsule collision tests.")]
	public bool UseCharacterCollisionData;

	[Tooltip("Radius of the sphere or capsule used for collision testing when aiming to possible teleport destinations. Ignored if UseCharacterCollisionData is true.")]
	public float AimCollisionRadius;

	[Tooltip("Height of the capsule used for collision testing when aiming to possible teleport destinations. Ignored if UseCharacterCollisionData is true.")]
	public float AimCollisionHeight;

	public States CurrentState { get; private set; }

	public Quaternion DestinationRotation => _teleportDestination.OrientationIndicator.rotation;

	public LocomotionController LocomotionController { get; private set; }

	public event Action<bool, Vector3?, Quaternion?, Quaternion?> UpdateTeleportDestination;

	public event Action EnterStateReady;

	public event Action EnterStateAim;

	public event Action<AimData> UpdateAimData;

	public event Action ExitStateAim;

	public event Action EnterStateCancelAim;

	public event Action EnterStatePreTeleport;

	public event Action EnterStateCancelTeleport;

	public event Action EnterStateTeleporting;

	public event Action EnterStatePostTeleport;

	public event Action<Transform, Vector3, Quaternion> Teleported;

	public void EnableMovement(bool ready, bool aim, bool pre, bool post)
	{
		EnableMovementDuringReady = ready;
		EnableMovementDuringAim = aim;
		EnableMovementDuringPreTeleport = pre;
		EnableMovementDuringPostTeleport = post;
	}

	public void EnableRotation(bool ready, bool aim, bool pre, bool post)
	{
		EnableRotationDuringReady = ready;
		EnableRotationDuringAim = aim;
		EnableRotationDuringPreTeleport = pre;
		EnableRotationDuringPostTeleport = post;
	}

	public void OnUpdateTeleportDestination(bool isValidDestination, Vector3? position, Quaternion? rotation, Quaternion? landingRotation)
	{
		if (this.UpdateTeleportDestination != null)
		{
			this.UpdateTeleportDestination(isValidDestination, position, rotation, landingRotation);
		}
	}

	public bool AimCollisionTest(Vector3 start, Vector3 end, LayerMask aimCollisionLayerMask, out RaycastHit hitInfo)
	{
		Vector3 vector = end - start;
		float magnitude = vector.magnitude;
		Vector3 direction = vector / magnitude;
		switch (AimCollisionType)
		{
		case AimCollisionTypes.Capsule:
		{
			float num;
			float num2;
			if (UseCharacterCollisionData)
			{
				CapsuleCollider characterController = LocomotionController.CharacterController;
				num = characterController.height;
				num2 = characterController.radius;
			}
			else
			{
				num = AimCollisionHeight;
				num2 = AimCollisionRadius;
			}
			return Physics.CapsuleCast(start + new Vector3(0f, num2, 0f), start + new Vector3(0f, num + num2, 0f), num2, direction, out hitInfo, magnitude, aimCollisionLayerMask, QueryTriggerInteraction.Ignore);
		}
		case AimCollisionTypes.Point:
			return Physics.Raycast(start, direction, out hitInfo, magnitude, aimCollisionLayerMask, QueryTriggerInteraction.Ignore);
		case AimCollisionTypes.Sphere:
		{
			float radius = ((!UseCharacterCollisionData) ? AimCollisionRadius : LocomotionController.CharacterController.radius);
			return Physics.SphereCast(start, radius, direction, out hitInfo, magnitude, aimCollisionLayerMask, QueryTriggerInteraction.Ignore);
		}
		default:
			throw new Exception();
		}
	}

	[Conditional("DEBUG_TELEPORT_STATES")]
	protected void LogState(string msg)
	{
		UnityEngine.Debug.Log(Time.frameCount + ": " + msg);
	}

	protected void CreateNewTeleportDestination()
	{
		TeleportDestinationPrefab.gameObject.SetActive(value: false);
		TeleportDestination teleportDestination = UnityEngine.Object.Instantiate(TeleportDestinationPrefab);
		teleportDestination.LocomotionTeleport = this;
		teleportDestination.gameObject.layer = TeleportDestinationLayer;
		_teleportDestination = teleportDestination;
		_teleportDestination.LocomotionTeleport = this;
	}

	private void DeactivateDestination()
	{
		_teleportDestination.OnDeactivated();
	}

	public void RecycleTeleportDestination(TeleportDestination oldDestination)
	{
		if (oldDestination == _teleportDestination)
		{
			CreateNewTeleportDestination();
		}
		UnityEngine.Object.Destroy(oldDestination.gameObject);
	}

	private void EnableMotion(bool enableLinear, bool enableRotation)
	{
		LocomotionController.PlayerController.EnableLinearMovement = enableLinear;
		LocomotionController.PlayerController.EnableRotation = enableRotation;
	}

	private void Awake()
	{
		LocomotionController = GetComponent<LocomotionController>();
		CreateNewTeleportDestination();
	}

	public virtual void OnEnable()
	{
		CurrentState = States.Ready;
		StartCoroutine(ReadyStateCoroutine());
	}

	public virtual void OnDisable()
	{
		StopAllCoroutines();
	}

	protected IEnumerator ReadyStateCoroutine()
	{
		yield return null;
		CurrentState = States.Ready;
		EnableMotion(EnableMovementDuringReady, EnableRotationDuringReady);
		if (this.EnterStateReady != null)
		{
			this.EnterStateReady();
		}
		while (CurrentIntention != TeleportIntentions.Aim)
		{
			yield return null;
		}
		yield return null;
		StartCoroutine(AimStateCoroutine());
	}

	public void OnUpdateAimData(AimData aimData)
	{
		if (this.UpdateAimData != null)
		{
			this.UpdateAimData(aimData);
		}
	}

	protected IEnumerator AimStateCoroutine()
	{
		CurrentState = States.Aim;
		EnableMotion(EnableMovementDuringAim, EnableRotationDuringAim);
		if (this.EnterStateAim != null)
		{
			this.EnterStateAim();
		}
		_teleportDestination.gameObject.SetActive(value: true);
		while (CurrentIntention == TeleportIntentions.Aim)
		{
			yield return null;
		}
		if (this.ExitStateAim != null)
		{
			this.ExitStateAim();
		}
		yield return null;
		if ((CurrentIntention == TeleportIntentions.PreTeleport || CurrentIntention == TeleportIntentions.Teleport) && _teleportDestination.IsValidDestination)
		{
			StartCoroutine(PreTeleportStateCoroutine());
		}
		else
		{
			StartCoroutine(CancelAimStateCoroutine());
		}
	}

	protected IEnumerator CancelAimStateCoroutine()
	{
		CurrentState = States.CancelAim;
		if (this.EnterStateCancelAim != null)
		{
			this.EnterStateCancelAim();
		}
		DeactivateDestination();
		yield return null;
		StartCoroutine(ReadyStateCoroutine());
	}

	protected IEnumerator PreTeleportStateCoroutine()
	{
		CurrentState = States.PreTeleport;
		EnableMotion(EnableMovementDuringPreTeleport, EnableRotationDuringPreTeleport);
		if (this.EnterStatePreTeleport != null)
		{
			this.EnterStatePreTeleport();
		}
		while (CurrentIntention == TeleportIntentions.PreTeleport || IsPreTeleportRequested)
		{
			yield return null;
		}
		if (_teleportDestination.IsValidDestination)
		{
			StartCoroutine(TeleportingStateCoroutine());
		}
		else
		{
			StartCoroutine(CancelTeleportStateCoroutine());
		}
	}

	protected IEnumerator CancelTeleportStateCoroutine()
	{
		CurrentState = States.CancelTeleport;
		if (this.EnterStateCancelTeleport != null)
		{
			this.EnterStateCancelTeleport();
		}
		DeactivateDestination();
		yield return null;
		StartCoroutine(ReadyStateCoroutine());
	}

	protected IEnumerator TeleportingStateCoroutine()
	{
		CurrentState = States.Teleporting;
		EnableMotion(enableLinear: false, enableRotation: false);
		if (this.EnterStateTeleporting != null)
		{
			this.EnterStateTeleporting();
		}
		while (IsTransitioning)
		{
			yield return null;
		}
		yield return null;
		StartCoroutine(PostTeleportStateCoroutine());
	}

	protected IEnumerator PostTeleportStateCoroutine()
	{
		CurrentState = States.PostTeleport;
		EnableMotion(EnableMovementDuringPostTeleport, EnableRotationDuringPostTeleport);
		if (this.EnterStatePostTeleport != null)
		{
			this.EnterStatePostTeleport();
		}
		while (IsPostTeleportRequested)
		{
			yield return null;
		}
		DeactivateDestination();
		yield return null;
		StartCoroutine(ReadyStateCoroutine());
	}

	public void DoTeleport()
	{
		CapsuleCollider characterController = LocomotionController.CharacterController;
		Transform transform = characterController.transform;
		Vector3 position = _teleportDestination.OrientationIndicator.position;
		position.y += characterController.height * 0.5f;
		Quaternion landingRotation = _teleportDestination.LandingRotation;
		if (this.Teleported != null)
		{
			this.Teleported(transform, position, landingRotation);
		}
		transform.position = position;
		transform.rotation = landingRotation;
	}

	public Vector3 GetCharacterPosition()
	{
		return LocomotionController.CharacterController.transform.position;
	}

	public Quaternion GetHeadRotationY()
	{
		Quaternion value = Quaternion.identity;
		InputDevice deviceAtXRNode = InputDevices.GetDeviceAtXRNode(XRNode.Head);
		if (deviceAtXRNode.isValid)
		{
			deviceAtXRNode.TryGetFeatureValue(CommonUsages.deviceRotation, out value);
		}
		Vector3 eulerAngles = value.eulerAngles;
		eulerAngles.x = 0f;
		eulerAngles.z = 0f;
		return Quaternion.Euler(eulerAngles);
	}

	public void DoWarp(Vector3 startPos, float positionPercent)
	{
		Vector3 position = _teleportDestination.OrientationIndicator.position;
		position.y += LocomotionController.CharacterController.height / 2f;
		Transform obj = LocomotionController.CharacterController.transform;
		Vector3 position2 = Vector3.Lerp(startPos, position, positionPercent);
		obj.position = position2;
	}
}
public class SimpleCapsuleWithStickMovement : MonoBehaviour
{
	public bool EnableLinearMovement = true;

	public bool EnableRotation = true;

	public bool HMDRotatesPlayer = true;

	public bool RotationEitherThumbstick;

	public float RotationAngle = 45f;

	public float Speed;

	public OVRCameraRig CameraRig;

	private bool ReadyToSnapTurn;

	private Rigidbody _rigidbody;

	public event Action CameraUpdated;

	public event Action PreCharacterMove;

	private void Awake()
	{
		_rigidbody = GetComponent<Rigidbody>();
		if (CameraRig == null)
		{
			CameraRig = GetComponentInChildren<OVRCameraRig>();
		}
	}

	private void Start()
	{
	}

	private void FixedUpdate()
	{
		if (this.CameraUpdated != null)
		{
			this.CameraUpdated();
		}
		if (this.PreCharacterMove != null)
		{
			this.PreCharacterMove();
		}
		if (HMDRotatesPlayer)
		{
			RotatePlayerToHMD();
		}
		if (EnableLinearMovement)
		{
			StickMovement();
		}
		if (EnableRotation)
		{
			SnapTurn();
		}
	}

	private void RotatePlayerToHMD()
	{
		Transform trackingSpace = CameraRig.trackingSpace;
		Transform centerEyeAnchor = CameraRig.centerEyeAnchor;
		Vector3 position = trackingSpace.position;
		Quaternion quaternion = trackingSpace.rotation;
		base.transform.rotation = Quaternion.Euler(0f, centerEyeAnchor.rotation.eulerAngles.y, 0f);
		trackingSpace.position = position;
		trackingSpace.rotation = quaternion;
	}

	private void StickMovement()
	{
		Vector3 eulerAngles = CameraRig.centerEyeAnchor.rotation.eulerAngles;
		eulerAngles.z = (eulerAngles.x = 0f);
		Quaternion quaternion = Quaternion.Euler(eulerAngles);
		Vector3 zero = Vector3.zero;
		Vector2 vector = OVRInput.Get(OVRInput.Axis2D.PrimaryThumbstick);
		zero += quaternion * (vector.x * Vector3.right);
		zero += quaternion * (vector.y * Vector3.forward);
		_rigidbody.MovePosition(_rigidbody.position + zero * Speed * Time.fixedDeltaTime);
	}

	private void SnapTurn()
	{
		Vector3 eulerAngles = base.transform.rotation.eulerAngles;
		if (OVRInput.Get(OVRInput.Button.SecondaryThumbstickLeft) || (RotationEitherThumbstick && OVRInput.Get(OVRInput.Button.PrimaryThumbstickLeft)))
		{
			if (ReadyToSnapTurn)
			{
				eulerAngles.y -= RotationAngle;
				ReadyToSnapTurn = false;
			}
		}
		else if (OVRInput.Get(OVRInput.Button.SecondaryThumbstickRight) || (RotationEitherThumbstick && OVRInput.Get(OVRInput.Button.PrimaryThumbstickRight)))
		{
			if (ReadyToSnapTurn)
			{
				eulerAngles.y += RotationAngle;
				ReadyToSnapTurn = false;
			}
		}
		else
		{
			ReadyToSnapTurn = true;
		}
		base.transform.rotation = Quaternion.Euler(eulerAngles);
	}
}
public abstract class TeleportAimHandler : TeleportSupport
{
	protected override void OnEnable()
	{
		base.OnEnable();
		base.LocomotionTeleport.AimHandler = this;
	}

	protected override void OnDisable()
	{
		if (base.LocomotionTeleport.AimHandler == this)
		{
			base.LocomotionTeleport.AimHandler = null;
		}
		base.OnDisable();
	}

	public abstract void GetPoints(List<Vector3> points);
}
public class TeleportAimHandlerLaser : TeleportAimHandler
{
	[Tooltip("Maximum range for aiming.")]
	public float Range = 100f;

	public override void GetPoints(List<Vector3> points)
	{
		base.LocomotionTeleport.InputHandler.GetAimData(out var aimRay);
		points.Add(aimRay.origin);
		points.Add(aimRay.origin + aimRay.direction * Range);
	}
}
public class TeleportAimHandlerParabolic : TeleportAimHandler
{
	[Tooltip("Maximum range for aiming.")]
	public float Range;

	[Tooltip("The MinimumElevation is relative to the AimPosition.")]
	public float MinimumElevation = -100f;

	[Tooltip("The Gravity is used in conjunction with AimVelocity and the aim direction to simulate a projectile.")]
	public float Gravity = -9.8f;

	[Tooltip("The AimVelocity is the initial speed of the faked projectile.")]
	[Range(0.001f, 50f)]
	public float AimVelocity = 1f;

	[Tooltip("The AimStep is the how much to subdivide the iteration.")]
	[Range(0.001f, 1f)]
	public float AimStep = 1f;

	public override void GetPoints(List<Vector3> points)
	{
		base.LocomotionTeleport.InputHandler.GetAimData(out var aimRay);
		Vector3 origin = aimRay.origin;
		Vector3 vector = aimRay.direction * AimVelocity;
		float num = Range * Range;
		do
		{
			points.Add(origin);
			Vector3 vector2 = vector;
			vector2.y += Gravity * (1f / 90f) * AimStep;
			vector = vector2;
			origin += vector2 * AimStep;
		}
		while (origin.y - aimRay.origin.y > MinimumElevation && (aimRay.origin - origin).sqrMagnitude <= num);
	}
}
public class TeleportAimVisualLaser : TeleportSupport
{
	[Tooltip("This prefab will be instantiated when the aim visual is awakened, and will be set active when the user is aiming, and deactivated when they are done aiming.")]
	public LineRenderer LaserPrefab;

	private readonly Action _enterAimStateAction;

	private readonly Action _exitAimStateAction;

	private readonly Action<LocomotionTeleport.AimData> _updateAimDataAction;

	private LineRenderer _lineRenderer;

	private Vector3[] _linePoints;

	public TeleportAimVisualLaser()
	{
		_enterAimStateAction = EnterAimState;
		_exitAimStateAction = ExitAimState;
		_updateAimDataAction = UpdateAimData;
	}

	private void EnterAimState()
	{
		_lineRenderer.gameObject.SetActive(value: true);
	}

	private void ExitAimState()
	{
		_lineRenderer.gameObject.SetActive(value: false);
	}

	private void Awake()
	{
		LaserPrefab.gameObject.SetActive(value: false);
		_lineRenderer = UnityEngine.Object.Instantiate(LaserPrefab);
	}

	protected override void AddEventHandlers()
	{
		base.AddEventHandlers();
		base.LocomotionTeleport.EnterStateAim += _enterAimStateAction;
		base.LocomotionTeleport.ExitStateAim += _exitAimStateAction;
		base.LocomotionTeleport.UpdateAimData += _updateAimDataAction;
	}

	protected override void RemoveEventHandlers()
	{
		base.LocomotionTeleport.EnterStateAim -= _enterAimStateAction;
		base.LocomotionTeleport.ExitStateAim -= _exitAimStateAction;
		base.LocomotionTeleport.UpdateAimData -= _updateAimDataAction;
		base.RemoveEventHandlers();
	}

	private void UpdateAimData(LocomotionTeleport.AimData obj)
	{
		_lineRenderer.sharedMaterial.color = (obj.TargetValid ? Color.green : Color.red);
		List<Vector3> points = obj.Points;
		_lineRenderer.positionCount = points.Count;
		for (int i = 0; i < points.Count; i++)
		{
			_lineRenderer.SetPosition(i, points[i]);
		}
	}
}
public class TeleportDestination : MonoBehaviour
{
	[Tooltip("If the target handler provides a target position, this transform will be moved to that position and it's game object enabled. A target position being provided does not mean the position is valid, only that the aim handler found something to test as a destination.")]
	public Transform PositionIndicator;

	[Tooltip("This transform will be rotated to match the rotation of the aiming target. Simple teleport destinations should assign this to the object containing this component. More complex teleport destinations might assign this to a sub-object that is used to indicate the landing orientation independently from the rest of the destination indicator, such as when world space effects are required. This will typically be a child of the PositionIndicator.")]
	public Transform OrientationIndicator;

	[Tooltip("After the player teleports, the character controller will have it's rotation set to this value. It is different from the OrientationIndicator transform.rotation in order to support both head-relative and forward-facing teleport modes (See TeleportOrientationHandlerThumbstick.cs).")]
	public Quaternion LandingRotation;

	[NonSerialized]
	public LocomotionTeleport LocomotionTeleport;

	[NonSerialized]
	public LocomotionTeleport.States TeleportState;

	private readonly Action<bool, Vector3?, Quaternion?, Quaternion?> _updateTeleportDestinationAction;

	private bool _eventsActive;

	public bool IsValidDestination { get; private set; }

	public event Action<TeleportDestination> Deactivated;

	private TeleportDestination()
	{
		_updateTeleportDestinationAction = UpdateTeleportDestination;
	}

	public void OnEnable()
	{
		PositionIndicator.gameObject.SetActive(value: false);
		if (OrientationIndicator != null)
		{
			OrientationIndicator.gameObject.SetActive(value: false);
		}
		LocomotionTeleport.UpdateTeleportDestination += _updateTeleportDestinationAction;
		_eventsActive = true;
	}

	private void TryDisableEventHandlers()
	{
		if (_eventsActive)
		{
			LocomotionTeleport.UpdateTeleportDestination -= _updateTeleportDestinationAction;
			_eventsActive = false;
		}
	}

	public void OnDisable()
	{
		TryDisableEventHandlers();
	}

	public void OnDeactivated()
	{
		if (this.Deactivated != null)
		{
			this.Deactivated(this);
		}
		else
		{
			Recycle();
		}
	}

	public void Recycle()
	{
		LocomotionTeleport.RecycleTeleportDestination(this);
	}

	public virtual void UpdateTeleportDestination(bool isValidDestination, Vector3? position, Quaternion? rotation, Quaternion? landingRotation)
	{
		IsValidDestination = isValidDestination;
		LandingRotation = landingRotation.GetValueOrDefault();
		GameObject gameObject = PositionIndicator.gameObject;
		bool activeInHierarchy = gameObject.activeInHierarchy;
		if (!position.HasValue)
		{
			if (activeInHierarchy)
			{
				gameObject.SetActive(value: false);
			}
			return;
		}
		if (!activeInHierarchy)
		{
			gameObject.SetActive(value: true);
		}
		base.transform.position = position.GetValueOrDefault();
		if (OrientationIndicator == null)
		{
			if (rotation.HasValue)
			{
				base.transform.rotation = rotation.GetValueOrDefault();
			}
			return;
		}
		GameObject gameObject2 = OrientationIndicator.gameObject;
		bool activeInHierarchy2 = gameObject2.activeInHierarchy;
		if (!rotation.HasValue)
		{
			if (activeInHierarchy2)
			{
				gameObject2.SetActive(value: false);
			}
			return;
		}
		OrientationIndicator.rotation = rotation.GetValueOrDefault();
		if (!activeInHierarchy2)
		{
			gameObject2.SetActive(value: true);
		}
	}
}
public abstract class TeleportInputHandler : TeleportSupport
{
	private readonly Action _startReadyAction;

	private readonly Action _startAimAction;

	protected TeleportInputHandler()
	{
		_startReadyAction = delegate
		{
			StartCoroutine(TeleportReadyCoroutine());
		};
		_startAimAction = delegate
		{
			StartCoroutine(TeleportAimCoroutine());
		};
	}

	protected override void AddEventHandlers()
	{
		base.LocomotionTeleport.InputHandler = this;
		base.AddEventHandlers();
		base.LocomotionTeleport.EnterStateReady += _startReadyAction;
		base.LocomotionTeleport.EnterStateAim += _startAimAction;
	}

	protected override void RemoveEventHandlers()
	{
		if (base.LocomotionTeleport.InputHandler == this)
		{
			base.LocomotionTeleport.InputHandler = null;
		}
		base.LocomotionTeleport.EnterStateReady -= _startReadyAction;
		base.LocomotionTeleport.EnterStateAim -= _startAimAction;
		base.RemoveEventHandlers();
	}

	private IEnumerator TeleportReadyCoroutine()
	{
		while (GetIntention() != LocomotionTeleport.TeleportIntentions.Aim)
		{
			yield return null;
		}
		base.LocomotionTeleport.CurrentIntention = LocomotionTeleport.TeleportIntentions.Aim;
	}

	private IEnumerator TeleportAimCoroutine()
	{
		LocomotionTeleport.TeleportIntentions intention = GetIntention();
		while (intention == LocomotionTeleport.TeleportIntentions.Aim || intention == LocomotionTeleport.TeleportIntentions.PreTeleport)
		{
			base.LocomotionTeleport.CurrentIntention = intention;
			yield return null;
			intention = GetIntention();
		}
		base.LocomotionTeleport.CurrentIntention = intention;
	}

	public abstract LocomotionTeleport.TeleportIntentions GetIntention();

	public abstract void GetAimData(out Ray aimRay);
}
public class TeleportInputHandlerHMD : TeleportInputHandler
{
	[Tooltip("The button used to begin aiming for a teleport.")]
	public OVRInput.RawButton AimButton;

	[Tooltip("The button used to trigger the teleport after aiming. It can be the same button as the AimButton, however you cannot abort a teleport if it is.")]
	public OVRInput.RawButton TeleportButton;

	[Tooltip("When true, the system will not use the PreTeleport intention which will allow a teleport to occur on a button downpress. When false, the button downpress will trigger the PreTeleport intention and the Teleport intention when the button is released.")]
	public bool FastTeleport;

	public Transform Pointer { get; private set; }

	public override LocomotionTeleport.TeleportIntentions GetIntention()
	{
		if (!base.isActiveAndEnabled)
		{
			return LocomotionTeleport.TeleportIntentions.None;
		}
		if (base.LocomotionTeleport.CurrentIntention == LocomotionTeleport.TeleportIntentions.Aim && OVRInput.GetDown(TeleportButton))
		{
			if (!FastTeleport)
			{
				return LocomotionTeleport.TeleportIntentions.PreTeleport;
			}
			return LocomotionTeleport.TeleportIntentions.Teleport;
		}
		if (base.LocomotionTeleport.CurrentIntention == LocomotionTeleport.TeleportIntentions.PreTeleport)
		{
			if (OVRInput.GetUp(TeleportButton))
			{
				return LocomotionTeleport.TeleportIntentions.Teleport;
			}
			return LocomotionTeleport.TeleportIntentions.PreTeleport;
		}
		if (OVRInput.Get(AimButton))
		{
			return LocomotionTeleport.TeleportIntentions.Aim;
		}
		if (AimButton == TeleportButton)
		{
			return LocomotionTeleport.TeleportIntentions.Teleport;
		}
		return LocomotionTeleport.TeleportIntentions.None;
	}

	public override void GetAimData(out Ray aimRay)
	{
		Transform centerEyeAnchor = base.LocomotionTeleport.LocomotionController.CameraRig.centerEyeAnchor;
		aimRay = new Ray(centerEyeAnchor.position, centerEyeAnchor.forward);
	}
}
public class TeleportInputHandlerTouch : TeleportInputHandlerHMD
{
	public enum InputModes
	{
		CapacitiveButtonForAimAndTeleport,
		SeparateButtonsForAimAndTeleport,
		ThumbstickTeleport,
		ThumbstickTeleportForwardBackOnly
	}

	public enum AimCapTouchButtons
	{
		A,
		B,
		LeftTrigger,
		LeftThumbstick,
		RightTrigger,
		RightThumbstick,
		X,
		Y
	}

	public Transform LeftHand;

	public Transform RightHand;

	[Tooltip("CapacitiveButtonForAimAndTeleport=Activate aiming via cap touch detection, press the same button to teleport.\nSeparateButtonsForAimAndTeleport=Use one button to begin aiming, and another to trigger the teleport.\nThumbstickTeleport=Push a thumbstick to begin aiming, release to teleport.")]
	public InputModes InputMode;

	private readonly OVRInput.RawButton[] _rawButtons = new OVRInput.RawButton[8]
	{
		OVRInput.RawButton.A,
		OVRInput.RawButton.B,
		OVRInput.RawButton.LIndexTrigger,
		OVRInput.RawButton.LThumbstick,
		OVRInput.RawButton.RIndexTrigger,
		OVRInput.RawButton.RThumbstick,
		OVRInput.RawButton.X,
		OVRInput.RawButton.Y
	};

	private readonly OVRInput.RawTouch[] _rawTouch = new OVRInput.RawTouch[8]
	{
		OVRInput.RawTouch.A,
		OVRInput.RawTouch.B,
		OVRInput.RawTouch.LIndexTrigger,
		OVRInput.RawTouch.LThumbstick,
		OVRInput.RawTouch.RIndexTrigger,
		OVRInput.RawTouch.RThumbstick,
		OVRInput.RawTouch.X,
		OVRInput.RawTouch.Y
	};

	[Tooltip("Select the controller to be used for aiming. Supports LTouch, RTouch, or Touch for either.")]
	public OVRInput.Controller AimingController;

	private OVRInput.Controller InitiatingController;

	[Tooltip("Select the button to use for triggering aim and teleport when InputMode==CapacitiveButtonForAimAndTeleport")]
	public AimCapTouchButtons CapacitiveAimAndTeleportButton;

	[Tooltip("The thumbstick magnitude required to trigger aiming and teleports when InputMode==InputModes.ThumbstickTeleport")]
	public float ThumbstickTeleportThreshold = 0.5f;

	private void Start()
	{
	}

	public override LocomotionTeleport.TeleportIntentions GetIntention()
	{
		if (!base.isActiveAndEnabled)
		{
			return LocomotionTeleport.TeleportIntentions.None;
		}
		if (InputMode == InputModes.SeparateButtonsForAimAndTeleport)
		{
			return base.GetIntention();
		}
		if (InputMode == InputModes.ThumbstickTeleport || InputMode == InputModes.ThumbstickTeleportForwardBackOnly)
		{
			Vector2 lhs = OVRInput.Get(OVRInput.RawAxis2D.LThumbstick);
			Vector2 lhs2 = OVRInput.Get(OVRInput.RawAxis2D.RThumbstick);
			float num = 0f;
			float num2 = 0f;
			float num3 = 0f;
			OVRInput.Controller controller = OVRInput.Controller.Touch;
			bool flag = OVRInput.Get(OVRInput.RawTouch.LThumbstick);
			bool flag2 = OVRInput.Get(OVRInput.RawTouch.RThumbstick);
			if (InputMode == InputModes.ThumbstickTeleportForwardBackOnly && base.LocomotionTeleport.CurrentIntention != LocomotionTeleport.TeleportIntentions.Aim)
			{
				num = Mathf.Abs(Vector2.Dot(lhs, Vector2.up));
				num2 = Mathf.Abs(Vector2.Dot(lhs2, Vector2.up));
			}
			else
			{
				num = lhs.magnitude;
				num2 = lhs2.magnitude;
			}
			if (AimingController == OVRInput.Controller.LTouch)
			{
				num3 = num;
				controller = OVRInput.Controller.LTouch;
			}
			else if (AimingController == OVRInput.Controller.RTouch)
			{
				num3 = num2;
				controller = OVRInput.Controller.RTouch;
			}
			else if (num > num2)
			{
				num3 = num;
				controller = OVRInput.Controller.LTouch;
			}
			else
			{
				num3 = num2;
				controller = OVRInput.Controller.RTouch;
			}
			if (!(num3 > ThumbstickTeleportThreshold) && (AimingController != OVRInput.Controller.Touch || !(flag || flag2)) && !(AimingController == OVRInput.Controller.LTouch && flag) && !(AimingController == OVRInput.Controller.RTouch && flag2))
			{
				if (base.LocomotionTeleport.CurrentIntention == LocomotionTeleport.TeleportIntentions.Aim)
				{
					if (!FastTeleport)
					{
						return LocomotionTeleport.TeleportIntentions.PreTeleport;
					}
					return LocomotionTeleport.TeleportIntentions.Teleport;
				}
				if (base.LocomotionTeleport.CurrentIntention == LocomotionTeleport.TeleportIntentions.PreTeleport)
				{
					return LocomotionTeleport.TeleportIntentions.Teleport;
				}
			}
			else if (base.LocomotionTeleport.CurrentIntention == LocomotionTeleport.TeleportIntentions.Aim)
			{
				return LocomotionTeleport.TeleportIntentions.Aim;
			}
			if (num3 > ThumbstickTeleportThreshold)
			{
				InitiatingController = controller;
				return LocomotionTeleport.TeleportIntentions.Aim;
			}
			return LocomotionTeleport.TeleportIntentions.None;
		}
		OVRInput.RawButton rawMask = _rawButtons[(int)CapacitiveAimAndTeleportButton];
		if (base.LocomotionTeleport.CurrentIntention == LocomotionTeleport.TeleportIntentions.Aim && OVRInput.GetDown(rawMask))
		{
			if (!FastTeleport)
			{
				return LocomotionTeleport.TeleportIntentions.PreTeleport;
			}
			return LocomotionTeleport.TeleportIntentions.Teleport;
		}
		if (base.LocomotionTeleport.CurrentIntention == LocomotionTeleport.TeleportIntentions.PreTeleport)
		{
			if (FastTeleport || OVRInput.GetUp(rawMask))
			{
				return LocomotionTeleport.TeleportIntentions.Teleport;
			}
			return LocomotionTeleport.TeleportIntentions.PreTeleport;
		}
		if (OVRInput.GetDown(_rawTouch[(int)CapacitiveAimAndTeleportButton]))
		{
			return LocomotionTeleport.TeleportIntentions.Aim;
		}
		if (base.LocomotionTeleport.CurrentIntention == LocomotionTeleport.TeleportIntentions.Aim && !OVRInput.GetUp(_rawTouch[(int)CapacitiveAimAndTeleportButton]))
		{
			return LocomotionTeleport.TeleportIntentions.Aim;
		}
		return LocomotionTeleport.TeleportIntentions.None;
	}

	public override void GetAimData(out Ray aimRay)
	{
		OVRInput.Controller controller = AimingController;
		if (controller == OVRInput.Controller.Touch)
		{
			controller = InitiatingController;
		}
		Transform transform = ((controller == OVRInput.Controller.LTouch) ? LeftHand : RightHand);
		aimRay = new Ray(transform.position, transform.forward);
	}
}
public abstract class TeleportOrientationHandler : TeleportSupport
{
	public enum OrientationModes
	{
		HeadRelative,
		ForwardFacing
	}

	private readonly Action _updateOrientationAction;

	private readonly Action<LocomotionTeleport.AimData> _updateAimDataAction;

	protected LocomotionTeleport.AimData AimData;

	protected TeleportOrientationHandler()
	{
		_updateOrientationAction = delegate
		{
			StartCoroutine(UpdateOrientationCoroutine());
		};
		_updateAimDataAction = UpdateAimData;
	}

	private void UpdateAimData(LocomotionTeleport.AimData aimData)
	{
		AimData = aimData;
	}

	protected override void AddEventHandlers()
	{
		base.AddEventHandlers();
		base.LocomotionTeleport.EnterStateAim += _updateOrientationAction;
		base.LocomotionTeleport.UpdateAimData += _updateAimDataAction;
	}

	protected override void RemoveEventHandlers()
	{
		base.RemoveEventHandlers();
		base.LocomotionTeleport.EnterStateAim -= _updateOrientationAction;
		base.LocomotionTeleport.UpdateAimData -= _updateAimDataAction;
	}

	private IEnumerator UpdateOrientationCoroutine()
	{
		InitializeTeleportDestination();
		while (base.LocomotionTeleport.CurrentState == LocomotionTeleport.States.Aim || base.LocomotionTeleport.CurrentState == LocomotionTeleport.States.PreTeleport)
		{
			if (AimData != null)
			{
				UpdateTeleportDestination();
			}
			yield return null;
		}
	}

	protected abstract void InitializeTeleportDestination();

	protected abstract void UpdateTeleportDestination();

	protected Quaternion GetLandingOrientation(OrientationModes mode, Quaternion rotation)
	{
		if (mode != 0)
		{
			return rotation * Quaternion.Euler(0f, 0f - base.LocomotionTeleport.LocomotionController.CameraRig.trackingSpace.localEulerAngles.y, 0f);
		}
		return rotation;
	}
}
public class TeleportOrientationHandler360 : TeleportOrientationHandler
{
	protected override void InitializeTeleportDestination()
	{
	}

	protected override void UpdateTeleportDestination()
	{
		base.LocomotionTeleport.OnUpdateTeleportDestination(AimData.TargetValid, AimData.Destination, null, null);
	}
}
public class TeleportOrientationHandlerHMD : TeleportOrientationHandler
{
	[Tooltip("HeadRelative=Character will orient to match the arrow. ForwardFacing=When user orients to match the arrow, they will be facing the sensors.")]
	public OrientationModes OrientationMode;

	[Tooltip("Should the destination orientation be updated during the aim state in addition to the PreTeleport state?")]
	public bool UpdateOrientationDuringAim;

	[Tooltip("How far from the destination must the HMD be pointing before using it for orientation")]
	public float AimDistanceThreshold;

	[Tooltip("How far from the destination must the HMD be pointing before rejecting the teleport")]
	public float AimDistanceMaxRange;

	private Quaternion _initialRotation;

	protected override void InitializeTeleportDestination()
	{
		_initialRotation = Quaternion.identity;
	}

	protected override void UpdateTeleportDestination()
	{
		if (AimData.Destination.HasValue && (UpdateOrientationDuringAim || base.LocomotionTeleport.CurrentState == LocomotionTeleport.States.PreTeleport))
		{
			Transform centerEyeAnchor = base.LocomotionTeleport.LocomotionController.CameraRig.centerEyeAnchor;
			Vector3 valueOrDefault = AimData.Destination.GetValueOrDefault();
			if (new Plane(Vector3.up, valueOrDefault).Raycast(new Ray(centerEyeAnchor.position, centerEyeAnchor.forward), out var enter))
			{
				Vector3 vector = centerEyeAnchor.position + centerEyeAnchor.forward * enter - valueOrDefault;
				vector.y = 0f;
				float magnitude = vector.magnitude;
				if (magnitude > AimDistanceThreshold)
				{
					vector.Normalize();
					Quaternion value = (_initialRotation = Quaternion.LookRotation(new Vector3(vector.x, 0f, vector.z), Vector3.up));
					if (AimDistanceMaxRange > 0f && magnitude > AimDistanceMaxRange)
					{
						AimData.TargetValid = false;
					}
					base.LocomotionTeleport.OnUpdateTeleportDestination(AimData.TargetValid, AimData.Destination, value, GetLandingOrientation(OrientationMode, value));
					return;
				}
			}
		}
		base.LocomotionTeleport.OnUpdateTeleportDestination(AimData.TargetValid, AimData.Destination, _initialRotation, GetLandingOrientation(OrientationMode, _initialRotation));
	}
}
public class TeleportOrientationHandlerThumbstick : TeleportOrientationHandler
{
	[Tooltip("HeadRelative=Character will orient to match the arrow. ForwardFacing=When user orients to match the arrow, they will be facing the sensors.")]
	public OrientationModes OrientationMode;

	[Tooltip("Which thumbstick is to be used for adjusting the teleport orientation. Supports LTouch, RTouch, or Touch for either.")]
	public OVRInput.Controller Thumbstick;

	[Tooltip("The orientation will only change if the thumbstick magnitude is above this value. This will usually be larger than the TeleportInputHandlerTouch.ThumbstickTeleportThreshold.")]
	public float RotateStickThreshold = 0.8f;

	private Quaternion _initialRotation;

	private Quaternion _currentRotation;

	private Vector2 _lastValidDirection;

	protected override void InitializeTeleportDestination()
	{
		_initialRotation = base.LocomotionTeleport.GetHeadRotationY();
		_currentRotation = _initialRotation;
		_lastValidDirection = default(Vector2);
	}

	protected override void UpdateTeleportDestination()
	{
		float num;
		Vector2 lastValidDirection;
		if (Thumbstick == OVRInput.Controller.Touch)
		{
			Vector2 vector = OVRInput.Get(OVRInput.RawAxis2D.LThumbstick);
			Vector2 vector2 = OVRInput.Get(OVRInput.RawAxis2D.RThumbstick);
			float magnitude = vector.magnitude;
			float magnitude2 = vector2.magnitude;
			if (magnitude > magnitude2)
			{
				num = magnitude;
				lastValidDirection = vector;
			}
			else
			{
				num = magnitude2;
				lastValidDirection = vector2;
			}
		}
		else
		{
			lastValidDirection = ((Thumbstick != OVRInput.Controller.LTouch) ? OVRInput.Get(OVRInput.RawAxis2D.RThumbstick) : OVRInput.Get(OVRInput.RawAxis2D.LThumbstick));
			num = lastValidDirection.magnitude;
		}
		if (!AimData.TargetValid)
		{
			_lastValidDirection = default(Vector2);
		}
		if (num < RotateStickThreshold)
		{
			lastValidDirection = _lastValidDirection;
			num = lastValidDirection.magnitude;
			if (num < RotateStickThreshold)
			{
				_initialRotation = base.LocomotionTeleport.GetHeadRotationY();
				lastValidDirection.x = 0f;
				lastValidDirection.y = 1f;
			}
		}
		else
		{
			_lastValidDirection = lastValidDirection;
		}
		Quaternion quaternion = base.LocomotionTeleport.LocomotionController.CameraRig.trackingSpace.rotation;
		if (num > RotateStickThreshold)
		{
			lastValidDirection /= num;
			Quaternion quaternion2 = _initialRotation * Quaternion.LookRotation(new Vector3(lastValidDirection.x, 0f, lastValidDirection.y), Vector3.up);
			_currentRotation = quaternion * quaternion2;
		}
		else
		{
			_currentRotation = quaternion * base.LocomotionTeleport.GetHeadRotationY();
		}
		base.LocomotionTeleport.OnUpdateTeleportDestination(AimData.TargetValid, AimData.Destination, _currentRotation, GetLandingOrientation(OrientationMode, _currentRotation));
	}
}
public class TeleportPoint : MonoBehaviour
{
	public float dimmingSpeed = 1f;

	public float fullIntensity = 1f;

	public float lowIntensity = 0.5f;

	public Transform destTransform;

	private float lastLookAtTime;

	private void Start()
	{
	}

	public Transform GetDestTransform()
	{
		return destTransform;
	}

	private void Update()
	{
		float value = Mathf.SmoothStep(fullIntensity, lowIntensity, (Time.time - lastLookAtTime) * dimmingSpeed);
		GetComponent<MeshRenderer>().material.SetFloat("_Intensity", value);
	}

	public void OnLookAt()
	{
		lastLookAtTime = Time.time;
	}
}
public abstract class TeleportSupport : MonoBehaviour
{
	private bool _eventsActive;

	protected LocomotionTeleport LocomotionTeleport { get; private set; }

	protected virtual void OnEnable()
	{
		LocomotionTeleport = GetComponent<LocomotionTeleport>();
		AddEventHandlers();
	}

	protected virtual void OnDisable()
	{
		RemoveEventHandlers();
		LocomotionTeleport = null;
	}

	[Conditional("DEBUG_TELEPORT_EVENT_HANDLERS")]
	private void LogEventHandler(string msg)
	{
		UnityEngine.Debug.Log("EventHandler: " + GetType().Name + ": " + msg);
	}

	protected virtual void AddEventHandlers()
	{
		_eventsActive = true;
	}

	protected virtual void RemoveEventHandlers()
	{
		_eventsActive = false;
	}
}
public abstract class TeleportTargetHandler : TeleportSupport
{
	[Tooltip("This bitmask controls which game object layers will be included in the targeting collision tests.")]
	public LayerMask AimCollisionLayerMask;

	protected readonly LocomotionTeleport.AimData AimData = new LocomotionTeleport.AimData();

	private readonly Action _startAimAction;

	private readonly List<Vector3> _aimPoints = new List<Vector3>();

	private const float ERROR_MARGIN = 0.1f;

	protected TeleportTargetHandler()
	{
		_startAimAction = delegate
		{
			StartCoroutine(TargetAimCoroutine());
		};
	}

	protected override void AddEventHandlers()
	{
		base.AddEventHandlers();
		base.LocomotionTeleport.EnterStateAim += _startAimAction;
	}

	protected override void RemoveEventHandlers()
	{
		base.RemoveEventHandlers();
		base.LocomotionTeleport.EnterStateAim -= _startAimAction;
	}

	private IEnumerator TargetAimCoroutine()
	{
		while (base.LocomotionTeleport.CurrentState == LocomotionTeleport.States.Aim)
		{
			ResetAimData();
			Vector3 start = base.LocomotionTeleport.transform.position;
			_aimPoints.Clear();
			base.LocomotionTeleport.AimHandler.GetPoints(_aimPoints);
			for (int i = 0; i < _aimPoints.Count; i++)
			{
				Vector3 end = _aimPoints[i];
				AimData.TargetValid = ConsiderTeleport(start, ref end);
				AimData.Points.Add(end);
				if (AimData.TargetValid)
				{
					AimData.Destination = ConsiderDestination(end);
					AimData.TargetValid = AimData.Destination.HasValue;
					break;
				}
				start = _aimPoints[i];
			}
			base.LocomotionTeleport.OnUpdateAimData(AimData);
			yield return null;
		}
	}

	protected virtual void ResetAimData()
	{
		AimData.Reset();
	}

	protected abstract bool ConsiderTeleport(Vector3 start, ref Vector3 end);

	public virtual Vector3? ConsiderDestination(Vector3 location)
	{
		CapsuleCollider characterController = base.LocomotionTeleport.LocomotionController.CharacterController;
		float num = characterController.radius - 0.1f;
		Vector3 vector = location;
		vector.y += num + 0.1f;
		Vector3 end = vector;
		end.y += characterController.height - 0.1f;
		if (Physics.CheckCapsule(vector, end, num, AimCollisionLayerMask, QueryTriggerInteraction.Ignore))
		{
			return null;
		}
		return location;
	}
}
public class TeleportTargetHandlerNavMesh : TeleportTargetHandler
{
	public int NavMeshAreaMask = -1;

	private NavMeshPath _path;

	private void Awake()
	{
		_path = new NavMeshPath();
	}

	protected override bool ConsiderTeleport(Vector3 start, ref Vector3 end)
	{
		if (base.LocomotionTeleport.AimCollisionTest(start, end, AimCollisionLayerMask, out AimData.TargetHitInfo))
		{
			Vector3 normalized = (end - start).normalized;
			end = start + normalized * AimData.TargetHitInfo.distance;
			return true;
		}
		return false;
	}

	public override Vector3? ConsiderDestination(Vector3 location)
	{
		Vector3? result = base.ConsiderDestination(location);
		if (result.HasValue)
		{
			Vector3 characterPosition = base.LocomotionTeleport.GetCharacterPosition();
			Vector3 valueOrDefault = result.GetValueOrDefault();
			NavMesh.CalculatePath(characterPosition, valueOrDefault, NavMeshAreaMask, _path);
			if (_path.status == NavMeshPathStatus.PathComplete)
			{
				return result;
			}
		}
		return null;
	}

	[Conditional("SHOW_PATH_RESULT")]
	private void OnDrawGizmos()
	{
	}
}
public class TeleportTargetHandlerNode : TeleportTargetHandler
{
	[Tooltip("When checking line of sight to the destination, add this value to the vertical offset for targeting collision checks.")]
	public float LOSOffset = 1f;

	[Tooltip("Teleport logic will only work with TeleportPoint components that exist in the layers specified by this mask.")]
	public LayerMask TeleportLayerMask;

	protected override bool ConsiderTeleport(Vector3 start, ref Vector3 end)
	{
		if (!base.LocomotionTeleport.AimCollisionTest(start, end, (int)AimCollisionLayerMask | (int)TeleportLayerMask, out AimData.TargetHitInfo))
		{
			return false;
		}
		TeleportPoint component = AimData.TargetHitInfo.collider.gameObject.GetComponent<TeleportPoint>();
		if (component == null)
		{
			return false;
		}
		Vector3 position = component.destTransform.position;
		Vector3 end2 = new Vector3(position.x, position.y + LOSOffset, position.z);
		if (base.LocomotionTeleport.AimCollisionTest(start, end2, (int)AimCollisionLayerMask & ~(int)TeleportLayerMask, out AimData.TargetHitInfo))
		{
			return false;
		}
		end = position;
		return true;
	}
}
public class TeleportTargetHandlerPhysical : TeleportTargetHandler
{
	protected override bool ConsiderTeleport(Vector3 start, ref Vector3 end)
	{
		if (base.LocomotionTeleport.AimCollisionTest(start, end, AimCollisionLayerMask, out AimData.TargetHitInfo))
		{
			Vector3 normalized = (end - start).normalized;
			end = start + normalized * AimData.TargetHitInfo.distance;
			return true;
		}
		return false;
	}
}
public abstract class TeleportTransition : TeleportSupport
{
	protected override void AddEventHandlers()
	{
		base.LocomotionTeleport.EnterStateTeleporting += LocomotionTeleportOnEnterStateTeleporting;
		base.AddEventHandlers();
	}

	protected override void RemoveEventHandlers()
	{
		base.LocomotionTeleport.EnterStateTeleporting -= LocomotionTeleportOnEnterStateTeleporting;
		base.RemoveEventHandlers();
	}

	protected abstract void LocomotionTeleportOnEnterStateTeleporting();
}
public class TeleportTransitionBlink : TeleportTransition
{
	[Tooltip("How long the transition takes. Usually this is greater than Teleport Delay.")]
	[Range(0.01f, 2f)]
	public float TransitionDuration = 0.5f;

	[Tooltip("At what percentage of the elapsed transition time does the teleport occur?")]
	[Range(0f, 1f)]
	public float TeleportDelay = 0.5f;

	[Tooltip("Fade to black over the duration of the transition")]
	public AnimationCurve FadeLevels = new AnimationCurve(new Keyframe(0f, 0f), new Keyframe(0.5f, 1f), new Keyframe(1f, 0f));

	protected override void LocomotionTeleportOnEnterStateTeleporting()
	{
		StartCoroutine(BlinkCoroutine());
	}

	protected IEnumerator BlinkCoroutine()
	{
		base.LocomotionTeleport.IsTransitioning = true;
		float elapsedTime = 0f;
		float teleportTime = TransitionDuration * TeleportDelay;
		bool teleported = false;
		while (elapsedTime < TransitionDuration)
		{
			yield return null;
			elapsedTime += Time.deltaTime;
			if (!teleported && elapsedTime >= teleportTime)
			{
				teleported = true;
				base.LocomotionTeleport.DoTeleport();
			}
		}
		base.LocomotionTeleport.IsTransitioning = false;
	}
}
public class TeleportTransitionInstant : TeleportTransition
{
	protected override void LocomotionTeleportOnEnterStateTeleporting()
	{
		base.LocomotionTeleport.DoTeleport();
	}
}
public class TeleportTransitionWarp : TeleportTransition
{
	[Tooltip("How much time the warp transition takes to complete.")]
	[Range(0.01f, 1f)]
	public float TransitionDuration = 0.5f;

	[HideInInspector]
	public AnimationCurve PositionLerp = AnimationCurve.Linear(0f, 0f, 1f, 1f);

	protected override void LocomotionTeleportOnEnterStateTeleporting()
	{
		StartCoroutine(DoWarp());
	}

	private IEnumerator DoWarp()
	{
		base.LocomotionTeleport.IsTransitioning = true;
		Vector3 startPosition = base.LocomotionTeleport.GetCharacterPosition();
		float elapsedTime = 0f;
		while (elapsedTime < TransitionDuration)
		{
			elapsedTime += Time.deltaTime;
			float time = elapsedTime / TransitionDuration;
			float positionPercent = PositionLerp.Evaluate(time);
			base.LocomotionTeleport.DoWarp(startPosition, positionPercent);
			yield return null;
		}
		base.LocomotionTeleport.DoWarp(startPosition, 1f);
		base.LocomotionTeleport.IsTransitioning = false;
	}
}
public static class NativeVideoPlayer
{
	public enum PlabackState
	{
		Idle = 1,
		Preparing,
		Buffering,
		Ready,
		Ended
	}

	public enum StereoMode
	{
		Unknown = -1,
		Mono,
		TopBottom,
		LeftRight,
		Mesh
	}

	private static IntPtr? _Activity;

	private static IntPtr? _VideoPlayerClass;

	private static readonly jvalue[] EmptyParams = new jvalue[0];

	private static IntPtr getIsPlayingMethodId;

	private static IntPtr getCurrentPlaybackStateMethodId;

	private static IntPtr getDurationMethodId;

	private static IntPtr getStereoModeMethodId;

	private static IntPtr getWidthMethodId;

	private static IntPtr getHeightMethodId;

	private static IntPtr getPlaybackPositionMethodId;

	private static IntPtr setPlaybackPositionMethodId;

	private static jvalue[] setPlaybackPositionParams;

	private static IntPtr playVideoMethodId;

	private static jvalue[] playVideoParams;

	private static IntPtr stopMethodId;

	private static IntPtr resumeMethodId;

	private static IntPtr pauseMethodId;

	private static IntPtr setPlaybackSpeedMethodId;

	private static jvalue[] setPlaybackSpeedParams;

	private static IntPtr setLoopingMethodId;

	private static jvalue[] setLoopingParams;

	private static IntPtr setListenerRotationQuaternionMethodId;

	private static jvalue[] setListenerRotationQuaternionParams;

	private static IntPtr VideoPlayerClass
	{
		get
		{
			if (!_VideoPlayerClass.HasValue)
			{
				try
				{
					IntPtr intPtr = AndroidJNI.FindClass("com/oculus/videoplayer/NativeVideoPlayer");
					if (intPtr != IntPtr.Zero)
					{
						_VideoPlayerClass = AndroidJNI.NewGlobalRef(intPtr);
						AndroidJNI.DeleteLocalRef(intPtr);
					}
					else
					{
						UnityEngine.Debug.LogError("Failed to find NativeVideoPlayer class");
						_VideoPlayerClass = IntPtr.Zero;
					}
				}
				catch (Exception exception)
				{
					UnityEngine.Debug.LogError("Failed to find NativeVideoPlayer class");
					UnityEngine.Debug.LogException(exception);
					_VideoPlayerClass = IntPtr.Zero;
				}
			}
			return _VideoPlayerClass.GetValueOrDefault();
		}
	}

	private static IntPtr Activity
	{
		get
		{
			if (!_Activity.HasValue)
			{
				try
				{
					IntPtr intPtr = AndroidJNI.FindClass("com/unity3d/player/UnityPlayer");
					IntPtr staticFieldID = AndroidJNI.GetStaticFieldID(intPtr, "currentActivity", "Landroid/app/Activity;");
					IntPtr staticObjectField = AndroidJNI.GetStaticObjectField(intPtr, staticFieldID);
					_Activity = AndroidJNI.NewGlobalRef(staticObjectField);
					AndroidJNI.DeleteLocalRef(staticObjectField);
					AndroidJNI.DeleteLocalRef(intPtr);
				}
				catch (Exception exception)
				{
					UnityEngine.Debug.LogException(exception);
					_Activity = IntPtr.Zero;
				}
			}
			return _Activity.GetValueOrDefault();
		}
	}

	public static bool IsAvailable => VideoPlayerClass != IntPtr.Zero;

	public static bool IsPlaying
	{
		get
		{
			if (getIsPlayingMethodId == IntPtr.Zero)
			{
				getIsPlayingMethodId = AndroidJNI.GetStaticMethodID(VideoPlayerClass, "getIsPlaying", "()Z");
			}
			return AndroidJNI.CallStaticBooleanMethod(VideoPlayerClass, getIsPlayingMethodId, EmptyParams);
		}
	}

	public static PlabackState CurrentPlaybackState
	{
		get
		{
			if (getCurrentPlaybackStateMethodId == IntPtr.Zero)
			{
				getCurrentPlaybackStateMethodId = AndroidJNI.GetStaticMethodID(VideoPlayerClass, "getCurrentPlaybackState", "()I");
			}
			return (PlabackState)AndroidJNI.CallStaticIntMethod(VideoPlayerClass, getCurrentPlaybackStateMethodId, EmptyParams);
		}
	}

	public static long Duration
	{
		get
		{
			if (getDurationMethodId == IntPtr.Zero)
			{
				getDurationMethodId = AndroidJNI.GetStaticMethodID(VideoPlayerClass, "getDuration", "()J");
			}
			return AndroidJNI.CallStaticLongMethod(VideoPlayerClass, getDurationMethodId, EmptyParams);
		}
	}

	public static StereoMode VideoStereoMode
	{
		get
		{
			if (getStereoModeMethodId == IntPtr.Zero)
			{
				getStereoModeMethodId = AndroidJNI.GetStaticMethodID(VideoPlayerClass, "getStereoMode", "()I");
			}
			return (StereoMode)AndroidJNI.CallStaticIntMethod(VideoPlayerClass, getStereoModeMethodId, EmptyParams);
		}
	}

	public static int VideoWidth
	{
		get
		{
			if (getWidthMethodId == IntPtr.Zero)
			{
				getWidthMethodId = AndroidJNI.GetStaticMethodID(VideoPlayerClass, "getWidth", "()I");
			}
			return AndroidJNI.CallStaticIntMethod(VideoPlayerClass, getWidthMethodId, EmptyParams);
		}
	}

	public static int VideoHeight
	{
		get
		{
			if (getHeightMethodId == IntPtr.Zero)
			{
				getHeightMethodId = AndroidJNI.GetStaticMethodID(VideoPlayerClass, "getHeight", "()I");
			}
			return AndroidJNI.CallStaticIntMethod(VideoPlayerClass, getHeightMethodId, EmptyParams);
		}
	}

	public static long PlaybackPosition
	{
		get
		{
			if (getPlaybackPositionMethodId == IntPtr.Zero)
			{
				getPlaybackPositionMethodId = AndroidJNI.GetStaticMethodID(VideoPlayerClass, "getPlaybackPosition", "()J");
			}
			return AndroidJNI.CallStaticLongMethod(VideoPlayerClass, getPlaybackPositionMethodId, EmptyParams);
		}
		set
		{
			if (setPlaybackPositionMethodId == IntPtr.Zero)
			{
				setPlaybackPositionMethodId = AndroidJNI.GetStaticMethodID(VideoPlayerClass, "setPlaybackPosition", "(J)V");
				setPlaybackPositionParams = new jvalue[1];
			}
			setPlaybackPositionParams[0].j = value;
			AndroidJNI.CallStaticVoidMethod(VideoPlayerClass, setPlaybackPositionMethodId, setPlaybackPositionParams);
		}
	}

	public static void PlayVideo(string path, string drmLicenseUrl, IntPtr surfaceObj)
	{
		if (playVideoMethodId == IntPtr.Zero)
		{
			playVideoMethodId = AndroidJNI.GetStaticMethodID(VideoPlayerClass, "playVideo", "(Landroid/content/Context;Ljava/lang/String;Ljava/lang/String;Landroid/view/Surface;)V");
			playVideoParams = new jvalue[4];
		}
		IntPtr intPtr = AndroidJNI.NewStringUTF(path);
		IntPtr intPtr2 = AndroidJNI.NewStringUTF(drmLicenseUrl);
		playVideoParams[0].l = Activity;
		playVideoParams[1].l = intPtr;
		playVideoParams[2].l = intPtr2;
		playVideoParams[3].l = surfaceObj;
		AndroidJNI.CallStaticVoidMethod(VideoPlayerClass, playVideoMethodId, playVideoParams);
		AndroidJNI.DeleteLocalRef(intPtr);
		AndroidJNI.DeleteLocalRef(intPtr2);
	}

	public static void Stop()
	{
		if (stopMethodId == IntPtr.Zero)
		{
			stopMethodId = AndroidJNI.GetStaticMethodID(VideoPlayerClass, "stop", "()V");
		}
		AndroidJNI.CallStaticVoidMethod(VideoPlayerClass, stopMethodId, EmptyParams);
	}

	public static void Play()
	{
		if (resumeMethodId == IntPtr.Zero)
		{
			resumeMethodId = AndroidJNI.GetStaticMethodID(VideoPlayerClass, "resume", "()V");
		}
		AndroidJNI.CallStaticVoidMethod(VideoPlayerClass, resumeMethodId, EmptyParams);
	}

	public static void Pause()
	{
		if (pauseMethodId == IntPtr.Zero)
		{
			pauseMethodId = AndroidJNI.GetStaticMethodID(VideoPlayerClass, "pause", "()V");
		}
		AndroidJNI.CallStaticVoidMethod(VideoPlayerClass, pauseMethodId, EmptyParams);
	}

	public static void SetPlaybackSpeed(float speed)
	{
		if (setPlaybackSpeedMethodId == IntPtr.Zero)
		{
			setPlaybackSpeedMethodId = AndroidJNI.GetStaticMethodID(VideoPlayerClass, "setPlaybackSpeed", "(F)V");
			setPlaybackSpeedParams = new jvalue[1];
		}
		setPlaybackSpeedParams[0].f = speed;
		AndroidJNI.CallStaticVoidMethod(VideoPlayerClass, setPlaybackSpeedMethodId, setPlaybackSpeedParams);
	}

	public static void SetLooping(bool looping)
	{
		if (setLoopingMethodId == IntPtr.Zero)
		{
			setLoopingMethodId = AndroidJNI.GetStaticMethodID(VideoPlayerClass, "setLooping", "(Z)V");
			setLoopingParams = new jvalue[1];
		}
		setLoopingParams[0].z = looping;
		AndroidJNI.CallStaticVoidMethod(VideoPlayerClass, setLoopingMethodId, setLoopingParams);
	}

	public static void SetListenerRotation(Quaternion rotation)
	{
		if (setListenerRotationQuaternionMethodId == IntPtr.Zero)
		{
			setListenerRotationQuaternionMethodId = AndroidJNI.GetStaticMethodID(VideoPlayerClass, "setListenerRotationQuaternion", "(FFFF)V");
			setListenerRotationQuaternionParams = new jvalue[4];
		}
		setListenerRotationQuaternionParams[0].f = rotation.x;
		setListenerRotationQuaternionParams[1].f = rotation.y;
		setListenerRotationQuaternionParams[2].f = rotation.z;
		setListenerRotationQuaternionParams[3].f = rotation.w;
		AndroidJNI.CallStaticVoidMethod(VideoPlayerClass, setListenerRotationQuaternionMethodId, setListenerRotationQuaternionParams);
	}
}
public class ButtonDownListener : MonoBehaviour, IPointerDownHandler, IEventSystemHandler
{
	public event Action onButtonDown;

	public void OnPointerDown(PointerEventData eventData)
	{
		if (this.onButtonDown != null)
		{
			this.onButtonDown();
		}
	}
}
public class MediaPlayerImage : Image
{
	public enum ButtonType
	{
		Play,
		Pause,
		FastForward,
		Rewind,
		SkipForward,
		SkipBack,
		Stop
	}

	[SerializeField]
	private ButtonType m_ButtonType;

	public ButtonType buttonType
	{
		get
		{
			return m_ButtonType;
		}
		set
		{
			if (m_ButtonType != value)
			{
				m_ButtonType = value;
				SetAllDirty();
			}
		}
	}

	protected override void OnPopulateMesh(VertexHelper toFill)
	{
		Rect pixelAdjustedRect = GetPixelAdjustedRect();
		Vector4 vector = new Vector4(pixelAdjustedRect.x, pixelAdjustedRect.y, pixelAdjustedRect.x + pixelAdjustedRect.width, pixelAdjustedRect.y + pixelAdjustedRect.height);
		Color32 color = this.color;
		toFill.Clear();
		switch (m_ButtonType)
		{
		case ButtonType.Play:
			toFill.AddVert(new Vector3(vector.x, vector.y), color, new Vector2(0f, 0f));
			toFill.AddVert(new Vector3(vector.x, vector.w), color, new Vector2(0f, 1f));
			toFill.AddVert(new Vector3(vector.z, Mathf.Lerp(vector.y, vector.w, 0.5f)), color, new Vector2(1f, 0.5f));
			toFill.AddTriangle(0, 1, 2);
			break;
		case ButtonType.Pause:
			toFill.AddVert(new Vector3(vector.x, vector.y), color, new Vector2(0f, 0f));
			toFill.AddVert(new Vector3(vector.x, vector.w), color, new Vector2(0f, 1f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.35f), vector.w), color, new Vector2(0.35f, 1f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.35f), vector.y), color, new Vector2(0.35f, 0f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.65f), vector.y), color, new Vector2(0.65f, 0f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.65f), vector.w), color, new Vector2(0.65f, 1f));
			toFill.AddVert(new Vector3(vector.z, vector.w), color, new Vector2(1f, 1f));
			toFill.AddVert(new Vector3(vector.z, vector.y), color, new Vector2(1f, 0f));
			toFill.AddTriangle(0, 1, 2);
			toFill.AddTriangle(2, 3, 0);
			toFill.AddTriangle(4, 5, 6);
			toFill.AddTriangle(6, 7, 4);
			break;
		case ButtonType.FastForward:
			toFill.AddVert(new Vector3(vector.x, vector.y), color, new Vector2(0f, 0f));
			toFill.AddVert(new Vector3(vector.x, vector.w), color, new Vector2(0f, 1f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.5f), Mathf.Lerp(vector.y, vector.w, 0.5f)), color, new Vector2(0.5f, 0.5f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.5f), vector.y), color, new Vector2(0.5f, 0f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.5f), vector.w), color, new Vector2(0.5f, 1f));
			toFill.AddVert(new Vector3(vector.z, Mathf.Lerp(vector.y, vector.w, 0.5f)), color, new Vector2(1f, 0.5f));
			toFill.AddTriangle(0, 1, 2);
			toFill.AddTriangle(3, 4, 5);
			break;
		case ButtonType.Rewind:
			toFill.AddVert(new Vector3(vector.x, Mathf.Lerp(vector.y, vector.w, 0.5f)), color, new Vector2(0f, 0.5f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.5f), vector.w), color, new Vector2(0.5f, 1f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.5f), vector.y), color, new Vector2(0.5f, 0f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.5f), Mathf.Lerp(vector.y, vector.w, 0.5f)), color, new Vector2(0.5f, 0.5f));
			toFill.AddVert(new Vector3(vector.z, vector.w), color, new Vector2(1f, 1f));
			toFill.AddVert(new Vector3(vector.z, vector.y), color, new Vector2(1f, 0f));
			toFill.AddTriangle(0, 1, 2);
			toFill.AddTriangle(3, 4, 5);
			break;
		case ButtonType.SkipForward:
			toFill.AddVert(new Vector3(vector.x, vector.y), color, new Vector2(0f, 0f));
			toFill.AddVert(new Vector3(vector.x, vector.w), color, new Vector2(0f, 1f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.4375f), Mathf.Lerp(vector.y, vector.w, 0.5f)), color, new Vector2(0.4375f, 0.5f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.4375f), vector.y), color, new Vector2(0.4375f, 0f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.4375f), vector.w), color, new Vector2(0.4375f, 1f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.875f), Mathf.Lerp(vector.y, vector.w, 0.5f)), color, new Vector2(0.875f, 0.5f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.875f), vector.y), color, new Vector2(0.875f, 0f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.875f), vector.w), color, new Vector2(0.875f, 1f));
			toFill.AddVert(new Vector3(vector.z, vector.w), color, new Vector2(1f, 1f));
			toFill.AddVert(new Vector3(vector.z, vector.y), color, new Vector2(1f, 0f));
			toFill.AddTriangle(0, 1, 2);
			toFill.AddTriangle(3, 4, 5);
			toFill.AddTriangle(6, 7, 8);
			toFill.AddTriangle(8, 9, 6);
			break;
		case ButtonType.SkipBack:
			toFill.AddVert(new Vector3(vector.x, vector.y), color, new Vector2(0f, 0f));
			toFill.AddVert(new Vector3(vector.x, vector.w), color, new Vector2(0f, 1f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.125f), vector.w), color, new Vector2(0.125f, 1f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.125f), vector.y), color, new Vector2(0.125f, 0f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.125f), Mathf.Lerp(vector.y, vector.w, 0.5f)), color, new Vector2(0.125f, 0.5f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.5625f), vector.w), color, new Vector2(0.5625f, 1f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.5625f), vector.y), color, new Vector2(0.5625f, 0f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.5625f), Mathf.Lerp(vector.y, vector.w, 0.5f)), color, new Vector2(0.5625f, 0.5f));
			toFill.AddVert(new Vector3(vector.z, vector.w), color, new Vector2(1f, 1f));
			toFill.AddVert(new Vector3(vector.z, vector.y), color, new Vector2(1f, 0f));
			toFill.AddTriangle(0, 1, 2);
			toFill.AddTriangle(2, 3, 0);
			toFill.AddTriangle(4, 5, 6);
			toFill.AddTriangle(7, 8, 9);
			break;
		default:
			toFill.AddVert(new Vector3(vector.x, vector.y), color, new Vector2(0f, 0f));
			toFill.AddVert(new Vector3(vector.x, vector.w), color, new Vector2(0f, 1f));
			toFill.AddVert(new Vector3(vector.z, vector.w), color, new Vector2(1f, 1f));
			toFill.AddVert(new Vector3(vector.z, vector.y), color, new Vector2(1f, 0f));
			toFill.AddTriangle(0, 1, 2);
			toFill.AddTriangle(2, 3, 0);
			break;
		}
	}
}
public class MoviePlayerSample : MonoBehaviour
{
	public enum VideoShape
	{
		_360,
		_180,
		Quad
	}

	public enum VideoStereo
	{
		Mono,
		TopBottom,
		LeftRight,
		BottomTop
	}

	private bool videoPausedBeforeAppPause;

	private VideoPlayer videoPlayer;

	private OVROverlay overlay;

	private Renderer mediaRenderer;

	private RenderTexture copyTexture;

	private Material externalTex2DMaterial;

	public string MovieName;

	public string DrmLicenseUrl;

	public bool LoopVideo;

	public VideoShape Shape;

	public VideoStereo Stereo;

	public bool AutoDetectStereoLayout;

	public bool DisplayMono;

	private VideoShape _LastShape = (VideoShape)(-1);

	private VideoStereo _LastStereo = (VideoStereo)(-1);

	private bool _LastDisplayMono;

	public bool IsPlaying { get; private set; }

	public long Duration { get; private set; }

	public long PlaybackPosition { get; private set; }

	private void Awake()
	{
		UnityEngine.Debug.Log("MovieSample Awake");
		mediaRenderer = GetComponent<Renderer>();
		videoPlayer = GetComponent<VideoPlayer>();
		if (videoPlayer == null)
		{
			videoPlayer = base.gameObject.AddComponent<VideoPlayer>();
		}
		videoPlayer.isLooping = LoopVideo;
		overlay = GetComponent<OVROverlay>();
		if (overlay == null)
		{
			overlay = base.gameObject.AddComponent<OVROverlay>();
		}
		overlay.enabled = false;
		overlay.isExternalSurface = NativeVideoPlayer.IsAvailable;
		overlay.enabled = overlay.currentOverlayShape != OVROverlay.OverlayShape.Equirect || UnityEngine.Application.platform == RuntimePlatform.Android;
	}

	private bool IsLocalVideo(string movieName)
	{
		return !movieName.Contains("://");
	}

	private void UpdateShapeAndStereo()
	{
		if (AutoDetectStereoLayout && overlay.isExternalSurface)
		{
			int videoWidth = NativeVideoPlayer.VideoWidth;
			int videoHeight = NativeVideoPlayer.VideoHeight;
			switch (NativeVideoPlayer.VideoStereoMode)
			{
			case NativeVideoPlayer.StereoMode.Mono:
				Stereo = VideoStereo.Mono;
				break;
			case NativeVideoPlayer.StereoMode.LeftRight:
				Stereo = VideoStereo.LeftRight;
				break;
			case NativeVideoPlayer.StereoMode.TopBottom:
				Stereo = VideoStereo.TopBottom;
				break;
			case NativeVideoPlayer.StereoMode.Unknown:
				if (videoWidth > videoHeight)
				{
					Stereo = VideoStereo.LeftRight;
				}
				else
				{
					Stereo = VideoStereo.TopBottom;
				}
				break;
			}
		}
		if (Shape != _LastShape || Stereo != _LastStereo || DisplayMono != _LastDisplayMono)
		{
			Rect rect = new Rect(0f, 0f, 1f, 1f);
			switch (Shape)
			{
			case VideoShape._360:
				overlay.currentOverlayShape = OVROverlay.OverlayShape.Equirect;
				break;
			case VideoShape._180:
				overlay.currentOverlayShape = OVROverlay.OverlayShape.Equirect;
				rect = new Rect(0.25f, 0f, 0.5f, 1f);
				break;
			default:
				overlay.currentOverlayShape = OVROverlay.OverlayShape.Quad;
				break;
			}
			overlay.overrideTextureRectMatrix = true;
			overlay.invertTextureRects = false;
			Rect rect2 = new Rect(0f, 0f, 1f, 1f);
			Rect rect3 = new Rect(0f, 0f, 1f, 1f);
			switch (Stereo)
			{
			case VideoStereo.LeftRight:
				rect2 = new Rect(0f, 0f, 0.5f, 1f);
				rect3 = new Rect(0.5f, 0f, 0.5f, 1f);
				break;
			case VideoStereo.TopBottom:
				rect2 = new Rect(0f, 0.5f, 1f, 0.5f);
				rect3 = new Rect(0f, 0f, 1f, 0.5f);
				break;
			case VideoStereo.BottomTop:
				rect2 = new Rect(0f, 0f, 1f, 0.5f);
				rect3 = new Rect(0f, 0.5f, 1f, 0.5f);
				break;
			}
			overlay.SetSrcDestRects(rect2, DisplayMono ? rect2 : rect3, rect, rect);
			_LastDisplayMono = DisplayMono;
			_LastStereo = Stereo;
			_LastShape = Shape;
		}
	}

	private IEnumerator Start()
	{
		if (mediaRenderer.material == null)
		{
			UnityEngine.Debug.LogError("No material for movie surface");
			yield break;
		}
		yield return new WaitForSeconds(1f);
		if (!string.IsNullOrEmpty(MovieName))
		{
			if (IsLocalVideo(MovieName))
			{
				Play(UnityEngine.Application.streamingAssetsPath + "/" + MovieName, null);
			}
			else
			{
				Play(MovieName, DrmLicenseUrl);
			}
		}
	}

	public void Play(string moviePath, string drmLicencesUrl)
	{
		if (moviePath != string.Empty)
		{
			UnityEngine.Debug.Log("Playing Video: " + moviePath);
			if (overlay.isExternalSurface)
			{
				OVROverlay.ExternalSurfaceObjectCreated externalSurfaceObjectCreated = delegate
				{
					UnityEngine.Debug.Log("Playing ExoPlayer with SurfaceObject");
					NativeVideoPlayer.PlayVideo(moviePath, drmLicencesUrl, overlay.externalSurfaceObject);
					NativeVideoPlayer.SetLooping(LoopVideo);
				};
				if (overlay.externalSurfaceObject == IntPtr.Zero)
				{
					overlay.externalSurfaceObjectCreated = externalSurfaceObjectCreated;
				}
				else
				{
					externalSurfaceObjectCreated();
				}
			}
			else
			{
				UnityEngine.Debug.Log("Playing Unity VideoPlayer");
				videoPlayer.url = moviePath;
				videoPlayer.Prepare();
				videoPlayer.Play();
			}
			UnityEngine.Debug.Log("MovieSample Start");
			IsPlaying = true;
		}
		else
		{
			UnityEngine.Debug.LogError("No media file name provided");
		}
	}

	public void Play()
	{
		if (overlay.isExternalSurface)
		{
			NativeVideoPlayer.Play();
		}
		else
		{
			videoPlayer.Play();
		}
		IsPlaying = true;
	}

	public void Pause()
	{
		if (overlay.isExternalSurface)
		{
			NativeVideoPlayer.Pause();
		}
		else
		{
			videoPlayer.Pause();
		}
		IsPlaying = false;
	}

	public void SeekTo(long position)
	{
		long num = Math.Max(0L, Math.Min(Duration, position));
		if (overlay.isExternalSurface)
		{
			NativeVideoPlayer.PlaybackPosition = num;
		}
		else
		{
			videoPlayer.time = (double)num / 1000.0;
		}
	}

	private void Update()
	{
		UpdateShapeAndStereo();
		if (!overlay.isExternalSurface)
		{
			Texture texture = ((videoPlayer.texture != null) ? videoPlayer.texture : Texture2D.blackTexture);
			if (overlay.enabled)
			{
				if (overlay.textures[0] != texture)
				{
					overlay.enabled = false;
					overlay.textures[0] = texture;
					overlay.enabled = true;
				}
			}
			else
			{
				mediaRenderer.material.mainTexture = texture;
				mediaRenderer.material.SetVector("_SrcRectLeft", overlay.srcRectLeft.ToVector());
				mediaRenderer.material.SetVector("_SrcRectRight", overlay.srcRectRight.ToVector());
			}
			IsPlaying = videoPlayer.isPlaying;
			PlaybackPosition = (long)(videoPlayer.time * 1000.0);
			Duration = (long)(videoPlayer.length * 1000.0);
		}
		else
		{
			NativeVideoPlayer.SetListenerRotation(Camera.main.transform.rotation);
			IsPlaying = NativeVideoPlayer.IsPlaying;
			PlaybackPosition = NativeVideoPlayer.PlaybackPosition;
			Duration = NativeVideoPlayer.Duration;
			if (IsPlaying && (int)OVRManager.display.displayFrequency != 60)
			{
				OVRManager.display.displayFrequency = 60f;
			}
			else if (!IsPlaying && (int)OVRManager.display.displayFrequency != 72)
			{
				OVRManager.display.displayFrequency = 72f;
			}
		}
	}

	public void SetPlaybackSpeed(float speed)
	{
		speed = Mathf.Max(0f, speed);
		if (overlay.isExternalSurface)
		{
			NativeVideoPlayer.SetPlaybackSpeed(speed);
		}
		else
		{
			videoPlayer.playbackSpeed = speed;
		}
	}

	public void Stop()
	{
		if (overlay.isExternalSurface)
		{
			NativeVideoPlayer.Stop();
		}
		else
		{
			videoPlayer.Stop();
		}
		IsPlaying = false;
	}

	private void OnApplicationPause(bool appWasPaused)
	{
		UnityEngine.Debug.Log("OnApplicationPause: " + appWasPaused);
		if (appWasPaused)
		{
			videoPausedBeforeAppPause = !IsPlaying;
		}
		if (!videoPausedBeforeAppPause)
		{
			if (appWasPaused)
			{
				Pause();
			}
			else
			{
				Play();
			}
		}
	}
}
public class MoviePlayerSampleControls : MonoBehaviour
{
	private enum PlaybackState
	{
		Playing,
		Paused,
		Rewinding,
		FastForwarding
	}

	public MoviePlayerSample Player;

	public OVRInputModule InputModule;

	public OVRGazePointer GazePointer;

	public GameObject LeftHand;

	public GameObject RightHand;

	public Canvas Canvas;

	public ButtonDownListener PlayPause;

	public MediaPlayerImage PlayPauseImage;

	public Slider ProgressBar;

	public ButtonDownListener FastForward;

	public MediaPlayerImage FastForwardImage;

	public ButtonDownListener Rewind;

	public MediaPlayerImage RewindImage;

	public float TimeoutTime = 10f;

	private bool _isVisible;

	private float _lastButtonTime;

	private bool _didSeek;

	private long _seekPreviousPosition;

	private long _rewindStartPosition;

	private float _rewindStartTime;

	private PlaybackState _state;

	private void Start()
	{
		PlayPause.onButtonDown += OnPlayPauseClicked;
		FastForward.onButtonDown += OnFastForwardClicked;
		Rewind.onButtonDown += OnRewindClicked;
		ProgressBar.onValueChanged.AddListener(OnSeekBarMoved);
		PlayPauseImage.buttonType = MediaPlayerImage.ButtonType.Pause;
		FastForwardImage.buttonType = MediaPlayerImage.ButtonType.SkipForward;
		RewindImage.buttonType = MediaPlayerImage.ButtonType.SkipBack;
		SetVisible(visible: false);
	}

	private void OnPlayPauseClicked()
	{
		switch (_state)
		{
		case PlaybackState.Paused:
			Player.Play();
			PlayPauseImage.buttonType = MediaPlayerImage.ButtonType.Pause;
			FastForwardImage.buttonType = MediaPlayerImage.ButtonType.FastForward;
			RewindImage.buttonType = MediaPlayerImage.ButtonType.Rewind;
			_state = PlaybackState.Playing;
			break;
		case PlaybackState.Playing:
			Player.Pause();
			PlayPauseImage.buttonType = MediaPlayerImage.ButtonType.Play;
			FastForwardImage.buttonType = MediaPlayerImage.ButtonType.SkipForward;
			RewindImage.buttonType = MediaPlayerImage.ButtonType.SkipBack;
			_state = PlaybackState.Paused;
			break;
		case PlaybackState.FastForwarding:
			Player.SetPlaybackSpeed(1f);
			PlayPauseImage.buttonType = MediaPlayerImage.ButtonType.Pause;
			_state = PlaybackState.Playing;
			break;
		case PlaybackState.Rewinding:
			Player.Play();
			_state = PlaybackState.Playing;
			PlayPauseImage.buttonType = MediaPlayerImage.ButtonType.Pause;
			break;
		}
	}

	private void OnFastForwardClicked()
	{
		switch (_state)
		{
		case PlaybackState.FastForwarding:
			Player.SetPlaybackSpeed(1f);
			_state = PlaybackState.Playing;
			PlayPauseImage.buttonType = MediaPlayerImage.ButtonType.Pause;
			break;
		case PlaybackState.Rewinding:
			Player.Play();
			Player.SetPlaybackSpeed(2f);
			_state = PlaybackState.FastForwarding;
			break;
		case PlaybackState.Playing:
			Player.SetPlaybackSpeed(2f);
			PlayPauseImage.buttonType = MediaPlayerImage.ButtonType.Play;
			_state = PlaybackState.FastForwarding;
			break;
		case PlaybackState.Paused:
			Seek(Player.PlaybackPosition + 15000);
			break;
		}
	}

	private void OnRewindClicked()
	{
		switch (_state)
		{
		case PlaybackState.Playing:
		case PlaybackState.FastForwarding:
			Player.SetPlaybackSpeed(1f);
			Player.Pause();
			_rewindStartPosition = Player.PlaybackPosition;
			_rewindStartTime = Time.time;
			PlayPauseImage.buttonType = MediaPlayerImage.ButtonType.Play;
			_state = PlaybackState.Rewinding;
			break;
		case PlaybackState.Rewinding:
			Player.Play();
			PlayPauseImage.buttonType = MediaPlayerImage.ButtonType.Pause;
			_state = PlaybackState.Playing;
			break;
		case PlaybackState.Paused:
			Seek(Player.PlaybackPosition - 15000);
			break;
		}
	}

	private void OnSeekBarMoved(float value)
	{
		long num = (long)(value * (float)Player.Duration);
		if (Mathf.Abs(num - Player.PlaybackPosition) > 200f)
		{
			Seek(num);
		}
	}

	private void Seek(long pos)
	{
		_didSeek = true;
		_seekPreviousPosition = Player.PlaybackPosition;
		Player.SeekTo(pos);
	}

	private void Update()
	{
		if (OVRInput.Get(OVRInput.Button.One) || OVRInput.Get(OVRInput.Button.PrimaryIndexTrigger) || OVRInput.Get(OVRInput.Button.SecondaryIndexTrigger))
		{
			_lastButtonTime = Time.time;
			if (!_isVisible)
			{
				SetVisible(visible: true);
			}
		}
		if (OVRInput.GetActiveController() == OVRInput.Controller.LTouch)
		{
			InputModule.rayTransform = LeftHand.transform;
			GazePointer.rayTransform = LeftHand.transform;
		}
		else
		{
			InputModule.rayTransform = RightHand.transform;
			GazePointer.rayTransform = RightHand.transform;
		}
		if (OVRInput.Get(OVRInput.Button.Back) && _isVisible)
		{
			SetVisible(visible: false);
		}
		if (_state == PlaybackState.Rewinding)
		{
			ProgressBar.value = Mathf.Clamp01(((float)_rewindStartPosition - 1000f * (Time.time - _rewindStartTime)) / (float)Player.Duration);
		}
		if (_isVisible && _state == PlaybackState.Playing && Time.time - _lastButtonTime > TimeoutTime)
		{
			SetVisible(visible: false);
		}
		if (_isVisible && (!_didSeek || Mathf.Abs(_seekPreviousPosition - Player.PlaybackPosition) > 50f))
		{
			_didSeek = false;
			if (Player.Duration > 0)
			{
				ProgressBar.value = (float)((double)Player.PlaybackPosition / (double)Player.Duration);
			}
			else
			{
				ProgressBar.value = 0f;
			}
		}
	}

	private void SetVisible(bool visible)
	{
		Canvas.enabled = visible;
		_isVisible = visible;
		Player.DisplayMono = visible;
		LeftHand.SetActive(visible);
		RightHand.SetActive(visible);
		UnityEngine.Debug.Log("Controls Visible: " + visible);
	}
}
public static class VectorUtil
{
	public static Vector4 ToVector(this Rect rect)
	{
		return new Vector4(rect.x, rect.y, rect.width, rect.height);
	}
}
public class DebugUISample : MonoBehaviour
{
	private bool inMenu;

	private Text sliderText;

	private void Start()
	{
		DebugUIBuilder.instance.AddButton("Button Pressed", LogButtonPressed);
		DebugUIBuilder.instance.AddLabel("Label");
		RectTransform rectTransform = DebugUIBuilder.instance.AddSlider("Slider", 1f, 10f, SliderPressed, wholeNumbersOnly: true);
		Text[] componentsInChildren = rectTransform.GetComponentsInChildren<Text>();
		sliderText = componentsInChildren[1];
		sliderText.text = rectTransform.GetComponentInChildren<Slider>().value.ToString();
		DebugUIBuilder.instance.AddDivider();
		DebugUIBuilder.instance.AddToggle("Toggle", TogglePressed);
		DebugUIBuilder.instance.AddRadio("Radio1", "group", delegate(Toggle t)
		{
			RadioPressed("Radio1", "group", t);
		});
		DebugUIBuilder.instance.AddRadio("Radio2", "group", delegate(Toggle t)
		{
			RadioPressed("Radio2", "group", t);
		});
		DebugUIBuilder.instance.AddLabel("Secondary Tab", 1);
		DebugUIBuilder.instance.AddDivider(1);
		DebugUIBuilder.instance.AddRadio("Side Radio 1", "group2", delegate(Toggle t)
		{
			RadioPressed("Side Radio 1", "group2", t);
		}, 1);
		DebugUIBuilder.instance.AddRadio("Side Radio 2", "group2", delegate(Toggle t)
		{
			RadioPressed("Side Radio 2", "group2", t);
		}, 1);
		DebugUIBuilder.instance.Show();
		inMenu = true;
	}

	public void TogglePressed(Toggle t)
	{
		UnityEngine.Debug.Log("Toggle pressed. Is on? " + t.isOn);
	}

	public void RadioPressed(string radioLabel, string group, Toggle t)
	{
		UnityEngine.Debug.Log("Radio value changed: " + radioLabel + ", from group " + group + ". New value: " + t.isOn);
	}

	public void SliderPressed(float f)
	{
		UnityEngine.Debug.Log("Slider: " + f);
		sliderText.text = f.ToString();
	}

	private void Update()
	{
		if (OVRInput.GetDown(OVRInput.Button.Two) || OVRInput.GetDown(OVRInput.Button.Start))
		{
			if (inMenu)
			{
				DebugUIBuilder.instance.Hide();
			}
			else
			{
				DebugUIBuilder.instance.Show();
			}
			inMenu = !inMenu;
		}
	}

	private void LogButtonPressed()
	{
		UnityEngine.Debug.Log("Button pressed");
	}
}
public class HandsActiveChecker : MonoBehaviour
{
	[SerializeField]
	private GameObject _notificationPrefab;

	private GameObject _notification;

	private OVRCameraRig _cameraRig;

	private Transform _centerEye;

	private void Awake()
	{
		_notification = UnityEngine.Object.Instantiate(_notificationPrefab);
		StartCoroutine(GetCenterEye());
	}

	private void Update()
	{
		if (OVRPlugin.GetHandTrackingEnabled())
		{
			_notification.SetActive(value: false);
			return;
		}
		_notification.SetActive(value: true);
		if ((bool)_centerEye)
		{
			_notification.transform.position = _centerEye.position + _centerEye.forward * 0.5f;
			_notification.transform.rotation = _centerEye.rotation;
		}
	}

	private IEnumerator GetCenterEye()
	{
		if ((_cameraRig = UnityEngine.Object.FindObjectOfType<OVRCameraRig>()) != null)
		{
			while (!_centerEye)
			{
				_centerEye = _cameraRig.centerEyeAnchor;
				yield return null;
			}
		}
	}
}
[ExecuteInEditMode]
public class CharacterCapsule : MonoBehaviour
{
	private CharacterController _character;

	private MeshFilter _meshFilter;

	private float _height;

	private float _radius;

	[Range(4f, 32f)]
	public int SubdivisionsU;

	[Range(4f, 32f)]
	public int SubdivisionsV;

	private int _subdivisionU;

	private int _subdivisionV;

	private Vector3[] _vertices;

	private int[] _triangles;

	private void Update()
	{
		if (_character == null)
		{
			_character = GetComponentInParent<CharacterController>();
			if (_character == null)
			{
				return;
			}
		}
		if (_height == _character.height && _radius == _character.radius && _subdivisionU == SubdivisionsU && _subdivisionV == SubdivisionsV)
		{
			return;
		}
		_height = _character.height;
		_radius = _character.radius;
		_subdivisionU = SubdivisionsU;
		_subdivisionV = SubdivisionsV;
		List<Vector3> list = new List<Vector3>();
		Vector3 vector = new Vector3(1f, 0f, 0f);
		Vector3 vector2 = new Vector3(0f, _height / 2f - _radius, 0f);
		Vector3 vector3 = new Vector3(0f, _radius - _height / 2f, 0f);
		list.Add(new Vector3(0f, _height / 2f, 0f));
		for (int num = SubdivisionsU - 1; num >= 0; num--)
		{
			float num2 = (float)num / (float)SubdivisionsU;
			for (int i = 0; i < SubdivisionsV; i++)
			{
				float num3 = (float)i / (float)SubdivisionsV;
				Vector3 item = Quaternion.Euler(0f, num3 * 360f, num2 * 90f) * vector * _radius + vector2;
				list.Add(item);
			}
		}
		for (int j = 0; j < SubdivisionsU; j++)
		{
			float num4 = (float)j / (float)SubdivisionsU;
			for (int k = 0; k < SubdivisionsV; k++)
			{
				float num5 = (float)k / (float)SubdivisionsV;
				Vector3 vector4 = Quaternion.Euler(0f, num5 * 360f + 180f, num4 * 90f) * vector;
				vector4 *= _radius;
				Vector3 item2 = vector3 - vector4;
				list.Add(item2);
			}
		}
		list.Add(new Vector3(0f, (0f - _height) / 2f, 0f));
		List<int> list2 = new List<int>();
		int item3;
		for (int l = 0; l < SubdivisionsV; l++)
		{
			item3 = 0;
			list2.Add(item3);
			list2.Add(l);
			list2.Add(l + 1);
		}
		list2.Add(0);
		list2.Add(SubdivisionsV);
		list2.Add(1);
		int num6;
		for (int m = 0; m < SubdivisionsU - 1; m++)
		{
			num6 = m * SubdivisionsV + 1;
			for (int n = 0; n < SubdivisionsV - 1; n++)
			{
				item3 = num6 + n;
				list2.Add(item3);
				list2.Add(item3 + SubdivisionsV);
				list2.Add(item3 + 1);
				list2.Add(item3 + 1);
				list2.Add(item3 + SubdivisionsV);
				list2.Add(item3 + SubdivisionsV + 1);
			}
			item3 = num6 + SubdivisionsV - 1;
			list2.Add(item3);
			list2.Add(item3 + SubdivisionsV);
			list2.Add(item3 + 1 - SubdivisionsV);
			list2.Add(item3 + 1 - SubdivisionsV);
			list2.Add(item3 + SubdivisionsV);
			list2.Add(item3 + 1);
		}
		num6 = (SubdivisionsU - 1) * SubdivisionsV + 1;
		for (int num7 = 0; num7 < SubdivisionsV - 1; num7++)
		{
			item3 = num6 + num7;
			list2.Add(item3);
			list2.Add(item3 + SubdivisionsV);
			list2.Add(item3 + 1);
			list2.Add(item3 + 1);
			list2.Add(item3 + SubdivisionsV);
			list2.Add(item3 + SubdivisionsV + 1);
		}
		item3 = num6 + SubdivisionsV - 1;
		list2.Add(item3);
		list2.Add(item3 + SubdivisionsV);
		list2.Add(item3 + 1 - SubdivisionsV);
		list2.Add(item3 + 1 - SubdivisionsV);
		list2.Add(item3 + SubdivisionsV);
		list2.Add(item3 + 1);
		for (int num8 = 0; num8 < SubdivisionsU - 1; num8++)
		{
			num6 = num8 * SubdivisionsV + SubdivisionsU * SubdivisionsV + 1;
			for (int num9 = 0; num9 < SubdivisionsV - 1; num9++)
			{
				item3 = num6 + num9;
				list2.Add(item3);
				list2.Add(item3 + SubdivisionsV);
				list2.Add(item3 + 1);
				list2.Add(item3 + 1);
				list2.Add(item3 + SubdivisionsV);
				list2.Add(item3 + SubdivisionsV + 1);
			}
			item3 = num6 + SubdivisionsV - 1;
			list2.Add(item3);
			list2.Add(item3 + SubdivisionsV);
			list2.Add(item3 + 1 - SubdivisionsV);
			list2.Add(item3 + 1 - SubdivisionsV);
			list2.Add(item3 + SubdivisionsV);
			list2.Add(item3 + 1);
		}
		int num10 = list.Count - 1;
		int num11 = num10 - SubdivisionsV;
		for (int num12 = 0; num12 < SubdivisionsV; num12++)
		{
			item3 = 0;
			list2.Add(num10);
			list2.Add(num11 + num12 + 1);
			list2.Add(num11 + num12);
		}
		list2.Add(num10);
		list2.Add(num11);
		list2.Add(num10 - 1);
		_vertices = list.ToArray();
		_triangles = list2.ToArray();
		_meshFilter = base.gameObject.GetComponent<MeshFilter>();
		_meshFilter.mesh = new Mesh();
		_meshFilter.sharedMesh.vertices = _vertices;
		_meshFilter.sharedMesh.triangles = _triangles;
		_meshFilter.sharedMesh.RecalculateNormals();
	}
}
public class LocomotionSampleSupport : MonoBehaviour
{
	private LocomotionController lc;

	private bool inMenu;

	private LocomotionTeleport TeleportController => lc.GetComponent<LocomotionTeleport>();

	public void Start()
	{
		lc = UnityEngine.Object.FindObjectOfType<LocomotionController>();
		DebugUIBuilder.instance.AddButton("Node Teleport w/ A", SetupNodeTeleport);
		DebugUIBuilder.instance.AddButton("Dual-stick teleport", SetupTwoStickTeleport);
		DebugUIBuilder.instance.AddButton("L Strafe R Teleport", SetupLeftStrafeRightTeleport);
		DebugUIBuilder.instance.AddButton("Walk Only", SetupWalkOnly);
		if (UnityEngine.Object.FindObjectOfType<EventSystem>() == null)
		{
			UnityEngine.Debug.LogError("Need EventSystem");
		}
		SetupTwoStickTeleport();
		Physics.IgnoreLayerCollision(0, 4);
	}

	public void Update()
	{
		if (OVRInput.GetDown(OVRInput.Button.Two) || OVRInput.GetDown(OVRInput.Button.Start))
		{
			if (inMenu)
			{
				DebugUIBuilder.instance.Hide();
			}
			else
			{
				DebugUIBuilder.instance.Show();
			}
			inMenu = !inMenu;
		}
	}

	[Conditional("DEBUG_LOCOMOTION_PANEL")]
	private static void Log(string msg)
	{
		UnityEngine.Debug.Log(msg);
	}

	public static TActivate ActivateCategory<TCategory, TActivate>(GameObject target) where TCategory : MonoBehaviour where TActivate : MonoBehaviour
	{
		TCategory[] components = target.GetComponents<TCategory>();
		Log("Activate " + typeof(TActivate)?.ToString() + " derived from " + typeof(TCategory)?.ToString() + "[" + components.Length + "]");
		TActivate result = null;
		foreach (MonoBehaviour monoBehaviour in components)
		{
			bool flag = monoBehaviour.GetType() == typeof(TActivate);
			Log(monoBehaviour.GetType()?.ToString() + " is " + typeof(TActivate)?.ToString() + " = " + flag);
			if (flag)
			{
				result = (TActivate)monoBehaviour;
			}
			if (monoBehaviour.enabled != flag)
			{
				monoBehaviour.enabled = flag;
			}
		}
		return result;
	}

	protected void ActivateHandlers<TInput, TAim, TTarget, TOrientation, TTransition>() where TInput : TeleportInputHandler where TAim : TeleportAimHandler where TTarget : TeleportTargetHandler where TOrientation : TeleportOrientationHandler where TTransition : TeleportTransition
	{
		ActivateInput<TInput>();
		ActivateAim<TAim>();
		ActivateTarget<TTarget>();
		ActivateOrientation<TOrientation>();
		ActivateTransition<TTransition>();
	}

	protected void ActivateInput<TActivate>() where TActivate : TeleportInputHandler
	{
		ActivateCategory<TeleportInputHandler, TActivate>();
	}

	protected void ActivateAim<TActivate>() where TActivate : TeleportAimHandler
	{
		ActivateCategory<TeleportAimHandler, TActivate>();
	}

	protected void ActivateTarget<TActivate>() where TActivate : TeleportTargetHandler
	{
		ActivateCategory<TeleportTargetHandler, TActivate>();
	}

	protected void ActivateOrientation<TActivate>() where TActivate : TeleportOrientationHandler
	{
		ActivateCategory<TeleportOrientationHandler, TActivate>();
	}

	protected void ActivateTransition<TActivate>() where TActivate : TeleportTransition
	{
		ActivateCategory<TeleportTransition, TActivate>();
	}

	protected TActivate ActivateCategory<TCategory, TActivate>() where TCategory : MonoBehaviour where TActivate : MonoBehaviour
	{
		return ActivateCategory<TCategory, TActivate>(lc.gameObject);
	}

	protected void UpdateToggle(Toggle toggle, bool enabled)
	{
		if (enabled != toggle.isOn)
		{
			toggle.isOn = enabled;
		}
	}

	private void SetupNonCap()
	{
		TeleportInputHandlerTouch component = TeleportController.GetComponent<TeleportInputHandlerTouch>();
		component.InputMode = TeleportInputHandlerTouch.InputModes.SeparateButtonsForAimAndTeleport;
		component.AimButton = OVRInput.RawButton.A;
		component.TeleportButton = OVRInput.RawButton.A;
	}

	private void SetupTeleportDefaults()
	{
		TeleportController.enabled = true;
		lc.PlayerController.RotationEitherThumbstick = false;
		TeleportController.EnableMovement(ready: false, aim: false, pre: false, post: false);
		TeleportController.EnableRotation(ready: false, aim: false, pre: false, post: false);
		TeleportInputHandlerTouch component = TeleportController.GetComponent<TeleportInputHandlerTouch>();
		component.InputMode = TeleportInputHandlerTouch.InputModes.CapacitiveButtonForAimAndTeleport;
		component.AimButton = OVRInput.RawButton.A;
		component.TeleportButton = OVRInput.RawButton.A;
		component.CapacitiveAimAndTeleportButton = TeleportInputHandlerTouch.AimCapTouchButtons.A;
		component.FastTeleport = false;
		TeleportInputHandlerHMD component2 = TeleportController.GetComponent<TeleportInputHandlerHMD>();
		component2.AimButton = OVRInput.RawButton.A;
		component2.TeleportButton = OVRInput.RawButton.A;
		TeleportController.GetComponent<TeleportOrientationHandlerThumbstick>().Thumbstick = OVRInput.Controller.LTouch;
	}

	protected GameObject AddInstance(GameObject template, string label)
	{
		GameObject obj = UnityEngine.Object.Instantiate(template);
		obj.transform.SetParent(base.transform, worldPositionStays: false);
		obj.name = label;
		return obj;
	}

	private void SetupNodeTeleport()
	{
		SetupTeleportDefaults();
		SetupNonCap();
		lc.PlayerController.RotationEitherThumbstick = true;
		TeleportController.EnableRotation(ready: true, aim: false, pre: false, post: true);
		ActivateHandlers<TeleportInputHandlerTouch, TeleportAimHandlerLaser, TeleportTargetHandlerNode, TeleportOrientationHandlerThumbstick, TeleportTransitionBlink>();
		TeleportController.GetComponent<TeleportInputHandlerTouch>().AimingController = OVRInput.Controller.RTouch;
	}

	private void SetupTwoStickTeleport()
	{
		SetupTeleportDefaults();
		TeleportController.EnableRotation(ready: true, aim: false, pre: false, post: true);
		TeleportController.EnableMovement(ready: false, aim: false, pre: false, post: false);
		lc.PlayerController.RotationEitherThumbstick = true;
		TeleportInputHandlerTouch component = TeleportController.GetComponent<TeleportInputHandlerTouch>();
		component.InputMode = TeleportInputHandlerTouch.InputModes.ThumbstickTeleportForwardBackOnly;
		component.AimingController = OVRInput.Controller.Touch;
		ActivateHandlers<TeleportInputHandlerTouch, TeleportAimHandlerParabolic, TeleportTargetHandlerPhysical, TeleportOrientationHandlerThumbstick, TeleportTransitionBlink>();
		TeleportController.GetComponent<TeleportOrientationHandlerThumbstick>().Thumbstick = OVRInput.Controller.Touch;
	}

	private void SetupWalkOnly()
	{
		SetupTeleportDefaults();
		TeleportController.enabled = false;
		lc.PlayerController.EnableLinearMovement = true;
		lc.PlayerController.RotationEitherThumbstick = false;
	}

	private void SetupLeftStrafeRightTeleport()
	{
		SetupTeleportDefaults();
		TeleportController.EnableRotation(ready: true, aim: false, pre: false, post: true);
		TeleportController.EnableMovement(ready: true, aim: false, pre: false, post: false);
		TeleportInputHandlerTouch component = TeleportController.GetComponent<TeleportInputHandlerTouch>();
		component.InputMode = TeleportInputHandlerTouch.InputModes.ThumbstickTeleportForwardBackOnly;
		component.AimingController = OVRInput.Controller.RTouch;
		ActivateHandlers<TeleportInputHandlerTouch, TeleportAimHandlerParabolic, TeleportTargetHandlerPhysical, TeleportOrientationHandlerThumbstick, TeleportTransitionBlink>();
		TeleportController.GetComponent<TeleportOrientationHandlerThumbstick>().Thumbstick = OVRInput.Controller.RTouch;
	}
}
[RequireComponent(typeof(Canvas))]
public class OVROverlayCanvas : MonoBehaviour
{
	public enum DrawMode
	{
		Opaque,
		OpaqueWithClip,
		TransparentDefaultAlpha,
		TransparentCorrectAlpha
	}

	[SerializeField]
	[HideInInspector]
	private Shader _transparentShader;

	[SerializeField]
	[HideInInspector]
	private Shader _opaqueShader;

	private RectTransform _rectTransform;

	private Canvas _canvas;

	private Camera _camera;

	private OVROverlay _overlay;

	private RenderTexture _renderTexture;

	private MeshRenderer _meshRenderer;

	private Mesh _quad;

	private Material _defaultMat;

	public int MaxTextureSize = 1600;

	public int MinTextureSize = 200;

	public float PixelsPerUnit = 1f;

	public int DrawRate = 1;

	public int DrawFrameOffset;

	public bool Expensive;

	public int Layer;

	public DrawMode Opacity = DrawMode.OpaqueWithClip;

	private bool ScaleViewport = UnityEngine.Application.isMobilePlatform;

	private static readonly Plane[] _FrustumPlanes = new Plane[6];

	public bool overlayEnabled
	{
		get
		{
			if ((bool)_overlay)
			{
				return _overlay.enabled;
			}
			return false;
		}
		set
		{
			if ((bool)_overlay)
			{
				_overlay.enabled = value;
				_defaultMat.color = (value ? Color.black : Color.white);
			}
		}
	}

	private void Start()
	{
		_canvas = GetComponent<Canvas>();
		_rectTransform = _canvas.GetComponent<RectTransform>();
		float width = _rectTransform.rect.width;
		float height = _rectTransform.rect.height;
		float num = ((width >= height) ? 1f : (width / height));
		float num2 = ((height >= width) ? 1f : (height / width));
		int num3 = ((!ScaleViewport) ? 8 : 0);
		int num4 = Mathf.CeilToInt(num * (float)(MaxTextureSize - num3 * 2));
		int num5 = Mathf.CeilToInt(num2 * (float)(MaxTextureSize - num3 * 2));
		int num6 = num4 + num3 * 2;
		int num7 = num5 + num3 * 2;
		float x = width * ((float)num6 / (float)num4);
		float num8 = height * ((float)num7 / (float)num5);
		float num9 = (float)num4 / (float)num6;
		float num10 = (float)num5 / (float)num7;
		Vector2 vector = ((Opacity == DrawMode.Opaque) ? new Vector2(0.005f / _rectTransform.lossyScale.x, 0.005f / _rectTransform.lossyScale.y) : Vector2.zero);
		_renderTexture = new RenderTexture(num6, num7, 0, RenderTextureFormat.ARGB32, RenderTextureReadWrite.Linear);
		_renderTexture.useMipMap = !ScaleViewport;
		GameObject gameObject = new GameObject(base.name + " Overlay Camera")
		{
			hideFlags = (HideFlags.HideInHierarchy | HideFlags.NotEditable)
		};
		gameObject.transform.SetParent(base.transform, worldPositionStays: false);
		_camera = gameObject.AddComponent<Camera>();
		_camera.stereoTargetEye = StereoTargetEyeMask.None;
		_camera.transform.position = base.transform.position - base.transform.forward;
		_camera.orthographic = true;
		_camera.enabled = false;
		_camera.targetTexture = _renderTexture;
		_camera.cullingMask = 1 << base.gameObject.layer;
		_camera.clearFlags = CameraClearFlags.Color;
		_camera.backgroundColor = Color.clear;
		_camera.orthographicSize = 0.5f * num8 * _rectTransform.localScale.y;
		_camera.nearClipPlane = 0.99f;
		_camera.farClipPlane = 1.01f;
		_quad = new Mesh
		{
			name = base.name + " Overlay Quad",
			hideFlags = HideFlags.HideAndDontSave
		};
		_quad.vertices = new Vector3[4]
		{
			new Vector3(-0.5f, -0.5f),
			new Vector3(-0.5f, 0.5f),
			new Vector3(0.5f, 0.5f),
			new Vector3(0.5f, -0.5f)
		};
		_quad.uv = new Vector2[4]
		{
			new Vector2(0f, 0f),
			new Vector2(0f, 1f),
			new Vector2(1f, 1f),
			new Vector2(1f, 0f)
		};
		_quad.triangles = new int[6] { 0, 1, 2, 2, 3, 0 };
		_quad.bounds = new Bounds(Vector3.zero, Vector3.one);
		_quad.UploadMeshData(markNoLongerReadable: true);
		switch (Opacity)
		{
		case DrawMode.Opaque:
			_defaultMat = new Material(_opaqueShader);
			break;
		case DrawMode.OpaqueWithClip:
			_defaultMat = new Material(_opaqueShader);
			_defaultMat.EnableKeyword("WITH_CLIP");
			break;
		case DrawMode.TransparentDefaultAlpha:
			_defaultMat = new Material(_transparentShader);
			_defaultMat.EnableKeyword("ALPHA_SQUARED");
			break;
		case DrawMode.TransparentCorrectAlpha:
			_defaultMat = new Material(_transparentShader);
			break;
		}
		_defaultMat.mainTexture = _renderTexture;
		_defaultMat.color = Color.black;
		_defaultMat.mainTextureOffset = new Vector2(0.5f - 0.5f * num9, 0.5f - 0.5f * num10);
		_defaultMat.mainTextureScale = new Vector2(num9, num10);
		GameObject gameObject2 = new GameObject(base.name + " MeshRenderer")
		{
			hideFlags = (HideFlags.HideInHierarchy | HideFlags.NotEditable)
		};
		gameObject2.transform.SetParent(base.transform, worldPositionStays: false);
		gameObject2.AddComponent<MeshFilter>().sharedMesh = _quad;
		_meshRenderer = gameObject2.AddComponent<MeshRenderer>();
		_meshRenderer.sharedMaterial = _defaultMat;
		gameObject2.layer = Layer;
		gameObject2.transform.localScale = new Vector3(width - vector.x, height - vector.y, 1f);
		GameObject gameObject3 = new GameObject(base.name + " Overlay")
		{
			hideFlags = (HideFlags.HideInHierarchy | HideFlags.NotEditable)
		};
		gameObject3.transform.SetParent(base.transform, worldPositionStays: false);
		_overlay = gameObject3.AddComponent<OVROverlay>();
		_overlay.isDynamic = true;
		_overlay.noDepthBufferTesting = true;
		_overlay.isAlphaPremultiplied = !UnityEngine.Application.isMobilePlatform;
		_overlay.textures[0] = _renderTexture;
		_overlay.currentOverlayType = OVROverlay.OverlayType.Underlay;
		_overlay.transform.localScale = new Vector3(x, num8, 1f);
		_overlay.useExpensiveSuperSample = Expensive;
	}

	private void OnDestroy()
	{
		UnityEngine.Object.Destroy(_defaultMat);
		UnityEngine.Object.Destroy(_quad);
		UnityEngine.Object.Destroy(_renderTexture);
	}

	private void OnEnable()
	{
		if ((bool)_overlay)
		{
			_meshRenderer.enabled = true;
			_overlay.enabled = true;
		}
		if ((bool)_camera)
		{
			_camera.enabled = true;
		}
	}

	private void OnDisable()
	{
		if ((bool)_overlay)
		{
			_overlay.enabled = false;
			_meshRenderer.enabled = false;
		}
		if ((bool)_camera)
		{
			_camera.enabled = false;
		}
	}

	protected virtual bool ShouldRender()
	{
		if (DrawRate > 1 && Time.frameCount % DrawRate != DrawFrameOffset % DrawRate)
		{
			return false;
		}
		if (Camera.main != null)
		{
			for (int i = 0; i < 2; i++)
			{
				Camera.StereoscopicEye eye = (Camera.StereoscopicEye)i;
				GeometryUtility.CalculateFrustumPlanes(Camera.main.GetStereoProjectionMatrix(eye) * Camera.main.GetStereoViewMatrix(eye), _FrustumPlanes);
				if (GeometryUtility.TestPlanesAABB(_FrustumPlanes, _meshRenderer.bounds))
				{
					return true;
				}
			}
			return false;
		}
		return true;
	}

	private void Update()
	{
		if (ShouldRender())
		{
			if (ScaleViewport && Camera.main != null)
			{
				float magnitude = (Camera.main.transform.position - base.transform.position).magnitude;
				float value = Mathf.Ceil(PixelsPerUnit * Mathf.Max(_rectTransform.rect.width * base.transform.lossyScale.x, _rectTransform.rect.height * base.transform.lossyScale.y) / magnitude / 8f * (float)_renderTexture.height) * 8f;
				value = Mathf.Clamp(value, MinTextureSize, _renderTexture.height);
				float num = value - 2f;
				_camera.orthographicSize = 0.5f * _rectTransform.rect.height * _rectTransform.localScale.y * value / num;
				float num2 = _rectTransform.rect.width / _rectTransform.rect.height;
				float num3 = num * num2;
				float num4 = Mathf.Ceil((num3 + 2f) * 0.5f) * 2f / (float)_renderTexture.width;
				float num5 = value / (float)_renderTexture.height;
				float num6 = ((Opacity == DrawMode.Opaque) ? 1.001f : 0f);
				float num7 = (num3 - num6) / (float)_renderTexture.width;
				float num8 = (num - num6) / (float)_renderTexture.height;
				_camera.rect = new Rect((1f - num4) / 2f, (1f - num5) / 2f, num4, num5);
				Rect rect = new Rect(0.5f - 0.5f * num7, 0.5f - 0.5f * num8, num7, num8);
				_defaultMat.mainTextureOffset = rect.min;
				_defaultMat.mainTextureScale = rect.size;
				_overlay.overrideTextureRectMatrix = true;
				rect.y = 1f - rect.height - rect.y;
				Rect rect2 = new Rect(0f, 0f, 1f, 1f);
				_overlay.SetSrcDestRects(rect, rect, rect2, rect2);
			}
			_camera.Render();
		}
	}
}
public class StartMenu : MonoBehaviour
{
	public OVROverlay overlay;

	public OVROverlay text;

	public OVRCameraRig vrRig;

	private void Start()
	{
		DebugUIBuilder.instance.AddLabel("Select Sample Scene");
		int sceneCountInBuildSettings = SceneManager.sceneCountInBuildSettings;
		for (int i = 0; i < sceneCountInBuildSettings; i++)
		{
			string scenePathByBuildIndex = SceneUtility.GetScenePathByBuildIndex(i);
			int sceneIndex = i;
			DebugUIBuilder.instance.AddButton(Path.GetFileNameWithoutExtension(scenePathByBuildIndex), delegate
			{
				LoadScene(sceneIndex);
			});
		}
		DebugUIBuilder.instance.Show();
	}

	private void LoadScene(int idx)
	{
		DebugUIBuilder.instance.Hide();
		UnityEngine.Debug.Log("Load scene: " + idx);
		SceneManager.LoadScene(idx);
	}
}
[AddComponentMenu("Camera-Control/Mouse Look")]
public class MouseLook : MonoBehaviour
{
	public enum RotationAxes
	{
		MouseXAndY,
		MouseX,
		MouseY
	}

	public RotationAxes axes;

	public float sensitivityX = 15f;

	public float sensitivityY = 15f;

	public float minimumX = -360f;

	public float maximumX = 360f;

	public float minimumY = -60f;

	public float maximumY = 60f;

	private float rotationY;

	private void Update()
	{
		if (axes == RotationAxes.MouseXAndY)
		{
			float y = base.transform.localEulerAngles.y + Input.GetAxis("Mouse X") * sensitivityX;
			rotationY += Input.GetAxis("Mouse Y") * sensitivityY;
			rotationY = Mathf.Clamp(rotationY, minimumY, maximumY);
			base.transform.localEulerAngles = new Vector3(0f - rotationY, y, 0f);
		}
		else if (axes == RotationAxes.MouseX)
		{
			base.transform.Rotate(0f, Input.GetAxis("Mouse X") * sensitivityX, 0f);
		}
		else
		{
			rotationY += Input.GetAxis("Mouse Y") * sensitivityY;
			rotationY = Mathf.Clamp(rotationY, minimumY, maximumY);
			base.transform.localEulerAngles = new Vector3(0f - rotationY, base.transform.localEulerAngles.y, 0f);
		}
	}

	private void Start()
	{
		if ((bool)GetComponent<Rigidbody>())
		{
			GetComponent<Rigidbody>().freezeRotation = true;
		}
	}
}
public class ONSPAmbisonicsNative : MonoBehaviour
{
	public enum ovrAmbisonicsNativeStatus
	{
		Uninitialized = -1,
		NotEnabled,
		Success,
		StreamError,
		ProcessError,
		MaxStatValue
	}

	private AudioSource source;

	private static int numFOAChannels = 4;

	private static int paramAmbiStat = 6;

	private ovrAmbisonicsNativeStatus currentStatus = ovrAmbisonicsNativeStatus.Uninitialized;

	private void OnEnable()
	{
		source = GetComponent<AudioSource>();
		currentStatus = ovrAmbisonicsNativeStatus.Uninitialized;
		if (source == null)
		{
			UnityEngine.Debug.Log("Ambisonic ERROR: AudioSource does not exist.");
			return;
		}
		if (source.spatialize)
		{
			UnityEngine.Debug.Log("Ambisonic WARNING: Turning spatialize field off for Ambisonic sources.");
			source.spatialize = false;
		}
		if (source.clip == null)
		{
			UnityEngine.Debug.Log("Ambisonic ERROR: AudioSource does not contain an audio clip.");
		}
		else if (source.clip.channels != numFOAChannels)
		{
			UnityEngine.Debug.Log("Ambisonic ERROR: AudioSource clip does not have correct number of channels.");
		}
	}

	private void Update()
	{
		if (source == null)
		{
			return;
		}
		float value = 0f;
		source.GetAmbisonicDecoderFloat(paramAmbiStat, out value);
		ovrAmbisonicsNativeStatus ovrAmbisonicsNativeStatus = (ovrAmbisonicsNativeStatus)value;
		if (ovrAmbisonicsNativeStatus != currentStatus)
		{
			switch (ovrAmbisonicsNativeStatus)
			{
			case ovrAmbisonicsNativeStatus.NotEnabled:
				UnityEngine.Debug.Log("Ambisonic Native: Ambisonic not enabled on clip. Check clip field and turn it on");
				break;
			case ovrAmbisonicsNativeStatus.Uninitialized:
				UnityEngine.Debug.Log("Ambisonic Native: Stream uninitialized");
				break;
			case ovrAmbisonicsNativeStatus.Success:
				UnityEngine.Debug.Log("Ambisonic Native: Stream successfully initialized and playing/playable");
				break;
			case ovrAmbisonicsNativeStatus.StreamError:
				UnityEngine.Debug.Log("Ambisonic Native WARNING: Stream error (bad input format?)");
				break;
			case ovrAmbisonicsNativeStatus.ProcessError:
				UnityEngine.Debug.Log("Ambisonic Native WARNING: Stream process error (check default speaker setup)");
				break;
			}
		}
		currentStatus = ovrAmbisonicsNativeStatus;
	}
}
public class ONSPAudioSource : MonoBehaviour
{
	private enum Parameters
	{
		P_GAIN,
		P_USEINVSQR,
		P_NEAR,
		P_FAR,
		P_RADIUS,
		P_DISABLE_RFL,
		P_AMBISTAT,
		P_READONLY_GLOBAL_RFL_ENABLED,
		P_READONLY_NUM_VOICES,
		P_SENDLEVEL,
		P_NUM
	}

	public const string strONSPS = "AudioPluginOculusSpatializer";

	[SerializeField]
	private bool enableSpatialization = true;

	[SerializeField]
	private float gain;

	[SerializeField]
	private bool useInvSqr;

	[SerializeField]
	private float near = 0.25f;

	[SerializeField]
	private float far = 250f;

	[SerializeField]
	private float volumetricRadius;

	[SerializeField]
	private float reverbSend;

	[SerializeField]
	private bool enableRfl;

	private static ONSPAudioSource RoomReflectionGizmoAS;

	public bool EnableSpatialization
	{
		get
		{
			return enableSpatialization;
		}
		set
		{
			enableSpatialization = value;
		}
	}

	public float Gain
	{
		get
		{
			return gain;
		}
		set
		{
			gain = Mathf.Clamp(value, 0f, 24f);
		}
	}

	public bool UseInvSqr
	{
		get
		{
			return useInvSqr;
		}
		set
		{
			useInvSqr = value;
		}
	}

	public float Near
	{
		get
		{
			return near;
		}
		set
		{
			near = Mathf.Clamp(value, 0f, 1000000f);
		}
	}

	public float Far
	{
		get
		{
			return far;
		}
		set
		{
			far = Mathf.Clamp(value, 0f, 1000000f);
		}
	}

	public float VolumetricRadius
	{
		get
		{
			return volumetricRadius;
		}
		set
		{
			volumetricRadius = Mathf.Clamp(value, 0f, 1000f);
		}
	}

	public float ReverbSend
	{
		get
		{
			return reverbSend;
		}
		set
		{
			reverbSend = Mathf.Clamp(value, -60f, 20f);
		}
	}

	public bool EnableRfl
	{
		get
		{
			return enableRfl;
		}
		set
		{
			enableRfl = value;
		}
	}

	[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
	private static void OnBeforeSceneLoadRuntimeMethod()
	{
		OSP_SetGlobalVoiceLimit(ONSPSettings.Instance.voiceLimit);
	}

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern void ONSP_GetGlobalRoomReflectionValues(ref bool reflOn, ref bool reverbOn, ref float width, ref float height, ref float length);

	private void Awake()
	{
		AudioSource source = GetComponent<AudioSource>();
		SetParameters(ref source);
	}

	private void Start()
	{
	}

	private void Update()
	{
		AudioSource source = GetComponent<AudioSource>();
		if (!UnityEngine.Application.isPlaying || AudioListener.pause || !source.isPlaying || !source.isActiveAndEnabled)
		{
			source.spatialize = false;
		}
		else
		{
			SetParameters(ref source);
		}
	}

	public void SetParameters(ref AudioSource source)
	{
		source.spatialize = enableSpatialization;
		source.SetSpatializerFloat(0, gain);
		if (useInvSqr)
		{
			source.SetSpatializerFloat(1, 1f);
		}
		else
		{
			source.SetSpatializerFloat(1, 0f);
		}
		source.SetSpatializerFloat(2, near);
		source.SetSpatializerFloat(3, far);
		source.SetSpatializerFloat(4, volumetricRadius);
		if (enableRfl)
		{
			source.SetSpatializerFloat(5, 0f);
		}
		else
		{
			source.SetSpatializerFloat(5, 1f);
		}
		source.SetSpatializerFloat(9, reverbSend);
	}

	private void OnDrawGizmos()
	{
		if (RoomReflectionGizmoAS == null)
		{
			RoomReflectionGizmoAS = this;
		}
		Color color = default(Color);
		color.r = 1f;
		color.g = 0.5f;
		color.b = 0f;
		color.a = 1f;
		Gizmos.color = color;
		Gizmos.DrawWireSphere(base.transform.position, Near);
		color.a = 0.1f;
		Gizmos.color = color;
		Gizmos.DrawSphere(base.transform.position, Near);
		color.r = 1f;
		color.g = 0f;
		color.b = 0f;
		color.a = 1f;
		Gizmos.color = Color.red;
		Gizmos.DrawWireSphere(base.transform.position, Far);
		color.a = 0.1f;
		Gizmos.color = color;
		Gizmos.DrawSphere(base.transform.position, Far);
		color.r = 1f;
		color.g = 0f;
		color.b = 1f;
		color.a = 1f;
		Gizmos.color = color;
		Gizmos.DrawWireSphere(base.transform.position, VolumetricRadius);
		color.a = 0.1f;
		Gizmos.color = color;
		Gizmos.DrawSphere(base.transform.position, VolumetricRadius);
		if (RoomReflectionGizmoAS == this)
		{
			bool reflOn = false;
			bool reverbOn = false;
			float width = 1f;
			float height = 1f;
			float length = 1f;
			ONSP_GetGlobalRoomReflectionValues(ref reflOn, ref reverbOn, ref width, ref height, ref length);
			if (Camera.main != null && reflOn)
			{
				color = (Gizmos.color = ((!reverbOn) ? Color.cyan : Color.white));
				Gizmos.DrawWireCube(Camera.main.transform.position, new Vector3(width, height, length));
				color.a = 0.1f;
				Gizmos.color = color;
				Gizmos.DrawCube(Camera.main.transform.position, new Vector3(width, height, length));
			}
		}
	}

	private void OnDestroy()
	{
		if (RoomReflectionGizmoAS == this)
		{
			RoomReflectionGizmoAS = null;
		}
	}

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_SetGlobalVoiceLimit(int VoiceLimit);
}
public class ONSPProfiler : MonoBehaviour
{
	public bool profilerEnabled;

	private const int DEFAULT_PORT = 2121;

	public int port = 2121;

	public const string strONSPS = "AudioPluginOculusSpatializer";

	private void Start()
	{
		UnityEngine.Application.runInBackground = true;
	}

	private void Update()
	{
		if (port < 0 || port > 65535)
		{
			port = 2121;
		}
		ONSP_SetProfilerPort(port);
		ONSP_SetProfilerEnabled(profilerEnabled);
	}

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int ONSP_SetProfilerEnabled(bool enabled);

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int ONSP_SetProfilerPort(int port);
}
public class ONSPPropagationGeometry : MonoBehaviour
{
	private struct MeshMaterial
	{
		public MeshFilter meshFilter;

		public ONSPPropagationMaterial[] materials;
	}

	private struct TerrainMaterial
	{
		public Terrain terrain;

		public ONSPPropagationMaterial[] materials;

		public Mesh[] treePrototypeMeshes;
	}

	public static string GeometryAssetDirectory = "AudioGeometry";

	public string filePathRelative = "";

	public bool fileEnabled;

	public bool includeChildMeshes = true;

	private IntPtr geometryHandle = IntPtr.Zero;

	public static int OSPSuccess = 0;

	public const string GEOMETRY_FILE_EXTENSION = "ovramesh";

	private static int terrainDecimation = 4;

	public static string GeometryAssetPath => UnityEngine.Application.streamingAssetsPath + "/" + GeometryAssetDirectory;

	public string filePath => GeometryAssetPath + "/" + filePathRelative;

	private static string GetPath(Transform current)
	{
		if (current.parent == null)
		{
			return current.gameObject.scene.name + "/" + current.name;
		}
		return GetPath(current.parent) + "-" + current.name;
	}

	private void Awake()
	{
		CreatePropagationGeometry();
	}

	private void CreatePropagationGeometry()
	{
		if (ONSPPropagation.Interface.CreateAudioGeometry(out geometryHandle) != OSPSuccess)
		{
			throw new Exception("Unable to create geometry handle");
		}
		if (filePath != null && filePath.Length != 0 && fileEnabled && UnityEngine.Application.isPlaying)
		{
			if (!ReadFile())
			{
				UnityEngine.Debug.LogError("Failed to read file, attempting to regenerate audio geometry");
				UploadGeometry();
			}
		}
		else
		{
			UploadGeometry();
		}
	}

	private void Update()
	{
		if (!(geometryHandle == IntPtr.Zero))
		{
			Matrix4x4 localToWorldMatrix = base.transform.localToWorldMatrix;
			float[] matrix4x = new float[16]
			{
				localToWorldMatrix[0, 0],
				localToWorldMatrix[1, 0],
				0f - localToWorldMatrix[2, 0],
				localToWorldMatrix[3, 0],
				localToWorldMatrix[0, 1],
				localToWorldMatrix[1, 1],
				0f - localToWorldMatrix[2, 1],
				localToWorldMatrix[3, 1],
				localToWorldMatrix[0, 2],
				localToWorldMatrix[1, 2],
				0f - localToWorldMatrix[2, 2],
				localToWorldMatrix[3, 2],
				localToWorldMatrix[0, 3],
				localToWorldMatrix[1, 3],
				0f - localToWorldMatrix[2, 3],
				localToWorldMatrix[3, 3]
			};
			ONSPPropagation.Interface.AudioGeometrySetTransform(geometryHandle, matrix4x);
		}
	}

	private void OnDestroy()
	{
		if (geometryHandle != IntPtr.Zero && ONSPPropagation.Interface.DestroyAudioGeometry(geometryHandle) != OSPSuccess)
		{
			throw new Exception("Unable to destroy geometry");
		}
		geometryHandle = IntPtr.Zero;
	}

	private static void traverseMeshHierarchy(GameObject obj, ONSPPropagationMaterial[] currentMaterials, bool includeChildren, List<MeshMaterial> meshMaterials, List<TerrainMaterial> terrainMaterials, bool ignoreStatic, ref int ignoredMeshCount)
	{
		if (!obj.activeInHierarchy)
		{
			return;
		}
		MeshFilter[] components = obj.GetComponents<MeshFilter>();
		Terrain[] components2 = obj.GetComponents<Terrain>();
		ONSPPropagationMaterial[] components3 = obj.GetComponents<ONSPPropagationMaterial>();
		if (components3 != null && components3.Length != 0)
		{
			int num = components3.Length;
			if (currentMaterials != null)
			{
				num = Math.Max(num, currentMaterials.Length);
			}
			ONSPPropagationMaterial[] array = new ONSPPropagationMaterial[num];
			if (currentMaterials != null)
			{
				for (int i = components3.Length; i < num; i++)
				{
					array[i] = currentMaterials[i];
				}
			}
			currentMaterials = array;
			for (int j = 0; j < components3.Length; j++)
			{
				currentMaterials[j] = components3[j];
			}
		}
		MeshFilter[] array2 = components;
		foreach (MeshFilter meshFilter in array2)
		{
			Mesh sharedMesh = meshFilter.sharedMesh;
			if (!(sharedMesh == null))
			{
				if (ignoreStatic && !sharedMesh.isReadable)
				{
					UnityEngine.Debug.LogWarning("Mesh: " + meshFilter.gameObject.name + " not readable, cannot be static.", meshFilter.gameObject);
					ignoredMeshCount++;
					continue;
				}
				MeshMaterial item = default(MeshMaterial);
				item.meshFilter = meshFilter;
				item.materials = currentMaterials;
				meshMaterials.Add(item);
			}
		}
		Terrain[] array3 = components2;
		foreach (Terrain terrain in array3)
		{
			TerrainMaterial item2 = default(TerrainMaterial);
			item2.terrain = terrain;
			item2.materials = currentMaterials;
			terrainMaterials.Add(item2);
		}
		if (!includeChildren)
		{
			return;
		}
		foreach (Transform item3 in obj.transform)
		{
			if (item3.GetComponent<ONSPPropagationGeometry>() == null)
			{
				traverseMeshHierarchy(item3.gameObject, currentMaterials, includeChildren, meshMaterials, terrainMaterials, ignoreStatic, ref ignoredMeshCount);
			}
		}
	}

	private int uploadMesh(IntPtr geometryHandle, GameObject meshObject, Matrix4x4 worldToLocal)
	{
		int ignoredMeshCount = 0;
		return uploadMesh(geometryHandle, meshObject, worldToLocal, ignoreStatic: false, ref ignoredMeshCount);
	}

	private int uploadMesh(IntPtr geometryHandle, GameObject meshObject, Matrix4x4 worldToLocal, bool ignoreStatic, ref int ignoredMeshCount)
	{
		List<MeshMaterial> list = new List<MeshMaterial>();
		List<TerrainMaterial> list2 = new List<TerrainMaterial>();
		traverseMeshHierarchy(meshObject, null, includeChildMeshes, list, list2, ignoreStatic, ref ignoredMeshCount);
		ONSPPropagationMaterial[] array = new ONSPPropagationMaterial[1] { base.gameObject.AddComponent<ONSPPropagationMaterial>() };
		array[0].SetPreset(ONSPPropagationMaterial.Preset.Foliage);
		int totalVertexCount = 0;
		uint totalIndexCount = 0u;
		int totalFaceCount = 0;
		int totalMaterialCount = 0;
		foreach (MeshMaterial item in list)
		{
			updateCountsForMesh(ref totalVertexCount, ref totalIndexCount, ref totalFaceCount, ref totalMaterialCount, item.meshFilter.sharedMesh);
		}
		for (int i = 0; i < list2.Count; i++)
		{
			TerrainMaterial value = list2[i];
			TerrainData terrainData = value.terrain.terrainData;
			int heightmapResolution = terrainData.heightmapResolution;
			int heightmapResolution2 = terrainData.heightmapResolution;
			int num = (heightmapResolution - 1) / terrainDecimation + 1;
			int num2 = (heightmapResolution2 - 1) / terrainDecimation + 1;
			int num3 = num * num2;
			int num4 = (num - 1) * (num2 - 1) * 6;
			totalMaterialCount++;
			totalVertexCount += num3;
			totalIndexCount += (uint)num4;
			totalFaceCount += num4 / 3;
			TreePrototype[] treePrototypes = terrainData.treePrototypes;
			value.treePrototypeMeshes = new Mesh[treePrototypes.Length];
			for (int j = 0; j < treePrototypes.Length; j++)
			{
				MeshFilter[] componentsInChildren = treePrototypes[j].prefab.GetComponentsInChildren<MeshFilter>();
				int num5 = int.MaxValue;
				int num6 = -1;
				for (int k = 0; k < componentsInChildren.Length; k++)
				{
					int vertexCount = componentsInChildren[k].sharedMesh.vertexCount;
					if (vertexCount < num5)
					{
						num5 = vertexCount;
						num6 = k;
					}
				}
				value.treePrototypeMeshes[j] = componentsInChildren[num6].sharedMesh;
			}
			TreeInstance[] treeInstances = terrainData.treeInstances;
			for (int l = 0; l < treeInstances.Length; l++)
			{
				TreeInstance treeInstance = treeInstances[l];
				updateCountsForMesh(ref totalVertexCount, ref totalIndexCount, ref totalFaceCount, ref totalMaterialCount, value.treePrototypeMeshes[treeInstance.prototypeIndex]);
			}
			list2[i] = value;
		}
		List<Vector3> tempVertices = new List<Vector3>();
		List<int> tempIndices = new List<int>();
		MeshGroup[] array2 = new MeshGroup[totalMaterialCount];
		float[] array3 = new float[totalVertexCount * 3];
		int[] array4 = new int[totalIndexCount];
		int vertexOffset = 0;
		int indexOffset = 0;
		int groupOffset = 0;
		foreach (MeshMaterial item2 in list)
		{
			MeshFilter meshFilter = item2.meshFilter;
			Matrix4x4 matrix = worldToLocal * meshFilter.gameObject.transform.localToWorldMatrix;
			uploadMeshFilter(tempVertices, tempIndices, array2, array3, array4, ref vertexOffset, ref indexOffset, ref groupOffset, meshFilter.sharedMesh, item2.materials, matrix);
		}
		foreach (TerrainMaterial item3 in list2)
		{
			TerrainData terrainData2 = item3.terrain.terrainData;
			Matrix4x4 matrix4x = worldToLocal * item3.terrain.gameObject.transform.localToWorldMatrix;
			int heightmapResolution3 = terrainData2.heightmapResolution;
			int heightmapResolution4 = terrainData2.heightmapResolution;
			float[,] heights = terrainData2.GetHeights(0, 0, heightmapResolution3, heightmapResolution4);
			Vector3 size = terrainData2.size;
			size = new Vector3(size.x / (float)(heightmapResolution3 - 1) * (float)terrainDecimation, size.y, size.z / (float)(heightmapResolution4 - 1) * (float)terrainDecimation);
			int num7 = (heightmapResolution3 - 1) / terrainDecimation + 1;
			int num8 = (heightmapResolution4 - 1) / terrainDecimation + 1;
			int num9 = num7 * num8;
			int num10 = (num7 - 1) * (num8 - 1) * 2;
			array2[groupOffset].faceType = FaceType.TRIANGLES;
			array2[groupOffset].faceCount = (UIntPtr)(ulong)num10;
			array2[groupOffset].indexOffset = (UIntPtr)(ulong)indexOffset;
			if (item3.materials != null && item3.materials.Length != 0)
			{
				item3.materials[0].StartInternal();
				array2[groupOffset].material = item3.materials[0].materialHandle;
			}
			else
			{
				array2[groupOffset].material = IntPtr.Zero;
			}
			for (int m = 0; m < num8; m++)
			{
				for (int n = 0; n < num7; n++)
				{
					int num11 = (vertexOffset + m * num7 + n) * 3;
					Vector3 vector = matrix4x.MultiplyPoint3x4(Vector3.Scale(size, new Vector3(m, heights[n * terrainDecimation, m * terrainDecimation], n)));
					array3[num11] = vector.x;
					array3[num11 + 1] = vector.y;
					array3[num11 + 2] = vector.z;
				}
			}
			for (int num12 = 0; num12 < num8 - 1; num12++)
			{
				for (int num13 = 0; num13 < num7 - 1; num13++)
				{
					array4[indexOffset] = vertexOffset + num12 * num7 + num13;
					array4[indexOffset + 1] = vertexOffset + num12 * num7 + num13 + 1;
					array4[indexOffset + 2] = vertexOffset + (num12 + 1) * num7 + num13;
					array4[indexOffset + 3] = vertexOffset + (num12 + 1) * num7 + num13;
					array4[indexOffset + 4] = vertexOffset + num12 * num7 + num13 + 1;
					array4[indexOffset + 5] = vertexOffset + (num12 + 1) * num7 + num13 + 1;
					indexOffset += 6;
				}
			}
			vertexOffset += num9;
			groupOffset++;
			TreeInstance[] treeInstances = terrainData2.treeInstances;
			for (int l = 0; l < treeInstances.Length; l++)
			{
				TreeInstance treeInstance2 = treeInstances[l];
				Vector3 vector2 = Vector3.Scale(treeInstance2.position, terrainData2.size);
				Matrix4x4 localToWorldMatrix = item3.terrain.gameObject.transform.localToWorldMatrix;
				localToWorldMatrix.SetColumn(3, localToWorldMatrix.GetColumn(3) + new Vector4(vector2.x, vector2.y, vector2.z, 0f));
				Matrix4x4 matrix2 = worldToLocal * localToWorldMatrix;
				uploadMeshFilter(tempVertices, tempIndices, array2, array3, array4, ref vertexOffset, ref indexOffset, ref groupOffset, item3.treePrototypeMeshes[treeInstance2.prototypeIndex], array, matrix2);
			}
		}
		return ONSPPropagation.Interface.AudioGeometryUploadMeshArrays(geometryHandle, array3, totalVertexCount, array4, array4.Length, array2, array2.Length);
	}

	private static void uploadMeshFilter(List<Vector3> tempVertices, List<int> tempIndices, MeshGroup[] groups, float[] vertices, int[] indices, ref int vertexOffset, ref int indexOffset, ref int groupOffset, Mesh mesh, ONSPPropagationMaterial[] materials, Matrix4x4 matrix)
	{
		tempVertices.Clear();
		mesh.GetVertices(tempVertices);
		int count = tempVertices.Count;
		for (int i = 0; i < count; i++)
		{
			Vector3 vector = matrix.MultiplyPoint3x4(tempVertices[i]);
			int num = (vertexOffset + i) * 3;
			vertices[num] = vector.x;
			vertices[num + 1] = vector.y;
			vertices[num + 2] = vector.z;
		}
		for (int j = 0; j < mesh.subMeshCount; j++)
		{
			MeshTopology topology = mesh.GetTopology(j);
			if (topology != 0 && topology != MeshTopology.Quads)
			{
				continue;
			}
			tempIndices.Clear();
			mesh.GetIndices(tempIndices, j);
			int count2 = tempIndices.Count;
			for (int k = 0; k < count2; k++)
			{
				indices[indexOffset + k] = tempIndices[k] + vertexOffset;
			}
			switch (topology)
			{
			case MeshTopology.Triangles:
				groups[groupOffset + j].faceType = FaceType.TRIANGLES;
				groups[groupOffset + j].faceCount = (UIntPtr)(ulong)(count2 / 3);
				break;
			case MeshTopology.Quads:
				groups[groupOffset + j].faceType = FaceType.QUADS;
				groups[groupOffset + j].faceCount = (UIntPtr)(ulong)(count2 / 4);
				break;
			}
			groups[groupOffset + j].indexOffset = (UIntPtr)(ulong)indexOffset;
			if (materials != null && materials.Length != 0)
			{
				int num2 = j;
				if (num2 >= materials.Length)
				{
					num2 = materials.Length - 1;
				}
				materials[num2].StartInternal();
				groups[groupOffset + j].material = materials[num2].materialHandle;
			}
			else
			{
				groups[groupOffset + j].material = IntPtr.Zero;
			}
			indexOffset += count2;
		}
		vertexOffset += count;
		groupOffset += mesh.subMeshCount;
	}

	private static void updateCountsForMesh(ref int totalVertexCount, ref uint totalIndexCount, ref int totalFaceCount, ref int totalMaterialCount, Mesh mesh)
	{
		totalMaterialCount += mesh.subMeshCount;
		totalVertexCount += mesh.vertexCount;
		for (int i = 0; i < mesh.subMeshCount; i++)
		{
			MeshTopology topology = mesh.GetTopology(i);
			if (topology == MeshTopology.Triangles || topology == MeshTopology.Quads)
			{
				uint indexCount = mesh.GetIndexCount(i);
				totalIndexCount += indexCount;
				switch (topology)
				{
				case MeshTopology.Triangles:
					totalFaceCount += (int)indexCount / 3;
					break;
				case MeshTopology.Quads:
					totalFaceCount += (int)indexCount / 4;
					break;
				}
			}
		}
	}

	public void UploadGeometry()
	{
		int ignoredMeshCount = 0;
		if (uploadMesh(geometryHandle, base.gameObject, base.gameObject.transform.worldToLocalMatrix, ignoreStatic: true, ref ignoredMeshCount) != OSPSuccess)
		{
			throw new Exception("Unable to upload audio mesh geometry");
		}
		if (ignoredMeshCount != 0)
		{
			UnityEngine.Debug.LogError("Failed to upload meshes, " + ignoredMeshCount + " static meshes ignored. Turn on \"File Enabled\" to process static meshes offline", base.gameObject);
		}
	}

	public bool ReadFile()
	{
		if (filePath == null || filePath.Length == 0)
		{
			UnityEngine.Debug.LogError("Invalid mesh file path");
			return false;
		}
		if (ONSPPropagation.Interface.AudioGeometryReadMeshFile(geometryHandle, filePath) != OSPSuccess)
		{
			UnityEngine.Debug.LogError("Error reading mesh file " + filePath);
			return false;
		}
		return true;
	}

	public bool WriteToObj()
	{
		IntPtr geometry = IntPtr.Zero;
		if (ONSPPropagation.Interface.CreateAudioGeometry(out geometry) != OSPSuccess)
		{
			throw new Exception("Failed to create temp geometry handle");
		}
		if (uploadMesh(geometry, base.gameObject, base.gameObject.transform.worldToLocalMatrix) != OSPSuccess)
		{
			UnityEngine.Debug.LogError("Error uploading mesh " + base.gameObject.name);
			return false;
		}
		if (ONSPPropagation.Interface.AudioGeometryWriteMeshFileObj(geometry, filePath + ".obj") != OSPSuccess)
		{
			UnityEngine.Debug.LogError("Error writing .obj file " + filePath + ".obj");
			return false;
		}
		if (ONSPPropagation.Interface.DestroyAudioGeometry(geometry) != OSPSuccess)
		{
			throw new Exception("Failed to destroy temp geometry handle");
		}
		return true;
	}
}
internal class ONSPPropagation
{
	public enum ovrAudioScalarType : uint
	{
		Int8,
		UInt8,
		Int16,
		UInt16,
		Int32,
		UInt32,
		Int64,
		UInt64,
		Float16,
		Float32,
		Float64
	}

	public class ClientType
	{
		public const uint OVRA_CLIENT_TYPE_NATIVE = 0u;

		public const uint OVRA_CLIENT_TYPE_WWISE_2016 = 1u;

		public const uint OVRA_CLIENT_TYPE_WWISE_2017_1 = 2u;

		public const uint OVRA_CLIENT_TYPE_WWISE_2017_2 = 3u;

		public const uint OVRA_CLIENT_TYPE_WWISE_2018_1 = 4u;

		public const uint OVRA_CLIENT_TYPE_FMOD = 5u;

		public const uint OVRA_CLIENT_TYPE_UNITY = 6u;

		public const uint OVRA_CLIENT_TYPE_UE4 = 7u;

		public const uint OVRA_CLIENT_TYPE_VST = 8u;

		public const uint OVRA_CLIENT_TYPE_AAX = 9u;

		public const uint OVRA_CLIENT_TYPE_TEST = 10u;

		public const uint OVRA_CLIENT_TYPE_OTHER = 11u;

		public const uint OVRA_CLIENT_TYPE_WWISE_UNKNOWN = 12u;

		public const uint OVRA_CLIENT_TYPE_WWISE_2019_1 = 13u;

		public const uint OVRA_CLIENT_TYPE_WWISE_2019_2 = 14u;
	}

	public interface PropagationInterface
	{
		int SetPropagationQuality(float quality);

		int SetPropagationThreadAffinity(ulong cpuMask);

		int CreateAudioGeometry(out IntPtr geometry);

		int DestroyAudioGeometry(IntPtr geometry);

		int AudioGeometryUploadMeshArrays(IntPtr geometry, float[] vertices, int vertexCount, int[] indices, int indexCount, MeshGroup[] groups, int groupCount);

		int AudioGeometrySetTransform(IntPtr geometry, float[] matrix4x4);

		int AudioGeometryGetTransform(IntPtr geometry, out float[] matrix4x4);

		int AudioGeometryWriteMeshFile(IntPtr geometry, string filePath);

		int AudioGeometryReadMeshFile(IntPtr geometry, string filePath);

		int AudioGeometryWriteMeshFileObj(IntPtr geometry, string filePath);

		int AudioMaterialGetFrequency(IntPtr material, MaterialProperty property, float frequency, out float value);

		int CreateAudioMaterial(out IntPtr material);

		int DestroyAudioMaterial(IntPtr material);

		int AudioMaterialSetFrequency(IntPtr material, MaterialProperty property, float frequency, float value);

		int AudioMaterialReset(IntPtr material, MaterialProperty property);
	}

	public class UnityNativeInterface : PropagationInterface
	{
		public const string strOSPS = "AudioPluginOculusSpatializer";

		private IntPtr context_ = IntPtr.Zero;

		private IntPtr context
		{
			get
			{
				if (context_ == IntPtr.Zero)
				{
					ovrAudio_GetPluginContext(out context_, 6u);
				}
				return context_;
			}
		}

		[DllImport("AudioPluginOculusSpatializer")]
		public static extern int ovrAudio_GetPluginContext(out IntPtr context, uint clientType);

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_SetPropagationQuality(IntPtr context, float quality);

		public int SetPropagationQuality(float quality)
		{
			return ovrAudio_SetPropagationQuality(context, quality);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_SetPropagationThreadAffinity(IntPtr context, ulong cpuMask);

		public int SetPropagationThreadAffinity(ulong cpuMask)
		{
			return ovrAudio_SetPropagationThreadAffinity(context, cpuMask);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_CreateAudioGeometry(IntPtr context, out IntPtr geometry);

		public int CreateAudioGeometry(out IntPtr geometry)
		{
			return ovrAudio_CreateAudioGeometry(context, out geometry);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_DestroyAudioGeometry(IntPtr geometry);

		public int DestroyAudioGeometry(IntPtr geometry)
		{
			return ovrAudio_DestroyAudioGeometry(geometry);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_AudioGeometryUploadMeshArrays(IntPtr geometry, float[] vertices, UIntPtr verticesBytesOffset, UIntPtr vertexCount, UIntPtr vertexStride, ovrAudioScalarType vertexType, int[] indices, UIntPtr indicesByteOffset, UIntPtr indexCount, ovrAudioScalarType indexType, MeshGroup[] groups, UIntPtr groupCount);

		public int AudioGeometryUploadMeshArrays(IntPtr geometry, float[] vertices, int vertexCount, int[] indices, int indexCount, MeshGroup[] groups, int groupCount)
		{
			return ovrAudio_AudioGeometryUploadMeshArrays(geometry, vertices, UIntPtr.Zero, (UIntPtr)(ulong)vertexCount, UIntPtr.Zero, ovrAudioScalarType.Float32, indices, UIntPtr.Zero, (UIntPtr)(ulong)indexCount, ovrAudioScalarType.UInt32, groups, (UIntPtr)(ulong)groupCount);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_AudioGeometrySetTransform(IntPtr geometry, float[] matrix4x4);

		public int AudioGeometrySetTransform(IntPtr geometry, float[] matrix4x4)
		{
			return ovrAudio_AudioGeometrySetTransform(geometry, matrix4x4);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_AudioGeometryGetTransform(IntPtr geometry, out float[] matrix4x4);

		public int AudioGeometryGetTransform(IntPtr geometry, out float[] matrix4x4)
		{
			return ovrAudio_AudioGeometryGetTransform(geometry, out matrix4x4);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_AudioGeometryWriteMeshFile(IntPtr geometry, string filePath);

		public int AudioGeometryWriteMeshFile(IntPtr geometry, string filePath)
		{
			return ovrAudio_AudioGeometryWriteMeshFile(geometry, filePath);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_AudioGeometryReadMeshFile(IntPtr geometry, string filePath);

		public int AudioGeometryReadMeshFile(IntPtr geometry, string filePath)
		{
			return ovrAudio_AudioGeometryReadMeshFile(geometry, filePath);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_AudioGeometryWriteMeshFileObj(IntPtr geometry, string filePath);

		public int AudioGeometryWriteMeshFileObj(IntPtr geometry, string filePath)
		{
			return ovrAudio_AudioGeometryWriteMeshFileObj(geometry, filePath);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_CreateAudioMaterial(IntPtr context, out IntPtr material);

		public int CreateAudioMaterial(out IntPtr material)
		{
			return ovrAudio_CreateAudioMaterial(context, out material);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_DestroyAudioMaterial(IntPtr material);

		public int DestroyAudioMaterial(IntPtr material)
		{
			return ovrAudio_DestroyAudioMaterial(material);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_AudioMaterialSetFrequency(IntPtr material, MaterialProperty property, float frequency, float value);

		public int AudioMaterialSetFrequency(IntPtr material, MaterialProperty property, float frequency, float value)
		{
			return ovrAudio_AudioMaterialSetFrequency(material, property, frequency, value);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_AudioMaterialGetFrequency(IntPtr material, MaterialProperty property, float frequency, out float value);

		public int AudioMaterialGetFrequency(IntPtr material, MaterialProperty property, float frequency, out float value)
		{
			return ovrAudio_AudioMaterialGetFrequency(material, property, frequency, out value);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_AudioMaterialReset(IntPtr material, MaterialProperty property);

		public int AudioMaterialReset(IntPtr material, MaterialProperty property)
		{
			return ovrAudio_AudioMaterialReset(material, property);
		}
	}

	public class WwisePluginInterface : PropagationInterface
	{
		public const string strOSPS = "OculusSpatializerWwise";

		private IntPtr context_ = IntPtr.Zero;

		private IntPtr context
		{
			get
			{
				if (context_ == IntPtr.Zero)
				{
					ovrAudio_GetPluginContext(out context_, 12u);
				}
				return context_;
			}
		}

		[DllImport("OculusSpatializerWwise")]
		public static extern int ovrAudio_GetPluginContext(out IntPtr context, uint clientType);

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_SetPropagationQuality(IntPtr context, float quality);

		public int SetPropagationQuality(float quality)
		{
			return ovrAudio_SetPropagationQuality(context, quality);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_SetPropagationThreadAffinity(IntPtr context, ulong cpuMask);

		public int SetPropagationThreadAffinity(ulong cpuMask)
		{
			return ovrAudio_SetPropagationThreadAffinity(context, cpuMask);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_CreateAudioGeometry(IntPtr context, out IntPtr geometry);

		public int CreateAudioGeometry(out IntPtr geometry)
		{
			return ovrAudio_CreateAudioGeometry(context, out geometry);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_DestroyAudioGeometry(IntPtr geometry);

		public int DestroyAudioGeometry(IntPtr geometry)
		{
			return ovrAudio_DestroyAudioGeometry(geometry);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_AudioGeometryUploadMeshArrays(IntPtr geometry, float[] vertices, UIntPtr verticesBytesOffset, UIntPtr vertexCount, UIntPtr vertexStride, ovrAudioScalarType vertexType, int[] indices, UIntPtr indicesByteOffset, UIntPtr indexCount, ovrAudioScalarType indexType, MeshGroup[] groups, UIntPtr groupCount);

		public int AudioGeometryUploadMeshArrays(IntPtr geometry, float[] vertices, int vertexCount, int[] indices, int indexCount, MeshGroup[] groups, int groupCount)
		{
			return ovrAudio_AudioGeometryUploadMeshArrays(geometry, vertices, UIntPtr.Zero, (UIntPtr)(ulong)vertexCount, UIntPtr.Zero, ovrAudioScalarType.Float32, indices, UIntPtr.Zero, (UIntPtr)(ulong)indexCount, ovrAudioScalarType.UInt32, groups, (UIntPtr)(ulong)groupCount);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_AudioGeometrySetTransform(IntPtr geometry, float[] matrix4x4);

		public int AudioGeometrySetTransform(IntPtr geometry, float[] matrix4x4)
		{
			return ovrAudio_AudioGeometrySetTransform(geometry, matrix4x4);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_AudioGeometryGetTransform(IntPtr geometry, out float[] matrix4x4);

		public int AudioGeometryGetTransform(IntPtr geometry, out float[] matrix4x4)
		{
			return ovrAudio_AudioGeometryGetTransform(geometry, out matrix4x4);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_AudioGeometryWriteMeshFile(IntPtr geometry, string filePath);

		public int AudioGeometryWriteMeshFile(IntPtr geometry, string filePath)
		{
			return ovrAudio_AudioGeometryWriteMeshFile(geometry, filePath);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_AudioGeometryReadMeshFile(IntPtr geometry, string filePath);

		public int AudioGeometryReadMeshFile(IntPtr geometry, string filePath)
		{
			return ovrAudio_AudioGeometryReadMeshFile(geometry, filePath);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_AudioGeometryWriteMeshFileObj(IntPtr geometry, string filePath);

		public int AudioGeometryWriteMeshFileObj(IntPtr geometry, string filePath)
		{
			return ovrAudio_AudioGeometryWriteMeshFileObj(geometry, filePath);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_CreateAudioMaterial(IntPtr context, out IntPtr material);

		public int CreateAudioMaterial(out IntPtr material)
		{
			return ovrAudio_CreateAudioMaterial(context, out material);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_DestroyAudioMaterial(IntPtr material);

		public int DestroyAudioMaterial(IntPtr material)
		{
			return ovrAudio_DestroyAudioMaterial(material);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_AudioMaterialSetFrequency(IntPtr material, MaterialProperty property, float frequency, float value);

		public int AudioMaterialSetFrequency(IntPtr material, MaterialProperty property, float frequency, float value)
		{
			return ovrAudio_AudioMaterialSetFrequency(material, property, frequency, value);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_AudioMaterialGetFrequency(IntPtr material, MaterialProperty property, float frequency, out float value);

		public int AudioMaterialGetFrequency(IntPtr material, MaterialProperty property, float frequency, out float value)
		{
			return ovrAudio_AudioMaterialGetFrequency(material, property, frequency, out value);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_AudioMaterialReset(IntPtr material, MaterialProperty property);

		public int AudioMaterialReset(IntPtr material, MaterialProperty property)
		{
			return ovrAudio_AudioMaterialReset(material, property);
		}
	}

	public class FMODPluginInterface : PropagationInterface
	{
		public const string strOSPS = "OculusSpatializerFMOD";

		private IntPtr context_ = IntPtr.Zero;

		private IntPtr context
		{
			get
			{
				if (context_ == IntPtr.Zero)
				{
					ovrAudio_GetPluginContext(out context_, 5u);
				}
				return context_;
			}
		}

		[DllImport("OculusSpatializerFMOD")]
		public static extern int ovrAudio_GetPluginContext(out IntPtr context, uint clientType);

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_SetPropagationQuality(IntPtr context, float quality);

		public int SetPropagationQuality(float quality)
		{
			return ovrAudio_SetPropagationQuality(context, quality);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_SetPropagationThreadAffinity(IntPtr context, ulong cpuMask);

		public int SetPropagationThreadAffinity(ulong cpuMask)
		{
			return ovrAudio_SetPropagationThreadAffinity(context, cpuMask);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_CreateAudioGeometry(IntPtr context, out IntPtr geometry);

		public int CreateAudioGeometry(out IntPtr geometry)
		{
			return ovrAudio_CreateAudioGeometry(context, out geometry);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_DestroyAudioGeometry(IntPtr geometry);

		public int DestroyAudioGeometry(IntPtr geometry)
		{
			return ovrAudio_DestroyAudioGeometry(geometry);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_AudioGeometryUploadMeshArrays(IntPtr geometry, float[] vertices, UIntPtr verticesBytesOffset, UIntPtr vertexCount, UIntPtr vertexStride, ovrAudioScalarType vertexType, int[] indices, UIntPtr indicesByteOffset, UIntPtr indexCount, ovrAudioScalarType indexType, MeshGroup[] groups, UIntPtr groupCount);

		public int AudioGeometryUploadMeshArrays(IntPtr geometry, float[] vertices, int vertexCount, int[] indices, int indexCount, MeshGroup[] groups, int groupCount)
		{
			return ovrAudio_AudioGeometryUploadMeshArrays(geometry, vertices, UIntPtr.Zero, (UIntPtr)(ulong)vertexCount, UIntPtr.Zero, ovrAudioScalarType.Float32, indices, UIntPtr.Zero, (UIntPtr)(ulong)indexCount, ovrAudioScalarType.UInt32, groups, (UIntPtr)(ulong)groupCount);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_AudioGeometrySetTransform(IntPtr geometry, float[] matrix4x4);

		public int AudioGeometrySetTransform(IntPtr geometry, float[] matrix4x4)
		{
			return ovrAudio_AudioGeometrySetTransform(geometry, matrix4x4);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_AudioGeometryGetTransform(IntPtr geometry, out float[] matrix4x4);

		public int AudioGeometryGetTransform(IntPtr geometry, out float[] matrix4x4)
		{
			return ovrAudio_AudioGeometryGetTransform(geometry, out matrix4x4);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_AudioGeometryWriteMeshFile(IntPtr geometry, string filePath);

		public int AudioGeometryWriteMeshFile(IntPtr geometry, string filePath)
		{
			return ovrAudio_AudioGeometryWriteMeshFile(geometry, filePath);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_AudioGeometryReadMeshFile(IntPtr geometry, string filePath);

		public int AudioGeometryReadMeshFile(IntPtr geometry, string filePath)
		{
			return ovrAudio_AudioGeometryReadMeshFile(geometry, filePath);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_AudioGeometryWriteMeshFileObj(IntPtr geometry, string filePath);

		public int AudioGeometryWriteMeshFileObj(IntPtr geometry, string filePath)
		{
			return ovrAudio_AudioGeometryWriteMeshFileObj(geometry, filePath);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_CreateAudioMaterial(IntPtr context, out IntPtr material);

		public int CreateAudioMaterial(out IntPtr material)
		{
			return ovrAudio_CreateAudioMaterial(context, out material);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_DestroyAudioMaterial(IntPtr material);

		public int DestroyAudioMaterial(IntPtr material)
		{
			return ovrAudio_DestroyAudioMaterial(material);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_AudioMaterialSetFrequency(IntPtr material, MaterialProperty property, float frequency, float value);

		public int AudioMaterialSetFrequency(IntPtr material, MaterialProperty property, float frequency, float value)
		{
			return ovrAudio_AudioMaterialSetFrequency(material, property, frequency, value);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_AudioMaterialGetFrequency(IntPtr material, MaterialProperty property, float frequency, out float value);

		public int AudioMaterialGetFrequency(IntPtr material, MaterialProperty property, float frequency, out float value)
		{
			return ovrAudio_AudioMaterialGetFrequency(material, property, frequency, out value);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_AudioMaterialReset(IntPtr material, MaterialProperty property);

		public int AudioMaterialReset(IntPtr material, MaterialProperty property)
		{
			return ovrAudio_AudioMaterialReset(material, property);
		}
	}

	private static PropagationInterface CachedInterface;

	public static PropagationInterface Interface
	{
		get
		{
			if (CachedInterface == null)
			{
				CachedInterface = FindInterface();
			}
			return CachedInterface;
		}
	}

	private static PropagationInterface FindInterface()
	{
		IntPtr context;
		try
		{
			WwisePluginInterface.ovrAudio_GetPluginContext(out context, 12u);
			UnityEngine.Debug.Log("Propagation initialized with Wwise Oculus Spatializer plugin");
			return new WwisePluginInterface();
		}
		catch (DllNotFoundException)
		{
		}
		try
		{
			FMODPluginInterface.ovrAudio_GetPluginContext(out context, 5u);
			UnityEngine.Debug.Log("Propagation initialized with FMOD Oculus Spatializer plugin");
			return new FMODPluginInterface();
		}
		catch (DllNotFoundException)
		{
		}
		UnityEngine.Debug.Log("Propagation initialized with Unity Oculus Spatializer plugin");
		return new UnityNativeInterface();
	}
}
public sealed class ONSPPropagationMaterial : MonoBehaviour
{
	public enum Preset
	{
		Custom,
		AcousticTile,
		Brick,
		BrickPainted,
		Carpet,
		CarpetHeavy,
		CarpetHeavyPadded,
		CeramicTile,
		Concrete,
		ConcreteRough,
		ConcreteBlock,
		ConcreteBlockPainted,
		Curtain,
		Foliage,
		Glass,
		GlassHeavy,
		Grass,
		Gravel,
		GypsumBoard,
		PlasterOnBrick,
		PlasterOnConcreteBlock,
		Soil,
		SoundProof,
		Snow,
		Steel,
		Water,
		WoodThin,
		WoodThick,
		WoodFloor,
		WoodOnConcrete
	}

	[Serializable]
	public sealed class Point
	{
		public float frequency;

		public float data;

		public Point(float frequency = 0f, float data = 0f)
		{
			this.frequency = frequency;
			this.data = data;
		}

		public static implicit operator Point(Vector2 v)
		{
			return new Point(v.x, v.y);
		}

		public static implicit operator Vector2(Point point)
		{
			return new Vector2(point.frequency, point.data);
		}
	}

	[Serializable]
	public sealed class Spectrum
	{
		public int selection = int.MaxValue;

		public List<Point> points = new List<Point>();

		public float this[float f]
		{
			get
			{
				if (points.Count > 0)
				{
					Point point = new Point(float.MinValue);
					Point point2 = new Point(float.MaxValue);
					foreach (Point point3 in points)
					{
						if (point3.frequency < f)
						{
							if (point3.frequency > point.frequency)
							{
								point = point3;
							}
						}
						else if (point3.frequency < point2.frequency)
						{
							point2 = point3;
						}
					}
					if (point.frequency == float.MinValue)
					{
						point.data = points.OrderBy((Point p) => p.frequency).First().data;
					}
					if (point2.frequency == float.MaxValue)
					{
						point2.data = points.OrderBy((Point p) => p.frequency).Last().data;
					}
					return point.data + (f - point.frequency) * (point2.data - point.data) / (point2.frequency - point.frequency);
				}
				return 0f;
			}
		}
	}

	public IntPtr materialHandle = IntPtr.Zero;

	[Tooltip("Absorption")]
	public Spectrum absorption = new Spectrum();

	[Tooltip("Transmission")]
	public Spectrum transmission = new Spectrum();

	[Tooltip("Scattering")]
	public Spectrum scattering = new Spectrum();

	[SerializeField]
	private Preset preset_;

	public Preset preset
	{
		get
		{
			return preset_;
		}
		set
		{
			SetPreset(value);
			preset_ = value;
		}
	}

	private void Start()
	{
		StartInternal();
	}

	public void StartInternal()
	{
		if (!(materialHandle != IntPtr.Zero))
		{
			if (ONSPPropagation.Interface.CreateAudioMaterial(out materialHandle) != ONSPPropagationGeometry.OSPSuccess)
			{
				throw new Exception("Unable to create internal audio material");
			}
			UploadMaterial();
		}
	}

	private void OnDestroy()
	{
		DestroyInternal();
	}

	public void DestroyInternal()
	{
		if (materialHandle != IntPtr.Zero)
		{
			ONSPPropagation.Interface.DestroyAudioMaterial(materialHandle);
			materialHandle = IntPtr.Zero;
		}
	}

	public void UploadMaterial()
	{
		if (materialHandle == IntPtr.Zero)
		{
			return;
		}
		ONSPPropagation.Interface.AudioMaterialReset(materialHandle, MaterialProperty.ABSORPTION);
		foreach (Point point in absorption.points)
		{
			ONSPPropagation.Interface.AudioMaterialSetFrequency(materialHandle, MaterialProperty.ABSORPTION, point.frequency, point.data);
		}
		ONSPPropagation.Interface.AudioMaterialReset(materialHandle, MaterialProperty.TRANSMISSION);
		foreach (Point point2 in transmission.points)
		{
			ONSPPropagation.Interface.AudioMaterialSetFrequency(materialHandle, MaterialProperty.TRANSMISSION, point2.frequency, point2.data);
		}
		ONSPPropagation.Interface.AudioMaterialReset(materialHandle, MaterialProperty.SCATTERING);
		foreach (Point point3 in scattering.points)
		{
			ONSPPropagation.Interface.AudioMaterialSetFrequency(materialHandle, MaterialProperty.SCATTERING, point3.frequency, point3.data);
		}
	}

	public void SetPreset(Preset preset)
	{
		ONSPPropagationMaterial material = this;
		switch (preset)
		{
		case Preset.AcousticTile:
			AcousticTile(ref material);
			break;
		case Preset.Brick:
			Brick(ref material);
			break;
		case Preset.BrickPainted:
			BrickPainted(ref material);
			break;
		case Preset.Carpet:
			Carpet(ref material);
			break;
		case Preset.CarpetHeavy:
			CarpetHeavy(ref material);
			break;
		case Preset.CarpetHeavyPadded:
			CarpetHeavyPadded(ref material);
			break;
		case Preset.CeramicTile:
			CeramicTile(ref material);
			break;
		case Preset.Concrete:
			Concrete(ref material);
			break;
		case Preset.ConcreteRough:
			ConcreteRough(ref material);
			break;
		case Preset.ConcreteBlock:
			ConcreteBlock(ref material);
			break;
		case Preset.ConcreteBlockPainted:
			ConcreteBlockPainted(ref material);
			break;
		case Preset.Curtain:
			Curtain(ref material);
			break;
		case Preset.Foliage:
			Foliage(ref material);
			break;
		case Preset.Glass:
			Glass(ref material);
			break;
		case Preset.GlassHeavy:
			GlassHeavy(ref material);
			break;
		case Preset.Grass:
			Grass(ref material);
			break;
		case Preset.Gravel:
			Gravel(ref material);
			break;
		case Preset.GypsumBoard:
			GypsumBoard(ref material);
			break;
		case Preset.PlasterOnBrick:
			PlasterOnBrick(ref material);
			break;
		case Preset.PlasterOnConcreteBlock:
			PlasterOnConcreteBlock(ref material);
			break;
		case Preset.Soil:
			Soil(ref material);
			break;
		case Preset.SoundProof:
			SoundProof(ref material);
			break;
		case Preset.Snow:
			Snow(ref material);
			break;
		case Preset.Steel:
			Steel(ref material);
			break;
		case Preset.Water:
			Water(ref material);
			break;
		case Preset.WoodThin:
			WoodThin(ref material);
			break;
		case Preset.WoodThick:
			WoodThick(ref material);
			break;
		case Preset.WoodFloor:
			WoodFloor(ref material);
			break;
		case Preset.WoodOnConcrete:
			WoodOnConcrete(ref material);
			break;
		case Preset.Custom:
			break;
		}
	}

	private static void AcousticTile(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.5f),
			new Point(250f, 0.7f),
			new Point(500f, 0.6f),
			new Point(1000f, 0.7f),
			new Point(2000f, 0.7f),
			new Point(4000f, 0.5f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.15f),
			new Point(500f, 0.2f),
			new Point(1000f, 0.2f),
			new Point(2000f, 0.25f),
			new Point(4000f, 0.3f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.05f),
			new Point(250f, 0.04f),
			new Point(500f, 0.03f),
			new Point(1000f, 0.02f),
			new Point(2000f, 0.005f),
			new Point(4000f, 0.002f)
		};
	}

	private static void Brick(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.02f),
			new Point(250f, 0.02f),
			new Point(500f, 0.03f),
			new Point(1000f, 0.04f),
			new Point(2000f, 0.05f),
			new Point(4000f, 0.07f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.2f),
			new Point(250f, 0.25f),
			new Point(500f, 0.3f),
			new Point(1000f, 0.35f),
			new Point(2000f, 0.4f),
			new Point(4000f, 0.45f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.025f),
			new Point(250f, 0.019f),
			new Point(500f, 0.01f),
			new Point(1000f, 0.0045f),
			new Point(2000f, 0.0018f),
			new Point(4000f, 0.00089f)
		};
	}

	private static void BrickPainted(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.01f),
			new Point(250f, 0.01f),
			new Point(500f, 0.02f),
			new Point(1000f, 0.02f),
			new Point(2000f, 0.02f),
			new Point(4000f, 0.03f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.15f),
			new Point(250f, 0.15f),
			new Point(500f, 0.2f),
			new Point(1000f, 0.2f),
			new Point(2000f, 0.2f),
			new Point(4000f, 0.25f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.025f),
			new Point(250f, 0.019f),
			new Point(500f, 0.01f),
			new Point(1000f, 0.0045f),
			new Point(2000f, 0.0018f),
			new Point(4000f, 0.00089f)
		};
	}

	private static void Carpet(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.01f),
			new Point(250f, 0.05f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.2f),
			new Point(2000f, 0.45f),
			new Point(4000f, 0.65f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.1f),
			new Point(500f, 0.15f),
			new Point(1000f, 0.2f),
			new Point(2000f, 0.3f),
			new Point(4000f, 0.45f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.004f),
			new Point(250f, 0.0079f),
			new Point(500f, 0.0056f),
			new Point(1000f, 0.0016f),
			new Point(2000f, 0.0014f),
			new Point(4000f, 0.0005f)
		};
	}

	private static void CarpetHeavy(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.02f),
			new Point(250f, 0.06f),
			new Point(500f, 0.14f),
			new Point(1000f, 0.37f),
			new Point(2000f, 0.48f),
			new Point(4000f, 0.63f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.15f),
			new Point(500f, 0.2f),
			new Point(1000f, 0.25f),
			new Point(2000f, 0.35f),
			new Point(4000f, 0.5f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.004f),
			new Point(250f, 0.0079f),
			new Point(500f, 0.0056f),
			new Point(1000f, 0.0016f),
			new Point(2000f, 0.0014f),
			new Point(4000f, 0.0005f)
		};
	}

	private static void CarpetHeavyPadded(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.08f),
			new Point(250f, 0.24f),
			new Point(500f, 0.57f),
			new Point(1000f, 0.69f),
			new Point(2000f, 0.71f),
			new Point(4000f, 0.73f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.15f),
			new Point(500f, 0.2f),
			new Point(1000f, 0.25f),
			new Point(2000f, 0.35f),
			new Point(4000f, 0.5f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.004f),
			new Point(250f, 0.0079f),
			new Point(500f, 0.0056f),
			new Point(1000f, 0.0016f),
			new Point(2000f, 0.0014f),
			new Point(4000f, 0.0005f)
		};
	}

	private static void CeramicTile(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.01f),
			new Point(250f, 0.01f),
			new Point(500f, 0.01f),
			new Point(1000f, 0.01f),
			new Point(2000f, 0.02f),
			new Point(4000f, 0.02f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.12f),
			new Point(500f, 0.14f),
			new Point(1000f, 0.16f),
			new Point(2000f, 0.18f),
			new Point(4000f, 0.2f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.004f),
			new Point(250f, 0.0079f),
			new Point(500f, 0.0056f),
			new Point(1000f, 0.0016f),
			new Point(2000f, 0.0014f),
			new Point(4000f, 0.0005f)
		};
	}

	private static void Concrete(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.01f),
			new Point(250f, 0.01f),
			new Point(500f, 0.02f),
			new Point(1000f, 0.02f),
			new Point(2000f, 0.02f),
			new Point(4000f, 0.02f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.11f),
			new Point(500f, 0.12f),
			new Point(1000f, 0.13f),
			new Point(2000f, 0.14f),
			new Point(4000f, 0.15f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.004f),
			new Point(250f, 0.0079f),
			new Point(500f, 0.0056f),
			new Point(1000f, 0.0016f),
			new Point(2000f, 0.0014f),
			new Point(4000f, 0.0005f)
		};
	}

	private static void ConcreteRough(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.01f),
			new Point(250f, 0.02f),
			new Point(500f, 0.04f),
			new Point(1000f, 0.06f),
			new Point(2000f, 0.08f),
			new Point(4000f, 0.1f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.12f),
			new Point(500f, 0.15f),
			new Point(1000f, 0.2f),
			new Point(2000f, 0.25f),
			new Point(4000f, 0.3f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.004f),
			new Point(250f, 0.0079f),
			new Point(500f, 0.0056f),
			new Point(1000f, 0.0016f),
			new Point(2000f, 0.0014f),
			new Point(4000f, 0.0005f)
		};
	}

	private static void ConcreteBlock(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.36f),
			new Point(250f, 0.44f),
			new Point(500f, 0.31f),
			new Point(1000f, 0.29f),
			new Point(2000f, 0.39f),
			new Point(4000f, 0.21f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.12f),
			new Point(500f, 0.15f),
			new Point(1000f, 0.2f),
			new Point(2000f, 0.3f),
			new Point(4000f, 0.4f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.02f),
			new Point(250f, 0.01f),
			new Point(500f, 0.0063f),
			new Point(1000f, 0.0035f),
			new Point(2000f, 0.00011f),
			new Point(4000f, 0.00063f)
		};
	}

	private static void ConcreteBlockPainted(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.05f),
			new Point(500f, 0.06f),
			new Point(1000f, 0.07f),
			new Point(2000f, 0.09f),
			new Point(4000f, 0.08f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.11f),
			new Point(500f, 0.13f),
			new Point(1000f, 0.15f),
			new Point(2000f, 0.16f),
			new Point(4000f, 0.2f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.02f),
			new Point(250f, 0.01f),
			new Point(500f, 0.0063f),
			new Point(1000f, 0.0035f),
			new Point(2000f, 0.00011f),
			new Point(4000f, 0.00063f)
		};
	}

	private static void Curtain(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.07f),
			new Point(250f, 0.31f),
			new Point(500f, 0.49f),
			new Point(1000f, 0.75f),
			new Point(2000f, 0.7f),
			new Point(4000f, 0.6f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.15f),
			new Point(500f, 0.2f),
			new Point(1000f, 0.3f),
			new Point(2000f, 0.4f),
			new Point(4000f, 0.5f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.42f),
			new Point(250f, 0.39f),
			new Point(500f, 0.21f),
			new Point(1000f, 0.14f),
			new Point(2000f, 0.079f),
			new Point(4000f, 0.045f)
		};
	}

	private static void Foliage(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.03f),
			new Point(250f, 0.06f),
			new Point(500f, 0.11f),
			new Point(1000f, 0.17f),
			new Point(2000f, 0.27f),
			new Point(4000f, 0.31f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.2f),
			new Point(250f, 0.3f),
			new Point(500f, 0.4f),
			new Point(1000f, 0.5f),
			new Point(2000f, 0.7f),
			new Point(4000f, 0.8f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.9f),
			new Point(250f, 0.9f),
			new Point(500f, 0.9f),
			new Point(1000f, 0.8f),
			new Point(2000f, 0.5f),
			new Point(4000f, 0.3f)
		};
	}

	private static void Glass(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.35f),
			new Point(250f, 0.25f),
			new Point(500f, 0.18f),
			new Point(1000f, 0.12f),
			new Point(2000f, 0.07f),
			new Point(4000f, 0.05f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.05f),
			new Point(250f, 0.05f),
			new Point(500f, 0.05f),
			new Point(1000f, 0.05f),
			new Point(2000f, 0.05f),
			new Point(4000f, 0.05f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.125f),
			new Point(250f, 0.089f),
			new Point(500f, 0.05f),
			new Point(1000f, 0.028f),
			new Point(2000f, 0.022f),
			new Point(4000f, 0.079f)
		};
	}

	private static void GlassHeavy(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.18f),
			new Point(250f, 0.06f),
			new Point(500f, 0.04f),
			new Point(1000f, 0.03f),
			new Point(2000f, 0.02f),
			new Point(4000f, 0.02f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.05f),
			new Point(250f, 0.05f),
			new Point(500f, 0.05f),
			new Point(1000f, 0.05f),
			new Point(2000f, 0.05f),
			new Point(4000f, 0.05f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.056f),
			new Point(250f, 0.039f),
			new Point(500f, 0.028f),
			new Point(1000f, 0.02f),
			new Point(2000f, 0.032f),
			new Point(4000f, 0.014f)
		};
	}

	private static void Grass(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.11f),
			new Point(250f, 0.26f),
			new Point(500f, 0.6f),
			new Point(1000f, 0.69f),
			new Point(2000f, 0.92f),
			new Point(4000f, 0.99f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.3f),
			new Point(250f, 0.3f),
			new Point(500f, 0.4f),
			new Point(1000f, 0.5f),
			new Point(2000f, 0.6f),
			new Point(4000f, 0.7f)
		};
		material.transmission.points = new List<Point>();
	}

	private static void Gravel(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.25f),
			new Point(250f, 0.6f),
			new Point(500f, 0.65f),
			new Point(1000f, 0.7f),
			new Point(2000f, 0.75f),
			new Point(4000f, 0.8f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.2f),
			new Point(250f, 0.3f),
			new Point(500f, 0.4f),
			new Point(1000f, 0.5f),
			new Point(2000f, 0.6f),
			new Point(4000f, 0.7f)
		};
		material.transmission.points = new List<Point>();
	}

	private static void GypsumBoard(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.29f),
			new Point(250f, 0.1f),
			new Point(500f, 0.05f),
			new Point(1000f, 0.04f),
			new Point(2000f, 0.07f),
			new Point(4000f, 0.09f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.11f),
			new Point(500f, 0.12f),
			new Point(1000f, 0.13f),
			new Point(2000f, 0.14f),
			new Point(4000f, 0.15f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.035f),
			new Point(250f, 0.0125f),
			new Point(500f, 0.0056f),
			new Point(1000f, 0.0025f),
			new Point(2000f, 0.0013f),
			new Point(4000f, 0.0032f)
		};
	}

	private static void PlasterOnBrick(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.01f),
			new Point(250f, 0.02f),
			new Point(500f, 0.02f),
			new Point(1000f, 0.03f),
			new Point(2000f, 0.04f),
			new Point(4000f, 0.05f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.2f),
			new Point(250f, 0.25f),
			new Point(500f, 0.3f),
			new Point(1000f, 0.35f),
			new Point(2000f, 0.4f),
			new Point(4000f, 0.45f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.025f),
			new Point(250f, 0.019f),
			new Point(500f, 0.01f),
			new Point(1000f, 0.0045f),
			new Point(2000f, 0.0018f),
			new Point(4000f, 0.00089f)
		};
	}

	private static void PlasterOnConcreteBlock(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.12f),
			new Point(250f, 0.09f),
			new Point(500f, 0.07f),
			new Point(1000f, 0.05f),
			new Point(2000f, 0.05f),
			new Point(4000f, 0.04f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.2f),
			new Point(250f, 0.25f),
			new Point(500f, 0.3f),
			new Point(1000f, 0.35f),
			new Point(2000f, 0.4f),
			new Point(4000f, 0.45f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.02f),
			new Point(250f, 0.01f),
			new Point(500f, 0.0063f),
			new Point(1000f, 0.0035f),
			new Point(2000f, 0.00011f),
			new Point(4000f, 0.00063f)
		};
	}

	private static void Soil(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.15f),
			new Point(250f, 0.25f),
			new Point(500f, 0.4f),
			new Point(1000f, 0.55f),
			new Point(2000f, 0.6f),
			new Point(4000f, 0.6f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.2f),
			new Point(500f, 0.25f),
			new Point(1000f, 0.4f),
			new Point(2000f, 0.55f),
			new Point(4000f, 0.7f)
		};
		material.transmission.points = new List<Point>();
	}

	private static void SoundProof(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(1000f, 1f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(1000f)
		};
		material.transmission.points = new List<Point>();
	}

	private static void Snow(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.45f),
			new Point(250f, 0.75f),
			new Point(500f, 0.9f),
			new Point(1000f, 0.95f),
			new Point(2000f, 0.95f),
			new Point(4000f, 0.95f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.2f),
			new Point(250f, 0.3f),
			new Point(500f, 0.4f),
			new Point(1000f, 0.5f),
			new Point(2000f, 0.6f),
			new Point(4000f, 0.75f)
		};
		material.transmission.points = new List<Point>();
	}

	private static void Steel(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.05f),
			new Point(250f, 0.1f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.1f),
			new Point(2000f, 0.07f),
			new Point(4000f, 0.02f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.1f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.1f),
			new Point(2000f, 0.1f),
			new Point(4000f, 0.1f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.25f),
			new Point(250f, 0.2f),
			new Point(500f, 0.17f),
			new Point(1000f, 0.089f),
			new Point(2000f, 0.089f),
			new Point(4000f, 0.0056f)
		};
	}

	private static void Water(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.01f),
			new Point(250f, 0.01f),
			new Point(500f, 0.01f),
			new Point(1000f, 0.02f),
			new Point(2000f, 0.02f),
			new Point(4000f, 0.03f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.1f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.07f),
			new Point(2000f, 0.05f),
			new Point(4000f, 0.05f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.03f),
			new Point(250f, 0.03f),
			new Point(500f, 0.03f),
			new Point(1000f, 0.02f),
			new Point(2000f, 0.015f),
			new Point(4000f, 0.01f)
		};
	}

	private static void WoodThin(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.42f),
			new Point(250f, 0.21f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.08f),
			new Point(2000f, 0.06f),
			new Point(4000f, 0.06f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.1f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.1f),
			new Point(2000f, 0.1f),
			new Point(4000f, 0.15f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.2f),
			new Point(250f, 0.125f),
			new Point(500f, 0.079f),
			new Point(1000f, 0.1f),
			new Point(2000f, 0.089f),
			new Point(4000f, 0.05f)
		};
	}

	private static void WoodThick(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.19f),
			new Point(250f, 0.14f),
			new Point(500f, 0.09f),
			new Point(1000f, 0.06f),
			new Point(2000f, 0.06f),
			new Point(4000f, 0.05f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.1f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.1f),
			new Point(2000f, 0.1f),
			new Point(4000f, 0.15f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.035f),
			new Point(250f, 0.028f),
			new Point(500f, 0.028f),
			new Point(1000f, 0.028f),
			new Point(2000f, 0.011f),
			new Point(4000f, 0.0071f)
		};
	}

	private static void WoodFloor(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.15f),
			new Point(250f, 0.11f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.07f),
			new Point(2000f, 0.06f),
			new Point(4000f, 0.07f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.1f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.1f),
			new Point(2000f, 0.1f),
			new Point(4000f, 0.15f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.071f),
			new Point(250f, 0.025f),
			new Point(500f, 0.0158f),
			new Point(1000f, 0.0056f),
			new Point(2000f, 0.0035f),
			new Point(4000f, 0.0016f)
		};
	}

	private static void WoodOnConcrete(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.04f),
			new Point(250f, 0.04f),
			new Point(500f, 0.07f),
			new Point(1000f, 0.06f),
			new Point(2000f, 0.06f),
			new Point(4000f, 0.07f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.1f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.1f),
			new Point(2000f, 0.1f),
			new Point(4000f, 0.15f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.004f),
			new Point(250f, 0.0079f),
			new Point(500f, 0.0056f),
			new Point(1000f, 0.0016f),
			new Point(2000f, 0.0014f),
			new Point(4000f, 0.0005f)
		};
	}
}
public class ONSPPropagationSettings : MonoBehaviour
{
	public float quality = 100f;

	private void Update()
	{
		ONSPPropagation.Interface.SetPropagationQuality(quality / 100f);
	}
}
public sealed class ONSPSettings : ScriptableObject
{
	[SerializeField]
	public int voiceLimit = 64;

	private static ONSPSettings instance;

	public static ONSPSettings Instance
	{
		get
		{
			if (instance == null)
			{
				instance = Resources.Load<ONSPSettings>("ONSPSettings");
				if (instance == null)
				{
					instance = ScriptableObject.CreateInstance<ONSPSettings>();
				}
			}
			return instance;
		}
	}
}
public class ONSPVersion : MonoBehaviour
{
	public const string strONSPS = "AudioPluginOculusSpatializer";

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern void ONSP_GetVersion(ref int Major, ref int Minor, ref int Patch);

	private void Awake()
	{
		int Major = 0;
		int Minor = 0;
		int Patch = 0;
		ONSP_GetVersion(ref Major, ref Minor, ref Patch);
		UnityEngine.Debug.Log($"ONSP Version: {Major:F0}.{Minor:F0}.{Patch:F0}");
	}

	private void Start()
	{
	}

	private void Update()
	{
	}
}
public class OculusSpatializerUnity : MonoBehaviour
{
	public delegate void AudioRaycastCallback(Vector3 origin, Vector3 direction, out Vector3 point, out Vector3 normal, IntPtr data);

	public LayerMask layerMask = -1;

	public bool visualizeRoom = true;

	private bool roomVisualizationInitialized;

	public int raysPerSecond = 256;

	public float roomInterpSpeed = 0.9f;

	public float maxWallDistance = 50f;

	public int rayCacheSize = 512;

	public bool dynamicReflectionsEnabled = true;

	private float particleSize = 0.2f;

	private float particleOffset = 0.1f;

	private GameObject room;

	private Renderer[] wallRenderer = new Renderer[6];

	private float[] dims = new float[3] { 1f, 1f, 1f };

	private float[] coefs = new float[6];

	private const int HIT_COUNT = 2048;

	private Vector3[] points = new Vector3[2048];

	private Vector3[] normals = new Vector3[2048];

	private ParticleSystem sys;

	private ParticleSystem.Particle[] particles = new ParticleSystem.Particle[2048];

	private static LayerMask gLayerMask = -1;

	private const string strOSP = "AudioPluginOculusSpatializer";

	private static Vector3 swapHandedness(Vector3 vec)
	{
		return new Vector3(vec.x, vec.y, 0f - vec.z);
	}

	[MonoPInvokeCallback(typeof(AudioRaycastCallback))]
	private static void AudioRaycast(Vector3 origin, Vector3 direction, out Vector3 point, out Vector3 normal, IntPtr data)
	{
		point = Vector3.zero;
		normal = Vector3.zero;
		if (Physics.Raycast(swapHandedness(origin), swapHandedness(direction), out var hitInfo, 1000f, gLayerMask.value))
		{
			point = swapHandedness(hitInfo.point);
			normal = swapHandedness(hitInfo.normal);
		}
	}

	private void Start()
	{
		OSP_Unity_AssignRaycastCallback(AudioRaycast, IntPtr.Zero);
	}

	private void OnDestroy()
	{
		OSP_Unity_AssignRaycastCallback(IntPtr.Zero, IntPtr.Zero);
	}

	private void Update()
	{
		if (dynamicReflectionsEnabled)
		{
			OSP_Unity_AssignRaycastCallback(AudioRaycast, IntPtr.Zero);
		}
		else
		{
			OSP_Unity_AssignRaycastCallback(IntPtr.Zero, IntPtr.Zero);
		}
		OSP_Unity_SetDynamicRoomRaysPerSecond(raysPerSecond);
		OSP_Unity_SetDynamicRoomInterpSpeed(roomInterpSpeed);
		OSP_Unity_SetDynamicRoomMaxWallDistance(maxWallDistance);
		OSP_Unity_SetDynamicRoomRaysRayCacheSize(rayCacheSize);
		gLayerMask = layerMask;
		OSP_Unity_UpdateRoomModel(1f);
		if (!visualizeRoom)
		{
			return;
		}
		if (!roomVisualizationInitialized)
		{
			inititalizeRoomVisualization();
			roomVisualizationInitialized = true;
		}
		OSP_Unity_GetRoomDimensions(dims, coefs, out var position);
		position.z *= -1f;
		Vector3 vector = new Vector3(dims[0], dims[1], dims[2]);
		float sqrMagnitude = vector.sqrMagnitude;
		if (!float.IsNaN(sqrMagnitude) && 0f < sqrMagnitude && sqrMagnitude < 1000000f)
		{
			base.transform.localScale = vector * 0.999f;
		}
		base.transform.position = position;
		OSP_Unity_GetRaycastHits(points, normals, 2048);
		for (int i = 0; i < 2048; i++)
		{
			if (points[i] == Vector3.zero)
			{
				points[i].y = -10000f;
			}
			points[i].z *= -1f;
			normals[i].z *= -1f;
			particles[i].position = points[i] + normals[i] * particleOffset;
			if (normals[i] != Vector3.zero)
			{
				particles[i].rotation3D = Quaternion.LookRotation(normals[i]).eulerAngles;
			}
			particles[i].startSize = particleSize;
			particles[i].startColor = new Color(0.8156863f, 0.14901961f, 58f / 85f, 1f);
		}
		for (int j = 0; j < 6; j++)
		{
			Color value = Color.Lerp(Color.red, Color.green, coefs[j]);
			wallRenderer[j].material.SetColor("_TintColor", value);
		}
		sys.SetParticles(particles, particles.Length);
	}

	private void inititalizeRoomVisualization()
	{
		UnityEngine.Debug.Log("Oculus Audio dynamic room estimation visualization enabled");
		base.transform.position = Vector3.zero;
		GameObject gameObject = new GameObject("DecalManager");
		gameObject.transform.parent = base.transform;
		sys = gameObject.AddComponent<ParticleSystem>();
		ParticleSystem.MainModule main = sys.main;
		main.simulationSpace = ParticleSystemSimulationSpace.World;
		main.loop = false;
		main.playOnAwake = false;
		ParticleSystem.EmissionModule emission = sys.emission;
		emission.enabled = false;
		ParticleSystem.ShapeModule shape = sys.shape;
		shape.enabled = false;
		ParticleSystemRenderer component = sys.GetComponent<ParticleSystemRenderer>();
		component.renderMode = ParticleSystemRenderMode.Mesh;
		component.material.shader = Shader.Find("Particles/Additive");
		Texture2D texture2D = new Texture2D(64, 64);
		for (int i = 0; i < 32; i++)
		{
			for (int j = 0; j < 32; j++)
			{
				float num = 32 - i;
				float num2 = 32 - j;
				float num3 = Mathf.Sqrt(num * num + num2 * num2);
				float num4 = 2f * num3 / 32f;
				float a = ((num3 < 32f) ? Mathf.Clamp01(Mathf.Sin((float)Math.PI * 2f * num4)) : 0f);
				Color color = new Color(1f, 1f, 1f, a);
				texture2D.SetPixel(i, j, color);
				texture2D.SetPixel(64 - i, j, color);
				texture2D.SetPixel(i, 64 - j, color);
				texture2D.SetPixel(64 - i, 64 - j, color);
			}
		}
		texture2D.Apply();
		component.material.mainTexture = texture2D;
		Mesh mesh = new Mesh();
		mesh.name = "ParticleQuad";
		mesh.vertices = new Vector3[4]
		{
			new Vector3(-0.5f, -0.5f, 0f),
			new Vector3(0.5f, -0.5f, 0f),
			new Vector3(0.5f, 0.5f, 0f),
			new Vector3(-0.5f, 0.5f, 0f)
		};
		mesh.uv = new Vector2[4]
		{
			new Vector2(0f, 0f),
			new Vector2(0f, 1f),
			new Vector2(1f, 1f),
			new Vector2(1f, 0f)
		};
		mesh.triangles = new int[6] { 0, 1, 2, 0, 2, 3 };
		mesh.RecalculateNormals();
		component.mesh = mesh;
		sys.Emit(2048);
		room = new GameObject("RoomVisualizer");
		room.transform.parent = base.transform;
		room.transform.localPosition = Vector3.zero;
		Texture2D texture2D2 = new Texture2D(32, 32);
		Color color2 = new Color(0f, 0f, 0f, 0f);
		for (int k = 0; k < 32; k++)
		{
			for (int l = 0; l < 32; l++)
			{
				texture2D2.SetPixel(k, l, color2);
			}
		}
		for (int m = 0; m < 32; m++)
		{
			Color color3 = Color.white * 0.125f;
			texture2D2.SetPixel(8, m, color3);
			texture2D2.SetPixel(m, 8, color3);
			texture2D2.SetPixel(24, m, color3);
			texture2D2.SetPixel(m, 24, color3);
			color3 *= 2f;
			texture2D2.SetPixel(16, m, color3);
			texture2D2.SetPixel(m, 16, color3);
			color3 *= 2f;
			texture2D2.SetPixel(0, m, color3);
			texture2D2.SetPixel(m, 0, color3);
		}
		texture2D2.Apply();
		for (int n = 0; n < 6; n++)
		{
			Mesh mesh2 = new Mesh();
			mesh2.name = "Plane" + n;
			Vector3[] array = new Vector3[4];
			int num5 = n / 2;
			int num6 = ((n % 2 == 0) ? 1 : (-1));
			for (int num7 = 0; num7 < 4; num7++)
			{
				array[num7][num5] = (float)num6 * 0.5f;
				array[num7][(num5 + 1) % 3] = 0.5f * (float)((num7 == 1 || num7 == 2) ? 1 : (-1));
				array[num7][(num5 + 2) % 3] = 0.5f * (float)((num7 == 2 || num7 == 3) ? 1 : (-1));
			}
			mesh2.vertices = array;
			mesh2.uv = new Vector2[4]
			{
				new Vector2(0f, 0f),
				new Vector2(0f, 1f),
				new Vector2(1f, 1f),
				new Vector2(1f, 0f)
			};
			mesh2.triangles = new int[6] { 0, 1, 2, 0, 2, 3 };
			mesh2.RecalculateNormals();
			GameObject obj = new GameObject("Wall_" + n);
			obj.AddComponent<MeshFilter>().mesh = mesh2;
			MeshRenderer meshRenderer = obj.AddComponent<MeshRenderer>();
			wallRenderer[n] = meshRenderer;
			meshRenderer.material.shader = Shader.Find("Particles/Additive");
			meshRenderer.material.mainTexture = texture2D2;
			meshRenderer.material.mainTextureScale = new Vector2(8f, 8f);
			obj.transform.parent = room.transform;
			room.transform.localPosition = Vector3.zero;
		}
	}

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_Unity_AssignRaycastCallback(AudioRaycastCallback callback, IntPtr data);

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_Unity_AssignRaycastCallback(IntPtr callback, IntPtr data);

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_Unity_SetDynamicRoomRaysPerSecond(int RaysPerSecond);

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_Unity_SetDynamicRoomInterpSpeed(float InterpSpeed);

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_Unity_SetDynamicRoomMaxWallDistance(float MaxWallDistance);

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_Unity_SetDynamicRoomRaysRayCacheSize(int RayCacheSize);

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_Unity_UpdateRoomModel(float wetLevel);

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_Unity_GetRoomDimensions(float[] roomDimensions, float[] reflectionsCoefs, out Vector3 position);

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_Unity_GetRaycastHits(Vector3[] points, Vector3[] normals, int length);
}
public struct ReflectionSnapshot
{
	public AudioMixerSnapshot mixerSnapshot;

	public float fadeTime;
}
public class ONSPReflectionZone : MonoBehaviour
{
	public AudioMixerSnapshot mixerSnapshot;

	public float fadeTime;

	private static Stack<ReflectionSnapshot> snapshotList = new Stack<ReflectionSnapshot>();

	private static ReflectionSnapshot currentSnapshot = default(ReflectionSnapshot);

	private void Start()
	{
	}

	private void Update()
	{
	}

	private void OnTriggerEnter(Collider other)
	{
		if (CheckForAudioListener(other.gameObject))
		{
			PushCurrentMixerShapshot();
		}
	}

	private void OnTriggerExit(Collider other)
	{
		if (CheckForAudioListener(other.gameObject))
		{
			PopCurrentMixerSnapshot();
		}
	}

	private bool CheckForAudioListener(GameObject gameObject)
	{
		if (gameObject.GetComponentInChildren<AudioListener>() != null)
		{
			return true;
		}
		return false;
	}

	private void PushCurrentMixerShapshot()
	{
		ReflectionSnapshot item = currentSnapshot;
		snapshotList.Push(item);
		SetReflectionValues();
	}

	private void PopCurrentMixerSnapshot()
	{
		ReflectionSnapshot mss = snapshotList.Pop();
		SetReflectionValues(ref mss);
	}

	private void SetReflectionValues()
	{
		if (mixerSnapshot != null)
		{
			UnityEngine.Debug.Log("Setting off snapshot " + mixerSnapshot.name);
			mixerSnapshot.TransitionTo(fadeTime);
			currentSnapshot.mixerSnapshot = mixerSnapshot;
			currentSnapshot.fadeTime = fadeTime;
		}
		else
		{
			UnityEngine.Debug.Log("Mixer snapshot not set - Please ensure play area has at least one encompassing snapshot.");
		}
	}

	private void SetReflectionValues(ref ReflectionSnapshot mss)
	{
		if (mss.mixerSnapshot != null)
		{
			UnityEngine.Debug.Log("Setting off snapshot " + mss.mixerSnapshot.name);
			mss.mixerSnapshot.TransitionTo(mss.fadeTime);
			currentSnapshot.mixerSnapshot = mss.mixerSnapshot;
			currentSnapshot.fadeTime = mss.fadeTime;
		}
		else
		{
			UnityEngine.Debug.Log("Mixer snapshot not set - Please ensure play area has at least one encompassing snapshot.");
		}
	}
}
public class OculusManager : MonoBehaviour
{
	[Serializable]
	public class QuestScoreEntry
	{
		public int rank;

		public string _name;

		public int score;
	}

	public delegate void TopScoresReturned();

	public delegate void NearbyScoresReturned();

	public bool useEntitlementcheck;

	public bool isentitled;

	public bool isInitalized;

	public string currentBoard = "Pyro1N";

	public string displayedBoard = "";

	public bool leaderboardLoading = true;

	public List<QuestScoreEntry> entries_top;

	public List<QuestScoreEntry> entries_nearby;

	public static OculusManager instance;

	public TopScoresReturned onTopScores;

	public NearbyScoresReturned onNearbyScores;

	private void Awake()
	{
		if (instance == null)
		{
			instance = this;
		}
		try
		{
			Core.AsyncInitialize();
			Entitlements.IsUserEntitledToApplication().OnComplete(EntitlementCallback);
		}
		catch (UnityException exception)
		{
			UnityEngine.Debug.LogError("Platform failed to initialize due to exception.");
			UnityEngine.Debug.LogException(exception);
		}
	}

	private void EntitlementCallback(Message msg)
	{
		if (msg.IsError)
		{
			UnityEngine.Debug.LogError("You are NOT entitled to use this app.");
			UnityEngine.Application.Quit();
		}
		else
		{
			UnityEngine.Debug.Log("You are entitled to use this app.");
		}
	}

	public void SetBoard(string board)
	{
		currentBoard = board;
	}

	public void SetTargetBoard()
	{
		string[] array = Persistence.instance.currentSongFilename.Split('_');
		currentBoard = array[1];
		currentBoard += array[2];
		if (Persistence.instance.currentDifficulty == 0)
		{
			currentBoard += "E";
		}
		else if (Persistence.instance.currentDifficulty == 1)
		{
			currentBoard += "N";
		}
		else if (Persistence.instance.currentDifficulty == 2)
		{
			currentBoard += "H";
		}
		else if (Persistence.instance.currentDifficulty == 3)
		{
			currentBoard += "X";
		}
		UnityEngine.Debug.Log("Target board is " + currentBoard);
	}

	public void RequestScores(bool topFirst = true)
	{
		if (topFirst)
		{
			RequestTop();
		}
		else
		{
			RequestNearby();
		}
	}

	public void RequestTop(int count = 10)
	{
		leaderboardLoading = true;
		Leaderboards.GetEntries(currentBoard, count, LeaderboardFilterType.None, LeaderboardStartAt.Top).OnComplete(GetTopEntriesCallBack);
		UnityEngine.Debug.Log("Requesting top " + count + " scores from " + currentBoard);
	}

	public void RequestNearby(int count = 3)
	{
		leaderboardLoading = true;
		Leaderboards.GetEntries(currentBoard, count, LeaderboardFilterType.None, LeaderboardStartAt.CenteredOnViewerOrTop).OnComplete(GetNearbyEntriesCallBack);
		UnityEngine.Debug.Log("Requesting top " + count + " scores from " + currentBoard);
	}

	private void GetTopEntriesCallBack(Message<LeaderboardEntryList> msg)
	{
		leaderboardLoading = false;
		if (!msg.IsError)
		{
			UnityEngine.Debug.Log("Got scores back: " + msg.Data.Count + " scores");
			entries_top.Clear();
			foreach (LeaderboardEntry datum in msg.Data)
			{
				entries_top.Add(new QuestScoreEntry
				{
					rank = datum.Rank,
					_name = datum.User.DisplayName,
					score = (int)datum.Score
				});
			}
			displayedBoard = currentBoard;
			onTopScores?.Invoke();
		}
		else
		{
			UnityEngine.Debug.Log("Scores returned an error: " + msg.GetError().Message);
		}
	}

	private void GetNearbyEntriesCallBack(Message<LeaderboardEntryList> msg)
	{
		leaderboardLoading = false;
		if (!msg.IsError)
		{
			UnityEngine.Debug.Log("Got scores back: " + msg.Data.Count + " scores");
			entries_nearby.Clear();
			foreach (LeaderboardEntry datum in msg.Data)
			{
				entries_nearby.Add(new QuestScoreEntry
				{
					rank = datum.Rank,
					_name = datum.User.DisplayName,
					score = (int)datum.Score
				});
			}
			displayedBoard = currentBoard;
			onNearbyScores?.Invoke();
		}
		else
		{
			UnityEngine.Debug.Log("Scores returned an error: " + msg.GetError().Message);
		}
	}

	public void SubmitScore(int score)
	{
		Leaderboards.WriteEntry(currentBoard, score).OnComplete(GetScoreSubmittedCallback);
		UnityEngine.Debug.Log("Attempting to submit score " + score + " to board " + currentBoard);
	}

	private void GetScoreSubmittedCallback(Message<bool> msg)
	{
		if (!msg.IsError)
		{
			UnityEngine.Debug.Log("ScoreSubmitted!");
			RequestTop();
		}
		else
		{
			UnityEngine.Debug.Log("Submit returned an error: " + msg.GetError().Message);
		}
	}

	public void UnlockAchievement(string achievement)
	{
		Achievements.Unlock(achievement);
	}
}
public class ParticleColourInit : MonoBehaviour
{
	public enum Hand
	{
		Left,
		Right,
		Double
	}

	public Hand hand;

	public List<ParticleSystem> colouredParticles;

	public float alpha = 1f;

	private void Awake()
	{
		Color color = Color.HSVToRGB(hand switch
		{
			Hand.Left => Persistence.instance.svMan.settingsSave.left_Colour, 
			Hand.Right => Persistence.instance.svMan.settingsSave.right_Colour, 
			Hand.Double => Persistence.instance.svMan.settingsSave.double_colour, 
			_ => Persistence.instance.svMan.settingsSave.left_Colour, 
		}, 1f, 1f);
		Color color2 = new Color(color.r, color.g, color.b, alpha);
		foreach (ParticleSystem colouredParticle in colouredParticles)
		{
			ParticleSystem.MainModule main = colouredParticle.main;
			main.startColor = new ParticleSystem.MinMaxGradient(color2);
			ParticleSystem.TrailModule trails = colouredParticle.trails;
			trails.colorOverLifetime = new ParticleSystem.MinMaxGradient(color);
		}
	}
}
[DisallowMultipleComponent]
public class Outline : MonoBehaviour
{
	public enum Mode
	{
		OutlineAll,
		OutlineVisible,
		OutlineHidden,
		OutlineAndSilhouette,
		SilhouetteOnly
	}

	[Serializable]
	private class ListVector3
	{
		public List<Vector3> data;
	}

	private static HashSet<Mesh> registeredMeshes = new HashSet<Mesh>();

	[SerializeField]
	private Mode outlineMode;

	[SerializeField]
	private Color outlineColor = Color.white;

	[SerializeField]
	[Range(0f, 10f)]
	private float outlineWidth = 2f;

	[Header("Optional")]
	[SerializeField]
	[Tooltip("Precompute enabled: Per-vertex calculations are performed in the editor and serialized with the object. Precompute disabled: Per-vertex calculations are performed at runtime in Awake(). This may cause a pause for large meshes.")]
	private bool precomputeOutline;

	[SerializeField]
	[HideInInspector]
	private List<Mesh> bakeKeys = new List<Mesh>();

	[SerializeField]
	[HideInInspector]
	private List<ListVector3> bakeValues = new List<ListVector3>();

	private Renderer[] renderers;

	private Material outlineMaskMaterial;

	private Material outlineFillMaterial;

	private bool needsUpdate;

	public Mode OutlineMode
	{
		get
		{
			return outlineMode;
		}
		set
		{
			outlineMode = value;
			needsUpdate = true;
		}
	}

	public Color OutlineColor
	{
		get
		{
			return outlineColor;
		}
		set
		{
			outlineColor = value;
			needsUpdate = true;
		}
	}

	public float OutlineWidth
	{
		get
		{
			return outlineWidth;
		}
		set
		{
			outlineWidth = value;
			needsUpdate = true;
		}
	}

	private void Awake()
	{
		renderers = GetComponentsInChildren<Renderer>();
		outlineMaskMaterial = UnityEngine.Object.Instantiate(Resources.Load<Material>("Materials/OutlineMask"));
		outlineFillMaterial = UnityEngine.Object.Instantiate(Resources.Load<Material>("Materials/OutlineFill"));
		outlineMaskMaterial.name = "OutlineMask (Instance)";
		outlineFillMaterial.name = "OutlineFill (Instance)";
		LoadSmoothNormals();
		needsUpdate = true;
	}

	private void OnEnable()
	{
		Renderer[] array = renderers;
		foreach (Renderer obj in array)
		{
			List<Material> list = obj.sharedMaterials.ToList();
			list.Add(outlineMaskMaterial);
			list.Add(outlineFillMaterial);
			obj.materials = list.ToArray();
		}
	}

	private void OnValidate()
	{
		needsUpdate = true;
		if ((!precomputeOutline && bakeKeys.Count != 0) || bakeKeys.Count != bakeValues.Count)
		{
			bakeKeys.Clear();
			bakeValues.Clear();
		}
		if (precomputeOutline && bakeKeys.Count == 0)
		{
			Bake();
		}
	}

	private void Update()
	{
		if (needsUpdate)
		{
			needsUpdate = false;
			UpdateMaterialProperties();
		}
	}

	private void OnDisable()
	{
		Renderer[] array = renderers;
		foreach (Renderer obj in array)
		{
			List<Material> list = obj.sharedMaterials.ToList();
			list.Remove(outlineMaskMaterial);
			list.Remove(outlineFillMaterial);
			obj.materials = list.ToArray();
		}
	}

	private void OnDestroy()
	{
		UnityEngine.Object.Destroy(outlineMaskMaterial);
		UnityEngine.Object.Destroy(outlineFillMaterial);
	}

	private void Bake()
	{
		HashSet<Mesh> hashSet = new HashSet<Mesh>();
		MeshFilter[] componentsInChildren = GetComponentsInChildren<MeshFilter>();
		foreach (MeshFilter meshFilter in componentsInChildren)
		{
			if (hashSet.Add(meshFilter.sharedMesh))
			{
				List<Vector3> data = SmoothNormals(meshFilter.sharedMesh);
				bakeKeys.Add(meshFilter.sharedMesh);
				bakeValues.Add(new ListVector3
				{
					data = data
				});
			}
		}
	}

	private void LoadSmoothNormals()
	{
		MeshFilter[] componentsInChildren = GetComponentsInChildren<MeshFilter>();
		foreach (MeshFilter meshFilter in componentsInChildren)
		{
			if (registeredMeshes.Add(meshFilter.sharedMesh))
			{
				int num = bakeKeys.IndexOf(meshFilter.sharedMesh);
				List<Vector3> uvs = ((num >= 0) ? bakeValues[num].data : SmoothNormals(meshFilter.sharedMesh));
				meshFilter.sharedMesh.SetUVs(3, uvs);
			}
		}
		SkinnedMeshRenderer[] componentsInChildren2 = GetComponentsInChildren<SkinnedMeshRenderer>();
		foreach (SkinnedMeshRenderer skinnedMeshRenderer in componentsInChildren2)
		{
			if (registeredMeshes.Add(skinnedMeshRenderer.sharedMesh))
			{
				skinnedMeshRenderer.sharedMesh.uv4 = new Vector2[skinnedMeshRenderer.sharedMesh.vertexCount];
			}
		}
	}

	private List<Vector3> SmoothNormals(Mesh mesh)
	{
		IEnumerable<IGrouping<Vector3, KeyValuePair<Vector3, int>>> enumerable = from pair in mesh.vertices.Select((Vector3 vertex, int index) => new KeyValuePair<Vector3, int>(vertex, index))
			group pair by pair.Key;
		List<Vector3> list = new List<Vector3>(mesh.normals);
		foreach (IGrouping<Vector3, KeyValuePair<Vector3, int>> item in enumerable)
		{
			if (item.Count() == 1)
			{
				continue;
			}
			Vector3 zero = Vector3.zero;
			foreach (KeyValuePair<Vector3, int> item2 in item)
			{
				zero += mesh.normals[item2.Value];
			}
			zero.Normalize();
			foreach (KeyValuePair<Vector3, int> item3 in item)
			{
				list[item3.Value] = zero;
			}
		}
		return list;
	}

	private void UpdateMaterialProperties()
	{
		outlineFillMaterial.SetColor("_OutlineColor", outlineColor);
		switch (outlineMode)
		{
		case Mode.OutlineAll:
			outlineMaskMaterial.SetFloat("_ZTest", 8f);
			outlineFillMaterial.SetFloat("_ZTest", 8f);
			outlineFillMaterial.SetFloat("_OutlineWidth", outlineWidth);
			break;
		case Mode.OutlineVisible:
			outlineMaskMaterial.SetFloat("_ZTest", 8f);
			outlineFillMaterial.SetFloat("_ZTest", 4f);
			outlineFillMaterial.SetFloat("_OutlineWidth", outlineWidth);
			break;
		case Mode.OutlineHidden:
			outlineMaskMaterial.SetFloat("_ZTest", 8f);
			outlineFillMaterial.SetFloat("_ZTest", 5f);
			outlineFillMaterial.SetFloat("_OutlineWidth", outlineWidth);
			break;
		case Mode.OutlineAndSilhouette:
			outlineMaskMaterial.SetFloat("_ZTest", 4f);
			outlineFillMaterial.SetFloat("_ZTest", 8f);
			outlineFillMaterial.SetFloat("_OutlineWidth", outlineWidth);
			break;
		case Mode.SilhouetteOnly:
			outlineMaskMaterial.SetFloat("_ZTest", 4f);
			outlineFillMaterial.SetFloat("_ZTest", 5f);
			outlineFillMaterial.SetFloat("_OutlineWidth", 0f);
			break;
		}
	}
}
public class RankingManager : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
	}

	public void SubmitDummyScore()
	{
	}
}
[ExecuteInEditMode]
public class ColliderJsonConverter : MonoBehaviour
{
	public string input;

	public List<string> colliderList;

	public void GetCollidersInInput()
	{
		FileInfo[] files = new DirectoryInfo(input).GetFiles();
		if (files.Length == 0)
		{
			UnityEngine.Debug.LogError("No files in directory.");
			return;
		}
		colliderList = new List<string>();
		foreach (FileInfo fileInfo in files)
		{
			if (fileInfo.Extension == ".collider")
			{
				colliderList.Add(fileInfo.FullName);
			}
		}
		UnityEngine.Debug.Log("Found " + colliderList.Count + " .collider files");
	}

	public void ConvertToJson()
	{
		if (colliderList.Count == 0)
		{
			UnityEngine.Debug.LogError("No .colliders to convert!");
			return;
		}
		UnityEngine.Debug.Log("Converting " + colliderList.Count + " .collider files");
		foreach (string collider in colliderList)
		{
			string fileNameWithoutExtension = Path.GetFileNameWithoutExtension(collider);
			BinaryFormatter binaryFormatter = new BinaryFormatter();
			FileStream serializationStream = File.Open(collider, FileMode.Open);
			Song obj = (Song)binaryFormatter.Deserialize(serializationStream);
			UnityEngine.Debug.Log("Collider " + fileNameWithoutExtension + " opened successfully");
			string contents = JsonUtility.ToJson(obj, prettyPrint: true);
			UnityEngine.Debug.Log("Converted to json.");
			File.WriteAllText(input + "/" + fileNameWithoutExtension + ".json", contents);
			UnityEngine.Debug.Log("Json file saved to " + input + "/" + fileNameWithoutExtension + ".json");
		}
	}
}
public class BonesOnlyBlendSystem : BlendSystem
{
	public override void OnVariableChanged()
	{
		isReady = true;
	}
}
[Serializable]
public class GestureInstance
{
	[SerializeField]
	public string gesture;

	[SerializeField]
	public AnimationClip clip;

	[SerializeField]
	public string triggerName;

	public GestureInstance(string gesture, AnimationClip clip, string triggerName)
	{
		this.gesture = gesture;
		this.clip = clip;
		this.triggerName = triggerName;
	}

	public bool IsValid(Animator animator)
	{
		for (int i = 0; i < animator.parameters.Length; i++)
		{
			if (animator.parameters[i].name == triggerName)
			{
				return true;
			}
		}
		return false;
	}
}
public class RoomOffset : MonoBehaviour
{
	private void Start()
	{
		ApplyOffset();
	}

	public void ApplyOffset()
	{
		SettingsSave settingsSave = Persistence.instance.svMan.settingsSave;
		base.transform.localPosition = new Vector3(settingsSave.room_xOffset, 0f, settingsSave.room_zOffset);
		base.transform.localRotation = Quaternion.Euler(0f, settingsSave.room_rotation, 0f);
		UnityEngine.Debug.Log("Room offset applied: " + base.transform.localPosition.ToString() + "|  rotation: " + base.transform.localRotation.eulerAngles.y);
	}
}
public class RotateAroundAxis : MonoBehaviour
{
	public Vector3 axis;

	public Vector2 speed;

	public bool worldSpace;

	private float _speed;

	private void Start()
	{
		_speed = UnityEngine.Random.Range(speed.x, speed.y);
	}

	private void Update()
	{
		base.transform.Rotate(axis, Time.deltaTime * _speed, (!worldSpace) ? Space.Self : Space.World);
	}

	private void OnDrawGizmos()
	{
	}
}
public class Scaler : MonoBehaviour
{
	public float currentScale = 1f;

	public float scaleInterval = 0.1f;

	public float maxScale = 2f;

	public float minScale = 0.8f;

	private void Start()
	{
		currentScale = base.transform.localScale.x;
		ScaleToCurrentScale();
	}

	private void ScaleToCurrentScale()
	{
		base.transform.localScale = Vector3.one * currentScale;
	}

	public void ScaleUp()
	{
		currentScale = Mathf.Min(currentScale + scaleInterval, maxScale);
		ScaleToCurrentScale();
	}

	public void ScaleDown()
	{
		currentScale = Mathf.Max(currentScale - scaleInterval, minScale);
		ScaleToCurrentScale();
	}

	public void ResetScale()
	{
		currentScale = 1f;
		ScaleToCurrentScale();
	}
}
public class SceneEditorNodeInteract : MonoBehaviour
{
}
public class DirectorTrigger : MonoBehaviour
{
	private PlayableDirector director;

	private void Start()
	{
		director = GetComponent<PlayableDirector>();
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.Space))
		{
			if (director.state == PlayState.Playing)
			{
				director.Stop();
			}
			else
			{
				director.Play();
			}
		}
	}
}
public class DisplayScoreText : MonoBehaviour
{
	public void Display()
	{
		GetComponent<TextMeshProUGUI>().text = GameManager.instance.score.score.ToString("N");
	}
}
public class ESCAPE : MonoBehaviour
{
	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.Escape))
		{
			UnityEngine.Application.Quit();
		}
	}
}
public class EnableComponentsPerPlatform : MonoBehaviour
{
	public List<MonoBehaviour> components;

	[Header("Enable on platform:")]
	public bool steamVR = true;

	public bool oculus = true;

	public bool stove = true;

	public bool monster = true;

	public bool springboard = true;

	public bool viveport = true;

	private void Awake()
	{
		if (oculus)
		{
			return;
		}
		foreach (MonoBehaviour component in components)
		{
			UnityEngine.Debug.Log("Disabled due to Platform: " + component.name, this);
			component.enabled = false;
		}
	}
}
public class EnablePerPlatform : MonoBehaviour
{
	[Header("Enable on platform:")]
	public bool steamVR = true;

	public bool oculus = true;

	public bool stove = true;

	public bool monster = true;

	public bool springboard = true;

	public bool viveport = true;

	[Header("Destroy object?")]
	public bool destroy;

	private void Awake()
	{
		if (!oculus)
		{
			UnityEngine.Debug.Log("Disabled due to Platform: " + base.gameObject.name, this);
			if (destroy)
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
			else
			{
				base.gameObject.SetActive(value: false);
			}
		}
	}
}
public class CascadeVisuals : MonoBehaviour
{
	public List<Node> nodes;

	private MeshRenderer mesh;

	private void Awake()
	{
		mesh = GetComponent<MeshRenderer>();
		mesh.enabled = false;
	}

	public void Init()
	{
		SplinePoint[] array = new SplinePoint[nodes.Count];
		for (int i = 0; i < nodes.Count; i++)
		{
			array[i] = new SplinePoint(Vector3.zero);
		}
		GetComponent<SplineComputer>().SetPoints(array);
		for (int j = 0; j < nodes.Count; j++)
		{
			nodes[j].gameObject.AddComponent<Dreamteck.Splines.Node>().AddConnection(GetComponent<SplineComputer>(), j);
		}
	}

	public void TurnOnMesh()
	{
		mesh.enabled = true;
	}
}
public class GameManager : MonoBehaviour
{
	[Serializable]
	public class ObjectRefrences
	{
		public LightShowManager lightManager;

		public PoolManager poolMananager;

		public GameObject pinkNodePrefab;

		public GameObject greenNodePrefab;

		public GameObject yellowNodePrefab;

		public GameObject pinkMiragePrefab;

		public GameObject greenMiragePrefab;

		public GameObject curveLeft;

		public GameObject curveRight;

		public GameObject straightLine;

		public GameObject leftController;

		public GameObject rightController;

		public GameObject leftContChild;

		public GameObject rightContChild;

		public Transform PlayerHeadMarker;

		public GameObject cascadeVisualsGreenPrefab;

		public GameObject cascadeVisualsPinkPrefab;

		public GameObject cascadeShellPrefab;

		public GameObject scoreEventSetPrefab;

		public GameObject scoreEventCascadePrefab;

		public GameObject scoreEventMultiPrefab;

		public GameObject scoreEventStreakPrefab;

		public GameObject scoreEventGeneric;

		public GameObject setEndEffect;

		public GameObject cascadeEndEffectPink;

		public GameObject cascadeEndEffectGreen;

		public GameObject setIdentifierPrefab;

		public SimplePlayback youtubePlayer;

		public GameObject shockwavePrefab;

		public GameObject starShatterPrefab;

		public Transform beatPoint;

		public GameObject godModeText;

		public GameObject leftPointer;

		public TextMeshProUGUI scoreText;

		public TextMeshProUGUI streakText;

		public TextMeshProUGUI multiText;

		public Slider progressbar;

		public Image progressHandle;

		public Image progressfill;

		public Image multiImage;

		public Image streakImage;

		public Image majorImage;

		public Image_Blinker handleBlinker;

		public Image_Blinker fillBlinker;

		public Image_Blinker majorBlinker;

		public Sprite perfectHandle;

		public Sprite normalHandle;

		public Sprite warningHandle;

		public Sprite deathHandle;

		public TextMeshProUGUI resultsAcc;

		public TextMeshProUGUI resultsEnergy;

		public TextMeshProUGUI resultsStreak;

		public TextMeshProUGUI resultsMulti;

		public TextMeshProUGUI resultsSets;

		public TextMeshProUGUI resultsCascade;

		public TextMeshProUGUI resultsScore;

		public TextMeshProUGUI resultsRank;

		public GameObject failureCanvas;

		public UI_Results resultsCanvas;

		public GameObject intro_UI;

		public TextMeshPro intro_title1;

		public TextMeshPro intro_title2;

		public TextMeshPro intro_title3;

		public TextMeshProUGUI dancebuttonStageName;

		public UI_Pause pause_ui;

		public UI_Settings settings_ui;

		public GameObject editorButton;

		public Button startButton;

		public Image startButtonFillBar;

		public GameObject uriel_button;

		public GameObject results_lobby_button;

		public GameObject results_restart_button;

		public GameObject results_nextstage_button;

		public UI_Uriel_Progress uriel_progress;

		[Range(0f, 1f)]
		public float dimChevAlpha;

		[Range(0f, 1f)]
		public float onChevAlpha;

		public float beatsPerChevron = 1f;

		public List<RawImage> rightSideChevs;

		public List<RawImage> rightSideChevs1;

		public List<RawImage> middleChevs;

		public List<RawImage> middleChevs1;

		public List<RawImage> leftSideChevs;

		public List<RawImage> leftSideChevs1;

		public Transform viveCenter;

		public Transform oculusCenter;

		public Transform oculusLeftEye;

		public Transform oculusRightEye;

		public Transform leftPrecisionPoint;

		public Transform rightPrecisionPoint;
	}

	[Serializable]
	public class NodePath
	{
		public string name;

		public SplineComputer spline;
	}

	public delegate void LightsPulse();

	public static GameManager instance;

	public ObjectRefrences objectRefrences;

	public List<AudioClip> songList;

	public List<string> songStrings;

	public List<NodePath> paths;

	public Persistence.Difficulty difficulty;

	public float heightModifier = 1f;

	public float spawnBuffer = 4f;

	public Song currentSong;

	public float songTime;

	public float dspSongStartTime;

	private VideoPlayer video;

	public bool songPlaying;

	public bool gameIntro;

	private bool songIsBuiltIn;

	public int basicNodeScoreMin;

	public int basicNodeScoreMax;

	public int doubleNodeScore;

	public int setbonus;

	public int cascadeSingleHit;

	public int cascadeBonus;

	public float maxVelocity;

	public float minVelocity;

	public float minPrecision;

	public float maxPrecision;

	public bool god;

	public bool loadArena = true;

	public bool doMissEffects = true;

	public bool inEditor;

	public bool isTutorial;

	public bool autoSetup = true;

	public bool autoNextStage = true;

	public float channelThreshold;

	public float cascadeDamageMultiplier;

	public Score score;

	public bool isTaunting;

	public float tauntDuration;

	public int curTaunt;

	private bool checkTauntHits;

	private string arenaLoaded = "";

	[HideInInspector]
	public HoloAnimationController holoCon;

	[HideInInspector]
	public VoiceOverManager voMan;

	[HideInInspector]
	public TutorialManager tutMan;

	[Range(0f, 100f)]
	public float complimentThreshold;

	[Range(0f, 1f)]
	public float insultThreshold;

	public int currentChannel;

	public float rightCountdown;

	public float middleCountdown;

	public float leftCountdown;

	public float leftChevTime;

	public float middleChevTime;

	public float rightChevTime;

	public int leftChevHits = -1;

	public int middleChevHits = -1;

	public int rightChevHits = -1;

	public bool leftChevIn;

	public bool leftChevOut;

	public bool rightChevIn;

	public bool rightChevOut;

	public bool midChevIn;

	public bool midChevOut;

	private UI_Settings settings;

	public float skipvalue;

	private ScoreEvent cascadeEvent;

	private ScoreEvent streakEvent;

	private ScoreEvent multiplierEvent;

	private float leftVibrationTime;

	private float rightVibrationTime;

	private bool waitingForOculus;

	private GameObject avatar;

	public Vector2 calibrationOffset;

	public int trailingScore;

	private float lastNodeTime;

	private float songProgressPercent;

	public LightsPulse _pulse;

	public Vector3 countdownTimes;

	public int musicNum;

	private bool perfect = true;

	public string fileName;

	public SetCounter currentSetCounter;

	public bool paused;

	private void Awake()
	{
		if (instance == null)
		{
			instance = this;
		}
	}

	public void Skip()
	{
		dspSongStartTime -= skipvalue;
		GetComponent<AudioSource>().Stop();
		GetComponent<AudioSource>().timeSamples = Mathf.CeilToInt(skipvalue * (float)AudioSettings.outputSampleRate);
		GetComponent<AudioSource>().Play();
	}

	private void Start()
	{
		god = Persistence.instance.nofail;
		if (objectRefrences.godModeText != null)
		{
			objectRefrences.godModeText.SetActive(god);
		}
		Time.timeScale = 1f;
		_ = inEditor;
		objectRefrences.scoreText.transform.parent.gameObject.SetActive(value: false);
		objectRefrences.resultsCanvas.nextStageUI.SetActive(value: false);
		objectRefrences.pause_ui.gameObject.SetActive(value: false);
		difficulty = Persistence.instance.GetDifficuty();
		cascadeEvent = UnityEngine.Object.Instantiate(objectRefrences.scoreEventCascadePrefab).GetComponent<ScoreEvent>();
		cascadeEvent.gameObject.SetActive(value: false);
		streakEvent = UnityEngine.Object.Instantiate(objectRefrences.scoreEventStreakPrefab).GetComponent<ScoreEvent>();
		streakEvent.gameObject.SetActive(value: false);
		multiplierEvent = UnityEngine.Object.Instantiate(objectRefrences.scoreEventMultiPrefab).GetComponent<ScoreEvent>();
		multiplierEvent.gameObject.SetActive(value: false);
		if (inEditor)
		{
			StartFadeIn();
		}
		StartCoroutine(LateStart());
		SetChevronsAlpha(objectRefrences.rightSideChevs, 0f, reset: true);
		SetChevronsAlpha(objectRefrences.rightSideChevs1, 0f, reset: true);
		SetChevronsAlpha(objectRefrences.leftSideChevs, 0f, reset: true);
		SetChevronsAlpha(objectRefrences.leftSideChevs1, 0f, reset: true);
		SetChevronsAlpha(objectRefrences.middleChevs, 0f, reset: true);
		SetChevronsAlpha(objectRefrences.middleChevs1, 0f, reset: true);
		objectRefrences.leftContChild = objectRefrences.leftController.transform.GetChild(0).gameObject;
		objectRefrences.rightContChild = objectRefrences.rightController.transform.GetChild(0).gameObject;
		if (Persistence.instance.fromEditor)
		{
			objectRefrences.editorButton.SetActive(value: true);
			Persistence.instance.fromEditor = false;
		}
		OVRManager.HMDUnmounted += UnmountPause;
	}

	private void UnmountPause()
	{
		Pause();
	}

	public void ThrowCascadeEvent(Vector3 pos)
	{
		cascadeEvent.transform.position = pos;
		cascadeEvent.gameObject.SetActive(value: true);
		cascadeEvent.SetRandomWord();
		cascadeEvent.Restart();
	}

	public void ThrowStreakEvent(Vector3 pos, string text)
	{
		streakEvent.transform.position = pos;
		streakEvent.gameObject.SetActive(value: true);
		streakEvent.text.text = text;
		streakEvent.Restart();
		streakEvent.GetComponent<AudioSource>().pitch = UnityEngine.Random.Range(0.9f, 1.1f);
		streakEvent.GetComponent<AudioSource>().Play();
	}

	public void ThrowMultiEvent(Vector3 pos, string text)
	{
		multiplierEvent.transform.position = pos;
		multiplierEvent.gameObject.SetActive(value: true);
		multiplierEvent.text.text = text;
		multiplierEvent.Restart();
	}

	private void SetChevronsAlpha(List<RawImage> _chevs, float _alpha = 0f, bool reset = false)
	{
		int num = 0;
		if (!reset)
		{
			num = 0;
		}
		for (int i = num; i < _chevs.Count; i++)
		{
			RawImage rawImage = _chevs[i];
			rawImage.color = new Color(rawImage.color.r, rawImage.color.g, rawImage.color.b, _alpha);
		}
	}

	private IEnumerator LateStart()
	{
		yield return new WaitForEndOfFrame();
		objectRefrences.resultsCanvas.gameObject.SetActive(value: false);
		objectRefrences.failureCanvas.SetActive(value: false);
		StartCoroutine(StartupDelay(2f));
	}

	private IEnumerator StartupDelay(float seconds = 1f)
	{
		yield return 1;
		yield return new WaitForSecondsRealtime(seconds);
		if (!inEditor && !isTutorial && autoSetup)
		{
			Calibrate();
			SetupGame();
		}
		else if (isTutorial)
		{
			LoadDance();
			loadArena = false;
		}
	}

	private void Update()
	{
		CheckPause();
		if (songPlaying && !paused)
		{
			songTime = CheckSongTime();
		}
		UpdateUI();
		UpdateTaunts();
		DirectionalArrowCountdowns();
		CheckVibration();
		if (OVRInput.GetDown(OVRInput.Button.Start, OVRInput.Controller.LTouch))
		{
			MenuPressed();
		}
	}

	public void VibrateLeft(float time)
	{
		leftVibrationTime = time;
		OVRInput.SetControllerVibration(0.8f, 0.8f, OVRInput.Controller.LTouch);
	}

	public void VibrateRight(float time)
	{
		rightVibrationTime = time;
		OVRInput.SetControllerVibration(0.8f, 0.8f, OVRInput.Controller.RTouch);
	}

	private void CheckVibration()
	{
		if (leftVibrationTime > 0f)
		{
			leftVibrationTime -= Time.unscaledDeltaTime;
			if (leftVibrationTime <= 0f)
			{
				OVRInput.SetControllerVibration(0f, 0f, OVRInput.Controller.LTouch);
				leftVibrationTime = 0f;
			}
		}
		if (rightVibrationTime > 0f)
		{
			rightVibrationTime -= Time.unscaledDeltaTime;
			if (rightVibrationTime <= 0f)
			{
				OVRInput.SetControllerVibration(0f, 0f, OVRInput.Controller.RTouch);
				rightVibrationTime = 0f;
			}
		}
	}

	private void CheckPause()
	{
		if (inEditor)
		{
			return;
		}
		if (objectRefrences.leftContChild == null)
		{
			objectRefrences.leftContChild = objectRefrences.leftController.transform.GetChild(0).gameObject;
		}
		if (objectRefrences.rightContChild == null)
		{
			objectRefrences.rightContChild = objectRefrences.rightController.transform.GetChild(0).gameObject;
		}
		if (!OVRManager.hasInputFocus || !OVRManager.hasVrFocus)
		{
			if (!paused)
			{
				if (songPlaying || gameIntro)
				{
					Pause();
					objectRefrences.leftContChild.SetActive(value: false);
					objectRefrences.rightContChild.SetActive(value: false);
					TogglePointers(toggle: false);
				}
				else
				{
					Pause(pauseUI: false);
					objectRefrences.leftContChild.SetActive(value: false);
					objectRefrences.rightContChild.SetActive(value: false);
					TogglePointers(toggle: false);
				}
			}
		}
		else if (paused)
		{
			if (songPlaying || gameIntro)
			{
				objectRefrences.leftContChild.SetActive(value: true);
				objectRefrences.rightContChild.SetActive(value: true);
				TogglePointers(toggle: true);
			}
			else
			{
				UnPause();
				objectRefrences.leftContChild.SetActive(value: true);
				objectRefrences.rightContChild.SetActive(value: true);
				TogglePointers(toggle: true);
			}
		}
	}

	private void CheckOculusInputStatus()
	{
	}

	private void DirectionalArrowCountdowns()
	{
		float num = 60f / currentSong.BPM * objectRefrences.beatsPerChevron;
		if (rightChevHits > -1)
		{
			if (songTime >= rightChevTime - num && rightChevIn)
			{
				float a = objectRefrences.rightSideChevs[objectRefrences.rightSideChevs.Count - 1].color.a;
				a += objectRefrences.dimChevAlpha * Time.deltaTime / num;
				a = ((a > objectRefrences.dimChevAlpha) ? objectRefrences.dimChevAlpha : a);
				SetChevronsAlpha(objectRefrences.rightSideChevs, a);
				SetChevronsAlpha(objectRefrences.rightSideChevs1, a);
			}
			if (rightChevOut)
			{
				float a2 = objectRefrences.rightSideChevs[objectRefrences.rightSideChevs.Count - 1].color.a;
				a2 -= objectRefrences.onChevAlpha * Time.deltaTime / num;
				if (a2 <= 0f)
				{
					a2 = 0f;
					rightChevOut = false;
					rightChevHits = -1;
				}
				SetChevronsAlpha(objectRefrences.rightSideChevs, a2);
				SetChevronsAlpha(objectRefrences.rightSideChevs1, a2);
			}
			if (songTime >= rightChevTime)
			{
				if (rightChevHits == 0)
				{
					SetChevronsAlpha(objectRefrences.rightSideChevs, objectRefrences.dimChevAlpha);
					SetChevronsAlpha(objectRefrences.rightSideChevs1, objectRefrences.dimChevAlpha);
					rightChevHits++;
					rightChevTime += num;
					rightChevIn = false;
				}
				else if (rightChevHits > 0 && rightChevHits < objectRefrences.rightSideChevs.Count + 1)
				{
					objectRefrences.rightSideChevs[rightChevHits - 1].color = new Color(1f, 1f, 1f, objectRefrences.onChevAlpha);
					objectRefrences.rightSideChevs1[rightChevHits - 1].color = new Color(1f, 1f, 1f, objectRefrences.onChevAlpha);
					rightChevHits++;
					rightChevTime += num;
				}
				else if (!rightChevIn && rightChevHits > 0)
				{
					rightChevOut = true;
				}
			}
		}
		else
		{
			SetChevronsAlpha(objectRefrences.rightSideChevs);
			SetChevronsAlpha(objectRefrences.rightSideChevs1);
		}
		if (middleChevHits > -1)
		{
			if (songTime >= middleChevTime - num && midChevIn)
			{
				float a3 = objectRefrences.middleChevs[objectRefrences.middleChevs.Count - 1].color.a;
				a3 += objectRefrences.dimChevAlpha * Time.deltaTime / num;
				a3 = ((a3 > objectRefrences.dimChevAlpha) ? objectRefrences.dimChevAlpha : a3);
				SetChevronsAlpha(objectRefrences.middleChevs, a3);
				SetChevronsAlpha(objectRefrences.middleChevs1, a3);
			}
			if (midChevOut)
			{
				float a4 = objectRefrences.middleChevs[objectRefrences.middleChevs.Count - 1].color.a;
				a4 -= objectRefrences.onChevAlpha * Time.deltaTime / num;
				if (a4 <= 0f)
				{
					a4 = 0f;
					midChevOut = false;
					middleChevHits = -1;
				}
				SetChevronsAlpha(objectRefrences.middleChevs, a4);
				SetChevronsAlpha(objectRefrences.middleChevs1, a4);
			}
			if (songTime >= middleChevTime)
			{
				if (middleChevHits == 0)
				{
					SetChevronsAlpha(objectRefrences.middleChevs, objectRefrences.dimChevAlpha);
					SetChevronsAlpha(objectRefrences.middleChevs1, objectRefrences.dimChevAlpha);
					middleChevHits++;
					middleChevTime += num;
					midChevIn = false;
				}
				else if (middleChevHits > 0 && middleChevHits < objectRefrences.middleChevs.Count + 1)
				{
					objectRefrences.middleChevs[middleChevHits - 1].color = new Color(1f, 1f, 1f, objectRefrences.onChevAlpha);
					objectRefrences.middleChevs1[middleChevHits - 1].color = new Color(1f, 1f, 1f, objectRefrences.onChevAlpha);
					middleChevHits++;
					middleChevTime += num;
				}
				else if (!midChevOut && middleChevHits > 0)
				{
					midChevOut = true;
				}
			}
		}
		else
		{
			SetChevronsAlpha(objectRefrences.middleChevs);
			SetChevronsAlpha(objectRefrences.middleChevs1);
		}
		if (leftChevHits > -1)
		{
			if (songTime >= leftChevTime - num && leftChevIn)
			{
				float a5 = objectRefrences.leftSideChevs[objectRefrences.leftSideChevs.Count - 1].color.a;
				a5 += objectRefrences.dimChevAlpha * Time.deltaTime / num;
				a5 = ((a5 > objectRefrences.dimChevAlpha) ? objectRefrences.dimChevAlpha : a5);
				SetChevronsAlpha(objectRefrences.leftSideChevs, a5);
				SetChevronsAlpha(objectRefrences.leftSideChevs1, a5);
			}
			if (leftChevOut)
			{
				float a6 = objectRefrences.leftSideChevs[objectRefrences.leftSideChevs.Count - 1].color.a;
				a6 -= objectRefrences.onChevAlpha * Time.deltaTime / num;
				if (a6 <= 0f)
				{
					a6 = 0f;
					leftChevOut = false;
					leftChevHits = -1;
				}
				SetChevronsAlpha(objectRefrences.leftSideChevs, a6);
				SetChevronsAlpha(objectRefrences.leftSideChevs1, a6);
			}
			if (songTime >= leftChevTime)
			{
				if (leftChevHits == 0)
				{
					SetChevronsAlpha(objectRefrences.leftSideChevs, objectRefrences.dimChevAlpha);
					SetChevronsAlpha(objectRefrences.leftSideChevs1, objectRefrences.dimChevAlpha);
					leftChevHits++;
					leftChevTime += num;
					leftChevIn = false;
				}
				else if (leftChevHits > 0 && leftChevHits < objectRefrences.leftSideChevs.Count + 1)
				{
					objectRefrences.leftSideChevs[leftChevHits - 1].color = new Color(1f, 1f, 1f, objectRefrences.onChevAlpha);
					objectRefrences.leftSideChevs1[leftChevHits - 1].color = new Color(1f, 1f, 1f, objectRefrences.onChevAlpha);
					leftChevHits++;
					leftChevTime += num;
				}
				else if (!leftChevOut && leftChevHits > 0)
				{
					leftChevOut = true;
				}
			}
		}
		else
		{
			SetChevronsAlpha(objectRefrences.leftSideChevs);
			SetChevronsAlpha(objectRefrences.leftSideChevs1);
		}
	}

	public void StartLeftChevrons(float _endTime)
	{
		float num = 60f / currentSong.BPM * objectRefrences.beatsPerChevron;
		leftChevTime = _endTime - num * (float)(objectRefrences.leftSideChevs.Count + 1);
		leftChevHits = 0;
		leftChevIn = true;
	}

	public void StartMiddleChevrons(float _endTime)
	{
		float num = 60f / currentSong.BPM * objectRefrences.beatsPerChevron;
		middleChevTime = _endTime - num * (float)(objectRefrences.middleChevs.Count + 1);
		middleChevHits = 0;
		midChevIn = true;
	}

	public void StartRightChevrons(float _endTime)
	{
		float num = 60f / currentSong.BPM * objectRefrences.beatsPerChevron;
		rightChevTime = _endTime - num * (float)(objectRefrences.rightSideChevs.Count + 1);
		rightChevHits = 0;
		rightChevIn = true;
	}

	private void ClearAllNodes()
	{
		UnityEngine.Debug.Log("Clearing all nodes!");
		Node[] array = UnityEngine.Object.FindObjectsOfType<Node>();
		for (int i = 0; i < array.Length; i++)
		{
			UnityEngine.Object.Destroy(array[i].gameObject);
		}
	}

	public void SetupGame()
	{
		LoadDance();
		if (!inEditor)
		{
			string text = "";
			if (text != "")
			{
				if (objectRefrences.dancebuttonStageName != null)
				{
					objectRefrences.dancebuttonStageName.text = "SONG FAILED TO LOAD.\nSomething has gone wrong!\n" + text;
				}
				objectRefrences.dancebuttonStageName.transform.parent.GetChild(0).gameObject.SetActive(value: false);
				objectRefrences.dancebuttonStageName.transform.parent.GetChild(1).gameObject.SetActive(value: false);
				objectRefrences.dancebuttonStageName.transform.parent.GetChild(2).gameObject.SetActive(value: false);
				return;
			}
		}
		AudioSource component = GetComponent<AudioSource>();
		component.clip = GetAudioClipFromMusicString(currentSong._music);
		if (component.clip == null)
		{
			if (objectRefrences.dancebuttonStageName != null)
			{
				objectRefrences.dancebuttonStageName.text = "SONG FAILED TO LOAD.\nCustom audio not found!\n" + currentSong._music;
			}
			objectRefrences.dancebuttonStageName.transform.parent.GetChild(0).gameObject.SetActive(value: false);
			objectRefrences.dancebuttonStageName.transform.parent.GetChild(1).gameObject.SetActive(value: false);
			objectRefrences.dancebuttonStageName.transform.parent.GetChild(2).gameObject.SetActive(value: false);
			return;
		}
		if (objectRefrences.dancebuttonStageName != null)
		{
			objectRefrences.dancebuttonStageName.text = ParseLoc.Parse(currentSong.title1) + "\n" + ParseLoc.Parse(currentSong.title2);
			if (Persistence.instance.currentDifficulty == 0)
			{
				TextMeshProUGUI dancebuttonStageName = objectRefrences.dancebuttonStageName;
				dancebuttonStageName.text = dancebuttonStageName.text + "\n" + ScriptLocalization.Easy;
			}
			else if (Persistence.instance.currentDifficulty == 1)
			{
				TextMeshProUGUI dancebuttonStageName2 = objectRefrences.dancebuttonStageName;
				dancebuttonStageName2.text = dancebuttonStageName2.text + "\n" + ScriptLocalization.Normal;
			}
			else if (Persistence.instance.currentDifficulty == 2)
			{
				TextMeshProUGUI dancebuttonStageName3 = objectRefrences.dancebuttonStageName;
				dancebuttonStageName3.text = dancebuttonStageName3.text + "\n" + ScriptLocalization.Hard;
			}
			else if (Persistence.instance.currentDifficulty == 3)
			{
				objectRefrences.dancebuttonStageName.text += "\nExtreme";
			}
		}
		if (!inEditor)
		{
			_ = isTutorial;
		}
		if (Persistence.instance.builtInSong)
		{
			Persistence.instance.SetLeaderboardTarget();
		}
		if (objectRefrences.settings_ui != null)
		{
			objectRefrences.settings_ui.gameObject.SetActive(value: true);
		}
	}

	public void Calibrate(bool setOffsets = false)
	{
		float a = objectRefrences.oculusCenter.transform.position.y;
		if (objectRefrences.viveCenter.gameObject.activeInHierarchy)
		{
			a = objectRefrences.viveCenter.transform.position.y;
		}
		if (!Persistence.instance.svMan.settingsSave.autoCalibration)
		{
			a = Persistence.instance.svMan.settingsSave.calibrationHeight;
		}
		a = Mathf.Max(a, 1.1f);
		float num = a / 7f;
		float num2 = num * 3f;
		float num3 = a + num / 2f - num - num / 2f;
		heightModifier = Mathf.Lerp(0.8f, 1f, Mathf.InverseLerp(1f, 1.73f, a));
		calibrationOffset = new Vector2(num3 - objectRefrences.beatPoint.position.y, num2 * 0.7f);
		if (setOffsets)
		{
			StartCoroutine(CalibrateRoutine());
		}
		UnityEngine.Debug.Log("Calibrated player with eye height of " + a.ToString("F3") + ", heightMod is " + heightModifier.ToString("F3") + ", offset is " + calibrationOffset.ToString() + " inEditor is " + inEditor);
		if (inEditor)
		{
			objectRefrences.beatPoint.position = new Vector3(0f, num3, num2 * 0.7f);
		}
	}

	private IEnumerator CalibrateRoutine()
	{
		Node[] array = UnityEngine.Object.FindObjectsOfType<Node>();
		for (int i = 0; i < array.Length; i++)
		{
			array[i].SetOffsets();
			yield return 1;
		}
	}

	private float CheckSongTime()
	{
		if (paused)
		{
			UnityEngine.Debug.LogError("The game is paused! Do not check the song time!");
		}
		return (float)(AudioSettings.dspTime - (double)dspSongStartTime);
	}

	private void UpdateUI()
	{
		if (trailingScore != score.score)
		{
			trailingScore = Mathf.CeilToInt(Mathf.Lerp(trailingScore, score.score, Time.deltaTime * 10f));
		}
		objectRefrences.scoreText.text = trailingScore.ToString("N0");
		objectRefrences.streakText.text = score.currentStreak.ToString();
		objectRefrences.multiText.text = score.multiplier.ToString();
		_ = songPlaying;
		GetBlinkers();
		if (score.GetAccuracy() < 100f)
		{
			if (score.health < 0.75f)
			{
				if (score.health < 0.25f)
				{
					objectRefrences.progressHandle.sprite = objectRefrences.deathHandle;
					objectRefrences.progressHandle.DisableSpriteOptimizations();
					objectRefrences.majorImage.sprite = objectRefrences.deathHandle;
					objectRefrences.majorImage.DisableSpriteOptimizations();
				}
				else
				{
					objectRefrences.progressHandle.sprite = objectRefrences.warningHandle;
					objectRefrences.progressHandle.DisableSpriteOptimizations();
					objectRefrences.majorImage.sprite = objectRefrences.warningHandle;
					objectRefrences.majorImage.DisableSpriteOptimizations();
				}
				objectRefrences.progressHandle.color = new Color(1f, score.health - 0.35f, 0f, Mathf.Clamp(songProgressPercent, 0f, 1f));
				objectRefrences.progressfill.color = new Color(1f, score.health - 0.35f, 0f, Mathf.Clamp(songProgressPercent, 0f, 0.8f));
				objectRefrences.handleBlinker.blink = true;
				objectRefrences.handleBlinker.blinkTime = Mathf.Max(0.1f, score.health / 3f);
				objectRefrences.fillBlinker.blink = true;
				objectRefrences.fillBlinker.blinkTime = Mathf.Max(0.1f, score.health / 3f);
				objectRefrences.majorBlinker.blink = true;
				objectRefrences.majorBlinker.blinkTime = Mathf.Max(0.1f, score.health / 3f);
				objectRefrences.majorImage.color = new Color(1f, score.health - 0.35f, 0f, 1f);
			}
			else
			{
				objectRefrences.fillBlinker.blink = false;
				objectRefrences.handleBlinker.blink = false;
				objectRefrences.progressHandle.sprite = objectRefrences.normalHandle;
				objectRefrences.majorImage.color = new Color(0f, 0f, 0f, 0f);
				objectRefrences.majorBlinker.blink = false;
				objectRefrences.progressHandle.color = new Color(1f, 1f, 1f, Mathf.Clamp(songProgressPercent, 0.1f, 1f));
				objectRefrences.progressfill.color = new Color(1f, 1f, 1f, Mathf.Clamp(songProgressPercent, 0.05f, 0.8f));
			}
		}
		else
		{
			_ = Mathf.Sin(Time.time * 3f) / 2f;
			objectRefrences.fillBlinker.blink = false;
			objectRefrences.handleBlinker.blink = false;
			objectRefrences.progressHandle.sprite = objectRefrences.normalHandle;
			objectRefrences.majorImage.color = new Color(0f, 0f, 0f, 0f);
			objectRefrences.majorBlinker.blink = false;
			objectRefrences.progressHandle.color = new Color(1f, 1f, 1f, Mathf.Clamp(songProgressPercent, 0.1f, 1f));
			objectRefrences.progressfill.color = new Color(1f, 1f, 1f, Mathf.Clamp(songProgressPercent, 0.05f, 0.8f));
		}
	}

	private void GetBlinkers()
	{
		if (objectRefrences.handleBlinker == null)
		{
			objectRefrences.handleBlinker = objectRefrences.progressHandle.GetComponent<Image_Blinker>();
		}
		if (objectRefrences.fillBlinker == null)
		{
			objectRefrences.fillBlinker = objectRefrences.progressfill.GetComponent<Image_Blinker>();
		}
		if (objectRefrences.majorBlinker == null)
		{
			objectRefrences.majorBlinker = objectRefrences.majorImage.GetComponent<Image_Blinker>();
		}
	}

	public Score.Rank GetRank(float acc, float energy, float precision)
	{
		float num = (acc * 2f + energy + precision) / 4f;
		if (num >= 99f)
		{
			return Score.Rank.Splus;
		}
		if (num >= 97f)
		{
			return Score.Rank.S;
		}
		if (num >= 95f)
		{
			return Score.Rank.Sminus;
		}
		if (num >= 85f)
		{
			return Score.Rank.Aplus;
		}
		if (num >= 80f)
		{
			return Score.Rank.A;
		}
		if (num >= 75f)
		{
			return Score.Rank.Aminus;
		}
		if (num >= 70f)
		{
			return Score.Rank.Bplus;
		}
		if (num >= 65f)
		{
			return Score.Rank.B;
		}
		if (num >= 60f)
		{
			return Score.Rank.Bminus;
		}
		if (num >= 55f)
		{
			return Score.Rank.Cplus;
		}
		if (num >= 50f)
		{
			return Score.Rank.C;
		}
		if (num >= 45f)
		{
			return Score.Rank.Cminus;
		}
		if (num >= 40f)
		{
			return Score.Rank.Dplus;
		}
		if (num >= 35f)
		{
			return Score.Rank.D;
		}
		if (num >= 30f)
		{
			return Score.Rank.Dminus;
		}
		if (num >= 25f)
		{
			return Score.Rank.Eplus;
		}
		if (num >= 20f)
		{
			return Score.Rank.E;
		}
		if (float.IsNaN(num))
		{
			return Score.Rank.Blank;
		}
		return Score.Rank.Eminus;
	}

	private void PulseScore(float amount)
	{
	}

	private void UpdateTaunts()
	{
		if (isTaunting)
		{
			tauntDuration -= Time.deltaTime;
			if (tauntDuration <= 0f)
			{
				isTaunting = false;
			}
		}
	}

	public void StartTaunt(TauntInfo taunt)
	{
		holoCon.Taunt();
	}

	public void DanceButtonPressed()
	{
		if (objectRefrences.settings_ui != null)
		{
			objectRefrences.settings_ui.gameObject.SetActive(value: false);
		}
		if (holoCon != null && !Persistence.instance.svMan.settingsSave.skipIntros && Persistence.instance.builtInSong)
		{
			gameIntro = true;
			holoCon.ShowHolo();
			voMan.PlaySound(voMan.musicAC, voMan.musicAS);
			objectRefrences.intro_UI.SetActive(value: true);
			objectRefrences.intro_title3.text = ParseLoc.Parse(currentSong.title3);
			objectRefrences.intro_title2.text = ParseLoc.Parse(currentSong.title2);
			objectRefrences.intro_title1.text = ParseLoc.Parse(currentSong.title1).ToLower();
			TogglePointers(toggle: false);
		}
		else
		{
			StartSong();
			if (Persistence.instance.builtInSong && Persistence.instance.svMan.settingsSave.enableDanceholograms)
			{
				UnityEngine.Object.FindObjectOfType<DirectorDirector>().StartDance(GetStageNum(musicNum) - 1);
				holoCon.ShowHolo();
			}
		}
	}

	public void StartCountdown()
	{
		StartCoroutine(Countdowntimer(countdownTimes.x, countdownTimes.y, countdownTimes.z));
	}

	private IEnumerator Countdowntimer(float oneTime, float twoTime, float threeTime)
	{
		yield return new WaitForSeconds(oneTime);
		UnityEngine.Object.Instantiate(objectRefrences.scoreEventGeneric, new Vector3(0f, 0f, 0f), Quaternion.identity).GetComponent<ScoreEvent>().text.text = "3";
		yield return new WaitForSeconds(twoTime);
		UnityEngine.Object.Instantiate(objectRefrences.scoreEventGeneric, new Vector3(0f, 0f, 0f), Quaternion.identity).GetComponent<ScoreEvent>().text.text = "2";
		yield return new WaitForSeconds(threeTime);
		UnityEngine.Object.Instantiate(objectRefrences.scoreEventGeneric, new Vector3(0f, 0f, 0f), Quaternion.identity).GetComponent<ScoreEvent>().text.text = "1";
	}

	public void ThrowTutorialScoreCard(string _text)
	{
		UnityEngine.Object.Instantiate(objectRefrences.scoreEventGeneric, new Vector3(0f, 0f, 0f), Quaternion.identity).GetComponent<ScoreEvent>().text.text = _text;
	}

	public void TogglePointers(bool toggle)
	{
		objectRefrences.leftPointer.SetActive(toggle);
	}

	public void StartSong()
	{
		gameIntro = false;
		UnityEngine.Object.FindObjectOfType<FadeInOut>().enabled = false;
		score.ResetScore();
		TogglePointers(toggle: false);
		if (!isTutorial && Persistence.instance.svMan.settingsSave.enableUI)
		{
			objectRefrences.scoreText.transform.parent.gameObject.SetActive(value: true);
		}
		ControllerFix();
		if (currentSong._music.StartsWith("#"))
		{
			songIsBuiltIn = true;
			StartBuiltInSong();
		}
		else if (currentSong._music.StartsWith("%"))
		{
			songIsBuiltIn = false;
			StartCustomSong();
		}
		else
		{
			songIsBuiltIn = false;
			StartYoutubeSong(currentSong._music);
		}
		if (!inEditor)
		{
			lastNodeTime = currentSong.GetLastNode().beatTime;
		}
	}

	private void ControllerFix()
	{
		objectRefrences.leftController.transform.localPosition = Vector3.zero;
		objectRefrences.rightController.transform.localPosition = Vector3.zero;
	}

	private void StartYoutubeSong(string URL)
	{
		if (songPlaying)
		{
			StopSong();
		}
		else
		{
			objectRefrences.youtubePlayer.PlayYoutubeVideo(URL);
		}
	}

	public void YoutubeVideoStarted()
	{
	}

	private void StartBuiltInSong(float startTime = 0f)
	{
		UnityEngine.Debug.Log("Start built-in audio");
		if (songPlaying)
		{
			StopSong();
			return;
		}
		if (inEditor)
		{
			currentSong.InitSong(startTime, incremental: false);
			ClearAllNodes();
			GetComponent<AudioSource>().Stop();
			GetComponent<AudioSource>().clip = Resources.Load<AudioClip>(songStrings[musicNum]);
			GetComponent<AudioSource>().timeSamples = TimeToSamples(startTime);
			GetComponent<AudioSource>().Play();
		}
		else if (!isTutorial)
		{
			GetComponent<AudioSource>().Stop();
			GetComponent<AudioSource>().clip = Resources.Load<AudioClip>(songStrings[musicNum]);
			GetComponent<AudioSource>().timeSamples = TimeToSamples(startTime);
			GetComponent<AudioSource>().Play();
		}
		songPlaying = true;
		if (!isTutorial)
		{
			dspSongStartTime = (float)AudioSettings.dspTime - startTime;
		}
		if (!paused)
		{
			songTime = CheckSongTime();
		}
	}

	private void StartCustomSong(float startTime = 0f)
	{
		UnityEngine.Debug.Log("start custom audio at " + startTime);
		if (songPlaying)
		{
			StopSong();
			return;
		}
		if (inEditor)
		{
			ClearAllNodes();
		}
		AudioSource component = GetComponent<AudioSource>();
		component.Stop();
		component.timeSamples = TimeToSamples(startTime, component.clip.frequency);
		component.Play();
		songPlaying = true;
		if (!isTutorial)
		{
			dspSongStartTime = (float)AudioSettings.dspTime - startTime;
		}
		if (!paused)
		{
			songTime = CheckSongTime();
		}
	}

	public AudioClip GetAudioClipFromMusicString(string music)
	{
		if (music.StartsWith("%"))
		{
			try
			{
				string path = UnityEngine.Application.persistentDataPath + "/Custom/Music/" + music.Substring(1);
				string text = "file://" + UnityEngine.Application.persistentDataPath + "/Custom/Music/" + music.Substring(1);
				UnityEngine.Debug.Log(text);
				if (Path.GetExtension(text) != ".mp3")
				{
					WWW wWW = new WWW(text);
					while (!wWW.isDone)
					{
					}
					AudioClip audioClip = wWW.GetAudioClip(threeD: false, stream: false);
					UnityEngine.Debug.Log("Loaded audioclip with " + audioClip.frequency + " frequency");
					return audioClip;
				}
				string fileNameWithoutExtension = Path.GetFileNameWithoutExtension(path);
				MpegFile mpegFile = new MpegFile(path);
				return AudioClip.Create(fileNameWithoutExtension, (int)(mpegFile.Length / 4 / mpegFile.Channels), mpegFile.Channels, mpegFile.SampleRate, stream: false, delegate(float[] data)
				{
					mpegFile.ReadSamples(data, 0, data.Length);
				});
			}
			catch (Exception ex)
			{
				UnityEngine.Debug.Log("custom audio failed - " + ex.ToString());
				return null;
			}
		}
		if (music.StartsWith("#"))
		{
			if (!int.TryParse(music.Substring(1), out var result))
			{
				UnityEngine.Debug.LogError(currentSong._music + " is not a valid music ID!, but that's probably ok?", this);
				return null;
			}
			return Resources.Load<AudioClip>(songStrings[result]);
		}
		return null;
	}

	private int TimeToSamples(float time)
	{
		return Mathf.CeilToInt(time * (float)AudioSettings.outputSampleRate);
	}

	private int TimeToSamples(float time, int frequency)
	{
		return Mathf.CeilToInt(time * (float)frequency);
	}

	private float SamplesToTime(int samples)
	{
		return (float)samples / ((float)AudioSettings.outputSampleRate * 1f);
	}

	private float SamplesToTime(int samples, int frequency)
	{
		return (float)samples / ((float)frequency * 1f);
	}

	public void StopSong(bool mute = true)
	{
		UnityEngine.Object.FindObjectOfType<FadeInOut>().enabled = true;
		if (!inEditor)
		{
			TogglePointers(toggle: true);
		}
		if (songIsBuiltIn)
		{
			songPlaying = false;
			if (mute)
			{
				GetComponent<AudioSource>().Stop();
			}
			ClearAllNodes();
		}
		else
		{
			songPlaying = false;
			ClearAllNodes();
		}
	}

	public void NextStage()
	{
		if (GetStageNum(musicNum) > 4)
		{
			UnityEngine.Debug.Log("Can't skip to the next stage!");
			return;
		}
		string[] array = Persistence.instance.currentSongFilename.Split('_');
		Persistence.instance.currentSongFilename = array[0] + "_" + array[1] + "_" + (GetStageNum(musicNum) + 1) + "_" + array[3];
		Reload();
	}

	public SplineComputer GetSpline(string splineName)
	{
		return paths.Find((NodePath n) => n.name.ToLower() == splineName.ToLower())?.spline;
	}

	public void NodeFinished(NodeType type, bool hit, bool endOfSet = false, bool cascade = false, float velocity = 0f, float precision = 0f)
	{
		if (hit)
		{
			if (cascade)
			{
				PulseScore(0.03f);
				score.AddScore(cascadeSingleHit);
				score.NodeHit(type, 0f, 0f, difficulty.heal * cascadeDamageMultiplier, cascade: true);
				return;
			}
			if (type == NodeType.Yellow)
			{
				if (!isTutorial)
				{
					_pulse?.Invoke();
				}
				PulseScore(1f);
				objectRefrences.scoreText.GetComponent<UI_Shaker>().Shake(0.7f, 1.7f);
				objectRefrences.multiText.GetComponent<UI_Shaker>().Shake(1f + 0.2f * (float)(score.multiplier - 1), 1f + 0.2f * (float)(score.multiplier - 1));
				if (score.GetAccuracy() > complimentThreshold && !inEditor && !isTutorial && voMan != null)
				{
					voMan.PlayVoiceLine(VOType.e_compliment);
				}
			}
			else
			{
				PulseScore(0.1f);
			}
			score.NodeHit(type, velocity, precision, difficulty.heal);
			if (endOfSet)
			{
				score.AddScore(setbonus);
				score.CompleteSet();
				PulseScore(1f);
				objectRefrences.scoreText.GetComponent<UI_Shaker>().Shake(0.3f, 1.3f);
				if (objectRefrences.lightManager != null)
				{
					objectRefrences.lightManager.Trigger(LightShowManager.e_EffectGroup.SetComplete);
				}
				if (!isTutorial)
				{
					_pulse();
				}
				UnityEngine.Debug.Log("endOfSet");
			}
		}
		else
		{
			if (score.health < insultThreshold && !inEditor && voMan != null)
			{
				voMan.PlayVoiceLine(VOType.e_insult);
				UnityEngine.Debug.Log("Playing insult VO.");
			}
			if (!cascade)
			{
				score.NodeMissed(difficulty.damage);
			}
			else
			{
				score.NodeMissed(difficulty.damage * cascadeDamageMultiplier);
			}
			if (perfect)
			{
				perfect = false;
			}
		}
	}

	public void LastNode()
	{
		if (!inEditor)
		{
			StopSong(!Persistence.instance.builtInSong);
			TogglePointers(toggle: false);
			if (((holoCon != null) & Persistence.instance.svMan.settingsSave.enableDanceholograms) && Persistence.instance.builtInSong)
			{
				holoCon.Victory();
			}
			else if (!isTutorial)
			{
				ShowResults();
			}
			else if (isTutorial)
			{
				tutMan.EndDance();
			}
		}
	}

	public void ShowResults()
	{
		objectRefrences.resultsCanvas.gameObject.SetActive(value: true);
		objectRefrences.resultsCanvas.score = score.score;
		objectRefrences.resultsCanvas.accuracy = score.GetAccuracy();
		objectRefrences.resultsCanvas.energy = score.GetEnergyRating();
		objectRefrences.resultsCanvas.streak = score.maxStreak;
		objectRefrences.resultsCanvas.maxMulti = score.maxMultiplier;
		objectRefrences.resultsCanvas.sets = score.completeSets;
		objectRefrences.resultsCanvas.cascades = score.perfectCascades;
		objectRefrences.resultsCanvas.precision = score.GetPrecisionRating();
		objectRefrences.resultsCanvas.rank = GetRank(score.GetAccuracy(), score.GetEnergyRating(), score.GetPrecisionRating());
		objectRefrences.resultsCanvas.stageNum = GetStageNum(musicNum);
		objectRefrences.resultsCanvas.Display();
		objectRefrences.scoreText.transform.parent.gameObject.SetActive(value: false);
		UnityEngine.Debug.Log("RESULTS SCORE IS " + score.score);
		if (god)
		{
			OculusManager.instance.RequestScores();
		}
		if (!Persistence.instance.builtInSong || god)
		{
			return;
		}
		Persistence.instance.UploadScore(score.score, GetRank(score.GetAccuracy(), score.GetEnergyRating(), score.GetPrecisionRating()));
		Persistence.instance.UpdateAchievements();
		Score.Rank rank = GetRank(score.GetAccuracy(), score.GetEnergyRating(), score.GetPrecisionRating());
		Persistence.instance.svMan.SetColliderRank(Persistence.instance.currentSongFilename, rank);
		if (score.GetAccuracy() == 100f)
		{
			OculusManager.instance.UnlockAchievement("A_PERFECT_STREAK");
		}
		string text = Persistence.instance.currentSongFilename.Split('_')[1];
		if (text != null)
		{
			switch (text)
			{
			case "Yuri":
				OculusManager.instance.UnlockAchievement("A_DEFEAT_YURI");
				break;
			case "Pyro":
				OculusManager.instance.UnlockAchievement("A_DEFEAT_PYRO");
				break;
			case "Lais":
				OculusManager.instance.UnlockAchievement("A_DEFEAT_LAIS");
				break;
			case "Remi":
				OculusManager.instance.UnlockAchievement("A_DEFEAT_REMI");
				break;
			case "Liu":
				OculusManager.instance.UnlockAchievement("A_DEFEAT_LIU");
				break;
			case "Dre":
				OculusManager.instance.UnlockAchievement("A_DEFEAT_DRE");
				break;
			case "Sonya":
				OculusManager.instance.UnlockAchievement("A_DEFEAT_SONYA");
				break;
			case "Core":
				OculusManager.instance.UnlockAchievement("A_DEFEAT_CORE");
				break;
			case "Uriel":
				OculusManager.instance.UnlockAchievement("A_LORDOFTHENET");
				break;
			}
		}
	}

	public void Uriel_Update()
	{
		float localUrielProgress = Persistence.instance.svMan.localUrielProgress;
		if (localUrielProgress == 1f)
		{
			UnityEngine.Debug.Log("Uriel already unlocked!");
			return;
		}
		objectRefrences.uriel_progress.transform.parent.gameObject.SetActive(value: true);
		Persistence.instance.svMan.IncreaseUrielUnlock(0.1f);
		float localUrielProgress2 = Persistence.instance.svMan.localUrielProgress;
		UnityEngine.Debug.Log("Uriel unlock progress: " + localUrielProgress + " --> " + localUrielProgress2);
		objectRefrences.uriel_progress.Init(localUrielProgress, localUrielProgress2);
		objectRefrences.uriel_progress.transform.parent.GetComponent<UrielAnimationEvent>().StartAnimation();
		if (localUrielProgress < 1f && localUrielProgress2 >= 1f)
		{
			UnityEngine.Debug.Log("Uriel unlock triggered!");
			OculusManager.instance.UnlockAchievement("A_BREACHED");
			objectRefrences.results_lobby_button.SetActive(value: false);
			objectRefrences.results_restart_button.SetActive(value: false);
			objectRefrences.results_nextstage_button.SetActive(value: false);
			Invoke("Uriel_Abort", 10f);
		}
	}

	private void Uriel_Abort()
	{
		objectRefrences.resultsCanvas.transform.GetChild(3).GetChild(0).gameObject.SetActive(value: false);
		objectRefrences.resultsCanvas.transform.GetChild(3).GetChild(1).gameObject.SetActive(value: false);
		objectRefrences.resultsCanvas.GetComponent<AudioSource>().Stop();
		objectRefrences.uriel_button.SetActive(value: true);
	}

	public int GetStageNum(int musicID)
	{
		switch (musicID)
		{
		case 0:
			return 1;
		case 1:
			return 2;
		case 2:
			return 3;
		case 3:
			return 1;
		case 4:
			return 2;
		case 5:
			return 3;
		case 6:
			return 1;
		case 7:
			return 2;
		case 8:
			return 3;
		case 9:
			return 1;
		case 10:
			return 2;
		case 11:
			return 3;
		case 12:
			return 1;
		case 13:
			return 2;
		case 14:
			return 3;
		case 15:
			return 1;
		case 16:
			return 2;
		case 17:
			return 3;
		case 18:
			return 1;
		case 19:
			return 2;
		case 20:
			return 3;
		case 21:
			return 1;
		case 22:
			return 2;
		case 23:
			return 3;
		case 24:
		case 25:
		case 26:
		case 27:
		case 28:
		case 29:
		case 30:
		case 31:
			return 4;
		case 32:
		case 33:
		case 34:
		case 35:
		case 36:
		case 37:
		case 38:
		case 39:
			return 5;
		case 40:
			return 1;
		case 41:
			return 2;
		case 42:
			return 3;
		case 43:
			return 4;
		case 44:
			return 5;
		default:
			return 1;
		}
	}

	public void CascadeNodeFinished(float percent, int count)
	{
		score.AwardCascadeScore(percent, count);
		PulseScore(percent);
		if (percent == 1f)
		{
			score.PerfectCascade();
			objectRefrences.scoreText.GetComponent<UI_Shaker>().Shake(0.5f, 1.2f);
		}
	}

	public void SpawnShockwave()
	{
	}

	private void SetupObjectPool()
	{
		List<SongNode> list = new List<SongNode>();
		List<SongNode> list2 = new List<SongNode>();
		for (int i = 0; i < currentSong.nodes.Count; i++)
		{
			SongNode songNode = currentSong.nodes[i];
			if (songNode.cascade)
			{
				switch (songNode.type)
				{
				case NodeType.Green:
					list2.Add(songNode);
					break;
				case NodeType.Pink:
					list.Add(songNode);
					break;
				case NodeType.GreenCascadeEnd:
					list2.Clear();
					break;
				case NodeType.PinkCascadeEnd:
					list.Clear();
					break;
				}
			}
		}
	}

	public void LoadDance()
	{
		fileName = Persistence.instance.currentSongFilename;
		if (Persistence.instance.builtInSong)
		{
			UnityEngine.Debug.Log("Loading an official song...");
			TextAsset textAsset = Resources.Load<TextAsset>("OfficialDances/" + fileName);
			currentSong = JsonUtility.FromJson<Song>(textAsset.text);
		}
		else
		{
			UnityEngine.Debug.Log("Loading a custom song...");
			string customDanceFilePath = GetCustomDanceFilePath(fileName);
			if (File.Exists(customDanceFilePath))
			{
				currentSong = JsonUtility.FromJson<Song>(File.ReadAllText(customDanceFilePath));
			}
			else
			{
				UnityEngine.Debug.Log("Can't find " + customDanceFilePath);
			}
		}
		if (currentSong._music[0] == "#"[0])
		{
			currentSong._lightshow = currentSong._arena;
		}
		spawnBuffer = 60f / currentSong.BPM * (float)difficulty.delay;
		if (!int.TryParse(currentSong._music.Substring(1), out musicNum))
		{
			UnityEngine.Debug.LogWarning(currentSong._music + " is not a valid music ID!, but that's probably ok?", this);
			musicNum = 0;
		}
		if (loadArena)
		{
			if (arenaLoaded != "")
			{
				SceneManager.UnloadSceneAsync(arenaLoaded);
				UnityEngine.Debug.Log("Uloading scene " + arenaLoaded);
			}
			StartCoroutine(LoadArena());
		}
		else if (!isTutorial)
		{
			StartFadeIn();
		}
	}

	private IEnumerator LoadArena()
	{
		Persistence.instance.ToggleOverlay(toggle: true);
		UnityEngine.Application.backgroundLoadingPriority = UnityEngine.ThreadPriority.High;
		AsyncOperation asyncLoad = SceneManager.LoadSceneAsync(currentSong._arena, LoadSceneMode.Additive);
		while (!asyncLoad.isDone)
		{
			yield return null;
		}
		currentSong.InitSong(0f, incremental: false);
		Persistence.instance.ToggleOverlay(toggle: false);
		arenaLoaded = currentSong._arena;
		SceneManager.SetActiveScene(SceneManager.GetSceneByName(currentSong._arena));
		TogglePointers(toggle: false);
		TogglePointers(toggle: true);
	}

	public void LoadLobby()
	{
		StartFadeOut();
		if (Persistence.instance.builtInSong)
		{
			Persistence.instance.lobbyscreen = 1;
		}
		else
		{
			Persistence.instance.lobbyscreen = 12;
		}
		StartCoroutine(LoadSceneDelayed());
	}

	public void Load_UrielLobby()
	{
		Persistence.instance.lobbyscreen = 1;
		StartFadeOut();
		StartCoroutine(LoadSceneDelayed());
	}

	public void StartFadeIn()
	{
		UnityEngine.Object.FindObjectOfType<FadeInOut>().target = 0f;
		UnityEngine.Object.FindObjectOfType<FadeInOut>().Fade();
	}

	public void StartFadeOut()
	{
		UnityEngine.Object.FindObjectOfType<FadeInOut>().target = 1f;
		UnityEngine.Object.FindObjectOfType<FadeInOut>().Fade();
	}

	private IEnumerator LoadSceneDelayed(string scene = "dance collider lobby", float delay = 1f)
	{
		yield return new WaitForSecondsRealtime(delay);
		Persistence.instance.ToggleOverlay(toggle: true);
		yield return new WaitForSecondsRealtime(0.5f);
		Persistence.instance.svMan.SavePrefs();
		SceneManager.LoadScene(scene);
	}

	public void Reload()
	{
		StartCoroutine(LoadSceneDelayed("Game"));
		UnityEngine.Debug.Log("RELOADING");
		StartFadeOut();
		StopSong();
		TogglePointers(toggle: false);
		SetChevronsAlpha(objectRefrences.rightSideChevs, 0f, reset: true);
		SetChevronsAlpha(objectRefrences.rightSideChevs1, 0f, reset: true);
		SetChevronsAlpha(objectRefrences.leftSideChevs, 0f, reset: true);
		SetChevronsAlpha(objectRefrences.leftSideChevs1, 0f, reset: true);
		SetChevronsAlpha(objectRefrences.middleChevs, 0f, reset: true);
		SetChevronsAlpha(objectRefrences.middleChevs1, 0f, reset: true);
		god = Persistence.instance.nofail;
		if (objectRefrences.godModeText != null)
		{
			objectRefrences.godModeText.SetActive(god);
		}
		Time.timeScale = 1f;
		UnityEngine.Debug.Log("Set the master volume up because GameManagerReload");
		objectRefrences.scoreText.transform.parent.gameObject.SetActive(value: false);
		objectRefrences.resultsCanvas.nextStageUI.SetActive(value: false);
		objectRefrences.pause_ui.gameObject.SetActive(value: false);
		difficulty = Persistence.instance.GetDifficuty();
		objectRefrences.resultsCanvas.gameObject.SetActive(value: false);
		objectRefrences.failureCanvas.SetActive(value: false);
		objectRefrences.uriel_progress.transform.parent.gameObject.SetActive(value: false);
	}

	private IEnumerator RestartDelay()
	{
		yield return new WaitForSeconds(1f);
		SetupGame();
		objectRefrences.startButton.transform.parent.gameObject.SetActive(value: true);
	}

	public void RestartTutorial()
	{
		StartCoroutine(LoadSceneDelayed("Tutorial", 0f));
	}

	public void Failure()
	{
		StopSong();
		objectRefrences.failureCanvas.SetActive(value: true);
		if (!inEditor && !isTutorial && holoCon != null)
		{
			holoCon.Defeat();
		}
	}

	public string GetCustomDanceFilePath(string _fileName)
	{
		return UnityEngine.Application.persistentDataPath + "/Custom/Dances/" + _fileName + ".json";
	}

	public void SpawnStreakScoreEvent()
	{
		if (Persistence.instance.svMan.settingsSave.enableUI)
		{
			ThrowStreakEvent(objectRefrences.beatPoint.position, score.currentStreak.ToString());
		}
	}

	public void SpawnSetCounter(int numInSet)
	{
		if (Persistence.instance.svMan.settingsSave.enableUI)
		{
			currentSetCounter = UnityEngine.Object.Instantiate(objectRefrences.scoreEventSetPrefab, base.transform.position, Quaternion.identity).GetComponent<SetCounter>();
		}
		else
		{
			currentSetCounter = UnityEngine.Object.Instantiate(objectRefrences.scoreEventSetPrefab, new Vector3(0f, -1000f, -1000f), Quaternion.identity).GetComponent<SetCounter>();
		}
		currentSetCounter.Init(numInSet);
		if (!inEditor)
		{
			UnityEngine.Object.FindObjectOfType<UI_SoundManager>().PlayScoreEventEffect();
		}
	}

	public void HitSet()
	{
		if (currentSetCounter == null)
		{
			UnityEngine.Debug.LogError("I'm hitting a set bu thtere's no counter", this);
		}
		else
		{
			currentSetCounter.Hit();
		}
	}

	public void BreakSet()
	{
		if (!(currentSetCounter == null))
		{
			currentSetCounter.Miss();
			currentSetCounter = null;
		}
	}

	public void Pause(bool pauseUI = true)
	{
		if (!inEditor)
		{
			if (pauseUI && objectRefrences.settings_ui != null)
			{
				objectRefrences.settings_ui.gameObject.SetActive(value: true);
			}
			objectRefrences.pause_ui.gameObject.SetActive(pauseUI);
			objectRefrences.pause_ui.Reset();
			TogglePointers(toggle: true);
			Time.timeScale = 0f;
			objectRefrences.leftController.GetComponent<TrailRenderer>().enabled = false;
			objectRefrences.rightController.GetComponent<TrailRenderer>().enabled = false;
			if (songPlaying)
			{
				GetComponent<AudioSource>().Pause();
			}
			UnityEngine.Debug.Log("Set the master volume down because gamemanagerpause");
			paused = true;
		}
	}

	public void UnPause()
	{
		dspSongStartTime = (float)(AudioSettings.dspTime - (double)songTime);
		Time.timeScale = 1f;
		TogglePointers(!songPlaying);
		UnityEngine.Debug.Log("TogglePointersUnPause");
		objectRefrences.leftController.GetComponent<TrailRenderer>().enabled = true;
		objectRefrences.rightController.GetComponent<TrailRenderer>().enabled = true;
		if ((songPlaying || gameIntro) && objectRefrences.settings_ui != null)
		{
			objectRefrences.settings_ui.gameObject.SetActive(value: false);
		}
		if (songPlaying)
		{
			GetComponent<AudioSource>().UnPause();
		}
		objectRefrences.pause_ui.gameObject.SetActive(value: false);
		paused = false;
	}

	private void MenuPressed()
	{
		UnityEngine.Debug.Log("Menu pressed!");
		if (inEditor)
		{
			EditorManager.instance.TogglePlayPause();
		}
		if ((songPlaying || gameIntro) && !paused)
		{
			Pause();
		}
	}

	public void Scrub(float time)
	{
		time = Mathf.Max(0f, time);
		if (!inEditor)
		{
			UnityEngine.Debug.Log("Can't scrub if you're not in the editor.");
		}
		StopSong();
		songIsBuiltIn = true;
		if (currentSong._music.StartsWith("#"))
		{
			StartBuiltInSong(time);
		}
		else if (currentSong._music.StartsWith("%"))
		{
			StartCustomSong(time);
		}
	}

	public void LoadEditor()
	{
		UnityEngine.Object.FindObjectOfType<FadeInOut>().target = 1f;
		UnityEngine.Object.FindObjectOfType<FadeInOut>().Fade();
		StartCoroutine(LoadSceneDelayed("DanceEditor"));
	}

	public void SetSongLoadProgress(float progress)
	{
		if (objectRefrences.startButtonFillBar != null)
		{
			objectRefrences.startButtonFillBar.fillAmount = 1f - progress;
		}
	}

	public void StartIncrementalSpawn(List<SongNode> nodes, float time = 0f)
	{
		StartCoroutine(SpawnNodesIncremental(nodes, time));
	}

	private IEnumerator SpawnNodesIncremental(List<SongNode> nodes, float time = 0f)
	{
		Node previousNode = null;
		Node previousGreenCascadeNode = null;
		Node previousRedCascadeNode = null;
		int i = 0;
		int numFrameSpawned = 0;
		for (int i2 = 0; i2 < nodes.Count; i2++)
		{
			SongNode songNode = nodes[i2];
			if (Persistence.instance.currentDifficulty < songNode.minDifficulty || songNode.beatTime < time)
			{
				continue;
			}
			Node node = songNode.type switch
			{
				NodeType.Green => UnityEngine.Object.Instantiate(instance.objectRefrences.greenNodePrefab, new Vector3(0f, 0f, i++), Quaternion.identity).GetComponent<Node>(), 
				NodeType.MirageGreen => UnityEngine.Object.Instantiate(instance.objectRefrences.greenMiragePrefab, new Vector3(0f, 0f, i++), Quaternion.identity).GetComponent<Node>(), 
				NodeType.Pink => UnityEngine.Object.Instantiate(instance.objectRefrences.pinkNodePrefab, new Vector3(0f, 0f, i++), Quaternion.identity).GetComponent<Node>(), 
				NodeType.MiragePink => UnityEngine.Object.Instantiate(instance.objectRefrences.pinkMiragePrefab, new Vector3(0f, 0f, i++), Quaternion.identity).GetComponent<Node>(), 
				NodeType.Yellow => UnityEngine.Object.Instantiate(instance.objectRefrences.yellowNodePrefab).GetComponent<Node>(), 
				_ => UnityEngine.Object.Instantiate(instance.objectRefrences.pinkNodePrefab, new Vector3(0f, 0f, i++), Quaternion.identity).GetComponent<Node>(), 
			};
			node.transform.parent = instance.transform.parent;
			node.beatTime = songNode.beatTime;
			node.offset = new Vector2(songNode.offsetX, songNode.offsetY);
			node.type = songNode.type;
			node.path = songNode.path;
			node.set = songNode.set;
			node.cascade = songNode.cascade;
			node.tauntInfo = new TauntInfo(songNode.serTauntInfo);
			node.holoLight = songNode.holoLight;
			node.danceID = songNode.danceID;
			node.holoNum = songNode.holoNum;
			node.bufferOverride = songNode.bufferOverride;
			node.minDifficulty = songNode.minDifficulty;
			node.Init();
			if (songNode.cascade)
			{
				if (songNode.type == NodeType.Pink)
				{
					if (previousRedCascadeNode != null)
					{
						node.cascadeChild = previousRedCascadeNode;
					}
					previousRedCascadeNode = node;
				}
				else if (songNode.type == NodeType.Green)
				{
					if (previousGreenCascadeNode != null)
					{
						node.cascadeChild = previousGreenCascadeNode;
					}
					previousGreenCascadeNode = node;
				}
			}
			else if (songNode.type == NodeType.Pink)
			{
				if (previousRedCascadeNode != null)
				{
					previousRedCascadeNode.MakeEndOfCascade();
					if (previousRedCascadeNode.cascadeChild != null)
					{
						previousRedCascadeNode.cascadeChild.InitCascade(previousRedCascadeNode);
					}
				}
				previousRedCascadeNode = null;
			}
			else if (songNode.type == NodeType.Green)
			{
				if (previousGreenCascadeNode != null)
				{
					previousGreenCascadeNode.MakeEndOfCascade();
					if (previousGreenCascadeNode.cascadeChild != null)
					{
						previousGreenCascadeNode.cascadeChild.InitCascade(previousGreenCascadeNode);
					}
				}
				previousGreenCascadeNode = null;
			}
			if (songNode.type == NodeType.GreenCascadeEnd)
			{
				if (previousGreenCascadeNode != null)
				{
					previousGreenCascadeNode.MakeEndOfCascade();
					previousGreenCascadeNode.cascadeChild.InitCascade(previousGreenCascadeNode);
				}
				previousGreenCascadeNode = null;
			}
			if (songNode.type == NodeType.PinkCascadeEnd)
			{
				if (previousRedCascadeNode != null)
				{
					previousRedCascadeNode.MakeEndOfCascade();
					previousRedCascadeNode.cascadeChild.InitCascade(previousRedCascadeNode);
				}
				previousRedCascadeNode = null;
			}
			if (previousNode != null)
			{
				previousNode.nextNeighbor = node;
				node.previousNeighbor = previousNode;
				previousNode.InitSet();
			}
			previousNode = node;
			int num = numFrameSpawned + 1;
			numFrameSpawned = num;
			SetSongLoadProgress(Mathf.InverseLerp(0f, nodes.Count, i2));
			if (numFrameSpawned > 10)
			{
				numFrameSpawned = 0;
				yield return null;
			}
		}
		if (objectRefrences.startButton != null)
		{
			objectRefrences.startButton.interactable = true;
		}
	}
}
[Serializable]
public class Score
{
	public enum Rank
	{
		Splus,
		S,
		Sminus,
		Aplus,
		A,
		Aminus,
		Bplus,
		B,
		Bminus,
		Cplus,
		C,
		Cminus,
		Dplus,
		D,
		Dminus,
		Eplus,
		E,
		Eminus,
		Blank
	}

	public int nodesHit;

	public int nodesMissed;

	public int score;

	public int sectionScore;

	public int multiplier = 1;

	public int maxMultiplier = 1;

	public int currentStreak;

	public int maxStreak;

	public int completeSets;

	public int totalSets;

	public int perfectCascades;

	public int totalCascades;

	public int powerNodesHit;

	private float totalEnergy;

	public float averageEnergy;

	private float totalPrecision;

	public float averagePrecision;

	[Range(0f, 1f)]
	public float health = 1f;

	public float GetAccuracy()
	{
		if (nodesHit == 0 && nodesMissed == 0)
		{
			return 100f;
		}
		if (nodesHit == 0)
		{
			return 0f;
		}
		return (float)nodesHit / ((float)(nodesHit + nodesMissed) * 1f) * 100f;
	}

	public float GetEnergyRating()
	{
		return averageEnergy * 100f;
	}

	public float GetPrecisionRating()
	{
		return averagePrecision * 100f;
	}

	public void NodeHit(NodeType type, float velocity, float precision, float heal = 0.05f, bool cascade = false)
	{
		if (!cascade)
		{
			powerNodesHit++;
		}
		nodesHit++;
		currentStreak++;
		if (currentStreak % 50 == 0)
		{
			GameManager.instance.objectRefrences.streakText.GetComponent<UI_Shaker>().Shake(3f, 2f);
			GameManager.instance.SpawnStreakScoreEvent();
		}
		health = Mathf.Clamp01(health + heal);
		if (currentStreak >= maxStreak)
		{
			maxStreak = currentStreak;
		}
		switch (type)
		{
		case NodeType.Green:
		case NodeType.Pink:
			AddScore(CalculateBaiscNodeScore(velocity, precision));
			break;
		case NodeType.Yellow:
			IncreaseMultiplier();
			AddScore(GameManager.instance.doubleNodeScore);
			break;
		}
		if (!cascade)
		{
			totalEnergy += Mathf.InverseLerp(GameManager.instance.minVelocity, GameManager.instance.maxVelocity, velocity);
			totalPrecision += Mathf.InverseLerp(GameManager.instance.maxPrecision, GameManager.instance.minPrecision, precision);
		}
		averageEnergy = totalEnergy / ((float)powerNodesHit * 1f);
		averagePrecision = totalPrecision / ((float)powerNodesHit * 1f);
	}

	private int CalculateBaiscNodeScore(float velocity, float precision)
	{
		float t = Mathf.InverseLerp(GameManager.instance.minVelocity, GameManager.instance.maxVelocity, velocity);
		float num = Mathf.InverseLerp(GameManager.instance.maxPrecision, GameManager.instance.minPrecision, precision);
		return Mathf.RoundToInt(Mathf.Lerp(GameManager.instance.basicNodeScoreMin, GameManager.instance.basicNodeScoreMax, t)) + Mathf.RoundToInt(num * 10f);
	}

	public void NodeMissed(float damage = 0.05f)
	{
		nodesMissed++;
		currentStreak = 0;
		DecreaseMultiplier();
		TakeDamage(damage);
	}

	private void TakeDamage(float damage)
	{
		if (!GameManager.instance.god)
		{
			health -= damage;
			if (health <= 0f && !GameManager.instance.god)
			{
				GameManager.instance.Failure();
			}
		}
	}

	public void ResetHealth()
	{
		health = 1f;
	}

	public void AddScore(int scoreToAdd)
	{
		score += scoreToAdd * multiplier;
		sectionScore += scoreToAdd * multiplier;
	}

	public void AwardCascadeScore(float percent, int count)
	{
		if (percent == 1f)
		{
			AddScore(Mathf.CeilToInt(GameManager.instance.cascadeBonus * count));
		}
	}

	public void CompleteSet()
	{
		completeSets++;
	}

	public void AddSet()
	{
		totalSets++;
	}

	public void PerfectCascade()
	{
		perfectCascades++;
	}

	public void AddCascade()
	{
		totalCascades++;
	}

	private void IncreaseMultiplier()
	{
		multiplier++;
		if (multiplier >= maxMultiplier)
		{
			maxMultiplier = multiplier;
		}
	}

	private void DecreaseMultiplier()
	{
		multiplier = Mathf.Max(1, multiplier - 1);
	}

	public void StartNewSection()
	{
		sectionScore = 0;
	}

	public void ResetScore()
	{
		score = 0;
		sectionScore = 0;
		multiplier = 1;
		maxMultiplier = 1;
		nodesMissed = 0;
		nodesHit = 0;
		currentStreak = 0;
		maxStreak = 0;
		perfectCascades = 0;
		completeSets = 0;
		health = 1f;
		totalEnergy = 0f;
		averageEnergy = 0f;
		powerNodesHit = 0;
		GameManager.instance.trailingScore = 0;
		totalPrecision = 0f;
		averagePrecision = 0f;
	}

	public static string GetRankString(int rank)
	{
		return rank switch
		{
			100 => "", 
			0 => "S+", 
			1 => "S", 
			2 => "S-", 
			3 => "A+", 
			4 => "A", 
			5 => "A-", 
			6 => "B+", 
			7 => "B", 
			8 => "B-", 
			9 => "C+", 
			10 => "C", 
			11 => "C-", 
			12 => "D+", 
			13 => "D", 
			14 => "D-", 
			15 => "E+", 
			16 => "E", 
			17 => "E-", 
			18 => "-", 
			_ => "Error", 
		};
	}
}
public class HandShield : MonoBehaviour
{
	public MeshRenderer pulsar;

	public float baseEmissivePower;

	public float pulsePower;

	public Color baseEmissiveColor;

	public float fadeRate;

	public float velocityForLine;

	private float power;

	private Material mat;

	private VelocityHolder velocity;

	private TrailRenderer trail;

	public ParticleSystem streakParticles;

	private AudioSource _audio;

	public bool leftHand;

	public AudioClip cascadeSound;

	public AudioClip cascadeBreakSound;

	private bool playingCascade;

	private float cascadeDuration;

	public Vector2 minMaxCascadePitch;

	private void Start()
	{
		power = baseEmissivePower;
		mat = pulsar.material;
		velocity = GetComponent<VelocityHolder>();
		trail = GetComponent<TrailRenderer>();
		_audio = GetComponent<AudioSource>();
		if (leftHand)
		{
			Color color = Color.HSVToRGB(Persistence.instance.svMan.settingsSave.left_Colour, 1f, 1f);
			mat.color = color;
			pulsar.transform.parent.GetChild(4).GetComponent<Renderer>().material.color = color;
			pulsar.transform.parent.GetChild(4).GetComponent<Renderer>().material.SetColor("_EmissionColor", Color.HSVToRGB(Persistence.instance.svMan.settingsSave.left_Colour, 1f, 0.2f));
			baseEmissiveColor = color;
			Gradient gradient = new Gradient();
			gradient.SetKeys(new GradientColorKey[2]
			{
				new GradientColorKey(color, 0f),
				new GradientColorKey(color, 1f)
			}, new GradientAlphaKey[2]
			{
				new GradientAlphaKey(0.1f, 0f),
				new GradientAlphaKey(0f, 1f)
			});
			trail.colorGradient = gradient;
		}
		else
		{
			Color color2 = Color.HSVToRGB(Persistence.instance.svMan.settingsSave.right_Colour, 1f, 1f);
			mat.color = color2;
			pulsar.transform.parent.GetChild(4).GetComponent<Renderer>().material.color = color2;
			pulsar.transform.parent.GetChild(4).GetComponent<Renderer>().material.SetColor("_EmissionColor", Color.HSVToRGB(Persistence.instance.svMan.settingsSave.right_Colour, 1f, 0.2f));
			baseEmissiveColor = color2;
			Gradient gradient2 = new Gradient();
			gradient2.SetKeys(new GradientColorKey[2]
			{
				new GradientColorKey(color2, 0f),
				new GradientColorKey(color2, 1f)
			}, new GradientAlphaKey[2]
			{
				new GradientAlphaKey(0.1f, 0f),
				new GradientAlphaKey(0f, 1f)
			});
			trail.colorGradient = gradient2;
		}
	}

	private void Update()
	{
		if (!GameManager.instance.paused)
		{
			mat.SetColor("_EmissionColor", new Vector4(power * baseEmissiveColor.r, power * baseEmissiveColor.g, power * baseEmissiveColor.b, 1f));
			baseEmissivePower = Mathf.Lerp(0.3f, 1f, Mathf.InverseLerp(50f, 200f, GameManager.instance.score.currentStreak));
			if (power > baseEmissivePower)
			{
				power = Mathf.Max(baseEmissivePower, power - fadeRate * Time.deltaTime);
			}
			else
			{
				power = Mathf.Min(baseEmissivePower, power + fadeRate * Time.deltaTime);
			}
			trail.enabled = velocity.velocity > velocityForLine;
			if (playingCascade)
			{
				_audio.pitch = Mathf.Min(_audio.pitch + (minMaxCascadePitch.y - minMaxCascadePitch.x) * Time.deltaTime / cascadeDuration, minMaxCascadePitch.y);
			}
		}
	}

	public void PulseEmissive()
	{
		power = pulsePower;
	}

	public void StartCascadeSound(float _cascadeDuration = 1f)
	{
		if (Persistence.instance.svMan.settingsSave.enableNodeSounds)
		{
			playingCascade = true;
			cascadeDuration = _cascadeDuration;
			_audio.pitch = minMaxCascadePitch.x;
			_audio.clip = cascadeSound;
			_audio.loop = true;
			_audio.Play();
		}
	}

	public void EndCascadeSound()
	{
		if (Persistence.instance.svMan.settingsSave.enableNodeSounds)
		{
			playingCascade = false;
			_audio.Stop();
			_audio.pitch = 1f;
		}
	}

	public void CancelCascadeSound()
	{
		if (Persistence.instance.svMan.settingsSave.enableNodeSounds)
		{
			playingCascade = false;
			_audio.Stop();
			_audio.pitch = 1f;
			_audio.clip = cascadeBreakSound;
			_audio.loop = false;
			_audio.Play();
		}
	}
}
public enum NodeType
{
	Green,
	Pink,
	Yellow,
	GreenCascadeEnd,
	PinkCascadeEnd,
	TauntStart,
	MirageGreen,
	MiragePink,
	HoloLight,
	SetEnd,
	LeftChannel,
	Midchannel,
	RightChannel
}
public enum VisualTreatment
{
	None,
	Flame,
	LongTail,
	ColorBlind,
	ColourSwitch,
	ColorBlind_Reverse,
	Spin,
	Yuri,
	Pyro,
	Lais,
	Remi,
	LiuWen,
	Dre,
	Sonya,
	Core
}
public class Node : MonoBehaviour
{
	[Serializable]
	public class NodeParticles
	{
		public GameObject setParticles;

		public GameObject fireParticles;

		public GameObject LongTailParticles;

		public GameObject Yuri_Particles;

		public GameObject Pyro_Particles;

		public GameObject Lais_Particles;

		public GameObject Remi_Particles;

		public GameObject LiuWen_Particles;

		public GameObject Dre_Particles;

		public GameObject Sonya_Particles;

		public GameObject Core_Particles;
	}

	private enum NodeAudioType
	{
		Bounce,
		Hit,
		Smash,
		Set
	}

	public NodeType type;

	public float beatTime;

	public Vector2 offset;

	public string path;

	public bool set;

	public bool cascade;

	public float holoLight;

	public int holoNum;

	public int danceID;

	public float bufferOverride;

	public int minDifficulty;

	private SplineFollower spline;

	public NodeParticles particles;

	private float spawnBuffer;

	private float secondsPerHalfBeat;

	public GameObject nodeHitPrefab;

	public GameObject setHitPrefab;

	public GameObject cascadeHitPrefab;

	public GameObject spawnInPrefab;

	public GameObject nodeBouncePrefab;

	public GameObject nodeSmashPrefab;

	public GameObject lastNodePrefab;

	private bool doubleNodeFirstHit;

	private bool finished;

	private bool alive;

	private bool hit;

	public bool endOfSet;

	public Node nextNeighbor;

	public Node previousNeighbor;

	public GameObject lightning;

	public GameObject batsuPrefab;

	public bool endOfCascade;

	public Node cascadeOwner;

	public Node cascadeChild;

	public List<Node> cascadeChildren;

	public int cascadeChildrenHits;

	public List<string> lightPayloads;

	public TauntInfo tauntInfo;

	private GameManager gm;

	public MeshRenderer shellMesh;

	public MeshRenderer core;

	public MeshRenderer outerParts;

	public List<MeshRenderer> colourMeshes;

	private bool firstInCascade;

	private bool utilityDone;

	private List<GameObject> activeParticles;

	private float angle;

	private float spinSpeed = 10f;

	private float spinRadius = 0.7f;

	private int readyToEnableVisuals;

	public static bool leftCascadeHaptic;

	public static bool rightCascadeHaptic;

	public bool cascadeCancelled;

	private static float lastCascadeTime;

	public List<AudioClip> hitSounds;

	public List<AudioClip> smashSounds;

	public List<AudioClip> bounceSounds;

	public List<AudioClip> setSounds;

	public bool pitchShift = true;

	public Vector2 minMaxPitchShift;

	public AudioMixerGroup nodeMixer;

	public AudioMixerGroup setMixer;

	private void Awake()
	{
		gm = GameManager.instance;
		spline = GetComponent<SplineFollower>();
	}

	private void Start()
	{
		if (set && cascade)
		{
			UnityEngine.Debug.LogError("A node can't be in a set and a cascade!");
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}

	public bool isUtilityNode()
	{
		if (type != NodeType.GreenCascadeEnd && type != NodeType.PinkCascadeEnd && type != NodeType.TauntStart && type != NodeType.HoloLight && type != NodeType.SetEnd && type != NodeType.LeftChannel && type != NodeType.Midchannel)
		{
			return type == NodeType.RightChannel;
		}
		return true;
	}

	public void Init()
	{
		GetComponent<TrailRenderer>().enabled = false;
		MeshRenderer[] componentsInChildren = GetComponentsInChildren<MeshRenderer>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			componentsInChildren[i].enabled = false;
		}
		if (bufferOverride > 0f)
		{
			spawnBuffer = bufferOverride;
		}
		else
		{
			spawnBuffer = gm.spawnBuffer;
		}
		if (!isUtilityNode() || type == NodeType.HoloLight)
		{
			secondsPerHalfBeat = 1f / (gm.currentSong.BPM / 60f) / 2f;
			SetOffsets();
			SetPath();
			spline.followSpeed = spline.spline.CalculateLength() / spawnBuffer;
			spline.SetPercent(0.0);
			base.transform.position = spline.spline.GetPointPosition(0);
			ActivateParticles();
			SetColours();
			EnableParticles(_enable: false);
			spline.enabled = false;
		}
	}

	public void SetOffsets()
	{
		Vector2 vector = offset;
		vector.x *= gm.difficulty.offsetMod;
		vector.y *= gm.difficulty.offsetMod;
		vector.x *= gm.heightModifier;
		vector.y *= gm.heightModifier;
		vector.y += gm.calibrationOffset.x;
		spline.motion.offset = new Vector2(0f - vector.x, vector.y);
	}

	public void InitSet()
	{
		if (set)
		{
			if (nextNeighbor == null)
			{
				endOfSet = true;
			}
			else if (nextNeighbor.type == NodeType.SetEnd || !nextNeighbor.set)
			{
				endOfSet = true;
			}
		}
		else
		{
			particles.setParticles.SetActive(value: false);
		}
	}

	private void ActivateParticles()
	{
		if (!Persistence.instance.svMan.settingsSave.enableTauntParticles)
		{
			return;
		}
		activeParticles = new List<GameObject>();
		if (type != 0 && type != NodeType.Pink)
		{
			return;
		}
		for (int i = 0; i < tauntInfo.NodeEffects.Count; i++)
		{
			switch (tauntInfo.NodeEffects[i])
			{
			case VisualTreatment.Flame:
				activeParticles.Add(UnityEngine.Object.Instantiate(particles.fireParticles, base.transform.position, Quaternion.identity, base.transform).gameObject);
				break;
			case VisualTreatment.LongTail:
				activeParticles.Add(UnityEngine.Object.Instantiate(particles.LongTailParticles, base.transform.position, Quaternion.identity, base.transform).gameObject);
				break;
			case VisualTreatment.Yuri:
				activeParticles.Add(UnityEngine.Object.Instantiate(particles.Yuri_Particles, base.transform.position, Quaternion.identity, base.transform).gameObject);
				break;
			case VisualTreatment.Pyro:
				activeParticles.Add(UnityEngine.Object.Instantiate(particles.Pyro_Particles, base.transform.position, Quaternion.identity, base.transform).gameObject);
				break;
			case VisualTreatment.Lais:
				activeParticles.Add(UnityEngine.Object.Instantiate(particles.Lais_Particles, base.transform.position, Quaternion.identity, base.transform).gameObject);
				break;
			case VisualTreatment.Remi:
				activeParticles.Add(UnityEngine.Object.Instantiate(particles.Remi_Particles, base.transform.position, Quaternion.identity, base.transform).gameObject);
				break;
			case VisualTreatment.LiuWen:
				activeParticles.Add(UnityEngine.Object.Instantiate(particles.LiuWen_Particles, base.transform.position, Quaternion.identity, base.transform).gameObject);
				break;
			case VisualTreatment.Dre:
				activeParticles.Add(UnityEngine.Object.Instantiate(particles.Dre_Particles, base.transform.position, Quaternion.identity, base.transform).gameObject);
				break;
			case VisualTreatment.Sonya:
				activeParticles.Add(UnityEngine.Object.Instantiate(particles.Sonya_Particles, base.transform.position, Quaternion.identity, base.transform).gameObject);
				break;
			case VisualTreatment.Core:
				activeParticles.Add(UnityEngine.Object.Instantiate(particles.Core_Particles, base.transform.position, Quaternion.identity, base.transform).gameObject);
				break;
			}
		}
	}

	private void EnableParticles(bool _enable)
	{
		if (!Persistence.instance.svMan.settingsSave.enableTauntParticles || activeParticles.Count == 0)
		{
			return;
		}
		for (int i = 0; i < activeParticles.Count; i++)
		{
			ParticleSystem[] componentsInChildren = activeParticles[i].GetComponentsInChildren<ParticleSystem>();
			for (int j = 0; j < componentsInChildren.Length; j++)
			{
				if (_enable)
				{
					componentsInChildren[j].Play();
				}
				else
				{
					componentsInChildren[j].Stop();
				}
			}
		}
	}

	public void InitCascade(Node _cascadeowner)
	{
		cascadeOwner = _cascadeowner;
		cascadeOwner.cascadeChildren.Add(this);
		GetComponent<TrailRenderer>().widthMultiplier *= 0.7f;
		if (cascadeChild != null)
		{
			cascadeChild.InitCascade(_cascadeowner);
		}
		else
		{
			firstInCascade = true;
		}
	}

	public void MakeEndOfCascade()
	{
		endOfCascade = true;
		cascadeChildren = new List<Node>();
	}

	public void SetUpCascadeVisuals()
	{
		CascadeVisuals cascadeVisuals = ((type != 0) ? UnityEngine.Object.Instantiate(gm.objectRefrences.cascadeVisualsPinkPrefab, base.transform).GetComponent<CascadeVisuals>() : UnityEngine.Object.Instantiate(gm.objectRefrences.cascadeVisualsGreenPrefab, base.transform).GetComponent<CascadeVisuals>());
		cascadeVisuals.nodes.Add(this);
		foreach (Node cascadeChild in cascadeChildren)
		{
			cascadeVisuals.nodes.Add(cascadeChild);
		}
		cascadeVisuals.Init();
	}

	private void SetColours()
	{
		Color color = Color.white;
		switch (type)
		{
		case NodeType.Green:
			color = Color.HSVToRGB(Persistence.instance.svMan.settingsSave.right_Colour, 1f, 1f);
			break;
		case NodeType.Pink:
			color = Color.HSVToRGB(Persistence.instance.svMan.settingsSave.left_Colour, 1f, 1f);
			break;
		case NodeType.Yellow:
			color = Color.HSVToRGB(Persistence.instance.svMan.settingsSave.double_colour, 1f, 1f);
			break;
		}
		SetTrailColour(color);
		SetMeshColour(color);
	}

	private void SetTrailColour(Color c)
	{
		Gradient gradient = new Gradient();
		gradient.SetKeys(new GradientColorKey[2]
		{
			new GradientColorKey(c, 0f),
			new GradientColorKey(c, 1f)
		}, new GradientAlphaKey[2]
		{
			new GradientAlphaKey(0.2f, 0f),
			new GradientAlphaKey(0f, 1f)
		});
		GetComponent<TrailRenderer>().colorGradient = gradient;
	}

	private void SetMeshColour(Color c)
	{
		switch (type)
		{
		case NodeType.Green:
		{
			foreach (MeshRenderer colourMesh in colourMeshes)
			{
				colourMesh.material.SetColor("_EmissionColor", Color.HSVToRGB(Persistence.instance.svMan.settingsSave.right_Colour, 1f, 1f));
			}
			break;
		}
		case NodeType.Pink:
		{
			foreach (MeshRenderer colourMesh2 in colourMeshes)
			{
				colourMesh2.material.SetColor("_EmissionColor", Color.HSVToRGB(Persistence.instance.svMan.settingsSave.left_Colour, 1f, 1f));
			}
			break;
		}
		case NodeType.Yellow:
		{
			foreach (MeshRenderer colourMesh3 in colourMeshes)
			{
				colourMesh3.material.SetColor("_EmissionColor", Color.HSVToRGB(Persistence.instance.svMan.settingsSave.double_colour, 1f, 1f));
			}
			break;
		}
		}
	}

	private void Update()
	{
		if (!gm.songPlaying)
		{
			return;
		}
		if (readyToEnableVisuals > 0)
		{
			readyToEnableVisuals++;
			if (readyToEnableVisuals == 5)
			{
				EnableVisuals();
				readyToEnableVisuals = 0;
			}
		}
		if (alive)
		{
			if (gm.songTime >= beatTime && (!isUtilityNode() || type == NodeType.HoloLight))
			{
				base.transform.Translate(base.transform.forward * Time.deltaTime * 10f, Space.World);
				spline.follow = false;
				if (gm.songTime - beatTime > secondsPerHalfBeat / 2f)
				{
					HitMissPoint();
				}
				if (base.transform.position.z <= -30f)
				{
					UnityEngine.Object.Destroy(base.gameObject);
				}
			}
		}
		else if (gm.songTime >= beatTime - spawnBuffer)
		{
			if (!isUtilityNode() || type == NodeType.HoloLight)
			{
				Activate();
			}
			else if (type == NodeType.TauntStart)
			{
				gm.StartTaunt(tauntInfo);
				alive = true;
			}
			else if (type == NodeType.LeftChannel)
			{
				gm.StartLeftChevrons(beatTime);
				alive = true;
			}
			else if (type == NodeType.Midchannel)
			{
				gm.StartMiddleChevrons(beatTime);
				alive = true;
			}
			else if (type == NodeType.RightChannel)
			{
				gm.StartRightChevrons(beatTime);
				alive = true;
			}
		}
		if (finished && !utilityDone && type == NodeType.HoloLight)
		{
			utilityDone = true;
		}
	}

	public void Activate()
	{
		if (!alive)
		{
			spline.enabled = true;
			alive = true;
			spline.SetPercent(Mathf.InverseLerp(beatTime - spawnBuffer, beatTime, gm.songTime));
			spline.follow = true;
			readyToEnableVisuals = 1;
		}
	}

	private void EnableVisuals()
	{
		if (isUtilityNode() || readyToEnableVisuals < 5)
		{
			return;
		}
		if (!cascade)
		{
			MeshRenderer[] componentsInChildren = GetComponentsInChildren<MeshRenderer>();
			foreach (MeshRenderer meshRenderer in componentsInChildren)
			{
				meshRenderer.enabled = true;
				meshRenderer.transform.localScale = meshRenderer.transform.localScale * gm.difficulty.sizeMod;
				if (set)
				{
					meshRenderer.transform.localScale = meshRenderer.transform.localScale * 0.9f;
				}
			}
			if (set)
			{
				particles.setParticles.SetActive(value: true);
				if (endOfSet)
				{
					gm.score.AddSet();
				}
			}
			if (previousNeighbor != null && previousNeighbor.set && !previousNeighbor.endOfSet)
			{
				previousNeighbor.lightning.GetComponentInChildren<ObservePosition>().oculusFollow = previousNeighbor.nextNeighbor.transform;
				previousNeighbor.lightning.SetActive(value: true);
			}
			RotateAroundAxis[] componentsInChildren2 = GetComponentsInChildren<RotateAroundAxis>();
			for (int i = 0; i < componentsInChildren2.Length; i++)
			{
				componentsInChildren2[i].enabled = true;
			}
			GetComponent<TrailRenderer>().enabled = true;
		}
		if (cascade)
		{
			MeshRenderer[] componentsInChildren = GetComponentsInChildren<MeshRenderer>();
			foreach (MeshRenderer meshRenderer2 in componentsInChildren)
			{
				meshRenderer2.enabled = true;
				meshRenderer2.transform.localScale = meshRenderer2.transform.localScale * 1f;
			}
			shellMesh.gameObject.SetActive(value: true);
			outerParts.gameObject.SetActive(value: false);
			RotateAroundAxis[] componentsInChildren2 = GetComponentsInChildren<RotateAroundAxis>();
			for (int i = 0; i < componentsInChildren2.Length; i++)
			{
				componentsInChildren2[i].enabled = true;
			}
			if (!endOfCascade && firstInCascade)
			{
				UnityEngine.Object.Instantiate(gm.objectRefrences.cascadeShellPrefab, base.transform);
				gm.score.AddCascade();
			}
		}
		EnableParticles(_enable: true);
		readyToEnableVisuals = 0;
	}

	private void HitMissPoint()
	{
		if (finished || type == NodeType.MirageGreen || type == NodeType.MiragePink)
		{
			return;
		}
		finished = true;
		if (!hit && !isUtilityNode())
		{
			gm.NodeFinished(type, hit: false, endOfSet, cascade);
			gm.objectRefrences.poolMananager.OnMiss(base.transform.position, base.transform.rotation * Quaternion.Euler(180f, 0f, 0f), cascade);
			_ = gm.doMissEffects;
			if (set)
			{
				CancelSet();
			}
			if (cascade)
			{
				if (cascadeOwner != null)
				{
					cascadeOwner.CancelCascadeSound(type == NodeType.Pink);
				}
				else
				{
					CancelCascadeSound(type == NodeType.Pink);
				}
			}
			if (endOfCascade && endOfCascade)
			{
				float percent = (float)cascadeChildrenHits * 1f / ((float)(cascadeChildren.Count + 1) * 1f);
				gm.CascadeNodeFinished(percent, cascadeChildren.Count + 1);
			}
		}
		if (nextNeighbor == null)
		{
			gm.LastNode();
		}
	}

	public void CancelSet()
	{
		if (set)
		{
			gm.BreakSet();
			particles.setParticles.SetActive(value: false);
			set = false;
			endOfSet = false;
			if (nextNeighbor != null)
			{
				nextNeighbor.CancelSet();
			}
		}
	}

	public void StartCascadeSound(bool left, bool firstInCascade)
	{
		if (left)
		{
			if (!leftCascadeHaptic)
			{
				GameManager.instance.objectRefrences.leftController.GetComponent<HandShield>().StartCascadeSound(cascadeOwner.beatTime - beatTime);
				if (gm.objectRefrences.lightManager != null)
				{
					gm.objectRefrences.lightManager.Trigger(LightShowManager.e_EffectGroup.LeftCascadeStart);
				}
			}
		}
		else if (!rightCascadeHaptic)
		{
			GameManager.instance.objectRefrences.rightController.GetComponent<HandShield>().StartCascadeSound(cascadeOwner.beatTime - beatTime);
			if (gm.objectRefrences.lightManager != null)
			{
				gm.objectRefrences.lightManager.Trigger(LightShowManager.e_EffectGroup.RightCascadeStart);
			}
		}
		if (firstInCascade)
		{
			if (cascadeOwner != null)
			{
				_ = cascadeOwner.cascadeCancelled;
			}
			else
			{
				_ = cascadeCancelled;
			}
		}
	}

	public void CancelCascadeSound(bool left, bool _break = true)
	{
		if (left)
		{
			if (_break)
			{
				GameManager.instance.objectRefrences.leftController.GetComponent<HandShield>().CancelCascadeSound();
				if (gm.objectRefrences.lightManager != null && !cascadeCancelled)
				{
					gm.objectRefrences.lightManager.Trigger(LightShowManager.e_EffectGroup.LeftCascadeBreak);
				}
			}
			else
			{
				GameManager.instance.objectRefrences.leftController.GetComponent<HandShield>().EndCascadeSound();
				if (gm.objectRefrences.lightManager != null && !cascadeCancelled)
				{
					gm.objectRefrences.lightManager.Trigger(LightShowManager.e_EffectGroup.LeftCascadeComplete);
				}
			}
			OVRInput.SetControllerVibration(0f, 0f, OVRInput.Controller.LTouch);
			leftCascadeHaptic = false;
		}
		else
		{
			if (_break)
			{
				GameManager.instance.objectRefrences.rightController.GetComponent<HandShield>().CancelCascadeSound();
				if (gm.objectRefrences.lightManager != null)
				{
					gm.objectRefrences.lightManager.Trigger(LightShowManager.e_EffectGroup.RightCascadeBreak);
				}
			}
			else
			{
				GameManager.instance.objectRefrences.rightController.GetComponent<HandShield>().EndCascadeSound();
				if (gm.objectRefrences.lightManager != null)
				{
					gm.objectRefrences.lightManager.Trigger(LightShowManager.e_EffectGroup.RightCascadeComplete);
				}
			}
			OVRInput.SetControllerVibration(0f, 0f, OVRInput.Controller.RTouch);
			rightCascadeHaptic = false;
		}
		if (cascadeCancelled)
		{
			return;
		}
		cascadeCancelled = true;
		float num = 0.7f;
		foreach (Node cascadeChild in cascadeChildren)
		{
			if (!(cascadeChild.core == null))
			{
				Color color = cascadeChild.core.material.GetColor("_EmissionColor");
				cascadeChild.core.material.SetColor("_EmissionColor", new Vector4(color.r * num, color.g * num, color.b * num, 1f));
				cascadeChild.GetComponent<TrailRenderer>().enabled = false;
			}
		}
		Color color2 = core.material.GetColor("_EmissionColor");
		core.material.SetColor("_EmissionColor", new Vector4(color2.r * num, color2.g * num, color2.b * num, 1f));
		GetComponent<TrailRenderer>().enabled = false;
	}

	private void OnTriggerEnter(Collider col)
	{
		if (type == NodeType.MirageGreen || type == NodeType.MiragePink)
		{
			return;
		}
		if (col.gameObject.tag == "LeftController" && type == NodeType.Pink)
		{
			if (cascade)
			{
				if (cascadeOwner != null)
				{
					cascadeOwner.cascadeChildrenHits++;
				}
				if (endOfCascade)
				{
					float num = (float)(cascadeChildrenHits + 1) * 1f / ((float)(cascadeChildren.Count + 1) * 1f);
					gm.CascadeNodeFinished(num, cascadeChildren.Count + 1);
					if (num == 1f)
					{
						lastCascadeTime = Time.time;
						if (Persistence.instance.svMan.settingsSave.enableParticles)
						{
							gm.objectRefrences.cascadeEndEffectPink.transform.position = base.transform.position;
							gm.objectRefrences.cascadeEndEffectPink.GetComponent<ParticleSystem>().Play();
							gm.objectRefrences.cascadeEndEffectPink.GetComponent<AudioSource>().Play();
						}
						if (!gm.inEditor)
						{
							UnityEngine.Object.FindObjectOfType<UI_SoundManager>().PlayScoreEventEffect();
						}
					}
					CancelCascadeSound(type == NodeType.Pink, _break: false);
				}
				else
				{
					StartCascadeSound(type == NodeType.Pink, firstInCascade);
				}
			}
			else if (GameManager.instance.isTutorial && !set && GameManager.instance.tutMan.throwCards)
			{
				GameManager.instance.tutMan.ThrowScoreCard(col.gameObject.GetComponent<VelocityHolder>().velocity);
			}
			float precision = Vector3.Distance(col.ClosestPoint(base.transform.position), GameManager.instance.objectRefrences.leftPrecisionPoint.position);
			gm.NodeFinished(type, hit: true, endOfSet, cascade, col.gameObject.GetComponent<VelocityHolder>().velocity, precision);
			GameManager.instance.VibrateLeft(0.2f);
			HitEffects(type, col.gameObject.GetComponent<VelocityHolder>().velocity);
			hit = true;
			col.gameObject.GetComponent<HandShield>().PulseEmissive();
		}
		if (col.gameObject.tag == "RightController" && type == NodeType.Green)
		{
			if (cascade)
			{
				if (cascadeOwner != null)
				{
					cascadeOwner.cascadeChildrenHits++;
				}
				if (endOfCascade)
				{
					float num2 = (float)(cascadeChildrenHits + 1) * 1f / ((float)(cascadeChildren.Count + 1) * 1f);
					gm.CascadeNodeFinished(num2, cascadeChildren.Count + 1);
					if (num2 == 1f)
					{
						lastCascadeTime = Time.time;
						if (Persistence.instance.svMan.settingsSave.enableParticles)
						{
							gm.objectRefrences.cascadeEndEffectGreen.transform.position = base.transform.position;
							gm.objectRefrences.cascadeEndEffectGreen.GetComponent<ParticleSystem>().Play();
							gm.objectRefrences.cascadeEndEffectGreen.GetComponent<AudioSource>().Play();
						}
						if (!gm.inEditor)
						{
							UnityEngine.Object.FindObjectOfType<UI_SoundManager>().PlayScoreEventEffect();
						}
					}
					CancelCascadeSound(type == NodeType.Pink, _break: false);
				}
				else
				{
					StartCascadeSound(type == NodeType.Pink, firstInCascade);
				}
			}
			else if (GameManager.instance.isTutorial && !set && GameManager.instance.tutMan.throwCards)
			{
				GameManager.instance.tutMan.ThrowScoreCard(col.gameObject.GetComponent<VelocityHolder>().velocity);
			}
			float precision2 = Vector3.Distance(col.ClosestPoint(base.transform.position), GameManager.instance.objectRefrences.rightPrecisionPoint.position);
			gm.NodeFinished(type, hit: true, endOfSet, cascade, col.gameObject.GetComponent<VelocityHolder>().velocity, precision2);
			GameManager.instance.VibrateRight(0.2f);
			HitEffects(type, col.gameObject.GetComponent<VelocityHolder>().velocity);
			hit = true;
			col.gameObject.GetComponent<HandShield>().PulseEmissive();
		}
		if ((!(col.gameObject.tag == "LeftController") && !(col.gameObject.tag == "RightController")) || type != NodeType.Yellow)
		{
			return;
		}
		if (!doubleNodeFirstHit)
		{
			doubleNodeFirstHit = true;
			return;
		}
		gm.NodeFinished(type, hit: true, endOfSet, cascade, col.gameObject.GetComponent<VelocityHolder>().velocity, GameManager.instance.minPrecision);
		GameManager.instance.VibrateLeft(0.5f);
		GameManager.instance.VibrateRight(0.5f);
		HitEffects(type);
		if (Persistence.instance.svMan.settingsSave.enableUI)
		{
			gm.ThrowMultiEvent(base.transform.position, gm.score.multiplier.ToString());
		}
		if (gm.objectRefrences.lightManager != null)
		{
			gm.objectRefrences.lightManager.Trigger(LightShowManager.e_EffectGroup.Double);
		}
		if (!gm.inEditor)
		{
			UnityEngine.Object.FindObjectOfType<UI_SoundManager>().PlayScoreEventEffect();
		}
		GameObject.FindWithTag("LeftController").GetComponent<HandShield>().PulseEmissive();
		GameObject.FindWithTag("RightController").GetComponent<HandShield>().PulseEmissive();
		hit = true;
		if (GameManager.instance.isTutorial && GameManager.instance.tutMan.throwCards)
		{
			GameManager.instance.tutMan.ThrowScoreCard(col.gameObject.GetComponent<VelocityHolder>().velocity);
		}
	}

	private void HitEffects(NodeType type, float velocity = 1f)
	{
		if (cascade)
		{
			if (Persistence.instance.svMan.settingsSave.enableParticles)
			{
				GameManager.instance.objectRefrences.poolMananager.OnCascadeHit(type, base.transform.position, base.transform.rotation * Quaternion.Euler(90f, 0f, 0f));
			}
		}
		else
		{
			if (set)
			{
				if (gm.currentSetCounter == null)
				{
					int num = 0;
					Node node = this;
					while (node.set)
					{
						node = node.nextNeighbor;
						num++;
					}
					gm.SpawnSetCounter(num);
				}
				particles.setParticles.SetActive(value: false);
				gm.HitSet();
				PlayAudio(NodeAudioType.Set);
				if (endOfSet)
				{
					if (Persistence.instance.svMan.settingsSave.enableParticles)
					{
						UnityEngine.Object.Instantiate(gm.objectRefrences.setEndEffect, base.transform.position, base.transform.rotation * Quaternion.Euler(90f, 0f, 0f));
					}
					if (gm.objectRefrences.lightManager != null)
					{
						gm.objectRefrences.lightManager.Trigger(LightShowManager.e_EffectGroup.SetComplete);
					}
				}
				else if (gm.objectRefrences.lightManager != null)
				{
					gm.objectRefrences.lightManager.Trigger(LightShowManager.e_EffectGroup.SetHit);
				}
			}
			if (type == NodeType.Yellow)
			{
				gm.SpawnShockwave();
				if (Persistence.instance.svMan.settingsSave.enableParticles)
				{
					UnityEngine.Object.Instantiate(nodeHitPrefab, base.transform.position, base.transform.rotation * Quaternion.Euler(90f, 0f, 0f));
				}
			}
			else
			{
				float num2 = Mathf.InverseLerp(GameManager.instance.minVelocity, GameManager.instance.maxVelocity, velocity);
				if (num2 > 0f)
				{
					if (num2 == 1f)
					{
						if (Persistence.instance.svMan.settingsSave.enableParticles)
						{
							UnityEngine.Object.Instantiate(nodeHitPrefab, base.transform.position, base.transform.rotation * Quaternion.Euler(90f, 0f, 0f));
						}
						if (!set)
						{
							PlayAudio(NodeAudioType.Smash);
						}
					}
					else
					{
						if (Persistence.instance.svMan.settingsSave.enableParticles)
						{
							UnityEngine.Object.Instantiate(nodeHitPrefab, base.transform.position, base.transform.rotation * Quaternion.Euler(90f, 0f, 0f));
						}
						if (!set)
						{
							PlayAudio(NodeAudioType.Hit);
						}
					}
				}
				else
				{
					if (Persistence.instance.svMan.settingsSave.enableParticles)
					{
						UnityEngine.Object.Instantiate(nodeBouncePrefab, base.transform.position, base.transform.rotation * Quaternion.Euler(90f, 0f, 0f));
					}
					if (!set)
					{
						PlayAudio(NodeAudioType.Bounce);
					}
				}
			}
		}
		MeshRenderer[] componentsInChildren = GetComponentsInChildren<MeshRenderer>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			componentsInChildren[i].enabled = false;
		}
		GetComponent<TrailRenderer>().enabled = false;
		if (!gm.isTutorial && nextNeighbor == null)
		{
			if (Persistence.instance.svMan.settingsSave.enableParticles)
			{
				UnityEngine.Object.Instantiate(lastNodePrefab, base.transform.position, base.transform.rotation * Quaternion.Euler(90f, 0f, 0f));
			}
			gm.SpawnShockwave();
		}
	}

	private void PlayAudio(NodeAudioType audioType)
	{
		if (Persistence.instance.svMan.settingsSave.enableNodeSounds)
		{
			AudioSource component = GetComponent<AudioSource>();
			switch (audioType)
			{
			case NodeAudioType.Bounce:
				component.outputAudioMixerGroup = nodeMixer;
				component.clip = bounceSounds[UnityEngine.Random.Range(0, bounceSounds.Count)];
				break;
			case NodeAudioType.Hit:
				component.outputAudioMixerGroup = nodeMixer;
				component.clip = hitSounds[UnityEngine.Random.Range(0, hitSounds.Count)];
				break;
			case NodeAudioType.Smash:
				component.outputAudioMixerGroup = nodeMixer;
				component.clip = smashSounds[UnityEngine.Random.Range(0, smashSounds.Count)];
				break;
			case NodeAudioType.Set:
				component.outputAudioMixerGroup = setMixer;
				component.clip = setSounds[UnityEngine.Random.Range(0, setSounds.Count)];
				break;
			}
			if (pitchShift)
			{
				component.pitch = UnityEngine.Random.Range(minMaxPitchShift.x, minMaxPitchShift.y);
			}
			component.Play();
		}
	}

	private void OnTriggerExit(Collider col)
	{
		if ((col.gameObject.tag == "LeftController" || col.gameObject.tag == "RightController") && type == NodeType.Yellow)
		{
			doubleNodeFirstHit = false;
		}
	}

	private void SetPath()
	{
		if (path == "Default")
		{
			if (cascade)
			{
				spline.spline = gm.GetSpline("StraightLine");
			}
			else
			{
				spline.spline = ((offset.x < 0f) ? gm.objectRefrences.curveLeft.GetComponent<SplineComputer>() : gm.objectRefrences.curveRight.GetComponent<SplineComputer>());
			}
			return;
		}
		spline.spline = gm.GetSpline(path);
		if (spline.spline == null)
		{
			spline.spline = ((offset.x < 0f) ? gm.objectRefrences.curveLeft.GetComponent<SplineComputer>() : gm.objectRefrences.curveRight.GetComponent<SplineComputer>());
		}
	}
}
public enum DamageAnimationType
{
	anim1,
	anim2,
	anim3
}
[Serializable]
public class TauntInfo
{
	public bool isTaunt;

	public float tauntDuration;

	public List<VisualTreatment> NodeEffects;

	public DamageAnimationType damageAnimation;

	public TauntInfo()
	{
		NodeEffects = new List<VisualTreatment>();
	}

	public TauntInfo(SerTauntInfo _serInfo)
	{
		isTaunt = _serInfo.isTaunt;
		tauntDuration = _serInfo.tauntDuration;
		NodeEffects = _serInfo.visualEffects;
	}
}
[Serializable]
public class SerTauntInfo
{
	public bool isTaunt;

	public float tauntDuration;

	public List<VisualTreatment> visualEffects;

	public DamageAnimationType damageAnimation;

	public SerTauntInfo()
	{
		visualEffects = new List<VisualTreatment>();
	}

	public SerTauntInfo(TauntInfo _ti)
	{
		isTaunt = _ti.isTaunt;
		tauntDuration = _ti.tauntDuration;
		visualEffects = _ti.NodeEffects;
	}
}
public class PoolManager : MonoBehaviour
{
	private class Batsu
	{
		public Transform tForm;

		public Animator anim;

		public AudioSource aSource;

		public RandomPitch pitch;
	}

	public int poolSize = 20;

	public float cascadeMissCooldown = 0.5f;

	public Vector3 missOffset = new Vector3(0f, 0f, 5f);

	public GameObject pinkCascadeHit;

	public GameObject greenCascadehit;

	public GameObject missPrefab;

	private List<ParticleSystem> pinkHits = new List<ParticleSystem>();

	private List<ParticleSystem> greenHits = new List<ParticleSystem>();

	private List<Batsu> batsus = new List<Batsu>();

	private float cascadeMissTimer;

	private void Start()
	{
		for (int i = 0; i < poolSize; i++)
		{
			GameObject gameObject = UnityEngine.Object.Instantiate(pinkCascadeHit, new Vector3(0f, -100f, 0f), Quaternion.identity);
			pinkHits.Add(gameObject.GetComponent<ParticleSystem>());
			gameObject = UnityEngine.Object.Instantiate(greenCascadehit, new Vector3(0f, -100f, 0f), Quaternion.identity);
			greenHits.Add(gameObject.GetComponent<ParticleSystem>());
			gameObject = UnityEngine.Object.Instantiate(missPrefab, new Vector3(0f, -100f, 0f), Quaternion.identity);
			Batsu batsu = new Batsu();
			batsu.tForm = gameObject.transform;
			batsu.anim = gameObject.GetComponent<Animator>();
			batsu.aSource = gameObject.GetComponent<AudioSource>();
			batsu.pitch = gameObject.GetComponent<RandomPitch>();
			batsus.Add(batsu);
		}
	}

	private void Update()
	{
		if (cascadeMissTimer >= 0f)
		{
			cascadeMissTimer -= Time.deltaTime;
		}
	}

	public void OnMiss(Vector3 _pos, Quaternion _rot, bool _isCascade = false)
	{
		if (!_isCascade || cascadeMissTimer < 0f)
		{
			Batsu batsu = batsus[0];
			batsu.tForm.position = _pos + missOffset;
			batsu.tForm.rotation = _rot;
			batsu.anim.SetTrigger("Reset");
			batsu.pitch.RandomisePitch(batsu.aSource);
			batsu.aSource.Play();
			batsus.Add(batsu);
			batsus.RemoveAt(0);
			if (_isCascade)
			{
				cascadeMissTimer = cascadeMissCooldown;
			}
		}
	}

	public void OnCascadeHit(NodeType _type, Vector3 _pos, Quaternion _rot)
	{
		ParticleSystem particleSystem = ((_type != NodeType.Pink) ? greenHits[0] : pinkHits[0]);
		particleSystem.transform.position = _pos;
		particleSystem.transform.rotation = _rot;
		particleSystem.Play();
		if (_type == NodeType.Pink)
		{
			pinkHits.Add(particleSystem);
			pinkHits.RemoveAt(0);
		}
		else
		{
			greenHits.Add(particleSystem);
			greenHits.RemoveAt(0);
		}
	}
}
[Serializable]
public class Song
{
	public List<SongNode> nodes;

	public string _music = "#0";

	public string _arena = "Arena #8 (Generic)";

	public string _lightshow = "Arena #1 (Yuri)";

	public float BPM;

	public float firstBeatBuffer;

	public string title1 = "Title1";

	public string title2 = "Title2";

	public string title3 = "Title3";

	public int maxScore;

	public List<CascadeContainer> cascades = new List<CascadeContainer>();

	public string nodeDebug = "No Error";

	public string InitSong(float time = 0f, bool incremental = true)
	{
		UnityEngine.Debug.Log("Init song");
		SortNodes();
		try
		{
			SpawnNodes(time, incremental);
			UnityEngine.Debug.Log("Song loaded successfully!");
			return "";
		}
		catch
		{
			UnityEngine.Debug.LogError("Song failed to load! | " + nodeDebug);
			return nodeDebug;
		}
	}

	public void SortNodes()
	{
		nodes.Sort((SongNode n1, SongNode n2) => n1.beatTime.CompareTo(n2.beatTime));
	}

	public void SpawnNodes(float time = 0f, bool incremental = true)
	{
		UnityEngine.Debug.Log("Spawning nodes at time " + time);
		Node node = null;
		Node node2 = null;
		Node node3 = null;
		Node node4 = null;
		int num = 0;
		if (incremental)
		{
			GameManager.instance.StartIncrementalSpawn(nodes, time);
			return;
		}
		foreach (SongNode node5 in nodes)
		{
			if (Persistence.instance.currentDifficulty < node5.minDifficulty || node5.beatTime < time)
			{
				continue;
			}
			float num2 = 60f / BPM * (float)Persistence.instance.GetDifficuty().delay;
			if (node5.beatTime < num2)
			{
				UnityEngine.Debug.Log("Early node! " + time.ToString("F2"));
				continue;
			}
			nodeDebug = "Node " + num + " at " + node5.beatTime + ": " + node5.type;
			node4 = node5.type switch
			{
				NodeType.Green => UnityEngine.Object.Instantiate(GameManager.instance.objectRefrences.greenNodePrefab, new Vector3(0f, 0f, num++), Quaternion.identity).GetComponent<Node>(), 
				NodeType.MirageGreen => UnityEngine.Object.Instantiate(GameManager.instance.objectRefrences.greenMiragePrefab, new Vector3(0f, 0f, num++), Quaternion.identity).GetComponent<Node>(), 
				NodeType.Pink => UnityEngine.Object.Instantiate(GameManager.instance.objectRefrences.pinkNodePrefab, new Vector3(0f, 0f, num++), Quaternion.identity).GetComponent<Node>(), 
				NodeType.MiragePink => UnityEngine.Object.Instantiate(GameManager.instance.objectRefrences.pinkMiragePrefab, new Vector3(0f, 0f, num++), Quaternion.identity).GetComponent<Node>(), 
				NodeType.Yellow => UnityEngine.Object.Instantiate(GameManager.instance.objectRefrences.yellowNodePrefab).GetComponent<Node>(), 
				_ => UnityEngine.Object.Instantiate(GameManager.instance.objectRefrences.pinkNodePrefab, new Vector3(0f, 0f, num++), Quaternion.identity).GetComponent<Node>(), 
			};
			node4.transform.parent = GameManager.instance.transform.parent;
			node4.beatTime = node5.beatTime;
			node4.offset = new Vector2(node5.offsetX, node5.offsetY);
			node4.type = node5.type;
			node4.path = node5.path;
			node4.set = node5.set;
			node4.cascade = node5.cascade;
			node4.tauntInfo = new TauntInfo(node5.serTauntInfo);
			node4.holoLight = node5.holoLight;
			node4.danceID = node5.danceID;
			node4.holoNum = node5.holoNum;
			node4.bufferOverride = node5.bufferOverride;
			node4.minDifficulty = node5.minDifficulty;
			node4.Init();
			if (node5.cascade)
			{
				if (node5.type == NodeType.Pink)
				{
					if (node3 != null)
					{
						node4.cascadeChild = node3;
					}
					node3 = node4;
				}
				else if (node5.type == NodeType.Green)
				{
					if (node2 != null)
					{
						node4.cascadeChild = node2;
					}
					node2 = node4;
				}
			}
			else if (node5.type == NodeType.Pink)
			{
				if (node3 != null)
				{
					node3.MakeEndOfCascade();
					if (node3.cascadeChild != null)
					{
						node3.cascadeChild.InitCascade(node3);
					}
				}
				node3 = null;
			}
			else if (node5.type == NodeType.Green)
			{
				if (node2 != null)
				{
					node2.MakeEndOfCascade();
					if (node2.cascadeChild != null)
					{
						node2.cascadeChild.InitCascade(node2);
					}
				}
				node2 = null;
			}
			if (node5.type == NodeType.GreenCascadeEnd)
			{
				if (node2 != null)
				{
					node2.MakeEndOfCascade();
					node2.cascadeChild.InitCascade(node2);
				}
				node2 = null;
			}
			if (node5.type == NodeType.PinkCascadeEnd)
			{
				if (node3 != null)
				{
					node3.MakeEndOfCascade();
					node3.cascadeChild.InitCascade(node3);
				}
				node3 = null;
			}
			if (node != null)
			{
				node.nextNeighbor = node4;
				node4.previousNeighbor = node;
				node.InitSet();
			}
			node = node4;
		}
	}

	public void GrabNodeGroups()
	{
		SongNode songNode = null;
		SongNode songNode2 = null;
		SongNode songNode3 = null;
		List<SongNode> list = new List<SongNode>();
		List<SongNode> list2 = new List<SongNode>();
		cascades = new List<CascadeContainer>();
		int num = 0;
		foreach (SongNode node in nodes)
		{
			if (node.cascade)
			{
				if (node.type == NodeType.Pink)
				{
					if (songNode3 != null)
					{
						node.cascadeChild = songNode3;
					}
					songNode3 = node;
					list2.Add(node);
				}
				else if (node.type == NodeType.Green)
				{
					if (songNode2 != null)
					{
						node.cascadeChild = songNode2;
					}
					songNode2 = node;
					list.Add(node);
				}
			}
			else if (node.type == NodeType.Pink)
			{
				if (songNode3 != null)
				{
					songNode3.endOfCascade = true;
					CascadeContainer cascadeContainer = new CascadeContainer();
					cascadeContainer.cascadeNodes = new List<SongNode>(list2);
					cascades.Add(cascadeContainer);
					list2.Clear();
				}
				songNode3 = null;
			}
			else if (node.type == NodeType.Green)
			{
				if (songNode2 != null)
				{
					songNode2.endOfCascade = true;
					CascadeContainer cascadeContainer2 = new CascadeContainer();
					cascadeContainer2.cascadeNodes = new List<SongNode>(list);
					cascades.Add(cascadeContainer2);
					list.Clear();
				}
				songNode2 = null;
			}
			if (node.type == NodeType.GreenCascadeEnd)
			{
				if (songNode2 != null)
				{
					songNode2.endOfCascade = true;
					CascadeContainer cascadeContainer3 = new CascadeContainer();
					cascadeContainer3.cascadeNodes = new List<SongNode>(list);
					cascades.Add(cascadeContainer3);
					list.Clear();
				}
				songNode2 = null;
			}
			if (node.type == NodeType.PinkCascadeEnd)
			{
				if (songNode3 != null)
				{
					songNode3.endOfCascade = true;
					CascadeContainer cascadeContainer4 = new CascadeContainer();
					cascadeContainer4.cascadeNodes = new List<SongNode>(list2);
					cascades.Add(cascadeContainer4);
					list2.Clear();
				}
				songNode3 = null;
			}
			if (songNode != null)
			{
				songNode.nextNeighbor = node;
			}
			songNode = node;
			if (node.type == NodeType.TauntStart)
			{
				List<SongNode> list3 = new List<SongNode>();
				bool flag = false;
				float num2 = node.beatTime + node.serTauntInfo.tauntDuration;
				int num3 = num + 1;
				while (!flag)
				{
					if (nodes[num3].beatTime > num2)
					{
						flag = true;
						break;
					}
					if (nodes[num3].serTauntInfo.isTaunt && !nodes[num3].isUtilityNode())
					{
						list3.Add(nodes[num3]);
					}
					num3++;
				}
			}
			num++;
		}
	}

	private void SpawnNodePool()
	{
	}

	public SongNode GetLastNode()
	{
		return nodes[nodes.Count - 1];
	}
}
[Serializable]
public class SongNode
{
	public float beatTime;

	public float offsetX;

	public float offsetY;

	public NodeType type;

	public string path;

	public bool set;

	public bool cascade;

	public float holoLight;

	public int holoNum;

	public int danceID;

	public float bufferOverride;

	public int minDifficulty;

	[HideInInspector]
	public SongNode cascadeChild;

	[HideInInspector]
	public bool endOfCascade;

	[HideInInspector]
	public SongNode nextNeighbor;

	public SerTauntInfo serTauntInfo;

	public List<string> lightPayloads;

	public SongNode(float _beatTime, float _offsetX, float _offsetY, NodeType _type, string _path = "Default", bool _set = false, bool _cascade = false, float _holoLight = 0f, int _danceID = -1, float _bufferOverride = 0f, int _minDifficulty = 0)
	{
		beatTime = _beatTime;
		offsetX = _offsetX;
		offsetY = _offsetY;
		type = _type;
		path = _path;
		set = _set;
		cascade = _cascade;
		holoLight = _holoLight;
		danceID = _danceID;
		bufferOverride = _bufferOverride;
		minDifficulty = _minDifficulty;
		serTauntInfo = new SerTauntInfo();
	}

	public SongNode(SceneEditorNode _sen)
	{
		beatTime = _sen.beatTime;
		offsetX = _sen.offset.x;
		offsetY = _sen.offset.y;
		type = _sen.type;
		path = _sen.path;
		set = _sen.set;
		cascade = _sen.cascade;
		holoLight = _sen.holoLight;
		holoNum = _sen.holoNum;
		danceID = _sen.danceID;
		bufferOverride = _sen.bufferOverride;
		minDifficulty = _sen.minDifficulty;
		serTauntInfo = new SerTauntInfo(_sen.tauntInfo);
	}

	public bool isUtilityNode()
	{
		if (type != NodeType.GreenCascadeEnd && type != NodeType.PinkCascadeEnd && type != NodeType.TauntStart)
		{
			return type == NodeType.HoloLight;
		}
		return true;
	}
}
[Serializable]
public class TauntContainter
{
	public List<SongNode> tauntNodes = new List<SongNode>();

	public TauntInfo tauntInfo;

	public float nodesHit;

	public TauntContainter()
	{
		tauntNodes = new List<SongNode>();
		tauntInfo = new TauntInfo();
		nodesHit = 0f;
	}

	public SongNode GetLastNode()
	{
		return tauntNodes[tauntNodes.Count - 1];
	}
}
[Serializable]
public class CascadeContainer
{
	public List<SongNode> cascadeNodes = new List<SongNode>();
}
public enum HardwareType
{
	e_none,
	e_Oculus,
	e_Vive
}
public class HardwareID : MonoBehaviour
{
	public HardwareType type;

	private void Awake()
	{
	}
}
public class DirectorDirector : MonoBehaviour
{
	public PlayableAsset Round1Dance;

	public PlayableAsset Round2Dance;

	public PlayableAsset Round3Dance;

	public PlayableAsset Round4Dance;

	public PlayableAsset Round5Dance;

	private PlayableDirector director;

	[Space(10f)]
	public bool debugDance;

	public int debugRound;

	private void Start()
	{
		director = GetComponent<PlayableDirector>();
		if (GameManager.instance == null && debugDance)
		{
			StartDance(debugRound - 1);
		}
	}

	private void Update()
	{
	}

	public void StartDance(int roundNum)
	{
		switch (roundNum)
		{
		case 0:
			director.playableAsset = Round1Dance;
			break;
		case 1:
			director.playableAsset = Round2Dance;
			break;
		case 2:
			director.playableAsset = Round3Dance;
			break;
		case 3:
			director.playableAsset = Round4Dance;
			break;
		case 4:
			director.playableAsset = Round5Dance;
			break;
		default:
			UnityEngine.Debug.LogWarning("Trying to play a timeline that doesn't exist!");
			break;
		}
		director.Play();
	}
}
public class HoloAnimationController : MonoBehaviour
{
	public enum AnimationType
	{
		Taunt,
		Dance,
		Victory,
		Defeat,
		None
	}

	public Animator holo;

	public PlayableDirector director;

	public List<Renderer> renderers;

	[Range(0f, 1f)]
	public float opacity;

	public bool fading;

	public float fadespeed = 1f;

	public float fadeTarget;

	public float fadeValue = 1f;

	public Transform introPosition;

	private Vector3 dancePos;

	public AnimationType nextFadeAnim;

	private void Start()
	{
		if (GameManager.instance != null)
		{
			GameManager.instance.holoCon = this;
		}
		if (director == null)
		{
			director = UnityEngine.Object.FindObjectOfType<PlayableDirector>();
		}
		ForceOpacity(0f);
		holo.gameObject.SetActive(value: false);
		dancePos = holo.transform.position;
		holo.transform.position = introPosition.position;
	}

	private void Update()
	{
		if (fading)
		{
			for (int i = 0; i < renderers.Count; i++)
			{
				Renderer renderer = renderers[i];
				for (int j = 0; j < renderer.materials.Length; j++)
				{
					renderer.materials[j].SetFloat("_Transparency", opacity);
				}
			}
		}
		if (opacity == fadeTarget)
		{
			return;
		}
		if (opacity < fadeTarget)
		{
			opacity += fadespeed * Time.deltaTime;
			if (opacity >= fadeTarget)
			{
				ForceOpacity(fadeTarget);
				FadeFinished();
			}
		}
		else
		{
			opacity -= fadespeed * Time.deltaTime;
			if (opacity <= fadeTarget)
			{
				ForceOpacity(fadeTarget);
				FadeFinished();
			}
		}
	}

	public void ForceOpacity(float value)
	{
		opacity = value;
		for (int i = 0; i < renderers.Count; i++)
		{
			Renderer renderer = renderers[i];
			for (int j = 0; j < renderer.materials.Length; j++)
			{
				renderer.materials[j].SetFloat("_Transparency", value);
			}
		}
		fadeTarget = value;
	}

	public void Fade(float target, AnimationType animation)
	{
		fading = true;
		fadeTarget = target;
		nextFadeAnim = animation;
		UnityEngine.Debug.Log("Starting fade " + ((target == 1f) ? "in" : "out") + " to " + nextFadeAnim);
	}

	private void FadeFinished()
	{
		fading = false;
		if (opacity == 0f)
		{
			holo.transform.position = dancePos;
		}
		switch (nextFadeAnim)
		{
		case AnimationType.Taunt:
			director.Stop();
			holo.SetTrigger("Taunt1");
			if (fadeTarget == 0f)
			{
				Fade(1f, AnimationType.None);
			}
			break;
		case AnimationType.Dance:
			director.time = GameManager.instance.songTime;
			director.Play();
			if (fadeTarget == 0f)
			{
				Fade(1f, AnimationType.None);
			}
			break;
		case AnimationType.Victory:
			director.Stop();
			holo.SetTrigger("OutroWin");
			if (fadeTarget == 0f)
			{
				Fade(1f, AnimationType.None);
			}
			break;
		case AnimationType.Defeat:
			director.Stop();
			holo.SetTrigger("OutroLose");
			if (fadeTarget == 0f)
			{
				Fade(1f, AnimationType.None);
			}
			break;
		case AnimationType.None:
			break;
		}
	}

	public void EndHolo()
	{
		Fade(0f, AnimationType.None);
	}

	public void ShowHolo()
	{
		UnityEngine.Debug.Log("ShowHolo");
		holo.gameObject.SetActive(value: true);
		Fade(fadeValue, AnimationType.None);
	}

	public void Taunt()
	{
		Fade(0f, AnimationType.Taunt);
	}

	public void ReturnToDance()
	{
		Fade(0f, AnimationType.Dance);
	}

	public void Victory()
	{
		Fade(0f, AnimationType.Victory);
	}

	public void Defeat()
	{
		Fade(0f, AnimationType.Defeat);
	}
}
public class HoloAnimationEnd : StateMachineBehaviour
{
	[Range(0f, 1f)]
	public float fadePoint;

	private bool canFade = true;

	public bool startSong;

	[Range(0f, 1f)]
	public float startTime;

	public bool showScore;

	[Range(0f, 1f)]
	public float scoreTime;

	public bool showDance;

	public override void OnStateUpdate(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		if ((double)stateInfo.normalizedTime <= 0.1)
		{
			canFade = true;
		}
		if (canFade && stateInfo.normalizedTime >= fadePoint)
		{
			AnimationMiddleMan component = animator.gameObject.GetComponent<AnimationMiddleMan>();
			if (showDance)
			{
				component.animCon.ReturnToDance();
			}
			canFade = false;
		}
		if (startSong && stateInfo.normalizedTime >= startTime)
		{
			GameManager.instance.StartSong();
			startSong = false;
		}
		if (showScore && stateInfo.normalizedTime >= scoreTime)
		{
			GameManager.instance.ShowResults();
			showScore = false;
		}
	}
}
public class HoloDamageController : MonoBehaviour
{
	public float totalDamage;

	public float currentDamage;

	[Range(0f, 1f)]
	public float damagePercent;

	public float dissolveBase;

	public AnimationCurve dissolveCurve;

	public float meshDeformBase;

	public AnimationCurve meshDeformCurve;

	public float shakeTimeBase;

	public AnimationCurve shakeTimeCurve;

	public float shakeSpeedBase;

	public AnimationCurve shakeSpeedCurve;

	public float shakeBendBase;

	public AnimationCurve shakeBendCurve;

	public float fresnelBase;

	public AnimationCurve fresnelCurve;

	public float damageTime;

	public AnimationCurve damageCurve;

	public float dissolveMax;

	public float meshDeformMax;

	public float shakeTimeMax;

	public float shakeSpeedMax;

	public float shakeBendMax;

	public float fresnelMax;

	private Material mat;

	private bool damaging;

	private float timer;

	[HideInInspector]
	public bool dead;

	private void Start()
	{
		mat = GetComponent<SkinnedMeshRenderer>().material;
	}

	private void Update()
	{
		damagePercent = currentDamage / totalDamage;
		if (!damaging)
		{
			UpdateHolo();
		}
		else
		{
			UpdateDamage();
		}
		if (Input.GetKeyDown(KeyCode.M))
		{
			TakeDamage(10f);
		}
	}

	private void UpdateHolo()
	{
		UpdateValue(dissolveBase, dissolveCurve, "_Dis");
		UpdateValue(meshDeformBase, meshDeformCurve, "_ShakeDisplacement");
		UpdateValue(shakeTimeBase, shakeTimeCurve, "_ShakeTime");
		UpdateValue(shakeSpeedBase, shakeSpeedCurve, "_Shakespeed");
		UpdateValue(shakeBendBase, shakeBendCurve, "_ShakeBending");
		UpdateValue(fresnelBase, fresnelCurve, "_RimPower");
	}

	private float UpdateValue(float _base, AnimationCurve _curve, string _shaderVar)
	{
		float num = _curve.Evaluate(damagePercent);
		mat.SetFloat(_shaderVar, num * _base);
		return num * _base;
	}

	private void UpdateDamage()
	{
		timer += Time.deltaTime;
		float num = timer / damageTime;
		if (num >= 1f)
		{
			damaging = false;
			return;
		}
		float num2 = damageCurve.Evaluate(num);
		float num3 = UpdateValue(dissolveBase, dissolveCurve, "_Dis");
		float num4 = UpdateValue(meshDeformBase, meshDeformCurve, "_ShakeDisplacement");
		float num5 = UpdateValue(shakeTimeBase, shakeTimeCurve, "_ShakeTime");
		float num6 = UpdateValue(shakeSpeedBase, shakeSpeedCurve, "_Shakespeed");
		float num7 = UpdateValue(shakeBendBase, shakeBendCurve, "_ShakeBending");
		float num8 = UpdateValue(fresnelBase, fresnelCurve, "_RimPower");
		SetValue("_Dis", dissolveMax * num2 + num3);
		SetValue("_ShakeDisplacement", meshDeformMax * num2 + num4);
		SetValue("_ShakeTime", shakeTimeMax * num2 + num5);
		SetValue("_Shakespeed", shakeSpeedMax * num2 + num6);
		SetValue("_ShakeBending", shakeBendMax * num2 + num7);
		SetValue("_RimPower", fresnelMax * (0f - num2) + num8);
	}

	private void SetValue(string _shaderVar, float _val)
	{
		mat.SetFloat(_shaderVar, _val);
	}

	public void TakeDamage(float _damage)
	{
		timer = 0f;
		damaging = true;
		if (currentDamage >= totalDamage)
		{
			dead = true;
		}
	}
}
public class LobbyVOManager : MonoBehaviour
{
	public UI_Character_select charMan;

	public List<VoiceOverManager> VOMen = new List<VoiceOverManager>();

	public void SelectPressed()
	{
		VOMen[charMan.selectedCharacter].PlayVoiceLine(VOType.e_lobby);
	}
}
[Serializable]
public class LookTarget
{
	public Transform target;

	public float weight = 10f;

	public LookTarget()
	{
		target = null;
		weight = 10f;
	}
}
public class LookAtManager : MonoBehaviour
{
	[Tooltip("Populated by getting components from all its children")]
	public List<PerfectLookAt> lookAt = new List<PerfectLookAt>();

	private List<AnimationMiddleMan> midMen = new List<AnimationMiddleMan>();

	public float playerTargetWeight;

	private LookTarget playerTarget = new LookTarget();

	public float noTargetWeight;

	public List<LookTarget> lookTargets;

	private LookTarget noTarget = new LookTarget();

	public float minLookTime = 1f;

	public float maxLookTime = 1f;

	private float currentLookTime;

	private float weightTotal;

	public void UpdateWeightTotal()
	{
		weightTotal = playerTarget.weight;
		weightTotal += noTarget.weight;
		for (int i = 0; i < lookTargets.Count; i++)
		{
			weightTotal += lookTargets[i].weight;
		}
	}

	private bool CheckMaxTime(float _maxTime)
	{
		return _maxTime >= minLookTime;
	}

	private void Start()
	{
		PerfectLookAt[] componentsInChildren = GetComponentsInChildren<PerfectLookAt>(includeInactive: true);
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			lookAt.Add(componentsInChildren[i]);
			midMen.Add(lookAt[i].GetComponent<AnimationMiddleMan>());
			midMen[i].laManager = this;
		}
		PlayerTargetSetter playerTargetSetter = UnityEngine.Object.FindObjectOfType<PlayerTargetSetter>();
		playerTarget.target = playerTargetSetter.vivePlayerTarget;
		if (playerTargetSetter.ocuPlayerTarget.gameObject.activeInHierarchy)
		{
			playerTarget.target = playerTargetSetter.ocuPlayerTarget;
		}
		playerTarget.weight = playerTargetWeight;
		noTarget.weight = noTargetWeight;
		UpdateWeightTotal();
		PickRandomTarget();
	}

	private void Update()
	{
		if (currentLookTime > 0f)
		{
			currentLookTime -= Time.deltaTime;
			if (currentLookTime <= 0f)
			{
				PickRandomTarget();
			}
		}
		if (Input.GetKeyDown(KeyCode.L))
		{
			PickRandomTarget();
		}
	}

	private void PickRandomTarget()
	{
		float num = UnityEngine.Random.Range(0f, weightTotal);
		float weight = playerTarget.weight;
		if (num <= weight && playerTarget.weight > 0f && playerTarget.target != null)
		{
			SetTarget(playerTarget.target);
			return;
		}
		weight += noTarget.weight;
		if (num <= weight && noTarget.weight > 0f)
		{
			DisableLookAt();
			return;
		}
		for (int i = 0; i < lookTargets.Count; i++)
		{
			weight += lookTargets[i].weight;
			if (num <= weight && lookTargets[i].weight > 0f)
			{
				SetTarget(lookTargets[i].target);
				return;
			}
		}
		UnityEngine.Debug.LogError("Pick Rand Target has rolled a number (" + num + ") lower than 0, or greater than the total weight (" + weightTotal + ").");
	}

	private void SetTarget(Transform _tForm, float _duration = 0f)
	{
		for (int i = 0; i < lookAt.Count; i++)
		{
			if (_tForm.gameObject != null)
			{
				lookAt[i].m_TargetObject = _tForm.gameObject;
			}
		}
		SetLookTime(_duration);
	}

	public void ForceTargetPlayer(float _duration = 0f)
	{
		SetTarget(playerTarget.target, _duration);
	}

	public void ForceNoTarget(float _duration = 0f)
	{
		DisableLookAt(_duration);
	}

	public void ForceGenericTarget(int _targetNum, float _duration = 0f)
	{
		if (_targetNum >= 0 && _targetNum < lookTargets.Count)
		{
			SetTarget(lookTargets[_targetNum].target, _duration);
		}
		else
		{
			UnityEngine.Debug.LogError("LookAt Manager attempted to set a target that doesn't exist. Number: " + _targetNum, this);
		}
	}

	private void DisableLookAt(float _duration = 0f)
	{
		for (int i = 0; i < lookAt.Count; i++)
		{
			if (midMen[i].blankLookTarget != null)
			{
				lookAt[i].m_TargetObject = midMen[i].blankLookTarget.gameObject;
			}
		}
		SetLookTime(_duration);
	}

	private void SetLookTime(float _duration = 0f)
	{
		currentLookTime = _duration;
		if (_duration <= 0f)
		{
			currentLookTime = UnityEngine.Random.Range(minLookTime, maxLookTime);
		}
	}
}
public class PlayerTargetSetter : MonoBehaviour
{
	public Transform vivePlayerTarget;

	public Transform ocuPlayerTarget;
}
public class VoiceOverAnimTrigger : StateMachineBehaviour
{
	public VOType voType;

	[Range(0f, 1f)]
	public float triggerTime;

	private bool played;

	public int forceLookAt = -2;

	public float lookDuration = 25f;

	private bool CheckLookTarget()
	{
		return forceLookAt > -3;
	}

	public override void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		animator.gameObject.GetComponent<AnimationMiddleMan>().SetLookAt(forceLookAt, lookDuration);
	}

	public override void OnStateUpdate(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		if (stateInfo.normalizedTime > triggerTime && !played)
		{
			animator.gameObject.GetComponent<AnimationMiddleMan>().PlayVoiceLine(voType);
			played = true;
		}
	}
}
[Serializable]
public class RoundVOs
{
	public List<LipSyncData> introVOs;

	public List<LipSyncData> winVOs;

	public List<LipSyncData> loseVOs;

	public List<LipSyncData> tauntVOs;

	public RoundVOs()
	{
		introVOs = new List<LipSyncData>();
		winVOs = new List<LipSyncData>();
		loseVOs = new List<LipSyncData>();
		tauntVOs = new List<LipSyncData>();
	}

	public void LoadLipsyncAudio()
	{
		LoadAudio(introVOs);
		LoadAudio(winVOs);
		LoadAudio(loseVOs);
		LoadAudio(tauntVOs);
	}

	private void LoadAudio(List<LipSyncData> _audio)
	{
		for (int i = 0; i < _audio.Count; i++)
		{
			_audio[i].clip.LoadAudioData();
		}
	}
}
public enum VOType
{
	e_intro,
	e_win,
	e_lose,
	e_taunt,
	e_compliment,
	e_insult,
	e_lobby
}
public class VoiceOverManager : MonoBehaviour
{
	public List<LipSync> lipSyncs;

	public LipSync introLipSync;

	[HideInInspector]
	public RoundVOs currentVOs = new RoundVOs();

	public RoundVOs round1VOs = new RoundVOs();

	[HideInInspector]
	public RoundVOs savedVOs = new RoundVOs();

	public int debugVOs = 1;

	public List<LipSyncData> complimentVOs = new List<LipSyncData>();

	public List<LipSyncData> insultVOs = new List<LipSyncData>();

	[HideInInspector]
	public List<LipSyncData> savedCompliments = new List<LipSyncData>();

	[HideInInspector]
	public List<LipSyncData> savedInsults = new List<LipSyncData>();

	public float voMinCooldown;

	public float voMaxCooldown;

	private float voTimer;

	public float introDelay;

	private float introTimer = -1f;

	public float outroDelay;

	public float lookAtPlayerTime = 5f;

	private float outroTimer;

	private VOType waitingForEnd = VOType.e_insult;

	private float endTimer;

	[Space(10f)]
	public List<LipSyncData> lobbyVOs = new List<LipSyncData>();

	[Header("Intro Music")]
	public AudioSource musicAS;

	public AudioClip musicAC;

	public AudioSource beepAS;

	public AudioClip beepAC;

	private bool fadeMusic;

	private bool introFaded;

	private bool loaded;

	[Space(10f)]
	public List<LipSyncData> manualVOs;

	[Space(10f)]
	public VOType debugType;

	private HoloAnimationController animCon;

	private LookAtManager loMan;

	[HideInInspector]
	private int curInsult;

	[HideInInspector]
	private int curCompliment;

	public void TestVoiceLine()
	{
		PlayVoiceLine(debugType);
	}

	private void Awake()
	{
		_ = debugVOs;
		if (GameManager.instance != null)
		{
			GameManager.instance.GetStageNum(GameManager.instance.musicNum);
			GameManager.instance.voMan = this;
			loMan = UnityEngine.Object.FindObjectOfType<LookAtManager>();
		}
		if (UnityEngine.Object.FindObjectOfType<HoloAnimationController>() != null)
		{
			animCon = UnityEngine.Object.FindObjectOfType<HoloAnimationController>();
		}
		currentVOs = round1VOs;
		if (!loaded)
		{
			LoadAll();
		}
		if (musicAC != null)
		{
			musicAC.LoadAudioData();
		}
		if (beepAC != null)
		{
			beepAC.LoadAudioData();
		}
		complimentVOs = ShuffleList(complimentVOs);
		insultVOs = ShuffleList(insultVOs);
	}

	public void LoadAll()
	{
		currentVOs.LoadLipsyncAudio();
		LoadAudio(complimentVOs);
		LoadAudio(insultVOs);
		LoadAudio(lobbyVOs);
		loaded = true;
	}

	private void LoadAudio(List<LipSyncData> _audio)
	{
		for (int i = 0; i < _audio.Count; i++)
		{
			_audio[i].clip.LoadAudioData();
		}
	}

	private List<LipSyncData> ShuffleList<LipSyncData>(List<LipSyncData> _toShuffle, LipSyncData _last = default(LipSyncData))
	{
		List<LipSyncData> list = new List<LipSyncData>();
		int count = _toShuffle.Count;
		for (int i = 0; i < count; i++)
		{
			int num = UnityEngine.Random.Range(0, _toShuffle.Count);
			if (i == 0 && _toShuffle.Count > 1 && _toShuffle[num].Equals(_last))
			{
				num = ((num <= 0) ? (num + 1) : (num - 1));
			}
			list.Add(_toShuffle[num]);
			_toShuffle.RemoveAt(num);
		}
		_toShuffle = new List<LipSyncData>(list);
		return _toShuffle;
	}

	private void Update()
	{
		if (voTimer > 0f)
		{
			voTimer -= Time.deltaTime;
		}
		if (introTimer > 0f)
		{
			introTimer -= Time.deltaTime;
			if (!introFaded && introTimer < 1f)
			{
				introFaded = true;
			}
			if (introTimer <= 0f)
			{
				StartGame();
			}
		}
		if (outroTimer > 0f)
		{
			outroTimer -= Time.deltaTime;
			if (outroTimer <= 0f)
			{
				animCon.EndHolo();
			}
		}
		if (fadeMusic)
		{
			musicAS.volume = Mathf.Lerp(musicAS.volume, 0f, 0.01f);
		}
		if (endTimer > 0f)
		{
			endTimer -= Time.deltaTime;
			if (endTimer <= 0f)
			{
				CheckEnd();
			}
		}
	}

	private void CheckEnd()
	{
		switch (waitingForEnd)
		{
		case VOType.e_intro:
			introTimer = introDelay;
			PlaySound(beepAC, beepAS);
			GameManager.instance.StartCountdown();
			GameManager.instance.holoCon.Fade(0f, HoloAnimationController.AnimationType.None);
			fadeMusic = true;
			waitingForEnd = VOType.e_insult;
			break;
		case VOType.e_win:
			outroTimer = outroDelay;
			GameManager.instance.ShowResults();
			waitingForEnd = VOType.e_insult;
			GameManager.instance.holoCon.Fade(0f, HoloAnimationController.AnimationType.None);
			break;
		case VOType.e_lose:
			outroTimer = outroDelay;
			waitingForEnd = VOType.e_insult;
			GameManager.instance.holoCon.Fade(0f, HoloAnimationController.AnimationType.None);
			break;
		}
	}

	public void PlayVoiceLine(VOType _type)
	{
		switch (_type)
		{
		case VOType.e_intro:
			if (!Persistence.instance.svMan.settingsSave.skipIntros)
			{
				PlayLipsync(currentVOs.introVOs, _type);
				waitingForEnd = _type;
			}
			break;
		case VOType.e_win:
			PlayLipsync(currentVOs.winVOs, _type);
			waitingForEnd = _type;
			break;
		case VOType.e_lose:
			PlayLipsync(currentVOs.loseVOs, _type);
			waitingForEnd = _type;
			break;
		case VOType.e_taunt:
			PlayLipsync(currentVOs.tauntVOs);
			break;
		case VOType.e_compliment:
			if (Persistence.instance.builtInSong && voTimer <= 0f)
			{
				PlayLipsync(complimentVOs, VOType.e_compliment);
				loMan.ForceTargetPlayer(lookAtPlayerTime);
			}
			break;
		case VOType.e_insult:
			if (Persistence.instance.builtInSong && voTimer <= 0f)
			{
				PlayLipsync(insultVOs, VOType.e_insult);
				loMan.ForceTargetPlayer(lookAtPlayerTime);
			}
			break;
		case VOType.e_lobby:
			PlayLipsync(lobbyVOs);
			break;
		default:
			UnityEngine.Debug.LogWarning("SOMETHING TRIED TO PLAY A TYPE OF VOICELINE THAT DOESN'T EXIST AAAAAAAAAA");
			break;
		}
	}

	private void PlayLipsync(List<LipSyncData> _data)
	{
		voTimer = UnityEngine.Random.Range(voMinCooldown, voMaxCooldown) * 2f;
		int index = UnityEngine.Random.Range(0, _data.Count);
		PlayVOData(_data[index]);
	}

	private void PlayLipsync(List<LipSyncData> _data, VOType _type)
	{
		voTimer = UnityEngine.Random.Range(voMinCooldown, voMaxCooldown) * 2f;
		LipSyncData data = null;
		switch (_type)
		{
		case VOType.e_intro:
		case VOType.e_win:
		case VOType.e_lose:
		{
			int index = UnityEngine.Random.Range(0, _data.Count);
			data = _data[index];
			endTimer = _data[index].clip.length + 0.5f;
			break;
		}
		case VOType.e_compliment:
			data = _data[curCompliment];
			curCompliment++;
			if (curCompliment == _data.Count)
			{
				complimentVOs = ShuffleList(complimentVOs, _data[curCompliment - 1]);
				curCompliment = 0;
			}
			break;
		case VOType.e_insult:
			data = _data[curInsult];
			curInsult++;
			if (curInsult == _data.Count)
			{
				insultVOs = ShuffleList(insultVOs, _data[curInsult - 1]);
				curInsult = 0;
			}
			break;
		default:
			UnityEngine.Debug.LogWarning("Why did you use this VO function? Use the other one.");
			break;
		}
		PlayVOData(data);
	}

	private void PlayVOData(LipSyncData _data)
	{
		for (int i = 0; i < lipSyncs.Count; i++)
		{
			lipSyncs[i].Play(_data);
		}
	}

	public void PlaySound(AudioClip _clip, AudioSource _source)
	{
		_source.Stop();
		_source.clip = _clip;
		_source.Play();
	}

	private void StartGame()
	{
		GameManager.instance.StartSong();
		if (Persistence.instance.builtInSong)
		{
			if (Persistence.instance.svMan.settingsSave.enableDanceholograms)
			{
				GameManager.instance.holoCon.ShowHolo();
				UnityEngine.Object.FindObjectOfType<DirectorDirector>().StartDance(GameManager.instance.GetStageNum(GameManager.instance.musicNum) - 1);
			}
			else
			{
				GameManager.instance.holoCon.EndHolo();
			}
		}
	}
}
public class CubeSound : MonoBehaviour
{
	public SubbandBeatDetection selectedBeatDetection;

	public int[] subbandsToEar;

	private MeshRenderer myMeshRenderer;

	private Color beatedColor;

	public float smoothnessChange;

	private void Start()
	{
		for (int i = 0; i < subbandsToEar.Length; i++)
		{
			selectedBeatDetection.subBands[subbandsToEar[i]].OnBeat += OnBeat;
		}
		myMeshRenderer = GetComponent<MeshRenderer>();
		beatedColor = Color.black;
	}

	private void Update()
	{
		beatedColor = Color.Lerp(beatedColor, Color.black, smoothnessChange * Time.deltaTime);
		myMeshRenderer.material.color = beatedColor;
	}

	private void OnBeat()
	{
		beatedColor = Color.yellow;
	}
}
public class CubesManager : MonoBehaviour
{
	public CubeSound prefabObject;

	public SubbandBeatDetection selectedBeatDetection;

	public int cubesToSpawn;

	private void Awake()
	{
		int num = 0;
		for (int i = 0; i < cubesToSpawn; i++)
		{
			CubeSound cubeSound = UnityEngine.Object.Instantiate(prefabObject);
			int[] subbandsToEar = new int[2]
			{
				num,
				num + 1
			};
			num += 2;
			cubeSound.selectedBeatDetection = selectedBeatDetection;
			cubeSound.subbandsToEar = subbandsToEar;
			cubeSound.smoothnessChange = 2f;
			cubeSound.transform.position = Vector3.right * (-cubesToSpawn + i * 2);
			cubeSound.transform.SetParent(base.transform);
		}
	}
}
public class SubbandBeatDetection : MonoBehaviour
{
	public class SubBand
	{
		public delegate void OnBeatHandler();

		public float instantEnergy;

		public float averageEnergy;

		public float instantVariance;

		public int frequencyWidth;

		private float[] historyBuffer;

		public event OnBeatHandler OnBeat;

		public SubBand(int _index)
		{
			frequencyWidth = Mathf.RoundToInt(0.44f * (float)_index + 1.56f);
			historyBuffer = new float[43];
		}

		public void ComputeInstantEnergy(int _start, int _end, float[] _samples0, float[] _samples1)
		{
			float num = 0f;
			for (int i = _start; i < _end; i++)
			{
				num += (float)Math.Pow(_samples0[i], 2.0) + (float)Math.Pow(_samples1[i], 2.0);
			}
			instantEnergy = num;
		}

		public void ComputeAverageEnergy()
		{
			float num = 0f;
			for (int i = 0; i < historyBuffer.Length; i++)
			{
				num += historyBuffer[i];
			}
			averageEnergy = num / (float)historyBuffer.Length;
			float[] array = ShiftArray(historyBuffer, 1);
			array[0] = instantEnergy;
			OverrideElementsToAnotherArray(array, historyBuffer);
		}

		public void ComputeInstantVariance()
		{
			float num = 0f;
			for (int i = 0; i < historyBuffer.Length; i++)
			{
				num += (float)Math.Pow(historyBuffer[i] - averageEnergy, 2.0);
			}
			instantVariance = num / (float)historyBuffer.Length;
		}

		public void hasBeated()
		{
			if (instantEnergy > 5f * averageEnergy && instantVariance > 1E-05f && this.OnBeat != null)
			{
				this.OnBeat();
			}
		}

		private void OverrideElementsToAnotherArray(float[] _from, float[] _to)
		{
			for (int i = 0; i < _from.Length; i++)
			{
				_to[i] = _from[i];
			}
		}

		private float[] ShiftArray(float[] _array, int amount)
		{
			float[] array = new float[_array.Length];
			for (int i = 0; i < _array.Length - amount; i++)
			{
				array[i + amount] = _array[i];
			}
			return array;
		}
	}

	public AudioSource audioSource;

	[Header("Algorithm Configuration")]
	public int numSubbands;

	public int numSamples;

	public FFTWindow FFTWindow;

	private float[] samplesLeftChannel;

	private float[] samplesRightChannel;

	private const float a = 0.44f;

	private const float b = 1.56f;

	private const int beatSensivity = 5;

	private const float varianceSensivity = 1E-05f;

	public SubBand[] subBands { get; set; }

	private void Awake()
	{
		samplesLeftChannel = new float[numSamples];
		samplesRightChannel = new float[numSamples];
		subBands = new SubBand[numSubbands];
		for (int i = 0; i < subBands.Length; i++)
		{
			subBands[i] = new SubBand(i + 1);
		}
	}

	private void Update()
	{
		audioSource.GetSpectrumData(samplesLeftChannel, 0, FFTWindow);
		audioSource.GetSpectrumData(samplesRightChannel, 1, FFTWindow);
		for (int i = 0; i < subBands.Length; i++)
		{
			int num = 0;
			for (int j = 0; j <= i - 1; j++)
			{
				num += subBands[j].frequencyWidth;
			}
			int num2 = 0;
			for (int k = 0; k <= i; k++)
			{
				num2 += subBands[k].frequencyWidth;
			}
			subBands[i].ComputeInstantEnergy(num, num2, samplesLeftChannel, samplesRightChannel);
			subBands[i].ComputeAverageEnergy();
			subBands[i].ComputeInstantVariance();
			subBands[i].hasBeated();
		}
	}
}
[AddComponentMenu("Lightshow/Blendshape Effect", 0)]
public class Effect_BlendShapes : LightShowEffect
{
	[Serializable]
	public struct BlendShapeProperty
	{
		public int index;

		public Vector2 startEnd;

		public bool gradientPulse;
	}

	public List<BlendShapeProperty> properties;

	public List<SkinnedMeshRenderer> renderers;

	public float pulseTime = 0.5f;

	private float timer;

	public bool startOff;

	private void Start()
	{
		if (startOff)
		{
			TurnOff();
		}
	}

	private void Update()
	{
		if (!(timer > 0f))
		{
			return;
		}
		timer -= Time.deltaTime;
		float t = Mathf.InverseLerp(pulseTime, 0f, timer);
		foreach (BlendShapeProperty property in properties)
		{
			if (property.gradientPulse)
			{
				SetValue(Mathf.Lerp(property.startEnd.x, property.startEnd.y, t), property.index);
			}
		}
		if (timer <= 0f)
		{
			timer = 0f;
			TurnOff();
		}
	}

	public override void Pulse()
	{
		base.Pulse();
		timer = pulseTime;
		TurnOn();
	}

	public override void TurnOff()
	{
		base.TurnOff();
		foreach (BlendShapeProperty property in properties)
		{
			SetValue(property.startEnd.y, property.index);
		}
	}

	public override void TurnOn()
	{
		base.TurnOn();
		foreach (BlendShapeProperty property in properties)
		{
			SetValue(property.startEnd.x, property.index);
		}
	}

	public void GetRenderersFromChildren()
	{
		renderers.Clear();
		renderers = new List<SkinnedMeshRenderer>(GetComponentsInChildren<SkinnedMeshRenderer>());
	}

	private void SetValue(float value, int index)
	{
		for (int i = 0; i < renderers.Count; i++)
		{
			renderers[i].SetBlendShapeWeight(index, value);
		}
	}
}
[AddComponentMenu("Lightshow/Rotation Effect", 0)]
public class Effect_Rotation : LightShowEffect
{
	public List<Transform> objects;

	public Vector3 axis;

	public bool localSpace = true;

	public float pulseDegrees = 90f;

	public float pulseTime = 0.5f;

	public float onSpeed = 30f;

	public float offSpeed;

	private float rotateSpeed;

	private float timer;

	public AnimationCurve curve = AnimationCurve.Linear(0f, 0f, 1f, 1f);

	private List<Quaternion> startPulseRots = new List<Quaternion>();

	private List<Quaternion> endPulseRots = new List<Quaternion>();

	public bool yellowOverride;

	private void Start()
	{
		if (yellowOverride)
		{
			GameManager instance = GameManager.instance;
			instance._pulse = (GameManager.LightsPulse)Delegate.Combine(instance._pulse, new GameManager.LightsPulse(Pulse));
		}
	}

	private void Update()
	{
		if (rotateSpeed > 0f)
		{
			for (int i = 0; i < objects.Count; i++)
			{
				objects[i].Rotate(axis, rotateSpeed * Time.deltaTime, localSpace ? Space.Self : Space.World);
			}
		}
		if (timer > 0f)
		{
			float time = Mathf.InverseLerp(pulseTime, 0f, timer);
			float t = curve.Evaluate(time);
			for (int j = 0; j < objects.Count; j++)
			{
				objects[j].transform.localRotation = Quaternion.Lerp(startPulseRots[j], endPulseRots[j], t);
			}
			timer -= Time.deltaTime;
			if (timer <= 0f)
			{
				timer = 0f;
				TurnOff();
			}
		}
	}

	public override void Pulse()
	{
		base.Pulse();
		timer = pulseTime;
		startPulseRots.Clear();
		endPulseRots.Clear();
		for (int i = 0; i < objects.Count; i++)
		{
			startPulseRots.Add(objects[i].localRotation);
			endPulseRots.Add(objects[i].localRotation * Quaternion.AngleAxis(pulseDegrees, axis));
		}
	}

	public override void TurnOff()
	{
		base.TurnOff();
		rotateSpeed = offSpeed;
	}

	public override void TurnOn()
	{
		base.TurnOn();
		rotateSpeed = onSpeed;
	}
}
[AddComponentMenu("Lightshow/Shader Colour Effect", 0)]
public class Effect_ShaderColour : LightShowEffect
{
	[Serializable]
	public struct ShaderProperty
	{
		public string property;

		public Color startColour;

		public Color endColour;

		public bool gradientPulse;
	}

	public List<ShaderProperty> properties;

	public List<Renderer> renderers;

	public float pulseTime = 0.5f;

	private float timer;

	public bool startOff;

	private void Start()
	{
		if (startOff)
		{
			TurnOff();
		}
	}

	private void FixedUpdate()
	{
		if (!(timer > 0f))
		{
			return;
		}
		timer -= Time.deltaTime;
		float t = Mathf.InverseLerp(pulseTime, 0f, timer);
		for (int i = 0; i < properties.Count; i++)
		{
			ShaderProperty shaderProperty = properties[i];
			if (shaderProperty.gradientPulse)
			{
				SetValue(Color.Lerp(shaderProperty.startColour, shaderProperty.endColour, t), shaderProperty.property);
			}
		}
		if (timer <= 0f)
		{
			timer = 0f;
			TurnOff();
		}
	}

	public override void Pulse()
	{
		base.Pulse();
		timer = pulseTime;
		TurnOn();
	}

	public override void TurnOff()
	{
		base.TurnOff();
		foreach (ShaderProperty property in properties)
		{
			SetValue(property.endColour, property.property);
		}
	}

	public override void TurnOn()
	{
		base.TurnOn();
		foreach (ShaderProperty property in properties)
		{
			SetValue(property.startColour, property.property);
		}
	}

	public void GetRenderersFromChildren()
	{
		renderers.Clear();
		renderers = new List<Renderer>(GetComponentsInChildren<Renderer>());
	}

	private void SetValue(Color value, string prop)
	{
		for (int i = 0; i < renderers.Count; i++)
		{
			if (!(renderers[i] != null))
			{
				continue;
			}
			for (int j = 0; j < renderers[i].materials.Length; j++)
			{
				if (renderers[i].materials[j] != null)
				{
					renderers[i].materials[j].SetColor(prop, value);
				}
			}
		}
	}
}
[AddComponentMenu("Lightshow/Shader Float Effect", 0)]
public class Effect_ShaderFloat : LightShowEffect
{
	[Serializable]
	public struct ShaderProperty
	{
		public string property;

		public Vector2 startEnd;

		public bool gradientPulse;
	}

	public List<ShaderProperty> properties;

	public List<Renderer> renderers;

	public float pulseTime = 0.5f;

	private float timer;

	public bool startOff;

	private void Start()
	{
		if (startOff)
		{
			TurnOff();
		}
	}

	private void FixedUpdate()
	{
		if (!(timer > 0f))
		{
			return;
		}
		timer -= Time.deltaTime;
		float t = Mathf.InverseLerp(pulseTime, 0f, timer);
		for (int i = 0; i < properties.Count; i++)
		{
			ShaderProperty shaderProperty = properties[i];
			if (shaderProperty.gradientPulse)
			{
				SetValue(Mathf.Lerp(shaderProperty.startEnd.x, shaderProperty.startEnd.y, t), shaderProperty.property);
			}
		}
		if (timer <= 0f)
		{
			timer = 0f;
			TurnOff();
		}
	}

	public override void Pulse()
	{
		base.Pulse();
		timer = pulseTime;
		TurnOn();
	}

	public override void TurnOff()
	{
		base.TurnOff();
		foreach (ShaderProperty property in properties)
		{
			SetValue(property.startEnd.y, property.property);
		}
	}

	public override void TurnOn()
	{
		base.TurnOn();
		foreach (ShaderProperty property in properties)
		{
			SetValue(property.startEnd.x, property.property);
		}
	}

	public void GetRenderersFromChildren()
	{
		renderers.Clear();
		renderers = new List<Renderer>(GetComponentsInChildren<Renderer>());
	}

	private void SetValue(float value, string prop)
	{
		for (int i = 0; i < renderers.Count; i++)
		{
			if (!(renderers[i] != null))
			{
				continue;
			}
			for (int j = 0; j < renderers[i].materials.Length; j++)
			{
				if (renderers[i].materials[j] != null)
				{
					renderers[i].materials[j].SetFloat(prop, value);
				}
			}
		}
	}
}
[AddComponentMenu("Lightshow/Shader Texture Effect", 0)]
public class Effect_ShaderTexture : LightShowEffect
{
	[Serializable]
	public struct ShaderProperty
	{
		public string property;

		public Texture startTex;

		public Texture endTex;
	}

	public List<ShaderProperty> properties;

	public List<Renderer> renderers;

	public float pulseTime = 0.5f;

	private float timer;

	public bool startOff;

	private void Start()
	{
		if (startOff)
		{
			TurnOff();
		}
	}

	private void Update()
	{
		if (timer > 0f)
		{
			timer -= Time.deltaTime;
			Mathf.InverseLerp(pulseTime, 0f, timer);
			if (timer <= 0f)
			{
				timer = 0f;
				TurnOff();
			}
		}
	}

	public override void Pulse()
	{
		base.Pulse();
		timer = pulseTime;
		TurnOn();
	}

	public override void TurnOff()
	{
		base.TurnOff();
		foreach (ShaderProperty property in properties)
		{
			SetValue(property.endTex, property.property);
		}
	}

	public override void TurnOn()
	{
		base.TurnOn();
		foreach (ShaderProperty property in properties)
		{
			SetValue(property.startTex, property.property);
		}
	}

	public void GetRenderersFromChildren()
	{
		renderers.Clear();
		renderers = new List<Renderer>(GetComponentsInChildren<Renderer>());
	}

	private void SetValue(Texture value, string prop)
	{
		for (int i = 0; i < renderers.Count; i++)
		{
			for (int j = 0; j < renderers[i].materials.Length; j++)
			{
				renderers[i].materials[j].SetTexture(prop, value);
			}
		}
	}
}
[AddComponentMenu("Lightshow/Toggle Object Effect", 0)]
public class Effect_ToggleGameObject : LightShowEffect
{
	public List<GameObject> objects;

	public float pulseTime = 0.5f;

	private float timer;

	private void Update()
	{
		if (!(timer > 0f))
		{
			return;
		}
		timer -= Time.deltaTime;
		if (timer <= 0f)
		{
			timer = 0f;
			for (int i = 0; i < objects.Count; i++)
			{
				objects[i].SetActive(value: false);
			}
		}
	}

	public override void Pulse()
	{
		base.Pulse();
		for (int i = 0; i < objects.Count; i++)
		{
			objects[i].SetActive(value: true);
		}
		timer = pulseTime;
	}

	public override void TurnOff()
	{
		base.TurnOff();
		for (int i = 0; i < objects.Count; i++)
		{
			objects[i].SetActive(value: false);
		}
	}

	public override void TurnOn()
	{
		base.TurnOn();
		for (int i = 0; i < objects.Count; i++)
		{
			objects[i].SetActive(value: true);
		}
	}
}
[AddComponentMenu("Lightshow/Translate Effect", 0)]
public class Effect_Translate : LightShowEffect
{
	public Transform _object;

	public Transform onPos;

	public float lerpValue = 0.5f;

	private Vector3 targetPos;

	private Vector3 startPos;

	public float pulseTime = 2f;

	public AnimationCurve curve;

	private float timer;

	public bool yellowOverride;

	public override void Pulse()
	{
		base.Pulse();
		timer = pulseTime;
	}

	public override void TurnOff()
	{
		base.TurnOff();
		targetPos = startPos;
	}

	public override void TurnOn()
	{
		base.TurnOn();
		targetPos = onPos.position;
	}

	private void Start()
	{
		startPos = _object.position;
		TurnOff();
		if (yellowOverride)
		{
			GameManager instance = GameManager.instance;
			instance._pulse = (GameManager.LightsPulse)Delegate.Combine(instance._pulse, new GameManager.LightsPulse(Pulse));
		}
	}

	private void Update()
	{
		if (timer > 0f)
		{
			float time = Mathf.InverseLerp(pulseTime, 0f, timer);
			float t = curve.Evaluate(time);
			_object.position = Vector3.Lerp(startPos, onPos.position, t);
			timer -= Time.deltaTime;
			if (timer <= 0f)
			{
				timer = 0f;
				TurnOff();
			}
		}
		else
		{
			_object.position = Vector3.Lerp(_object.position, targetPos, lerpValue);
		}
	}

	private void OnDrawGizmosSelected()
	{
		Gizmos.color = Color.red;
		Gizmos.DrawLine(_object.position, onPos.position);
		Gizmos.DrawSphere(onPos.position, 0.1f);
	}
}
public class LightShowEffect : MonoBehaviour
{
	public virtual void Pulse()
	{
	}

	public virtual void TurnOn()
	{
	}

	public virtual void TurnOff()
	{
	}

	public void Trigger(LightShowManager.e_EffectType type)
	{
		switch (type)
		{
		case LightShowManager.e_EffectType.Pulse:
			Pulse();
			break;
		case LightShowManager.e_EffectType.On:
			TurnOn();
			break;
		case LightShowManager.e_EffectType.Off:
			TurnOff();
			break;
		case LightShowManager.e_EffectType.None:
			break;
		}
	}
}
public class LightShowManager : MonoBehaviour
{
	public enum e_EffectType
	{
		Pulse,
		On,
		Off,
		None
	}

	public enum e_EffectGroup
	{
		Double,
		SetComplete,
		SetHit,
		LeftCascadeStart,
		LeftCascadeComplete,
		LeftCascadeBreak,
		RightCascadeStart,
		RightCascadeComplete,
		RightCascadeBreak
	}

	[Serializable]
	public class Instruction
	{
		public LightShowEffect effect;

		public e_EffectType type;

		public void Trigger()
		{
			effect.Trigger(type);
		}
	}

	public List<Instruction> DoubleGroup;

	[Header("Sets")]
	public List<Instruction> SetCompleteGroup;

	public List<Instruction> SetHitGroup;

	[Header("Cascades")]
	public List<Instruction> LeftCascadeStartGroup;

	public List<Instruction> LeftCascadeEndGroup;

	public List<Instruction> LeftCascadeBreakGroup;

	public List<Instruction> RightCascadeStartGroup;

	public List<Instruction> RightCascadeEndGroup;

	public List<Instruction> RightCascadeBreakGroup;

	private void Start()
	{
		GameManager.instance.objectRefrences.lightManager = this;
	}

	public void Trigger(e_EffectGroup group)
	{
		if (!(Persistence.instance != null) || Persistence.instance.svMan.settingsSave.enableLightshows)
		{
			switch (group)
			{
			case e_EffectGroup.Double:
				TriggerGroup(DoubleGroup);
				break;
			case e_EffectGroup.SetComplete:
				TriggerGroup(SetCompleteGroup);
				break;
			case e_EffectGroup.LeftCascadeStart:
				TriggerGroup(LeftCascadeStartGroup);
				break;
			case e_EffectGroup.LeftCascadeComplete:
				TriggerGroup(LeftCascadeEndGroup);
				break;
			case e_EffectGroup.SetHit:
				TriggerGroup(SetHitGroup);
				break;
			case e_EffectGroup.LeftCascadeBreak:
				TriggerGroup(LeftCascadeBreakGroup);
				break;
			case e_EffectGroup.RightCascadeStart:
				TriggerGroup(RightCascadeStartGroup);
				break;
			case e_EffectGroup.RightCascadeComplete:
				TriggerGroup(RightCascadeEndGroup);
				break;
			case e_EffectGroup.RightCascadeBreak:
				TriggerGroup(RightCascadeBreakGroup);
				break;
			}
		}
	}

	private void TriggerGroup(List<Instruction> instructions)
	{
		for (int i = 0; i < instructions.Count; i++)
		{
			instructions[i].Trigger();
		}
	}

	public void TestDouble()
	{
		Trigger(e_EffectGroup.Double);
	}

	public void TestSetHit()
	{
		Trigger(e_EffectGroup.SetHit);
	}

	public void TestSetComplete()
	{
		Trigger(e_EffectGroup.SetComplete);
	}

	public void TestLeftCascadeStart()
	{
		Trigger(e_EffectGroup.LeftCascadeStart);
	}

	public void TestRightCascadeStart()
	{
		Trigger(e_EffectGroup.RightCascadeStart);
	}

	public void TestLeftCascadeBreak()
	{
		Trigger(e_EffectGroup.LeftCascadeBreak);
	}

	public void TestRightCascadeBreak()
	{
		Trigger(e_EffectGroup.RightCascadeBreak);
	}

	public void TestLeftCascadeComplete()
	{
		Trigger(e_EffectGroup.LeftCascadeComplete);
	}

	public void TestRightCascadeComplete()
	{
		Trigger(e_EffectGroup.RightCascadeComplete);
	}
}
public class LookAt_PerAxis : MonoBehaviour
{
	public Transform target;

	public bool x;

	public bool y;

	public bool z;

	private void Start()
	{
	}

	private void Update()
	{
		if (!(target == null))
		{
			base.transform.LookAt(new Vector3(x ? target.position.x : base.transform.position.x, y ? target.position.y : base.transform.position.y, z ? target.position.z : base.transform.position.z));
		}
	}
}
public class NodePreviewManager : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
	}

	public void PlayPreview(string previewFileName)
	{
		Persistence.instance.currentSongFilename = previewFileName;
		SceneManager.LoadScene("Game");
	}
}
public class OpenURL : MonoBehaviour
{
	public string URL;

	public void Open()
	{
		UnityEngine.Application.OpenURL(URL);
	}
}
public class Persistence : MonoBehaviour
{
	[Serializable]
	public class Difficulty
	{
		public int delay;

		public float sizeMod;

		public float offsetMod;

		public float damage;

		public float heal;
	}

	public static Persistence instance;

	[SerializeField]
	public string currentSongFilename;

	[SerializeField]
	public bool builtInSong = true;

	private LeaderboardManager lbMan;

	public SaveManager svMan;

	public AchievementsManager achMan;

	public AudioMixer masterMix;

	public Terminal console;

	[HideInInspector]
	public bool oculusInitialised;

	public bool devConsoleEnabled;

	public bool fromEditor;

	public int currentDifficulty;

	public Difficulty Easy;

	public Difficulty Normal;

	public Difficulty Hard;

	public Difficulty Extreme;

	public int lobbyscreen;

	public bool nofail;

	private Vector3Int minAuraValues = new Vector3Int(20, 11, 16);

	private Vector3Int maxAuraValues = new Vector3Int(80, 45, 64);

	private bool lastPause;

	private void Awake()
	{
		if (instance != null)
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
		else
		{
			instance = this;
			UnityEngine.Object.DontDestroyOnLoad(this);
		}
		LevelLoaded(SceneManager.GetActiveScene(), LoadSceneMode.Additive);
		SceneManager.sceneLoaded += LevelLoaded;
		lbMan = GetComponent<LeaderboardManager>();
		svMan = GetComponent<SaveManager>();
		achMan = GetComponent<AchievementsManager>();
		console = GetComponent<Terminal>();
	}

	public void ToggleOverlay(bool toggle)
	{
	}

	private void SetupLIV()
	{
	}

	public Difficulty GetDifficuty()
	{
		return currentDifficulty switch
		{
			0 => Easy, 
			1 => Normal, 
			2 => Hard, 
			3 => Extreme, 
			_ => Normal, 
		};
	}

	private void Start()
	{
	}

	private void Update()
	{
	}

	private void LevelLoaded(Scene scene, LoadSceneMode mode)
	{
		Time.timeScale = 1f;
		ToggleOverlay(toggle: false);
		_ = scene.name != "PSVRSetup";
	}

	private IEnumerator SetaudioLate()
	{
		yield return 1;
	}

	public void ToggleTerminal(bool toggle)
	{
		console.enabled = toggle;
		devConsoleEnabled = toggle;
	}

	public void SetLeaderboardTarget()
	{
		OculusManager.instance.SetTargetBoard();
	}

	public void UpdateLeaderboard()
	{
		try
		{
			UnityEngine.Object.FindObjectOfType<UI_Leaderboard>().SetLoading();
		}
		catch
		{
		}
		OculusManager.instance.SetTargetBoard();
	}

	public void UploadScore(int _score, Score.Rank _grade)
	{
		OculusManager.instance.SubmitScore(_score);
	}

	public void ResetLeaderboardManager()
	{
		lbMan.state = LBManState.e_none;
	}

	public string GetPlayerName()
	{
		return "name";
	}

	public void InitPlayerName()
	{
		lbMan.InitPlayerName();
	}

	public void UpdateAchievements()
	{
		achMan.UpdateAchievements();
	}

	public void CheckDevConsole()
	{
	}

	public Vector3Int GetAuraResolution()
	{
		float auraQuality = svMan.settingsSave.auraQuality;
		int x = Mathf.RoundToInt(Mathf.Lerp(minAuraValues.x, maxAuraValues.x, auraQuality));
		int y = Mathf.RoundToInt(Mathf.Lerp(minAuraValues.y, maxAuraValues.y, auraQuality));
		int z = Mathf.RoundToInt(Mathf.Lerp(minAuraValues.z, maxAuraValues.z, auraQuality));
		return new Vector3Int(x, y, z);
	}

	public void SetAA()
	{
		switch (svMan.settingsSave.antiAliasing)
		{
		case 0:
			QualitySettings.antiAliasing = 0;
			break;
		case 1:
			QualitySettings.antiAliasing = 2;
			break;
		case 2:
			QualitySettings.antiAliasing = 4;
			break;
		case 3:
			QualitySettings.antiAliasing = 8;
			break;
		}
	}
}
public class PlatformManager : MonoBehaviour
{
	public static PlatformManager inst;

	public LeaderboardManager lbMan;

	public bool paused;

	private bool waitingForOculus;

	private bool waitingForSteamVR;

	private bool waitingForStove;

	private HardwareType hardware;

	private GameObject avatar;

	private static readonly string VIVEPORT_ID = "6c8e8b77-c99a-4044-815a-7aad9c2b655d";

	private static readonly string VIVEPORT_KEY = "MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCEZk0HbUp8lHPoJXedT0fqYY12uQ7fejqauq6ZY/4pmXpnfpjWmo82tHwkbE+z+/DGgKWSI0dJo0QD+hYPFDBJcw1jPWojsQu+oqkujxYgeJ35m1qR2ANUXc04h+aaFwhX3OWndNhQ1N9LhEJcZg10LdKd3JsGhV7alVyRmtt/twIDAQAB";
}
[RequireComponent(typeof(AudioSource))]
public class RandomPitch : MonoBehaviour
{
	public Vector2 range;

	private void OnEnable()
	{
		GetComponent<AudioSource>().pitch = UnityEngine.Random.Range(range.x, range.y);
	}

	public void RandomisePitch(AudioSource _aSource)
	{
		_aSource.pitch = UnityEngine.Random.Range(range.x, range.y);
	}
}
[RequireComponent(typeof(RawImage))]
public class RawImageScroller : MonoBehaviour
{
	private RawImage img;

	public Vector2 scrollamount;

	private Rect r;

	private void Start()
	{
		img = GetComponent<RawImage>();
		r.x = img.uvRect.x;
		r.y = img.uvRect.y;
		r.height = img.uvRect.height;
		r.width = img.uvRect.width;
	}

	private void Update()
	{
		r.x += scrollamount.x * Time.deltaTime;
		r.y += scrollamount.y * Time.deltaTime;
		img.uvRect = r;
		img.SetMaterialDirty();
	}
}
public class SceneLauncher : MonoBehaviour
{
	public void LaunchLobby()
	{
		StartCoroutine(LoadScene());
	}

	private IEnumerator LoadScene(string scene = "intro cutscene")
	{
		Persistence.instance.ToggleOverlay(toggle: true);
		UnityEngine.Application.backgroundLoadingPriority = UnityEngine.ThreadPriority.Low;
		AsyncOperation asyncLoad = SceneManager.LoadSceneAsync(scene, LoadSceneMode.Single);
		while (!asyncLoad.isDone)
		{
			yield return null;
		}
		Persistence.instance.ToggleOverlay(toggle: false);
	}
}
public class SetConnector : MonoBehaviour
{
	private LineRenderer lr;

	public Transform target;

	private void Awake()
	{
		lr = GetComponent<LineRenderer>();
		Color col = lr.startColor;
		if (base.transform.parent.parent.GetComponent<Node>() != null)
		{
			col = ((base.transform.parent.parent.GetComponent<Node>().type == NodeType.Pink) ? Color.HSVToRGB(Persistence.instance.svMan.settingsSave.left_Colour, 1f, 1f) : Color.HSVToRGB(Persistence.instance.svMan.settingsSave.right_Colour, 1f, 1f));
		}
		Gradient gradient = new Gradient();
		gradient.SetKeys(new GradientColorKey[2]
		{
			new GradientColorKey(col, 0f),
			new GradientColorKey(col, 1f)
		}, new GradientAlphaKey[2]
		{
			new GradientAlphaKey(1f, 0f),
			new GradientAlphaKey(1f, 1f)
		});
		lr.colorGradient = gradient;
	}

	private void Start()
	{
	}

	private void Update()
	{
		lr.SetPosition(0, base.transform.position);
		lr.SetPosition(1, target.position);
		lr.material.SetTextureOffset("_MainTex", new Vector2(Time.time, 0f));
	}
}
public class SetCounter : MonoBehaviour
{
	public int numInSet;

	public int numHit;

	public TextMeshProUGUI text;

	public List<string> coolWords;

	public void Init(int num)
	{
		numInSet = num;
		UpdateText();
	}

	public void Hit()
	{
		numHit++;
		UpdateText();
		if (numHit == numInSet)
		{
			GetComponent<Animator>().SetTrigger("Succeed");
			GameManager.instance.currentSetCounter = null;
		}
	}

	public void Miss()
	{
		GetComponent<Animator>().SetTrigger("Fail");
	}

	private void UpdateText()
	{
		text.text = numHit + " / " + numInSet;
	}

	public void DestroyThis()
	{
		UnityEngine.Object.Destroy(this);
	}

	public void ShowCoolWord()
	{
		text.text = ParseLoc.Parse(coolWords[UnityEngine.Random.Range(0, coolWords.Count)]);
	}
}
[RequireComponent(typeof(Slider))]
public class SiliderValueDisplay : MonoBehaviour
{
	public TextMeshProUGUI display;

	private Slider slider;

	private void Start()
	{
		slider = GetComponent<Slider>();
	}

	public void UpdateDisplay()
	{
		display.text = (GetComponent<Slider>().value * 100f).ToString("F0");
	}
}
public class EditorManager : MonoBehaviour
{
	[Serializable]
	public class ObjectRefrences
	{
		public GameObject fakeNodePrefab;

		public GameObject leftController;

		public GameObject rightController;

		public GameObject leftMarker;

		public GameObject rightMarker;

		public GameObject yellowMarker;

		public GameObject beatMarker;

		public TMP_InputField filenameInput;

		public TMP_InputField bpmInput;

		public TMP_InputField offsetInput;

		public TMP_InputField durationInput;

		public TMP_InputField title1Input;

		public TMP_InputField title2Input;

		public TMP_InputField title3Input;

		public TextMeshProUGUI infoText;

		public TextMeshProUGUI timeText;

		public TextMeshProUGUI musicText;

		public TextMeshProUGUI browserPathText;

		public Button clearButton;

		public Button loadButton;

		public Button saveButton;

		public Button testButton;

		public Button newButton;

		public Toggle additiveToggle;

		public Toggle timeSelectToggle;

		public Toggle holdForCascadesToggle;

		public Toggle loadBackgroundArenaToggle;

		public TextMeshPro leftHandInfo;

		public TextMeshPro rightHandInfo;

		public GameObject browser;

		public GameObject browserButton;

		public GameObject browserExplorerButton;

		public GameObject browserExplorerText;

		public TMP_Dropdown musicTypeDropdown;

		public TMP_Dropdown arenaDropdown;

		public SongEditor songEditor;

		public ControllerScrollArea mainScrollArea;

		public UI_NodeSettings nodeSettingsUI;

		public ArcRenderer leftArc;

		public ArcRenderer rightArc;

		public Editor_UI_Panel nodeInspectorPanel;

		public Editor_UI_Panel navigationPanel;

		public Editor_UI_Panel keyboardPanel;

		public Editor_UI_Panel bpmPanel;

		public Editor_UI_Panel testPanel;

		public UI_Editor_EditTools editTools;
	}

	public enum TriggerMode
	{
		Select,
		BoxSelect,
		TimeSelect,
		Add
	}

	public static EditorManager instance;

	private GameManager gm;

	private int handsInScrollAreas;

	public ObjectRefrences objectRefrences;

	private bool handsClose;

	public Color pinkNodeColour;

	public Color greenNodeColour;

	public Color yellowNodeColour;

	public float handsCloseThreshold = 0.075f;

	public float cascadeInterval;

	public bool singleSelectAdditive;

	public bool multiSelectTimeSelect;

	public bool holdForCascades = true;

	public bool loadBackgroundArena = true;

	public TriggerMode triggerMode;

	public bool loading;

	private float songDuration;

	private float dragCounter = 1f;

	private bool leftDragStart;

	private bool rightDragStart;

	private bool leftDragActive;

	private bool rightDragActive;

	public float dragDelay = 0.5f;

	public CubeBetween2Points selectionCube;

	public Transform pointA;

	public Transform pointB;

	public GameObject textPopupPrefab;

	private List<string> messageQueue = new List<string>();

	private float messagedelay = 0.25f;

	private float messagedelaytimer;

	private SceneEditorNode leftCascadeStartNode;

	private SceneEditorNode rightCascadeStartNode;

	private List<Vector3> leftCascadePositions = new List<Vector3>();

	private List<Vector3> rightCascadePositions = new List<Vector3>();

	private float leftCascadeTimer;

	private float rightCascadeTimer;

	public float cascadeThreshold = 0.5f;

	private bool leftCascade;

	private bool rightCascade;

	private SceneEditorNode lastSpawnedNode;

	private string[] soundtrackNames;

	public List<SceneEditorNode> clipboard;

	public GameObject clipboard_Object;

	public int HandsInScrollAreas
	{
		get
		{
			return handsInScrollAreas;
		}
		set
		{
			if (value == 0)
			{
				objectRefrences.mainScrollArea.scrollActive = true;
			}
			handsInScrollAreas = value;
		}
	}

	private void Awake()
	{
		if (instance == null)
		{
			instance = this;
		}
		gm = GameManager.instance;
		if (loadBackgroundArena)
		{
			LoadBackground();
		}
		soundtrackNames = new string[45]
		{
			"Yuri: " + ScriptLocalization.Yuri_Stage1,
			"Yuri: " + ScriptLocalization.Yuri_Stage2,
			"Yuri: " + ScriptLocalization.Yuri_Stage3,
			"Pyro: " + ScriptLocalization.Pyro_Stage1,
			"Pyro: " + ScriptLocalization.Pyro_Stage2,
			"Pyro: " + ScriptLocalization.Pyro_Stage3,
			"Lais: " + ScriptLocalization.Lais_Stage1,
			"Lais: " + ScriptLocalization.Lais_Stage2,
			"Lais: " + ScriptLocalization.Lais_Stage3,
			"Dre: " + ScriptLocalization.Dre_Stage1,
			"Dre: " + ScriptLocalization.Dre_Stage2,
			"Dre: " + ScriptLocalization.Dre_Stage3,
			"LiuWen: " + ScriptLocalization.Liu_Stage1,
			"LiuWen: " + ScriptLocalization.Liu_Stage2,
			"LiuWen: " + ScriptLocalization.Liu_Stage3,
			"Remi: " + ScriptLocalization.Remi_Stage1,
			"Remi: " + ScriptLocalization.Remi_Stage2,
			"Remi: " + ScriptLocalization.Remi_Stage3,
			"Sonya: " + ScriptLocalization.Sonya_Stage1,
			"Sonya: " + ScriptLocalization.Sonya_Stage2,
			"Sonya: " + ScriptLocalization.Sonya_Stage3,
			"Core: " + ScriptLocalization.Core_Stage1,
			"Core: " + ScriptLocalization.Core_Stage2,
			"Core: " + ScriptLocalization.Core_Stage3,
			"Yuri: " + ScriptLocalization.Yuri_Stage4,
			"Pyro: " + ScriptLocalization.Pyro_Stage4,
			"Lais: " + ScriptLocalization.Lais_Stage4,
			"Dre: " + ScriptLocalization.Dre_Stage4,
			"LiuWen: " + ScriptLocalization.Liu_Stage4,
			"Remi: " + ScriptLocalization.Remi_Stage4,
			"Sonya: " + ScriptLocalization.Sonya_Stage4,
			"Core: " + ScriptLocalization.Core_Stage4,
			"Yuri: " + ScriptLocalization.Yuri_Stage5,
			"Pyro: " + ScriptLocalization.Pyro_Stage5,
			"Lais: " + ScriptLocalization.Lais_Stage5,
			"Dre: " + ScriptLocalization.Dre_Stage5,
			"LiuWen: " + ScriptLocalization.Liu_Stage5,
			"Remi: " + ScriptLocalization.Remi_Stage5,
			"Sonya: " + ScriptLocalization.Sonya_Stage5,
			"Core: " + ScriptLocalization.Core_Stage5,
			"Uriel: " + ScriptLocalization.Uriel_Stage1,
			"Uriel: " + ScriptLocalization.Uriel_Stage2,
			"Uriel: " + ScriptLocalization.Uriel_Stage3,
			"Uriel: " + ScriptLocalization.Uriel_Stage4,
			"Uriel: " + ScriptLocalization.Uriel_Stage5
		};
	}

	private void Start()
	{
		objectRefrences.beatMarker.SetActive(value: false);
		Persistence.instance.builtInSong = false;
	}

	private IEnumerator CalibrateWhenReady()
	{
		while (gm.objectRefrences.oculusCenter.transform.position.y <= 0f)
		{
			yield return null;
		}
		gm.Calibrate();
		objectRefrences.mainScrollArea.SetOrigin();
	}

	public void StartSong()
	{
		if (gm.songPlaying)
		{
			objectRefrences.clearButton.interactable = true;
			objectRefrences.loadButton.interactable = true;
			objectRefrences.saveButton.interactable = true;
			objectRefrences.testButton.interactable = true;
			objectRefrences.newButton.interactable = true;
			objectRefrences.songEditor.EndPlayback();
		}
		else
		{
			objectRefrences.clearButton.interactable = false;
			objectRefrences.loadButton.interactable = false;
			objectRefrences.saveButton.interactable = false;
			objectRefrences.testButton.interactable = false;
			objectRefrences.newButton.interactable = false;
			objectRefrences.songEditor.StartPlayback();
		}
	}

	public void PlayDance()
	{
		SaveDance();
		Persistence.instance.fromEditor = true;
		Persistence.instance.builtInSong = false;
		Persistence.instance.currentSongFilename = objectRefrences.filenameInput.text;
		UnityEngine.Object.FindObjectOfType<FadeInOut>().target = 1f;
		UnityEngine.Object.FindObjectOfType<FadeInOut>().Fade();
		StartCoroutine(LoadSceneDelayed("Game"));
	}

	private IEnumerator LoadSceneDelayed(string scene = "dance collider lobby", float delay = 1f)
	{
		yield return new WaitForSecondsRealtime(delay);
		Persistence.instance.ToggleOverlay(toggle: true);
		yield return new WaitForSecondsRealtime(0.5f);
		SceneManager.LoadScene(scene);
	}

	public void LoadBackground()
	{
		StartCoroutine(LoadArena("Practice_Arena_New"));
	}

	public void UnLoadBackground()
	{
		StartCoroutine(UnLoadArena("Practice_Arena_New"));
	}

	private IEnumerator LoadArena(string arena)
	{
		Persistence.instance.ToggleOverlay(toggle: true);
		UnityEngine.Application.backgroundLoadingPriority = UnityEngine.ThreadPriority.High;
		AsyncOperation asyncLoad = SceneManager.LoadSceneAsync(arena, LoadSceneMode.Additive);
		while (!asyncLoad.isDone)
		{
			yield return null;
		}
		Persistence.instance.ToggleOverlay(toggle: false);
		SceneManager.SetActiveScene(SceneManager.GetSceneByName(arena));
	}

	private IEnumerator UnLoadArena(string arena)
	{
		Persistence.instance.ToggleOverlay(toggle: true);
		UnityEngine.Application.backgroundLoadingPriority = UnityEngine.ThreadPriority.High;
		AsyncOperation asyncLoad = SceneManager.UnloadSceneAsync(arena);
		while (!asyncLoad.isDone)
		{
			yield return null;
		}
		Persistence.instance.ToggleOverlay(toggle: false);
	}

	private void Update()
	{
		handsClose = Vector3.Distance(objectRefrences.leftMarker.transform.position, objectRefrences.rightMarker.transform.position) < handsCloseThreshold;
		objectRefrences.leftMarker.GetComponent<MeshRenderer>().enabled = !handsClose;
		objectRefrences.rightMarker.GetComponent<MeshRenderer>().enabled = !handsClose;
		objectRefrences.yellowMarker.GetComponent<MeshRenderer>().enabled = handsClose;
		if (gm.songPlaying)
		{
			if (leftCascadeTimer > 0f)
			{
				leftCascadeTimer -= Time.deltaTime;
				if (leftCascadeTimer <= 0f)
				{
					leftCascadeTimer = 0f;
					CascadeStart(leftHand: true);
				}
			}
			if (rightCascadeTimer > 0f)
			{
				rightCascadeTimer -= Time.deltaTime;
				if (rightCascadeTimer <= 0f)
				{
					rightCascadeTimer = 0f;
					CascadeStart(leftHand: false);
				}
			}
		}
		if (messagedelaytimer > 0f)
		{
			messagedelaytimer -= Time.deltaTime;
		}
		else if (messageQueue.Count > 0)
		{
			SpawnMessage(messageQueue[0]);
			messageQueue.RemoveAt(0);
			messagedelaytimer = messagedelay;
		}
	}

	public float GetCurrentTime()
	{
		if (gm.songPlaying)
		{
			return gm.songTime;
		}
		return (0f - (objectRefrences.songEditor.transform.localPosition.z + objectRefrences.songEditor.transform.parent.localPosition.z)) / objectRefrences.songEditor.unitsPerSecond;
	}

	public void Scrub()
	{
		if (gm.songPlaying)
		{
			gm.StopSong();
			objectRefrences.songEditor.scrollArea.scrollActive = true;
		}
		else
		{
			objectRefrences.songEditor.scrollArea.scrollActive = false;
			gm.Scrub((0f - (objectRefrences.songEditor.transform.localPosition.z + objectRefrences.songEditor.transform.parent.localPosition.z)) / objectRefrences.songEditor.unitsPerSecond);
			objectRefrences.songEditor.transform.parent.localPosition = new Vector3(objectRefrences.songEditor.transform.parent.localPosition.x, objectRefrences.songEditor.transform.parent.localPosition.y, 0f);
		}
	}

	public void SkipToStart()
	{
		SkipToSeconds(0f);
	}

	public void SkipToEnd()
	{
		SkipToSeconds(objectRefrences.songEditor.songDuration);
	}

	public void SkipToSeconds(float seconds)
	{
		objectRefrences.songEditor.scrollArea.ScrollToLocal(new Vector3(0f, 0f, (0f - seconds) * objectRefrences.songEditor.unitsPerSecond));
		objectRefrences.songEditor.transform.localPosition = new Vector3(objectRefrences.songEditor.transform.parent.localPosition.x, objectRefrences.songEditor.transform.parent.localPosition.y, 0f);
	}

	private void TouchpadClicked()
	{
		SwapTriggerMode();
	}

	public void SwapTriggerMode(TriggerMode? mode = null)
	{
		switch (mode)
		{
		case null:
			switch (triggerMode)
			{
			case TriggerMode.Select:
				if (multiSelectTimeSelect)
				{
					SwapTriggerMode(TriggerMode.TimeSelect);
				}
				else
				{
					SwapTriggerMode(TriggerMode.BoxSelect);
				}
				break;
			case TriggerMode.BoxSelect:
				SwapTriggerMode(TriggerMode.Add);
				break;
			case TriggerMode.TimeSelect:
				SwapTriggerMode(TriggerMode.Add);
				break;
			case TriggerMode.Add:
				SwapTriggerMode(TriggerMode.Select);
				break;
			}
			break;
		case TriggerMode.Select:
			triggerMode = TriggerMode.Select;
			DisplayMessage(singleSelectAdditive ? "Mode: Select (Additive)" : "Mode: Select");
			GameManager.instance.TogglePointers(toggle: true);
			objectRefrences.leftHandInfo.text = "Select";
			objectRefrences.rightHandInfo.text = "Select";
			break;
		case TriggerMode.BoxSelect:
			triggerMode = TriggerMode.BoxSelect;
			DisplayMessage("Mode: Multi-Select (Box)");
			GameManager.instance.TogglePointers(toggle: false);
			objectRefrences.leftHandInfo.text = "Multi-Select";
			objectRefrences.rightHandInfo.text = "Multi-Select";
			break;
		case TriggerMode.TimeSelect:
			triggerMode = TriggerMode.TimeSelect;
			DisplayMessage("Mode: Multi-Select (Time)");
			GameManager.instance.TogglePointers(toggle: false);
			objectRefrences.leftHandInfo.text = "Multi-Select";
			objectRefrences.rightHandInfo.text = "Multi-Select";
			break;
		case TriggerMode.Add:
			triggerMode = TriggerMode.Add;
			objectRefrences.songEditor.DeselectAllNodes();
			DisplayMessage("Mode: Add");
			GameManager.instance.TogglePointers(toggle: false);
			objectRefrences.leftHandInfo.text = "Add";
			objectRefrences.rightHandInfo.text = "Add";
			break;
		}
		objectRefrences.editTools.RefreshUI();
	}

	public void DisplayMessage(string message)
	{
		messageQueue.Add(message);
	}

	private void SpawnMessage(string message)
	{
		UnityEngine.Object.Instantiate(textPopupPrefab, GameManager.instance.objectRefrences.oculusCenter.position + GameManager.instance.objectRefrences.oculusCenter.forward * 0.8f + new Vector3(0f, -0.3f, 0f), Quaternion.identity).GetComponent<TextPopup>().SetText(message);
	}

	private void StartSelectCounter(bool leftDown)
	{
		if (!leftDragStart && !rightDragStart && !leftDragActive && !rightDragActive)
		{
			if (leftDown)
			{
				leftDragStart = true;
				DragStart(left: true);
			}
			else
			{
				rightDragStart = true;
				DragStart(left: false);
			}
		}
	}

	private void DragStart(bool left)
	{
		if (multiSelectTimeSelect)
		{
			if (left)
			{
				objectRefrences.leftArc.gameObject.SetActive(value: true);
				leftDragActive = true;
				leftDragStart = false;
			}
			else
			{
				objectRefrences.rightArc.gameObject.SetActive(value: true);
				rightDragActive = true;
				rightDragStart = false;
			}
			return;
		}
		selectionCube.gameObject.SetActive(value: true);
		if (left)
		{
			pointA.position = objectRefrences.leftController.transform.position;
			pointA.parent = objectRefrences.songEditor.transform;
			pointB.parent = objectRefrences.leftController.transform;
			pointB.localPosition = Vector3.zero;
			leftDragActive = true;
			leftDragStart = false;
		}
		else
		{
			pointA.position = objectRefrences.rightController.transform.position;
			pointA.parent = objectRefrences.songEditor.transform;
			pointB.parent = objectRefrences.rightController.transform;
			pointB.localPosition = Vector3.zero;
			rightDragActive = true;
			rightDragStart = false;
		}
	}

	private void StopDrag(bool left = true)
	{
		if (multiSelectTimeSelect)
		{
			float z;
			float resultZ;
			if (left)
			{
				z = objectRefrences.leftArc.transform.position.z;
				resultZ = objectRefrences.leftArc.resultZ;
			}
			else
			{
				z = objectRefrences.rightArc.transform.position.z;
				resultZ = objectRefrences.rightArc.resultZ;
			}
			if (z < resultZ)
			{
				SceneEditorNode[] array = UnityEngine.Object.FindObjectsOfType<SceneEditorNode>();
				foreach (SceneEditorNode sceneEditorNode in array)
				{
					if (sceneEditorNode.transform.position.z > z && sceneEditorNode.transform.position.z < resultZ)
					{
						sceneEditorNode.Select(multi: true);
					}
				}
			}
			else
			{
				SceneEditorNode[] array = UnityEngine.Object.FindObjectsOfType<SceneEditorNode>();
				foreach (SceneEditorNode sceneEditorNode2 in array)
				{
					if (sceneEditorNode2.transform.position.z < z && sceneEditorNode2.transform.position.z > resultZ)
					{
						sceneEditorNode2.Select(multi: true);
					}
				}
			}
			objectRefrences.leftArc.gameObject.SetActive(value: false);
			objectRefrences.rightArc.gameObject.SetActive(value: false);
		}
		else
		{
			Vector3 localScale = selectionCube.transform.localScale;
			Collider[] array2 = Physics.OverlapBox(halfExtents: new Vector3(Mathf.Abs(localScale.x), Mathf.Abs(localScale.y), Mathf.Abs(localScale.z)) * 0.5f, center: selectionCube.transform.position);
			foreach (Collider collider in array2)
			{
				if (collider.GetComponent<SceneEditorNode>() != null)
				{
					collider.GetComponent<SceneEditorNode>().Select(multi: true);
				}
			}
			selectionCube.gameObject.SetActive(value: false);
			pointA.parent = null;
			pointB.parent = null;
		}
		leftDragActive = false;
		rightDragActive = false;
		dragCounter = dragDelay;
		SwapTriggerMode(TriggerMode.Select);
	}

	private void TriggerReleased()
	{
	}

	private void TriggerClicked()
	{
	}

	private void CascadeStart(bool leftHand)
	{
		if (leftHand)
		{
			leftCascadeStartNode.cascade = true;
			for (int i = 0; i < leftCascadePositions.Count; i++)
			{
				Vector3 vector = leftCascadePositions[i];
				CreateNode(leftHand: true, cascade: true, null, new Vector3(vector.x, vector.y, objectRefrences.songEditor.transform.position.z + vector.z * objectRefrences.songEditor.unitsPerSecond));
			}
			leftCascade = true;
			UnityEngine.Debug.Log("Left Cascade Threshold met, retroactivley spawning " + leftCascadePositions.Count + " nodes.");
			DisplayMessage("Pink Cascade");
			leftCascadePositions.Clear();
		}
		else
		{
			rightCascadeStartNode.cascade = true;
			for (int j = 0; j < rightCascadePositions.Count; j++)
			{
				Vector3 vector2 = rightCascadePositions[j];
				CreateNode(leftHand: false, cascade: true, null, new Vector3(vector2.x, vector2.y, objectRefrences.songEditor.transform.position.z + vector2.z * objectRefrences.songEditor.unitsPerSecond));
			}
			rightCascade = true;
			UnityEngine.Debug.Log("Right Cascade Threshold met, retroactivley spawning " + rightCascadePositions.Count + " nodes.");
			DisplayMessage("Green Cascade");
			rightCascadePositions.Clear();
		}
	}

	private void CascadeFinish(bool leftHand)
	{
		if (gm.songPlaying)
		{
			if (leftHand && leftCascade)
			{
				CreateNode(leftHand: true, cascade: false, NodeType.PinkCascadeEnd);
				leftCascade = false;
				StopCoroutine(CreateLeftCascadeNodes());
			}
			else if (!leftHand && rightCascade)
			{
				CreateNode(leftHand: false, cascade: false, NodeType.GreenCascadeEnd);
				rightCascade = false;
				StopCoroutine(CreateRightCascadeNodes());
			}
		}
	}

	private IEnumerator CreateLeftCascadeNodes()
	{
		yield return new WaitForSeconds(cascadeInterval);
	}

	private IEnumerator CreateRightCascadeNodes()
	{
		yield return new WaitForSeconds(cascadeInterval);
	}

	private void ButtonOneDown()
	{
		TogglePlayPause();
	}

	public void TogglePlayPause()
	{
		DisplayMessage(gm.songPlaying ? "Pause" : "Play");
		if (gm.songPlaying)
		{
			SwapTriggerMode(TriggerMode.Select);
		}
		else
		{
			SwapTriggerMode(TriggerMode.Add);
		}
		CascadeFinish(leftHand: true);
		CascadeFinish(leftHand: false);
		lastSpawnedNode = null;
		StartSong();
		Scrub();
	}

	public void SaveDance()
	{
		if (float.TryParse(objectRefrences.bpmInput.text, out var result))
		{
			objectRefrences.songEditor.currentSong.BPM = result;
			if (float.TryParse(objectRefrences.offsetInput.text, out var result2))
			{
				objectRefrences.songEditor.currentSong.firstBeatBuffer = result2;
				objectRefrences.songEditor.currentSong.title1 = objectRefrences.title1Input.text;
				objectRefrences.songEditor.currentSong.title2 = objectRefrences.title2Input.text;
				objectRefrences.songEditor.currentSong.title3 = objectRefrences.title3Input.text;
				objectRefrences.songEditor.currentSong._arena = GetArenaString(objectRefrences.arenaDropdown.value);
				objectRefrences.songEditor.SaveDance();
			}
			else
			{
				DisplayMessage("Can't save: Invalid BPM");
			}
		}
		else
		{
			DisplayMessage("Can't save: Invalid BPM");
		}
	}

	public void SetFileInput_NoDifficulty(string filename)
	{
		objectRefrences.filenameInput.text = filename;
	}

	public void SetAdditiveSelect()
	{
		singleSelectAdditive = objectRefrences.additiveToggle.isOn;
		DisplayMessage("Additive single select: " + (singleSelectAdditive ? "On" : "Off"));
	}

	public void SetTimeSelect()
	{
		multiSelectTimeSelect = objectRefrences.timeSelectToggle.isOn;
		DisplayMessage("Multi select mode: " + (multiSelectTimeSelect ? "Time Select" : "Box Select"));
	}

	public void SetHoldCascades()
	{
		holdForCascades = objectRefrences.holdForCascadesToggle.isOn;
		DisplayMessage("Cascades: " + (holdForCascades ? "Enabled" : "Disabled"));
	}

	public void SetLoadArena()
	{
		loadBackgroundArena = objectRefrences.loadBackgroundArenaToggle.isOn;
		if (loadBackgroundArena)
		{
			LoadBackground();
		}
		else
		{
			UnLoadBackground();
		}
		DisplayMessage("Background: " + (loadBackgroundArena ? "Enabled" : "Disabled"));
	}

	public void LoadDance()
	{
		Persistence.instance.currentSongFilename = objectRefrences.filenameInput.text;
		objectRefrences.songEditor.DeselectAllNodes();
		gm.LoadDance();
		objectRefrences.songEditor.filename = Persistence.instance.currentSongFilename;
		objectRefrences.songEditor.Clear();
		objectRefrences.songEditor.LoadDance();
		objectRefrences.mainScrollArea.Reset();
		objectRefrences.musicText.text = GetCleanMusicString(objectRefrences.songEditor.currentSong._music);
		if (objectRefrences.songEditor.currentSong._music.StartsWith("%"))
		{
			gm.GetComponent<AudioSource>().clip = gm.GetAudioClipFromMusicString(gm.currentSong._music);
		}
		objectRefrences.bpmInput.text = objectRefrences.songEditor.currentSong.BPM.ToString();
		objectRefrences.offsetInput.text = objectRefrences.songEditor.currentSong.firstBeatBuffer.ToString();
		objectRefrences.title1Input.text = objectRefrences.songEditor.currentSong.title1;
		objectRefrences.title2Input.text = objectRefrences.songEditor.currentSong.title2;
		objectRefrences.title3Input.text = objectRefrences.songEditor.currentSong.title3;
		objectRefrences.arenaDropdown.value = GetArenaIndex(objectRefrences.songEditor.currentSong._arena);
	}

	public void NewDance()
	{
		if (!loading)
		{
			if (objectRefrences.filenameInput.text == "")
			{
				DisplayMessage("Enter a filename to create a dance!");
				return;
			}
			if (File.Exists(UnityEngine.Application.dataPath + "/StreamingAssets/Custom/Dances/" + objectRefrences.filenameInput.text + ".json"))
			{
				DisplayMessage("Can't create new dance! " + objectRefrences.filenameInput.text + ".json already exists!");
				return;
			}
			if (objectRefrences.songEditor.transform.childCount - 2 != 0)
			{
				DisplayMessage("Clear your song before making a new one!");
				return;
			}
			objectRefrences.songEditor.currentSong.BPM = 145f;
			objectRefrences.songEditor.currentSong.firstBeatBuffer = 0f;
			objectRefrences.songEditor.currentSong.title1 = "";
			objectRefrences.songEditor.currentSong.title2 = objectRefrences.filenameInput.text;
			objectRefrences.songEditor.currentSong.title3 = "Custom Song";
			objectRefrences.songEditor.currentSong._arena = "Practice_Arena_New";
			objectRefrences.songEditor.SaveDance();
			LoadDance();
		}
	}

	public void SetLoading(bool _loading)
	{
		loading = _loading;
		objectRefrences.saveButton.interactable = !loading;
		objectRefrences.loadButton.interactable = !loading;
		objectRefrences.clearButton.interactable = !loading;
		objectRefrences.testButton.interactable = !loading;
		objectRefrences.newButton.interactable = !loading;
	}

	public string GetCleanMusicString(string input)
	{
		if (input.StartsWith("#"))
		{
			return soundtrackNames[int.Parse(input.Substring(1))];
		}
		if (input.StartsWith("%"))
		{
			return input.Substring(1);
		}
		return "invalid";
	}

	public void ClearDance()
	{
		gm.currentSong.nodes.Clear();
		objectRefrences.songEditor.Clear();
		objectRefrences.mainScrollArea.Reset();
		HandsInScrollAreas = 0;
	}

	private SceneEditorNode CreateNode(bool leftHand, bool cascade = false, NodeType? type = null, Vector3? pos = null)
	{
		Vector3 vector = (pos.HasValue ? pos.Value : ((!gm.songPlaying) ? (leftHand ? gm.objectRefrences.leftController.transform.position : gm.objectRefrences.rightController.transform.position) : (leftHand ? new Vector3(gm.objectRefrences.leftController.transform.position.x, gm.objectRefrences.leftController.transform.position.y, gm.objectRefrences.beatPoint.position.z) : new Vector3(gm.objectRefrences.rightController.transform.position.x, gm.objectRefrences.rightController.transform.position.y, gm.objectRefrences.beatPoint.position.z))));
		if (lastSpawnedNode != null && gm.songPlaying && Vector3.Distance(vector, lastSpawnedNode.transform.position) < 0.15f && !leftCascade && !rightCascade && ((lastSpawnedNode.type == NodeType.Green && leftHand) || (lastSpawnedNode.type == NodeType.Pink && !leftHand)))
		{
			Vector3 position = (vector + lastSpawnedNode.transform.position) / 2f;
			UnityEngine.Object.Destroy(lastSpawnedNode.gameObject);
			SceneEditorNode component = UnityEngine.Object.Instantiate(objectRefrences.songEditor.sceneEditorNode, position, Quaternion.identity).GetComponent<SceneEditorNode>();
			component.transform.parent = objectRefrences.songEditor.transform;
			component.type = NodeType.Yellow;
			component.cascade = false;
			component.editor = objectRefrences.songEditor;
			component.UpdateValues();
			lastSpawnedNode = component;
			return component;
		}
		SceneEditorNode component2 = UnityEngine.Object.Instantiate(objectRefrences.songEditor.sceneEditorNode, vector, Quaternion.identity).GetComponent<SceneEditorNode>();
		component2.transform.parent = objectRefrences.songEditor.transform;
		component2.type = (type ?? new NodeType?(leftHand ? NodeType.Pink : NodeType.Green)).Value;
		component2.path = "Default";
		component2.cascade = cascade;
		component2.editor = objectRefrences.songEditor;
		component2.UpdateValues();
		lastSpawnedNode = component2;
		return component2;
	}

	public void GetColliders()
	{
		objectRefrences.browser.SetActive(value: true);
		foreach (Transform item in objectRefrences.browserButton.transform.parent)
		{
			if (item.gameObject.activeSelf)
			{
				UnityEngine.Object.Destroy(item.gameObject);
			}
		}
		FileInfo[] files = new DirectoryInfo(UnityEngine.Application.dataPath + "/StreamingAssets/Custom/Dances").GetFiles();
		foreach (FileInfo fileInfo in files)
		{
			if (fileInfo.Extension == ".json")
			{
				GameObject gameObject = UnityEngine.Object.Instantiate(objectRefrences.browserButton, objectRefrences.browserButton.transform.parent);
				string fileName = fileInfo.Name.Split('.')[0];
				gameObject.GetComponentInChildren<TextMeshProUGUI>().text = fileName;
				gameObject.GetComponentInChildren<Button>().onClick.AddListener(delegate
				{
					SetFilenameInput(fileName);
				});
				gameObject.SetActive(value: true);
			}
		}
		objectRefrences.browserPathText.text = ".../Custom/Dances";
		objectRefrences.browserExplorerText.SetActive(value: false);
		objectRefrences.browserExplorerButton.SetActive(value: true);
	}

	public void GetLocalAudio()
	{
		objectRefrences.browser.SetActive(value: true);
		foreach (Transform item in objectRefrences.browserButton.transform.parent)
		{
			if (item.gameObject.activeSelf)
			{
				UnityEngine.Object.Destroy(item.gameObject);
			}
		}
		FileInfo[] files = new DirectoryInfo(UnityEngine.Application.dataPath + "/StreamingAssets/Custom/Music").GetFiles();
		foreach (FileInfo file in files)
		{
			if (file.Extension == ".wav" || file.Extension == ".mp3" || file.Extension == ".ogg")
			{
				GameObject obj = UnityEngine.Object.Instantiate(objectRefrences.browserButton, objectRefrences.browserButton.transform.parent);
				obj.GetComponentInChildren<TextMeshProUGUI>().text = file.Name;
				obj.GetComponentInChildren<Button>().onClick.AddListener(delegate
				{
					SetCustomAudioInput(file.Name);
				});
				obj.SetActive(value: true);
			}
		}
		objectRefrences.browserPathText.text = ".../Custom/Music";
		objectRefrences.browserExplorerText.SetActive(value: false);
		objectRefrences.browserExplorerButton.SetActive(value: true);
	}

	public void GetSoundtrackAudio()
	{
		objectRefrences.browser.SetActive(value: true);
		foreach (Transform item in objectRefrences.browserButton.transform.parent)
		{
			if (item.gameObject.activeSelf)
			{
				UnityEngine.Object.Destroy(item.gameObject);
			}
		}
		for (int i = 0; i < soundtrackNames.Length; i++)
		{
			string text = soundtrackNames[i];
			int copy = i;
			GameObject obj = UnityEngine.Object.Instantiate(objectRefrences.browserButton, objectRefrences.browserButton.transform.parent);
			UnityEngine.Debug.Log("Spawned ui: " + text + " | " + copy);
			obj.GetComponentInChildren<TextMeshProUGUI>().text = text;
			obj.GetComponentInChildren<Button>().onClick.AddListener(delegate
			{
				SetSoundtrackAudioInput(copy);
			});
			obj.SetActive(value: true);
		}
		objectRefrences.browserPathText.text = "Official Soundtrack";
		objectRefrences.browserExplorerText.SetActive(value: false);
		objectRefrences.browserExplorerButton.SetActive(value: false);
	}

	public void SetFilenameInput(string input)
	{
		objectRefrences.filenameInput.text = input;
	}

	public void SetCustomAudioInput(string input)
	{
		objectRefrences.songEditor.currentSong._music = "%" + input;
		gm.currentSong._music = "%" + input;
		objectRefrences.musicText.text = input;
		gm.GetComponent<AudioSource>().clip = gm.GetAudioClipFromMusicString(gm.currentSong._music);
	}

	public void SetSoundtrackAudioInput(int input)
	{
		UnityEngine.Debug.Log("Setting soundtrack audio input with index of " + input);
		objectRefrences.songEditor.currentSong._music = "#" + input;
		gm.currentSong._music = "#" + input;
		gm.musicNum = input;
		objectRefrences.musicText.text = soundtrackNames[input];
	}

	public string GetArenaString(int arenaIndex)
	{
		switch (arenaIndex)
		{
		case 0:
			return "Practice_Arena_New";
		case 1:
			return "Yuri_Arena_New";
		case 2:
			return "Pyro_Arena_New";
		case 3:
			return "Lais_Arena_New";
		case 4:
			return "Dre_Arena_New";
		case 5:
			return "Liu_Arena_New";
		case 6:
			return "Remi_Arena_New";
		case 7:
			return "Sonya_Arena_New";
		case 8:
			return "Core_Arena_New";
		default:
			UnityEngine.Debug.LogError("Invalid arenaIndex!");
			return "";
		}
	}

	public int GetArenaIndex(string arenaString)
	{
		switch (arenaString)
		{
		case "Arena #8 (Generic)":
		case "Practice_Arena_New":
			return 0;
		case "Arena #1 (Yuri)":
		case "Yuri_Arena_New":
			return 1;
		case "Arena #0 (Pyro)":
		case "Pyro_Arena_New":
			return 2;
		case "Arena #2 (Lais)":
		case "Lais_Arena_New":
			return 3;
		case "Arena #5 (Dre)":
		case "Dre_Arena_New":
			return 4;
		case "Arena #4 (LiuWen)":
		case "Liu_Arena_New":
			return 5;
		case "Arena #3 (Remi)":
		case "Remi_Arena_New":
			return 6;
		case "Arena #6 (Sonya)":
		case "Sonya_Arena_New":
			return 7;
		case "Arena #7 (Core)":
		case "Core_Arena_New":
			return 8;
		default:
			UnityEngine.Debug.LogError("Invalid arenaString!");
			return 0;
		}
	}

	public void OpenCustomInWindowsExplorer()
	{
		string text = UnityEngine.Application.streamingAssetsPath + "/Custom/";
		text = text.Replace("/", "\\");
		UnityEngine.Debug.Log("Running command /root,\"" + text + "\"");
		Process.Start("explorer.exe", "/root,\"" + text + "\"");
	}

	public void Cut()
	{
		CopySelectedNodes();
		objectRefrences.nodeSettingsUI.DeleteNode();
	}

	public void Copy()
	{
		CopySelectedNodes();
	}

	public void Paste()
	{
		PasteNodesFromClipboard();
	}

	private void CopySelectedNodes()
	{
		if (objectRefrences.songEditor.selectedNodes.Count == 0)
		{
			return;
		}
		ClearClipboard();
		foreach (SceneEditorNode selectedNode in objectRefrences.songEditor.selectedNodes)
		{
			SceneEditorNode component = UnityEngine.Object.Instantiate(objectRefrences.songEditor.sceneEditorNode, Vector3.zero, Quaternion.identity).GetComponent<SceneEditorNode>();
			component.transform.parent = clipboard_Object.transform;
			component.type = selectedNode.type;
			component.path = selectedNode.path;
			component.cascade = selectedNode.cascade;
			component.editor = objectRefrences.songEditor;
			component.beatTime = selectedNode.beatTime;
			component.offset = selectedNode.offset;
			component.set = selectedNode.set;
			component.gameObject.SetActive(value: false);
			clipboard.Add(component);
		}
	}

	private void PasteNodesFromClipboard()
	{
		if (clipboard.Count == 0)
		{
			return;
		}
		objectRefrences.songEditor.DeselectAllNodes();
		float num = clipboard.Min((SceneEditorNode p) => p.beatTime);
		foreach (SceneEditorNode item in clipboard)
		{
			SceneEditorNode component = UnityEngine.Object.Instantiate(objectRefrences.songEditor.sceneEditorNode, Vector3.zero, Quaternion.identity).GetComponent<SceneEditorNode>();
			component.transform.parent = objectRefrences.songEditor.transform;
			component.type = item.type;
			component.path = item.path;
			component.cascade = item.cascade;
			component.editor = objectRefrences.songEditor;
			component.beatTime = item.beatTime;
			component.offset = item.offset;
			component.set = item.set;
			component.transform.position = new Vector3(component.offset.x, gm.objectRefrences.beatPoint.transform.position.y + component.offset.y, (gm.objectRefrences.beatPoint.transform.position.z + (component.beatTime - num)) * objectRefrences.songEditor.unitsPerSecond);
			component.UpdateValues();
			component.Select(multi: true);
		}
	}

	private void ClearClipboard()
	{
		for (int i = 0; i < clipboard.Count; i++)
		{
			UnityEngine.Object.Destroy(clipboard[i].gameObject);
		}
		clipboard.Clear();
	}
}
public class PlayPoint : MonoBehaviour
{
	public void UpdatePlayPoint()
	{
		base.transform.localPosition = new Vector3(0f, 0f, Mathf.Max(0f, base.transform.localPosition.z));
		base.transform.parent.GetComponent<SongEditor>().playBackTime = base.transform.localPosition.z;
	}
}
public class SceneEditorNode : MonoBehaviour
{
	public SongEditor editor;

	public NodeType type;

	public float beatTime;

	public Vector2 offset;

	public string path;

	public bool set;

	public bool cascade;

	public float holoLight = -2f;

	public int holoNum = -1;

	public int danceID = -1;

	public float bufferOverride;

	public int minDifficulty;

	public Material green;

	public Material red;

	public Material yellow;

	public Material utility;

	public TauntInfo tauntInfo;

	public List<string> lightPayloads;

	public bool selected;

	public ControllerScrollArea scrollXY;

	public ControllerScrollArea scrollZpos;

	public ControllerScrollArea scrollZneg;

	private Outline outline;

	private MeshRenderer mesh;

	public Mesh sphere_mesh;

	public Mesh triangle_mesh;

	public Mesh cube_mesh;

	public SpriteRenderer Arrow_Right_1;

	public SpriteRenderer Arrow_Right_2;

	public SpriteRenderer Arrow_Left_1;

	public SpriteRenderer Arrow_Left_2;

	public SpriteRenderer Set_Icon;

	public SpriteRenderer Cascade_Icon;

	public TextMeshPro utilityText;

	public GameObject ui_root;

	private Collider col;

	private readonly float visibilityThreshold = 35f;

	public void Init()
	{
		DisableAllUI();
		mesh = GetComponent<MeshRenderer>();
		switch (type)
		{
		case NodeType.Green:
			mesh.material = green;
			GetComponent<MeshFilter>().mesh = sphere_mesh;
			base.transform.localScale = Vector3.one * 0.2f;
			Set_Icon.color = Color.green;
			Cascade_Icon.color = Color.green;
			break;
		case NodeType.Pink:
			mesh.material = red;
			GetComponent<MeshFilter>().mesh = sphere_mesh;
			base.transform.localScale = Vector3.one * 0.2f;
			Set_Icon.color = new Color(1f, 0f, 1f);
			Cascade_Icon.color = new Color(1f, 0f, 1f);
			break;
		case NodeType.Yellow:
			mesh.material = yellow;
			GetComponent<MeshFilter>().mesh = triangle_mesh;
			base.transform.localScale = Vector3.one * 0.3f;
			break;
		case NodeType.GreenCascadeEnd:
			utilityText.color = Color.green;
			SetToUtilityCube("Green Cascade End");
			break;
		case NodeType.PinkCascadeEnd:
			utilityText.color = new Color(1f, 0f, 1f);
			SetToUtilityCube("Pink Cascade End");
			break;
		case NodeType.TauntStart:
			SetToUtilityCube("Taunt Start");
			break;
		case NodeType.HoloLight:
			SetToUtilityCube("Hologram");
			break;
		case NodeType.MirageGreen:
			SetToUtilityCube();
			break;
		case NodeType.MiragePink:
			SetToUtilityCube();
			break;
		case NodeType.SetEnd:
			SetToUtilityCube("Set End");
			break;
		case NodeType.LeftChannel:
			SetToUtilityCube("Arrows Left");
			Arrow_Right_1.gameObject.SetActive(value: true);
			Arrow_Right_2.gameObject.SetActive(value: true);
			break;
		case NodeType.Midchannel:
			SetToUtilityCube("Arrows Center");
			Arrow_Left_1.gameObject.SetActive(value: true);
			Arrow_Right_1.gameObject.SetActive(value: true);
			break;
		case NodeType.RightChannel:
			SetToUtilityCube("Arrows Right");
			Arrow_Left_1.gameObject.SetActive(value: true);
			Arrow_Left_2.gameObject.SetActive(value: true);
			break;
		}
		if (path == null)
		{
			path = "Default";
		}
		string text = "";
		if (set)
		{
			text += "(S) ";
			if (!UI_NodeSettings.IsUtilityType(type))
			{
				Set_Icon.gameObject.SetActive(value: true);
			}
		}
		if (cascade)
		{
			text += "(C) ";
			if (!UI_NodeSettings.IsUtilityType(type))
			{
				Cascade_Icon.gameObject.SetActive(value: true);
			}
		}
		base.gameObject.name = text + type.ToString() + ": " + beatTime.ToString("F2");
		col = GetComponent<Collider>();
		outline = GetComponent<Outline>();
	}

	private void SetToUtilityCube(string text = "Utility")
	{
		mesh.material = utility;
		GetComponent<MeshFilter>().mesh = cube_mesh;
		base.transform.localScale = Vector3.one * 0.1f;
		utilityText.gameObject.SetActive(value: true);
		utilityText.text = text;
	}

	private void Update()
	{
		if (base.transform.position.z > visibilityThreshold || base.transform.position.z < 0f - visibilityThreshold)
		{
			mesh.enabled = false;
			ui_root.SetActive(value: false);
		}
		else
		{
			mesh.enabled = true;
			ui_root.SetActive(value: true);
		}
	}

	public void DisableAllUI()
	{
		Arrow_Left_1.gameObject.SetActive(value: false);
		Arrow_Left_2.gameObject.SetActive(value: false);
		Arrow_Right_1.gameObject.SetActive(value: false);
		Arrow_Right_2.gameObject.SetActive(value: false);
		Set_Icon.gameObject.SetActive(value: false);
		Cascade_Icon.gameObject.SetActive(value: false);
		utilityText.gameObject.SetActive(value: false);
		utilityText.color = Color.white;
	}

	public void LeftTriggerDown()
	{
	}

	public void RightTriggerDown()
	{
	}

	public void Delete()
	{
		UnityEngine.Object.Destroy(base.gameObject);
	}

	public void Select(bool multi = false)
	{
		if (selected)
		{
			editor.DeselectNode(this);
			return;
		}
		if (!multi && !EditorManager.instance.singleSelectAdditive)
		{
			editor.DeselectAllNodes();
		}
		editor.SelectNode(this);
		selected = true;
		ControllerScrollArea[] componentsInChildren = GetComponentsInChildren<ControllerScrollArea>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			componentsInChildren[i].scrollActive = true;
		}
		TriggerObjectEnabler[] componentsInChildren2 = GetComponentsInChildren<TriggerObjectEnabler>();
		for (int j = 0; j < componentsInChildren2.Length; j++)
		{
			componentsInChildren2[j].enabled = true;
		}
		GetComponentInChildren<LookAt_PerAxis>().enabled = true;
		SelectedHighlight();
	}

	public void Deselect()
	{
		selected = false;
		ClearScrollAreas();
		ControllerScrollArea[] componentsInChildren = GetComponentsInChildren<ControllerScrollArea>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			componentsInChildren[i].scrollActive = false;
		}
		TriggerObjectEnabler[] componentsInChildren2 = GetComponentsInChildren<TriggerObjectEnabler>();
		foreach (TriggerObjectEnabler triggerObjectEnabler in componentsInChildren2)
		{
			for (int k = 0; k < triggerObjectEnabler.objects.Count; k++)
			{
				triggerObjectEnabler.objects[k].SetActive(value: false);
			}
			triggerObjectEnabler.enabled = false;
		}
		GetComponentInChildren<LookAt_PerAxis>().enabled = false;
		SelectedHighlight(on: false);
	}

	private void SelectedHighlight(bool on = true)
	{
		outline.OutlineColor = Color.white;
		outline.enabled = on;
		outline.OutlineWidth = 2.5f;
	}

	public void Highlight(bool on = true)
	{
		if (!selected)
		{
			outline.OutlineWidth = 1f;
			outline.OutlineColor = new Color(0.6f, 0.6f, 0.6f, 0.6f);
			outline.enabled = on;
		}
	}

	[Obsolete]
	public void LinkScrollAreas(SceneEditorNode node)
	{
		UnityEngine.Debug.Log(base.name + " is linking to " + node.name);
		scrollXY.linkedScrollers.Add(node.scrollXY);
		node.scrollXY.linked = true;
		scrollZpos.linkedScrollers.Add(node.scrollZpos);
		node.scrollZpos.linked = true;
		scrollZneg.linkedScrollers.Add(node.scrollZneg);
		node.scrollZneg.linked = true;
	}

	public void ClearScrollAreas()
	{
		ControllerScrollArea[] componentsInChildren = GetComponentsInChildren<ControllerScrollArea>();
		foreach (ControllerScrollArea controllerScrollArea in componentsInChildren)
		{
			foreach (ControllerScrollArea linkedScroller in controllerScrollArea.linkedScrollers)
			{
				linkedScroller.linked = false;
			}
			controllerScrollArea.linkedScrollers.Clear();
			controllerScrollArea.grabState = ControllerScrollArea.GrabbedState.None;
		}
	}

	public void SetExclusiveScrollAreas(bool set = true)
	{
		ControllerScrollArea[] componentsInChildren = GetComponentsInChildren<ControllerScrollArea>();
		foreach (ControllerScrollArea controllerScrollArea in componentsInChildren)
		{
			controllerScrollArea.exclusiveScrollAreas.Clear();
			if (set)
			{
				controllerScrollArea.exclusiveScrollAreas.Add(EditorManager.instance.objectRefrences.mainScrollArea);
			}
		}
	}

	public void UpdateValues()
	{
		beatTime = base.transform.localPosition.z / editor.unitsPerSecond;
		offset = new Vector2(base.transform.localPosition.x, base.transform.localPosition.y);
		Init();
	}

	private void OnDrawGizmosSelected()
	{
	}

	public void SnapToNearestBeat()
	{
		Snap(1f);
		UpdateValues();
	}

	public void SnapToNearestHalfBeat()
	{
		Snap(2f);
		UpdateValues();
	}

	public void SnapToNearestQuarterBeat()
	{
		Snap(4f);
		UpdateValues();
	}

	private void Snap(float interval)
	{
		base.transform.localPosition = new Vector3(base.transform.localPosition.x, base.transform.localPosition.y, Mathf.Round(base.transform.localPosition.z / (editor.secondsPerBeat * editor.unitsPerSecond / interval)) * (editor.secondsPerBeat * editor.unitsPerSecond / interval) + editor.firstBeatBuffer * editor.unitsPerSecond);
	}

	private List<string> GetEditorPathList()
	{
		List<string> list = new List<string>();
		list.Add("Default");
		foreach (GameManager.NodePath path in UnityEngine.Object.FindObjectOfType<GameManager>().paths)
		{
			list.Add(path.name);
		}
		return list;
	}
}
[RequireComponent(typeof(AudioSource))]
public class SongEditor : MonoBehaviour
{
	public enum DifficultySelect
	{
		Easy,
		Normal,
		Hard
	}

	public Song currentSong;

	public string filename = "testSong";

	public float playBackTime;

	private readonly bool TheTruth = true;

	private bool playingBack;

	private float startZ;

	private float dspSongStartTime;

	private float startPlaybackTime;

	public float unitsPerSecond = 1f;

	public GameObject sceneEditorNode;

	public float BPM;

	public float firstBeatBuffer;

	public float songDuration;

	public Transform playBackPoint;

	public DifficultySelect difficulty;

	private bool saveError;

	private bool loadError;

	[HideInInspector]
	public float secondsPerBeat;

	[HideInInspector]
	public float totalbeats;

	public List<SceneEditorNode> selectedNodes;

	public ControllerScrollArea scrollArea;

	public int MAX_SPAWN_BATCH_MILLISECONDS = 2;

	public bool useIncrementalLoad = true;

	public LineRenderer line;

	public int num_beats_on_line = 20;

	public Color lineBaseColour;

	public float lineOpacityStart;

	public float lineOpacityEnd;

	public float lineWidth;

	public float majorBeatSize;

	public float halfBeatSize;

	private List<LineRenderer> lines = new List<LineRenderer>();

	private LineRenderer mainLine;

	public Transform lineParent;

	public Material lineMaterial;

	public void Load()
	{
		LoadDance();
	}

	public void Save()
	{
		SaveDance();
	}

	public void Clear()
	{
		RemoveEditorNodes();
		currentSong.nodes.Clear();
	}

	public bool HasNoChildren()
	{
		return base.transform.childCount <= 2;
	}

	public void StartPlayback()
	{
		dspSongStartTime = (float)AudioSettings.dspTime;
		startPlaybackTime = playBackTime;
		GetComponent<AudioSource>().timeSamples = TimeToSamples(playBackTime);
		GetComponent<AudioSource>().Play();
		playingBack = true;
		startZ = base.transform.position.z;
	}

	public void EndPlayback()
	{
		GetComponent<AudioSource>().Stop();
		playingBack = false;
		playBackPoint.GetComponent<PlayPoint>().UpdatePlayPoint();
	}

	private void CheckPlayback()
	{
		if (playingBack)
		{
			base.transform.localPosition = new Vector3(0f, 0f, (0f - GameManager.instance.songTime) * unitsPerSecond);
		}
	}

	private float GetSongTime()
	{
		return (float)(AudioSettings.dspTime - (double)dspSongStartTime) + startPlaybackTime;
	}

	private int TimeToSamples(float time)
	{
		return Mathf.CeilToInt(time * (float)AudioSettings.outputSampleRate);
	}

	private float SamplesToTime(int samples)
	{
		return (float)samples / ((float)AudioSettings.outputSampleRate * 1f);
	}

	private void SnapAllToHalfBeat()
	{
		foreach (Transform item in base.transform)
		{
			SceneEditorNode component = item.GetComponent<SceneEditorNode>();
			if (component != null)
			{
				component.SnapToNearestHalfBeat();
			}
		}
	}

	public void SetBPM(float bpm)
	{
		BPM = bpm;
		secondsPerBeat = 60f / BPM;
		totalbeats = Mathf.CeilToInt(songDuration / secondsPerBeat);
		SetUpNewLine();
		EditorManager.instance.DisplayMessage("BPM set to: " + bpm);
	}

	private string GetDifficultyString(DifficultySelect diff)
	{
		return diff switch
		{
			DifficultySelect.Easy => "_Easy", 
			DifficultySelect.Normal => "_Normal", 
			DifficultySelect.Hard => "_Hard", 
			_ => "_Hard", 
		};
	}

	private void LoadYuri1()
	{
		filename = "Arcade_Yuri_1" + GetDifficultyString(difficulty);
		Clear();
		LoadDance();
	}

	private void LoadYuri2()
	{
		filename = "Arcade_Yuri_2" + GetDifficultyString(difficulty);
		Clear();
		LoadDance();
	}

	private void LoadYuri3()
	{
		filename = "Arcade_Yuri_3" + GetDifficultyString(difficulty);
		Clear();
		LoadDance();
	}

	private void LoadPyro1()
	{
		filename = "Arcade_Pyro_1" + GetDifficultyString(difficulty);
		Clear();
		LoadDance();
	}

	private void LoadPyro2()
	{
		filename = "Arcade_Pyro_2" + GetDifficultyString(difficulty);
		Clear();
		LoadDance();
	}

	private void LoadPyro3()
	{
		filename = "Arcade_Pyro_3" + GetDifficultyString(difficulty);
		Clear();
		LoadDance();
	}

	private void LoadLais1()
	{
		filename = "Arcade_Lais_1" + GetDifficultyString(difficulty);
		Clear();
		LoadDance();
	}

	private void LoadLais2()
	{
		filename = "Arcade_Lais_2" + GetDifficultyString(difficulty);
		Clear();
		LoadDance();
	}

	private void LoadLais3()
	{
		filename = "Arcade_Lais_3" + GetDifficultyString(difficulty);
		Clear();
		LoadDance();
	}

	private void LoadRemi1()
	{
		filename = "Arcade_Remi_1" + GetDifficultyString(difficulty);
		Clear();
		LoadDance();
	}

	private void LoadRemi2()
	{
		filename = "Arcade_Remi_2" + GetDifficultyString(difficulty);
		Clear();
		LoadDance();
	}

	private void LoadRemi3()
	{
		filename = "Arcade_Remi_3" + GetDifficultyString(difficulty);
		Clear();
		LoadDance();
	}

	private void LoadLiu1()
	{
		filename = "Arcade_Liu_1" + GetDifficultyString(difficulty);
		Clear();
		LoadDance();
	}

	private void LoadLiu2()
	{
		filename = "Arcade_Liu_2" + GetDifficultyString(difficulty);
		Clear();
		LoadDance();
	}

	private void LoadLiu3()
	{
		filename = "Arcade_Liu_3" + GetDifficultyString(difficulty);
		Clear();
		LoadDance();
	}

	private void LoadDre1()
	{
		filename = "Arcade_Dre_1" + GetDifficultyString(difficulty);
		Clear();
		LoadDance();
	}

	private void LoadDre2()
	{
		filename = "Arcade_Dre_2" + GetDifficultyString(difficulty);
		Clear();
		LoadDance();
	}

	private void LoadDre3()
	{
		filename = "Arcade_Dre_3" + GetDifficultyString(difficulty);
		Clear();
		LoadDance();
	}

	private void LoadSonya1()
	{
		filename = "Arcade_Sonya_1" + GetDifficultyString(difficulty);
		Clear();
		LoadDance();
	}

	private void LoadSonya2()
	{
		filename = "Arcade_Sonya_2" + GetDifficultyString(difficulty);
		Clear();
		LoadDance();
	}

	private void LoadSonya3()
	{
		filename = "Arcade_Sonya_3" + GetDifficultyString(difficulty);
		Clear();
		LoadDance();
	}

	private void LoadCore1()
	{
		filename = "Arcade_Core_1" + GetDifficultyString(difficulty);
		Clear();
		LoadDance();
	}

	private void LoadCore2()
	{
		filename = "Arcade_Core_2" + GetDifficultyString(difficulty);
		Clear();
		LoadDance();
	}

	private void LoadCore3()
	{
		filename = "Arcade_Core_3" + GetDifficultyString(difficulty);
		Clear();
		LoadDance();
	}

	private void Start()
	{
		secondsPerBeat = 60f / BPM;
		totalbeats = Mathf.CeilToInt(songDuration / secondsPerBeat);
	}

	private void Update()
	{
		CheckPlayback();
		UpdateLines();
	}

	public void SaveDance()
	{
		if (EditorManager.instance.loading)
		{
			UnityEngine.Debug.Log("Can't save... wait for load to finish");
			return;
		}
		SaveEditorNodesToLocalSong();
		filename = EditorManager.instance.objectRefrences.filenameInput.text;
		if (filename == "")
		{
			saveError = true;
			EditorManager.instance.DisplayMessage("Can't save, no filename");
			return;
		}
		File.WriteAllText(GetDanceFilePath(filename), JsonUtility.ToJson(currentSong, prettyPrint: true));
		EditorManager.instance.DisplayMessage("Saving " + filename);
		currentSong.SortNodes();
		saveError = false;
		loadError = false;
	}

	public void LoadDance()
	{
		if (EditorManager.instance.loading)
		{
			UnityEngine.Debug.Log("Can't load... already loading!");
			return;
		}
		string danceFilePath = GetDanceFilePath(filename);
		UnityEngine.Debug.Log("Loading song - " + filename);
		if (File.Exists(danceFilePath) && base.transform.childCount <= 2)
		{
			currentSong.nodes.Clear();
			currentSong = JsonUtility.FromJson<Song>(File.ReadAllText(danceFilePath));
			currentSong.SortNodes();
			saveError = false;
			loadError = false;
			BPM = currentSong.BPM;
			firstBeatBuffer = currentSong.firstBeatBuffer;
			SpawnEditorNodes();
			base.gameObject.name = "SongEditor - " + filename;
			AudioClip audioClipFromMusicString = GameManager.instance.GetAudioClipFromMusicString(currentSong._music);
			if (audioClipFromMusicString != null)
			{
				songDuration = audioClipFromMusicString.length;
			}
			totalbeats = Mathf.CeilToInt(songDuration / secondsPerBeat);
			SetUpNewLine();
			base.transform.localPosition = Vector3.zero;
			EditorManager.instance.DisplayMessage("Loading " + filename + "...");
		}
		else
		{
			loadError = true;
			EditorManager.instance.DisplayMessage("Can't load...");
		}
	}

	public string GetDanceFilePath(string _fileName)
	{
		return UnityEngine.Application.dataPath + "/StreamingAssets/Custom/Dances/" + _fileName + ".json";
	}

	private void SpawnEditorNodes()
	{
		if (useIncrementalLoad)
		{
			StartCoroutine(SpawnEditorNodesIncrement());
			return;
		}
		foreach (SongNode node in currentSong.nodes)
		{
			SceneEditorNode component = UnityEngine.Object.Instantiate(sceneEditorNode, new Vector3(base.transform.position.x + node.offsetX, base.transform.position.y + node.offsetY, base.transform.position.z + node.beatTime * unitsPerSecond), Quaternion.identity, base.transform).GetComponent<SceneEditorNode>();
			component.type = node.type;
			component.offset = new Vector2(node.offsetX, node.offsetY);
			component.beatTime = node.beatTime;
			component.editor = this;
			component.path = node.path;
			component.set = node.set;
			component.cascade = node.cascade;
			component.holoLight = node.holoLight;
			component.holoNum = node.holoNum;
			component.danceID = node.danceID;
			component.tauntInfo = new TauntInfo(node.serTauntInfo);
			component.bufferOverride = node.bufferOverride;
			component.minDifficulty = node.minDifficulty;
			component.Init();
		}
	}

	private IEnumerator SpawnEditorNodesIncrement()
	{
		if (currentSong.nodes.Count == 0)
		{
			EditorManager.instance.DisplayMessage("Loading Complete! (0 Nodes)");
			yield break;
		}
		Stopwatch watch = new Stopwatch();
		EditorManager.instance.SetLoading(_loading: true);
		watch.Start();
		for (int i = 0; i < currentSong.nodes.Count; i++)
		{
			SongNode songNode = currentSong.nodes[i];
			SceneEditorNode component = UnityEngine.Object.Instantiate(sceneEditorNode, new Vector3(base.transform.position.x + songNode.offsetX, base.transform.position.y + songNode.offsetY, base.transform.position.z + songNode.beatTime * unitsPerSecond), Quaternion.identity, base.transform).GetComponent<SceneEditorNode>();
			component.type = songNode.type;
			component.offset = new Vector2(songNode.offsetX, songNode.offsetY);
			component.beatTime = songNode.beatTime;
			component.editor = this;
			component.path = songNode.path;
			component.set = songNode.set;
			component.cascade = songNode.cascade;
			component.holoLight = songNode.holoLight;
			component.holoNum = songNode.holoNum;
			component.danceID = songNode.danceID;
			component.tauntInfo = new TauntInfo(songNode.serTauntInfo);
			component.bufferOverride = songNode.bufferOverride;
			component.minDifficulty = songNode.minDifficulty;
			component.Init();
			if (i == Mathf.RoundToInt(currentSong.nodes.Count / 4))
			{
				EditorManager.instance.DisplayMessage("Loading... 25%");
			}
			if (i == Mathf.RoundToInt(currentSong.nodes.Count / 4) * 2)
			{
				EditorManager.instance.DisplayMessage("Loading... 50%");
			}
			if (i == Mathf.RoundToInt(currentSong.nodes.Count / 4) * 3)
			{
				EditorManager.instance.DisplayMessage("Loading... 75%");
			}
			if (i == currentSong.nodes.Count - 1)
			{
				EditorManager.instance.DisplayMessage("Loading complete! (" + currentSong.nodes.Count + " Nodes)");
			}
			if (watch.ElapsedMilliseconds > MAX_SPAWN_BATCH_MILLISECONDS)
			{
				watch.Reset();
				yield return null;
				watch.Start();
			}
		}
		EditorManager.instance.SetLoading(_loading: false);
	}

	public void SelectNode(SceneEditorNode node)
	{
		if (node.selected)
		{
			node.Deselect();
			return;
		}
		selectedNodes.Add(node);
		node.SetExclusiveScrollAreas();
		EditorManager.instance.objectRefrences.nodeInspectorPanel.Open();
		EditorManager.instance.objectRefrences.nodeSettingsUI.UpdateUI();
		EditorManager.instance.objectRefrences.mainScrollArea.multiplier = 3f;
		EditorManager.instance.objectRefrences.editTools.RefreshUI();
	}

	public void DeselectNode(SceneEditorNode node, bool remove = true)
	{
		if (node.selected)
		{
			if (remove)
			{
				selectedNodes.Remove(node);
			}
			node.Deselect();
			EditorManager.instance.objectRefrences.nodeSettingsUI.selectedNodes = null;
			EditorManager.instance.objectRefrences.nodeSettingsUI.UpdateUI();
			node.SetExclusiveScrollAreas(set: false);
			if (selectedNodes.Count == 0)
			{
				line.transform.localPosition = Vector3.zero;
				EditorManager.instance.objectRefrences.mainScrollArea.multiplier = 17f;
			}
			EditorManager.instance.objectRefrences.editTools.RefreshUI();
		}
	}

	public void SelectAllNodes()
	{
		UnityEngine.Debug.Log("Selecting all nodes");
		DeselectAllNodes();
		foreach (Transform item in base.transform)
		{
			SceneEditorNode component = item.GetComponent<SceneEditorNode>();
			if (component != null)
			{
				component.Select(multi: true);
			}
		}
		EditorManager.instance.objectRefrences.editTools.RefreshUI();
	}

	public void DeselectAllNodes()
	{
		for (int i = 0; i < selectedNodes.Count; i++)
		{
			SceneEditorNode node = selectedNodes[i];
			DeselectNode(node, remove: false);
		}
		selectedNodes.Clear();
		line.transform.localPosition = Vector3.zero;
		EditorManager.instance.objectRefrences.mainScrollArea.multiplier = 17f;
		EditorManager.instance.objectRefrences.nodeSettingsUI.UpdateUI();
		EditorManager.instance.HandsInScrollAreas = 0;
		EditorManager.instance.objectRefrences.editTools.RefreshUI();
	}

	private void RemoveEditorNodes()
	{
		List<GameObject> list = new List<GameObject>();
		foreach (Transform item in base.transform)
		{
			list.Add(item.gameObject);
		}
		foreach (GameObject item2 in list)
		{
			if (item2.GetComponent<SceneEditorNode>() != null)
			{
				UnityEngine.Object.DestroyImmediate(item2);
			}
		}
	}

	private void OnDrawGizmos()
	{
		Gizmos.color = new Color(0.5f, 0.5f, 0.5f, 0.5f);
		Gizmos.DrawRay(base.transform.position, base.transform.forward * songDuration * unitsPerSecond);
		for (int i = 0; (float)i < totalbeats; i++)
		{
			Gizmos.DrawLine(new Vector3(base.transform.position.x - 0.2f, base.transform.position.y, base.transform.position.z + ((float)i * secondsPerBeat + firstBeatBuffer) * unitsPerSecond), new Vector3(base.transform.position.x + 0.2f, base.transform.position.y, base.transform.position.z + ((float)i * secondsPerBeat + firstBeatBuffer) * unitsPerSecond));
		}
		for (int j = 0; (float)j < totalbeats; j++)
		{
			Gizmos.DrawLine(new Vector3(base.transform.position.x - 0.1f, base.transform.position.y, base.transform.position.z + ((float)j * secondsPerBeat + secondsPerBeat * 0.5f + firstBeatBuffer) * unitsPerSecond), new Vector3(base.transform.position.x + 0.1f, base.transform.position.y, base.transform.position.z + ((float)j * secondsPerBeat + secondsPerBeat * 0.5f + firstBeatBuffer) * unitsPerSecond));
		}
		for (int k = 0; (float)k < totalbeats * 2f; k++)
		{
			Gizmos.DrawLine(new Vector3(base.transform.position.x - 0.05f, base.transform.position.y, base.transform.position.z + ((float)k * secondsPerBeat / 2f + secondsPerBeat * 0.25f + firstBeatBuffer) * unitsPerSecond), new Vector3(base.transform.position.x + 0.05f, base.transform.position.y, base.transform.position.z + ((float)k * secondsPerBeat / 2f + secondsPerBeat * 0.25f + firstBeatBuffer) * unitsPerSecond));
		}
	}

	private void SetupLineRenderer()
	{
		List<Vector3> list = new List<Vector3>();
		list.Add(new Vector3(0f, -1f, 0f));
		list.Add(new Vector3(0f, -1f, firstBeatBuffer * unitsPerSecond));
		for (int i = 0; (float)i < totalbeats + 1f; i++)
		{
			Vector3 vector = list[list.Count - 1];
			list.Add(vector + new Vector3(0.4f, 0f, 0f));
			list.Add(vector + new Vector3(-0.4f, 0f, 0f));
			list.Add(vector + new Vector3(0f, 0f, 0f));
			list.Add(vector + new Vector3(0f, 0f, secondsPerBeat / 2f * unitsPerSecond));
			vector = list[list.Count - 1];
			list.Add(vector + new Vector3(0.2f, 0f, 0f));
			list.Add(vector + new Vector3(-0.2f, 0f, 0f));
			list.Add(vector + new Vector3(0f, 0f, 0f));
			list.Add(vector + new Vector3(0f, 0f, secondsPerBeat / 2f * unitsPerSecond));
		}
		line.positionCount = list.Count;
		line.SetPositions(list.ToArray());
	}

	private void SetUpNewLine()
	{
		if (mainLine != null)
		{
			UnityEngine.Object.Destroy(mainLine.gameObject);
			foreach (LineRenderer line in lines)
			{
				UnityEngine.Object.Destroy(line.gameObject);
			}
		}
		mainLine = new GameObject("Mainline").AddComponent<LineRenderer>();
		mainLine.transform.parent = lineParent;
		mainLine.transform.localPosition = new Vector3(0f, 0f, 0f);
		mainLine.useWorldSpace = false;
		mainLine.positionCount = 3;
		mainLine.SetPosition(0, new Vector3(0f, 0f, 0f - (float)(num_beats_on_line / 2) * secondsPerBeat * unitsPerSecond));
		mainLine.SetPosition(1, new Vector3(0f, 0f, 0f));
		mainLine.SetPosition(2, new Vector3(0f, 0f, (float)(num_beats_on_line / 2) * secondsPerBeat * unitsPerSecond));
		Gradient gradient = new Gradient();
		gradient.SetKeys(new GradientColorKey[2]
		{
			new GradientColorKey(lineBaseColour, 0f),
			new GradientColorKey(lineBaseColour, 1f)
		}, new GradientAlphaKey[3]
		{
			new GradientAlphaKey(lineOpacityEnd, 0f),
			new GradientAlphaKey(lineOpacityStart, 0.5f),
			new GradientAlphaKey(lineOpacityEnd, 1f)
		});
		mainLine.colorGradient = gradient;
		mainLine.material = lineMaterial;
		mainLine.startWidth = lineWidth;
		mainLine.endWidth = lineWidth;
		lines = new List<LineRenderer>();
		for (int i = 0; i < num_beats_on_line * 2 - 1; i++)
		{
			LineRenderer lineRenderer = CreateNewLine((i % 2 == 0) ? majorBeatSize : halfBeatSize);
			lineRenderer.transform.localPosition = new Vector3(0f, 0f, (float)(num_beats_on_line / 2) * secondsPerBeat * unitsPerSecond - secondsPerBeat * unitsPerSecond - secondsPerBeat * unitsPerSecond / 2f * (float)i + firstBeatBuffer);
			lines.Add(lineRenderer);
		}
	}

	private LineRenderer CreateNewLine(float length)
	{
		LineRenderer lineRenderer = new GameObject("BeatMarker").AddComponent<LineRenderer>();
		lineRenderer.transform.parent = mainLine.transform;
		lineRenderer.useWorldSpace = false;
		lineRenderer.positionCount = 3;
		lineRenderer.SetPosition(0, new Vector3(length, 0f, 0f));
		lineRenderer.SetPosition(1, new Vector3(0f, 0f, 0f));
		lineRenderer.SetPosition(2, new Vector3(0f - length, 0f, 0f));
		lineRenderer.colorGradient = SimpleLineColour(lineBaseColour, 0.5f);
		lineRenderer.material = lineMaterial;
		lineRenderer.startWidth = lineWidth;
		lineRenderer.endWidth = lineWidth;
		return lineRenderer;
	}

	private Gradient SimpleLineColour(Color color, float alpha)
	{
		Gradient gradient = new Gradient();
		gradient.SetKeys(new GradientColorKey[2]
		{
			new GradientColorKey(color, 0f),
			new GradientColorKey(color, 1f)
		}, new GradientAlphaKey[2]
		{
			new GradientAlphaKey(alpha, 0f),
			new GradientAlphaKey(alpha, 1f)
		});
		return gradient;
	}

	private float GetLineOffset()
	{
		float currentTime = EditorManager.instance.GetCurrentTime();
		secondsPerBeat = 60f / BPM;
		return (currentTime - firstBeatBuffer) % secondsPerBeat;
	}

	private void UpdateLines()
	{
		if (lines.Count != 0)
		{
			float lineOffset = GetLineOffset();
			for (int i = 0; i < lines.Count; i++)
			{
				lines[i].transform.localPosition = new Vector3(0f, 0f, (float)(num_beats_on_line / 2) * secondsPerBeat * unitsPerSecond - secondsPerBeat * unitsPerSecond - secondsPerBeat * unitsPerSecond / 2f * (float)i + firstBeatBuffer - lineOffset * unitsPerSecond);
				lines[i].colorGradient = SimpleLineColour(lineBaseColour, Mathf.Lerp(lineOpacityStart, lineOpacityEnd, Mathf.InverseLerp(0f, (float)(num_beats_on_line / 2) * secondsPerBeat * unitsPerSecond, Mathf.Abs(lines[i].transform.localPosition.z))));
			}
		}
	}

	private void SaveEditorNodesToLocalSong()
	{
		currentSong.nodes.Clear();
		foreach (Transform item in base.transform)
		{
			SceneEditorNode component = item.GetComponent<SceneEditorNode>();
			if (component != null)
			{
				component.UpdateValues();
				currentSong.nodes.Add(new SongNode(component));
			}
		}
		currentSong.SortNodes();
	}
}
public class AutoSongGenerator : MonoBehaviour
{
	public enum NodeColour
	{
		Pink,
		Green
	}

	[Serializable]
	public class Subband_Generator
	{
		public float timeout = 0.1f;

		public Vector2 xOffsetRange;

		public Vector2 yOffsetRange;

		public NodeColour color;

		private float timer;

		private AutoSongGenerator parent;

		public void Init(AutoSongGenerator gen)
		{
			parent = gen;
		}

		public void Spawn()
		{
			if (!(timer > 0f))
			{
				parent.CreateNode(UnityEngine.Random.Range(xOffsetRange.x, xOffsetRange.y), UnityEngine.Random.Range(yOffsetRange.x, yOffsetRange.y), color);
				Timeout();
			}
		}

		public void Update()
		{
			if (timer > 0f)
			{
				timer -= Time.deltaTime;
				if (timer < 0f)
				{
					timer = 0f;
				}
			}
		}

		public void Timeout()
		{
			timer = timeout;
		}
	}

	public string youtubeID;

	public GameObject fakeNodePrefab;

	public SubbandBeatDetection beatDetector;

	public Subband_Generator sub0;

	public Subband_Generator sub1;

	public Subband_Generator sub2;

	public Subband_Generator sub3;

	public Subband_Generator sub4;

	public Subband_Generator sub5;

	public float colourTimeout = 0.1f;

	private float pinkTimer;

	private float greenTimer;

	public Song currentSong;

	public SimplePlayback youtubeplayer_Analyzer;

	public SimplePlayback youtubePlayer_Live;

	private YoutubeAPIManager youtubeapi;

	public string videoName = "Name_Not_Loaded";

	private void Start()
	{
		youtubeapi = GetComponent<YoutubeAPIManager>();
		sub0.Init(this);
		sub1.Init(this);
		sub2.Init(this);
		sub3.Init(this);
		sub4.Init(this);
		sub5.Init(this);
		beatDetector.subBands[0].OnBeat += sub0.Spawn;
		beatDetector.subBands[1].OnBeat += sub0.Spawn;
		beatDetector.subBands[2].OnBeat += sub1.Spawn;
		beatDetector.subBands[3].OnBeat += sub1.Spawn;
		beatDetector.subBands[4].OnBeat += sub2.Spawn;
		beatDetector.subBands[5].OnBeat += sub2.Spawn;
		beatDetector.subBands[6].OnBeat += sub3.Spawn;
		beatDetector.subBands[7].OnBeat += sub3.Spawn;
		beatDetector.subBands[8].OnBeat += sub4.Spawn;
		beatDetector.subBands[9].OnBeat += sub4.Spawn;
		beatDetector.subBands[10].OnBeat += sub5.Spawn;
		beatDetector.subBands[11].OnBeat += sub5.Spawn;
		youtubeplayer_Analyzer.OnVideoFinished += AnalyzerFinished;
	}

	public void StartAnalysis()
	{
		youtubeplayer_Analyzer.PlayYoutubeVideo(youtubeID);
		currentSong._music = youtubeID;
		currentSong.BPM = 120f;
		youtubeapi.GetVideoData(youtubeID, OnFinishLoadingData);
	}

	public void StopAnalysis()
	{
		youtubeplayer_Analyzer.PlayerPause();
		SaveDance();
	}

	private void OnFinishLoadingData(YoutubeData result)
	{
		videoName = CleanupString(result.snippet.title);
	}

	public string CleanupString(string input)
	{
		string text = input;
		char[] invalidFileNameChars = Path.GetInvalidFileNameChars();
		foreach (char oldChar in invalidFileNameChars)
		{
			text = text.Replace(oldChar, '_');
		}
		return text.Replace(' ', '_');
	}

	private void Update()
	{
		sub0.Update();
		sub1.Update();
		sub2.Update();
		sub3.Update();
		sub4.Update();
		sub5.Update();
		if (greenTimer > 0f)
		{
			greenTimer -= Time.deltaTime;
			if (greenTimer < 0f)
			{
				greenTimer = 0f;
			}
		}
		if (pinkTimer > 0f)
		{
			pinkTimer -= Time.deltaTime;
			if (pinkTimer < 0f)
			{
				pinkTimer = 0f;
			}
		}
	}

	private float CheckAnalyzerSongTime()
	{
		return (float)youtubeplayer_Analyzer.unityVideoPlayer.frame / youtubeplayer_Analyzer.unityVideoPlayer.frameRate;
	}

	private float CheckLiveSongTime()
	{
		return (float)youtubePlayer_Live.unityVideoPlayer.frame / youtubePlayer_Live.unityVideoPlayer.frameRate;
	}

	private void CreateNode(float offsetX, float offsetY, NodeColour color)
	{
		Color color2 = Color.white;
		switch (color)
		{
		case NodeColour.Green:
			if (greenTimer > 0f)
			{
				return;
			}
			color2 = Color.green;
			greenTimer = colourTimeout;
			currentSong.nodes.Add(new SongNode(CheckAnalyzerSongTime(), offsetX, offsetY, NodeType.Green));
			break;
		case NodeColour.Pink:
			if (pinkTimer > 0f)
			{
				return;
			}
			color2 = new Color(1f, 0f, 1f);
			pinkTimer = colourTimeout;
			currentSong.nodes.Add(new SongNode(CheckAnalyzerSongTime(), offsetX, offsetY, NodeType.Pink));
			break;
		}
		UnityEngine.Object.Instantiate(fakeNodePrefab, base.transform.position + new Vector3(offsetX, offsetY, 0f), Quaternion.identity, base.transform).GetComponentInChildren<Renderer>().material.color = color2;
	}

	private void AnalyzerFinished()
	{
		SaveDance();
	}

	public void SaveDance()
	{
		if (currentSong.nodes.Count == 0)
		{
			UnityEngine.Debug.Log("Can't save due to no nodes");
			return;
		}
		string danceFilePath = GetDanceFilePath("Auto_" + videoName);
		BinaryFormatter binaryFormatter = new BinaryFormatter();
		FileStream fileStream = File.Open(danceFilePath, FileMode.OpenOrCreate);
		binaryFormatter.Serialize(fileStream, currentSong);
		fileStream.Close();
		UnityEngine.Debug.Log("Saving Auto_" + videoName + " at " + danceFilePath);
	}

	public string GetDanceFilePath(string _fileName)
	{
		return UnityEngine.Application.dataPath + "/StreamingAssets/Save Files/Dances/" + _fileName + ".collider";
	}
}
public class AchievementFunctions : MonoBehaviour
{
	public List<Achievement> achievements = new List<Achievement>();

	private void Start()
	{
	}

	private void Update()
	{
	}

	public virtual void UnlockAchievement(string _achID)
	{
	}

	public virtual void PopulateAchievements(List<string> _IDs)
	{
	}

	public Achievement GetAchievement(string _achID)
	{
		for (int i = 0; i < achievements.Count; i++)
		{
			if (achievements[i].achievementID == _achID)
			{
				return achievements[i];
			}
		}
		return new Achievement("ERROR", "ERROR", "ERROR", _ach: true);
	}
}
public class AchievementFunctionsOculus : AchievementFunctions
{
	private List<string> achIDs = new List<string>();

	public override void UnlockAchievement(string _achID)
	{
		UnityEngine.Debug.Log("Trying to unlock oculus achievement");
		if (GetAchievement(_achID).achieved)
		{
			UnityEngine.Debug.Log("Already achieved.");
		}
		else
		{
			Achievements.Unlock(_achID).OnComplete(AchievementUnlocked);
		}
	}

	private void AchievementUnlocked(Message<AchievementUpdate> _msg)
	{
		if (!_msg.IsError)
		{
			GetAchievement(_msg.Data.Name).achieved = true;
		}
	}

	public override void PopulateAchievements(List<string> _IDs)
	{
		achIDs = _IDs;
		Achievements.GetAllProgress().OnComplete(OnGetAllProgress);
	}

	private void OnGetAllProgress(Message<AchievementProgressList> _achs)
	{
		if (_achs.IsError)
		{
			return;
		}
		for (int i = 0; i < _achs.Data.Count; i++)
		{
			AchievementProgress achievementProgress = _achs.Data[i];
			achievements.Add(new Achievement(achievementProgress.Name, "", "", achievementProgress.IsUnlocked));
		}
		for (int j = 0; j < achIDs.Count; j++)
		{
			if (GetAchievement(achIDs[j]).name == "ERROR")
			{
				achievements.Add(new Achievement(achIDs[j], "", ""));
			}
		}
	}
}
[Serializable]
public class Achievement
{
	public string achievementID;

	public string name;

	public string description;

	public bool achieved;

	public Achievement(string _id, string _name, string _desc, bool _ach = false)
	{
		achievementID = _id;
		name = _name;
		description = _desc;
		achieved = _ach;
	}
}
public class AchievementsManager : MonoBehaviour
{
	public AchievementFunctions aFun;

	public List<string> achievementIDs;

	public bool disableAchievements;

	private SaveManager sMan;

	private List<string> sessionClears = new List<string>();

	private bool gotAchievements;

	private void Awake()
	{
		aFun = GetComponent<AchievementFunctions>();
		sMan = GetComponent<SaveManager>();
	}

	private void Update()
	{
		if (Persistence.instance.oculusInitialised && !gotAchievements)
		{
			aFun.PopulateAchievements(achievementIDs);
			gotAchievements = true;
		}
	}

	public void UnlockAchievement(string _achID)
	{
	}

	public void UpdateAchievements()
	{
	}

	private bool CheckAchievement(string _id)
	{
		return false;
	}

	private void CheckAllClearAchievements()
	{
	}
}
public class LeaderboardFinder : MonoBehaviour
{
	public enum ScoreTextType
	{
		e_stageTitle,
		e_ranks,
		e_names,
		e_scores,
		e_grades
	}
}
public enum LBState
{
	e_noBoard,
	e_hasBoard,
	e_hasScores,
	e_scoreUploaded,
	e_boardError
}
public class LeaderboardFunctions : MonoBehaviour
{
	public bool ready = true;

	public LBState state;

	public int currentPlayerRank;

	public List<ScoreEntry> scores = new List<ScoreEntry>();

	public string playerName;

	public virtual void GetLeaderboard(string _boardName)
	{
	}

	public virtual void GetScores(int _count, LBRange _range = LBRange.e_global, int _startPoint = 1)
	{
	}

	public virtual void UploadScore(int _score, int[] _grade)
	{
	}

	public virtual void GetPlayerName()
	{
	}
}
[Serializable]
public class ScoreEntry
{
	public int rank;

	public string name = "";

	public int score;

	public int grade;

	public ulong ocuID;
}
public class LeaderboardFunctionsOculus : LeaderboardFunctions
{
	public SortedDictionary<int, LeaderboardEntry> ocuScores = new SortedDictionary<int, LeaderboardEntry>();

	private string targetBoard = "";

	private ulong playerID;

	public bool debug;

	private void Start()
	{
		Core.AsyncInitialize("3848483328577203");
	}

	private void Update()
	{
	}

	public override void GetLeaderboard(string _boardName)
	{
		targetBoard = _boardName;
		ready = true;
		state = LBState.e_hasBoard;
		UnityEngine.Debug.Log("Board set: " + _boardName);
	}

	public override void GetScores(int _count, LBRange _range, int _startPoint = 1)
	{
		LeaderboardStartAt startAt = LeaderboardStartAt.Top;
		LeaderboardFilterType filter = LeaderboardFilterType.None;
		if (_range == LBRange.e_friends)
		{
			filter = LeaderboardFilterType.Friends;
		}
		if (_range == LBRange.e_nearby)
		{
			startAt = LeaderboardStartAt.CenteredOnViewer;
		}
		ready = false;
		ocuScores = new SortedDictionary<int, LeaderboardEntry>();
		Leaderboards.GetEntries(targetBoard, _count, filter, startAt).OnComplete(OnGetScores);
	}

	private void OnGetScores(Message<LeaderboardEntryList> _board)
	{
		if (!_board.IsError)
		{
			for (int i = 0; i < _board.Data.Count; i++)
			{
				LeaderboardEntry leaderboardEntry = _board.Data[i];
				ocuScores[leaderboardEntry.Rank] = leaderboardEntry;
			}
			if (_board.Data.HasNextPage)
			{
				Leaderboards.GetNextEntries(_board.Data).OnComplete(OnGetScores);
				return;
			}
			ParseScores();
			ready = true;
			state = LBState.e_hasScores;
		}
		else
		{
			ready = true;
			state = LBState.e_hasBoard;
			Persistence.instance.ResetLeaderboardManager();
		}
	}

	private void ParseScores()
	{
		scores.Clear();
		int[] array = new int[ocuScores.Count];
		ocuScores.Keys.CopyTo(array, 0);
		for (int i = 0; i < array.Length; i++)
		{
			ScoreEntry scoreEntry = new ScoreEntry();
			LeaderboardEntry value = null;
			ocuScores.TryGetValue(array[i], out value);
			scoreEntry.name = value.User.OculusID;
			scoreEntry.score = (int)value.Score;
			scoreEntry.rank = value.Rank;
			scoreEntry.grade = BitConverter.ToInt32(value.ExtraData, 0);
			scoreEntry.ocuID = value.User.ID;
			scores.Add(scoreEntry);
		}
	}

	public override void UploadScore(int _score, int[] _grade)
	{
		ready = false;
		byte[] bytes = BitConverter.GetBytes(_grade[0]);
		Leaderboards.WriteEntry(targetBoard, _score, bytes).OnComplete(OnScoreUploaded);
		UnityEngine.Debug.Log("Upload started!");
	}

	private void OnScoreUploaded(Message<bool> _msg)
	{
		if (!_msg.IsError)
		{
			state = LBState.e_scoreUploaded;
			ready = true;
		}
	}

	public override void GetPlayerName()
	{
		Users.GetLoggedInUser().OnComplete(OnGetUser);
	}

	private void OnGetUser(Message<User> _usr)
	{
		playerName = _usr.Data.OculusID;
	}
}
public enum LBManState
{
	e_none,
	e_uploadScore,
	e_downloadScores
}
public enum LBRange
{
	e_global,
	e_friends,
	e_nearby
}
[Serializable]
public class LeaderboardUI
{
	public TextMeshProUGUI stageText;

	public TextMeshProUGUI rankText;

	public TextMeshProUGUI scoreText;

	public TextMeshProUGUI nameText;

	public TextMeshProUGUI gradeText;
}
public class LeaderboardManager : MonoBehaviour
{
	private LeaderboardFunctions lFun;

	public LBManState state;

	public LBRange curRange;

	public LeaderboardUI topScoresUI;

	public LeaderboardUI nearbyScoresUI;

	public string targetBoard;

	public string title;

	public int defaultScoresToGet = 10;

	public int friendScoresToGet = 15;

	public int nearbyScoresToGet = 4;

	public int scoresToGet;

	public int scoreStartPoint;

	public int scoreToUpload;

	public int gradeToUpload;

	public bool disableSubmission;

	[HideInInspector]
	public int curBoard;

	private bool waiting;

	private void Start()
	{
		lFun = GetComponent<LeaderboardFunctionsOculus>();
		SetTargetBoard();
	}

	private void Update()
	{
		if (lFun.ready)
		{
			switch (state)
			{
			case LBManState.e_none:
				if (waiting)
				{
					waiting = false;
					UpdateScoreboard();
				}
				break;
			case LBManState.e_downloadScores:
				switch (lFun.state)
				{
				case LBState.e_noBoard:
					lFun.GetLeaderboard(targetBoard);
					if (topScoresUI.stageText != null)
					{
						topScoresUI.stageText.text = title;
					}
					break;
				case LBState.e_hasBoard:
					lFun.GetScores(scoresToGet, curRange);
					break;
				case LBState.e_hasScores:
					if (!waiting)
					{
						DisplayScores(lFun.scores);
					}
					lFun.ready = false;
					state = LBManState.e_none;
					if (curRange == LBRange.e_global)
					{
						GetNearbyScores(_getBoard: false);
					}
					else
					{
						lFun.ready = true;
					}
					break;
				case LBState.e_boardError:
					DisplayError();
					break;
				}
				break;
			case LBManState.e_uploadScore:
				switch (lFun.state)
				{
				case LBState.e_noBoard:
					lFun.GetLeaderboard(targetBoard);
					if (topScoresUI.stageText != null)
					{
						topScoresUI.stageText.text = title;
					}
					break;
				case LBState.e_hasBoard:
				{
					int[] grade = new int[1] { gradeToUpload };
					lFun.UploadScore(scoreToUpload, grade);
					break;
				}
				case LBState.e_scoreUploaded:
					switch (curBoard)
					{
					case 0:
						GetTopScores();
						break;
					case 1:
						GetFriendScores();
						break;
					case 2:
						UnityEngine.Object.FindObjectOfType<UI_Leaderboard>().GetLocalScores();
						break;
					}
					break;
				case LBState.e_boardError:
					DisplayError();
					break;
				}
				break;
			}
		}
		if (Input.GetKeyDown(KeyCode.T))
		{
			SetTargetBoard();
		}
	}

	public void UpdateScoreboard()
	{
		if (waiting)
		{
			return;
		}
		if (state == LBManState.e_none)
		{
			SetTargetBoard();
			switch (curBoard)
			{
			case 0:
				GetTopScores();
				break;
			case 1:
				GetFriendScores();
				break;
			case 2:
				UnityEngine.Object.FindObjectOfType<UI_Leaderboard>().GetLocalScores();
				break;
			}
		}
		else
		{
			waiting = true;
		}
	}

	public void SetTargetBoard()
	{
		string[] array = Persistence.instance.currentSongFilename.Split('_');
		targetBoard = array[1];
		targetBoard += array[2];
		if (Persistence.instance.currentDifficulty == 0)
		{
			targetBoard += "E";
		}
		else if (Persistence.instance.currentDifficulty == 1)
		{
			targetBoard += "N";
		}
		else if (Persistence.instance.currentDifficulty == 2)
		{
			targetBoard += "H";
		}
		if (topScoresUI.stageText != null)
		{
			topScoresUI.stageText.text = title;
		}
		UnityEngine.Debug.Log("Target board is " + targetBoard);
	}

	public void DisplayScores(List<ScoreEntry> _scores)
	{
		if (GameManager.instance == null)
		{
			Lobby_Leaderboards leaderboards = LobbyMainMenuManager.instance.leaderboards;
			if (curRange != LBRange.e_nearby)
			{
				leaderboards._leaderboardScores = new List<Lobby_Leaderboards.LeaderboardScores>();
				foreach (ScoreEntry _score in _scores)
				{
					Lobby_Leaderboards.LeaderboardScores item = new Lobby_Leaderboards.LeaderboardScores
					{
						playerName = _score.name,
						playerScore = _score.score,
						position = _score.rank
					};
					leaderboards._leaderboardScores.Add(item);
				}
			}
			if (curRange != LBRange.e_nearby)
			{
				leaderboards.UpdateEntryList();
			}
			else
			{
				Lobby_Leaderboards.LeaderboardScores leaderboardScores = new Lobby_Leaderboards.LeaderboardScores
				{
					playerName = _scores[1].name,
					playerScore = _scores[1].score,
					position = _scores[1].rank
				};
				Lobby_Leaderboards.LeaderboardScores previewAbove = new Lobby_Leaderboards.LeaderboardScores
				{
					playerName = _scores[0].name,
					playerScore = _scores[0].score,
					position = _scores[0].rank
				};
				Lobby_Leaderboards.LeaderboardScores previewBelow = new Lobby_Leaderboards.LeaderboardScores
				{
					playerName = _scores[2].name,
					playerScore = _scores[2].score,
					position = _scores[2].rank
				};
				leaderboards.UpdateNearbyScores(leaderboardScores, previewAbove, leaderboardScores, previewBelow);
			}
		}
		string text = "";
		string text2 = "";
		string text3 = "";
		string text4 = "";
		for (int i = 0; i < _scores.Count; i++)
		{
			ScoreEntry scoreEntry = _scores[i];
			bool flag = scoreEntry.name == Persistence.instance.GetPlayerName();
			text = text + (flag ? "<b>" : "") + ((curRange == LBRange.e_friends) ? (i + 1 + "\n") : (scoreEntry.rank + "\n")) + (flag ? "</b>" : "");
			text2 = text2 + (flag ? "<b><color=#f7ac20>" : "") + scoreEntry.name + "\n" + (flag ? "</color></b>" : "");
			text3 = text3 + (flag ? "<b>" : "") + scoreEntry.score.ToString("N0") + "\n" + (flag ? "</b>" : "");
			text4 = text4 + (flag ? "<b>" : "") + GetGrade(scoreEntry.grade) + "\n" + (flag ? "</b>" : "");
		}
		if (curRange != LBRange.e_nearby)
		{
			SetText(topScoresUI.rankText, text);
			SetText(topScoresUI.nameText, text2);
			SetText(topScoresUI.scoreText, text3);
			SetText(topScoresUI.gradeText, text4);
			SetText(nearbyScoresUI.stageText, "");
			SetText(nearbyScoresUI.rankText, "");
			SetText(nearbyScoresUI.nameText, "");
			SetText(nearbyScoresUI.scoreText, "");
			SetText(nearbyScoresUI.gradeText, "");
		}
		else if (_scores.Count > 0)
		{
			SetText(nearbyScoresUI.rankText, text);
			SetText(nearbyScoresUI.nameText, text2);
			SetText(nearbyScoresUI.scoreText, text3);
			SetText(nearbyScoresUI.gradeText, text4);
			SetText(nearbyScoresUI.stageText, "_____________________");
		}
	}

	private void SetText(TextMeshProUGUI _mesh, string _text)
	{
		if (_mesh != null)
		{
			_mesh.text = _text;
		}
	}

	private void DisplayError()
	{
		topScoresUI.scoreText.text = "ERROR";
	}

	public void GetTopScores()
	{
		GetScores(defaultScoresToGet);
	}

	public void GetFriendScores()
	{
		GetScores(friendScoresToGet, LBRange.e_friends);
	}

	public void GetNearbyScores(bool _getBoard = true)
	{
		GetScores(nearbyScoresToGet, LBRange.e_nearby, _getBoard);
	}

	private void GetScores(int _count, LBRange _range = LBRange.e_global, bool _getBoard = true)
	{
		scoresToGet = _count;
		curRange = _range;
		state = LBManState.e_downloadScores;
		if (_getBoard)
		{
			lFun.state = LBState.e_noBoard;
		}
		else
		{
			lFun.state = LBState.e_hasBoard;
		}
		lFun.ready = true;
	}

	public void UploadScore(int _score, Score.Rank _grade)
	{
		if (!disableSubmission)
		{
			gradeToUpload = (int)_grade;
			scoreToUpload = _score;
			lFun.state = LBState.e_noBoard;
		}
		else
		{
			lFun.state = LBState.e_scoreUploaded;
		}
		curRange = LBRange.e_global;
		state = LBManState.e_uploadScore;
		lFun.ready = true;
	}

	public string GetDanceFilePath(string _fileName)
	{
		return UnityEngine.Application.dataPath + "/StreamingAssets/Custom/Dances/" + _fileName + ".json";
	}

	public static string GetGrade(int _grade)
	{
		string result = "?";
		switch (_grade)
		{
		case 0:
			result = "S+";
			break;
		case 1:
			result = "S";
			break;
		case 2:
			result = "S-";
			break;
		case 3:
			result = "A+";
			break;
		case 4:
			result = "A";
			break;
		case 5:
			result = "A-";
			break;
		case 6:
			result = "B+";
			break;
		case 7:
			result = "B";
			break;
		case 8:
			result = "B-";
			break;
		case 9:
			result = "C+";
			break;
		case 10:
			result = "C";
			break;
		case 11:
			result = "C-";
			break;
		case 12:
			result = "D+";
			break;
		case 13:
			result = "D";
			break;
		case 14:
			result = "D-";
			break;
		case 15:
			result = "E+";
			break;
		case 16:
			result = "E";
			break;
		case 17:
			result = "E-";
			break;
		default:
			UnityEngine.Debug.LogWarning("Attempting to find invalid grade!");
			break;
		}
		return result;
	}

	public string GetPlayerName()
	{
		return lFun.playerName;
	}

	public void InitPlayerName()
	{
		lFun.GetPlayerName();
	}
}
[Serializable]
public class DCSaveData
{
	public float uriel_unlock;

	public List<CharacterData> characters;

	public int prevRank = 100;

	public int consistentCount;

	public List<string> ARanks = new List<string>();

	public List<string> DRanks = new List<string>();

	public DCSaveData()
	{
		characters = new List<CharacterData>();
		AddCharacter("Pyro");
		AddCharacter("Yuri");
		AddCharacter("Liu");
		AddCharacter("Remi");
		AddCharacter("Lais");
		AddCharacter("Dre");
		AddCharacter("Sonya");
		AddCharacter("Core");
		AddCharacter("Uriel");
	}

	private void AddCharacter(string _name)
	{
		CharacterData characterData = new CharacterData();
		characterData.name = _name;
		characters.Add(characterData);
	}

	public CharacterData GetCharacter(string _charName)
	{
		for (int i = 0; i < characters.Count; i++)
		{
			if (characters[i].name == _charName)
			{
				return characters[i];
			}
		}
		return new CharacterData();
	}

	public StageData GetStage(CharacterData _charData, string _stageNum)
	{
		for (int i = 0; i < _charData.stages.Count; i++)
		{
			if (_charData.stages[i].name == _stageNum)
			{
				return _charData.stages[i];
			}
		}
		return new StageData();
	}

	public DifficultyData GetDifficulty(StageData _stage, string _difficulty)
	{
		for (int i = 0; i < _stage.difficulties.Count; i++)
		{
			if (_stage.difficulties[i].name == _difficulty)
			{
				return _stage.difficulties[i];
			}
		}
		return new DifficultyData();
	}

	public LocalLeaderboard GetLocalLeaderboard(string _collider)
	{
		string[] array = _collider.Split('_');
		CharacterData character = GetCharacter(array[1]);
		StageData stage = GetStage(character, array[2]);
		DifficultyData difficulty = GetDifficulty(stage, array[3]);
		if (difficulty.name != "ERROR")
		{
			return difficulty.leaderboard;
		}
		return new LocalLeaderboard
		{
			entries = 
			{
				new LocalLeaderboardEntry()
			}
		};
	}

	public void SubmitScore(string _collider, string _name, int _score, int _grade)
	{
		string[] array = _collider.Split('_');
		CharacterData character = GetCharacter(array[1]);
		StageData stage = GetStage(character, array[2]);
		DifficultyData difficulty = GetDifficulty(stage, array[3]);
		if (character.name != "ERROR")
		{
			if (stage.name != "ERROR")
			{
				stage.cleared = true;
				if (difficulty.name != "ERROR")
				{
					difficulty.cleared = true;
					difficulty.CheckGrade(_grade);
				}
				stage.CheckGrade();
			}
			character.CheckGrade();
		}
		LocalLeaderboardEntry entry = new LocalLeaderboardEntry(_name, _score, _grade);
		GetLocalLeaderboard(_collider).SubmitScore(entry);
	}

	public void ResetPersonalLeaderboard(string _collider)
	{
		GetLocalLeaderboard(_collider).Reset();
	}

	public void ResetPersonalLeaderboardsALL()
	{
		for (int i = 0; i < characters.Count; i++)
		{
			CharacterData characterData = characters[i];
			for (int j = 0; j < characterData.stages.Count; j++)
			{
				StageData stageData = characterData.stages[j];
				for (int k = 0; k < stageData.difficulties.Count; k++)
				{
					stageData.difficulties[k].leaderboard.Reset();
				}
			}
		}
	}

	public int GetCharacterRank(string _collider)
	{
		string[] array = _collider.Split('_');
		return GetCharacter(array[1]).averageGrade;
	}

	public int GetStageRank(string _collider)
	{
		string[] array = _collider.Split('_');
		return GetStage(GetCharacter(array[1]), array[2]).bestGrade;
	}

	public int GetDifficultyRank(string _collider)
	{
		string[] array = _collider.Split('_');
		return GetDifficulty(GetStage(GetCharacter(array[1]), array[2]), array[3]).bestGrade;
	}
}
[Serializable]
public class CharacterData
{
	public string name = "ERROR";

	public int averageGrade = 100;

	public List<StageData> stages;

	public bool easyCleared;

	public bool normalCleared;

	public bool hardCleared;

	public CharacterData()
	{
		stages = new List<StageData>();
		AddStage("1");
		AddStage("2");
		AddStage("3");
		AddStage("4");
		AddStage("5");
	}

	private void AddStage(string _name)
	{
		StageData stageData = new StageData();
		stageData.name = _name;
		stages.Add(stageData);
	}

	public void CheckGrade()
	{
		int num = 0;
		bool flag = true;
		bool flag2 = true;
		bool flag3 = true;
		bool flag4 = true;
		for (int i = 0; i < stages.Count; i++)
		{
			if (stages[i].cleared)
			{
				num += stages[i].bestGrade;
				if (!stages[i].difficulties[0].cleared)
				{
					flag2 = false;
				}
				if (!stages[i].difficulties[1].cleared)
				{
					flag3 = false;
				}
				if (!stages[i].difficulties[2].cleared)
				{
					flag4 = false;
				}
			}
			else
			{
				flag = false;
			}
		}
		if (flag)
		{
			float f = (float)num / 3f;
			averageGrade = Mathf.CeilToInt(f);
		}
		easyCleared = flag2;
		normalCleared = flag3;
		hardCleared = flag4;
	}
}
[Serializable]
public class StageData
{
	public string name = "ERROR";

	public bool cleared;

	public int bestGrade = 100;

	public List<DifficultyData> difficulties;

	public StageData()
	{
		difficulties = new List<DifficultyData>();
		AddDifficulty("Easy");
		AddDifficulty("Normal");
		AddDifficulty("Hard");
		AddDifficulty("X");
	}

	private void AddDifficulty(string _name)
	{
		DifficultyData difficultyData = new DifficultyData();
		difficultyData.name = _name;
		difficulties.Add(difficultyData);
	}

	public void CheckGrade()
	{
		for (int i = 0; i < difficulties.Count; i++)
		{
			if (difficulties[i].bestGrade < bestGrade)
			{
				bestGrade = difficulties[i].bestGrade;
			}
		}
	}
}
[Serializable]
public class DifficultyData
{
	public string name = "ERROR";

	public bool cleared;

	public int bestGrade = 100;

	public LocalLeaderboard leaderboard;

	public DifficultyData()
	{
		leaderboard = new LocalLeaderboard();
	}

	public void CheckGrade(int _grade)
	{
		if (_grade < bestGrade)
		{
			bestGrade = _grade;
		}
	}
}
[Serializable]
public class LocalLeaderboard
{
	public List<LocalLeaderboardEntry> entries;

	public LocalLeaderboard()
	{
		entries = new List<LocalLeaderboardEntry>();
	}

	public void SubmitScore(LocalLeaderboardEntry _entry)
	{
		entries.Add(_entry);
		entries.Sort(SortByScore);
		if (entries.Count > 10)
		{
			entries.RemoveAt(10);
		}
	}

	private int SortByScore(LocalLeaderboardEntry _e1, LocalLeaderboardEntry _e2)
	{
		return _e1.score.CompareTo(_e2.score) * -1;
	}

	public void Reset()
	{
		entries.Clear();
	}
}
[Serializable]
public class LocalLeaderboardEntry
{
	public string name = "ERROR";

	public int score;

	public int grade = 100;

	public LocalLeaderboardEntry()
	{
	}

	public LocalLeaderboardEntry(string _name, int _score, int _grade)
	{
		name = _name;
		score = _score;
		grade = _grade;
	}
}
public class SaveManager : MonoBehaviour
{
	public DCSaveData curSave;

	private DCSaveData localLeaders;

	public SettingsSave settingsSave;

	private string userFilePath;

	private string localFilePath;

	private string settingsPath;

	public bool disableProgress;

	[Space(10f)]
	[Range(0f, 1f)]
	public float auraDebug;

	public static string[] Colliders = new string[180]
	{
		"Arcade_Yuri_1_Easy", "Arcade_Yuri_1_Normal", "Arcade_Yuri_1_Hard", "Arcade_Yuri_2_Easy", "Arcade_Yuri_2_Normal", "Arcade_Yuri_2_Hard", "Arcade_Yuri_3_Easy", "Arcade_Yuri_3_Normal", "Arcade_Yuri_3_Hard", "Arcade_Yuri_4_Easy",
		"Arcade_Yuri_4_Normal", "Arcade_Yuri_4_Hard", "Arcade_Yuri_5_Easy", "Arcade_Yuri_5_Normal", "Arcade_Yuri_5_Hard", "Arcade_Pyro_1_Easy", "Arcade_Pyro_1_Normal", "Arcade_Pyro_1_Hard", "Arcade_Pyro_2_Easy", "Arcade_Pyro_2_Normal",
		"Arcade_Pyro_2_Hard", "Arcade_Pyro_3_Easy", "Arcade_Pyro_3_Normal", "Arcade_Pyro_3_Hard", "Arcade_Pyro_4_Easy", "Arcade_Pyro_4_Normal", "Arcade_Pyro_4_Hard", "Arcade_Pyro_5_Easy", "Arcade_Pyro_5_Normal", "Arcade_Pyro_5_Hard",
		"Arcade_Lais_1_Easy", "Arcade_Lais_1_Normal", "Arcade_Lais_1_Hard", "Arcade_Lais_2_Easy", "Arcade_Lais_2_Normal", "Arcade_Lais_2_Hard", "Arcade_Lais_3_Easy", "Arcade_Lais_3_Normal", "Arcade_Lais_3_Hard", "Arcade_Lais_4_Easy",
		"Arcade_Lais_4_Normal", "Arcade_Lais_4_Hard", "Arcade_Lais_5_Easy", "Arcade_Lais_5_Normal", "Arcade_Lais_5_Hard", "Arcade_Remi_1_Easy", "Arcade_Remi_1_Normal", "Arcade_Remi_1_Hard", "Arcade_Remi_2_Easy", "Arcade_Remi_2_Normal",
		"Arcade_Remi_2_Hard", "Arcade_Remi_3_Easy", "Arcade_Remi_3_Normal", "Arcade_Remi_3_Hard", "Arcade_Remi_4_Easy", "Arcade_Remi_4_Normal", "Arcade_Remi_4_Hard", "Arcade_Remi_5_Easy", "Arcade_Remi_5_Normal", "Arcade_Remi_5_Hard",
		"Arcade_Liu_1_Easy", "Arcade_Liu_1_Normal", "Arcade_Liu_1_Hard", "Arcade_Liu_2_Easy", "Arcade_Liu_2_Normal", "Arcade_Liu_2_Hard", "Arcade_Liu_3_Easy", "Arcade_Liu_3_Normal", "Arcade_Liu_3_Hard", "Arcade_Liu_4_Easy",
		"Arcade_Liu_4_Normal", "Arcade_Liu_4_Hard", "Arcade_Liu_5_Easy", "Arcade_Liu_5_Normal", "Arcade_Liu_5_Hard", "Arcade_Dre_1_Easy", "Arcade_Dre_1_Normal", "Arcade_Dre_1_Hard", "Arcade_Dre_2_Easy", "Arcade_Dre_2_Normal",
		"Arcade_Dre_2_Hard", "Arcade_Dre_3_Easy", "Arcade_Dre_3_Normal", "Arcade_Dre_3_Hard", "Arcade_Dre_4_Easy", "Arcade_Dre_4_Normal", "Arcade_Dre_4_Hard", "Arcade_Dre_5_Easy", "Arcade_Dre_5_Normal", "Arcade_Dre_5_Hard",
		"Arcade_Sonya_1_Easy", "Arcade_Sonya_1_Normal", "Arcade_Sonya_1_Hard", "Arcade_Sonya_2_Easy", "Arcade_Sonya_2_Normal", "Arcade_Sonya_2_Hard", "Arcade_Sonya_3_Easy", "Arcade_Sonya_3_Normal", "Arcade_Sonya_3_Hard", "Arcade_Sonya_4_Easy",
		"Arcade_Sonya_4_Normal", "Arcade_Sonya_4_Hard", "Arcade_Sonya_5_Easy", "Arcade_Sonya_5_Normal", "Arcade_Sonya_5_Hard", "Arcade_Core_1_Easy", "Arcade_Core_1_Normal", "Arcade_Core_1_Hard", "Arcade_Core_2_Easy", "Arcade_Core_2_Normal",
		"Arcade_Core_2_Hard", "Arcade_Core_3_Easy", "Arcade_Core_3_Normal", "Arcade_Core_3_Hard", "Arcade_Core_4_Easy", "Arcade_Core_4_Normal", "Arcade_Core_4_Hard", "Arcade_Core_5_Easy", "Arcade_Core_5_Normal", "Arcade_Core_5_Hard",
		"Arcade_Uriel_1_Easy", "Arcade_Uriel_1_Normal", "Arcade_Uriel_1_Hard", "Arcade_Uriel_2_Easy", "Arcade_Uriel_2_Normal", "Arcade_Uriel_2_Hard", "Arcade_Uriel_3_Easy", "Arcade_Uriel_3_Normal", "Arcade_Uriel_3_Hard", "Arcade_Uriel_4_Easy",
		"Arcade_Uriel_4_Normal", "Arcade_Uriel_4_Hard", "Arcade_Uriel_5_Easy", "Arcade_Uriel_5_Normal", "Arcade_Uriel_5_Hard", "Arcade_Yuri_1_X", "Arcade_Yuri_2_X", "Arcade_Yuri_3_X", "Arcade_Yuri_4_X", "Arcade_Yuri_5_X",
		"Arcade_Pyro_1_X", "Arcade_Pyro_2_X", "Arcade_Pyro_3_X", "Arcade_Pyro_4_X", "Arcade_Pyro_5_X", "Arcade_Lais_1_X", "Arcade_Lais_2_X", "Arcade_Lais_3_X", "Arcade_Lais_4_X", "Arcade_Lais_5_X",
		"Arcade_Remi_1_X", "Arcade_Remi_2_X", "Arcade_Remi_3_X", "Arcade_Remi_4_X", "Arcade_Remi_5_X", "Arcade_Liu_1_X", "Arcade_Liu_2_X", "Arcade_Liu_3_X", "Arcade_Liu_4_X", "Arcade_Liu_5_X",
		"Arcade_Dre_1_X", "Arcade_Dre_2_X", "Arcade_Dre_3_X", "Arcade_Dre_4_X", "Arcade_Dre_5_X", "Arcade_Sonya_1_X", "Arcade_Sonya_2_X", "Arcade_Sonya_3_X", "Arcade_Sonya_4_X", "Arcade_Sonya_5_X",
		"Arcade_Core_1_X", "Arcade_Core_2_X", "Arcade_Core_3_X", "Arcade_Core_4_X", "Arcade_Core_5_X", "Arcade_Uriel_1_X", "Arcade_Uriel_2_X", "Arcade_Uriel_3_X", "Arcade_Uriel_4_X", "Arcade_Uriel_5_X"
	};

	public float localUrielProgress;

	private void Start()
	{
		LoadSettings();
		PopulateLocalPrefs();
	}

	public void PopulateLocalPrefs()
	{
		localUrielProgress = PlayerPrefs.GetFloat("Uriel_Progress", 0f);
		UnityEngine.Debug.Log("Populated local uriel progress");
	}

	public void LoadSettings()
	{
		Persistence.instance.svMan.settingsSave.skipIntros = GetBool("skipIntros", _default: false);
		Persistence.instance.svMan.settingsSave.enableDanceholograms = GetBool("enableDanceholograms");
		Persistence.instance.svMan.settingsSave.enableUI = GetBool("enableUI");
		Persistence.instance.svMan.settingsSave.enableParticles = GetBool("enableParticles");
		Persistence.instance.svMan.settingsSave.double_colour = PlayerPrefs.GetFloat("double_colour", 0.1866667f);
		Persistence.instance.svMan.settingsSave.left_Colour = PlayerPrefs.GetFloat("left_Colour", 5f / 6f);
		Persistence.instance.svMan.settingsSave.right_Colour = PlayerPrefs.GetFloat("right_Colour", 0.4013802f);
		UnityEngine.Debug.Log("settings loaded!");
	}

	public void SaveSettings()
	{
		SetBool("skipIntros", Persistence.instance.svMan.settingsSave.skipIntros);
		SetBool("enableDanceholograms", Persistence.instance.svMan.settingsSave.enableDanceholograms);
		SetBool("enableUI", Persistence.instance.svMan.settingsSave.enableUI);
		SetBool("enableParticles", Persistence.instance.svMan.settingsSave.enableParticles);
		PlayerPrefs.SetFloat("double_colour", Persistence.instance.svMan.settingsSave.double_colour);
		PlayerPrefs.SetFloat("left_Colour", Persistence.instance.svMan.settingsSave.left_Colour);
		PlayerPrefs.SetFloat("right_Colour", Persistence.instance.svMan.settingsSave.right_Colour);
		SavePrefs();
		UnityEngine.Debug.Log("settings saved!");
	}

	private bool GetBool(string name, bool _default = true)
	{
		return PlayerPrefs.GetInt(name, _default ? 1 : 0) == 1;
	}

	private void SetBool(string name, bool value)
	{
		PlayerPrefs.SetInt(name, value ? 1 : 0);
	}

	public void SavePrefs()
	{
		PlayerPrefs.Save();
		UnityEngine.Debug.Log("Saved PlayerPrefs");
	}

	public void ClearSave()
	{
		string[] colliders = Colliders;
		foreach (string collider in colliders)
		{
			SetColliderRank(collider, Score.Rank.Blank);
		}
		ResetUrielProgress();
		SavePrefs();
	}

	public Score.Rank GetColliderRank(string collider)
	{
		Score.Rank @int = (Score.Rank)PlayerPrefs.GetInt(collider, 18);
		UnityEngine.Debug.Log("Get rank from " + collider + " returned " + @int);
		return @int;
	}

	[Obsolete]
	public Score.Rank GetLocalColliderRank(string collider)
	{
		return Score.Rank.Blank;
	}

	public void SetColliderRank(string collider, Score.Rank rank)
	{
		PlayerPrefs.SetInt(collider, (int)rank);
		UnityEngine.Debug.Log("Set rank " + collider + " to " + rank);
		SavePrefs();
	}

	public int GetStageRank(string _collider)
	{
		return (int)GetColliderRank(_collider);
	}

	public void IncreaseUrielUnlock(float amount)
	{
		localUrielProgress = Mathf.Min(1f, localUrielProgress + amount);
		PlayerPrefs.SetFloat("Uriel_Progress", localUrielProgress);
		SavePrefs();
	}

	public void ResetUrielProgress()
	{
		PlayerPrefs.SetFloat("Uriel_Progress", 0f);
		SavePrefs();
	}
}
[Serializable]
public class SettingsSave
{
	public float masterVolume;

	public float gameMusicVolume;

	public float ambientMusicVolume;

	public float sfxVolume;

	public float voVolume;

	public float auraQuality;

	public int language;

	public bool enableDanceholograms;

	public bool enableLightshows;

	public bool enableTauntParticles;

	public bool enableNodeSounds;

	public bool enableAura;

	public bool skipIntros;

	public bool postProcessing;

	public int antiAliasing;

	public bool smoothCamera;

	public float smoothCamera_Smoothness;

	public float smoothCamera_FOV;

	public bool smoothCamera_postProcessing;

	public float left_Colour;

	public float right_Colour;

	public float double_colour;

	public float room_xOffset;

	public float room_zOffset;

	public float room_rotation;

	public bool autoCalibration;

	public float calibrationHeight;

	public bool enableFog;

	public bool enableEnvironments;

	public bool enableParticles;

	public bool enableUI;

	public SettingsSave()
	{
		masterVolume = 1f;
		gameMusicVolume = 0.85f;
		ambientMusicVolume = 1f;
		sfxVolume = 1f;
		voVolume = 1f;
		auraQuality = 0.5f;
		language = 0;
		enableDanceholograms = false;
		enableLightshows = false;
		enableTauntParticles = false;
		enableNodeSounds = true;
		enableAura = false;
		skipIntros = true;
		postProcessing = false;
		antiAliasing = 1;
		smoothCamera = false;
		smoothCamera_Smoothness = 0.9f;
		smoothCamera_FOV = 100f;
		smoothCamera_postProcessing = true;
		Color.RGBToHSV(new Color(1f, 0.17f, 1f, 1f), out left_Colour, out var S, out var V);
		Color.RGBToHSV(new Color(0f, 0.9528301f, 0.3890223f, 1f), out right_Colour, out V, out S);
		Color.RGBToHSV(new Color(0.88f, 1f, 0f, 1f), out double_colour, out S, out V);
		room_xOffset = 0f;
		room_zOffset = 0f;
		room_rotation = 0f;
		autoCalibration = true;
		calibrationHeight = 1.6f;
		enableFog = false;
		enableEnvironments = false;
		enableParticles = false;
		enableUI = true;
	}
}
[Serializable]
public class TutorialChunk
{
	public string title;

	public TutorialInfo intro;

	public GameObject demoObject;

	public string colliderFileName;

	public List<TutorialScoreCard> scoreCards = new List<TutorialScoreCard>();

	public List<TutorialResults> results = new List<TutorialResults>();

	public bool done;

	public bool passed;

	public bool fadeAudio;

	public bool ignorePower;

	private GlobalTutorialObjects gto;

	private GameManager gMan;

	private float introTimer = -1f;

	private float resultsTimer = -1f;

	public void StartChunk(GlobalTutorialObjects _gto)
	{
		gto = _gto;
		gto.title.text = ParseLoc.Parse(title);
		gto.title.GetComponent<TextFader>().FadeIn();
		gMan = GameManager.instance;
		SetupChunk();
		SetInfo(intro);
		if (demoObject != null)
		{
			demoObject.GetComponent<FadeFinder>().FadeIn();
		}
		introTimer = _gto.universalDelay + intro.extradelay;
		if (intro.VO != null)
		{
			introTimer += intro.VO.length;
		}
		gto.skipButton.SetActive(value: true);
		GameManager.instance.TogglePointers(toggle: true);
	}

	public void RepeatChunk()
	{
		SetupChunk();
		introTimer = 0f;
	}

	private void SetupChunk()
	{
		if (colliderFileName != "")
		{
			Persistence.instance.currentSongFilename = colliderFileName;
			gMan.LoadDance();
			gMan.currentSong.InitSong(0f, incremental: false);
		}
		else
		{
			passed = true;
		}
		fadeAudio = false;
		gto.musicSource.volume = 1f;
	}

	public void UpdateChunk()
	{
		if (introTimer >= 0f)
		{
			introTimer -= Time.deltaTime;
			if (introTimer < 0f)
			{
				if (!passed)
				{
					StartDance();
				}
				else
				{
					done = true;
				}
			}
		}
		if (resultsTimer >= 0f)
		{
			resultsTimer -= Time.deltaTime;
			if (resultsTimer < 0f)
			{
				done = true;
			}
		}
		if (fadeAudio)
		{
			gto.musicSource.volume = Mathf.Lerp(gto.musicSource.volume, 0f, gto.audioFadeRate * Time.deltaTime);
		}
	}

	public void StartDance()
	{
		if (demoObject != null)
		{
			demoObject.GetComponent<FadeFinder>().FadeOut();
		}
		gto.info.GetComponent<TextFader>().FadeOut();
		gto.skipButton.SetActive(value: false);
		GameManager.instance.TogglePointers(toggle: false);
		gto.title.GetComponent<TextFader>().FadeOut();
		gMan.dspSongStartTime = (float)AudioSettings.dspTime;
		gMan.StartSong();
	}

	public void EndDance()
	{
		for (int i = 0; i < results.Count; i++)
		{
			TutorialResults tutorialResults = results[i];
			float accuracy = gMan.score.GetAccuracy();
			float pow = 100f;
			if (!ignorePower)
			{
				pow = gMan.score.GetEnergyRating();
			}
			int perfectCascades = gMan.score.perfectCascades;
			if (tutorialResults.Cleared(accuracy, pow, perfectCascades))
			{
				SetInfo(tutorialResults.result);
				resultsTimer = gto.universalDelay + tutorialResults.result.extradelay;
				if (tutorialResults.result.VO != null)
				{
					resultsTimer += tutorialResults.result.VO.length;
				}
				gto.skipButton.SetActive(value: true);
				GameManager.instance.TogglePointers(toggle: true);
				passed = tutorialResults.passing;
				break;
			}
			TutorialInfo tutorialInfo = new TutorialInfo();
			tutorialInfo.text = "ERROR";
			resultsTimer = gto.universalDelay;
			SetInfo(tutorialInfo);
		}
		fadeAudio = true;
	}

	private void SetInfo(TutorialInfo _info)
	{
		if (_info.VO != null)
		{
			gto.audioS.clip = _info.VO;
			gto.audioS.Play();
		}
		gto.info.text = ParseLoc.Parse(_info.text);
		gto.info.gameObject.GetComponent<TextFader>().FadeIn();
	}

	public TutorialInfo GetCard(float _power)
	{
		for (int i = 0; i < scoreCards.Count; i++)
		{
			TutorialScoreCard tutorialScoreCard = scoreCards[i];
			if (_power >= tutorialScoreCard.reqPower.x && _power <= tutorialScoreCard.reqPower.y)
			{
				return tutorialScoreCard.cardInfo[UnityEngine.Random.Range(0, tutorialScoreCard.cardInfo.Count)];
			}
		}
		return new TutorialInfo
		{
			text = "ERROR",
			VO = null
		};
	}

	public void SkipText()
	{
		if (introTimer > 0f)
		{
			introTimer = 0f;
		}
		if (resultsTimer > 0f)
		{
			resultsTimer = 0f;
		}
	}
}
[Serializable]
public class TutorialResults
{
	public TutorialInfo result;

	public Vector2 reqAccuracy;

	public Vector2 reqPower;

	public int reqCascades;

	public bool passing;

	public bool Cleared(float _acc, float _pow, int _casc)
	{
		UnityEngine.Debug.Log("Checking " + _acc + " & " + _pow);
		if (_acc >= reqAccuracy.x && _acc <= reqAccuracy.y && _pow >= reqPower.x && _pow <= reqPower.y && _casc >= reqCascades)
		{
			return true;
		}
		return false;
	}
}
[Serializable]
public class TutorialInfo
{
	public AudioClip VO;

	[Multiline]
	public string text;

	public float extradelay;
}
[Serializable]
public class TutorialScoreCard
{
	public List<TutorialInfo> cardInfo = new List<TutorialInfo>();

	public Vector2 reqPower;
}
[Serializable]
public class GlobalTutorialObjects
{
	public AudioSource audioS;

	public AudioSource musicSource;

	public float audioFadeRate;

	public TextMeshProUGUI title;

	public TextMeshProUGUI info;

	public float universalDelay;

	public GameObject skipButton;
}
public class TutorialManager : MonoBehaviour
{
	public GlobalTutorialObjects globalObjects;

	public List<TutorialChunk> tutorialSections = new List<TutorialChunk>();

	[HideInInspector]
	public bool throwCards = true;

	private int curChunk = -1;

	private float cooldown = 0.5f;

	private float timer;

	private void Awake()
	{
		GameManager.instance.tutMan = this;
		throwCards = true;
		for (int i = 0; i < tutorialSections.Count; i++)
		{
			TutorialChunk tutorialChunk = tutorialSections[i];
			LoadAudio(tutorialChunk.intro);
			for (int j = 0; j < tutorialChunk.results.Count; j++)
			{
				TutorialResults tutorialResults = tutorialChunk.results[j];
				LoadAudio(tutorialResults.result);
			}
			for (int k = 0; k < tutorialChunk.scoreCards.Count; k++)
			{
				TutorialScoreCard tutorialScoreCard = tutorialChunk.scoreCards[k];
				for (int l = 0; l < tutorialScoreCard.cardInfo.Count; l++)
				{
					LoadAudio(tutorialScoreCard.cardInfo[l]);
				}
			}
		}
	}

	private void LoadAudio(TutorialInfo _info)
	{
		if (_info.VO != null)
		{
			_info.VO.LoadAudioData();
		}
	}

	private void Update()
	{
		if (curChunk > -1 && curChunk < tutorialSections.Count)
		{
			tutorialSections[curChunk].UpdateChunk();
			if (tutorialSections[curChunk].done)
			{
				EndChunk();
			}
		}
		if (timer >= 0f)
		{
			timer -= Time.deltaTime;
		}
	}

	public void StartTutorial()
	{
		curChunk = 0;
		tutorialSections[curChunk].StartChunk(globalObjects);
	}

	public void EndDance()
	{
		tutorialSections[curChunk].EndDance();
	}

	private void EndChunk()
	{
		TutorialChunk tutorialChunk = tutorialSections[curChunk];
		if (tutorialChunk.passed)
		{
			curChunk++;
			if (curChunk < tutorialSections.Count)
			{
				tutorialSections[curChunk].StartChunk(globalObjects);
			}
			else
			{
				BackToLobby();
			}
		}
		else
		{
			tutorialChunk.done = false;
			tutorialChunk.RepeatChunk();
		}
	}

	public void ThrowScoreCard(float _power)
	{
		_power = Mathf.InverseLerp(GameManager.instance.minVelocity, GameManager.instance.maxVelocity, _power) * 100f;
		if (timer < 0f && tutorialSections[curChunk].scoreCards.Count > 0)
		{
			TutorialInfo card = tutorialSections[curChunk].GetCard(_power);
			GameManager.instance.ThrowTutorialScoreCard(ParseLoc.Parse(card.text));
			if (card.VO != null)
			{
				globalObjects.audioS.clip = card.VO;
				globalObjects.audioS.Play();
			}
			timer = cooldown;
		}
	}

	public void BackToLobby()
	{
		Persistence.instance.lobbyscreen = 1;
		GameManager.instance.LoadLobby();
	}

	public void SkipText()
	{
		tutorialSections[curChunk].SkipText();
	}
}
public class Keyboard : MonoBehaviour
{
	public TextMeshProUGUI nameText;

	public string input = "";

	public bool submitted;

	public AudioClip keyPressClip;

	public AudioClip backspaceClip;

	public AudioClip submitClip;

	public AudioClip errorClip;

	private AudioSource _audio;

	public Color confirmColour;

	public int maxLength = 10;

	private void Start()
	{
		nameText.text = "";
		_audio = GetComponent<AudioSource>();
	}

	private void UpdateString()
	{
		if (input.Length < 2)
		{
			if (nameText.text != "r")
			{
				nameText.text = input.ToUpper();
			}
		}
		else if (input.Substring(0, 1) != "r")
		{
			nameText.text = input.Substring(0, 1).ToUpper() + input.Substring(1);
		}
	}

	public void SubmitKey(string key)
	{
		if (submitted || input.Length >= maxLength)
		{
			PlayClip(errorClip);
			return;
		}
		PlayClip(keyPressClip);
		input += key;
		UpdateString();
	}

	public void Backspace()
	{
		if (submitted || input.Length < 1)
		{
			PlayClip(errorClip);
			return;
		}
		PlayClip(backspaceClip);
		input = input.Remove(input.Length - 1);
		UpdateString();
	}

	public void Submit()
	{
		if (input.Length < 1)
		{
			PlayClip(errorClip);
			return;
		}
		PlayClip(submitClip);
		submitted = true;
		nameText.color = confirmColour;
		UnityEngine.Object.FindObjectOfType<UI_Leaderboard>().SubmitLocalScore(nameText.text);
		Invoke("HideKeyboard", 1f);
	}

	private void PlayClip(AudioClip clip)
	{
		_audio.Stop();
		_audio.clip = clip;
		_audio.Play();
	}

	private void HideKeyboard()
	{
		base.gameObject.SetActive(value: false);
	}
}
public class Lobby_UI_Manager : MonoBehaviour
{
	public static Lobby_UI_Manager instance;

	public List<UI_Screen> screens;

	public GameObject settings;

	private bool lastPause;

	public List<AudioClip> musicPreviews;

	public AudioClip lobbyMusic;

	public AudioSource _audio;

	private void Awake()
	{
		if (instance == null)
		{
			instance = this;
		}
	}

	private void Start()
	{
		screens[Persistence.instance.lobbyscreen].Transition(on: true);
		Persistence.instance.lobbyscreen = 1;
		for (int i = 0; i < musicPreviews.Count; i++)
		{
			musicPreviews[i].LoadAudioData();
		}
	}

	private void Update()
	{
		_ = PlatformManager.inst.paused;
		_ = lastPause;
		lastPause = PlatformManager.inst.paused;
	}

	private void DisableAllScreens()
	{
		foreach (UI_Screen screen in screens)
		{
			screen.Transition(on: false);
		}
	}

	public void TransitionTo(UI_Screen screen)
	{
		DisableAllScreens();
		screen.Transition(on: true);
	}

	public void LoadGame()
	{
		UnityEngine.Object.FindObjectOfType<FadeInOut>().target = 1f;
		UnityEngine.Object.FindObjectOfType<FadeInOut>().Fade();
		Persistence.instance.builtInSong = true;
		StartCoroutine(LoadSceneDelayed("Game"));
	}

	public void LoadGameCustom()
	{
		UnityEngine.Object.FindObjectOfType<FadeInOut>().target = 1f;
		UnityEngine.Object.FindObjectOfType<FadeInOut>().Fade();
		Persistence.instance.builtInSong = false;
		StartCoroutine(LoadSceneDelayed("Game"));
	}

	public void LoadTutorial()
	{
		Persistence.instance.currentSongFilename = "Tutorial_0";
		Persistence.instance.currentDifficulty = 0;
		UnityEngine.Application.backgroundLoadingPriority = UnityEngine.ThreadPriority.High;
		UnityEngine.Object.FindObjectOfType<FadeInOut>().target = 1f;
		UnityEngine.Object.FindObjectOfType<FadeInOut>().Fade();
		Persistence.instance.builtInSong = true;
		StartCoroutine(LoadSceneDelayed("Tutorial"));
	}

	public void LoadEditor()
	{
		UnityEngine.Object.FindObjectOfType<FadeInOut>().target = 1f;
		UnityEngine.Object.FindObjectOfType<FadeInOut>().Fade();
		Persistence.instance.builtInSong = false;
		StartCoroutine(LoadSceneDelayed("DanceEditor"));
	}

	private IEnumerator LoadSceneDelayed(string scene)
	{
		yield return new WaitForSecondsRealtime(1f);
		Persistence.instance.ToggleOverlay(toggle: true);
		UnityEngine.Application.backgroundLoadingPriority = UnityEngine.ThreadPriority.High;
		yield return new WaitForSecondsRealtime(0.5f);
		SceneManager.LoadScene(scene);
	}

	public void SetLanguage(string _language)
	{
		Persistence.instance.GetComponent<SetLanguage>()._Language = _language;
		Persistence.instance.GetComponent<SetLanguage>().ApplyLanguage();
	}

	public void ChangeMusic(int music)
	{
		_audio.Stop();
		if (music == -1)
		{
			_audio.clip = lobbyMusic;
		}
		else
		{
			_audio.clip = musicPreviews[music];
		}
		_audio.Play();
	}

	public void ToggleSettings(bool on)
	{
		settings.SetActive(on);
	}
}
public class UI_Screen : MonoBehaviour
{
	public virtual void Transition(bool on)
	{
		base.gameObject.SetActive(on);
	}
}
public class GetSongData : MonoBehaviour
{
	[Serializable]
	public class CharacterSongData
	{
		[Space]
		[Space]
		public string songName;

		public string songDuration;

		public string songBPM;

		public string filename;

		public AudioClip songPreview;
	}

	public string songName;

	public string songDuration;

	public string songBPM;

	public int songRank;

	public List<CharacterSongData> _DreSongData = new List<CharacterSongData>();

	public List<CharacterSongData> _CoreSongData = new List<CharacterSongData>();

	public List<CharacterSongData> _LaisSongData = new List<CharacterSongData>();

	public List<CharacterSongData> _LuiwenSongData = new List<CharacterSongData>();

	public List<CharacterSongData> _PyrosSongData = new List<CharacterSongData>();

	public List<CharacterSongData> _RemiSongData = new List<CharacterSongData>();

	public List<CharacterSongData> _SonyaSongData = new List<CharacterSongData>();

	public List<CharacterSongData> _YuriSongData = new List<CharacterSongData>();

	public List<CharacterSongData> _UrielSongData = new List<CharacterSongData>();

	public CharacterSongData GetBuiltInSongData(int characterID, int songID)
	{
		CharacterSongData result = new CharacterSongData();
		switch (characterID)
		{
		case 0:
			result = _YuriSongData[songID];
			break;
		case 1:
			result = _PyrosSongData[songID];
			break;
		case 2:
			result = _LaisSongData[songID];
			break;
		case 3:
			result = _RemiSongData[songID];
			break;
		case 4:
			result = _LuiwenSongData[songID];
			break;
		case 5:
			result = _DreSongData[songID];
			break;
		case 6:
			result = _SonyaSongData[songID];
			break;
		case 7:
			result = _CoreSongData[songID];
			break;
		case 8:
			result = _UrielSongData[songID];
			break;
		}
		return result;
	}
}
public class LobbyMainMenuManager : MonoBehaviour
{
	public static LobbyMainMenuManager instance;

	public List<LobbyMenu_AbstractClass> windows;

	[HideInInspector]
	public List<LobbyMenu_AbstractClass> settingsWindows;

	[HideInInspector]
	public LobbyMenu_AbstractClass currentWindow;

	[HideInInspector]
	public LobbyMenu_AbstractClass previousWindow;

	[HideInInspector]
	public LobbyMenu_AbstractClass settingsPreviousWindow;

	public Lobby_Title title;

	public Lobby_CharacterSelect characterSelect;

	public Lobby_SongSelect songSelect;

	public Lobby_Leaderboards leaderboards;

	public Lobby_CharacterBio characterBio;

	public Lobby_CustomSongSelect customSongSelect;

	public Lobby_Settings_Graphics settingsMenu;

	public Lobby_Settings_Credits credits;

	public Lobby_Settings_Language languageSettings;

	public Lobby_Setting_Audio audioSettings;

	public TextMeshProUGUI currentMenuDescription;

	public Button backButton;

	public Button settingsButton;

	public GameObject discordButton;

	[HideInInspector]
	public bool settingsBackButton_Toggle;

	[HideInInspector]
	public UnityEvent goBack;

	[HideInInspector]
	public UnityEvent goBack_Settings;

	public AudioSource music;

	public AudioClip defaultMusic;

	public GameObject yuriObject;

	public GameObject pyroObject;

	public GameObject laisObject;

	public GameObject dreObject;

	public GameObject liuObject;

	public GameObject remiObject;

	public GameObject sonyaObject;

	public GameObject coreObject;

	public int selectedCharacter;

	public LipSyncData[] yuriVO;

	public LipSyncData[] pyroVO;

	public LipSyncData[] laisVO;

	public LipSyncData[] dreVO;

	public LipSyncData[] liuVO;

	public LipSyncData[] remiVO;

	public LipSyncData[] sonyaVO;

	public LipSyncData[] coreVO;

	private void Awake()
	{
		if (instance == null)
		{
			instance = this;
		}
	}

	private void Start()
	{
		foreach (LobbyMenu_AbstractClass window in windows)
		{
			if (window != null)
			{
				window.mainMenuManager = this;
				window.gameObject.SetActive(value: false);
			}
		}
		backButton.gameObject.SetActive(value: true);
		currentMenuDescription.transform.parent.gameObject.SetActive(value: true);
		if (windows[Persistence.instance.lobbyscreen] != null)
		{
			windows[Persistence.instance.lobbyscreen].OpenWindow();
		}
		Persistence.instance.lobbyscreen = 1;
		StartCoroutine(LateStart());
	}

	private IEnumerator LateStart()
	{
		yield return new WaitForSecondsRealtime(1.5f);
	}

	public void GoBack()
	{
		if (previousWindow != null)
		{
			currentWindow.CloseWindow();
			previousWindow.OpenWindow();
		}
	}

	public void OpenSettings()
	{
		if (currentWindow != settingsMenu)
		{
			currentWindow.CloseWindow();
			settingsMenu.OpenWindow();
		}
	}

	public void OpenCustom()
	{
		if (currentWindow != customSongSelect)
		{
			currentWindow.CloseWindow();
			customSongSelect.OpenWindow();
		}
	}

	public void OpenLanguage()
	{
		if (currentWindow != languageSettings)
		{
			currentWindow.CloseWindow();
			languageSettings.OpenWindow();
		}
	}

	public void CloseAllBut(LobbyMenu_AbstractClass current)
	{
		foreach (LobbyMenu_AbstractClass window in windows)
		{
			if (window != null && !(window == current) && window.gameObject.activeSelf)
			{
				window.CloseWindow();
			}
		}
	}

	public void SetMenuDescription(string description)
	{
		currentMenuDescription.text = ParseString(description);
	}

	public static string ParseString(string input)
	{
		if (input.StartsWith("#"))
		{
			return LocalizationManager.GetTranslation(input.Substring(1));
		}
		return input;
	}

	private void OnDestroy()
	{
		instance = null;
	}

	public void LoadTutorial()
	{
		SceneManager.LoadScene("Tutorial");
	}

	public void TurnOffAllCharacters()
	{
	}

	public void PlayMusic(AudioClip clip)
	{
		music.Stop();
		music.clip = clip;
		music.Play();
	}

	public void PlayLobbyMusic()
	{
		if (music.clip != defaultMusic)
		{
			PlayMusic(defaultMusic);
		}
	}

	public void ClearSave()
	{
		Persistence.instance.svMan.ClearSave();
		LoadScene("dance collider lobby");
	}

	public void IncreaseUriel()
	{
		Persistence.instance.svMan.IncreaseUrielUnlock(0.1f);
	}

	public void SubmitDummyScore()
	{
		Persistence.instance.GetComponent<OculusManager>().SubmitScore(UnityEngine.Random.Range(100, 2000));
	}

	public void TestGetRanks()
	{
		Persistence.instance.GetComponent<OculusManager>().RequestTop();
	}

	private IEnumerator LoadSceneDelayed(string scene)
	{
		yield return new WaitForSecondsRealtime(1f);
		Persistence.instance.ToggleOverlay(toggle: true);
		UnityEngine.Application.backgroundLoadingPriority = UnityEngine.ThreadPriority.High;
		yield return new WaitForSecondsRealtime(0.5f);
		SceneManager.LoadScene(scene);
	}

	public void LoadScene(string scene)
	{
		UnityEngine.Object.FindObjectOfType<FadeInOut>().target = 1f;
		UnityEngine.Object.FindObjectOfType<FadeInOut>().Fade();
		StartCoroutine(LoadSceneDelayed(scene));
	}

	public void PlayYuriVO()
	{
		yuriObject.GetComponentInChildren<LipSync>().Play(yuriVO[UnityEngine.Random.Range(0, yuriVO.Length)], 0f);
	}

	public void PlayPyroVO()
	{
		pyroObject.GetComponentInChildren<LipSync>().Play(pyroVO[UnityEngine.Random.Range(0, pyroVO.Length)], 0f);
	}

	public void PlayLaisVO()
	{
		laisObject.GetComponentInChildren<LipSync>().Play(laisVO[UnityEngine.Random.Range(0, laisVO.Length)], 0f);
	}

	public void PlayDreVO()
	{
		dreObject.GetComponentInChildren<LipSync>().Play(dreVO[UnityEngine.Random.Range(0, dreVO.Length)], 0f);
	}

	public void PlayLiuVO()
	{
		liuObject.GetComponentInChildren<LipSync>().Play(liuVO[UnityEngine.Random.Range(0, liuVO.Length)], 0f);
	}

	public void PlayRemiVO()
	{
		remiObject.GetComponentInChildren<LipSync>().Play(remiVO[UnityEngine.Random.Range(0, remiVO.Length)], 0f);
	}

	public void PlaySonyaVO()
	{
		sonyaObject.GetComponentInChildren<LipSync>().Play(sonyaVO[UnityEngine.Random.Range(0, sonyaVO.Length)], 0f);
	}

	public void PlayCoreVO()
	{
		coreObject.GetComponentInChildren<LipSync>().Play(coreVO[UnityEngine.Random.Range(0, coreVO.Length)], 0f);
	}
}
public abstract class LobbyMenu_AbstractClass : MonoBehaviour
{
	public string menuDescription;

	[HideInInspector]
	public LobbyMainMenuManager mainMenuManager;

	private Text descriptionText;

	public abstract void OpenWindow();

	public abstract void CloseWindow();

	public virtual void Transition(bool activeState)
	{
		if (activeState)
		{
			base.gameObject.SetActive(activeState);
			if (mainMenuManager != null)
			{
				mainMenuManager.SetMenuDescription(ParseLoc.Parse(menuDescription));
			}
		}
		else
		{
			base.gameObject.SetActive(activeState);
		}
	}

	private void SetActiveState()
	{
		base.gameObject.SetActive(value: false);
	}
}
public class Lobby_CharacterBio : LobbyMenu_AbstractClass
{
	public override void CloseWindow()
	{
		base.Transition(activeState: false);
	}

	public override void OpenWindow()
	{
		base.Transition(activeState: true);
		mainMenuManager.previousWindow = mainMenuManager.characterSelect;
		mainMenuManager.currentWindow = this;
	}
}
[Serializable]
public class CharacterInfo
{
	public Sprite characterBG;

	public Sprite characterPortrait;

	public string CharacterName;

	public string CharacterDescription;

	public string CharacterStyle;

	public string CharacterOrigin;
}
public class Lobby_CharacterSelect : LobbyMenu_AbstractClass
{
	public Image characterInfo_characterBG;

	public Image characterInfo_characterPortrait;

	public TextMeshProUGUI characterInfo_CharacterName;

	public TextMeshProUGUI characterInfo_CharacterRealName;

	public TextMeshProUGUI characterInfo_CharacterDescription;

	public TextMeshProUGUI characterInfo_CharacterAge;

	public Image selectedCharacterProfile;

	public Button selectButton;

	public Button bioButton;

	public List<CharacterInfo> _characterinfos = new List<CharacterInfo>();

	public Button urielButton;

	public GameObject[] uriel_locked_objects;

	public GameObject[] uriel_unlocked_objects;

	public Image urielBar;

	public GameObject yuriObject;

	public GameObject pyroObject;

	public GameObject laisObject;

	public GameObject dreObject;

	public GameObject liuObject;

	public GameObject remiObject;

	public GameObject sonyaObject;

	public GameObject coreObject;

	public GameObject urielObject;

	public override void OpenWindow()
	{
		base.Transition(activeState: true);
		mainMenuManager.previousWindow = mainMenuManager.title;
		mainMenuManager.currentWindow = this;
		selectButton.interactable = false;
		bioButton.interactable = false;
		mainMenuManager.settingsButton.gameObject.SetActive(value: true);
		LobbyMainMenuManager.instance.PlayLobbyMusic();
		LobbyMainMenuManager.instance.TurnOffAllCharacters();
		selectedCharacterProfile.gameObject.SetActive(value: false);
		if (Persistence.instance.svMan.localUrielProgress < 1f)
		{
			GameObject[] array = uriel_locked_objects;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].SetActive(value: true);
			}
			array = uriel_unlocked_objects;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].SetActive(value: false);
			}
			urielBar.fillAmount = Persistence.instance.svMan.localUrielProgress;
			urielButton.interactable = false;
		}
		else
		{
			GameObject[] array = uriel_locked_objects;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].SetActive(value: false);
			}
			array = uriel_unlocked_objects;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].SetActive(value: true);
			}
			urielButton.interactable = true;
		}
	}

	public override void CloseWindow()
	{
		base.Transition(activeState: false);
	}

	private void HideAllCharacterBioObjects()
	{
		yuriObject.SetActive(value: false);
		pyroObject.SetActive(value: false);
		laisObject.SetActive(value: false);
		dreObject.SetActive(value: false);
		liuObject.SetActive(value: false);
		remiObject.SetActive(value: false);
		sonyaObject.SetActive(value: false);
		coreObject.SetActive(value: false);
		urielObject.SetActive(value: false);
	}

	public void characterSelected()
	{
		CloseWindow();
		mainMenuManager.characterBio.CloseWindow();
		mainMenuManager.songSelect.OpenWindow();
		switch (mainMenuManager.selectedCharacter)
		{
		case 0:
			mainMenuManager.PlayYuriVO();
			break;
		case 1:
			mainMenuManager.PlayPyroVO();
			break;
		case 2:
			mainMenuManager.PlayLaisVO();
			break;
		case 3:
			mainMenuManager.PlayRemiVO();
			break;
		case 4:
			mainMenuManager.PlayLiuVO();
			break;
		case 5:
			mainMenuManager.PlayDreVO();
			break;
		case 6:
			mainMenuManager.PlaySonyaVO();
			break;
		case 7:
			mainMenuManager.PlayCoreVO();
			break;
		}
	}

	public void CharacterBio()
	{
		CloseWindow();
		mainMenuManager.characterBio.OpenWindow();
	}

	public void Yuri_Button()
	{
		SetCharacterButton(0);
		HideAllCharacterBioObjects();
		yuriObject.SetActive(value: true);
	}

	public void Pyros_Button()
	{
		SetCharacterButton(1);
		HideAllCharacterBioObjects();
		pyroObject.SetActive(value: true);
	}

	public void Lais_Button()
	{
		SetCharacterButton(2);
		HideAllCharacterBioObjects();
		laisObject.SetActive(value: true);
	}

	public void Remis_Button()
	{
		SetCharacterButton(3);
		HideAllCharacterBioObjects();
		remiObject.SetActive(value: true);
	}

	public void Liuwen_Button()
	{
		SetCharacterButton(4);
		HideAllCharacterBioObjects();
		liuObject.SetActive(value: true);
	}

	public void Dre_Button()
	{
		SetCharacterButton(5);
		HideAllCharacterBioObjects();
		dreObject.SetActive(value: true);
	}

	public void Sonya_Button()
	{
		SetCharacterButton(6);
		HideAllCharacterBioObjects();
		sonyaObject.SetActive(value: true);
	}

	public void Kores_Button()
	{
		SetCharacterButton(7);
		HideAllCharacterBioObjects();
		coreObject.SetActive(value: true);
	}

	public void Uriel_Button()
	{
		SetCharacterButton(8);
		HideAllCharacterBioObjects();
		urielObject.SetActive(value: true);
	}

	private void SetCharacterButton(int index)
	{
		selectedCharacterProfile.gameObject.SetActive(value: true);
		LobbyMainMenuManager.instance.TurnOffAllCharacters();
		selectButton.interactable = true;
		bioButton.interactable = true;
		characterInfo_CharacterName.text = LobbyMainMenuManager.ParseString(_characterinfos[index].CharacterName);
		characterInfo_CharacterRealName.text = LobbyMainMenuManager.ParseString(_characterinfos[index].CharacterStyle);
		characterInfo_CharacterDescription.text = LobbyMainMenuManager.ParseString(_characterinfos[index].CharacterDescription);
		characterInfo_CharacterAge.text = LobbyMainMenuManager.ParseString(_characterinfos[index].CharacterOrigin);
		selectedCharacterProfile.sprite = _characterinfos[index].characterPortrait;
		LobbyMainMenuManager.instance.selectedCharacter = index;
	}
}
public class Lobby_CustomSongSelect : LobbyMenu_AbstractClass
{
	public List<Sprite> _ratingSprites;

	public int numcolliders = 4;

	public int selectedSongIndex;

	private int contextRange = 2;

	public TextMeshProUGUI currentSong_Name;

	public GetSongData songData;

	public Button ScrollUpButton;

	public Button ScrollDownButton;

	public Button danceButton;

	public Toggle easyToggle;

	public Toggle normalToggle;

	public Toggle proToggle;

	public Toggle expertToggle;

	public Toggle noFailtoggle;

	public List<CustomSongPreview> top_SongPreviews = new List<CustomSongPreview>();

	public List<CustomSongPreview> bottom_SongPreviews = new List<CustomSongPreview>();

	public List<string> colliders = new List<string>();

	public GameObject noSongsDisplay;

	public GameObject songList;

	public override void OpenWindow()
	{
		base.Transition(activeState: true);
		mainMenuManager.previousWindow = mainMenuManager.title;
		mainMenuManager.currentWindow = this;
		selectedSongIndex = 0;
		foreach (CustomSongPreview top_SongPreview in top_SongPreviews)
		{
			top_SongPreview.gameObject.SetActive(value: true);
		}
		foreach (CustomSongPreview bottom_SongPreview in bottom_SongPreviews)
		{
			bottom_SongPreview.gameObject.SetActive(value: true);
		}
		GetColliders();
		songList.SetActive(colliders.Count > 0);
		noSongsDisplay.SetActive(colliders.Count <= 0);
		danceButton.interactable = colliders.Count > 0;
		if (colliders.Count > 0)
		{
			RefreshUI();
			return;
		}
		ScrollUpButton.interactable = false;
		ScrollDownButton.interactable = false;
	}

	public override void CloseWindow()
	{
		base.Transition(activeState: false);
	}

	public void OpenLeaderboards()
	{
		CloseWindow();
		mainMenuManager.leaderboards.OpenWindow();
	}

	private void RefreshUI()
	{
		InitDifficultyToggles();
		SetSongFileName();
		UpdateSongPreviews();
		UpdateCurrentSong();
		UpdateScrollButtons();
	}

	private void UpdateSongPreviews()
	{
		for (int i = 0; i < top_SongPreviews.Count; i++)
		{
			if (i < selectedSongIndex)
			{
				top_SongPreviews[i].previewGameObject.SetActive(value: true);
				top_SongPreviews[i].songName.text = colliders[selectedSongIndex - (1 - i)];
			}
			else
			{
				top_SongPreviews[i].previewGameObject.SetActive(value: false);
			}
		}
		for (int j = 0; j < bottom_SongPreviews.Count; j++)
		{
			if (selectedSongIndex + (j + 1) < numcolliders)
			{
				bottom_SongPreviews[j].previewGameObject.SetActive(value: true);
				bottom_SongPreviews[j].songName.text = colliders[selectedSongIndex + (j + 1)];
			}
			else
			{
				bottom_SongPreviews[j].previewGameObject.SetActive(value: false);
			}
		}
	}

	private void UpdateCurrentSong()
	{
		currentSong_Name.text = colliders[selectedSongIndex];
	}

	private void UpdateScrollButtons()
	{
		ScrollUpButton.interactable = selectedSongIndex > 0;
		ScrollDownButton.interactable = selectedSongIndex < numcolliders - 1;
	}

	private void InitDifficultyToggles()
	{
		easyToggle.SetIsOnWithoutNotify(Persistence.instance.currentDifficulty == 0);
		normalToggle.SetIsOnWithoutNotify(Persistence.instance.currentDifficulty == 1);
		proToggle.SetIsOnWithoutNotify(Persistence.instance.currentDifficulty == 2);
		expertToggle.SetIsOnWithoutNotify(Persistence.instance.currentDifficulty == 3);
	}

	public void UpdateDifficulty(int diff)
	{
		UnityEngine.Debug.Log("UpdateDifficultyCalled");
		easyToggle.SetIsOnWithoutNotify(value: false);
		normalToggle.SetIsOnWithoutNotify(value: false);
		proToggle.SetIsOnWithoutNotify(value: false);
		expertToggle.SetIsOnWithoutNotify(value: false);
		Persistence.instance.currentDifficulty = diff;
		RefreshUI();
	}

	public void Scroll(bool scrollDown)
	{
		if (scrollDown)
		{
			if (selectedSongIndex < numcolliders - 1)
			{
				selectedSongIndex++;
			}
		}
		else if (selectedSongIndex > 0)
		{
			selectedSongIndex--;
		}
		RefreshUI();
	}

	public void Dance()
	{
		SetSongFileName();
		Persistence.instance.nofail = noFailtoggle.isOn;
		Persistence.instance.builtInSong = false;
		mainMenuManager.LoadScene("Game");
	}

	public void SetSongFileName()
	{
		Persistence.instance.currentSongFilename = colliders[selectedSongIndex];
	}

	private string GetDifficultySuffix()
	{
		if (Persistence.instance.currentDifficulty == 0)
		{
			return "Easy";
		}
		if (Persistence.instance.currentDifficulty == 1)
		{
			return "Normal";
		}
		if (Persistence.instance.currentDifficulty == 2)
		{
			return "Hard";
		}
		UnityEngine.Debug.Log("bad difficulty");
		return "Normal";
	}

	public void LoadSongEditor()
	{
		mainMenuManager.LoadScene("DanceEditor");
	}

	private void GetColliders()
	{
		string text = UnityEngine.Application.persistentDataPath + "/Custom/Dances";
		UnityEngine.Debug.Log("trying to find custom songs at " + text);
		FileInfo[] files = new DirectoryInfo(text).GetFiles();
		numcolliders = 0;
		FileInfo[] array = files;
		foreach (FileInfo fileInfo in array)
		{
			if (fileInfo.Extension == ".json")
			{
				numcolliders++;
				string item = fileInfo.Name.Split('.')[0];
				colliders.Add(item);
			}
		}
	}
}
public class Lobby_Leaderboards : LobbyMenu_AbstractClass
{
	[Serializable]
	public class LeaderboardEntry
	{
		[Space]
		[Space]
		public GameObject entryObject;

		public TextMeshProUGUI position;

		public TextMeshProUGUI playerName;

		public TextMeshProUGUI playerScore;
	}

	[Serializable]
	public class LeaderboardScores
	{
		[Space]
		[Space]
		public int position;

		public string playerName;

		public float playerScore;
	}

	public List<LeaderboardEntry> _leaderboardEntrys = new List<LeaderboardEntry>();

	public List<LeaderboardScores> _leaderboardScores = new List<LeaderboardScores>();

	public Image characterIcon;

	public Image characterBG;

	public TextMeshProUGUI characterName;

	public TextMeshProUGUI songName;

	public TextMeshProUGUI difficultyName;

	public GameObject loadingText;

	public GameObject previewLoadingText;

	public LeaderboardEntry playerentry;

	public LeaderboardEntry preview_above;

	public LeaderboardEntry preview_player;

	public LeaderboardEntry preview_below;

	public int leaderboardIndex;

	public override void CloseWindow()
	{
		base.Transition(activeState: false);
	}

	public override void OpenWindow()
	{
		base.Transition(activeState: true);
		mainMenuManager.previousWindow = mainMenuManager.songSelect;
		mainMenuManager.currentWindow = this;
	}

	public void LoadLeaderboard()
	{
	}

	public void UpdateEntryList(int startAt = 0)
	{
	}

	public void ScrollUp()
	{
	}

	public void ScrollDown()
	{
	}

	public void UpdateNearbyScores(LeaderboardScores _playerScore, LeaderboardScores _previewAbove, LeaderboardScores _previewPlayer, LeaderboardScores _previewBelow)
	{
	}

	private void ResetScoreDisplays()
	{
	}
}
public class Lobby_MainMenu : LobbyMenu_AbstractClass
{
	private void Start()
	{
	}

	public override void OpenWindow()
	{
		base.Transition(activeState: true);
		mainMenuManager.previousWindow = mainMenuManager.title;
		mainMenuManager.currentWindow = this;
		LobbyMainMenuManager.instance.TurnOffAllCharacters();
		LobbyMainMenuManager.instance.backButton.gameObject.SetActive(value: true);
		LobbyMainMenuManager.instance.currentMenuDescription.transform.parent.gameObject.SetActive(value: true);
	}

	public override void CloseWindow()
	{
		base.Transition(activeState: false);
	}

	public void Arcade_Button()
	{
		CloseWindow();
		mainMenuManager.characterSelect.OpenWindow();
	}

	public void CustomSongs_Button()
	{
		CloseWindow();
	}

	public void HowToPlay_Button()
	{
		Persistence.instance.currentSongFilename = "Tutorial_0";
		Persistence.instance.currentDifficulty = 0;
		UnityEngine.Application.backgroundLoadingPriority = UnityEngine.ThreadPriority.High;
		Persistence.instance.builtInSong = true;
		mainMenuManager.LoadScene("Tutorial");
	}
}
public class Lobby_Setting_Audio : LobbyMenu_AbstractClass
{
	public Slider slider_MasterVolume;

	public Slider slider_GameMusic;

	public Slider slider_AmbientMusic;

	public Slider slider_SFXVolume;

	public Slider slider_VoiceVolume;

	public Toggle nodeHits;

	public override void OpenWindow()
	{
		base.Transition(activeState: true);
		mainMenuManager.previousWindow = mainMenuManager.settingsMenu;
		mainMenuManager.currentWindow = this;
		LoadSettings();
	}

	public override void CloseWindow()
	{
		UnityEngine.Debug.Log("audio window close");
		SaveSettings();
		base.Transition(activeState: false);
	}

	public void LoadSettings()
	{
		slider_MasterVolume.value = Persistence.instance.svMan.settingsSave.masterVolume;
		slider_GameMusic.value = Persistence.instance.svMan.settingsSave.gameMusicVolume;
		slider_AmbientMusic.value = Persistence.instance.svMan.settingsSave.ambientMusicVolume;
		slider_SFXVolume.value = Persistence.instance.svMan.settingsSave.sfxVolume;
		slider_VoiceVolume.value = Persistence.instance.svMan.settingsSave.voVolume;
		nodeHits.isOn = Persistence.instance.svMan.settingsSave.enableNodeSounds;
		UpdateAudio();
	}

	private void SaveSettings()
	{
		Persistence.instance.svMan.settingsSave.masterVolume = slider_MasterVolume.value;
		Persistence.instance.svMan.settingsSave.gameMusicVolume = slider_GameMusic.value;
		Persistence.instance.svMan.settingsSave.ambientMusicVolume = slider_AmbientMusic.value;
		Persistence.instance.svMan.settingsSave.sfxVolume = slider_SFXVolume.value;
		Persistence.instance.svMan.settingsSave.voVolume = slider_VoiceVolume.value;
		Persistence.instance.svMan.settingsSave.enableNodeSounds = nodeHits.isOn;
		UpdateAudio();
	}

	public void UpdateAudio()
	{
		UnityEngine.Debug.Log("Set the master volume up because LobbyUpdateAudio");
	}
}
public class Lobby_SettingsMenu : LobbyMenu_AbstractClass
{
	public override void OpenWindow()
	{
		base.Transition(activeState: true);
		mainMenuManager.currentWindow = this;
	}

	public override void CloseWindow()
	{
		base.Transition(activeState: false);
		mainMenuManager.settingsBackButton_Toggle = false;
	}

	public void Graphics_Button()
	{
		CloseWindow();
	}

	public void Audio_Button()
	{
		CloseWindow();
		mainMenuManager.audioSettings.OpenWindow();
	}

	public void Language_Button()
	{
		CloseWindow();
		mainMenuManager.languageSettings.OpenWindow();
	}

	public void Credits_Button()
	{
		CloseWindow();
		mainMenuManager.credits.OpenWindow();
	}

	public void Gameplay_Button()
	{
		CloseWindow();
	}
}
public class Lobby_Settings_Credits : LobbyMenu_AbstractClass
{
	public override void OpenWindow()
	{
		base.Transition(activeState: true);
		mainMenuManager.previousWindow = mainMenuManager.settingsMenu;
		mainMenuManager.currentWindow = this;
	}

	public override void CloseWindow()
	{
		base.Transition(activeState: false);
	}
}
public class Lobby_Settings_Graphics : LobbyMenu_AbstractClass
{
	[Header("Gameplay")]
	public GameObject SettingsMenu;

	public Toggle toggle_CharacterHologram;

	public Toggle toggle_SkipIntro;

	public Toggle toggle_gameui;

	public Toggle toggle_particles;

	[Header("Colours")]
	public GameObject coloursMenu;

	public Slider slider_leftColour;

	public Slider slider_rightColour;

	public Slider slider_doubleColour;

	public Image leftColourPreview;

	public Image rightColourPreview;

	public Image doubleColourPreview;

	public override void OpenWindow()
	{
		base.Transition(activeState: true);
		mainMenuManager.previousWindow = mainMenuManager.characterSelect;
		mainMenuManager.currentWindow = this;
		mainMenuManager.settingsButton.interactable = false;
		LoadSettings();
	}

	public void Start()
	{
		SettingsMenu.SetActive(value: true);
		coloursMenu.SetActive(value: false);
	}

	public override void CloseWindow()
	{
		SaveSettings();
		mainMenuManager.settingsButton.interactable = true;
		base.Transition(activeState: false);
	}

	public void LoadSettings()
	{
		SettingsSave settingsSave = Persistence.instance.svMan.settingsSave;
		toggle_CharacterHologram.SetIsOnWithoutNotify(settingsSave.enableDanceholograms);
		toggle_SkipIntro.SetIsOnWithoutNotify(settingsSave.skipIntros);
		toggle_gameui.SetIsOnWithoutNotify(settingsSave.enableUI);
		toggle_particles.SetIsOnWithoutNotify(settingsSave.enableParticles);
		slider_leftColour.SetValueWithoutNotify(settingsSave.left_Colour);
		slider_rightColour.SetValueWithoutNotify(settingsSave.right_Colour);
		slider_doubleColour.SetValueWithoutNotify(settingsSave.double_colour);
		UpdateSliders();
	}

	public void SaveSettings()
	{
		UnityEngine.Debug.Log("graphics settings saved!");
		SettingsSave settingsSave = Persistence.instance.svMan.settingsSave;
		settingsSave.enableDanceholograms = toggle_CharacterHologram.isOn;
		settingsSave.skipIntros = toggle_SkipIntro.isOn;
		settingsSave.enableUI = toggle_gameui.isOn;
		settingsSave.enableParticles = toggle_particles.isOn;
		settingsSave.left_Colour = slider_leftColour.value;
		settingsSave.right_Colour = slider_rightColour.value;
		settingsSave.double_colour = slider_doubleColour.value;
		Persistence.instance.svMan.SaveSettings();
	}

	public void UpdateAA()
	{
		SaveSettings();
		Persistence.instance.SetAA();
	}

	public void UpdatePost()
	{
	}

	public void UpdateSliders()
	{
		leftColourPreview.color = Color.HSVToRGB(slider_leftColour.value, 1f, 1f);
		rightColourPreview.color = Color.HSVToRGB(slider_rightColour.value, 1f, 1f);
		doubleColourPreview.color = Color.HSVToRGB(slider_doubleColour.value, 1f, 1f);
	}

	public void ResetColour()
	{
		Color.RGBToHSV(new Color(1f, 0.17f, 1f, 1f), out var H, out var S, out var V);
		Color.RGBToHSV(new Color(0f, 0.9528301f, 0.3890223f, 1f), out var H2, out V, out S);
		Color.RGBToHSV(new Color(0.88f, 1f, 0f, 1f), out var H3, out S, out V);
		slider_leftColour.SetValueWithoutNotify(H);
		slider_rightColour.SetValueWithoutNotify(H2);
		slider_doubleColour.SetValueWithoutNotify(H3);
		UpdateSliders();
	}

	public void ApplyOffset()
	{
		SaveSettings();
		UnityEngine.Object.FindObjectOfType<RoomOffset>().ApplyOffset();
	}

	public void ToggleCalibration()
	{
	}

	public void CalibrateHeight()
	{
	}

	public void OpenGameplay()
	{
	}

	public void OpenGraphics()
	{
	}
}
public class Lobby_Settings_Language : LobbyMenu_AbstractClass
{
	public GameObject[] highlights;

	public Image currentLanguageFlag;

	public TextMeshProUGUI currentLanguageText;

	public Sprite[] flags;

	public override void OpenWindow()
	{
		base.Transition(activeState: true);
		mainMenuManager.previousWindow = mainMenuManager.title;
		mainMenuManager.currentWindow = this;
		CheckCurrentLanguage();
	}

	public override void CloseWindow()
	{
		base.Transition(activeState: false);
	}

	private void ResetHighlights()
	{
		GameObject[] array = highlights;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].SetActive(value: false);
		}
	}

	private void CheckCurrentLanguage()
	{
		string currentLanguage = LocalizationManager.CurrentLanguage;
		if (currentLanguage != null)
		{
			switch (currentLanguage)
			{
			case "English":
				SetCurrentLanguages(0);
				break;
			case "French":
				SetCurrentLanguages(1);
				break;
			case "Italian":
				SetCurrentLanguages(2);
				break;
			case "German":
				SetCurrentLanguages(3);
				break;
			case "Spanish":
				SetCurrentLanguages(4);
				break;
			case "Korean":
				SetCurrentLanguages(5);
				break;
			case "Japanese":
				SetCurrentLanguages(6);
				break;
			}
		}
	}

	public void SetCurrentLanguages(int _langInt)
	{
		ResetHighlights();
		highlights[_langInt].SetActive(value: true);
		currentLanguageFlag.sprite = flags[_langInt];
		switch (_langInt)
		{
		case 0:
			UnityEngine.Debug.Log("ENGLISH");
			LocalizationManager.CurrentLanguage = "English";
			currentLanguageText.text = ParseLoc.Parse("&Lobby/Language_English");
			break;
		case 1:
			LocalizationManager.CurrentLanguage = "French";
			UnityEngine.Debug.Log("FRENCH");
			currentLanguageText.text = ParseLoc.Parse("&Lobby/Language_French");
			break;
		case 2:
			LocalizationManager.CurrentLanguage = "Italian";
			UnityEngine.Debug.Log("ITALIAN");
			currentLanguageText.text = ParseLoc.Parse("&Lobby/Language_Italian");
			break;
		case 3:
			LocalizationManager.CurrentLanguage = "German";
			UnityEngine.Debug.Log("GERMAN");
			currentLanguageText.text = ParseLoc.Parse("&Lobby/Language_German");
			break;
		case 4:
			LocalizationManager.CurrentLanguage = "Spanish";
			UnityEngine.Debug.Log("SPANISH");
			currentLanguageText.text = ParseLoc.Parse("&Lobby/Language_Spanish");
			break;
		case 5:
			LocalizationManager.CurrentLanguage = "Korean";
			UnityEngine.Debug.Log("KOREAN");
			currentLanguageText.text = ParseLoc.Parse("&Lobby/Language_Korean");
			break;
		case 6:
			LocalizationManager.CurrentLanguage = "Japanese";
			UnityEngine.Debug.Log("JAPANESE");
			currentLanguageText.text = ParseLoc.Parse("&Lobby/Language_Japanese");
			break;
		}
		mainMenuManager.SetMenuDescription(ParseLoc.Parse(menuDescription));
	}
}
public class Lobby_SongSelect : LobbyMenu_AbstractClass
{
	public List<Sprite> _ratingSprites;

	public int maxNumberOfSongs = 4;

	public int songInt;

	private int contextRange = 2;

	public TextMeshProUGUI currentSong_Name;

	public TextMeshProUGUI currentSong_Duration;

	public TextMeshProUGUI currentSong_BPM;

	public TextMeshProUGUI currentSong_Ranking;

	public GetSongData songData;

	public Button ScrollUpButton;

	public Button ScrollDownButton;

	public Toggle easyToggle;

	public Toggle normalToggle;

	public Toggle proToggle;

	public Toggle xToggle;

	public Toggle noFailtoggle;

	public Image characterIcon;

	public Image characterBG;

	public TextMeshProUGUI characterName;

	public TextMeshProUGUI characterRank;

	public GameObject moreButton;

	public List<SongPreviews> top_SongPreviews = new List<SongPreviews>();

	public List<SongPreviews> bottom_SongPreviews = new List<SongPreviews>();

	public TextMeshProUGUI rankingPreview1_rank;

	public TextMeshProUGUI rankingPreview1_name;

	public TextMeshProUGUI rankingPreview1_score;

	public TextMeshProUGUI rankingPreview2_rank;

	public TextMeshProUGUI rankingPreview2_name;

	public TextMeshProUGUI rankingPreview2_score;

	public TextMeshProUGUI rankingPreview3_rank;

	public TextMeshProUGUI rankingPreview3_name;

	public TextMeshProUGUI rankingPreview3_score;

	public GameObject networkError;

	public override void OpenWindow()
	{
		base.Transition(activeState: true);
		mainMenuManager.previousWindow = mainMenuManager.characterSelect;
		mainMenuManager.currentWindow = this;
		songInt = 0;
		foreach (SongPreviews top_SongPreview in top_SongPreviews)
		{
			top_SongPreview.gameObject.SetActive(value: true);
		}
		foreach (SongPreviews bottom_SongPreview in bottom_SongPreviews)
		{
			bottom_SongPreview.gameObject.SetActive(value: true);
		}
		characterIcon.sprite = LobbyMainMenuManager.instance.characterSelect._characterinfos[LobbyMainMenuManager.instance.selectedCharacter].characterPortrait;
		if (LobbyMainMenuManager.instance.selectedCharacter < 8)
		{
			characterBG.enabled = true;
			characterBG.sprite = LobbyMainMenuManager.instance.characterSelect._characterinfos[LobbyMainMenuManager.instance.selectedCharacter].characterBG;
		}
		else
		{
			characterBG.enabled = false;
		}
		characterName.text = LobbyMainMenuManager.ParseString(LobbyMainMenuManager.instance.characterSelect._characterinfos[LobbyMainMenuManager.instance.selectedCharacter].CharacterName);
		RefreshUI();
		OculusManager instance = OculusManager.instance;
		instance.onNearbyScores = (OculusManager.NearbyScoresReturned)Delegate.Combine(instance.onNearbyScores, new OculusManager.NearbyScoresReturned(UpdateRankingPreview));
	}

	public override void CloseWindow()
	{
		base.Transition(activeState: false);
		OculusManager instance = OculusManager.instance;
		instance.onNearbyScores = (OculusManager.NearbyScoresReturned)Delegate.Remove(instance.onNearbyScores, new OculusManager.NearbyScoresReturned(UpdateRankingPreview));
	}

	public void OpenLeaderboards()
	{
		CloseWindow();
		mainMenuManager.leaderboards.OpenWindow();
	}

	private void RefreshUI()
	{
		UnityEngine.Debug.Log("RefreshUICalled");
		InitDifficultyToggles();
		SetSongFileName();
		UpdateSongPreviews();
		UpdateCurrentSong();
		UpdateScrollButtons();
		if (LobbyMainMenuManager.instance.music.clip != songData.GetBuiltInSongData(LobbyMainMenuManager.instance.selectedCharacter, songInt).songPreview)
		{
			LobbyMainMenuManager.instance.PlayMusic(songData.GetBuiltInSongData(LobbyMainMenuManager.instance.selectedCharacter, songInt).songPreview);
		}
	}

	private void UpdateSongPreviews()
	{
		UnityEngine.Debug.Log("UpdateSongPreviewCalled");
		for (int i = 0; i < top_SongPreviews.Count; i++)
		{
			int songID = songInt - i - 1;
			top_SongPreviews[i].songID = songID;
			top_SongPreviews[i].UpdateState();
		}
		for (int j = 0; j < bottom_SongPreviews.Count; j++)
		{
			int songID2 = songInt + j + 1;
			bottom_SongPreviews[j].songID = songID2;
			bottom_SongPreviews[j].UpdateState();
		}
	}

	private void UpdateCurrentSong()
	{
		UnityEngine.Debug.Log("UpdateCurrentSongCalled");
		GetSongData.CharacterSongData builtInSongData = songData.GetBuiltInSongData(LobbyMainMenuManager.instance.selectedCharacter, songInt);
		currentSong_Name.text = LobbyMainMenuManager.ParseString(builtInSongData.songName);
		currentSong_Duration.text = builtInSongData.songDuration;
		currentSong_BPM.text = builtInSongData.songBPM;
		currentSong_Ranking.text = Score.GetRankString((int)Persistence.instance.svMan.GetColliderRank(Persistence.instance.currentSongFilename));
		mainMenuManager.leaderboards.LoadLeaderboard();
	}

	private void UpdateScrollButtons()
	{
		UnityEngine.Debug.Log("UpdateScrollButtonsCalled");
		ScrollUpButton.interactable = songInt > 0;
		ScrollDownButton.interactable = songInt < maxNumberOfSongs - 1;
	}

	private void InitDifficultyToggles()
	{
		UnityEngine.Debug.Log("InitDifficultyTogglesCalled");
		easyToggle.SetIsOnWithoutNotify(Persistence.instance.currentDifficulty == 0);
		normalToggle.SetIsOnWithoutNotify(Persistence.instance.currentDifficulty == 1);
		proToggle.SetIsOnWithoutNotify(Persistence.instance.currentDifficulty == 2);
		xToggle.SetIsOnWithoutNotify(Persistence.instance.currentDifficulty == 3);
	}

	public void UpdateDifficulty(int diff)
	{
		UnityEngine.Debug.Log("UpdateDifficultyCalled");
		easyToggle.SetIsOnWithoutNotify(value: false);
		normalToggle.SetIsOnWithoutNotify(value: false);
		proToggle.SetIsOnWithoutNotify(value: false);
		xToggle.SetIsOnWithoutNotify(value: false);
		Persistence.instance.currentDifficulty = diff;
		RefreshUI();
	}

	public void Scroll(bool scrollDown)
	{
		if (scrollDown)
		{
			if (songInt < maxNumberOfSongs - 1)
			{
				songInt++;
			}
		}
		else if (songInt > 0)
		{
			songInt--;
		}
		RefreshUI();
	}

	public void Dance()
	{
		SetSongFileName();
		Persistence.instance.nofail = noFailtoggle.isOn;
		Persistence.instance.builtInSong = true;
		OculusManager instance = OculusManager.instance;
		instance.onNearbyScores = (OculusManager.NearbyScoresReturned)Delegate.Remove(instance.onNearbyScores, new OculusManager.NearbyScoresReturned(UpdateRankingPreview));
		mainMenuManager.LoadScene("Game");
	}

	public void SetSongFileName()
	{
		UnityEngine.Debug.Log("SetSongFileNameCalled");
		Persistence.instance.currentSongFilename = songData.GetBuiltInSongData(LobbyMainMenuManager.instance.selectedCharacter, songInt).filename + GetDifficultySuffix();
		Persistence.instance.SetLeaderboardTarget();
		OculusManager.instance.RequestScores(topFirst: false);
		UpdateRankingPreview();
	}

	private string GetDifficultySuffix()
	{
		if (Persistence.instance.currentDifficulty == 0)
		{
			return "Easy";
		}
		if (Persistence.instance.currentDifficulty == 1)
		{
			return "Normal";
		}
		if (Persistence.instance.currentDifficulty == 2)
		{
			return "Hard";
		}
		if (Persistence.instance.currentDifficulty == 3)
		{
			return "X";
		}
		UnityEngine.Debug.Log("bad difficulty");
		return "Normal";
	}

	public void UpdateRankingPreview()
	{
		UnityEngine.Debug.Log("UpdateRankingPreviewCalled");
		HideLeaderboardError();
		if (OculusManager.instance.currentBoard == OculusManager.instance.displayedBoard)
		{
			if (OculusManager.instance.entries_nearby.Count > 0)
			{
				rankingPreview1_rank.text = OculusManager.instance.entries_nearby[0].rank.ToString();
				rankingPreview1_name.text = OculusManager.instance.entries_nearby[0]._name.ToString();
				rankingPreview1_score.text = OculusManager.instance.entries_nearby[0].score.ToString();
			}
			if (OculusManager.instance.entries_nearby.Count > 1)
			{
				rankingPreview2_rank.text = OculusManager.instance.entries_nearby[1].rank.ToString();
				rankingPreview2_name.text = OculusManager.instance.entries_nearby[1]._name.ToString();
				rankingPreview2_score.text = OculusManager.instance.entries_nearby[1].score.ToString();
			}
			if (OculusManager.instance.entries_nearby.Count > 2)
			{
				rankingPreview3_rank.text = OculusManager.instance.entries_nearby[2].rank.ToString();
				rankingPreview3_name.text = OculusManager.instance.entries_nearby[2]._name.ToString();
				rankingPreview3_score.text = OculusManager.instance.entries_nearby[2].score.ToString();
			}
		}
		else
		{
			rankingPreview1_rank.text = "-";
			rankingPreview1_name.text = "Loading...";
			rankingPreview1_score.text = "";
			rankingPreview2_rank.text = "-";
			rankingPreview2_name.text = "Loading...";
			rankingPreview2_score.text = "";
			rankingPreview3_rank.text = "-";
			rankingPreview3_name.text = "Loading...";
			rankingPreview3_score.text = "";
		}
	}

	public void ShowLeaderboardError()
	{
		rankingPreview1_name.transform.parent.gameObject.SetActive(value: false);
		rankingPreview2_name.transform.parent.gameObject.SetActive(value: false);
		rankingPreview3_name.transform.parent.gameObject.SetActive(value: false);
		moreButton.SetActive(value: false);
		networkError.SetActive(value: true);
	}

	private void HideLeaderboardError()
	{
		rankingPreview1_name.transform.parent.gameObject.SetActive(value: true);
		rankingPreview2_name.transform.parent.gameObject.SetActive(value: true);
		rankingPreview3_name.transform.parent.gameObject.SetActive(value: true);
		networkError.SetActive(value: false);
	}

	public void TestSubmitScore()
	{
	}
}
public class SongPreviews : MonoBehaviour
{
	public Lobby_SongSelect songselect;

	public GameObject previewGameObject;

	public TextMeshProUGUI songName;

	public int songID;

	public TextMeshProUGUI ratingDisplay;

	public void UpdateState()
	{
		if (songID < 0 || songID >= songselect.maxNumberOfSongs)
		{
			previewGameObject.SetActive(value: false);
		}
		else if (songID >= 0 && songselect.maxNumberOfSongs > songID)
		{
			previewGameObject.SetActive(value: true);
			songName.text = LobbyMainMenuManager.ParseString(songselect.songData.GetBuiltInSongData(LobbyMainMenuManager.instance.selectedCharacter, songID).songName);
			string[] array = Persistence.instance.currentSongFilename.Split('_');
			ratingDisplay.text = Score.GetRankString((int)Persistence.instance.svMan.GetColliderRank(array[0] + "_" + array[1] + "_" + (songID + 1) + "_" + array[3]));
		}
	}
}
public class ScoreEvent : MonoBehaviour
{
	public TextMeshProUGUI text;

	public Image icon;

	public List<string> words;

	private void Start()
	{
	}

	public void SetRandomWord()
	{
		text.text = ParseLoc.Parse(words[UnityEngine.Random.Range(0, words.Count)]);
	}

	private void Update()
	{
	}

	public void DestroyThis()
	{
		UnityEngine.Object.Destroy(base.gameObject);
	}

	public void Restart()
	{
		GetComponent<Animator>().SetTrigger("Restart");
	}
}
public class UI_Character_select : UI_Screen
{
	public TextMeshProUGUI yuri_rank;

	public TextMeshProUGUI pyro_rank;

	public TextMeshProUGUI lais_rank;

	public TextMeshProUGUI dre_rank;

	public TextMeshProUGUI liu_rank;

	public TextMeshProUGUI remi_rank;

	public TextMeshProUGUI sonya_rank;

	public TextMeshProUGUI core_rank;

	public int selectedCharacter = -1;

	public List<GameObject> characterPreviews;

	public Button selectButton;

	public UI_SongSelect songSelect;

	public override void Transition(bool on)
	{
		base.Transition(on);
		if (on)
		{
			selectedCharacter = -1;
			selectButton.interactable = false;
			DisableCharacterPreviews();
			Lobby_UI_Manager.instance.ChangeMusic(-1);
			Lobby_UI_Manager.instance.ToggleSettings(on: true);
		}
	}

	public void SelectCharacter(int character)
	{
		selectedCharacter = character;
		selectButton.interactable = true;
		SetCharacterPreview(character);
	}

	private void SetCharacterPreview(int character)
	{
		DisableCharacterPreviews();
		if (character != -1)
		{
			characterPreviews[character].SetActive(value: true);
		}
	}

	private void DisableCharacterPreviews()
	{
		foreach (GameObject characterPreview in characterPreviews)
		{
			characterPreview.SetActive(value: false);
		}
	}

	public void SubmitCharacter()
	{
		if (selectedCharacter != -1)
		{
			songSelect.selectedCharacter = selectedCharacter;
			Lobby_UI_Manager.instance.TransitionTo(songSelect);
		}
	}
}
public class UI_Display : UI_Screen
{
	private void Start()
	{
	}

	private void Update()
	{
	}
}
public class UI_Leaderboard : MonoBehaviour
{
	private LeaderboardManager lbMan;

	private SaveManager svMan;

	public LeaderboardUI topScoresUI;

	public LeaderboardUI nearbyScoresUI;

	public Keyboard keyboard;

	private List<ScoreEntry> localScores = new List<ScoreEntry>();

	private void OnEnable()
	{
		OculusManager instance = OculusManager.instance;
		instance.onTopScores = (OculusManager.TopScoresReturned)Delegate.Combine(instance.onTopScores, new OculusManager.TopScoresReturned(DisplayScores));
	}

	private void OnDisable()
	{
		OculusManager instance = OculusManager.instance;
		instance.onTopScores = (OculusManager.TopScoresReturned)Delegate.Remove(instance.onTopScores, new OculusManager.TopScoresReturned(DisplayScores));
	}

	public void DisplayScores()
	{
		string text = "";
		string text2 = "";
		string text3 = "";
		string text4 = "";
		List<OculusManager.QuestScoreEntry> entries_nearby = OculusManager.instance.entries_nearby;
		for (int i = 0; i < entries_nearby.Count; i++)
		{
			OculusManager.QuestScoreEntry questScoreEntry = entries_nearby[i];
			text = text + questScoreEntry.rank + "\n";
			text2 = text2 + questScoreEntry._name + "\n";
			text3 = text3 + questScoreEntry.score.ToString("N0") + "\n";
		}
		SetText(topScoresUI.rankText, text);
		SetText(topScoresUI.nameText, text2);
		SetText(topScoresUI.scoreText, text3);
		SetText(topScoresUI.gradeText, text4);
		SetText(nearbyScoresUI.stageText, "");
		SetText(nearbyScoresUI.rankText, "");
		SetText(nearbyScoresUI.nameText, "");
		SetText(nearbyScoresUI.scoreText, "");
		SetText(nearbyScoresUI.gradeText, "");
	}

	private void SetText(TextMeshProUGUI _mesh, string _text)
	{
		if (_mesh != null)
		{
			_mesh.text = _text;
		}
	}

	public void GetGlobalScores()
	{
	}

	public void GetFriendsScores()
	{
	}

	public void GetLocalScores()
	{
	}

	private void ShowLocalScores()
	{
	}

	public void SubmitLocalScore(string _name)
	{
	}

	public void SetLoading()
	{
		topScoresUI.nameText.text = "Loading...";
		topScoresUI.rankText.text = "";
		topScoresUI.gradeText.text = "";
		topScoresUI.scoreText.text = "";
		nearbyScoresUI.nameText.text = "";
		nearbyScoresUI.rankText.text = "";
		nearbyScoresUI.gradeText.text = "";
		nearbyScoresUI.scoreText.text = "";
		nearbyScoresUI.stageText.text = "";
	}
}
public class UI_MainMenu : UI_Screen
{
	public override void Transition(bool on)
	{
		base.Transition(on);
		if (on)
		{
			Lobby_UI_Manager.instance.ToggleSettings(on: false);
		}
	}
}
[Serializable]
public class RankObject
{
	public GameObject gObject;

	public AudioClip SFX;
}
[Serializable]
public class ScoreSound
{
	public AudioClip SFX;

	public bool started;
}
public class UI_Results : MonoBehaviour
{
	public TextMeshProUGUI title;

	public TextMeshProUGUI scoreText;

	public TextMeshProUGUI accText;

	public TextMeshProUGUI energyText;

	public TextMeshProUGUI streakText;

	public TextMeshProUGUI maxMultiText;

	public TextMeshProUGUI setsText;

	public TextMeshProUGUI cascadeText;

	public TextMeshProUGUI rankText;

	public TextMeshProUGUI precisionText;

	public float score;

	public float accuracy;

	public float energy;

	public float streak;

	public float maxMulti;

	public float sets;

	public float cascades;

	public float precision;

	public Score.Rank rank;

	public int stageNum = 1;

	public GameObject nextStageUI;

	public TextMeshProUGUI nextStageAutoText;

	public AudioSource audio;

	public GameObject Subpanel_R1;

	public GameObject Subpanel_R2;

	public GameObject Subpanel_L1;

	public GameObject Subpanel_L2;

	public TextMeshProUGUI R1_Stage;

	public TextMeshProUGUI R1_Rank;

	public TextMeshProUGUI R2_Stage;

	public TextMeshProUGUI R2_Rank;

	public TextMeshProUGUI L1_Stage;

	public TextMeshProUGUI L1_Rank;

	public TextMeshProUGUI L2_Stage;

	public TextMeshProUGUI L2_Rank;

	[Header("Settings")]
	public float totalAnimationTime = 7f;

	public Vector2 scoreTiming;

	public Vector2 accuracyTiming;

	public Vector2 energyTiming;

	public Vector2 streakTiming;

	public Vector2 maxMultiTiming;

	public Vector2 setsTiming;

	public Vector2 cascadesTiming;

	public RankObject rank_s;

	public RankObject rank_a;

	public RankObject rank_b;

	public RankObject rank_c;

	public RankObject rank_d;

	public RankObject rank_e;

	public RankObject rank_plus;

	public RankObject rank_minus;

	public RankObject rank_error;

	public GameObject sParticles;

	public GameObject goldParticles;

	public GameObject silverParticles;

	public GameObject leaderboard;

	public Animator anim;

	public ScoreSound mainScoreSound;

	private float timer;

	private float progress;

	private bool animating;

	private bool finished;

	private void Update()
	{
		if (animating)
		{
			timer += Time.deltaTime;
			progress = Mathf.InverseLerp(0f, totalAnimationTime, timer);
			if (!mainScoreSound.started)
			{
				audio.clip = mainScoreSound.SFX;
				audio.Play();
				mainScoreSound.started = true;
			}
			if (progress > scoreTiming.x)
			{
				scoreText.text = Mathf.Lerp(0f, score, Mathf.InverseLerp(scoreTiming.x, scoreTiming.y, progress)).ToString("N0");
			}
			if (progress > accuracyTiming.x)
			{
				accText.text = Mathf.Lerp(0f, accuracy, Mathf.InverseLerp(accuracyTiming.x, accuracyTiming.y, progress)).ToString("F1");
			}
			if (progress > energyTiming.x)
			{
				energyText.text = Mathf.Lerp(0f, energy, Mathf.InverseLerp(energyTiming.x, energyTiming.y, progress)).ToString("F1");
				precisionText.text = Mathf.Lerp(0f, precision, Mathf.InverseLerp(energyTiming.x, energyTiming.y, progress)).ToString("F1");
			}
			if (progress > streakTiming.x)
			{
				streakText.text = Mathf.Lerp(0f, streak, Mathf.InverseLerp(streakTiming.x, streakTiming.y, progress)).ToString("F0");
			}
			if (progress > maxMultiTiming.x)
			{
				maxMultiText.text = Mathf.Lerp(0f, maxMulti, Mathf.InverseLerp(maxMultiTiming.x, maxMultiTiming.y, progress)).ToString("F0");
			}
			if (progress > setsTiming.x)
			{
				setsText.text = Mathf.Lerp(0f, sets, Mathf.InverseLerp(setsTiming.x, setsTiming.y, progress)).ToString("F0");
			}
			if (progress > cascadesTiming.x)
			{
				cascadeText.text = Mathf.Lerp(0f, cascades, Mathf.InverseLerp(cascadesTiming.x, cascadesTiming.y, progress)).ToString("F0");
			}
			if (progress == 1f && !finished)
			{
				ShowRank(rank);
				finished = true;
				Finish();
			}
		}
	}

	public void Display()
	{
		HideAll();
		finished = false;
		animating = true;
		timer = 0f;
		title.text = "Song Clear";
	}

	private void Finish()
	{
		GameManager.instance.TogglePointers(toggle: true);
		GameManager.instance.objectRefrences.results_lobby_button.SetActive(value: true);
		GameManager.instance.objectRefrences.results_restart_button.SetActive(value: true);
		GameManager.instance.objectRefrences.results_nextstage_button.SetActive(GameManager.instance.GetStageNum(GameManager.instance.musicNum) < 5);
		if (Persistence.instance.builtInSong)
		{
			if (!GameManager.instance.god)
			{
				GameManager.instance.Uriel_Update();
			}
			_ = GameManager.instance.autoNextStage;
		}
	}

	private IEnumerator NextStageCountdown(int seconds)
	{
		int counter = seconds;
		while (counter > 0)
		{
			nextStageAutoText.text = "Stage " + (stageNum + 1) + " in " + counter + "...";
			int num = counter - 1;
			counter = num;
			yield return new WaitForSeconds(1f);
		}
		GameManager.instance.NextStage();
	}

	private void HideAll()
	{
		scoreText.text = "";
		accText.text = "";
		energyText.text = "";
		streakText.text = "";
		maxMultiText.text = "";
		setsText.text = "";
		cascadeText.text = "";
		rankText.enabled = false;
		rank_s.gObject.SetActive(value: false);
		rank_a.gObject.SetActive(value: false);
		rank_b.gObject.SetActive(value: false);
		rank_c.gObject.SetActive(value: false);
		rank_d.gObject.SetActive(value: false);
		rank_e.gObject.SetActive(value: false);
		rank_plus.gObject.SetActive(value: false);
		rank_minus.gObject.SetActive(value: false);
		rank_error.gObject.SetActive(value: false);
	}

	private void ShowRank(Score.Rank _rank)
	{
		UnityEngine.Debug.Log("ShowRank");
		anim.enabled = true;
		anim.SetTrigger("restart");
		audio.Stop();
		switch (_rank)
		{
		case Score.Rank.Splus:
			rank_s.gObject.SetActive(value: true);
			rank_plus.gObject.SetActive(value: true);
			audio.clip = rank_s.SFX;
			break;
		case Score.Rank.S:
			rank_s.gObject.SetActive(value: true);
			audio.clip = rank_s.SFX;
			break;
		case Score.Rank.Sminus:
			rank_s.gObject.SetActive(value: true);
			rank_minus.gObject.SetActive(value: true);
			audio.clip = rank_s.SFX;
			break;
		case Score.Rank.Aplus:
			rank_a.gObject.SetActive(value: true);
			rank_plus.gObject.SetActive(value: true);
			audio.clip = rank_a.SFX;
			break;
		case Score.Rank.A:
			rank_a.gObject.SetActive(value: true);
			audio.clip = rank_a.SFX;
			break;
		case Score.Rank.Aminus:
			rank_a.gObject.SetActive(value: true);
			rank_minus.gObject.SetActive(value: true);
			audio.clip = rank_a.SFX;
			break;
		case Score.Rank.Bplus:
			rank_b.gObject.SetActive(value: true);
			rank_plus.gObject.SetActive(value: true);
			audio.clip = rank_b.SFX;
			break;
		case Score.Rank.B:
			rank_b.gObject.SetActive(value: true);
			audio.clip = rank_b.SFX;
			break;
		case Score.Rank.Bminus:
			rank_b.gObject.SetActive(value: true);
			rank_minus.gObject.SetActive(value: true);
			audio.clip = rank_b.SFX;
			break;
		case Score.Rank.Cplus:
			rank_c.gObject.SetActive(value: true);
			rank_plus.gObject.SetActive(value: true);
			audio.clip = rank_c.SFX;
			break;
		case Score.Rank.C:
			rank_c.gObject.SetActive(value: true);
			audio.clip = rank_c.SFX;
			break;
		case Score.Rank.Cminus:
			rank_c.gObject.SetActive(value: true);
			rank_minus.gObject.SetActive(value: true);
			audio.clip = rank_c.SFX;
			break;
		case Score.Rank.Dplus:
			rank_d.gObject.SetActive(value: true);
			rank_plus.gObject.SetActive(value: true);
			audio.clip = rank_d.SFX;
			break;
		case Score.Rank.D:
			rank_d.gObject.SetActive(value: true);
			audio.clip = rank_d.SFX;
			break;
		case Score.Rank.Dminus:
			rank_d.gObject.SetActive(value: true);
			rank_minus.gObject.SetActive(value: true);
			audio.clip = rank_d.SFX;
			break;
		case Score.Rank.Eplus:
			rank_e.gObject.SetActive(value: true);
			rank_plus.gObject.SetActive(value: true);
			audio.clip = rank_e.SFX;
			break;
		case Score.Rank.E:
			rank_e.gObject.SetActive(value: true);
			audio.clip = rank_e.SFX;
			break;
		case Score.Rank.Eminus:
			rank_e.gObject.SetActive(value: true);
			rank_minus.gObject.SetActive(value: true);
			audio.clip = rank_e.SFX;
			break;
		default:
			rank_error.gObject.SetActive(value: true);
			audio.clip = rank_error.SFX;
			break;
		}
		audio.Play();
	}

	public void Impact()
	{
		switch (rank)
		{
		case Score.Rank.Splus:
		case Score.Rank.S:
		case Score.Rank.Sminus:
			sParticles.SetActive(value: true);
			break;
		case Score.Rank.Aplus:
		case Score.Rank.A:
		case Score.Rank.Aminus:
			goldParticles.SetActive(value: true);
			break;
		default:
			silverParticles.SetActive(value: true);
			break;
		}
	}
}
public class UI_Shaker : MonoBehaviour
{
	public float _time;

	public float _size;

	private float shakeTime;

	private float shakeSize;

	private float shakeTimecontainer;

	private float shakeSizecontainer;

	private float shakePercent;

	private void Start()
	{
	}

	private void Update()
	{
	}

	public void TestShake()
	{
		Shake(_time, _size);
	}

	public void Shake(float time, float size)
	{
	}
}
public class UI_SongSelect : UI_Screen
{
	public TextMeshPro infoName;

	public TextMeshPro infoBio;

	public TextMeshProUGUI stage1Title;

	public TextMeshProUGUI stage1Duration;

	public TextMeshProUGUI stage1BPM;

	public TextMeshProUGUI stage1Rank;

	public TextMeshProUGUI stage2Title;

	public TextMeshProUGUI stage2Duration;

	public TextMeshProUGUI stage2BPM;

	public TextMeshProUGUI stage2Rank;

	public TextMeshProUGUI stage3Title;

	public TextMeshProUGUI stage3Duration;

	public TextMeshProUGUI stage3BPM;

	public TextMeshProUGUI stage3Rank;

	public TextMeshProUGUI stage4Title;

	public TextMeshProUGUI stage4Duration;

	public TextMeshProUGUI stage4BPM;

	public TextMeshProUGUI stage4Rank;

	public Image stage1Pulse;

	public Image stage2Pulse;

	public Image stage3Pulse;

	public Image stage4Pulse;

	private Color pulseBaseColour;

	public int selectedCharacter;

	public int selectedStage;

	public List<AudioClip> yuriVoiceLines;

	public List<AudioClip> pyroVoiceLines;

	public List<AudioClip> laisVoiceLines;

	public List<AudioClip> remiVoicelines;

	public List<AudioClip> liuweiVoiceLines;

	public List<AudioClip> dreVoiceLines;

	public List<AudioClip> sonyaVoiceLines;

	public List<AudioClip> coreVoiceLines;

	public List<GameObject> characterUI;

	public Toggle easyToggle;

	public Toggle normalToggle;

	public Toggle hardToggle;

	private void Awake()
	{
		pulseBaseColour = stage1Pulse.color;
	}

	public override void Transition(bool on)
	{
		base.Transition(on);
		if (on)
		{
			switch (selectedCharacter)
			{
			case 0:
				GetComponent<AudioSource>().clip = yuriVoiceLines[UnityEngine.Random.Range(0, yuriVoiceLines.Count)];
				infoName.text = ScriptLocalization.Yuri_Name;
				infoBio.text = ScriptLocalization.Yuri_Bio;
				break;
			case 1:
				GetComponent<AudioSource>().clip = pyroVoiceLines[UnityEngine.Random.Range(0, pyroVoiceLines.Count)];
				infoName.text = ScriptLocalization.Pyro_Name;
				infoBio.text = ScriptLocalization.Pyro_Bio;
				break;
			case 2:
				GetComponent<AudioSource>().clip = laisVoiceLines[UnityEngine.Random.Range(0, laisVoiceLines.Count)];
				infoName.text = ScriptLocalization.Lais_Name;
				infoBio.text = ScriptLocalization.Lais_Bio;
				break;
			case 3:
				infoName.text = ScriptLocalization.Remi_Name;
				infoBio.text = ScriptLocalization.Remi_Bio;
				break;
			case 4:
				infoName.text = ScriptLocalization.LiuWei_Name;
				infoBio.text = ScriptLocalization.Liu_Bio;
				break;
			case 5:
				infoName.text = ScriptLocalization.Dre_Name;
				infoBio.text = ScriptLocalization.Dre_Bio;
				break;
			case 6:
				infoName.text = ScriptLocalization.Sonya_Name;
				infoBio.text = ScriptLocalization.Sonya_Bio;
				break;
			case 7:
				infoName.text = ScriptLocalization.Core_Name;
				infoBio.text = ScriptLocalization.Core_Bio;
				break;
			default:
				UnityEngine.Debug.Log("Selected a bad character");
				break;
			}
			GetComponent<AudioSource>().Play();
			characterUI[selectedCharacter].SetActive(value: true);
			PressStage1();
			easyToggle.isOn = Persistence.instance.currentDifficulty == 0;
			normalToggle.isOn = Persistence.instance.currentDifficulty == 1;
			hardToggle.isOn = Persistence.instance.currentDifficulty == 2;
			UpdateRoundButtons();
			UpdateRanks();
			return;
		}
		foreach (GameObject item in characterUI)
		{
			item.SetActive(value: false);
		}
	}

	public void UpdateDifficulty()
	{
		int currentDifficulty = Persistence.instance.currentDifficulty;
		if (easyToggle.isOn)
		{
			Persistence.instance.currentDifficulty = 0;
		}
		else if (normalToggle.isOn)
		{
			Persistence.instance.currentDifficulty = 1;
		}
		else if (hardToggle.isOn)
		{
			Persistence.instance.currentDifficulty = 2;
		}
		else
		{
			Persistence.instance.currentDifficulty = 1;
			UnityEngine.Debug.Log("bad difficulty, default to normal");
		}
		if (currentDifficulty != Persistence.instance.currentDifficulty)
		{
			Persistence.instance.UpdateLeaderboard();
		}
		UpdateRanks();
	}

	private void Update()
	{
		float num = Mathf.Sin(Time.time * 2f) * 0.1f + 0.2f;
		stage1Pulse.color = pulseBaseColour;
		stage2Pulse.color = pulseBaseColour;
		stage3Pulse.color = pulseBaseColour;
		stage4Pulse.color = pulseBaseColour;
		if (selectedStage == 1)
		{
			stage1Pulse.color = new Color(pulseBaseColour.r + num, pulseBaseColour.g + num, pulseBaseColour.b + num, pulseBaseColour.a);
		}
		else if (selectedStage == 2)
		{
			stage2Pulse.color = new Color(pulseBaseColour.r + num, pulseBaseColour.g + num, pulseBaseColour.b + num, pulseBaseColour.a);
		}
		else if (selectedStage == 3)
		{
			stage3Pulse.color = new Color(pulseBaseColour.r + num, pulseBaseColour.g + num, pulseBaseColour.b + num, pulseBaseColour.a);
		}
		else if (selectedStage == 4)
		{
			stage4Pulse.color = new Color(pulseBaseColour.r + num, pulseBaseColour.g + num, pulseBaseColour.b + num, pulseBaseColour.a);
		}
	}

	public void PressStage1()
	{
		selectedStage = 1;
		switch (selectedCharacter)
		{
		case 0:
			Lobby_UI_Manager.instance.ChangeMusic(0);
			Persistence.instance.currentSongFilename = "Arcade_Yuri_1";
			break;
		case 1:
			Lobby_UI_Manager.instance.ChangeMusic(3);
			Persistence.instance.currentSongFilename = "Arcade_Pyro_1";
			break;
		case 2:
			Lobby_UI_Manager.instance.ChangeMusic(6);
			Persistence.instance.currentSongFilename = "Arcade_Lais_1";
			break;
		case 3:
			Lobby_UI_Manager.instance.ChangeMusic(9);
			Persistence.instance.currentSongFilename = "Arcade_Remi_1";
			break;
		case 4:
			Lobby_UI_Manager.instance.ChangeMusic(12);
			Persistence.instance.currentSongFilename = "Arcade_Liu_1";
			break;
		case 5:
			Lobby_UI_Manager.instance.ChangeMusic(15);
			Persistence.instance.currentSongFilename = "Arcade_Dre_1";
			break;
		case 6:
			Lobby_UI_Manager.instance.ChangeMusic(18);
			Persistence.instance.currentSongFilename = "Arcade_Sonya_1";
			break;
		case 7:
			Lobby_UI_Manager.instance.ChangeMusic(21);
			Persistence.instance.currentSongFilename = "Arcade_Core_1";
			break;
		default:
			UnityEngine.Debug.Log("Selected a bad character");
			break;
		}
		Persistence.instance.UpdateLeaderboard();
	}

	public void PressStage2()
	{
		selectedStage = 2;
		switch (selectedCharacter)
		{
		case 0:
			Lobby_UI_Manager.instance.ChangeMusic(1);
			Persistence.instance.currentSongFilename = "Arcade_Yuri_2";
			break;
		case 1:
			Lobby_UI_Manager.instance.ChangeMusic(4);
			Persistence.instance.currentSongFilename = "Arcade_Pyro_2";
			break;
		case 2:
			Lobby_UI_Manager.instance.ChangeMusic(7);
			Persistence.instance.currentSongFilename = "Arcade_Lais_2";
			break;
		case 3:
			Lobby_UI_Manager.instance.ChangeMusic(10);
			Persistence.instance.currentSongFilename = "Arcade_Remi_2";
			break;
		case 4:
			Lobby_UI_Manager.instance.ChangeMusic(13);
			Persistence.instance.currentSongFilename = "Arcade_Liu_2";
			break;
		case 5:
			Lobby_UI_Manager.instance.ChangeMusic(16);
			Persistence.instance.currentSongFilename = "Arcade_Dre_2";
			break;
		case 6:
			Lobby_UI_Manager.instance.ChangeMusic(19);
			Persistence.instance.currentSongFilename = "Arcade_Sonya_2";
			break;
		case 7:
			Lobby_UI_Manager.instance.ChangeMusic(22);
			Persistence.instance.currentSongFilename = "Arcade_Core_2";
			break;
		default:
			UnityEngine.Debug.Log("Selected a bad character");
			break;
		}
		Persistence.instance.UpdateLeaderboard();
	}

	public void PressStage3()
	{
		selectedStage = 3;
		switch (selectedCharacter)
		{
		case 0:
			Lobby_UI_Manager.instance.ChangeMusic(2);
			Persistence.instance.currentSongFilename = "Arcade_Yuri_3";
			break;
		case 1:
			Lobby_UI_Manager.instance.ChangeMusic(5);
			Persistence.instance.currentSongFilename = "Arcade_Pyro_3";
			break;
		case 2:
			Lobby_UI_Manager.instance.ChangeMusic(8);
			Persistence.instance.currentSongFilename = "Arcade_Lais_3";
			break;
		case 3:
			Lobby_UI_Manager.instance.ChangeMusic(11);
			Persistence.instance.currentSongFilename = "Arcade_Remi_3";
			break;
		case 4:
			Lobby_UI_Manager.instance.ChangeMusic(14);
			Persistence.instance.currentSongFilename = "Arcade_Liu_3";
			break;
		case 5:
			Lobby_UI_Manager.instance.ChangeMusic(17);
			Persistence.instance.currentSongFilename = "Arcade_Dre_3";
			break;
		case 6:
			Lobby_UI_Manager.instance.ChangeMusic(20);
			Persistence.instance.currentSongFilename = "Arcade_Sonya_3";
			break;
		case 7:
			Lobby_UI_Manager.instance.ChangeMusic(23);
			Persistence.instance.currentSongFilename = "Arcade_Core_3";
			break;
		default:
			UnityEngine.Debug.Log("Selected a bad character");
			break;
		}
		Persistence.instance.UpdateLeaderboard();
	}

	public void PressStage4()
	{
		selectedStage = 4;
		switch (selectedCharacter)
		{
		case 0:
			Lobby_UI_Manager.instance.ChangeMusic(24);
			Persistence.instance.currentSongFilename = "Arcade_Yuri_4";
			break;
		case 1:
			Lobby_UI_Manager.instance.ChangeMusic(25);
			Persistence.instance.currentSongFilename = "Arcade_Pyro_4";
			break;
		case 2:
			Lobby_UI_Manager.instance.ChangeMusic(26);
			Persistence.instance.currentSongFilename = "Arcade_Lais_4";
			break;
		case 3:
			Lobby_UI_Manager.instance.ChangeMusic(27);
			Persistence.instance.currentSongFilename = "Arcade_Remi_4";
			break;
		case 4:
			Lobby_UI_Manager.instance.ChangeMusic(28);
			Persistence.instance.currentSongFilename = "Arcade_Liu_4";
			break;
		case 5:
			Lobby_UI_Manager.instance.ChangeMusic(29);
			Persistence.instance.currentSongFilename = "Arcade_Dre_4";
			break;
		case 6:
			Lobby_UI_Manager.instance.ChangeMusic(30);
			Persistence.instance.currentSongFilename = "Arcade_Sonya_4";
			break;
		case 7:
			Lobby_UI_Manager.instance.ChangeMusic(31);
			Persistence.instance.currentSongFilename = "Arcade_Core_4";
			break;
		default:
			UnityEngine.Debug.Log("Selected a bad character");
			break;
		}
		Persistence.instance.UpdateLeaderboard();
	}

	private string GetDifficultySuffix()
	{
		if (Persistence.instance.currentDifficulty == 0)
		{
			return "_Easy";
		}
		if (Persistence.instance.currentDifficulty == 1)
		{
			return "_Normal";
		}
		if (Persistence.instance.currentDifficulty == 2)
		{
			return "_Hard";
		}
		UnityEngine.Debug.Log("bad difficulty");
		return "_Normal";
	}

	public void Battle()
	{
		Persistence.instance.currentSongFilename += GetDifficultySuffix();
	}

	private void UpdateRoundButtons()
	{
		switch (selectedCharacter)
		{
		case 0:
			stage1Title.text = ScriptLocalization.Yuri_Stage1;
			stage2Title.text = ScriptLocalization.Yuri_Stage2;
			stage3Title.text = ScriptLocalization.Yuri_Stage3;
			stage4Title.text = ScriptLocalization.Yuri_Stage4;
			stage1Duration.text = "2:04";
			stage2Duration.text = "2:27";
			stage3Duration.text = "2:18";
			stage4Duration.text = "3:52";
			stage1BPM.text = "145";
			stage2BPM.text = "145";
			stage3BPM.text = "145";
			stage4BPM.text = "130";
			break;
		case 1:
			stage1Title.text = ScriptLocalization.Pyro_Stage1;
			stage2Title.text = ScriptLocalization.Pyro_Stage2;
			stage3Title.text = ScriptLocalization.Pyro_Stage3;
			stage4Title.text = ScriptLocalization.Pyro_Stage4;
			stage1Duration.text = "1:56";
			stage2Duration.text = "2:02";
			stage3Duration.text = "2:01";
			stage4Duration.text = "3:20";
			stage1BPM.text = "170";
			stage2BPM.text = "170";
			stage3BPM.text = "150";
			stage4BPM.text = "110";
			break;
		case 2:
			stage1Title.text = ScriptLocalization.Lais_Stage1;
			stage2Title.text = ScriptLocalization.Lais_Stage2;
			stage3Title.text = ScriptLocalization.Lais_Stage3;
			stage4Title.text = ScriptLocalization.Lais_Stage4;
			stage1Duration.text = "2:52";
			stage2Duration.text = "2:27";
			stage3Duration.text = "2:37";
			stage4Duration.text = "3:01";
			stage1BPM.text = "128";
			stage2BPM.text = "128";
			stage3BPM.text = "128";
			stage4BPM.text = "175";
			break;
		case 3:
			stage1Title.text = ScriptLocalization.Remi_Stage1;
			stage2Title.text = ScriptLocalization.Remi_Stage2;
			stage3Title.text = ScriptLocalization.Remi_Stage3;
			stage4Title.text = ScriptLocalization.Remi_Stage4;
			stage1Duration.text = "2:32";
			stage2Duration.text = "2:28";
			stage3Duration.text = "2:39";
			stage4Duration.text = "3:45";
			stage1BPM.text = "105";
			stage2BPM.text = "175";
			stage3BPM.text = "105";
			stage4BPM.text = "130";
			break;
		case 4:
			stage1Title.text = ScriptLocalization.Liu_Stage1;
			stage2Title.text = ScriptLocalization.Liu_Stage2;
			stage3Title.text = ScriptLocalization.Liu_Stage3;
			stage4Title.text = ScriptLocalization.Liu_Stage4;
			stage1Duration.text = "2:07";
			stage2Duration.text = "2:05";
			stage3Duration.text = "2:39";
			stage4Duration.text = "4:01";
			stage1BPM.text = "128";
			stage2BPM.text = "128";
			stage3BPM.text = "128";
			stage4BPM.text = "140";
			break;
		case 5:
			stage1Title.text = ScriptLocalization.Dre_Stage1;
			stage2Title.text = ScriptLocalization.Dre_Stage2;
			stage3Title.text = ScriptLocalization.Dre_Stage3;
			stage4Title.text = ScriptLocalization.Dre_Stage4;
			stage1Duration.text = "2:27";
			stage2Duration.text = "2:21";
			stage3Duration.text = "2:57";
			stage4Duration.text = "3:00";
			stage1BPM.text = "170";
			stage2BPM.text = "114";
			stage3BPM.text = "128";
			stage4BPM.text = "130";
			break;
		case 6:
			stage1Title.text = ScriptLocalization.Sonya_Stage1;
			stage2Title.text = ScriptLocalization.Sonya_Stage2;
			stage3Title.text = ScriptLocalization.Sonya_Stage3;
			stage4Title.text = ScriptLocalization.Sonya_Stage4;
			stage1Duration.text = "2:42";
			stage2Duration.text = "2:32";
			stage3Duration.text = "2:50";
			stage4Duration.text = "3:30";
			stage1BPM.text = "130";
			stage2BPM.text = "170";
			stage3BPM.text = "110";
			stage4BPM.text = "128";
			break;
		case 7:
			stage1Title.text = ScriptLocalization.Core_Stage1;
			stage2Title.text = ScriptLocalization.Core_Stage2;
			stage3Title.text = ScriptLocalization.Core_Stage3;
			stage4Title.text = ScriptLocalization.Core_Stage4;
			stage1Duration.text = "2:49";
			stage2Duration.text = "2:19";
			stage3Duration.text = "2:42";
			stage4Duration.text = "3:49";
			stage1BPM.text = "160";
			stage2BPM.text = "160";
			stage3BPM.text = "135";
			stage4BPM.text = "115";
			break;
		default:
			UnityEngine.Debug.Log("Selected a bad character");
			break;
		}
	}

	private string FormatInfo(string bpm, string duration)
	{
		return "BPM: <color=white>" + bpm + "</color>\nDuration: <color=white>" + duration + "</color>";
	}

	private void UpdateRanks()
	{
		string[] array = Persistence.instance.currentSongFilename.Split('_');
		stage1Rank.text = Score.GetRankString(Persistence.instance.svMan.curSave.GetDifficultyRank(array[0] + "_" + array[1] + "_1" + GetDifficultySuffix()));
		stage2Rank.text = Score.GetRankString(Persistence.instance.svMan.curSave.GetDifficultyRank(array[0] + "_" + array[1] + "_2" + GetDifficultySuffix()));
		stage3Rank.text = Score.GetRankString(Persistence.instance.svMan.curSave.GetDifficultyRank(array[0] + "_" + array[1] + "_3" + GetDifficultySuffix()));
	}
}
public class UI_SoundManager : MonoBehaviour
{
	public AudioSource sfxPlayer;

	public List<AudioClip> startSFX = new List<AudioClip>();

	public List<AudioClip> danceSFX = new List<AudioClip>();

	public List<AudioClip> confirmSFX = new List<AudioClip>();

	public List<AudioClip> backSFX = new List<AudioClip>();

	public List<AudioClip> denySFX = new List<AudioClip>();

	public List<AudioClip> scoreEventSFX = new List<AudioClip>();

	private void Awake()
	{
		LoadAudio(startSFX);
		LoadAudio(danceSFX);
		LoadAudio(confirmSFX);
		LoadAudio(backSFX);
		LoadAudio(denySFX);
		LoadAudio(scoreEventSFX);
	}

	private void LoadAudio(List<AudioClip> _clips)
	{
		for (int i = 0; i < _clips.Count; i++)
		{
			_clips[i].LoadAudioData();
		}
	}

	public void PlayStartEffect()
	{
		PlaySFX(startSFX);
	}

	public void PlayConfirmEffect()
	{
		PlaySFX(confirmSFX);
	}

	public void PlayBackEffect()
	{
		PlaySFX(backSFX);
	}

	public void PlayDenyEffect()
	{
		PlaySFX(denySFX);
	}

	public void PlayScoreEventEffect()
	{
	}

	public void PlayDanceEffect()
	{
		PlaySFX(danceSFX);
	}

	private void PlaySFX(List<AudioClip> _clips, float _pitchRange = 0f)
	{
		int index = UnityEngine.Random.Range(0, _clips.Count);
		sfxPlayer.Stop();
		sfxPlayer.pitch = 1f + UnityEngine.Random.Range(_pitchRange * -1f, _pitchRange);
		sfxPlayer.clip = _clips[index];
		sfxPlayer.Play();
	}
}
public class UI_Pause : MonoBehaviour
{
	public GameObject buttons;

	public Image fillbar;

	public TextMeshProUGUI currentTimeText;

	public float unpauseTime = 3f;

	private float unpauseTimer = 3f;

	private bool unpausing;

	public void Reset()
	{
		fillbar.fillAmount = 0f;
		unpauseTimer = unpauseTime;
		buttons.SetActive(value: true);
		TimeSpan.FromSeconds(GameManager.instance.songTime);
	}

	public void StartUnpause()
	{
		buttons.SetActive(value: false);
		unpausing = true;
	}

	private void Update()
	{
		if (unpausing)
		{
			fillbar.fillAmount = Mathf.InverseLerp(unpauseTime, 0f, unpauseTimer);
			unpauseTimer -= Time.unscaledDeltaTime;
			if (unpauseTimer <= 0f)
			{
				Unpause();
			}
		}
	}

	private void Unpause()
	{
		unpausing = false;
		base.gameObject.SetActive(value: false);
		GameManager.instance.UnPause();
	}
}
public class UI_Settings : MonoBehaviour
{
	public GameObject main;

	public GameObject audio;

	public GameObject graphics;

	public GameObject other;

	public GameObject credits;

	public Slider audio_master;

	public Slider audio_game;

	public Slider audio_ambient;

	public Slider audio_sfx;

	public Slider audio_voice;

	public Slider graphics_aura;

	public Toggle audio_nodeSounds;

	public Toggle other_console;

	public Toggle other_danceHolograms;

	public Toggle other_skipIntros;

	public Toggle graphics_lightshows;

	public Toggle graphics_tauntParticles;

	public Toggle graphics_enableAura;

	public TMP_Dropdown other_language;

	private void Start()
	{
		LoadSettings();
	}

	public void LoadSettings()
	{
		SettingsSave settingsSave = Persistence.instance.svMan.settingsSave;
		audio_master.value = settingsSave.masterVolume;
		audio_game.value = settingsSave.gameMusicVolume;
		audio_ambient.value = settingsSave.ambientMusicVolume;
		audio_sfx.value = settingsSave.sfxVolume;
		audio_voice.value = settingsSave.voVolume;
		audio_nodeSounds.Set(settingsSave.enableNodeSounds);
		UpdateAudio();
		graphics_aura.value = settingsSave.auraQuality;
		graphics_lightshows.Set(settingsSave.enableLightshows);
		graphics_tauntParticles.Set(settingsSave.enableTauntParticles);
		graphics_enableAura.Set(settingsSave.enableAura);
		other_language.value = settingsSave.language;
		other_console.Set(Persistence.instance.devConsoleEnabled);
		other_danceHolograms.Set(settingsSave.enableDanceholograms);
		other_skipIntros.Set(settingsSave.skipIntros);
		UpdateLanguage();
		UnityEngine.Debug.Log("Settings Loaded");
	}

	public void SaveSettings()
	{
		Persistence.instance.svMan.settingsSave.masterVolume = audio_master.value;
		Persistence.instance.svMan.settingsSave.gameMusicVolume = audio_game.value;
		Persistence.instance.svMan.settingsSave.ambientMusicVolume = audio_ambient.value;
		Persistence.instance.svMan.settingsSave.sfxVolume = audio_sfx.value;
		Persistence.instance.svMan.settingsSave.voVolume = audio_voice.value;
		Persistence.instance.svMan.settingsSave.enableNodeSounds = audio_nodeSounds.isOn;
		UpdateAudio();
		Persistence.instance.svMan.settingsSave.auraQuality = graphics_aura.value;
		Persistence.instance.svMan.settingsSave.enableLightshows = graphics_lightshows.isOn;
		Persistence.instance.svMan.settingsSave.enableTauntParticles = graphics_tauntParticles.isOn;
		Persistence.instance.svMan.settingsSave.enableAura = graphics_enableAura.isOn;
		Persistence.instance.svMan.settingsSave.language = other_language.value;
		UpdateLanguage();
		Persistence.instance.svMan.settingsSave.enableDanceholograms = other_danceHolograms.isOn;
		Persistence.instance.svMan.settingsSave.skipIntros = other_skipIntros.isOn;
		Persistence.instance.svMan.SaveSettings();
		UnityEngine.Debug.Log("Settings Saved");
	}

	private void UpdateAudioSliders()
	{
		audio_master.GetComponent<SiliderValueDisplay>().UpdateDisplay();
		audio_game.GetComponent<SiliderValueDisplay>().UpdateDisplay();
		audio_ambient.GetComponent<SiliderValueDisplay>().UpdateDisplay();
		audio_sfx.GetComponent<SiliderValueDisplay>().UpdateDisplay();
		audio_voice.GetComponent<SiliderValueDisplay>().UpdateDisplay();
		graphics_aura.GetComponent<SiliderValueDisplay>().UpdateDisplay();
	}

	public void OpenMain()
	{
		main.SetActive(value: true);
		audio.SetActive(value: false);
		graphics.SetActive(value: false);
		other.SetActive(value: false);
		credits.SetActive(value: false);
		LoadSettings();
	}

	public void OpenAudio()
	{
		main.SetActive(value: false);
		audio.SetActive(value: true);
		graphics.SetActive(value: false);
		other.SetActive(value: false);
		credits.SetActive(value: false);
		UpdateAudioSliders();
	}

	public void OpenGraphics()
	{
		main.SetActive(value: false);
		audio.SetActive(value: false);
		graphics.SetActive(value: true);
		other.SetActive(value: false);
		credits.SetActive(value: false);
	}

	public void OpenOther()
	{
		main.SetActive(value: false);
		audio.SetActive(value: false);
		graphics.SetActive(value: false);
		other.SetActive(value: true);
		credits.SetActive(value: false);
	}

	public void OpenCredits()
	{
		main.SetActive(value: false);
		audio.SetActive(value: false);
		graphics.SetActive(value: false);
		other.SetActive(value: false);
		credits.SetActive(value: true);
	}

	private void UpdateAudio()
	{
		UnityEngine.Debug.Log("Set the master volume up because UpdateAudio");
	}

	private void UpdateLanguage()
	{
		LocalizationManager.CurrentLanguage = other_language.options[other_language.value].text;
	}

	public void ToggleDevConsole()
	{
		Persistence.instance.ToggleTerminal(other_console.isOn);
	}
}
public class UVScroller : MonoBehaviour
{
	private Renderer rend;

	public List<Vector2> scrollValues;

	public bool randomise;

	public Vector2 scrollInterval = new Vector2(4f, 12f);

	public float timer;

	public int index;

	private void Start()
	{
		rend = GetComponent<Renderer>();
		ResetTimer();
		index = 0;
	}

	private void Update()
	{
		if (timer > 0f)
		{
			timer -= Time.deltaTime;
			if (timer <= 0f)
			{
				Scroll();
				ResetTimer();
			}
		}
	}

	private void Scroll()
	{
		if (!randomise)
		{
			index++;
			if (index == scrollValues.Count)
			{
				index = 0;
			}
		}
		else
		{
			int num = index;
			while (num == index && scrollValues.Count >= 2)
			{
				index = UnityEngine.Random.Range(0, scrollValues.Count);
			}
		}
		rend.material.mainTextureOffset = scrollValues[index];
	}

	private void ResetTimer()
	{
		timer = UnityEngine.Random.Range(scrollInterval.x, scrollInterval.y);
	}
}
public class AnimationMiddleMan : MonoBehaviour
{
	public HoloAnimationController animCon;

	[HideInInspector]
	public VoiceOverManager voManager;

	[HideInInspector]
	public LookAtManager laManager;

	public Transform blankLookTarget;

	private void Awake()
	{
		if (SceneManager.GetActiveScene().name != "dance collider lobby")
		{
			voManager = UnityEngine.Object.FindObjectOfType<VoiceOverManager>();
			animCon = UnityEngine.Object.FindObjectOfType<HoloAnimationController>();
		}
	}

	public void EndHolo()
	{
		animCon.EndHolo();
	}

	public void PlayVoiceLine(VOType _type)
	{
		if (voManager != null)
		{
			voManager.PlayVoiceLine(_type);
		}
	}

	public void SetLookAt(int _id, float _duration)
	{
		switch (_id)
		{
		case -2:
			laManager.ForceTargetPlayer(_duration);
			break;
		case -1:
			laManager.ForceNoTarget(_duration);
			break;
		default:
			laManager.ForceGenericTarget(_id, _duration);
			break;
		}
	}

	public void ShowDance()
	{
	}
}
public class AnimationSelectENUM : MonoBehaviour
{
	public enum Animations
	{
		Anim0,
		Anim1,
		Anim2,
		Anim3,
		Anim4,
		Anim5,
		Anim6,
		Anim7,
		Anim8,
		Anim9,
		Anim10,
		Anim11,
		Anim12,
		Anim13,
		Anim14,
		Anim15,
		Anim16,
		Anim17,
		Anim18,
		Anim19,
		Anim20
	}

	public Animations animations;

	public List<AnimationClip> _animNames = new List<AnimationClip>();

	private void Start()
	{
		AnimSet();
	}

	public void AnimSet()
	{
		Animation component = GetComponent<Animation>();
		switch (animations)
		{
		case Animations.Anim0:
			component.clip = _animNames[0];
			break;
		case Animations.Anim1:
			component.clip = _animNames[1];
			break;
		case Animations.Anim2:
			component.clip = _animNames[2];
			break;
		case Animations.Anim3:
			component.clip = _animNames[3];
			break;
		case Animations.Anim4:
			component.clip = _animNames[4];
			break;
		case Animations.Anim5:
			component.clip = _animNames[5];
			break;
		case Animations.Anim6:
			component.clip = _animNames[6];
			break;
		case Animations.Anim7:
			component.clip = _animNames[7];
			break;
		case Animations.Anim8:
			component.clip = _animNames[8];
			break;
		case Animations.Anim9:
			component.clip = _animNames[9];
			break;
		case Animations.Anim10:
			component.clip = _animNames[10];
			break;
		case Animations.Anim11:
			component.clip = _animNames[11];
			break;
		case Animations.Anim12:
			component.clip = _animNames[12];
			break;
		case Animations.Anim13:
			component.clip = _animNames[13];
			break;
		case Animations.Anim14:
			component.clip = _animNames[14];
			break;
		case Animations.Anim15:
			component.clip = _animNames[15];
			break;
		case Animations.Anim16:
			component.clip = _animNames[16];
			break;
		case Animations.Anim17:
			component.clip = _animNames[17];
			break;
		case Animations.Anim18:
			component.clip = _animNames[18];
			break;
		case Animations.Anim19:
			component.clip = _animNames[19];
			break;
		case Animations.Anim20:
			component.clip = _animNames[20];
			break;
		}
		component.Play();
	}
}
public class AudioLoader : MonoBehaviour
{
	public List<AudioClip> toLoad;

	public List<VoiceOverManager> voMans;

	public List<LipSync> lipSyncs;

	private void Start()
	{
		if (toLoad.Count > 0)
		{
			for (int i = 0; i < toLoad.Count; i++)
			{
				toLoad[i].LoadAudioData();
			}
		}
		if (voMans.Count > 0)
		{
			for (int j = 0; j < voMans.Count; j++)
			{
				voMans[j].LoadAll();
			}
		}
		if (lipSyncs.Count > 0)
		{
			for (int k = 0; k < lipSyncs.Count; k++)
			{
				lipSyncs[k].Invoke("Awake", 0f);
			}
		}
		AudioSource component = GetComponent<AudioSource>();
		if (component != null)
		{
			component.clip.LoadAudioData();
		}
	}
}
public class BobScript : MonoBehaviour
{
	public Vector3 axis = new Vector3(0f, 1f, 0f);

	private Vector3 startPos;

	public float speed;

	public float amplitude = 1f;

	public float cycleOffset;

	private void Start()
	{
		startPos = base.transform.localPosition;
	}

	private void Update()
	{
		float num = Mathf.Sin((Time.time + cycleOffset) * speed) * amplitude;
		base.transform.localPosition = startPos + num * axis.normalized;
	}
}
public class CopyRotation : MonoBehaviour
{
	public Transform target;

	public bool copyX = true;

	public bool copyY = true;

	public bool copyZ = true;

	private void Start()
	{
	}

	private void Update()
	{
		Vector3 eulerAngles = base.transform.localRotation.eulerAngles;
		if (copyX)
		{
			eulerAngles.x = target.localRotation.eulerAngles.x;
		}
		if (copyY)
		{
			eulerAngles.y = target.localRotation.eulerAngles.y;
		}
		if (copyZ)
		{
			eulerAngles.z = target.localRotation.eulerAngles.z;
		}
		base.transform.localRotation = Quaternion.Euler(eulerAngles);
	}
}
public class FadeFinder : MonoBehaviour
{
	public List<TextFader> faders = new List<TextFader>();

	public List<GameObject> toggles = new List<GameObject>();

	public void FadeIn()
	{
		for (int i = 0; i < faders.Count; i++)
		{
			faders[i].FadeIn();
		}
		for (int j = 0; j < toggles.Count; j++)
		{
			toggles[j].SetActive(value: true);
		}
	}

	public void FadeOut()
	{
		for (int i = 0; i < faders.Count; i++)
		{
			faders[i].FadeOut();
		}
		for (int j = 0; j < toggles.Count; j++)
		{
			toggles[j].SetActive(value: false);
		}
	}
}
public class FadeInOut : MonoBehaviour
{
	public MeshRenderer ocuFader;

	public float value;

	public float target;

	public bool startFade;

	private bool fading;

	public float fadeRate = 0.1f;

	private Texture2D blackTexture;

	public void Fade()
	{
		fading = true;
		UnityEngine.Debug.Log("starting fade! value: " + value + " target: " + target);
		ocuFader.material.color = new Color(0f, 0f, 0f, value);
	}

	private void Start()
	{
		Persistence.instance.masterMix.SetFloat("MasterVolume", -80f);
		UnityEngine.Debug.Log("Set the master volume down because fadeinoutstart");
		ocuFader.material.color = new Color(0f, 0f, 0f, value);
		if (startFade)
		{
			Fade();
		}
	}

	private void Update()
	{
		if (!fading)
		{
			return;
		}
		if (Mathf.Abs(target - value) < 0.01f)
		{
			fading = false;
			value = target;
			ocuFader.material.color = new Color(0f, 0f, 0f, value);
			ocuFader.GetComponentInChildren<SpriteRenderer>().color = new Color(1f, 1f, 1f, value - 0.4f);
			return;
		}
		if (value < target)
		{
			value += 0.011f;
		}
		else
		{
			value -= 0.011f;
		}
		float f = Mathf.Lerp(1f, 0.01f, value);
		Persistence.instance.masterMix.SetFloat("MasterVolume", Mathf.Log10(f) * 20f);
		ocuFader.material.color = new Color(0f, 0f, 0f, value);
		ocuFader.GetComponentInChildren<SpriteRenderer>().color = new Color(1f, 1f, 1f, value - 0.4f);
	}
}
public class FogSetter : MonoBehaviour
{
	private void Start()
	{
		if ((bool)GameManager.instance)
		{
			if (!GameManager.instance.isTutorial)
			{
				GameManager.instance.StartFadeIn();
			}
			else
			{
				Invoke("TutorialDelay", 2.5f);
			}
		}
	}

	private void TutorialDelay()
	{
		GameManager.instance.StartFadeIn();
	}
}
public class GraphyGrabber : MonoBehaviour
{
	public void LogData(int _scm)
	{
		UnityEngine.Object.FindObjectOfType<PerformanceLogger>().SceneLeft((SceneCloseMethod)_scm);
	}
}
public class HoloKiller : MonoBehaviour
{
	public void KILLKILLKILL()
	{
		if (!GameManager.instance.isTutorial && !GameManager.instance.inEditor)
		{
			UnityEngine.Object.FindObjectOfType<HoloAnimationController>().EndHolo();
		}
	}
}
public class Image_Blinker : MonoBehaviour
{
	public Image image;

	public float blinkTime;

	public bool blink;

	private Color startCol;

	private void Awake()
	{
		startCol = image.color;
	}

	private void OnEnable()
	{
		StartCoroutine(Blink());
	}

	private IEnumerator Blink()
	{
		while (true)
		{
			if (blink)
			{
				image.enabled = false;
				yield return new WaitForSeconds(blinkTime);
			}
			image.enabled = true;
			yield return new WaitForSeconds(blinkTime);
		}
	}
}
public class LBButtonUpdater : MonoBehaviour
{
	public enum ButtonType
	{
		e_Global,
		e_Friends,
		e_Local
	}

	private LeaderboardManager lbMan;

	private Button button;

	public ButtonType type;

	private void Start()
	{
		lbMan = UnityEngine.Object.FindObjectOfType<LeaderboardManager>();
		button = GetComponent<Button>();
	}

	private void Update()
	{
		if (button.interactable)
		{
			switch (type)
			{
			case ButtonType.e_Global:
				if (lbMan.curBoard == 0)
				{
					button.interactable = false;
				}
				break;
			case ButtonType.e_Friends:
				if (lbMan.curBoard == 1)
				{
					button.interactable = false;
				}
				break;
			case ButtonType.e_Local:
				if (lbMan.curBoard == 2)
				{
					button.interactable = false;
				}
				break;
			}
			return;
		}
		switch (type)
		{
		case ButtonType.e_Global:
			if (lbMan.curBoard != 0)
			{
				button.interactable = true;
			}
			break;
		case ButtonType.e_Friends:
			if (lbMan.curBoard != 1)
			{
				button.interactable = true;
			}
			break;
		case ButtonType.e_Local:
			if (lbMan.curBoard != 2)
			{
				button.interactable = true;
			}
			break;
		}
	}
}
public class LerpToPosition : MonoBehaviour
{
	public Transform objectToFollow;

	public float lerpRate;

	private void Update()
	{
		base.transform.position = Vector3.Lerp(base.transform.position, objectToFollow.position, Time.deltaTime * lerpRate);
	}
}
public class LookAt : MonoBehaviour
{
	public Transform target;

	public Vector3 offset = Vector3.zero;

	private void FixedUpdate()
	{
		base.transform.LookAt(target.position);
		base.transform.Rotate(offset, Space.Self);
	}
}
public class MoveInDirection : MonoBehaviour
{
	public Vector3 direction;

	public float speed;

	private void Update()
	{
		base.transform.Translate(direction.normalized * speed * Time.deltaTime);
	}
}
public class ObservePosition : MonoBehaviour
{
	public Transform oculusFollow;

	public Transform viveFollow;

	public bool followX;

	public bool followY;

	public bool followZ;

	private void Update()
	{
		if (oculusFollow != null && oculusFollow.gameObject.activeInHierarchy)
		{
			base.transform.position = new Vector3(followX ? oculusFollow.position.x : base.transform.position.x, followY ? oculusFollow.position.y : base.transform.position.y, followZ ? oculusFollow.position.z : base.transform.position.z);
		}
		else if (viveFollow != null && viveFollow.gameObject.activeInHierarchy)
		{
			base.transform.position = new Vector3(followX ? viveFollow.position.x : base.transform.position.x, followY ? viveFollow.position.y : base.transform.position.y, followZ ? viveFollow.position.z : base.transform.position.z);
		}
	}
}
public class OffsetPosition : MonoBehaviour
{
	public Transform targetTransform;

	public Vector3 offset;

	private void Update()
	{
		base.transform.position = targetTransform.position + offset;
	}
}
public static class ParseLoc
{
	public static string Parse(string input)
	{
		if (input.StartsWith("&"))
		{
			string Translation = "";
			if (LocalizationManager.TryGetTranslation(input.Substring(1), out Translation))
			{
				return Translation;
			}
			UnityEngine.Debug.Log("Error: Key " + input + "(" + input.Substring(1) + ") not found.");
			return input + "?";
		}
		return input;
	}
}
public class ParticleAttractor : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
	}
}
public enum SceneCloseMethod
{
	e_Back,
	e_Stop,
	e_Restart,
	e_Next,
	e_Timer,
	e_Battle
}
public class PerformanceLogger : MonoBehaviour
{
	private GraphyManager graMan;

	private string outputString = "";

	private string filename = "";

	public Canvas graphyCanvas;

	private void Start()
	{
		graMan = UnityEngine.Object.FindObjectOfType<GraphyManager>();
		DateTime now = DateTime.Now;
		string text = "";
		text = now.Day + "-" + now.Month + "-" + now.Year + "  " + now.Hour + " " + now.Minute + " " + now.Second + " " + now.Millisecond;
		filename = UnityEngine.Application.dataPath + "/DC Log " + text + ".txt";
		outputString = " Dance Collider Performance Log\n";
		outputString += " ==============================\n\n";
		outputString = "Loaded Scene: ";
		outputString = outputString + SceneManager.GetActiveScene().name + " at " + DateTime.Now.ToString() + ".\n\n";
		UnityEngine.Debug.Log("Writing To " + filename);
		File.WriteAllText(filename, outputString);
		outputString = "";
	}

	private void Update()
	{
		if ((Input.GetKey(KeyCode.LeftControl) || Input.GetKey(KeyCode.RightControl)) && Input.GetKeyDown(KeyCode.H))
		{
			graphyCanvas.enabled = !graphyCanvas.enabled;
		}
	}

	private void OnLevelWasLoaded(int level)
	{
		outputString = "Loaded Scene: ";
		outputString = outputString + SceneManager.GetActiveScene().name + " at " + DateTime.Now.ToString() + ".\n\n";
		UnityEngine.Debug.Log("Writing To " + filename);
		File.WriteAllText(filename, outputString);
		outputString = "";
	}

	public void SceneLeft(SceneCloseMethod _method)
	{
		outputString += "== FPS ==\n";
		outputString = outputString + "Avg: " + graMan.AverageFPS + "\n";
		outputString = outputString + "Min: " + graMan.MinFPS + "\n";
		outputString = outputString + "Max: " + graMan.MaxFPS + "\n\n";
		outputString += "== RAM ==\n";
		outputString = outputString + "Allocated: " + graMan.AllocatedRam + " MB\n";
		outputString = outputString + "Reserved: " + graMan.ReservedRam + " MB\n";
		outputString = outputString + "Mono: " + graMan.MonoRam + " MB\n\n";
		outputString += "== Audio ==\n";
		outputString = outputString + "Max Decibels: " + graMan.MaxDB + "\n\n";
		outputString += "== System Info ==\n";
		outputString = outputString + "CPU: " + SystemInfo.processorType + " [" + SystemInfo.processorCount + "] @" + SystemInfo.processorFrequency + "GHz\n";
		outputString = outputString + "RAM: " + SystemInfo.systemMemorySize + " MB\n";
		outputString = outputString + "GPU: " + SystemInfo.graphicsDeviceName + "\n";
		outputString = outputString + "GPU API: " + SystemInfo.graphicsDeviceVersion + "\n";
		outputString = outputString + "VRAM: " + SystemInfo.graphicsMemorySize + " MB. Max texture size: " + SystemInfo.maxTextureSize + "px. Shader level: " + SystemInfo.graphicsShaderLevel + " \n";
		outputString = outputString + "OS: " + SystemInfo.operatingSystem + " [" + SystemInfo.deviceType.ToString() + "]\n\n";
		string text = "NOTHING?";
		switch (_method)
		{
		case SceneCloseMethod.e_Back:
			text = "Back Button";
			break;
		case SceneCloseMethod.e_Next:
			text = "Next Button";
			break;
		case SceneCloseMethod.e_Restart:
			text = "Restart Button";
			break;
		case SceneCloseMethod.e_Stop:
			text = "Stop Button";
			break;
		case SceneCloseMethod.e_Timer:
			text = "Next Timer";
			break;
		case SceneCloseMethod.e_Battle:
			text = "Battle Button";
			break;
		}
		outputString = outputString + "Scene closed via " + text + " at " + DateTime.Now.ToString() + ".\n";
		outputString += "\n===============\n";
		File.AppendAllText(filename, outputString);
	}
}
[Serializable]
public class ManualVO
{
	public LipSyncData vo;

	public KeyCode key;

	public bool useTimer;

	public float playAfter;

	private float timer;

	public bool CheckPress()
	{
		if (Input.GetKeyDown(key))
		{
			return true;
		}
		return false;
	}

	public bool UpdateTimer()
	{
		if (useTimer && timer < playAfter)
		{
			timer += Time.deltaTime;
			if (timer >= playAfter)
			{
				return true;
			}
		}
		return false;
	}
}
public class PlayVoiceline : MonoBehaviour
{
	public LipSync lipSync;

	public List<ManualVO> voiceOvers;

	private void Update()
	{
		for (int i = 0; i < voiceOvers.Count; i++)
		{
			if (voiceOvers[i].CheckPress())
			{
				PlayLine(voiceOvers[i].vo);
			}
			if (voiceOvers[i].UpdateTimer())
			{
				PlayLine(voiceOvers[i].vo);
			}
		}
	}

	private void PlayLine(LipSyncData _data)
	{
		lipSync.Stop(stopAudio: true);
		lipSync.Play(_data);
	}
}
public class SelfDestruct : MonoBehaviour
{
	public float lifetime;

	private void Start()
	{
		Invoke("Destruct", lifetime);
	}

	private void Destruct()
	{
		UnityEngine.Object.Destroy(base.gameObject);
	}
}
public class Shrinker : MonoBehaviour
{
	private Vector3 startScale;

	public void Awake()
	{
	}

	public void Shrink()
	{
	}

	public void Unshrink()
	{
	}
}
public class StayBetweenTwoObjects : MonoBehaviour
{
	public Transform obj1;

	public Transform obj2;

	[Range(0f, 1f)]
	public float percentage;

	private void Update()
	{
		base.transform.position = Vector3.Lerp(obj1.position, obj2.position, percentage);
	}
}
public class TextFader : MonoBehaviour
{
	private enum FadeState
	{
		e_None,
		e_FadeIn,
		e_FadeOut
	}

	private TMP_Text text;

	public float fadeTime = 0.25f;

	private FadeState state;

	private float progress;

	public AnimationCurve fadeCurve;

	private bool fadeTransition;

	private string textToSet;

	private void Start()
	{
		text = GetComponent<TextMeshProUGUI>();
		if (text == null)
		{
			text = GetComponent<TextMeshPro>();
		}
	}

	private void Update()
	{
		if (state == FadeState.e_None)
		{
			return;
		}
		progress += Time.deltaTime / fadeTime;
		progress = Mathf.Clamp01(progress);
		float num = fadeCurve.Evaluate(progress);
		if (state == FadeState.e_FadeIn)
		{
			SetAlpha(num);
		}
		else if (state == FadeState.e_FadeOut)
		{
			SetAlpha(1f - num);
		}
		if (progress >= 1f)
		{
			if (fadeTransition)
			{
				FadeIn();
				text.text = textToSet;
				fadeTransition = false;
			}
			else
			{
				state = FadeState.e_None;
			}
		}
	}

	public void FadeIn()
	{
		if (text.color.a < 0.9f)
		{
			SetAlpha(0f);
			progress = 0f;
			state = FadeState.e_FadeIn;
		}
	}

	public void FadeOut()
	{
		if (text.color.a > 0.1f)
		{
			SetAlpha(1f);
			progress = 0f;
			state = FadeState.e_FadeOut;
		}
	}

	public void FadeTransition(string _text)
	{
		textToSet = _text;
		if (text.color.a < 0.1f)
		{
			text.text = _text;
			FadeIn();
		}
		else
		{
			fadeTransition = true;
			FadeOut();
		}
	}

	private void SetAlpha(float _alpha)
	{
		text.color = new Color(text.color.r, text.color.g, text.color.b, _alpha);
	}
}
public class VelocityHolder : MonoBehaviour
{
	public int framesBuffer = 5;

	public float velocity;

	public bool usebuffer;

	private List<float> frames;

	private Vector3 oldPos = Vector3.zero;

	private void Awake()
	{
		frames = new List<float>();
	}

	private void Update()
	{
		if (usebuffer)
		{
			float num = Vector3.Distance(base.transform.position, oldPos) / Time.deltaTime;
			if (num == 0f)
			{
				return;
			}
			frames.Add(num);
			if (frames.Count > framesBuffer)
			{
				frames.RemoveAt(0);
			}
			float num2 = 0f;
			for (int i = 0; i < frames.Count; i++)
			{
				num2 += frames[i];
			}
			velocity = num2 / ((float)frames.Count * 1f);
		}
		else
		{
			velocity = Vector3.Distance(base.transform.position, oldPos) / Time.deltaTime;
		}
		oldPos = base.transform.position;
	}
}
public class SmoothCamera : MonoBehaviour
{
	public Camera oculusTarget;

	public Camera viveTarget;

	private Transform target;

	private void OnEnable()
	{
	}

	private void FixedUpdate()
	{
		base.transform.position = Vector3.Lerp(base.transform.position, target.position, 1f - Persistence.instance.svMan.settingsSave.smoothCamera_Smoothness);
		base.transform.rotation = Quaternion.Lerp(base.transform.rotation, target.rotation, 1f - Persistence.instance.svMan.settingsSave.smoothCamera_Smoothness);
	}

	public void ApplySettings()
	{
	}
}
public class SmoothCameraController : MonoBehaviour
{
	public GameObject smoothCamera;

	private void Start()
	{
		StartCoroutine(lateStart());
	}

	private IEnumerator lateStart()
	{
		yield return new WaitForSeconds(1f);
		UpdateSettings();
	}

	public void UpdateSettings()
	{
		smoothCamera.SetActive(Persistence.instance.svMan.settingsSave.smoothCamera);
		smoothCamera.GetComponent<SmoothCamera>().ApplySettings();
	}
}
public class SplashManager : MonoBehaviour
{
	public float delay = 2f;

	public void Start()
	{
		StartCoroutine(LoadYourAsyncScene());
	}

	private IEnumerator LoadYourAsyncScene()
	{
		yield return new WaitForSeconds(delay);
		AsyncOperation asyncLoad = SceneManager.LoadSceneAsync("intro cutscene");
		while (!asyncLoad.isDone)
		{
			yield return null;
		}
	}
}
public class SteamVR_ControllerFix : MonoBehaviour
{
	public Vector3 newPos;

	public Vector3 newRot;

	private void Start()
	{
	}
}
public class TextPopup : MonoBehaviour
{
	public float time = 1.5f;

	public float floatSpeed = 0.1f;

	private float timer;

	public TextMeshPro text;

	private void Start()
	{
		timer = time;
		base.transform.LookAt(GameManager.instance.objectRefrences.oculusCenter);
	}

	public void SetText(string message)
	{
		text.text = message;
	}

	private void Update()
	{
		if (timer >= 0f)
		{
			timer -= Time.deltaTime;
			if (timer < 0f)
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
		}
		text.color = new Color(text.color.r, text.color.g, text.color.b, text.color.a - Time.deltaTime / time);
		base.transform.position += Vector3.up * floatSpeed * Time.deltaTime;
	}
}
public class TriggerObjectEnabler : MonoBehaviour
{
	public List<GameObject> objects;

	public Transform leftController;

	public Transform rightController;

	private GameManager gm;

	private Collider col;

	private bool inBounds;

	private void Awake()
	{
		gm = GameManager.instance;
		col = GetComponent<Collider>();
	}

	private void Start()
	{
		leftController = gm.objectRefrences.leftController.transform;
		rightController = gm.objectRefrences.rightController.transform;
	}

	public void DisableAllObjects()
	{
		for (int i = 0; i < objects.Count; i++)
		{
			objects[i].SetActive(value: false);
		}
	}

	private void Update()
	{
		inBounds = col.bounds.Contains(leftController.position) || col.bounds.Contains(rightController.position);
		for (int i = 0; i < objects.Count; i++)
		{
			objects[i].SetActive(inBounds);
		}
	}
}
public class ExampleCardItemAction : MonoBehaviour
{
	public Transform title;

	public Transform description;

	private Text titleText;

	private Text descriptionText;

	private void Awake()
	{
		if (null != title)
		{
			titleText = title.GetComponent<Text>();
		}
		if (null != description)
		{
			descriptionText = description.GetComponent<Text>();
		}
	}

	private void Start()
	{
		GetComponent<CardItem>().OnCardClicked += ShowDescription;
	}

	private void ShowDescription(Card card)
	{
		if (null != titleText)
		{
			titleText.text = card.title;
		}
		if (null != descriptionText)
		{
			descriptionText.text = card.description;
		}
	}
}
public class ExampleDynamicCardList : MonoBehaviour
{
	public CardListManager clm;

	private void Start()
	{
		UpdateList();
	}

	public void UpdateList()
	{
		clm.Reset();
		clm.cardList.Clear();
		for (int i = 0; i <= 5; i++)
		{
			Card card = new Card();
			card.title = "Test " + i;
			clm.cardList.Add(card);
		}
		clm.PopulateList();
	}
}
public class ExampleOptionControl : MonoBehaviour
{
	private OptionsManager optionsManager;

	private void Start()
	{
		optionsManager = GetComponent<OptionsManager>();
		optionsManager.OnOptionSelected += SwitchInteractionMode;
	}

	private void SwitchInteractionMode(int i)
	{
		UnityEngine.Debug.Log("Current selected index: " + i);
		if (!(null == LaserInputModule.instance))
		{
			switch (i)
			{
			case 0:
				LaserInputModule.instance.pointer = VRUiKits.Utils.Pointer.LeftHand;
				break;
			case 1:
				LaserInputModule.instance.pointer = VRUiKits.Utils.Pointer.Eye;
				break;
			}
		}
	}
}
public class InvokeKeyboard : MonoBehaviour, ISelectHandler, IEventSystemHandler, IDeselectHandler
{
	public GameObject keyboard;

	public bool hideKeyboardOnDeslect;

	public void OnSelect(BaseEventData eventData)
	{
		if (!keyboard.activeSelf)
		{
			keyboard.SetActive(value: true);
		}
	}

	public void OnDeselect(BaseEventData eventData)
	{
		if (hideKeyboardOnDeslect && keyboard.activeSelf)
		{
			keyboard.SetActive(value: false);
		}
	}
}
public class SwitchUI : MonoBehaviour
{
	public List<GameObject> canvas;

	private int currentIndex;

	public void NextUI()
	{
		if (canvas.Count != 0)
		{
			canvas[currentIndex].SetActive(value: false);
			currentIndex++;
			if (currentIndex >= canvas.Count)
			{
				currentIndex = 0;
			}
			canvas[currentIndex].SetActive(value: true);
		}
	}
}
public class UI_Browser : MonoBehaviour
{
	public GameObject browserButton;

	public UI_Editor_Display manager;

	public void GetColliders()
	{
		foreach (Transform item in browserButton.transform.parent)
		{
			if (item.gameObject.activeSelf)
			{
				UnityEngine.Object.Destroy(item.gameObject);
			}
		}
		FileInfo[] files = new DirectoryInfo(UnityEngine.Application.dataPath + "/StreamingAssets/Custom/Dances").GetFiles();
		foreach (FileInfo fileInfo in files)
		{
			if (!fileInfo.Name.StartsWith("Arcade_") && !fileInfo.Name.StartsWith("Tutorial_") && fileInfo.Extension == ".json")
			{
				GameObject gameObject = UnityEngine.Object.Instantiate(browserButton, browserButton.transform.parent);
				string fileName = fileInfo.Name.Split('.')[0];
				gameObject.GetComponentInChildren<TextMeshProUGUI>().text = fileName;
				gameObject.GetComponentInChildren<Button>().onClick.AddListener(delegate
				{
					SetCustomSong(fileName);
				});
				gameObject.SetActive(value: true);
			}
		}
	}

	private void SetCustomSong(string name)
	{
		manager.selectedSong.text = name;
		manager.danceButton.interactable = true;
	}

	public void OpenCustomInWindowsExplorer()
	{
		string text = UnityEngine.Application.streamingAssetsPath + "/Custom/";
		text = text.Replace("/", "\\");
		UnityEngine.Debug.Log("Running command /root,\"" + text + "\"");
		Process.Start("explorer.exe", "/root,\"" + text + "\"");
	}
}
public class UI_Editor_Display : UI_Screen
{
	public UI_Browser browser;

	public Toggle easytoggle;

	public Toggle normalToggle;

	public Toggle hardToggle;

	public TextMeshProUGUI selectedSong;

	public Button danceButton;

	public override void Transition(bool on)
	{
		base.Transition(on);
		if (on)
		{
			browser.GetColliders();
			easytoggle.isOn = Persistence.instance.currentDifficulty == 0;
			normalToggle.isOn = Persistence.instance.currentDifficulty == 1;
			hardToggle.isOn = Persistence.instance.currentDifficulty == 2;
			selectedSong.text = "";
			danceButton.interactable = false;
		}
	}

	public void UpdateDifficulty(int diff)
	{
		Persistence.instance.currentDifficulty = diff;
	}

	public void LoadCustomSong()
	{
		Persistence.instance.currentSongFilename = selectedSong.text;
		Lobby_UI_Manager.instance.LoadGameCustom();
	}
}
public class UI_Editor_EditTools : MonoBehaviour
{
	public EditorManager editorManager;

	public Button cut_button;

	public Button copy_button;

	public Button paste_button;

	public TextMeshProUGUI clipboardText;

	public Image trigger_select_highlight;

	public Image trigger_multi_highlight;

	public Image trigger_add_highlight;

	private void Start()
	{
		RefreshUI();
	}

	public void RefreshUI()
	{
		cut_button.interactable = editorManager.objectRefrences.songEditor.selectedNodes.Count > 0;
		copy_button.interactable = editorManager.objectRefrences.songEditor.selectedNodes.Count > 0;
		paste_button.interactable = editorManager.clipboard.Count > 0;
		clipboardText.text = editorManager.clipboard.Count.ToString();
		trigger_select_highlight.enabled = editorManager.triggerMode == EditorManager.TriggerMode.Select;
		trigger_multi_highlight.enabled = editorManager.triggerMode == EditorManager.TriggerMode.BoxSelect || editorManager.triggerMode == EditorManager.TriggerMode.TimeSelect;
		trigger_add_highlight.enabled = editorManager.triggerMode == EditorManager.TriggerMode.Add;
	}

	public void Cut()
	{
		editorManager.Cut();
		RefreshUI();
	}

	public void Copy()
	{
		editorManager.Copy();
		RefreshUI();
	}

	public void Paste()
	{
		editorManager.Paste();
		RefreshUI();
	}

	public void Trigger_Select()
	{
		editorManager.SwapTriggerMode(EditorManager.TriggerMode.Select);
	}

	public void Trigger_Multi()
	{
		editorManager.SwapTriggerMode((!editorManager.multiSelectTimeSelect) ? EditorManager.TriggerMode.BoxSelect : EditorManager.TriggerMode.TimeSelect);
	}

	public void Trigger_Add()
	{
		editorManager.SwapTriggerMode(EditorManager.TriggerMode.Add);
	}
}
public class UI_Editor_Info : MonoBehaviour
{
	public Dictionary<string, string> texts;

	public TextMeshProUGUI text;

	public void SetText(string key)
	{
		string value = "oops";
		texts.TryGetValue(key, out value);
		text.text = value;
	}
}
public class UI_Editor_TestPanel : MonoBehaviour
{
	public TextMeshProUGUI infoText;

	public Toggle easytoggle;

	public Toggle normalToggle;

	public Toggle proToggle;

	public Toggle godToggle;

	public Toggle arenaToggle;

	public Button testButton;

	private GameManager gm;

	private EditorManager em;

	private SongEditor editor;

	private int difficulty = 1;

	private void Start()
	{
		gm = GameManager.instance;
		em = EditorManager.instance;
		editor = em.objectRefrences.songEditor;
		testButton.interactable = false;
		infoText.text = "Nothing loaded!";
	}

	private void Update()
	{
		TimeSpan timeSpan = TimeSpan.FromSeconds(editor.songDuration);
		if (!editor.HasNoChildren())
		{
			infoText.text = Persistence.instance.currentSongFilename + "\n" + timeSpan.Minutes + "m " + timeSpan.Seconds + "s\n" + (editor.transform.childCount - 2) + " nodes";
		}
		testButton.interactable = !editor.HasNoChildren() && !em.loading;
	}

	public void UpdateDifficulty()
	{
		if (easytoggle.isOn)
		{
			difficulty = 0;
		}
		else if (normalToggle.isOn)
		{
			difficulty = 1;
		}
		else if (proToggle.isOn)
		{
			difficulty = 2;
		}
	}

	public void Test()
	{
		UpdateDifficulty();
		Persistence.instance.currentDifficulty = difficulty;
		em.PlayDance();
	}
}
public class UI_IncrementalValue : MonoBehaviour
{
	public Button up_Button;

	public Button down_Button;

	public TextMeshProUGUI valueText;

	public float increment = 1f;

	public Vector2 minMaxValue;

	public float value;

	public string format;

	public void SetValue(float _value)
	{
		value = _value;
		UpdateValues();
	}

	public void Up()
	{
		value += increment;
		UpdateValues();
	}

	public void Down()
	{
		value -= increment;
		UpdateValues();
	}

	private void UpdateValues()
	{
		up_Button.interactable = value + increment <= minMaxValue.y;
		down_Button.interactable = value - increment >= minMaxValue.x;
		valueText.text = value.ToString(format);
	}

	private void OnEnable()
	{
		UpdateValues();
	}
}
public class UI_Navigation : MonoBehaviour
{
	public Slider progressBar;

	public TextMeshProUGUI timer;

	public Button skipToStart;

	public Button skipToEnd;

	public Button playPause;

	public Sprite playSprite;

	public Sprite pauseSprite;

	private void Start()
	{
	}

	private void Update()
	{
		if (EditorManager.instance.objectRefrences.songEditor.currentSong != null)
		{
			TimeSpan timeSpan = TimeSpan.FromSeconds(EditorManager.instance.GetCurrentTime());
			TimeSpan timeSpan2 = TimeSpan.FromSeconds(EditorManager.instance.objectRefrences.songEditor.songDuration);
			string text = $"{timeSpan.Minutes}:{timeSpan.Seconds:D2}.{timeSpan.Milliseconds:D3}";
			string text2 = $"{timeSpan2.Minutes}:{timeSpan2.Seconds:D2}.{timeSpan2.Milliseconds:D3}";
			timer.text = text + " / " + text2;
			progressBar.Set(Mathf.InverseLerp(0f, EditorManager.instance.objectRefrences.songEditor.songDuration, EditorManager.instance.GetCurrentTime()));
		}
		else
		{
			timer.text = "No song loaded!";
		}
		progressBar.interactable = !GameManager.instance.songPlaying;
		skipToStart.interactable = !GameManager.instance.songPlaying;
		skipToEnd.interactable = !GameManager.instance.songPlaying;
		TogglePlayPauseSprite();
	}

	public void OnSliderValuechange()
	{
		float seconds = Mathf.Lerp(0f, EditorManager.instance.objectRefrences.songEditor.songDuration, progressBar.value);
		EditorManager.instance.SkipToSeconds(seconds);
	}

	public void TogglePlayPauseSprite()
	{
		playPause.GetComponent<Image>().sprite = (GameManager.instance.songPlaying ? pauseSprite : playSprite);
	}
}
public class UI_NodeSettings : MonoBehaviour
{
	public bool isutility;

	public List<SceneEditorNode> selectedNodes;

	public GameObject gameplayPanel;

	public GameObject utilityPanel;

	public GameObject nothingPanel;

	public GameObject deleteButton;

	public GameObject deselectButton;

	public TMP_Dropdown colourDropdown;

	public TMP_Dropdown pathDropdown;

	public TMP_Dropdown utilityTypeDropdown;

	public Toggle setToggle;

	public Toggle cascadeToggle;

	public TextMeshProUGUI utilityInfo;

	public TextMeshProUGUI nodeCount;

	public LineRenderer line;

	public Toggle toggle_colour_green;

	public Toggle toggle_colour_pink;

	public Toggle toggle_colour_yellow;

	public Toggle toggle_node_normal;

	public Toggle toggle_node_set;

	public Toggle toggle_node_cascade;

	public Toggle toggle_path_wideLeft;

	public Toggle toggle_path_curveLeft;

	public Toggle toggle_path_center;

	public Toggle toggle_path_curveRight;

	public Toggle toggle_path_wideRight;

	public Toggle toggle_path_default;

	public Image path_wideLeft;

	public Image path_curveLeft;

	public Image path_center;

	public Image path_curveRight;

	public Image path_wideRight;

	public GameObject tooltip;

	public TextMeshProUGUI tooltipText;

	private float tooltipTimer = 2f;

	private SongEditor editor => EditorManager.instance.objectRefrences.songEditor;

	private void Start()
	{
	}

	private void Update()
	{
		if (tooltipTimer > 0f)
		{
			tooltipTimer -= Time.deltaTime;
			if (tooltipTimer <= 0f)
			{
				tooltip.SetActive(value: false);
				tooltipTimer = 0f;
			}
		}
		UpdateLineRenderer();
	}

	public void SetNodeToUtility()
	{
		SetTypeButtons(NodeType.GreenCascadeEnd);
		SetPathButtons("Default");
		SetSetCascadeButtons(set: false, cascade: false);
		isutility = true;
		UpdateNode();
	}

	public void SetNodeToGameplay()
	{
		SetTypeButtons(NodeType.Green);
		SetPathButtons("Default");
		SetSetCascadeButtons(set: false, cascade: false);
		isutility = false;
		UpdateNode();
	}

	public void SwitchToUtility()
	{
		UnityEngine.Debug.Log("Switch to utility");
		gameplayPanel.SetActive(value: false);
		utilityPanel.SetActive(value: true);
		nothingPanel.SetActive(value: false);
		deleteButton.SetActive(value: true);
		isutility = true;
	}

	public void SwitchToGameplay()
	{
		UnityEngine.Debug.Log("Switch to gameplay");
		gameplayPanel.SetActive(value: true);
		utilityPanel.SetActive(value: false);
		nothingPanel.SetActive(value: false);
		deleteButton.SetActive(value: true);
		isutility = false;
	}

	public void SwitchToNothing()
	{
		gameplayPanel.SetActive(value: false);
		utilityPanel.SetActive(value: false);
		nothingPanel.SetActive(value: true);
		deleteButton.SetActive(value: false);
		isutility = false;
	}

	public void SnapToBeat()
	{
		for (int i = 0; i < editor.selectedNodes.Count; i++)
		{
			editor.selectedNodes[i].SnapToNearestBeat();
		}
	}

	public void SnapToHalfBeat()
	{
		for (int i = 0; i < editor.selectedNodes.Count; i++)
		{
			editor.selectedNodes[i].SnapToNearestHalfBeat();
		}
	}

	public void DeleteNode()
	{
		int count = editor.selectedNodes.Count;
		for (int i = 0; i < count; i++)
		{
			SceneEditorNode sceneEditorNode = editor.selectedNodes[0];
			editor.DeselectNode(sceneEditorNode);
			sceneEditorNode.Delete();
		}
		EditorManager.instance.HandsInScrollAreas = 0;
	}

	public void UpdateNode()
	{
		foreach (SceneEditorNode selectedNode in editor.selectedNodes)
		{
			if (isutility)
			{
				switch (utilityTypeDropdown.value)
				{
				case 0:
					selectedNode.type = NodeType.GreenCascadeEnd;
					utilityInfo.text = "Required to signify the end of a green cascade.";
					break;
				case 1:
					selectedNode.type = NodeType.PinkCascadeEnd;
					utilityInfo.text = "Required to signify the end of a pink cascade.";
					break;
				case 2:
					selectedNode.type = NodeType.SetEnd;
					utilityInfo.text = "Used to force a set to end. Used when you want to have one set after another, with no nodes inbetween.";
					break;
				case 3:
					selectedNode.type = NodeType.LeftChannel;
					utilityInfo.text = "Turns on the arrows pointing to the left.";
					break;
				case 4:
					selectedNode.type = NodeType.Midchannel;
					utilityInfo.text = "Turns on the arrows pointing to the center.";
					break;
				case 5:
					selectedNode.type = NodeType.RightChannel;
					utilityInfo.text = "Turns on the arrows pointing to the right.";
					break;
				case 6:
					selectedNode.type = NodeType.TauntStart;
					utilityInfo.text = "Makes the character play a taunt animation";
					break;
				default:
					utilityInfo.text = "";
					break;
				}
			}
			else
			{
				if (toggle_colour_green.isOn)
				{
					selectedNode.type = NodeType.Green;
				}
				else if (toggle_colour_pink.isOn)
				{
					selectedNode.type = NodeType.Pink;
				}
				else if (toggle_colour_yellow.isOn)
				{
					selectedNode.type = NodeType.Yellow;
				}
				if (toggle_node_normal.isOn)
				{
					selectedNode.set = false;
					selectedNode.cascade = false;
				}
				else if (toggle_node_set.isOn)
				{
					selectedNode.set = true;
					selectedNode.cascade = false;
				}
				else if (toggle_node_cascade.isOn)
				{
					selectedNode.set = false;
					selectedNode.cascade = true;
				}
				if (toggle_path_wideLeft.isOn)
				{
					selectedNode.path = "LS_CurveRight";
				}
				else if (toggle_path_curveLeft.isOn)
				{
					selectedNode.path = "curveLeft";
				}
				else if (toggle_path_center.isOn)
				{
					selectedNode.path = "straightLine";
				}
				else if (toggle_path_curveRight.isOn)
				{
					selectedNode.path = "curveRight";
				}
				else if (toggle_path_wideRight.isOn)
				{
					selectedNode.path = "RS_CurveLeft";
				}
				else if (toggle_path_default.isOn)
				{
					selectedNode.path = "Default";
				}
			}
			selectedNode.UpdateValues();
		}
		UpdateUI();
	}

	public void UpdateUI()
	{
		if (editor.selectedNodes.Count > 1)
		{
			line.enabled = true;
			nodeCount.text = editor.selectedNodes.Count + " nodes selected";
			if (CheckIfSameNodeType(editor.selectedNodes))
			{
				SetTypeButtons(editor.selectedNodes[0].type);
			}
			else
			{
				SetToggleValueNoCallback(toggle_colour_green, value: false);
				SetToggleValueNoCallback(toggle_colour_pink, value: false);
				SetToggleValueNoCallback(toggle_colour_yellow, value: false);
				SetDropdownValueNoCallback(utilityTypeDropdown, 7);
			}
			if (CheckIfSameSetCascade(editor.selectedNodes))
			{
				SetSetCascadeButtons(editor.selectedNodes[0].set, editor.selectedNodes[0].cascade);
			}
			else
			{
				SetToggleValueNoCallback(toggle_node_normal, value: false);
				SetToggleValueNoCallback(toggle_node_set, value: false);
				SetToggleValueNoCallback(toggle_node_cascade, value: false);
			}
			if (CheckIfSamePath(editor.selectedNodes))
			{
				SetPathButtons(editor.selectedNodes[0].path);
			}
			else
			{
				SetToggleValueNoCallback(toggle_path_center, value: false);
				SetToggleValueNoCallback(toggle_path_curveLeft, value: false);
				SetToggleValueNoCallback(toggle_path_curveRight, value: false);
				SetToggleValueNoCallback(toggle_path_default, value: false);
				SetToggleValueNoCallback(toggle_path_wideLeft, value: false);
				SetToggleValueNoCallback(toggle_path_wideRight, value: false);
				path_wideLeft.color = new Color(path_wideLeft.color.r, path_wideLeft.color.g, path_wideLeft.color.b, 0.3f);
				path_curveLeft.color = new Color(path_curveLeft.color.r, path_curveLeft.color.g, path_curveLeft.color.b, 0.3f);
				path_center.color = new Color(path_center.color.r, path_center.color.g, path_center.color.b, 0.3f);
				path_curveRight.color = new Color(path_curveRight.color.r, path_curveRight.color.g, path_curveRight.color.b, 0.3f);
				path_wideRight.color = new Color(path_wideRight.color.r, path_wideRight.color.g, path_wideRight.color.b, 0.3f);
			}
			if (CheckIfAllGameplayUtilitySame(editor.selectedNodes))
			{
				if (!IsUtilityType(editor.selectedNodes[editor.selectedNodes.Count - 1].type))
				{
					SwitchToGameplay();
				}
				else
				{
					SwitchToUtility();
				}
			}
			else
			{
				SwitchToGameplay();
			}
		}
		else if (editor.selectedNodes.Count == 1)
		{
			line.enabled = true;
			nodeCount.text = "";
			SetTypeButtons(editor.selectedNodes[0].type);
			SetPathButtons(editor.selectedNodes[0].path);
			SetSetCascadeButtons(editor.selectedNodes[0].set, editor.selectedNodes[0].cascade);
			if (isutility)
			{
				SwitchToUtility();
			}
			else
			{
				SwitchToGameplay();
			}
		}
		else
		{
			line.enabled = false;
			nodeCount.text = "";
			SwitchToNothing();
		}
	}

	private void SetSetCascadeButtons(bool set, bool cascade)
	{
		if (!(set && cascade))
		{
			if (set)
			{
				SetToggleValueNoCallback(toggle_node_normal, value: false);
				SetToggleValueNoCallback(toggle_node_set, value: true);
				SetToggleValueNoCallback(toggle_node_cascade, value: false);
			}
			else if (cascade)
			{
				SetToggleValueNoCallback(toggle_node_normal, value: false);
				SetToggleValueNoCallback(toggle_node_set, value: false);
				SetToggleValueNoCallback(toggle_node_cascade, value: true);
			}
			else
			{
				SetToggleValueNoCallback(toggle_node_normal, value: true);
				SetToggleValueNoCallback(toggle_node_set, value: false);
				SetToggleValueNoCallback(toggle_node_cascade, value: false);
			}
			toggle_colour_yellow.interactable = !(set || cascade);
		}
	}

	private void SetPathButtons(string path)
	{
		SetToggleValueNoCallback(toggle_path_default, path == "Default");
		SetToggleValueNoCallback(toggle_path_wideLeft, path == "LS_CurveRight");
		SetToggleValueNoCallback(toggle_path_curveLeft, path == "curveLeft");
		SetToggleValueNoCallback(toggle_path_center, path == "straightLine");
		SetToggleValueNoCallback(toggle_path_curveRight, path == "curveRight");
		SetToggleValueNoCallback(toggle_path_wideRight, path == "RS_CurveLeft");
		path_wideLeft.color = new Color(path_wideLeft.color.r, path_wideLeft.color.g, path_wideLeft.color.b, (path == "LS_CurveRight") ? 1f : 0.3f);
		path_curveLeft.color = new Color(path_curveLeft.color.r, path_curveLeft.color.g, path_curveLeft.color.b, (path == "curveLeft" || path == "Default") ? 1f : 0.3f);
		path_center.color = new Color(path_center.color.r, path_center.color.g, path_center.color.b, (path == "straightLine") ? 1f : 0.3f);
		path_curveRight.color = new Color(path_curveRight.color.r, path_curveRight.color.g, path_curveRight.color.b, (path == "curveRight" || path == "Default") ? 1f : 0.3f);
		path_wideRight.color = new Color(path_wideRight.color.r, path_wideRight.color.g, path_wideRight.color.b, (path == "RS_CurveLeft") ? 1f : 0.3f);
	}

	private void SetTypeButtons(NodeType type)
	{
		switch (type)
		{
		case NodeType.Green:
			SetToggleValueNoCallback(toggle_colour_green, value: true);
			SetToggleValueNoCallback(toggle_colour_pink, value: false);
			SetToggleValueNoCallback(toggle_colour_yellow, value: false);
			isutility = false;
			break;
		case NodeType.Pink:
			SetToggleValueNoCallback(toggle_colour_green, value: false);
			SetToggleValueNoCallback(toggle_colour_pink, value: true);
			SetToggleValueNoCallback(toggle_colour_yellow, value: false);
			isutility = false;
			break;
		case NodeType.Yellow:
			SetToggleValueNoCallback(toggle_colour_green, value: false);
			SetToggleValueNoCallback(toggle_colour_pink, value: false);
			SetToggleValueNoCallback(toggle_colour_yellow, value: true);
			isutility = false;
			break;
		case NodeType.GreenCascadeEnd:
			SetDropdownValueNoCallback(utilityTypeDropdown, 0);
			SetToggleValueNoCallback(toggle_colour_green, value: false);
			SetToggleValueNoCallback(toggle_colour_pink, value: false);
			SetToggleValueNoCallback(toggle_colour_yellow, value: false);
			isutility = true;
			break;
		case NodeType.PinkCascadeEnd:
			SetDropdownValueNoCallback(utilityTypeDropdown, 1);
			SetToggleValueNoCallback(toggle_colour_green, value: false);
			SetToggleValueNoCallback(toggle_colour_pink, value: false);
			SetToggleValueNoCallback(toggle_colour_yellow, value: false);
			isutility = true;
			break;
		case NodeType.SetEnd:
			SetDropdownValueNoCallback(utilityTypeDropdown, 2);
			SetToggleValueNoCallback(toggle_colour_green, value: false);
			SetToggleValueNoCallback(toggle_colour_pink, value: false);
			SetToggleValueNoCallback(toggle_colour_yellow, value: false);
			isutility = true;
			break;
		case NodeType.LeftChannel:
			SetDropdownValueNoCallback(utilityTypeDropdown, 3);
			SetToggleValueNoCallback(toggle_colour_green, value: false);
			SetToggleValueNoCallback(toggle_colour_pink, value: false);
			SetToggleValueNoCallback(toggle_colour_yellow, value: false);
			isutility = true;
			break;
		case NodeType.Midchannel:
			SetDropdownValueNoCallback(utilityTypeDropdown, 4);
			SetToggleValueNoCallback(toggle_colour_green, value: false);
			SetToggleValueNoCallback(toggle_colour_pink, value: false);
			SetToggleValueNoCallback(toggle_colour_yellow, value: false);
			isutility = true;
			break;
		case NodeType.RightChannel:
			SetDropdownValueNoCallback(utilityTypeDropdown, 5);
			SetToggleValueNoCallback(toggle_colour_green, value: false);
			SetToggleValueNoCallback(toggle_colour_pink, value: false);
			SetToggleValueNoCallback(toggle_colour_yellow, value: false);
			isutility = true;
			break;
		case NodeType.TauntStart:
			SetDropdownValueNoCallback(utilityTypeDropdown, 6);
			SetToggleValueNoCallback(toggle_colour_green, value: false);
			SetToggleValueNoCallback(toggle_colour_pink, value: false);
			SetToggleValueNoCallback(toggle_colour_yellow, value: false);
			isutility = true;
			break;
		}
		toggle_node_set.interactable = type != NodeType.Yellow;
		toggle_node_cascade.interactable = type != NodeType.Yellow;
	}

	public void UpdateLineRenderer()
	{
		if (editor.selectedNodes == null)
		{
			return;
		}
		if (editor.selectedNodes.Count == 1)
		{
			line.positionCount = 2;
			line.SetPosition(0, line.transform.position);
			line.SetPosition(1, editor.selectedNodes[0].transform.position);
		}
		else if (editor.selectedNodes.Count > 0)
		{
			line.positionCount = editor.selectedNodes.Count + 2;
			Vector3[] array = new Vector3[editor.selectedNodes.Count + 2];
			array[0] = line.transform.position;
			for (int i = 0; i < editor.selectedNodes.Count; i++)
			{
				array[i + 1] = editor.selectedNodes[i].transform.position;
			}
			array[array.Length - 1] = line.transform.position;
			line.SetPositions(array);
		}
	}

	public bool CheckIfSameNodeType(List<SceneEditorNode> nodes)
	{
		NodeType baseType = nodes[0].type;
		return nodes.All((SceneEditorNode n) => n.type == baseType);
	}

	public bool CheckIfAllGameplayUtilitySame(List<SceneEditorNode> nodes)
	{
		bool baseGameplay = IsUtilityType(nodes[0].type);
		return nodes.All((SceneEditorNode n) => IsUtilityType(n.type) == baseGameplay);
	}

	public bool CheckIfSamePath(List<SceneEditorNode> nodes)
	{
		string basePath = nodes[0].path;
		return nodes.All((SceneEditorNode n) => n.path == basePath);
	}

	public bool CheckIfSameSetCascade(List<SceneEditorNode> nodes)
	{
		bool baseSet = nodes[0].set;
		bool num = nodes.All((SceneEditorNode s) => s.set == baseSet);
		bool baseCascade = nodes[0].cascade;
		bool flag = nodes.All((SceneEditorNode c) => c.cascade == baseCascade);
		return num && flag;
	}

	public static bool IsUtilityType(NodeType type)
	{
		if (type != 0 && type != NodeType.Pink)
		{
			return type != NodeType.Yellow;
		}
		return false;
	}

	public void SetDropdownValueNoCallback(TMP_Dropdown dropdown, int value)
	{
		dropdown.onValueChanged.SetPersistentListenerState(0, UnityEventCallState.Off);
		dropdown.value = value;
		dropdown.onValueChanged.SetPersistentListenerState(0, UnityEventCallState.RuntimeOnly);
	}

	public void SetToggleValueNoCallback(Toggle toggle, bool value)
	{
		toggle.onValueChanged.SetPersistentListenerState(0, UnityEventCallState.Off);
		toggle.isOn = value;
		toggle.onValueChanged.SetPersistentListenerState(0, UnityEventCallState.RuntimeOnly);
	}

	public void ShowTooltip(string tip)
	{
		tooltip.SetActive(value: true);
		tooltipText.text = tip;
		tooltipTimer = 2f;
	}
}
public class UI_SongEditor_Keyboard : MonoBehaviour
{
	public TMP_InputField inputField;

	public bool shift;

	public List<Button> buttons;

	public LineRenderer line;

	private void Start()
	{
		for (int i = 0; i < buttons.Count; i++)
		{
			buttons[i].interactable = false;
		}
	}

	private void Update()
	{
		if (inputField != null)
		{
			line.SetPosition(0, line.transform.position);
			line.SetPosition(1, inputField.transform.position);
		}
		else
		{
			line.enabled = false;
		}
	}

	public void ClickKey(string character)
	{
		CheckForInput();
		if (!(inputField == null))
		{
			if (shift)
			{
				inputField.text += character.ToUpper();
			}
			else
			{
				inputField.text += character.ToLower();
			}
		}
	}

	public void Backspace()
	{
		CheckForInput();
		if (!(inputField == null) && inputField.text.Length > 0)
		{
			inputField.text = inputField.text.Substring(0, inputField.text.Length - 1);
		}
	}

	public void Shift()
	{
		shift = !shift;
		foreach (Button button in buttons)
		{
			TextMeshProUGUI componentInChildren = button.GetComponentInChildren<TextMeshProUGUI>();
			if (shift)
			{
				componentInChildren.text = componentInChildren.text.ToUpper();
			}
			else
			{
				componentInChildren.text = componentInChildren.text.ToLower();
			}
		}
	}

	public void CheckForInput()
	{
		if (EventSystem.current.currentSelectedGameObject == null)
		{
			UnityEngine.Debug.Log("Nothing is selected yet");
			ToggleButtons(toggle: false);
			line.enabled = false;
		}
		else if (EventSystem.current.currentSelectedGameObject.GetComponent<TMP_InputField>() != null)
		{
			inputField = EventSystem.current.currentSelectedGameObject.GetComponent<TMP_InputField>();
			UnityEngine.Debug.Log("Valid Keyboard Input", this);
			ToggleButtons(toggle: true);
			line.enabled = true;
		}
		else
		{
			UnityEngine.Debug.Log("Invalid Keyboard Input: " + EventSystem.current.currentSelectedGameObject.name, EventSystem.current.currentSelectedGameObject);
		}
	}

	private void ToggleButtons(bool toggle)
	{
		for (int i = 0; i < buttons.Count; i++)
		{
			buttons[i].interactable = toggle;
		}
	}
}
public class UI_Uriel_Progress : MonoBehaviour
{
	[Serializable]
	public struct NewsStory
	{
		public float threshold;

		[Multiline(2)]
		public string title;

		[Multiline(2)]
		public string subtitle;

		public VideoClip clip;
	}

	public bool _update;

	public float value;

	public float targetValue;

	public float speed;

	public float speedIncrease;

	private float speedValue;

	public Image progressBar;

	public TextMeshProUGUI progressText;

	public List<Image> baseImages;

	public List<Image> highlightImages;

	public Image icon_info;

	public Image icon_warn;

	public Image icon_skull;

	public Image bar_background;

	public Color colour_info_base;

	public Color colour_info_highlight;

	public Color colour_warn_base;

	public Color colour_warn_highlight;

	public Color colour_skull_base;

	public Color colour_skull_highlight;

	public TextMeshProUGUI title;

	public TextMeshProUGUI subtitle;

	public string info_title;

	public string info_subtitle;

	public string warn_title;

	public string warn_subtitle;

	public string skull_title;

	public string skull_subtitle;

	public TextMeshProUGUI news_title;

	public TextMeshProUGUI news_subtitle;

	public VideoPlayer videoPlayer;

	public List<NewsStory> newsStories;

	public void Init(float startValue, float endValue)
	{
		value = startValue;
		targetValue = endValue;
		speedValue = speed;
		if (startValue < 0.2f)
		{
			SetInfo();
		}
		else if (startValue <= 0.6f)
		{
			SetWarn();
		}
		else
		{
			SetSkull();
		}
		for (int i = 0; i < newsStories.Count; i++)
		{
			NewsStory newsStory = newsStories.OrderByDescending((NewsStory x) => x.threshold).ToList()[i];
			if (newsStory.threshold <= startValue)
			{
				news_title.text = newsStory.title;
				news_subtitle.text = newsStory.subtitle;
				videoPlayer.Stop();
				videoPlayer.clip = newsStory.clip;
				videoPlayer.Play();
				break;
			}
		}
	}

	private void Update()
	{
		progressBar.fillAmount = value;
		progressText.text = value.ToString("P1");
		if (_update && value < targetValue)
		{
			value += speedValue * Time.deltaTime;
			speedValue += speedIncrease * Time.deltaTime;
			if (value >= targetValue)
			{
				value = targetValue;
				_update = false;
			}
		}
	}

	private void SetColours(Color _base, Color _highlight)
	{
		foreach (Image baseImage in baseImages)
		{
			baseImage.color = _base;
		}
		foreach (Image highlightImage in highlightImages)
		{
			highlightImage.color = _highlight;
		}
		bar_background.color = new Color(_base.r, _base.g, _base.b, 0.15f);
	}

	public void SetInfo()
	{
		SetColours(colour_info_base, colour_info_highlight);
		icon_info.gameObject.SetActive(value: true);
		icon_warn.gameObject.SetActive(value: false);
		icon_skull.gameObject.SetActive(value: false);
		title.text = info_title;
		subtitle.text = info_subtitle;
	}

	public void SetWarn()
	{
		SetColours(colour_warn_base, colour_warn_highlight);
		icon_info.gameObject.SetActive(value: false);
		icon_warn.gameObject.SetActive(value: true);
		icon_skull.gameObject.SetActive(value: false);
		title.text = warn_title;
		subtitle.text = warn_subtitle;
	}

	public void SetSkull()
	{
		SetColours(colour_skull_base, colour_skull_highlight);
		icon_info.gameObject.SetActive(value: false);
		icon_warn.gameObject.SetActive(value: false);
		icon_skull.gameObject.SetActive(value: true);
		title.text = skull_title;
		subtitle.text = skull_subtitle;
	}

	public void StartUpdate()
	{
		_update = true;
	}
}
public class UrielAnimationEvent : MonoBehaviour
{
	public UI_Uriel_Progress progressbar;

	public AudioClip audio1;

	public AudioClip audio2;

	public AudioClip audio3;

	public void ProgressBarStart()
	{
		progressbar.StartUpdate();
	}

	public void StartAnimation()
	{
		GetComponent<Animator>().SetTrigger("Restart");
	}

	public void PlayAudio1()
	{
		GetComponent<AudioSource>().clip = audio1;
		GetComponent<AudioSource>().Play();
	}

	public void PlayAudio2()
	{
		GetComponent<AudioSource>().clip = audio2;
		GetComponent<AudioSource>().Play();
	}

	public void PlayAudio3()
	{
		GetComponent<AudioSource>().clip = audio3;
		GetComponent<AudioSource>().Play();
	}
}
public class Uriel_Countdown : MonoBehaviour
{
	public TextMeshProUGUI timerText;

	public float countdownTime;

	private float timer;

	private void Start()
	{
		timer = countdownTime;
	}

	private void Update()
	{
		if (timer > 0f)
		{
			timer -= Time.deltaTime * 0.8f;
			timerText.text = timer.ToString("F0");
			if (timer <= 0f)
			{
				UnityEngine.Debug.Log("Load Uriel");
				GameManager.instance.Load_UrielLobby();
				timer = 0f;
				timerText.text = "...";
			}
		}
	}
}
public class DynamicBoneDemo1 : MonoBehaviour
{
	public GameObject m_Player;

	private void Update()
	{
		m_Player.transform.Rotate(new Vector3(0f, Input.GetAxis("Horizontal") * Time.deltaTime * 200f, 0f));
		m_Player.transform.Translate(base.transform.forward * Input.GetAxis("Vertical") * Time.deltaTime * 4f);
	}

	private void OnGUI()
	{
		GUI.Label(new Rect(50f, 50f, 200f, 20f), "Press arrow key to move");
		Animation componentInChildren = m_Player.GetComponentInChildren<Animation>();
		componentInChildren.enabled = GUI.Toggle(new Rect(50f, 70f, 200f, 20f), componentInChildren.enabled, "Play Animation");
		DynamicBone[] components = m_Player.GetComponents<DynamicBone>();
		GUI.Label(new Rect(50f, 100f, 200f, 20f), "Choose dynamic bone:");
		DynamicBone obj = components[0];
		bool flag2 = (components[1].enabled = GUI.Toggle(new Rect(50f, 120f, 100f, 20f), components[0].enabled, "Breasts"));
		obj.enabled = flag2;
		components[2].enabled = GUI.Toggle(new Rect(50f, 140f, 100f, 20f), components[2].enabled, "Tail");
	}
}
[AddComponentMenu("Dynamic Bone/Dynamic Bone")]
public class DynamicBone : MonoBehaviour
{
	public enum UpdateMode
	{
		Normal,
		AnimatePhysics,
		UnscaledTime
	}

	public enum FreezeAxis
	{
		None,
		X,
		Y,
		Z
	}

	private class Particle
	{
		public Transform m_Transform;

		public int m_ParentIndex = -1;

		public float m_Damping;

		public float m_Elasticity;

		public float m_Stiffness;

		public float m_Inert;

		public float m_Radius;

		public float m_BoneLength;

		public Vector3 m_Position = Vector3.zero;

		public Vector3 m_PrevPosition = Vector3.zero;

		public Vector3 m_EndOffset = Vector3.zero;

		public Vector3 m_InitLocalPosition = Vector3.zero;

		public Quaternion m_InitLocalRotation = Quaternion.identity;
	}

	public Transform m_Root;

	public float m_UpdateRate = 60f;

	public UpdateMode m_UpdateMode;

	[Range(0f, 1f)]
	public float m_Damping = 0.1f;

	public AnimationCurve m_DampingDistrib;

	[Range(0f, 1f)]
	public float m_Elasticity = 0.1f;

	public AnimationCurve m_ElasticityDistrib;

	[Range(0f, 1f)]
	public float m_Stiffness = 0.1f;

	public AnimationCurve m_StiffnessDistrib;

	[Range(0f, 1f)]
	public float m_Inert;

	public AnimationCurve m_InertDistrib;

	public float m_Radius;

	public AnimationCurve m_RadiusDistrib;

	public float m_EndLength;

	public Vector3 m_EndOffset = Vector3.zero;

	public Vector3 m_Gravity = Vector3.zero;

	public Vector3 m_Force = Vector3.zero;

	public List<DynamicBoneColliderBase> m_Colliders;

	public List<Transform> m_Exclusions;

	public FreezeAxis m_FreezeAxis;

	public bool m_DistantDisable;

	public Transform m_ReferenceObject;

	public float m_DistanceToObject = 20f;

	private Vector3 m_LocalGravity = Vector3.zero;

	private Vector3 m_ObjectMove = Vector3.zero;

	private Vector3 m_ObjectPrevPosition = Vector3.zero;

	private float m_BoneTotalLength;

	private float m_ObjectScale = 1f;

	private float m_Time;

	private float m_Weight = 1f;

	private bool m_DistantDisabled;

	private List<Particle> m_Particles = new List<Particle>();

	private void Start()
	{
		SetupParticles();
	}

	private void FixedUpdate()
	{
		if (m_UpdateMode == UpdateMode.AnimatePhysics)
		{
			PreUpdate();
		}
	}

	private void Update()
	{
		if (m_UpdateMode != UpdateMode.AnimatePhysics)
		{
			PreUpdate();
		}
	}

	private void LateUpdate()
	{
		if (m_DistantDisable)
		{
			CheckDistance();
		}
		if (m_Weight > 0f && (!m_DistantDisable || !m_DistantDisabled))
		{
			float deltaTime = Time.deltaTime;
			UpdateDynamicBones(deltaTime);
		}
	}

	private void PreUpdate()
	{
		if (m_Weight > 0f && (!m_DistantDisable || !m_DistantDisabled))
		{
			InitTransforms();
		}
	}

	private void CheckDistance()
	{
		Transform referenceObject = m_ReferenceObject;
		if (referenceObject == null && Camera.main != null)
		{
			referenceObject = Camera.main.transform;
		}
		if (!(referenceObject != null))
		{
			return;
		}
		bool flag = (referenceObject.position - base.transform.position).sqrMagnitude > m_DistanceToObject * m_DistanceToObject;
		if (flag != m_DistantDisabled)
		{
			if (!flag)
			{
				ResetParticlesPosition();
			}
			m_DistantDisabled = flag;
		}
	}

	private void OnEnable()
	{
		ResetParticlesPosition();
	}

	private void OnDisable()
	{
		InitTransforms();
	}

	private void OnValidate()
	{
		m_UpdateRate = Mathf.Max(m_UpdateRate, 0f);
		m_Damping = Mathf.Clamp01(m_Damping);
		m_Elasticity = Mathf.Clamp01(m_Elasticity);
		m_Stiffness = Mathf.Clamp01(m_Stiffness);
		m_Inert = Mathf.Clamp01(m_Inert);
		m_Radius = Mathf.Max(m_Radius, 0f);
		if (UnityEngine.Application.isEditor && UnityEngine.Application.isPlaying)
		{
			InitTransforms();
			SetupParticles();
		}
	}

	private void OnDrawGizmosSelected()
	{
		if (!base.enabled || m_Root == null)
		{
			return;
		}
		if (UnityEngine.Application.isEditor && !UnityEngine.Application.isPlaying && base.transform.hasChanged)
		{
			InitTransforms();
			SetupParticles();
		}
		Gizmos.color = Color.white;
		for (int i = 0; i < m_Particles.Count; i++)
		{
			Particle particle = m_Particles[i];
			if (particle.m_ParentIndex >= 0)
			{
				Particle particle2 = m_Particles[particle.m_ParentIndex];
				Gizmos.DrawLine(particle.m_Position, particle2.m_Position);
			}
			if (particle.m_Radius > 0f)
			{
				Gizmos.DrawWireSphere(particle.m_Position, particle.m_Radius * m_ObjectScale);
			}
		}
	}

	public void SetWeight(float w)
	{
		if (m_Weight != w)
		{
			if (w == 0f)
			{
				InitTransforms();
			}
			else if (m_Weight == 0f)
			{
				ResetParticlesPosition();
			}
			m_Weight = w;
		}
	}

	public float GetWeight()
	{
		return m_Weight;
	}

	private void UpdateDynamicBones(float t)
	{
		if (m_Root == null)
		{
			return;
		}
		m_ObjectScale = Mathf.Abs(base.transform.lossyScale.x);
		m_ObjectMove = base.transform.position - m_ObjectPrevPosition;
		m_ObjectPrevPosition = base.transform.position;
		int num = 1;
		if (m_UpdateRate > 0f)
		{
			float num2 = 1f / m_UpdateRate;
			m_Time += t;
			num = 0;
			while (m_Time >= num2)
			{
				m_Time -= num2;
				if (++num >= 3)
				{
					m_Time = 0f;
					break;
				}
			}
		}
		if (num > 0)
		{
			for (int i = 0; i < num; i++)
			{
				UpdateParticles1();
				UpdateParticles2();
				m_ObjectMove = Vector3.zero;
			}
		}
		else
		{
			SkipUpdateParticles();
		}
		ApplyParticlesToTransforms();
	}

	private void SetupParticles()
	{
		m_Particles.Clear();
		if (!(m_Root == null))
		{
			m_LocalGravity = m_Root.InverseTransformDirection(m_Gravity);
			m_ObjectScale = Mathf.Abs(base.transform.lossyScale.x);
			m_ObjectPrevPosition = base.transform.position;
			m_ObjectMove = Vector3.zero;
			m_BoneTotalLength = 0f;
			AppendParticles(m_Root, -1, 0f);
			UpdateParameters();
		}
	}

	private void AppendParticles(Transform b, int parentIndex, float boneLength)
	{
		Particle particle = new Particle();
		particle.m_Transform = b;
		particle.m_ParentIndex = parentIndex;
		if (b != null)
		{
			particle.m_Position = (particle.m_PrevPosition = b.position);
			particle.m_InitLocalPosition = b.localPosition;
			particle.m_InitLocalRotation = b.localRotation;
		}
		else
		{
			Transform transform = m_Particles[parentIndex].m_Transform;
			if (m_EndLength > 0f)
			{
				Transform parent = transform.parent;
				if (parent != null)
				{
					particle.m_EndOffset = transform.InverseTransformPoint(transform.position * 2f - parent.position) * m_EndLength;
				}
				else
				{
					particle.m_EndOffset = new Vector3(m_EndLength, 0f, 0f);
				}
			}
			else
			{
				particle.m_EndOffset = transform.InverseTransformPoint(base.transform.TransformDirection(m_EndOffset) + transform.position);
			}
			particle.m_Position = (particle.m_PrevPosition = transform.TransformPoint(particle.m_EndOffset));
		}
		if (parentIndex >= 0)
		{
			boneLength += (m_Particles[parentIndex].m_Transform.position - particle.m_Position).magnitude;
			particle.m_BoneLength = boneLength;
			m_BoneTotalLength = Mathf.Max(m_BoneTotalLength, boneLength);
		}
		int count = m_Particles.Count;
		m_Particles.Add(particle);
		if (!(b != null))
		{
			return;
		}
		for (int i = 0; i < b.childCount; i++)
		{
			bool flag = false;
			if (m_Exclusions != null)
			{
				for (int j = 0; j < m_Exclusions.Count; j++)
				{
					if (m_Exclusions[j] == b.GetChild(i))
					{
						flag = true;
						break;
					}
				}
			}
			if (!flag)
			{
				AppendParticles(b.GetChild(i), count, boneLength);
			}
			else if (m_EndLength > 0f || m_EndOffset != Vector3.zero)
			{
				AppendParticles(null, count, boneLength);
			}
		}
		if (b.childCount == 0 && (m_EndLength > 0f || m_EndOffset != Vector3.zero))
		{
			AppendParticles(null, count, boneLength);
		}
	}

	public void UpdateParameters()
	{
		if (m_Root == null)
		{
			return;
		}
		m_LocalGravity = m_Root.InverseTransformDirection(m_Gravity);
		for (int i = 0; i < m_Particles.Count; i++)
		{
			Particle particle = m_Particles[i];
			particle.m_Damping = m_Damping;
			particle.m_Elasticity = m_Elasticity;
			particle.m_Stiffness = m_Stiffness;
			particle.m_Inert = m_Inert;
			particle.m_Radius = m_Radius;
			if (m_BoneTotalLength > 0f)
			{
				float time = particle.m_BoneLength / m_BoneTotalLength;
				if (m_DampingDistrib != null && m_DampingDistrib.keys.Length != 0)
				{
					particle.m_Damping *= m_DampingDistrib.Evaluate(time);
				}
				if (m_ElasticityDistrib != null && m_ElasticityDistrib.keys.Length != 0)
				{
					particle.m_Elasticity *= m_ElasticityDistrib.Evaluate(time);
				}
				if (m_StiffnessDistrib != null && m_StiffnessDistrib.keys.Length != 0)
				{
					particle.m_Stiffness *= m_StiffnessDistrib.Evaluate(time);
				}
				if (m_InertDistrib != null && m_InertDistrib.keys.Length != 0)
				{
					particle.m_Inert *= m_InertDistrib.Evaluate(time);
				}
				if (m_RadiusDistrib != null && m_RadiusDistrib.keys.Length != 0)
				{
					particle.m_Radius *= m_RadiusDistrib.Evaluate(time);
				}
			}
			particle.m_Damping = Mathf.Clamp01(particle.m_Damping);
			particle.m_Elasticity = Mathf.Clamp01(particle.m_Elasticity);
			particle.m_Stiffness = Mathf.Clamp01(particle.m_Stiffness);
			particle.m_Inert = Mathf.Clamp01(particle.m_Inert);
			particle.m_Radius = Mathf.Max(particle.m_Radius, 0f);
		}
	}

	private void InitTransforms()
	{
		for (int i = 0; i < m_Particles.Count; i++)
		{
			Particle particle = m_Particles[i];
			if (particle.m_Transform != null)
			{
				particle.m_Transform.localPosition = particle.m_InitLocalPosition;
				particle.m_Transform.localRotation = particle.m_InitLocalRotation;
			}
		}
	}

	private void ResetParticlesPosition()
	{
		for (int i = 0; i < m_Particles.Count; i++)
		{
			Particle particle = m_Particles[i];
			if (particle.m_Transform != null)
			{
				particle.m_Position = (particle.m_PrevPosition = particle.m_Transform.position);
				continue;
			}
			Transform transform = m_Particles[particle.m_ParentIndex].m_Transform;
			particle.m_Position = (particle.m_PrevPosition = transform.TransformPoint(particle.m_EndOffset));
		}
		m_ObjectPrevPosition = base.transform.position;
	}

	private void UpdateParticles1()
	{
		Vector3 gravity = m_Gravity;
		Vector3 normalized = m_Gravity.normalized;
		Vector3 lhs = m_Root.TransformDirection(m_LocalGravity);
		Vector3 vector = normalized * Mathf.Max(Vector3.Dot(lhs, normalized), 0f);
		gravity -= vector;
		gravity = (gravity + m_Force) * m_ObjectScale;
		for (int i = 0; i < m_Particles.Count; i++)
		{
			Particle particle = m_Particles[i];
			if (particle.m_ParentIndex >= 0)
			{
				Vector3 vector2 = particle.m_Position - particle.m_PrevPosition;
				Vector3 vector3 = m_ObjectMove * particle.m_Inert;
				particle.m_PrevPosition = particle.m_Position + vector3;
				particle.m_Position += vector2 * (1f - particle.m_Damping) + gravity + vector3;
			}
			else
			{
				particle.m_PrevPosition = particle.m_Position;
				particle.m_Position = particle.m_Transform.position;
			}
		}
	}

	private void UpdateParticles2()
	{
		Plane plane = default(Plane);
		for (int i = 1; i < m_Particles.Count; i++)
		{
			Particle particle = m_Particles[i];
			Particle particle2 = m_Particles[particle.m_ParentIndex];
			float num = ((!(particle.m_Transform != null)) ? particle2.m_Transform.localToWorldMatrix.MultiplyVector(particle.m_EndOffset).magnitude : (particle2.m_Transform.position - particle.m_Transform.position).magnitude);
			float num2 = Mathf.Lerp(1f, particle.m_Stiffness, m_Weight);
			if (num2 > 0f || particle.m_Elasticity > 0f)
			{
				Matrix4x4 localToWorldMatrix = particle2.m_Transform.localToWorldMatrix;
				localToWorldMatrix.SetColumn(3, particle2.m_Position);
				Vector3 vector = ((!(particle.m_Transform != null)) ? localToWorldMatrix.MultiplyPoint3x4(particle.m_EndOffset) : localToWorldMatrix.MultiplyPoint3x4(particle.m_Transform.localPosition));
				Vector3 vector2 = vector - particle.m_Position;
				particle.m_Position += vector2 * particle.m_Elasticity;
				if (num2 > 0f)
				{
					vector2 = vector - particle.m_Position;
					float magnitude = vector2.magnitude;
					float num3 = num * (1f - num2) * 2f;
					if (magnitude > num3)
					{
						particle.m_Position += vector2 * ((magnitude - num3) / magnitude);
					}
				}
			}
			if (m_Colliders != null)
			{
				float particleRadius = particle.m_Radius * m_ObjectScale;
				for (int j = 0; j < m_Colliders.Count; j++)
				{
					DynamicBoneColliderBase dynamicBoneColliderBase = m_Colliders[j];
					if (dynamicBoneColliderBase != null && dynamicBoneColliderBase.enabled)
					{
						dynamicBoneColliderBase.Collide(ref particle.m_Position, particleRadius);
					}
				}
			}
			if (m_FreezeAxis != 0)
			{
				switch (m_FreezeAxis)
				{
				case FreezeAxis.X:
					plane.SetNormalAndPosition(particle2.m_Transform.right, particle2.m_Position);
					break;
				case FreezeAxis.Y:
					plane.SetNormalAndPosition(particle2.m_Transform.up, particle2.m_Position);
					break;
				case FreezeAxis.Z:
					plane.SetNormalAndPosition(particle2.m_Transform.forward, particle2.m_Position);
					break;
				}
				particle.m_Position -= plane.normal * plane.GetDistanceToPoint(particle.m_Position);
			}
			Vector3 vector3 = particle2.m_Position - particle.m_Position;
			float magnitude2 = vector3.magnitude;
			if (magnitude2 > 0f)
			{
				particle.m_Position += vector3 * ((magnitude2 - num) / magnitude2);
			}
		}
	}

	private void SkipUpdateParticles()
	{
		for (int i = 0; i < m_Particles.Count; i++)
		{
			Particle particle = m_Particles[i];
			if (particle.m_ParentIndex >= 0)
			{
				particle.m_PrevPosition += m_ObjectMove;
				particle.m_Position += m_ObjectMove;
				Particle particle2 = m_Particles[particle.m_ParentIndex];
				float num = ((!(particle.m_Transform != null)) ? particle2.m_Transform.localToWorldMatrix.MultiplyVector(particle.m_EndOffset).magnitude : (particle2.m_Transform.position - particle.m_Transform.position).magnitude);
				float num2 = Mathf.Lerp(1f, particle.m_Stiffness, m_Weight);
				if (num2 > 0f)
				{
					Matrix4x4 localToWorldMatrix = particle2.m_Transform.localToWorldMatrix;
					localToWorldMatrix.SetColumn(3, particle2.m_Position);
					Vector3 vector = ((!(particle.m_Transform != null)) ? localToWorldMatrix.MultiplyPoint3x4(particle.m_EndOffset) : localToWorldMatrix.MultiplyPoint3x4(particle.m_Transform.localPosition));
					Vector3 vector2 = vector - particle.m_Position;
					float magnitude = vector2.magnitude;
					float num3 = num * (1f - num2) * 2f;
					if (magnitude > num3)
					{
						particle.m_Position += vector2 * ((magnitude - num3) / magnitude);
					}
				}
				Vector3 vector3 = particle2.m_Position - particle.m_Position;
				float magnitude2 = vector3.magnitude;
				if (magnitude2 > 0f)
				{
					particle.m_Position += vector3 * ((magnitude2 - num) / magnitude2);
				}
			}
			else
			{
				particle.m_PrevPosition = particle.m_Position;
				particle.m_Position = particle.m_Transform.position;
			}
		}
	}

	private static Vector3 MirrorVector(Vector3 v, Vector3 axis)
	{
		return v - axis * (Vector3.Dot(v, axis) * 2f);
	}

	private void ApplyParticlesToTransforms()
	{
		for (int i = 1; i < m_Particles.Count; i++)
		{
			Particle particle = m_Particles[i];
			Particle particle2 = m_Particles[particle.m_ParentIndex];
			if (particle2.m_Transform.childCount <= 1)
			{
				Vector3 direction = ((!(particle.m_Transform != null)) ? particle.m_EndOffset : particle.m_Transform.localPosition);
				Vector3 toDirection = particle.m_Position - particle2.m_Position;
				Quaternion quaternion = Quaternion.FromToRotation(particle2.m_Transform.TransformDirection(direction), toDirection);
				particle2.m_Transform.rotation = quaternion * particle2.m_Transform.rotation;
			}
			if (particle.m_Transform != null)
			{
				particle.m_Transform.position = particle.m_Position;
			}
		}
	}
}
[AddComponentMenu("Dynamic Bone/Dynamic Bone Collider")]
public class DynamicBoneCollider : DynamicBoneColliderBase
{
	public float m_Radius = 0.5f;

	public float m_Height;

	private void OnValidate()
	{
		m_Radius = Mathf.Max(m_Radius, 0f);
		m_Height = Mathf.Max(m_Height, 0f);
	}

	public override void Collide(ref Vector3 particlePosition, float particleRadius)
	{
		float num = m_Radius * Mathf.Abs(base.transform.lossyScale.x);
		float num2 = m_Height * 0.5f - m_Radius;
		if (num2 <= 0f)
		{
			if (m_Bound == Bound.Outside)
			{
				OutsideSphere(ref particlePosition, particleRadius, base.transform.TransformPoint(m_Center), num);
			}
			else
			{
				InsideSphere(ref particlePosition, particleRadius, base.transform.TransformPoint(m_Center), num);
			}
			return;
		}
		Vector3 center = m_Center;
		Vector3 center2 = m_Center;
		switch (m_Direction)
		{
		case Direction.X:
			center.x -= num2;
			center2.x += num2;
			break;
		case Direction.Y:
			center.y -= num2;
			center2.y += num2;
			break;
		case Direction.Z:
			center.z -= num2;
			center2.z += num2;
			break;
		}
		if (m_Bound == Bound.Outside)
		{
			OutsideCapsule(ref particlePosition, particleRadius, base.transform.TransformPoint(center), base.transform.TransformPoint(center2), num);
		}
		else
		{
			InsideCapsule(ref particlePosition, particleRadius, base.transform.TransformPoint(center), base.transform.TransformPoint(center2), num);
		}
	}

	private static void OutsideSphere(ref Vector3 particlePosition, float particleRadius, Vector3 sphereCenter, float sphereRadius)
	{
		float num = sphereRadius + particleRadius;
		float num2 = num * num;
		Vector3 vector = particlePosition - sphereCenter;
		float sqrMagnitude = vector.sqrMagnitude;
		if (sqrMagnitude > 0f && sqrMagnitude < num2)
		{
			float num3 = Mathf.Sqrt(sqrMagnitude);
			particlePosition = sphereCenter + vector * (num / num3);
		}
	}

	private static void InsideSphere(ref Vector3 particlePosition, float particleRadius, Vector3 sphereCenter, float sphereRadius)
	{
		float num = sphereRadius - particleRadius;
		float num2 = num * num;
		Vector3 vector = particlePosition - sphereCenter;
		float sqrMagnitude = vector.sqrMagnitude;
		if (sqrMagnitude > num2)
		{
			float num3 = Mathf.Sqrt(sqrMagnitude);
			particlePosition = sphereCenter + vector * (num / num3);
		}
	}

	private static void OutsideCapsule(ref Vector3 particlePosition, float particleRadius, Vector3 capsuleP0, Vector3 capsuleP1, float capsuleRadius)
	{
		float num = capsuleRadius + particleRadius;
		float num2 = num * num;
		Vector3 vector = capsuleP1 - capsuleP0;
		Vector3 vector2 = particlePosition - capsuleP0;
		float num3 = Vector3.Dot(vector2, vector);
		if (num3 <= 0f)
		{
			float sqrMagnitude = vector2.sqrMagnitude;
			if (sqrMagnitude > 0f && sqrMagnitude < num2)
			{
				float num4 = Mathf.Sqrt(sqrMagnitude);
				particlePosition = capsuleP0 + vector2 * (num / num4);
			}
			return;
		}
		float sqrMagnitude2 = vector.sqrMagnitude;
		if (num3 >= sqrMagnitude2)
		{
			vector2 = particlePosition - capsuleP1;
			float sqrMagnitude3 = vector2.sqrMagnitude;
			if (sqrMagnitude3 > 0f && sqrMagnitude3 < num2)
			{
				float num5 = Mathf.Sqrt(sqrMagnitude3);
				particlePosition = capsuleP1 + vector2 * (num / num5);
			}
		}
		else if (sqrMagnitude2 > 0f)
		{
			num3 /= sqrMagnitude2;
			vector2 -= vector * num3;
			float sqrMagnitude4 = vector2.sqrMagnitude;
			if (sqrMagnitude4 > 0f && sqrMagnitude4 < num2)
			{
				float num6 = Mathf.Sqrt(sqrMagnitude4);
				particlePosition += vector2 * ((num - num6) / num6);
			}
		}
	}

	private static void InsideCapsule(ref Vector3 particlePosition, float particleRadius, Vector3 capsuleP0, Vector3 capsuleP1, float capsuleRadius)
	{
		float num = capsuleRadius - particleRadius;
		float num2 = num * num;
		Vector3 vector = capsuleP1 - capsuleP0;
		Vector3 vector2 = particlePosition - capsuleP0;
		float num3 = Vector3.Dot(vector2, vector);
		if (num3 <= 0f)
		{
			float sqrMagnitude = vector2.sqrMagnitude;
			if (sqrMagnitude > num2)
			{
				float num4 = Mathf.Sqrt(sqrMagnitude);
				particlePosition = capsuleP0 + vector2 * (num / num4);
			}
			return;
		}
		float sqrMagnitude2 = vector.sqrMagnitude;
		if (num3 >= sqrMagnitude2)
		{
			vector2 = particlePosition - capsuleP1;
			float sqrMagnitude3 = vector2.sqrMagnitude;
			if (sqrMagnitude3 > num2)
			{
				float num5 = Mathf.Sqrt(sqrMagnitude3);
				particlePosition = capsuleP1 + vector2 * (num / num5);
			}
		}
		else if (sqrMagnitude2 > 0f)
		{
			num3 /= sqrMagnitude2;
			vector2 -= vector * num3;
			float sqrMagnitude4 = vector2.sqrMagnitude;
			if (sqrMagnitude4 > num2)
			{
				float num6 = Mathf.Sqrt(sqrMagnitude4);
				particlePosition += vector2 * ((num - num6) / num6);
			}
		}
	}

	private void OnDrawGizmosSelected()
	{
		if (!base.enabled)
		{
			return;
		}
		if (m_Bound == Bound.Outside)
		{
			Gizmos.color = Color.yellow;
		}
		else
		{
			Gizmos.color = Color.magenta;
		}
		float radius = m_Radius * Mathf.Abs(base.transform.lossyScale.x);
		float num = m_Height * 0.5f - m_Radius;
		if (num <= 0f)
		{
			Gizmos.DrawWireSphere(base.transform.TransformPoint(m_Center), radius);
			return;
		}
		Vector3 center = m_Center;
		Vector3 center2 = m_Center;
		switch (m_Direction)
		{
		case Direction.X:
			center.x -= num;
			center2.x += num;
			break;
		case Direction.Y:
			center.y -= num;
			center2.y += num;
			break;
		case Direction.Z:
			center.z -= num;
			center2.z += num;
			break;
		}
		Gizmos.DrawWireSphere(base.transform.TransformPoint(center), radius);
		Gizmos.DrawWireSphere(base.transform.TransformPoint(center2), radius);
	}
}
public class DynamicBoneColliderBase : MonoBehaviour
{
	public enum Direction
	{
		X,
		Y,
		Z
	}

	public enum Bound
	{
		Outside,
		Inside
	}

	public Direction m_Direction = Direction.Y;

	public Vector3 m_Center = Vector3.zero;

	public Bound m_Bound;

	public virtual void Collide(ref Vector3 particlePosition, float particleRadius)
	{
	}
}
[AddComponentMenu("Dynamic Bone/Dynamic Bone Plane Collider")]
public class DynamicBonePlaneCollider : DynamicBoneColliderBase
{
	private void OnValidate()
	{
	}

	public override void Collide(ref Vector3 particlePosition, float particleRadius)
	{
		Vector3 vector = Vector3.up;
		switch (m_Direction)
		{
		case Direction.X:
			vector = base.transform.right;
			break;
		case Direction.Y:
			vector = base.transform.up;
			break;
		case Direction.Z:
			vector = base.transform.forward;
			break;
		}
		Vector3 inPoint = base.transform.TransformPoint(m_Center);
		float distanceToPoint = new Plane(vector, inPoint).GetDistanceToPoint(particlePosition);
		if (m_Bound == Bound.Outside)
		{
			if (distanceToPoint < 0f)
			{
				particlePosition -= vector * distanceToPoint;
			}
		}
		else if (distanceToPoint > 0f)
		{
			particlePosition -= vector * distanceToPoint;
		}
	}

	private void OnDrawGizmosSelected()
	{
		if (base.enabled)
		{
			if (m_Bound == Bound.Outside)
			{
				Gizmos.color = Color.yellow;
			}
			else
			{
				Gizmos.color = Color.magenta;
			}
			Vector3 vector = Vector3.up;
			switch (m_Direction)
			{
			case Direction.X:
				vector = base.transform.right;
				break;
			case Direction.Y:
				vector = base.transform.up;
				break;
			case Direction.Z:
				vector = base.transform.forward;
				break;
			}
			Vector3 vector2 = base.transform.TransformPoint(m_Center);
			Gizmos.DrawLine(vector2, vector2 + vector);
		}
	}
}
public class DecalDestroyer : MonoBehaviour
{
	public float lifeTime = 5f;

	private IEnumerator Start()
	{
		yield return new WaitForSeconds(lifeTime);
		UnityEngine.Object.Destroy(base.gameObject);
	}
}
public class ExtinguishableFire : MonoBehaviour
{
	public ParticleSystem fireParticleSystem;

	public ParticleSystem smokeParticleSystem;

	protected bool m_isExtinguished;

	private const float m_FireStartingTime = 2f;

	private void Start()
	{
		m_isExtinguished = true;
		smokeParticleSystem.Stop();
		fireParticleSystem.Stop();
		StartCoroutine(StartingFire());
	}

	public void Extinguish()
	{
		if (!m_isExtinguished)
		{
			m_isExtinguished = true;
			StartCoroutine(Extinguishing());
		}
	}

	private IEnumerator Extinguishing()
	{
		fireParticleSystem.Stop();
		smokeParticleSystem.time = 0f;
		smokeParticleSystem.Play();
		for (float elapsedTime = 0f; elapsedTime < 2f; elapsedTime += Time.deltaTime)
		{
			float num = Mathf.Max(0f, 1f - elapsedTime / 2f);
			fireParticleSystem.transform.localScale = Vector3.one * num;
			yield return null;
		}
		yield return new WaitForSeconds(2f);
		smokeParticleSystem.Stop();
		fireParticleSystem.transform.localScale = Vector3.one;
		yield return new WaitForSeconds(4f);
		StartCoroutine(StartingFire());
	}

	private IEnumerator StartingFire()
	{
		smokeParticleSystem.Stop();
		fireParticleSystem.time = 0f;
		fireParticleSystem.Play();
		for (float elapsedTime = 0f; elapsedTime < 2f; elapsedTime += Time.deltaTime)
		{
			float num = Mathf.Min(1f, elapsedTime / 2f);
			fireParticleSystem.transform.localScale = Vector3.one * num;
			yield return null;
		}
		fireParticleSystem.transform.localScale = Vector3.one;
		m_isExtinguished = false;
	}
}
public class GunAim : MonoBehaviour
{
	public int borderLeft;

	public int borderRight;

	public int borderTop;

	public int borderBottom;

	private Camera parentCamera;

	private bool isOutOfBounds;

	private void Start()
	{
		parentCamera = GetComponentInParent<Camera>();
	}

	private void Update()
	{
		float x = Input.mousePosition.x;
		float y = Input.mousePosition.y;
		if (x <= (float)borderLeft || x >= (float)(Screen.width - borderRight) || y <= (float)borderBottom || y >= (float)(Screen.height - borderTop))
		{
			isOutOfBounds = true;
		}
		else
		{
			isOutOfBounds = false;
		}
		if (!isOutOfBounds)
		{
			base.transform.LookAt(parentCamera.ScreenToWorldPoint(new Vector3(x, y, 5f)));
		}
	}

	public bool GetIsOutOfBounds()
	{
		return isOutOfBounds;
	}
}
public class GunShoot : MonoBehaviour
{
	public float fireRate = 0.25f;

	public float weaponRange = 20f;

	public Transform gunEnd;

	public ParticleSystem muzzleFlash;

	public ParticleSystem cartridgeEjection;

	public GameObject metalHitEffect;

	public GameObject sandHitEffect;

	public GameObject stoneHitEffect;

	public GameObject waterLeakEffect;

	public GameObject waterLeakExtinguishEffect;

	public GameObject[] fleshHitEffects;

	public GameObject woodHitEffect;

	private float nextFire;

	private Animator anim;

	private GunAim gunAim;

	private void Start()
	{
		anim = GetComponent<Animator>();
		gunAim = GetComponentInParent<GunAim>();
	}

	private void Update()
	{
		if (Input.GetButtonDown("Fire1") && Time.time > nextFire && !gunAim.GetIsOutOfBounds())
		{
			nextFire = Time.time + fireRate;
			muzzleFlash.Play();
			cartridgeEjection.Play();
			anim.SetTrigger("Fire");
			if (Physics.Raycast(gunEnd.position, gunEnd.forward, out var hitInfo, weaponRange))
			{
				HandleHit(hitInfo);
			}
		}
	}

	private void HandleHit(RaycastHit hit)
	{
		if (!(hit.collider.sharedMaterial != null))
		{
			return;
		}
		string text = hit.collider.sharedMaterial.name;
		if (text != null)
		{
			switch (text)
			{
			case "Metal":
				SpawnDecal(hit, metalHitEffect);
				break;
			case "Sand":
				SpawnDecal(hit, sandHitEffect);
				break;
			case "Stone":
				SpawnDecal(hit, stoneHitEffect);
				break;
			case "WaterFilled":
				SpawnDecal(hit, waterLeakEffect);
				SpawnDecal(hit, metalHitEffect);
				break;
			case "Wood":
				SpawnDecal(hit, woodHitEffect);
				break;
			case "Meat":
				SpawnDecal(hit, fleshHitEffects[UnityEngine.Random.Range(0, fleshHitEffects.Length)]);
				break;
			case "Character":
				SpawnDecal(hit, fleshHitEffects[UnityEngine.Random.Range(0, fleshHitEffects.Length)]);
				break;
			case "WaterFilledExtinguish":
				SpawnDecal(hit, waterLeakExtinguishEffect);
				SpawnDecal(hit, metalHitEffect);
				break;
			}
		}
	}

	private void SpawnDecal(RaycastHit hit, GameObject prefab)
	{
		UnityEngine.Object.Instantiate(prefab, hit.point, Quaternion.LookRotation(hit.normal)).transform.SetParent(hit.collider.transform);
	}
}
public class ParticleCollision : MonoBehaviour
{
	private List<ParticleCollisionEvent> m_CollisionEvents = new List<ParticleCollisionEvent>();

	private ParticleSystem m_ParticleSystem;

	private void Start()
	{
		m_ParticleSystem = GetComponent<ParticleSystem>();
	}

	private void OnParticleCollision(GameObject other)
	{
		int collisionEvents = m_ParticleSystem.GetCollisionEvents(other, m_CollisionEvents);
		for (int i = 0; i < collisionEvents; i++)
		{
			ExtinguishableFire component = m_CollisionEvents[i].colliderComponent.GetComponent<ExtinguishableFire>();
			if (component != null)
			{
				component.Extinguish();
			}
		}
	}
}
[Serializable]
public class ParticleExamples
{
	public string title;

	[TextArea]
	public string description;

	public bool isWeaponEffect;

	public GameObject particleSystemGO;

	public Vector3 particlePosition;

	public Vector3 particleRotation;
}
public class ParticleMenu : MonoBehaviour
{
	public ParticleExamples[] particleSystems;

	public GameObject gunGameObject;

	private int currentIndex;

	private GameObject currentGO;

	public Transform spawnLocation;

	public Text title;

	public Text description;

	public Text navigationDetails;

	private void Start()
	{
		Navigate(0);
		currentIndex = 0;
	}

	public void Navigate(int i)
	{
		currentIndex = (particleSystems.Length + currentIndex + i) % particleSystems.Length;
		if (currentGO != null)
		{
			UnityEngine.Object.Destroy(currentGO);
		}
		currentGO = UnityEngine.Object.Instantiate(particleSystems[currentIndex].particleSystemGO, spawnLocation.position + particleSystems[currentIndex].particlePosition, Quaternion.Euler(particleSystems[currentIndex].particleRotation));
		gunGameObject.SetActive(particleSystems[currentIndex].isWeaponEffect);
		title.text = particleSystems[currentIndex].title;
		description.text = particleSystems[currentIndex].description;
		navigationDetails.text = currentIndex + 1 + " out of " + particleSystems.Length;
	}
}
public class ButtonScript : MonoBehaviour
{
	public GameObject Button;

	private Text MyButtonText;

	private string projectileParticleName;

	private FireProjectile effectScript;

	private ProjectileScript projectileScript;

	public float buttonsX;

	public float buttonsY;

	public float buttonsSizeX;

	public float buttonsSizeY;

	public float buttonsDistance;

	private void Start()
	{
		effectScript = GameObject.Find("FireProjectile").GetComponent<FireProjectile>();
		getProjectileNames();
		MyButtonText = Button.transform.Find("Text").GetComponent<Text>();
		MyButtonText.text = projectileParticleName;
	}

	private void Update()
	{
		MyButtonText.text = projectileParticleName;
	}

	public void getProjectileNames()
	{
		projectileScript = effectScript.projectiles[effectScript.currentProjectile].GetComponent<ProjectileScript>();
		projectileParticleName = projectileScript.projectileParticle.name;
	}

	public bool overButton()
	{
		Rect rect = new Rect(buttonsX, buttonsY, buttonsSizeX, buttonsSizeY);
		Rect rect2 = new Rect(buttonsX + buttonsDistance, buttonsY, buttonsSizeX, buttonsSizeY);
		if (rect.Contains(new Vector2(Input.mousePosition.x, (float)Screen.height - Input.mousePosition.y)) || rect2.Contains(new Vector2(Input.mousePosition.x, (float)Screen.height - Input.mousePosition.y)))
		{
			return true;
		}
		return false;
	}

	public void LoadStage1()
	{
		SceneManager.LoadScene("magic_projectiles");
	}

	public void LoadStage2()
	{
		SceneManager.LoadScene("magic_sprays");
	}

	public void LoadStage3()
	{
		SceneManager.LoadScene("magic_aura");
	}

	public void LoadStage4()
	{
		SceneManager.LoadScene("magic_modular");
	}

	public void LoadStage5()
	{
		SceneManager.LoadScene("magic_domes");
	}

	public void LoadStage6()
	{
		SceneManager.LoadScene("magic_shields");
	}

	public void LoadStage7()
	{
		SceneManager.LoadScene("magic_sphereblast");
	}
}
[AddComponentMenu("Camera-Control/Mouse drag Orbit with zoom")]
public class DragMouseOrbit : MonoBehaviour
{
	public Transform target;

	public float distance = 5f;

	public float xSpeed = 120f;

	public float ySpeed = 120f;

	public float yMinLimit = -20f;

	public float yMaxLimit = 80f;

	public float distanceMin = 0.5f;

	public float distanceMax = 15f;

	public float smoothTime = 2f;

	private float rotationYAxis;

	private float rotationXAxis;

	private float velocityX;

	private float velocityY;

	private void Start()
	{
		Vector3 eulerAngles = base.transform.eulerAngles;
		rotationYAxis = eulerAngles.y;
		rotationXAxis = eulerAngles.x;
		if ((bool)GetComponent<Rigidbody>())
		{
			GetComponent<Rigidbody>().freezeRotation = true;
		}
	}

	private void LateUpdate()
	{
		if ((bool)target)
		{
			if (Input.GetMouseButton(1))
			{
				velocityX += xSpeed * Input.GetAxis("Mouse X") * distance * 0.02f;
				velocityY += ySpeed * Input.GetAxis("Mouse Y") * 0.02f;
			}
			rotationYAxis += velocityX;
			rotationXAxis -= velocityY;
			rotationXAxis = ClampAngle(rotationXAxis, yMinLimit, yMaxLimit);
			Quaternion quaternion = Quaternion.Euler(rotationXAxis, rotationYAxis, 0f);
			distance = Mathf.Clamp(distance - Input.GetAxis("Mouse ScrollWheel") * 5f, distanceMin, distanceMax);
			if (Physics.Linecast(target.position, base.transform.position, out var hitInfo))
			{
				distance -= hitInfo.distance;
			}
			Vector3 vector = new Vector3(0f, 0f, 0f - distance);
			Vector3 position = quaternion * vector + target.position;
			base.transform.rotation = quaternion;
			base.transform.position = position;
			velocityX = Mathf.Lerp(velocityX, 0f, Time.deltaTime * smoothTime);
			velocityY = Mathf.Lerp(velocityY, 0f, Time.deltaTime * smoothTime);
		}
	}

	public static float ClampAngle(float angle, float min, float max)
	{
		if (angle < -360f)
		{
			angle += 360f;
		}
		if (angle > 360f)
		{
			angle -= 360f;
		}
		return Mathf.Clamp(angle, min, max);
	}
}
public class FireProjectile : MonoBehaviour
{
	private RaycastHit hit;

	public GameObject[] projectiles;

	public Transform spawnPosition;

	[HideInInspector]
	public int currentProjectile;

	public float speed = 1000f;

	private ButtonScript selectedProjectileButton;

	private void Start()
	{
		selectedProjectileButton = GameObject.Find("Button").GetComponent<ButtonScript>();
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.RightArrow))
		{
			nextEffect();
			selectedProjectileButton.getProjectileNames();
		}
		if (Input.GetKeyDown(KeyCode.D))
		{
			nextEffect();
			selectedProjectileButton.getProjectileNames();
		}
		if (Input.GetKeyDown(KeyCode.A))
		{
			previousEffect();
			selectedProjectileButton.getProjectileNames();
		}
		else if (Input.GetKeyDown(KeyCode.LeftArrow))
		{
			previousEffect();
			selectedProjectileButton.getProjectileNames();
		}
		if (Input.GetKeyDown(KeyCode.Mouse0) && !selectedProjectileButton.overButton() && Physics.Raycast(Camera.main.ScreenPointToRay(Input.mousePosition), out hit, 100f))
		{
			GameObject gameObject = UnityEngine.Object.Instantiate(projectiles[currentProjectile], spawnPosition.position, Quaternion.identity);
			gameObject.transform.LookAt(hit.point);
			gameObject.GetComponent<Rigidbody>().AddForce(gameObject.transform.forward * speed);
			gameObject.GetComponent<ProjectileScript>().impactNormal = hit.normal;
		}
		UnityEngine.Debug.DrawRay(Camera.main.ScreenPointToRay(Input.mousePosition).origin, Camera.main.ScreenPointToRay(Input.mousePosition).direction * 100f, Color.yellow);
	}

	public void nextEffect()
	{
		if (currentProjectile < projectiles.Length - 1)
		{
			currentProjectile++;
		}
		else
		{
			currentProjectile = 0;
		}
	}

	public void previousEffect()
	{
		if (currentProjectile > 0)
		{
			currentProjectile--;
		}
		else
		{
			currentProjectile = projectiles.Length - 1;
		}
	}

	public void AdjustSpeed(float newSpeed)
	{
		speed = newSpeed;
	}
}
public class LoadSceneOnClick : MonoBehaviour
{
	public void CollectionFlamethrower()
	{
		SceneManager.LoadScene("CollectionFlamethrower");
	}

	public void CollectionFull()
	{
		SceneManager.LoadScene("CollectionFull");
	}

	public void CollectionMissiles()
	{
		SceneManager.LoadScene("CollectionMissiles");
	}

	public void CollectionSmall()
	{
		SceneManager.LoadScene("CollectionSmall");
	}

	public void FX1Fire()
	{
		SceneManager.LoadScene("FX1Fire");
	}

	public void FX1FireFull()
	{
		SceneManager.LoadScene("FX1FireFull");
	}

	public void FX1Flamethrower()
	{
		SceneManager.LoadScene("FX1Flamethrower");
	}

	public void FX1Missiles()
	{
		SceneManager.LoadScene("FX1Missiles");
	}

	public void FX2Fire()
	{
		SceneManager.LoadScene("FX2Fire");
	}

	public void FX2FireFull()
	{
		SceneManager.LoadScene("FX2FireFull");
	}

	public void FX2Flamethrower()
	{
		SceneManager.LoadScene("FX2Flamethrower");
	}

	public void FX2Missiles()
	{
		SceneManager.LoadScene("FX2Missiles");
	}
}
public class Projectile : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
	}
}
public class ProjectileScript : MonoBehaviour
{
	public GameObject impactParticle;

	public GameObject projectileParticle;

	public GameObject[] trailParticles;

	[HideInInspector]
	public Vector3 impactNormal;

	private void Start()
	{
		projectileParticle = UnityEngine.Object.Instantiate(projectileParticle, base.transform.position, base.transform.rotation);
		projectileParticle.transform.parent = base.transform;
	}

	private void OnCollisionEnter(Collision hit)
	{
		impactParticle = UnityEngine.Object.Instantiate(impactParticle, base.transform.position, Quaternion.FromToRotation(Vector3.up, impactNormal));
		if (hit.gameObject.tag == "Destructible")
		{
			UnityEngine.Object.Destroy(hit.gameObject);
		}
		GameObject[] array = trailParticles;
		foreach (GameObject gameObject in array)
		{
			GameObject obj = base.transform.Find(projectileParticle.name + "/" + gameObject.name).gameObject;
			obj.transform.parent = null;
			UnityEngine.Object.Destroy(obj, 3f);
		}
		UnityEngine.Object.Destroy(projectileParticle, 3f);
		UnityEngine.Object.Destroy(impactParticle, 5f);
		UnityEngine.Object.Destroy(base.gameObject);
	}
}
public class lightScript : MonoBehaviour
{
	private bool Impact;

	public float Sqr;

	private void Start()
	{
		Impact = true;
		base.gameObject.GetComponent<Light>().intensity = 7f;
		Sqr = base.gameObject.GetComponent<Light>().intensity * base.gameObject.GetComponent<Light>().intensity * ((base.gameObject.GetComponent<Light>().intensity < 0f) ? (-1f) : 1f);
	}

	private void Update()
	{
		if (Impact)
		{
			base.gameObject.GetComponent<Light>().intensity -= 1f / Time.deltaTime * Sqr * 0.0001f;
			if (base.gameObject.GetComponent<Light>().intensity <= 0f)
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
		}
	}
}
public class loopScript : MonoBehaviour
{
	public GameObject chosenEffect;

	public float loopTimeLimit = 2f;

	private void Start()
	{
		PlayEffect();
	}

	public void PlayEffect()
	{
		StartCoroutine("EffectLoop");
	}

	private IEnumerator EffectLoop()
	{
		GameObject effectPlayer = UnityEngine.Object.Instantiate(chosenEffect, base.transform.position, base.transform.rotation);
		yield return new WaitForSeconds(loopTimeLimit);
		UnityEngine.Object.Destroy(effectPlayer);
		PlayEffect();
	}
}
public class ZE_MagicSphereDemoGUI : MonoBehaviour
{
	public struct HSBColor
	{
		public float h;

		public float s;

		public float b;

		public float a;

		public HSBColor(float h, float s, float b, float a)
		{
			this.h = h;
			this.s = s;
			this.b = b;
			this.a = a;
		}
	}

	public GameObject[] Prefabs;

	public Texture HUETexture;

	private int currentNomber;

	private GameObject currentInstance;

	private GUIStyle guiStyleHeader = new GUIStyle();

	private float oldIntensity;

	private Color oldAmbientColor;

	private float dpiScale;

	private bool isDay;

	private float colorHUE;

	private void Start()
	{
		if (Screen.dpi < 1f)
		{
			dpiScale = 1f;
		}
		if (Screen.dpi < 200f)
		{
			dpiScale = 1f;
		}
		else
		{
			dpiScale = Screen.dpi / 200f;
		}
		guiStyleHeader.fontSize = (int)(15f * dpiScale);
		guiStyleHeader.normal.textColor = new Color(0.15f, 0.15f, 0.15f);
		ChangeCurrent(0);
	}

	private void OnGUI()
	{
		if (GUI.Button(new Rect(10f * dpiScale, 15f * dpiScale, 135f * dpiScale, 37f * dpiScale), "PREVIOUS EFFECT"))
		{
			ChangeCurrent(-1);
		}
		if (GUI.Button(new Rect(160f * dpiScale, 15f * dpiScale, 135f * dpiScale, 37f * dpiScale), "NEXT EFFECT"))
		{
			ChangeCurrent(1);
		}
		GUI.DrawTexture(new Rect(12f * dpiScale, 60f * dpiScale, 285f * dpiScale, 15f * dpiScale), HUETexture, ScaleMode.StretchToFill, alphaBlend: false, 0f);
		float num = colorHUE;
		colorHUE = GUI.HorizontalSlider(new Rect(12f * dpiScale, 80f * dpiScale, 285f * dpiScale, 15f * dpiScale), colorHUE, 0f, 360f);
		if ((double)Mathf.Abs(num - colorHUE) > 0.001)
		{
			ChangeColor();
		}
	}

	private void ChangeCurrent(int delta)
	{
		currentNomber += delta;
		if (currentNomber > Prefabs.Length - 1)
		{
			currentNomber = 0;
		}
		else if (currentNomber < 0)
		{
			currentNomber = Prefabs.Length - 1;
		}
		if (currentInstance != null)
		{
			UnityEngine.Object.Destroy(currentInstance);
		}
		currentInstance = UnityEngine.Object.Instantiate(Prefabs[currentNomber], base.transform.position, base.transform.rotation);
		CancelInvoke();
	}

	private void Reactivate()
	{
		currentInstance.SetActive(value: false);
		currentInstance.SetActive(value: true);
	}

	private Color Hue(float H)
	{
		Color result = new Color(1f, 0f, 0f);
		if (H >= 0f && H < 1f)
		{
			result = new Color(1f, 0f, H);
		}
		if (H >= 1f && H < 2f)
		{
			result = new Color(2f - H, 0f, 1f);
		}
		if (H >= 2f && H < 3f)
		{
			result = new Color(0f, H - 2f, 1f);
		}
		if (H >= 3f && H < 4f)
		{
			result = new Color(0f, 1f, 4f - H);
		}
		if (H >= 4f && H < 5f)
		{
			result = new Color(H - 4f, 1f, 0f);
		}
		if (H >= 5f && H < 6f)
		{
			result = new Color(1f, 6f - H, 0f);
		}
		return result;
	}

	public HSBColor ColorToHSV(Color color)
	{
		HSBColor result = new HSBColor(0f, 0f, 0f, color.a);
		float r = color.r;
		float g = color.g;
		float b = color.b;
		float num = Mathf.Max(r, Mathf.Max(g, b));
		if (num <= 0f)
		{
			return result;
		}
		float num2 = Mathf.Min(r, Mathf.Min(g, b));
		float num3 = num - num2;
		if (num > num2)
		{
			if (g == num)
			{
				result.h = (b - r) / num3 * 60f + 120f;
			}
			else if (b == num)
			{
				result.h = (r - g) / num3 * 60f + 240f;
			}
			else if (b > g)
			{
				result.h = (g - b) / num3 * 60f + 360f;
			}
			else
			{
				result.h = (g - b) / num3 * 60f;
			}
			if (result.h < 0f)
			{
				result.h += 360f;
			}
		}
		else
		{
			result.h = 0f;
		}
		result.h *= 0.0027777778f;
		result.s = num3 / num * 1f;
		result.b = num;
		return result;
	}

	public Color HSVToColor(HSBColor hsbColor)
	{
		float value = hsbColor.b;
		float value2 = hsbColor.b;
		float value3 = hsbColor.b;
		if (hsbColor.s != 0f)
		{
			float b = hsbColor.b;
			float num = hsbColor.b * hsbColor.s;
			float num2 = hsbColor.b - num;
			float num3 = hsbColor.h * 360f;
			if (num3 < 60f)
			{
				value = b;
				value2 = num3 * num / 60f + num2;
				value3 = num2;
			}
			else if (num3 < 120f)
			{
				value = (0f - (num3 - 120f)) * num / 60f + num2;
				value2 = b;
				value3 = num2;
			}
			else if (num3 < 180f)
			{
				value = num2;
				value2 = b;
				value3 = (num3 - 120f) * num / 60f + num2;
			}
			else if (num3 < 240f)
			{
				value = num2;
				value2 = (0f - (num3 - 240f)) * num / 60f + num2;
				value3 = b;
			}
			else if (num3 < 300f)
			{
				value = (num3 - 240f) * num / 60f + num2;
				value2 = num2;
				value3 = b;
			}
			else if (num3 <= 360f)
			{
				value = b;
				value2 = num2;
				value3 = (0f - (num3 - 360f)) * num / 60f + num2;
			}
			else
			{
				value = 0f;
				value2 = 0f;
				value3 = 0f;
			}
		}
		return new Color(Mathf.Clamp01(value), Mathf.Clamp01(value2), Mathf.Clamp01(value3), hsbColor.a);
	}

	private Material SetMatHUEColor(Material mat, string name, float hueColor)
	{
		Color color = mat.GetColor(name);
		float num = color.maxColorComponent;
		if (num < 0.0001f)
		{
			num = 0.0001f;
		}
		HSBColor hsbColor = ColorToHSV(color / num);
		hsbColor.h = hueColor / 360f;
		Color value = HSVToColor(hsbColor) * num;
		value.a = color.a;
		mat.SetColor(name, value);
		return mat;
	}

	private void ChangeColor()
	{
		Renderer[] componentsInChildren = currentInstance.GetComponentsInChildren<Renderer>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			Material material = componentsInChildren[i].material;
			if (!(material == null))
			{
				if (material.HasProperty("_TintColor"))
				{
					SetMatHUEColor(material, "_TintColor", colorHUE);
				}
				if (material.HasProperty("_CoreColor"))
				{
					SetMatHUEColor(material, "_CoreColor", colorHUE);
				}
				if (material.HasProperty("_MainColor"))
				{
					SetMatHUEColor(material, "_MainColor", colorHUE);
				}
				if (material.HasProperty("_RimColor"))
				{
					SetMatHUEColor(material, "_RimColor", colorHUE);
				}
			}
		}
		Projector[] componentsInChildren2 = currentInstance.GetComponentsInChildren<Projector>();
		foreach (Projector projector in componentsInChildren2)
		{
			Material material2 = projector.material;
			if (!(material2 == null) && material2.HasProperty("_TintColor"))
			{
				projector.material = SetMatHUEColor(material2, "_TintColor", colorHUE);
			}
		}
		Light componentInChildren = currentInstance.GetComponentInChildren<Light>(includeInactive: true);
		if (componentInChildren != null)
		{
			HSBColor hsbColor = ColorToHSV(componentInChildren.color);
			hsbColor.h = colorHUE / 360f;
			componentInChildren.color = HSVToColor(hsbColor);
		}
	}
}
internal class ZE_UVTextureAnimator : MonoBehaviour
{
	public Material[] AnimatedMaterialsNotInstance;

	public int Rows = 4;

	public int Columns = 4;

	public float Fps = 20f;

	public int OffsetMat;

	public Vector2 SelfTiling;

	public bool IsLoop = true;

	public bool IsReverse;

	public bool IsRandomOffsetForInctance;

	public bool IsBump;

	public bool IsHeight;

	public bool IsCutOut;

	private bool isInizialised;

	private int index;

	private int count;

	private int allCount;

	private float deltaFps;

	private bool isVisible;

	private bool isCorutineStarted;

	private Renderer currentRenderer;

	private Material instanceMaterial;

	private void Start()
	{
		InitMaterial();
		InitDefaultVariables();
		isInizialised = true;
		isVisible = true;
		StartCoroutine(UpdateCorutine());
	}

	public void SetInstanceMaterial(Material mat, Vector2 offsetMat)
	{
		instanceMaterial = mat;
		InitDefaultVariables();
	}

	private void InitDefaultVariables()
	{
		allCount = 0;
		deltaFps = 1f / Fps;
		count = Rows * Columns;
		index = Columns - 1;
		Vector2 value = new Vector2((float)index / (float)Columns - (float)(index / Columns), 1f - (float)(index / Columns) / (float)Rows);
		OffsetMat = ((!IsRandomOffsetForInctance) ? (OffsetMat - OffsetMat / count * count) : UnityEngine.Random.Range(0, count));
		Vector2 value2 = ((SelfTiling == Vector2.zero) ? new Vector2(1f / (float)Columns, 1f / (float)Rows) : SelfTiling);
		if (AnimatedMaterialsNotInstance.Length != 0)
		{
			Material[] animatedMaterialsNotInstance = AnimatedMaterialsNotInstance;
			foreach (Material material in animatedMaterialsNotInstance)
			{
				material.SetTextureScale("_MainTex", value2);
				material.SetTextureOffset("_MainTex", Vector2.zero);
				if (IsBump)
				{
					material.SetTextureScale("_BumpMap", value2);
					material.SetTextureOffset("_BumpMap", Vector2.zero);
				}
				if (IsHeight)
				{
					material.SetTextureScale("_HeightMap", value2);
					material.SetTextureOffset("_HeightMap", Vector2.zero);
				}
				if (IsCutOut)
				{
					material.SetTextureScale("_CutOut", value2);
					material.SetTextureOffset("_CutOut", Vector2.zero);
				}
			}
		}
		else if (instanceMaterial != null)
		{
			instanceMaterial.SetTextureScale("_MainTex", value2);
			instanceMaterial.SetTextureOffset("_MainTex", value);
			if (IsBump)
			{
				instanceMaterial.SetTextureScale("_BumpMap", value2);
				instanceMaterial.SetTextureOffset("_BumpMap", value);
			}
			if (IsBump)
			{
				instanceMaterial.SetTextureScale("_HeightMap", value2);
				instanceMaterial.SetTextureOffset("_HeightMap", value);
			}
			if (IsCutOut)
			{
				instanceMaterial.SetTextureScale("_CutOut", value2);
				instanceMaterial.SetTextureOffset("_CutOut", value);
			}
		}
		else if (currentRenderer != null)
		{
			currentRenderer.material.SetTextureScale("_MainTex", value2);
			currentRenderer.material.SetTextureOffset("_MainTex", value);
			if (IsBump)
			{
				currentRenderer.material.SetTextureScale("_BumpMap", value2);
				currentRenderer.material.SetTextureOffset("_BumpMap", value);
			}
			if (IsHeight)
			{
				currentRenderer.material.SetTextureScale("_HeightMap", value2);
				currentRenderer.material.SetTextureOffset("_HeightMap", value);
			}
			if (IsCutOut)
			{
				currentRenderer.material.SetTextureScale("_CutOut", value2);
				currentRenderer.material.SetTextureOffset("_CutOut", value);
			}
		}
	}

	private void InitMaterial()
	{
		if (GetComponent<Renderer>() != null)
		{
			currentRenderer = GetComponent<Renderer>();
			return;
		}
		Projector component = GetComponent<Projector>();
		if (component != null)
		{
			if (!component.material.name.EndsWith("(Instance)"))
			{
				component.material = new Material(component.material)
				{
					name = component.material.name + " (Instance)"
				};
			}
			instanceMaterial = component.material;
		}
	}

	private void OnEnable()
	{
		if (isInizialised)
		{
			InitDefaultVariables();
			isVisible = true;
			if (!isCorutineStarted)
			{
				StartCoroutine(UpdateCorutine());
			}
		}
	}

	private void OnDisable()
	{
		isCorutineStarted = false;
		isVisible = false;
		StopAllCoroutines();
	}

	private void OnBecameVisible()
	{
		isVisible = true;
		if (!isCorutineStarted)
		{
			StartCoroutine(UpdateCorutine());
		}
	}

	private void OnBecameInvisible()
	{
		isVisible = false;
	}

	private IEnumerator UpdateCorutine()
	{
		isCorutineStarted = true;
		while (isVisible && (IsLoop || allCount != count))
		{
			UpdateCorutineFrame();
			if (!IsLoop && allCount == count)
			{
				break;
			}
			yield return new WaitForSeconds(deltaFps);
		}
		isCorutineStarted = false;
	}

	private void UpdateCorutineFrame()
	{
		if (currentRenderer == null && instanceMaterial == null && AnimatedMaterialsNotInstance.Length == 0)
		{
			return;
		}
		allCount++;
		if (IsReverse)
		{
			index--;
		}
		else
		{
			index++;
		}
		if (index >= count)
		{
			index = 0;
		}
		if (AnimatedMaterialsNotInstance.Length != 0)
		{
			for (int i = 0; i < AnimatedMaterialsNotInstance.Length; i++)
			{
				int num = i * OffsetMat + index + OffsetMat;
				num -= num / count * count;
				Vector2 value = new Vector2((float)num / (float)Columns - (float)(num / Columns), 1f - (float)(num / Columns) / (float)Rows);
				AnimatedMaterialsNotInstance[i].SetTextureOffset("_MainTex", value);
				if (IsBump)
				{
					AnimatedMaterialsNotInstance[i].SetTextureOffset("_BumpMap", value);
				}
				if (IsHeight)
				{
					AnimatedMaterialsNotInstance[i].SetTextureOffset("_HeightMap", value);
				}
				if (IsCutOut)
				{
					AnimatedMaterialsNotInstance[i].SetTextureOffset("_CutOut", value);
				}
			}
			return;
		}
		Vector2 value2;
		if (IsRandomOffsetForInctance)
		{
			int num2 = index + OffsetMat;
			value2 = new Vector2((float)num2 / (float)Columns - (float)(num2 / Columns), 1f - (float)(num2 / Columns) / (float)Rows);
		}
		else
		{
			value2 = new Vector2((float)index / (float)Columns - (float)(index / Columns), 1f - (float)(index / Columns) / (float)Rows);
		}
		if (instanceMaterial != null)
		{
			instanceMaterial.SetTextureOffset("_MainTex", value2);
			if (IsBump)
			{
				instanceMaterial.SetTextureOffset("_BumpMap", value2);
			}
			if (IsHeight)
			{
				instanceMaterial.SetTextureOffset("_HeightMap", value2);
			}
			if (IsCutOut)
			{
				instanceMaterial.SetTextureOffset("_CutOut", value2);
			}
		}
		else if (currentRenderer != null)
		{
			currentRenderer.material.SetTextureOffset("_MainTex", value2);
			if (IsBump)
			{
				currentRenderer.material.SetTextureOffset("_BumpMap", value2);
			}
			if (IsHeight)
			{
				currentRenderer.material.SetTextureOffset("_HeightMap", value2);
			}
			if (IsCutOut)
			{
				currentRenderer.material.SetTextureOffset("_CutOut", value2);
			}
		}
	}
}
public class RFX1_DemoGUI : MonoBehaviour
{
	public int Current;

	public GameObject[] Prefabs;

	public bool[] IsShield;

	public GameObject ShieldProjectile;

	public GameObject ShieldProjectile2;

	public float ShieldProjectileReactiovationTime = 7f;

	public Light Sun;

	public ReflectionProbe ReflectionProbe;

	public Light[] NightLights = new Light[0];

	public Texture HUETexture;

	public bool UseMobileVersion;

	public GameObject MobileCharacter;

	public GameObject Target;

	public Color guiColor = Color.red;

	public RFX1_DistortionAndBloom RFX1_DistortionAndBloom;

	private int currentNomber;

	private GameObject currentInstance;

	private GUIStyle guiStyleHeader = new GUIStyle();

	private GUIStyle guiStyleHeaderMobile = new GUIStyle();

	private float dpiScale;

	private bool isDay;

	private float colorHUE;

	private float startSunIntensity;

	private Quaternion startSunRotation;

	private Color startAmbientLight;

	private float startAmbientIntencity;

	private float startReflectionIntencity;

	private LightShadows startLightShadows;

	private float currentSpeed = 1f;

	private GameObject mobileCharacterInstance;

	private bool isButtonPressed;

	private GameObject instanceShieldProjectile;

	private void Start()
	{
		if (Screen.dpi < 1f)
		{
			dpiScale = 1f;
		}
		if (Screen.dpi < 200f)
		{
			dpiScale = 1f;
		}
		else
		{
			dpiScale = Screen.dpi / 200f;
		}
		guiStyleHeader.fontSize = (int)(15f * dpiScale);
		guiStyleHeader.normal.textColor = guiColor;
		guiStyleHeaderMobile.fontSize = (int)(17f * dpiScale);
		ChangeCurrent(Current);
		startSunIntensity = Sun.intensity;
		startSunRotation = Sun.transform.rotation;
		startAmbientLight = RenderSettings.ambientLight;
		startAmbientIntencity = RenderSettings.ambientIntensity;
		startReflectionIntencity = RenderSettings.reflectionIntensity;
		startLightShadows = Sun.shadows;
		RFX1_DistortionAndBloom = Camera.main.GetComponent<RFX1_DistortionAndBloom>();
	}

	private void OnGUI()
	{
		if (Input.GetKeyUp(KeyCode.LeftArrow) || Input.GetKeyUp(KeyCode.RightArrow) || Input.GetKeyUp(KeyCode.DownArrow))
		{
			isButtonPressed = false;
		}
		if (GUI.Button(new Rect(10f * dpiScale, 15f * dpiScale, 135f * dpiScale, 37f * dpiScale), "PREVIOUS EFFECT") || (!isButtonPressed && Input.GetKeyDown(KeyCode.LeftArrow)))
		{
			isButtonPressed = true;
			ChangeCurrent(-1);
		}
		if (GUI.Button(new Rect(160f * dpiScale, 15f * dpiScale, 135f * dpiScale, 37f * dpiScale), "NEXT EFFECT") || (!isButtonPressed && Input.GetKeyDown(KeyCode.RightArrow)))
		{
			isButtonPressed = true;
			ChangeCurrent(1);
		}
		float num = 0f;
		if (GUI.Button(new Rect(10f * dpiScale, 63f * dpiScale + num, 285f * dpiScale, 37f * dpiScale), "Day / Night") || (!isButtonPressed && Input.GetKeyDown(KeyCode.DownArrow)))
		{
			isButtonPressed = true;
			if (ReflectionProbe != null)
			{
				ReflectionProbe.RenderProbe();
			}
			Sun.intensity = ((!isDay) ? 0.05f : startSunIntensity);
			Sun.shadows = (isDay ? startLightShadows : LightShadows.None);
			Light[] nightLights = NightLights;
			for (int i = 0; i < nightLights.Length; i++)
			{
				nightLights[i].shadows = ((!isDay) ? startLightShadows : LightShadows.None);
			}
			Sun.transform.rotation = (isDay ? startSunRotation : Quaternion.Euler(350f, 30f, 90f));
			RenderSettings.ambientLight = ((!isDay) ? new Color(0.1f, 0.1f, 0.1f) : startAmbientLight);
			float num2 = ((!UseMobileVersion) ? 1f : 0.2f);
			RenderSettings.ambientIntensity = (isDay ? startAmbientIntencity : num2);
			RenderSettings.reflectionIntensity = (isDay ? startReflectionIntencity : 0.2f);
			isDay = !isDay;
		}
		GUI.Label(new Rect(400f * dpiScale, 15f * dpiScale + num / 2f, 100f * dpiScale, 20f * dpiScale), "Prefab name is \"" + Prefabs[currentNomber].name + "\"  \r\nHold any mouse button that would move the camera", guiStyleHeader);
		if (!IsShield[currentNomber] && !UseMobileVersion)
		{
			GUI.Label(new Rect(12f * dpiScale, 110f * dpiScale + num, 50f * dpiScale, 20f * dpiScale), "Projectile Speed: " + Mathf.Round(currentSpeed * 10f) / 10f, guiStyleHeader);
			float num3 = currentSpeed;
			if (!UseMobileVersion)
			{
				currentSpeed = GUI.HorizontalSlider(new Rect(154f * dpiScale, 114f * dpiScale + num, 135f * dpiScale, 15f * dpiScale), currentSpeed, 0.1f, 10f);
			}
			if ((double)Math.Abs(num3 - currentSpeed) > 0.001)
			{
				RFX1_AnimatorEvents component = currentInstance.GetComponent<RFX1_AnimatorEvents>();
				if (component != null)
				{
					component.Speed = currentSpeed;
				}
			}
		}
		GUI.DrawTexture(new Rect(12f * dpiScale, 140f * dpiScale + num, 285f * dpiScale, 15f * dpiScale), HUETexture, ScaleMode.StretchToFill, alphaBlend: false, 0f);
		float num4 = colorHUE;
		colorHUE = GUI.HorizontalSlider(new Rect(12f * dpiScale, 147f * dpiScale + num, 285f * dpiScale, 15f * dpiScale), colorHUE, 0f, 360f);
		if (!((double)Mathf.Abs(num4 - colorHUE) > 0.001))
		{
			return;
		}
		RFX1_AnimatorEvents component2 = currentInstance.GetComponent<RFX1_AnimatorEvents>();
		if (component2 != null)
		{
			component2.HUE = colorHUE / 360f;
		}
		if (UseMobileVersion)
		{
			RFX1_EffectSettingColor rFX1_EffectSettingColor = currentInstance.GetComponent<RFX1_EffectSettingColor>();
			if (rFX1_EffectSettingColor == null)
			{
				rFX1_EffectSettingColor = currentInstance.AddComponent<RFX1_EffectSettingColor>();
			}
			RFX1_ColorHelper.HSBColor hsbColor = RFX1_ColorHelper.ColorToHSV(rFX1_EffectSettingColor.Color);
			hsbColor.H = colorHUE / 360f;
			rFX1_EffectSettingColor.Color = RFX1_ColorHelper.HSVToColor(hsbColor);
		}
	}

	private void ChangeCurrent(int delta)
	{
		currentSpeed = 1f;
		currentNomber += delta;
		if (currentNomber > Prefabs.Length - 1)
		{
			currentNomber = 0;
		}
		else if (currentNomber < 0)
		{
			currentNomber = Prefabs.Length - 1;
		}
		if (currentInstance != null)
		{
			UnityEngine.Object.Destroy(currentInstance);
			RemoveClones();
		}
		currentInstance = UnityEngine.Object.Instantiate(Prefabs[currentNomber]);
		RFX1_AnimatorEvents component = currentInstance.GetComponent<RFX1_AnimatorEvents>();
		if (component != null)
		{
			component.Target = Target;
		}
		RFX1_Target component2 = currentInstance.GetComponent<RFX1_Target>();
		if (component2 != null)
		{
			component2.Target = Target;
		}
		CancelInvoke("ReactivateShieldProjectile");
		if (IsShield[currentNomber])
		{
			if (currentNomber != 23)
			{
				InvokeRepeating("ReactivateShieldProjectile", 5f, ShieldProjectileReactiovationTime);
			}
			else
			{
				InvokeRepeating("ReactivateShieldProjectile", 3f, 3f);
			}
		}
		RFX1_TransformMotion componentInChildren = currentInstance.GetComponentInChildren<RFX1_TransformMotion>();
		if (componentInChildren != null)
		{
			currentSpeed = componentInChildren.Speed;
		}
		if (UseMobileVersion)
		{
			CancelInvoke("ReactivateEffect");
			componentInChildren = currentInstance.GetComponentInChildren<RFX1_TransformMotion>();
			if (componentInChildren != null)
			{
				componentInChildren.CollisionEnter += delegate
				{
					Invoke("ReactivateEffect", 3f);
				};
			}
		}
		if (mobileCharacterInstance != null)
		{
			UnityEngine.Object.Destroy(mobileCharacterInstance);
		}
		if (IsShield[currentNomber] && UseMobileVersion)
		{
			mobileCharacterInstance = UnityEngine.Object.Instantiate(MobileCharacter);
		}
	}

	private void RemoveClones()
	{
		GameObject[] array = UnityEngine.Object.FindObjectsOfType<GameObject>();
		foreach (GameObject gameObject in array)
		{
			if (gameObject.name.Contains("(Clone)"))
			{
				UnityEngine.Object.Destroy(gameObject);
			}
		}
	}

	private void ReactivateShieldProjectile()
	{
		if (instanceShieldProjectile != null)
		{
			UnityEngine.Object.Destroy(instanceShieldProjectile);
		}
		instanceShieldProjectile = ((currentNomber != 23) ? UnityEngine.Object.Instantiate(ShieldProjectile) : UnityEngine.Object.Instantiate(ShieldProjectile2));
		instanceShieldProjectile.SetActive(value: false);
		instanceShieldProjectile.SetActive(value: true);
	}

	private void ReactivateEffect()
	{
		currentInstance.SetActive(value: false);
		currentInstance.SetActive(value: true);
	}
}
public class RFX1_FPS : MonoBehaviour
{
	public GUIStyle guiStyleHeader = new GUIStyle();

	private float timeleft;

	private float timeleft2;

	private const float updateTime = 0.5f;

	private float fps;

	private int frames;

	private void OnGUI()
	{
		GUI.Label(new Rect(0f, 0f, 30f, 30f), "FPS: " + (float)(int)fps / 0.5f, guiStyleHeader);
	}

	private void Update()
	{
		timeleft -= Time.deltaTime;
		frames++;
		if ((double)timeleft <= 0.0)
		{
			fps = frames;
			timeleft = 0.5f;
			frames = 0;
		}
	}
}
public class RFX1_MouseOrbit : MonoBehaviour
{
	public GameObject target;

	public float distance = 10f;

	public float xSpeed = 250f;

	public float ySpeed = 120f;

	public float yMinLimit = -20f;

	public float yMaxLimit = 80f;

	private float x;

	private float y;

	private float prevDistance;

	private void Start()
	{
		Vector3 eulerAngles = base.transform.eulerAngles;
		x = eulerAngles.y;
		y = eulerAngles.x;
	}

	private void LateUpdate()
	{
		if (distance < 2f)
		{
			distance = 2f;
		}
		distance -= Input.GetAxis("Mouse ScrollWheel") * 2f;
		if ((bool)target && (Input.GetMouseButton(0) || Input.GetMouseButton(1)))
		{
			Vector3 mousePosition = Input.mousePosition;
			float num = 1f;
			if (Screen.dpi < 1f)
			{
				num = 1f;
			}
			num = ((!(Screen.dpi < 200f)) ? (Screen.dpi / 200f) : 1f);
			if (mousePosition.x < 380f * num && (float)Screen.height - mousePosition.y < 250f * num)
			{
				return;
			}
			Cursor.visible = false;
			Cursor.lockState = CursorLockMode.Locked;
			x += Input.GetAxis("Mouse X") * xSpeed * 0.02f;
			y -= Input.GetAxis("Mouse Y") * ySpeed * 0.02f;
			y = ClampAngle(y, yMinLimit, yMaxLimit);
			Quaternion quaternion = Quaternion.Euler(y, x, 0f);
			Vector3 position = quaternion * new Vector3(0f, 0f, 0f - distance) + target.transform.position;
			base.transform.rotation = quaternion;
			base.transform.position = position;
		}
		else
		{
			Cursor.visible = true;
			Cursor.lockState = CursorLockMode.None;
		}
		if (Math.Abs(prevDistance - distance) > 0.001f)
		{
			prevDistance = distance;
			Quaternion quaternion2 = Quaternion.Euler(y, x, 0f);
			Vector3 position2 = quaternion2 * new Vector3(0f, 0f, 0f - distance) + target.transform.position;
			base.transform.rotation = quaternion2;
			base.transform.position = position2;
		}
	}

	private static float ClampAngle(float angle, float min, float max)
	{
		if (angle < -360f)
		{
			angle += 360f;
		}
		if (angle > 360f)
		{
			angle -= 360f;
		}
		return Mathf.Clamp(angle, min, max);
	}
}
public class RFX1_RealtimeReflection : MonoBehaviour
{
	private ReflectionProbe probe;

	private Transform camT;

	private void Awake()
	{
		probe = GetComponent<ReflectionProbe>();
		camT = Camera.main.transform;
	}

	private void Update()
	{
		Vector3 position = camT.position;
		probe.transform.position = new Vector3(position.x, position.y * -1f, position.z);
		probe.RenderProbe();
	}
}
[ExecuteInEditMode]
[RequireComponent(typeof(Camera))]
[AddComponentMenu("KriptoFX/RFX1_BloomAndDistortion")]
public class RFX1_DistortionAndBloom : MonoBehaviour
{
	[Range(0.05f, 1f)]
	[Tooltip("Camera render texture resolution")]
	public float RenderTextureResolutoinFactor = 0.25f;

	public bool UseBloom = true;

	[Range(0.1f, 3f)]
	[Tooltip("Filters out pixels under this level of brightness.")]
	public float Threshold = 2f;

	[SerializeField]
	[Range(0f, 1f)]
	[Tooltip("Makes transition between under/over-threshold gradual.")]
	public float SoftKnee;

	[Range(1f, 7f)]
	[Tooltip("Changes extent of veiling effects in A screen resolution-independent fashion.")]
	public float Radius = 7f;

	[Tooltip("Blend factor of the result image.")]
	public float Intensity = 1f;

	[Tooltip("Controls filter quality and buffer resolution.")]
	public bool HighQuality;

	[Tooltip("Reduces flashing noise with an additional filter.")]
	public bool AntiFlicker;

	private const string shaderName = "Hidden/KriptoFX/PostEffects/RFX1_Bloom";

	private const string shaderAdditiveName = "Hidden/KriptoFX/PostEffects/RFX1_BloomAdditive";

	private const string cameraName = "MobileCamera(Distort_Bloom_Depth)";

	private RenderTexture source;

	private RenderTexture depth;

	private RenderTexture destination;

	private int previuosFrameWidth;

	private int previuosFrameHeight;

	private float previousScale;

	private Camera addCamera;

	private GameObject tempGO;

	private bool HDRSupported;

	private Material m_Material;

	private Material m_MaterialAdditive;

	private const int kMaxIterations = 16;

	private readonly RenderTexture[] m_blurBuffer1 = new RenderTexture[16];

	private readonly RenderTexture[] m_blurBuffer2 = new RenderTexture[16];

	public GUIStyle guiStyleHeader = new GUIStyle();

	public Material mat
	{
		get
		{
			if (m_Material == null)
			{
				m_Material = CheckShaderAndCreateMaterial(Shader.Find("Hidden/KriptoFX/PostEffects/RFX1_Bloom"));
			}
			return m_Material;
		}
	}

	public Material matAdditive
	{
		get
		{
			if (m_MaterialAdditive == null)
			{
				m_MaterialAdditive = CheckShaderAndCreateMaterial(Shader.Find("Hidden/KriptoFX/PostEffects/RFX1_BloomAdditive"));
				m_MaterialAdditive.renderQueue = 3900;
			}
			return m_MaterialAdditive;
		}
	}

	public static Material CheckShaderAndCreateMaterial(Shader s)
	{
		if (s == null || !s.isSupported)
		{
			return null;
		}
		return new Material(s)
		{
			hideFlags = HideFlags.DontSave
		};
	}

	private void OnDisable()
	{
		if (m_Material != null)
		{
			UnityEngine.Object.DestroyImmediate(m_Material);
		}
		m_Material = null;
		if (m_MaterialAdditive != null)
		{
			UnityEngine.Object.DestroyImmediate(m_MaterialAdditive);
		}
		m_MaterialAdditive = null;
		if (tempGO != null)
		{
			UnityEngine.Object.DestroyImmediate(tempGO);
		}
		Shader.DisableKeyword("DISTORT_OFF");
		Shader.DisableKeyword("_MOBILEDEPTH_ON");
	}

	private void Start()
	{
		InitializeRenderTarget();
	}

	private void LateUpdate()
	{
		if (previuosFrameWidth != Screen.width || previuosFrameHeight != Screen.height || Mathf.Abs(previousScale - RenderTextureResolutoinFactor) > 0.01f)
		{
			InitializeRenderTarget();
			previuosFrameWidth = Screen.width;
			previuosFrameHeight = Screen.height;
			previousScale = RenderTextureResolutoinFactor;
		}
		Shader.EnableKeyword("DISTORT_OFF");
		Shader.EnableKeyword("_MOBILEDEPTH_ON");
		GrabImage();
		if (UseBloom && HDRSupported)
		{
			UpdateBloom();
		}
		Shader.SetGlobalTexture("_GrabTexture", source);
		Shader.SetGlobalTexture("_CameraDepthTexture", depth);
		Shader.SetGlobalFloat("_GrabTextureScale", RenderTextureResolutoinFactor);
		Shader.DisableKeyword("DISTORT_OFF");
	}

	private void OnPostRender()
	{
		Graphics.Blit(destination, null, matAdditive);
	}

	private void InitializeRenderTarget()
	{
		int num = (int)((float)Screen.width * RenderTextureResolutoinFactor);
		int num2 = (int)((float)Screen.height * RenderTextureResolutoinFactor);
		if (SystemInfo.SupportsRenderTextureFormat(RenderTextureFormat.RGB111110Float))
		{
			source = new RenderTexture(num, num2, 0, RenderTextureFormat.RGB111110Float);
			depth = new RenderTexture(num, num2, 8, RenderTextureFormat.Depth);
			HDRSupported = true;
			if (UseBloom)
			{
				destination = new RenderTexture(((double)RenderTextureResolutoinFactor > 0.99) ? num : (num / 2), ((double)RenderTextureResolutoinFactor > 0.99) ? num2 : (num2 / 2), 0, RenderTextureFormat.RGB111110Float);
			}
		}
		else
		{
			HDRSupported = false;
			source = new RenderTexture(num, num2, 0, RenderTextureFormat.RGB565);
			depth = new RenderTexture(num, num2, 8, RenderTextureFormat.Depth);
		}
	}

	private void UpdateBloom()
	{
		bool isMobilePlatform = UnityEngine.Application.isMobilePlatform;
		if (source == null)
		{
			return;
		}
		int num = source.width;
		int num2 = source.height;
		if (!HighQuality)
		{
			num /= 2;
			num2 /= 2;
		}
		RenderTextureFormat format = (isMobilePlatform ? RenderTextureFormat.Default : RenderTextureFormat.DefaultHDR);
		float num3 = Mathf.Log(num2, 2f) + Radius - 8f;
		int num4 = (int)num3;
		int num5 = Mathf.Clamp(num4, 1, 16);
		float num6 = Mathf.GammaToLinearSpace(Threshold);
		mat.SetFloat("_Threshold", num6);
		float num7 = num6 * SoftKnee + 1E-05f;
		Vector3 vector = new Vector3(num6 - num7, num7 * 2f, 0.25f / num7);
		mat.SetVector("_Curve", vector);
		bool flag = !HighQuality && AntiFlicker;
		mat.SetFloat("_PrefilterOffs", flag ? (-0.5f) : 0f);
		mat.SetFloat("_SampleScale", 0.5f + num3 - (float)num4);
		mat.SetFloat("_Intensity", Mathf.Max(0f, Intensity));
		RenderTexture temporary = RenderTexture.GetTemporary(num, num2, 0, format);
		Graphics.Blit(source, temporary, mat, AntiFlicker ? 1 : 0);
		RenderTexture renderTexture = temporary;
		for (int i = 0; i < num5; i++)
		{
			m_blurBuffer1[i] = RenderTexture.GetTemporary(renderTexture.width / 2, renderTexture.height / 2, 0, format);
			Graphics.Blit(renderTexture, m_blurBuffer1[i], mat, (i == 0) ? (AntiFlicker ? 3 : 2) : 4);
			renderTexture = m_blurBuffer1[i];
		}
		for (int num8 = num5 - 2; num8 >= 0; num8--)
		{
			RenderTexture renderTexture2 = m_blurBuffer1[num8];
			mat.SetTexture("_BaseTex", renderTexture2);
			m_blurBuffer2[num8] = RenderTexture.GetTemporary(renderTexture2.width, renderTexture2.height, 0, format);
			Graphics.Blit(renderTexture, m_blurBuffer2[num8], mat, HighQuality ? 6 : 5);
			renderTexture = m_blurBuffer2[num8];
		}
		destination.DiscardContents();
		Graphics.Blit(renderTexture, destination, mat, HighQuality ? 8 : 7);
		for (int j = 0; j < 16; j++)
		{
			if (m_blurBuffer1[j] != null)
			{
				RenderTexture.ReleaseTemporary(m_blurBuffer1[j]);
			}
			if (m_blurBuffer2[j] != null)
			{
				RenderTexture.ReleaseTemporary(m_blurBuffer2[j]);
			}
			m_blurBuffer1[j] = null;
			m_blurBuffer2[j] = null;
		}
		RenderTexture.ReleaseTemporary(temporary);
	}

	private void GrabImage()
	{
		Camera camera = Camera.current;
		if (camera == null)
		{
			camera = Camera.main;
		}
		if (tempGO == null)
		{
			tempGO = new GameObject();
			tempGO.hideFlags = HideFlags.HideAndDontSave;
			tempGO.name = "MobileCamera(Distort_Bloom_Depth)";
			addCamera = tempGO.AddComponent<Camera>();
			addCamera.enabled = false;
		}
		else
		{
			addCamera = tempGO.GetComponent<Camera>();
		}
		addCamera.CopyFrom(camera);
		addCamera.SetTargetBuffers(source.colorBuffer, depth.depthBuffer);
		addCamera.depth--;
		addCamera.Render();
	}
}
public class RFX1_AudioPitchCurves : MonoBehaviour
{
	public AnimationCurve AudioCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	public float GraphTimeMultiplier = 1f;

	public float GraphPitchMultiplier = 1f;

	public bool IsLoop;

	private bool canUpdate;

	private float startTime;

	private AudioSource audioSource;

	private float startPitch;

	private void Awake()
	{
		audioSource = GetComponent<AudioSource>();
		startPitch = audioSource.pitch;
		audioSource.pitch = AudioCurve.Evaluate(0f) * GraphPitchMultiplier;
	}

	private void OnEnable()
	{
		startTime = Time.time;
		canUpdate = true;
		if (audioSource != null)
		{
			audioSource.pitch = AudioCurve.Evaluate(0f) * GraphPitchMultiplier;
		}
	}

	private void Update()
	{
		float num = Time.time - startTime;
		if (canUpdate)
		{
			float pitch = AudioCurve.Evaluate(num / GraphTimeMultiplier) * startPitch * GraphPitchMultiplier;
			audioSource.pitch = pitch;
		}
		if (num >= GraphTimeMultiplier)
		{
			if (IsLoop)
			{
				startTime = Time.time;
			}
			else
			{
				canUpdate = false;
			}
		}
	}
}
public class RFX1_AudioVolumeCurves : MonoBehaviour
{
	public AnimationCurve AudioCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	public float GraphTimeMultiplier = 1f;

	public bool IsLoop;

	private bool canUpdate;

	private float startTime;

	private AudioSource audioSource;

	private float startVolume;

	private void Awake()
	{
		audioSource = GetComponent<AudioSource>();
		startVolume = audioSource.volume;
		audioSource.volume = AudioCurve.Evaluate(0f);
	}

	private void OnEnable()
	{
		startTime = Time.time;
		canUpdate = true;
		if (audioSource != null)
		{
			audioSource.volume = AudioCurve.Evaluate(0f);
		}
	}

	private void Update()
	{
		float num = Time.time - startTime;
		if (canUpdate)
		{
			float volume = AudioCurve.Evaluate(num / GraphTimeMultiplier) * startVolume;
			audioSource.volume = volume;
		}
		if (num >= GraphTimeMultiplier)
		{
			if (IsLoop)
			{
				startTime = Time.time;
			}
			else
			{
				canUpdate = false;
			}
		}
	}
}
public class RFX1_LightCurves : MonoBehaviour
{
	public AnimationCurve LightCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	public float GraphTimeMultiplier = 1f;

	public float GraphIntensityMultiplier = 1f;

	public bool IsLoop;

	[HideInInspector]
	public bool canUpdate;

	private float startTime;

	private Light lightSource;

	private void Awake()
	{
		lightSource = GetComponent<Light>();
		lightSource.intensity = LightCurve.Evaluate(0f) * GraphIntensityMultiplier;
	}

	private void OnEnable()
	{
		startTime = Time.time;
		canUpdate = true;
		if (lightSource != null)
		{
			lightSource.intensity = LightCurve.Evaluate(0f) * GraphIntensityMultiplier;
		}
	}

	private void Update()
	{
		float num = Time.time - startTime;
		if (canUpdate)
		{
			float intensity = LightCurve.Evaluate(num / GraphTimeMultiplier) * GraphIntensityMultiplier;
			lightSource.intensity = intensity;
		}
		if (num >= GraphTimeMultiplier)
		{
			if (IsLoop)
			{
				startTime = Time.time;
			}
			else
			{
				canUpdate = false;
			}
		}
	}
}
public class RFX1_ProjectorSizeCurves : MonoBehaviour
{
	public AnimationCurve ProjectorSize = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	public float GraphTimeMultiplier = 1f;

	public float GraphIntensityMultiplier = 1f;

	public bool IsLoop;

	private bool canUpdate;

	private float startTime;

	private Projector projector;

	private void Awake()
	{
		projector = GetComponent<Projector>();
		projector.orthographicSize = ProjectorSize.Evaluate(0f);
	}

	private void OnEnable()
	{
		startTime = Time.time;
		canUpdate = true;
	}

	private void Update()
	{
		float num = Time.time - startTime;
		if (canUpdate)
		{
			float orthographicSize = ProjectorSize.Evaluate(num / GraphTimeMultiplier) * GraphIntensityMultiplier;
			projector.orthographicSize = orthographicSize;
		}
		if (num >= GraphTimeMultiplier)
		{
			if (IsLoop)
			{
				startTime = Time.time;
			}
			else
			{
				canUpdate = false;
			}
		}
	}
}
public class RFX1_ScaleCurves : MonoBehaviour
{
	public AnimationCurve FloatCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	public float GraphTimeMultiplier = 1f;

	public float GraphIntensityMultiplier = 1f;

	public bool IsLoop;

	private bool canUpdate;

	private float startTime;

	private Transform t;

	private int nameId;

	private Projector proj;

	private Vector3 startScale;

	private void Awake()
	{
		t = GetComponent<Transform>();
		startScale = t.localScale;
		t.localScale = Vector3.zero;
		proj = GetComponent<Projector>();
	}

	private void OnEnable()
	{
		startTime = Time.time;
		canUpdate = true;
		t.localScale = Vector3.zero;
	}

	private void Update()
	{
		float num = Time.time - startTime;
		if (canUpdate)
		{
			float num2 = FloatCurve.Evaluate(num / GraphTimeMultiplier) * GraphIntensityMultiplier;
			t.localScale = num2 * startScale;
			if (proj != null)
			{
				proj.orthographicSize = num2;
			}
		}
		if (num >= GraphTimeMultiplier)
		{
			if (IsLoop)
			{
				startTime = Time.time;
			}
			else
			{
				canUpdate = false;
			}
		}
	}
}
public class RFX1_ShaderColorGradient : MonoBehaviour
{
	public RFX1_ShaderProperties ShaderColorProperty;

	public Gradient Color = new Gradient();

	public float TimeMultiplier = 1f;

	public bool IsLoop;

	public bool UseSharedMaterial;

	[HideInInspector]
	public float HUE = -1f;

	[HideInInspector]
	public bool canUpdate;

	private Material mat;

	private int propertyID;

	private float startTime;

	private Color startColor;

	private bool isInitialized;

	private string shaderProperty;

	private void Start()
	{
		Init();
	}

	private void Init()
	{
		shaderProperty = ShaderColorProperty.ToString();
		startTime = Time.time;
		canUpdate = true;
		Renderer component = GetComponent<Renderer>();
		if (component == null)
		{
			Projector component2 = GetComponent<Projector>();
			if (component2 != null)
			{
				if (!component2.material.name.EndsWith("(Instance)"))
				{
					component2.material = new Material(component2.material)
					{
						name = component2.material.name + " (Instance)"
					};
				}
				mat = component2.material;
			}
		}
		else if (!UseSharedMaterial)
		{
			mat = component.material;
		}
		else
		{
			mat = component.sharedMaterial;
		}
		if (mat == null)
		{
			canUpdate = false;
			return;
		}
		if (!mat.HasProperty(shaderProperty))
		{
			canUpdate = false;
			return;
		}
		if (mat.HasProperty(shaderProperty))
		{
			propertyID = Shader.PropertyToID(shaderProperty);
		}
		startColor = mat.GetColor(propertyID);
		Color color = Color.Evaluate(0f);
		mat.SetColor(propertyID, color * startColor);
		isInitialized = true;
	}

	private void OnEnable()
	{
		if (isInitialized)
		{
			startTime = Time.time;
			canUpdate = true;
		}
	}

	private void Update()
	{
		if (mat == null)
		{
			return;
		}
		float num = Time.time - startTime;
		if (canUpdate)
		{
			Color color = Color.Evaluate(num / TimeMultiplier);
			mat.SetColor(propertyID, color * startColor);
		}
		if (num >= TimeMultiplier)
		{
			if (IsLoop)
			{
				startTime = Time.time;
			}
			else
			{
				canUpdate = false;
			}
		}
	}

	private void OnDisable()
	{
		if (!(mat == null))
		{
			if (UseSharedMaterial)
			{
				mat.SetColor(propertyID, startColor);
			}
			mat.SetColor(propertyID, startColor);
		}
	}
}
public class RFX1_ShaderFloatCurve : MonoBehaviour
{
	public RFX1_ShaderProperties ShaderFloatProperty = RFX1_ShaderProperties._Cutoff;

	public AnimationCurve FloatCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	public float GraphTimeMultiplier = 1f;

	public float GraphIntensityMultiplier = 1f;

	public bool IsLoop;

	public bool UseSharedMaterial;

	private bool canUpdate;

	private float startTime;

	private Material mat;

	private float startFloat;

	private int propertyID;

	private string shaderProperty;

	private bool isInitialized;

	private void Awake()
	{
		Renderer component = GetComponent<Renderer>();
		if (component == null)
		{
			Projector component2 = GetComponent<Projector>();
			if (component2 != null)
			{
				if (!UseSharedMaterial)
				{
					if (!component2.material.name.EndsWith("(Instance)"))
					{
						component2.material = new Material(component2.material)
						{
							name = component2.material.name + " (Instance)"
						};
					}
					mat = component2.material;
				}
				else
				{
					mat = component2.material;
				}
			}
		}
		else if (!UseSharedMaterial)
		{
			mat = component.material;
		}
		else
		{
			mat = component.sharedMaterial;
		}
		shaderProperty = ShaderFloatProperty.ToString();
		if (mat.HasProperty(shaderProperty))
		{
			propertyID = Shader.PropertyToID(shaderProperty);
		}
		startFloat = mat.GetFloat(propertyID);
		float value = FloatCurve.Evaluate(0f) * GraphIntensityMultiplier;
		mat.SetFloat(propertyID, value);
		isInitialized = true;
	}

	private void OnEnable()
	{
		startTime = Time.time;
		canUpdate = true;
		if (isInitialized)
		{
			float value = FloatCurve.Evaluate(0f) * GraphIntensityMultiplier;
			mat.SetFloat(propertyID, value);
		}
	}

	private void Update()
	{
		float num = Time.time - startTime;
		if (canUpdate)
		{
			float value = FloatCurve.Evaluate(num / GraphTimeMultiplier) * GraphIntensityMultiplier;
			mat.SetFloat(propertyID, value);
		}
		if (num >= GraphTimeMultiplier)
		{
			if (IsLoop)
			{
				startTime = Time.time;
			}
			else
			{
				canUpdate = false;
			}
		}
	}

	private void OnDisable()
	{
		if (UseSharedMaterial)
		{
			mat.SetFloat(propertyID, startFloat);
		}
	}
}
public enum RFX1_ShaderProperties
{
	_TintColor,
	_Cutoff,
	_Color,
	_EmissionColor,
	_MaskPow,
	_Cutout,
	_Speed,
	_BumpAmt,
	_AlphaPow,
	_Distortion,
	_MainColor
}
public class RFX1_WindCurves : MonoBehaviour
{
	public AnimationCurve WindCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	public float GraphTimeMultiplier = 1f;

	public float GraphIntensityMultiplier = 1f;

	public bool IsLoop;

	private bool canUpdate;

	private float startTime;

	private WindZone windZone;

	private void Awake()
	{
		windZone = GetComponent<WindZone>();
		windZone.windMain = WindCurve.Evaluate(0f);
	}

	private void OnEnable()
	{
		startTime = Time.time;
		canUpdate = true;
	}

	private void Update()
	{
		float num = Time.time - startTime;
		if (canUpdate)
		{
			float windMain = WindCurve.Evaluate(num / GraphTimeMultiplier) * GraphIntensityMultiplier;
			windZone.windMain = windMain;
		}
		if (num >= GraphTimeMultiplier)
		{
			if (IsLoop)
			{
				startTime = Time.time;
			}
			else
			{
				canUpdate = false;
			}
		}
	}
}
public class RFX1_EffectSettingColor : MonoBehaviour
{
	public Color Color = Color.red;

	private Color previousColor;

	private void OnEnable()
	{
		UpdateColor();
	}

	private void Update()
	{
		if (previousColor != Color)
		{
			UpdateColor();
		}
	}

	private void UpdateColor()
	{
		float h = RFX1_ColorHelper.ColorToHSV(Color).H;
		RFX1_ColorHelper.ChangeObjectColorByHUE(base.gameObject, h);
		RFX1_TransformMotion componentInChildren = GetComponentInChildren<RFX1_TransformMotion>(includeInactive: true);
		if (componentInChildren != null)
		{
			componentInChildren.HUE = h;
		}
		previousColor = Color;
	}
}
public class RFX1_EffectSettingProjectile : MonoBehaviour
{
	public float FlyDistanceForProjectiles = 30f;

	public float SpeedMultiplier = 1f;

	public LayerMask CollidesWith = -1;

	private float startSpeed;

	private float oldSpeedMultiplier;

	private void Awake()
	{
		oldSpeedMultiplier = SpeedMultiplier;
		RFX1_TransformMotion componentInChildren = GetComponentInChildren<RFX1_TransformMotion>(includeInactive: true);
		if (componentInChildren != null)
		{
			startSpeed = componentInChildren.Speed;
		}
	}

	private void OnEnable()
	{
		RFX1_TransformMotion componentInChildren = GetComponentInChildren<RFX1_TransformMotion>(includeInactive: true);
		if (componentInChildren != null)
		{
			componentInChildren.Distance = FlyDistanceForProjectiles;
			componentInChildren.CollidesWith = CollidesWith;
			componentInChildren.Speed = startSpeed * SpeedMultiplier;
		}
	}

	private void Update()
	{
		if (Mathf.Abs(oldSpeedMultiplier - SpeedMultiplier) > 0.001f)
		{
			OnEnable();
		}
	}
}
public class RFX1_ShieldInteraction : MonoBehaviour
{
	private RFX1_TransformMotion transformMotion;

	private SphereCollider coll;

	private void Start()
	{
		transformMotion = GetComponentInChildren<RFX1_TransformMotion>();
		if (transformMotion != null)
		{
			transformMotion.CollisionEnter += TransformMotion_CollisionEnter;
			coll = transformMotion.gameObject.AddComponent<SphereCollider>();
			coll.radius = 0.1f;
			coll.isTrigger = true;
		}
	}

	private void TransformMotion_CollisionEnter(object sender, RFX1_TransformMotion.RFX1_CollisionInfo e)
	{
		RFX1_ShieldCollisionTrigger componentInChildren = e.Hit.transform.GetComponentInChildren<RFX1_ShieldCollisionTrigger>();
		if (!(componentInChildren == null))
		{
			componentInChildren.OnCollision(e.Hit, base.gameObject);
			coll.enabled = false;
		}
	}

	private void OnEnable()
	{
		if (coll != null)
		{
			coll.enabled = true;
		}
	}

	private void Update()
	{
	}
}
public class RFX1_Target : MonoBehaviour
{
	public GameObject Target;

	private GameObject currentTarget;

	private RFX1_TransformMotion transformMotion;

	private void Start()
	{
		transformMotion = GetComponentInChildren<RFX1_TransformMotion>();
		UpdateTarget();
	}

	private void Update()
	{
		UpdateTarget();
	}

	private void UpdateTarget()
	{
		if (!(Target == null))
		{
			if (transformMotion == null)
			{
				UnityEngine.Debug.Log("You must attach the target script on projectile effect!");
			}
			else if (Target != currentTarget)
			{
				currentTarget = Target;
				transformMotion.Target = currentTarget;
			}
		}
	}
}
public class RFX1_ActivateGravityAfterCollision : MonoBehaviour
{
	public RFX1_TransformMotion TransformMotion;

	public Vector2 Gravity = new Vector2(1f, 1f);

	private ParticleSystem ps;

	private ParticleSystem.MinMaxCurve startGravity;

	private bool isInitialized;

	private void OnEnable()
	{
		TransformMotion.CollisionEnter += TransformMotion_CollisionEnter;
		ps = GetComponent<ParticleSystem>();
		ParticleSystem.MainModule main = ps.main;
		if (!isInitialized)
		{
			isInitialized = true;
			startGravity = main.gravityModifier;
		}
		else
		{
			main.gravityModifier = startGravity;
		}
	}

	private void OnDisable()
	{
		TransformMotion.CollisionEnter -= TransformMotion_CollisionEnter;
	}

	private void TransformMotion_CollisionEnter(object sender, RFX1_TransformMotion.RFX1_CollisionInfo e)
	{
		ParticleSystem.MainModule main = ps.main;
		main.gravityModifier = new ParticleSystem.MinMaxCurve(Gravity.x, Gravity.y);
	}
}
public class RFX1_AnimatorEvents : MonoBehaviour
{
	[Serializable]
	public class RFX1_EffectAnimatorProperty
	{
		public GameObject Prefab;

		public Transform BonePosition;

		public Transform BoneRotation;

		public float DestroyTime = 10f;

		[HideInInspector]
		public GameObject CurrentInstance;
	}

	public RFX1_EffectAnimatorProperty Effect1;

	public RFX1_EffectAnimatorProperty Effect2;

	public RFX1_EffectAnimatorProperty Effect3;

	public GameObject Target;

	[HideInInspector]
	public float HUE = -1f;

	[HideInInspector]
	public float Speed = -1f;

	private float oldHUE;

	private float oldSpeed;

	private void InstantiateEffect(RFX1_EffectAnimatorProperty effect)
	{
		if (effect.Prefab == null)
		{
			return;
		}
		effect.CurrentInstance = UnityEngine.Object.Instantiate(effect.Prefab, effect.BonePosition.position, effect.BoneRotation.rotation);
		if (HUE > -0.9f)
		{
			UpdateColor(effect);
		}
		if (Speed > -0.9f)
		{
			UpdateSpeed(effect);
		}
		if (Target != null)
		{
			RFX1_Target component = effect.CurrentInstance.GetComponent<RFX1_Target>();
			if (component != null)
			{
				component.Target = Target;
			}
		}
		if (effect.DestroyTime > 0.001f)
		{
			UnityEngine.Object.Destroy(effect.CurrentInstance, effect.DestroyTime);
		}
	}

	public void ActivateEffect1()
	{
		InstantiateEffect(Effect1);
	}

	public void ActivateEffect2()
	{
		InstantiateEffect(Effect2);
	}

	public void ActivateEffect3()
	{
		InstantiateEffect(Effect3);
	}

	private void LateUpdate()
	{
		UpdateInstance(Effect1);
		UpdateInstance(Effect2);
		UpdateInstance(Effect3);
	}

	private void UpdateInstance(RFX1_EffectAnimatorProperty effect)
	{
		if (effect.CurrentInstance != null && effect.BonePosition != null)
		{
			effect.CurrentInstance.transform.position = effect.BonePosition.position;
			if (HUE > -0.9f && Mathf.Abs(oldHUE - HUE) > 0.001f)
			{
				UpdateColor(effect);
			}
			if (Speed > -0.9f && Mathf.Abs(oldSpeed - Speed) > 0.001f)
			{
				UpdateSpeed(effect);
			}
		}
	}

	private void UpdateSpeed(RFX1_EffectAnimatorProperty effect)
	{
		oldSpeed = Speed;
		RFX1_EffectSettingProjectile rFX1_EffectSettingProjectile = effect.CurrentInstance.GetComponent<RFX1_EffectSettingProjectile>();
		if (rFX1_EffectSettingProjectile == null)
		{
			rFX1_EffectSettingProjectile = effect.CurrentInstance.AddComponent<RFX1_EffectSettingProjectile>();
		}
		rFX1_EffectSettingProjectile.SpeedMultiplier *= Speed;
	}

	private void UpdateColor(RFX1_EffectAnimatorProperty effect)
	{
		oldHUE = HUE;
		RFX1_EffectSettingColor rFX1_EffectSettingColor = effect.CurrentInstance.GetComponent<RFX1_EffectSettingColor>();
		if (rFX1_EffectSettingColor == null)
		{
			rFX1_EffectSettingColor = effect.CurrentInstance.AddComponent<RFX1_EffectSettingColor>();
		}
		RFX1_ColorHelper.HSBColor hsbColor = RFX1_ColorHelper.ColorToHSV(rFX1_EffectSettingColor.Color);
		hsbColor.H = HUE;
		rFX1_EffectSettingColor.Color = RFX1_ColorHelper.HSVToColor(hsbColor);
	}
}
public static class RFX1_ColorHelper
{
	public struct HSBColor
	{
		public float H;

		public float S;

		public float B;

		public float A;

		public HSBColor(float h, float s, float b, float a)
		{
			H = h;
			S = s;
			B = b;
			A = a;
		}
	}

	private const float TOLERANCE = 0.0001f;

	private static string[] colorProperties = new string[10] { "_TintColor", "_Color", "_EmissionColor", "_BorderColor", "_ReflectColor", "_RimColor", "_MainColor", "_CoreColor", "_FresnelColor", "_CutoutColor" };

	public static HSBColor ColorToHSV(Color color)
	{
		HSBColor result = new HSBColor(0f, 0f, 0f, color.a);
		float r = color.r;
		float g = color.g;
		float b = color.b;
		float num = Mathf.Max(r, Mathf.Max(g, b));
		if (num <= 0f)
		{
			return result;
		}
		float num2 = Mathf.Min(r, Mathf.Min(g, b));
		float num3 = num - num2;
		if (num > num2)
		{
			if (Math.Abs(g - num) < 0.0001f)
			{
				result.H = (b - r) / num3 * 60f + 120f;
			}
			else if (Math.Abs(b - num) < 0.0001f)
			{
				result.H = (r - g) / num3 * 60f + 240f;
			}
			else if (b > g)
			{
				result.H = (g - b) / num3 * 60f + 360f;
			}
			else
			{
				result.H = (g - b) / num3 * 60f;
			}
			if (result.H < 0f)
			{
				result.H += 360f;
			}
		}
		else
		{
			result.H = 0f;
		}
		result.H *= 0.0027777778f;
		result.S = num3 / num * 1f;
		result.B = num;
		return result;
	}

	public static Color HSVToColor(HSBColor hsbColor)
	{
		float value = hsbColor.B;
		float value2 = hsbColor.B;
		float value3 = hsbColor.B;
		if (Math.Abs(hsbColor.S) > 0.0001f)
		{
			float b = hsbColor.B;
			float num = hsbColor.B * hsbColor.S;
			float num2 = hsbColor.B - num;
			float num3 = hsbColor.H * 360f;
			if (num3 < 60f)
			{
				value = b;
				value2 = num3 * num / 60f + num2;
				value3 = num2;
			}
			else if (num3 < 120f)
			{
				value = (0f - (num3 - 120f)) * num / 60f + num2;
				value2 = b;
				value3 = num2;
			}
			else if (num3 < 180f)
			{
				value = num2;
				value2 = b;
				value3 = (num3 - 120f) * num / 60f + num2;
			}
			else if (num3 < 240f)
			{
				value = num2;
				value2 = (0f - (num3 - 240f)) * num / 60f + num2;
				value3 = b;
			}
			else if (num3 < 300f)
			{
				value = (num3 - 240f) * num / 60f + num2;
				value2 = num2;
				value3 = b;
			}
			else if (num3 <= 360f)
			{
				value = b;
				value2 = num2;
				value3 = (0f - (num3 - 360f)) * num / 60f + num2;
			}
			else
			{
				value = 0f;
				value2 = 0f;
				value3 = 0f;
			}
		}
		return new Color(Mathf.Clamp01(value), Mathf.Clamp01(value2), Mathf.Clamp01(value3), hsbColor.A);
	}

	public static Color ConvertRGBColorByHUE(Color rgbColor, float hue)
	{
		float num = ColorToHSV(rgbColor).B;
		if (num < 0.0001f)
		{
			num = 0.0001f;
		}
		HSBColor hsbColor = ColorToHSV(rgbColor / num);
		hsbColor.H = hue;
		Color result = HSVToColor(hsbColor) * num;
		result.a = rgbColor.a;
		return result;
	}

	public static void ChangeObjectColorByHUE(GameObject go, float hue)
	{
		Renderer[] componentsInChildren = go.GetComponentsInChildren<Renderer>(includeInactive: true);
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			Material material = componentsInChildren[i].material;
			if (material == null)
			{
				continue;
			}
			string[] array = colorProperties;
			foreach (string name in array)
			{
				if (material.HasProperty(name))
				{
					setMatHUEColor(material, name, hue);
				}
			}
		}
		ParticleSystemRenderer[] componentsInChildren2 = go.GetComponentsInChildren<ParticleSystemRenderer>(includeInactive: true);
		foreach (ParticleSystemRenderer particleSystemRenderer in componentsInChildren2)
		{
			Material trailMaterial = particleSystemRenderer.trailMaterial;
			if (trailMaterial == null)
			{
				continue;
			}
			trailMaterial = (particleSystemRenderer.trailMaterial = new Material(trailMaterial)
			{
				name = trailMaterial.name + " (Instance)"
			});
			string[] array = colorProperties;
			foreach (string name2 in array)
			{
				if (trailMaterial.HasProperty(name2))
				{
					setMatHUEColor(trailMaterial, name2, hue);
				}
			}
		}
		SkinnedMeshRenderer[] componentsInChildren3 = go.GetComponentsInChildren<SkinnedMeshRenderer>(includeInactive: true);
		for (int i = 0; i < componentsInChildren3.Length; i++)
		{
			Material material3 = componentsInChildren3[i].material;
			if (material3 == null)
			{
				continue;
			}
			string[] array = colorProperties;
			foreach (string name3 in array)
			{
				if (material3.HasProperty(name3))
				{
					setMatHUEColor(material3, name3, hue);
				}
			}
		}
		Projector[] componentsInChildren4 = go.GetComponentsInChildren<Projector>(includeInactive: true);
		foreach (Projector projector in componentsInChildren4)
		{
			if (!projector.material.name.EndsWith("(Instance)"))
			{
				projector.material = new Material(projector.material)
				{
					name = projector.material.name + " (Instance)"
				};
			}
			Material material4 = projector.material;
			if (material4 == null)
			{
				continue;
			}
			string[] array = colorProperties;
			foreach (string name4 in array)
			{
				if (material4.HasProperty(name4))
				{
					projector.material = setMatHUEColor(material4, name4, hue);
				}
			}
		}
		Light[] componentsInChildren5 = go.GetComponentsInChildren<Light>(includeInactive: true);
		foreach (Light obj in componentsInChildren5)
		{
			HSBColor hsbColor = ColorToHSV(obj.color);
			hsbColor.H = hue;
			obj.color = HSVToColor(hsbColor);
		}
		ParticleSystem[] componentsInChildren6 = go.GetComponentsInChildren<ParticleSystem>(includeInactive: true);
		foreach (ParticleSystem obj2 in componentsInChildren6)
		{
			ParticleSystem.MainModule main = obj2.main;
			HSBColor hsbColor2 = ColorToHSV(obj2.main.startColor.color);
			hsbColor2.H = hue;
			main.startColor = HSVToColor(hsbColor2);
			ParticleSystem.ColorOverLifetimeModule colorOverLifetime = obj2.colorOverLifetime;
			ParticleSystem.MinMaxGradient color = colorOverLifetime.color;
			Gradient gradient = colorOverLifetime.color.gradient;
			GradientColorKey[] colorKeys = colorOverLifetime.color.gradient.colorKeys;
			float num = 0f;
			hsbColor2 = ColorToHSV(colorKeys[0].color);
			num = Math.Abs(ColorToHSV(colorKeys[1].color).H - hsbColor2.H);
			hsbColor2.H = hue;
			colorKeys[0].color = HSVToColor(hsbColor2);
			for (int k = 1; k < colorKeys.Length; k++)
			{
				hsbColor2 = ColorToHSV(colorKeys[k].color);
				hsbColor2.H = Mathf.Repeat(hsbColor2.H + num, 1f);
				colorKeys[k].color = HSVToColor(hsbColor2);
			}
			gradient.colorKeys = colorKeys;
			color.gradient = gradient;
			colorOverLifetime.color = color;
		}
		RFX1_ShaderColorGradient[] componentsInChildren7 = go.GetComponentsInChildren<RFX1_ShaderColorGradient>(includeInactive: true);
		for (int i = 0; i < componentsInChildren7.Length; i++)
		{
			componentsInChildren7[i].HUE = hue;
		}
	}

	private static Material setMatHUEColor(Material mat, string name, float hueColor)
	{
		Color value = ConvertRGBColorByHUE(mat.GetColor(name), hueColor);
		mat.SetColor(name, value);
		return mat;
	}

	private static Material setMatAlphaColor(Material mat, string name, float alpha)
	{
		Color color = mat.GetColor(name);
		color.a = alpha;
		mat.SetColor(name, color);
		return mat;
	}
}
public class RFX1_DeactivateByTime : MonoBehaviour
{
	public float DeactivateTime = 3f;

	private void OnEnable()
	{
		Invoke("DeactivateThis", DeactivateTime);
	}

	private void OnDisable()
	{
		CancelInvoke("DeactivateThis");
	}

	private void DeactivateThis()
	{
		base.gameObject.SetActive(value: false);
	}
}
[ExecuteInEditMode]
public class RFX1_ParticleCollisionDecal : MonoBehaviour
{
	public ParticleSystem DecalParticles;

	public bool IsBilboard;

	public bool InstantiateWhenZeroSpeed;

	public float MaxGroundAngleDeviation = 45f;

	public float MinDistanceBetweenDecals = 0.1f;

	public float MinDistanceBetweenSurface = 0.03f;

	private List<ParticleCollisionEvent> collisionEvents = new List<ParticleCollisionEvent>();

	private ParticleSystem.Particle[] particles;

	private ParticleSystem initiatorPS;

	private List<GameObject> collidedGameObjects = new List<GameObject>();

	private void OnEnable()
	{
		collisionEvents.Clear();
		collidedGameObjects.Clear();
		initiatorPS = GetComponent<ParticleSystem>();
		particles = new ParticleSystem.Particle[DecalParticles.main.maxParticles];
		if (InstantiateWhenZeroSpeed)
		{
			InvokeRepeating("CollisionDetect", 0f, 0.1f);
		}
	}

	private void OnDisable()
	{
		if (InstantiateWhenZeroSpeed)
		{
			CancelInvoke("CollisionDetect");
		}
	}

	private void CollisionDetect()
	{
		int aliveParticles = 0;
		if (InstantiateWhenZeroSpeed)
		{
			aliveParticles = DecalParticles.GetParticles(particles);
		}
		foreach (GameObject collidedGameObject in collidedGameObjects)
		{
			OnParticleCollisionManual(collidedGameObject, aliveParticles);
		}
	}

	private void OnParticleCollisionManual(GameObject other, int aliveParticles = -1)
	{
		collisionEvents.Clear();
		int num = initiatorPS.GetCollisionEvents(other, collisionEvents);
		for (int i = 0; i < num; i++)
		{
			if (Vector3.Angle(collisionEvents[i].normal, Vector3.up) > MaxGroundAngleDeviation)
			{
				continue;
			}
			if (InstantiateWhenZeroSpeed)
			{
				if (collisionEvents[i].velocity.sqrMagnitude > 0.1f)
				{
					continue;
				}
				bool flag = false;
				for (int j = 0; j < aliveParticles; j++)
				{
					if (Vector3.Distance(collisionEvents[i].intersection, particles[j].position) < MinDistanceBetweenDecals)
					{
						flag = true;
					}
				}
				if (flag)
				{
					continue;
				}
			}
			ParticleSystem.EmitParams emitParams = default(ParticleSystem.EmitParams);
			emitParams.position = collisionEvents[i].intersection;
			Vector3 eulerAngles = Quaternion.LookRotation(-collisionEvents[i].normal).eulerAngles;
			eulerAngles.z = UnityEngine.Random.Range(0, 360);
			emitParams.rotation3D = eulerAngles;
			DecalParticles.Emit(emitParams, 1);
		}
	}

	private void OnParticleCollision(GameObject other)
	{
		if (InstantiateWhenZeroSpeed)
		{
			if (!collidedGameObjects.Contains(other))
			{
				collidedGameObjects.Add(other);
			}
		}
		else
		{
			OnParticleCollisionManual(other);
		}
	}
}
public class RFX1_ParticleCollisionGameObject : MonoBehaviour
{
	public GameObject InstancedGO;

	public float DestroyDelay = 5f;

	private List<ParticleCollisionEvent> collisionEvents = new List<ParticleCollisionEvent>();

	private ParticleSystem initiatorPS;

	private void OnEnable()
	{
		collisionEvents.Clear();
		initiatorPS = GetComponent<ParticleSystem>();
	}

	private void OnParticleCollision(GameObject other)
	{
		int num = initiatorPS.GetCollisionEvents(other, collisionEvents);
		for (int i = 0; i < num; i++)
		{
			UnityEngine.Object.Destroy(UnityEngine.Object.Instantiate(InstancedGO, collisionEvents[i].intersection, default(Quaternion)), DestroyDelay);
		}
	}
}
[ExecuteInEditMode]
public class RFX1_ParticleGravityPoint : MonoBehaviour
{
	public Transform target;

	public float Force = 1f;

	public AnimationCurve ForceByTime = AnimationCurve.EaseInOut(0f, 1f, 1f, 1f);

	public float ForceLifeTime = 1f;

	private ParticleSystem ps;

	private ParticleSystem.Particle[] particles;

	private ParticleSystem.MainModule mainModule;

	private float startTime;

	private void Start()
	{
		ps = GetComponent<ParticleSystem>();
		mainModule = ps.main;
	}

	private void OnEnable()
	{
		startTime = Time.time;
	}

	private void LateUpdate()
	{
		int maxParticles = mainModule.maxParticles;
		if (particles == null || particles.Length < maxParticles)
		{
			particles = new ParticleSystem.Particle[maxParticles];
		}
		int num = ps.GetParticles(particles);
		float num2 = ForceByTime.Evaluate((Time.time - startTime) / ForceLifeTime) * Time.deltaTime * Force;
		Vector3 vector = Vector3.zero;
		if (mainModule.simulationSpace == ParticleSystemSimulationSpace.Local)
		{
			vector = base.transform.InverseTransformPoint(target.position);
		}
		if (mainModule.simulationSpace == ParticleSystemSimulationSpace.World)
		{
			vector = target.position;
		}
		for (int i = 0; i < num; i++)
		{
			Vector3 vector2 = Vector3.Normalize(vector - particles[i].position) * num2;
			particles[i].velocity += vector2;
		}
		ps.SetParticles(particles, num);
	}
}
public class RFX1_ParticleInfinite : MonoBehaviour
{
	public float Delay = 3f;

	private ParticleSystem ps;

	private ParticleSystem.MainModule main;

	private float oldSimulation;

	private void OnEnable()
	{
		if (ps == null)
		{
			ps = GetComponent<ParticleSystem>();
			main = ps.main;
			oldSimulation = main.simulationSpeed;
		}
		else
		{
			main.simulationSpeed = oldSimulation;
		}
		CancelInvoke("UpdateParticles");
		Invoke("UpdateParticles", Delay);
	}

	private void UpdateParticles()
	{
		main.simulationSpeed = 0f;
	}
}
public class RFX1_ParticlePositionPoint : MonoBehaviour
{
	[HideInInspector]
	public Vector3 Position;

	public RFX1_ShieldCollisionTrigger ShieldCollisionTrigger;

	public float Force = 1f;

	public AnimationCurve ForceByTime = AnimationCurve.EaseInOut(0f, 1f, 1f, 1f);

	public float ForceLifeTime = 1f;

	private bool canUpdate;

	private ParticleSystem ps;

	private ParticleSystem.Particle[] particles;

	private ParticleSystem.MainModule mainModule;

	private float startTime;

	private void Start()
	{
		ShieldCollisionTrigger.CollisionEnter += ShieldCollisionTrigger_CollisionEnter;
		ShieldCollisionTrigger.Detected += ShieldCollisionTrigger_Detected;
		ps = GetComponent<ParticleSystem>();
		mainModule = ps.main;
	}

	private void ShieldCollisionTrigger_Detected(object sender, RFX1_ShieldDetectInfo e)
	{
		if (Physics.Raycast(e.DetectedGameObject.transform.position, e.DetectedGameObject.transform.forward, out var hitInfo, 10f))
		{
			Position = hitInfo.point;
			ManualOnEnable();
		}
	}

	private void ShieldCollisionTrigger_CollisionEnter(object sender, RFX1_ShieldCollisionInfo e)
	{
		Position = e.Hit.point;
		ManualOnEnable();
	}

	public void ManualOnEnable()
	{
		CancelInvoke("ManualOnDisable");
		startTime = Time.time;
		canUpdate = true;
		Invoke("ManualOnDisable", ForceLifeTime);
	}

	private void ManualOnDisable()
	{
		canUpdate = false;
	}

	private void LateUpdate()
	{
		if (canUpdate)
		{
			int maxParticles = mainModule.maxParticles;
			if (particles == null || particles.Length < maxParticles)
			{
				particles = new ParticleSystem.Particle[maxParticles];
			}
			ps.GetParticles(particles);
			float num = ForceByTime.Evaluate((Time.time - startTime) / ForceLifeTime) * Time.deltaTime * Force;
			Vector3 vector = Vector3.zero;
			if (mainModule.simulationSpace == ParticleSystemSimulationSpace.Local)
			{
				vector = base.transform.InverseTransformPoint(Position);
			}
			if (mainModule.simulationSpace == ParticleSystemSimulationSpace.World)
			{
				vector = Position;
			}
			int particleCount = ps.particleCount;
			for (int i = 0; i < particleCount; i++)
			{
				Vector3 vector2 = Vector3.Normalize(vector - particles[i].position) * num;
				particles[i].position += vector2;
			}
			ps.SetParticles(particles, particleCount);
		}
	}
}
public class RFX1_RandomRotate : MonoBehaviour
{
	public int x = 300;

	public int y = 300;

	public int z = 300;

	private float rangeX;

	private float rangeY;

	private float rangeZ;

	private void Start()
	{
		rangeX = (float)UnityEngine.Random.Range(0, 10000) / 100f;
		rangeY = (float)UnityEngine.Random.Range(0, 10000) / 100f;
		rangeZ = (float)UnityEngine.Random.Range(0, 10000) / 100f;
	}

	private void Update()
	{
		base.transform.Rotate(Time.deltaTime * Mathf.Sin(Time.time + rangeX) * (float)x, Time.deltaTime * Mathf.Sin(Time.time + rangeY) * (float)y, Time.deltaTime * Mathf.Sin(Time.time + rangeZ) * (float)z);
	}
}
public class RFX1_RotationFreeze : MonoBehaviour
{
	public bool LockX = true;

	public bool LockY = true;

	public bool LockZ = true;

	private Vector3 startRotation;

	private void Start()
	{
		startRotation = base.transform.localRotation.eulerAngles;
	}

	private void Update()
	{
		float x = (LockX ? startRotation.x : base.transform.rotation.eulerAngles.x);
		float y = (LockY ? startRotation.y : base.transform.rotation.eulerAngles.y);
		float z = (LockZ ? startRotation.z : base.transform.rotation.eulerAngles.z);
		base.transform.rotation = Quaternion.Euler(x, y, z);
	}
}
public class RFX1_ShieldCollisionTrigger : MonoBehaviour
{
	public float DetectRange;

	public GameObject[] EffectOnCollision;

	public float DestroyTimeDelay = 5f;

	public bool CollisionEffectInWorldSpace = true;

	public float CollisionOffset;

	private const string layerName = "Collision";

	public event EventHandler<RFX1_ShieldCollisionInfo> CollisionEnter;

	public event EventHandler<RFX1_ShieldDetectInfo> Detected;

	private void Start()
	{
	}

	private void Update()
	{
		if (DetectRange < 0.001f)
		{
			return;
		}
		Collider[] array = Physics.OverlapSphere(base.transform.position, DetectRange);
		foreach (Collider collider in array)
		{
			if (collider.name.EndsWith("Collision"))
			{
				this.Detected?.Invoke(this, new RFX1_ShieldDetectInfo
				{
					DetectedGameObject = collider.gameObject
				});
			}
		}
	}

	private void OnDrawGizmosSelected()
	{
		if (!UnityEngine.Application.isPlaying)
		{
			Gizmos.color = Color.blue;
			Gizmos.DrawWireSphere(base.transform.position, DetectRange);
		}
	}

	public void OnCollision(RaycastHit hit, GameObject sender = null)
	{
		this.CollisionEnter?.Invoke(this, new RFX1_ShieldCollisionInfo
		{
			Hit = hit
		});
		GameObject[] effectOnCollision = EffectOnCollision;
		for (int i = 0; i < effectOnCollision.Length; i++)
		{
			GameObject gameObject = UnityEngine.Object.Instantiate(effectOnCollision[i], hit.point + hit.normal * CollisionOffset, default(Quaternion));
			gameObject.transform.LookAt(hit.point + hit.normal + hit.normal * CollisionOffset);
			if (!CollisionEffectInWorldSpace)
			{
				gameObject.transform.parent = base.transform;
			}
			UnityEngine.Object.Destroy(gameObject, DestroyTimeDelay);
		}
	}
}
public class RFX1_ShieldCollisionInfo : EventArgs
{
	public RaycastHit Hit;
}
public class RFX1_ShieldDetectInfo : EventArgs
{
	public GameObject DetectedGameObject;
}
public class RFX1_SimpleDecal : MonoBehaviour
{
	public float Offset = 0.05f;

	private Transform t;

	private RaycastHit hit;

	private void Awake()
	{
		t = base.transform;
	}

	private void LateUpdate()
	{
		if (Physics.Raycast(t.parent.position + Vector3.up / 2f, Vector3.down, out hit))
		{
			base.transform.position = hit.point + Vector3.up * Offset;
			base.transform.rotation = Quaternion.LookRotation(-hit.normal);
		}
	}
}
public class RFX1_StartDelay : MonoBehaviour
{
	public GameObject ActivatedGameObject;

	public float Delay = 1f;

	private void OnEnable()
	{
		ActivatedGameObject.SetActive(value: false);
		Invoke("ActivateGO", Delay);
	}

	private void ActivateGO()
	{
		ActivatedGameObject.SetActive(value: true);
	}

	private void OnDisable()
	{
		CancelInvoke("ActivateGO");
	}
}
public enum RFX1_TextureShaderProperties
{
	_MainTex,
	_DistortTex,
	_Mask,
	_Cutout,
	_CutoutTex,
	_Bump,
	_BumpTex,
	_EmissionTex
}
public class RFX1_TransformMotion : MonoBehaviour
{
	public enum RFX4_SimulationSpace
	{
		Local,
		World
	}

	public class RFX1_CollisionInfo : EventArgs
	{
		public RaycastHit Hit;
	}

	public float Distance = 30f;

	public float Speed = 1f;

	public float TimeDelay;

	public float RandomMoveRadius;

	public float RandomMoveSpeedScale;

	public GameObject Target;

	public LayerMask CollidesWith = -1;

	public GameObject[] EffectsOnCollision;

	public float CollisionOffset;

	public float DestroyTimeDelay = 5f;

	public bool CollisionEffectInWorldSpace = true;

	public GameObject[] DeactivatedObjectsOnCollision;

	[HideInInspector]
	public float HUE = -1f;

	[HideInInspector]
	public List<GameObject> CollidedInstances;

	private Vector3 startPosition;

	private Vector3 startPositionLocal;

	private Transform t;

	private Transform targetT;

	private Vector3 oldPos;

	private bool isCollided;

	private bool isOutDistance;

	private Quaternion startQuaternion;

	private float currentDelay;

	private const float RayCastTolerance = 0.15f;

	private bool isInitialized;

	private bool dropFirstFrameForFixUnityBugWithParticles;

	private Vector3 randomTimeOffset;

	public event EventHandler<RFX1_CollisionInfo> CollisionEnter;

	private void Start()
	{
		t = base.transform;
		if (Target != null)
		{
			targetT = Target.transform;
		}
		startQuaternion = t.rotation;
		startPositionLocal = t.localPosition;
		startPosition = t.position;
		oldPos = t.TransformPoint(startPositionLocal);
		Initialize();
		isInitialized = true;
	}

	private void OnEnable()
	{
		if (isInitialized)
		{
			Initialize();
		}
	}

	private void OnDisable()
	{
		if (isInitialized)
		{
			Initialize();
		}
	}

	private void Initialize()
	{
		isCollided = false;
		isOutDistance = false;
		currentDelay = 0f;
		startQuaternion = t.rotation;
		t.localPosition = startPositionLocal;
		oldPos = t.TransformPoint(startPositionLocal);
		OnCollisionDeactivateBehaviour(active: true);
		dropFirstFrameForFixUnityBugWithParticles = true;
		randomTimeOffset = UnityEngine.Random.insideUnitSphere * 10f;
	}

	private void Update()
	{
		if (!dropFirstFrameForFixUnityBugWithParticles)
		{
			UpdateWorldPosition();
		}
		else
		{
			dropFirstFrameForFixUnityBugWithParticles = false;
		}
	}

	private void UpdateWorldPosition()
	{
		currentDelay += Time.deltaTime;
		if (currentDelay < TimeDelay)
		{
			return;
		}
		Vector3 vector = Vector3.zero;
		if (RandomMoveRadius > 0f)
		{
			vector = GetRadiusRandomVector() * RandomMoveRadius;
			if (Target != null)
			{
				if (targetT == null)
				{
					targetT = Target.transform;
				}
				float num = Vector3.Distance(t.position, targetT.position) / Vector3.Distance(startPosition, targetT.position);
				vector *= num;
			}
		}
		Vector3 vector2 = Vector3.zero;
		Vector3 vector3 = Vector3.zero;
		if (!isCollided && !isOutDistance)
		{
			if (Target == null)
			{
				Vector3 vector4 = (Vector3.forward + vector) * Speed * Time.deltaTime;
				vector2 = t.localRotation * vector4;
				vector3 = startQuaternion * vector4;
			}
			else
			{
				vector3 = (vector2 = ((targetT.position - t.position).normalized + vector) * Speed * Time.deltaTime);
			}
		}
		float magnitude = (t.localPosition + vector2 - startPositionLocal).magnitude;
		UnityEngine.Debug.DrawRay(t.position, vector3.normalized * (Distance - magnitude));
		if (!isCollided && Physics.Raycast(t.position, vector3.normalized, out var hitInfo, Distance, CollidesWith) && vector2.magnitude + 0.15f > hitInfo.distance)
		{
			isCollided = true;
			t.position = hitInfo.point;
			oldPos = t.position;
			OnCollisionBehaviour(hitInfo);
			OnCollisionDeactivateBehaviour(active: false);
		}
		else if (!isOutDistance && magnitude + 0.15f > Distance)
		{
			isOutDistance = true;
			OnCollisionDeactivateBehaviour(active: false);
			if (Target == null)
			{
				t.localPosition = startPositionLocal + t.localRotation * (Vector3.forward + vector) * Distance;
			}
			else
			{
				Vector3 normalized = (targetT.position - t.position).normalized;
				t.position = startPosition + normalized * Distance;
			}
			oldPos = t.position;
		}
		else
		{
			t.position = oldPos + vector3;
			oldPos = t.position;
		}
	}

	private Vector3 GetRadiusRandomVector()
	{
		float num = Time.time * RandomMoveSpeedScale + randomTimeOffset.x;
		float x = Mathf.Sin(num / 7f + Mathf.Cos(num / 2f)) * Mathf.Cos(num / 5f + Mathf.Sin(num));
		num = Time.time * RandomMoveSpeedScale + randomTimeOffset.y;
		float y = Mathf.Cos(num / 8f + Mathf.Sin(num / 2f)) * Mathf.Sin(Mathf.Sin(num / 1.2f) + num * 1.2f);
		num = Time.time * RandomMoveSpeedScale + randomTimeOffset.z;
		float z = Mathf.Cos(num * 0.7f + Mathf.Cos(num * 0.5f)) * Mathf.Cos(Mathf.Sin(num * 0.8f) + num * 0.3f);
		return new Vector3(x, y, z);
	}

	private void OnCollisionBehaviour(RaycastHit hit)
	{
		this.CollisionEnter?.Invoke(this, new RFX1_CollisionInfo
		{
			Hit = hit
		});
		CollidedInstances.Clear();
		GameObject[] effectsOnCollision = EffectsOnCollision;
		for (int i = 0; i < effectsOnCollision.Length; i++)
		{
			GameObject gameObject = UnityEngine.Object.Instantiate(effectsOnCollision[i], hit.point + hit.normal * CollisionOffset, default(Quaternion));
			CollidedInstances.Add(gameObject);
			if (HUE > -0.9f)
			{
				RFX1_EffectSettingColor rFX1_EffectSettingColor = gameObject.AddComponent<RFX1_EffectSettingColor>();
				RFX1_ColorHelper.HSBColor hsbColor = RFX1_ColorHelper.ColorToHSV(rFX1_EffectSettingColor.Color);
				hsbColor.H = HUE;
				rFX1_EffectSettingColor.Color = RFX1_ColorHelper.HSVToColor(hsbColor);
			}
			gameObject.transform.LookAt(hit.point + hit.normal + hit.normal * CollisionOffset);
			if (!CollisionEffectInWorldSpace)
			{
				gameObject.transform.parent = base.transform;
			}
			UnityEngine.Object.Destroy(gameObject, DestroyTimeDelay);
		}
	}

	private void OnCollisionDeactivateBehaviour(bool active)
	{
		GameObject[] deactivatedObjectsOnCollision = DeactivatedObjectsOnCollision;
		foreach (GameObject gameObject in deactivatedObjectsOnCollision)
		{
			if (gameObject != null)
			{
				gameObject.SetActive(active);
			}
		}
	}

	private void OnDrawGizmosSelected()
	{
		if (!UnityEngine.Application.isPlaying)
		{
			t = base.transform;
			Gizmos.color = Color.blue;
			Gizmos.DrawLine(t.position, t.position + t.forward * Distance);
		}
	}
}
public class RFX1_UVAnimation : MonoBehaviour
{
	public int TilesX = 4;

	public int TilesY = 4;

	public int FPS = 30;

	public float StartDelay;

	public bool IsLoop = true;

	public bool IsReverse;

	public bool IsInterpolateFrames;

	public bool IsParticleSystemTrail;

	public RFX1_TextureShaderProperties[] TextureNames = new RFX1_TextureShaderProperties[1];

	public AnimationCurve FrameOverTime = AnimationCurve.Linear(0f, 1f, 1f, 1f);

	private Renderer currentRenderer;

	private Projector projector;

	private Material instanceMaterial;

	private float animationStartTime;

	private bool canUpdate;

	private int previousIndex;

	private int totalFrames;

	private float currentInterpolatedTime;

	private int currentIndex;

	private Vector2 size;

	private bool isInitialized;

	private bool startDelayIsBroken;

	private ParticleSystemRenderer pr;

	private void OnEnable()
	{
		if (isInitialized)
		{
			InitDefaultVariables();
		}
	}

	private void Start()
	{
		InitDefaultVariables();
		isInitialized = true;
	}

	private void Update()
	{
		if (startDelayIsBroken)
		{
			ManualUpdate();
		}
	}

	private void ManualUpdate()
	{
		if (canUpdate)
		{
			UpdateMaterial();
			SetSpriteAnimation();
			if (IsInterpolateFrames)
			{
				SetSpriteAnimationIterpolated();
			}
		}
	}

	private void StartDelayFunc()
	{
		startDelayIsBroken = true;
		animationStartTime = Time.time;
	}

	private void InitDefaultVariables()
	{
		InitializeMaterial();
		totalFrames = TilesX * TilesY;
		previousIndex = 0;
		canUpdate = true;
		Vector3 zero = Vector3.zero;
		size = new Vector2(1f / (float)TilesX, 1f / (float)TilesY);
		animationStartTime = Time.time;
		if (StartDelay > 1E-05f)
		{
			startDelayIsBroken = false;
			Invoke("StartDelayFunc", StartDelay);
		}
		else
		{
			startDelayIsBroken = true;
		}
		if (instanceMaterial != null)
		{
			RFX1_TextureShaderProperties[] textureNames = TextureNames;
			for (int i = 0; i < textureNames.Length; i++)
			{
				RFX1_TextureShaderProperties rFX1_TextureShaderProperties = textureNames[i];
				instanceMaterial.SetTextureScale(rFX1_TextureShaderProperties.ToString(), size);
				instanceMaterial.SetTextureOffset(rFX1_TextureShaderProperties.ToString(), zero);
			}
		}
	}

	private void InitializeMaterial()
	{
		if (IsParticleSystemTrail)
		{
			pr = GetComponent<ParticleSystem>().GetComponent<ParticleSystemRenderer>();
			currentRenderer = pr;
			instanceMaterial = pr.trailMaterial;
			if (!instanceMaterial.name.EndsWith("(Instance)"))
			{
				instanceMaterial = new Material(instanceMaterial)
				{
					name = instanceMaterial.name + " (Instance)"
				};
			}
			pr.trailMaterial = instanceMaterial;
			return;
		}
		currentRenderer = GetComponent<Renderer>();
		if (currentRenderer == null)
		{
			projector = GetComponent<Projector>();
			if (projector != null)
			{
				if (!projector.material.name.EndsWith("(Instance)"))
				{
					projector.material = new Material(projector.material)
					{
						name = projector.material.name + " (Instance)"
					};
				}
				instanceMaterial = projector.material;
			}
		}
		else
		{
			instanceMaterial = currentRenderer.material;
		}
	}

	private void UpdateMaterial()
	{
		if (currentRenderer == null)
		{
			if (projector != null)
			{
				if (!projector.material.name.EndsWith("(Instance)"))
				{
					projector.material = new Material(projector.material)
					{
						name = projector.material.name + " (Instance)"
					};
				}
				instanceMaterial = projector.material;
			}
		}
		else if (!IsParticleSystemTrail)
		{
			instanceMaterial = currentRenderer.material;
		}
	}

	private void SetSpriteAnimation()
	{
		int num = (int)((Time.time - animationStartTime) * (float)FPS);
		num %= totalFrames;
		if (!IsLoop && num < previousIndex)
		{
			canUpdate = false;
			return;
		}
		if (IsInterpolateFrames && num != previousIndex)
		{
			currentInterpolatedTime = 0f;
		}
		previousIndex = num;
		if (IsReverse)
		{
			num = totalFrames - num - 1;
		}
		int num2 = num % TilesX;
		int num3 = num / TilesX;
		float x = (float)num2 * size.x;
		float y = 1f - size.y - (float)num3 * size.y;
		Vector2 value = new Vector2(x, y);
		if (instanceMaterial != null)
		{
			RFX1_TextureShaderProperties[] textureNames = TextureNames;
			for (int i = 0; i < textureNames.Length; i++)
			{
				RFX1_TextureShaderProperties rFX1_TextureShaderProperties = textureNames[i];
				instanceMaterial.SetTextureScale(rFX1_TextureShaderProperties.ToString(), size);
				instanceMaterial.SetTextureOffset(rFX1_TextureShaderProperties.ToString(), value);
			}
		}
	}

	private void SetSpriteAnimationIterpolated()
	{
		currentInterpolatedTime += Time.deltaTime;
		int num = previousIndex + 1;
		if (num == totalFrames)
		{
			num = previousIndex;
		}
		if (IsReverse)
		{
			num = totalFrames - num - 1;
		}
		int num2 = num % TilesX;
		int num3 = num / TilesX;
		float x = (float)num2 * size.x;
		float y = 1f - size.y - (float)num3 * size.y;
		Vector2 vector = new Vector2(x, y);
		if (instanceMaterial != null)
		{
			instanceMaterial.SetVector("_Tex_NextFrame", new Vector4(size.x, size.y, vector.x, vector.y));
			instanceMaterial.SetFloat("InterpolationValue", Mathf.Clamp01(currentInterpolatedTime * (float)FPS));
		}
	}
}
[ExecuteInEditMode]
public class RFX4_LocalSpaceFix : MonoBehaviour
{
	private void Update()
	{
		Matrix4x4 worldToLocalMatrix = base.transform.worldToLocalMatrix;
		ParticleSystemRenderer component = GetComponent<ParticleSystemRenderer>();
		if (component != null)
		{
			if (UnityEngine.Application.isPlaying)
			{
				component.material.SetMatrix("_InverseTransformMatrix", worldToLocalMatrix);
			}
			else
			{
				component.sharedMaterial.SetMatrix("_InverseTransformMatrix", worldToLocalMatrix);
			}
		}
	}
}
public class DetectInternetSpeed : MonoBehaviour
{
	private void Start()
	{
		StartCoroutine(CallWebPage());
	}

	private IEnumerator CallWebPage()
	{
		_ = DateTime.Now;
		yield return new WWW("https://static.pexels.com/photos/20974/pexels-photo.jpg");
		_ = DateTime.Now;
	}
}
public class HandheldPlayback : MonoBehaviour
{
	private RequestResolver resolver;

	private string videoUrl;

	public static HandheldPlayback instance;

	private Action videoFinishCallback;

	private void Start()
	{
		instance = this;
		resolver = base.gameObject.AddComponent<RequestResolver>();
	}

	public void PlayVideo(string url, Action OnVideoFinished)
	{
		videoFinishCallback = OnVideoFinished;
		StartCoroutine(resolver.GetDownloadUrls(FinishLoadingUrls, url, decryptSignature: false));
	}

	private void FinishLoadingUrls()
	{
		foreach (VideoInfo videoInfo in resolver.videoInfos)
		{
			if (videoInfo.VideoType == VideoType.Mp4 && videoInfo.Resolution == 720)
			{
				if (videoInfo.RequiresDecryption)
				{
					StartCoroutine(resolver.DecryptDownloadUrl(DecryptionFinished, videoInfo));
				}
				else
				{
					StartCoroutine(Play(videoInfo.DownloadUrl));
				}
				break;
			}
		}
	}

	public void DecryptionFinished(string url)
	{
		StartCoroutine(Play(url));
	}

	private IEnumerator Play(string url)
	{
		UnityEngine.Debug.Log("Play!");
		Handheld.PlayFullScreenMovie(url, Color.black, FullScreenMovieControlMode.Full, FullScreenMovieScalingMode.Fill);
		yield return new WaitForSeconds(1f);
		videoFinishCallback();
	}
}
public class HighQualityPlayback : MonoBehaviour
{
	public enum VideoQuality
	{
		mediumQuality,
		Hd720,
		Hd1080,
		Hd1440,
		Hd2160
	}

	[Header("Enable to use new experimental version")]
	public bool getFromWebserver;

	public string videoId = "bc0sJvtKrRM";

	public VideoQuality videoQuality;

	private string videoUrl;

	private string audioVideoUrl;

	private bool videoAreReadyToPlay;

	public bool useNewUnityPlayer;

	public VideoPlayer unityVideoPlayer;

	public bool playOnStart;

	[HideInInspector]
	public bool noHD;

	private RequestResolver resolver;

	private float lastPlayTime;

	private bool audioDecryptDone;

	private bool videoDecryptDone;

	public VideoPlayer audioVplayer;

	private bool checkIfVideoArePrepared;

	private float lastVideoReadyToPlay;

	private bool videoPrepared;

	private bool audioPrepared;

	[HideInInspector]
	public bool isSyncing;

	[Header("If you think audio is out of sync enable this bool below")]
	[Header("This happens in some unity versions, the most stable is the 5.6.1p1")]
	public bool syncIssue;

	[SerializeField]
	public YoutubeResultIds newRequestResults;

	private const string serverURI = "https://unity-dev-youtube.herokuapp.com/api/info?url=https://www.youtube.com/watch?v=";

	private const string formatURI = "&format=best&flatten=true";

	private const string VIDEOURIFORWEBGLPLAYER = "https://youtubewebgl.herokuapp.com/download.php?mime=video/mp4&title=generatedvideo&token=";

	private long lastFrameReady;

	private float lastFrameReadyTime;

	private bool isRetry;

	private VideoQuality lastTryQuality = VideoQuality.Hd2160;

	private string lastTryVideoId;

	private float lastStartedTime;

	private float lastErrorTime;

	public void Start()
	{
		if (videoQuality == VideoQuality.Hd720)
		{
			noHD = true;
		}
		unityVideoPlayer.started += VideoStarted;
		unityVideoPlayer.errorReceived += VideoErrorReceived;
		unityVideoPlayer.frameDropped += VideoFrameDropped;
		unityVideoPlayer.sendFrameReadyEvents = true;
		unityVideoPlayer.frameReady += VideoFrameReady;
		resolver = base.gameObject.AddComponent<RequestResolver>();
		if (UnityEngine.Application.isMobilePlatform && GetMaxQualitySupportedByDevice() <= 720)
		{
			if (videoQuality != 0)
			{
				videoQuality = VideoQuality.Hd720;
			}
			noHD = true;
		}
		if (playOnStart)
		{
			PlayYoutubeVideo(videoId);
		}
	}

	public void PlayYoutubeVideo(string _videoId)
	{
		if (GetComponent<VideoController>() != null)
		{
			GetComponent<VideoController>().ShowLoading("Loading...");
		}
		videoId = _videoId;
		isRetry = false;
		lastTryQuality = videoQuality;
		lastTryVideoId = _videoId;
		lastPlayTime = Time.time;
		lastVideoReadyToPlay = 0f;
		if (!getFromWebserver)
		{
			StartCoroutine(resolver.GetDownloadUrls(FinishLoadingUrls, videoId, decryptSignature: false));
		}
		else
		{
			StartCoroutine(NewRequest(videoId));
		}
	}

	private void FinishLoadingUrls()
	{
		List<VideoInfo> videoInfos = resolver.videoInfos;
		videoDecryptDone = false;
		audioDecryptDone = false;
		foreach (VideoInfo item in videoInfos)
		{
			if (item.VideoType == VideoType.Mp4 && item.Resolution == 360)
			{
				if (item.RequiresDecryption)
				{
					StartCoroutine(resolver.DecryptDownloadUrl(DecryptAudioDone, item));
				}
				else
				{
					audioVideoUrl = item.DownloadUrl;
				}
				break;
			}
		}
		int num = 360;
		switch (videoQuality)
		{
		case VideoQuality.mediumQuality:
			num = 360;
			break;
		case VideoQuality.Hd720:
			num = 720;
			break;
		case VideoQuality.Hd1080:
			num = 1080;
			break;
		case VideoQuality.Hd1440:
			num = 1440;
			break;
		case VideoQuality.Hd2160:
			num = 2160;
			break;
		}
		bool flag = false;
		foreach (VideoInfo item2 in videoInfos)
		{
			if (item2.VideoType == VideoType.Mp4 && item2.Resolution == num)
			{
				if (item2.RequiresDecryption)
				{
					StartCoroutine(resolver.DecryptDownloadUrl(DecryptVideoDone, item2));
				}
				else
				{
					videoUrl = item2.DownloadUrl;
					videoAreReadyToPlay = true;
				}
				flag = true;
				break;
			}
		}
		if (!flag && num == 2160)
		{
			foreach (VideoInfo item3 in videoInfos)
			{
				if (item3.FormatCode == 313)
				{
					UnityEngine.Debug.Log("Found but with unknow format in results, check to see if the video works normal.");
					if (item3.RequiresDecryption)
					{
						StartCoroutine(resolver.DecryptDownloadUrl(DecryptVideoDone, item3));
					}
					else
					{
						videoUrl = item3.DownloadUrl;
						videoAreReadyToPlay = true;
					}
					flag = true;
					break;
				}
			}
		}
		if (flag)
		{
			return;
		}
		UnityEngine.Debug.Log("Desired quality not found, playing with low quality, check if the video id: " + videoId + " support that quality!");
		foreach (VideoInfo item4 in videoInfos)
		{
			if (item4.VideoType == VideoType.Mp4 && item4.Resolution == 360)
			{
				if (item4.RequiresDecryption)
				{
					StartCoroutine(resolver.DecryptDownloadUrl(DecryptVideoDone, item4));
					break;
				}
				videoUrl = item4.DownloadUrl;
				videoAreReadyToPlay = true;
				break;
			}
		}
	}

	public void DecryptAudioDone(string url)
	{
		audioVideoUrl = url;
		audioDecryptDone = true;
		if (videoDecryptDone)
		{
			videoAreReadyToPlay = true;
		}
	}

	public void DecryptVideoDone(string url)
	{
		videoUrl = url;
		videoDecryptDone = true;
		if (audioDecryptDone)
		{
			videoAreReadyToPlay = true;
		}
	}

	private void FixedUpdate()
	{
		if (videoAreReadyToPlay)
		{
			videoAreReadyToPlay = false;
			lastVideoReadyToPlay = Time.time;
			if (!useNewUnityPlayer)
			{
				StartHandheldVideo();
			}
			else
			{
				UnityEngine.Debug.Log("Play!!" + videoUrl);
				lastVideoReadyToPlay = Time.time;
				unityVideoPlayer.source = VideoSource.Url;
				unityVideoPlayer.url = videoUrl;
				checkIfVideoArePrepared = true;
				unityVideoPlayer.Prepare();
				if (!noHD)
				{
					audioVplayer.source = VideoSource.Url;
					audioVplayer.url = audioVideoUrl;
					audioVplayer.Prepare();
				}
			}
		}
		if (checkIfVideoArePrepared)
		{
			checkIfVideoArePrepared = false;
			videoPrepared = false;
			unityVideoPlayer.prepareCompleted += VideoPrepared;
			if (!noHD)
			{
				audioPrepared = false;
				audioVplayer.prepareCompleted += AudioPrepared;
			}
		}
		CheckIfIsDesync();
	}

	private void AudioPrepared(VideoPlayer vPlayer)
	{
		audioVplayer.prepareCompleted -= AudioPrepared;
		audioPrepared = true;
		if (audioPrepared && videoPrepared)
		{
			Play();
		}
	}

	private void VideoPrepared(VideoPlayer vPlayer)
	{
		unityVideoPlayer.prepareCompleted -= VideoPrepared;
		videoPrepared = true;
		if (noHD)
		{
			Play();
		}
		else if (audioPrepared && videoPrepared)
		{
			Play();
		}
	}

	public void Play()
	{
		unityVideoPlayer.loopPointReached += PlaybackDone;
		StartCoroutine(WaitAndPlay());
	}

	private void PlaybackDone(VideoPlayer vPlayer)
	{
		OnVideoFinished();
	}

	private IEnumerator WaitAndPlay()
	{
		if (!noHD)
		{
			audioVplayer.Play();
			if (syncIssue)
			{
				yield return new WaitForSeconds(0.35f);
			}
			else
			{
				yield return new WaitForSeconds(0f);
			}
		}
		else if (syncIssue)
		{
			yield return new WaitForSeconds(1f);
		}
		else
		{
			yield return new WaitForSeconds(0f);
		}
		unityVideoPlayer.Play();
		if (GetComponent<VideoController>() != null)
		{
			GetComponent<VideoController>().HideLoading();
		}
	}

	private void StartHandheldVideo()
	{
		UnityEngine.Debug.Log("P");
		base.gameObject.AddComponent<HandheldPlayback>().PlayVideo(videoUrl, OnVideoFinished);
	}

	public void OnVideoFinished()
	{
		if (unityVideoPlayer.isPrepared)
		{
			UnityEngine.Debug.Log("Finished");
			if (unityVideoPlayer.isLooping)
			{
				unityVideoPlayer.time = 0.0;
				unityVideoPlayer.frame = 0L;
				audioVplayer.time = 0.0;
				audioVplayer.frame = 0L;
				unityVideoPlayer.Play();
				audioVplayer.Play();
			}
		}
	}

	private void CheckIfIsDesync()
	{
		if (isRetry || !(lastFrameReadyTime < Time.time - 1f) || !(lastFrameReadyTime > Time.time - 5f))
		{
			if (!isRetry && lastFrameReadyTime < Time.time - 5f && unityVideoPlayer.frame > 0 && unityVideoPlayer.frameCount != 0)
			{
				UnityEngine.Debug.Log("Dropping frames, retry with low quality!: " + lastFrameReadyTime + " " + lastFrameReady);
				lastTryQuality = VideoQuality.mediumQuality;
				RetryPlayYoutubeVideo();
			}
			else if (!isRetry && lastStartedTime < lastPlayTime && lastPlayTime < Time.time - 5f && lastVideoReadyToPlay > lastPlayTime && lastVideoReadyToPlay < Time.time - 5f)
			{
				UnityEngine.Debug.Log("Starting time out, retry with low quality!: " + lastFrameReadyTime + " " + lastFrameReady);
				lastTryQuality = VideoQuality.mediumQuality;
				RetryPlayYoutubeVideo();
			}
			else if (!isRetry && lastStartedTime < lastErrorTime && lastErrorTime > lastPlayTime)
			{
				UnityEngine.Debug.Log("Error detected!, retry with low quality!");
				lastTryQuality = VideoQuality.mediumQuality;
				RetryPlayYoutubeVideo();
			}
		}
	}

	private void Sync()
	{
		if (!(UnityEngine.Object.FindObjectOfType<VideoController>() != null))
		{
			UnityEngine.Debug.LogWarning("Please add a video controller to your scene to make the sync work! Will be improved in the future.");
		}
	}

	public int GetMaxQualitySupportedByDevice()
	{
		if (Screen.orientation == ScreenOrientation.LandscapeLeft)
		{
			return Screen.currentResolution.height;
		}
		if (Screen.orientation == ScreenOrientation.Portrait)
		{
			return Screen.currentResolution.width;
		}
		return Screen.currentResolution.height;
	}

	private IEnumerator NewRequest(string videoID)
	{
		WWW request = new WWW("https://unity-dev-youtube.herokuapp.com/api/info?url=https://www.youtube.com/watch?v=" + videoID + "&format=best&flatten=true");
		yield return request;
		JSONNode jSONNode = JSON.Parse(request.text);
		JSONNode jSONNode2 = jSONNode["videos"][0]["formats"];
		newRequestResults.bestFormatWithAudioIncluded = jSONNode["videos"][0]["url"];
		for (int i = 0; i < jSONNode2.Count; i++)
		{
			if (jSONNode2[i]["format_id"] == (object)"160")
			{
				newRequestResults.lowQuality = jSONNode2[i]["url"];
			}
			else if (jSONNode2[i]["format_id"] == (object)"133")
			{
				newRequestResults.lowQuality = jSONNode2[i]["url"];
			}
			else if (jSONNode2[i]["format_id"] == (object)"134")
			{
				newRequestResults.standardQuality = jSONNode2[i]["url"];
			}
			else if (jSONNode2[i]["format_id"] == (object)"135")
			{
				newRequestResults.mediumQuality = jSONNode2[i]["url"];
			}
			else if (jSONNode2[i]["format_id"] == (object)"136")
			{
				newRequestResults.hdQuality = newRequestResults.bestFormatWithAudioIncluded;
			}
			else if (jSONNode2[i]["format_id"] == (object)"137")
			{
				newRequestResults.fullHdQuality = jSONNode2[i]["url"];
			}
			else if (jSONNode2[i]["format_id"] == (object)"266")
			{
				newRequestResults.ultraHdQuality = jSONNode2[i]["url"];
			}
			else if (jSONNode2[i]["format_id"] == (object)"139")
			{
				newRequestResults.audioUrl = jSONNode2[i]["url"];
			}
		}
		audioVideoUrl = newRequestResults.bestFormatWithAudioIncluded;
		videoUrl = newRequestResults.lowQuality;
		switch (videoQuality)
		{
		case VideoQuality.mediumQuality:
			videoUrl = newRequestResults.mediumQuality;
			break;
		case VideoQuality.Hd720:
			videoUrl = newRequestResults.hdQuality;
			break;
		case VideoQuality.Hd1080:
			videoUrl = newRequestResults.fullHdQuality;
			break;
		}
		videoAreReadyToPlay = true;
	}

	private string ConvertToWebglUrl(string url)
	{
		string text = Convert.ToBase64String(Encoding.UTF8.GetBytes(url));
		UnityEngine.Debug.Log(url);
		return "https://youtubewebgl.herokuapp.com/download.php?mime=video/mp4&title=generatedvideo&token=" + text;
	}

	private void VideoFrameReady(VideoPlayer source, long frameIdx)
	{
		lastFrameReady = frameIdx;
		lastFrameReadyTime = Time.time;
	}

	public void RetryPlayYoutubeVideo()
	{
		if (!getFromWebserver)
		{
			StopIfPlaying();
			UnityEngine.Debug.Log("Youtube Retrying...:" + lastTryVideoId);
			isRetry = true;
			if (GetComponent<VideoController>() != null)
			{
				GetComponent<VideoController>().ShowLoading("Loading...");
			}
			videoId = lastTryVideoId;
			StartCoroutine(resolver.GetDownloadUrls(FinishLoadingUrls, videoId, decryptSignature: false));
		}
	}

	private void StopIfPlaying()
	{
		UnityEngine.Debug.Log("Stopping video");
		if (unityVideoPlayer.isPlaying)
		{
			unityVideoPlayer.Stop();
		}
		if (audioVplayer.isPlaying)
		{
			audioVplayer.Stop();
		}
	}

	private void VideoFrameDropped(VideoPlayer source)
	{
		UnityEngine.Debug.Log("Youtube VideoFrameDropped!");
	}

	private void VideoStarted(VideoPlayer source)
	{
		lastStartedTime = Time.time;
		lastFrameReadyTime = lastStartedTime;
		lastErrorTime = lastStartedTime;
		UnityEngine.Debug.Log("Youtube Video Started");
	}

	private void VideoErrorReceived(VideoPlayer source, string message)
	{
		lastErrorTime = Time.time;
		UnityEngine.Debug.Log("Youtube VideoErrorReceived!:" + message);
	}
}
public class MultiVideoDemo : MonoBehaviour
{
	public string videoId = "bc0sJvtKrRM";

	private string videoUrl;

	private bool videoAreReadyToPlay;

	public bool useNewUnityPlayer;

	public VideoPlayer unityVideoPlayer;

	public GameObject[] objectsToPlayTheSameVIdeo;

	public bool playOnStart;

	private RequestResolver resolver;

	private bool checkIfVideoArePrepared;

	public void Start()
	{
		resolver = base.gameObject.AddComponent<RequestResolver>();
		if (playOnStart)
		{
			PlayYoutubeVideo(videoId);
		}
	}

	public void PlayYoutubeVideo(string _videoId)
	{
		videoId = _videoId;
		StartCoroutine(resolver.GetDownloadUrls(FinishLoadingUrls, videoId, decryptSignature: false));
	}

	private void FinishLoadingUrls()
	{
		foreach (VideoInfo videoInfo in resolver.videoInfos)
		{
			if (videoInfo.VideoType == VideoType.Mp4 && videoInfo.Resolution == 360)
			{
				if (videoInfo.RequiresDecryption)
				{
					StartCoroutine(resolver.DecryptDownloadUrl(DecryptDone, videoInfo));
					break;
				}
				videoUrl = videoInfo.DownloadUrl;
				videoAreReadyToPlay = true;
				break;
			}
		}
	}

	public void DecryptDone(string url)
	{
		videoUrl = url;
		videoAreReadyToPlay = true;
	}

	private void FixedUpdate()
	{
		if (videoAreReadyToPlay)
		{
			videoAreReadyToPlay = false;
			if (!useNewUnityPlayer)
			{
				StartCoroutine(StartVideo());
			}
			else
			{
				UnityEngine.Debug.Log("Play!!" + videoUrl);
				unityVideoPlayer.source = VideoSource.Url;
				unityVideoPlayer.url = videoUrl;
				unityVideoPlayer.Prepare();
				checkIfVideoArePrepared = true;
			}
		}
		if (checkIfVideoArePrepared && unityVideoPlayer.isPrepared)
		{
			checkIfVideoArePrepared = false;
			StartCoroutine(PreparingAudio());
		}
	}

	private IEnumerator PreparingAudio()
	{
		WaitForSeconds waitForSeconds = new WaitForSeconds(1f);
		if (!unityVideoPlayer.isPrepared)
		{
			UnityEngine.Debug.Log("Preparing Video");
			yield return waitForSeconds;
		}
		UnityEngine.Debug.Log("Done Preparing Video");
		unityVideoPlayer.Play();
		GameObject[] array = objectsToPlayTheSameVIdeo;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].GetComponent<Renderer>().material.mainTexture = unityVideoPlayer.texture;
		}
		unityVideoPlayer.GetComponent<AudioSource>().Play();
		while (unityVideoPlayer.isPlaying)
		{
			yield return null;
		}
		OnVideoFinished();
	}

	private IEnumerator StartVideo()
	{
		Handheld.PlayFullScreenMovie(videoUrl);
		yield return new WaitForSeconds(1.4f);
		OnVideoFinished();
	}

	public void OnVideoFinished()
	{
		UnityEngine.Debug.Log("Video finished");
	}
}
public class NewPlaybackSystem : MonoBehaviour
{
	public enum VideoQuality
	{
		HD720,
		HD1080,
		HD2160
	}

	private const string serverURI = "https://unity-dev-youtube.herokuapp.com/api/info?url=https://www.youtube.com/watch?v=";

	private const string formatURI = "&format=best&flatten=true";

	private const string videoURI = "https://youtubewebgl.herokuapp.com/download.php?mime=video/mp4&title=generatedvideo&token=";

	[SerializeField]
	public YoutubeNewResultIds results;

	public string videoId = "bc0sJvtKrRM";

	public VideoQuality videoQuality;

	private string videoUrl;

	private string audioVideoUrl;

	public VideoPlayer unityVideoPlayer;

	public bool playOnStart;

	[Tooltip("Use the SD video instead of a video and a audio separated, use this if you want to play sd videos, for hd+ you need to leave this setted to false")]
	public bool use_sd_videoWithAudioIncluded;

	private bool noHD;

	private RequestResolver resolver;

	private bool audioDecryptDone;

	private bool videoDecryptDone;

	public VideoPlayer audioVplayer;

	private bool startedPlaying;

	private bool videoPrepared;

	private bool audioPrepared;

	[HideInInspector]
	public bool isSyncing;

	[Header("If you think audio is out of sync enable this bool below")]
	[Header("This happens in some unity versions, the most stable is the 5.6.1p1")]
	public bool syncIssue;

	public void Start()
	{
		resolver = base.gameObject.AddComponent<RequestResolver>();
		if (playOnStart)
		{
			PlayYoutubeVideo(videoId);
		}
	}

	public void PlayYoutubeVideo(string _videoId)
	{
		if (GetComponent<VideoController>() != null)
		{
			GetComponent<VideoController>().ShowLoading("Loading...");
		}
		videoId = _videoId;
		StartCoroutine(Request(videoId));
	}

	private IEnumerator Request(string videoID)
	{
		WWW request = new WWW("https://unity-dev-youtube.herokuapp.com/api/info?url=https://www.youtube.com/watch?v=" + videoID + "&format=best&flatten=true");
		yield return request;
		JSONNode jSONNode = JSON.Parse(request.text);
		JSONNode jSONNode2 = jSONNode["videos"][0]["formats"];
		results.bestFormatWithAudioIncluded = jSONNode["videos"][0]["url"];
		for (int i = 0; i < jSONNode2.Count; i++)
		{
			if (jSONNode2[i]["format_id"] == (object)"160")
			{
				results.lowQuality = jSONNode2[i]["url"];
			}
			else if (jSONNode2[i]["format_id"] == (object)"133")
			{
				results.lowQuality = jSONNode2[i]["url"];
			}
			else if (jSONNode2[i]["format_id"] == (object)"134")
			{
				results.standardQuality = jSONNode2[i]["url"];
			}
			else if (jSONNode2[i]["format_id"] == (object)"135")
			{
				results.mediumQuality = jSONNode2[i]["url"];
			}
			else if (jSONNode2[i]["format_id"] == (object)"136")
			{
				results.hdQuality = jSONNode2[i]["url"];
			}
			else if (jSONNode2[i]["format_id"] == (object)"137")
			{
				results.fullHdQuality = jSONNode2[i]["url"];
			}
			else if (jSONNode2[i]["format_id"] == (object)"266")
			{
				results.ultraHdQuality = jSONNode2[i]["url"];
			}
			else if (jSONNode2[i]["format_id"] == (object)"18")
			{
				results.audioUrl = jSONNode2[i]["url"];
			}
		}
		if (use_sd_videoWithAudioIncluded)
		{
			GetSDVideo(results.bestFormatWithAudioIncluded);
			yield break;
		}
		switch (videoQuality)
		{
		case VideoQuality.HD720:
			GetVideo(results.hdQuality, results.audioUrl);
			break;
		case VideoQuality.HD1080:
			GetVideo(results.fullHdQuality, results.audioUrl);
			break;
		case VideoQuality.HD2160:
			GetVideo(results.ultraHdQuality, results.audioUrl);
			break;
		}
	}

	public void GetSDVideo(string videourl)
	{
		string text = Convert.ToBase64String(Encoding.UTF8.GetBytes(videourl));
		videoUrl = "https://youtubewebgl.herokuapp.com/download.php?mime=video/mp4&title=generatedvideo&token=" + text;
		UnityEngine.Debug.Log("Play!! " + videoUrl);
		unityVideoPlayer.source = VideoSource.Url;
		unityVideoPlayer.url = videoUrl;
		unityVideoPlayer.Prepare();
		videoPrepared = false;
		unityVideoPlayer.prepareCompleted += VideoPrepared;
	}

	public void GetVideo(string videourl, string audiourl)
	{
		videoUrl = videourl;
		audioVideoUrl = audiourl;
		UnityEngine.Debug.Log("Play!! " + videoUrl);
		unityVideoPlayer.source = VideoSource.Url;
		unityVideoPlayer.url = videoUrl;
		unityVideoPlayer.Prepare();
		audioVplayer.source = VideoSource.Url;
		audioVplayer.url = audioVideoUrl;
		audioVplayer.Prepare();
		videoPrepared = false;
		unityVideoPlayer.prepareCompleted += VideoPrepared;
		audioPrepared = false;
		audioVplayer.prepareCompleted += AudioPrepared;
	}

	private IEnumerator WebGLPlay()
	{
		yield return new WaitForSeconds(2f);
		Play();
	}

	private void FixedUpdate()
	{
		if (unityVideoPlayer.isPrepared && !startedPlaying)
		{
			startedPlaying = true;
			StartCoroutine(WebGLPlay());
		}
		CheckIfIsDesync();
	}

	private void AudioPrepared(VideoPlayer vPlayer)
	{
		audioVplayer.prepareCompleted -= AudioPrepared;
		audioPrepared = true;
		if (audioPrepared && videoPrepared)
		{
			Play();
		}
	}

	private void VideoPrepared(VideoPlayer vPlayer)
	{
		unityVideoPlayer.prepareCompleted -= VideoPrepared;
		videoPrepared = true;
		UnityEngine.Debug.Log("Playing youtube video only, the audio separated will be implemented in the final release of webgl support");
		if (use_sd_videoWithAudioIncluded)
		{
			noHD = true;
			Play();
			return;
		}
		noHD = false;
		if (audioPrepared && videoPrepared)
		{
			Play();
		}
	}

	public void Play()
	{
		unityVideoPlayer.loopPointReached += PlaybackDone;
		StartCoroutine(WaitAndPlay());
	}

	private void PlaybackDone(VideoPlayer vPlayer)
	{
		OnVideoFinished();
	}

	private IEnumerator WaitAndPlay()
	{
		if (!noHD)
		{
			audioVplayer.Play();
			if (syncIssue)
			{
				yield return new WaitForSeconds(0.35f);
			}
			else
			{
				yield return new WaitForSeconds(0f);
			}
		}
		else if (syncIssue)
		{
			yield return new WaitForSeconds(1f);
		}
		else
		{
			yield return new WaitForSeconds(0f);
		}
		unityVideoPlayer.Play();
		if (GetComponent<VideoController>() != null)
		{
			GetComponent<VideoController>().HideLoading();
		}
	}

	private IEnumerator StartVideo()
	{
		Handheld.PlayFullScreenMovie(videoUrl);
		yield return new WaitForSeconds(1.4f);
		OnVideoFinished();
	}

	public void OnVideoFinished()
	{
		if (unityVideoPlayer.isPrepared)
		{
			UnityEngine.Debug.Log("Finished");
			if (unityVideoPlayer.isLooping)
			{
				unityVideoPlayer.time = 0.0;
				unityVideoPlayer.frame = 0L;
				audioVplayer.time = 0.0;
				audioVplayer.frame = 0L;
				unityVideoPlayer.Play();
				audioVplayer.Play();
			}
		}
	}

	private void CheckIfIsDesync()
	{
		if (noHD)
		{
			return;
		}
		double num = unityVideoPlayer.time - audioVplayer.time;
		if (!isSyncing)
		{
			if (num != 0.0)
			{
				Sync();
			}
			else if (unityVideoPlayer.frame != audioVplayer.frame)
			{
				Sync();
			}
		}
	}

	private void Sync()
	{
		if (!(UnityEngine.Object.FindObjectOfType<VideoController>() != null))
		{
			UnityEngine.Debug.LogWarning("Please add a video controller to your scene to make the sync work! Will be improved in the future.");
		}
	}

	public int GetMaxQualitySupportedByDevice()
	{
		if (Screen.orientation == ScreenOrientation.LandscapeLeft)
		{
			return Screen.currentResolution.height;
		}
		if (Screen.orientation == ScreenOrientation.Portrait)
		{
			return Screen.currentResolution.width;
		}
		return Screen.currentResolution.height;
	}
}
[Serializable]
public class YoutubeNewResultIds
{
	public string lowQuality;

	public string standardQuality;

	public string mediumQuality;

	public string hdQuality;

	public string fullHdQuality;

	public string ultraHdQuality;

	public string bestFormatWithAudioIncluded;

	public string audioUrl;
}
public class ReactingLights : MonoBehaviour
{
	public enum VideoSide
	{
		up,
		left,
		right,
		down,
		center
	}

	public VideoPlayer videoSource;

	public Light[] lights;

	public Color averageColor;

	private Texture2D tex;

	public VideoSide videoSide;

	private bool createTexture;

	private void Start()
	{
		videoSource.frameReady += NewFrame;
		videoSource.sendFrameReadyEvents = true;
	}

	private void NewFrame(VideoPlayer vplayer, long frame)
	{
		if (!createTexture)
		{
			createTexture = true;
			switch (videoSide)
			{
			case VideoSide.up:
				tex = new Texture2D(videoSource.texture.width / 2, 20);
				break;
			case VideoSide.down:
				tex = new Texture2D(videoSource.texture.width / 2, 20);
				break;
			case VideoSide.left:
				tex = new Texture2D(20, videoSource.texture.height / 2);
				break;
			case VideoSide.right:
				tex = new Texture2D(20, videoSource.texture.height / 2);
				break;
			case VideoSide.center:
				tex = new Texture2D(videoSource.texture.height / 2, videoSource.texture.height / 2);
				break;
			}
		}
		RenderTexture.active = (RenderTexture)videoSource.texture;
		switch (videoSide)
		{
		case VideoSide.up:
			tex.ReadPixels(new Rect(videoSource.texture.width / 2, 0f, videoSource.texture.width / 2, 20f), 0, 0);
			break;
		case VideoSide.down:
			tex.ReadPixels(new Rect(videoSource.texture.width / 2, videoSource.texture.height - 20, videoSource.texture.width / 2, 20f), 0, 0);
			break;
		case VideoSide.left:
			tex.ReadPixels(new Rect(0f, 0f, 20f, videoSource.texture.height / 2), 0, 0);
			break;
		case VideoSide.right:
			tex.ReadPixels(new Rect(videoSource.texture.width - 20, 0f, 20f, videoSource.texture.height / 2), 0, 0);
			break;
		case VideoSide.center:
			tex.ReadPixels(new Rect(videoSource.texture.width / 2 - videoSource.texture.width / 2, videoSource.texture.height / 2 - videoSource.texture.height / 2, videoSource.texture.width / 2, videoSource.texture.height / 2), 0, 0);
			break;
		}
		tex.Apply();
		averageColor = AverageColorFromTexture(tex);
		averageColor.a = 1f;
		Light[] array = lights;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].color = averageColor;
		}
	}

	private Color32 AverageColorFromTexture(Texture2D tex)
	{
		Color32[] pixels = tex.GetPixels32();
		int num = pixels.Length;
		float num2 = 0f;
		float num3 = 0f;
		float num4 = 0f;
		for (int i = 0; i < num; i++)
		{
			num2 += (float)(int)pixels[i].r;
			num3 += (float)(int)pixels[i].g;
			num4 += (float)(int)pixels[i].b;
		}
		return new Color32((byte)(num2 / (float)num), (byte)(num3 / (float)num), (byte)(num4 / (float)num), 0);
	}
}
public class SimplePlayback : MonoBehaviour
{
	public delegate void VideoFinishedEvent();

	public delegate void VideoStartedEvent();

	public string videoId = "bc0sJvtKrRM";

	private string videoUrl;

	private bool videoAreReadyToPlay;

	public bool useNewUnityPlayer;

	public VideoPlayer unityVideoPlayer;

	public bool playOnStart;

	public YoutubeLogo youtubeLogo;

	private RequestResolver resolver;

	private bool checkIfVideoArePrepared;

	public event VideoFinishedEvent OnVideoFinished;

	public event VideoStartedEvent OnVideoStarted;

	public void Start()
	{
		resolver = base.gameObject.AddComponent<RequestResolver>();
		if (playOnStart)
		{
			PlayYoutubeVideo(videoId);
		}
	}

	public void PlayYoutubeVideo(string _videoId)
	{
		if (youtubeLogo != null)
		{
			youtubeLogo.youtubeurl = "https://www.youtube.com/watch?v=" + _videoId;
		}
		videoId = _videoId;
		try
		{
			StartCoroutine(resolver.GetDownloadUrls(FinishLoadingUrls, videoId, decryptSignature: false));
		}
		catch
		{
			UnityEngine.Debug.LogError("Something went wrong with the video load?");
		}
	}

	private void FinishLoadingUrls()
	{
		foreach (VideoInfo videoInfo in resolver.videoInfos)
		{
			if (videoInfo.VideoType == VideoType.Mp4 && videoInfo.Resolution == 360)
			{
				if (videoInfo.RequiresDecryption)
				{
					videoAreReadyToPlay = false;
					UnityEngine.Debug.Log("Decript");
					StartCoroutine(resolver.DecryptDownloadUrl(DecryptionFinished, videoInfo));
				}
				else
				{
					videoUrl = videoInfo.DownloadUrl;
					videoAreReadyToPlay = true;
				}
				break;
			}
		}
	}

	public void DecryptionFinished(string url)
	{
		videoUrl = url;
		videoAreReadyToPlay = true;
	}

	private void FixedUpdate()
	{
		if (videoAreReadyToPlay)
		{
			videoAreReadyToPlay = false;
			if (!useNewUnityPlayer)
			{
				StartHandheldVideo();
			}
			else
			{
				UnityEngine.Debug.Log("Play!!" + videoUrl);
				unityVideoPlayer.source = VideoSource.Url;
				unityVideoPlayer.url = videoUrl;
				checkIfVideoArePrepared = true;
				unityVideoPlayer.Prepare();
			}
		}
		if (checkIfVideoArePrepared)
		{
			checkIfVideoArePrepared = false;
			StartCoroutine(PreparingAudio());
		}
	}

	private IEnumerator PreparingAudio()
	{
		WaitForSeconds waitForSeconds = new WaitForSeconds(1f);
		if (!unityVideoPlayer.isPrepared)
		{
			UnityEngine.Debug.Log("Preparing Video");
			yield return waitForSeconds;
		}
		UnityEngine.Debug.Log("Done Preparing Video");
		unityVideoPlayer.Play();
		unityVideoPlayer.Play();
		if (this.OnVideoStarted != null)
		{
			this.OnVideoStarted();
		}
		UnityEngine.Debug.Log("Playing Video");
		while (unityVideoPlayer.isPlaying)
		{
			yield return null;
		}
		if (this.OnVideoFinished != null)
		{
			this.OnVideoFinished();
		}
	}

	public void Play()
	{
		unityVideoPlayer.Play();
	}

	private void StartHandheldVideo()
	{
	}

	public void Play_Pause()
	{
		if (unityVideoPlayer.isPlaying)
		{
			unityVideoPlayer.Pause();
		}
		else
		{
			unityVideoPlayer.Play();
		}
	}

	public void PlayerPause()
	{
		unityVideoPlayer.Pause();
	}

	public void PlayerPlay()
	{
		unityVideoPlayer.Play();
	}
}
public static class UISetExtensions
{
	private static readonly MethodInfo toggleSetMethod;

	private static readonly MethodInfo sliderSetMethod;

	private static readonly MethodInfo scrollbarSetMethod;

	private static readonly FieldInfo dropdownValueField;

	private static readonly MethodInfo dropdownRefreshMethod;

	static UISetExtensions()
	{
		toggleSetMethod = FindSetMethod(typeof(Toggle));
		sliderSetMethod = FindSetMethod(typeof(Slider));
		scrollbarSetMethod = FindSetMethod(typeof(Scrollbar));
		dropdownValueField = typeof(Dropdown).GetField("m_Value", BindingFlags.Instance | BindingFlags.NonPublic);
		dropdownRefreshMethod = typeof(Dropdown).GetMethod("Refresh", BindingFlags.Instance | BindingFlags.NonPublic);
	}

	public static void Set(this Toggle instance, bool value, bool sendCallback = false)
	{
		toggleSetMethod.Invoke(instance, new object[2] { value, sendCallback });
	}

	public static void Set(this Slider instance, float value, bool sendCallback = false)
	{
		sliderSetMethod.Invoke(instance, new object[2] { value, sendCallback });
	}

	public static void Set(this Scrollbar instance, float value, bool sendCallback = false)
	{
		scrollbarSetMethod.Invoke(instance, new object[2] { value, sendCallback });
	}

	public static void Set(this Dropdown instance, int value)
	{
		dropdownValueField.SetValue(instance, value);
		instance.RefreshShownValue();
	}

	private static MethodInfo FindSetMethod(Type objectType)
	{
		MethodInfo[] methods = objectType.GetMethods(BindingFlags.Instance | BindingFlags.NonPublic);
		for (int i = 0; i < methods.Length; i++)
		{
			if (methods[i].Name == "Set" && methods[i].GetParameters().Length == 2)
			{
				return methods[i];
			}
		}
		return null;
	}
}
public class VideoController : MonoBehaviour
{
	private bool noHD;

	public VideoPlayer sourceVideo;

	public VideoPlayer sourceAudioVideo;

	public bool hideControls;

	public int secondsToHideScreen = 3;

	[Header("The main controller ui parent")]
	public GameObject mainControllerUi;

	[Header("Slider with duration and progress")]
	public Slider progressSlider;

	[Header("Play/Pause Button")]
	public GameObject playImage;

	[Header("Volume slider")]
	public Slider volumeSlider;

	[Header("Playback speed")]
	public Slider playbackSpeed;

	[Header("Current Time")]
	public Text currentTimeString;

	[Header("Total Time")]
	public Text totalTimeString;

	private float totalVideoDuration;

	private float currentVideoDuration;

	private bool videoSeekDone;

	private bool videoAudioSeekDone;

	[Header("Loading control")]
	public GameObject loadingPanel;

	public Text loadingMessage;

	private float hideScreenTime;

	private bool finished;

	private bool showingPlaybackSpeed;

	private bool showingVolume;

	private void Start()
	{
		if (sourceVideo.GetComponent<HighQualityPlayback>() != null)
		{
			noHD = sourceVideo.GetComponent<HighQualityPlayback>().noHD;
		}
		else
		{
			noHD = false;
		}
		if (!noHD)
		{
			sourceVideo.audioOutputMode = VideoAudioOutputMode.None;
		}
	}

	public void ShowLoading(string message)
	{
		UnityEngine.Debug.Log("Loading: " + message);
		if (loadingPanel != null)
		{
			loadingPanel.SetActive(value: true);
			loadingMessage.text = message;
		}
	}

	public void HideLoading()
	{
		if (loadingPanel != null)
		{
			loadingPanel.SetActive(value: false);
		}
	}

	private void Update()
	{
		if (sourceVideo.isPlaying && progressSlider != null)
		{
			totalVideoDuration = Mathf.RoundToInt((float)sourceVideo.frameCount / sourceVideo.frameRate);
			currentVideoDuration = Mathf.RoundToInt((float)sourceVideo.frame / sourceVideo.frameRate);
			progressSlider.maxValue = totalVideoDuration;
			progressSlider.Set(currentVideoDuration);
		}
		if (currentVideoDuration >= totalVideoDuration && !finished)
		{
			Finished();
		}
		if (!hideControls)
		{
			return;
		}
		if (UserInteract())
		{
			hideScreenTime = 0f;
			if (mainControllerUi != null)
			{
				mainControllerUi.SetActive(value: true);
			}
			return;
		}
		hideScreenTime += Time.deltaTime;
		if (hideScreenTime >= (float)secondsToHideScreen)
		{
			hideScreenTime = secondsToHideScreen;
			HideControllers();
		}
	}

	private void FixedUpdate()
	{
		if (currentTimeString != null && totalTimeString != null)
		{
			currentTimeString.text = FormatTime(Mathf.RoundToInt(currentVideoDuration));
			totalTimeString.text = FormatTime(Mathf.RoundToInt(totalVideoDuration));
		}
	}

	private void HideControllers()
	{
		if (mainControllerUi != null)
		{
			mainControllerUi.SetActive(value: false);
			showingVolume = false;
			showingPlaybackSpeed = false;
			volumeSlider.gameObject.SetActive(value: false);
			playbackSpeed.gameObject.SetActive(value: false);
		}
	}

	public void Seek()
	{
		sourceVideo.GetComponent<HighQualityPlayback>().isSyncing = true;
		if (Mathf.RoundToInt(currentVideoDuration) == Mathf.RoundToInt(totalVideoDuration))
		{
			return;
		}
		finished = false;
		if (!sourceVideo.canSetTime || !sourceVideo.canStep)
		{
			return;
		}
		ShowLoading("Syncing...");
		Pause();
		videoSeekDone = false;
		videoAudioSeekDone = false;
		if (!noHD)
		{
			sourceAudioVideo.seekCompleted += SeekVideoAudioDone;
			if (Mathf.RoundToInt(progressSlider.value) == 0)
			{
				sourceAudioVideo.time = 1.0;
			}
			else
			{
				sourceAudioVideo.time = Mathf.RoundToInt(progressSlider.value);
			}
		}
		else
		{
			sourceVideo.seekCompleted += SeekVideoDone;
			if (Mathf.RoundToInt(progressSlider.value) == 0)
			{
				sourceVideo.time = 1.0;
			}
			else
			{
				sourceVideo.time = Mathf.RoundToInt(progressSlider.value);
			}
		}
	}

	public void Finished()
	{
		finished = true;
		if (sourceVideo.GetComponent<HighQualityPlayback>() != null)
		{
			sourceVideo.GetComponent<HighQualityPlayback>().OnVideoFinished();
		}
		else if (sourceVideo.GetComponent<WebGlPlayback>() != null)
		{
			sourceVideo.GetComponent<WebGlPlayback>().OnVideoFinished();
		}
	}

	public void Volume()
	{
		if (sourceVideo.audioOutputMode == VideoAudioOutputMode.Direct)
		{
			sourceAudioVideo.SetDirectAudioVolume(0, volumeSlider.value);
		}
		else if (sourceVideo.audioOutputMode == VideoAudioOutputMode.AudioSource)
		{
			sourceVideo.GetComponent<AudioSource>().volume = volumeSlider.value;
		}
		else
		{
			sourceVideo.GetComponent<AudioSource>().volume = volumeSlider.value;
		}
	}

	public void Speed()
	{
		if (sourceVideo.canSetPlaybackSpeed)
		{
			if (playbackSpeed.value == 0f)
			{
				sourceVideo.playbackSpeed = 0.5f;
				sourceAudioVideo.playbackSpeed = 0.5f;
			}
			else
			{
				sourceVideo.playbackSpeed = playbackSpeed.value;
				sourceAudioVideo.playbackSpeed = playbackSpeed.value;
			}
		}
	}

	public void PlayButton()
	{
		if (!sourceVideo.isPlaying)
		{
			playImage.SetActive(value: false);
			sourceAudioVideo.time = sourceVideo.time;
			sourceAudioVideo.frame = sourceVideo.frame;
			Play();
		}
		else
		{
			playImage.SetActive(value: true);
			Pause();
		}
	}

	public void VolumeSlider()
	{
		if (showingVolume)
		{
			showingVolume = false;
			volumeSlider.gameObject.SetActive(value: false);
		}
		else
		{
			showingVolume = true;
			volumeSlider.gameObject.SetActive(value: true);
		}
	}

	public void PlaybackSpeedSlider()
	{
		if (showingPlaybackSpeed)
		{
			showingPlaybackSpeed = false;
			playbackSpeed.gameObject.SetActive(value: false);
		}
		else
		{
			showingPlaybackSpeed = true;
			playbackSpeed.gameObject.SetActive(value: true);
		}
	}

	public void Pause()
	{
		if (!noHD)
		{
			sourceVideo.Pause();
			sourceAudioVideo.Pause();
		}
	}

	public void Play()
	{
		StartCoroutine(WaitAndPlay());
	}

	private IEnumerator WaitAndPlay()
	{
		if (!noHD)
		{
			sourceAudioVideo.Play();
			yield return new WaitForSeconds(0.35f);
		}
		else
		{
			yield return new WaitForSeconds(1f);
		}
		sourceVideo.Play();
	}

	public void Stop()
	{
		sourceVideo.Stop();
		if (!noHD)
		{
			sourceAudioVideo.Stop();
		}
	}

	private void SeekVideoDone(VideoPlayer vp)
	{
		sourceVideo.seekCompleted -= SeekVideoDone;
		videoSeekDone = true;
		if (!noHD)
		{
			if (videoSeekDone && videoAudioSeekDone)
			{
				sourceVideo.GetComponent<HighQualityPlayback>().isSyncing = false;
				long frame = sourceVideo.frame;
				sourceVideo.frame = frame;
				sourceAudioVideo.frame = frame;
				StartCoroutine(SeekFinished());
			}
		}
		else
		{
			sourceVideo.GetComponent<HighQualityPlayback>().isSyncing = false;
			HideLoading();
			Play();
		}
	}

	private void SeekVideoAudioDone(VideoPlayer vp)
	{
		sourceAudioVideo.seekCompleted -= SeekVideoAudioDone;
		sourceVideo.seekCompleted += SeekVideoDone;
		sourceVideo.frame = sourceAudioVideo.frame;
		sourceVideo.time = sourceAudioVideo.time;
		videoAudioSeekDone = true;
	}

	private IEnumerator SeekFinished()
	{
		yield return new WaitForSeconds(1f);
		HideLoading();
		Play();
	}

	private string FormatTime(int time)
	{
		int num = time / 3600;
		int num2 = time % 3600 / 60;
		int num3 = time % 3600 % 60;
		if (num == 0 && num2 != 0)
		{
			return num2.ToString("00") + ":" + num3.ToString("00");
		}
		if (num == 0 && num2 == 0)
		{
			return "00:" + num3.ToString("00");
		}
		return num.ToString("00") + ":" + num2.ToString("00") + ":" + num3.ToString("00");
	}

	private bool UserInteract()
	{
		if (UnityEngine.Application.isMobilePlatform)
		{
			if (Input.touches.Length >= 1)
			{
				return true;
			}
			return false;
		}
		if (Input.GetMouseButtonDown(0))
		{
			return true;
		}
		if (Input.GetAxis("Mouse X") == 0f)
		{
			return Input.GetAxis("Mouse Y") != 0f;
		}
		return true;
	}
}
public class WebGlPlayback : MonoBehaviour
{
	public enum VideoQuality
	{
		mediumQuality,
		Hd720,
		Hd1080,
		Hd1440,
		Hd2160
	}

	private const string serverURI = "https://unity-dev-youtube.herokuapp.com/api/info?url=https://www.youtube.com/watch?v=";

	private const string formatURI = "&format=best[ext=mp4]/mp4&flatten=true";

	private const string videoURI = "https://youtubewebgl.herokuapp.com/download.php?mime=video/mp4&title=generatedvideo&token=";

	public YoutubeResultIds webGlResults;

	public string videoId = "bc0sJvtKrRM";

	private string videoUrl;

	private string audioVideoUrl;

	public VideoPlayer unityVideoPlayer;

	public bool playOnStart;

	private bool noHD;

	private RequestResolver resolver;

	private bool audioDecryptDone;

	private bool videoDecryptDone;

	public VideoPlayer audioVplayer;

	private bool startedPlaying;

	private bool videoPrepared;

	private bool audioPrepared;

	[HideInInspector]
	public bool isSyncing;

	[Header("If you think audio is out of sync enable this bool below")]
	[Header("This happens in some unity versions, the most stable is the 5.6.1p1")]
	public bool syncIssue;

	public void Start()
	{
		resolver = base.gameObject.AddComponent<RequestResolver>();
		if (playOnStart)
		{
			PlayYoutubeVideo(videoId);
		}
	}

	public void PlayYoutubeVideo(string _videoId)
	{
		UnityEngine.Debug.LogError("Please use this script only for webgl");
	}

	private IEnumerator WebGlRequest(string videoID)
	{
		WWW request = new WWW("https://unity-dev-youtube.herokuapp.com/api/info?url=https://www.youtube.com/watch?v=" + videoID + "&format=best[ext=mp4]/mp4&flatten=true");
		yield return request;
		webGlResults = new YoutubeResultIds();
		UnityEngine.Debug.Log(request.url);
		JSONNode jSONNode = JSON.Parse(request.text);
		JSONNode jSONNode2 = jSONNode["videos"][0]["formats"];
		webGlResults.bestFormatWithAudioIncluded = jSONNode["videos"][0]["url"];
		for (int i = 0; i < jSONNode2.Count; i++)
		{
			if (jSONNode2[i]["format_id"] == (object)"160")
			{
				webGlResults.lowQuality = jSONNode2[i]["url"];
			}
			else if (jSONNode2[i]["format_id"] == (object)"133")
			{
				webGlResults.lowQuality = jSONNode2[i]["url"];
			}
			else if (jSONNode2[i]["format_id"] == (object)"134")
			{
				webGlResults.standardQuality = jSONNode2[i]["url"];
			}
			else if (jSONNode2[i]["format_id"] == (object)"135")
			{
				webGlResults.mediumQuality = jSONNode2[i]["url"];
			}
			else if (jSONNode2[i]["format_id"] == (object)"136")
			{
				webGlResults.hdQuality = jSONNode2[i]["url"];
			}
			else if (jSONNode2[i]["format_id"] == (object)"137")
			{
				webGlResults.fullHdQuality = jSONNode2[i]["url"];
			}
			else if (jSONNode2[i]["format_id"] == (object)"266")
			{
				webGlResults.ultraHdQuality = jSONNode2[i]["url"];
			}
			else if (jSONNode2[i]["format_id"] == (object)"139")
			{
				webGlResults.audioUrl = jSONNode2[i]["url"];
			}
		}
		WebGlGetVideo(webGlResults.bestFormatWithAudioIncluded);
	}

	public void WebGlGetVideo(string url)
	{
		string text = Convert.ToBase64String(Encoding.UTF8.GetBytes(url));
		UnityEngine.Debug.Log(url);
		videoUrl = "https://youtubewebgl.herokuapp.com/download.php?mime=video/mp4&title=generatedvideo&token=" + text;
		UnityEngine.Debug.Log("Play!! " + videoUrl);
		unityVideoPlayer.source = VideoSource.Url;
		unityVideoPlayer.url = videoUrl;
		unityVideoPlayer.Prepare();
		videoPrepared = false;
		unityVideoPlayer.prepareCompleted += VideoPrepared;
	}

	private IEnumerator WebGLPlay()
	{
		yield return new WaitForSeconds(2f);
		Play();
	}

	private void FixedUpdate()
	{
		if (unityVideoPlayer.isPrepared && !startedPlaying)
		{
			startedPlaying = true;
			StartCoroutine(WebGLPlay());
		}
		CheckIfIsDesync();
	}

	private void AudioPrepared(VideoPlayer vPlayer)
	{
		audioVplayer.prepareCompleted -= AudioPrepared;
		audioPrepared = true;
		if (audioPrepared && videoPrepared)
		{
			Play();
		}
	}

	private void VideoPrepared(VideoPlayer vPlayer)
	{
		unityVideoPlayer.prepareCompleted -= VideoPrepared;
		videoPrepared = true;
		UnityEngine.Debug.Log("Playing youtube video only, the audio separated will be implemented in the final release of webgl support");
		noHD = true;
		Play();
	}

	public void Play()
	{
		unityVideoPlayer.loopPointReached += PlaybackDone;
		StartCoroutine(WaitAndPlay());
	}

	private void PlaybackDone(VideoPlayer vPlayer)
	{
		OnVideoFinished();
	}

	private IEnumerator WaitAndPlay()
	{
		if (!noHD)
		{
			audioVplayer.Play();
			if (syncIssue)
			{
				yield return new WaitForSeconds(0.35f);
			}
			else
			{
				yield return new WaitForSeconds(0f);
			}
		}
		else if (syncIssue)
		{
			yield return new WaitForSeconds(1f);
		}
		else
		{
			yield return new WaitForSeconds(0f);
		}
		unityVideoPlayer.Play();
		if (GetComponent<VideoController>() != null)
		{
			GetComponent<VideoController>().HideLoading();
		}
	}

	private IEnumerator StartVideo()
	{
		Handheld.PlayFullScreenMovie(videoUrl);
		yield return new WaitForSeconds(1.4f);
		OnVideoFinished();
	}

	public void OnVideoFinished()
	{
		if (unityVideoPlayer.isPrepared)
		{
			UnityEngine.Debug.Log("Finished");
			if (unityVideoPlayer.isLooping)
			{
				unityVideoPlayer.time = 0.0;
				unityVideoPlayer.frame = 0L;
				audioVplayer.time = 0.0;
				audioVplayer.frame = 0L;
				unityVideoPlayer.Play();
				audioVplayer.Play();
			}
		}
	}

	private void CheckIfIsDesync()
	{
		if (noHD)
		{
			return;
		}
		double num = unityVideoPlayer.time - audioVplayer.time;
		if (!isSyncing)
		{
			if (num != 0.0)
			{
				Sync();
			}
			else if (unityVideoPlayer.frame != audioVplayer.frame)
			{
				Sync();
			}
		}
	}

	private void Sync()
	{
		if (!(UnityEngine.Object.FindObjectOfType<VideoController>() != null))
		{
			UnityEngine.Debug.LogWarning("Please add a video controller to your scene to make the sync work! Will be improved in the future.");
		}
	}

	public int GetMaxQualitySupportedByDevice()
	{
		if (Screen.orientation == ScreenOrientation.LandscapeLeft)
		{
			return Screen.currentResolution.height;
		}
		if (Screen.orientation == ScreenOrientation.Portrait)
		{
			return Screen.currentResolution.width;
		}
		return Screen.currentResolution.height;
	}
}
[Serializable]
public class YoutubeResultIds
{
	public string lowQuality;

	public string standardQuality;

	public string mediumQuality;

	public string hdQuality;

	public string fullHdQuality;

	public string ultraHdQuality;

	public string bestFormatWithAudioIncluded;

	public string audioUrl;
}
public class YoutubeAudioFromDifferentSource : MonoBehaviour
{
	public enum VideoQuality
	{
		mediumQuality,
		Hd720,
		Hd1080,
		Hd1440,
		Hd2160
	}

	public bool useNewVersion;

	public string videoId = "bc0sJvtKrRM";

	public string audioId = "";

	public VideoQuality videoQuality;

	private string videoUrl;

	private string audioVideoUrl;

	private bool videoAreReadyToPlay;

	public bool useNewUnityPlayer;

	public VideoPlayer unityVideoPlayer;

	public bool playOnStart;

	public bool noHD;

	private RequestResolver resolver;

	private bool audioDecryptDone;

	private bool videoDecryptDone;

	public VideoPlayer audioVplayer;

	private bool checkIfVideoArePrepared;

	private bool videoPrepared;

	private bool audioPrepared;

	[HideInInspector]
	public bool isSyncing;

	[Header("If you think audio is out of sync enable this bool below")]
	[Header("This happens in some unity versions, the most stable is the 5.6.1p1")]
	public bool syncIssue;

	[SerializeField]
	public YoutubeResultIds newRequestResults;

	private const string serverURI = "https://unity-dev-youtube.herokuapp.com/api/info?url=https://www.youtube.com/watch?v=";

	private const string formatURI = "&format=best&flatten=true";

	private const string videoURI = "https://youtubewebgl.herokuapp.com/download.php?mime=video/mp4&title=generatedvideo&token=";

	public void Start()
	{
		resolver = base.gameObject.AddComponent<RequestResolver>();
		if (UnityEngine.Application.isMobilePlatform && GetMaxQualitySupportedByDevice() <= 720)
		{
			if (videoQuality != 0)
			{
				videoQuality = VideoQuality.Hd720;
			}
			noHD = true;
		}
		if (playOnStart)
		{
			PlayYoutubeVideo(videoId);
		}
	}

	public void PlayYoutubeVideo(string _videoId)
	{
		if (GetComponent<VideoController>() != null)
		{
			GetComponent<VideoController>().ShowLoading("Loading...");
		}
		videoId = _videoId;
		StartCoroutine(resolver.GetDownloadUrls(FinishLoadingUrls, videoId, decryptSignature: false));
		StartCoroutine(resolver.GetDownloadUrls(FinishLoadingAudioUrls, audioId, decryptSignature: false));
	}

	private void FinishLoadingAudioUrls()
	{
		foreach (VideoInfo videoInfo in resolver.videoInfos)
		{
			if (videoInfo.VideoType == VideoType.Mp4 && videoInfo.Resolution == 360)
			{
				if (videoInfo.RequiresDecryption)
				{
					StartCoroutine(resolver.DecryptDownloadUrl(DecryptAudioDone, videoInfo));
				}
				else
				{
					audioVideoUrl = videoInfo.DownloadUrl;
				}
				break;
			}
		}
	}

	private void FinishLoadingUrls()
	{
		List<VideoInfo> videoInfos = resolver.videoInfos;
		videoDecryptDone = false;
		audioDecryptDone = false;
		int num = 360;
		switch (videoQuality)
		{
		case VideoQuality.mediumQuality:
			num = 360;
			break;
		case VideoQuality.Hd720:
			num = 720;
			break;
		case VideoQuality.Hd1080:
			num = 1080;
			break;
		case VideoQuality.Hd1440:
			num = 1440;
			break;
		case VideoQuality.Hd2160:
			num = 2160;
			break;
		}
		bool flag = false;
		foreach (VideoInfo item in videoInfos)
		{
			if (item.VideoType == VideoType.Mp4 && item.Resolution == num)
			{
				if (item.RequiresDecryption)
				{
					StartCoroutine(resolver.DecryptDownloadUrl(DecryptVideoDone, item));
				}
				else
				{
					videoUrl = item.DownloadUrl;
					videoAreReadyToPlay = true;
				}
				flag = true;
				break;
			}
		}
		if (!flag && num == 2160)
		{
			foreach (VideoInfo item2 in videoInfos)
			{
				if (item2.FormatCode == 313)
				{
					UnityEngine.Debug.Log("Found but with unknow format in results, check to see if the video works normal.");
					if (item2.RequiresDecryption)
					{
						StartCoroutine(resolver.DecryptDownloadUrl(DecryptVideoDone, item2));
					}
					else
					{
						videoUrl = item2.DownloadUrl;
						videoAreReadyToPlay = true;
					}
					flag = true;
					break;
				}
			}
		}
		if (flag)
		{
			return;
		}
		UnityEngine.Debug.Log("Desired quality not found, playing with low quality, check if the video id: " + videoId + " support that quality!");
		foreach (VideoInfo item3 in videoInfos)
		{
			if (item3.VideoType == VideoType.Mp4 && item3.Resolution == 360)
			{
				if (item3.RequiresDecryption)
				{
					StartCoroutine(resolver.DecryptDownloadUrl(DecryptVideoDone, item3));
					break;
				}
				videoUrl = item3.DownloadUrl;
				videoAreReadyToPlay = true;
				break;
			}
		}
	}

	public void DecryptAudioDone(string url)
	{
		audioVideoUrl = url;
		audioDecryptDone = true;
		if (videoDecryptDone)
		{
			videoAreReadyToPlay = true;
		}
	}

	public void DecryptVideoDone(string url)
	{
		videoUrl = url;
		videoDecryptDone = true;
		if (audioDecryptDone)
		{
			videoAreReadyToPlay = true;
		}
	}

	private void FixedUpdate()
	{
		if (videoAreReadyToPlay)
		{
			videoAreReadyToPlay = false;
			if (!useNewUnityPlayer)
			{
				StartHandheldVideo();
			}
			else
			{
				UnityEngine.Debug.Log("Play!!" + videoUrl);
				unityVideoPlayer.source = VideoSource.Url;
				unityVideoPlayer.url = videoUrl;
				checkIfVideoArePrepared = true;
				unityVideoPlayer.Prepare();
				if (!noHD)
				{
					audioVplayer.source = VideoSource.Url;
					audioVplayer.url = audioVideoUrl;
					audioVplayer.Prepare();
				}
			}
		}
		if (checkIfVideoArePrepared)
		{
			checkIfVideoArePrepared = false;
			videoPrepared = false;
			unityVideoPlayer.prepareCompleted += VideoPrepared;
			if (!noHD)
			{
				audioPrepared = false;
				audioVplayer.prepareCompleted += AudioPrepared;
			}
		}
		CheckIfIsDesync();
	}

	private void AudioPrepared(VideoPlayer vPlayer)
	{
		audioVplayer.prepareCompleted -= AudioPrepared;
		audioPrepared = true;
		if (audioPrepared && videoPrepared)
		{
			Play();
		}
	}

	private void VideoPrepared(VideoPlayer vPlayer)
	{
		unityVideoPlayer.prepareCompleted -= VideoPrepared;
		videoPrepared = true;
		if (noHD)
		{
			Play();
		}
		else if (audioPrepared && videoPrepared)
		{
			Play();
		}
	}

	public void Play()
	{
		unityVideoPlayer.loopPointReached += PlaybackDone;
		StartCoroutine(WaitAndPlay());
	}

	private void PlaybackDone(VideoPlayer vPlayer)
	{
		OnVideoFinished();
	}

	private IEnumerator WaitAndPlay()
	{
		if (!noHD)
		{
			audioVplayer.Play();
			if (syncIssue)
			{
				yield return new WaitForSeconds(0.35f);
			}
			else
			{
				yield return new WaitForSeconds(0f);
			}
		}
		else if (syncIssue)
		{
			yield return new WaitForSeconds(1f);
		}
		else
		{
			yield return new WaitForSeconds(0f);
		}
		unityVideoPlayer.Play();
		if (GetComponent<VideoController>() != null)
		{
			GetComponent<VideoController>().HideLoading();
		}
	}

	private void StartHandheldVideo()
	{
		UnityEngine.Debug.Log("P");
		base.gameObject.AddComponent<HandheldPlayback>().PlayVideo(videoUrl, OnVideoFinished);
	}

	public void OnVideoFinished()
	{
		if (unityVideoPlayer.isPrepared)
		{
			UnityEngine.Debug.Log("Finished");
			if (unityVideoPlayer.isLooping)
			{
				unityVideoPlayer.time = 0.0;
				unityVideoPlayer.frame = 0L;
				audioVplayer.time = 0.0;
				audioVplayer.frame = 0L;
				unityVideoPlayer.Play();
				audioVplayer.Play();
			}
		}
	}

	private void CheckIfIsDesync()
	{
		if (noHD)
		{
			return;
		}
		double num = unityVideoPlayer.time - audioVplayer.time;
		if (!isSyncing)
		{
			if (num != 0.0)
			{
				Sync();
			}
			else if (unityVideoPlayer.frame != audioVplayer.frame)
			{
				Sync();
			}
		}
	}

	private void Sync()
	{
		if (!(UnityEngine.Object.FindObjectOfType<VideoController>() != null))
		{
			UnityEngine.Debug.LogWarning("Please add a video controller to your scene to make the sync work! Will be improved in the future.");
		}
	}

	public int GetMaxQualitySupportedByDevice()
	{
		if (Screen.orientation == ScreenOrientation.LandscapeLeft)
		{
			return Screen.currentResolution.height;
		}
		if (Screen.orientation == ScreenOrientation.Portrait)
		{
			return Screen.currentResolution.width;
		}
		return Screen.currentResolution.height;
	}

	private IEnumerator NewRequest(string videoID)
	{
		WWW request = new WWW("https://unity-dev-youtube.herokuapp.com/api/info?url=https://www.youtube.com/watch?v=" + videoID + "&format=best&flatten=true");
		yield return request;
		JSONNode jSONNode = JSON.Parse(request.text);
		JSONNode jSONNode2 = jSONNode["videos"][0]["formats"];
		newRequestResults.bestFormatWithAudioIncluded = jSONNode["videos"][0]["url"];
		for (int i = 0; i < jSONNode2.Count; i++)
		{
			if (jSONNode2[i]["format_id"] == (object)"160")
			{
				newRequestResults.lowQuality = jSONNode2[i]["url"];
			}
			else if (jSONNode2[i]["format_id"] == (object)"133")
			{
				newRequestResults.lowQuality = jSONNode2[i]["url"];
			}
			else if (jSONNode2[i]["format_id"] == (object)"134")
			{
				newRequestResults.standardQuality = jSONNode2[i]["url"];
			}
			else if (jSONNode2[i]["format_id"] == (object)"135")
			{
				newRequestResults.mediumQuality = jSONNode2[i]["url"];
			}
			else if (jSONNode2[i]["format_id"] == (object)"136")
			{
				newRequestResults.hdQuality = jSONNode2[i]["url"];
			}
			else if (jSONNode2[i]["format_id"] == (object)"137")
			{
				newRequestResults.fullHdQuality = jSONNode2[i]["url"];
			}
			else if (jSONNode2[i]["format_id"] == (object)"266")
			{
				newRequestResults.ultraHdQuality = jSONNode2[i]["url"];
			}
			else if (jSONNode2[i]["format_id"] == (object)"139")
			{
				newRequestResults.audioUrl = jSONNode2[i]["url"];
			}
		}
		audioVideoUrl = newRequestResults.bestFormatWithAudioIncluded;
		videoUrl = newRequestResults.lowQuality;
		switch (videoQuality)
		{
		case VideoQuality.mediumQuality:
			videoUrl = newRequestResults.mediumQuality;
			break;
		case VideoQuality.Hd720:
			videoUrl = newRequestResults.hdQuality;
			break;
		case VideoQuality.Hd1080:
			videoUrl = newRequestResults.fullHdQuality;
			break;
		}
		videoAreReadyToPlay = true;
	}

	private string ConvertToWebglUrl(string url)
	{
		string text = Convert.ToBase64String(Encoding.UTF8.GetBytes(url));
		UnityEngine.Debug.Log(url);
		return "https://youtubewebgl.herokuapp.com/download.php?mime=video/mp4&title=generatedvideo&token=" + text;
	}
}
public class YoutubeLogo : MonoBehaviour
{
	public string youtubeurl;

	private void OnMouseDown()
	{
		UnityEngine.Application.OpenURL(youtubeurl);
	}
}
public class AlphaButtonClickMask : MonoBehaviour, ICanvasRaycastFilter
{
	protected Image _image;

	public void Start()
	{
		_image = GetComponent<Image>();
		Texture2D texture = _image.sprite.texture;
		bool flag = false;
		if (texture != null)
		{
			try
			{
				texture.GetPixels32();
			}
			catch (UnityException ex)
			{
				UnityEngine.Debug.LogError(ex.Message);
				flag = true;
			}
		}
		else
		{
			flag = true;
		}
		if (flag)
		{
			UnityEngine.Debug.LogError("This script need an Image with a readbale Texture2D to work.");
		}
	}

	public bool IsRaycastLocationValid(Vector2 sp, Camera eventCamera)
	{
		RectTransformUtility.ScreenPointToLocalPointInRectangle(_image.rectTransform, sp, eventCamera, out var localPoint);
		Vector2 pivot = _image.rectTransform.pivot;
		Vector2 vector = new Vector2(pivot.x + localPoint.x / _image.rectTransform.rect.width, pivot.y + localPoint.y / _image.rectTransform.rect.height);
		Vector2 vector2 = new Vector2(_image.sprite.rect.x + vector.x * _image.sprite.rect.width, _image.sprite.rect.y + vector.y * _image.sprite.rect.height);
		vector2.x /= _image.sprite.texture.width;
		vector2.y /= _image.sprite.texture.height;
		return _image.sprite.texture.GetPixelBilinear(vector2.x, vector2.y).a > 0.1f;
	}
}
public class EventSystemChecker : MonoBehaviour
{
	private void Awake()
	{
		if (!UnityEngine.Object.FindObjectOfType<EventSystem>())
		{
			GameObject obj = new GameObject("EventSystem");
			obj.AddComponent<EventSystem>();
			obj.AddComponent<StandaloneInputModule>().forceModuleActive = true;
		}
	}
}
public class ChannelSearchDemo : MonoBehaviour
{
	private YoutubeAPIManager youtubeapi;

	public Text searchField;

	public Dropdown mainFilters;

	public GameObject[] channelListUI;

	public GameObject[] videoListUI;

	public GameObject videoUIResult;

	public GameObject channelUIResult;

	public GameObject mainUI;

	private void Start()
	{
		youtubeapi = UnityEngine.Object.FindObjectOfType<YoutubeAPIManager>();
		if (youtubeapi == null)
		{
			youtubeapi = base.gameObject.AddComponent<YoutubeAPIManager>();
		}
	}

	public void SearchChannel()
	{
		YoutubeAPIManager.YoutubeSearchOrderFilter order = YoutubeAPIManager.YoutubeSearchOrderFilter.none;
		switch (mainFilters.value)
		{
		case 0:
			order = YoutubeAPIManager.YoutubeSearchOrderFilter.none;
			break;
		case 1:
			order = YoutubeAPIManager.YoutubeSearchOrderFilter.date;
			break;
		case 2:
			order = YoutubeAPIManager.YoutubeSearchOrderFilter.rating;
			break;
		case 3:
			order = YoutubeAPIManager.YoutubeSearchOrderFilter.relevance;
			break;
		case 4:
			order = YoutubeAPIManager.YoutubeSearchOrderFilter.title;
			break;
		case 5:
			order = YoutubeAPIManager.YoutubeSearchOrderFilter.videoCount;
			break;
		case 6:
			order = YoutubeAPIManager.YoutubeSearchOrderFilter.viewCount;
			break;
		}
		youtubeapi.SearchForChannels(searchField.text, 10, order, YoutubeAPIManager.YoutubeSafeSearchFilter.none, OnSearchDone);
	}

	private void OnSearchDone(YoutubeChannel[] results)
	{
		channelUIResult.SetActive(value: true);
		LoadChannelsOnUI(results);
	}

	private void LoadChannelsOnUI(YoutubeChannel[] videoList)
	{
		for (int i = 0; i < videoList.Length; i++)
		{
			UnityEngine.Debug.Log(videoList[i].thumbnail);
			channelListUI[i].GetComponent<YoutubeChannelUI>().videoName.text = videoList[i].title;
			channelListUI[i].GetComponent<YoutubeChannelUI>().videoId = videoList[i].id;
			channelListUI[i].GetComponent<YoutubeChannelUI>().thumbUrl = videoList[i].thumbnail;
			channelListUI[i].GetComponent<YoutubeChannelUI>().LoadThumbnail();
		}
	}

	public void LoadChannelResult(string channelId)
	{
		youtubeapi.GetChannelVideos(channelId, 10, OnChannelResultLoaded);
	}

	private void OnChannelResultLoaded(YoutubeData[] videoList)
	{
		channelUIResult.SetActive(value: false);
		videoUIResult.SetActive(value: true);
		for (int i = 0; i < videoList.Length; i++)
		{
			videoListUI[i].GetComponent<YoutubeVideoUi>().videoName.text = videoList[i].snippet.title;
			videoListUI[i].GetComponent<YoutubeVideoUi>().videoId = videoList[i].id;
			videoListUI[i].GetComponent<YoutubeVideoUi>().thumbUrl = videoList[i].snippet.thumbnails.defaultThumbnail.url;
			videoListUI[i].GetComponent<YoutubeVideoUi>().LoadThumbnail();
		}
	}
}
public class CommentsDemo : MonoBehaviour
{
	private YoutubeAPIManager youtubeapi;

	public Text videoIdInput;

	public Text commentsTextArea;

	private void Start()
	{
		youtubeapi = UnityEngine.Object.FindObjectOfType<YoutubeAPIManager>();
		if (youtubeapi == null)
		{
			youtubeapi = base.gameObject.AddComponent<YoutubeAPIManager>();
		}
	}

	public void GetComments()
	{
		youtubeapi.GetComments(videoIdInput.text, OnFinishLoadingComments);
	}

	private void OnFinishLoadingComments(YoutubeComments[] comments)
	{
		string text = "";
		for (int i = 0; i < comments.Length; i++)
		{
			text = text + "<color=red>" + comments[i].authorDisplayName + "</color>: " + comments[i].textDisplay + "\n";
		}
		commentsTextArea.text = text;
	}
}
public class IndividualVideoDataDemo : MonoBehaviour
{
	private YoutubeAPIManager youtubeapi;

	public Text videoIdInput;

	public Text UI_title;

	public Text UI_description;

	public Text UI_duration;

	public Text UI_likes;

	public Text UI_dislikes;

	public Text UI_favorites;

	public Text UI_comments;

	public Text UI_views;

	public Image UI_thumbnail;

	private void Start()
	{
		youtubeapi = UnityEngine.Object.FindObjectOfType<YoutubeAPIManager>();
		if (youtubeapi == null)
		{
			youtubeapi = base.gameObject.AddComponent<YoutubeAPIManager>();
		}
	}

	public void GetVideoData()
	{
		youtubeapi.GetVideoData(videoIdInput.text, OnFinishLoadingData);
	}

	private void OnFinishLoadingData(YoutubeData result)
	{
		UI_title.text = result.snippet.title;
		UI_description.text = result.snippet.description;
		UI_duration.text = "Duration: " + result.contentDetails.duration.Replace("PT", "");
		UI_likes.text = "Likes: " + result.statistics.likeCount;
		UI_dislikes.text = "Dislikes: " + result.statistics.dislikeCount;
		UI_favorites.text = "Favs: " + result.statistics.favoriteCount;
		UI_comments.text = "Comments: " + result.statistics.commentCount;
		UI_views.text = "Views: " + result.statistics.viewCount;
		LoadThumbnail(result.snippet.thumbnails.defaultThumbnail.url);
	}

	private void LoadThumbnail(string url)
	{
		StartCoroutine(DownloadThumb(url));
	}

	private IEnumerator DownloadThumb(string url)
	{
		WWW www = new WWW(url);
		yield return www;
		Texture2D texture2D = new Texture2D(100, 100);
		www.LoadImageIntoTexture(texture2D);
		UI_thumbnail.sprite = Sprite.Create(texture2D, new Rect(0f, 0f, texture2D.width, texture2D.height), new Vector2(0.5f, 0.5f), 100f);
	}
}
public class PlaylistDemo : MonoBehaviour
{
	private YoutubeAPIManager youtubeapi;

	public Text searchField;

	public YoutubeVideoUi[] videoListUI;

	public GameObject videoUIResult;

	public GameObject mainUI;

	private void Start()
	{
		youtubeapi = UnityEngine.Object.FindObjectOfType<YoutubeAPIManager>();
		if (youtubeapi == null)
		{
			youtubeapi = base.gameObject.AddComponent<YoutubeAPIManager>();
		}
	}

	public void GetPlaylist()
	{
		youtubeapi.GetPlaylistItems(searchField.text, 10, OnGetPlaylistDone);
	}

	private void OnGetPlaylistDone(YoutubePlaylistItems[] results)
	{
		videoUIResult.SetActive(value: true);
		LoadVideosOnUI(results);
	}

	private void LoadVideosOnUI(YoutubePlaylistItems[] videoList)
	{
		for (int i = 0; i < videoList.Length; i++)
		{
			videoListUI[i].GetComponent<YoutubeVideoUi>().videoName.text = videoList[i].snippet.title;
			videoListUI[i].GetComponent<YoutubeVideoUi>().videoId = videoList[i].videoId;
			videoListUI[i].GetComponent<YoutubeVideoUi>().thumbUrl = videoList[i].snippet.thumbnails.defaultThumbnail.url;
			videoListUI[i].GetComponent<YoutubeVideoUi>().LoadThumbnail();
		}
	}
}
public class VideoSearchDemo : MonoBehaviour
{
	private YoutubeAPIManager youtubeapi;

	public Text searchField;

	public Text categoryField;

	public Toggle categoryFilter;

	public Dropdown mainFilters;

	public YoutubeVideoUi[] videoListUI;

	public GameObject videoUIResult;

	public GameObject mainUI;

	private void Start()
	{
		youtubeapi = UnityEngine.Object.FindObjectOfType<YoutubeAPIManager>();
		if (youtubeapi == null)
		{
			youtubeapi = base.gameObject.AddComponent<YoutubeAPIManager>();
		}
	}

	public void Search()
	{
		YoutubeAPIManager.YoutubeSearchOrderFilter order = YoutubeAPIManager.YoutubeSearchOrderFilter.none;
		switch (mainFilters.value)
		{
		case 0:
			order = YoutubeAPIManager.YoutubeSearchOrderFilter.none;
			break;
		case 1:
			order = YoutubeAPIManager.YoutubeSearchOrderFilter.date;
			break;
		case 2:
			order = YoutubeAPIManager.YoutubeSearchOrderFilter.rating;
			break;
		case 3:
			order = YoutubeAPIManager.YoutubeSearchOrderFilter.relevance;
			break;
		case 4:
			order = YoutubeAPIManager.YoutubeSearchOrderFilter.title;
			break;
		case 5:
			order = YoutubeAPIManager.YoutubeSearchOrderFilter.videoCount;
			break;
		case 6:
			order = YoutubeAPIManager.YoutubeSearchOrderFilter.viewCount;
			break;
		}
		if (categoryFilter.isOn)
		{
			youtubeapi.SearchByCategory(searchField.text, categoryField.text, 10, order, YoutubeAPIManager.YoutubeSafeSearchFilter.none, OnSearchDone);
		}
		else
		{
			youtubeapi.Search(searchField.text, 10, order, YoutubeAPIManager.YoutubeSafeSearchFilter.none, OnSearchDone);
		}
	}

	public void SearchByLocation(string location)
	{
		YoutubeAPIManager.YoutubeSearchOrderFilter order = YoutubeAPIManager.YoutubeSearchOrderFilter.none;
		switch (mainFilters.value)
		{
		case 0:
			order = YoutubeAPIManager.YoutubeSearchOrderFilter.none;
			break;
		case 1:
			order = YoutubeAPIManager.YoutubeSearchOrderFilter.date;
			break;
		case 2:
			order = YoutubeAPIManager.YoutubeSearchOrderFilter.rating;
			break;
		case 3:
			order = YoutubeAPIManager.YoutubeSearchOrderFilter.relevance;
			break;
		case 4:
			order = YoutubeAPIManager.YoutubeSearchOrderFilter.title;
			break;
		case 5:
			order = YoutubeAPIManager.YoutubeSearchOrderFilter.videoCount;
			break;
		case 6:
			order = YoutubeAPIManager.YoutubeSearchOrderFilter.viewCount;
			break;
		}
		string[] array = location.Split(',');
		float latitude = float.Parse(array[0]);
		float longitude = float.Parse(array[1]);
		int locationRadius = 10;
		youtubeapi.SearchByLocation(searchField.text, 10, locationRadius, latitude, longitude, order, YoutubeAPIManager.YoutubeSafeSearchFilter.none, OnSearchDone);
	}

	private void OnSearchDone(YoutubeData[] results)
	{
		videoUIResult.SetActive(value: true);
		LoadVideosOnUI(results);
	}

	private void LoadVideosOnUI(YoutubeData[] videoList)
	{
		for (int i = 0; i < videoList.Length; i++)
		{
			videoListUI[i].GetComponent<YoutubeVideoUi>().videoName.text = videoList[i].snippet.title;
			videoListUI[i].GetComponent<YoutubeVideoUi>().videoId = videoList[i].id;
			videoListUI[i].GetComponent<YoutubeVideoUi>().thumbUrl = videoList[i].snippet.thumbnails.defaultThumbnail.url;
			videoListUI[i].GetComponent<YoutubeVideoUi>().LoadThumbnail();
		}
	}
}
public class YoutubeApiGetUnlimitedVideos : MonoBehaviour
{
	public string APIKey = "AIzaSyDD-lxGLHsBIFPFPt2i31fc0tAHGeAb8mc";

	public string searchKeyword = "Unity";

	[SerializeField]
	private List<YoutubeData> searchResults;

	private int currentResults;

	public int maxResult;

	private void Start()
	{
		searchResults = new List<YoutubeData>();
		UnityEngine.Debug.Log("Demo call");
		StartCoroutine(YoutubeSearch("Unity"));
	}

	private IEnumerator YoutubeSearch(string keyword)
	{
		keyword = keyword.Replace(" ", "%20");
		int num = ((maxResult <= 50) ? maxResult : 50);
		string s = WWW.EscapeURL("https://www.googleapis.com/youtube/v3/search/?q=" + keyword + "&type=video&maxResults=" + num + "&part=snippet,id&key=" + APIKey);
		WWW call = new WWW(WWW.UnEscapeURL(s));
		yield return call;
		JSONNode jSONNode = JSON.Parse(call.text);
		currentResults += jSONNode["items"].Count;
		for (int i = 0; i < jSONNode["items"].Count; i++)
		{
			YoutubeData youtubeData = new YoutubeData();
			youtubeData.id = jSONNode["items"][i]["id"]["videoId"];
			SetSnippet(jSONNode["items"][i]["snippet"], out youtubeData.snippet);
			searchResults.Add(youtubeData);
		}
		if (currentResults < maxResult)
		{
			StartCoroutine(YoutubeGetNextPage(jSONNode["nextPageToken"]));
		}
		else
		{
			UnityEngine.Debug.Log("List is done");
		}
	}

	private IEnumerator YoutubeGetNextPage(string pageToken)
	{
		int num = ((maxResult <= 50) ? maxResult : 50);
		string s = WWW.EscapeURL("https://www.googleapis.com/youtube/v3/search/?pageToken=" + pageToken + "&type=video&maxResults=" + num + "&part=snippet,id&key=" + APIKey);
		WWW call = new WWW(WWW.UnEscapeURL(s));
		yield return call;
		JSONNode jSONNode = JSON.Parse(call.text);
		currentResults += jSONNode["items"].Count;
		for (int i = 0; i < jSONNode["items"].Count; i++)
		{
			YoutubeData youtubeData = new YoutubeData();
			youtubeData.id = jSONNode["items"][i]["id"]["videoId"];
			SetSnippet(jSONNode["items"][i]["snippet"], out youtubeData.snippet);
			searchResults.Add(youtubeData);
		}
		if (currentResults < maxResult)
		{
			StartCoroutine(YoutubeGetNextPage(jSONNode["nextPageToken"]));
		}
		else
		{
			UnityEngine.Debug.Log("List is done");
		}
	}

	private void SetSnippet(JSONNode resultSnippet, out YoutubeSnippet data)
	{
		data = new YoutubeSnippet();
		data.publishedAt = resultSnippet["publishedAt"];
		data.channelId = resultSnippet["channelId"];
		data.title = resultSnippet["title"];
		UnityEngine.Debug.Log(data.title);
		data.description = resultSnippet["description"];
		data.thumbnails = new YoutubeTumbnails();
		data.thumbnails.defaultThumbnail = new YoutubeThumbnailData();
		data.thumbnails.defaultThumbnail.url = resultSnippet["thumbnails"]["default"]["url"];
		data.thumbnails.defaultThumbnail.width = resultSnippet["thumbnails"]["default"]["width"];
		data.thumbnails.defaultThumbnail.height = resultSnippet["thumbnails"]["default"]["height"];
		data.thumbnails.mediumThumbnail = new YoutubeThumbnailData();
		data.thumbnails.mediumThumbnail.url = resultSnippet["thumbnails"]["medium"]["url"];
		data.thumbnails.mediumThumbnail.width = resultSnippet["thumbnails"]["medium"]["width"];
		data.thumbnails.mediumThumbnail.height = resultSnippet["thumbnails"]["medium"]["height"];
		data.thumbnails.highThumbnail = new YoutubeThumbnailData();
		data.thumbnails.highThumbnail.url = resultSnippet["thumbnails"]["high"]["url"];
		data.thumbnails.highThumbnail.width = resultSnippet["thumbnails"]["high"]["width"];
		data.thumbnails.highThumbnail.height = resultSnippet["thumbnails"]["high"]["height"];
		data.thumbnails.standardThumbnail = new YoutubeThumbnailData();
		data.thumbnails.standardThumbnail.url = resultSnippet["thumbnails"]["standard"]["url"];
		data.thumbnails.standardThumbnail.width = resultSnippet["thumbnails"]["standard"]["width"];
		data.thumbnails.standardThumbnail.height = resultSnippet["thumbnails"]["standard"]["height"];
		data.channelTitle = resultSnippet["channelTitle"];
		data.tags = new string[resultSnippet["tags"].Count];
		for (int i = 0; i < data.tags.Length; i++)
		{
			data.tags[i] = resultSnippet["tags"][i];
		}
		data.categoryId = resultSnippet["categoryId"];
	}
}
public class YoutubeChannelUI : MonoBehaviour
{
	public Text videoName;

	public string videoId;

	public string thumbUrl;

	public Image videoThumb;

	public void LoadChannel()
	{
		UnityEngine.Object.FindObjectOfType<ChannelSearchDemo>().LoadChannelResult(videoId);
	}

	public void LoadThumbnail()
	{
		StartCoroutine(DownloadThumb());
	}

	private IEnumerator DownloadThumb()
	{
		WWW www = new WWW(thumbUrl);
		yield return www;
		Texture2D texture2D = new Texture2D(100, 100);
		www.LoadImageIntoTexture(texture2D);
		videoThumb.sprite = Sprite.Create(texture2D, new Rect(0f, 0f, texture2D.width, texture2D.height), new Vector2(0.5f, 0.5f), 100f);
	}
}
public class YoutubeVideoUi : MonoBehaviour
{
	public Text videoName;

	public string videoId;

	public string thumbUrl;

	public Image videoThumb;

	private GameObject mainUI;

	public void PlayYoutubeVideo()
	{
		if (UnityEngine.Object.FindObjectOfType<SimplePlayback>() != null)
		{
			UnityEngine.Object.FindObjectOfType<SimplePlayback>().PlayYoutubeVideo(videoId);
			UnityEngine.Object.FindObjectOfType<SimplePlayback>().unityVideoPlayer.loopPointReached += VideoFinished;
		}
		else if (UnityEngine.Object.FindObjectOfType<HighQualityPlayback>() != null)
		{
			UnityEngine.Object.FindObjectOfType<HighQualityPlayback>().PlayYoutubeVideo(videoId);
			UnityEngine.Object.FindObjectOfType<HighQualityPlayback>().unityVideoPlayer.loopPointReached += VideoFinished;
		}
		if (UnityEngine.Object.FindObjectOfType<VideoSearchDemo>() != null)
		{
			mainUI = UnityEngine.Object.FindObjectOfType<VideoSearchDemo>().mainUI;
		}
		else if (UnityEngine.Object.FindObjectOfType<ChannelSearchDemo>() != null)
		{
			mainUI = UnityEngine.Object.FindObjectOfType<ChannelSearchDemo>().mainUI;
		}
		else if (UnityEngine.Object.FindObjectOfType<PlaylistDemo>() != null)
		{
			mainUI = UnityEngine.Object.FindObjectOfType<PlaylistDemo>().mainUI;
		}
	}

	private void VideoFinished(VideoPlayer vPlayer)
	{
		if (UnityEngine.Object.FindObjectOfType<SimplePlayback>() != null)
		{
			UnityEngine.Object.FindObjectOfType<SimplePlayback>().unityVideoPlayer.loopPointReached -= VideoFinished;
		}
		else if (UnityEngine.Object.FindObjectOfType<HighQualityPlayback>() != null)
		{
			UnityEngine.Object.FindObjectOfType<HighQualityPlayback>().unityVideoPlayer.loopPointReached -= VideoFinished;
		}
		UnityEngine.Debug.Log("Video Finished");
		mainUI.SetActive(value: true);
	}

	public IEnumerator PlayVideo(string url)
	{
		yield return Handheld.PlayFullScreenMovie(url, Color.black, FullScreenMovieControlMode.Full, FullScreenMovieScalingMode.Fill);
		UnityEngine.Debug.Log("below this line will run when the video is finished");
		VideoFinished();
	}

	public void LoadThumbnail()
	{
		StartCoroutine(DownloadThumb());
	}

	private IEnumerator DownloadThumb()
	{
		WWW www = new WWW(thumbUrl);
		yield return www;
		Texture2D texture2D = new Texture2D(100, 100);
		www.LoadImageIntoTexture(texture2D);
		videoThumb.sprite = Sprite.Create(texture2D, new Rect(0f, 0f, texture2D.width, texture2D.height), new Vector2(0.5f, 0.5f), 100f);
	}

	public void VideoFinished()
	{
		UnityEngine.Debug.Log("Finished!");
	}
}
public class YoutubeAPIManager : MonoBehaviour
{
	public enum YoutubeSearchOrderFilter
	{
		none,
		date,
		rating,
		relevance,
		title,
		videoCount,
		viewCount
	}

	public enum YoutubeSafeSearchFilter
	{
		none,
		moderate,
		strict
	}

	private YoutubeData data;

	private YoutubeData[] searchResults;

	private YoutubeComments[] comments;

	private YoutubePlaylistItems[] playslistItems;

	private YoutubeChannel[] channels;

	private const string APIKey = "AIzaSyDD-lxGLHsBIFPFPt2i31fc0tAHGeAb8mc";

	public void GetVideoData(string videoId, Action<YoutubeData> callback)
	{
		StartCoroutine(LoadSingleVideo(videoId, callback));
	}

	private void Start()
	{
		UnityEngine.Debug.LogWarning("REMEMBER TO CHANGE THE API KEY TO YOUR OWN KEY - REMOVE THIS IF YOU CHANGED");
	}

	public void GetChannelVideos(string channelId, int maxResults, Action<YoutubeData[]> callback)
	{
		StartCoroutine(GetVideosFromChannel(channelId, maxResults, callback));
	}

	public void Search(string keyword, int maxResult, YoutubeSearchOrderFilter order, YoutubeSafeSearchFilter safeSearch, Action<YoutubeData[]> callback)
	{
		StartCoroutine(YoutubeSearch(keyword, maxResult, order, safeSearch, callback));
	}

	public void SearchForChannels(string keyword, int maxResult, YoutubeSearchOrderFilter order, YoutubeSafeSearchFilter safeSearch, Action<YoutubeChannel[]> callback)
	{
		StartCoroutine(YoutubeSearchChannel(keyword, maxResult, order, safeSearch, callback));
	}

	public void SearchByCategory(string keyword, string category, int maxResult, YoutubeSearchOrderFilter order, YoutubeSafeSearchFilter safeSearch, Action<YoutubeData[]> callback)
	{
		StartCoroutine(YoutubeSearchUsingCategory(keyword, category, maxResult, order, safeSearch, callback));
	}

	public void SearchByLocation(string keyword, int maxResult, int locationRadius, float latitude, float longitude, YoutubeSearchOrderFilter order, YoutubeSafeSearchFilter safeSearch, Action<YoutubeData[]> callback)
	{
		StartCoroutine(YoutubeSearchByLocation(keyword, maxResult, locationRadius, latitude, longitude, order, safeSearch, callback));
	}

	public void GetComments(string videoId, Action<YoutubeComments[]> callback)
	{
		StartCoroutine(YoutubeCallComments(videoId, callback));
	}

	public void GetPlaylistItems(string playlistId, int maxResults, Action<YoutubePlaylistItems[]> callback)
	{
		StartCoroutine(YoutubeCallPlaylist(playlistId, maxResults, callback));
	}

	private IEnumerator GetVideosFromChannel(string channelId, int maxResults, Action<YoutubeData[]> callback)
	{
		WWW call = new WWW("https://www.googleapis.com/youtube/v3/search?order=date&type=video&part=snippet&channelId=" + channelId + "&maxResults=" + maxResults + "&key=AIzaSyDD-lxGLHsBIFPFPt2i31fc0tAHGeAb8mc");
		yield return call;
		UnityEngine.Debug.Log(call.url);
		JSONNode jSONNode = JSON.Parse(call.text);
		searchResults = new YoutubeData[jSONNode["items"].Count];
		for (int i = 0; i < searchResults.Length; i++)
		{
			searchResults[i] = new YoutubeData();
			searchResults[i].id = jSONNode["items"][i]["id"]["videoId"];
			SetSnippet(jSONNode["items"][i]["snippet"], out searchResults[i].snippet);
		}
		callback(searchResults);
	}

	private IEnumerator YoutubeCallPlaylist(string playlistId, int maxResults, Action<YoutubePlaylistItems[]> callback)
	{
		WWW call = new WWW("https://www.googleapis.com/youtube/v3/playlistItems/?playlistId=" + playlistId + "&maxResults=" + maxResults + "&part=snippet%2CcontentDetails&key=AIzaSyDD-lxGLHsBIFPFPt2i31fc0tAHGeAb8mc");
		yield return call;
		UnityEngine.Debug.Log(call.url);
		JSONNode jSONNode = JSON.Parse(call.text);
		playslistItems = new YoutubePlaylistItems[jSONNode["items"].Count];
		for (int i = 0; i < playslistItems.Length; i++)
		{
			playslistItems[i] = new YoutubePlaylistItems();
			playslistItems[i].videoId = jSONNode["items"][i]["snippet"]["resourceId"]["videoId"];
			SetSnippet(jSONNode["items"][i]["snippet"], out playslistItems[i].snippet);
		}
		callback(playslistItems);
	}

	private IEnumerator YoutubeCallComments(string videoId, Action<YoutubeComments[]> callback)
	{
		WWW call = new WWW("https://www.googleapis.com/youtube/v3/commentThreads/?videoId=" + videoId + "&part=snippet%2Creplies&key=AIzaSyDD-lxGLHsBIFPFPt2i31fc0tAHGeAb8mc");
		yield return call;
		UnityEngine.Debug.Log(call.url);
		JSONNode jSONNode = JSON.Parse(call.text);
		comments = new YoutubeComments[jSONNode["items"].Count];
		for (int i = 0; i < comments.Length; i++)
		{
			comments[i] = new YoutubeComments();
			SetComment(jSONNode["items"][i]["snippet"], out comments[i]);
		}
		callback(comments);
	}

	private IEnumerator YoutubeSearchUsingCategory(string keyword, string category, int maxresult, YoutubeSearchOrderFilter order, YoutubeSafeSearchFilter safeSearch, Action<YoutubeData[]> callback)
	{
		keyword = keyword.Replace(" ", "%20");
		category = category.Replace(" ", "%20");
		string text = "";
		if (order != 0)
		{
			text = "&order=" + order;
		}
		string text2 = "&safeSearch=" + safeSearch;
		WWW call = new WWW("https://www.googleapis.com/youtube/v3/search/?q=" + keyword + "&category=" + category + "&maxResults=" + maxresult + "&type=video&part=snippet,id&key=AIzaSyDD-lxGLHsBIFPFPt2i31fc0tAHGeAb8mc" + text + text2);
		yield return call;
		UnityEngine.Debug.Log(call.url);
		JSONNode jSONNode = JSON.Parse(call.text);
		searchResults = new YoutubeData[jSONNode["items"].Count];
		UnityEngine.Debug.Log(searchResults.Length);
		for (int i = 0; i < searchResults.Length; i++)
		{
			searchResults[i] = new YoutubeData();
			searchResults[i].id = jSONNode["items"][i]["id"]["videoId"];
			SetSnippet(jSONNode["items"][i]["snippet"], out searchResults[i].snippet);
		}
		callback(searchResults);
	}

	private IEnumerator YoutubeSearchChannel(string keyword, int maxresult, YoutubeSearchOrderFilter order, YoutubeSafeSearchFilter safeSearch, Action<YoutubeChannel[]> callback)
	{
		keyword = keyword.Replace(" ", "%20");
		string text = "";
		if (order != 0)
		{
			text = "&order=" + order;
		}
		string text2 = "&safeSearch=" + safeSearch;
		WWW call = new WWW("https://www.googleapis.com/youtube/v3/search/?q=" + keyword + "&type=channel&maxResults=" + maxresult + "&part=snippet,id&key=AIzaSyDD-lxGLHsBIFPFPt2i31fc0tAHGeAb8mc" + text + text2);
		yield return call;
		UnityEngine.Debug.Log(call.url);
		JSONNode jSONNode = JSON.Parse(call.text);
		channels = new YoutubeChannel[jSONNode["items"].Count];
		for (int i = 0; i < channels.Length; i++)
		{
			channels[i] = new YoutubeChannel();
			channels[i].id = jSONNode["items"][i]["id"]["channelId"];
			channels[i].title = jSONNode["items"][i]["snippet"]["title"];
			channels[i].description = jSONNode["items"][i]["snippet"]["description"];
			channels[i].thumbnail = jSONNode["items"][i]["snippet"]["thumbnails"]["high"]["url"];
		}
		callback(channels);
	}

	private IEnumerator YoutubeSearch(string keyword, int maxresult, YoutubeSearchOrderFilter order, YoutubeSafeSearchFilter safeSearch, Action<YoutubeData[]> callback)
	{
		keyword = keyword.Replace(" ", "%20");
		string text = "";
		if (order != 0)
		{
			text = "&order=" + order;
		}
		string text2 = "&safeSearch=" + safeSearch;
		string text3 = WWW.EscapeURL("https://www.googleapis.com/youtube/v3/search/?q=" + keyword + "&type=video&maxResults=" + maxresult + "&part=snippet,id&key=AIzaSyDD-lxGLHsBIFPFPt2i31fc0tAHGeAb8mc" + text + text2);
		UnityEngine.Debug.Log(text3);
		WWW call = new WWW(WWW.UnEscapeURL(text3));
		yield return call;
		UnityEngine.Debug.Log(call.url);
		JSONNode jSONNode = JSON.Parse(call.text);
		searchResults = new YoutubeData[jSONNode["items"].Count];
		UnityEngine.Debug.Log(searchResults.Length);
		for (int i = 0; i < searchResults.Length; i++)
		{
			searchResults[i] = new YoutubeData();
			searchResults[i].id = jSONNode["items"][i]["id"]["videoId"];
			SetSnippet(jSONNode["items"][i]["snippet"], out searchResults[i].snippet);
		}
		callback(searchResults);
	}

	private IEnumerator YoutubeSearchByLocation(string keyword, int maxResult, int locationRadius, float latitude, float longitude, YoutubeSearchOrderFilter order, YoutubeSafeSearchFilter safeSearch, Action<YoutubeData[]> callback)
	{
		keyword = keyword.Replace(" ", "%20");
		string text = "";
		if (order != 0)
		{
			text = "&order=" + order;
		}
		string text2 = "&safeSearch=" + safeSearch;
		WWW call = new WWW("https://www.googleapis.com/youtube/v3/search/?type=video&q=" + keyword + "&type=video&locationRadius=" + locationRadius + "mi&location=" + latitude + "%2C" + longitude + "&part=snippet,id&maxResults=" + maxResult + "&key=AIzaSyDD-lxGLHsBIFPFPt2i31fc0tAHGeAb8mc" + text + text2);
		yield return call;
		UnityEngine.Debug.Log(call.url);
		JSONNode jSONNode = JSON.Parse(call.text);
		searchResults = new YoutubeData[jSONNode["items"].Count];
		UnityEngine.Debug.Log(searchResults.Length);
		for (int i = 0; i < searchResults.Length; i++)
		{
			searchResults[i] = new YoutubeData();
			searchResults[i].id = jSONNode["items"][i]["id"]["videoId"];
			SetSnippet(jSONNode["items"][i]["snippet"], out searchResults[i].snippet);
		}
		callback(searchResults);
	}

	private IEnumerator LoadSingleVideo(string videoId, Action<YoutubeData> callback)
	{
		WWW call = new WWW("https://www.googleapis.com/youtube/v3/videos?id=" + videoId + "&part=snippet,id,contentDetails,statistics&key=AIzaSyDD-lxGLHsBIFPFPt2i31fc0tAHGeAb8mc");
		yield return call;
		data = new YoutubeData();
		JSONNode jSONNode = JSON.Parse(call.text);
		jSONNode = jSONNode["items"][0];
		data.id = jSONNode["id"];
		SetSnippet(jSONNode["snippet"], out data.snippet);
		SetStatistics(jSONNode["statistics"], out data.statistics);
		SetContentDetails(jSONNode["contentDetails"], out data.contentDetails);
		callback(data);
	}

	private void SetSnippet(JSONNode resultSnippet, out YoutubeSnippet data)
	{
		data = new YoutubeSnippet();
		data.publishedAt = resultSnippet["publishedAt"];
		data.channelId = resultSnippet["channelId"];
		data.title = resultSnippet["title"];
		data.description = resultSnippet["description"];
		data.thumbnails = new YoutubeTumbnails();
		data.thumbnails.defaultThumbnail = new YoutubeThumbnailData();
		data.thumbnails.defaultThumbnail.url = resultSnippet["thumbnails"]["default"]["url"];
		data.thumbnails.defaultThumbnail.width = resultSnippet["thumbnails"]["default"]["width"];
		data.thumbnails.defaultThumbnail.height = resultSnippet["thumbnails"]["default"]["height"];
		data.thumbnails.mediumThumbnail = new YoutubeThumbnailData();
		data.thumbnails.mediumThumbnail.url = resultSnippet["thumbnails"]["medium"]["url"];
		data.thumbnails.mediumThumbnail.width = resultSnippet["thumbnails"]["medium"]["width"];
		data.thumbnails.mediumThumbnail.height = resultSnippet["thumbnails"]["medium"]["height"];
		data.thumbnails.highThumbnail = new YoutubeThumbnailData();
		data.thumbnails.highThumbnail.url = resultSnippet["thumbnails"]["high"]["url"];
		data.thumbnails.highThumbnail.width = resultSnippet["thumbnails"]["high"]["width"];
		data.thumbnails.highThumbnail.height = resultSnippet["thumbnails"]["high"]["height"];
		data.thumbnails.standardThumbnail = new YoutubeThumbnailData();
		data.thumbnails.standardThumbnail.url = resultSnippet["thumbnails"]["standard"]["url"];
		data.thumbnails.standardThumbnail.width = resultSnippet["thumbnails"]["standard"]["width"];
		data.thumbnails.standardThumbnail.height = resultSnippet["thumbnails"]["standard"]["height"];
		data.channelTitle = resultSnippet["channelTitle"];
		data.tags = new string[resultSnippet["tags"].Count];
		for (int i = 0; i < data.tags.Length; i++)
		{
			data.tags[i] = resultSnippet["tags"][i];
		}
		data.categoryId = resultSnippet["categoryId"];
	}

	private void SetStatistics(JSONNode resultStatistics, out YoutubeStatistics data)
	{
		data = new YoutubeStatistics();
		data.viewCount = resultStatistics["viewCount"];
		data.likeCount = resultStatistics["likeCount"];
		data.dislikeCount = resultStatistics["dislikeCount"];
		data.favoriteCount = resultStatistics["favoriteCount"];
		data.commentCount = resultStatistics["commentCount"];
	}

	private void SetContentDetails(JSONNode resultContentDetails, out YoutubeContentDetails data)
	{
		data = new YoutubeContentDetails();
		data.duration = resultContentDetails["duration"];
		data.dimension = resultContentDetails["dimension"];
		data.definition = resultContentDetails["definition"];
		data.caption = resultContentDetails["caption"];
		data.licensedContent = resultContentDetails["licensedContent"];
		data.projection = resultContentDetails["projection"];
	}

	private void SetComment(JSONNode commentsData, out YoutubeComments data)
	{
		data = new YoutubeComments();
		data.videoId = commentsData["videoId"];
		JSONNode jSONNode = commentsData["topLevelComment"]["snippet"];
		data.authorDisplayName = jSONNode["authorDisplayName"];
		data.authorProfileImageUrl = jSONNode["authorProfileImageUrl"];
		data.authorChannelUrl = jSONNode["authorChannelUrl"];
		data.authorChannelId = jSONNode["authorChannelId"]["value"];
		data.textDisplay = jSONNode["textDisplay"];
		data.textOriginal = jSONNode["textOriginal"];
		data.canRate = jSONNode["canRate"].AsBool;
		data.viewerRating = jSONNode["viewerRating"];
		data.likeCount = jSONNode["likeCount"].AsInt;
		data.publishedAt = jSONNode["publishedAt"];
		data.updatedAt = jSONNode["updatedAt"];
	}
}
public class YoutubeData
{
	public YoutubeSnippet snippet;

	public YoutubeStatistics statistics;

	public YoutubeContentDetails contentDetails;

	public string id;
}
public class YoutubeComments
{
	public string authorDisplayName;

	public string authorProfileImageUrl;

	public string authorChannelUrl;

	public string authorChannelId;

	public string videoId;

	public string textDisplay;

	public string textOriginal;

	public bool canRate;

	public string viewerRating;

	public int likeCount;

	public string publishedAt;

	public string updatedAt;
}
public class YoutubePlaylistItems
{
	public string videoId;

	public YoutubeSnippet snippet;
}
public class YoutubeChannel
{
	public string id;

	public string title;

	public string description;

	public string thumbnail;
}
public class YoutubeContentDetails
{
	public string duration;

	public string dimension;

	public string definition;

	public string caption;

	public string licensedContent;

	public string projection;
}
public class YoutubeSnippet
{
	public string publishedAt;

	public string channelId;

	public string title;

	public string description;

	public YoutubeTumbnails thumbnails;

	public string channelTitle;

	public string[] tags;

	public string categoryId;
}
public class YoutubeTumbnails
{
	public YoutubeThumbnailData defaultThumbnail;

	public YoutubeThumbnailData mediumThumbnail;

	public YoutubeThumbnailData highThumbnail;

	public YoutubeThumbnailData standardThumbnail;
}
public class YoutubeThumbnailData
{
	public string url;

	public string width;

	public string height;
}
public class YoutubeStatistics
{
	public string viewCount;

	public string likeCount;

	public string dislikeCount;

	public string favoriteCount;

	public string commentCount;
}
public class YoutubeDemoUsage : MonoBehaviour
{
	public GameObject mainUI;

	public Text videoUrlInput;

	public void DemoPlayback()
	{
		if (UnityEngine.Object.FindObjectOfType<SimplePlayback>() != null)
		{
			UnityEngine.Object.FindObjectOfType<SimplePlayback>().PlayYoutubeVideo("bc0sJvtKrRM");
			UnityEngine.Object.FindObjectOfType<SimplePlayback>().unityVideoPlayer.loopPointReached += OnVideoFinished;
		}
		else if (UnityEngine.Object.FindObjectOfType<HighQualityPlayback>() != null)
		{
			UnityEngine.Object.FindObjectOfType<HighQualityPlayback>().PlayYoutubeVideo("bc0sJvtKrRM");
			UnityEngine.Object.FindObjectOfType<HighQualityPlayback>().unityVideoPlayer.loopPointReached += OnVideoFinished;
		}
		mainUI.SetActive(value: false);
	}

	public void PlayFromInput()
	{
		if (UnityEngine.Object.FindObjectOfType<SimplePlayback>() != null)
		{
			UnityEngine.Object.FindObjectOfType<SimplePlayback>().PlayYoutubeVideo(videoUrlInput.text);
			UnityEngine.Object.FindObjectOfType<SimplePlayback>().unityVideoPlayer.loopPointReached += OnVideoFinished;
		}
		else if (UnityEngine.Object.FindObjectOfType<HighQualityPlayback>() != null)
		{
			UnityEngine.Object.FindObjectOfType<HighQualityPlayback>().PlayYoutubeVideo(videoUrlInput.text);
			UnityEngine.Object.FindObjectOfType<HighQualityPlayback>().unityVideoPlayer.loopPointReached += OnVideoFinished;
		}
		mainUI.SetActive(value: false);
	}

	private void OnVideoFinished(VideoPlayer vPlayer)
	{
		if (UnityEngine.Object.FindObjectOfType<SimplePlayback>() != null)
		{
			UnityEngine.Object.FindObjectOfType<SimplePlayback>().unityVideoPlayer.loopPointReached -= OnVideoFinished;
		}
		else if (UnityEngine.Object.FindObjectOfType<HighQualityPlayback>() != null)
		{
			UnityEngine.Object.FindObjectOfType<HighQualityPlayback>().unityVideoPlayer.loopPointReached -= OnVideoFinished;
		}
		mainUI.SetActive(value: true);
	}
}
public class YoutubeEasyMovieTexture : MonoBehaviour
{
	public string videoId = "bc0sJvtKrRM";

	private string videoUrl;

	private RequestResolver resolver;

	public void Start()
	{
		resolver = base.gameObject.AddComponent<RequestResolver>();
		GetURL(videoId);
	}

	public void GetURL(string _videoId)
	{
		videoId = _videoId;
		StartCoroutine(resolver.GetDownloadUrls(FinishLoadingUrls, videoId, decryptSignature: false));
	}

	private void FinishLoadingUrls()
	{
		foreach (VideoInfo videoInfo in resolver.videoInfos)
		{
			if (videoInfo.VideoType == VideoType.Mp4 && videoInfo.Resolution == 360)
			{
				if (videoInfo.RequiresDecryption)
				{
					StartCoroutine(resolver.DecryptDownloadUrl(DecryptionFinished, videoInfo));
				}
				else
				{
					videoUrl = videoInfo.DownloadUrl;
				}
				break;
			}
		}
	}

	public void DecryptionFinished(string url)
	{
		videoUrl = url;
	}
}
public class JsonNetSample : MonoBehaviour
{
	public class Product
	{
		public string Name;

		public DateTime ExpiryDate = new DateTime(2000, 1, 1, 0, 0, 0, DateTimeKind.Utc);

		public decimal Price;

		public string[] Sizes;

		public override bool Equals(object obj)
		{
			if (obj is Product)
			{
				Product product = (Product)obj;
				if (product.Name == Name && product.ExpiryDate == ExpiryDate)
				{
					return product.Price == Price;
				}
				return false;
			}
			return base.Equals(obj);
		}

		public override int GetHashCode()
		{
			return (Name ?? string.Empty).GetHashCode();
		}
	}

	[Serializable]
	public class CharacterListItem
	{
		public int Id { get; set; }

		public string Name { get; set; }

		public int Level { get; set; }

		public string Class { get; set; }

		public string Sex { get; set; }
	}

	public class Movie
	{
		public string Name { get; set; }

		public string Description { get; set; }

		public string Classification { get; set; }

		public string Studio { get; set; }

		public DateTime? ReleaseDate { get; set; }

		public List<string> ReleaseCountries { get; set; }
	}

	public Text Output;

	private void Start()
	{
		Output.text = "Start!\n\n";
		TestJson();
		SerailizeJson();
		DeserializeJson();
		LinqToJson();
		JsonPath();
		WriteLine("\nDone!");
	}

	private void WriteLine(string msg)
	{
		Output.text = Output.text + msg + "\n";
	}

	private void TestJson()
	{
		WriteLine("* TestJson");
		CharacterListItem characterListItem = JsonConvert.DeserializeObject<CharacterListItem>("{\"Id\":51, \"Name\":\"padre\", \"Level\":0, \"Class\":\"Vampire\", \"Sex\":\"F\"}");
		WriteLine(characterListItem.Id + " " + characterListItem.Name);
	}

	private void SerailizeJson()
	{
		WriteLine("* SerailizeJson");
		Product product = new Product();
		product.Name = "Apple";
		product.ExpiryDate = new DateTime(2008, 12, 28);
		product.Sizes = new string[1] { "Small" };
		string msg = JsonConvert.SerializeObject(product);
		WriteLine(msg);
	}

	private void DeserializeJson()
	{
		WriteLine("* DeserializeJson");
		string msg = JsonConvert.DeserializeObject<Movie>("{\r\n          'Name': 'Bad Boys',\r\n          'ReleaseDate': '1995-4-7T00:00:00',\r\n          'Genres': [\r\n            'Action',\r\n            'Comedy'\r\n          ]\r\n        }").Name;
		WriteLine(msg);
	}

	private void LinqToJson()
	{
		WriteLine("* LinqToJson");
		JArray jArray = new JArray();
		jArray.Add("Manual text");
		jArray.Add(new DateTime(2000, 5, 23));
		string msg = new JObject { ["MyArray"] = jArray }.ToString();
		WriteLine(msg);
	}

	private void JsonPath()
	{
		WriteLine("* JsonPath");
		JObject jObject = JObject.Parse("{\r\n            'Stores': [\r\n            'Lambton Quay',\r\n            'Willis Street'\r\n            ],\r\n            'Manufacturers': [\r\n            {\r\n                'Name': 'Acme Co',\r\n                'Products': [\r\n                {\r\n                    'Name': 'Anvil',\r\n                    'Price': 50\r\n                }\r\n                ]\r\n            },\r\n            {\r\n                'Name': 'Contoso',\r\n                'Products': [\r\n                {\r\n                    'Name': 'Elbow Grease',\r\n                    'Price': 99.95\r\n                },\r\n                {\r\n                    'Name': 'Headlight Fluid',\r\n                    'Price': 4\r\n                }\r\n                ]\r\n            }\r\n            ]\r\n        }");
		JToken jToken = jObject.SelectToken("$.Manufacturers[?(@.Name == 'Acme Co')]");
		WriteLine(jToken.ToString());
		foreach (JToken item in jObject.SelectTokens("$..Products[?(@.Price >= 50)].Name"))
		{
			WriteLine(item.ToString());
		}
	}
}
public class LoadSceneButton : MonoBehaviour
{
	public void LoadPrevious(UnityEngine.Object scene)
	{
		if (scene != null)
		{
			SceneManager.LoadScene(scene.name);
		}
		else
		{
			SceneManager.LoadScene(SceneManager.GetActiveScene().buildIndex - 1);
		}
	}

	public void LoadNext(UnityEngine.Object scene)
	{
		if (scene != null)
		{
			SceneManager.LoadScene(scene.name);
		}
		else
		{
			SceneManager.LoadScene(SceneManager.GetActiveScene().buildIndex + 1);
		}
	}
}
public class ExampleShowToPoint : MonoBehaviour
{
	public void ShowToPoint(LightningObject lightning)
	{
		if (!lightning.gameObject.activeSelf)
		{
			lightning.Show(Vector3.zero);
		}
		else
		{
			lightning.gameObject.SetActive(value: false);
		}
	}
}
public class ExampleShowToTarget : MonoBehaviour
{
	public LightningObject lightning;

	public void ShowToTarget(Transform target)
	{
		if (!lightning.gameObject.activeSelf)
		{
			lightning.Show(target);
		}
		else
		{
			lightning.gameObject.SetActive(value: false);
		}
	}
}
public class ExampleTimeScaler : BaseLightningTimer
{
	public Text timeScaleText;

	public override float GetDeltaTime()
	{
		return UnityEngine.Random.Range(0.001f, 0.1f);
	}

	public void SetTimeScale(Slider slider)
	{
		Time.timeScale = slider.value;
		OnEnable();
	}

	private void OnEnable()
	{
		timeScaleText.text = $"Current time scale:{Time.timeScale:0.00}";
	}

	private void OnDestroy()
	{
		Time.timeScale = 1f;
	}
}
public class ExampleToggleGameObjectState : MonoBehaviour
{
	public void ToggleState(GameObject toggleGameObject)
	{
		toggleGameObject.SetActive(!toggleGameObject.activeSelf);
	}
}
public class randomrotation : MonoBehaviour
{
	private Vector3 rotationAxis;

	private float speed;

	private Transform mineTransform;

	private void OnEnable()
	{
		speed = UnityEngine.Random.Range(1f, 3f);
		mineTransform = base.transform;
		rotationAxis = UnityEngine.Random.insideUnitSphere;
	}

	private void Update()
	{
		mineTransform.Rotate(rotationAxis, speed * Time.deltaTime * 57.29578f);
	}
}
public class BakeTexturesAtRuntime : MonoBehaviour
{
	public GameObject target;

	private float elapsedTime;

	private MB3_TextureBaker.CreateAtlasesCoroutineResult result = new MB3_TextureBaker.CreateAtlasesCoroutineResult();

	private void OnGUI()
	{
		GUILayout.Label("Time to bake textures: " + elapsedTime);
		if (GUILayout.Button("Combine textures & build combined mesh all at once"))
		{
			MB3_MeshBaker componentInChildren = target.GetComponentInChildren<MB3_MeshBaker>();
			MB3_TextureBaker component = target.GetComponent<MB3_TextureBaker>();
			component.textureBakeResults = ScriptableObject.CreateInstance<MB2_TextureBakeResults>();
			component.resultMaterial = new Material(Shader.Find("Diffuse"));
			float realtimeSinceStartup = Time.realtimeSinceStartup;
			component.CreateAtlases();
			elapsedTime = Time.realtimeSinceStartup - realtimeSinceStartup;
			componentInChildren.ClearMesh();
			componentInChildren.textureBakeResults = component.textureBakeResults;
			componentInChildren.AddDeleteGameObjects(component.GetObjectsToCombine().ToArray(), null, disableRendererInSource: true);
			componentInChildren.Apply();
		}
		if (GUILayout.Button("Combine textures & build combined mesh using coroutine"))
		{
			UnityEngine.Debug.Log("Starting to bake textures on frame " + Time.frameCount);
			MB3_TextureBaker component2 = target.GetComponent<MB3_TextureBaker>();
			component2.textureBakeResults = ScriptableObject.CreateInstance<MB2_TextureBakeResults>();
			component2.resultMaterial = new Material(Shader.Find("Diffuse"));
			component2.onBuiltAtlasesSuccess = OnBuiltAtlasesSuccess;
			StartCoroutine(component2.CreateAtlasesCoroutine(null, result));
		}
	}

	private void OnBuiltAtlasesSuccess()
	{
		UnityEngine.Debug.Log("Calling success callback. baking meshes");
		MB3_MeshBaker componentInChildren = target.GetComponentInChildren<MB3_MeshBaker>();
		MB3_TextureBaker component = target.GetComponent<MB3_TextureBaker>();
		if (result.isFinished && result.success)
		{
			componentInChildren.ClearMesh();
			componentInChildren.textureBakeResults = component.textureBakeResults;
			componentInChildren.AddDeleteGameObjects(component.GetObjectsToCombine().ToArray(), null, disableRendererInSource: true);
			componentInChildren.Apply();
		}
		UnityEngine.Debug.Log("Completed baking textures on frame " + Time.frameCount);
	}
}
public class MB_BatchPrepareObjectsForDynamicBatchingDescription : MonoBehaviour
{
	private void OnGUI()
	{
		GUILayout.Label("This scene is set up to create a combined material and meshes with adjusted UVs so \n objects can share a material and be batched by Unity's static/dynamic batching.\n This scene has added a BatchPrefabBaker component to a Mesh and Material Baker which \n  can bake many prefabs (each of which can have several renderers) in one click.\n The batching tool accepts prefab assets instead of scene objects. \n");
	}
}
public class MB_SwapShirts : MonoBehaviour
{
	public MB3_MeshBaker meshBaker;

	public Renderer[] clothingAndBodyPartsBareTorso;

	public Renderer[] clothingAndBodyPartsBareTorsoDamagedArm;

	public Renderer[] clothingAndBodyPartsHoodie;

	private void Start()
	{
		GameObject[] array = new GameObject[clothingAndBodyPartsBareTorso.Length];
		for (int i = 0; i < clothingAndBodyPartsBareTorso.Length; i++)
		{
			array[i] = clothingAndBodyPartsBareTorso[i].gameObject;
		}
		meshBaker.ClearMesh();
		meshBaker.AddDeleteGameObjects(array, null, disableRendererInSource: true);
		meshBaker.Apply();
	}

	private void OnGUI()
	{
		if (GUILayout.Button("Wear Hoodie"))
		{
			ChangeOutfit(clothingAndBodyPartsHoodie);
		}
		if (GUILayout.Button("Bare Torso"))
		{
			ChangeOutfit(clothingAndBodyPartsBareTorso);
		}
		if (GUILayout.Button("Damaged Arm"))
		{
			ChangeOutfit(clothingAndBodyPartsBareTorsoDamagedArm);
		}
	}

	private void ChangeOutfit(Renderer[] outfit)
	{
		List<GameObject> list = new List<GameObject>();
		foreach (GameObject item in meshBaker.meshCombiner.GetObjectsInCombined())
		{
			Renderer component = item.GetComponent<Renderer>();
			bool flag = false;
			for (int i = 0; i < outfit.Length; i++)
			{
				if (component == outfit[i])
				{
					flag = true;
					break;
				}
			}
			if (!flag)
			{
				list.Add(component.gameObject);
				UnityEngine.Debug.Log("Removing " + component.gameObject);
			}
		}
		List<GameObject> list2 = new List<GameObject>();
		for (int j = 0; j < outfit.Length; j++)
		{
			if (!meshBaker.meshCombiner.GetObjectsInCombined().Contains(outfit[j].gameObject))
			{
				list2.Add(outfit[j].gameObject);
				UnityEngine.Debug.Log("Adding " + outfit[j].gameObject);
			}
		}
		meshBaker.AddDeleteGameObjects(list2.ToArray(), list.ToArray(), disableRendererInSource: true);
		meshBaker.Apply();
	}
}
public class MB_PrepareObjectsForDynamicBatchingDescription : MonoBehaviour
{
	private void OnGUI()
	{
		GUILayout.Label("This scene creates a combined material and meshes with adjusted UVs so objects \n can share a material and be batched by Unity's static/dynamic batching.\n Output has been set to 'bakeMeshAssetsInPlace' on the Mesh Baker\n Position, Scale and Rotation will be baked into meshes so place them appropriately.\n Dynamic batching requires objects with uniform scale. You can fix non-uniform scale here\n After baking you need to duplicate your source prefab assets and replace the  \n meshes and materials with the generated ones.\n");
	}
}
public class MB_DynamicAddDeleteExample : MonoBehaviour
{
	public GameObject prefab;

	private List<GameObject> objsInCombined = new List<GameObject>();

	private MB3_MultiMeshBaker mbd;

	private GameObject[] objs;

	private float GaussianValue()
	{
		float num;
		float num3;
		do
		{
			num = 2f * UnityEngine.Random.Range(0f, 1f) - 1f;
			float num2 = 2f * UnityEngine.Random.Range(0f, 1f) - 1f;
			num3 = num * num + num2 * num2;
		}
		while (num3 >= 1f);
		num3 = Mathf.Sqrt(-2f * Mathf.Log(num3) / num3);
		return num * num3;
	}

	private void Start()
	{
		mbd = GetComponentInChildren<MB3_MultiMeshBaker>();
		int num = 10;
		GameObject[] array = new GameObject[num * num];
		for (int i = 0; i < num; i++)
		{
			for (int j = 0; j < num; j++)
			{
				GameObject gameObject = UnityEngine.Object.Instantiate(prefab);
				array[i * num + j] = gameObject.GetComponentInChildren<MeshRenderer>().gameObject;
				float num2 = UnityEngine.Random.Range(-4f, 4f);
				float num3 = UnityEngine.Random.Range(-4f, 4f);
				gameObject.transform.position = new Vector3(3f * (float)i + num2, 0f, 3f * (float)j + num3);
				float y = UnityEngine.Random.Range(0, 360);
				gameObject.transform.rotation = Quaternion.Euler(0f, y, 0f);
				Vector3 localScale = Vector3.one + Vector3.one * GaussianValue() * 0.15f;
				gameObject.transform.localScale = localScale;
				if ((i * num + j) % 3 == 0)
				{
					objsInCombined.Add(array[i * num + j]);
				}
			}
		}
		mbd.AddDeleteGameObjects(array, null, disableRendererInSource: true);
		mbd.Apply();
		objs = objsInCombined.ToArray();
		StartCoroutine(largeNumber());
	}

	private IEnumerator largeNumber()
	{
		while (true)
		{
			yield return new WaitForSeconds(1.5f);
			mbd.AddDeleteGameObjects(null, objs, disableRendererInSource: true);
			mbd.Apply();
			yield return new WaitForSeconds(1.5f);
			mbd.AddDeleteGameObjects(objs, null, disableRendererInSource: true);
			mbd.Apply();
		}
	}

	private void OnGUI()
	{
		GUILayout.Label("Dynamically instantiates game objects. \nRepeatedly adds and removes some of them\n from the combined mesh.");
	}
}
public class MB_Example : MonoBehaviour
{
	public MB3_MeshBaker meshbaker;

	public GameObject[] objsToCombine;

	private void Start()
	{
		meshbaker.AddDeleteGameObjects(objsToCombine, null, disableRendererInSource: true);
		meshbaker.Apply();
	}

	private void LateUpdate()
	{
		meshbaker.UpdateGameObjects(objsToCombine);
		meshbaker.Apply(triangles: false, vertices: true, normals: true, tangents: true, uvs: false, uv2: false, uv3: false, uv4: false, colors: false);
	}

	private void OnGUI()
	{
		GUILayout.Label("Dynamically updates the vertices, normals and tangents in combined mesh every frame.\nThis is similar to dynamic batching. It is not recommended to do this every frame.\nAlso consider baking the mesh renderer objects into a skinned mesh renderer\nThe skinned mesh approach is faster for objects that need to move independently of each other every frame.");
	}
}
public class MB_ExampleMover : MonoBehaviour
{
	public int axis;

	private void Update()
	{
		Vector3 position = new Vector3(5f, 5f, 5f);
		position[axis] *= Mathf.Sin(Time.time);
		base.transform.position = position;
	}
}
public class MB_ExampleSkinnedMeshDescription : MonoBehaviour
{
	private void OnGUI()
	{
		GUILayout.Label("Mesh Renderer objects have been baked into a skinned mesh. Each source object\n is still in the scene (with renderer disabled) and becomes a bone. Any scripts, animations,\n or physics that affect the invisible source objects will be visible in the\nSkinned Mesh. This approach is more efficient than either dynamic batching or updating every frame \n for many small objects that constantly and independently move. \n With this approach pay attention to the SkinnedMeshRenderer Bounds and Animation Culling\nsettings. You may need to write your own script to manage/update these or your object may vanish or stop animating.\n You can update the combined mesh at runtime as objects are added and deleted from the scene.");
	}
}
public class MB_SkinnedMeshSceneController : MonoBehaviour
{
	public GameObject swordPrefab;

	public GameObject hatPrefab;

	public GameObject glassesPrefab;

	public GameObject workerPrefab;

	public GameObject targetCharacter;

	public MB3_MeshBaker skinnedMeshBaker;

	private GameObject swordInstance;

	private GameObject glassesInstance;

	private GameObject hatInstance;

	private void Start()
	{
		GameObject gameObject = UnityEngine.Object.Instantiate(workerPrefab);
		gameObject.transform.position = new Vector3(1.31f, 0.985f, -0.25f);
		Animation component = gameObject.GetComponent<Animation>();
		component.wrapMode = WrapMode.Loop;
		component.cullingType = AnimationCullingType.AlwaysAnimate;
		component.Play("run");
		GameObject[] gos = new GameObject[1] { gameObject.GetComponentInChildren<SkinnedMeshRenderer>().gameObject };
		skinnedMeshBaker.AddDeleteGameObjects(gos, null, disableRendererInSource: true);
		skinnedMeshBaker.Apply();
	}

	private void OnGUI()
	{
		if (GUILayout.Button("Add/Remove Sword"))
		{
			if (swordInstance == null)
			{
				Transform parent = SearchHierarchyForBone(targetCharacter.transform, "RightHandAttachPoint");
				swordInstance = UnityEngine.Object.Instantiate(swordPrefab);
				swordInstance.transform.parent = parent;
				swordInstance.transform.localPosition = Vector3.zero;
				swordInstance.transform.localRotation = Quaternion.identity;
				swordInstance.transform.localScale = Vector3.one;
				GameObject[] gos = new GameObject[1] { swordInstance.GetComponentInChildren<MeshRenderer>().gameObject };
				skinnedMeshBaker.AddDeleteGameObjects(gos, null, disableRendererInSource: true);
				skinnedMeshBaker.Apply();
			}
			else if (skinnedMeshBaker.CombinedMeshContains(swordInstance.GetComponentInChildren<MeshRenderer>().gameObject))
			{
				GameObject[] deleteGOs = new GameObject[1] { swordInstance.GetComponentInChildren<MeshRenderer>().gameObject };
				skinnedMeshBaker.AddDeleteGameObjects(null, deleteGOs, disableRendererInSource: true);
				skinnedMeshBaker.Apply();
				UnityEngine.Object.Destroy(swordInstance);
				swordInstance = null;
			}
		}
		if (GUILayout.Button("Add/Remove Hat"))
		{
			if (hatInstance == null)
			{
				Transform parent2 = SearchHierarchyForBone(targetCharacter.transform, "HeadAttachPoint");
				hatInstance = UnityEngine.Object.Instantiate(hatPrefab);
				hatInstance.transform.parent = parent2;
				hatInstance.transform.localPosition = Vector3.zero;
				hatInstance.transform.localRotation = Quaternion.identity;
				hatInstance.transform.localScale = Vector3.one;
				GameObject[] gos2 = new GameObject[1] { hatInstance.GetComponentInChildren<MeshRenderer>().gameObject };
				skinnedMeshBaker.AddDeleteGameObjects(gos2, null, disableRendererInSource: true);
				skinnedMeshBaker.Apply();
			}
			else if (skinnedMeshBaker.CombinedMeshContains(hatInstance.GetComponentInChildren<MeshRenderer>().gameObject))
			{
				GameObject[] deleteGOs2 = new GameObject[1] { hatInstance.GetComponentInChildren<MeshRenderer>().gameObject };
				skinnedMeshBaker.AddDeleteGameObjects(null, deleteGOs2, disableRendererInSource: true);
				skinnedMeshBaker.Apply();
				UnityEngine.Object.Destroy(hatInstance);
				hatInstance = null;
			}
		}
		if (GUILayout.Button("Add/Remove Glasses"))
		{
			if (glassesInstance == null)
			{
				Transform parent3 = SearchHierarchyForBone(targetCharacter.transform, "NoseAttachPoint");
				glassesInstance = UnityEngine.Object.Instantiate(glassesPrefab);
				glassesInstance.transform.parent = parent3;
				glassesInstance.transform.localPosition = Vector3.zero;
				glassesInstance.transform.localRotation = Quaternion.identity;
				glassesInstance.transform.localScale = Vector3.one;
				GameObject[] gos3 = new GameObject[1] { glassesInstance.GetComponentInChildren<MeshRenderer>().gameObject };
				skinnedMeshBaker.AddDeleteGameObjects(gos3, null, disableRendererInSource: true);
				skinnedMeshBaker.Apply();
			}
			else if (skinnedMeshBaker.CombinedMeshContains(glassesInstance.GetComponentInChildren<MeshRenderer>().gameObject))
			{
				GameObject[] deleteGOs3 = new GameObject[1] { glassesInstance.GetComponentInChildren<MeshRenderer>().gameObject };
				skinnedMeshBaker.AddDeleteGameObjects(null, deleteGOs3, disableRendererInSource: true);
				skinnedMeshBaker.Apply();
				UnityEngine.Object.Destroy(glassesInstance);
				glassesInstance = null;
			}
		}
	}

	public Transform SearchHierarchyForBone(Transform current, string name)
	{
		if (current.name.Equals(name))
		{
			return current;
		}
		for (int i = 0; i < current.childCount; i++)
		{
			Transform transform = SearchHierarchyForBone(current.GetChild(i), name);
			if (transform != null)
			{
				return transform;
			}
		}
		return null;
	}
}
[Serializable]
public class MB_AtlasesAndRects
{
	public Texture2D[] atlases;

	[NonSerialized]
	public List<MB_MaterialAndUVRect> mat2rect_map;

	public string[] texPropertyNames;
}
[Serializable]
public class MB_MultiMaterial
{
	public Material combinedMaterial;

	public bool considerMeshUVs;

	public List<Material> sourceMaterials = new List<Material>();
}
[Serializable]
public class MB_MaterialAndUVRect
{
	public Material material;

	public Rect atlasRect;

	public string srcObjName;

	public bool allPropsUseSameTiling = true;

	[FormerlySerializedAs("sourceMaterialTiling")]
	public Rect allPropsUseSameTiling_sourceMaterialTiling;

	[FormerlySerializedAs("samplingEncapsulatinRect")]
	public Rect allPropsUseSameTiling_samplingEncapsulatinRect;

	public Rect propsUseDifferntTiling_srcUVsamplingRect;

	public MB_TextureTilingTreatment tilingTreatment = MB_TextureTilingTreatment.unknown;

	public MB_MaterialAndUVRect(Material mat, Rect destRect, bool allPropsUseSameTiling, Rect sourceMaterialTiling, Rect samplingEncapsulatingRect, Rect srcUVsamplingRect, MB_TextureTilingTreatment treatment, string objName)
	{
		material = mat;
		atlasRect = destRect;
		tilingTreatment = treatment;
		this.allPropsUseSameTiling = allPropsUseSameTiling;
		allPropsUseSameTiling_sourceMaterialTiling = sourceMaterialTiling;
		allPropsUseSameTiling_samplingEncapsulatinRect = samplingEncapsulatingRect;
		propsUseDifferntTiling_srcUVsamplingRect = srcUVsamplingRect;
		srcObjName = objName;
	}

	public override int GetHashCode()
	{
		return material.GetInstanceID() ^ allPropsUseSameTiling_samplingEncapsulatinRect.GetHashCode() ^ propsUseDifferntTiling_srcUVsamplingRect.GetHashCode();
	}

	public override bool Equals(object obj)
	{
		if (!(obj is MB_MaterialAndUVRect))
		{
			return false;
		}
		MB_MaterialAndUVRect mB_MaterialAndUVRect = (MB_MaterialAndUVRect)obj;
		if (material == mB_MaterialAndUVRect.material && allPropsUseSameTiling_samplingEncapsulatinRect == mB_MaterialAndUVRect.allPropsUseSameTiling_samplingEncapsulatinRect && allPropsUseSameTiling_sourceMaterialTiling == mB_MaterialAndUVRect.allPropsUseSameTiling_sourceMaterialTiling && allPropsUseSameTiling == mB_MaterialAndUVRect.allPropsUseSameTiling)
		{
			return propsUseDifferntTiling_srcUVsamplingRect == mB_MaterialAndUVRect.propsUseDifferntTiling_srcUVsamplingRect;
		}
		return false;
	}

	public Rect GetEncapsulatingRect()
	{
		if (allPropsUseSameTiling)
		{
			return allPropsUseSameTiling_samplingEncapsulatinRect;
		}
		return propsUseDifferntTiling_srcUVsamplingRect;
	}

	public Rect GetMaterialTilingRect()
	{
		if (allPropsUseSameTiling)
		{
			return allPropsUseSameTiling_sourceMaterialTiling;
		}
		return new Rect(0f, 0f, 1f, 1f);
	}
}
public class MB2_TextureBakeResults : ScriptableObject
{
	public class Material2AtlasRectangleMapper
	{
		private MB2_TextureBakeResults tbr;

		private int[] numTimesMatAppearsInAtlas;

		private MB_MaterialAndUVRect[] matsAndSrcUVRect;

		public Material2AtlasRectangleMapper(MB2_TextureBakeResults res)
		{
			tbr = res;
			matsAndSrcUVRect = res.materialsAndUVRects;
			numTimesMatAppearsInAtlas = new int[matsAndSrcUVRect.Length];
			for (int i = 0; i < matsAndSrcUVRect.Length; i++)
			{
				if (numTimesMatAppearsInAtlas[i] > 1)
				{
					continue;
				}
				int num = 1;
				for (int j = i + 1; j < matsAndSrcUVRect.Length; j++)
				{
					if (matsAndSrcUVRect[i].material == matsAndSrcUVRect[j].material)
					{
						num++;
					}
				}
				numTimesMatAppearsInAtlas[i] = num;
				if (num <= 1)
				{
					continue;
				}
				for (int k = i + 1; k < matsAndSrcUVRect.Length; k++)
				{
					if (matsAndSrcUVRect[i].material == matsAndSrcUVRect[k].material)
					{
						numTimesMatAppearsInAtlas[k] = num;
					}
				}
			}
		}

		public bool TryMapMaterialToUVRect(Material mat, Mesh m, int submeshIdx, int idxInResultMats, MB3_MeshCombinerSingle.MeshChannelsCache meshChannelCache, Dictionary<int, MB_Utility.MeshAnalysisResult[]> meshAnalysisCache, out MB_TextureTilingTreatment tilingTreatment, out Rect rectInAtlas, out Rect encapsulatingRectOut, out Rect sourceMaterialTilingOut, ref string errorMsg, MB2_LogLevel logLevel)
		{
			if (tbr.version < VERSION)
			{
				UpgradeToCurrentVersion(tbr);
			}
			tilingTreatment = MB_TextureTilingTreatment.unknown;
			if (tbr.materialsAndUVRects.Length == 0)
			{
				errorMsg = "The 'Texture Bake Result' needs to be re-baked to be compatible with this version of Mesh Baker. Please re-bake using the MB3_TextureBaker.";
				rectInAtlas = default(Rect);
				encapsulatingRectOut = default(Rect);
				sourceMaterialTilingOut = default(Rect);
				return false;
			}
			if (mat == null)
			{
				rectInAtlas = default(Rect);
				encapsulatingRectOut = default(Rect);
				sourceMaterialTilingOut = default(Rect);
				errorMsg = $"Mesh {m.name} Had no material on submesh {submeshIdx} cannot map to a material in the atlas";
				return false;
			}
			if (submeshIdx >= m.subMeshCount)
			{
				errorMsg = "Submesh index is greater than the number of submeshes";
				rectInAtlas = default(Rect);
				encapsulatingRectOut = default(Rect);
				sourceMaterialTilingOut = default(Rect);
				return false;
			}
			int num = -1;
			for (int i = 0; i < matsAndSrcUVRect.Length; i++)
			{
				if (mat == matsAndSrcUVRect[i].material)
				{
					num = i;
					break;
				}
			}
			if (num == -1)
			{
				rectInAtlas = default(Rect);
				encapsulatingRectOut = default(Rect);
				sourceMaterialTilingOut = default(Rect);
				errorMsg = $"Material {mat.name} could not be found in the Texture Bake Result";
				return false;
			}
			if (!tbr.resultMaterials[idxInResultMats].considerMeshUVs)
			{
				if (numTimesMatAppearsInAtlas[num] != 1)
				{
					UnityEngine.Debug.LogError("There is a problem with this TextureBakeResults. FixOutOfBoundsUVs is false and a material appears more than once.");
				}
				MB_MaterialAndUVRect mB_MaterialAndUVRect = matsAndSrcUVRect[num];
				rectInAtlas = mB_MaterialAndUVRect.atlasRect;
				tilingTreatment = mB_MaterialAndUVRect.tilingTreatment;
				encapsulatingRectOut = mB_MaterialAndUVRect.GetEncapsulatingRect();
				sourceMaterialTilingOut = mB_MaterialAndUVRect.GetMaterialTilingRect();
				return true;
			}
			if (!meshAnalysisCache.TryGetValue(m.GetInstanceID(), out var value))
			{
				value = new MB_Utility.MeshAnalysisResult[m.subMeshCount];
				for (int j = 0; j < m.subMeshCount; j++)
				{
					MB_Utility.hasOutOfBoundsUVs(meshChannelCache.GetUv0Raw(m), m, ref value[j], j);
				}
				meshAnalysisCache.Add(m.GetInstanceID(), value);
			}
			bool flag = false;
			Rect rect = new Rect(0f, 0f, 0f, 0f);
			Rect rect2 = new Rect(0f, 0f, 0f, 0f);
			if (logLevel >= MB2_LogLevel.trace)
			{
				UnityEngine.Debug.Log(string.Format("Trying to find a rectangle in atlas capable of holding tiled sampling rect for mesh {0} using material {1} meshUVrect={2}", m, mat, value[submeshIdx].uvRect.ToString("f5")));
			}
			for (int k = num; k < matsAndSrcUVRect.Length; k++)
			{
				MB_MaterialAndUVRect mB_MaterialAndUVRect2 = matsAndSrcUVRect[k];
				if (!(mB_MaterialAndUVRect2.material == mat))
				{
					continue;
				}
				if (mB_MaterialAndUVRect2.allPropsUseSameTiling)
				{
					rect = mB_MaterialAndUVRect2.allPropsUseSameTiling_samplingEncapsulatinRect;
					rect2 = mB_MaterialAndUVRect2.allPropsUseSameTiling_sourceMaterialTiling;
				}
				else
				{
					rect = mB_MaterialAndUVRect2.propsUseDifferntTiling_srcUVsamplingRect;
					rect2 = new Rect(0f, 0f, 1f, 1f);
				}
				if (IsMeshAndMaterialRectEnclosedByAtlasRect(mB_MaterialAndUVRect2.tilingTreatment, value[submeshIdx].uvRect, rect2, rect, logLevel))
				{
					if (logLevel >= MB2_LogLevel.trace)
					{
						UnityEngine.Debug.Log("Found rect in atlas capable of containing tiled sampling rect for mesh " + m?.ToString() + " at idx=" + k);
					}
					num = k;
					flag = true;
					break;
				}
			}
			if (flag)
			{
				MB_MaterialAndUVRect mB_MaterialAndUVRect3 = matsAndSrcUVRect[num];
				rectInAtlas = mB_MaterialAndUVRect3.atlasRect;
				tilingTreatment = mB_MaterialAndUVRect3.tilingTreatment;
				encapsulatingRectOut = mB_MaterialAndUVRect3.GetEncapsulatingRect();
				sourceMaterialTilingOut = mB_MaterialAndUVRect3.GetMaterialTilingRect();
				return true;
			}
			rectInAtlas = default(Rect);
			encapsulatingRectOut = default(Rect);
			sourceMaterialTilingOut = default(Rect);
			errorMsg = $"Could not find a tiled rectangle in the atlas capable of containing the uv and material tiling on mesh {m.name} for material {mat}. Was this mesh included when atlases were baked?";
			return false;
		}

		private void UpgradeToCurrentVersion(MB2_TextureBakeResults tbr)
		{
			if (tbr.version < 3252)
			{
				for (int i = 0; i < tbr.materialsAndUVRects.Length; i++)
				{
					tbr.materialsAndUVRects[i].allPropsUseSameTiling = true;
				}
			}
		}
	}

	public int version;

	public MB_MaterialAndUVRect[] materialsAndUVRects;

	public MB_MultiMaterial[] resultMaterials;

	public bool doMultiMaterial;

	public static int VERSION => 3252;

	public MB2_TextureBakeResults()
	{
		version = VERSION;
	}

	private void OnEnable()
	{
		if (version < 3251)
		{
			for (int i = 0; i < materialsAndUVRects.Length; i++)
			{
				materialsAndUVRects[i].allPropsUseSameTiling = true;
			}
		}
		version = VERSION;
	}

	public static MB2_TextureBakeResults CreateForMaterialsOnRenderer(GameObject[] gos, List<Material> matsOnTargetRenderer)
	{
		HashSet<Material> hashSet = new HashSet<Material>(matsOnTargetRenderer);
		for (int i = 0; i < gos.Length; i++)
		{
			if (gos[i] == null)
			{
				UnityEngine.Debug.LogError($"Game object {i} in list of objects to add was null");
				return null;
			}
			Material[] gOMaterials = MB_Utility.GetGOMaterials(gos[i]);
			if (gOMaterials.Length == 0)
			{
				UnityEngine.Debug.LogError($"Game object {i} in list of objects to add no renderer");
				return null;
			}
			for (int j = 0; j < gOMaterials.Length; j++)
			{
				if (!hashSet.Contains(gOMaterials[j]))
				{
					hashSet.Add(gOMaterials[j]);
				}
			}
		}
		Material[] array = new Material[hashSet.Count];
		hashSet.CopyTo(array);
		MB2_TextureBakeResults mB2_TextureBakeResults = (MB2_TextureBakeResults)ScriptableObject.CreateInstance(typeof(MB2_TextureBakeResults));
		List<MB_MaterialAndUVRect> list = new List<MB_MaterialAndUVRect>();
		for (int k = 0; k < array.Length; k++)
		{
			if (array[k] != null)
			{
				MB_MaterialAndUVRect item = new MB_MaterialAndUVRect(array[k], new Rect(0f, 0f, 1f, 1f), allPropsUseSameTiling: true, new Rect(0f, 0f, 1f, 1f), new Rect(0f, 0f, 1f, 1f), new Rect(0f, 0f, 0f, 0f), MB_TextureTilingTreatment.none, "");
				if (!list.Contains(item))
				{
					list.Add(item);
				}
			}
		}
		mB2_TextureBakeResults.resultMaterials = new MB_MultiMaterial[list.Count];
		for (int l = 0; l < list.Count; l++)
		{
			mB2_TextureBakeResults.resultMaterials[l] = new MB_MultiMaterial();
			List<Material> list2 = new List<Material>();
			list2.Add(list[l].material);
			mB2_TextureBakeResults.resultMaterials[l].sourceMaterials = list2;
			mB2_TextureBakeResults.resultMaterials[l].combinedMaterial = list[l].material;
			mB2_TextureBakeResults.resultMaterials[l].considerMeshUVs = false;
		}
		if (array.Length == 1)
		{
			mB2_TextureBakeResults.doMultiMaterial = false;
		}
		else
		{
			mB2_TextureBakeResults.doMultiMaterial = true;
		}
		mB2_TextureBakeResults.materialsAndUVRects = list.ToArray();
		return mB2_TextureBakeResults;
	}

	public bool DoAnyResultMatsUseConsiderMeshUVs()
	{
		if (resultMaterials == null)
		{
			return false;
		}
		for (int i = 0; i < resultMaterials.Length; i++)
		{
			if (resultMaterials[i].considerMeshUVs)
			{
				return true;
			}
		}
		return false;
	}

	public bool ContainsMaterial(Material m)
	{
		for (int i = 0; i < materialsAndUVRects.Length; i++)
		{
			if (materialsAndUVRects[i].material == m)
			{
				return true;
			}
		}
		return false;
	}

	public string GetDescription()
	{
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.Append("Shaders:\n");
		HashSet<Shader> hashSet = new HashSet<Shader>();
		if (materialsAndUVRects != null)
		{
			for (int i = 0; i < materialsAndUVRects.Length; i++)
			{
				if (materialsAndUVRects[i].material != null)
				{
					hashSet.Add(materialsAndUVRects[i].material.shader);
				}
			}
		}
		foreach (Shader item in hashSet)
		{
			stringBuilder.Append("  ").Append(item.name).AppendLine();
		}
		stringBuilder.Append("Materials:\n");
		if (materialsAndUVRects != null)
		{
			for (int j = 0; j < materialsAndUVRects.Length; j++)
			{
				if (materialsAndUVRects[j].material != null)
				{
					stringBuilder.Append("  ").Append(materialsAndUVRects[j].material.name).AppendLine();
				}
			}
		}
		return stringBuilder.ToString();
	}

	public static bool IsMeshAndMaterialRectEnclosedByAtlasRect(MB_TextureTilingTreatment tilingTreatment, Rect uvR, Rect sourceMaterialTiling, Rect samplingEncapsulatinRect, MB2_LogLevel logLevel)
	{
		Rect rect = default(Rect);
		rect = MB3_UVTransformUtility.CombineTransforms(ref uvR, ref sourceMaterialTiling);
		if (logLevel >= MB2_LogLevel.trace && logLevel >= MB2_LogLevel.trace)
		{
			UnityEngine.Debug.Log("Rect in atlas uvR=" + uvR.ToString("f5") + " sourceMaterialTiling=" + sourceMaterialTiling.ToString("f5") + "Potential Rect " + rect.ToString("f5") + " encapsulating=" + samplingEncapsulatinRect.ToString("f5"));
		}
		if (logLevel >= MB2_LogLevel.trace && logLevel >= MB2_LogLevel.trace)
		{
			UnityEngine.Debug.Log("Potential Rect (must fit in encapsulating)  " + rect.ToString("f5") + " encapsulating=" + samplingEncapsulatinRect.ToString("f5"));
		}
		switch (tilingTreatment)
		{
		case MB_TextureTilingTreatment.edgeToEdgeX:
			if (MB3_UVTransformUtility.LineSegmentContainsShifted(samplingEncapsulatinRect.y, samplingEncapsulatinRect.height, rect.y, rect.height))
			{
				return true;
			}
			break;
		case MB_TextureTilingTreatment.edgeToEdgeY:
			if (MB3_UVTransformUtility.LineSegmentContainsShifted(samplingEncapsulatinRect.x, samplingEncapsulatinRect.width, rect.x, rect.width))
			{
				return true;
			}
			break;
		case MB_TextureTilingTreatment.edgeToEdgeXY:
			return true;
		default:
			if (MB3_UVTransformUtility.RectContainsShifted(ref samplingEncapsulatinRect, ref rect))
			{
				return true;
			}
			break;
		}
		return false;
	}
}
public class MB2_UpdateSkinnedMeshBoundsFromBones : MonoBehaviour
{
	private SkinnedMeshRenderer smr;

	private Transform[] bones;

	private void Start()
	{
		smr = GetComponent<SkinnedMeshRenderer>();
		if (smr == null)
		{
			UnityEngine.Debug.LogError("Need to attach MB2_UpdateSkinnedMeshBoundsFromBones script to an object with a SkinnedMeshRenderer component attached.");
			return;
		}
		bones = smr.bones;
		bool updateWhenOffscreen = smr.updateWhenOffscreen;
		smr.updateWhenOffscreen = true;
		smr.updateWhenOffscreen = updateWhenOffscreen;
	}

	private void Update()
	{
		if (smr != null)
		{
			MB3_MeshCombiner.UpdateSkinnedMeshApproximateBoundsFromBonesStatic(bones, smr);
		}
	}
}
public class MB2_UpdateSkinnedMeshBoundsFromBounds : MonoBehaviour
{
	public List<GameObject> objects;

	private SkinnedMeshRenderer smr;

	private void Start()
	{
		smr = GetComponent<SkinnedMeshRenderer>();
		if (smr == null)
		{
			UnityEngine.Debug.LogError("Need to attach MB2_UpdateSkinnedMeshBoundsFromBounds script to an object with a SkinnedMeshRenderer component attached.");
			return;
		}
		if (objects == null || objects.Count == 0)
		{
			UnityEngine.Debug.LogWarning("The MB2_UpdateSkinnedMeshBoundsFromBounds had no Game Objects. It should have the same list of game objects that the MeshBaker does.");
			smr = null;
			return;
		}
		for (int i = 0; i < objects.Count; i++)
		{
			if (objects[i] == null || objects[i].GetComponent<Renderer>() == null)
			{
				UnityEngine.Debug.LogError("The list of objects had nulls or game objects without a renderer attached at position " + i);
				smr = null;
				return;
			}
		}
		bool updateWhenOffscreen = smr.updateWhenOffscreen;
		smr.updateWhenOffscreen = true;
		smr.updateWhenOffscreen = updateWhenOffscreen;
	}

	private void Update()
	{
		if (smr != null && objects != null)
		{
			MB3_MeshCombiner.UpdateSkinnedMeshApproximateBoundsFromBoundsStatic(objects, smr);
		}
	}
}
public class MB3_BatchPrefabBaker : MonoBehaviour
{
	[Serializable]
	public class MB3_PrefabBakerRow
	{
		public GameObject sourcePrefab;

		public GameObject resultPrefab;
	}

	public MB2_LogLevel LOG_LEVEL = MB2_LogLevel.info;

	public MB3_PrefabBakerRow[] prefabRows;

	public string outputPrefabFolder;
}
public class MB3_BoneWeightCopier : MonoBehaviour
{
	public GameObject inputGameObject;

	public GameObject outputPrefab;

	public float radius = 0.01f;

	public SkinnedMeshRenderer seamMesh;

	public string outputFolder;
}
public class MB3_DisableHiddenAnimations : MonoBehaviour
{
	public List<Animation> animationsToCull = new List<Animation>();

	private void Start()
	{
		if (GetComponent<SkinnedMeshRenderer>() == null)
		{
			UnityEngine.Debug.LogError("The MB3_CullHiddenAnimations script was placed on and object " + base.name + " which has no SkinnedMeshRenderer attached");
		}
	}

	private void OnBecameVisible()
	{
		for (int i = 0; i < animationsToCull.Count; i++)
		{
			if (animationsToCull[i] != null)
			{
				animationsToCull[i].enabled = true;
			}
		}
	}

	private void OnBecameInvisible()
	{
		for (int i = 0; i < animationsToCull.Count; i++)
		{
			if (animationsToCull[i] != null)
			{
				animationsToCull[i].enabled = false;
			}
		}
	}
}
public class MB3_MeshBaker : MB3_MeshBakerCommon
{
	[SerializeField]
	protected MB3_MeshCombinerSingle _meshCombiner = new MB3_MeshCombinerSingle();

	public override MB3_MeshCombiner meshCombiner => _meshCombiner;

	public void BuildSceneMeshObject()
	{
		_meshCombiner.BuildSceneMeshObject();
	}

	public virtual bool ShowHide(GameObject[] gos, GameObject[] deleteGOs)
	{
		return _meshCombiner.ShowHideGameObjects(gos, deleteGOs);
	}

	public virtual void ApplyShowHide()
	{
		_meshCombiner.ApplyShowHide();
	}

	public override bool AddDeleteGameObjects(GameObject[] gos, GameObject[] deleteGOs, bool disableRendererInSource)
	{
		_meshCombiner.name = base.name + "-mesh";
		return _meshCombiner.AddDeleteGameObjects(gos, deleteGOs, disableRendererInSource);
	}

	public override bool AddDeleteGameObjectsByID(GameObject[] gos, int[] deleteGOinstanceIDs, bool disableRendererInSource)
	{
		_meshCombiner.name = base.name + "-mesh";
		return _meshCombiner.AddDeleteGameObjectsByID(gos, deleteGOinstanceIDs, disableRendererInSource);
	}
}
public abstract class MB3_MeshBakerCommon : MB3_MeshBakerRoot
{
	public List<GameObject> objsToMesh;

	public bool useObjsToMeshFromTexBaker = true;

	public bool clearBuffersAfterBake = true;

	public string bakeAssetsInPlaceFolderPath;

	[HideInInspector]
	public GameObject resultPrefab;

	public abstract MB3_MeshCombiner meshCombiner { get; }

	public override MB2_TextureBakeResults textureBakeResults
	{
		get
		{
			return meshCombiner.textureBakeResults;
		}
		set
		{
			meshCombiner.textureBakeResults = value;
		}
	}

	public override List<GameObject> GetObjectsToCombine()
	{
		if (useObjsToMeshFromTexBaker)
		{
			MB3_TextureBaker component = base.gameObject.GetComponent<MB3_TextureBaker>();
			if (component == null)
			{
				component = base.gameObject.transform.parent.GetComponent<MB3_TextureBaker>();
			}
			if (component != null)
			{
				return component.GetObjectsToCombine();
			}
			UnityEngine.Debug.LogWarning("Use Objects To Mesh From Texture Baker was checked but no texture baker");
			return new List<GameObject>();
		}
		if (objsToMesh == null)
		{
			objsToMesh = new List<GameObject>();
		}
		return objsToMesh;
	}

	public void EnableDisableSourceObjectRenderers(bool show)
	{
		for (int i = 0; i < GetObjectsToCombine().Count; i++)
		{
			GameObject gameObject = GetObjectsToCombine()[i];
			if (!(gameObject != null))
			{
				continue;
			}
			Renderer renderer = MB_Utility.GetRenderer(gameObject);
			if (renderer != null)
			{
				renderer.enabled = show;
			}
			LODGroup componentInParent = renderer.GetComponentInParent<LODGroup>();
			if (!(componentInParent != null))
			{
				continue;
			}
			bool flag = true;
			LOD[] lODs = componentInParent.GetLODs();
			for (int j = 0; j < lODs.Length; j++)
			{
				for (int k = 0; k < lODs[j].renderers.Length; k++)
				{
					if (lODs[j].renderers[k] != renderer)
					{
						flag = false;
						break;
					}
				}
			}
			if (flag)
			{
				componentInParent.enabled = show;
			}
		}
	}

	public virtual void ClearMesh()
	{
		meshCombiner.ClearMesh();
	}

	public virtual void DestroyMesh()
	{
		meshCombiner.DestroyMesh();
	}

	public virtual void DestroyMeshEditor(MB2_EditorMethodsInterface editorMethods)
	{
		meshCombiner.DestroyMeshEditor(editorMethods);
	}

	public virtual int GetNumObjectsInCombined()
	{
		return meshCombiner.GetNumObjectsInCombined();
	}

	public virtual int GetNumVerticesFor(GameObject go)
	{
		return meshCombiner.GetNumVerticesFor(go);
	}

	public MB3_TextureBaker GetTextureBaker()
	{
		MB3_TextureBaker component = GetComponent<MB3_TextureBaker>();
		if (component != null)
		{
			return component;
		}
		if (base.transform.parent != null)
		{
			return base.transform.parent.GetComponent<MB3_TextureBaker>();
		}
		return null;
	}

	public abstract bool AddDeleteGameObjects(GameObject[] gos, GameObject[] deleteGOs, bool disableRendererInSource = true);

	public abstract bool AddDeleteGameObjectsByID(GameObject[] gos, int[] deleteGOinstanceIDs, bool disableRendererInSource = true);

	public virtual void Apply(MB3_MeshCombiner.GenerateUV2Delegate uv2GenerationMethod = null)
	{
		meshCombiner.name = base.name + "-mesh";
		meshCombiner.Apply(uv2GenerationMethod);
	}

	public virtual void Apply(bool triangles, bool vertices, bool normals, bool tangents, bool uvs, bool uv2, bool uv3, bool uv4, bool colors, bool bones = false, bool blendShapesFlag = false, MB3_MeshCombiner.GenerateUV2Delegate uv2GenerationMethod = null)
	{
		meshCombiner.name = base.name + "-mesh";
		meshCombiner.Apply(triangles, vertices, normals, tangents, uvs, uv2, uv3, uv4, colors, bones, blendShapesFlag, uv2GenerationMethod);
	}

	public virtual bool CombinedMeshContains(GameObject go)
	{
		return meshCombiner.CombinedMeshContains(go);
	}

	public virtual void UpdateGameObjects(GameObject[] gos, bool recalcBounds = true, bool updateVertices = true, bool updateNormals = true, bool updateTangents = true, bool updateUV = false, bool updateUV1 = false, bool updateUV2 = false, bool updateColors = false, bool updateSkinningInfo = false)
	{
		meshCombiner.name = base.name + "-mesh";
		meshCombiner.UpdateGameObjects(gos, recalcBounds, updateVertices, updateNormals, updateTangents, updateUV, updateUV1, updateUV2, updateColors, updateSkinningInfo);
	}

	public virtual void UpdateSkinnedMeshApproximateBounds()
	{
		if (_ValidateForUpdateSkinnedMeshBounds())
		{
			meshCombiner.UpdateSkinnedMeshApproximateBounds();
		}
	}

	public virtual void UpdateSkinnedMeshApproximateBoundsFromBones()
	{
		if (_ValidateForUpdateSkinnedMeshBounds())
		{
			meshCombiner.UpdateSkinnedMeshApproximateBoundsFromBones();
		}
	}

	public virtual void UpdateSkinnedMeshApproximateBoundsFromBounds()
	{
		if (_ValidateForUpdateSkinnedMeshBounds())
		{
			meshCombiner.UpdateSkinnedMeshApproximateBoundsFromBounds();
		}
	}

	protected virtual bool _ValidateForUpdateSkinnedMeshBounds()
	{
		if (meshCombiner.outputOption == MB2_OutputOptions.bakeMeshAssetsInPlace)
		{
			UnityEngine.Debug.LogWarning("Can't UpdateSkinnedMeshApproximateBounds when output type is bakeMeshAssetsInPlace");
			return false;
		}
		if (meshCombiner.resultSceneObject == null)
		{
			UnityEngine.Debug.LogWarning("Result Scene Object does not exist. No point in calling UpdateSkinnedMeshApproximateBounds.");
			return false;
		}
		if (meshCombiner.resultSceneObject.GetComponentInChildren<SkinnedMeshRenderer>() == null)
		{
			UnityEngine.Debug.LogWarning("No SkinnedMeshRenderer on result scene object.");
			return false;
		}
		return true;
	}
}
public class MB3_MeshBakerGrouper : MonoBehaviour
{
	public enum ClusterType
	{
		none,
		grid,
		pie,
		agglomerative
	}

	public MB3_MeshBakerGrouperCore grouper;

	public ClusterType clusterType;

	public GrouperData data = new GrouperData();

	[HideInInspector]
	public Bounds sourceObjectBounds = new Bounds(Vector3.zero, Vector3.one);

	private void OnDrawGizmosSelected()
	{
		if (grouper == null)
		{
			grouper = CreateGrouper(clusterType, data);
		}
		if (grouper.d == null)
		{
			grouper.d = data;
		}
		grouper.DrawGizmos(sourceObjectBounds);
	}

	public MB3_MeshBakerGrouperCore CreateGrouper(ClusterType t, GrouperData data)
	{
		if (t == ClusterType.grid)
		{
			grouper = new MB3_MeshBakerGrouperGrid(data);
		}
		if (t == ClusterType.pie)
		{
			grouper = new MB3_MeshBakerGrouperPie(data);
		}
		if (t == ClusterType.agglomerative)
		{
			MB3_TextureBaker component = GetComponent<MB3_TextureBaker>();
			List<GameObject> gos = ((!(component != null)) ? new List<GameObject>() : component.GetObjectsToCombine());
			grouper = new MB3_MeshBakerGrouperCluster(data, gos);
		}
		if (t == ClusterType.none)
		{
			grouper = new MB3_MeshBakerGrouperNone(data);
		}
		return grouper;
	}
}
public abstract class MB3_MeshBakerRoot : MonoBehaviour
{
	public class ZSortObjects
	{
		public class Item
		{
			public GameObject go;

			public Vector3 point;
		}

		public class ItemComparer : IComparer<Item>
		{
			public int Compare(Item a, Item b)
			{
				return (int)Mathf.Sign(b.point.z - a.point.z);
			}
		}

		public Vector3 sortAxis;

		public void SortByDistanceAlongAxis(List<GameObject> gos)
		{
			if (sortAxis == Vector3.zero)
			{
				UnityEngine.Debug.LogError("The sort axis cannot be the zero vector.");
				return;
			}
			UnityEngine.Debug.Log("Z sorting meshes along axis numObjs=" + gos.Count);
			List<Item> list = new List<Item>();
			Quaternion quaternion = Quaternion.FromToRotation(sortAxis, Vector3.forward);
			for (int i = 0; i < gos.Count; i++)
			{
				if (gos[i] != null)
				{
					Item item = new Item();
					item.point = gos[i].transform.position;
					item.go = gos[i];
					item.point = quaternion * item.point;
					list.Add(item);
				}
			}
			list.Sort(new ItemComparer());
			for (int j = 0; j < gos.Count; j++)
			{
				gos[j] = list[j].go;
			}
		}
	}

	public static bool DO_INTEGRITY_CHECKS;

	public Vector3 sortAxis;

	[HideInInspector]
	public abstract MB2_TextureBakeResults textureBakeResults { get; set; }

	public virtual List<GameObject> GetObjectsToCombine()
	{
		return null;
	}

	public static bool DoCombinedValidate(MB3_MeshBakerRoot mom, MB_ObjsToCombineTypes objToCombineType, MB2_EditorMethodsInterface editorMethods, MB2_ValidationLevel validationLevel)
	{
		if (mom.textureBakeResults == null)
		{
			UnityEngine.Debug.LogError("Need to set Texture Bake Result on " + mom);
			return false;
		}
		if (mom is MB3_MeshBakerCommon)
		{
			MB3_TextureBaker textureBaker = ((MB3_MeshBakerCommon)mom).GetTextureBaker();
			if (textureBaker != null && textureBaker.textureBakeResults != mom.textureBakeResults)
			{
				UnityEngine.Debug.LogWarning("Texture Bake Result on this component is not the same as the Texture Bake Result on the MB3_TextureBaker.");
			}
		}
		Dictionary<int, MB_Utility.MeshAnalysisResult> dictionary = null;
		if (validationLevel == MB2_ValidationLevel.robust)
		{
			dictionary = new Dictionary<int, MB_Utility.MeshAnalysisResult>();
		}
		List<GameObject> objectsToCombine = mom.GetObjectsToCombine();
		for (int i = 0; i < objectsToCombine.Count; i++)
		{
			GameObject gameObject = objectsToCombine[i];
			if (gameObject == null)
			{
				UnityEngine.Debug.LogError("The list of objects to combine contains a null at position." + i + " Select and use [shift] delete to remove");
				return false;
			}
			for (int j = i + 1; j < objectsToCombine.Count; j++)
			{
				if (objectsToCombine[i] == objectsToCombine[j])
				{
					UnityEngine.Debug.LogError("The list of objects to combine contains duplicates at " + i + " and " + j);
					return false;
				}
			}
			if (MB_Utility.GetGOMaterials(gameObject).Length == 0)
			{
				UnityEngine.Debug.LogError("Object " + gameObject?.ToString() + " in the list of objects to be combined does not have a material");
				return false;
			}
			Mesh mesh = MB_Utility.GetMesh(gameObject);
			if (mesh == null)
			{
				UnityEngine.Debug.LogError("Object " + gameObject?.ToString() + " in the list of objects to be combined does not have a mesh");
				return false;
			}
			if (mesh != null && !UnityEngine.Application.isEditor && UnityEngine.Application.isPlaying && mom.textureBakeResults.doMultiMaterial && validationLevel >= MB2_ValidationLevel.robust)
			{
				if (!dictionary.TryGetValue(mesh.GetInstanceID(), out var value))
				{
					MB_Utility.doSubmeshesShareVertsOrTris(mesh, ref value);
					dictionary.Add(mesh.GetInstanceID(), value);
				}
				if (value.hasOverlappingSubmeshVerts)
				{
					UnityEngine.Debug.LogWarning("Object " + objectsToCombine[i]?.ToString() + " in the list of objects to combine has overlapping submeshes (submeshes share vertices). If the UVs associated with the shared vertices are important then this bake may not work. If you are using multiple materials then this object can only be combined with objects that use the exact same set of textures (each atlas contains one texture). There may be other undesirable side affects as well. Mesh Master, available in the asset store can fix overlapping submeshes.");
				}
			}
		}
		List<GameObject> list = objectsToCombine;
		if (mom is MB3_MeshBaker)
		{
			list = mom.GetObjectsToCombine();
			if (list == null || list.Count == 0)
			{
				UnityEngine.Debug.LogError("No meshes to combine. Please assign some meshes to combine.");
				return false;
			}
			if (mom is MB3_MeshBaker && ((MB3_MeshBaker)mom).meshCombiner.renderType == MB_RenderType.skinnedMeshRenderer && !editorMethods.ValidateSkinnedMeshes(list))
			{
				return false;
			}
		}
		editorMethods?.CheckPrefabTypes(objToCombineType, objectsToCombine);
		return true;
	}
}
public class MB3_MultiMeshBaker : MB3_MeshBakerCommon
{
	[SerializeField]
	protected MB3_MultiMeshCombiner _meshCombiner = new MB3_MultiMeshCombiner();

	public override MB3_MeshCombiner meshCombiner => _meshCombiner;

	public override bool AddDeleteGameObjects(GameObject[] gos, GameObject[] deleteGOs, bool disableRendererInSource)
	{
		if (_meshCombiner.resultSceneObject == null)
		{
			_meshCombiner.resultSceneObject = new GameObject("CombinedMesh-" + base.name);
		}
		meshCombiner.name = base.name + "-mesh";
		return _meshCombiner.AddDeleteGameObjects(gos, deleteGOs, disableRendererInSource);
	}

	public override bool AddDeleteGameObjectsByID(GameObject[] gos, int[] deleteGOs, bool disableRendererInSource)
	{
		if (_meshCombiner.resultSceneObject == null)
		{
			_meshCombiner.resultSceneObject = new GameObject("CombinedMesh-" + base.name);
		}
		meshCombiner.name = base.name + "-mesh";
		return _meshCombiner.AddDeleteGameObjectsByID(gos, deleteGOs, disableRendererInSource);
	}
}
public class MB3_TextureBaker : MB3_MeshBakerRoot
{
	public delegate void OnCombinedTexturesCoroutineSuccess();

	public delegate void OnCombinedTexturesCoroutineFail();

	public class CreateAtlasesCoroutineResult
	{
		public bool success = true;

		public bool isFinished;
	}

	public MB2_LogLevel LOG_LEVEL = MB2_LogLevel.info;

	[SerializeField]
	protected MB2_TextureBakeResults _textureBakeResults;

	[SerializeField]
	protected int _atlasPadding = 1;

	[SerializeField]
	protected int _maxAtlasSize = 4096;

	[SerializeField]
	protected bool _useMaxAtlasWidthOverride;

	[SerializeField]
	protected int _maxAtlasWidthOverride = 4096;

	[SerializeField]
	protected bool _useMaxAtlasHeightOverride;

	[SerializeField]
	protected int _maxAtlasHeightOverride = 4096;

	[SerializeField]
	protected bool _resizePowerOfTwoTextures;

	[SerializeField]
	protected bool _fixOutOfBoundsUVs;

	[SerializeField]
	protected int _maxTilingBakeSize = 1024;

	[SerializeField]
	protected MB2_PackingAlgorithmEnum _packingAlgorithm = MB2_PackingAlgorithmEnum.MeshBakerTexturePacker;

	[SerializeField]
	protected bool _meshBakerTexturePackerForcePowerOfTwo = true;

	[SerializeField]
	protected List<ShaderTextureProperty> _customShaderProperties = new List<ShaderTextureProperty>();

	[SerializeField]
	protected List<string> _customShaderPropNames_Depricated = new List<string>();

	[SerializeField]
	protected bool _doMultiMaterial;

	[SerializeField]
	protected bool _doMultiMaterialSplitAtlasesIfTooBig = true;

	[SerializeField]
	protected bool _doMultiMaterialSplitAtlasesIfOBUVs = true;

	[SerializeField]
	protected Material _resultMaterial;

	[SerializeField]
	protected bool _considerNonTextureProperties;

	[SerializeField]
	protected bool _doSuggestTreatment = true;

	private CreateAtlasesCoroutineResult _coroutineResult;

	public MB_MultiMaterial[] resultMaterials = new MB_MultiMaterial[0];

	public List<GameObject> objsToMesh;

	public OnCombinedTexturesCoroutineSuccess onBuiltAtlasesSuccess;

	public OnCombinedTexturesCoroutineFail onBuiltAtlasesFail;

	public MB_AtlasesAndRects[] OnCombinedTexturesCoroutineAtlasesAndRects;

	public override MB2_TextureBakeResults textureBakeResults
	{
		get
		{
			return _textureBakeResults;
		}
		set
		{
			_textureBakeResults = value;
		}
	}

	public virtual int atlasPadding
	{
		get
		{
			return _atlasPadding;
		}
		set
		{
			_atlasPadding = value;
		}
	}

	public virtual int maxAtlasSize
	{
		get
		{
			return _maxAtlasSize;
		}
		set
		{
			_maxAtlasSize = value;
		}
	}

	public virtual bool useMaxAtlasWidthOverride
	{
		get
		{
			return _useMaxAtlasWidthOverride;
		}
		set
		{
			_useMaxAtlasWidthOverride = value;
		}
	}

	public virtual int maxAtlasWidthOverride
	{
		get
		{
			return _maxAtlasWidthOverride;
		}
		set
		{
			_maxAtlasWidthOverride = value;
		}
	}

	public virtual bool useMaxAtlasHeightOverride
	{
		get
		{
			return _useMaxAtlasHeightOverride;
		}
		set
		{
			_useMaxAtlasHeightOverride = value;
		}
	}

	public virtual int maxAtlasHeightOverride
	{
		get
		{
			return _maxAtlasHeightOverride;
		}
		set
		{
			_maxAtlasHeightOverride = value;
		}
	}

	public virtual bool resizePowerOfTwoTextures
	{
		get
		{
			return _resizePowerOfTwoTextures;
		}
		set
		{
			_resizePowerOfTwoTextures = value;
		}
	}

	public virtual bool fixOutOfBoundsUVs
	{
		get
		{
			return _fixOutOfBoundsUVs;
		}
		set
		{
			_fixOutOfBoundsUVs = value;
		}
	}

	public virtual int maxTilingBakeSize
	{
		get
		{
			return _maxTilingBakeSize;
		}
		set
		{
			_maxTilingBakeSize = value;
		}
	}

	public virtual MB2_PackingAlgorithmEnum packingAlgorithm
	{
		get
		{
			return _packingAlgorithm;
		}
		set
		{
			_packingAlgorithm = value;
		}
	}

	public bool meshBakerTexturePackerForcePowerOfTwo
	{
		get
		{
			return _meshBakerTexturePackerForcePowerOfTwo;
		}
		set
		{
			_meshBakerTexturePackerForcePowerOfTwo = value;
		}
	}

	public virtual List<ShaderTextureProperty> customShaderProperties
	{
		get
		{
			return _customShaderProperties;
		}
		set
		{
			_customShaderProperties = value;
		}
	}

	public virtual List<string> customShaderPropNames
	{
		get
		{
			return _customShaderPropNames_Depricated;
		}
		set
		{
			_customShaderPropNames_Depricated = value;
		}
	}

	public virtual bool doMultiMaterial
	{
		get
		{
			return _doMultiMaterial;
		}
		set
		{
			_doMultiMaterial = value;
		}
	}

	public virtual bool doMultiMaterialSplitAtlasesIfTooBig
	{
		get
		{
			return _doMultiMaterialSplitAtlasesIfTooBig;
		}
		set
		{
			_doMultiMaterialSplitAtlasesIfTooBig = value;
		}
	}

	public virtual bool doMultiMaterialSplitAtlasesIfOBUVs
	{
		get
		{
			return _doMultiMaterialSplitAtlasesIfOBUVs;
		}
		set
		{
			_doMultiMaterialSplitAtlasesIfOBUVs = value;
		}
	}

	public virtual Material resultMaterial
	{
		get
		{
			return _resultMaterial;
		}
		set
		{
			_resultMaterial = value;
		}
	}

	public bool considerNonTextureProperties
	{
		get
		{
			return _considerNonTextureProperties;
		}
		set
		{
			_considerNonTextureProperties = value;
		}
	}

	public bool doSuggestTreatment
	{
		get
		{
			return _doSuggestTreatment;
		}
		set
		{
			_doSuggestTreatment = value;
		}
	}

	public CreateAtlasesCoroutineResult CoroutineResult => _coroutineResult;

	public override List<GameObject> GetObjectsToCombine()
	{
		if (objsToMesh == null)
		{
			objsToMesh = new List<GameObject>();
		}
		return objsToMesh;
	}

	public MB_AtlasesAndRects[] CreateAtlases()
	{
		return CreateAtlases(null);
	}

	public IEnumerator CreateAtlasesCoroutine(ProgressUpdateDelegate progressInfo, CreateAtlasesCoroutineResult coroutineResult, bool saveAtlasesAsAssets = false, MB2_EditorMethodsInterface editorMethods = null, float maxTimePerFrame = 0.01f)
	{
		MBVersionConcrete mBVersionConcrete = new MBVersionConcrete();
		if (!MB3_TextureCombiner._RunCorutineWithoutPauseIsRunning && (mBVersionConcrete.GetMajorVersion() < 5 || (mBVersionConcrete.GetMajorVersion() == 5 && mBVersionConcrete.GetMinorVersion() < 3)))
		{
			UnityEngine.Debug.LogError("Running the texture combiner as a coroutine only works in Unity 5.3 and higher");
			coroutineResult.success = false;
			yield break;
		}
		OnCombinedTexturesCoroutineAtlasesAndRects = null;
		if (maxTimePerFrame <= 0f)
		{
			UnityEngine.Debug.LogError("maxTimePerFrame must be a value greater than zero");
			coroutineResult.isFinished = true;
			yield break;
		}
		MB2_ValidationLevel validationLevel = (UnityEngine.Application.isPlaying ? MB2_ValidationLevel.quick : MB2_ValidationLevel.robust);
		if (!MB3_MeshBakerRoot.DoCombinedValidate(this, MB_ObjsToCombineTypes.dontCare, null, validationLevel))
		{
			coroutineResult.isFinished = true;
			yield break;
		}
		if (_doMultiMaterial && !_ValidateResultMaterials())
		{
			coroutineResult.isFinished = true;
			yield break;
		}
		if (!_doMultiMaterial)
		{
			if (_resultMaterial == null)
			{
				UnityEngine.Debug.LogError("Combined Material is null please create and assign a result material.");
				coroutineResult.isFinished = true;
				yield break;
			}
			Shader shader = _resultMaterial.shader;
			for (int j = 0; j < objsToMesh.Count; j++)
			{
				Material[] gOMaterials = MB_Utility.GetGOMaterials(objsToMesh[j]);
				foreach (Material material in gOMaterials)
				{
					if (material != null && material.shader != shader)
					{
						UnityEngine.Debug.LogWarning("Game object " + objsToMesh[j]?.ToString() + " does not use shader " + shader?.ToString() + " it may not have the required textures. If not small solid color textures will be generated.");
					}
				}
			}
		}
		MB3_TextureCombiner combiner = CreateAndConfigureTextureCombiner();
		combiner.saveAtlasesAsAssets = saveAtlasesAsAssets;
		int num = 1;
		if (_doMultiMaterial)
		{
			num = resultMaterials.Length;
		}
		OnCombinedTexturesCoroutineAtlasesAndRects = new MB_AtlasesAndRects[num];
		for (int l = 0; l < OnCombinedTexturesCoroutineAtlasesAndRects.Length; l++)
		{
			OnCombinedTexturesCoroutineAtlasesAndRects[l] = new MB_AtlasesAndRects();
		}
		for (int i = 0; i < OnCombinedTexturesCoroutineAtlasesAndRects.Length; i++)
		{
			List<Material> allowedMaterialsFilter = null;
			Material combinedMaterial;
			if (_doMultiMaterial)
			{
				allowedMaterialsFilter = resultMaterials[i].sourceMaterials;
				combinedMaterial = resultMaterials[i].combinedMaterial;
				combiner.fixOutOfBoundsUVs = resultMaterials[i].considerMeshUVs;
			}
			else
			{
				combinedMaterial = _resultMaterial;
			}
			MB3_TextureCombiner.CombineTexturesIntoAtlasesCoroutineResult coroutineResult2 = new MB3_TextureCombiner.CombineTexturesIntoAtlasesCoroutineResult();
			yield return combiner.CombineTexturesIntoAtlasesCoroutine(progressInfo, OnCombinedTexturesCoroutineAtlasesAndRects[i], combinedMaterial, objsToMesh, allowedMaterialsFilter, editorMethods, coroutineResult2, maxTimePerFrame);
			coroutineResult.success = coroutineResult2.success;
			if (!coroutineResult.success)
			{
				coroutineResult.isFinished = true;
				yield break;
			}
		}
		unpackMat2RectMap(textureBakeResults);
		textureBakeResults.doMultiMaterial = _doMultiMaterial;
		if (_doMultiMaterial)
		{
			textureBakeResults.resultMaterials = resultMaterials;
		}
		else
		{
			MB_MultiMaterial[] array = new MB_MultiMaterial[1]
			{
				new MB_MultiMaterial()
			};
			array[0].combinedMaterial = _resultMaterial;
			array[0].considerMeshUVs = _fixOutOfBoundsUVs;
			array[0].sourceMaterials = new List<Material>();
			for (int m = 0; m < textureBakeResults.materialsAndUVRects.Length; m++)
			{
				array[0].sourceMaterials.Add(textureBakeResults.materialsAndUVRects[m].material);
			}
			textureBakeResults.resultMaterials = array;
		}
		MB3_MeshBakerCommon[] componentsInChildren = GetComponentsInChildren<MB3_MeshBakerCommon>();
		for (int n = 0; n < componentsInChildren.Length; n++)
		{
			componentsInChildren[n].textureBakeResults = textureBakeResults;
		}
		if (LOG_LEVEL >= MB2_LogLevel.info)
		{
			UnityEngine.Debug.Log("Created Atlases");
		}
		coroutineResult.isFinished = true;
		if (coroutineResult.success && onBuiltAtlasesSuccess != null)
		{
			onBuiltAtlasesSuccess();
		}
		if (!coroutineResult.success && onBuiltAtlasesFail != null)
		{
			onBuiltAtlasesFail();
		}
	}

	public MB_AtlasesAndRects[] CreateAtlases(ProgressUpdateDelegate progressInfo, bool saveAtlasesAsAssets = false, MB2_EditorMethodsInterface editorMethods = null)
	{
		MB_AtlasesAndRects[] array = null;
		try
		{
			_coroutineResult = new CreateAtlasesCoroutineResult();
			MB3_TextureCombiner.RunCorutineWithoutPause(CreateAtlasesCoroutine(progressInfo, _coroutineResult, saveAtlasesAsAssets, editorMethods, 1000f), 0);
			if (_coroutineResult.success && textureBakeResults != null)
			{
				array = OnCombinedTexturesCoroutineAtlasesAndRects;
			}
		}
		catch (Exception message)
		{
			UnityEngine.Debug.LogError(message);
		}
		finally
		{
			if (saveAtlasesAsAssets && array != null)
			{
				foreach (MB_AtlasesAndRects mB_AtlasesAndRects in array)
				{
					if (mB_AtlasesAndRects == null || mB_AtlasesAndRects.atlases == null)
					{
						continue;
					}
					for (int j = 0; j < mB_AtlasesAndRects.atlases.Length; j++)
					{
						if (mB_AtlasesAndRects.atlases[j] != null)
						{
							if (editorMethods != null)
							{
								editorMethods.Destroy(mB_AtlasesAndRects.atlases[j]);
							}
							else
							{
								MB_Utility.Destroy(mB_AtlasesAndRects.atlases[j]);
							}
						}
					}
				}
			}
		}
		return array;
	}

	private void unpackMat2RectMap(MB2_TextureBakeResults tbr)
	{
		List<Material> list = new List<Material>();
		List<MB_MaterialAndUVRect> list2 = new List<MB_MaterialAndUVRect>();
		List<Rect> list3 = new List<Rect>();
		for (int i = 0; i < OnCombinedTexturesCoroutineAtlasesAndRects.Length; i++)
		{
			List<MB_MaterialAndUVRect> mat2rect_map = OnCombinedTexturesCoroutineAtlasesAndRects[i].mat2rect_map;
			if (mat2rect_map != null)
			{
				for (int j = 0; j < mat2rect_map.Count; j++)
				{
					list2.Add(mat2rect_map[j]);
					list.Add(mat2rect_map[j].material);
					list3.Add(mat2rect_map[j].atlasRect);
				}
			}
		}
		tbr.version = MB2_TextureBakeResults.VERSION;
		tbr.materialsAndUVRects = list2.ToArray();
	}

	public MB3_TextureCombiner CreateAndConfigureTextureCombiner()
	{
		return new MB3_TextureCombiner
		{
			LOG_LEVEL = LOG_LEVEL,
			atlasPadding = _atlasPadding,
			maxAtlasSize = _maxAtlasSize,
			maxAtlasHeightOverride = _maxAtlasHeightOverride,
			maxAtlasWidthOverride = _maxAtlasWidthOverride,
			useMaxAtlasHeightOverride = _useMaxAtlasWidthOverride,
			useMaxAtlasWidthOverride = _useMaxAtlasHeightOverride,
			customShaderPropNames = _customShaderProperties,
			fixOutOfBoundsUVs = _fixOutOfBoundsUVs,
			maxTilingBakeSize = _maxTilingBakeSize,
			packingAlgorithm = _packingAlgorithm,
			meshBakerTexturePackerForcePowerOfTwo = _meshBakerTexturePackerForcePowerOfTwo,
			resizePowerOfTwoTextures = _resizePowerOfTwoTextures,
			considerNonTextureProperties = _considerNonTextureProperties
		};
	}

	public static void ConfigureNewMaterialToMatchOld(Material newMat, Material original)
	{
		if (original == null)
		{
			UnityEngine.Debug.LogWarning("Original material is null, could not copy properties to " + newMat?.ToString() + ". Setting shader to " + newMat.shader);
			return;
		}
		newMat.shader = original.shader;
		newMat.CopyPropertiesFromMaterial(original);
		ShaderTextureProperty[] shaderTexPropertyNames = MB3_TextureCombinerPipeline.shaderTexPropertyNames;
		for (int i = 0; i < shaderTexPropertyNames.Length; i++)
		{
			Vector2 one = Vector2.one;
			Vector2 zero = Vector2.zero;
			if (newMat.HasProperty(shaderTexPropertyNames[i].name))
			{
				newMat.SetTextureOffset(shaderTexPropertyNames[i].name, zero);
				newMat.SetTextureScale(shaderTexPropertyNames[i].name, one);
			}
		}
	}

	private string PrintSet(HashSet<Material> s)
	{
		StringBuilder stringBuilder = new StringBuilder();
		foreach (Material item in s)
		{
			stringBuilder.Append(item?.ToString() + ",");
		}
		return stringBuilder.ToString();
	}

	private bool _ValidateResultMaterials()
	{
		HashSet<Material> hashSet = new HashSet<Material>();
		for (int i = 0; i < objsToMesh.Count; i++)
		{
			if (!(objsToMesh[i] != null))
			{
				continue;
			}
			Material[] gOMaterials = MB_Utility.GetGOMaterials(objsToMesh[i]);
			for (int j = 0; j < gOMaterials.Length; j++)
			{
				if (gOMaterials[j] != null)
				{
					hashSet.Add(gOMaterials[j]);
				}
			}
		}
		HashSet<Material> hashSet2 = new HashSet<Material>();
		for (int k = 0; k < resultMaterials.Length; k++)
		{
			MB_MultiMaterial mB_MultiMaterial = resultMaterials[k];
			if (mB_MultiMaterial.combinedMaterial == null)
			{
				UnityEngine.Debug.LogError("Combined Material is null please create and assign a result material.");
				return false;
			}
			Shader shader = mB_MultiMaterial.combinedMaterial.shader;
			for (int l = 0; l < mB_MultiMaterial.sourceMaterials.Count; l++)
			{
				if (mB_MultiMaterial.sourceMaterials[l] == null)
				{
					UnityEngine.Debug.LogError("There are null entries in the list of Source Materials");
					return false;
				}
				if (shader != mB_MultiMaterial.sourceMaterials[l].shader)
				{
					UnityEngine.Debug.LogWarning("Source material " + mB_MultiMaterial.sourceMaterials[l]?.ToString() + " does not use shader " + shader?.ToString() + " it may not have the required textures. If not empty textures will be generated.");
				}
				if (hashSet2.Contains(mB_MultiMaterial.sourceMaterials[l]))
				{
					UnityEngine.Debug.LogError("A Material " + mB_MultiMaterial.sourceMaterials[l]?.ToString() + " appears more than once in the list of source materials in the source material to combined mapping. Each source material must be unique.");
					return false;
				}
				hashSet2.Add(mB_MultiMaterial.sourceMaterials[l]);
			}
		}
		if (hashSet.IsProperSubsetOf(hashSet2))
		{
			hashSet2.ExceptWith(hashSet);
			UnityEngine.Debug.LogWarning("There are materials in the mapping that are not used on your source objects: " + PrintSet(hashSet2));
		}
		if (resultMaterials != null && resultMaterials.Length != 0 && hashSet2.IsProperSubsetOf(hashSet))
		{
			hashSet.ExceptWith(hashSet2);
			UnityEngine.Debug.LogError("There are materials on the objects to combine that are not in the mapping: " + PrintSet(hashSet));
			return false;
		}
		return true;
	}
}
public class MB2_TestShowHide : MonoBehaviour
{
	public MB3_MeshBaker mb;

	public GameObject[] objs;

	private void Update()
	{
		if (Time.frameCount == 100)
		{
			mb.ShowHide(null, objs);
			mb.ApplyShowHide();
			UnityEngine.Debug.Log("should have disappeared");
		}
		if (Time.frameCount == 200)
		{
			mb.ShowHide(objs, null);
			mb.ApplyShowHide();
			UnityEngine.Debug.Log("should show");
		}
	}
}
public class MB2_TestUpdate : MonoBehaviour
{
	public MB3_MeshBaker meshbaker;

	public MB3_MultiMeshBaker multiMeshBaker;

	public GameObject[] objsToMove;

	public GameObject objWithChangingUVs;

	private Vector2[] uvs;

	private Mesh m;

	private void Start()
	{
		meshbaker.AddDeleteGameObjects(objsToMove, null, disableRendererInSource: true);
		meshbaker.AddDeleteGameObjects(new GameObject[1] { objWithChangingUVs }, null, disableRendererInSource: true);
		MeshFilter component = objWithChangingUVs.GetComponent<MeshFilter>();
		m = component.sharedMesh;
		uvs = m.uv;
		meshbaker.Apply();
		multiMeshBaker.AddDeleteGameObjects(objsToMove, null, disableRendererInSource: true);
		multiMeshBaker.AddDeleteGameObjects(new GameObject[1] { objWithChangingUVs }, null, disableRendererInSource: true);
		component = objWithChangingUVs.GetComponent<MeshFilter>();
		m = component.sharedMesh;
		uvs = m.uv;
		multiMeshBaker.Apply();
	}

	private void LateUpdate()
	{
		meshbaker.UpdateGameObjects(objsToMove, recalcBounds: false);
		Vector2[] uv = m.uv;
		for (int i = 0; i < uv.Length; i++)
		{
			uv[i] = Mathf.Sin(Time.time) * uvs[i];
		}
		m.uv = uv;
		meshbaker.UpdateGameObjects(new GameObject[1] { objWithChangingUVs }, recalcBounds: true, updateVertices: true, updateNormals: true, updateTangents: true, updateUV: true);
		meshbaker.Apply(triangles: false, vertices: true, normals: true, tangents: true, uvs: true, uv2: false, uv3: false, uv4: false, colors: false);
		multiMeshBaker.UpdateGameObjects(objsToMove, recalcBounds: false);
		uv = m.uv;
		for (int j = 0; j < uv.Length; j++)
		{
			uv[j] = Mathf.Sin(Time.time) * uvs[j];
		}
		m.uv = uv;
		multiMeshBaker.UpdateGameObjects(new GameObject[1] { objWithChangingUVs }, recalcBounds: true, updateVertices: true, updateNormals: true, updateTangents: true, updateUV: true);
		multiMeshBaker.Apply(triangles: false, vertices: true, normals: true, tangents: true, uvs: true, uv2: false, uv3: false, uv4: false, colors: false);
	}
}
public class MB3_TestAddingRemovingSkinnedMeshes : MonoBehaviour
{
	public MB3_MeshBaker meshBaker;

	public GameObject[] g;

	private void Start()
	{
		StartCoroutine(TestScript());
	}

	private IEnumerator TestScript()
	{
		UnityEngine.Debug.Log("Test 1 adding 0,1,2");
		GameObject[] gos = new GameObject[3]
		{
			g[0],
			g[1],
			g[2]
		};
		meshBaker.AddDeleteGameObjects(gos, null, disableRendererInSource: true);
		meshBaker.Apply();
		meshBaker.meshCombiner.CheckIntegrity();
		yield return new WaitForSeconds(3f);
		UnityEngine.Debug.Log("Test 2 remove 1 and add 3,4,5");
		GameObject[] deleteGOs = new GameObject[1] { g[1] };
		gos = new GameObject[3]
		{
			g[3],
			g[4],
			g[5]
		};
		meshBaker.AddDeleteGameObjects(gos, deleteGOs, disableRendererInSource: true);
		meshBaker.Apply();
		meshBaker.meshCombiner.CheckIntegrity();
		yield return new WaitForSeconds(3f);
		UnityEngine.Debug.Log("Test 3 remove 0,2,5 and add 1");
		deleteGOs = new GameObject[3]
		{
			g[3],
			g[4],
			g[5]
		};
		gos = new GameObject[1] { g[1] };
		meshBaker.AddDeleteGameObjects(gos, deleteGOs, disableRendererInSource: true);
		meshBaker.Apply();
		meshBaker.meshCombiner.CheckIntegrity();
		yield return new WaitForSeconds(3f);
		UnityEngine.Debug.Log("Test 3 remove all remaining");
		deleteGOs = new GameObject[3]
		{
			g[0],
			g[1],
			g[2]
		};
		meshBaker.AddDeleteGameObjects(null, deleteGOs, disableRendererInSource: true);
		meshBaker.Apply();
		meshBaker.meshCombiner.CheckIntegrity();
		yield return new WaitForSeconds(3f);
		UnityEngine.Debug.Log("Test 3 add all");
		meshBaker.AddDeleteGameObjects(g, null, disableRendererInSource: true);
		meshBaker.Apply();
		meshBaker.meshCombiner.CheckIntegrity();
		yield return new WaitForSeconds(1f);
		UnityEngine.Debug.Log("Done");
	}
}
public class MB3_TestBakeAllWithSameMaterial : MonoBehaviour
{
	public GameObject[] listOfObjsToCombineGood;

	public GameObject[] listOfObjsToCombineBad;

	private void Start()
	{
		testCombine();
	}

	private void testCombine()
	{
		MB3_MeshCombinerSingle mB3_MeshCombinerSingle = new MB3_MeshCombinerSingle();
		UnityEngine.Debug.Log("About to bake 1");
		mB3_MeshCombinerSingle.AddDeleteGameObjects(listOfObjsToCombineGood, null);
		mB3_MeshCombinerSingle.Apply();
		mB3_MeshCombinerSingle.UpdateGameObjects(listOfObjsToCombineGood);
		mB3_MeshCombinerSingle.Apply();
		mB3_MeshCombinerSingle.AddDeleteGameObjects(null, listOfObjsToCombineGood);
		mB3_MeshCombinerSingle.Apply();
		UnityEngine.Debug.Log("Did bake 1");
		UnityEngine.Debug.Log("About to bake 2 should get error that one material doesn't match");
		mB3_MeshCombinerSingle.AddDeleteGameObjects(listOfObjsToCombineBad, null);
		mB3_MeshCombinerSingle.Apply();
		UnityEngine.Debug.Log("Did bake 2");
		UnityEngine.Debug.Log("Doing same with multi mesh combiner");
		MB3_MultiMeshCombiner mB3_MultiMeshCombiner = new MB3_MultiMeshCombiner();
		UnityEngine.Debug.Log("About to bake 3");
		mB3_MultiMeshCombiner.AddDeleteGameObjects(listOfObjsToCombineGood, null);
		mB3_MultiMeshCombiner.Apply();
		mB3_MultiMeshCombiner.UpdateGameObjects(listOfObjsToCombineGood);
		mB3_MultiMeshCombiner.Apply();
		mB3_MultiMeshCombiner.AddDeleteGameObjects(null, listOfObjsToCombineGood);
		mB3_MultiMeshCombiner.Apply();
		UnityEngine.Debug.Log("Did bake 3");
		UnityEngine.Debug.Log("About to bake 4  should get error that one material doesn't match");
		mB3_MultiMeshCombiner.AddDeleteGameObjects(listOfObjsToCombineBad, null);
		mB3_MultiMeshCombiner.Apply();
		UnityEngine.Debug.Log("Did bake 4");
	}
}
public class MB3_TestRenderTextureTestHarness : MonoBehaviour
{
	public Texture2D input;

	public bool doColor;

	public Color32 color;

	public Texture2D Create3x3Tex()
	{
		Texture2D texture2D = new Texture2D(3, 3, TextureFormat.ARGB32, mipChain: false);
		Color32[] array = new Color32[texture2D.width * texture2D.height];
		for (int i = 0; i < array.Length; i++)
		{
			array[i] = color;
		}
		texture2D.SetPixels32(array);
		texture2D.Apply();
		return texture2D;
	}

	public Texture2D Create3x3Clone()
	{
		Texture2D texture2D = new Texture2D(3, 3, TextureFormat.ARGB32, mipChain: false);
		Color32[] pixels = new Color32[9]
		{
			new Color32(54, 54, 201, byte.MaxValue),
			new Color32(128, 37, 218, byte.MaxValue),
			new Color32(201, 54, 201, byte.MaxValue),
			new Color32(37, 128, 218, byte.MaxValue),
			new Color32(128, 128, byte.MaxValue, byte.MaxValue),
			new Color32(218, 128, 218, byte.MaxValue),
			new Color32(54, 201, 201, byte.MaxValue),
			new Color32(128, 218, 218, byte.MaxValue),
			new Color32(201, 201, 201, byte.MaxValue)
		};
		texture2D.SetPixels32(pixels);
		texture2D.Apply();
		return texture2D;
	}

	public static void TestRender(Texture2D input, Texture2D output)
	{
		int num = 1;
		ShaderTextureProperty[] array = new ShaderTextureProperty[1]
		{
			new ShaderTextureProperty("_BumpMap", norm: false)
		};
		int width = input.width;
		int height = input.height;
		int padding = 0;
		Rect[] rects = new Rect[1]
		{
			new Rect(0f, 0f, 1f, 1f)
		};
		List<MB_TexSet> list = new List<MB_TexSet>();
		MB_TexSet item = new MB_TexSet(new MeshBakerMaterialTexture[1]
		{
			new MeshBakerMaterialTexture(input)
		}, Vector2.zero, Vector2.one, MB_TextureTilingTreatment.considerUVs);
		list.Add(item);
		GameObject obj = new GameObject("MBrenderAtlasesGO");
		MB3_AtlasPackerRenderTexture mB3_AtlasPackerRenderTexture = obj.AddComponent<MB3_AtlasPackerRenderTexture>();
		obj.AddComponent<Camera>();
		for (int i = 0; i < num; i++)
		{
			Texture2D texture2D = null;
			UnityEngine.Debug.Log("About to render " + array[i].name + " isNormal=" + array[i].isNormalMap);
			mB3_AtlasPackerRenderTexture.LOG_LEVEL = MB2_LogLevel.trace;
			mB3_AtlasPackerRenderTexture.width = width;
			mB3_AtlasPackerRenderTexture.height = height;
			mB3_AtlasPackerRenderTexture.padding = padding;
			mB3_AtlasPackerRenderTexture.rects = rects;
			mB3_AtlasPackerRenderTexture.textureSets = list;
			mB3_AtlasPackerRenderTexture.indexOfTexSetToRender = i;
			mB3_AtlasPackerRenderTexture.isNormalMap = array[i].isNormalMap;
			texture2D = mB3_AtlasPackerRenderTexture.OnRenderAtlas(null);
			UnityEngine.Debug.Log("Created atlas " + array[i].name + " w=" + texture2D.width + " h=" + texture2D.height + " id=" + texture2D.GetInstanceID());
			UnityEngine.Debug.Log("Color " + texture2D.GetPixel(5, 5).ToString() + " " + Color.red.ToString());
			byte[] bytes = texture2D.EncodeToPNG();
			File.WriteAllBytes(UnityEngine.Application.dataPath + "/_Experiment/red.png", bytes);
		}
	}
}
public class MB3_KMeansClustering
{
	private class DataPoint
	{
		public Vector3 center;

		public GameObject gameObject;

		public int Cluster;

		public DataPoint(GameObject go)
		{
			gameObject = go;
			center = go.transform.position;
			if (go.GetComponent<Renderer>() == null)
			{
				UnityEngine.Debug.LogError("Object does not have a renderer " + go);
			}
		}
	}

	private List<DataPoint> _normalizedDataToCluster = new List<DataPoint>();

	private Vector3[] _clusters = new Vector3[0];

	private int _numberOfClusters;

	public MB3_KMeansClustering(List<GameObject> gos, int numClusters)
	{
		for (int i = 0; i < gos.Count; i++)
		{
			if (gos[i] != null)
			{
				DataPoint item = new DataPoint(gos[i]);
				_normalizedDataToCluster.Add(item);
			}
			else
			{
				UnityEngine.Debug.LogWarning($"Object {i} in list of objects to cluster was null.");
			}
		}
		if (numClusters <= 0)
		{
			UnityEngine.Debug.LogError("Number of clusters must be posititve.");
			numClusters = 1;
		}
		if (_normalizedDataToCluster.Count <= numClusters)
		{
			UnityEngine.Debug.LogError("There must be fewer clusters than objects to cluster");
			numClusters = _normalizedDataToCluster.Count - 1;
		}
		_numberOfClusters = numClusters;
		if (_numberOfClusters <= 0)
		{
			_numberOfClusters = 1;
		}
		_clusters = new Vector3[_numberOfClusters];
	}

	private void InitializeCentroids()
	{
		for (int i = 0; i < _numberOfClusters; i++)
		{
			_normalizedDataToCluster[i].Cluster = i;
		}
		for (int j = _numberOfClusters; j < _normalizedDataToCluster.Count; j++)
		{
			_normalizedDataToCluster[j].Cluster = UnityEngine.Random.Range(0, _numberOfClusters);
		}
	}

	private bool UpdateDataPointMeans(bool force)
	{
		if (AnyAreEmpty(_normalizedDataToCluster) && !force)
		{
			return false;
		}
		Vector3[] array = new Vector3[_numberOfClusters];
		int[] array2 = new int[_numberOfClusters];
		for (int i = 0; i < _normalizedDataToCluster.Count; i++)
		{
			int cluster = _normalizedDataToCluster[i].Cluster;
			array[cluster] += _normalizedDataToCluster[i].center;
			array2[cluster]++;
		}
		for (int j = 0; j < _numberOfClusters; j++)
		{
			_clusters[j] = array[j] / array2[j];
		}
		return true;
	}

	private bool AnyAreEmpty(List<DataPoint> data)
	{
		int[] array = new int[_numberOfClusters];
		for (int i = 0; i < _normalizedDataToCluster.Count; i++)
		{
			array[_normalizedDataToCluster[i].Cluster]++;
		}
		for (int j = 0; j < array.Length; j++)
		{
			if (array[j] == 0)
			{
				return true;
			}
		}
		return false;
	}

	private bool UpdateClusterMembership()
	{
		bool flag = false;
		float[] array = new float[_numberOfClusters];
		for (int i = 0; i < _normalizedDataToCluster.Count; i++)
		{
			for (int j = 0; j < _numberOfClusters; j++)
			{
				array[j] = ElucidanDistance(_normalizedDataToCluster[i], _clusters[j]);
			}
			int num = MinIndex(array);
			if (num != _normalizedDataToCluster[i].Cluster)
			{
				flag = true;
				_normalizedDataToCluster[i].Cluster = num;
			}
		}
		if (!flag)
		{
			return false;
		}
		return true;
	}

	private float ElucidanDistance(DataPoint dataPoint, Vector3 mean)
	{
		return Vector3.Distance(dataPoint.center, mean);
	}

	private int MinIndex(float[] distances)
	{
		int result = 0;
		double num = distances[0];
		for (int i = 0; i < distances.Length; i++)
		{
			if ((double)distances[i] < num)
			{
				num = distances[i];
				result = i;
			}
		}
		return result;
	}

	public List<Renderer> GetCluster(int idx, out Vector3 mean, out float size)
	{
		if (idx < 0 || idx >= _numberOfClusters)
		{
			UnityEngine.Debug.LogError("idx is out of bounds");
			mean = Vector3.zero;
			size = 1f;
			return new List<Renderer>();
		}
		UpdateDataPointMeans(force: true);
		List<Renderer> list = new List<Renderer>();
		mean = _clusters[idx];
		float num = 0f;
		for (int i = 0; i < _normalizedDataToCluster.Count; i++)
		{
			if (_normalizedDataToCluster[i].Cluster == idx)
			{
				float num2 = Vector3.Distance(mean, _normalizedDataToCluster[i].center);
				if (num2 > num)
				{
					num = num2;
				}
				list.Add(_normalizedDataToCluster[i].gameObject.GetComponent<Renderer>());
			}
		}
		mean = _clusters[idx];
		size = num;
		return list;
	}

	public void Cluster()
	{
		bool flag = true;
		bool flag2 = true;
		InitializeCentroids();
		int num = _normalizedDataToCluster.Count * 1000;
		int num2 = 0;
		while (flag2 && flag && num2 < num)
		{
			num2++;
			flag2 = UpdateDataPointMeans(force: false);
			flag = UpdateClusterMembership();
		}
	}
}
public class MB_TextureCombinerRenderTexture
{
	public MB2_LogLevel LOG_LEVEL = MB2_LogLevel.info;

	private Material mat;

	private RenderTexture _destinationTexture;

	private Camera myCamera;

	private int _padding;

	private bool _isNormalMap;

	private bool _fixOutOfBoundsUVs;

	private bool _doRenderAtlas;

	private Rect[] rs;

	private List<MB_TexSet> textureSets;

	private int indexOfTexSetToRender;

	private ShaderTextureProperty _texPropertyName;

	private MB3_TextureCombinerNonTextureProperties _resultMaterialTextureBlender;

	private Texture2D targTex;

	public Texture2D DoRenderAtlas(GameObject gameObject, int width, int height, int padding, Rect[] rss, List<MB_TexSet> textureSetss, int indexOfTexSetToRenders, ShaderTextureProperty texPropertyname, MB3_TextureCombinerNonTextureProperties resultMaterialTextureBlender, bool isNormalMap, bool fixOutOfBoundsUVs, bool considerNonTextureProperties, MB3_TextureCombiner texCombiner, MB2_LogLevel LOG_LEV)
	{
		LOG_LEVEL = LOG_LEV;
		textureSets = textureSetss;
		indexOfTexSetToRender = indexOfTexSetToRenders;
		_texPropertyName = texPropertyname;
		_padding = padding;
		_isNormalMap = isNormalMap;
		_fixOutOfBoundsUVs = fixOutOfBoundsUVs;
		_resultMaterialTextureBlender = resultMaterialTextureBlender;
		rs = rss;
		Shader shader = ((!_isNormalMap) ? Shader.Find("MeshBaker/AlbedoShader") : Shader.Find("MeshBaker/NormalMapShader"));
		if (shader == null)
		{
			UnityEngine.Debug.LogError("Could not find shader for RenderTexture. Try reimporting mesh baker");
			return null;
		}
		mat = new Material(shader);
		_destinationTexture = new RenderTexture(width, height, 24, RenderTextureFormat.ARGB32);
		_destinationTexture.filterMode = FilterMode.Point;
		myCamera = gameObject.GetComponent<Camera>();
		myCamera.orthographic = true;
		myCamera.orthographicSize = height >> 1;
		myCamera.aspect = (float)width / (float)height;
		myCamera.targetTexture = _destinationTexture;
		myCamera.clearFlags = CameraClearFlags.Color;
		Transform component = myCamera.GetComponent<Transform>();
		component.localPosition = new Vector3((float)width / 2f, (float)height / 2f, 3f);
		component.localRotation = Quaternion.Euler(0f, 180f, 180f);
		_doRenderAtlas = true;
		if (LOG_LEVEL >= MB2_LogLevel.debug)
		{
			UnityEngine.Debug.Log(string.Format("Begin Camera.Render destTex w={0} h={1} camPos={2} camSize={3} camAspect={4}", width, height, component.localPosition, myCamera.orthographicSize, myCamera.aspect.ToString("f5")));
		}
		myCamera.Render();
		_doRenderAtlas = false;
		MB_Utility.Destroy(mat);
		MB_Utility.Destroy(_destinationTexture);
		if (LOG_LEVEL >= MB2_LogLevel.debug)
		{
			UnityEngine.Debug.Log("Finished Camera.Render ");
		}
		Texture2D result = targTex;
		targTex = null;
		return result;
	}

	public void OnRenderObject()
	{
		if (!_doRenderAtlas)
		{
			return;
		}
		Stopwatch stopwatch = new Stopwatch();
		stopwatch.Start();
		for (int i = 0; i < rs.Length; i++)
		{
			MeshBakerMaterialTexture meshBakerMaterialTexture = textureSets[i].ts[indexOfTexSetToRender];
			Texture2D texture2D = meshBakerMaterialTexture.GetTexture2D();
			if (LOG_LEVEL >= MB2_LogLevel.trace && texture2D != null)
			{
				string[] obj = new string[14]
				{
					"Added ",
					texture2D?.ToString(),
					" to atlas w=",
					texture2D.width.ToString(),
					" h=",
					texture2D.height.ToString(),
					" offset=",
					meshBakerMaterialTexture.matTilingRect.min.ToString(),
					" scale=",
					meshBakerMaterialTexture.matTilingRect.size.ToString(),
					" rect=",
					null,
					null,
					null
				};
				Rect rect = rs[i];
				obj[11] = rect.ToString();
				obj[12] = " padding=";
				obj[13] = _padding.ToString();
				UnityEngine.Debug.Log(string.Concat(obj));
			}
			CopyScaledAndTiledToAtlas(textureSets[i], meshBakerMaterialTexture, textureSets[i].obUVoffset, textureSets[i].obUVscale, rs[i], _texPropertyName, _resultMaterialTextureBlender);
		}
		stopwatch.Stop();
		stopwatch.Start();
		if (LOG_LEVEL >= MB2_LogLevel.debug)
		{
			UnityEngine.Debug.Log("Total time for Graphics.DrawTexture calls " + stopwatch.ElapsedMilliseconds.ToString("f5"));
		}
		if (LOG_LEVEL >= MB2_LogLevel.debug)
		{
			UnityEngine.Debug.Log("Copying RenderTexture to Texture2D. destW" + _destinationTexture.width + " destH" + _destinationTexture.height);
		}
		Texture2D texture2D2 = new Texture2D(_destinationTexture.width, _destinationTexture.height, TextureFormat.ARGB32, mipChain: true);
		RenderTexture active = RenderTexture.active;
		RenderTexture.active = _destinationTexture;
		int num = Mathf.CeilToInt((float)_destinationTexture.width / 512f);
		int num2 = Mathf.CeilToInt((float)_destinationTexture.height / 512f);
		if (num == 0 || num2 == 0)
		{
			if (LOG_LEVEL >= MB2_LogLevel.trace)
			{
				UnityEngine.Debug.Log("Copying all in one shot");
			}
			texture2D2.ReadPixels(new Rect(0f, 0f, _destinationTexture.width, _destinationTexture.height), 0, 0, recalculateMipMaps: true);
		}
		else
		{
			if (LOG_LEVEL >= MB2_LogLevel.trace)
			{
				UnityEngine.Debug.Log("Not OpenGL copying blocks");
			}
			for (int j = 0; j < num; j++)
			{
				for (int k = 0; k < num2; k++)
				{
					int num3 = j * 512;
					int num4 = _destinationTexture.height - 512 - k * 512;
					texture2D2.ReadPixels(new Rect(num3, num4, 512f, 512f), j * 512, k * 512, recalculateMipMaps: true);
				}
			}
		}
		RenderTexture.active = active;
		texture2D2.Apply();
		if (LOG_LEVEL >= MB2_LogLevel.trace)
		{
			UnityEngine.Debug.Log("TempTexture ");
			if (texture2D2.height <= 16 && texture2D2.width <= 16)
			{
				_printTexture(texture2D2);
			}
		}
		myCamera.targetTexture = null;
		RenderTexture.active = null;
		targTex = texture2D2;
		if (LOG_LEVEL >= MB2_LogLevel.debug)
		{
			UnityEngine.Debug.Log("Total time to copy RenderTexture to Texture2D " + stopwatch.ElapsedMilliseconds.ToString("f5"));
		}
	}

	private Color32 ConvertNormalFormatFromUnity_ToStandard(Color32 c)
	{
		Vector3 zero = Vector3.zero;
		zero.x = (float)(int)c.a * 2f - 1f;
		zero.y = (float)(int)c.g * 2f - 1f;
		zero.z = Mathf.Sqrt(1f - zero.x * zero.x - zero.y * zero.y);
		Color32 result = default(Color32);
		result.a = 1;
		result.r = (byte)((zero.x + 1f) * 0.5f);
		result.g = (byte)((zero.y + 1f) * 0.5f);
		result.b = (byte)((zero.z + 1f) * 0.5f);
		return result;
	}

	private bool IsOpenGL()
	{
		return SystemInfo.graphicsDeviceVersion.StartsWith("OpenGL");
	}

	private void CopyScaledAndTiledToAtlas(MB_TexSet texSet, MeshBakerMaterialTexture source, Vector2 obUVoffset, Vector2 obUVscale, Rect rec, ShaderTextureProperty texturePropertyName, MB3_TextureCombinerNonTextureProperties resultMatTexBlender)
	{
		Rect rect = rec;
		myCamera.backgroundColor = resultMatTexBlender.GetColorForTemporaryTexture(texSet.matsAndGOs.mats[0].mat, texturePropertyName);
		rect.y = 1f - (rect.y + rect.height);
		rect.x *= _destinationTexture.width;
		rect.y *= _destinationTexture.height;
		rect.width *= _destinationTexture.width;
		rect.height *= _destinationTexture.height;
		Rect rect2 = rect;
		rect2.x -= _padding;
		rect2.y -= _padding;
		rect2.width += _padding * 2;
		rect2.height += _padding * 2;
		Rect screenRect = default(Rect);
		Rect rect3 = texSet.ts[indexOfTexSetToRender].GetEncapsulatingSamplingRect().GetRect();
		_ = _fixOutOfBoundsUVs;
		Texture2D texture2D = source.GetTexture2D();
		TextureWrapMode wrapMode = texture2D.wrapMode;
		if (rect3.width == 1f && rect3.height == 1f && rect3.x == 0f && rect3.y == 0f)
		{
			texture2D.wrapMode = TextureWrapMode.Clamp;
		}
		else
		{
			texture2D.wrapMode = TextureWrapMode.Repeat;
		}
		if (LOG_LEVEL >= MB2_LogLevel.trace)
		{
			string[] obj = new string[8] { "DrawTexture tex=", texture2D.name, " destRect=", null, null, null, null, null };
			Rect rect4 = rect;
			obj[3] = rect4.ToString();
			obj[4] = " srcRect=";
			rect4 = rect3;
			obj[5] = rect4.ToString();
			obj[6] = " Mat=";
			obj[7] = mat?.ToString();
			UnityEngine.Debug.Log(string.Concat(obj));
		}
		Rect sourceRect = default(Rect);
		sourceRect.x = rect3.x;
		sourceRect.y = rect3.y + 1f - 1f / (float)texture2D.height;
		sourceRect.width = rect3.width;
		sourceRect.height = 1f / (float)texture2D.height;
		screenRect.x = rect.x;
		screenRect.y = rect2.y;
		screenRect.width = rect.width;
		screenRect.height = _padding;
		RenderTexture active = RenderTexture.active;
		RenderTexture.active = _destinationTexture;
		Graphics.DrawTexture(screenRect, texture2D, sourceRect, 0, 0, 0, 0, mat);
		sourceRect.x = rect3.x;
		sourceRect.y = rect3.y;
		sourceRect.width = rect3.width;
		sourceRect.height = 1f / (float)texture2D.height;
		screenRect.x = rect.x;
		screenRect.y = rect.y + rect.height;
		screenRect.width = rect.width;
		screenRect.height = _padding;
		Graphics.DrawTexture(screenRect, texture2D, sourceRect, 0, 0, 0, 0, mat);
		sourceRect.x = rect3.x;
		sourceRect.y = rect3.y;
		sourceRect.width = 1f / (float)texture2D.width;
		sourceRect.height = rect3.height;
		screenRect.x = rect2.x;
		screenRect.y = rect.y;
		screenRect.width = _padding;
		screenRect.height = rect.height;
		Graphics.DrawTexture(screenRect, texture2D, sourceRect, 0, 0, 0, 0, mat);
		sourceRect.x = rect3.x + 1f - 1f / (float)texture2D.width;
		sourceRect.y = rect3.y;
		sourceRect.width = 1f / (float)texture2D.width;
		sourceRect.height = rect3.height;
		screenRect.x = rect.x + rect.width;
		screenRect.y = rect.y;
		screenRect.width = _padding;
		screenRect.height = rect.height;
		Graphics.DrawTexture(screenRect, texture2D, sourceRect, 0, 0, 0, 0, mat);
		sourceRect.x = rect3.x;
		sourceRect.y = rect3.y + 1f - 1f / (float)texture2D.height;
		sourceRect.width = 1f / (float)texture2D.width;
		sourceRect.height = 1f / (float)texture2D.height;
		screenRect.x = rect2.x;
		screenRect.y = rect2.y;
		screenRect.width = _padding;
		screenRect.height = _padding;
		Graphics.DrawTexture(screenRect, texture2D, sourceRect, 0, 0, 0, 0, mat);
		sourceRect.x = rect3.x + 1f - 1f / (float)texture2D.width;
		sourceRect.y = rect3.y + 1f - 1f / (float)texture2D.height;
		sourceRect.width = 1f / (float)texture2D.width;
		sourceRect.height = 1f / (float)texture2D.height;
		screenRect.x = rect.x + rect.width;
		screenRect.y = rect2.y;
		screenRect.width = _padding;
		screenRect.height = _padding;
		Graphics.DrawTexture(screenRect, texture2D, sourceRect, 0, 0, 0, 0, mat);
		sourceRect.x = rect3.x;
		sourceRect.y = rect3.y;
		sourceRect.width = 1f / (float)texture2D.width;
		sourceRect.height = 1f / (float)texture2D.height;
		screenRect.x = rect2.x;
		screenRect.y = rect.y + rect.height;
		screenRect.width = _padding;
		screenRect.height = _padding;
		Graphics.DrawTexture(screenRect, texture2D, sourceRect, 0, 0, 0, 0, mat);
		sourceRect.x = rect3.x + 1f - 1f / (float)texture2D.width;
		sourceRect.y = rect3.y;
		sourceRect.width = 1f / (float)texture2D.width;
		sourceRect.height = 1f / (float)texture2D.height;
		screenRect.x = rect.x + rect.width;
		screenRect.y = rect.y + rect.height;
		screenRect.width = _padding;
		screenRect.height = _padding;
		Graphics.DrawTexture(screenRect, texture2D, sourceRect, 0, 0, 0, 0, mat);
		Graphics.DrawTexture(rect, texture2D, rect3, 0, 0, 0, 0, mat);
		RenderTexture.active = active;
		texture2D.wrapMode = wrapMode;
	}

	private void _printTexture(Texture2D t)
	{
		if (t.width * t.height > 100)
		{
			UnityEngine.Debug.Log("Not printing texture too large.");
			return;
		}
		try
		{
			Color32[] pixels = t.GetPixels32();
			string text = "";
			for (int i = 0; i < t.height; i++)
			{
				for (int j = 0; j < t.width; j++)
				{
					string text2 = text;
					Color32 color = pixels[i * t.width + j];
					text = text2 + color.ToString() + ", ";
				}
				text += "\n";
			}
			UnityEngine.Debug.Log(text);
		}
		catch (Exception ex)
		{
			UnityEngine.Debug.Log("Could not print texture. texture may not be readable." + ex.ToString());
		}
	}
}
[ExecuteInEditMode]
public class MB3_AtlasPackerRenderTexture : MonoBehaviour
{
	private MB_TextureCombinerRenderTexture fastRenderer;

	private bool _doRenderAtlas;

	public int width;

	public int height;

	public int padding;

	public bool isNormalMap;

	public bool fixOutOfBoundsUVs;

	public bool considerNonTextureProperties;

	public MB3_TextureCombinerNonTextureProperties resultMaterialTextureBlender;

	public Rect[] rects;

	public Texture2D tex1;

	public List<MB_TexSet> textureSets;

	public int indexOfTexSetToRender;

	public ShaderTextureProperty texPropertyName;

	public MB2_LogLevel LOG_LEVEL = MB2_LogLevel.info;

	public Texture2D testTex;

	public Material testMat;

	public Texture2D OnRenderAtlas(MB3_TextureCombiner combiner)
	{
		fastRenderer = new MB_TextureCombinerRenderTexture();
		_doRenderAtlas = true;
		Texture2D result = fastRenderer.DoRenderAtlas(base.gameObject, width, height, padding, rects, textureSets, indexOfTexSetToRender, texPropertyName, resultMaterialTextureBlender, isNormalMap, fixOutOfBoundsUVs, considerNonTextureProperties, combiner, LOG_LEVEL);
		_doRenderAtlas = false;
		return result;
	}

	private void OnRenderObject()
	{
		if (_doRenderAtlas)
		{
			fastRenderer.OnRenderObject();
			_doRenderAtlas = false;
		}
	}
}
public class ParticleForceFieldsDemo : MonoBehaviour
{
	[Header("Overview")]
	public Text FPSText;

	public Text particleCountText;

	public Toggle postProcessingToggle;

	public MonoBehaviour postProcessing;

	[Header("Particle System Settings")]
	public ParticleSystem particleSystem;

	private ParticleSystem.MainModule particleSystemMainModule;

	private ParticleSystem.EmissionModule particleSystemEmissionModule;

	public Text maxParticlesText;

	public Text particlesPerSecondText;

	public Slider maxParticlesSlider;

	public Slider particlesPerSecondSlider;

	[Header("Attraction Particle Force Field Settings")]
	public AttractionParticleForceField attractionParticleForceField;

	public Text attractionParticleForceFieldRadiusText;

	public Text attractionParticleForceFieldMaxForceText;

	public Text attractionParticleForceFieldArrivalRadiusText;

	public Text attractionParticleForceFieldArrivedRadiusText;

	public Text attractionParticleForceFieldPositionTextX;

	public Text attractionParticleForceFieldPositionTextY;

	public Text attractionParticleForceFieldPositionTextZ;

	public Slider attractionParticleForceFieldRadiusSlider;

	public Slider attractionParticleForceFieldMaxForceSlider;

	public Slider attractionParticleForceFieldArrivalRadiusSlider;

	public Slider attractionParticleForceFieldArrivedRadiusSlider;

	public Slider attractionParticleForceFieldPositionSliderX;

	public Slider attractionParticleForceFieldPositionSliderY;

	public Slider attractionParticleForceFieldPositionSliderZ;

	[Header("Vortex Particle Force Field Settings")]
	public VortexParticleForceField vortexParticleForceField;

	public Text vortexParticleForceFieldRadiusText;

	public Text vortexParticleForceFieldMaxForceText;

	public Text vortexParticleForceFieldRotationTextX;

	public Text vortexParticleForceFieldRotationTextY;

	public Text vortexParticleForceFieldRotationTextZ;

	public Text vortexParticleForceFieldPositionTextX;

	public Text vortexParticleForceFieldPositionTextY;

	public Text vortexParticleForceFieldPositionTextZ;

	public Slider vortexParticleForceFieldRadiusSlider;

	public Slider vortexParticleForceFieldMaxForceSlider;

	public Slider vortexParticleForceFieldRotationSliderX;

	public Slider vortexParticleForceFieldRotationSliderY;

	public Slider vortexParticleForceFieldRotationSliderZ;

	public Slider vortexParticleForceFieldPositionSliderX;

	public Slider vortexParticleForceFieldPositionSliderY;

	public Slider vortexParticleForceFieldPositionSliderZ;

	private void Start()
	{
		if ((bool)postProcessing)
		{
			postProcessingToggle.isOn = postProcessing.enabled;
		}
		particleSystemMainModule = particleSystem.main;
		particleSystemEmissionModule = particleSystem.emission;
		maxParticlesSlider.value = particleSystemMainModule.maxParticles;
		particlesPerSecondSlider.value = particleSystemEmissionModule.rateOverTime.constant;
		maxParticlesText.text = "Max Particles: " + maxParticlesSlider.value;
		particlesPerSecondText.text = "Particles Per Second: " + particlesPerSecondSlider.value;
		attractionParticleForceFieldRadiusSlider.value = attractionParticleForceField.radius;
		attractionParticleForceFieldMaxForceSlider.value = attractionParticleForceField.force;
		attractionParticleForceFieldArrivalRadiusSlider.value = attractionParticleForceField.arrivalRadius;
		attractionParticleForceFieldArrivedRadiusSlider.value = attractionParticleForceField.arrivedRadius;
		Vector3 position = attractionParticleForceField.transform.position;
		attractionParticleForceFieldPositionSliderX.value = position.x;
		attractionParticleForceFieldPositionSliderY.value = position.y;
		attractionParticleForceFieldPositionSliderZ.value = position.z;
		attractionParticleForceFieldRadiusText.text = "Radius: " + attractionParticleForceFieldRadiusSlider.value;
		attractionParticleForceFieldMaxForceText.text = "Max Force: " + attractionParticleForceFieldMaxForceSlider.value;
		attractionParticleForceFieldArrivalRadiusText.text = "Arrival Radius: " + attractionParticleForceFieldArrivalRadiusSlider.value;
		attractionParticleForceFieldArrivedRadiusText.text = "Arrived Radius: " + attractionParticleForceFieldArrivedRadiusSlider.value;
		attractionParticleForceFieldPositionTextX.text = "Position X: " + attractionParticleForceFieldPositionSliderX.value;
		attractionParticleForceFieldPositionTextY.text = "Position Y: " + attractionParticleForceFieldPositionSliderY.value;
		attractionParticleForceFieldPositionTextZ.text = "Position Z: " + attractionParticleForceFieldPositionSliderZ.value;
		vortexParticleForceFieldRadiusSlider.value = vortexParticleForceField.radius;
		vortexParticleForceFieldMaxForceSlider.value = vortexParticleForceField.force;
		Vector3 eulerAngles = vortexParticleForceField.transform.eulerAngles;
		vortexParticleForceFieldRotationSliderX.value = eulerAngles.x;
		vortexParticleForceFieldRotationSliderY.value = eulerAngles.y;
		vortexParticleForceFieldRotationSliderZ.value = eulerAngles.z;
		Vector3 position2 = vortexParticleForceField.transform.position;
		vortexParticleForceFieldPositionSliderX.value = position2.x;
		vortexParticleForceFieldPositionSliderY.value = position2.y;
		vortexParticleForceFieldPositionSliderZ.value = position2.z;
		vortexParticleForceFieldRadiusText.text = "Radius: " + vortexParticleForceFieldRadiusSlider.value;
		vortexParticleForceFieldMaxForceText.text = "Max Force: " + vortexParticleForceFieldMaxForceSlider.value;
		vortexParticleForceFieldRotationTextX.text = "Rotation X: " + vortexParticleForceFieldRotationSliderX.value;
		vortexParticleForceFieldRotationTextY.text = "Rotation Y: " + vortexParticleForceFieldRotationSliderY.value;
		vortexParticleForceFieldRotationTextZ.text = "Rotation Z: " + vortexParticleForceFieldRotationSliderZ.value;
		vortexParticleForceFieldPositionTextX.text = "Position X: " + vortexParticleForceFieldPositionSliderX.value;
		vortexParticleForceFieldPositionTextY.text = "Position Y: " + vortexParticleForceFieldPositionSliderY.value;
		vortexParticleForceFieldPositionTextZ.text = "Position Z: " + vortexParticleForceFieldPositionSliderZ.value;
	}

	private void Update()
	{
		FPSText.text = "FPS: " + 1f / Time.deltaTime;
		particleCountText.text = "Particle Count: " + particleSystem.particleCount;
	}

	public void ReloadScene()
	{
		SceneManager.LoadScene(SceneManager.GetActiveScene().buildIndex);
	}

	public void SetMaxParticles(float value)
	{
		particleSystemMainModule.maxParticles = (int)value;
		maxParticlesText.text = "Max Particles: " + value;
	}

	public void SetParticleEmissionPerSecond(float value)
	{
		particleSystemEmissionModule.rateOverTime = value;
		particlesPerSecondText.text = "Particles Per Second: " + value;
	}

	public void SetAttractionParticleForceFieldRadius(float value)
	{
		attractionParticleForceField.radius = value;
		attractionParticleForceFieldRadiusText.text = "Radius: " + value;
	}

	public void SetAttractionParticleForceFieldMaxForce(float value)
	{
		attractionParticleForceField.force = value;
		attractionParticleForceFieldMaxForceText.text = "Max Force: " + value;
	}

	public void SetAttractionParticleForceFieldArrivalRadius(float value)
	{
		attractionParticleForceField.arrivalRadius = value;
		attractionParticleForceFieldArrivalRadiusText.text = "Arrival Radius: " + value;
	}

	public void SetAttractionParticleForceFieldArrivedRadius(float value)
	{
		attractionParticleForceField.arrivedRadius = value;
		attractionParticleForceFieldArrivedRadiusText.text = "Arrived Radius: " + value;
	}

	public void SetAttractionParticleForceFieldPositionX(float value)
	{
		Vector3 position = attractionParticleForceField.transform.position;
		position.x = value;
		attractionParticleForceField.transform.position = position;
		attractionParticleForceFieldPositionTextX.text = "Position X: " + value;
	}

	public void SetAttractionParticleForceFieldPositionY(float value)
	{
		Vector3 position = attractionParticleForceField.transform.position;
		position.y = value;
		attractionParticleForceField.transform.position = position;
		attractionParticleForceFieldPositionTextY.text = "Position Y: " + value;
	}

	public void SetAttractionParticleForceFieldPositionZ(float value)
	{
		Vector3 position = attractionParticleForceField.transform.position;
		position.z = value;
		attractionParticleForceField.transform.position = position;
		attractionParticleForceFieldPositionTextZ.text = "Position Z: " + value;
	}

	public void SetVortexParticleForceFieldRadius(float value)
	{
		vortexParticleForceField.radius = value;
		vortexParticleForceFieldRadiusText.text = "Radius: " + value;
	}

	public void SetVortexParticleForceFieldMaxForce(float value)
	{
		vortexParticleForceField.force = value;
		vortexParticleForceFieldMaxForceText.text = "Max Force: " + value;
	}

	public void SetVortexParticleForceFieldRotationX(float value)
	{
		Vector3 eulerAngles = vortexParticleForceField.transform.eulerAngles;
		eulerAngles.x = value;
		vortexParticleForceField.transform.eulerAngles = eulerAngles;
		vortexParticleForceFieldRotationTextX.text = "Rotation X: " + value;
	}

	public void SetVortexParticleForceFieldRotationY(float value)
	{
		Vector3 eulerAngles = vortexParticleForceField.transform.eulerAngles;
		eulerAngles.y = value;
		vortexParticleForceField.transform.eulerAngles = eulerAngles;
		vortexParticleForceFieldRotationTextY.text = "Rotation Y: " + value;
	}

	public void SetVortexParticleForceFieldRotationZ(float value)
	{
		Vector3 eulerAngles = vortexParticleForceField.transform.eulerAngles;
		eulerAngles.z = value;
		vortexParticleForceField.transform.eulerAngles = eulerAngles;
		vortexParticleForceFieldRotationTextZ.text = "Rotation Z: " + value;
	}

	public void SetVortexParticleForceFieldPositionX(float value)
	{
		Vector3 position = vortexParticleForceField.transform.position;
		position.x = value;
		vortexParticleForceField.transform.position = position;
		vortexParticleForceFieldPositionTextX.text = "Position X: " + value;
	}

	public void SetVortexParticleForceFieldPositionY(float value)
	{
		Vector3 position = vortexParticleForceField.transform.position;
		position.y = value;
		vortexParticleForceField.transform.position = position;
		vortexParticleForceFieldPositionTextY.text = "Position Y: " + value;
	}

	public void SetVortexParticleForceFieldPositionZ(float value)
	{
		Vector3 position = vortexParticleForceField.transform.position;
		position.z = value;
		vortexParticleForceField.transform.position = position;
		vortexParticleForceFieldPositionTextZ.text = "Position Z: " + value;
	}
}
public class ParticleForceFieldsDemo_CameraRig : MonoBehaviour
{
	public Transform pivot;

	private Vector3 targetRotation;

	[Range(0f, 90f)]
	public float rotationLimit = 90f;

	public float rotationSpeed = 2f;

	public float rotationLerpSpeed = 4f;

	private Vector3 startRotation;

	private void Start()
	{
		startRotation = pivot.localEulerAngles;
		targetRotation = startRotation;
	}

	private void Update()
	{
		float axis = Input.GetAxis("Horizontal");
		float axis2 = Input.GetAxis("Vertical");
		if (Input.GetKeyDown(KeyCode.R))
		{
			targetRotation = startRotation;
		}
		axis *= rotationSpeed;
		axis2 *= rotationSpeed;
		targetRotation.y += axis;
		targetRotation.x += axis2;
		targetRotation.x = Mathf.Clamp(targetRotation.x, 0f - rotationLimit, rotationLimit);
		targetRotation.y = Mathf.Clamp(targetRotation.y, 0f - rotationLimit, rotationLimit);
		Vector3 localEulerAngles = pivot.localEulerAngles;
		localEulerAngles.x = Mathf.LerpAngle(localEulerAngles.x, targetRotation.x, Time.deltaTime * rotationLerpSpeed);
		localEulerAngles.y = Mathf.LerpAngle(localEulerAngles.y, targetRotation.y, Time.deltaTime * rotationLerpSpeed);
		pivot.localEulerAngles = localEulerAngles;
	}
}
public class ParticlePlexusDemo_CameraRig : MonoBehaviour
{
	public Transform pivot;

	private Vector3 targetRotation;

	[Range(0f, 90f)]
	public float rotationLimit = 90f;

	public float rotationSpeed = 2f;

	public float rotationLerpSpeed = 4f;

	private Vector3 startRotation;

	private void Start()
	{
		startRotation = pivot.localEulerAngles;
		targetRotation = startRotation;
	}

	private void Update()
	{
		float axis = Input.GetAxis("Horizontal");
		float axis2 = Input.GetAxis("Vertical");
		if (Input.GetKeyDown(KeyCode.R))
		{
			targetRotation = startRotation;
		}
		axis *= rotationSpeed;
		axis2 *= rotationSpeed;
		targetRotation.y += axis;
		targetRotation.x += axis2;
		targetRotation.x = Mathf.Clamp(targetRotation.x, 0f - rotationLimit, rotationLimit);
		targetRotation.y = Mathf.Clamp(targetRotation.y, 0f - rotationLimit, rotationLimit);
		Vector3 localEulerAngles = pivot.localEulerAngles;
		localEulerAngles.x = Mathf.LerpAngle(localEulerAngles.x, targetRotation.x, Time.deltaTime * rotationLerpSpeed);
		localEulerAngles.y = Mathf.LerpAngle(localEulerAngles.y, targetRotation.y, Time.deltaTime * rotationLerpSpeed);
		pivot.localEulerAngles = localEulerAngles;
	}
}
public class Presentation : MonoBehaviour
{
	private bool left = true;

	private bool rotated;

	private bool move;

	public float speed = 0.35f;

	public int maxX = 16;

	private void Start()
	{
	}

	private void Update()
	{
		if (base.transform.position.x < (float)maxX && left)
		{
			base.transform.Translate(Vector3.left * (Time.deltaTime * speed));
		}
		else if (!rotated)
		{
			left = false;
			base.transform.Rotate(0f, 180f, 0f, Space.World);
			rotated = true;
		}
		else if (base.transform.position.x > 0f)
		{
			base.transform.Translate(Vector3.left * (Time.deltaTime * speed));
		}
		else if (!move)
		{
			base.transform.Rotate(0f, -90f, 0f, Space.World);
			move = true;
		}
	}
}
public class Doors : MonoBehaviour
{
	private Animator animator;

	private bool doorOpen;

	private void Start()
	{
		doorOpen = false;
		animator = GetComponent<Animator>();
	}

	private void OnTriggerEnter(Collider col)
	{
		if (col.gameObject.tag == "Player")
		{
			doorOpen = true;
			DoorControl("Open");
		}
	}

	private void OnTriggerExit(Collider col)
	{
		if (doorOpen)
		{
			doorOpen = false;
			DoorControl("Close");
		}
	}

	private void DoorControl(string direction)
	{
		animator.SetTrigger(direction);
	}
}
public class ScrollingUVs : MonoBehaviour
{
	public int materialIndex;

	public Vector2 uvAnimationRate = new Vector2(1f, 0f);

	public string textureName = "_MainTex";

	private Vector2 uvOffset = Vector2.zero;

	private void LateUpdate()
	{
		uvOffset += uvAnimationRate * Time.deltaTime;
		if (GetComponent<Renderer>().enabled)
		{
			GetComponent<Renderer>().materials[materialIndex].SetTextureOffset(textureName, uvOffset);
		}
	}
}
public class BasicCommands
{
	[Command("clear", "clears the terminal screen")]
	public void ClearTerminal()
	{
		Terminal.instance.Clear();
	}

	[Command("help", "Shows list of available commands")]
	public string Help()
	{
		string text = "List of available commands:";
		foreach (MethodInfo method in Terminal.instance.terminalMethods.methods)
		{
			object[] customAttributes = method.GetCustomAttributes(inherit: true);
			foreach (object obj in customAttributes)
			{
				if (obj is CommandAttribute)
				{
					CommandAttribute commandAttribute = (CommandAttribute)obj;
					text = text + "\n      " + commandAttribute.commandName + " --> " + commandAttribute.commandDesc;
				}
			}
		}
		return text;
	}

	[Command("hide", "Hides the terminal")]
	public void Hide()
	{
		Terminal.instance.Hide();
	}
}
[CreateAssetMenu]
public class TerminalConfig : ScriptableObject
{
	public string arrow;

	public string backslash;

	public string console;

	public Font font;

	public Color commandColor;

	public Color autoCompleteHoverColor;
}
public class SampleCommand
{
	[Command("debug", "Debugs a sample line in Unity Console")]
	public void SampleDebug(string input)
	{
		UnityEngine.Debug.Log(input);
	}
}
public class Terminal : MonoBehaviour
{
	public static Terminal instance;

	[SerializeField]
	public TerminalConfig config;

	public TerminalMethods terminalMethods;

	private TerminalInputHandler inputHandler;

	private TerminalGUI terminalGui;

	public TouchScreenKeyboard touchScreenKeyboard;

	public int mobileTouchCount = 4;

	public bool displayTerminal { get; private set; }

	public string inputText { get; private set; }

	public string history { get; private set; }

	public List<string> autoCompList { get; private set; }

	public int autoCompIndex { get; private set; }

	public string consoleLine => config.console + config.backslash + config.arrow + " ";

	private void Awake()
	{
		instance = this;
		if (config == null)
		{
			config = Resources.Load<TerminalConfig>("Config/ZSH");
		}
		if (mobileTouchCount <= 0)
		{
			mobileTouchCount = 4;
		}
		autoCompIndex = 0;
		autoCompList = new List<string>();
		terminalMethods = new TerminalMethods();
		inputHandler = new TerminalInputHandler(this);
		terminalGui = new TerminalGUI(this);
	}

	internal void Hide()
	{
		displayTerminal = false;
	}

	private void OnGUI()
	{
		if (displayTerminal)
		{
			terminalGui.OnGUI();
		}
	}

	private void Update()
	{
		inputHandler.Update();
	}

	internal void SetInputText(string inputString)
	{
		inputText = inputString;
	}

	public void UpdateInputText(string input)
	{
		inputText += input;
	}

	public void OnUpArrowPressed()
	{
		if (autoCompList.Count > 0)
		{
			autoCompIndex = (int)Mathf.Repeat(autoCompIndex - 1, autoCompList.Count);
		}
	}

	internal void ChangeInput(string input)
	{
		inputText = input;
	}

	public void OnDownArrowPressed()
	{
		if (autoCompList.Count > 0)
		{
			autoCompIndex = (int)Mathf.Repeat(autoCompIndex + 1, autoCompList.Count);
		}
	}

	public void PreExecute()
	{
		string text = ExecuteCommand(inputText);
		history = history + consoleLine + inputText + "\n" + ((!string.IsNullOrEmpty(text)) ? (text + "\n") : "");
		inputText = "";
	}

	public void OnTabPressed()
	{
		if (autoCompList.Count != 0)
		{
			OnEnterPressed();
			return;
		}
		autoCompIndex = 0;
		autoCompList.Clear();
		autoCompList.AddRange(terminalMethods.GetCommandsContaining(inputText));
	}

	private string ExecuteCommand(string inputText)
	{
		autoCompList.Clear();
		bool flag = false;
		string text = null;
		string value = Regex.Match(inputText, "\\(([^)]*)\\)").Groups[1].Value;
		List<string> list = new List<string>();
		string text2;
		if (!string.IsNullOrEmpty(value))
		{
			list = value.Split(',').ToList();
			text2 = inputText.Replace(value, "").Replace("(", "").Replace(")", "")
				.Replace(";", "");
		}
		else
		{
			text2 = inputText.Replace("(", "").Replace(")", "").Replace(";", "");
		}
		foreach (MethodInfo method in terminalMethods.methods)
		{
			object[] customAttributes = method.GetCustomAttributes(inherit: true);
			foreach (object obj in customAttributes)
			{
				if (!(obj is CommandAttribute) || !(((CommandAttribute)obj).commandName == text2))
				{
					continue;
				}
				if (flag)
				{
					UnityEngine.Debug.LogError("Multiple commands are defined with: " + text2);
				}
				Type declaringType = method.DeclaringType;
				ParameterInfo[] parameters = method.GetParameters();
				List<object> list2 = new List<object>();
				if (list.Count != 0)
				{
					if (parameters.Length != list.Count)
					{
						text = $"Method {text2} needs {parameters.Length} arguments, passed {list.Count}";
						UnityEngine.Debug.Log(text);
						return text;
					}
					for (int j = 0; j < parameters.Length; j++)
					{
						try
						{
							object item = Convert.ChangeType(list[j], parameters[j].ParameterType);
							list2.Add(item);
						}
						catch
						{
							text = $"Counld not convert {list[j]} to Type {parameters[j].ParameterType}";
							UnityEngine.Debug.LogError(text);
							return text;
						}
					}
				}
				if (declaringType.IsSubclassOf(typeof(UnityEngine.Object)))
				{
					UnityEngine.Object[] array = UnityEngine.Object.FindObjectsOfType(declaringType);
					if (array != null)
					{
						UnityEngine.Object[] array2 = array;
						foreach (UnityEngine.Object obj3 in array2)
						{
							text = (string)method.Invoke(obj3, list2.ToArray());
						}
					}
				}
				else
				{
					object obj4 = Activator.CreateInstance(declaringType);
					text = (string)method.Invoke(obj4, list2.ToArray());
				}
				flag = true;
				break;
			}
		}
		if (!string.IsNullOrEmpty(text))
		{
			return text;
		}
		if (flag)
		{
			return null;
		}
		return "Command not found! type \"help\" for list of available commands!";
	}

	internal void Clear()
	{
		StartCoroutine(ClearTerminalCoroutine());
	}

	private IEnumerator ClearTerminalCoroutine()
	{
		yield return new WaitForEndOfFrame();
		history = "";
	}

	internal void ToggleTerminal()
	{
		displayTerminal = !displayTerminal;
		DisplayTouchScreenKeyboard();
	}

	public void DisplayTouchScreenKeyboard()
	{
		if ((UnityEngine.Application.platform == RuntimePlatform.Android || UnityEngine.Application.platform == RuntimePlatform.IPhonePlayer) && displayTerminal)
		{
			touchScreenKeyboard = TouchScreenKeyboard.Open(inputText, TouchScreenKeyboardType.Default);
			TouchScreenKeyboard.hideInput = true;
		}
	}

	internal void OnBackSpacePressed()
	{
		if (inputText.Length >= 1)
		{
			inputText = inputText.Substring(0, inputText.Length - 1);
		}
	}

	internal void OnEnterPressed()
	{
		if (autoCompList.Count > 0)
		{
			inputText = autoCompList[autoCompIndex];
			autoCompList.Clear();
		}
		else
		{
			PreExecute();
		}
	}
}
[AttributeUsage(AttributeTargets.Method)]
public class CommandAttribute : Attribute
{
	public string commandName;

	public string commandDesc;

	public CommandAttribute(string name)
	{
		commandName = name;
	}

	public CommandAttribute(string name, string desc)
	{
		commandName = name;
		commandDesc = desc;
	}
}
public class TerminalGUI
{
	private Terminal terminal;

	private TerminalConfig config;

	public GUIStyle terminalStyle { get; private set; }

	public TerminalGUI(Terminal terminal)
	{
		this.terminal = terminal;
		config = terminal.config;
		terminalStyle = new GUIStyle();
		terminalStyle.font = config.font;
		terminalStyle.fontSize = 16;
		terminalStyle.richText = true;
		terminalStyle.normal.textColor = config.commandColor;
		terminalStyle.hover.textColor = config.autoCompleteHoverColor;
		terminalStyle.active.textColor = config.autoCompleteHoverColor;
		terminalStyle.onHover.textColor = config.autoCompleteHoverColor;
		terminalStyle.onActive.textColor = config.autoCompleteHoverColor;
	}

	internal void OnGUI()
	{
		GUILayout.Label(terminal.history + terminal.consoleLine + terminal.inputText, terminalStyle);
		if (terminal.autoCompList.Count > 0)
		{
			for (int i = 0; i < terminal.autoCompList.Count; i++)
			{
				GUI.SetNextControlName(terminal.autoCompList[i]);
				GUIStyle style = terminalStyle;
				if (i == terminal.autoCompIndex)
				{
					GUI.color = config.autoCompleteHoverColor;
				}
				else
				{
					GUI.color = config.commandColor;
				}
				if (GUILayout.Button(terminal.autoCompList[i], style))
				{
					terminal.ChangeInput(terminal.autoCompList[i]);
					terminal.PreExecute();
				}
			}
		}
		else
		{
			GUI.color = config.commandColor;
		}
	}
}
public class TerminalInputHandler
{
	private Terminal terminal;

	private int touchCounter;

	private float touchDelay = 1.5f;

	private float ellapsedTime;

	public TerminalInputHandler(Terminal t)
	{
		terminal = t;
	}

	public void Update()
	{
		if ((UnityEngine.Application.platform == RuntimePlatform.Android || UnityEngine.Application.platform == RuntimePlatform.IPhonePlayer) && MobileInput())
		{
			terminal.ToggleTerminal();
		}
		else if (Input.GetKeyDown("`"))
		{
			terminal.ToggleTerminal();
		}
		else if (terminal.displayTerminal)
		{
			if (Input.GetKeyDown(KeyCode.Backspace))
			{
				terminal.OnBackSpacePressed();
			}
			else if (Input.GetKeyDown(KeyCode.Tab))
			{
				terminal.OnTabPressed();
			}
			else if (Input.GetKeyDown(KeyCode.Return) || Input.GetKeyDown(KeyCode.KeypadEnter))
			{
				terminal.OnEnterPressed();
			}
			else if (Input.GetKeyDown(KeyCode.DownArrow))
			{
				terminal.OnDownArrowPressed();
			}
			else if (Input.GetKeyDown(KeyCode.UpArrow))
			{
				terminal.OnUpArrowPressed();
			}
			else if (UnityEngine.Application.platform != RuntimePlatform.Android && UnityEngine.Application.platform != RuntimePlatform.IPhonePlayer)
			{
				terminal.UpdateInputText(Input.inputString);
			}
		}
	}

	private bool MobileInput()
	{
		if (terminal.touchScreenKeyboard != null && terminal.touchScreenKeyboard.done)
		{
			terminal.SetInputText(terminal.touchScreenKeyboard.text);
			terminal.OnEnterPressed();
			terminal.touchScreenKeyboard = null;
		}
		if (Input.touchCount == terminal.mobileTouchCount)
		{
			ellapsedTime += Time.deltaTime;
		}
		if (ellapsedTime > touchDelay)
		{
			ellapsedTime = 0f;
			if (terminal.displayTerminal)
			{
				terminal.DisplayTouchScreenKeyboard();
				return false;
			}
			return true;
		}
		return false;
	}
}
public class TerminalMethods
{
	private List<string> methodNames = new List<string>();

	public List<MethodInfo> methods { get; private set; }

	public TerminalMethods()
	{
		methods = new List<MethodInfo>();
		Assembly assembly = AppDomain.CurrentDomain.Load("Assembly-CSharp");
		methods = (from y in assembly.GetTypes().SelectMany((Type x) => x.GetMethods())
			where y.GetCustomAttributes(inherit: true).OfType<CommandAttribute>().Any()
			select y).ToList();
		foreach (MethodInfo method in methods)
		{
			object[] customAttributes = method.GetCustomAttributes(inherit: true);
			foreach (object obj in customAttributes)
			{
				if (obj is CommandAttribute)
				{
					CommandAttribute commandAttribute = (CommandAttribute)obj;
					methodNames.Add(commandAttribute.commandName);
				}
			}
		}
	}

	public string[] GetCommandsContaining(string input)
	{
		return methodNames.Where((string k) => k.Contains(input)).ToArray();
	}
}
public class TerminalStrings
{
	public const string COMMAND_NOT_FOUND = "Command not found! type \"help\" for list of available commands!";

	public const string MULTIPLE_COMMAND_NAMES = "Multiple commands are defined with: ";

	public const string ARGUMENT_COUNT_MISSMATCH = "Method {0} needs {1} arguments, passed {2}";
}
[RequireComponent(typeof(ParticleSystem))]
public class particleAttractorLinear : MonoBehaviour
{
	private ParticleSystem ps;

	private ParticleSystem.Particle[] m_Particles;

	public Transform target;

	public float speed = 5f;

	private int numParticlesAlive;

	private void Start()
	{
		ps = GetComponent<ParticleSystem>();
		if (!GetComponent<Transform>())
		{
			GetComponent<Transform>();
		}
	}

	private void Update()
	{
		m_Particles = new ParticleSystem.Particle[ps.main.maxParticles];
		numParticlesAlive = ps.GetParticles(m_Particles);
		float t = speed * Time.deltaTime;
		for (int i = 0; i < numParticlesAlive; i++)
		{
			m_Particles[i].position = Vector3.LerpUnclamped(m_Particles[i].position, target.position, t);
		}
		ps.SetParticles(m_Particles, numParticlesAlive);
	}
}
[RequireComponent(typeof(ParticleSystem))]
public class particleAttractorMove : MonoBehaviour
{
	private ParticleSystem ps;

	private ParticleSystem.Particle[] m_Particles;

	public Transform target;

	public float speed = 5f;

	private int numParticlesAlive;

	private void Start()
	{
		ps = GetComponent<ParticleSystem>();
		if (!GetComponent<Transform>())
		{
			GetComponent<Transform>();
		}
	}

	private void Update()
	{
		m_Particles = new ParticleSystem.Particle[ps.main.maxParticles];
		numParticlesAlive = ps.GetParticles(m_Particles);
		float maxDistanceDelta = speed * Time.deltaTime;
		for (int i = 0; i < numParticlesAlive; i++)
		{
			m_Particles[i].position = Vector3.MoveTowards(m_Particles[i].position, target.position, maxDistanceDelta);
		}
		ps.SetParticles(m_Particles, numParticlesAlive);
	}
}
[RequireComponent(typeof(ParticleSystem))]
public class particleAttractorSelf : MonoBehaviour
{
	private ParticleSystem ps;

	private ParticleSystem.Particle[] m_Particles;

	public float speed = 5f;

	private int numParticlesAlive;

	private void Start()
	{
		ps = GetComponent<ParticleSystem>();
		if (!GetComponent<Transform>())
		{
			GetComponent<Transform>();
		}
	}

	private void Update()
	{
		m_Particles = new ParticleSystem.Particle[ps.main.maxParticles];
		numParticlesAlive = ps.GetParticles(m_Particles);
		float t = speed * Time.deltaTime;
		for (int i = 0; i < numParticlesAlive; i++)
		{
			m_Particles[i].position = Vector3.SlerpUnclamped(m_Particles[i].position, m_Particles[i + 1].position, t);
		}
		ps.SetParticles(m_Particles, numParticlesAlive);
	}
}
[RequireComponent(typeof(ParticleSystem))]
public class particleAttractorSpherical : MonoBehaviour
{
	private ParticleSystem ps;

	private ParticleSystem.Particle[] m_Particles;

	public Transform target;

	public float speed = 5f;

	private int numParticlesAlive;

	private void Start()
	{
		ps = GetComponent<ParticleSystem>();
		if (!GetComponent<Transform>())
		{
			GetComponent<Transform>();
		}
	}

	private void Update()
	{
		m_Particles = new ParticleSystem.Particle[ps.main.maxParticles];
		numParticlesAlive = ps.GetParticles(m_Particles);
		float t = speed * Time.deltaTime;
		for (int i = 0; i < numParticlesAlive; i++)
		{
			m_Particles[i].position = Vector3.SlerpUnclamped(m_Particles[i].position, target.position, t);
		}
		ps.SetParticles(m_Particles, numParticlesAlive);
	}
}
public class rotation : MonoBehaviour
{
	public float xRotation;

	public float yRotation;

	public float zRotation;

	private void OnEnable()
	{
		InvokeRepeating("rotate", 0f, 0.0167f);
	}

	private void OnDisable()
	{
		CancelInvoke();
	}

	public void clickOn()
	{
		InvokeRepeating("rotate", 0f, 0.0167f);
	}

	public void clickOff()
	{
		CancelInvoke();
	}

	private void rotate()
	{
		base.transform.localEulerAngles += new Vector3(xRotation, yRotation, zRotation);
	}
}
public class PL_RandomMovement : MonoBehaviour
{
	public Vector3 rp;

	public int counter;

	public float speed;

	public int duplicate;

	public static bool duped;

	public IEnumerator Start()
	{
		if (base.transform.childCount > 0)
		{
			InvokeRepeating("RandomPos", 0f, UnityEngine.Random.Range(1.1f, 0.3f));
			yield return new WaitForSeconds(4f);
			if (!duped)
			{
				for (int i = 0; i < duplicate; i++)
				{
					StartCoroutine(Spawn());
				}
				duped = true;
			}
		}
		else
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}

	public void RandomPos()
	{
		rp = UnityEngine.Random.insideUnitSphere * 30f;
		rp.x *= 1.25f;
		rp.z *= 2f;
		rp.y *= 0.87f;
		counter = 0;
	}

	public IEnumerator Spawn()
	{
		yield return new WaitForSeconds(UnityEngine.Random.value);
		UnityEngine.Object.Instantiate(base.gameObject);
	}

	public void Update()
	{
		counter++;
		base.transform.position = Vector3.Lerp(base.transform.position, rp, Time.deltaTime * (float)counter * 0.05f * speed);
	}
}
public class PL_RandomRotate : MonoBehaviour
{
	private Quaternion rotTarget;

	public float rotateEverySecond = 1f;

	public void Start()
	{
		randomRot();
		InvokeRepeating("randomRot", 0f, rotateEverySecond);
	}

	public void Update()
	{
		base.transform.rotation = Quaternion.Lerp(base.transform.rotation, rotTarget, Time.deltaTime);
	}

	public void randomRot()
	{
		rotTarget = UnityEngine.Random.rotation;
	}
}
public class ParticleLineSpawner : MonoBehaviour
{
	public GameObject[] particles;

	public int maxButtons = 10;

	public bool spawnOnAwake = true;

	public string removeTextFromButton;

	public string removeTextFromMaterialButton;

	public float autoChangeDelay;

	private int page;

	private int pages;

	private GameObject currentGO;

	private Color currentColor;

	private bool isPS;

	private bool _active = true;

	private int counter = -1;

	public GUIStyle bigStyle;

	public void Start()
	{
		particles = particles.OrderBy((GameObject go) => go.name).ToArray();
		pages = (int)Mathf.Ceil((particles.Length - 1) / maxButtons);
		if (spawnOnAwake)
		{
			counter = 0;
			ReplaceGO(particles[counter]);
		}
		if (autoChangeDelay > 0f)
		{
			InvokeRepeating("NextModel", autoChangeDelay, autoChangeDelay);
		}
	}

	public void Update()
	{
		if (Input.GetKeyDown(KeyCode.Space))
		{
			if (_active)
			{
				_active = false;
			}
			else
			{
				_active = true;
			}
		}
		if (Input.GetKeyDown(KeyCode.RightArrow))
		{
			NextModel();
		}
		if (Input.GetKeyDown(KeyCode.LeftArrow))
		{
			counter--;
			if (counter < 0)
			{
				counter = particles.Length - 1;
			}
			ReplaceGO(particles[counter]);
		}
	}

	public void NextModel()
	{
		counter++;
		if (counter > particles.Length - 1)
		{
			counter = 0;
		}
		ReplaceGO(particles[counter]);
	}

	public void AddMovement()
	{
		currentGO.AddComponent<PL_RandomMovement>().speed = 3f;
	}

	public void Duplicate()
	{
		UnityEngine.Object.Instantiate(currentGO, currentGO.transform.position, currentGO.transform.rotation);
	}

	public void DestroyAll()
	{
		ParticleSystem[] array = (ParticleSystem[])UnityEngine.Object.FindObjectsOfType(typeof(ParticleSystem));
		for (int i = 0; i < array.Length; i++)
		{
			UnityEngine.Object.Destroy(array[i].gameObject);
		}
	}

	public void OnGUI()
	{
		if (!_active)
		{
			return;
		}
		if (particles.Length > maxButtons)
		{
			if (GUI.Button(new Rect(20f, (maxButtons + 1) * 18, 75f, 18f), "Prev"))
			{
				if (page > 0)
				{
					page--;
				}
				else
				{
					page = pages;
				}
			}
			if (GUI.Button(new Rect(95f, (maxButtons + 1) * 18, 75f, 18f), "Next"))
			{
				if (page < pages)
				{
					page++;
				}
				else
				{
					page = 0;
				}
			}
			GUI.Label(new Rect(60f, (maxButtons + 2) * 18, 150f, 22f), "Page" + (page + 1) + " / " + (pages + 1));
		}
		if (GUI.Button(new Rect(20f, (maxButtons + 3) * 18, 150f, 18f), "Add Movement"))
		{
			AddMovement();
		}
		if (GUI.Button(new Rect(20f, (maxButtons + 4) * 18, 150f, 18f), "Duplicate"))
		{
			Duplicate();
		}
		int num = particles.Length - page * maxButtons;
		if (num > maxButtons)
		{
			num = maxButtons;
		}
		for (int i = 0; i < num; i++)
		{
			string text = particles[i + page * maxButtons].transform.name;
			if (removeTextFromButton != "")
			{
				text = text.Replace(removeTextFromButton, "");
			}
			if (GUI.Button(new Rect(20f, i * 18 + 18, 150f, 18f), text))
			{
				DestroyAll();
				GameObject gameObject = UnityEngine.Object.Instantiate(particles[i + page * maxButtons]);
				currentGO = gameObject;
				counter = i + page * maxButtons;
			}
		}
	}

	public void ReplaceGO(GameObject _go)
	{
		if (currentGO != null)
		{
			UnityEngine.Object.Destroy(currentGO);
		}
		GameObject gameObject = UnityEngine.Object.Instantiate(_go);
		currentGO = gameObject;
	}

	public void PlayPS(ParticleSystem _ps, int _nr)
	{
		Time.timeScale = 1f;
		_ps.Play();
	}
}
public class SBCrossfadeAnimations : MonoBehaviour
{
	private Animation a;

	private ArrayList animations;

	private int current;

	private void Start()
	{
		CreateAnimationList();
		if (animations.Count != 0)
		{
			Invoke("CrossfadeRandom", 1f);
		}
	}

	private void CreateAnimationList()
	{
		animations = new ArrayList();
		a = base.transform.GetComponent<Animation>();
		foreach (AnimationState item in a)
		{
			animations.Add(item.name);
		}
	}

	private void CrossfadeRandom()
	{
		a.CrossFade((string)animations[UnityEngine.Random.Range(0, animations.Count)], 0.5f);
		Invoke("CrossfadeRandom", UnityEngine.Random.Range(2, 3));
	}
}
public class SBDemoRotate : MonoBehaviour
{
	public float speed = 50f;

	private void Update()
	{
		base.transform.Rotate(Vector3.up * speed * Time.deltaTime);
	}
}
public class VertexColorToonLight : MonoBehaviour
{
	public Transform lig;

	public Renderer ren;

	public float distanceMultiplier = 3f;

	private Material mat;

	private void Start()
	{
		mat = ren.material;
	}

	private void Update()
	{
		mat.SetFloat("_LightTweakX", (lig.transform.position.x - base.transform.position.x) * distanceMultiplier);
		mat.SetFloat("_LightTweakY", (lig.transform.position.y - base.transform.position.y) * distanceMultiplier);
		mat.SetFloat("_LightTweakZ", (lig.transform.position.z - base.transform.position.z) * distanceMultiplier);
	}
}
[ExecuteInEditMode]
public class ParticleLines : MonoBehaviour
{
	public SimpleLineRenderer _line;

	public ParticleSystem _ps;

	public bool _sortParticleOnLife;

	public bool _sortParticleOnDistance = true;

	public bool _freezeZeroParticle = true;

	public Color startColor = Color.yellow;

	public Color endColor = Color.white;

	public bool _gradients;

	public Gradient _gradientStart;

	public Gradient _gradientEnd;

	public float _gradientSpeed = 1f;

	public bool _randomGradientStart;

	public bool _gradientLight;

	public Light _light;

	public bool _vertexCountIntensity;

	public float _vertexCountIntensityMultiplier = 0.01f;

	public bool _flicker;

	public AnimationCurve _lightFlicker;

	public string _positionLight;

	public bool _tileLineMaterial;

	public float _tileMultiplier = 1f;

	public bool _fixedTileMaterial;

	public bool _tileAnimate;

	public float _tileAnimateSpeed;

	public bool animateScale;

	public float startScaleMultiplier = 1f;

	public AnimationCurve startScale = AnimationCurve.Linear(0f, 1f, 1f, 1f);

	public float endScaleMultiplier = 1f;

	public AnimationCurve endScale = AnimationCurve.Linear(0f, 1f, 1f, 1f);

	public float _scaleSpeed = 1f;

	public Vector3 _rotationSpeed;

	public int _sortInterval = 2;

	private int _lineVertex;

	private ParticleSystem.Particle[] myParticles;

	private ParticleSystem.Particle[] myParticlesX;

	private ParticleSystem.Particle[] myParticlesY;

	private float _gradientCounter;

	private float _randomNumber;

	private float _saveLightIntensity;

	private int _randomInt;

	public int _cutEndSegments;

	public int _lineResolution = 150;

	public int _currentResolution;

	public int sorted;

	public Material lineMaterial;

	public MeshRenderer cacheMeshRenderer;

	public void Start()
	{
		cacheMeshRenderer = GetComponent<MeshRenderer>();
		if (cacheMeshRenderer.sharedMaterial == null)
		{
			cacheMeshRenderer.sharedMaterial = UnityEngine.Object.Instantiate(lineMaterial);
		}
		if (_line == null)
		{
			_line = base.transform.GetComponent<SimpleLineRenderer>();
		}
		if (_ps == null)
		{
			_ps = base.transform.GetComponent<ParticleSystem>();
		}
		if (_ps == null)
		{
			_ps = base.transform.parent.GetComponent<ParticleSystem>();
		}
		if (_light != null)
		{
			_saveLightIntensity = _light.intensity;
		}
		_randomNumber = UnityEngine.Random.value;
		_randomInt = (int)(_randomNumber * 10f);
		_lightFlicker.postWrapMode = WrapMode.Loop;
		startScale.postWrapMode = WrapMode.Loop;
		endScale.postWrapMode = WrapMode.Loop;
		if (_randomGradientStart)
		{
			_gradientCounter = _randomNumber;
		}
	}

	public int GetFrameCount()
	{
		return Time.frameCount + _randomInt;
	}

	public int Compare(float first, float second)
	{
		return second.CompareTo(first);
	}

	public void SetLine()
	{
		if (myParticlesX == null)
		{
			return;
		}
		for (int i = 0; i < _lineVertex - _cutEndSegments; i++)
		{
			if (i < myParticlesX.Length)
			{
				_line.SetPosition(i, myParticlesX[i].position);
			}
			else
			{
				_line.SetPosition(i, base.transform.position);
			}
		}
	}

	public void SortLifetime()
	{
		CreateLine();
		if (myParticlesX != null)
		{
			Array.Sort(myParticlesX, (ParticleSystem.Particle g1, ParticleSystem.Particle g2) => Compare(g1.remainingLifetime, g2.remainingLifetime));
		}
	}

	public void SortDistance()
	{
		CreateLine();
		if (myParticlesX != null)
		{
			Array.Sort(myParticlesX, (ParticleSystem.Particle g1, ParticleSystem.Particle g2) => Compare(Vector3.Distance(base.transform.position, g2.position), Vector3.Distance(base.transform.position, g1.position)));
		}
	}

	public void CreateLine()
	{
		if (myParticles.Length == 0)
		{
			return;
		}
		myParticlesX = new ParticleSystem.Particle[_lineVertex];
		float num = myParticles.Length / _lineVertex;
		for (int i = 0; i < _lineVertex; i++)
		{
			int num2 = (int)((float)i * num);
			if (num2 < myParticles.Length)
			{
				myParticlesX[i] = myParticles[num2];
			}
		}
	}

	public void LerpLine()
	{
		if (myParticles.Length != 0)
		{
			float num = myParticlesX.Length / _lineVertex;
			for (int i = 0; i < myParticlesX.Length; i++)
			{
				int a = (int)((float)i * num);
				myParticlesX[i].position = Vector3.Lerp(myParticlesX[i].position, myParticlesX[Mathf.Min(a, myParticlesX.Length - 1)].position, 1f);
			}
		}
	}

	public void SetLineResolution()
	{
		if (_ps.particleCount < _lineResolution)
		{
			_lineVertex = myParticles.Length;
		}
		if (_lineVertex > _lineResolution)
		{
			_lineVertex = _lineResolution;
		}
		if (_lineVertex < 1)
		{
			_lineVertex = 1;
		}
		if (_lineVertex != _currentResolution)
		{
			_line.SetVertexCount(Mathf.Max(_lineVertex - _cutEndSegments, 0));
			if (sorted <= 10)
			{
				SortLifetime();
				sorted++;
			}
		}
		_currentResolution = _lineVertex;
	}

	public void LinePos()
	{
		myParticles = new ParticleSystem.Particle[_ps.particleCount];
		_ps.GetParticles(myParticles);
		SetLineResolution();
		if (sorted > 10 && _sortInterval > 1 && _sortParticleOnLife && _lineVertex > 2)
		{
			if (GetFrameCount() % _sortInterval == 0)
			{
				SortLifetime();
			}
		}
		else if (_sortInterval > 1 && _sortParticleOnDistance && _lineVertex > 2)
		{
			if (GetFrameCount() % _sortInterval == 0)
			{
				SortDistance();
			}
		}
		else if (_sortParticleOnLife)
		{
			SortLifetime();
		}
		else if (_sortParticleOnDistance)
		{
			SortDistance();
		}
		else
		{
			CreateLine();
		}
		if (_freezeZeroParticle && _lineVertex > 0 && myParticlesX != null && myParticlesX.Length != 0)
		{
			myParticlesX[0].position = _ps.transform.position;
		}
		SetLine();
	}

	public void Update()
	{
		if (!_ps.IsAlive())
		{
			return;
		}
		LinePos();
		if (_gradients)
		{
			if (_gradientCounter < 1f)
			{
				_gradientCounter += Time.deltaTime * _gradientSpeed;
			}
			else
			{
				_gradientCounter = 0f;
			}
			startColor = _gradientStart.Evaluate(_gradientCounter);
			endColor = _gradientEnd.Evaluate(_gradientCounter);
			if (_light != null && _gradientLight)
			{
				_light.color = _gradientStart.Evaluate(_gradientCounter);
			}
		}
		_line.SetColor(startColor, endColor);
		if (_tileLineMaterial && _fixedTileMaterial)
		{
			cacheMeshRenderer.sharedMaterial.mainTextureScale = new Vector2(_tileMultiplier, cacheMeshRenderer.sharedMaterial.mainTextureScale.y);
		}
		else if (_tileLineMaterial)
		{
			cacheMeshRenderer.sharedMaterial.mainTextureScale = new Vector2((float)_lineVertex * _tileMultiplier, cacheMeshRenderer.sharedMaterial.mainTextureScale.y);
		}
		if (_tileAnimate)
		{
			cacheMeshRenderer.sharedMaterial.mainTextureOffset = new Vector2((cacheMeshRenderer.sharedMaterial.mainTextureOffset.x + _tileAnimateSpeed * Time.deltaTime) % 1f, cacheMeshRenderer.sharedMaterial.mainTextureOffset.y);
		}
		if (!animateScale)
		{
			_line.SetWidth(startScaleMultiplier, endScaleMultiplier);
		}
		else
		{
			float time = _ps.time * _scaleSpeed + _randomNumber;
			_line.SetWidth(startScale.Evaluate(time) * startScaleMultiplier, endScale.Evaluate(time) * endScaleMultiplier);
		}
		if (_vertexCountIntensity)
		{
			_light.intensity = _saveLightIntensity * _vertexCountIntensityMultiplier * (float)_lineVertex;
		}
		if (_light != null)
		{
			if (_positionLight == "end" && _ps.particleCount > 5)
			{
				_light.transform.position = Vector3.Lerp(_light.transform.position, myParticles[_ps.particleCount - 6].position, Time.deltaTime * 10f);
			}
			else if (_positionLight == "random" && _ps.particleCount > 5)
			{
				_light.transform.position = Vector3.Lerp(_light.transform.position, myParticles[UnityEngine.Random.Range(0, _ps.particleCount)].position, Time.deltaTime * 2f);
			}
			if (_flicker)
			{
				_light.intensity = _lightFlicker.Evaluate(Time.time + _randomNumber) * _saveLightIntensity;
			}
		}
		if (_rotationSpeed.magnitude > 0f)
		{
			_ps.transform.Rotate(_rotationSpeed * Time.deltaTime);
		}
	}
}
[RequireComponent(typeof(MeshFilter), typeof(MeshRenderer))]
[ExecuteInEditMode]
public class SimpleLineRenderer : MonoBehaviour
{
	private Mesh mesh;

	private int[] triangles;

	private Vector2[] uvs;

	public List<Vertex> points;

	private int currentVertexPointCount;

	[HideInInspector]
	public Transform cacheTransform;

	public LayerMask layerMask = -1;

	public bool hardEdge;

	private void Awake()
	{
		mesh = new Mesh();
		points = new List<Vertex>();
		GetComponent<MeshFilter>().sharedMesh = mesh;
		cacheTransform = base.transform;
	}

	private void LateUpdate()
	{
		Camera[] allCameras = Camera.allCameras;
		for (int i = 0; i < allCameras.Length; i++)
		{
			if (allCameras[i].isActiveAndEnabled && (int)layerMask == ((int)layerMask | (1 << allCameras[i].gameObject.layer)))
			{
				UpdateLineMesh(allCameras[i]);
			}
		}
	}

	private void EditorInit()
	{
		if (points == null)
		{
			points = new List<Vertex>();
		}
		if (cacheTransform == null)
		{
			cacheTransform = base.transform;
		}
	}

	public void SetPosition(int index, Vector3 position)
	{
		if (index >= 0 && points != null && index < points.Count)
		{
			points[index].position = position;
		}
	}

	public void SetWidth(int index, float width)
	{
		if (index >= 0 && index < points.Count)
		{
			points[index].width = width;
		}
	}

	public void SetWidth(float startWidth, float endWidth)
	{
		for (int i = 0; i < points.Count; i++)
		{
			points[i].width = Mathf.Lerp(startWidth, endWidth, (float)i / (float)(points.Count - 1));
		}
	}

	public void SetColor(Color startColor, Color endColor)
	{
		for (int i = 0; i < points.Count; i++)
		{
			points[i].color = Color.Lerp(startColor, endColor, (float)i / (float)(points.Count - 1));
		}
	}

	public void SetColor(int index, Color color)
	{
		if (index >= 0 && index < points.Count)
		{
			points[index].color = color;
		}
	}

	public void UpdateLineMesh(Camera targetCamera)
	{
		cacheTransform.position = Vector3.zero;
		cacheTransform.rotation = Quaternion.identity;
		Vector3 vector = base.transform.InverseTransformPoint(targetCamera.transform.position);
		Vector3[] vertices = mesh.vertices;
		Vector3[] normals = mesh.normals;
		Color[] colors = mesh.colors;
		Vector3 vector2 = Vector3.zero;
		_ = Vector3.zero;
		for (int i = 0; i < points.Count - 1; i++)
		{
			Vector3 normalized = (vector - points[i].position).normalized;
			Vector3 normalized2 = Vector3.Cross(points[i + 1].position - points[i].position, normalized).normalized;
			Vector3 vector3;
			if (hardEdge)
			{
				vector3 = (vector2 + normalized2).normalized * points[i].width / 2f;
				vector2 = normalized2;
			}
			else
			{
				vector3 = normalized2.normalized * points[i].width / 2f;
			}
			vertices[i * 2] = points[i].position - vector3;
			vertices[i * 2 + 1] = points[i].position + vector3;
			normals[i * 2] = (normals[i * 2 + 1] = normalized);
			colors[i * 2] = (colors[i * 2 + 1] = points[i].color);
			if (i == points.Count - 2)
			{
				vertices[i * 2 + 2] = points[i + 1].position - normalized2 * points[i + 1].width / 2f;
				vertices[i * 2 + 3] = points[i + 1].position + normalized2 * points[i + 1].width / 2f;
				normals[i * 2 + 2] = (normals[i * 2 + 3] = normalized);
				colors[i * 2 + 2] = (colors[i * 2 + 3] = points[i + 1].color);
			}
		}
		mesh.vertices = vertices;
		mesh.normals = normals;
		mesh.colors = colors;
		mesh.uv = uvs;
		mesh.triangles = triangles;
		mesh.RecalculateBounds();
	}

	public void SetVertexCount(int vertexPointCount)
	{
		if (vertexPointCount != currentVertexPointCount)
		{
			currentVertexPointCount = vertexPointCount;
			if (mesh == null)
			{
				mesh = new Mesh();
			}
			mesh.Clear();
			GetComponent<MeshFilter>().sharedMesh = mesh;
			if (points.Count > vertexPointCount)
			{
				points.RemoveRange(vertexPointCount, points.Count - vertexPointCount);
			}
			while (points.Count < vertexPointCount)
			{
				points.Add(new Vertex());
			}
			mesh.vertices = new Vector3[points.Count * 2];
			mesh.normals = new Vector3[points.Count * 2];
			mesh.colors = new Color[points.Count * 2];
			triangles = new int[points.Count * 2 * 3];
			int num = 0;
			int num2 = 0;
			while (num2 < points.Count * 2 - 3)
			{
				triangles[num2 * 3] = num * 2;
				triangles[num2 * 3 + 1] = num * 2 + 1;
				triangles[num2 * 3 + 2] = num * 2 + 2;
				triangles[num2 * 3 + 3] = num * 2 + 1;
				triangles[num2 * 3 + 4] = num * 2 + 3;
				triangles[num2 * 3 + 5] = num * 2 + 2;
				num2 += 2;
				num++;
			}
			uvs = new Vector2[points.Count * 2];
			for (int i = 0; i < points.Count; i++)
			{
				uvs[i * 2] = (uvs[i * 2 + 1] = new Vector2((float)i / (float)(points.Count - 1), 0f));
				uvs[i * 2 + 1].y = 1f;
			}
		}
	}
}
public class Vertex
{
	public Vector3 position = Vector3.zero;

	public Color color = Color.white;

	public float width = 1f;
}
public class MoveObjectTestCode : MonoBehaviour
{
	private PerfectLookAt m_PerfectLookAt;

	private GUIStyle m_Style;

	private Animator m_Anim;

	private bool m_switch = true;

	private void Start()
	{
		m_Style = new GUIStyle();
		m_PerfectLookAt = GetComponent<PerfectLookAt>();
		m_Anim = GetComponent<Animator>();
		m_Style.normal.textColor = new Color(0.5f, 0f, 0.75f, 1f);
		m_Style.fontSize = 20;
	}

	private void OnGUI()
	{
		GUI.Label(new Rect(0f, 0f, 100f, 100f), "Use W, A, S, D, Q and E to the target object. Use O to activate/deactivate Perfect Look At\nHold T or G to blend between idle, walk and run", m_Style);
	}

	private void Update()
	{
		if (m_Anim != null)
		{
			float num = m_Anim.GetFloat("speed");
			if (Input.GetKey(KeyCode.T))
			{
				num += 2f * Time.deltaTime;
				num = Mathf.Clamp(num, 0f, 2f);
				m_Anim.SetFloat("speed", num);
			}
			if (Input.GetKey(KeyCode.G))
			{
				num -= 2f * Time.deltaTime;
				num = Mathf.Clamp(num, 0f, 2f);
				m_Anim.SetFloat("speed", num);
			}
		}
		if (!(m_PerfectLookAt != null))
		{
			return;
		}
		GameObject targetObject = m_PerfectLookAt.m_TargetObject;
		if (!(targetObject != null))
		{
			return;
		}
		if (Input.GetKeyDown(KeyCode.O))
		{
			m_switch = !m_switch;
			if (m_switch)
			{
				m_PerfectLookAt.EnablePerfectLookat(0.4f);
			}
			else
			{
				m_PerfectLookAt.DisablePerfectLookat(0.4f);
			}
		}
		if (Input.GetKey(KeyCode.A))
		{
			targetObject.transform.position = new Vector3(targetObject.transform.position.x + Time.deltaTime, targetObject.transform.position.y, targetObject.transform.position.z);
		}
		if (Input.GetKey(KeyCode.D))
		{
			targetObject.transform.position = new Vector3(targetObject.transform.position.x - Time.deltaTime, targetObject.transform.position.y, targetObject.transform.position.z);
		}
		if (Input.GetKey(KeyCode.W))
		{
			targetObject.transform.position = new Vector3(targetObject.transform.position.x, targetObject.transform.position.y + Time.deltaTime, targetObject.transform.position.z);
		}
		if (Input.GetKey(KeyCode.S))
		{
			targetObject.transform.position = new Vector3(targetObject.transform.position.x, targetObject.transform.position.y - Time.deltaTime, targetObject.transform.position.z);
		}
		if (Input.GetKey(KeyCode.Q))
		{
			targetObject.transform.position = new Vector3(targetObject.transform.position.x, targetObject.transform.position.y, targetObject.transform.position.z - Time.deltaTime);
		}
		if (Input.GetKey(KeyCode.E))
		{
			targetObject.transform.position = new Vector3(targetObject.transform.position.x, targetObject.transform.position.y, targetObject.transform.position.z + Time.deltaTime);
		}
	}
}
public class PerfectLookAt : MonoBehaviour
{
	public GameObject m_TargetObject;

	public Vector3 m_UpVector = Vector3.up;

	private float m_Weight = 1f;

	public float m_LookAtBlendSpeed = 5f;

	private float m_BlendSpeed;

	public bool m_DrawDebugLookAtLines;

	private bool m_IsValid = true;

	public PerfectLookAtData[] m_LookAtBones;

	private Quaternion[] m_BlendedRotations;

	private Quaternion[] m_LastFrameRotations;

	public float GetLookAtWeight()
	{
		return m_Weight;
	}

	public void SetLookAtWeight(float weight)
	{
		m_Weight = Mathf.Clamp(weight, 0f, 1f);
		m_BlendSpeed = 0f;
	}

	public void EnablePerfectLookat(float time, bool cancelCurrentTransition = true)
	{
		if (Mathf.Abs(m_Weight - 1f) > Mathf.Epsilon)
		{
			if (Mathf.Abs(m_BlendSpeed) < Mathf.Epsilon || cancelCurrentTransition)
			{
				m_BlendSpeed = (1f - m_Weight) / time;
			}
		}
		else
		{
			m_BlendSpeed = 0f;
		}
	}

	public void DisablePerfectLookat(float time, bool cancelCurrentTransition = true)
	{
		if (Mathf.Abs(m_Weight) > Mathf.Epsilon)
		{
			if (Mathf.Abs(m_BlendSpeed) < Mathf.Epsilon || cancelCurrentTransition)
			{
				m_BlendSpeed = (0f - m_Weight) / time;
			}
		}
		else
		{
			m_BlendSpeed = 0f;
		}
	}

	public bool IsInTransition()
	{
		if (Mathf.Abs(m_BlendSpeed) > Mathf.Epsilon)
		{
			return true;
		}
		return false;
	}

	public float GetTimeToFinishTransition()
	{
		float result = 0f;
		if (Mathf.Abs(m_BlendSpeed) > 10f * Mathf.Epsilon)
		{
			result = ((!(m_BlendSpeed > 0f)) ? (m_Weight / m_BlendSpeed) : ((1f - m_Weight) / m_BlendSpeed));
		}
		return result;
	}

	private Quaternion GetWorldLookAtRotation(Vector3 targetVector, Vector3 fwdVectorInWorldSpace)
	{
		float num = Vector3.Angle(fwdVectorInWorldSpace, targetVector) * ((float)Math.PI / 180f);
		Vector3 rotationAxis = ((!(Mathf.Abs(num - (float)Math.PI) < Mathf.Epsilon) && !(num <= Mathf.Epsilon)) ? Vector3.Cross(fwdVectorInWorldSpace, targetVector) : Vector3.up);
		return QuaternionFromAngleAxis(ref rotationAxis, num);
	}

	private Quaternion PerfectLookAtSlerp(Quaternion a, Quaternion b, float weight)
	{
		if (Mathf.Abs(weight - 1f) < Mathf.Epsilon)
		{
			return b;
		}
		if (weight < Mathf.Epsilon)
		{
			return a;
		}
		return Quaternion.Slerp(a, b, weight);
	}

	private Quaternion QuaternionFromAngleAxis(ref Vector3 rotationAxis, float angleRad)
	{
		float f = angleRad * 0.5f;
		rotationAxis = rotationAxis.normalized * Mathf.Sin(f);
		float w = Mathf.Cos(f);
		return new Quaternion(rotationAxis.x, rotationAxis.y, rotationAxis.z, w);
	}

	private void CheckForForceDefaultRotation()
	{
		for (int i = 0; i < m_LookAtBones.Length; i++)
		{
			PerfectLookAtData perfectLookAtData = m_LookAtBones[i];
			if (perfectLookAtData.m_ResetToDefaultRotation)
			{
				perfectLookAtData.m_Bone.transform.localRotation = perfectLookAtData.GetDefaultRotation();
			}
			for (int j = 0; j < perfectLookAtData.m_LinkedBones.Length; j++)
			{
				PerfecLookAtLinkedBones perfecLookAtLinkedBones = perfectLookAtData.m_LinkedBones[j];
				if (perfecLookAtLinkedBones.m_ResetToDefaultRotation)
				{
					perfecLookAtLinkedBones.m_Bone.transform.localRotation = perfecLookAtLinkedBones.GetDefaultRotation();
				}
			}
		}
	}

	private bool CheckValidity()
	{
		bool result = true;
		for (int i = 0; i < m_LookAtBones.Length; i++)
		{
			PerfectLookAtData perfectLookAtData = m_LookAtBones[i];
			if (perfectLookAtData.m_Bone == null)
			{
				result = false;
				break;
			}
			for (int j = 0; j < perfectLookAtData.m_LinkedBones.Length; j++)
			{
				if (perfectLookAtData.m_LinkedBones[j].m_Bone == null)
				{
					result = false;
					break;
				}
			}
		}
		return result;
	}

	private float GetAngleFromQuaternionDeg(ref Quaternion inputQuat)
	{
		return Mathf.Acos(inputQuat.w) * 57.29578f * 2f;
	}

	private float GetAngleFromQuaternionDeg(Quaternion inputQuat)
	{
		return Mathf.Acos(inputQuat.w) * 57.29578f * 2f;
	}

	private float GetAngleFromQuaternionRad(Quaternion inputQuat)
	{
		return Mathf.Acos(inputQuat.w) * 2f;
	}

	private float GetAngleFromQuaternionRad(ref Quaternion inputQuat)
	{
		return Mathf.Acos(inputQuat.w) * 2f;
	}

	private Vector3 GetForwardVector(ref Transform inputTr, FwdDirection inputAxis)
	{
		return inputAxis switch
		{
			FwdDirection.X_AXIS => inputTr.right, 
			FwdDirection.Y_AXIS => inputTr.up, 
			FwdDirection.Z_AXIS => inputTr.forward, 
			FwdDirection.MINUS_X_AXIS => -inputTr.right, 
			FwdDirection.MINUS_Y_AXIS => -inputTr.up, 
			FwdDirection.MINUS_Z_AXIS => -inputTr.forward, 
			_ => inputTr.forward, 
		};
	}

	private Vector3 BlendTowardTargetVector(ref Transform inputTr, FwdDirection inputAxis)
	{
		return inputAxis switch
		{
			FwdDirection.X_AXIS => inputTr.right, 
			FwdDirection.Y_AXIS => inputTr.up, 
			FwdDirection.Z_AXIS => inputTr.forward, 
			FwdDirection.MINUS_X_AXIS => -inputTr.right, 
			FwdDirection.MINUS_Y_AXIS => -inputTr.up, 
			FwdDirection.MINUS_Z_AXIS => -inputTr.forward, 
			_ => inputTr.forward, 
		};
	}

	private void Start()
	{
		m_IsValid = CheckValidity();
		m_BlendedRotations = new Quaternion[m_LookAtBones.Length];
		m_LastFrameRotations = new Quaternion[m_LookAtBones.Length];
		for (int i = 0; i < m_LookAtBones.Length; i++)
		{
			PerfectLookAtData perfectLookAtData = m_LookAtBones[i];
			PerfecLookAtLinkedBones[] linkedBones = perfectLookAtData.m_LinkedBones;
			perfectLookAtData.SetDefaultRotation(perfectLookAtData.m_Bone.localRotation);
			m_LastFrameRotations[i] = perfectLookAtData.m_Bone.localRotation;
			perfectLookAtData.CheckJointRotation();
			for (int j = 0; j < linkedBones.Length; j++)
			{
				linkedBones[j].SetDefaultRotation(linkedBones[j].m_Bone.localRotation);
				linkedBones[j].SetLastFrameRotation(linkedBones[j].m_Bone.rotation);
			}
		}
	}

	private void Update()
	{
		if (m_LookAtBones.Length == 0)
		{
			return;
		}
		if (m_DrawDebugLookAtLines)
		{
			Vector3 vector = m_TargetObject.transform.position - m_LookAtBones[0].m_Bone.position;
			UnityEngine.Debug.DrawLine(m_LookAtBones[0].m_Bone.position, m_LookAtBones[0].m_Bone.position + vector);
		}
		if (Mathf.Abs(m_BlendSpeed) > Mathf.Epsilon && m_IsValid)
		{
			m_Weight += m_BlendSpeed * Time.deltaTime;
			if (m_BlendSpeed > 0f)
			{
				if (m_Weight > 1f)
				{
					m_Weight = 1f;
					m_BlendSpeed = 0f;
				}
			}
			else if (m_Weight < 0f)
			{
				m_Weight = 0f;
				m_BlendSpeed = 0f;
			}
		}
		else
		{
			m_BlendSpeed = 0f;
		}
	}

	private void LateUpdate()
	{
		if (m_TargetObject == null || !m_IsValid)
		{
			return;
		}
		if (m_Weight < Mathf.Epsilon)
		{
			for (int i = 0; i < m_LookAtBones.Length; i++)
			{
				PerfectLookAtData perfectLookAtData = m_LookAtBones[i];
				m_LastFrameRotations[i] = perfectLookAtData.m_Bone.localRotation;
				for (int j = 0; j < perfectLookAtData.m_LinkedBones.Length; j++)
				{
					perfectLookAtData.m_LinkedBones[j].SetLastFrameRotation(perfectLookAtData.m_LinkedBones[j].m_Bone.rotation);
				}
			}
		}
		else
		{
			if (m_LookAtBones.Length == 0)
			{
				return;
			}
			CheckForForceDefaultRotation();
			Dictionary<int, Quaternion> dictionary = new Dictionary<int, Quaternion>();
			Vector3 vector = GetForwardVector(ref m_LookAtBones[0].m_Bone, m_LookAtBones[0].m_ForwardAxis);
			Vector3 vector2 = m_TargetObject.transform.position - m_LookAtBones[0].m_Bone.position;
			Vector3 lhs = vector;
			byte b = 1;
			Vector3 a = default(Vector3);
			for (int k = 0; k < m_LookAtBones.Length; k++)
			{
				Transform inputTr = m_LookAtBones[k].m_Bone;
				Transform inputTr2 = inputTr.parent;
				float num = m_LookAtBones[k].m_RotationLimit;
				bool flag = true;
				Vector3 forwardVector = GetForwardVector(ref inputTr, m_LookAtBones[k].m_ForwardAxis);
				Vector3 forwardVector2 = GetForwardVector(ref inputTr2, m_LookAtBones[k].m_ParentBoneForwardAxis);
				if (inputTr2 != null)
				{
					forwardVector = GetForwardVector(ref inputTr, m_LookAtBones[k].m_ForwardAxis);
					forwardVector2 = GetForwardVector(ref inputTr2, m_LookAtBones[k].m_ParentBoneForwardAxis);
					float num2 = Vector3.Angle(forwardVector, forwardVector2);
					if (num2 > num)
					{
						num = num2;
					}
				}
				else
				{
					flag = false;
				}
				Quaternion inputQuat = GetWorldLookAtRotation(vector2, vector);
				if (m_LookAtBones[k].m_RotateAroundUpVectorWeight > 0f)
				{
					a.x = inputQuat.x;
					a.y = inputQuat.y;
					a.z = inputQuat.z;
					Vector3 b2 = Mathf.Sign(Vector3.Cross(lhs, vector2).y) * m_UpVector;
					b2 = Vector3.Lerp(a, b2, m_LookAtBones[k].m_RotateAroundUpVectorWeight);
					inputQuat = QuaternionFromAngleAxis(ref b2, GetAngleFromQuaternionRad(inputQuat));
				}
				Quaternion quaternion = inputQuat * inputTr.rotation;
				if (flag)
				{
					float num3 = Mathf.Abs(Vector3.Angle(forwardVector2, inputQuat * forwardVector)) - num;
					if (!(num3 > 0f))
					{
						Quaternion localRotation = inputTr.localRotation;
						m_LookAtBones[k].m_Bone.rotation = quaternion;
						m_BlendedRotations[k] = PerfectLookAtSlerp(localRotation, m_LookAtBones[k].m_Bone.localRotation, m_Weight);
						if (m_LookAtBones[k].m_LinkedBones.Length != 0)
						{
							dictionary.Add(k, PerfectLookAtSlerp(Quaternion.identity, inputQuat, m_Weight));
						}
						break;
					}
					Vector3 rotationAxis = new Vector3(inputQuat.x, inputQuat.y, inputQuat.z);
					float angleRad = GetAngleFromQuaternionRad(ref inputQuat) + (float)Math.PI / 180f * (0f - num3);
					inputQuat = QuaternionFromAngleAxis(ref rotationAxis, angleRad);
					quaternion = inputQuat * inputTr.rotation;
					Quaternion localRotation2 = inputTr.localRotation;
					m_LookAtBones[k].m_Bone.rotation = quaternion;
					m_BlendedRotations[k] = PerfectLookAtSlerp(localRotation2, m_LookAtBones[k].m_Bone.localRotation, m_Weight);
					if (m_LookAtBones[k].m_LinkedBones.Length != 0)
					{
						dictionary.Add(k, PerfectLookAtSlerp(Quaternion.identity, inputQuat, m_Weight));
					}
					if (k != m_LookAtBones.Length - 1)
					{
						Vector3 vector3 = m_LookAtBones[0].m_Bone.position - m_LookAtBones[k + 1].m_Bone.position;
						Vector3 vector4 = m_TargetObject.transform.position - m_LookAtBones[0].m_Bone.position;
						vector = GetForwardVector(ref m_LookAtBones[0].m_Bone, m_LookAtBones[0].m_ForwardAxis);
						vector = vector4.magnitude * vector.normalized;
						vector = vector3 + vector;
						vector2 = vector3 + vector4;
						b++;
						if (m_DrawDebugLookAtLines)
						{
							UnityEngine.Debug.DrawLine(m_LookAtBones[k + 1].m_Bone.position, m_LookAtBones[k + 1].m_Bone.position + vector, Color.green);
							UnityEngine.Debug.DrawLine(m_LookAtBones[k + 1].m_Bone.position, m_LookAtBones[k + 1].m_Bone.position + vector2, Color.red);
						}
					}
				}
				else
				{
					Quaternion localRotation3 = inputTr.localRotation;
					m_LookAtBones[k].m_Bone.rotation = quaternion;
					m_BlendedRotations[k] = PerfectLookAtSlerp(localRotation3, m_LookAtBones[k].m_Bone.localRotation, m_Weight);
					if (m_LookAtBones[k].m_LinkedBones.Length != 0)
					{
						dictionary.Add(k, PerfectLookAtSlerp(Quaternion.identity, inputQuat, m_Weight));
					}
					if (k < m_LookAtBones.Length - 1)
					{
						UnityEngine.Debug.LogWarning("Warning Bone name doesn't have a parent. The rest of the PerfectLookAt bone chain won't work after this bone!", this);
						break;
					}
				}
			}
			bool flag2 = Mathf.Abs(m_Weight - 1f) > Mathf.Epsilon;
			float num4 = Mathf.Clamp(m_LookAtBlendSpeed * Time.deltaTime, 0f, 1f);
			num4 = (num4 - 1f) * m_Weight + 1f;
			for (int l = 0; l < m_LookAtBones.Length; l++)
			{
				PerfectLookAtData perfectLookAtData2 = m_LookAtBones[l];
				Quaternion b3 = ((!flag2 || l >= b) ? perfectLookAtData2.m_Bone.localRotation : m_BlendedRotations[l]);
				_ = perfectLookAtData2.m_Bone.localRotation;
				perfectLookAtData2.m_Bone.localRotation = PerfectLookAtSlerp(m_LastFrameRotations[l], b3, num4);
				m_LastFrameRotations[l] = perfectLookAtData2.m_Bone.localRotation;
			}
			for (int m = 0; m < m_LookAtBones.Length; m++)
			{
				PerfectLookAtData perfectLookAtData3 = m_LookAtBones[m];
				if (perfectLookAtData3.m_LinkedBones.Length == 0)
				{
					continue;
				}
				if (m < b)
				{
					Quaternion quaternion2 = dictionary[m];
					for (int n = 0; n < perfectLookAtData3.m_LinkedBones.Length; n++)
					{
						Transform bone = perfectLookAtData3.m_LinkedBones[n].m_Bone;
						bone.rotation = PerfectLookAtSlerp(perfectLookAtData3.m_LinkedBones[n].GetLastFrameRotation(), quaternion2 * bone.rotation, num4);
						perfectLookAtData3.m_LinkedBones[n].SetLastFrameRotation(bone.rotation);
					}
				}
				else
				{
					for (int num5 = 0; num5 < perfectLookAtData3.m_LinkedBones.Length; num5++)
					{
						perfectLookAtData3.m_LinkedBones[num5].SetLastFrameRotation(perfectLookAtData3.m_LinkedBones[num5].m_Bone.rotation);
					}
				}
			}
		}
	}
}
public enum FwdDirection
{
	X_AXIS,
	Y_AXIS,
	Z_AXIS,
	MINUS_X_AXIS,
	MINUS_Y_AXIS,
	MINUS_Z_AXIS
}
[Serializable]
public class PerfectLookAtData
{
	private Quaternion m_DefaultRotation;

	public Transform m_Bone;

	public float m_RotationLimit = 90f;

	public float m_RotateAroundUpVectorWeight;

	public FwdDirection m_ForwardAxis;

	public FwdDirection m_ParentBoneForwardAxis;

	public bool m_ResetToDefaultRotation;

	public PerfecLookAtLinkedBones[] m_LinkedBones;

	public void SetDefaultRotation(Quaternion rot)
	{
		m_DefaultRotation = rot;
	}

	public Quaternion GetDefaultRotation()
	{
		return m_DefaultRotation;
	}

	public void CheckJointRotation()
	{
		if (m_RotationLimit < Mathf.Epsilon)
		{
			UnityEngine.Debug.LogWarning("Joint limit is zero or negative. No rotation will take effect");
		}
	}
}
[Serializable]
public class PerfecLookAtLinkedBones
{
	private Quaternion m_DefaultRotation;

	private Quaternion m_LastFrameRotation;

	public Transform m_Bone;

	public bool m_ResetToDefaultRotation;

	public void SetDefaultRotation(Quaternion rot)
	{
		m_DefaultRotation = rot;
	}

	public Quaternion GetDefaultRotation()
	{
		return m_DefaultRotation;
	}

	public void SetLastFrameRotation(Quaternion rotation)
	{
		m_LastFrameRotation = rotation;
	}

	public Quaternion GetLastFrameRotation()
	{
		return m_LastFrameRotation;
	}
}
public class HighlightNearestFace : MonoBehaviour
{
	public float travel = 50f;

	public float speed = 0.2f;

	private pb_Object target;

	private pb_Face nearest;

	private void Start()
	{
		target = pb_ShapeGenerator.PlaneGenerator(travel, travel, 25, 25, Axis.Up, smooth: false);
		target.SetFaceMaterial(target.faces, pb_Constant.DefaultMaterial);
		target.transform.position = new Vector3(travel * 0.5f, 0f, travel * 0.5f);
		target.ToMesh();
		target.Refresh();
		Camera main = Camera.main;
		main.transform.position = new Vector3(25f, 40f, 0f);
		main.transform.localRotation = Quaternion.Euler(new Vector3(65f, 0f, 0f));
	}

	private void Update()
	{
		float num = Time.time * speed;
		Vector3 position = new Vector3(Mathf.PerlinNoise(num, num) * travel, 2f, Mathf.PerlinNoise(num + 1f, num + 1f) * travel);
		base.transform.position = position;
		if (target == null)
		{
			UnityEngine.Debug.LogWarning("Missing the ProBuilder Mesh target!");
			return;
		}
		Vector3 a = target.transform.InverseTransformPoint(base.transform.position);
		if (nearest != null)
		{
			target.SetFaceColor(nearest, Color.white);
		}
		int num2 = target.faces.Length;
		float num3 = float.PositiveInfinity;
		nearest = target.faces[0];
		for (int i = 0; i < num2; i++)
		{
			float num4 = Vector3.Distance(a, FaceCenter(target, target.faces[i]));
			if (num4 < num3)
			{
				num3 = num4;
				nearest = target.faces[i];
			}
		}
		target.SetFaceColor(nearest, Color.blue);
		target.RefreshColors();
	}

	private Vector3 FaceCenter(pb_Object pb, pb_Face face)
	{
		Vector3[] vertices = pb.vertices;
		Vector3 zero = Vector3.zero;
		int[] distinctIndices = face.distinctIndices;
		foreach (int num in distinctIndices)
		{
			zero.x += vertices[num].x;
			zero.y += vertices[num].y;
			zero.z += vertices[num].z;
		}
		float num2 = face.distinctIndices.Length;
		zero.x /= num2;
		zero.y /= num2;
		zero.z /= num2;
		return zero;
	}
}
public class CharacterSelector : MonoBehaviour
{
	public float orbitSpeed = 10f;

	public float upDownAmplitude = 0.1f;

	public float upDownSpeed = 10f;

	public GameObject makeHumanGO;

	public GameObject autodeskGO;

	public GameObject mixamoGO;

	public Button makeHumanButton;

	public Button autodeskButton;

	public Button mixamoButton;

	private GameObject activeGameObject;

	private LookTargetController lookTargetController;

	private Transform sphereAnchorXform;

	private Transform sphereXform;

	private Transform leftCubeXform;

	private Transform rightCubeXform;

	private float timeToChangeLeftRightTarget;

	private Transform leftRightTargetXform;

	private float sphereUpDownTime;

	private bool isSphereOrbiting;

	private bool isSphereUpAndDown;

	private bool isLookingLeftRight;

	private void Awake()
	{
		sphereAnchorXform = base.transform.Find("Sphere anchor");
		if (sphereAnchorXform != null)
		{
			sphereXform = sphereAnchorXform.Find("Sphere");
		}
		leftCubeXform = base.transform.Find("Left cube");
		rightCubeXform = base.transform.Find("Right cube");
		activeGameObject = autodeskGO;
		UpdateCharacters();
	}

	public void OnAutodeskSelected()
	{
		activeGameObject = autodeskGO;
		UpdateCharacters();
	}

	public void OnLookAtPlayerSelected()
	{
		isLookingLeftRight = false;
		lookTargetController.LookAtPlayer();
	}

	public void OnLookAtSphereSelected()
	{
		isLookingLeftRight = false;
		lookTargetController.LookAtPoiDirectly(sphereXform);
	}

	public void OnLookIdlySelected()
	{
		isLookingLeftRight = false;
		lookTargetController.LookAroundIdly();
	}

	public void OnMakeHumanSelected()
	{
		activeGameObject = makeHumanGO;
		UpdateCharacters();
	}

	public void OnMixamoSelected()
	{
		activeGameObject = mixamoGO;
		UpdateCharacters();
	}

	public void OnLeftRightSelected()
	{
		isLookingLeftRight = true;
		timeToChangeLeftRightTarget = 4f;
		leftRightTargetXform = ((leftRightTargetXform == leftCubeXform) ? rightCubeXform : leftCubeXform);
		lookTargetController.LookAtPoiDirectly(leftRightTargetXform);
	}

	public void OnToggleSphereOribiting(bool toggle)
	{
		isSphereOrbiting = !isSphereOrbiting;
	}

	public void OnToggleSphereUpAndDown(bool toggle)
	{
		isSphereUpAndDown = !isSphereUpAndDown;
	}

	private void Update()
	{
		if (isLookingLeftRight)
		{
			timeToChangeLeftRightTarget -= Time.deltaTime;
			if (timeToChangeLeftRightTarget < 0f)
			{
				timeToChangeLeftRightTarget = 4f;
				leftRightTargetXform = ((leftRightTargetXform == leftCubeXform) ? rightCubeXform : leftCubeXform);
				lookTargetController.LookAtPoiDirectly(leftRightTargetXform);
			}
		}
		if (isSphereOrbiting)
		{
			sphereAnchorXform.Rotate(Vector3.up, Time.deltaTime * orbitSpeed);
		}
		if (isSphereUpAndDown)
		{
			sphereUpDownTime += Time.deltaTime;
			sphereAnchorXform.localPosition = upDownAmplitude * Mathf.Sin(sphereUpDownTime * upDownSpeed) * Vector3.up;
		}
	}

	private void UpdateCharacters()
	{
		mixamoGO.SetActive(activeGameObject == mixamoGO);
		autodeskGO.SetActive(activeGameObject == autodeskGO);
		makeHumanGO.SetActive(activeGameObject == makeHumanGO);
		makeHumanButton.interactable = activeGameObject != makeHumanGO;
		autodeskButton.interactable = activeGameObject != autodeskGO;
		mixamoButton.interactable = activeGameObject != mixamoGO;
		lookTargetController = activeGameObject.GetComponent<LookTargetController>();
	}
}
public class ActivateSong : MonoBehaviour
{
	[HideInInspector]
	public int pos;

	public Text songName;

	public Text duration;

	public Image activeSongImage;

	private MusicPlayer musicPlayer;

	private void Awake()
	{
		musicPlayer = GetComponentInParent<MusicPlayer>();
	}

	public void ChangeToThisSong()
	{
		musicPlayer.ChangeSong(pos);
	}

	public void ShowSongData(string _artist, string _songName, int _pos, int minutes, int seconds)
	{
		pos = _pos;
		duration.text = "Duration \n" + minutes + ":" + seconds.ToString("D2");
		songName.text = _artist + " - " + _songName;
		activeSongImage.enabled = true;
	}
}
public class MusicPlayer : MonoBehaviour
{
	[HideInInspector]
	public bool PrimaryMusicPlayer;

	public SongData actualSong;

	[Header("Assignation")]
	public AudioSource audioSource;

	public Sprite playSprite;

	public Sprite pauseSprite;

	public InputField searchSong;

	[Header("Music Player UI")]
	public Image playPauseButton;

	public Text songName;

	public Image playerBar;

	public Slider sliderBar;

	public Text actualTime;

	public Text totalTime;

	[Header("Songs List")]
	public GameObject songList;

	public List<SongData> songs;

	public List<GameObject> songSearchList;

	[Header("Song Selection")]
	public GameObject songPrefab;

	public GameObject songSelectionPanel;

	public Transform songsSelectionTransform;

	private int actualPos;

	private float amount;

	private bool playing;

	private bool active;

	public bool animateSearch = true;

	public Animator contentAnim;

	public static MusicPlayer instance;

	private void Awake()
	{
		if (instance == null)
		{
			PrimaryMusicPlayer = true;
			instance = this;
			SongData[] componentsInChildren = songList.GetComponentsInChildren<SongData>();
			foreach (SongData item in componentsInChildren)
			{
				songs.Add(item);
			}
			active = false;
			playing = false;
			CreateSongSelectionList();
			actualPos = UnityEngine.Random.Range(0, songSearchList.Count - 1);
			ChangeSong(actualPos);
		}
		else
		{
			PrimaryMusicPlayer = false;
		}
	}

	private void CreateSongSelectionList()
	{
		int num = 0;
		foreach (SongData song in songs)
		{
			GameObject gameObject = UnityEngine.Object.Instantiate(songPrefab, base.transform);
			gameObject.name = $"{song.artist} - {song.title}";
			float length = song.songClip.length;
			int seconds = (int)(length % 60f);
			int minutes = (int)(length / 60f % 60f);
			gameObject.GetComponent<ActivateSong>().ShowSongData(song.artist, song.title, num, minutes, seconds);
			gameObject.transform.SetParent(songsSelectionTransform);
			RectTransform component = gameObject.GetComponent<RectTransform>();
			component.localPosition = Vector3.zero;
			component.localScale = Vector3.one;
			songSearchList.Insert(songSearchList.Count, gameObject);
			num++;
		}
	}

	public void SearchSongByName()
	{
		string text = searchSong.text;
		foreach (GameObject songSearch in songSearchList)
		{
			if (Regex.IsMatch(songSearch.name, text, RegexOptions.IgnoreCase))
			{
				songSearch.SetActive(value: true);
			}
			else
			{
				songSearch.SetActive(value: false);
			}
		}
	}

	public void OrderList()
	{
		IComparer comparer = new OrderSongs();
		GameObject[] array = new GameObject[songSearchList.Count];
		for (int i = 0; i < songSearchList.Count; i++)
		{
			array[i] = songSearchList[i];
		}
		Array.Sort(array, comparer);
		GameObject[] array2 = array;
		for (int j = 0; j < array2.Length; j++)
		{
			array2[j].transform.SetAsLastSibling();
		}
		songSearchList.Clear();
		for (int k = 0; k < array.Length; k++)
		{
			songSearchList.Insert(songSearchList.Count, array[k]);
		}
		for (int l = 0; l < songs.Count; l++)
		{
			if (songs[l] == actualSong)
			{
				actualPos = l;
				break;
			}
		}
	}

	public void ActivateOrDeactivate()
	{
		if (base.gameObject.activeSelf)
		{
			if (!songSelectionPanel.activeSelf)
			{
				StopCoroutine("HideAnimate");
				contentAnim.SetBool("Show", value: true);
				songSelectionPanel.SetActive(value: true);
			}
			else if (animateSearch)
			{
				StartCoroutine(HideAnimation());
			}
			else
			{
				songSelectionPanel.SetActive(value: false);
			}
		}
	}

	private IEnumerator HideAnimation()
	{
		if (contentAnim != null)
		{
			contentAnim.SetBool("Show", value: false);
			yield return new WaitForSeconds(contentAnim.GetCurrentAnimatorStateInfo(0).length);
			songSelectionPanel.SetActive(value: false);
		}
		else
		{
			songSelectionPanel.SetActive(value: false);
		}
	}

	private void SetActiveSongImage()
	{
		foreach (GameObject songSearch in songSearchList)
		{
			songSearch.GetComponent<ActivateSong>().activeSongImage.enabled = false;
		}
		songSearchList[actualPos].GetComponent<ActivateSong>().activeSongImage.enabled = true;
	}

	public void ChangeSong(int pos)
	{
		if (!PrimaryMusicPlayer)
		{
			instance.ChangeSong(pos);
			return;
		}
		StopSong();
		actualPos = pos;
		actualSong = songs[actualPos];
		songName.text = $"{songs[pos].artist} - {songs[pos].title}";
		PrepareToLoadSong(pos);
		SetActiveSongImage();
	}

	private void Update()
	{
		if (!PrimaryMusicPlayer)
		{
			playPauseButton.sprite = instance.playPauseButton.sprite;
			songName.text = instance.songName.text;
			actualTime.text = instance.actualTime.text;
			totalTime.text = instance.totalTime.text;
			playerBar.fillAmount = instance.playerBar.fillAmount;
			actualSong = instance.actualSong;
			active = instance.active;
			playing = instance.playing;
			amount = instance.amount;
			actualPos = instance.actualPos;
			songSearchList = instance.songSearchList;
			songs = instance.songs;
			return;
		}
		if (Input.GetKeyDown(KeyCode.Space))
		{
			PlayOrPauseSong();
		}
		else if (Input.GetKeyDown(KeyCode.Backspace))
		{
			StopSong();
		}
		if (active && playing)
		{
			if (audioSource.isPlaying)
			{
				amount = audioSource.time / audioSource.clip.length;
				playerBar.fillAmount = amount;
				CalculateActualTime();
			}
			else
			{
				active = false;
				playing = false;
				NextSong();
			}
		}
	}

	private void CalculateActualTime()
	{
		float time = audioSource.time;
		int num = (int)(time % 60f);
		int num2 = (int)(time / 60f % 60f);
		actualTime.text = num2 + ":" + num.ToString("D2");
	}

	public void ChangePosition()
	{
		if (audioSource.clip != null)
		{
			active = false;
			audioSource.time = sliderBar.value * audioSource.clip.length;
			playerBar.fillAmount = sliderBar.value;
			active = true;
			CalculateActualTime();
		}
	}

	public void StopSong()
	{
		if (!PrimaryMusicPlayer)
		{
			instance.StopSong();
			return;
		}
		StopAllCoroutines();
		active = false;
		playing = false;
		actualTime.text = "0:00";
		audioSource.Stop();
		audioSource.time = 0f;
		playPauseButton.sprite = playSprite;
		amount = 0f;
		sliderBar.value = 0f;
		playerBar.fillAmount = 0f;
	}

	public void PlayOrPauseSong()
	{
		if (!PrimaryMusicPlayer)
		{
			instance.PlayOrPauseSong();
		}
		else if (playing)
		{
			active = false;
			playing = false;
			audioSource.Pause();
			playPauseButton.sprite = playSprite;
		}
		else
		{
			audioSource.Play();
			playPauseButton.sprite = pauseSprite;
			playing = true;
			active = true;
		}
	}

	public void NextSong()
	{
		if (!PrimaryMusicPlayer)
		{
			instance.NextSong();
			return;
		}
		actualPos++;
		if (actualPos > songSearchList.Count - 1)
		{
			actualPos = 0;
		}
		ChangeSong(actualPos);
		SetActiveSongImage();
	}

	public void PreviousSong()
	{
		if (!PrimaryMusicPlayer)
		{
			instance.PreviousSong();
			return;
		}
		actualPos--;
		if (actualPos < 0)
		{
			actualPos = songSearchList.Count - 1;
		}
		ChangeSong(actualPos);
		SetActiveSongImage();
	}

	private void PrepareToLoadSong(int pos)
	{
		StopCoroutine("LoadSong");
		StartCoroutine(LoadSong(songs[pos]));
	}

	private IEnumerator LoadSong(SongData song)
	{
		AudioClip a = song.songClip;
		a.name = song.artist + " - " + song.title;
		while (!a.isReadyToPlay)
		{
			yield return null;
		}
		audioSource.clip = a;
		float length = audioSource.clip.length;
		int num = (int)(length % 60f);
		int num2 = (int)(length / 60f % 60f);
		totalTime.text = num2 + ":" + num.ToString("D2");
		PlayOrPauseSong();
	}
}
public class OrderSongs : IComparer
{
	int IComparer.Compare(object x, object y)
	{
		return new CaseInsensitiveComparer().Compare(((GameObject)x).name, ((GameObject)y).name);
	}
}
public class SongData : MonoBehaviour
{
	public string title;

	public string artist;

	public AudioClip songClip;

	private void OnEnable()
	{
		base.name = $"{artist} - {title}";
	}
}
public class RhythmVisualizatorPro : MonoBehaviour
{
	public enum ScaleFrom
	{
		Center,
		Downside
	}

	public enum Visualizations
	{
		Line,
		Circle,
		ExpansibleCircle,
		Sphere
	}

	public enum Channels
	{
		n512,
		n1024,
		n2048,
		n4096,
		n8192
	}

	public GameObject soundBarPrefabCenter;

	public GameObject soundBarPrefabDownside;

	public Transform soundBarsTransform;

	[Header("Audio Settings")]
	[Tooltip("Do you want to listen all incoming audios from other AudioSources?")]
	public bool listenAllSounds;

	public AudioSource audioSource;

	[Space(5f)]
	[Header("Sound Bars Options [Requires Restart]")]
	public List<GameObject> soundBars;

	[Range(32f, 256f)]
	public int barsQuantity = 100;

	private int usedSoundBars = 100;

	public ScaleFrom scaleFrom = ScaleFrom.Downside;

	[Range(0.1f, 10f)]
	public float soundBarsWidth = 2f;

	[Header("Camera Control")]
	[Tooltip("Deactivate to use your own camera")]
	public Transform center;

	public bool cameraControl = true;

	[Tooltip("Rotating around camera")]
	public bool rotateCamera = true;

	public bool UseDefaultCameraOnChange = true;

	[Range(-35f, 35f)]
	[Tooltip("Camera rotating velocity, positive = right, negative = left")]
	public float velocity = 15f;

	[Range(0f, 200f)]
	public float height = 40f;

	[Range(0f, 500f)]
	public float orbitDistance = 300f;

	[Range(1f, 179f)]
	public int fieldOfView = 60;

	[Header("Visualization Control")]
	public bool ScaleByRhythm;

	[Range(10f, 200f)]
	[Tooltip("Visualization Length")]
	public float length = 65f;

	[Tooltip("Visualization Form")]
	public Visualizations visualization;

	[Range(1f, 50f)]
	public float extraScaleVelocity = 50f;

	[Header("Levels Control")]
	[Range(0.75f, 15f)]
	[Tooltip("Sound Bars global scale")]
	public float globalScale = 3f;

	[Range(1f, 15f)]
	[Tooltip("Sound Bars smooth velocity to return to 0")]
	public int smoothVelocity = 3;

	[Range(0f, 5f)]
	public float minHeight = 1.5f;

	[Tooltip("Large value of channels represents more spectrum values, you will need increase the SoundBars amount to represent all these values. Recommended: 4096, 2048")]
	public Channels channels = Channels.n2048;

	[Tooltip("FFTWindow to use, it is a type of filter. Rectangular = Very Low filter, BlackmanHarris = Very High filter. Recommended = Blackman")]
	public FFTWindow method = FFTWindow.Blackman;

	private int channelValue = 2048;

	[Header("Auto Rhythm Particles [Experimental]")]
	public ParticleSystem rhythmParticleSystem;

	public bool autoRhythmParticles = true;

	[Tooltip("Rhythm Sensibility, highter values is equal to more particles. Recommended: 5")]
	[Range(0f, 100f)]
	public float rhythmSensibility = 5f;

	private const float minRhythmSensibility = 1.5f;

	[Tooltip("Amount of Particles to Emit")]
	[Range(1f, 150f)]
	public int amountToEmit = 100;

	[Tooltip("Rhythm Particles Interval Time (Recommended: 0.05 Seconds).")]
	[Range(0.01f, 1f)]
	public float rhythmParticlesMaxInterval = 0.05f;

	private float remainingRhythmParticlesTime;

	private bool rhythmSurpassed;

	[Header("Bass Control")]
	[Range(1f, 300f)]
	public float bassSensibility = 40f;

	[Range(0.5f, 2f)]
	public float bassHeight = 1.5f;

	[Range(1f, 5f)]
	public int bassHorizontalScale = 1;

	[Range(0f, 256f)]
	[Tooltip("Bass Horizontal Off-set")]
	public int bassOffset;

	[Header("Treble Control")]
	[Range(1f, 300f)]
	public float trebleSensibility = 80f;

	[Range(0.5f, 2f)]
	public float trebleHeight = 1.35f;

	[Range(1f, 5f)]
	public int trebleHorizontalScale = 3;

	[Range(0f, 256f)]
	[Tooltip("Treble Horizontal Off-set, don't decrease or you will get bass values")]
	public int trebleOffset = 67;

	[Header("Appearance Control")]
	public bool soundBarsParticles = true;

	[Tooltip("Particles Interval Time (Recommended: 0.005 Seconds). 0 = No interval")]
	[Range(0f, 0.1f)]
	public float particlesMaxInterval = 0.005f;

	private float remainingParticlesTime;

	private bool surpassed;

	[Range(0.1f, 2f)]
	public float minParticleSensibility = 1.5f;

	public bool lerpColor = true;

	public Color[] colors = new Color[4];

	[Range(0.1f, 5f)]
	public float colorIntervalTime = 3f;

	[Range(0.1f, 5f)]
	public float colorLerpTime = 2f;

	public bool useGradient;

	public Gradient gradient;

	public Color rhythmParticleSystemColor = Color.white;

	[Header("Rays [Requires Restart]")]
	[Range(0f, 2f)]
	public float raysLenght = 0.5f;

	[Range(0f, 1f)]
	public float raysAlpha = 0.3f;

	private int posColor;

	[HideInInspector]
	public Color actualColor;

	private Vector3 prevLeftScale;

	private Vector3 prevRightScale;

	private Vector3 rightScale;

	private Vector3 leftScale;

	private float timeChange;

	private int halfBarsValue;

	private int visualizationNumber = 1;

	private float newLeftScale;

	private float newRightScale;

	private float rhythmAverage;

	private Visualizations lastVisualizationForm;

	private int lastVisualization = 1;

	private Color currentColor;

	private bool colorUpdated;

	public void EmitIfThereAreRhythm()
	{
		float[] spectrumData = audioSource.GetSpectrumData(channelValue, 0, method);
		float[] spectrumData2 = audioSource.GetSpectrumData(channelValue, 1, method);
		int num = 0;
		float num2 = 0f;
		for (int i = 0; i < 40; i++)
		{
			num2 += Mathf.Max(spectrumData[i], spectrumData2[i]);
			num++;
		}
		rhythmAverage = num2 / (float)num * rhythmSensibility;
		if (rhythmAverage >= 1.5f)
		{
			rhythmSurpassed = true;
		}
		if (autoRhythmParticles && rhythmSurpassed)
		{
			rhythmParticleSystem.Emit(amountToEmit);
		}
	}

	public void Restart()
	{
		colorUpdated = false;
		for (int i = 0; i < soundBars.Count; i++)
		{
			UnityEngine.Object.DestroyImmediate(soundBars[i]);
		}
		soundBars.Clear();
		if (visualization == Visualizations.Line)
		{
			visualizationNumber = 1;
		}
		else if (visualization == Visualizations.Circle)
		{
			visualizationNumber = 2;
		}
		else if (visualization == Visualizations.ExpansibleCircle)
		{
			visualizationNumber = 3;
		}
		else if (visualization == Visualizations.Sphere)
		{
			visualizationNumber = 4;
		}
		lastVisualization = visualizationNumber;
		if (soundBarPrefabCenter != null && soundBarPrefabDownside != null)
		{
			usedSoundBars = barsQuantity;
			halfBarsValue = usedSoundBars / 2;
			CreateCubes();
		}
		else
		{
			UnityEngine.Debug.LogWarning("Please assign Sound Bar Prefabs to the script");
			base.enabled = false;
		}
	}

	private void Awake()
	{
		Restart();
	}

	private void CreateCubes()
	{
		float y = raysLenght * 5f;
		float num = soundBarsWidth - 1f;
		GameObject original;
		if (scaleFrom == ScaleFrom.Center)
		{
			original = soundBarPrefabCenter;
			num = num / 2f - 0.5f;
		}
		else
		{
			original = soundBarPrefabDownside;
		}
		for (int i = 0; i < usedSoundBars; i++)
		{
			GameObject gameObject = UnityEngine.Object.Instantiate(original, base.transform.position, Quaternion.identity);
			gameObject.transform.SetParent(soundBarsTransform.transform);
			gameObject.GetComponent<SoundBar>().cube.transform.localScale = new Vector3(soundBarsWidth, 1f, 1f);
			gameObject.name = $"SoundBar {i + 1}";
			Renderer[] componentsInChildren = gameObject.GetComponentsInChildren<Renderer>();
			Color color = colors[0];
			Color value = color;
			value.a = raysAlpha;
			if (useGradient)
			{
				color = gradient.Evaluate((float)(i + 1) / (float)usedSoundBars);
				ParticleSystem.MainModule main = rhythmParticleSystem.main;
				main.startColor = rhythmParticleSystemColor;
			}
			Renderer[] array = componentsInChildren;
			for (int j = 0; j < array.Length; j++)
			{
				array[j].material.color = color;
			}
			ParticleSystem.MainModule main2 = gameObject.GetComponentInChildren<ParticleSystem>().main;
			main2.startColor = color;
			gameObject.GetComponent<SoundBar>().ray.material.SetColor("_TintColor", value);
			if (scaleFrom == ScaleFrom.Downside)
			{
				gameObject.GetComponent<SoundBar>().ray.transform.localScale = new Vector3(Mathf.Clamp(num, 1f, float.PositiveInfinity), 1f, raysLenght);
				gameObject.GetComponent<SoundBar>().ray.transform.localPosition = new Vector3(0f, y, 0f);
			}
			else
			{
				gameObject.GetComponent<SoundBar>().ray.transform.localScale = new Vector3(Mathf.Clamp(num, 0.5f, float.PositiveInfinity), 1f, raysLenght);
			}
			soundBars.Add(gameObject);
		}
		UpdateVisualizations();
	}

	public void NextForm(bool next)
	{
		if (next)
		{
			visualizationNumber++;
		}
		else
		{
			visualizationNumber--;
		}
		if (visualizationNumber > 4)
		{
			visualizationNumber = 1;
		}
		else if (visualizationNumber <= 0)
		{
			visualizationNumber = 4;
		}
		if (visualizationNumber == 1)
		{
			visualization = Visualizations.Line;
		}
		else if (visualizationNumber == 2)
		{
			visualization = Visualizations.Circle;
		}
		else if (visualizationNumber == 3)
		{
			visualization = Visualizations.ExpansibleCircle;
		}
		else if (visualizationNumber == 4)
		{
			visualization = Visualizations.Sphere;
		}
		UpdateVisualizations();
	}

	private void UpdateChannels()
	{
		if (channels == Channels.n512)
		{
			channelValue = 512;
		}
		else if (channels == Channels.n1024)
		{
			channelValue = 1024;
		}
		else if (channels == Channels.n2048)
		{
			channelValue = 2048;
		}
		else if (channels == Channels.n4096)
		{
			channelValue = 4096;
		}
		else if (channels == Channels.n8192)
		{
			channelValue = 8192;
		}
	}

	private void CameraPosition()
	{
		if (visualization == Visualizations.Line)
		{
			Camera.main.fieldOfView = fieldOfView;
			Vector3 position = base.transform.position;
			position.z -= 170f;
			Camera.main.transform.position = position;
			position.y += 5f + height;
			Camera.main.transform.position = position;
			Camera.main.transform.LookAt(center);
		}
		else if (visualization == Visualizations.Circle)
		{
			Camera.main.fieldOfView = fieldOfView;
			Vector3 position2 = base.transform.position;
			position2.y += (1f + height) / 20f;
			position2.z += 5f;
			Camera.main.transform.position = position2;
			Camera.main.transform.LookAt(soundBarsTransform.position);
		}
		else if (visualization == Visualizations.ExpansibleCircle)
		{
			Camera.main.fieldOfView = fieldOfView;
			Vector3 position3 = base.transform.position;
			position3.y += 55f;
			Camera.main.transform.position = position3;
			Camera.main.transform.LookAt(soundBarsTransform.position);
		}
		else if (visualization == Visualizations.Sphere)
		{
			Camera.main.fieldOfView = fieldOfView;
			Vector3 position4 = base.transform.position;
			position4.z -= 40f;
			position4.y += 5f + height;
			Camera.main.transform.position = position4;
			Camera.main.transform.LookAt(soundBarsTransform.position);
			Camera.main.transform.position = position4;
		}
	}

	private void SetVisualizationPredefinedValues()
	{
		if (visualizationNumber == 1)
		{
			height = 40f;
			orbitDistance = 300f;
		}
		else if (visualizationNumber == 2)
		{
			height = 40f;
			orbitDistance = 125f;
		}
		else if (visualizationNumber == 3)
		{
			height = 40f;
			orbitDistance = 175f;
		}
		else if (visualizationNumber == 4)
		{
			height = 15f;
			orbitDistance = 220f;
		}
	}

	private void CameraMovement()
	{
		Camera.main.transform.position = center.position + (Camera.main.transform.position - center.position).normalized * orbitDistance;
		if (rotateCamera)
		{
			Camera.main.transform.RotateAround(center.position, Vector3.up, (0f - velocity) * Time.deltaTime);
		}
	}

	private void ChangeColor()
	{
		currentColor = soundBars[0].GetComponent<SoundBar>().cube.material.color;
		actualColor = Color.Lerp(currentColor, colors[posColor], Time.deltaTime / colorLerpTime);
		foreach (GameObject soundBar in soundBars)
		{
			Color value = actualColor;
			value.a = raysAlpha;
			soundBar.GetComponent<SoundBar>().ray.material.SetColor("_TintColor", value);
			soundBar.GetComponent<SoundBar>().cube.material.color = actualColor;
			ParticleSystem.MainModule main = soundBar.GetComponent<SoundBar>().particleSystem.main;
			main.startColor = actualColor;
			ParticleSystem.MainModule main2 = rhythmParticleSystem.main;
			main2.startColor = actualColor;
		}
	}

	private void NextColor()
	{
		timeChange = colorIntervalTime;
		lerpColor = false;
		if (posColor < colors.Length - 1)
		{
			posColor++;
		}
		else
		{
			posColor = 0;
		}
		lerpColor = true;
	}

	public void UpdateVisualizations()
	{
		if (visualization == Visualizations.Circle)
		{
			for (int i = 0; i < usedSoundBars; i++)
			{
				float f = (float)i * (float)Math.PI * 2f / (float)usedSoundBars;
				Vector3 localPosition = soundBarsTransform.transform.localPosition;
				localPosition -= new Vector3(Mathf.Cos(f), 0f, Mathf.Sin(f)) * length;
				soundBars[i].transform.localPosition = localPosition;
				soundBars[i].transform.LookAt(soundBarsTransform.position);
				Vector3 eulerAngles = soundBars[i].transform.eulerAngles;
				eulerAngles.x = 0f;
				soundBars[i].transform.localEulerAngles = eulerAngles;
			}
		}
		else if (visualization == Visualizations.Line)
		{
			for (int j = 0; j < usedSoundBars; j++)
			{
				Vector3 localPosition2 = soundBarsTransform.transform.localPosition;
				localPosition2.x -= length * 5f;
				localPosition2.x += length / (float)usedSoundBars * (float)(j * 10);
				soundBars[j].transform.localPosition = localPosition2;
				soundBars[j].transform.localEulerAngles = Vector3.zero;
			}
		}
		else if (visualization == Visualizations.ExpansibleCircle)
		{
			for (int k = 0; k < usedSoundBars; k++)
			{
				float f2 = (float)k * (float)Math.PI * 2f / (float)usedSoundBars;
				Vector3 localPosition3 = soundBarsTransform.transform.localPosition;
				localPosition3 -= new Vector3(Mathf.Cos(f2), 0f, Mathf.Sin(f2)) * length;
				soundBars[k].transform.localPosition = localPosition3;
				soundBars[k].transform.LookAt(soundBarsTransform.position);
				Vector3 eulerAngles2 = soundBars[k].transform.eulerAngles;
				eulerAngles2.x -= 90f;
				soundBars[k].transform.eulerAngles = eulerAngles2;
			}
		}
		else if (visualization == Visualizations.Sphere)
		{
			Vector3[] array = UniformPointsOnSphere(usedSoundBars, length);
			for (int l = 0; l < usedSoundBars; l++)
			{
				soundBars[l].transform.localPosition = array[l];
				soundBars[l].transform.LookAt(soundBarsTransform.position);
				Vector3 eulerAngles3 = soundBars[l].transform.eulerAngles;
				eulerAngles3.x -= 90f;
				soundBars[l].transform.eulerAngles = eulerAngles3;
			}
		}
		UpdateChannels();
		if (!cameraControl)
		{
			return;
		}
		if (lastVisualizationForm != visualization)
		{
			lastVisualization = visualizationNumber;
			if (visualization == Visualizations.Line)
			{
				visualizationNumber = 1;
			}
			else if (visualization == Visualizations.Circle)
			{
				visualizationNumber = 2;
			}
			else if (visualization == Visualizations.ExpansibleCircle)
			{
				visualizationNumber = 3;
			}
			else if (visualization == Visualizations.Sphere)
			{
				visualizationNumber = 4;
			}
			if (UseDefaultCameraOnChange)
			{
				SetVisualizationPredefinedValues();
			}
		}
		CameraPosition();
	}

	private Vector3[] UniformPointsOnSphere(float verticlesNum, float scale)
	{
		List<Vector3> list = new List<Vector3>();
		float num = (float)Math.PI * (3f - Mathf.Sqrt(5f));
		float num2 = 2f / verticlesNum;
		for (int i = 0; (float)i < verticlesNum; i++)
		{
			float num3 = (float)i * num2 - 1f + num2 / 2f;
			float num4 = Mathf.Sqrt(1f - num3 * num3);
			float f = (float)i * num;
			list.Add(new Vector3(Mathf.Cos(f) * num4, num3, Mathf.Sin(f) * num4) * scale);
		}
		return list.ToArray();
	}

	private void LateUpdate()
	{
		if (lerpColor)
		{
			timeChange -= Time.deltaTime;
			if (timeChange < 0f)
			{
				NextColor();
			}
			ChangeColor();
			colorUpdated = false;
		}
		else if (useGradient)
		{
			if (!colorUpdated)
			{
				for (int i = 0; i < soundBars.Count; i++)
				{
					Color color = gradient.Evaluate((float)(i + 1) / (float)usedSoundBars);
					soundBars[i].GetComponent<SoundBar>().cube.material.color = color;
					ParticleSystem.MainModule main = soundBars[i].GetComponentInChildren<ParticleSystem>().main;
					main.startColor = color;
					color.a = raysAlpha;
					soundBars[i].GetComponent<SoundBar>().ray.material.SetColor("_TintColor", color);
				}
				ParticleSystem.MainModule main2 = rhythmParticleSystem.main;
				main2.startColor = rhythmParticleSystemColor;
				colorUpdated = true;
			}
		}
		else
		{
			colorUpdated = false;
		}
		float[] spectrumData;
		float[] spectrumData2;
		if (listenAllSounds)
		{
			spectrumData = AudioListener.GetSpectrumData(channelValue, 0, method);
			spectrumData2 = AudioListener.GetSpectrumData(channelValue, 1, method);
		}
		else if (audioSource == null)
		{
			UnityEngine.Debug.LogWarning("No AudioSource detected 'Listen All Sounds' activated");
			listenAllSounds = true;
			spectrumData = AudioListener.GetSpectrumData(channelValue, 0, method);
			spectrumData2 = AudioListener.GetSpectrumData(channelValue, 1, method);
		}
		else
		{
			if (audioSource.clip == null)
			{
				UnityEngine.Debug.LogWarning("Assign an AudioClip to the AudioSource and Play it!");
			}
			spectrumData = audioSource.GetSpectrumData(channelValue, 0, method);
			spectrumData2 = audioSource.GetSpectrumData(channelValue, 1, method);
		}
		if (remainingRhythmParticlesTime <= 0f)
		{
			int num = 0;
			float num2 = 0f;
			for (int j = 0; j < 40; j++)
			{
				num2 += Mathf.Max(spectrumData[j], spectrumData2[j]);
				num++;
			}
			rhythmAverage = num2 / (float)num * rhythmSensibility;
			if (rhythmAverage >= 1.5f)
			{
				rhythmSurpassed = true;
			}
			if (autoRhythmParticles && rhythmSurpassed)
			{
				rhythmParticleSystem.Emit(amountToEmit);
			}
		}
		if (!ScaleByRhythm)
		{
			for (int k = 0; k < halfBarsValue; k++)
			{
				int num3 = k * bassHorizontalScale + bassOffset;
				int num4 = k * trebleHorizontalScale + trebleOffset;
				prevLeftScale = soundBars[k].transform.localScale;
				prevRightScale = soundBars[k + halfBarsValue].transform.localScale;
				float num5 = spectrumData[num3] * bassSensibility;
				float num6 = spectrumData2[num4] * trebleSensibility;
				newLeftScale = Mathf.Lerp(prevLeftScale.y, num5 * bassHeight * globalScale, Time.deltaTime * extraScaleVelocity);
				EmitParticle(k, num5);
				if (newLeftScale >= prevLeftScale.y)
				{
					prevLeftScale.y = newLeftScale;
					leftScale = prevLeftScale;
				}
				else
				{
					leftScale = prevLeftScale;
					leftScale.y = Mathf.Lerp(prevLeftScale.y, minHeight, Time.deltaTime * (float)smoothVelocity);
				}
				soundBars[k].transform.localScale = leftScale;
				newRightScale = Mathf.Lerp(prevRightScale.y, num6 * trebleHeight * globalScale, Time.deltaTime * extraScaleVelocity);
				EmitParticle(k + halfBarsValue, num6);
				if (newRightScale >= prevRightScale.y)
				{
					prevRightScale.y = newRightScale;
					rightScale = prevRightScale;
				}
				else
				{
					rightScale = prevRightScale;
					rightScale.y = Mathf.Lerp(prevRightScale.y, minHeight, Time.deltaTime * (float)smoothVelocity);
				}
				soundBars[k + halfBarsValue].transform.localScale = rightScale;
			}
		}
		else
		{
			for (int l = 0; l < usedSoundBars; l++)
			{
				prevLeftScale = soundBars[l].transform.localScale;
				if (rhythmSurpassed)
				{
					newLeftScale = Mathf.Lerp(prevLeftScale.y, rhythmAverage * bassHeight * globalScale, Time.deltaTime * (float)smoothVelocity);
					if (soundBarsParticles && remainingParticlesTime <= 0f)
					{
						soundBars[l].GetComponentInChildren<ParticleSystem>().Play();
						surpassed = true;
					}
				}
				else
				{
					newLeftScale = Mathf.Lerp(prevLeftScale.y, rhythmAverage * globalScale, Time.deltaTime * extraScaleVelocity);
				}
				if (newLeftScale >= prevLeftScale.y)
				{
					prevLeftScale.y = newLeftScale;
					rightScale = prevLeftScale;
				}
				else
				{
					rightScale = prevLeftScale;
					rightScale.y = Mathf.Lerp(prevLeftScale.y, minHeight, Time.deltaTime * (float)smoothVelocity);
				}
				soundBars[l].transform.localScale = rightScale;
			}
		}
		if (soundBarsParticles)
		{
			if (surpassed)
			{
				surpassed = false;
				remainingParticlesTime = particlesMaxInterval;
			}
			else
			{
				remainingParticlesTime -= Time.deltaTime;
			}
		}
		if (rhythmSurpassed)
		{
			rhythmSurpassed = false;
			remainingRhythmParticlesTime = rhythmParticlesMaxInterval;
		}
		else
		{
			remainingRhythmParticlesTime -= Time.deltaTime;
		}
		if (cameraControl)
		{
			CameraMovement();
		}
	}

	private void EmitParticle(int index, float spectrumValue)
	{
		if (soundBarsParticles && spectrumValue >= minParticleSensibility && remainingParticlesTime <= 0f)
		{
			soundBars[index].GetComponentInChildren<ParticleSystem>().Play();
			surpassed = true;
		}
	}
}
public class SoundBar : MonoBehaviour
{
	public Renderer cube;

	public Renderer ray;

	public ParticleSystem particleSystem;
}
public class AlleyDemoControl : MonoBehaviour
{
	[Header("Dimensions")]
	public float width = 6f;

	public float height = 4f;

	public float depth = 24f;

	public float speed = 5f;

	[Header("Population")]
	public int maxBlocks = 200;

	public int maxPebbles = 200;

	public int maxWires = 50;

	public int maxSigns = 150;

	[Header("Rendering")]
	public Color fogColor = Color.white;

	public Material blockMaterial;

	public Material pebbleMaterial;

	public Material wireMaterial;

	public SSFSGenerator ssfsGenerator;

	private Light sun;

	private Transform[] leftblocks;

	private Transform[] rightblocks;

	private Transform[] pebbles;

	private Transform[] signs;

	private List<Transform> wires = new List<Transform>();

	public int maxWireVerts = 7;

	private Vector3 tunnelMovement => -Vector3.forward * Time.deltaTime * speed * (1f + 3f * Mathf.PerlinNoise(Time.time * 0.05f, 111.111f));

	private void Start()
	{
		CreateSun();
		CreateWall(Vector3.back, new Vector3(0f, height * 5f, depth), new Vector3(width * 5f, 1f, height * 2.5f), noshadow: true);
		CreateWall(Vector3.up, new Vector3(0f, 0f, depth * 0.5f), new Vector3(height * 0.1f, 1f, depth * 0.1f));
		CreateWall(Vector3.left, new Vector3(width * 0.5f, height * 0.5f, depth * 0.5f), new Vector3(height * 0.1f, 1f, depth * 0.1f));
		CreateWall(Vector3.right, new Vector3((0f - width) * 0.5f, height * 0.5f, depth * 0.5f), new Vector3(height * 0.1f, 1f, depth * 0.1f));
		PopulateBlockList(ref leftblocks, -1f);
		PopulateBlockList(ref rightblocks, 1f);
		PopulateSigns();
		PopulatePebbles();
	}

	private void Update()
	{
		UpdateBlocks(ref leftblocks, -1f);
		UpdateBlocks(ref rightblocks, 1f);
		UpdateDetail();
		Shader.SetGlobalFloat("_TunnelDemoDepth", depth);
		Shader.SetGlobalColor("_TunnelDemoFogColor", fogColor);
		sun.color = fogColor;
		Vector3 up = Vector3.up;
		up.x += (-1f + 2f * Mathf.PerlinNoise(Time.time * 0.01f, 1f)) * width * 0.5f;
		up.y += Mathf.PerlinNoise(2f, Time.time * 0.02f);
		up.z += Mathf.PerlinNoise(Time.time * 0.03f, 3f);
		base.transform.position = up;
		base.transform.rotation = Quaternion.Euler(Mathf.PerlinNoise(1.11f, Time.time * 0.01f) * 10f - 10f, Mathf.PerlinNoise(Time.time * 0.02f, 0.5f) * 5f, 12f * Mathf.Sin(Time.time * 0.01f));
		sun.transform.forward = new Vector3(-0.5f + Mathf.PerlinNoise(11.111f, Time.time * 0.01f), -1f, -1f).normalized;
	}

	private void CreateSun()
	{
		GameObject gameObject = new GameObject("Sun");
		gameObject.hideFlags = HideFlags.HideInHierarchy;
		sun = gameObject.AddComponent<Light>();
		sun.type = LightType.Directional;
		sun.transform.rotation = Quaternion.Euler(35f, 170f, 0f);
		sun.intensity = 1.2f;
		sun.shadows = LightShadows.Soft;
		sun.shadowStrength = 0.95f;
		sun.shadowResolution = LightShadowResolution.VeryHigh;
		sun.shadowBias = 0.025f;
		sun.shadowNormalBias = 0f;
		sun.shadowNearPlane = 5f;
	}

	private void RandColor(ref Transform block, float minValue = 0.2f, float valueRange = 0.4f)
	{
		MaterialPropertyBlock materialPropertyBlock = new MaterialPropertyBlock();
		materialPropertyBlock.SetColor("_Color", Color.HSVToRGB(UnityEngine.Random.value, UnityEngine.Random.value * 0.3f, UnityEngine.Random.value * valueRange + minValue));
		block.GetComponent<MeshRenderer>().SetPropertyBlock(materialPropertyBlock);
	}

	private void CreateWall(Vector3 up, Vector3 pos, Vector3 scl, bool noshadow = false)
	{
		Transform obj = GameObject.CreatePrimitive(PrimitiveType.Plane).transform;
		obj.hideFlags = HideFlags.HideInHierarchy;
		MeshRenderer component = obj.GetComponent<MeshRenderer>();
		component.shadowCastingMode = ((!noshadow) ? ShadowCastingMode.TwoSided : ShadowCastingMode.Off);
		component.sharedMaterial = blockMaterial;
		obj.up = up;
		obj.position = pos;
		obj.localScale = scl;
	}

	private void PopulateBlockList(ref Transform[] blocks, float side)
	{
		blocks = new Transform[maxBlocks];
		for (int i = 0; i < maxBlocks; i++)
		{
			blocks[i] = GameObject.CreatePrimitive(PrimitiveType.Cube).transform;
			blocks[i].hideFlags = HideFlags.HideInHierarchy;
			blocks[i].GetComponent<MeshRenderer>().sharedMaterial = blockMaterial;
			bool bridge = UnityEngine.Random.value > 0.98f;
			ScaleBlock(ref blocks[i], bridge);
			PositionBlock(ref blocks[i], side * width * 0.5f, bridge);
			Vector3 position = blocks[i].position;
			position.z = UnityEngine.Random.value * depth;
			blocks[i].position = position;
			RandColor(ref blocks[i]);
		}
	}

	private void PopulatePebbles()
	{
		pebbles = new Transform[maxPebbles];
		for (int i = 0; i < maxPebbles; i++)
		{
			pebbles[i] = GameObject.CreatePrimitive(PrimitiveType.Cube).transform;
			pebbles[i].hideFlags = HideFlags.HideInHierarchy;
			MeshRenderer component = pebbles[i].GetComponent<MeshRenderer>();
			component.sharedMaterial = pebbleMaterial;
			component.shadowCastingMode = ShadowCastingMode.Off;
			NewPebblePos(ref pebbles[i], randomDepth: true);
			RandColor(ref pebbles[i], 0.25f, 0.5f);
		}
	}

	private void ScaleBlock(ref Transform block, bool bridge)
	{
		Vector3 localScale = new Vector3(UnityEngine.Random.value * 2f + 0.2f, UnityEngine.Random.value * height + 0.5f, UnityEngine.Random.value * depth * 0.1f + 0.25f);
		if (bridge)
		{
			localScale.x = width;
			localScale.y = 1f;
			localScale.z = UnityEngine.Random.value * 3f + 1f;
		}
		block.localScale = localScale;
	}

	private void PositionBlock(ref Transform block, float xpos, bool bridge)
	{
		Vector3 position = new Vector3(xpos, UnityEngine.Random.value * height, depth);
		if (bridge)
		{
			position.x = 0f;
			position.y = Mathf.Max(position.y, 3f);
		}
		block.position = position;
	}

	private void TripBlock(ref Transform block, float side)
	{
		bool bridge = UnityEngine.Random.value > 0.98f;
		ScaleBlock(ref block, bridge);
		PositionBlock(ref block, side * width * 0.5f, bridge);
		if (block.position.y > 3f && UnityEngine.Random.value > 0.8f && wires.Count < maxWires)
		{
			CreateWire(block.position, (0f - Mathf.Sign(block.position.x)) * Vector3.right * width + Vector3.up * UnityEngine.Random.value);
		}
	}

	private void PopulateSigns()
	{
		signs = new Transform[maxSigns];
		if (!(ssfsGenerator == null))
		{
			for (int i = 0; i < maxSigns; i++)
			{
				GameObject gameObject = GameObject.CreatePrimitive(PrimitiveType.Quad);
				gameObject.hideFlags = HideFlags.HideInHierarchy;
				gameObject.transform.localScale = Vector3.one * (2f * UnityEngine.Random.value + 1f);
				Vector3 position = NewSignPosition();
				gameObject.transform.position = position;
				gameObject.transform.forward = ((UnityEngine.Random.value > 0.8f) ? Vector3.forward : (Mathf.Sign(position.x) * Vector3.right));
				MeshRenderer component = gameObject.GetComponent<MeshRenderer>();
				component.sharedMaterial = ssfsGenerator.GenerateMaterial();
				component.shadowCastingMode = ShadowCastingMode.Off;
				Light light = gameObject.AddComponent<Light>();
				light.color = Color.HSVToRGB(UnityEngine.Random.value, UnityEngine.Random.value * 0.5f + 0.5f, 1f);
				light.range = 2f;
				signs[i] = gameObject.transform;
			}
		}
	}

	private Vector3 NewSignPosition(bool atEnd = false)
	{
		Vector3 result = Vector3.zero;
		Vector3 origin = new Vector3(0f, (UnityEngine.Random.value * 0.8f + 0.1f) * height, atEnd ? (depth - 5f) : (UnityEngine.Random.value * depth));
		if (Physics.Raycast(new Ray(origin, (UnityEngine.Random.value > 0.5f) ? Vector3.right : Vector3.left), out var hitInfo))
		{
			result = hitInfo.point + hitInfo.normal * (UnityEngine.Random.value + 0.1f);
		}
		return result;
	}

	private void UpdateBlocks(ref Transform[] blocks, float side)
	{
		for (int i = 0; i < maxBlocks; i++)
		{
			blocks[i].position += tunnelMovement;
			if (blocks[i].position.z < 0f - blocks[i].localScale.z)
			{
				TripBlock(ref blocks[i], side);
			}
		}
	}

	private void NewPebblePos(ref Transform pebble, bool randomDepth = false)
	{
		Vector3 position = new Vector3(width * (UnityEngine.Random.value - 0.5f), 0f, randomDepth ? (UnityEngine.Random.value * depth) : depth);
		Vector3 localScale = UnityEngine.Random.onUnitSphere * 0.1f + Vector3.one * 0.2f;
		localScale.y *= 0.5f;
		pebble.position = position;
		pebble.localScale = localScale;
	}

	private void UpdateDetail()
	{
		for (int num = wires.Count - 1; num > -1; num--)
		{
			wires[num].position += tunnelMovement;
			if (wires[num].position.z < -1f)
			{
				UnityEngine.Object.Destroy(wires[num].gameObject);
				wires.RemoveAt(num);
			}
		}
		for (int i = 0; i < maxSigns; i++)
		{
			if (!(signs[i] != null))
			{
				continue;
			}
			signs[i].position += tunnelMovement;
			if (signs[i].position.z < -1f)
			{
				signs[i].position = NewSignPosition(atEnd: true);
				signs[i].forward = ((UnityEngine.Random.value > 0.8f) ? Vector3.forward : (Mathf.Sign(signs[i].position.x) * Vector3.right));
				Material existingMaterial = signs[i].GetComponent<MeshRenderer>().sharedMaterial;
				ssfsGenerator.GenerateMaterial(ref existingMaterial);
				Light component = signs[i].GetComponent<Light>();
				if (component != null)
				{
					component.color = Color.HSVToRGB(UnityEngine.Random.value, UnityEngine.Random.value * 0.5f + 0.5f, 1f);
					component.range = 2f;
				}
			}
		}
		for (int j = 0; j < maxPebbles; j++)
		{
			pebbles[j].position += tunnelMovement;
			if (pebbles[j].position.z < -1f)
			{
				NewPebblePos(ref pebbles[j]);
			}
		}
	}

	private void CreateWire(Vector3 p1, Vector3 p2)
	{
		GameObject gameObject = new GameObject();
		gameObject.hideFlags = HideFlags.HideInHierarchy;
		gameObject.transform.position = p1;
		LineRenderer lineRenderer = gameObject.AddComponent<LineRenderer>();
		lineRenderer.material = wireMaterial;
		Vector3[] array = new Vector3[maxWireVerts];
		for (int i = 0; i < maxWireVerts; i++)
		{
			float num = (float)i / ((float)maxWireVerts - 1f);
			array[i] = Vector3.Lerp(Vector3.zero, p2, num);
			array[i] -= Vector3.up * p2.magnitude * 0.1f * (1f - Mathf.Pow(2f * num - 1f, 2f));
		}
		lineRenderer.useWorldSpace = false;
		lineRenderer.widthMultiplier = (UnityEngine.Random.value + 0.1f) * 0.1f;
		lineRenderer.positionCount = maxWireVerts;
		lineRenderer.SetPositions(array);
		wires.Add(gameObject.transform);
	}
}
public class Demo_SignSwitcher : MonoBehaviour
{
	public Material[] materials;

	public bool autoswitch;

	public float delay = 6f;

	public float transitionTime = 1f;

	public KeyCode nextKey = KeyCode.RightArrow;

	public KeyCode prevKey = KeyCode.LeftArrow;

	private bool isswitching;

	private int currentId;

	private float cphase;

	private Renderer r;

	private float t;

	private void Start()
	{
		r = GetComponent<Renderer>();
		t = delay;
		StartCoroutine(GoToMaterial());
	}

	public IEnumerator GoToMaterial()
	{
		if (materials.Length != 0)
		{
			Material nextMat = materials[currentId];
			isswitching = true;
			while (cphase > 0f)
			{
				cphase -= Time.deltaTime / transitionTime;
				r.sharedMaterial.SetFloat("_Phase", cphase);
				yield return new WaitForEndOfFrame();
			}
			r.sharedMaterial = nextMat;
			while (cphase < 1f)
			{
				cphase += Time.deltaTime / transitionTime;
				r.sharedMaterial.SetFloat("_Phase", cphase);
				yield return new WaitForEndOfFrame();
			}
			isswitching = false;
		}
	}

	private void ShiftMaterial(int offset)
	{
		currentId = (int)Mathf.Repeat(currentId + offset, materials.Length);
		StartCoroutine(GoToMaterial());
	}

	private void Update()
	{
		if (isswitching || r == null)
		{
			return;
		}
		if (autoswitch)
		{
			if (t > 0f)
			{
				t -= Time.deltaTime;
				return;
			}
			t = delay;
			ShiftMaterial(1);
			return;
		}
		if (Input.GetKeyDown(nextKey))
		{
			ShiftMaterial(1);
		}
		if (Input.GetKeyDown(prevKey))
		{
			ShiftMaterial(-1);
		}
	}
}
[ExecuteInEditMode]
internal class LightColorFromTexture : MonoBehaviour
{
	public Renderer r;

	[Range(0f, 2f)]
	public float colorIntensity = 1f;

	[NonSerialized]
	private Light _l;

	[NonSerialized]
	private Material m;

	[NonSerialized]
	private Texture2D t1;

	[NonSerialized]
	private Texture2D t2;

	[NonSerialized]
	private Color c1;

	[NonSerialized]
	private Color c2;

	private Dictionary<Texture, Color> cachedEvaluations = new Dictionary<Texture, Color>();

	private Light l
	{
		get
		{
			if (_l == null)
			{
				_l = GetComponent<Light>();
			}
			return _l;
		}
	}

	private bool hasSwap => t2 != null;

	private void Update()
	{
		if (!CheckUpdate())
		{
			return;
		}
		Color c = c1;
		if (m.HasProperty("_Phase"))
		{
			if (hasSwap)
			{
				c = Color.Lerp(c2, c, m.GetFloat("_Phase"));
			}
			else
			{
				c *= m.GetFloat("_Phase");
			}
		}
		if (m.HasProperty("_Color"))
		{
			c *= m.GetColor("_Color");
		}
		Intensify(ref c);
		if (l != null)
		{
			l.color = c;
		}
	}

	public bool FindTexture(string propertyName, ref Texture2D texture)
	{
		if (m.HasProperty(propertyName))
		{
			Texture2D texture2D = (Texture2D)m.GetTexture(propertyName);
			if (texture2D != texture)
			{
				texture = texture2D;
				return texture2D != null;
			}
			return false;
		}
		return false;
	}

	public bool CheckUpdate()
	{
		if (r == null)
		{
			return false;
		}
		if (r.sharedMaterial != m)
		{
			m = r.sharedMaterial;
		}
		if (m == null)
		{
			return false;
		}
		if (FindTexture("_MainTex", ref t1))
		{
			c1 = EvaluateColor(t1);
		}
		if (t1 == null)
		{
			return false;
		}
		if (FindTexture("_MainTex2", ref t2))
		{
			c2 = EvaluateColor(t2);
		}
		return true;
	}

	public void Intensify(ref Color c)
	{
		Color.RGBToHSV(c, out var H, out var S, out var V);
		c = Color.HSVToRGB(H, S * colorIntensity, Mathf.Clamp01(V * colorIntensity));
	}

	public Color EvaluateColor(Texture2D texture)
	{
		if (texture == null)
		{
			return Color.clear;
		}
		if (cachedEvaluations.ContainsKey(texture))
		{
			return cachedEvaluations[texture];
		}
		Color32[] pixels;
		try
		{
			pixels = texture.GetPixels32();
		}
		catch
		{
			return Color.clear;
		}
		Color black = Color.black;
		int num = 0;
		int num2 = 100;
		for (int i = 0; i < pixels.Length; i += num2)
		{
			if (pixels[i].a > 0)
			{
				black += (Color)pixels[i];
				num++;
			}
		}
		Color color = black / num;
		color.r = Mathf.Clamp01(color.r);
		color.g = Mathf.Clamp01(color.g);
		color.b = Mathf.Clamp01(color.b);
		color.a = 1f;
		cachedEvaluations.Add(texture, color);
		return color;
	}
}
[Serializable]
public class MaterialParameter
{
	public enum MaterialParamType
	{
		number,
		color,
		texture,
		vector
	}

	public string parameterName = "_Parameter";

	public string displayName = "Parameter Value";

	public int repeat = 2;

	public MaterialParamType type;

	public float min;

	public float max = 1f;

	public string label_x = "X";

	public string label_y = "Y";

	public string label_z = "Z";

	public string label_w = "W";

	public Vector4 min4 = Vector4.zero;

	public Vector4 max4 = Vector4.one;

	public List<Texture> textures = new List<Texture>();

	[NonSerialized]
	public float value;

	[NonSerialized]
	public Color valueC;

	[NonSerialized]
	public Vector4 value4;

	public int texID => Mathf.FloorToInt(Mathf.Repeat(value * (float)textures.Count, textures.Count));

	public MaterialParameter()
	{
		parameterName = "_Parameter";
		displayName = "Parameter Value";
		repeat = 1;
		type = MaterialParamType.number;
		min = 0f;
		max = 1f;
		min4 = Vector4.zero;
		max4 = Vector4.one;
		textures = new List<Texture>();
	}

	public MaterialParameter(MaterialParameter other)
	{
		parameterName = other.parameterName;
		displayName = other.displayName;
		repeat = other.repeat;
		type = other.type;
		min = other.min;
		max = other.max;
		min4 = other.min4;
		max4 = other.max4;
		textures = new List<Texture>(other.textures);
	}
}
public class ParameterFiddler : MonoBehaviour
{
	public Material sourceMaterial;

	private Material material;

	public bool automatic = true;

	public bool showMenu;

	public float menuVis;

	[Range(0.25f, 5f)]
	public float fiddleTime = 3f;

	public List<MaterialParameter> parameters = new List<MaterialParameter>();

	public Texture sliderBar;

	public Texture sliderThumb;

	private GUIStyle sliderStyle;

	private GUIStyle sliderThumbStyle;

	private int currentParameterIndex;

	private float t;

	private bool fiddling;

	private GUIStyle nameStyle;

	private GUIStyle nameStyle2;

	private GUIStyle buttonStyle;

	private GUIStyle scrollStyle;

	private GUIStyle boxStyle;

	private Color baseGUIColor = Color.white;

	private float tf => t / fiddleTime;

	private void Start()
	{
		material = new Material(sourceMaterial);
		GetComponent<Renderer>().material = material;
		if (parameters.Count > 0 && automatic)
		{
			StartCoroutine(Unfiddle());
		}
		ManualRead();
	}

	private void Update()
	{
		if (automatic)
		{
			if (fiddling)
			{
				t += Time.deltaTime;
			}
			if (parameters[currentParameterIndex].parameterName != "_Phase")
			{
				material.SetFloat("_Phase", 0.5f);
			}
			return;
		}
		if (showMenu)
		{
			menuVis = Mathf.Lerp(menuVis, (Input.mousePosition.x > (float)Screen.width - (float)Screen.width * 0.2f) ? 1f : 0f, Time.deltaTime * 10f);
		}
		int num = currentParameterIndex;
		if (Input.GetKeyDown(KeyCode.A))
		{
			currentParameterIndex = (int)Mathf.Repeat(currentParameterIndex - 1, parameters.Count - 1);
		}
		if (Input.GetKeyDown(KeyCode.D))
		{
			currentParameterIndex = (int)Mathf.Repeat(currentParameterIndex + 1, parameters.Count - 1);
		}
		if (num != currentParameterIndex)
		{
			ManualRead();
		}
		ManualFiddle();
	}

	public void ManualRead()
	{
		if (currentParameterIndex < 0)
		{
			return;
		}
		MaterialParameter materialParameter = parameters[currentParameterIndex];
		if (material.HasProperty(materialParameter.parameterName))
		{
			switch (materialParameter.type)
			{
			case MaterialParameter.MaterialParamType.number:
				materialParameter.value = material.GetFloat(materialParameter.parameterName);
				break;
			case MaterialParameter.MaterialParamType.color:
				materialParameter.valueC = material.GetColor(materialParameter.parameterName);
				break;
			case MaterialParameter.MaterialParamType.vector:
				materialParameter.value4 = material.GetVector(materialParameter.parameterName);
				break;
			case MaterialParameter.MaterialParamType.texture:
				break;
			}
		}
	}

	public void ManualFiddle()
	{
		if (currentParameterIndex < 0)
		{
			return;
		}
		MaterialParameter materialParameter = parameters[currentParameterIndex];
		if (!material.HasProperty(materialParameter.parameterName))
		{
			return;
		}
		switch (materialParameter.type)
		{
		case MaterialParameter.MaterialParamType.number:
			material.SetFloat(materialParameter.parameterName, materialParameter.value);
			break;
		case MaterialParameter.MaterialParamType.color:
			material.SetColor(materialParameter.parameterName, materialParameter.valueC);
			break;
		case MaterialParameter.MaterialParamType.vector:
			material.SetVector(materialParameter.parameterName, materialParameter.value4);
			break;
		case MaterialParameter.MaterialParamType.texture:
			if (materialParameter.textures.Count > 0)
			{
				material.SetTexture(materialParameter.parameterName, materialParameter.textures[materialParameter.texID]);
			}
			break;
		}
	}

	public void FiddleParameter()
	{
		MaterialParameter materialParameter = parameters[currentParameterIndex];
		if (material.HasProperty(materialParameter.parameterName))
		{
			switch (materialParameter.type)
			{
			case MaterialParameter.MaterialParamType.number:
				StartCoroutine(FiddleFloat(materialParameter));
				break;
			case MaterialParameter.MaterialParamType.color:
				StartCoroutine(FiddleColor(materialParameter));
				break;
			case MaterialParameter.MaterialParamType.texture:
				StartCoroutine(FiddleTexture(materialParameter));
				break;
			case MaterialParameter.MaterialParamType.vector:
				StartCoroutine(FiddleVector(materialParameter));
				break;
			}
		}
		else
		{
			UnityEngine.Debug.Log("Material Parameter Not Found: " + materialParameter.parameterName);
		}
	}

	public IEnumerator FiddleFloat(MaterialParameter p)
	{
		float o = (p.value = material.GetFloat(p.parameterName));
		float j = 0f;
		while (j < 1f)
		{
			j += Time.deltaTime * 6f;
			p.value = Mathf.Lerp(p.value, 0f, j);
			material.SetFloat(p.parameterName, p.value);
			yield return new WaitForEndOfFrame();
		}
		while (t < fiddleTime)
		{
			float num = (0f - Mathf.Cos(tf * (float)Math.PI * 1.5f * (float)p.repeat)) * 0.5f + 0.5f;
			p.value = Mathf.Lerp(p.min, p.max, num);
			material.SetFloat(p.parameterName, p.value);
			yield return new WaitForEndOfFrame();
		}
		j = 0f;
		while (j < 1f)
		{
			j += Time.deltaTime * 6f;
			p.value = Mathf.Lerp(p.value, o, j);
			material.SetFloat(p.parameterName, p.value);
			yield return new WaitForEndOfFrame();
		}
		currentParameterIndex++;
		StartCoroutine(Unfiddle());
	}

	public IEnumerator FiddleColor(MaterialParameter param)
	{
		Color o = material.GetColor(param.parameterName);
		Color c = o;
		float j = 0f;
		while (j < 1f)
		{
			j += Time.deltaTime * 6f;
			material.SetColor(param.parameterName, Color.HSVToRGB(0f, 0.9f, 0.9f));
			yield return new WaitForEndOfFrame();
		}
		while (t < fiddleTime)
		{
			param.valueC = Color.HSVToRGB(Mathf.Repeat(tf * (float)param.repeat, 1f), 0.9f, 0.9f);
			material.SetColor(param.parameterName, param.valueC);
			yield return new WaitForEndOfFrame();
		}
		j = 0f;
		while (j < 1f)
		{
			j += Time.deltaTime * 6f;
			material.SetColor(param.parameterName, Color.Lerp(c, o, j));
			yield return new WaitForEndOfFrame();
		}
		material.SetColor(param.parameterName, o);
		currentParameterIndex++;
		StartCoroutine(Unfiddle());
	}

	public IEnumerator FiddleTexture(MaterialParameter param)
	{
		Texture o = material.GetTexture(param.parameterName);
		while (t < fiddleTime)
		{
			int num = (int)Mathf.Floor(tf * (float)param.textures.Count);
			param.value = Mathf.Clamp01((float)num / (float)param.textures.Count);
			material.SetTexture(param.parameterName, param.textures[num]);
			yield return new WaitForEndOfFrame();
		}
		material.SetTexture(param.parameterName, o);
		currentParameterIndex++;
		StartCoroutine(Unfiddle());
	}

	public IEnumerator FiddleVector(MaterialParameter param)
	{
		Vector4 o = material.GetVector(param.parameterName);
		while (t < fiddleTime)
		{
			float num = (0f - Mathf.Cos(tf * (float)Math.PI * 1.5f * (float)param.repeat)) * 0.5f + 0.5f;
			param.value4 = Vector4.Lerp(param.min4, param.max4, num);
			material.SetVector(param.parameterName, param.value4);
			yield return new WaitForEndOfFrame();
		}
		material.SetVector(param.parameterName, o);
		currentParameterIndex++;
		StartCoroutine(Unfiddle());
	}

	private IEnumerator Unfiddle()
	{
		fiddling = false;
		yield return new WaitForSeconds(1f);
		t = 0f;
		fiddling = true;
		FiddleParameter();
	}

	public void SetupGUIStyles()
	{
		nameStyle = new GUIStyle(GUI.skin.box);
		if (sliderBar != null)
		{
			nameStyle.normal.background = (Texture2D)sliderBar;
		}
		nameStyle.normal.textColor = Color.black;
		nameStyle.stretchWidth = true;
		nameStyle.margin = new RectOffset(0, 0, 0, 0);
		nameStyle.padding = new RectOffset(4, 4, 3, 3);
		nameStyle.overflow.bottom = 1;
		nameStyle.overflow.right = 1;
		nameStyle.wordWrap = false;
		nameStyle.alignment = TextAnchor.LowerLeft;
		nameStyle2 = new GUIStyle(nameStyle);
		nameStyle2.alignment = TextAnchor.LowerCenter;
		boxStyle = new GUIStyle(GUI.skin.box);
		if (sliderBar != null)
		{
			boxStyle.normal.background = (Texture2D)sliderBar;
		}
		boxStyle.margin = new RectOffset(0, 0, 0, 0);
		boxStyle.padding = new RectOffset(0, 0, 0, 0);
		boxStyle.overflow.top = 1;
		boxStyle.overflow.right = 1;
		boxStyle.overflow.bottom = 1;
		scrollStyle = new GUIStyle(GUI.skin.scrollView);
		scrollStyle.normal.background = GUI.skin.box.normal.background;
		scrollStyle.border = GUI.skin.box.border;
		scrollStyle.margin = new RectOffset(0, 0, 0, 0);
		scrollStyle.padding = new RectOffset(8, 8, 8, 8);
		scrollStyle.stretchWidth = true;
		buttonStyle = new GUIStyle(GUI.skin.button);
		buttonStyle.normal.background = GUI.skin.box.normal.background;
		buttonStyle.normal.textColor = Color.black;
		buttonStyle.hover.background = GUI.skin.box.normal.background;
		buttonStyle.hover.textColor = Color.black;
		buttonStyle.active.background = GUI.skin.box.normal.background;
		buttonStyle.active.textColor = Color.black;
	}

	private void OnGUI()
	{
		baseGUIColor = GUI.color;
		SetupGUIStyles();
		if (parameters.Count > 0 && currentParameterIndex < parameters.Count && currentParameterIndex > -1)
		{
			GUIStyle gUIStyle = new GUIStyle(GUI.skin.label);
			gUIStyle.alignment = TextAnchor.LowerCenter;
			gUIStyle.fontStyle = FontStyle.Bold;
			gUIStyle.fontSize = 24;
			gUIStyle.clipping = TextClipping.Overflow;
			gUIStyle.wordWrap = false;
			sliderStyle = new GUIStyle(GUI.skin.horizontalSlider);
			sliderThumbStyle = new GUIStyle(GUI.skin.horizontalSliderThumb);
			if (sliderBar != null)
			{
				sliderStyle.normal.background = (Texture2D)sliderBar;
			}
			if (sliderThumb != null)
			{
				sliderThumbStyle.normal.background = (Texture2D)sliderThumb;
				sliderThumbStyle.hover.background = (Texture2D)sliderThumb;
				sliderThumbStyle.active.background = (Texture2D)sliderThumb;
			}
			MaterialParameter materialParameter = parameters[currentParameterIndex];
			GUILayout.BeginArea(new Rect(0f, 0f, Screen.width, Screen.height));
			GUILayout.Space(30f);
			GUILayout.BeginHorizontal();
			GUILayout.FlexibleSpace();
			GUILayout.Label((fiddling || !automatic) ? materialParameter.displayName : "", gUIStyle, GUILayout.Height(40f));
			GUILayout.FlexibleSpace();
			GUILayout.EndHorizontal();
			GUILayout.FlexibleSpace();
			GUILayout.BeginHorizontal();
			GUILayout.Space((float)Screen.width * 0.25f);
			GUILayout.BeginVertical();
			gUIStyle.fontSize = 14;
			if (automatic)
			{
				switch (materialParameter.type)
				{
				case MaterialParameter.MaterialParamType.number:
					Slider("", materialParameter.value);
					break;
				case MaterialParameter.MaterialParamType.texture:
					Slider("", materialParameter.value);
					break;
				case MaterialParameter.MaterialParamType.vector:
					Slider(materialParameter.value4, materialParameter.min4, materialParameter.max4);
					break;
				case MaterialParameter.MaterialParamType.color:
					Slider(materialParameter.valueC);
					break;
				}
			}
			else
			{
				switch (materialParameter.type)
				{
				case MaterialParameter.MaterialParamType.number:
					Slider("", ref materialParameter.value, materialParameter.min, materialParameter.max);
					break;
				case MaterialParameter.MaterialParamType.texture:
					Slider(materialParameter.textures[materialParameter.texID].name, ref materialParameter.value);
					break;
				case MaterialParameter.MaterialParamType.vector:
					Slider(ref materialParameter.value4, materialParameter.min4, materialParameter.max4, materialParameter.label_x, materialParameter.label_y, materialParameter.label_z, materialParameter.label_w);
					break;
				case MaterialParameter.MaterialParamType.color:
					Slider(ref materialParameter.valueC);
					break;
				}
			}
			GUILayout.EndVertical();
			GUILayout.Space((float)Screen.width * 0.25f);
			GUILayout.EndHorizontal();
			GUILayout.Space(30f);
			GUILayout.EndArea();
		}
		if (parameters.Count <= 0)
		{
			return;
		}
		float num = 150f;
		float num2 = 8f;
		float num3 = (float)(parameters.Count + 1) * 21f + 1f;
		GUILayout.BeginArea(new Rect((float)Screen.width - num * menuVis - num2, (float)Screen.height * 0.5f - num3 * 0.5f, num + num2, num3));
		GUILayout.BeginHorizontal();
		GUILayout.Label("", boxStyle, GUILayout.Width(num2), GUILayout.ExpandHeight(expand: true));
		GUILayout.BeginVertical();
		GUILayout.Label("Parameters", nameStyle2);
		for (int i = 0; i < parameters.Count; i++)
		{
			GUI.color = ((currentParameterIndex == i) ? new Color(1f, 1f, 1f, 1f) : new Color(1f, 1f, 1f, 0.6f));
			if (GUILayout.Button(parameters[i].displayName, nameStyle))
			{
				currentParameterIndex = ((currentParameterIndex == i) ? (-1) : i);
				ManualRead();
			}
			GUI.color = baseGUIColor;
		}
		GUILayout.EndVertical();
		GUILayout.EndHorizontal();
		GUILayout.EndArea();
	}

	public void Slider(Color color)
	{
		GUI.color = color * 0.5f + Color.white * 0.5f;
		Slider("R", color.r);
		Slider("G", color.g);
		Slider("B", color.b);
		Slider("A", color.a);
		GUI.color = baseGUIColor;
	}

	public void Slider(ref Color color)
	{
		GUI.color = color * 0.8f + Color.white * 0.2f;
		Slider("R", ref color.r);
		Slider("G", ref color.g);
		Slider("B", ref color.b);
		Slider("A", ref color.a);
		GUI.color = baseGUIColor;
	}

	public void Slider(Vector4 v, Vector4 min4, Vector4 max4)
	{
		Slider("X", v.x, min4.x, max4.x);
		Slider("Y", v.y, min4.y, max4.y);
		Slider("Z", v.z, min4.z, max4.z);
		Slider("W", v.w, min4.w, max4.w);
	}

	public void Slider(ref Vector4 v, Vector4 min4, Vector4 max4, string xLabel = "X", string yLabel = "Y", string zLabel = "Z", string wLabel = "W")
	{
		if (!string.IsNullOrEmpty(xLabel))
		{
			Slider(xLabel, ref v.x, min4.x, max4.x);
		}
		if (!string.IsNullOrEmpty(yLabel))
		{
			Slider(yLabel, ref v.y, min4.y, max4.y);
		}
		if (!string.IsNullOrEmpty(zLabel))
		{
			Slider(zLabel, ref v.z, min4.z, max4.z);
		}
		if (!string.IsNullOrEmpty(wLabel))
		{
			Slider(wLabel, ref v.w, min4.w, max4.w);
		}
	}

	public void Slider(string label, float v, float min = 0f, float max = 1f)
	{
		GUILayout.BeginHorizontal();
		GUILayout.FlexibleSpace();
		if (label.Length > 0)
		{
			GUILayout.Label(label, GUILayout.Width((float)Screen.width * 0.3f));
		}
		GUILayout.HorizontalSlider(v, min, max, sliderStyle, sliderThumbStyle, GUILayout.Width((float)Screen.width * 0.3f));
		GUILayout.FlexibleSpace();
		GUILayout.EndHorizontal();
	}

	public void Slider(string label, ref float v, float min = 0f, float max = 1f)
	{
		GUILayout.BeginHorizontal();
		GUILayout.FlexibleSpace();
		if (label.Length > 0)
		{
			GUILayout.Label(label, GUILayout.Width((float)Screen.width * 0.3f));
		}
		v = GUILayout.HorizontalSlider(v, min, max, sliderStyle, sliderThumbStyle, GUILayout.Width((float)Screen.width * 0.3f));
		GUILayout.FlexibleSpace();
		GUILayout.EndHorizontal();
	}
}
public class AppCoreControl : MonoBehaviour
{
	public enum AASetting
	{
		None,
		x2,
		x4,
		x8
	}

	public int frameRateLimit = 90;

	public bool showFps;

	public bool enableVsync;

	public int maxQueuedFrames = 2;

	public bool pauseOnFocusLoss;

	public AASetting antialiasing = AASetting.x4;

	[ContextMenu("Update Settings Now")]
	private void Start()
	{
		UnityEngine.Application.runInBackground = !pauseOnFocusLoss;
		UnityEngine.Application.targetFrameRate = frameRateLimit;
		if (enableVsync)
		{
			QualitySettings.vSyncCount = 1;
		}
		else
		{
			QualitySettings.vSyncCount = 0;
		}
		QualitySettings.maxQueuedFrames = maxQueuedFrames;
		QualitySettings.antiAliasing = (int)antialiasing;
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.Escape))
		{
			UnityEngine.Application.Quit();
		}
	}

	private void OnGUI()
	{
		if (showFps)
		{
			GUILayout.BeginArea(new Rect(0f, 0f, Screen.width, Screen.height));
			GUILayout.Label("~" + Mathf.RoundToInt(1f / Time.smoothDeltaTime) + " fps");
			GUILayout.EndArea();
		}
	}
}
public class CameraOrbit : MonoBehaviour
{
	public Transform target;

	public float distance = 2f;

	public float lerpSpeed = 3f;

	public float scrollSpeed = 5f;

	public float minDist = 0.5f;

	public float maxDist = 5f;

	public bool raycastedDistance;

	private float wdist;

	private float cdist;

	private Vector3 wrot;

	private Vector3 crot;

	private Vector3 worigin;

	private Vector3 corigin;

	private void Start()
	{
		wdist = distance;
		base.transform.position = corigin - base.transform.forward * wdist;
	}

	private void Update()
	{
		float t = Time.deltaTime * 2f * lerpSpeed;
		wdist -= Input.GetAxis("Mouse ScrollWheel") * Time.deltaTime * 5f * scrollSpeed;
		wdist = Mathf.Clamp(wdist, minDist, maxDist);
		cdist = Mathf.Lerp(cdist, wdist, t);
		if (Input.GetMouseButton(1))
		{
			wrot.y += Input.GetAxis("Mouse X") * 3f;
			wrot.x -= Input.GetAxis("Mouse Y") * 3f;
		}
		wrot.z = 0f;
		crot.x = Mathf.LerpAngle(crot.x, wrot.x, t);
		crot.y = Mathf.LerpAngle(crot.y, wrot.y, t);
		crot.z = Mathf.LerpAngle(crot.z, wrot.z, t);
		base.transform.rotation = Quaternion.Euler(crot);
		if (target != null)
		{
			worigin = target.position;
		}
		else
		{
			worigin = Vector3.zero;
		}
		if (raycastedDistance && Physics.Raycast(new Ray(worigin - base.transform.forward * (cdist + 1f), base.transform.forward), out var hitInfo))
		{
			worigin = hitInfo.point;
		}
		corigin = Vector3.Lerp(corigin, worigin, t);
		base.transform.position = corigin - base.transform.forward * cdist;
	}

	private void OnDrawGizmosSelected()
	{
		Gizmos.color = Color.red;
		Gizmos.DrawWireSphere(worigin, 0.2f);
		Gizmos.DrawLine(worigin, base.transform.position);
		Gizmos.color = Color.blue;
		Gizmos.DrawWireSphere(corigin, 0.2f);
		Gizmos.DrawLine(corigin, base.transform.position);
	}
}
public class ConstantTransform : MonoBehaviour
{
	public Vector3 translation;

	public Space translationSpace;

	public Vector3 rotation;

	public Space rotationSpace;

	private void Update()
	{
		base.transform.Translate(translation * Time.deltaTime, translationSpace);
		base.transform.Rotate(rotation * Time.deltaTime, rotationSpace);
	}
}
public class StepRotation : MonoBehaviour
{
	public int segments = 4;

	public float delay = 0.25f;

	private float i;

	private float t;

	private Quaternion targetRotation = Quaternion.identity;

	private void Update()
	{
		base.transform.rotation = Quaternion.SlerpUnclamped(base.transform.rotation, targetRotation, Time.deltaTime * 10f);
		t += Time.deltaTime;
		if (t >= delay)
		{
			t = 0f;
			Rotate();
		}
	}

	public void Rotate()
	{
		i = Mathf.Repeat(i + 1f / (float)segments, 1f);
		float f = i * (float)Math.PI * 2f;
		targetRotation = Quaternion.LookRotation(new Vector3(Mathf.Sin(f), 0f, Mathf.Cos(f)), Vector3.up);
	}
}
[CreateAssetMenu(fileName = "SSFS Generator", menuName = "New SSFS Generator", order = 1)]
public class SSFSGenerator : ScriptableObject
{
	public TextureList textures = new TextureList();

	public TextureList scatters = new TextureList();

	public RandomColor baseTint = new RandomColor();

	public RandomColor transitionTint = new RandomColor();

	public boolchance useTextureSwap = new boolchance(boolean: false, 0.1f);

	public boolchance useImageAsScatter = new boolchance(boolean: false, 0.1f);

	public boolchance useRandomTileCount = new boolchance(boolean: true, 1f);

	public boolchance allowIdleAnimation = new boolchance(boolean: true, 0.5f);

	public boolchance allowIdleNoise = new boolchance(boolean: true, 0.2f);

	public RandomRange idleNoiseStrength = new RandomRange();

	public RandomRange idleIntensity = new RandomRange();

	public RandomRange idleSpeed = new RandomRange();

	public boolchance allowIdleReverse = new boolchance(boolean: true, 0.2f);

	public boolchance allowTileClipping = new boolchance(boolean: true, 0.2f);

	public boolchance allowRadial = new boolchance(boolean: true, 0.5f);

	public RandomRange phaseDirection = new RandomRange();

	public boolchance separateTileCounts = new boolchance(boolean: true, 0.2f);

	public RandomRangeInt tileCountUniform = new RandomRangeInt();

	public RandomRangeInt tileCountX = new RandomRangeInt();

	public RandomRangeInt tileCountY = new RandomRangeInt();

	public boolchance separateAxisScaling = new boolchance(boolean: true, 0.2f);

	public boolchance allowTileCentricScaling = new boolchance(boolean: true, 0.2f);

	public RandomRange scalingUniform = new RandomRange();

	public RandomRange scalingX = new RandomRange();

	public RandomRange scalingY = new RandomRange();

	public RandomRange scattering = new RandomRange();

	public RandomRange phaseSharpness = new RandomRange();

	public RandomRange overbright = new RandomRange();

	public RandomRange aberration = new RandomRange();

	public RandomRange effectAberration = new RandomRange();

	public RandomRange scanlineIntensity = new RandomRange();

	public RandomRange scanlineDistortion = new RandomRange();

	public RandomRange scanlineScale = new RandomRange();

	public RandomRange scanlineSpeed = new RandomRange();

	public RandomRange flash = new RandomRange();

	public RandomRange flicker = new RandomRange();

	public Material GenerateMaterial()
	{
		Material m = SSFSCore.newMaterial;
		genmat(ref m);
		return m;
	}

	public void GenerateMaterial(ref Material existingMaterial)
	{
		if (existingMaterial == null)
		{
			existingMaterial = SSFSCore.newMaterial;
		}
		else if (existingMaterial.shader != SSFSCore.shader)
		{
			existingMaterial.shader = SSFSCore.shader;
		}
		genmat(ref existingMaterial);
	}

	private bool SyncKeyword(ref Material m, string keyword, bool value)
	{
		if (value)
		{
			m.EnableKeyword(keyword);
		}
		else
		{
			m.DisableKeyword(keyword);
		}
		return value;
	}

	private void genmat(ref Material m)
	{
		if (m == null)
		{
			UnityEngine.Debug.Log("Null material passed to SSFSGenerator");
			return;
		}
		m.EnableKeyword("COMPLEX");
		m.DisableKeyword("POST");
		m.DisableKeyword("WORLD_SPACE_SCANLINES");
		m.SetFloat("_Cull", 0f);
		m.SetFloat("_BlendSrc", 1f);
		m.SetFloat("_BlendDst", 1f);
		m.SetFloat("_ZWrite", 0f);
		m.SetFloat("_ZTest", 4f);
		m.SetTexture("_MainTex", textures.texture);
		bool check = useTextureSwap.check;
		m.SetTexture("_MainTex2", check ? textures.texture : null);
		SyncKeyword(ref m, "TEXTURE_SWAP", check);
		m.SetTexture("_Noise", useImageAsScatter.check ? m.GetTexture("_MainTex") : scatters.texture);
		m.SetColor("_Color", baseTint.get_color);
		m.SetColor("_Color2", transitionTint.get_color);
		m.SetFloat("_Phase", 1f);
		m.SetVector("_PhaseDirection", new Vector4(phaseDirection.get_float, allowRadial.check ? 1f : 0f, 0f, 0f));
		float num = (allowIdleAnimation.check ? idleIntensity.get_float : 0f);
		float get_float = idleSpeed.get_float;
		float z = (allowIdleNoise.check ? idleNoiseStrength.get_float : 0f);
		float w = (allowIdleReverse.check ? 1f : 0f);
		SyncKeyword(ref m, "IDLE", num > 0f);
		m.SetVector("_IdleData", new Vector4(num, get_float, z, w));
		bool check2 = separateTileCounts.check;
		m.SetFloat("_SquareTiles", check2 ? 1f : 0f);
		int num2 = (check2 ? tileCountUniform.get_int : tileCountX.get_int);
		int num3 = (check2 ? tileCountUniform.get_int : tileCountY.get_int);
		m.SetVector("_TileCount", new Vector4(num2, num3, 0f, 0f));
		bool check3 = separateAxisScaling.check;
		float num4 = (check3 ? scalingUniform.get_float : scalingX.get_float);
		float num5 = (check3 ? scalingUniform.get_float : scalingY.get_float);
		m.SetVector("_Scaling", new Vector4(num4 * 3.5f - 0.5f, num5 * 3.5f - 0.5f, 0.5f, 0.5f));
		m.SetFloat("_ScaleAroundTile", SyncKeyword(ref m, "SCALE_AROUND_TILE", allowTileCentricScaling.check) ? 1f : 0f);
		m.SetFloat("_Scattering", scattering.get_float);
		m.SetFloat("_PhaseSharpness", phaseSharpness.get_float);
		m.SetFloat("_Overbright", overbright.get_float);
		float get_float2 = aberration.get_float;
		float get_float3 = effectAberration.get_float;
		SyncKeyword(ref m, "ABERRATION", Mathf.Max(get_float2, get_float3) > 0f);
		m.SetFloat("_Aberration", get_float2);
		m.SetFloat("_EffectAberration", get_float3);
		m.SetFloat("_Flash", flash.get_float);
		m.SetFloat("_Flicker", flicker.get_float);
		float get_float4 = scanlineIntensity.get_float;
		float get_float5 = scanlineDistortion.get_float;
		SyncKeyword(ref m, "SCAN_LINES", Mathf.Max(get_float4, get_float5) > 0f);
		m.SetVector("_ScanlineData", new Vector4(get_float4, scanlineScale.get_float, get_float5, scanlineSpeed.get_float));
		m.SetFloat("_ClippedTiles", SyncKeyword(ref m, "CLIPPING", allowTileClipping.check) ? 1f : 0f);
	}
}
[Serializable]
public class TextureList
{
	public List<Texture2D> list = new List<Texture2D>();

	public Texture2D texture => list[UnityEngine.Random.Range(0, list.Count)];

	public Texture2D this[int index]
	{
		get
		{
			return list[index];
		}
		set
		{
			list[index] = value;
		}
	}

	public int Count => list.Count;

	public TextureList()
	{
		list = new List<Texture2D>();
	}

	public void Add(Texture2D tex)
	{
		list.Add(tex);
	}

	public void Remove(Texture2D tex)
	{
		list.Remove(tex);
	}

	public void RemoveAt(int index)
	{
		list.RemoveAt(index);
	}

	public void Clear()
	{
		list.Clear();
	}
}
[Serializable]
public class boolchance
{
	public bool boolean;

	public float chance;

	public bool check
	{
		get
		{
			if (boolean)
			{
				return UnityEngine.Random.value <= chance;
			}
			return false;
		}
	}

	public boolchance(bool boolean, float chance)
	{
		this.boolean = boolean;
		this.chance = chance;
	}
}
[Serializable]
public class RandomColor
{
	public bool useRandom = true;

	public float minHue;

	public float minSaturation;

	public float minValue;

	public float maxHue = 1f;

	public float maxSaturation = 1f;

	public float maxValue = 1f;

	public Color fixedColor = Color.white;

	public Color testcolor = Color.clear;

	public Color get_color
	{
		get
		{
			float h = UnityEngine.Random.Range(minHue, maxHue);
			float s = UnityEngine.Random.Range(minSaturation, maxSaturation);
			float v = UnityEngine.Random.Range(minValue, maxValue);
			return Color.HSVToRGB(h, s, v);
		}
	}

	public RandomColor(float minHue = 0f, float maxHue = 1f, float minSaturation = 0f, float maxSaturation = 1f, float minValue = 0f, float maxValue = 1f)
	{
		useRandom = true;
		this.minHue = minHue;
		this.maxHue = maxHue;
		this.minSaturation = minSaturation;
		this.maxSaturation = maxSaturation;
		this.minValue = minValue;
		this.maxValue = maxValue;
		testcolor = Color.clear;
	}
}
[Serializable]
public class RandomRange
{
	public bool useRandom = true;

	public float min;

	public float max = 1f;

	public float def = 1f;

	public float test;

	public float get_float
	{
		get
		{
			if (!useRandom)
			{
				return def;
			}
			return UnityEngine.Random.Range(min, max);
		}
	}

	public RandomRange(float def = 1f, float min = 0f, float max = 1f)
	{
		useRandom = true;
		this.min = min;
		this.max = max;
		this.def = def;
		test = def;
	}
}
[Serializable]
public class RandomRangeInt
{
	public bool useRandom = true;

	public int min = 10;

	public int max = 1000;

	public int def = 24;

	public int test;

	public int get_int
	{
		get
		{
			if (!useRandom)
			{
				return def;
			}
			return UnityEngine.Random.Range(min, max);
		}
	}

	public RandomRangeInt(int def = 26, int min = 10, int max = 100)
	{
		useRandom = true;
		this.min = min;
		this.max = max;
		this.def = def;
		test = def;
	}
}
[RequireComponent(typeof(Camera))]
public class EnableCameraDepthInForward : MonoBehaviour
{
	private void Start()
	{
		Set();
	}

	private void Set()
	{
		if (GetComponent<Camera>().depthTextureMode == DepthTextureMode.None)
		{
			GetComponent<Camera>().depthTextureMode = DepthTextureMode.Depth;
		}
	}
}
[RequireComponent(typeof(MeshFilter))]
public class SoftNormalsToVertexColor : MonoBehaviour
{
	public enum Method
	{
		Simple,
		AngularDeviation
	}

	public Method method = Method.AngularDeviation;

	public bool generateOnAwake;

	public bool generateNow;

	private void OnDrawGizmos()
	{
		if (generateNow)
		{
			generateNow = false;
			TryGenerate();
		}
	}

	private void Awake()
	{
		if (generateOnAwake)
		{
			TryGenerate();
		}
	}

	private void TryGenerate()
	{
		MeshFilter component = GetComponent<MeshFilter>();
		if (component == null)
		{
			UnityEngine.Debug.LogError("MeshFilter missing on the vertex color generator", base.gameObject);
			return;
		}
		if (component.sharedMesh == null)
		{
			UnityEngine.Debug.LogError("Assign a mesh to the MeshFilter before generating vertex colors", base.gameObject);
			return;
		}
		Generate(component.sharedMesh);
		UnityEngine.Debug.Log("Vertex colors generated", base.gameObject);
	}

	private void Generate(Mesh m)
	{
		Vector3[] normals = m.normals;
		Vector3[] vertices = m.vertices;
		Color[] array = new Color[normals.Length];
		List<List<int>> list = new List<List<int>>();
		for (int i = 0; i < vertices.Length; i++)
		{
			bool flag = false;
			foreach (List<int> item in list)
			{
				if (vertices[item[0]] == vertices[i])
				{
					item.Add(i);
					flag = true;
					break;
				}
			}
			if (!flag)
			{
				List<int> list2 = new List<int>();
				list2.Add(i);
				list.Add(list2);
			}
		}
		foreach (List<int> item2 in list)
		{
			Vector3 zero = Vector3.zero;
			foreach (int item3 in item2)
			{
				zero += normals[item3];
			}
			zero.Normalize();
			if (method == Method.AngularDeviation)
			{
				float num = 0f;
				foreach (int item4 in item2)
				{
					num += Vector3.Dot(normals[item4], zero);
				}
				num /= (float)item2.Count;
				float num2 = Mathf.Acos(num) * 57.29578f;
				float num3 = 180f - num2 - 90f;
				float num4 = 0.5f / Mathf.Sin(num3 * ((float)Math.PI / 180f));
				zero *= num4;
			}
			foreach (int item5 in item2)
			{
				array[item5] = new Color(zero.x, zero.y, zero.z);
			}
		}
		m.colors = array;
	}
}
[RequireComponent(typeof(ParticleSystem))]
public class ParticleSeekOptimized : MonoBehaviour
{
	public Transform target;

	public float force = 10f;

	private ParticleSystem particleSystem;

	private ParticleSystem.Particle[] particles;

	private ParticleSystem.MainModule particleSystemMainModule;

	private void Start()
	{
		particleSystem = GetComponent<ParticleSystem>();
		particleSystemMainModule = particleSystem.main;
	}

	private void LateUpdate()
	{
		int maxParticles = particleSystemMainModule.maxParticles;
		if (particles == null || particles.Length < maxParticles)
		{
			particles = new ParticleSystem.Particle[maxParticles];
		}
		particleSystem.GetParticles(particles);
		float num = force * Time.deltaTime;
		Vector3 vector = particleSystemMainModule.simulationSpace switch
		{
			ParticleSystemSimulationSpace.Local => base.transform.InverseTransformPoint(target.position), 
			ParticleSystemSimulationSpace.Custom => particleSystemMainModule.customSimulationSpace.InverseTransformPoint(target.position), 
			ParticleSystemSimulationSpace.World => target.position, 
			_ => throw new NotSupportedException($"Unsupported simulation space '{Enum.GetName(typeof(ParticleSystemSimulationSpace), particleSystemMainModule.simulationSpace)}'."), 
		};
		int particleCount = particleSystem.particleCount;
		for (int i = 0; i < particleCount; i++)
		{
			Vector3 vector2 = Vector3.Normalize(vector - particles[i].position) * num;
			particles[i].velocity += vector2;
		}
		particleSystem.SetParticles(particles, particleCount);
	}
}
public class LipSyncTest : MonoBehaviour
{
	public LipSync ls;

	public LipSyncData data1;

	public LipSyncData data2;

	public LipSyncData data3;

	public LipSyncData data4;

	public LipSyncData data5;

	public void Play1()
	{
		ls.Play(data1);
	}

	public void Play2()
	{
		ls.Play(data2);
	}

	public void Play3()
	{
		ls.Play(data3);
	}

	public void Play4()
	{
		ls.Play(data4);
	}

	public void Play5()
	{
		ls.Play(data5);
	}
}
public class enableDelay : MonoBehaviour
{
	public float time = 5f;

	public Camera cam;

	private void Update()
	{
		if (time > 0f)
		{
			time -= Time.deltaTime;
			if (time <= 0f)
			{
				cam.enabled = true;
			}
		}
	}
}
public class pulse : MonoBehaviour
{
	public Color pulseColour;

	private Color _pulseColour;

	public Color startColour;

	public float pulseDuration = 1f;

	private float _timer;

	private Renderer _renderer;

	private void Start()
	{
		_renderer = GetComponent<Renderer>();
		startColour = _renderer.materials[0].GetColor("_EmissionColor");
		_pulseColour *= Mathf.LinearToGammaSpace(1f);
		GameManager instance = GameManager.instance;
		instance._pulse = (GameManager.LightsPulse)Delegate.Combine(instance._pulse, new GameManager.LightsPulse(Pulse));
	}

	private void Update()
	{
		if (_timer > 0f)
		{
			_renderer.materials[0].SetColor("_EmissionColor", Color.Lerp(startColour, pulseColour, Mathf.InverseLerp(0f, pulseDuration, _timer)));
			_timer -= Time.deltaTime;
			if (_timer <= 0f)
			{
				_renderer.materials[0].SetColor("_EmissionColor", startColour);
				_timer = 0f;
			}
		}
	}

	public void Pulse()
	{
		_renderer.materials[0].SetColor("_EmissionColor", pulseColour);
		_timer = pulseDuration;
	}
}
namespace Tayx.Graphy
{
	public class GraphyDebugger : Singleton<GraphyDebugger>
	{
		public enum DebugVariable
		{
			Fps,
			Fps_Min,
			Fps_Max,
			Fps_Avg,
			Ram_Allocated,
			Ram_Reserved,
			Ram_Mono,
			Audio_DB
		}

		public enum DebugComparer
		{
			Less_than,
			Equals_or_less_than,
			Equals,
			Equals_or_greater_than,
			Greater_than
		}

		public enum ConditionEvaluation
		{
			All_conditions_must_be_met,
			Only_one_condition_has_to_be_met
		}

		public enum MessageType
		{
			Log,
			Warning,
			Error
		}

		[Serializable]
		public struct DebugCondition
		{
			[Tooltip("Variable to compare against")]
			public DebugVariable Variable;

			[Tooltip("Comparer operator to use")]
			public DebugComparer Comparer;

			[Tooltip("Value to compare against the chosen variable")]
			public float Value;
		}

		[Serializable]
		public class DebugPacket
		{
			[Tooltip("If false, it won't be checked")]
			public bool Active = true;

			[Tooltip("Optional Id. It's used to get or remove DebugPackets in runtime")]
			public int Id;

			[Tooltip("If true, once the actions are executed, this DebugPacket will delete itself")]
			public bool ExecuteOnce = true;

			[Tooltip("Time to wait before checking if conditions are met (use this to avoid low fps drops triggering the conditions when loading the game)")]
			public float InitSleepTime = 2f;

			[Tooltip("Time to wait before checking if conditions are met again (once they have already been met and if ExecuteOnce is false)")]
			public float ExecuteSleepTime = 2f;

			public ConditionEvaluation ConditionEvaluation;

			[Tooltip("List of conditions that will be checked each frame")]
			public List<DebugCondition> DebugConditions = new List<DebugCondition>();

			public MessageType MessageType;

			[Multiline]
			public string Message = string.Empty;

			public bool TakeScreenshot;

			public string ScreenshotFileName = "Graphy_Screenshot";

			[Tooltip("If true, it pauses the editor")]
			public bool DebugBreak;

			public UnityEvent UnityEvents;

			public List<Action> Callbacks = new List<Action>();

			private bool canBeChecked;

			private bool executed;

			private float timePassed;

			public bool Check => canBeChecked;

			public void Update()
			{
				if (!canBeChecked)
				{
					timePassed += Time.deltaTime;
					if ((executed && timePassed >= ExecuteSleepTime) || (!executed && timePassed >= InitSleepTime))
					{
						canBeChecked = true;
						timePassed = 0f;
					}
				}
			}

			public void Executed()
			{
				canBeChecked = false;
				executed = true;
			}
		}

		private FpsMonitor m_fpsMonitor;

		private RamMonitor m_ramMonitor;

		private AudioMonitor m_audioMonitor;

		[SerializeField]
		private List<DebugPacket> m_debugPackets;

		protected GraphyDebugger()
		{
		}

		private void Start()
		{
			m_fpsMonitor = GetComponentInChildren<FpsMonitor>();
			m_ramMonitor = GetComponentInChildren<RamMonitor>();
			m_audioMonitor = GetComponentInChildren<AudioMonitor>();
		}

		private void Update()
		{
			CheckDebugPackets();
		}

		public void AddNewDebugPacket(DebugPacket newDebugPacket)
		{
			m_debugPackets.Add(newDebugPacket);
		}

		public void AddNewDebugPacket(int newId, DebugCondition newDebugCondition, MessageType newMessageType, string newMessage, bool newDebugBreak, Action newCallback)
		{
			DebugPacket debugPacket = new DebugPacket();
			debugPacket.Id = newId;
			debugPacket.DebugConditions.Add(newDebugCondition);
			debugPacket.MessageType = newMessageType;
			debugPacket.Message = newMessage;
			debugPacket.DebugBreak = newDebugBreak;
			debugPacket.Callbacks.Add(newCallback);
			AddNewDebugPacket(debugPacket);
		}

		public void AddNewDebugPacket(int newId, List<DebugCondition> newDebugConditions, MessageType newMessageType, string newMessage, bool newDebugBreak, Action newCallback)
		{
			DebugPacket debugPacket = new DebugPacket();
			debugPacket.Id = newId;
			debugPacket.DebugConditions = newDebugConditions;
			debugPacket.MessageType = newMessageType;
			debugPacket.Message = newMessage;
			debugPacket.DebugBreak = newDebugBreak;
			debugPacket.Callbacks.Add(newCallback);
			AddNewDebugPacket(debugPacket);
		}

		public void AddNewDebugPacket(int newId, DebugCondition newDebugCondition, MessageType newMessageType, string newMessage, bool newDebugBreak, List<Action> newCallbacks)
		{
			DebugPacket debugPacket = new DebugPacket();
			debugPacket.Id = newId;
			debugPacket.DebugConditions.Add(newDebugCondition);
			debugPacket.MessageType = newMessageType;
			debugPacket.Message = newMessage;
			debugPacket.DebugBreak = newDebugBreak;
			debugPacket.Callbacks = newCallbacks;
			AddNewDebugPacket(debugPacket);
		}

		public void AddNewDebugPacket(int newId, List<DebugCondition> newDebugConditions, MessageType newMessageType, string newMessage, bool newDebugBreak, List<Action> newCallbacks)
		{
			DebugPacket debugPacket = new DebugPacket();
			debugPacket.Id = newId;
			debugPacket.DebugConditions = newDebugConditions;
			debugPacket.MessageType = newMessageType;
			debugPacket.Message = newMessage;
			debugPacket.DebugBreak = newDebugBreak;
			debugPacket.Callbacks = newCallbacks;
			AddNewDebugPacket(debugPacket);
		}

		public DebugPacket GetFirstDebugPacketWithId(int packetId)
		{
			return m_debugPackets.First((DebugPacket x) => x.Id == packetId);
		}

		public List<DebugPacket> GetAllDebugPacketsWithId(int packetId)
		{
			return m_debugPackets.FindAll((DebugPacket x) => x.Id == packetId);
		}

		public void RemoveFirstDebugPacketWithId(int packetId)
		{
			m_debugPackets.Remove(GetFirstDebugPacketWithId(packetId));
		}

		public void RemoveAllDebugPacketsWithId(int packetId)
		{
			m_debugPackets.RemoveAll((DebugPacket x) => x.Id == packetId);
		}

		public void AddCallbackToFirstDebugPacketWithId(Action callback, int id)
		{
			GetFirstDebugPacketWithId(id).Callbacks.Add(callback);
		}

		public void AddCallbackToAllDebugPacketWithId(Action callback, int id)
		{
			foreach (DebugPacket item in GetAllDebugPacketsWithId(id))
			{
				item.Callbacks.Add(callback);
			}
		}

		private void CheckDebugPackets()
		{
			List<DebugPacket> list = new List<DebugPacket>();
			foreach (DebugPacket debugPacket in m_debugPackets)
			{
				if (!debugPacket.Active)
				{
					continue;
				}
				debugPacket.Update();
				if (!debugPacket.Check)
				{
					continue;
				}
				switch (debugPacket.ConditionEvaluation)
				{
				case ConditionEvaluation.All_conditions_must_be_met:
				{
					int num = 0;
					foreach (DebugCondition debugCondition in debugPacket.DebugConditions)
					{
						if (CheckIfConditionIsMet(debugCondition))
						{
							num++;
						}
					}
					if (num >= debugPacket.DebugConditions.Count)
					{
						ExecuteOperationsInDebugPacket(debugPacket);
						if (debugPacket.ExecuteOnce)
						{
							list.Add(debugPacket);
						}
					}
					break;
				}
				case ConditionEvaluation.Only_one_condition_has_to_be_met:
					foreach (DebugCondition debugCondition2 in debugPacket.DebugConditions)
					{
						if (CheckIfConditionIsMet(debugCondition2))
						{
							ExecuteOperationsInDebugPacket(debugPacket);
							if (debugPacket.ExecuteOnce)
							{
								list.Add(debugPacket);
							}
							break;
						}
					}
					break;
				}
			}
			foreach (DebugPacket item in list)
			{
				m_debugPackets.Remove(item);
			}
		}

		private bool CheckIfConditionIsMet(DebugCondition debugCondition)
		{
			return debugCondition.Comparer switch
			{
				DebugComparer.Less_than => GetRequestedValueFromDebugVariable(debugCondition.Variable) < debugCondition.Value, 
				DebugComparer.Equals_or_less_than => GetRequestedValueFromDebugVariable(debugCondition.Variable) <= debugCondition.Value, 
				DebugComparer.Equals => Mathf.Approximately(GetRequestedValueFromDebugVariable(debugCondition.Variable), debugCondition.Value), 
				DebugComparer.Equals_or_greater_than => GetRequestedValueFromDebugVariable(debugCondition.Variable) >= debugCondition.Value, 
				DebugComparer.Greater_than => GetRequestedValueFromDebugVariable(debugCondition.Variable) > debugCondition.Value, 
				_ => false, 
			};
		}

		private float GetRequestedValueFromDebugVariable(DebugVariable debugVariable)
		{
			return debugVariable switch
			{
				DebugVariable.Fps => m_fpsMonitor.CurrentFPS, 
				DebugVariable.Fps_Min => m_fpsMonitor.MinFPS, 
				DebugVariable.Fps_Max => m_fpsMonitor.MaxFPS, 
				DebugVariable.Fps_Avg => m_fpsMonitor.AverageFPS, 
				DebugVariable.Ram_Allocated => m_ramMonitor.AllocatedRam, 
				DebugVariable.Ram_Reserved => m_ramMonitor.AllocatedRam, 
				DebugVariable.Ram_Mono => m_ramMonitor.AllocatedRam, 
				DebugVariable.Audio_DB => m_audioMonitor.MaxDB, 
				_ => 0f, 
			};
		}

		private void ExecuteOperationsInDebugPacket(DebugPacket debugPacket)
		{
			if (debugPacket.DebugBreak)
			{
				UnityEngine.Debug.Break();
			}
			if (debugPacket.Message != "")
			{
				string message = "[Graphy] (" + DateTime.Now.ToString() + "): " + debugPacket.Message;
				switch (debugPacket.MessageType)
				{
				case MessageType.Log:
					UnityEngine.Debug.Log(message);
					break;
				case MessageType.Warning:
					UnityEngine.Debug.LogWarning(message);
					break;
				case MessageType.Error:
					UnityEngine.Debug.LogError(message);
					break;
				}
			}
			if (debugPacket.TakeScreenshot)
			{
				ScreenCapture.CaptureScreenshot((debugPacket.ScreenshotFileName + "_" + DateTime.Now.ToString() + ".png").Replace("/", "-").Replace(" ", "_").Replace(":", "-"));
			}
			debugPacket.UnityEvents.Invoke();
			foreach (Action callback in debugPacket.Callbacks)
			{
				callback?.Invoke();
			}
			debugPacket.Executed();
		}
	}
	public class GraphyManager : Singleton<GraphyManager>
	{
		public enum Mode
		{
			FULL,
			LIGHT
		}

		public enum ModuleType
		{
			FPS,
			RAM,
			AUDIO,
			ADVANCED
		}

		public enum ModuleState
		{
			FULL,
			TEXT,
			BASIC,
			BACKGROUND,
			OFF
		}

		public enum ModulePosition
		{
			TOP_RIGHT,
			TOP_LEFT,
			BOTTOM_RIGHT,
			BOTTOM_LEFT
		}

		public enum LookForAudioListener
		{
			ALWAYS,
			ON_SCENE_LOAD,
			NEVER
		}

		public enum ModulePreset
		{
			FPS_BASIC,
			FPS_TEXT,
			FPS_FULL,
			FPS_TEXT_RAM_TEXT,
			FPS_FULL_RAM_TEXT,
			FPS_FULL_RAM_FULL,
			FPS_TEXT_RAM_TEXT_AUDIO_TEXT,
			FPS_FULL_RAM_TEXT_AUDIO_TEXT,
			FPS_FULL_RAM_FULL_AUDIO_TEXT,
			FPS_FULL_RAM_FULL_AUDIO_FULL,
			FPS_FULL_RAM_FULL_AUDIO_FULL_ADVANCED_FULL,
			FPS_BASIC_ADVANCED_FULL
		}

		private FpsManager m_fpsManager;

		private RamManager m_ramManager;

		private AudioManager m_audioManager;

		private AdvancedData m_advancedData;

		private FpsMonitor m_fpsMonitor;

		private RamMonitor m_ramMonitor;

		private AudioMonitor m_audioMonitor;

		[SerializeField]
		private Mode m_graphyMode;

		private ModulePreset m_modulePresetState = ModulePreset.FPS_BASIC_ADVANCED_FULL;

		private bool m_active = true;

		[SerializeField]
		private bool m_keepAlive = true;

		[SerializeField]
		private bool m_background = true;

		[SerializeField]
		private Color m_backgroundColor = new Color(0f, 0f, 0f, 0.3f);

		[SerializeField]
		private KeyCode m_toggleModeKeyCode = KeyCode.G;

		[SerializeField]
		private bool m_toggleModeCtrl = true;

		[SerializeField]
		private bool m_toggleModeAlt;

		[SerializeField]
		private KeyCode m_toggleActiveKeyCode = KeyCode.H;

		[SerializeField]
		private bool m_toggleActiveCtrl = true;

		[SerializeField]
		private bool m_toggleActiveAlt;

		[SerializeField]
		private ModulePosition m_graphModulePosition;

		[SerializeField]
		private ModuleState m_fpsModuleState;

		[Range(0f, 200f)]
		[Tooltip("Time (in seconds) to reset the minimum and maximum framerates if they don't change in the specified time. Set to 0 if you don't want it to reset.")]
		[SerializeField]
		private int m_timeToResetMinMaxFps = 10;

		[SerializeField]
		private Color m_goodFpsColor = new Color32(118, 212, 58, byte.MaxValue);

		[SerializeField]
		private int m_goodFpsThreshold = 60;

		[SerializeField]
		private Color m_cautionFpsColor = new Color32(243, 232, 0, byte.MaxValue);

		[SerializeField]
		private int m_cautionFpsThreshold = 30;

		[SerializeField]
		private Color m_criticalFpsColor = new Color32(220, 41, 30, byte.MaxValue);

		[Range(10f, 300f)]
		[SerializeField]
		private int m_fpsGraphResolution = 150;

		[Range(1f, 200f)]
		[SerializeField]
		private int m_fpsTextUpdateRate = 3;

		[SerializeField]
		private ModuleState m_ramModuleState;

		[SerializeField]
		private Color m_allocatedRamColor = new Color32(byte.MaxValue, 190, 60, byte.MaxValue);

		[SerializeField]
		private Color m_reservedRamColor = new Color32(205, 84, 229, byte.MaxValue);

		[SerializeField]
		private Color m_monoRamColor = new Color(0.3f, 0.65f, 1f, 1f);

		[Range(10f, 300f)]
		[SerializeField]
		private int m_ramGraphResolution = 150;

		[Range(1f, 200f)]
		[SerializeField]
		private int m_ramTextUpdateRate = 3;

		[SerializeField]
		private ModuleState m_audioModuleState;

		[SerializeField]
		private LookForAudioListener m_findAudioListenerInCameraIfNull = LookForAudioListener.ON_SCENE_LOAD;

		[SerializeField]
		private AudioListener m_audioListener;

		[SerializeField]
		private Color m_audioGraphColor = Color.white;

		[Range(10f, 300f)]
		[SerializeField]
		private int m_audioGraphResolution = 81;

		[Range(1f, 200f)]
		[SerializeField]
		private int m_audioTextUpdateRate = 3;

		[SerializeField]
		private FFTWindow m_FFTWindow = FFTWindow.Blackman;

		[Tooltip("Must be a power of 2 and between 64-8192")]
		[SerializeField]
		private int m_spectrumSize = 512;

		[SerializeField]
		private ModulePosition m_advancedModulePosition = ModulePosition.BOTTOM_LEFT;

		[SerializeField]
		private ModuleState m_advancedModuleState;

		public Mode GraphyMode
		{
			get
			{
				return m_graphyMode;
			}
			set
			{
				m_graphyMode = value;
				UpdateAllParameters();
			}
		}

		public bool KeepAlive => m_keepAlive;

		public bool Background
		{
			get
			{
				return m_background;
			}
			set
			{
				m_background = value;
				UpdateAllParameters();
			}
		}

		public Color BackgroundColor
		{
			get
			{
				return m_backgroundColor;
			}
			set
			{
				m_backgroundColor = value;
				UpdateAllParameters();
			}
		}

		public ModulePosition GraphModulePosition
		{
			get
			{
				return m_graphModulePosition;
			}
			set
			{
				m_graphModulePosition = value;
				m_fpsManager.SetPosition(m_graphModulePosition);
				m_ramManager.SetPosition(m_graphModulePosition);
				m_audioManager.SetPosition(m_graphModulePosition);
			}
		}

		public ModuleState FpsModuleState
		{
			get
			{
				return m_fpsModuleState;
			}
			set
			{
				m_fpsModuleState = value;
				m_fpsManager.SetState(m_fpsModuleState);
			}
		}

		public int TimeToResetMinMaxFps
		{
			get
			{
				return m_timeToResetMinMaxFps;
			}
			set
			{
				m_timeToResetMinMaxFps = value;
				m_fpsManager.UpdateParameters();
			}
		}

		public Color GoodFPSColor
		{
			get
			{
				return m_goodFpsColor;
			}
			set
			{
				m_goodFpsColor = value;
				m_fpsManager.UpdateParameters();
			}
		}

		public Color CautionFPSColor
		{
			get
			{
				return m_cautionFpsColor;
			}
			set
			{
				m_cautionFpsColor = value;
				m_fpsManager.UpdateParameters();
			}
		}

		public Color CriticalFPSColor
		{
			get
			{
				return m_criticalFpsColor;
			}
			set
			{
				m_criticalFpsColor = value;
				m_fpsManager.UpdateParameters();
			}
		}

		public int GoodFPSThreshold
		{
			get
			{
				return m_goodFpsThreshold;
			}
			set
			{
				m_goodFpsThreshold = value;
				m_fpsManager.UpdateParameters();
			}
		}

		public int CautionFPSThreshold
		{
			get
			{
				return m_cautionFpsThreshold;
			}
			set
			{
				m_cautionFpsThreshold = value;
				m_fpsManager.UpdateParameters();
			}
		}

		public int FpsGraphResolution
		{
			get
			{
				return m_fpsGraphResolution;
			}
			set
			{
				m_fpsGraphResolution = value;
				m_fpsManager.UpdateParameters();
			}
		}

		public int FpsTextUpdateRate
		{
			get
			{
				return m_fpsTextUpdateRate;
			}
			set
			{
				m_fpsTextUpdateRate = value;
				m_fpsManager.UpdateParameters();
			}
		}

		public float CurrentFPS => m_fpsMonitor.CurrentFPS;

		public float AverageFPS => m_fpsMonitor.AverageFPS;

		public float MinFPS => m_fpsMonitor.MinFPS;

		public float MaxFPS => m_fpsMonitor.MaxFPS;

		public ModuleState RamModuleState
		{
			get
			{
				return m_ramModuleState;
			}
			set
			{
				m_ramModuleState = value;
				m_ramManager.SetState(m_ramModuleState);
			}
		}

		public Color AllocatedRamColor
		{
			get
			{
				return m_allocatedRamColor;
			}
			set
			{
				m_allocatedRamColor = value;
				m_ramManager.UpdateParameters();
			}
		}

		public Color ReservedRamColor
		{
			get
			{
				return m_reservedRamColor;
			}
			set
			{
				m_reservedRamColor = value;
				m_ramManager.UpdateParameters();
			}
		}

		public Color MonoRamColor
		{
			get
			{
				return m_monoRamColor;
			}
			set
			{
				m_monoRamColor = value;
				m_ramManager.UpdateParameters();
			}
		}

		public int RamGraphResolution
		{
			get
			{
				return m_ramGraphResolution;
			}
			set
			{
				m_ramGraphResolution = value;
				m_ramManager.UpdateParameters();
			}
		}

		public int RamTextUpdateRate
		{
			get
			{
				return m_ramTextUpdateRate;
			}
			set
			{
				m_ramTextUpdateRate = value;
				m_ramManager.UpdateParameters();
			}
		}

		public float AllocatedRam => m_ramMonitor.AllocatedRam;

		public float ReservedRam => m_ramMonitor.ReservedRam;

		public float MonoRam => m_ramMonitor.MonoRam;

		public ModuleState AudioModuleState
		{
			get
			{
				return m_audioModuleState;
			}
			set
			{
				m_audioModuleState = value;
				m_audioManager.SetState(m_audioModuleState);
			}
		}

		public AudioListener AudioListener
		{
			get
			{
				return m_audioListener;
			}
			set
			{
				m_audioListener = value;
				m_audioManager.UpdateParameters();
			}
		}

		public LookForAudioListener FindAudioListenerInCameraIfNull
		{
			get
			{
				return m_findAudioListenerInCameraIfNull;
			}
			set
			{
				m_findAudioListenerInCameraIfNull = value;
				m_audioManager.UpdateParameters();
			}
		}

		public Color AudioGraphColor
		{
			get
			{
				return m_audioGraphColor;
			}
			set
			{
				m_audioGraphColor = value;
				m_audioManager.UpdateParameters();
			}
		}

		public int AudioGraphResolution
		{
			get
			{
				return m_audioGraphResolution;
			}
			set
			{
				m_audioGraphResolution = value;
				m_audioManager.UpdateParameters();
			}
		}

		public int AudioTextUpdateRate
		{
			get
			{
				return m_audioTextUpdateRate;
			}
			set
			{
				m_audioTextUpdateRate = value;
				m_audioManager.UpdateParameters();
			}
		}

		public FFTWindow FftWindow
		{
			get
			{
				return m_FFTWindow;
			}
			set
			{
				m_FFTWindow = value;
				m_audioManager.UpdateParameters();
			}
		}

		public int SpectrumSize
		{
			get
			{
				return m_spectrumSize;
			}
			set
			{
				m_spectrumSize = value;
				m_audioManager.UpdateParameters();
			}
		}

		public float[] Spectrum => m_audioMonitor.Spectrum;

		public float MaxDB => m_audioMonitor.MaxDB;

		public ModuleState AdvancedModuleState
		{
			get
			{
				return m_advancedModuleState;
			}
			set
			{
				m_advancedModuleState = value;
				m_advancedData.SetState(m_advancedModuleState);
			}
		}

		public ModulePosition AdvancedModulePosition
		{
			get
			{
				return m_advancedModulePosition;
			}
			set
			{
				m_advancedModulePosition = value;
				m_advancedData.SetPosition(m_advancedModulePosition);
			}
		}

		protected GraphyManager()
		{
		}

		private void Start()
		{
			Init();
		}

		private void Update()
		{
			CheckForHotkeyPresses();
		}

		public void SetModulePosition(ModuleType moduleType, ModulePosition modulePosition)
		{
			switch (moduleType)
			{
			case ModuleType.FPS:
			case ModuleType.RAM:
			case ModuleType.AUDIO:
				m_graphModulePosition = modulePosition;
				m_ramManager.SetPosition(modulePosition);
				m_fpsManager.SetPosition(modulePosition);
				m_audioManager.SetPosition(modulePosition);
				break;
			case ModuleType.ADVANCED:
				m_advancedData.SetPosition(modulePosition);
				break;
			}
		}

		public void SetModuleMode(ModuleType moduleType, ModuleState moduleState)
		{
			switch (moduleType)
			{
			case ModuleType.FPS:
				m_fpsManager.SetState(moduleState);
				break;
			case ModuleType.RAM:
				m_ramManager.SetState(moduleState);
				break;
			case ModuleType.AUDIO:
				m_audioManager.SetState(moduleState);
				break;
			case ModuleType.ADVANCED:
				m_advancedData.SetState(moduleState);
				break;
			}
		}

		public void ToggleModes()
		{
			if ((int)m_modulePresetState >= Enum.GetNames(typeof(ModulePreset)).Length - 1)
			{
				m_modulePresetState = ModulePreset.FPS_BASIC;
			}
			else
			{
				m_modulePresetState++;
			}
			SetPreset(m_modulePresetState);
		}

		public void SetPreset(ModulePreset modulePreset)
		{
			m_modulePresetState = modulePreset;
			switch (m_modulePresetState)
			{
			case ModulePreset.FPS_BASIC:
				m_fpsManager.SetState(ModuleState.BASIC);
				m_ramManager.SetState(ModuleState.OFF);
				m_audioManager.SetState(ModuleState.OFF);
				m_advancedData.SetState(ModuleState.OFF);
				break;
			case ModulePreset.FPS_TEXT:
				m_fpsManager.SetState(ModuleState.TEXT);
				m_ramManager.SetState(ModuleState.OFF);
				m_audioManager.SetState(ModuleState.OFF);
				m_advancedData.SetState(ModuleState.OFF);
				break;
			case ModulePreset.FPS_FULL:
				m_fpsManager.SetState(ModuleState.FULL);
				m_ramManager.SetState(ModuleState.OFF);
				m_audioManager.SetState(ModuleState.OFF);
				m_advancedData.SetState(ModuleState.OFF);
				break;
			case ModulePreset.FPS_TEXT_RAM_TEXT:
				m_fpsManager.SetState(ModuleState.TEXT);
				m_ramManager.SetState(ModuleState.TEXT);
				m_audioManager.SetState(ModuleState.OFF);
				m_advancedData.SetState(ModuleState.OFF);
				break;
			case ModulePreset.FPS_FULL_RAM_TEXT:
				m_fpsManager.SetState(ModuleState.FULL);
				m_ramManager.SetState(ModuleState.TEXT);
				m_audioManager.SetState(ModuleState.OFF);
				m_advancedData.SetState(ModuleState.OFF);
				break;
			case ModulePreset.FPS_FULL_RAM_FULL:
				m_fpsManager.SetState(ModuleState.FULL);
				m_ramManager.SetState(ModuleState.FULL);
				m_audioManager.SetState(ModuleState.OFF);
				m_advancedData.SetState(ModuleState.OFF);
				break;
			case ModulePreset.FPS_TEXT_RAM_TEXT_AUDIO_TEXT:
				m_fpsManager.SetState(ModuleState.TEXT);
				m_ramManager.SetState(ModuleState.TEXT);
				m_audioManager.SetState(ModuleState.TEXT);
				m_advancedData.SetState(ModuleState.OFF);
				break;
			case ModulePreset.FPS_FULL_RAM_TEXT_AUDIO_TEXT:
				m_fpsManager.SetState(ModuleState.FULL);
				m_ramManager.SetState(ModuleState.TEXT);
				m_audioManager.SetState(ModuleState.TEXT);
				m_advancedData.SetState(ModuleState.OFF);
				break;
			case ModulePreset.FPS_FULL_RAM_FULL_AUDIO_TEXT:
				m_fpsManager.SetState(ModuleState.FULL);
				m_ramManager.SetState(ModuleState.FULL);
				m_audioManager.SetState(ModuleState.TEXT);
				m_advancedData.SetState(ModuleState.OFF);
				break;
			case ModulePreset.FPS_FULL_RAM_FULL_AUDIO_FULL:
				m_fpsManager.SetState(ModuleState.FULL);
				m_ramManager.SetState(ModuleState.FULL);
				m_audioManager.SetState(ModuleState.FULL);
				m_advancedData.SetState(ModuleState.OFF);
				break;
			case ModulePreset.FPS_FULL_RAM_FULL_AUDIO_FULL_ADVANCED_FULL:
				m_fpsManager.SetState(ModuleState.FULL);
				m_ramManager.SetState(ModuleState.FULL);
				m_audioManager.SetState(ModuleState.FULL);
				m_advancedData.SetState(ModuleState.FULL);
				break;
			case ModulePreset.FPS_BASIC_ADVANCED_FULL:
				m_fpsManager.SetState(ModuleState.BASIC);
				m_ramManager.SetState(ModuleState.OFF);
				m_audioManager.SetState(ModuleState.OFF);
				m_advancedData.SetState(ModuleState.FULL);
				break;
			}
		}

		public void ToggleActive()
		{
			m_active = !m_active;
			if (m_active)
			{
				m_fpsManager.RestorePreviousState();
				m_ramManager.RestorePreviousState();
				m_audioManager.RestorePreviousState();
				m_advancedData.RestorePreviousState();
			}
			else
			{
				m_fpsManager.SetState(ModuleState.OFF);
				m_ramManager.SetState(ModuleState.OFF);
				m_audioManager.SetState(ModuleState.OFF);
				m_advancedData.SetState(ModuleState.OFF);
			}
		}

		private void Init()
		{
			if (m_keepAlive)
			{
				UnityEngine.Object.DontDestroyOnLoad(base.transform.root.gameObject);
			}
			m_fpsMonitor = GetComponentInChildren(typeof(FpsMonitor), includeInactive: true) as FpsMonitor;
			m_ramMonitor = GetComponentInChildren(typeof(RamMonitor), includeInactive: true) as RamMonitor;
			m_audioMonitor = GetComponentInChildren(typeof(AudioMonitor), includeInactive: true) as AudioMonitor;
			m_fpsManager = GetComponentInChildren(typeof(FpsManager), includeInactive: true) as FpsManager;
			m_ramManager = GetComponentInChildren(typeof(RamManager), includeInactive: true) as RamManager;
			m_audioManager = GetComponentInChildren(typeof(AudioManager), includeInactive: true) as AudioManager;
			m_advancedData = GetComponentInChildren(typeof(AdvancedData), includeInactive: true) as AdvancedData;
			m_fpsManager.SetPosition(m_graphModulePosition);
			m_ramManager.SetPosition(m_graphModulePosition);
			m_audioManager.SetPosition(m_graphModulePosition);
			m_advancedData.SetPosition(m_advancedModulePosition);
			m_fpsManager.SetState(m_fpsModuleState);
			m_ramManager.SetState(m_ramModuleState);
			m_audioManager.SetState(m_audioModuleState);
			m_advancedData.SetState(m_advancedModuleState);
		}

		private void CheckForHotkeyPresses()
		{
			if (m_toggleModeCtrl && m_toggleModeAlt)
			{
				if (CheckFor3KeyPress(m_toggleModeKeyCode, KeyCode.LeftControl, KeyCode.LeftAlt) || CheckFor3KeyPress(m_toggleModeKeyCode, KeyCode.RightControl, KeyCode.LeftAlt) || CheckFor3KeyPress(m_toggleModeKeyCode, KeyCode.RightControl, KeyCode.RightAlt) || CheckFor3KeyPress(m_toggleModeKeyCode, KeyCode.LeftControl, KeyCode.RightAlt))
				{
					ToggleModes();
				}
			}
			else if (m_toggleModeCtrl)
			{
				if (CheckFor2KeyPress(m_toggleModeKeyCode, KeyCode.LeftControl) || CheckFor2KeyPress(m_toggleModeKeyCode, KeyCode.RightControl))
				{
					ToggleModes();
				}
			}
			else if (m_toggleModeAlt)
			{
				if (CheckFor2KeyPress(m_toggleModeKeyCode, KeyCode.LeftAlt) || CheckFor2KeyPress(m_toggleModeKeyCode, KeyCode.RightAlt))
				{
					ToggleModes();
				}
			}
			else if (CheckFor1KeyPress(m_toggleModeKeyCode))
			{
				ToggleModes();
			}
			if (m_toggleActiveCtrl && m_toggleActiveAlt)
			{
				if (CheckFor3KeyPress(m_toggleActiveKeyCode, KeyCode.LeftControl, KeyCode.LeftAlt) || CheckFor3KeyPress(m_toggleActiveKeyCode, KeyCode.RightControl, KeyCode.LeftAlt) || CheckFor3KeyPress(m_toggleActiveKeyCode, KeyCode.RightControl, KeyCode.RightAlt) || CheckFor3KeyPress(m_toggleActiveKeyCode, KeyCode.LeftControl, KeyCode.RightAlt))
				{
					ToggleActive();
				}
			}
			else if (m_toggleActiveCtrl)
			{
				if (CheckFor2KeyPress(m_toggleActiveKeyCode, KeyCode.LeftControl) || CheckFor2KeyPress(m_toggleActiveKeyCode, KeyCode.RightControl))
				{
					ToggleActive();
				}
			}
			else if (m_toggleActiveAlt)
			{
				if (CheckFor2KeyPress(m_toggleActiveKeyCode, KeyCode.LeftAlt) || CheckFor2KeyPress(m_toggleActiveKeyCode, KeyCode.RightAlt))
				{
					ToggleActive();
				}
			}
			else if (CheckFor1KeyPress(m_toggleActiveKeyCode))
			{
				ToggleActive();
			}
		}

		private bool CheckFor1KeyPress(KeyCode key)
		{
			return Input.GetKeyDown(key);
		}

		private bool CheckFor2KeyPress(KeyCode key1, KeyCode key2)
		{
			if (!Input.GetKeyDown(key1) || !Input.GetKey(key2))
			{
				if (Input.GetKeyDown(key2))
				{
					return Input.GetKey(key1);
				}
				return false;
			}
			return true;
		}

		private bool CheckFor3KeyPress(KeyCode key1, KeyCode key2, KeyCode key3)
		{
			if ((!Input.GetKeyDown(key1) || !Input.GetKey(key2) || !Input.GetKey(key3)) && (!Input.GetKeyDown(key2) || !Input.GetKey(key1) || !Input.GetKey(key3)))
			{
				if (Input.GetKeyDown(key3) && Input.GetKey(key1))
				{
					return Input.GetKey(key2);
				}
				return false;
			}
			return true;
		}

		private void UpdateAllParameters()
		{
			m_fpsManager.UpdateParameters();
			m_ramManager.UpdateParameters();
			m_audioManager.UpdateParameters();
			m_advancedData.UpdateParameters();
		}
	}
	public class ShaderGraph
	{
		public const int ArrayMaxSizeFull = 512;

		public const int ArrayMaxSizeLight = 128;

		public int ArrayMaxSize = 128;

		public Image Image;

		private string Name = "GraphValues";

		private string Name_Length = "GraphValues_Length";

		public float[] Array;

		public float Average;

		private int averagePropertyId;

		public float GoodThreshold;

		public float CautionThreshold;

		private int goodThresholdPropertyId;

		private int cautionThresholdPropertyId;

		public Color GoodColor;

		public Color CautionColor;

		public Color CriticalColor;

		private int goodColorPropertyId;

		private int cautionColorPropertyId;

		private int criticalColorPropertyId;

		public void InitializeShader()
		{
			Image.material.SetFloatArray(Name, new float[ArrayMaxSize]);
			averagePropertyId = Shader.PropertyToID("Average");
			goodThresholdPropertyId = Shader.PropertyToID("_GoodThreshold");
			cautionThresholdPropertyId = Shader.PropertyToID("_CautionThreshold");
			goodColorPropertyId = Shader.PropertyToID("_GoodColor");
			cautionColorPropertyId = Shader.PropertyToID("_CautionColor");
			criticalColorPropertyId = Shader.PropertyToID("_CriticalColor");
		}

		public void UpdateArray()
		{
			Image.material.SetInt(Name_Length, Array.Length);
		}

		public void UpdateAverage()
		{
			Image.material.SetFloat(averagePropertyId, Average);
		}

		public void UpdateThresholds()
		{
			Image.material.SetFloat(goodThresholdPropertyId, GoodThreshold);
			Image.material.SetFloat(cautionThresholdPropertyId, CautionThreshold);
		}

		public void UpdateColors()
		{
			Image.material.SetColor(goodColorPropertyId, GoodColor);
			Image.material.SetColor(cautionColorPropertyId, CautionColor);
			Image.material.SetColor(criticalColorPropertyId, CriticalColor);
		}

		public void UpdatePoints()
		{
			Image.material.SetFloatArray(Name, Array);
		}
	}
}
namespace Tayx.Graphy.Utils
{
	public static class ExtensionMethods
	{
		public static List<GameObject> SetAllActive(this List<GameObject> gameObjects, bool active)
		{
			foreach (GameObject gameObject in gameObjects)
			{
				gameObject.SetActive(active);
			}
			return gameObjects;
		}

		public static List<Image> SetOneActive(this List<Image> images, int active)
		{
			for (int i = 0; i < images.Count; i++)
			{
				images[i].gameObject.SetActive(i == active);
			}
			return images;
		}

		public static List<Image> SetAllActive(this List<Image> images, bool active)
		{
			foreach (Image image in images)
			{
				image.gameObject.SetActive(active);
			}
			return images;
		}
	}
	public static class IntString
	{
		public static string[] positiveBuffer = new string[0];

		public static string[] negativeBuffer = new string[0];

		public static float maxValue => positiveBuffer.Length;

		public static float minValue => negativeBuffer.Length;

		public static bool Inited
		{
			get
			{
				if (positiveBuffer.Length == 0)
				{
					return negativeBuffer.Length != 0;
				}
				return true;
			}
		}

		public static void Init(int minNegativeValue, int maxPositiveValue)
		{
			if (maxPositiveValue >= 0)
			{
				positiveBuffer = new string[maxPositiveValue];
				for (int i = 0; i < maxPositiveValue; i++)
				{
					positiveBuffer[i] = i.ToString();
				}
			}
			if (minNegativeValue <= 0)
			{
				int num = Mathf.Abs(minNegativeValue);
				negativeBuffer = new string[num];
				for (int j = 0; j < num; j++)
				{
					negativeBuffer[j] = (-j).ToString();
				}
			}
		}

		public static string ToStringNonAlloc(this int value)
		{
			if (value >= 0 && value < positiveBuffer.Length)
			{
				return positiveBuffer[value];
			}
			if (value < 0 && -value < negativeBuffer.Length)
			{
				return negativeBuffer[-value];
			}
			return value.ToString();
		}
	}
	public static class FloatString
	{
		private static float decimalMultiplayer = 1f;

		public static string[] positiveBuffer = new string[0];

		public static string[] negativeBuffer = new string[0];

		public static bool Inited
		{
			get
			{
				if (positiveBuffer.Length == 0)
				{
					return negativeBuffer.Length != 0;
				}
				return true;
			}
		}

		public static float maxValue => (positiveBuffer.Length - 1).FromIndex();

		public static float minValue => 0f - (negativeBuffer.Length - 1).FromIndex();

		public static void Init(float minNegativeValue, float maxPositiveValue, int deciminals = 1)
		{
			decimalMultiplayer = Pow(10, Mathf.Clamp(deciminals, 1, 5));
			int num = minNegativeValue.ToIndex();
			int num2 = maxPositiveValue.ToIndex();
			if (num2 >= 0)
			{
				positiveBuffer = new string[num2];
				for (int i = 0; i < num2; i++)
				{
					positiveBuffer[i] = i.FromIndex().ToString("0.0");
				}
			}
			if (num >= 0)
			{
				negativeBuffer = new string[num];
				for (int j = 0; j < num; j++)
				{
					negativeBuffer[j] = (-j).FromIndex().ToString("0.0");
				}
			}
		}

		public static string ToStringNonAlloc(this float value)
		{
			int num = value.ToIndex();
			if (value >= 0f && num < positiveBuffer.Length)
			{
				return positiveBuffer[num];
			}
			if (value < 0f && num < negativeBuffer.Length)
			{
				return negativeBuffer[num];
			}
			return value.ToString();
		}

		public static string ToStringNonAlloc(this float value, string format)
		{
			int num = value.ToIndex();
			if (value >= 0f && num < positiveBuffer.Length)
			{
				return positiveBuffer[num];
			}
			if (value < 0f && num < negativeBuffer.Length)
			{
				return negativeBuffer[num];
			}
			return value.ToString(format);
		}

		private static int Pow(int f, int p)
		{
			for (int i = 1; i < p; i++)
			{
				f *= f;
			}
			return f;
		}

		private static int ToIndex(this float f)
		{
			return Mathf.Abs((f * decimalMultiplayer).ToInt());
		}

		private static float FromIndex(this int i)
		{
			return i.ToFloat() / decimalMultiplayer;
		}

		public static int ToInt(this float f)
		{
			return (int)f;
		}

		public static float ToFloat(this int i)
		{
			return i;
		}
	}
	public class Singleton<T> : MonoBehaviour where T : MonoBehaviour
	{
		private static T _instance;

		private static object _lock = new object();

		private static bool _applicationIsQuitting = false;

		public static T Instance
		{
			get
			{
				if (_applicationIsQuitting)
				{
					return null;
				}
				lock (_lock)
				{
					if (_instance == null)
					{
						_instance = (T)UnityEngine.Object.FindObjectOfType(typeof(T));
						if (UnityEngine.Object.FindObjectsOfType(typeof(T)).Length > 1)
						{
							return _instance;
						}
						if (_instance == null)
						{
							UnityEngine.Debug.Log("[Singleton] An instance of " + typeof(T)?.ToString() + " is trying to be accessed, but it wasn't initialized first. Make sure to add an instance of " + typeof(T)?.ToString() + " in the scene before  trying to access it.");
						}
					}
					return _instance;
				}
			}
		}

		private void Awake()
		{
			if (_instance != null)
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
			else
			{
				_instance = GetComponent<T>();
			}
		}

		public void OnDestroy()
		{
			_applicationIsQuitting = true;
		}
	}
}
namespace Tayx.Graphy.UI
{
	public interface IModifiableState
	{
		void SetState(GraphyManager.ModuleState newState);
	}
	public interface IMovable
	{
		void SetPosition(GraphyManager.ModulePosition newModulePosition);
	}
}
namespace Tayx.Graphy.Ram
{
	public class RamGraph : Tayx.Graphy.Graph.Graph
	{
		private GraphyManager m_graphyManager;

		private RamMonitor m_ramMonitor;

		[SerializeField]
		private Image m_imageAllocated;

		[SerializeField]
		private Image m_imageReserved;

		[SerializeField]
		private Image m_imageMono;

		private int m_resolution = 150;

		private ShaderGraph m_shaderGraphAllocated;

		private ShaderGraph m_shaderGraphReserved;

		private ShaderGraph m_shaderGraphMono;

		public Shader ShaderFull;

		public Shader ShaderLight;

		private float[] m_allocatedArray;

		private float[] m_reservedArray;

		private float[] m_monoArray;

		private float m_highestMemory;

		private void Awake()
		{
			Init();
		}

		private void Update()
		{
			UpdateGraph();
		}

		public void UpdateParameters()
		{
			switch (m_graphyManager.GraphyMode)
			{
			case GraphyManager.Mode.FULL:
				m_shaderGraphAllocated.ArrayMaxSize = 512;
				m_shaderGraphReserved.ArrayMaxSize = 512;
				m_shaderGraphMono.ArrayMaxSize = 512;
				m_shaderGraphAllocated.Image.material = new Material(ShaderFull);
				m_shaderGraphReserved.Image.material = new Material(ShaderFull);
				m_shaderGraphMono.Image.material = new Material(ShaderFull);
				break;
			case GraphyManager.Mode.LIGHT:
				m_shaderGraphAllocated.ArrayMaxSize = 128;
				m_shaderGraphReserved.ArrayMaxSize = 128;
				m_shaderGraphMono.ArrayMaxSize = 128;
				m_shaderGraphAllocated.Image.material = new Material(ShaderLight);
				m_shaderGraphReserved.Image.material = new Material(ShaderLight);
				m_shaderGraphMono.Image.material = new Material(ShaderLight);
				break;
			}
			m_shaderGraphAllocated.InitializeShader();
			m_shaderGraphReserved.InitializeShader();
			m_shaderGraphMono.InitializeShader();
			m_resolution = m_graphyManager.RamGraphResolution;
			CreatePoints();
		}

		protected override void UpdateGraph()
		{
			float allocatedRam = m_ramMonitor.AllocatedRam;
			float reservedRam = m_ramMonitor.ReservedRam;
			float monoRam = m_ramMonitor.MonoRam;
			m_highestMemory = 0f;
			for (int i = 0; i <= m_resolution - 1; i++)
			{
				if (i >= m_resolution - 1)
				{
					m_allocatedArray[i] = allocatedRam;
					m_reservedArray[i] = reservedRam;
					m_monoArray[i] = monoRam;
				}
				else
				{
					m_allocatedArray[i] = m_allocatedArray[i + 1];
					m_reservedArray[i] = m_reservedArray[i + 1];
					m_monoArray[i] = m_monoArray[i + 1];
				}
				if (m_highestMemory < m_reservedArray[i])
				{
					m_highestMemory = m_reservedArray[i];
				}
			}
			for (int j = 0; j <= m_resolution - 1; j++)
			{
				m_shaderGraphAllocated.Array[j] = m_allocatedArray[j] / m_highestMemory;
				m_shaderGraphReserved.Array[j] = m_reservedArray[j] / m_highestMemory;
				m_shaderGraphMono.Array[j] = m_monoArray[j] / m_highestMemory;
			}
			m_shaderGraphAllocated.UpdatePoints();
			m_shaderGraphReserved.UpdatePoints();
			m_shaderGraphMono.UpdatePoints();
		}

		protected override void CreatePoints()
		{
			m_shaderGraphAllocated.Array = new float[m_resolution];
			m_shaderGraphReserved.Array = new float[m_resolution];
			m_shaderGraphMono.Array = new float[m_resolution];
			m_allocatedArray = new float[m_resolution];
			m_reservedArray = new float[m_resolution];
			m_monoArray = new float[m_resolution];
			for (int i = 0; i < m_resolution; i++)
			{
				m_shaderGraphAllocated.Array[i] = 0f;
				m_shaderGraphReserved.Array[i] = 0f;
				m_shaderGraphMono.Array[i] = 0f;
			}
			m_shaderGraphAllocated.GoodColor = m_graphyManager.AllocatedRamColor;
			m_shaderGraphAllocated.CautionColor = m_graphyManager.AllocatedRamColor;
			m_shaderGraphAllocated.CriticalColor = m_graphyManager.AllocatedRamColor;
			m_shaderGraphAllocated.UpdateColors();
			m_shaderGraphReserved.GoodColor = m_graphyManager.ReservedRamColor;
			m_shaderGraphReserved.CautionColor = m_graphyManager.ReservedRamColor;
			m_shaderGraphReserved.CriticalColor = m_graphyManager.ReservedRamColor;
			m_shaderGraphReserved.UpdateColors();
			m_shaderGraphMono.GoodColor = m_graphyManager.MonoRamColor;
			m_shaderGraphMono.CautionColor = m_graphyManager.MonoRamColor;
			m_shaderGraphMono.CriticalColor = m_graphyManager.MonoRamColor;
			m_shaderGraphMono.UpdateColors();
			m_shaderGraphAllocated.GoodThreshold = 0f;
			m_shaderGraphAllocated.CautionThreshold = 0f;
			m_shaderGraphAllocated.UpdateThresholds();
			m_shaderGraphReserved.GoodThreshold = 0f;
			m_shaderGraphReserved.CautionThreshold = 0f;
			m_shaderGraphReserved.UpdateThresholds();
			m_shaderGraphMono.GoodThreshold = 0f;
			m_shaderGraphMono.CautionThreshold = 0f;
			m_shaderGraphMono.UpdateThresholds();
			m_shaderGraphAllocated.UpdateArray();
			m_shaderGraphReserved.UpdateArray();
			m_shaderGraphMono.UpdateArray();
			m_shaderGraphAllocated.Average = 0f;
			m_shaderGraphReserved.Average = 0f;
			m_shaderGraphMono.Average = 0f;
			m_shaderGraphAllocated.UpdateAverage();
			m_shaderGraphReserved.UpdateAverage();
			m_shaderGraphMono.UpdateAverage();
		}

		private void Init()
		{
			m_graphyManager = base.transform.root.GetComponentInChildren<GraphyManager>();
			m_ramMonitor = GetComponent<RamMonitor>();
			m_shaderGraphAllocated = new ShaderGraph();
			m_shaderGraphReserved = new ShaderGraph();
			m_shaderGraphMono = new ShaderGraph();
			m_shaderGraphAllocated.Image = m_imageAllocated;
			m_shaderGraphReserved.Image = m_imageReserved;
			m_shaderGraphMono.Image = m_imageMono;
			UpdateParameters();
		}
	}
	public class RamManager : MonoBehaviour, IMovable, IModifiableState
	{
		private GraphyManager m_graphyManager;

		private RamGraph m_ramGraph;

		private RamText m_ramText;

		private RectTransform m_rectTransform;

		[SerializeField]
		private GameObject m_ramGraphGameObject;

		private List<GameObject> m_childrenGameObjects = new List<GameObject>();

		[SerializeField]
		private List<Image> m_backgroundImages = new List<Image>();

		private GraphyManager.ModuleState m_previousModuleState;

		private GraphyManager.ModuleState m_currentModuleState;

		private void Awake()
		{
			Init();
		}

		private void Start()
		{
			UpdateParameters();
		}

		public void SetPosition(GraphyManager.ModulePosition newModulePosition)
		{
			float num = Mathf.Abs(m_rectTransform.anchoredPosition.x);
			float num2 = Mathf.Abs(m_rectTransform.anchoredPosition.y);
			switch (newModulePosition)
			{
			case GraphyManager.ModulePosition.TOP_LEFT:
				m_rectTransform.anchorMax = Vector2.up;
				m_rectTransform.anchorMin = Vector2.up;
				m_rectTransform.anchoredPosition = new Vector2(num, 0f - num2);
				break;
			case GraphyManager.ModulePosition.TOP_RIGHT:
				m_rectTransform.anchorMax = Vector2.one;
				m_rectTransform.anchorMin = Vector2.one;
				m_rectTransform.anchoredPosition = new Vector2(0f - num, 0f - num2);
				break;
			case GraphyManager.ModulePosition.BOTTOM_LEFT:
				m_rectTransform.anchorMax = Vector2.zero;
				m_rectTransform.anchorMin = Vector2.zero;
				m_rectTransform.anchoredPosition = new Vector2(num, num2);
				break;
			case GraphyManager.ModulePosition.BOTTOM_RIGHT:
				m_rectTransform.anchorMax = Vector2.right;
				m_rectTransform.anchorMin = Vector2.right;
				m_rectTransform.anchoredPosition = new Vector2(0f - num, num2);
				break;
			}
		}

		public void SetState(GraphyManager.ModuleState state)
		{
			m_previousModuleState = m_currentModuleState;
			m_currentModuleState = state;
			switch (state)
			{
			case GraphyManager.ModuleState.FULL:
				base.gameObject.SetActive(value: true);
				m_childrenGameObjects.SetAllActive(active: true);
				SetGraphActive(active: true);
				if (m_graphyManager.Background)
				{
					m_backgroundImages.SetOneActive(0);
				}
				else
				{
					m_backgroundImages.SetAllActive(active: false);
				}
				break;
			case GraphyManager.ModuleState.TEXT:
			case GraphyManager.ModuleState.BASIC:
				base.gameObject.SetActive(value: true);
				m_childrenGameObjects.SetAllActive(active: true);
				SetGraphActive(active: false);
				if (m_graphyManager.Background)
				{
					m_backgroundImages.SetOneActive(1);
				}
				else
				{
					m_backgroundImages.SetAllActive(active: false);
				}
				break;
			case GraphyManager.ModuleState.BACKGROUND:
				base.gameObject.SetActive(value: true);
				SetGraphActive(active: false);
				m_childrenGameObjects.SetAllActive(active: false);
				m_backgroundImages.SetAllActive(active: false);
				break;
			case GraphyManager.ModuleState.OFF:
				base.gameObject.SetActive(value: false);
				break;
			}
		}

		public void RestorePreviousState()
		{
			SetState(m_previousModuleState);
		}

		public void UpdateParameters()
		{
			foreach (Image backgroundImage in m_backgroundImages)
			{
				backgroundImage.color = m_graphyManager.BackgroundColor;
			}
			m_ramGraph.UpdateParameters();
			m_ramText.UpdateParameters();
			SetState(m_graphyManager.RamModuleState);
		}

		private void Init()
		{
			m_graphyManager = base.transform.root.GetComponentInChildren<GraphyManager>();
			m_ramGraph = GetComponent<RamGraph>();
			m_ramText = GetComponent<RamText>();
			m_rectTransform = GetComponent<RectTransform>();
			foreach (Transform item in base.transform)
			{
				if (item.parent == base.transform)
				{
					m_childrenGameObjects.Add(item.gameObject);
				}
			}
		}

		private void SetGraphActive(bool active)
		{
			m_ramGraph.enabled = active;
			m_ramGraphGameObject.SetActive(active);
		}
	}
	public class RamMonitor : MonoBehaviour
	{
		private float m_allocatedRam;

		private float m_reservedRam;

		private float m_monoRam;

		public float AllocatedRam => m_allocatedRam;

		public float ReservedRam => m_reservedRam;

		public float MonoRam => m_monoRam;

		private void Update()
		{
			m_allocatedRam = (float)Profiler.GetTotalAllocatedMemoryLong() / 1048576f;
			m_reservedRam = (float)Profiler.GetTotalReservedMemoryLong() / 1048576f;
			m_monoRam = (float)Profiler.GetMonoUsedSizeLong() / 1048576f;
		}
	}
	public class RamText : MonoBehaviour
	{
		private GraphyManager m_graphyManager;

		private RamMonitor m_ramMonitor;

		[SerializeField]
		private Text m_allocatedSystemMemorySizeText;

		[SerializeField]
		private Text m_reservedSystemMemorySizeText;

		[SerializeField]
		private Text m_monoSystemMemorySizeText;

		private float m_updateRate = 4f;

		private float m_deltaTime;

		private readonly string m_memoryStringFormat = "0.0";

		private void Awake()
		{
			Init();
		}

		private void Update()
		{
			m_deltaTime += Time.unscaledDeltaTime;
			if ((double)m_deltaTime > 1.0 / (double)m_updateRate)
			{
				m_allocatedSystemMemorySizeText.text = m_ramMonitor.AllocatedRam.ToStringNonAlloc(m_memoryStringFormat);
				m_reservedSystemMemorySizeText.text = m_ramMonitor.ReservedRam.ToStringNonAlloc(m_memoryStringFormat);
				m_monoSystemMemorySizeText.text = m_ramMonitor.MonoRam.ToStringNonAlloc(m_memoryStringFormat);
				m_deltaTime = 0f;
			}
		}

		public void UpdateParameters()
		{
			m_allocatedSystemMemorySizeText.color = m_graphyManager.AllocatedRamColor;
			m_reservedSystemMemorySizeText.color = m_graphyManager.ReservedRamColor;
			m_monoSystemMemorySizeText.color = m_graphyManager.MonoRamColor;
			m_updateRate = m_graphyManager.RamTextUpdateRate;
		}

		private void Init()
		{
			if (!FloatString.Inited || FloatString.minValue > -1000f || FloatString.maxValue < 16384f)
			{
				FloatString.Init(-1001f, 16386f);
			}
			m_graphyManager = base.transform.root.GetComponentInChildren<GraphyManager>();
			m_ramMonitor = GetComponent<RamMonitor>();
			UpdateParameters();
		}
	}
}
namespace Tayx.Graphy.Graph
{
	public abstract class Graph : MonoBehaviour
	{
		protected abstract void UpdateGraph();

		protected abstract void CreatePoints();
	}
}
namespace Tayx.Graphy.Fps
{
	public class FpsGraph : Tayx.Graphy.Graph.Graph
	{
		private GraphyManager m_graphyManager;

		private FpsMonitor m_fpsMonitor;

		[SerializeField]
		private Image m_imageGraph;

		private int m_resolution = 150;

		private ShaderGraph m_shaderGraph;

		public Shader ShaderFull;

		public Shader ShaderLight;

		private int[] m_fpsArray;

		private int m_highestFps;

		private void Awake()
		{
			Init();
		}

		private void Update()
		{
			UpdateGraph();
		}

		public void UpdateParameters()
		{
			switch (m_graphyManager.GraphyMode)
			{
			case GraphyManager.Mode.FULL:
				m_shaderGraph.ArrayMaxSize = 512;
				m_shaderGraph.Image.material = new Material(ShaderFull);
				break;
			case GraphyManager.Mode.LIGHT:
				m_shaderGraph.ArrayMaxSize = 128;
				m_shaderGraph.Image.material = new Material(ShaderLight);
				break;
			}
			m_shaderGraph.InitializeShader();
			m_resolution = m_graphyManager.FpsGraphResolution;
			CreatePoints();
		}

		protected override void UpdateGraph()
		{
			int num = (int)(1f / Time.unscaledDeltaTime);
			int num2 = 0;
			for (int i = 0; i <= m_resolution - 1; i++)
			{
				if (i >= m_resolution - 1)
				{
					m_fpsArray[i] = num;
				}
				else
				{
					m_fpsArray[i] = m_fpsArray[i + 1];
				}
				if (num2 < m_fpsArray[i])
				{
					num2 = m_fpsArray[i];
				}
			}
			m_highestFps = ((m_highestFps < 1 || m_highestFps <= num2) ? num2 : (m_highestFps - 1));
			for (int j = 0; j <= m_resolution - 1; j++)
			{
				m_shaderGraph.Array[j] = (float)m_fpsArray[j] / (float)m_highestFps;
			}
			m_shaderGraph.UpdatePoints();
			m_shaderGraph.Average = m_fpsMonitor.AverageFPS / (float)m_highestFps;
			m_shaderGraph.UpdateAverage();
			m_shaderGraph.GoodThreshold = (float)m_graphyManager.GoodFPSThreshold / (float)m_highestFps;
			m_shaderGraph.CautionThreshold = (float)m_graphyManager.CautionFPSThreshold / (float)m_highestFps;
			m_shaderGraph.UpdateThresholds();
		}

		protected override void CreatePoints()
		{
			m_shaderGraph.Array = new float[m_resolution];
			m_fpsArray = new int[m_resolution];
			for (int i = 0; i < m_resolution; i++)
			{
				m_shaderGraph.Array[i] = 0f;
			}
			m_shaderGraph.GoodColor = m_graphyManager.GoodFPSColor;
			m_shaderGraph.CautionColor = m_graphyManager.CautionFPSColor;
			m_shaderGraph.CriticalColor = m_graphyManager.CriticalFPSColor;
			m_shaderGraph.UpdateColors();
			m_shaderGraph.UpdateArray();
		}

		private void Init()
		{
			m_graphyManager = base.transform.root.GetComponentInChildren<GraphyManager>();
			m_fpsMonitor = GetComponent<FpsMonitor>();
			m_shaderGraph = new ShaderGraph();
			m_shaderGraph.Image = m_imageGraph;
			UpdateParameters();
		}
	}
	public class FpsManager : MonoBehaviour, IMovable, IModifiableState
	{
		private GraphyManager m_graphyManager;

		private FpsGraph m_fpsGraph;

		private FpsMonitor m_fpsMonitor;

		private FpsText m_fpsText;

		private RectTransform m_rectTransform;

		[SerializeField]
		private GameObject m_fpsGraphGameObject;

		[SerializeField]
		private List<GameObject> m_nonBasicTextGameObjects = new List<GameObject>();

		[SerializeField]
		private List<Image> m_backgroundImages = new List<Image>();

		private List<GameObject> m_childrenGameObjects = new List<GameObject>();

		private GraphyManager.ModuleState m_previousModuleState;

		private GraphyManager.ModuleState m_currentModuleState;

		private void Awake()
		{
			Init();
		}

		private void Start()
		{
			UpdateParameters();
		}

		public void SetPosition(GraphyManager.ModulePosition newModulePosition)
		{
			float num = Mathf.Abs(m_rectTransform.anchoredPosition.x);
			float num2 = Mathf.Abs(m_rectTransform.anchoredPosition.y);
			switch (newModulePosition)
			{
			case GraphyManager.ModulePosition.TOP_LEFT:
				m_rectTransform.anchorMax = Vector2.up;
				m_rectTransform.anchorMin = Vector2.up;
				m_rectTransform.anchoredPosition = new Vector2(num, 0f - num2);
				break;
			case GraphyManager.ModulePosition.TOP_RIGHT:
				m_rectTransform.anchorMax = Vector2.one;
				m_rectTransform.anchorMin = Vector2.one;
				m_rectTransform.anchoredPosition = new Vector2(0f - num, 0f - num2);
				break;
			case GraphyManager.ModulePosition.BOTTOM_LEFT:
				m_rectTransform.anchorMax = Vector2.zero;
				m_rectTransform.anchorMin = Vector2.zero;
				m_rectTransform.anchoredPosition = new Vector2(num, num2);
				break;
			case GraphyManager.ModulePosition.BOTTOM_RIGHT:
				m_rectTransform.anchorMax = Vector2.right;
				m_rectTransform.anchorMin = Vector2.right;
				m_rectTransform.anchoredPosition = new Vector2(0f - num, num2);
				break;
			}
		}

		public void SetState(GraphyManager.ModuleState state)
		{
			m_previousModuleState = m_currentModuleState;
			m_currentModuleState = state;
			switch (state)
			{
			case GraphyManager.ModuleState.FULL:
				base.gameObject.SetActive(value: true);
				m_childrenGameObjects.SetAllActive(active: true);
				SetGraphActive(active: true);
				if (m_graphyManager.Background)
				{
					m_backgroundImages.SetOneActive(0);
				}
				else
				{
					m_backgroundImages.SetAllActive(active: false);
				}
				break;
			case GraphyManager.ModuleState.TEXT:
				base.gameObject.SetActive(value: true);
				m_childrenGameObjects.SetAllActive(active: true);
				SetGraphActive(active: false);
				if (m_graphyManager.Background)
				{
					m_backgroundImages.SetOneActive(1);
				}
				else
				{
					m_backgroundImages.SetAllActive(active: false);
				}
				break;
			case GraphyManager.ModuleState.BASIC:
				base.gameObject.SetActive(value: true);
				m_childrenGameObjects.SetAllActive(active: true);
				m_nonBasicTextGameObjects.SetAllActive(active: false);
				SetGraphActive(active: false);
				if (m_graphyManager.Background)
				{
					m_backgroundImages.SetOneActive(2);
				}
				else
				{
					m_backgroundImages.SetAllActive(active: false);
				}
				break;
			case GraphyManager.ModuleState.BACKGROUND:
				base.gameObject.SetActive(value: true);
				m_childrenGameObjects.SetAllActive(active: false);
				SetGraphActive(active: false);
				m_backgroundImages.SetAllActive(active: false);
				break;
			case GraphyManager.ModuleState.OFF:
				base.gameObject.SetActive(value: false);
				break;
			}
		}

		public void RestorePreviousState()
		{
			SetState(m_previousModuleState);
		}

		public void UpdateParameters()
		{
			foreach (Image backgroundImage in m_backgroundImages)
			{
				backgroundImage.color = m_graphyManager.BackgroundColor;
			}
			m_fpsGraph.UpdateParameters();
			m_fpsMonitor.UpdateParameters();
			m_fpsText.UpdateParameters();
			SetState(m_graphyManager.FpsModuleState);
		}

		private void Init()
		{
			m_graphyManager = base.transform.root.GetComponentInChildren<GraphyManager>();
			m_rectTransform = GetComponent<RectTransform>();
			m_fpsGraph = GetComponent<FpsGraph>();
			m_fpsMonitor = GetComponent<FpsMonitor>();
			m_fpsText = GetComponent<FpsText>();
			foreach (Transform item in base.transform)
			{
				if (item.parent == base.transform)
				{
					m_childrenGameObjects.Add(item.gameObject);
				}
			}
		}

		private void SetGraphActive(bool active)
		{
			m_fpsGraph.enabled = active;
			m_fpsGraphGameObject.SetActive(active);
		}
	}
	public class FpsMonitor : MonoBehaviour
	{
		private GraphyManager m_graphyManager;

		private float m_currentFps = -1f;

		private float m_avgFps = -1f;

		private float m_minFps = -1f;

		private float m_maxFps = -1f;

		[SerializeField]
		private int m_averageSamples = 200;

		private List<float> m_averageFpsSamples;

		private int m_timeToResetMinMaxFps = 10;

		private float m_timeToResetMinFpsPassed;

		private float m_timeToResetMaxFpsPassed;

		private float unscaledDeltaTime;

		public float CurrentFPS => m_currentFps;

		public float AverageFPS => m_avgFps;

		public float MinFPS => m_minFps;

		public float MaxFPS => m_maxFps;

		private void Awake()
		{
			Init();
		}

		private void Update()
		{
			unscaledDeltaTime = Time.unscaledDeltaTime;
			m_timeToResetMinFpsPassed += unscaledDeltaTime;
			m_timeToResetMaxFpsPassed += unscaledDeltaTime;
			m_currentFps = 1f / unscaledDeltaTime;
			m_avgFps = 0f;
			if (m_averageFpsSamples.Count >= m_averageSamples)
			{
				m_averageFpsSamples.Add(m_currentFps);
				m_averageFpsSamples.RemoveAt(0);
			}
			else
			{
				m_averageFpsSamples.Add(m_currentFps);
			}
			for (int i = 0; i < m_averageFpsSamples.Count; i++)
			{
				m_avgFps += m_averageFpsSamples[i];
			}
			m_avgFps /= m_averageSamples;
			if (m_timeToResetMinMaxFps > 0 && m_timeToResetMinFpsPassed > (float)m_timeToResetMinMaxFps)
			{
				m_minFps = -1f;
				m_timeToResetMinFpsPassed = 0f;
			}
			if (m_timeToResetMinMaxFps > 0 && m_timeToResetMaxFpsPassed > (float)m_timeToResetMinMaxFps)
			{
				m_maxFps = -1f;
				m_timeToResetMaxFpsPassed = 0f;
			}
			if (m_currentFps < m_minFps || m_minFps < 0f)
			{
				m_minFps = m_currentFps;
				m_timeToResetMinFpsPassed = 0f;
			}
			if (m_currentFps > m_maxFps || m_maxFps < 0f)
			{
				m_maxFps = m_currentFps;
				m_timeToResetMaxFpsPassed = 0f;
			}
		}

		public void UpdateParameters()
		{
			m_timeToResetMinMaxFps = m_graphyManager.TimeToResetMinMaxFps;
		}

		private void Init()
		{
			m_graphyManager = base.transform.root.GetComponentInChildren<GraphyManager>();
			m_averageFpsSamples = new List<float>();
			UpdateParameters();
		}
	}
	public class FpsText : MonoBehaviour
	{
		private GraphyManager m_graphyManager;

		private FpsMonitor m_fpsMonitor;

		[SerializeField]
		private Text m_fpsText;

		[SerializeField]
		private Text m_msText;

		[SerializeField]
		private Text m_avgFpsText;

		[SerializeField]
		private Text m_minFpsText;

		[SerializeField]
		private Text m_maxFpsText;

		private int m_updateRate = 4;

		private int m_frameCount;

		private float m_deltaTime;

		private float m_fps;

		private const string m_msStringFormat = "0.0";

		private void Awake()
		{
			Init();
		}

		private void Update()
		{
			m_deltaTime += Time.unscaledDeltaTime;
			m_frameCount++;
			if ((double)m_deltaTime > 1.0 / (double)m_updateRate)
			{
				m_fps = (float)m_frameCount / m_deltaTime;
				m_fpsText.text = m_fps.ToInt().ToStringNonAlloc();
				m_msText.text = (m_deltaTime / (float)m_frameCount * 1000f).ToStringNonAlloc("0.0");
				m_minFpsText.text = m_fpsMonitor.MinFPS.ToInt().ToStringNonAlloc();
				SetFpsRelatedTextColor(m_minFpsText, m_fpsMonitor.MinFPS);
				m_maxFpsText.text = m_fpsMonitor.MaxFPS.ToInt().ToStringNonAlloc();
				SetFpsRelatedTextColor(m_maxFpsText, m_fpsMonitor.MaxFPS);
				m_avgFpsText.text = m_fpsMonitor.AverageFPS.ToInt().ToStringNonAlloc();
				SetFpsRelatedTextColor(m_avgFpsText, m_fpsMonitor.AverageFPS);
				m_deltaTime = 0f;
				m_frameCount = 0;
			}
		}

		public void UpdateParameters()
		{
			m_updateRate = m_graphyManager.FpsTextUpdateRate;
		}

		private void SetFpsRelatedTextColor(Text text, float fps)
		{
			if (fps > (float)m_graphyManager.GoodFPSThreshold)
			{
				text.color = m_graphyManager.GoodFPSColor;
			}
			else if (fps > (float)m_graphyManager.CautionFPSThreshold)
			{
				text.color = m_graphyManager.CautionFPSColor;
			}
			else
			{
				text.color = m_graphyManager.CriticalFPSColor;
			}
		}

		private void Init()
		{
			if (!FloatString.Inited || FloatString.minValue > -1000f || FloatString.maxValue < 16384f)
			{
				FloatString.Init(-1001f, 16386f);
			}
			m_graphyManager = base.transform.root.GetComponentInChildren<GraphyManager>();
			m_fpsMonitor = GetComponent<FpsMonitor>();
			UpdateParameters();
		}
	}
}
namespace Tayx.Graphy.Audio
{
	public class AudioGraph : Tayx.Graphy.Graph.Graph
	{
		private GraphyManager m_graphyManager;

		private AudioMonitor m_audioMonitor;

		[SerializeField]
		private Image m_imageGraph;

		[SerializeField]
		private Image m_imageGraphHighestValues;

		private int m_resolution = 40;

		private ShaderGraph m_shaderGraph;

		private ShaderGraph m_shaderGraphHighestValues;

		public Shader ShaderFull;

		public Shader ShaderLight;

		private float[] m_graphArray;

		private float[] m_graphArrayHighestValue;

		private void Awake()
		{
			Init();
		}

		private void Update()
		{
			if (m_audioMonitor.SpectrumDataAvailable)
			{
				UpdateGraph();
			}
		}

		public void UpdateParameters()
		{
			switch (m_graphyManager.GraphyMode)
			{
			case GraphyManager.Mode.FULL:
				m_shaderGraph.ArrayMaxSize = 512;
				m_shaderGraph.Image.material = new Material(ShaderFull);
				m_shaderGraphHighestValues.ArrayMaxSize = 512;
				m_shaderGraphHighestValues.Image.material = new Material(ShaderFull);
				break;
			case GraphyManager.Mode.LIGHT:
				m_shaderGraph.ArrayMaxSize = 128;
				m_shaderGraph.Image.material = new Material(ShaderLight);
				m_shaderGraphHighestValues.ArrayMaxSize = 128;
				m_shaderGraphHighestValues.Image.material = new Material(ShaderLight);
				break;
			}
			m_shaderGraph.InitializeShader();
			m_shaderGraphHighestValues.InitializeShader();
			m_resolution = m_graphyManager.AudioGraphResolution;
			CreatePoints();
		}

		protected override void UpdateGraph()
		{
			int num = Mathf.FloorToInt((float)m_audioMonitor.Spectrum.Length / (float)m_resolution);
			for (int i = 0; i <= m_resolution - 1; i++)
			{
				float num2 = 0f;
				for (int j = 0; j < num; j++)
				{
					num2 += m_audioMonitor.Spectrum[i * num + j];
				}
				if ((i + 1) % 3 == 0 && i > 1)
				{
					float num3 = (m_audioMonitor.dBNormalized(m_audioMonitor.lin2dB(num2 / (float)num)) + m_graphArray[i - 1] + m_graphArray[i - 2]) / 3f;
					m_graphArray[i] = num3;
					m_graphArray[i - 1] = num3;
					m_graphArray[i - 2] = -1f;
				}
				else
				{
					m_graphArray[i] = m_audioMonitor.dBNormalized(m_audioMonitor.lin2dB(num2 / (float)num));
				}
			}
			for (int k = 0; k <= m_resolution - 1; k++)
			{
				m_shaderGraph.Array[k] = m_graphArray[k];
			}
			m_shaderGraph.UpdatePoints();
			for (int l = 0; l <= m_resolution - 1; l++)
			{
				float num4 = 0f;
				for (int m = 0; m < num; m++)
				{
					num4 += m_audioMonitor.SpectrumHighestValues[l * num + m];
				}
				if ((l + 1) % 3 == 0 && l > 1)
				{
					float num5 = (m_audioMonitor.dBNormalized(m_audioMonitor.lin2dB(num4 / (float)num)) + m_graphArrayHighestValue[l - 1] + m_graphArrayHighestValue[l - 2]) / 3f;
					m_graphArrayHighestValue[l] = num5;
					m_graphArrayHighestValue[l - 1] = num5;
					m_graphArrayHighestValue[l - 2] = -1f;
				}
				else
				{
					m_graphArrayHighestValue[l] = m_audioMonitor.dBNormalized(m_audioMonitor.lin2dB(num4 / (float)num));
				}
			}
			for (int n = 0; n <= m_resolution - 1; n++)
			{
				m_shaderGraphHighestValues.Array[n] = m_graphArrayHighestValue[n];
			}
			m_shaderGraphHighestValues.UpdatePoints();
		}

		protected override void CreatePoints()
		{
			m_shaderGraph.Array = new float[m_resolution];
			m_shaderGraphHighestValues.Array = new float[m_resolution];
			m_graphArray = new float[m_resolution];
			m_graphArrayHighestValue = new float[m_resolution];
			for (int i = 0; i < m_resolution; i++)
			{
				m_shaderGraph.Array[i] = 0f;
				m_shaderGraphHighestValues.Array[i] = 0f;
			}
			m_shaderGraph.GoodColor = m_graphyManager.AudioGraphColor;
			m_shaderGraph.CautionColor = m_graphyManager.AudioGraphColor;
			m_shaderGraph.CriticalColor = m_graphyManager.AudioGraphColor;
			m_shaderGraph.UpdateColors();
			m_shaderGraphHighestValues.GoodColor = m_graphyManager.AudioGraphColor;
			m_shaderGraphHighestValues.CautionColor = m_graphyManager.AudioGraphColor;
			m_shaderGraphHighestValues.CriticalColor = m_graphyManager.AudioGraphColor;
			m_shaderGraphHighestValues.UpdateColors();
			m_shaderGraph.GoodThreshold = 0f;
			m_shaderGraph.CautionThreshold = 0f;
			m_shaderGraph.UpdateThresholds();
			m_shaderGraphHighestValues.GoodThreshold = 0f;
			m_shaderGraphHighestValues.CautionThreshold = 0f;
			m_shaderGraphHighestValues.UpdateThresholds();
			m_shaderGraph.UpdateArray();
			m_shaderGraphHighestValues.UpdateArray();
			m_shaderGraph.Average = 0f;
			m_shaderGraph.UpdateAverage();
			m_shaderGraphHighestValues.Average = 0f;
			m_shaderGraphHighestValues.UpdateAverage();
		}

		private void Init()
		{
			m_graphyManager = base.transform.root.GetComponentInChildren<GraphyManager>();
			m_audioMonitor = GetComponent<AudioMonitor>();
			m_shaderGraph = new ShaderGraph();
			m_shaderGraph.Image = m_imageGraph;
			m_shaderGraphHighestValues = new ShaderGraph();
			m_shaderGraphHighestValues.Image = m_imageGraphHighestValues;
			UpdateParameters();
		}
	}
	public class AudioManager : MonoBehaviour, IMovable, IModifiableState
	{
		private GraphyManager m_graphyManager;

		private AudioGraph m_audioGraph;

		private AudioMonitor m_audioMonitor;

		private AudioText m_audioText;

		private RectTransform m_rectTransform;

		[SerializeField]
		private GameObject m_audioGraphGameObject;

		[SerializeField]
		private Text m_audioDbText;

		private List<GameObject> m_childrenGameObjects = new List<GameObject>();

		[SerializeField]
		private List<Image> m_backgroundImages = new List<Image>();

		private GraphyManager.ModuleState m_previousModuleState;

		private GraphyManager.ModuleState m_currentModuleState;

		private void Awake()
		{
			Init();
		}

		private void Start()
		{
			UpdateParameters();
		}

		public void SetPosition(GraphyManager.ModulePosition newModulePosition)
		{
			float num = Mathf.Abs(m_rectTransform.anchoredPosition.x);
			float num2 = Mathf.Abs(m_rectTransform.anchoredPosition.y);
			switch (newModulePosition)
			{
			case GraphyManager.ModulePosition.TOP_LEFT:
				m_rectTransform.anchorMax = Vector2.up;
				m_rectTransform.anchorMin = Vector2.up;
				m_rectTransform.anchoredPosition = new Vector2(num, 0f - num2);
				m_audioDbText.alignment = TextAnchor.UpperLeft;
				break;
			case GraphyManager.ModulePosition.TOP_RIGHT:
				m_rectTransform.anchorMax = Vector2.one;
				m_rectTransform.anchorMin = Vector2.one;
				m_rectTransform.anchoredPosition = new Vector2(0f - num, 0f - num2);
				m_audioDbText.alignment = TextAnchor.UpperRight;
				break;
			case GraphyManager.ModulePosition.BOTTOM_LEFT:
				m_rectTransform.anchorMax = Vector2.zero;
				m_rectTransform.anchorMin = Vector2.zero;
				m_rectTransform.anchoredPosition = new Vector2(num, num2);
				m_audioDbText.alignment = TextAnchor.UpperLeft;
				break;
			case GraphyManager.ModulePosition.BOTTOM_RIGHT:
				m_rectTransform.anchorMax = Vector2.right;
				m_rectTransform.anchorMin = Vector2.right;
				m_rectTransform.anchoredPosition = new Vector2(0f - num, num2);
				m_audioDbText.alignment = TextAnchor.UpperRight;
				break;
			}
		}

		public void SetState(GraphyManager.ModuleState state)
		{
			m_previousModuleState = m_currentModuleState;
			m_currentModuleState = state;
			switch (state)
			{
			case GraphyManager.ModuleState.FULL:
				base.gameObject.SetActive(value: true);
				m_childrenGameObjects.SetAllActive(active: true);
				SetGraphActive(active: true);
				if (m_graphyManager.Background)
				{
					m_backgroundImages.SetOneActive(0);
				}
				else
				{
					m_backgroundImages.SetAllActive(active: false);
				}
				break;
			case GraphyManager.ModuleState.TEXT:
			case GraphyManager.ModuleState.BASIC:
				base.gameObject.SetActive(value: true);
				m_childrenGameObjects.SetAllActive(active: true);
				SetGraphActive(active: false);
				if (m_graphyManager.Background)
				{
					m_backgroundImages.SetOneActive(1);
				}
				else
				{
					m_backgroundImages.SetAllActive(active: false);
				}
				break;
			case GraphyManager.ModuleState.BACKGROUND:
				base.gameObject.SetActive(value: true);
				SetGraphActive(active: false);
				m_childrenGameObjects.SetAllActive(active: false);
				m_backgroundImages.SetAllActive(active: false);
				break;
			case GraphyManager.ModuleState.OFF:
				base.gameObject.SetActive(value: false);
				break;
			}
		}

		public void RestorePreviousState()
		{
			SetState(m_previousModuleState);
		}

		public void UpdateParameters()
		{
			foreach (Image backgroundImage in m_backgroundImages)
			{
				backgroundImage.color = m_graphyManager.BackgroundColor;
			}
			m_audioGraph.UpdateParameters();
			m_audioMonitor.UpdateParameters();
			m_audioText.UpdateParameters();
			SetState(m_graphyManager.AudioModuleState);
		}

		private void Init()
		{
			m_graphyManager = base.transform.root.GetComponentInChildren<GraphyManager>();
			m_rectTransform = GetComponent<RectTransform>();
			m_audioGraph = GetComponent<AudioGraph>();
			m_audioMonitor = GetComponent<AudioMonitor>();
			m_audioText = GetComponent<AudioText>();
			foreach (Transform item in base.transform)
			{
				if (item.parent == base.transform)
				{
					m_childrenGameObjects.Add(item.gameObject);
				}
			}
		}

		private void SetGraphActive(bool active)
		{
			m_audioGraph.enabled = active;
			m_audioGraphGameObject.SetActive(active);
		}
	}
	public class AudioMonitor : MonoBehaviour
	{
		private const float m_refValue = 1f;

		private GraphyManager m_graphyManager;

		private AudioListener m_audioListener;

		private GraphyManager.LookForAudioListener m_findAudioListenerInCameraIfNull = GraphyManager.LookForAudioListener.ON_SCENE_LOAD;

		private FFTWindow m_FFTWindow = FFTWindow.Blackman;

		private int m_spectrumSize = 512;

		private float[] m_spectrum;

		private float[] m_spectrumHighestValues;

		private float m_maxDB;

		public float[] Spectrum => m_spectrum;

		public float[] SpectrumHighestValues => m_spectrumHighestValues;

		public float MaxDB => m_maxDB;

		public bool SpectrumDataAvailable => m_audioListener != null;

		private void Awake()
		{
			Init();
		}

		private void Update()
		{
			if (m_audioListener != null)
			{
				AudioListener.GetOutputData(m_spectrum, 0);
				float num = 0f;
				for (int i = 0; i < m_spectrum.Length; i++)
				{
					num += m_spectrum[i] * m_spectrum[i];
				}
				float num2 = Mathf.Sqrt(num / (float)m_spectrum.Length);
				m_maxDB = 20f * Mathf.Log10(num2 / 1f);
				if (m_maxDB < -80f)
				{
					m_maxDB = -80f;
				}
				AudioListener.GetSpectrumData(m_spectrum, 0, m_FFTWindow);
				for (int j = 0; j < m_spectrum.Length; j++)
				{
					if (m_spectrum[j] > m_spectrumHighestValues[j])
					{
						m_spectrumHighestValues[j] = m_spectrum[j];
					}
					else
					{
						m_spectrumHighestValues[j] = Mathf.Clamp(m_spectrumHighestValues[j] - m_spectrumHighestValues[j] * Time.deltaTime * 2f, 0f, 1f);
					}
				}
			}
			else if (m_audioListener == null && m_findAudioListenerInCameraIfNull == GraphyManager.LookForAudioListener.ALWAYS)
			{
				FindAudioListener();
			}
		}

		public void UpdateParameters()
		{
			m_findAudioListenerInCameraIfNull = m_graphyManager.FindAudioListenerInCameraIfNull;
			m_audioListener = m_graphyManager.AudioListener;
			m_FFTWindow = m_graphyManager.FftWindow;
			m_spectrumSize = m_graphyManager.SpectrumSize;
			if (m_audioListener == null && m_findAudioListenerInCameraIfNull != GraphyManager.LookForAudioListener.NEVER)
			{
				FindAudioListener();
			}
			m_spectrum = new float[m_spectrumSize];
			m_spectrumHighestValues = new float[m_spectrumSize];
		}

		public float lin2dB(float linear)
		{
			return Mathf.Clamp(Mathf.Log10(linear) * 20f, -160f, 0f);
		}

		public float dBNormalized(float db)
		{
			return (db + 160f) / 160f;
		}

		private void FindAudioListener()
		{
		}

		private void Init()
		{
			m_graphyManager = base.transform.root.GetComponentInChildren<GraphyManager>();
			UpdateParameters();
			SceneManager.sceneLoaded += delegate
			{
				if (m_findAudioListenerInCameraIfNull == GraphyManager.LookForAudioListener.ON_SCENE_LOAD)
				{
					FindAudioListener();
				}
			};
		}
	}
	public class AudioText : MonoBehaviour
	{
		private GraphyManager m_graphyManager;

		private AudioMonitor m_audioMonitor;

		[SerializeField]
		private Text m_DBText;

		private int m_updateRate = 4;

		private float m_deltaTimeOffset;

		private void Awake()
		{
			Init();
		}

		private void Update()
		{
			if (m_audioMonitor.SpectrumDataAvailable)
			{
				if (m_deltaTimeOffset > 1f / (float)m_updateRate)
				{
					m_deltaTimeOffset = 0f;
					m_DBText.text = Mathf.Clamp(m_audioMonitor.MaxDB, -80f, 0f).ToStringNonAlloc();
				}
				else
				{
					m_deltaTimeOffset += Time.deltaTime;
				}
			}
		}

		public void UpdateParameters()
		{
			m_updateRate = m_graphyManager.AudioTextUpdateRate;
		}

		private void Init()
		{
			if (!FloatString.Inited || FloatString.minValue > -1000f || FloatString.maxValue < 16384f)
			{
				FloatString.Init(-1001f, 16386f);
			}
			m_graphyManager = base.transform.root.GetComponentInChildren<GraphyManager>();
			m_audioMonitor = GetComponent<AudioMonitor>();
			UpdateParameters();
		}
	}
}
namespace Tayx.Graphy.Advanced
{
	public class AdvancedData : MonoBehaviour, IMovable, IModifiableState
	{
		private GraphyManager m_graphyManager;

		private RectTransform m_rectTransform;

		[SerializeField]
		private List<Image> m_backgroundImages = new List<Image>();

		[SerializeField]
		private Text m_graphicsDeviceVersionText;

		[SerializeField]
		private Text m_processorTypeText;

		[SerializeField]
		private Text m_operatingSystemText;

		[SerializeField]
		private Text m_systemMemoryText;

		[SerializeField]
		private Text m_graphicsDeviceNameText;

		[SerializeField]
		private Text m_graphicsMemorySizeText;

		[SerializeField]
		private Text m_screenResolutionText;

		[SerializeField]
		private Text m_gameWindowResolutionText;

		[Range(1f, 60f)]
		[SerializeField]
		private float m_updateRate = 1f;

		private float m_deltaTime;

		private StringBuilder m_sb;

		private GraphyManager.ModuleState m_previousModuleState;

		private GraphyManager.ModuleState m_currentModuleState;

		private readonly string[] m_windowStrings = new string[6] { "Window: ", "x", "@", "Hz", "[", "dpi]" };

		private void Awake()
		{
			Init();
		}

		private void Update()
		{
			m_deltaTime += Time.unscaledDeltaTime;
			if ((double)m_deltaTime > 1.0 / (double)m_updateRate)
			{
				m_sb.Length = 0;
				m_sb.Append(m_windowStrings[0]).Append(Screen.width.ToStringNonAlloc()).Append(m_windowStrings[1])
					.Append(Screen.height.ToStringNonAlloc())
					.Append(m_windowStrings[2])
					.Append(Screen.currentResolution.refreshRate.ToStringNonAlloc())
					.Append(m_windowStrings[3])
					.Append(m_windowStrings[4])
					.Append(Screen.dpi.ToStringNonAlloc())
					.Append(m_windowStrings[5]);
				m_gameWindowResolutionText.text = m_sb.ToString();
				m_deltaTime = 0f;
			}
		}

		public void SetPosition(GraphyManager.ModulePosition newModulePosition)
		{
			float num = Mathf.Abs(m_backgroundImages[0].rectTransform.anchoredPosition.x);
			float num2 = Mathf.Abs(m_rectTransform.anchoredPosition.y);
			switch (newModulePosition)
			{
			case GraphyManager.ModulePosition.TOP_LEFT:
				m_rectTransform.anchorMax = Vector2.one;
				m_rectTransform.anchorMin = Vector2.up;
				m_rectTransform.anchoredPosition = new Vector2(0f, 0f - num2);
				m_backgroundImages[0].rectTransform.anchorMax = Vector2.up;
				m_backgroundImages[0].rectTransform.anchorMin = Vector2.zero;
				m_backgroundImages[0].rectTransform.anchoredPosition = new Vector2(num, 0f);
				break;
			case GraphyManager.ModulePosition.TOP_RIGHT:
				m_rectTransform.anchorMax = Vector2.one;
				m_rectTransform.anchorMin = Vector2.up;
				m_rectTransform.anchoredPosition = new Vector2(0f, 0f - num2);
				m_backgroundImages[0].rectTransform.anchorMax = Vector2.one;
				m_backgroundImages[0].rectTransform.anchorMin = Vector2.right;
				m_backgroundImages[0].rectTransform.anchoredPosition = new Vector2(0f - num, 0f);
				break;
			case GraphyManager.ModulePosition.BOTTOM_LEFT:
				m_rectTransform.anchorMax = Vector2.right;
				m_rectTransform.anchorMin = Vector2.zero;
				m_rectTransform.anchoredPosition = new Vector2(0f, num2);
				m_backgroundImages[0].rectTransform.anchorMax = Vector2.up;
				m_backgroundImages[0].rectTransform.anchorMin = Vector2.zero;
				m_backgroundImages[0].rectTransform.anchoredPosition = new Vector2(num, 0f);
				break;
			case GraphyManager.ModulePosition.BOTTOM_RIGHT:
				m_rectTransform.anchorMax = Vector2.right;
				m_rectTransform.anchorMin = Vector2.zero;
				m_rectTransform.anchoredPosition = new Vector2(0f, num2);
				m_backgroundImages[0].rectTransform.anchorMax = Vector2.one;
				m_backgroundImages[0].rectTransform.anchorMin = Vector2.right;
				m_backgroundImages[0].rectTransform.anchoredPosition = new Vector2(0f - num, 0f);
				break;
			}
			switch (newModulePosition)
			{
			case GraphyManager.ModulePosition.TOP_LEFT:
			case GraphyManager.ModulePosition.BOTTOM_LEFT:
				m_processorTypeText.alignment = TextAnchor.UpperLeft;
				m_systemMemoryText.alignment = TextAnchor.UpperLeft;
				m_graphicsDeviceNameText.alignment = TextAnchor.UpperLeft;
				m_graphicsDeviceVersionText.alignment = TextAnchor.UpperLeft;
				m_graphicsMemorySizeText.alignment = TextAnchor.UpperLeft;
				m_screenResolutionText.alignment = TextAnchor.UpperLeft;
				m_gameWindowResolutionText.alignment = TextAnchor.UpperLeft;
				m_operatingSystemText.alignment = TextAnchor.UpperLeft;
				break;
			case GraphyManager.ModulePosition.TOP_RIGHT:
			case GraphyManager.ModulePosition.BOTTOM_RIGHT:
				m_processorTypeText.alignment = TextAnchor.UpperRight;
				m_systemMemoryText.alignment = TextAnchor.UpperRight;
				m_graphicsDeviceNameText.alignment = TextAnchor.UpperRight;
				m_graphicsDeviceVersionText.alignment = TextAnchor.UpperRight;
				m_graphicsMemorySizeText.alignment = TextAnchor.UpperRight;
				m_screenResolutionText.alignment = TextAnchor.UpperRight;
				m_gameWindowResolutionText.alignment = TextAnchor.UpperRight;
				m_operatingSystemText.alignment = TextAnchor.UpperRight;
				break;
			}
		}

		public void SetState(GraphyManager.ModuleState state)
		{
			m_previousModuleState = m_currentModuleState;
			m_currentModuleState = state;
			bool flag = state == GraphyManager.ModuleState.FULL || state == GraphyManager.ModuleState.TEXT || state == GraphyManager.ModuleState.BASIC;
			base.gameObject.SetActive(flag);
			m_backgroundImages.SetAllActive(flag && m_graphyManager.Background);
		}

		public void RestorePreviousState()
		{
			SetState(m_previousModuleState);
		}

		public void UpdateParameters()
		{
			foreach (Image backgroundImage in m_backgroundImages)
			{
				backgroundImage.color = m_graphyManager.BackgroundColor;
			}
			SetPosition(m_graphyManager.AdvancedModulePosition);
			SetState(m_graphyManager.AdvancedModuleState);
		}

		private void Init()
		{
			if (!FloatString.Inited || FloatString.minValue > -1000f || FloatString.maxValue < 16384f)
			{
				FloatString.Init(-1001f, 16386f);
			}
			m_graphyManager = base.transform.root.GetComponentInChildren<GraphyManager>();
			m_sb = new StringBuilder();
			m_rectTransform = GetComponent<RectTransform>();
			m_processorTypeText.text = "CPU: " + SystemInfo.processorType + " [" + SystemInfo.processorCount + " cores]";
			m_systemMemoryText.text = "RAM: " + SystemInfo.systemMemorySize + " MB";
			m_graphicsDeviceVersionText.text = "Graphics API: " + SystemInfo.graphicsDeviceVersion;
			m_graphicsDeviceNameText.text = "GPU: " + SystemInfo.graphicsDeviceName;
			m_graphicsMemorySizeText.text = "VRAM: " + SystemInfo.graphicsMemorySize + "MB. Max texture size: " + SystemInfo.maxTextureSize + "px. Shader level: " + SystemInfo.graphicsShaderLevel;
			Resolution currentResolution = Screen.currentResolution;
			m_screenResolutionText.text = "Screen: " + currentResolution.width + "x" + currentResolution.height + "@" + currentResolution.refreshRate + "Hz";
			m_operatingSystemText.text = "OS: " + SystemInfo.operatingSystem + " [" + SystemInfo.deviceType.ToString() + "]";
			float num = 0f;
			foreach (Text item in new List<Text> { m_graphicsDeviceVersionText, m_processorTypeText, m_systemMemoryText, m_graphicsDeviceNameText, m_graphicsMemorySizeText, m_screenResolutionText, m_gameWindowResolutionText, m_operatingSystemText })
			{
				if (item.preferredWidth > num)
				{
					num = item.preferredWidth;
				}
			}
			m_backgroundImages[0].rectTransform.SetSizeWithCurrentAnchors(RectTransform.Axis.Horizontal, num + 10f);
			m_backgroundImages[0].rectTransform.anchoredPosition = new Vector2((num + 15f) / 2f * Mathf.Sign(m_backgroundImages[0].rectTransform.anchoredPosition.x), m_backgroundImages[0].rectTransform.anchoredPosition.y);
			UpdateParameters();
		}
	}
}
namespace Tayx.Graphy.CustomizationScene
{
	public class CUIColorPicker : MonoBehaviour
	{
		[SerializeField]
		private Slider alphaSlider;

		[SerializeField]
		private Image alphaSliderBGImage;

		private Color _color = new Color32(byte.MaxValue, 0, 0, 128);

		private Action<Color> _onValueChange;

		private Action _update;

		public Color Color
		{
			get
			{
				return _color;
			}
			set
			{
				Setup(value);
			}
		}

		public void SetOnValueChangeCallback(Action<Color> onValueChange)
		{
			_onValueChange = onValueChange;
		}

		private static void RGBToHSV(Color color, out float h, out float s, out float v)
		{
			float num = Mathf.Min(color.r, color.g, color.b);
			float num2 = Mathf.Max(color.r, color.g, color.b);
			float num3 = num2 - num;
			if (num3 == 0f)
			{
				h = 0f;
			}
			else if (num2 == color.r)
			{
				h = Mathf.Repeat((color.g - color.b) / num3, 6f);
			}
			else if (num2 == color.g)
			{
				h = (color.b - color.r) / num3 + 2f;
			}
			else
			{
				h = (color.r - color.g) / num3 + 4f;
			}
			s = ((num2 == 0f) ? 0f : (num3 / num2));
			v = num2;
		}

		private static bool GetLocalMouse(GameObject go, out Vector2 result)
		{
			RectTransform rectTransform = (RectTransform)go.transform;
			Vector3 point = rectTransform.InverseTransformPoint(Input.mousePosition);
			result.x = Mathf.Clamp(point.x, rectTransform.rect.min.x, rectTransform.rect.max.x);
			result.y = Mathf.Clamp(point.y, rectTransform.rect.min.y, rectTransform.rect.max.y);
			return rectTransform.rect.Contains(point);
		}

		private static Vector2 GetWidgetSize(GameObject go)
		{
			return ((RectTransform)go.transform).rect.size;
		}

		private GameObject GO(string name)
		{
			return base.transform.Find(name).gameObject;
		}

		private void Setup(Color inputColor)
		{
			alphaSlider.value = inputColor.a;
			alphaSliderBGImage.color = inputColor;
			GameObject satvalGO = GO("SaturationValue");
			GameObject satvalKnob = GO("SaturationValue/Knob");
			GameObject hueGO = GO("Hue");
			GameObject hueKnob = GO("Hue/Knob");
			GameObject result = GO("Result");
			Color[] hueColors = new Color[6]
			{
				Color.red,
				Color.yellow,
				Color.green,
				Color.cyan,
				Color.blue,
				Color.magenta
			};
			Color[] satvalColors = new Color[4]
			{
				new Color(0f, 0f, 0f),
				new Color(0f, 0f, 0f),
				new Color(1f, 1f, 1f),
				hueColors[0]
			};
			Texture2D texture2D = new Texture2D(1, 7);
			for (int i = 0; i < 7; i++)
			{
				texture2D.SetPixel(0, i, hueColors[i % 6]);
			}
			texture2D.Apply();
			hueGO.GetComponent<Image>().sprite = Sprite.Create(texture2D, new Rect(0f, 0.5f, 1f, 6f), new Vector2(0.5f, 0.5f));
			Vector2 hueSz = GetWidgetSize(hueGO);
			Texture2D satvalTex = new Texture2D(2, 2);
			satvalGO.GetComponent<Image>().sprite = Sprite.Create(satvalTex, new Rect(0.5f, 0.5f, 1f, 1f), new Vector2(0.5f, 0.5f));
			Action resetSatValTexture = delegate
			{
				for (int j = 0; j < 2; j++)
				{
					for (int k = 0; k < 2; k++)
					{
						satvalTex.SetPixel(k, j, satvalColors[k + j * 2]);
					}
				}
				satvalTex.Apply();
			};
			Vector2 satvalSz = GetWidgetSize(satvalGO);
			RGBToHSV(inputColor, out var Hue, out var Saturation, out var Value);
			Action applyHue = delegate
			{
				int num = Mathf.Clamp((int)Hue, 0, 5);
				int num2 = (num + 1) % 6;
				Color color6 = Color.Lerp(hueColors[num], hueColors[num2], Hue - (float)num);
				satvalColors[3] = color6;
				resetSatValTexture();
			};
			Action applySaturationValue = delegate
			{
				Vector2 vector = new Vector2(Saturation, Value);
				Vector2 vector2 = new Vector2(1f - vector.x, 1f - vector.y);
				Color color = vector2.x * vector2.y * satvalColors[0];
				Color color2 = vector.x * vector2.y * satvalColors[1];
				Color color3 = vector2.x * vector.y * satvalColors[2];
				Color color4 = vector.x * vector.y * satvalColors[3];
				Color color5 = color + color2 + color3 + color4;
				result.GetComponent<Image>().color = color5;
				if (_color != color5)
				{
					color5 = new Color(color5.r, color5.g, color5.b, alphaSlider.value);
					if (_onValueChange != null)
					{
						_onValueChange(color5);
					}
					_color = color5;
					alphaSliderBGImage.color = _color;
				}
			};
			applyHue();
			applySaturationValue();
			satvalKnob.transform.localPosition = new Vector2(Saturation * satvalSz.x, Value * satvalSz.y);
			hueKnob.transform.localPosition = new Vector2(hueKnob.transform.localPosition.x, Hue / 6f * satvalSz.y);
			Action dragH = null;
			Action dragSV = null;
			Action idle = delegate
			{
				if (Input.GetMouseButtonDown(0))
				{
					if (GetLocalMouse(hueGO, out var result4))
					{
						_update = dragH;
					}
					else if (GetLocalMouse(satvalGO, out result4))
					{
						_update = dragSV;
					}
				}
			};
			dragH = delegate
			{
				GetLocalMouse(hueGO, out var result3);
				Hue = result3.y / hueSz.y * 6f;
				applyHue();
				applySaturationValue();
				hueKnob.transform.localPosition = new Vector2(hueKnob.transform.localPosition.x, result3.y);
				if (Input.GetMouseButtonUp(0))
				{
					_update = idle;
				}
			};
			dragSV = delegate
			{
				GetLocalMouse(satvalGO, out var result2);
				Saturation = result2.x / satvalSz.x;
				Value = result2.y / satvalSz.y;
				applySaturationValue();
				satvalKnob.transform.localPosition = result2;
				if (Input.GetMouseButtonUp(0))
				{
					_update = idle;
				}
			};
			_update = idle;
		}

		public void SetRandomColor()
		{
			System.Random random = new System.Random();
			float r = (float)(random.Next() % 1000) / 1000f;
			float g = (float)(random.Next() % 1000) / 1000f;
			float b = (float)(random.Next() % 1000) / 1000f;
			Color = new Color(r, g, b);
		}

		private void Awake()
		{
			Color = new Color32(byte.MaxValue, 0, 0, 128);
		}

		private void Start()
		{
			alphaSlider.onValueChanged.AddListener(delegate(float value)
			{
				_color = new Color(_color.r, _color.g, _color.b, value);
				alphaSliderBGImage.color = _color;
				if (_onValueChange != null)
				{
					_onValueChange(_color);
				}
			});
		}

		private void Update()
		{
			_update();
		}
	}
	public class CustomizeGraphy : MonoBehaviour
	{
		[Header("Customize Graphy")]
		[SerializeField]
		private CUIColorPicker m_colorPicker;

		[SerializeField]
		private Toggle m_backgroundToggle;

		[SerializeField]
		private Dropdown m_graphyModeDropdown;

		[SerializeField]
		private Button m_backgroundColorButton;

		[SerializeField]
		private Dropdown m_graphModulePositionDropdown;

		[Header("Fps")]
		[SerializeField]
		private Dropdown m_fpsModuleStateDropdown;

		[SerializeField]
		private InputField m_goodInputField;

		[SerializeField]
		private InputField m_cautionInputField;

		[SerializeField]
		private Button m_goodColorButton;

		[SerializeField]
		private Button m_cautionColorButton;

		[SerializeField]
		private Button m_criticalColorButton;

		[SerializeField]
		private Slider m_timeToResetMinMaxSlider;

		[SerializeField]
		private Slider m_fpsGraphResolutionSlider;

		[SerializeField]
		private Slider m_fpsTextUpdateRateSlider;

		[Header("Memory")]
		[SerializeField]
		private Dropdown m_ramModuleStateDropdown;

		[SerializeField]
		private Button m_reservedColorButton;

		[SerializeField]
		private Button m_allocatedColorButton;

		[SerializeField]
		private Button m_monoColorButton;

		[SerializeField]
		private Slider m_ramGraphResolutionSlider;

		[SerializeField]
		private Slider m_ramTextUpdateRateSlider;

		[Header("Audio")]
		[SerializeField]
		private Dropdown m_audioModuleStateDropdown;

		[SerializeField]
		private Button m_audioGraphColorButton;

		[SerializeField]
		private Dropdown m_findAudioListenerDropdown;

		[SerializeField]
		private Dropdown m_fttWindowDropdown;

		[SerializeField]
		private Slider m_spectrumSizeSlider;

		[SerializeField]
		private Slider m_audioGraphResolutionSlider;

		[SerializeField]
		private Slider m_audioTextUpdateRateSlider;

		[Header("Advanced")]
		[SerializeField]
		private Dropdown m_advancedModulePositionDropdown;

		[SerializeField]
		private Toggle m_advancedModuleToggle;

		[Header("Other")]
		[SerializeField]
		private Button m_musicButton;

		[SerializeField]
		private Button m_sfxButton;

		[SerializeField]
		private Slider m_musicVolumeSlider;

		[SerializeField]
		private Slider m_sfxVolumeSlider;

		[SerializeField]
		private AudioSource m_musicAudioSource;

		[SerializeField]
		private AudioSource m_sfxAudioSource;

		[SerializeField]
		private List<AudioClip> m_sfxAudioClips = new List<AudioClip>();

		private GraphyManager m_graphyManager;

		private void Start()
		{
			m_graphyManager = Singleton<GraphyManager>.Instance;
			SetupCallbacks();
		}

		private void SetupCallbacks()
		{
			m_backgroundToggle.onValueChanged.AddListener(delegate(bool value)
			{
				m_graphyManager.Background = value;
			});
			m_backgroundColorButton.onClick.AddListener(delegate
			{
				m_colorPicker.SetOnValueChangeCallback(null);
				m_colorPicker.Color = m_backgroundColorButton.GetComponent<Image>().color;
				m_colorPicker.SetOnValueChangeCallback(delegate(Color color)
				{
					m_backgroundColorButton.GetComponent<Image>().color = color;
					m_graphyManager.BackgroundColor = color;
				});
			});
			m_graphyModeDropdown.onValueChanged.AddListener(delegate(int value)
			{
				switch ((GraphyManager.Mode)value)
				{
				case GraphyManager.Mode.FULL:
					m_fpsGraphResolutionSlider.maxValue = 300f;
					m_ramGraphResolutionSlider.maxValue = 300f;
					m_audioGraphResolutionSlider.maxValue = 300f;
					break;
				case GraphyManager.Mode.LIGHT:
					m_fpsGraphResolutionSlider.maxValue = 128f;
					m_ramGraphResolutionSlider.maxValue = 128f;
					m_audioGraphResolutionSlider.maxValue = 128f;
					break;
				}
				m_graphyManager.GraphyMode = (GraphyManager.Mode)value;
			});
			m_graphModulePositionDropdown.onValueChanged.AddListener(delegate(int value)
			{
				m_graphyManager.GraphModulePosition = (GraphyManager.ModulePosition)value;
			});
			m_fpsModuleStateDropdown.onValueChanged.AddListener(delegate(int value)
			{
				m_graphyManager.FpsModuleState = (GraphyManager.ModuleState)value;
			});
			m_goodInputField.onValueChanged.AddListener(delegate(string value)
			{
				if (int.TryParse(value, out var result2))
				{
					m_graphyManager.GoodFPSThreshold = result2;
				}
			});
			m_cautionInputField.onValueChanged.AddListener(delegate(string value)
			{
				if (int.TryParse(value, out var result))
				{
					m_graphyManager.CautionFPSThreshold = result;
				}
			});
			m_goodColorButton.onClick.AddListener(delegate
			{
				m_colorPicker.SetOnValueChangeCallback(null);
				m_colorPicker.Color = m_goodColorButton.GetComponent<Image>().color;
				m_colorPicker.SetOnValueChangeCallback(delegate(Color color)
				{
					m_goodColorButton.GetComponent<Image>().color = color;
					m_graphyManager.GoodFPSColor = color;
				});
			});
			m_cautionColorButton.onClick.AddListener(delegate
			{
				m_colorPicker.SetOnValueChangeCallback(null);
				m_colorPicker.Color = m_cautionColorButton.GetComponent<Image>().color;
				m_colorPicker.SetOnValueChangeCallback(delegate(Color color)
				{
					m_cautionColorButton.GetComponent<Image>().color = color;
					m_graphyManager.CautionFPSColor = color;
				});
			});
			m_criticalColorButton.onClick.AddListener(delegate
			{
				m_colorPicker.SetOnValueChangeCallback(null);
				m_colorPicker.Color = m_criticalColorButton.GetComponent<Image>().color;
				m_colorPicker.SetOnValueChangeCallback(delegate(Color color)
				{
					m_criticalColorButton.GetComponent<Image>().color = color;
					m_graphyManager.CriticalFPSColor = color;
				});
			});
			m_timeToResetMinMaxSlider.onValueChanged.AddListener(delegate(float value)
			{
				m_graphyManager.TimeToResetMinMaxFps = (int)value;
			});
			m_fpsGraphResolutionSlider.onValueChanged.AddListener(delegate(float value)
			{
				m_graphyManager.FpsGraphResolution = (int)value;
			});
			m_fpsTextUpdateRateSlider.onValueChanged.AddListener(delegate(float value)
			{
				m_graphyManager.FpsTextUpdateRate = (int)value;
			});
			m_ramModuleStateDropdown.onValueChanged.AddListener(delegate(int value)
			{
				m_graphyManager.RamModuleState = (GraphyManager.ModuleState)value;
			});
			m_reservedColorButton.onClick.AddListener(delegate
			{
				m_colorPicker.SetOnValueChangeCallback(null);
				m_colorPicker.Color = m_reservedColorButton.GetComponent<Image>().color;
				m_colorPicker.SetOnValueChangeCallback(delegate(Color color)
				{
					m_reservedColorButton.GetComponent<Image>().color = color;
					m_graphyManager.ReservedRamColor = color;
				});
			});
			m_allocatedColorButton.onClick.AddListener(delegate
			{
				m_colorPicker.SetOnValueChangeCallback(null);
				m_colorPicker.Color = m_allocatedColorButton.GetComponent<Image>().color;
				m_colorPicker.SetOnValueChangeCallback(delegate(Color color)
				{
					m_allocatedColorButton.GetComponent<Image>().color = color;
					m_graphyManager.AllocatedRamColor = color;
				});
			});
			m_monoColorButton.onClick.AddListener(delegate
			{
				m_colorPicker.SetOnValueChangeCallback(null);
				m_colorPicker.Color = m_monoColorButton.GetComponent<Image>().color;
				m_colorPicker.SetOnValueChangeCallback(delegate(Color color)
				{
					m_monoColorButton.GetComponent<Image>().color = color;
					m_graphyManager.MonoRamColor = color;
				});
			});
			m_ramGraphResolutionSlider.onValueChanged.AddListener(delegate(float value)
			{
				m_graphyManager.RamGraphResolution = (int)value;
			});
			m_ramTextUpdateRateSlider.onValueChanged.AddListener(delegate(float value)
			{
				m_graphyManager.RamTextUpdateRate = (int)value;
			});
			m_audioModuleStateDropdown.onValueChanged.AddListener(delegate(int value)
			{
				m_graphyManager.AudioModuleState = (GraphyManager.ModuleState)value;
			});
			m_audioGraphColorButton.onClick.AddListener(delegate
			{
				m_colorPicker.SetOnValueChangeCallback(null);
				m_colorPicker.Color = m_audioGraphColorButton.GetComponent<Image>().color;
				m_colorPicker.SetOnValueChangeCallback(delegate(Color color)
				{
					m_audioGraphColorButton.GetComponent<Image>().color = color;
					m_graphyManager.AudioGraphColor = color;
				});
			});
			m_findAudioListenerDropdown.onValueChanged.AddListener(delegate(int value)
			{
				m_graphyManager.FindAudioListenerInCameraIfNull = (GraphyManager.LookForAudioListener)value;
			});
			m_fttWindowDropdown.onValueChanged.AddListener(delegate(int value)
			{
				m_graphyManager.FftWindow = (FFTWindow)value;
			});
			m_spectrumSizeSlider.onValueChanged.AddListener(delegate(float value)
			{
				m_graphyManager.SpectrumSize = (int)value;
			});
			m_audioGraphResolutionSlider.onValueChanged.AddListener(delegate(float value)
			{
				m_graphyManager.AudioGraphResolution = (int)value;
			});
			m_audioTextUpdateRateSlider.onValueChanged.AddListener(delegate(float value)
			{
				m_graphyManager.AudioTextUpdateRate = (int)value;
			});
			m_advancedModulePositionDropdown.onValueChanged.AddListener(delegate(int value)
			{
				m_graphyManager.AdvancedModulePosition = (GraphyManager.ModulePosition)value;
			});
			m_advancedModuleToggle.onValueChanged.AddListener(delegate(bool value)
			{
				m_graphyManager.AdvancedModuleState = ((!value) ? GraphyManager.ModuleState.OFF : GraphyManager.ModuleState.FULL);
			});
			m_musicButton.onClick.AddListener(ToggleMusic);
			m_sfxButton.onClick.AddListener(PlayRandomSFX);
			m_musicVolumeSlider.onValueChanged.AddListener(delegate(float value)
			{
				m_musicAudioSource.volume = value / 100f;
			});
			m_sfxVolumeSlider.onValueChanged.AddListener(delegate(float value)
			{
				m_sfxAudioSource.volume = value / 100f;
			});
		}

		private void ToggleMusic()
		{
			if (m_musicAudioSource.isPlaying)
			{
				m_musicAudioSource.Pause();
			}
			else
			{
				m_musicAudioSource.Play();
			}
		}

		private void PlayRandomSFX()
		{
			if (m_sfxAudioClips.Count > 0)
			{
				m_sfxAudioSource.clip = m_sfxAudioClips[UnityEngine.Random.Range(0, m_sfxAudioClips.Count)];
				m_sfxAudioSource.Play();
			}
		}
	}
	public class ForceSliderToMultipleOf3 : MonoBehaviour
	{
		[SerializeField]
		private Slider m_slider;

		private void Start()
		{
			m_slider.onValueChanged.AddListener(UpdateValue);
		}

		private void UpdateValue(float value)
		{
			int num = (int)value;
			if (num % 3 != 0 && num < 300)
			{
				num += 3 - num % 3;
			}
			m_slider.value = num;
		}
	}
	public class ForceSliderToPowerOf2 : MonoBehaviour
	{
		[SerializeField]
		private Slider m_slider;

		private int[] m_powerOf2Values = new int[7] { 128, 256, 512, 1024, 2048, 4096, 8192 };

		private Text m_text;

		private void Start()
		{
			m_slider.onValueChanged.AddListener(UpdateValue);
		}

		private void UpdateValue(float value)
		{
			int num = 0;
			int num2 = 100000;
			for (int i = 0; i < m_powerOf2Values.Length; i++)
			{
				int num3 = Mathf.Abs((int)value - m_powerOf2Values[i]);
				if (num3 < num2)
				{
					num2 = num3;
					num = i;
				}
			}
			m_slider.value = m_powerOf2Values[num];
		}
	}
	public class UpdateTextWithSliderValue : MonoBehaviour
	{
		[SerializeField]
		private Slider m_slider;

		private Text m_text;

		private void Start()
		{
			m_text = GetComponent<Text>();
			m_slider.onValueChanged.AddListener(UpdateText);
		}

		private void UpdateText(float value)
		{
			m_text.text = value.ToString();
		}
	}
}
namespace SSFS
{
	public enum TextureSwapMode
	{
		Manual,
		Automatic,
		External
	}
	public class TextureSwapper : MonoBehaviour
	{
		public bool off;

		public TextureSwapMode mode = TextureSwapMode.Automatic;

		public bool remote;

		public Renderer targetRenderer;

		[NonSerialized]
		private Renderer _r;

		[NonSerialized]
		private Material _m;

		public List<Texture> textures = new List<Texture>();

		[Range(0.5f, 5f)]
		public float transitionSpeed = 1f;

		public float transitionDelay = 5f;

		public KeyCode swapKey = KeyCode.Space;

		public bool randomOrder;

		private bool _swapping;

		private float t = 0.1f;

		private float tr = 1f;

		private int i;

		private int ni;

		public Renderer r
		{
			get
			{
				if (remote)
				{
					_r = targetRenderer;
				}
				if (_r == null)
				{
					_r = GetComponent<Renderer>();
				}
				return _r;
			}
		}

		public Material m
		{
			get
			{
				if (_m == null && r != null && r.material != null)
				{
					_m = new Material(r.material);
					_m.name = "Temp SSFS Material";
					r.sharedMaterial = _m;
				}
				return _m;
			}
		}

		public bool swapping => _swapping;

		public void Update()
		{
			t = Time.deltaTime * transitionSpeed;
			if (mode == TextureSwapMode.Automatic)
			{
				tr -= t;
				if (tr <= 0f)
				{
					SwapTexture();
					tr = transitionDelay;
				}
			}
			else if (mode == TextureSwapMode.Manual && Input.GetKeyDown(swapKey))
			{
				SwapTexture();
			}
		}

		public void SwapTexture(int id = -1)
		{
			if (textures.Count >= 2)
			{
				int nextIndex = ((id >= 0) ? Mathf.Clamp(id, 0, textures.Count) : (randomOrder ? UnityEngine.Random.Range(0, textures.Count) : ((int)Mathf.Repeat((float)i + 1f, textures.Count))));
				StartCoroutine(Transition(nextIndex));
			}
		}

		public void ToggleState()
		{
			StartCoroutine(Toggle());
		}

		private IEnumerator Transition(int nextIndex)
		{
			if (m != null && textures.Count > 1 && !_swapping && !off)
			{
				_swapping = true;
				float p = 1f;
				m.SetFloat("_Phase", p);
				ni = nextIndex;
				m.SetTexture("_MainTex", textures[i]);
				m.SetTexture("_MainTex2", textures[ni]);
				m.EnableKeyword("TEXTURE_SWAP");
				while (p > 0f)
				{
					m.SetFloat("_Phase", p);
					p -= t;
					yield return new WaitForEndOfFrame();
				}
				i = ni;
				m.SetTexture("_MainTex", textures[i]);
				m.SetFloat("_Phase", 1f);
				_swapping = false;
			}
		}

		private IEnumerator Toggle()
		{
			if (m != null && !_swapping)
			{
				_swapping = true;
				m.SetTexture("_MainTex2", null);
				m.DisableKeyword("TEXTURE_SWAP");
				float p = (off ? 0f : 1f);
				while (off ? (p < 1f) : (p > 0f))
				{
					p += (off ? t : (0f - t));
					m.SetFloat("_Phase", p);
					yield return new WaitForEndOfFrame();
				}
				off = !off;
				_swapping = false;
			}
		}
	}
	public static class MaterialExtensions
	{
		public static IEnumerator SSFSPhaseTo(this Material m, float endPhase, float time = 1f)
		{
			float o = m.GetFloat("_Phase");
			while ((double)Mathf.Abs(o - endPhase) > 0.0001)
			{
				float maxDelta = Time.deltaTime / time;
				Mathf.MoveTowards(o, endPhase, maxDelta);
				yield return new WaitForEndOfFrame();
			}
		}

		public static void SyncKeyword(this Material m, string keyword, bool state)
		{
			if (!(m == null))
			{
				if (state)
				{
					m.EnableKeyword(keyword);
				}
				else
				{
					m.DisableKeyword(keyword);
				}
			}
		}

		public static void SetVector(this Material m, string name, Vector2 v1, Vector2 v2)
		{
			m.SetVector(name, new Vector4(v1.x, v1.y, v2.x, v2.y));
		}

		public static void GetVector(this Material m, string name, out Vector2 v1, out Vector2 v2)
		{
			Vector4 vector = m.GetVector(name);
			v1 = new Vector2(vector.x, vector.y);
			v2 = new Vector2(vector.z, vector.w);
		}

		public static Vector4 Append(this Vector2 v1, Vector2 v2)
		{
			return new Vector4(v1.x, v1.y, v2.x, v2.y);
		}

		public static void Split(this Vector4 v0, out Vector2 v1, out Vector2 v2)
		{
			v1 = new Vector2(v0.x, v0.y);
			v2 = new Vector2(v0.z, v0.w);
		}
	}
	public static class SSFSCore
	{
		public static string shaderPath => "Sci-Fi/SSFS/Base";

		public static Shader shader
		{
			get
			{
				Shader obj = Shader.Find(shaderPath);
				if (obj == null)
				{
					UnityEngine.Debug.LogError("SSFS SHADER NOT FOUND");
				}
				return obj;
			}
		}

		public static Material newMaterial
		{
			get
			{
				Material material = new Material(shader);
				if (material == null)
				{
					UnityEngine.Debug.LogError("SSFS MATERIAL CREATION FAILED");
				}
				else
				{
					material.name = "New SSFS Material";
				}
				return material;
			}
		}
	}
	[RequireComponent(typeof(MeshRenderer))]
	public class SSFS_GeneratorTester : MonoBehaviour
	{
		private MeshRenderer _mr;

		private Material mat;

		public SSFSGenerator generator;

		public KeyCode key = KeyCode.R;

		private MeshRenderer mr
		{
			get
			{
				if (_mr == null)
				{
					_mr = GetComponent<MeshRenderer>();
				}
				return _mr;
			}
		}

		private void Start()
		{
			mat = generator.GenerateMaterial();
			mr.material = mat;
		}

		private void Update()
		{
			if (Input.GetKeyDown(key))
			{
				if (generator == null)
				{
					UnityEngine.Debug.Log("Null SSFS Generator");
				}
				else
				{
					generator.GenerateMaterial(ref mat);
				}
			}
		}
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(Camera))]
	[AddComponentMenu("Image Effects/SSFS Post")]
	public class SSFS_PostEffect : MonoBehaviour
	{
		[Serializable]
		public class SSFSShellVars
		{
			public Color mainColor;

			public Color effectColor;

			public Vector2 mainTextureOffset;

			public Vector2 mainTextureScale;

			public Vector2 mainTexture2Offset;

			public Vector2 mainTexture2Scale;

			public Texture mainTexture;

			public Texture mainTexture2;

			public Texture noiseTexture;

			public Vector2 tileCount;

			public Vector2 scaling;

			public Vector2 scalingCenter;

			public Vector2 RotationRadial;

			public float phase;

			public float sharpness;

			public float overbright;

			public float aberration;

			public float effectAberration;

			public float flash;

			public float flicker;

			public float idleAmount;

			public float idleSpeed;

			public float idleRand;

			public float scattering;

			public float scanlineIntensity;

			public float scanlineScale;

			public float scanlineShift;

			public float scanlineSpeed;

			public float scaleAroundTile;

			public float backfaceVisibility;

			public bool complex;

			public bool squareTiles;

			public bool invertPhase;

			public bool invertIdle;

			public bool clipTiles;

			public bool roundClipping;

			public bool twoSided;

			public SSFSShellVars()
			{
				mainColor = Color.white;
				effectColor = Color.white;
				mainTextureOffset = Vector2.zero;
				mainTextureScale = Vector2.one;
				mainTexture2Offset = Vector2.zero;
				mainTexture2Scale = Vector2.one;
				mainTexture = null;
				mainTexture2 = null;
				noiseTexture = null;
				tileCount = new Vector2(42f, 42f);
				scaling = Vector2.zero;
				scalingCenter = Vector2.one * 0.5f;
				RotationRadial = new Vector2(0.5f, 0f);
				scattering = 0.25f;
				scanlineIntensity = 0.2f;
				scanlineScale = 1f;
				scanlineShift = 0f;
				scaleAroundTile = 0f;
				backfaceVisibility = 0.5f;
				phase = 1f;
				sharpness = 0.6f;
				overbright = 0f;
				aberration = 0.2f;
				effectAberration = 0.5f;
				flash = 0.1f;
				flicker = 0.1f;
				idleAmount = 0.2f;
				idleSpeed = 0.2f;
				idleRand = 0f;
				complex = true;
				squareTiles = false;
				invertPhase = false;
				invertIdle = false;
				clipTiles = false;
				roundClipping = false;
				twoSided = true;
			}

			public void Apply(ref Material m)
			{
				if (!(m == null))
				{
					m.SyncKeyword("COMPLEX", complex);
					m.SetFloat("_Phase", phase);
					m.SetFloat("_PhaseSharpness", sharpness);
					m.SetFloat("_Overbright", overbright);
					m.SyncKeyword("IDLE", idleAmount > 0f);
					m.SetVector("_IdleData", new Vector4(idleAmount, idleSpeed, idleRand, invertIdle ? 1f : 0f));
					m.SetFloat("_Idle", idleAmount);
					m.SetFloat("_IdleSpeed", idleSpeed);
					m.SetFloat("_IdleRand", idleRand);
					m.SetColor("_Color", mainColor);
					m.SetColor("_Color2", effectColor);
					m.SyncKeyword("TEXTURE_SWAP", mainTexture2 != null);
					m.SetTexture("_MainTex2", mainTexture2);
					m.SetTexture("_Noise", noiseTexture);
					m.SetVector("_TileCount", tileCount);
					m.SetVector("_Scaling", scaling.Append(scalingCenter));
					m.SetFloat("_Scattering", scattering);
					m.SetFloat("_BackfaceVisibility", backfaceVisibility);
					m.SetFloat("_FlashAmount", flash);
					m.SetFloat("_Flicker", flicker);
					m.SyncKeyword("RADIAL", RotationRadial.y > 0f);
					m.SetVector("_PhaseDirection", RotationRadial);
					m.SyncKeyword("SCALE_AROUND_TILE", scaleAroundTile > 0f);
					m.SetFloat("_ScaleAroundTile", scaleAroundTile);
					m.SetFloat("_SquareTiles", squareTiles ? 1f : 0f);
					m.SetFloat("_InvertPhase", invertPhase ? 1f : 0f);
					m.SetFloat("_InvertIdle", invertIdle ? 1f : 0f);
					m.SyncKeyword("CLIPPING", clipTiles);
					m.SetFloat("_ClippedTiles", clipTiles ? 1f : 0f);
					m.SetFloat("_RoundClipping", roundClipping ? 1f : 0f);
					m.SyncKeyword("ABERRATION", aberration > 0f || effectAberration > 0f);
					m.SetFloat("_Aberration", aberration);
					m.SetFloat("_EffectAberration", effectAberration);
					m.SyncKeyword("SCAN_LINES", scanlineIntensity > 0f || scanlineShift > 0f);
					m.SetVector("_ScanlineData", new Vector4(scanlineIntensity, scanlineScale, scanlineShift, scanlineSpeed));
				}
			}
		}

		public Camera transitionCamera;

		public bool forceUpdate;

		private Material _m;

		public SSFSShellVars vars = new SSFSShellVars();

		private Material m
		{
			get
			{
				if (_m == null)
				{
					_m = SSFSCore.newMaterial;
					_m.name = "SSFS_POST_TEMP_MATERIAL";
					_m.SetInt("_ZWrite", 0);
					_m.SetInt("_ZTest", 8);
					_m.SetInt("_Cull", 0);
					_m.SetInt("_BlendSrc", 1);
					_m.SetInt("_BlendDst", 0);
					_m.EnableKeyword("POST");
					_m.renderQueue = -1;
				}
				return _m;
			}
		}

		private void OnEnable()
		{
			UpdateMaterialVars();
		}

		private void OnDisable()
		{
			if (_m != null)
			{
				UnityEngine.Object.Destroy(_m);
			}
		}

		public void UpdateMaterialVars()
		{
			if (transitionCamera != null)
			{
				if (transitionCamera.targetTexture == null)
				{
					transitionCamera.targetTexture = new RenderTexture(Screen.width, Screen.height, 16);
				}
				vars.mainTexture2 = transitionCamera.targetTexture;
			}
			else
			{
				vars.mainTexture2 = null;
			}
			vars.Apply(ref _m);
		}

		private void OnRenderImage(RenderTexture src, RenderTexture dst)
		{
			if (m == null)
			{
				Graphics.Blit(src, dst);
				return;
			}
			if (forceUpdate)
			{
				UpdateMaterialVars();
			}
			else
			{
				m.SetFloat("_Phase", vars.phase);
			}
			Graphics.Blit(src, dst, m);
		}
	}
	public class SimpleSSFSToggle : MonoBehaviour
	{
		public enum TargetMode
		{
			Material,
			Renderer
		}

		public enum ToggleMode
		{
			KeyPress,
			KeyHold,
			Boolean,
			Timer
		}

		public TargetMode targetMode;

		public ToggleMode toggleMode;

		public Material material;

		public Renderer targetRenderer;

		public bool phaseOn = true;

		public KeyCode key = KeyCode.E;

		public float timerDelay = 5f;

		public float transitionLength = 0.2f;

		private float targetPhase = 1f;

		private float timer;

		private bool transitioning;

		private Material _mat;

		private Material mat
		{
			get
			{
				if (_mat == null)
				{
					switch (targetMode)
					{
					case TargetMode.Material:
						_mat = material;
						break;
					case TargetMode.Renderer:
						_mat = targetRenderer.sharedMaterial;
						break;
					}
				}
				return _mat;
			}
		}

		private void Update()
		{
			float @float = mat.GetFloat("_Phase");
			switch (toggleMode)
			{
			case ToggleMode.KeyPress:
				if (Input.GetKeyDown(key) && !transitioning)
				{
					transitioning = true;
					targetPhase = ((@float > 0.5f) ? 0f : 1f);
				}
				break;
			case ToggleMode.KeyHold:
				targetPhase = (Input.GetKey(key) ? 1f : 0f);
				transitioning = @float != targetPhase;
				break;
			case ToggleMode.Boolean:
				targetPhase = (phaseOn ? 1f : 0f);
				transitioning = @float != targetPhase;
				break;
			case ToggleMode.Timer:
				timer += Time.deltaTime;
				if (timer > timerDelay)
				{
					transitioning = true;
					targetPhase = ((@float > 0.5f) ? 0f : 1f);
					timer = 0f;
				}
				break;
			}
			if (transitioning)
			{
				if (Mathf.Abs(@float - targetPhase) > 0.0001f)
				{
					mat.SetFloat("_Phase", Mathf.MoveTowards(@float, targetPhase, Time.deltaTime / transitionLength));
				}
				else
				{
					transitioning = false;
				}
			}
		}
	}
}
namespace RealisticEyeMovements
{
	[Serializable]
	public class EyeRotationLimiter
	{
		[Serializable]
		public class EyeRotationLimiterForExport
		{
			public string transformPath;

			public SerializableQuaternion defaultQ;

			public SerializableQuaternion lookUpQ;

			public SerializableQuaternion lookDownQ;

			public bool isLookUpSet;

			public bool isLookDownSet;
		}

		[SerializeField]
		private Transform transform;

		[SerializeField]
		private Quaternion defaultQ;

		[SerializeField]
		private Quaternion lookUpQ;

		[SerializeField]
		private Quaternion lookDownQ;

		public float maxUpAngle;

		public float maxDownAngle;

		[SerializeField]
		private bool isLookUpSet;

		[SerializeField]
		private bool isLookDownSet;

		public bool CanImport(EyeRotationLimiterForExport import, Transform startXform)
		{
			return Utils.CanGetTransformFromPath(startXform, import.transformPath);
		}

		public float ClampAngle(float angle)
		{
			return Mathf.Clamp(Utils.NormalizedDegAngle(angle), 0f - maxUpAngle, maxDownAngle);
		}

		public EyeRotationLimiterForExport GetExport(Transform startXform)
		{
			return new EyeRotationLimiterForExport
			{
				transformPath = Utils.GetPathForTransform(startXform, transform),
				defaultQ = defaultQ,
				lookUpQ = lookUpQ,
				lookDownQ = lookDownQ,
				isLookUpSet = isLookUpSet,
				isLookDownSet = isLookDownSet
			};
		}

		public float GetEyeUp01(float angle)
		{
			if (!(angle >= 0f))
			{
				return Mathf.InverseLerp(0f, maxUpAngle, 0f - angle);
			}
			return 0f;
		}

		public float GetEyeDown01(float angle)
		{
			if (!(angle <= 0f))
			{
				return Mathf.InverseLerp(0f, maxDownAngle, angle);
			}
			return 0f;
		}

		public void Import(EyeRotationLimiterForExport import, Transform startXform)
		{
			transform = Utils.GetTransformFromPath(startXform, import.transformPath);
			defaultQ = import.defaultQ;
			lookUpQ = import.lookUpQ;
			lookDownQ = import.lookDownQ;
			isLookUpSet = import.isLookUpSet;
			isLookDownSet = import.isLookDownSet;
			UpdateMaxAngles();
		}

		public void RestoreDefault()
		{
			transform.localRotation = defaultQ;
		}

		public void RestoreLookDown()
		{
			transform.localRotation = lookDownQ;
		}

		public void RestoreLookUp()
		{
			transform.localRotation = lookUpQ;
		}

		public void SaveDefault(Transform t)
		{
			transform = t;
			defaultQ = t.localRotation;
			if (!isLookDownSet)
			{
				lookDownQ = defaultQ * Quaternion.Euler(20f, 0f, 0f);
			}
			if (!isLookUpSet)
			{
				lookUpQ = defaultQ * Quaternion.Euler(-8f, 0f, 0f);
			}
			UpdateMaxAngles();
		}

		public void SaveLookDown()
		{
			lookDownQ = transform.localRotation;
			UpdateMaxAngles();
			isLookDownSet = true;
		}

		public void SaveLookUp()
		{
			lookUpQ = transform.localRotation;
			UpdateMaxAngles();
			isLookUpSet = true;
		}

		private void UpdateMaxAngles()
		{
			Vector3 eulerAngles = (Quaternion.Inverse(defaultQ) * lookUpQ).eulerAngles;
			maxUpAngle = Mathf.Max(Mathf.Abs(Utils.NormalizedDegAngle(eulerAngles.x)), Mathf.Max(Mathf.Abs(Utils.NormalizedDegAngle(eulerAngles.y)), Mathf.Abs(Utils.NormalizedDegAngle(eulerAngles.z))));
			Vector3 eulerAngles2 = (Quaternion.Inverse(defaultQ) * lookDownQ).eulerAngles;
			maxDownAngle = Mathf.Max(Mathf.Abs(Utils.NormalizedDegAngle(eulerAngles2.x)), Mathf.Max(Mathf.Abs(Utils.NormalizedDegAngle(eulerAngles2.y)), Mathf.Abs(Utils.NormalizedDegAngle(eulerAngles2.z))));
		}
	}
	[Serializable]
	public class EyelidRotationLimiter
	{
		[Serializable]
		public class EyelidRotationLimiterForExport
		{
			public string transformPath;

			public SerializableQuaternion defaultQ;

			public SerializableQuaternion closedQ;

			public SerializableQuaternion lookUpQ;

			public SerializableQuaternion lookDownQ;

			public float eyeMaxDownAngle;

			public float eyeMaxUpAngle;

			public SerializableVector3 defaultPos;

			public SerializableVector3 closedPos;

			public SerializableVector3 lookUpPos;

			public SerializableVector3 lookDownPos;

			public bool isLookUpSet;

			public bool isLookDownSet;

			public bool isDefaultPosSet;

			public bool isClosedPosSet;

			public bool isLookUpPosSet;

			public bool isLookDownPosSet;
		}

		[SerializeField]
		private Transform transform;

		[SerializeField]
		private Quaternion defaultQ;

		[SerializeField]
		private Quaternion closedQ;

		[SerializeField]
		private Quaternion lookUpQ;

		[SerializeField]
		private Quaternion lookDownQ;

		[SerializeField]
		private float eyeMaxDownAngle;

		[SerializeField]
		private float eyeMaxUpAngle;

		[SerializeField]
		private Vector3 defaultPos;

		[SerializeField]
		private Vector3 closedPos;

		[SerializeField]
		private Vector3 lookUpPos;

		[SerializeField]
		private Vector3 lookDownPos;

		[SerializeField]
		private bool isLookUpSet;

		[SerializeField]
		private bool isLookDownSet;

		[SerializeField]
		private bool isDefaultPosSet;

		[SerializeField]
		private bool isClosedPosSet;

		[SerializeField]
		private bool isLookUpPosSet;

		[SerializeField]
		private bool isLookDownPosSet;

		public bool CanImport(EyelidRotationLimiterForExport import, Transform startXform)
		{
			return Utils.CanGetTransformFromPath(startXform, import.transformPath);
		}

		public EyelidRotationLimiterForExport GetExport(Transform startXform)
		{
			return new EyelidRotationLimiterForExport
			{
				transformPath = Utils.GetPathForTransform(startXform, transform),
				defaultQ = defaultQ,
				closedQ = closedQ,
				lookUpQ = lookUpQ,
				lookDownQ = lookDownQ,
				eyeMaxDownAngle = eyeMaxDownAngle,
				eyeMaxUpAngle = eyeMaxUpAngle,
				defaultPos = defaultPos,
				closedPos = closedPos,
				lookUpPos = lookUpPos,
				lookDownPos = lookDownPos,
				isLookUpSet = isLookUpSet,
				isLookDownSet = isLookDownSet,
				isDefaultPosSet = isDefaultPosSet,
				isClosedPosSet = isClosedPosSet,
				isLookUpPosSet = isLookUpPosSet,
				isLookDownPosSet = isLookDownPosSet
			};
		}

		public void GetRotationAndPosition(float eyeAngle, float blink01, float eyeWidenOrSquint, bool isUpper, out Quaternion rotation, ref Vector3 position, ControlData.EyelidBoneMode eyelidBoneMode)
		{
			bool flag = eyeAngle > 0f;
			float t = Mathf.InverseLerp(0f, flag ? eyeMaxDownAngle : (0f - eyeMaxUpAngle), eyeAngle);
			if (eyeWidenOrSquint < 0f)
			{
				blink01 = Mathf.Lerp(blink01, 1f, 0f - eyeWidenOrSquint);
			}
			if (eyelidBoneMode == ControlData.EyelidBoneMode.RotationAndPosition || eyelidBoneMode == ControlData.EyelidBoneMode.Rotation)
			{
				rotation = Quaternion.Slerp(defaultQ, flag ? lookDownQ : lookUpQ, t);
				rotation = Quaternion.Slerp(rotation, closedQ, blink01);
				if (eyeWidenOrSquint > 0f)
				{
					rotation = Quaternion.Slerp(rotation, isUpper ? lookUpQ : lookDownQ, eyeWidenOrSquint);
				}
			}
			else
			{
				rotation = Quaternion.identity;
			}
			if (eyelidBoneMode != 0 && eyelidBoneMode != ControlData.EyelidBoneMode.Position)
			{
				return;
			}
			if (flag)
			{
				if (isDefaultPosSet && isLookDownPosSet)
				{
					position = Vector3.Lerp(defaultPos, lookDownPos, t);
				}
			}
			else if (isDefaultPosSet && isLookUpPosSet)
			{
				position = Vector3.Lerp(defaultPos, lookUpPos, t);
			}
			if (isDefaultPosSet && isClosedPosSet)
			{
				position = Vector3.Lerp(position, closedPos, blink01);
			}
			if (eyeWidenOrSquint > 0f)
			{
				position = Vector3.Lerp(position, isUpper ? lookUpPos : lookDownPos, eyeWidenOrSquint);
			}
		}

		public void Import(EyelidRotationLimiterForExport import, Transform startXform)
		{
			transform = Utils.GetTransformFromPath(startXform, import.transformPath);
			defaultQ = import.defaultQ;
			closedQ = import.closedQ;
			lookUpQ = import.lookUpQ;
			lookDownQ = import.lookDownQ;
			eyeMaxDownAngle = import.eyeMaxDownAngle;
			eyeMaxUpAngle = import.eyeMaxUpAngle;
			defaultPos = import.defaultPos;
			closedPos = import.closedPos;
			lookUpPos = import.lookUpPos;
			lookDownPos = import.lookDownPos;
			isLookUpSet = import.isLookUpSet;
			isLookDownSet = import.isLookDownSet;
			isDefaultPosSet = import.isDefaultPosSet;
			isClosedPosSet = import.isClosedPosSet;
			isLookUpPosSet = import.isLookUpPosSet;
			isLookDownPosSet = import.isLookDownPosSet;
		}

		public void RestoreClosed(ControlData.EyelidBoneMode eyelidBoneMode)
		{
			if (eyelidBoneMode == ControlData.EyelidBoneMode.RotationAndPosition || eyelidBoneMode == ControlData.EyelidBoneMode.Rotation)
			{
				transform.localRotation = closedQ;
			}
			if ((eyelidBoneMode == ControlData.EyelidBoneMode.RotationAndPosition || eyelidBoneMode == ControlData.EyelidBoneMode.Position) && isClosedPosSet)
			{
				transform.localPosition = closedPos;
			}
		}

		public void RestoreDefault(ControlData.EyelidBoneMode eyelidBoneMode)
		{
			if (eyelidBoneMode == ControlData.EyelidBoneMode.RotationAndPosition || eyelidBoneMode == ControlData.EyelidBoneMode.Rotation)
			{
				transform.localRotation = defaultQ;
			}
			if ((eyelidBoneMode == ControlData.EyelidBoneMode.RotationAndPosition || eyelidBoneMode == ControlData.EyelidBoneMode.Position) && isDefaultPosSet)
			{
				transform.localPosition = defaultPos;
			}
		}

		public void RestoreLookDown(ControlData.EyelidBoneMode eyelidBoneMode)
		{
			if (eyelidBoneMode == ControlData.EyelidBoneMode.RotationAndPosition || eyelidBoneMode == ControlData.EyelidBoneMode.Rotation)
			{
				transform.localRotation = lookDownQ;
			}
			if ((eyelidBoneMode == ControlData.EyelidBoneMode.RotationAndPosition || eyelidBoneMode == ControlData.EyelidBoneMode.Position) && isLookDownPosSet)
			{
				transform.localPosition = lookDownPos;
			}
		}

		public void RestoreLookUp(ControlData.EyelidBoneMode eyelidBoneMode)
		{
			if (eyelidBoneMode == ControlData.EyelidBoneMode.RotationAndPosition || eyelidBoneMode == ControlData.EyelidBoneMode.Rotation)
			{
				transform.localRotation = lookUpQ;
			}
			if ((eyelidBoneMode == ControlData.EyelidBoneMode.RotationAndPosition || eyelidBoneMode == ControlData.EyelidBoneMode.Position) && isLookUpPosSet)
			{
				transform.localPosition = lookUpPos;
			}
		}

		public void SaveClosed()
		{
			closedQ = transform.localRotation;
			closedPos = transform.localPosition;
			isClosedPosSet = true;
		}

		public void SaveDefault(Transform t)
		{
			transform = t;
			defaultQ = t.localRotation;
			if (!isLookDownSet)
			{
				lookDownQ = defaultQ * Quaternion.Euler(20f, 0f, 0f);
			}
			if (!isLookUpSet)
			{
				lookUpQ = defaultQ * Quaternion.Euler(-8f, 0f, 0f);
			}
			defaultPos = t.localPosition;
			isDefaultPosSet = true;
			if (!isLookUpPosSet)
			{
				lookUpPos = defaultPos;
			}
			if (!isLookDownPosSet)
			{
				lookDownPos = defaultPos;
			}
			if (!isClosedPosSet)
			{
				closedPos = defaultPos;
			}
		}

		public void SaveLookDown(float eyeMaxDownAngle)
		{
			this.eyeMaxDownAngle = eyeMaxDownAngle;
			lookDownQ = transform.localRotation;
			lookDownPos = transform.localPosition;
			isLookDownSet = true;
			isLookDownPosSet = true;
		}

		public void SaveLookUp(float eyeMaxUpAngle)
		{
			this.eyeMaxUpAngle = eyeMaxUpAngle;
			lookUpQ = transform.localRotation;
			lookUpPos = transform.localPosition;
			isLookUpSet = true;
			isLookUpPosSet = true;
		}
	}
	[Serializable]
	public class ControlData
	{
		[Serializable]
		public class ControlDataForExport
		{
			public EyeControl eyeControl;

			public EyelidBoneMode eyelidBoneMode;

			public string leftEyePath;

			public string rightEyePath;

			public float maxEyeUpBoneAngle;

			public float maxEyeDownBoneAngle;

			public float maxEyeUpEyeballAngle;

			public float maxEyeDownEyeballAngle;

			public bool isEyeBallDefaultSet;

			public bool isEyeBoneDefaultSet;

			public bool isEyeBallLookUpSet;

			public bool isEyeBoneLookUpSet;

			public bool isEyeBallLookDownSet;

			public bool isEyeBoneLookDownSet;

			public EyeRotationLimiter.EyeRotationLimiterForExport leftBoneEyeRotationLimiter;

			public EyeRotationLimiter.EyeRotationLimiterForExport rightBoneEyeRotationLimiter;

			public EyeRotationLimiter.EyeRotationLimiterForExport leftEyeballEyeRotationLimiter;

			public EyeRotationLimiter.EyeRotationLimiterForExport rightEyeballEyeRotationLimiter;

			public EyelidControl eyelidControl;

			public bool eyelidsFollowEyesVertically;

			public string upperEyeLidLeftPath;

			public string upperEyeLidRightPath;

			public string lowerEyeLidLeftPath;

			public string lowerEyeLidRightPath;

			public bool isEyelidBonesDefaultSet;

			public bool isEyelidBonesClosedSet;

			public bool isEyelidBonesLookUpSet;

			public bool isEyelidBonesLookDownSet;

			public EyelidRotationLimiter.EyelidRotationLimiterForExport upperLeftLimiter;

			public EyelidRotationLimiter.EyelidRotationLimiterForExport upperRightLimiter;

			public EyelidRotationLimiter.EyelidRotationLimiterForExport lowerLeftLimiter;

			public EyelidRotationLimiter.EyelidRotationLimiterForExport lowerRightLimiter;

			public float eyeWidenOrSquint;

			public EyelidPositionBlendshapeForExport[] blendshapesForBlinking;

			public EyelidPositionBlendshapeForExport[] blendshapesForLookingUp;

			public EyelidPositionBlendshapeForExport[] blendshapesForLookingDown;

			public BlendshapesConfigForExport[] blendshapesConfigs;

			public bool isEyelidBlendshapeDefaultSet;

			public bool isEyelidBlendshapeClosedSet;

			public bool isEyelidBlendshapeLookUpSet;

			public bool isEyelidBlendshapeLookDownSet;
		}

		public enum EyeControl
		{
			None,
			MecanimEyeBones,
			SelectedObjects
		}

		public enum EyelidControl
		{
			None,
			Bones,
			Blendshapes,
			MCS_Blendshapes
		}

		public enum EyelidBoneMode
		{
			RotationAndPosition,
			Rotation,
			Position
		}

		[Serializable]
		public class EyelidPositionBlendshapeForExport
		{
			public string skinnedMeshRendererPath;

			public float defaultWeight;

			public float positionWeight;

			public int index;

			public string name;

			public bool isUsedInEalierConfig;
		}

		[Serializable]
		public class EyelidPositionBlendshape
		{
			public SkinnedMeshRenderer skinnedMeshRenderer;

			public float defaultWeight;

			public float positionWeight;

			public int index;

			public string name;

			public bool isUsedInEalierConfig;

			public static bool CanImport(EyelidPositionBlendshapeForExport import, Transform startXform, EyelidControl eyelidControl)
			{
				if (string.IsNullOrEmpty(import.skinnedMeshRendererPath))
				{
					return false;
				}
				Transform transformFromPath = Utils.GetTransformFromPath(startXform, import.skinnedMeshRendererPath);
				if (transformFromPath == null)
				{
					return false;
				}
				SkinnedMeshRenderer component = transformFromPath.GetComponent<SkinnedMeshRenderer>();
				if (component == null)
				{
					return false;
				}
				if (import.index >= component.sharedMesh.blendShapeCount)
				{
					return false;
				}
				if (!string.IsNullOrEmpty(import.name))
				{
					bool flag = false;
					for (int i = 0; i < component.sharedMesh.blendShapeCount; i++)
					{
						if (component.sharedMesh.GetBlendShapeName(i).Equals(import.name))
						{
							flag = true;
							break;
						}
					}
					if (!flag)
					{
						return false;
					}
				}
				return true;
			}

			public EyelidPositionBlendshapeForExport GetExport(Transform startXform)
			{
				return new EyelidPositionBlendshapeForExport
				{
					skinnedMeshRendererPath = ((skinnedMeshRenderer != null) ? Utils.GetPathForTransform(startXform, skinnedMeshRenderer.transform) : null),
					defaultWeight = defaultWeight,
					positionWeight = positionWeight,
					index = index,
					name = name,
					isUsedInEalierConfig = isUsedInEalierConfig
				};
			}

			public void Import(EyelidPositionBlendshapeForExport export, Transform startXform)
			{
				skinnedMeshRenderer = ((export.skinnedMeshRendererPath != null) ? Utils.GetTransformFromPath(startXform, export.skinnedMeshRendererPath).GetComponent<SkinnedMeshRenderer>() : null);
				defaultWeight = export.defaultWeight;
				positionWeight = export.positionWeight;
				index = export.index;
				name = export.name;
				isUsedInEalierConfig = export.isUsedInEalierConfig;
				if (string.IsNullOrEmpty(name) || !(skinnedMeshRenderer != null))
				{
					return;
				}
				for (int i = 0; i < skinnedMeshRenderer.sharedMesh.blendShapeCount; i++)
				{
					if (skinnedMeshRenderer.sharedMesh.GetBlendShapeName(i).Equals(name))
					{
						index = i;
						break;
					}
				}
			}
		}

		[Serializable]
		public class BlendshapesConfigForExport
		{
			public string skinnedMeshRendererPath;

			public int blendShapeCount;

			public string[] blendshapeNames;

			public float[] blendshapeWeights;
		}

		[Serializable]
		public class BlendshapesConfig
		{
			public SkinnedMeshRenderer skinnedMeshRenderer;

			public int blendShapeCount;

			public string[] blendshapeNames;

			public float[] blendshapeWeights;

			public static bool CanImport(BlendshapesConfigForExport import, Transform startXform)
			{
				if (string.IsNullOrEmpty(import.skinnedMeshRendererPath))
				{
					return false;
				}
				Transform transformFromPath = Utils.GetTransformFromPath(startXform, import.skinnedMeshRendererPath);
				if (transformFromPath == null)
				{
					return false;
				}
				SkinnedMeshRenderer component = transformFromPath.GetComponent<SkinnedMeshRenderer>();
				if (component == null)
				{
					return false;
				}
				if (import.blendShapeCount != component.sharedMesh.blendShapeCount)
				{
					return false;
				}
				if (import.blendshapeNames != null && import.blendshapeNames.Length != 0)
				{
					for (int i = 0; i < import.blendShapeCount; i++)
					{
						if (!import.blendshapeNames[i].Equals(component.sharedMesh.GetBlendShapeName(i)))
						{
							return false;
						}
					}
				}
				return true;
			}

			public BlendshapesConfigForExport GetExport(Transform startXform)
			{
				return new BlendshapesConfigForExport
				{
					skinnedMeshRendererPath = ((skinnedMeshRenderer != null) ? Utils.GetPathForTransform(startXform, skinnedMeshRenderer.transform) : null),
					blendShapeCount = blendShapeCount,
					blendshapeNames = blendshapeNames,
					blendshapeWeights = blendshapeWeights
				};
			}

			public void Import(Transform startXform, BlendshapesConfigForExport import)
			{
				skinnedMeshRenderer = ((import.skinnedMeshRendererPath != null) ? Utils.GetTransformFromPath(startXform, import.skinnedMeshRendererPath).GetComponent<SkinnedMeshRenderer>() : null);
				blendShapeCount = import.blendShapeCount;
				blendshapeNames = import.blendshapeNames;
				blendshapeWeights = import.blendshapeWeights;
			}
		}

		public EyeControl eyeControl;

		public Transform leftEye;

		public Transform rightEye;

		public float maxEyeUpBoneAngle = 20f;

		public float maxEyeDownBoneAngle = 20f;

		public float maxEyeUpEyeballAngle = 20f;

		public float maxEyeDownEyeballAngle = 20f;

		public bool isEyeBallDefaultSet;

		public bool isEyeBoneDefaultSet;

		public bool isEyeBallLookUpSet;

		public bool isEyeBoneLookUpSet;

		public bool isEyeBallLookDownSet;

		public bool isEyeBoneLookDownSet;

		[SerializeField]
		private EyeRotationLimiter leftBoneEyeRotationLimiter = new EyeRotationLimiter();

		[SerializeField]
		private EyeRotationLimiter rightBoneEyeRotationLimiter = new EyeRotationLimiter();

		[SerializeField]
		private EyeRotationLimiter leftEyeballEyeRotationLimiter = new EyeRotationLimiter();

		[SerializeField]
		private EyeRotationLimiter rightEyeballEyeRotationLimiter = new EyeRotationLimiter();

		public EyelidControl eyelidControl;

		public EyelidBoneMode eyelidBoneMode;

		public bool eyelidsFollowEyesVertically;

		public Transform upperEyeLidLeft;

		public Transform upperEyeLidRight;

		public Transform lowerEyeLidLeft;

		public Transform lowerEyeLidRight;

		public bool isEyelidBonesDefaultSet;

		public bool isEyelidBonesClosedSet;

		public bool isEyelidBonesLookUpSet;

		public bool isEyelidBonesLookDownSet;

		[SerializeField]
		private EyelidRotationLimiter upperLeftLimiter = new EyelidRotationLimiter();

		[SerializeField]
		private EyelidRotationLimiter upperRightLimiter = new EyelidRotationLimiter();

		[SerializeField]
		private EyelidRotationLimiter lowerLeftLimiter = new EyelidRotationLimiter();

		[SerializeField]
		private EyelidRotationLimiter lowerRightLimiter = new EyelidRotationLimiter();

		[Tooltip("0: normal. 1: max widened, -1: max squint")]
		[Range(-1f, 1f)]
		public float eyeWidenOrSquint;

		[SerializeField]
		private EyelidPositionBlendshape[] blendshapesForBlinking = new EyelidPositionBlendshape[0];

		[SerializeField]
		private EyelidPositionBlendshape[] blendshapesForLookingUp = new EyelidPositionBlendshape[0];

		[SerializeField]
		private EyelidPositionBlendshape[] blendshapesForLookingDown = new EyelidPositionBlendshape[0];

		[SerializeField]
		private BlendshapesConfig[] blendshapesConfigs = new BlendshapesConfig[0];

		public bool isEyelidBlendshapeDefaultSet;

		public bool isEyelidBlendshapeClosedSet;

		public bool isEyelidBlendshapeLookUpSet;

		public bool isEyelidBlendshapeLookDownSet;

		public bool CanImport(ControlDataForExport import, Transform startXform)
		{
			if (!Utils.CanGetTransformFromPath(startXform, import.leftEyePath) || !Utils.CanGetTransformFromPath(startXform, import.rightEyePath) || !Utils.CanGetTransformFromPath(startXform, import.upperEyeLidLeftPath) || !Utils.CanGetTransformFromPath(startXform, import.upperEyeLidRightPath) || !Utils.CanGetTransformFromPath(startXform, import.lowerEyeLidLeftPath) || !Utils.CanGetTransformFromPath(startXform, import.lowerEyeLidRightPath) || !leftBoneEyeRotationLimiter.CanImport(import.leftBoneEyeRotationLimiter, startXform) || !rightBoneEyeRotationLimiter.CanImport(import.rightBoneEyeRotationLimiter, startXform) || !leftEyeballEyeRotationLimiter.CanImport(import.leftEyeballEyeRotationLimiter, startXform) || !rightEyeballEyeRotationLimiter.CanImport(import.rightEyeballEyeRotationLimiter, startXform) || !upperLeftLimiter.CanImport(import.upperLeftLimiter, startXform) || !upperRightLimiter.CanImport(import.upperRightLimiter, startXform) || !lowerLeftLimiter.CanImport(import.lowerLeftLimiter, startXform) || !lowerRightLimiter.CanImport(import.lowerRightLimiter, startXform))
			{
				return false;
			}
			if (import.blendshapesForBlinking != null)
			{
				EyelidPositionBlendshapeForExport[] array = import.blendshapesForBlinking;
				for (int i = 0; i < array.Length; i++)
				{
					if (!EyelidPositionBlendshape.CanImport(array[i], startXform, import.eyelidControl))
					{
						return false;
					}
				}
			}
			if (import.blendshapesForLookingUp != null)
			{
				EyelidPositionBlendshapeForExport[] array = import.blendshapesForLookingUp;
				for (int i = 0; i < array.Length; i++)
				{
					if (!EyelidPositionBlendshape.CanImport(array[i], startXform, import.eyelidControl))
					{
						return false;
					}
				}
			}
			if (import.blendshapesForLookingDown != null)
			{
				EyelidPositionBlendshapeForExport[] array = import.blendshapesForLookingDown;
				for (int i = 0; i < array.Length; i++)
				{
					if (!EyelidPositionBlendshape.CanImport(array[i], startXform, import.eyelidControl))
					{
						return false;
					}
				}
			}
			if (import.eyelidControl == EyelidControl.MCS_Blendshapes)
			{
				UnityEngine.Debug.LogError("To import a MCS_Blendshape preset, please define USE_MCS in ControlData and EyeAndHeadAnimatorEditor.");
				return false;
			}
			return true;
		}

		public void CheckConsistency(Animator animator, EyeAndHeadAnimator eyeAndHeadAnimator)
		{
			if (eyeControl == EyeControl.MecanimEyeBones)
			{
				if (null == animator)
				{
					throw new Exception("No Animator found.");
				}
				if (null == animator.GetBoneTransform(HumanBodyBones.LeftEye) || null == animator.GetBoneTransform(HumanBodyBones.LeftEye))
				{
					throw new Exception("Mecanim humanoid eye bones not found.");
				}
				if (!isEyeBoneDefaultSet)
				{
					SaveDefault(eyeAndHeadAnimator);
				}
			}
			else if (eyeControl == EyeControl.SelectedObjects)
			{
				if (null == leftEye)
				{
					throw new Exception("The left eye object hasn't been assigned.");
				}
				if (null == rightEye)
				{
					throw new Exception("The right eye object hasn't been assigned.");
				}
				if (!isEyeBallDefaultSet)
				{
					SaveDefault(eyeAndHeadAnimator);
				}
			}
			if (eyelidControl == EyelidControl.Bones)
			{
				if (upperEyeLidLeft == null || upperEyeLidRight == null)
				{
					throw new Exception("The upper eyelid bones haven't been assigned.");
				}
				if (!isEyelidBonesDefaultSet)
				{
					throw new Exception("The default eyelid position hasn't been saved.");
				}
				if (!isEyelidBonesClosedSet)
				{
					throw new Exception("The eyes closed eyelid position hasn't been saved.");
				}
				if (!isEyelidBonesLookUpSet)
				{
					throw new Exception("The eyes look up eyelid position hasn't been saved.");
				}
				if (!isEyelidBonesLookDownSet)
				{
					throw new Exception("The eyes look down eyelid position hasn't been saved.");
				}
			}
			else if (eyelidControl == EyelidControl.Blendshapes)
			{
				if (!isEyelidBlendshapeDefaultSet)
				{
					throw new Exception("The default eyelid position hasn't been saved.");
				}
				if (!isEyelidBlendshapeClosedSet)
				{
					throw new Exception("The eyes closed eyelid position hasn't been saved.");
				}
				if (!isEyelidBlendshapeLookUpSet)
				{
					throw new Exception("The eyes look up eyelid position hasn't been saved.");
				}
				if (!isEyelidBlendshapeLookDownSet)
				{
					throw new Exception("The eyes look down eyelid position hasn't been saved.");
				}
			}
		}

		public float ClampLeftVertEyeAngle(float angle)
		{
			if (eyeControl == EyeControl.MecanimEyeBones)
			{
				return leftBoneEyeRotationLimiter.ClampAngle(angle);
			}
			if (eyeControl == EyeControl.SelectedObjects)
			{
				return leftEyeballEyeRotationLimiter.ClampAngle(angle);
			}
			return angle;
		}

		public float ClampRightVertEyeAngle(float angle)
		{
			if (eyeControl == EyeControl.MecanimEyeBones)
			{
				return rightBoneEyeRotationLimiter.ClampAngle(angle);
			}
			if (eyeControl == EyeControl.SelectedObjects)
			{
				return rightEyeballEyeRotationLimiter.ClampAngle(angle);
			}
			return angle;
		}

		public ControlDataForExport GetExport(Transform startXform)
		{
			ControlDataForExport controlDataForExport = new ControlDataForExport
			{
				eyeControl = eyeControl,
				eyelidBoneMode = eyelidBoneMode,
				leftEyePath = Utils.GetPathForTransform(startXform, leftEye),
				rightEyePath = Utils.GetPathForTransform(startXform, rightEye),
				maxEyeUpBoneAngle = maxEyeUpBoneAngle,
				maxEyeDownBoneAngle = maxEyeDownBoneAngle,
				maxEyeUpEyeballAngle = maxEyeUpEyeballAngle,
				maxEyeDownEyeballAngle = maxEyeDownEyeballAngle,
				isEyeBallDefaultSet = isEyeBallDefaultSet,
				isEyeBoneDefaultSet = isEyeBoneDefaultSet,
				isEyeBallLookUpSet = isEyeBallLookUpSet,
				isEyeBoneLookUpSet = isEyeBoneLookUpSet,
				isEyeBallLookDownSet = isEyeBallLookDownSet,
				isEyeBoneLookDownSet = isEyeBoneLookDownSet,
				leftBoneEyeRotationLimiter = leftBoneEyeRotationLimiter.GetExport(startXform),
				rightBoneEyeRotationLimiter = rightBoneEyeRotationLimiter.GetExport(startXform),
				leftEyeballEyeRotationLimiter = leftEyeballEyeRotationLimiter.GetExport(startXform),
				rightEyeballEyeRotationLimiter = rightEyeballEyeRotationLimiter.GetExport(startXform),
				eyelidControl = eyelidControl,
				eyelidsFollowEyesVertically = eyelidsFollowEyesVertically,
				upperEyeLidLeftPath = Utils.GetPathForTransform(startXform, upperEyeLidLeft),
				upperEyeLidRightPath = Utils.GetPathForTransform(startXform, upperEyeLidRight),
				lowerEyeLidLeftPath = Utils.GetPathForTransform(startXform, lowerEyeLidLeft),
				lowerEyeLidRightPath = Utils.GetPathForTransform(startXform, lowerEyeLidRight),
				isEyelidBonesDefaultSet = isEyelidBonesDefaultSet,
				isEyelidBonesClosedSet = isEyelidBonesClosedSet,
				isEyelidBonesLookUpSet = isEyelidBonesLookUpSet,
				isEyelidBonesLookDownSet = isEyelidBonesLookDownSet,
				upperLeftLimiter = upperLeftLimiter.GetExport(startXform),
				upperRightLimiter = upperRightLimiter.GetExport(startXform),
				lowerLeftLimiter = lowerLeftLimiter.GetExport(startXform),
				lowerRightLimiter = lowerRightLimiter.GetExport(startXform),
				eyeWidenOrSquint = eyeWidenOrSquint,
				isEyelidBlendshapeDefaultSet = isEyelidBlendshapeDefaultSet,
				isEyelidBlendshapeClosedSet = isEyelidBlendshapeClosedSet,
				isEyelidBlendshapeLookUpSet = isEyelidBlendshapeLookUpSet,
				isEyelidBlendshapeLookDownSet = isEyelidBlendshapeLookDownSet
			};
			controlDataForExport.blendshapesForBlinking = new EyelidPositionBlendshapeForExport[blendshapesForBlinking.Length];
			for (int i = 0; i < blendshapesForBlinking.Length; i++)
			{
				controlDataForExport.blendshapesForBlinking[i] = blendshapesForBlinking[i].GetExport(startXform);
			}
			controlDataForExport.blendshapesForLookingUp = new EyelidPositionBlendshapeForExport[blendshapesForLookingUp.Length];
			for (int j = 0; j < blendshapesForLookingUp.Length; j++)
			{
				controlDataForExport.blendshapesForLookingUp[j] = blendshapesForLookingUp[j].GetExport(startXform);
			}
			controlDataForExport.blendshapesForLookingDown = new EyelidPositionBlendshapeForExport[blendshapesForLookingDown.Length];
			for (int k = 0; k < blendshapesForLookingDown.Length; k++)
			{
				controlDataForExport.blendshapesForLookingDown[k] = blendshapesForLookingDown[k].GetExport(startXform);
			}
			controlDataForExport.blendshapesConfigs = new BlendshapesConfigForExport[blendshapesConfigs.Length];
			for (int l = 0; l < blendshapesConfigs.Length; l++)
			{
				controlDataForExport.blendshapesConfigs[l] = blendshapesConfigs[l].GetExport(startXform);
			}
			return controlDataForExport;
		}

		public void Import(ControlDataForExport import, Transform startXform)
		{
			eyeControl = import.eyeControl;
			eyelidBoneMode = import.eyelidBoneMode;
			leftEye = Utils.GetTransformFromPath(startXform, import.leftEyePath);
			rightEye = Utils.GetTransformFromPath(startXform, import.rightEyePath);
			maxEyeUpBoneAngle = import.maxEyeUpBoneAngle;
			maxEyeDownBoneAngle = import.maxEyeDownBoneAngle;
			maxEyeUpEyeballAngle = import.maxEyeUpEyeballAngle;
			maxEyeDownEyeballAngle = import.maxEyeDownEyeballAngle;
			isEyeBallDefaultSet = import.isEyeBallDefaultSet;
			isEyeBoneDefaultSet = import.isEyeBoneDefaultSet;
			isEyeBallLookUpSet = import.isEyeBallLookUpSet;
			isEyeBoneLookUpSet = import.isEyeBoneLookUpSet;
			isEyeBallLookDownSet = import.isEyeBallLookDownSet;
			isEyeBoneLookDownSet = import.isEyeBoneLookDownSet;
			eyelidControl = import.eyelidControl;
			eyelidsFollowEyesVertically = import.eyelidsFollowEyesVertically;
			upperEyeLidLeft = Utils.GetTransformFromPath(startXform, import.upperEyeLidLeftPath);
			upperEyeLidRight = Utils.GetTransformFromPath(startXform, import.upperEyeLidRightPath);
			lowerEyeLidLeft = Utils.GetTransformFromPath(startXform, import.lowerEyeLidLeftPath);
			lowerEyeLidRight = Utils.GetTransformFromPath(startXform, import.lowerEyeLidRightPath);
			isEyelidBonesDefaultSet = import.isEyelidBonesDefaultSet;
			isEyelidBonesClosedSet = import.isEyelidBonesClosedSet;
			isEyelidBonesLookUpSet = import.isEyelidBonesLookUpSet;
			isEyelidBonesLookDownSet = import.isEyelidBonesLookDownSet;
			eyeWidenOrSquint = import.eyeWidenOrSquint;
			isEyelidBlendshapeDefaultSet = import.isEyelidBlendshapeDefaultSet;
			isEyelidBlendshapeClosedSet = import.isEyelidBlendshapeClosedSet;
			isEyelidBlendshapeLookUpSet = import.isEyelidBlendshapeLookUpSet;
			isEyelidBlendshapeLookDownSet = import.isEyelidBlendshapeLookDownSet;
			leftBoneEyeRotationLimiter.Import(import.leftBoneEyeRotationLimiter, startXform);
			rightBoneEyeRotationLimiter.Import(import.rightBoneEyeRotationLimiter, startXform);
			leftEyeballEyeRotationLimiter.Import(import.leftEyeballEyeRotationLimiter, startXform);
			rightEyeballEyeRotationLimiter.Import(import.rightEyeballEyeRotationLimiter, startXform);
			upperLeftLimiter.Import(import.upperLeftLimiter, startXform);
			upperRightLimiter.Import(import.upperRightLimiter, startXform);
			lowerLeftLimiter.Import(import.lowerLeftLimiter, startXform);
			lowerRightLimiter.Import(import.lowerRightLimiter, startXform);
			if (import.blendshapesForBlinking != null)
			{
				blendshapesForBlinking = new EyelidPositionBlendshape[import.blendshapesForBlinking.Length];
				for (int i = 0; i < import.blendshapesForBlinking.Length; i++)
				{
					EyelidPositionBlendshape eyelidPositionBlendshape = new EyelidPositionBlendshape();
					eyelidPositionBlendshape.Import(import.blendshapesForBlinking[i], startXform);
					blendshapesForBlinking[i] = eyelidPositionBlendshape;
				}
			}
			if (import.blendshapesForLookingUp != null)
			{
				blendshapesForLookingUp = new EyelidPositionBlendshape[import.blendshapesForLookingUp.Length];
				for (int j = 0; j < import.blendshapesForLookingUp.Length; j++)
				{
					EyelidPositionBlendshape eyelidPositionBlendshape2 = new EyelidPositionBlendshape();
					eyelidPositionBlendshape2.Import(import.blendshapesForLookingUp[j], startXform);
					blendshapesForLookingUp[j] = eyelidPositionBlendshape2;
				}
			}
			if (import.blendshapesForLookingDown != null)
			{
				blendshapesForLookingDown = new EyelidPositionBlendshape[import.blendshapesForLookingDown.Length];
				for (int k = 0; k < import.blendshapesForLookingDown.Length; k++)
				{
					EyelidPositionBlendshape eyelidPositionBlendshape3 = new EyelidPositionBlendshape();
					eyelidPositionBlendshape3.Import(import.blendshapesForLookingDown[k], startXform);
					blendshapesForLookingDown[k] = eyelidPositionBlendshape3;
				}
			}
			bool flag = false;
			if (import.eyelidControl == EyelidControl.Blendshapes)
			{
				SkinnedMeshRenderer[] componentsInChildren = startXform.GetComponentsInChildren<SkinnedMeshRenderer>();
				if (import.blendshapesConfigs != null && componentsInChildren.Length == import.blendshapesConfigs.Length)
				{
					flag = true;
					BlendshapesConfigForExport[] array = import.blendshapesConfigs;
					for (int l = 0; l < array.Length; l++)
					{
						if (!BlendshapesConfig.CanImport(array[l], startXform))
						{
							flag = false;
							break;
						}
					}
				}
			}
			if (flag)
			{
				blendshapesConfigs = new BlendshapesConfig[import.blendshapesConfigs.Length];
				for (int m = 0; m < import.blendshapesConfigs.Length; m++)
				{
					BlendshapesConfig blendshapesConfig = new BlendshapesConfig();
					blendshapesConfig.Import(startXform, import.blendshapesConfigs[m]);
					blendshapesConfigs[m] = blendshapesConfig;
				}
			}
			else
			{
				blendshapesConfigs = new BlendshapesConfig[0];
			}
		}

		public void Initialize(Transform startXform)
		{
			if (eyelidControl == EyelidControl.Blendshapes || eyelidControl == EyelidControl.MCS_Blendshapes)
			{
				EyelidPositionBlendshape[] array = blendshapesForBlinking;
				foreach (EyelidPositionBlendshape eyelidPositionBlendshape in array)
				{
					eyelidPositionBlendshape.isUsedInEalierConfig = false;
					EyelidPositionBlendshape[] array2 = blendshapesForLookingUp;
					foreach (EyelidPositionBlendshape eyelidPositionBlendshape2 in array2)
					{
						if (eyelidPositionBlendshape.skinnedMeshRenderer == eyelidPositionBlendshape2.skinnedMeshRenderer && eyelidPositionBlendshape.index == eyelidPositionBlendshape2.index)
						{
							eyelidPositionBlendshape.isUsedInEalierConfig = true;
							break;
						}
					}
					if (eyelidPositionBlendshape.isUsedInEalierConfig)
					{
						continue;
					}
					array2 = blendshapesForLookingDown;
					foreach (EyelidPositionBlendshape eyelidPositionBlendshape3 in array2)
					{
						if (eyelidPositionBlendshape.skinnedMeshRenderer == eyelidPositionBlendshape3.skinnedMeshRenderer && eyelidPositionBlendshape.index == eyelidPositionBlendshape3.index)
						{
							eyelidPositionBlendshape.isUsedInEalierConfig = true;
							break;
						}
					}
				}
			}
			if (eyelidControl == EyelidControl.MCS_Blendshapes)
			{
				UnityEngine.Debug.LogError("Eyelid control is set to MCS_Blendshapes, but USE_MCS is not defined in ControlData.cs and EyeAndHeadAnimatorEditor.cs");
			}
		}

		private void LerpBlendshapeConfig(EyelidPositionBlendshape[] blendshapes, float lerpValue, bool relativeToCurrentValueIfUsedInOtherConfig = false)
		{
			foreach (EyelidPositionBlendshape eyelidPositionBlendshape in blendshapes)
			{
				if (eyelidPositionBlendshape.skinnedMeshRenderer != null)
				{
					float value = Mathf.Lerp((eyelidPositionBlendshape.isUsedInEalierConfig && relativeToCurrentValueIfUsedInOtherConfig) ? eyelidPositionBlendshape.skinnedMeshRenderer.GetBlendShapeWeight(eyelidPositionBlendshape.index) : eyelidPositionBlendshape.defaultWeight, eyelidPositionBlendshape.positionWeight, lerpValue);
					eyelidPositionBlendshape.skinnedMeshRenderer.SetBlendShapeWeight(eyelidPositionBlendshape.index, value);
				}
			}
		}

		public bool NeedsSaveDefaultBlendshapeConfig()
		{
			if (blendshapesConfigs != null)
			{
				return blendshapesConfigs.Length == 0;
			}
			return true;
		}

		public void OnDestroy()
		{
		}

		private void ResetBlendshapeConfig(EyelidPositionBlendshape[] blendshapes)
		{
			if (blendshapes == null)
			{
				return;
			}
			foreach (EyelidPositionBlendshape eyelidPositionBlendshape in blendshapes)
			{
				if (eyelidPositionBlendshape.skinnedMeshRenderer != null)
				{
					eyelidPositionBlendshape.skinnedMeshRenderer.SetBlendShapeWeight(eyelidPositionBlendshape.index, eyelidPositionBlendshape.defaultWeight);
				}
			}
		}

		private void ResetAllBlendshapesToDefault()
		{
			ResetBlendshapeConfig(blendshapesForBlinking);
			ResetBlendshapeConfig(blendshapesForLookingDown);
			ResetBlendshapeConfig(blendshapesForLookingUp);
		}

		public void RestoreClosed()
		{
			if (eyeControl == EyeControl.MecanimEyeBones)
			{
				leftBoneEyeRotationLimiter.RestoreDefault();
				rightBoneEyeRotationLimiter.RestoreDefault();
			}
			else if (eyeControl == EyeControl.SelectedObjects)
			{
				leftEyeballEyeRotationLimiter.RestoreDefault();
				rightEyeballEyeRotationLimiter.RestoreDefault();
			}
			if (eyelidControl == EyelidControl.Bones)
			{
				upperLeftLimiter.RestoreClosed(eyelidBoneMode);
				upperRightLimiter.RestoreClosed(eyelidBoneMode);
				if (lowerEyeLidLeft != null)
				{
					lowerLeftLimiter.RestoreClosed(eyelidBoneMode);
				}
				if (lowerEyeLidRight != null)
				{
					lowerRightLimiter.RestoreClosed(eyelidBoneMode);
				}
			}
			else
			{
				if (eyelidControl != EyelidControl.Blendshapes && eyelidControl != EyelidControl.MCS_Blendshapes)
				{
					return;
				}
				ResetAllBlendshapesToDefault();
				if (blendshapesForBlinking == null)
				{
					return;
				}
				EyelidPositionBlendshape[] array = blendshapesForBlinking;
				foreach (EyelidPositionBlendshape eyelidPositionBlendshape in array)
				{
					if (eyelidControl == EyelidControl.Blendshapes)
					{
						eyelidPositionBlendshape.skinnedMeshRenderer.SetBlendShapeWeight(eyelidPositionBlendshape.index, eyelidPositionBlendshape.positionWeight);
					}
					else if (eyelidControl == EyelidControl.MCS_Blendshapes)
					{
						UnityEngine.Debug.LogError("Eyelid control is set to MCS_Blendshapes, but USE_MCS is not defined in ControlData.cs and EyeAndHeadAnimator.cs");
					}
				}
			}
		}

		public void RestoreDefault(bool withEyelids = true)
		{
			if (eyeControl == EyeControl.MecanimEyeBones)
			{
				leftBoneEyeRotationLimiter.RestoreDefault();
				rightBoneEyeRotationLimiter.RestoreDefault();
			}
			else if (eyeControl == EyeControl.SelectedObjects)
			{
				leftEyeballEyeRotationLimiter.RestoreDefault();
				rightEyeballEyeRotationLimiter.RestoreDefault();
			}
			if (!withEyelids)
			{
				return;
			}
			if (eyelidControl == EyelidControl.Bones)
			{
				upperLeftLimiter.RestoreDefault(eyelidBoneMode);
				upperRightLimiter.RestoreDefault(eyelidBoneMode);
				if (lowerEyeLidLeft != null)
				{
					lowerLeftLimiter.RestoreDefault(eyelidBoneMode);
				}
				if (lowerEyeLidRight != null)
				{
					lowerRightLimiter.RestoreDefault(eyelidBoneMode);
				}
			}
			else if (eyelidControl == EyelidControl.Blendshapes || eyelidControl == EyelidControl.MCS_Blendshapes)
			{
				ResetAllBlendshapesToDefault();
			}
		}

		public void RestoreLookDown()
		{
			if (eyeControl == EyeControl.MecanimEyeBones)
			{
				leftBoneEyeRotationLimiter.RestoreLookDown();
				rightBoneEyeRotationLimiter.RestoreLookDown();
			}
			else if (eyeControl == EyeControl.SelectedObjects)
			{
				leftEyeballEyeRotationLimiter.RestoreLookDown();
				rightEyeballEyeRotationLimiter.RestoreLookDown();
			}
			if (eyelidControl == EyelidControl.Bones)
			{
				upperLeftLimiter.RestoreLookDown(eyelidBoneMode);
				upperRightLimiter.RestoreLookDown(eyelidBoneMode);
				if (lowerEyeLidLeft != null)
				{
					lowerLeftLimiter.RestoreLookDown(eyelidBoneMode);
				}
				if (lowerEyeLidRight != null)
				{
					lowerRightLimiter.RestoreLookDown(eyelidBoneMode);
				}
			}
			else
			{
				if (eyelidControl != EyelidControl.Blendshapes && eyelidControl != EyelidControl.MCS_Blendshapes)
				{
					return;
				}
				ResetAllBlendshapesToDefault();
				EyelidPositionBlendshape[] array = blendshapesForLookingDown;
				foreach (EyelidPositionBlendshape eyelidPositionBlendshape in array)
				{
					if (eyelidControl == EyelidControl.Blendshapes)
					{
						eyelidPositionBlendshape.skinnedMeshRenderer.SetBlendShapeWeight(eyelidPositionBlendshape.index, eyelidPositionBlendshape.positionWeight);
					}
					else if (eyelidControl == EyelidControl.MCS_Blendshapes)
					{
						UnityEngine.Debug.LogError("Eyelid control is set to MCS_Blendshapes, but USE_MCS is not defined in ControlData.cs and EyeAndHeadAnimator.cs");
					}
				}
			}
		}

		public void RestoreLookUp()
		{
			if (eyeControl == EyeControl.MecanimEyeBones)
			{
				leftBoneEyeRotationLimiter.RestoreLookUp();
				rightBoneEyeRotationLimiter.RestoreLookUp();
			}
			else if (eyeControl == EyeControl.SelectedObjects)
			{
				leftEyeballEyeRotationLimiter.RestoreLookUp();
				rightEyeballEyeRotationLimiter.RestoreLookUp();
			}
			if (eyelidControl == EyelidControl.Bones)
			{
				upperLeftLimiter.RestoreLookUp(eyelidBoneMode);
				upperRightLimiter.RestoreLookUp(eyelidBoneMode);
				if (lowerEyeLidLeft != null)
				{
					lowerLeftLimiter.RestoreLookUp(eyelidBoneMode);
				}
				if (lowerEyeLidRight != null)
				{
					lowerRightLimiter.RestoreLookUp(eyelidBoneMode);
				}
			}
			else
			{
				if (eyelidControl != EyelidControl.Blendshapes && eyelidControl != EyelidControl.MCS_Blendshapes)
				{
					return;
				}
				ResetAllBlendshapesToDefault();
				EyelidPositionBlendshape[] array = blendshapesForLookingUp;
				foreach (EyelidPositionBlendshape eyelidPositionBlendshape in array)
				{
					if (eyelidControl == EyelidControl.Blendshapes)
					{
						eyelidPositionBlendshape.skinnedMeshRenderer.SetBlendShapeWeight(eyelidPositionBlendshape.index, eyelidPositionBlendshape.positionWeight);
					}
					else if (eyelidControl == EyelidControl.MCS_Blendshapes)
					{
						UnityEngine.Debug.LogError("Eyelid control is set to MCS_Blendshapes, but USE_MCS is not defined in ControlData.cs and EyeAndHeadAnimator.cs");
					}
				}
			}
		}

		private void SaveBlendshapesForEyelidPosition(ref EyelidPositionBlendshape[] blendshapesForPosition, UnityEngine.Object rootObject, string positionName)
		{
			List<EyelidPositionBlendshape> list = new List<EyelidPositionBlendshape>();
			if (eyelidControl == EyelidControl.Blendshapes)
			{
				SkinnedMeshRenderer[] componentsInChildren = (rootObject as MonoBehaviour).GetComponentsInChildren<SkinnedMeshRenderer>();
				if (componentsInChildren.Length != blendshapesConfigs.Length)
				{
					UnityEngine.Debug.LogError("The saved data for open eyelids is invalid. Please reset to open eyelids and resave 'Eyes open, looking straight'.");
					isEyelidBlendshapeDefaultSet = false;
					isEyelidBlendshapeClosedSet = false;
					isEyelidBlendshapeLookDownSet = false;
					isEyelidBlendshapeLookUpSet = false;
				}
				else
				{
					for (int i = 0; i < componentsInChildren.Length; i++)
					{
						SkinnedMeshRenderer skinnedMeshRenderer = componentsInChildren[i];
						BlendshapesConfig blendshapesConfig = blendshapesConfigs[i];
						if (skinnedMeshRenderer != blendshapesConfig.skinnedMeshRenderer || skinnedMeshRenderer.sharedMesh.blendShapeCount != blendshapesConfig.blendShapeCount)
						{
							UnityEngine.Debug.LogError("The saved data for open eyelids is invalid. Please reset to open eyelids and resave 'Eyes open, looking straight'.");
							isEyelidBlendshapeDefaultSet = false;
							isEyelidBlendshapeClosedSet = false;
							isEyelidBlendshapeLookDownSet = false;
							isEyelidBlendshapeLookUpSet = false;
							continue;
						}
						for (int j = 0; j < blendshapesConfig.blendShapeCount; j++)
						{
							if (Mathf.Abs(blendshapesConfig.blendshapeWeights[j] - skinnedMeshRenderer.GetBlendShapeWeight(j)) >= 0.01f)
							{
								EyelidPositionBlendshape item = new EyelidPositionBlendshape
								{
									skinnedMeshRenderer = skinnedMeshRenderer,
									index = j,
									defaultWeight = blendshapesConfig.blendshapeWeights[j],
									positionWeight = skinnedMeshRenderer.GetBlendShapeWeight(j)
								};
								list.Add(item);
							}
						}
					}
				}
			}
			else if (eyelidControl == EyelidControl.MCS_Blendshapes)
			{
				UnityEngine.Debug.LogError("Eyelid control is set to MCS_Blendshapes, but USE_MCS is not defined in ControlData.cs and EyeAndHeadAnimator.cs");
			}
			blendshapesForPosition = list.ToArray();
		}

		public void SaveClosed(UnityEngine.Object rootObject)
		{
			if (eyelidControl == EyelidControl.Bones)
			{
				upperLeftLimiter.SaveClosed();
				upperRightLimiter.SaveClosed();
				if (lowerEyeLidLeft != null)
				{
					lowerLeftLimiter.SaveClosed();
				}
				if (lowerEyeLidRight != null)
				{
					lowerRightLimiter.SaveClosed();
				}
				isEyelidBonesClosedSet = true;
			}
			else if (eyelidControl == EyelidControl.Blendshapes || eyelidControl == EyelidControl.MCS_Blendshapes)
			{
				isEyelidBlendshapeClosedSet = true;
				SaveBlendshapesForEyelidPosition(ref blendshapesForBlinking, rootObject, "closed eyes");
			}
		}

		public void SaveDefault(UnityEngine.Object rootObject)
		{
			if (eyeControl == EyeControl.MecanimEyeBones)
			{
				Animator component = (rootObject as MonoBehaviour).GetComponent<Animator>();
				Transform boneTransform = component.GetBoneTransform(HumanBodyBones.LeftEye);
				Transform boneTransform2 = component.GetBoneTransform(HumanBodyBones.RightEye);
				leftBoneEyeRotationLimiter.SaveDefault(boneTransform);
				rightBoneEyeRotationLimiter.SaveDefault(boneTransform2);
				isEyeBoneDefaultSet = true;
			}
			else if (eyeControl == EyeControl.SelectedObjects)
			{
				leftEyeballEyeRotationLimiter.SaveDefault(leftEye);
				rightEyeballEyeRotationLimiter.SaveDefault(rightEye);
				isEyeBallDefaultSet = true;
			}
			if (eyelidControl == EyelidControl.Bones)
			{
				upperLeftLimiter.SaveDefault(upperEyeLidLeft);
				upperRightLimiter.SaveDefault(upperEyeLidRight);
				if (lowerEyeLidLeft != null)
				{
					lowerLeftLimiter.SaveDefault(lowerEyeLidLeft);
				}
				if (lowerEyeLidRight != null)
				{
					lowerRightLimiter.SaveDefault(lowerEyeLidRight);
				}
				isEyelidBonesDefaultSet = true;
			}
			else
			{
				if (eyelidControl != EyelidControl.Blendshapes)
				{
					return;
				}
				SkinnedMeshRenderer[] componentsInChildren = (rootObject as MonoBehaviour).GetComponentsInChildren<SkinnedMeshRenderer>();
				blendshapesConfigs = new BlendshapesConfig[componentsInChildren.Length];
				for (int i = 0; i < componentsInChildren.Length; i++)
				{
					BlendshapesConfig blendshapesConfig = new BlendshapesConfig
					{
						skinnedMeshRenderer = componentsInChildren[i]
					};
					blendshapesConfig.blendShapeCount = blendshapesConfig.skinnedMeshRenderer.sharedMesh.blendShapeCount;
					blendshapesConfig.blendshapeWeights = new float[blendshapesConfig.blendShapeCount];
					for (int j = 0; j < blendshapesConfig.blendShapeCount; j++)
					{
						blendshapesConfig.blendshapeWeights[j] = blendshapesConfig.skinnedMeshRenderer.GetBlendShapeWeight(j);
					}
					blendshapesConfigs[i] = blendshapesConfig;
				}
				isEyelidBlendshapeDefaultSet = true;
			}
		}

		public void SaveLookDown(UnityEngine.Object rootObject)
		{
			bool num = eyeControl == EyeControl.MecanimEyeBones;
			bool flag = eyeControl == EyeControl.SelectedObjects;
			if (num)
			{
				leftBoneEyeRotationLimiter.SaveLookDown();
				rightBoneEyeRotationLimiter.SaveLookDown();
				isEyeBoneLookDownSet = true;
			}
			else if (flag)
			{
				leftEyeballEyeRotationLimiter.SaveLookDown();
				rightEyeballEyeRotationLimiter.SaveLookDown();
				isEyeBallLookDownSet = true;
			}
			float eyeMaxDownAngle = (num ? leftBoneEyeRotationLimiter.maxDownAngle : leftEyeballEyeRotationLimiter.maxDownAngle);
			float eyeMaxDownAngle2 = (num ? rightBoneEyeRotationLimiter.maxDownAngle : rightEyeballEyeRotationLimiter.maxDownAngle);
			if (eyelidControl == EyelidControl.Bones)
			{
				upperLeftLimiter.SaveLookDown(eyeMaxDownAngle);
				upperRightLimiter.SaveLookDown(eyeMaxDownAngle2);
				if (lowerEyeLidLeft != null)
				{
					lowerLeftLimiter.SaveLookDown(eyeMaxDownAngle);
				}
				if (lowerEyeLidRight != null)
				{
					lowerRightLimiter.SaveLookDown(eyeMaxDownAngle2);
				}
				isEyelidBonesLookDownSet = true;
			}
			else if (eyelidControl == EyelidControl.Blendshapes || eyelidControl == EyelidControl.MCS_Blendshapes)
			{
				isEyelidBlendshapeLookDownSet = true;
				SaveBlendshapesForEyelidPosition(ref blendshapesForLookingDown, rootObject, "looking down");
			}
		}

		public void SaveLookUp(UnityEngine.Object rootObject)
		{
			bool num = eyeControl == EyeControl.MecanimEyeBones;
			bool flag = eyeControl == EyeControl.SelectedObjects;
			if (num)
			{
				leftBoneEyeRotationLimiter.SaveLookUp();
				rightBoneEyeRotationLimiter.SaveLookUp();
				isEyeBoneLookUpSet = true;
			}
			else if (flag)
			{
				leftEyeballEyeRotationLimiter.SaveLookUp();
				rightEyeballEyeRotationLimiter.SaveLookUp();
				isEyeBallLookUpSet = true;
			}
			float eyeMaxUpAngle = (num ? leftBoneEyeRotationLimiter.maxUpAngle : leftEyeballEyeRotationLimiter.maxUpAngle);
			float eyeMaxUpAngle2 = (num ? rightBoneEyeRotationLimiter.maxUpAngle : rightEyeballEyeRotationLimiter.maxUpAngle);
			if (eyelidControl == EyelidControl.Bones)
			{
				upperLeftLimiter.SaveLookUp(eyeMaxUpAngle);
				upperRightLimiter.SaveLookUp(eyeMaxUpAngle2);
				if (lowerEyeLidLeft != null)
				{
					lowerLeftLimiter.SaveLookUp(eyeMaxUpAngle);
				}
				if (lowerEyeLidRight != null)
				{
					lowerRightLimiter.SaveLookUp(eyeMaxUpAngle2);
				}
				isEyelidBonesLookUpSet = true;
			}
			else if (eyelidControl == EyelidControl.Blendshapes || eyelidControl == EyelidControl.MCS_Blendshapes)
			{
				isEyelidBlendshapeLookUpSet = true;
				SaveBlendshapesForEyelidPosition(ref blendshapesForLookingUp, rootObject, "looking up");
			}
		}

		public void UpdateEyelids(float leftEyeAngle, float rightEyeAngle, float blink01, bool eyelidsFollowEyesVertically)
		{
			leftEyeAngle = Utils.NormalizedDegAngle(leftEyeAngle);
			rightEyeAngle = Utils.NormalizedDegAngle(rightEyeAngle);
			if (eyelidControl == EyelidControl.Bones)
			{
				Vector3 position = upperEyeLidLeft.localPosition;
				upperLeftLimiter.GetRotationAndPosition(leftEyeAngle, blink01, eyeWidenOrSquint, isUpper: true, out var rotation, ref position, eyelidBoneMode);
				if (eyelidBoneMode == EyelidBoneMode.RotationAndPosition || eyelidBoneMode == EyelidBoneMode.Rotation)
				{
					upperEyeLidLeft.localRotation = rotation;
				}
				if (eyelidBoneMode == EyelidBoneMode.RotationAndPosition || eyelidBoneMode == EyelidBoneMode.Position)
				{
					upperEyeLidLeft.localPosition = position;
				}
				position = upperEyeLidRight.localPosition;
				upperRightLimiter.GetRotationAndPosition(rightEyeAngle, blink01, eyeWidenOrSquint, isUpper: true, out rotation, ref position, eyelidBoneMode);
				if (eyelidBoneMode == EyelidBoneMode.RotationAndPosition || eyelidBoneMode == EyelidBoneMode.Rotation)
				{
					upperEyeLidRight.localRotation = rotation;
				}
				if (eyelidBoneMode == EyelidBoneMode.RotationAndPosition || eyelidBoneMode == EyelidBoneMode.Position)
				{
					upperEyeLidRight.localPosition = position;
				}
				if (lowerEyeLidLeft != null)
				{
					position = lowerEyeLidLeft.localPosition;
					lowerLeftLimiter.GetRotationAndPosition(leftEyeAngle, blink01, eyeWidenOrSquint, isUpper: false, out rotation, ref position, eyelidBoneMode);
					if (eyelidBoneMode == EyelidBoneMode.RotationAndPosition || eyelidBoneMode == EyelidBoneMode.Rotation)
					{
						lowerEyeLidLeft.localRotation = rotation;
					}
					if (eyelidBoneMode == EyelidBoneMode.RotationAndPosition || eyelidBoneMode == EyelidBoneMode.Position)
					{
						lowerEyeLidLeft.localPosition = position;
					}
				}
				if (lowerEyeLidRight != null)
				{
					position = lowerEyeLidRight.localPosition;
					lowerRightLimiter.GetRotationAndPosition(rightEyeAngle, blink01, eyeWidenOrSquint, isUpper: false, out rotation, ref position, eyelidBoneMode);
					if (eyelidBoneMode == EyelidBoneMode.RotationAndPosition || eyelidBoneMode == EyelidBoneMode.Rotation)
					{
						lowerEyeLidRight.localRotation = rotation;
					}
					if (eyelidBoneMode == EyelidBoneMode.RotationAndPosition || eyelidBoneMode == EyelidBoneMode.Position)
					{
						lowerEyeLidRight.localPosition = position;
					}
				}
			}
			else if (eyelidControl == EyelidControl.Blendshapes || eyelidControl == EyelidControl.MCS_Blendshapes)
			{
				bool flag = leftEyeAngle > 0f;
				float lerpValue = (flag ? 0f : ((eyeControl == EyeControl.MecanimEyeBones) ? leftBoneEyeRotationLimiter.GetEyeUp01(leftEyeAngle) : leftEyeballEyeRotationLimiter.GetEyeUp01(leftEyeAngle)));
				float lerpValue2 = ((!flag) ? 0f : ((eyeControl == EyeControl.MecanimEyeBones) ? leftBoneEyeRotationLimiter.GetEyeDown01(leftEyeAngle) : leftEyeballEyeRotationLimiter.GetEyeDown01(leftEyeAngle)));
				if (this.eyelidsFollowEyesVertically)
				{
					ResetAllBlendshapesToDefault();
				}
				else
				{
					ResetBlendshapeConfig(blendshapesForBlinking);
				}
				if (eyelidsFollowEyesVertically)
				{
					if (flag)
					{
						LerpBlendshapeConfig(blendshapesForLookingDown, lerpValue2);
					}
					else
					{
						LerpBlendshapeConfig(blendshapesForLookingUp, lerpValue);
					}
				}
				LerpBlendshapeConfig(blendshapesForBlinking, blink01, eyelidsFollowEyesVertically);
			}
			this.eyelidsFollowEyesVertically = eyelidsFollowEyesVertically;
		}
	}
	internal struct CritDampTweenQuaternion
	{
		[StructLayout(LayoutKind.Explicit)]
		private struct QVUnion
		{
			[FieldOffset(0)]
			public Vector4 v;

			[FieldOffset(0)]
			public Quaternion q;
		}

		private QVUnion _rotation;

		public Vector4 velocity;

		public float omega;

		private readonly float maxSpeed;

		public Quaternion rotation
		{
			get
			{
				return _rotation.q;
			}
			set
			{
				_rotation.q = value;
			}
		}

		private static Vector4 q2v(Quaternion q)
		{
			return new Vector4(q.x, q.y, q.z, q.w);
		}

		public CritDampTweenQuaternion(Quaternion rotation, float omega, float maxSpeed)
		{
			_rotation.v = Vector4.zero;
			_rotation.q = rotation;
			velocity = Vector4.zero;
			this.omega = omega;
			this.maxSpeed = maxSpeed;
		}

		public void Step(Quaternion target)
		{
			Vector4 vector = q2v(target);
			if (Vector4.Dot(_rotation.v, vector) < 0f)
			{
				vector = -vector;
			}
			float deltaTime = Time.deltaTime;
			Vector4 vector2 = velocity - (_rotation.v - vector) * (omega * omega * deltaTime);
			float num = 1f + omega * deltaTime;
			velocity = vector2 / (num * num);
			float magnitude = velocity.magnitude;
			velocity = Mathf.Min(magnitude, maxSpeed) / magnitude * velocity;
			_rotation.v = (_rotation.v + velocity * deltaTime).normalized;
		}

		public static implicit operator Quaternion(CritDampTweenQuaternion m)
		{
			return m.rotation;
		}
	}
	public class DestroyNotifier : MonoBehaviour
	{
		public event Action<DestroyNotifier> OnDestroyedEvent;

		private void OnDestroyed()
		{
			if (this.OnDestroyedEvent != null)
			{
				this.OnDestroyedEvent(this);
			}
		}
	}
	[Serializable]
	public class EyeAndHeadAnimatorForExport
	{
		public string headBonePath;

		public float headSpeedModifier;

		public float headWeight;

		public bool useMicroSaccades;

		public bool useMacroSaccades;

		public bool kDrawSightlinesInEditor;

		public ControlData.ControlDataForExport controlData;

		public float kMinNextBlinkTime;

		public float kMaxNextBlinkTime;

		public bool eyelidsFollowEyesVertically;

		public float maxEyeHorizAngle;

		public float maxEyeHorizAngleTowardsNose;

		public float crossEyeCorrection;

		public float nervousness;

		public float limitHeadAngle;
	}
	public class EyeAndHeadAnimator : MonoBehaviour
	{
		private enum HeadControl
		{
			None,
			Mecanim,
			FinalIK,
			Transform
		}

		private enum HeadTweenMethod
		{
			SmoothDamping,
			CriticalDamping
		}

		private enum BlinkState
		{
			Idle,
			Closing,
			KeepingClosed,
			Opening
		}

		public enum HeadSpeed
		{
			Slow,
			Fast
		}

		public enum EyeDelay
		{
			Simultaneous,
			EyesFirst,
			HeadFirst
		}

		private enum LookTarget
		{
			StraightAhead,
			ClearingTargetPhase1,
			ClearingTargetPhase2,
			GeneralDirection,
			SpecificThing,
			Face
		}

		private enum FaceLookTarget
		{
			EyesCenter,
			LeftEye,
			RightEye,
			Mouth
		}

		private const float kMaxLimitedHorizontalHeadAngle = 55f;

		private const float kMaxLimitedVerticalHeadAngle = 40f;

		private const float kMaxHorizViewAngle = 100f;

		private const float kMaxVertViewAngle = 60f;

		[HideInInspector]
		public float headSpeedModifier = 1f;

		[HideInInspector]
		public float headWeight = 1f;

		[HideInInspector]
		public Transform headBoneNonMecanimXform;

		private Quaternion headBoneNonMecanimFromRootQ;

		private const float kHeadJitterFrequency = 0.2f;

		private const float kHeadJitterAmount = 1f;

		private Vector3 headJitterRotationComponents = new Vector3(1f, 1f, 0f);

		private const int kHeadJitterOctave = 3;

		private float headJitterTime;

		private Vector2[] headJitterNoiseVectors;

		private HeadControl headControl;

		private HeadTweenMethod headTweenMethod;

		public bool allowHeadMotion = true;

		public bool useMicroSaccades = true;

		public bool useMacroSaccades = true;

		public bool useHeadJitter = true;

		public bool kDrawSightlinesInEditor;

		public bool areUpdatedControlledExternally;

		[HideInInspector]
		public ControlData controlData = new ControlData();

		[Tooltip("Minimum seconds until next blink")]
		public float kMinNextBlinkTime = 3f;

		[Tooltip("Maximum seconds until next blink")]
		public float kMaxNextBlinkTime = 15f;

		[Tooltip("The blinking speed.")]
		[Range(0.1f, 3f)]
		public float blinkSpeed = 1f;

		[Tooltip("Whether the eyelids move up a bit when looking up and down when looking down.")]
		public bool eyelidsFollowEyesVertically = true;

		private bool useUpperEyelids;

		private bool useLowerEyelids;

		private float timeOfNextBlink;

		private BlinkState blinkState;

		private float blinkStateTime;

		private float blinkDuration;

		private bool isShortBlink;

		private const float kBlinkCloseTimeShort = 0.036f;

		private const float kBlinkOpenTimeShort = 0.072f;

		private const float kBlinkCloseTimeLong = 0.072f;

		private const float kBlinkOpenTimeLong = 0.144f;

		private const float kBlinkKeepingClosedTime = 0.008f;

		[Range(0f, 1f)]
		public float headWeightOverride = 1f;

		[Tooltip("Maximum horizontal eye angle (away from nose)")]
		public float maxEyeHorizAngle = 35f;

		[Tooltip("Maximum horizontal eye angle towards nose")]
		public float maxEyeHorizAngleTowardsNose = 35f;

		[Tooltip("Cross eye correction factor")]
		[Range(0f, 5f)]
		public float crossEyeCorrection = 1f;

		[Tooltip("The more nervous, the more often you do micro-and macrosaccades.")]
		[Range(0f, 10f)]
		public float nervousness;

		[Tooltip("Limits the angle for the head movement")]
		[Range(0f, 1f)]
		public float limitHeadAngle;

		private Transform leftEyeAnchor;

		private Transform rightEyeAnchor;

		private float leftMaxSpeedHoriz;

		private float leftHorizDuration;

		private float leftMaxSpeedVert;

		private float leftVertDuration;

		private float leftCurrentSpeedX;

		private float leftCurrentSpeedY;

		private float rightMaxSpeedHoriz;

		private float rightHorizDuration;

		private float rightMaxSpeedVert;

		private float rightVertDuration;

		private float rightCurrentSpeedX;

		private float rightCurrentSpeedY;

		private float startLeftEyeHorizDuration;

		private float startLeftEyeVertDuration;

		private float startLeftEyeMaxSpeedHoriz;

		private float startLeftEyeMaxSpeedVert;

		private float startRightEyeHorizDuration;

		private float startRightEyeVertDuration;

		private float startRightEyeMaxSpeedHoriz;

		private float startRightEyeMaxSpeedVert;

		private float timeOfEyeMovementStart;

		private float timeOfHeadMovementStart;

		private float headMaxSpeedHoriz;

		private float headMaxSpeedVert;

		private float headHorizDuration;

		private float headVertDuration;

		private float startHeadHorizDuration;

		private float startHeadVertDuration;

		private float startHeadMaxSpeedHoriz;

		private float startHeadMaxSpeedVert;

		private float currentHeadHorizSpeed;

		private float currentHeadVertSpeed;

		private float currentHeadZSpeed;

		private const float kMaxHeadVelocity = 2f;

		private const float kHeadOmega = 3.5f;

		private CritDampTweenQuaternion critDampTween;

		private Vector3 headEulerSpeed;

		private Vector3 lastHeadEuler;

		private float maxHeadHorizSpeedSinceSaccadeStart;

		private float maxHeadVertSpeedSinceSaccadeStart;

		private bool isHeadTracking;

		private float headTrackingFactor = 1f;

		private float headLatency;

		private float eyeLatency;

		private float ikWeight = 1f;

		private Animator animator;

		private bool hasLateUpdateRunThisFrame;

		private Transform currentHeadTargetPOI;

		private Transform currentEyeTargetPOI;

		private Transform nextHeadTargetPOI;

		private Transform nextEyeTargetPOI;

		private Transform currentTargetLeftEyeXform;

		private Transform currentTargetRightEyeXform;

		private Transform nextTargetLeftEyeXform;

		private Transform nextTargetRightEyeXform;

		private readonly Transform[] createdTargetXforms = new Transform[2];

		private int createdTargetXformIndex;

		private Transform headTargetPivotXform;

		private Transform headXform;

		private Quaternion leftEyeRootFromAnchorQ;

		private Quaternion rightEyeRootFromAnchorQ;

		private Quaternion leftAnchorFromEyeRootQ;

		private Quaternion rightAnchorFromEyeRootQ;

		private Vector3 currentLeftEyeLocalEuler;

		private Vector3 currentRightEyeLocalEuler;

		private Quaternion originalLeftEyeLocalQ;

		private Quaternion originalRightEyeLocalQ;

		private Quaternion lastLeftEyeLocalRotation;

		private Quaternion lastRightEyeLocalQ;

		private Quaternion headBoneInAvatarQ;

		private Vector3 macroSaccadeTargetLocal;

		private Vector3 microSaccadeTargetLocal;

		private float timeOfEnteringClearingPhase;

		private float timeOfLastMacroSaccade = -100f;

		private float timeToMicroSaccade;

		private float timeToMacroSaccade;

		private bool isInitialized;

		private int lastFrameOfUpdate1 = -1;

		private int lastFrameOfUpdate2 = -1;

		private HeadSpeed headSpeed;

		private LookTarget lookTarget;

		private FaceLookTarget faceLookTarget;

		public float blink01 { get; private set; }

		public float eyeDistance { get; private set; }

		public float eyeDistanceScale { get; private set; }

		public Transform eyesRootXform { get; private set; }

		public Transform headParentXform { get; private set; }

		public event Action OnCannotGetTargetIntoView;

		public event Action OnTargetDestroyed;

		public event Action OnTargetOutOfSight;

		public event Action OnUpdate2Finished;

		private void Awake()
		{
			Initialize();
			headWeight = headWeightOverride;
			if (!allowHeadMotion)
			{
				headControl = HeadControl.None;
			}
		}

		public void Blink(bool isShortBlink = true)
		{
			if (blinkState == BlinkState.Idle)
			{
				this.isShortBlink = isShortBlink;
				blinkState = BlinkState.Closing;
				blinkStateTime = 0f;
				blinkDuration = 1f / blinkSpeed * (isShortBlink ? 0.036f : 0.072f);
			}
		}

		public bool CanGetIntoView(Vector3 point)
		{
			Vector3 eulerAngles = Quaternion.LookRotation(headParentXform.InverseTransformPoint(point)).eulerAngles;
			float num = Mathf.Abs(Utils.NormalizedDegAngle(eulerAngles.x));
			bool num2 = Mathf.Abs(Utils.NormalizedDegAngle(eulerAngles.y)) < LimitHorizontalHeadAngle(55f) + maxEyeHorizAngle + 20f;
			float f = controlData.ClampRightVertEyeAngle(eulerAngles.x);
			bool flag = num < LimitVerticalHeadAngle(40f) + Mathf.Abs(f) + 12f;
			return num2 && flag;
		}

		public bool CanChangePointOfAttention()
		{
			return Time.time - timeOfLastMacroSaccade >= 2f / (1f + nervousness);
		}

		public bool CanImportFromFile(string filename)
		{
			EyeAndHeadAnimatorForExport eyeAndHeadAnimatorForExport;
			using (FileStream serializationStream = new FileStream(filename, FileMode.Open, FileAccess.Read, FileShare.Read))
			{
				eyeAndHeadAnimatorForExport = (EyeAndHeadAnimatorForExport)new BinaryFormatter().Deserialize(serializationStream);
			}
			if (Utils.CanGetTransformFromPath(base.transform, eyeAndHeadAnimatorForExport.headBonePath))
			{
				return controlData.CanImport(eyeAndHeadAnimatorForExport.controlData, base.transform);
			}
			return false;
		}

		private void CheckLatencies()
		{
			if (eyeLatency > 0f)
			{
				eyeLatency -= Time.deltaTime;
				if (eyeLatency <= 0f)
				{
					currentEyeTargetPOI = nextEyeTargetPOI;
					currentTargetLeftEyeXform = nextTargetLeftEyeXform;
					currentTargetRightEyeXform = nextTargetRightEyeXform;
				}
			}
			else if (headLatency > 0f)
			{
				headLatency -= Time.deltaTime;
				if (headLatency <= 0f)
				{
					StartHeadMovement(nextHeadTargetPOI);
				}
			}
		}

		private void CheckMacroSaccades()
		{
			if (lookTarget == LookTarget.SpecificThing || controlData.eyeControl == ControlData.EyeControl.None || eyeLatency > 0f)
			{
				return;
			}
			timeToMacroSaccade -= Time.deltaTime;
			if (!(timeToMacroSaccade <= 0f))
			{
				return;
			}
			if (lookTarget == LookTarget.GeneralDirection && useMacroSaccades)
			{
				bool flag = controlData.eyelidControl == ControlData.EyelidControl.Bones;
				float x = UnityEngine.Random.Range(-10f * (flag ? 0.65f : 0.3f), 10f * (flag ? 0.65f : 0.4f));
				float y = UnityEngine.Random.Range(-10f, 10f);
				SetMacroSaccadeTarget(eyesRootXform.TransformPoint(Quaternion.Euler(x, y, 0f) * eyesRootXform.InverseTransformPoint(GetCurrentEyeTargetPos())));
				timeToMacroSaccade = UnityEngine.Random.Range(5f, 8f);
				timeToMacroSaccade *= 1f / (1f + nervousness);
			}
			else if (lookTarget == LookTarget.Face && currentEyeTargetPOI == null)
			{
				switch (faceLookTarget)
				{
				case FaceLookTarget.LeftEye:
					faceLookTarget = ((UnityEngine.Random.value < 0.75f) ? FaceLookTarget.RightEye : FaceLookTarget.Mouth);
					break;
				case FaceLookTarget.RightEye:
					faceLookTarget = ((UnityEngine.Random.value < 0.75f) ? FaceLookTarget.LeftEye : FaceLookTarget.Mouth);
					break;
				case FaceLookTarget.EyesCenter:
				case FaceLookTarget.Mouth:
					faceLookTarget = ((UnityEngine.Random.value < 0.5f) ? FaceLookTarget.LeftEye : FaceLookTarget.RightEye);
					break;
				}
				SetMacroSaccadeTarget(GetLookTargetPosForSocialTriangle(faceLookTarget));
				timeToMacroSaccade = ((faceLookTarget == FaceLookTarget.Mouth) ? UnityEngine.Random.Range(0.4f, 0.9f) : UnityEngine.Random.Range(1f, 3f));
				timeToMacroSaccade *= 1f / (1f + nervousness);
			}
		}

		private void CheckMicroSaccades()
		{
			if (!useMicroSaccades || controlData.eyeControl == ControlData.EyeControl.None || eyeLatency > 0f || (lookTarget != LookTarget.GeneralDirection && lookTarget != LookTarget.SpecificThing && (lookTarget != LookTarget.Face || !(currentEyeTargetPOI != null))))
			{
				return;
			}
			timeToMicroSaccade -= Time.deltaTime;
			if (timeToMicroSaccade <= 0f)
			{
				bool flag = controlData.eyelidControl == ControlData.EyelidControl.Bones;
				float num = UnityEngine.Random.Range(-3f * (flag ? 0.8f : 0.5f), 3f * (flag ? 0.85f : 0.6f));
				float num2 = UnityEngine.Random.Range(-3f, 3f);
				if (lookTarget == LookTarget.Face)
				{
					num *= 0.5f;
					num2 *= 0.5f;
				}
				SetMicroSaccadeTarget(eyesRootXform.TransformPoint(Quaternion.Euler(num, num2, 0f) * eyesRootXform.InverseTransformPoint(currentEyeTargetPOI.TransformPoint(macroSaccadeTargetLocal))));
			}
		}

		private float ClampLeftHorizEyeAngle(float angle)
		{
			float num = Utils.NormalizedDegAngle(angle);
			float num2 = ((num > 0f) ? maxEyeHorizAngleTowardsNose : maxEyeHorizAngle);
			return Mathf.Clamp(num, 0f - num2, num2);
		}

		private float ClampRightHorizEyeAngle(float angle)
		{
			float num = Utils.NormalizedDegAngle(angle);
			float num2 = ((num < 0f) ? maxEyeHorizAngleTowardsNose : maxEyeHorizAngle);
			return Mathf.Clamp(num, 0f - num2, num2);
		}

		public void ClearLookTarget()
		{
			LookAtAreaAround(GetOwnEyeCenter() + base.transform.forward * 1000f * eyeDistance);
			lookTarget = LookTarget.ClearingTargetPhase1;
			timeOfEnteringClearingPhase = Time.time;
		}

		private void DrawSightlinesInEditor()
		{
			if (controlData.eyeControl != 0)
			{
				Vector3 vector = leftEyeAnchor.parent.rotation * leftEyeAnchor.localRotation * leftAnchorFromEyeRootQ * Vector3.forward;
				Vector3 vector2 = rightEyeAnchor.parent.rotation * rightEyeAnchor.localRotation * rightAnchorFromEyeRootQ * Vector3.forward;
				UnityEngine.Debug.DrawLine(leftEyeAnchor.position, leftEyeAnchor.position + vector * 10f * eyeDistanceScale);
				UnityEngine.Debug.DrawLine(rightEyeAnchor.position, rightEyeAnchor.position + vector2 * 10f * eyeDistanceScale);
			}
		}

		public void ExportToFile(string filename)
		{
			EyeAndHeadAnimatorForExport graph = new EyeAndHeadAnimatorForExport
			{
				headBonePath = Utils.GetPathForTransform(base.transform, headBoneNonMecanimXform),
				headSpeedModifier = headSpeedModifier,
				headWeight = headWeight,
				useMicroSaccades = useMicroSaccades,
				useMacroSaccades = useMacroSaccades,
				kDrawSightlinesInEditor = kDrawSightlinesInEditor,
				controlData = controlData.GetExport(base.transform),
				kMaxNextBlinkTime = kMaxNextBlinkTime,
				eyelidsFollowEyesVertically = eyelidsFollowEyesVertically,
				maxEyeHorizAngle = maxEyeHorizAngle,
				maxEyeHorizAngleTowardsNose = maxEyeHorizAngleTowardsNose,
				crossEyeCorrection = crossEyeCorrection,
				nervousness = nervousness,
				limitHeadAngle = limitHeadAngle
			};
			FileStream fileStream = new FileStream(filename, FileMode.Create, FileAccess.Write, FileShare.Write);
			new BinaryFormatter().Serialize(fileStream, graph);
			fileStream.Close();
		}

		private Vector3 GetCurrentEyeTargetPos()
		{
			if (!(currentEyeTargetPOI != null))
			{
				return 0.5f * (currentTargetLeftEyeXform.position + currentTargetRightEyeXform.position);
			}
			return currentEyeTargetPOI.position;
		}

		private Vector3 GetCurrentHeadTargetPos()
		{
			if (!(currentHeadTargetPOI != null))
			{
				return 0.5f * (currentTargetLeftEyeXform.position + currentTargetRightEyeXform.position);
			}
			return currentHeadTargetPOI.position;
		}

		public Vector3 GetHeadDirection()
		{
			return headXform.rotation * headBoneInAvatarQ * Vector3.forward;
		}

		public Vector3 GetLeftEyeDirection()
		{
			if (leftEyeAnchor == null)
			{
				return eyesRootXform.forward;
			}
			return leftEyeAnchor.parent.rotation * leftEyeAnchor.localRotation * leftAnchorFromEyeRootQ * Vector3.forward;
		}

		private Vector3 GetLookTargetPosForSocialTriangle(FaceLookTarget playerFaceLookTarget)
		{
			if (currentTargetLeftEyeXform == null || currentTargetRightEyeXform == null)
			{
				return currentEyeTargetPOI.position;
			}
			Vector3 result = Vector3.zero;
			Vector3 vector = 0.5f * (currentTargetLeftEyeXform.position + currentTargetRightEyeXform.position);
			switch (playerFaceLookTarget)
			{
			case FaceLookTarget.EyesCenter:
				result = GetCurrentEyeTargetPos();
				break;
			case FaceLookTarget.LeftEye:
				result = Vector3.Lerp(vector, currentTargetLeftEyeXform.position, 0.75f);
				break;
			case FaceLookTarget.RightEye:
				result = Vector3.Lerp(vector, currentTargetRightEyeXform.position, 0.75f);
				break;
			case FaceLookTarget.Mouth:
			{
				Vector3 vector2 = 0.5f * (currentTargetLeftEyeXform.up + currentTargetRightEyeXform.up);
				result = vector - vector2 * 0.4f * Vector3.Distance(currentTargetLeftEyeXform.position, currentTargetRightEyeXform.position);
				break;
			}
			}
			return result;
		}

		public Vector3 GetOwnEyeCenter()
		{
			return eyesRootXform.position;
		}

		private Vector3 GetOwnLookDirection()
		{
			if (!(leftEyeAnchor != null) || !(rightEyeAnchor != null))
			{
				return eyesRootXform.forward;
			}
			return Quaternion.Slerp(leftEyeAnchor.rotation * leftAnchorFromEyeRootQ, rightEyeAnchor.rotation * rightAnchorFromEyeRootQ, 0.5f) * Vector3.forward;
		}

		public Vector3 GetRightEyeDirection()
		{
			if (rightEyeAnchor == null)
			{
				return eyesRootXform.forward;
			}
			return rightEyeAnchor.parent.rotation * rightEyeAnchor.localRotation * rightAnchorFromEyeRootQ * Vector3.forward;
		}

		public float GetStareAngleMeAtTarget(Vector3 target)
		{
			return Vector3.Angle(GetOwnLookDirection(), target - eyesRootXform.position);
		}

		public float GetStareAngleTargetAtMe(Transform targetXform)
		{
			return Vector3.Angle(targetXform.forward, GetOwnEyeCenter() - targetXform.position);
		}

		public void ImportFromFile(string filename)
		{
			if (!CanImportFromFile(filename))
			{
				UnityEngine.Debug.LogError(base.name + " cannot import from file");
				return;
			}
			EyeAndHeadAnimatorForExport eyeAndHeadAnimatorForExport;
			using (FileStream serializationStream = new FileStream(filename, FileMode.Open, FileAccess.Read, FileShare.Read))
			{
				eyeAndHeadAnimatorForExport = (EyeAndHeadAnimatorForExport)new BinaryFormatter().Deserialize(serializationStream);
			}
			headBoneNonMecanimXform = Utils.GetTransformFromPath(base.transform, eyeAndHeadAnimatorForExport.headBonePath);
			headSpeedModifier = eyeAndHeadAnimatorForExport.headSpeedModifier;
			headWeight = eyeAndHeadAnimatorForExport.headWeight;
			useMicroSaccades = eyeAndHeadAnimatorForExport.useMicroSaccades;
			useMacroSaccades = eyeAndHeadAnimatorForExport.useMacroSaccades;
			kDrawSightlinesInEditor = eyeAndHeadAnimatorForExport.kDrawSightlinesInEditor;
			controlData.Import(eyeAndHeadAnimatorForExport.controlData, base.transform);
			kMaxNextBlinkTime = eyeAndHeadAnimatorForExport.kMaxNextBlinkTime;
			eyelidsFollowEyesVertically = eyeAndHeadAnimatorForExport.eyelidsFollowEyesVertically;
			maxEyeHorizAngle = eyeAndHeadAnimatorForExport.maxEyeHorizAngle;
			maxEyeHorizAngleTowardsNose = eyeAndHeadAnimatorForExport.maxEyeHorizAngleTowardsNose;
			if (maxEyeHorizAngleTowardsNose <= 0f)
			{
				maxEyeHorizAngleTowardsNose = maxEyeHorizAngle;
			}
			crossEyeCorrection = eyeAndHeadAnimatorForExport.crossEyeCorrection;
			nervousness = eyeAndHeadAnimatorForExport.nervousness;
			limitHeadAngle = eyeAndHeadAnimatorForExport.limitHeadAngle;
			isInitialized = false;
			if (controlData.NeedsSaveDefaultBlendshapeConfig())
			{
				controlData.RestoreDefault();
				controlData.SaveDefault(this);
			}
		}

		public void Initialize()
		{
			if (isInitialized || controlData == null)
			{
				return;
			}
			headJitterTime = UnityEngine.Random.value * 10f;
			headJitterNoiseVectors = new Vector2[6];
			for (int i = 0; i < 6; i++)
			{
				float f = UnityEngine.Random.value * (float)Math.PI * 2f;
				headJitterNoiseVectors[i].Set(Mathf.Cos(f), Mathf.Sin(f));
			}
			eyeDistance = 0.064f;
			animator = GetComponentInChildren<Animator>();
			headXform = null;
			if (headControl == HeadControl.None)
			{
				if (animator != null && animator.GetBoneTransform(HumanBodyBones.Head) != null)
				{
					headControl = HeadControl.Mecanim;
					headXform = animator.GetBoneTransform(HumanBodyBones.Head);
				}
				else if (headBoneNonMecanimXform != null)
				{
					headControl = HeadControl.Transform;
					headXform = headBoneNonMecanimXform;
					headBoneNonMecanimFromRootQ = Quaternion.Inverse(base.transform.rotation) * headBoneNonMecanimXform.rotation;
				}
			}
			else
			{
				_ = headControl;
				_ = 2;
			}
			if (headXform == null)
			{
				headXform = base.transform;
			}
			headBoneInAvatarQ = Quaternion.Inverse(base.transform.rotation) * headXform.rotation;
			controlData.CheckConsistency(animator, this);
			controlData.Initialize(base.transform);
			if (createdTargetXforms[0] == null)
			{
				createdTargetXforms[0] = new GameObject(base.name + "_createdEyeTarget_1").transform;
				createdTargetXforms[0].gameObject.hideFlags = HideFlags.HideInHierarchy;
				createdTargetXforms[0].parent = base.transform;
			}
			if (createdTargetXforms[1] == null)
			{
				createdTargetXforms[1] = new GameObject(base.name + "_createdEyeTarget_2").transform;
				createdTargetXforms[1].gameObject.hideFlags = HideFlags.HideInHierarchy;
				createdTargetXforms[1].parent = base.transform;
			}
			if (headParentXform == null)
			{
				Transform transform = null;
				if (animator != null)
				{
					transform = animator.GetBoneTransform(HumanBodyBones.Chest);
					if (transform == null)
					{
						transform = animator.GetBoneTransform(HumanBodyBones.Spine);
					}
				}
				if (transform == null)
				{
					transform = base.transform;
				}
				headParentXform = new GameObject(base.name + " head parent").transform;
				headParentXform.gameObject.hideFlags = HideFlags.HideInHierarchy;
				headParentXform.parent = transform;
				headParentXform.position = headXform.position;
				headParentXform.rotation = base.transform.rotation;
			}
			if (headTargetPivotXform == null)
			{
				headTargetPivotXform = new GameObject(base.name + " head target").transform;
				headTargetPivotXform.gameObject.hideFlags = HideFlags.HideInHierarchy;
				headTargetPivotXform.parent = headParentXform;
				headTargetPivotXform.localPosition = Vector3.zero;
				headTargetPivotXform.localRotation = Quaternion.identity;
				critDampTween = new CritDampTweenQuaternion(headTargetPivotXform.localRotation, 3.5f, 2f);
				lastHeadEuler = headTargetPivotXform.localEulerAngles;
			}
			if (controlData.eyeControl == ControlData.EyeControl.MecanimEyeBones || controlData.eyeControl == ControlData.EyeControl.SelectedObjects)
			{
				if (controlData.eyeControl == ControlData.EyeControl.MecanimEyeBones)
				{
					Transform boneTransform = animator.GetBoneTransform(HumanBodyBones.LeftEye);
					Transform boneTransform2 = animator.GetBoneTransform(HumanBodyBones.RightEye);
					leftEyeAnchor = boneTransform;
					rightEyeAnchor = boneTransform2;
					if (leftEyeAnchor == null)
					{
						UnityEngine.Debug.LogError("Left eye bone not found in Mecanim rig");
					}
					if (rightEyeAnchor == null)
					{
						UnityEngine.Debug.LogError("Right eye bone not found in Mecanim rig");
					}
				}
				else if (controlData.eyeControl == ControlData.EyeControl.SelectedObjects)
				{
					leftEyeAnchor = controlData.leftEye;
					rightEyeAnchor = controlData.rightEye;
				}
			}
			if (eyesRootXform == null)
			{
				eyesRootXform = new GameObject(base.name + "_eyesRoot").transform;
				eyesRootXform.gameObject.hideFlags = HideFlags.HideInHierarchy;
				eyesRootXform.rotation = base.transform.rotation;
			}
			if (leftEyeAnchor != null && rightEyeAnchor != null)
			{
				eyeDistance = Vector3.Distance(leftEyeAnchor.position, rightEyeAnchor.position);
				eyeDistanceScale = eyeDistance / 0.064f;
				controlData.RestoreDefault(withEyelids: false);
				Quaternion quaternion = Quaternion.Inverse(eyesRootXform.rotation);
				leftEyeRootFromAnchorQ = quaternion * leftEyeAnchor.rotation;
				rightEyeRootFromAnchorQ = quaternion * rightEyeAnchor.rotation;
				leftAnchorFromEyeRootQ = Quaternion.Inverse(leftEyeRootFromAnchorQ);
				rightAnchorFromEyeRootQ = Quaternion.Inverse(rightEyeRootFromAnchorQ);
				originalLeftEyeLocalQ = leftEyeAnchor.localRotation;
				originalRightEyeLocalQ = rightEyeAnchor.localRotation;
				eyesRootXform.position = 0.5f * (leftEyeAnchor.position + rightEyeAnchor.position);
				Transform commonAncestor = Utils.GetCommonAncestor(leftEyeAnchor, rightEyeAnchor);
				eyesRootXform.parent = ((commonAncestor != null) ? commonAncestor : leftEyeAnchor.parent);
			}
			else if (animator != null)
			{
				if (headXform != null)
				{
					eyesRootXform.position = headXform.position;
					eyesRootXform.parent = headXform;
				}
				else
				{
					eyesRootXform.position = base.transform.position;
					eyesRootXform.parent = base.transform;
				}
			}
			else
			{
				eyesRootXform.position = base.transform.position;
				eyesRootXform.parent = base.transform;
			}
			if (controlData.eyelidControl == ControlData.EyelidControl.Bones)
			{
				if (controlData.upperEyeLidLeft != null && controlData.upperEyeLidRight != null)
				{
					useUpperEyelids = true;
				}
				if (controlData.lowerEyeLidLeft != null && controlData.lowerEyeLidRight != null)
				{
					useLowerEyelids = true;
				}
			}
			blink01 = 0f;
			float minInclusive = Mathf.Max(0.1f, Mathf.Min(kMinNextBlinkTime, kMaxNextBlinkTime));
			float maxInclusive = Mathf.Max(0.1f, Mathf.Max(kMinNextBlinkTime, kMaxNextBlinkTime));
			timeOfNextBlink = Time.time + UnityEngine.Random.Range(minInclusive, maxInclusive);
			ikWeight = headWeight;
			isInitialized = true;
		}

		public bool IsInView(Vector3 target)
		{
			if (leftEyeAnchor == null || rightEyeAnchor == null)
			{
				Vector3 eulerAngles = Quaternion.LookRotation(eyesRootXform.InverseTransformDirection(target - GetOwnEyeCenter())).eulerAngles;
				float f = Utils.NormalizedDegAngle(eulerAngles.x);
				float f2 = Utils.NormalizedDegAngle(eulerAngles.y);
				if (Mathf.Abs(f) <= 60f)
				{
					return Mathf.Abs(f2) <= 100f;
				}
				return false;
			}
			Vector3 eulerAngles2 = (leftEyeRootFromAnchorQ * Quaternion.Inverse(leftEyeAnchor.rotation) * Quaternion.LookRotation(target - leftEyeAnchor.position, leftEyeAnchor.up)).eulerAngles;
			float f3 = Utils.NormalizedDegAngle(eulerAngles2.x);
			float f4 = Utils.NormalizedDegAngle(eulerAngles2.y);
			bool num = Mathf.Abs(f3) <= 60f && Mathf.Abs(f4) <= 100f;
			Vector3 eulerAngles3 = (rightEyeRootFromAnchorQ * Quaternion.Inverse(rightEyeAnchor.rotation) * Quaternion.LookRotation(target - rightEyeAnchor.position, rightEyeAnchor.up)).eulerAngles;
			float f5 = Utils.NormalizedDegAngle(eulerAngles3.x);
			float f6 = Utils.NormalizedDegAngle(eulerAngles3.y);
			bool flag = Mathf.Abs(f5) <= 60f && Mathf.Abs(f6) <= 100f;
			return num || flag;
		}

		public bool IsLookingAtFace()
		{
			return lookTarget == LookTarget.Face;
		}

		private void LateUpdate()
		{
			if (!areUpdatedControlledExternally)
			{
				Update1();
			}
		}

		private float LimitHorizontalHeadAngle(float headAngle)
		{
			float num = Mathf.Lerp(55f, 0f, limitHeadAngle);
			headAngle = Utils.NormalizedDegAngle(headAngle);
			float num2 = Mathf.Abs(headAngle);
			return Mathf.Sign(headAngle) * (num2 - (140f - num) / Mathf.Pow(140f, 2.4f) * Mathf.Pow(num2, 2.4f));
		}

		private float LimitVerticalHeadAngle(float headAngle)
		{
			float num = Mathf.Lerp(40f, 0f, limitHeadAngle);
			headAngle = Utils.NormalizedDegAngle(headAngle);
			float num2 = Mathf.Abs(headAngle);
			return Mathf.Sign(headAngle) * (num2 - (80f - num) / Mathf.Pow(80f, 1.5f) * Mathf.Pow(num2, 1.5f));
		}

		public void LookAtFace(Transform eyeCenterXform, float headLatency = 0.075f)
		{
			lookTarget = LookTarget.Face;
			headSpeed = HeadSpeed.Fast;
			faceLookTarget = FaceLookTarget.EyesCenter;
			nextHeadTargetPOI = eyeCenterXform;
			this.headLatency = headLatency;
			currentTargetLeftEyeXform = (currentTargetRightEyeXform = null);
			nextTargetLeftEyeXform = (nextTargetRightEyeXform = null);
		}

		public void LookAtFace(Transform leftEyeXform, Transform rightEyeXform, float headLatency = 0.075f)
		{
			lookTarget = LookTarget.Face;
			headSpeed = HeadSpeed.Fast;
			faceLookTarget = FaceLookTarget.EyesCenter;
			this.headLatency = headLatency;
			currentTargetLeftEyeXform = leftEyeXform;
			currentTargetRightEyeXform = rightEyeXform;
			nextTargetLeftEyeXform = (nextTargetRightEyeXform = null);
			nextHeadTargetPOI = null;
		}

		public void LookAtSpecificThing(Transform poi, float headLatency = 0.075f)
		{
			lookTarget = LookTarget.SpecificThing;
			headSpeed = HeadSpeed.Fast;
			this.headLatency = headLatency;
			nextHeadTargetPOI = poi;
			currentTargetLeftEyeXform = (currentTargetRightEyeXform = null);
			nextTargetLeftEyeXform = (nextTargetRightEyeXform = null);
		}

		public void LookAtSpecificThing(Vector3 point, float headLatency = 0.075f)
		{
			createdTargetXformIndex = (createdTargetXformIndex + 1) % createdTargetXforms.Length;
			createdTargetXforms[createdTargetXformIndex].position = point;
			LookAtSpecificThing(createdTargetXforms[createdTargetXformIndex], headLatency);
		}

		public void LookAtAreaAround(Transform poi)
		{
			lookTarget = LookTarget.GeneralDirection;
			headSpeed = HeadSpeed.Slow;
			eyeLatency = UnityEngine.Random.Range(0.05f, 0.1f);
			nextEyeTargetPOI = poi;
			currentTargetLeftEyeXform = (currentTargetRightEyeXform = null);
			nextTargetLeftEyeXform = (nextTargetRightEyeXform = null);
			StartHeadMovement(poi);
		}

		public void LookAtAreaAround(Vector3 point)
		{
			createdTargetXformIndex = (createdTargetXformIndex + 1) % createdTargetXforms.Length;
			createdTargetXforms[createdTargetXformIndex].position = point;
			LookAtAreaAround(createdTargetXforms[createdTargetXformIndex]);
		}

		private void OnAnimatorIK()
		{
			if (headControl == HeadControl.Mecanim && controlData.eyeControl != 0 && !(headWeight <= 0f))
			{
				float b = ((lookTarget == LookTarget.StraightAhead || lookTarget == LookTarget.ClearingTargetPhase2 || lookTarget == LookTarget.ClearingTargetPhase1) ? 0f : headWeight);
				ikWeight = Mathf.Lerp(ikWeight, b, Time.deltaTime);
				animator.SetLookAtWeight(1f, 0.01f, ikWeight);
				animator.SetLookAtPosition(headTargetPivotXform.TransformPoint(eyeDistanceScale * Vector3.forward));
			}
		}

		private void OnCreatedXformDestroyed(DestroyNotifier destroyNotifer)
		{
			Transform component = destroyNotifer.GetComponent<Transform>();
			for (int i = 0; i < createdTargetXforms.Length; i++)
			{
				if (createdTargetXforms[i] == component)
				{
					createdTargetXforms[i] = null;
				}
			}
		}

		private void OnDestroy()
		{
			controlData.OnDestroy();
		}

		private void OnEnable()
		{
			Initialize();
		}

		private void SetMacroSaccadeTarget(Vector3 targetGlobal)
		{
			macroSaccadeTargetLocal = ((currentEyeTargetPOI != null) ? currentEyeTargetPOI : currentTargetLeftEyeXform).InverseTransformPoint(targetGlobal);
			timeOfLastMacroSaccade = Time.time;
			SetMicroSaccadeTarget(targetGlobal);
			timeToMicroSaccade += 0.75f;
		}

		private void SetMicroSaccadeTarget(Vector3 targetGlobal)
		{
			microSaccadeTargetLocal = ((currentEyeTargetPOI != null) ? currentEyeTargetPOI : currentTargetLeftEyeXform).InverseTransformPoint(targetGlobal);
			Vector3 eulerAngles = Quaternion.LookRotation(eyesRootXform.InverseTransformDirection(targetGlobal - leftEyeAnchor.position)).eulerAngles;
			eulerAngles = new Vector3(controlData.ClampLeftVertEyeAngle(eulerAngles.x), ClampLeftHorizEyeAngle(eulerAngles.y), eulerAngles.z);
			float num = Mathf.Abs(Mathf.DeltaAngle(currentLeftEyeLocalEuler.y, eulerAngles.y));
			leftMaxSpeedHoriz = 473f * (1f - Mathf.Exp((0f - num) / 7.8f));
			leftHorizDuration = 0.025f + 0.00235f * num;
			float num2 = Mathf.Abs(Mathf.DeltaAngle(currentLeftEyeLocalEuler.x, eulerAngles.x));
			leftMaxSpeedVert = 473f * (1f - Mathf.Exp((0f - num2) / 7.8f));
			leftVertDuration = 0.025f + 0.00235f * num2;
			Vector3 eulerAngles2 = Quaternion.LookRotation(eyesRootXform.InverseTransformDirection(targetGlobal - rightEyeAnchor.position)).eulerAngles;
			eulerAngles2 = new Vector3(controlData.ClampRightVertEyeAngle(eulerAngles2.x), ClampRightHorizEyeAngle(eulerAngles2.y), eulerAngles2.z);
			float num3 = Mathf.Abs(Mathf.DeltaAngle(currentRightEyeLocalEuler.y, eulerAngles2.y));
			rightMaxSpeedHoriz = 473f * (1f - Mathf.Exp((0f - num3) / 7.8f));
			rightHorizDuration = 0.025f + 0.00235f * num3;
			float num4 = Mathf.Abs(Mathf.DeltaAngle(currentRightEyeLocalEuler.x, eulerAngles2.x));
			rightMaxSpeedVert = 473f * (1f - Mathf.Exp((0f - num4) / 7.8f));
			rightVertDuration = 0.025f + 0.00235f * num4;
			leftMaxSpeedHoriz = (rightMaxSpeedHoriz = Mathf.Max(leftMaxSpeedHoriz, rightMaxSpeedHoriz));
			leftMaxSpeedVert = (rightMaxSpeedVert = Mathf.Max(leftMaxSpeedVert, rightMaxSpeedVert));
			leftHorizDuration = (rightHorizDuration = Mathf.Max(leftHorizDuration, rightHorizDuration));
			leftVertDuration = (rightVertDuration = Mathf.Max(leftVertDuration, rightVertDuration));
			timeToMicroSaccade = UnityEngine.Random.Range(0.8f, 1.75f);
			timeToMicroSaccade *= 1f / (1f + 0.4f * nervousness);
			if ((useUpperEyelids || useLowerEyelids || controlData.eyelidControl == ControlData.EyelidControl.Blendshapes) && Mathf.Max(num, Mathf.Max(num3, Mathf.Max(num2, num4))) >= 25f)
			{
				Blink(isShortBlink: false);
			}
			startLeftEyeHorizDuration = leftHorizDuration;
			startLeftEyeVertDuration = leftVertDuration;
			startLeftEyeMaxSpeedHoriz = leftMaxSpeedHoriz;
			startLeftEyeMaxSpeedVert = leftMaxSpeedVert;
			startRightEyeHorizDuration = rightHorizDuration;
			startRightEyeVertDuration = rightVertDuration;
			startRightEyeMaxSpeedHoriz = rightMaxSpeedHoriz;
			startRightEyeMaxSpeedVert = rightMaxSpeedVert;
			timeOfEyeMovementStart = Time.time;
		}

		private void Start()
		{
		}

		private void StartEyeMovement(Transform targetXform = null)
		{
			eyeLatency = 0f;
			currentEyeTargetPOI = targetXform;
			nextEyeTargetPOI = null;
			nextTargetLeftEyeXform = (nextTargetRightEyeXform = null);
			if (controlData.eyeControl != 0)
			{
				SetMacroSaccadeTarget(GetCurrentEyeTargetPos());
				timeToMacroSaccade = UnityEngine.Random.Range(1.5f, 2.5f);
				timeToMacroSaccade *= 1f / (1f + nervousness);
			}
			if (currentHeadTargetPOI == null)
			{
				currentHeadTargetPOI = currentEyeTargetPOI;
			}
		}

		private void StartHeadMovement(Transform targetXform = null)
		{
			headLatency = 0f;
			currentHeadTargetPOI = targetXform;
			nextHeadTargetPOI = null;
			Vector3 localEulerAngles = headTargetPivotXform.localEulerAngles;
			Vector3 eulerAngles = Quaternion.LookRotation(headParentXform.InverseTransformPoint(GetCurrentHeadTargetPos()), headParentXform.up).eulerAngles;
			eulerAngles = new Vector3(LimitVerticalHeadAngle(eulerAngles.x), LimitHorizontalHeadAngle(eulerAngles.y), 0f);
			float num = Mathf.Abs(Mathf.DeltaAngle(localEulerAngles.y, eulerAngles.y));
			float num2 = Mathf.Abs(Mathf.DeltaAngle(localEulerAngles.x, eulerAngles.x));
			bool flag = headSpeed == HeadSpeed.Fast;
			if (headTweenMethod == HeadTweenMethod.SmoothDamping)
			{
				float num3 = (flag ? 0.3874687f : 0.5820854f);
				float num4 = (flag ? 0.00741433f : 0.01056395f);
				headHorizDuration = num3 + num4 * num;
				headVertDuration = num3 + num4 * num2;
				float num5 = (flag ? 33.4204f : 19.799381f);
				float num6 = (flag ? 2.5867999f : 1.6078972f);
				headMaxSpeedHoriz = num5 + num6 * num;
				headMaxSpeedVert = num5 + num6 * num2;
				float num7 = (flag ? 1.3f : 1f) * headSpeedModifier;
				headMaxSpeedHoriz *= num7;
				headMaxSpeedVert *= num7;
				headHorizDuration /= num7;
				headVertDuration /= num7;
				startHeadHorizDuration = headHorizDuration;
				startHeadVertDuration = headVertDuration;
				startHeadMaxSpeedHoriz = headMaxSpeedHoriz;
				startHeadMaxSpeedVert = headMaxSpeedVert;
			}
			else if (headTweenMethod == HeadTweenMethod.CriticalDamping)
			{
				isHeadTracking = false;
				headTrackingFactor = 1f;
			}
			timeOfHeadMovementStart = Time.time;
			maxHeadHorizSpeedSinceSaccadeStart = (maxHeadVertSpeedSinceSaccadeStart = 0f);
			if (currentEyeTargetPOI == null && currentTargetLeftEyeXform == null)
			{
				currentEyeTargetPOI = currentHeadTargetPOI;
			}
		}

		private void Update()
		{
			hasLateUpdateRunThisFrame = false;
			if (isInitialized)
			{
				CheckLatencies();
			}
		}

		public void Update1()
		{
			UpdateBlinking();
			UpdateEyelids();
			if (Time.frameCount == lastFrameOfUpdate1)
			{
				UnityEngine.Debug.LogWarning("Update1 is suppsed to be called only once per frame");
				return;
			}
			lastFrameOfUpdate1 = Time.frameCount;
			hasLateUpdateRunThisFrame = true;
			if (!isInitialized || lookTarget == LookTarget.StraightAhead)
			{
				return;
			}
			if (currentHeadTargetPOI == null && currentTargetLeftEyeXform == null)
			{
				if (this.OnTargetDestroyed != null)
				{
					this.OnTargetDestroyed();
				}
				return;
			}
			if (headControl == HeadControl.Transform)
			{
				float b = ((lookTarget == LookTarget.StraightAhead || lookTarget == LookTarget.ClearingTargetPhase2 || lookTarget == LookTarget.ClearingTargetPhase1) ? 0f : headWeight);
				ikWeight = Mathf.Lerp(ikWeight, b, Time.deltaTime);
				Quaternion b2 = Quaternion.LookRotation(headTargetPivotXform.TransformPoint(eyeDistanceScale * Vector3.forward) - headBoneNonMecanimXform.position, base.transform.up);
				Quaternion quaternion = Quaternion.Slerp(Quaternion.identity, b2, ikWeight);
				headBoneNonMecanimXform.rotation = quaternion * headBoneNonMecanimFromRootQ;
			}
			if (controlData.eyeControl != 0)
			{
				Transform transform = ((currentEyeTargetPOI != null) ? currentEyeTargetPOI : currentTargetLeftEyeXform);
				if (transform != null && this.OnCannotGetTargetIntoView != null && !CanGetIntoView(transform.TransformPoint(macroSaccadeTargetLocal)) && eyeLatency <= 0f)
				{
					this.OnCannotGetTargetIntoView();
				}
			}
			UpdateHeadMovement();
			if (headControl != HeadControl.FinalIK && !areUpdatedControlledExternally)
			{
				Update2();
			}
		}

		public void Update2()
		{
			if (Time.frameCount == lastFrameOfUpdate2)
			{
				UnityEngine.Debug.LogWarning("Update2 is suppsed to be called only once per frame");
				return;
			}
			lastFrameOfUpdate2 = Time.frameCount;
			if (isInitialized && base.enabled && lookTarget != 0)
			{
				if (controlData.eyeControl != 0)
				{
					CheckMicroSaccades();
					CheckMacroSaccades();
				}
				if (kDrawSightlinesInEditor)
				{
					DrawSightlinesInEditor();
				}
				if (this.OnUpdate2Finished != null)
				{
					this.OnUpdate2Finished();
				}
			}
		}

		private void UpdateBlinking()
		{
			if (blinkState != 0)
			{
				blinkStateTime += Time.deltaTime;
				if (blinkStateTime >= blinkDuration)
				{
					blinkStateTime = 0f;
					if (blinkState == BlinkState.Closing)
					{
						if (isShortBlink)
						{
							blinkState = BlinkState.Opening;
							blinkDuration = 1f / blinkSpeed * (isShortBlink ? 0.072f : 0.144f);
							blink01 = 1f;
						}
						else
						{
							blinkState = BlinkState.KeepingClosed;
							blinkDuration = 1f / blinkSpeed * 0.008f;
							blink01 = 1f;
						}
					}
					else if (blinkState == BlinkState.KeepingClosed)
					{
						blinkState = BlinkState.Opening;
						blinkDuration = 1f / blinkSpeed * (isShortBlink ? 0.072f : 0.144f);
					}
					else if (blinkState == BlinkState.Opening)
					{
						blinkState = BlinkState.Idle;
						float minInclusive = Mathf.Max(0.1f, Mathf.Min(kMinNextBlinkTime, kMaxNextBlinkTime));
						float maxInclusive = Mathf.Max(0.1f, Mathf.Max(kMinNextBlinkTime, kMaxNextBlinkTime));
						timeOfNextBlink = Time.time + UnityEngine.Random.Range(minInclusive, maxInclusive);
						blink01 = 0f;
					}
				}
				else
				{
					blink01 = Utils.EaseSineIn(blinkStateTime, (blinkState != BlinkState.Closing) ? 1 : 0, (blinkState == BlinkState.Closing) ? 1 : (-1), blinkDuration);
				}
			}
			if (Time.time >= timeOfNextBlink && blinkState == BlinkState.Idle)
			{
				Blink();
			}
		}

		private void UpdateEyelids()
		{
			if (controlData.eyelidControl != 0)
			{
				controlData.UpdateEyelids(currentLeftEyeLocalEuler.x, currentRightEyeLocalEuler.x, blink01, eyelidsFollowEyesVertically);
			}
		}

		private void UpdateEyeMovement()
		{
			if (lookTarget == LookTarget.ClearingTargetPhase2)
			{
				if (Time.time - timeOfEnteringClearingPhase >= 1f)
				{
					lookTarget = LookTarget.StraightAhead;
					return;
				}
				leftEyeAnchor.localRotation = (lastLeftEyeLocalRotation = Quaternion.Slerp(lastLeftEyeLocalRotation, originalLeftEyeLocalQ, Time.deltaTime));
				rightEyeAnchor.localRotation = (lastRightEyeLocalQ = Quaternion.Slerp(lastRightEyeLocalQ, originalRightEyeLocalQ, Time.deltaTime));
				return;
			}
			if (lookTarget == LookTarget.ClearingTargetPhase1 && Time.time - timeOfEnteringClearingPhase >= 2f)
			{
				lookTarget = LookTarget.ClearingTargetPhase2;
				timeOfEnteringClearingPhase = Time.time;
			}
			bool flag = lookTarget == LookTarget.Face;
			bool flag2 = flag && faceLookTarget != FaceLookTarget.EyesCenter;
			Transform transform = ((currentEyeTargetPOI != null) ? currentEyeTargetPOI : currentTargetLeftEyeXform);
			if (!(transform == null))
			{
				Vector3 vector = (flag2 ? GetLookTargetPosForSocialTriangle(faceLookTarget) : transform.TransformPoint(microSaccadeTargetLocal));
				Vector3 ownEyeCenter = GetOwnEyeCenter();
				Vector3 vector2 = vector - ownEyeCenter;
				float num = vector2.magnitude / eyeDistanceScale;
				float num2 = (flag ? 2f : 0.6f);
				float num3 = (flag ? 1.5f : 0.2f);
				if (num < num2)
				{
					float num4 = num3 + num * (num2 - num3) / num2;
					num4 = crossEyeCorrection * (num4 - num) + num;
					vector = ownEyeCenter + eyeDistanceScale * num4 * (vector2 / num);
				}
				float num5 = Time.time - (timeOfEyeMovementStart + 1.5f * startLeftEyeHorizDuration);
				if (num5 > 0f)
				{
					leftHorizDuration = 0.005f + startLeftEyeHorizDuration / (1f + num5);
					leftMaxSpeedHoriz = 600f - startLeftEyeMaxSpeedHoriz / (1f + num5);
				}
				float num6 = Time.time - (timeOfEyeMovementStart + 1.5f * startLeftEyeVertDuration);
				if (num6 > 0f)
				{
					leftVertDuration = 0.005f + startLeftEyeVertDuration / (1f + num6);
					leftMaxSpeedVert = 600f - startLeftEyeMaxSpeedVert / (1f + num6);
				}
				float num7 = Time.time - (timeOfEyeMovementStart + 1.5f * startRightEyeHorizDuration);
				if (num7 > 0f)
				{
					rightHorizDuration = 0.005f + startRightEyeHorizDuration / (1f + num7);
					rightMaxSpeedHoriz = 600f - startRightEyeMaxSpeedHoriz / (1f + num7);
				}
				float num8 = Time.time - (timeOfEyeMovementStart + 1.5f * startRightEyeVertDuration);
				if (num8 > 0f)
				{
					rightVertDuration = 0.005f + startRightEyeVertDuration / (1f + num8);
					rightMaxSpeedVert = 600f - startRightEyeMaxSpeedVert / (1f + num8);
				}
				Vector3 eulerAngles = Quaternion.LookRotation(eyesRootXform.InverseTransformDirection(vector - leftEyeAnchor.position)).eulerAngles;
				Vector3 vector3 = new Vector3(controlData.ClampLeftVertEyeAngle(eulerAngles.x), ClampLeftHorizEyeAngle(eulerAngles.y), 0f);
				float deltaTime = Mathf.Max(0.0001f, Time.deltaTime);
				float a = 4f * maxHeadHorizSpeedSinceSaccadeStart * Mathf.Sign(headEulerSpeed.y);
				float a2 = 4f * maxHeadVertSpeedSinceSaccadeStart * Mathf.Sign(headEulerSpeed.x);
				currentLeftEyeLocalEuler = new Vector3(controlData.ClampLeftVertEyeAngle(Mathf.SmoothDampAngle(currentLeftEyeLocalEuler.x, vector3.x, ref leftCurrentSpeedX, leftVertDuration, Mathf.Max(a2, leftMaxSpeedVert), deltaTime)), ClampLeftHorizEyeAngle(Mathf.SmoothDampAngle(currentLeftEyeLocalEuler.y, vector3.y, ref leftCurrentSpeedY, leftHorizDuration, Mathf.Max(a, leftMaxSpeedHoriz), deltaTime)), vector3.z);
				leftEyeAnchor.localRotation = Quaternion.Inverse(leftEyeAnchor.parent.rotation) * eyesRootXform.rotation * Quaternion.Euler(currentLeftEyeLocalEuler) * leftEyeRootFromAnchorQ;
				Vector3 eulerAngles2 = Quaternion.LookRotation(eyesRootXform.InverseTransformDirection(vector - rightEyeAnchor.position)).eulerAngles;
				Vector3 vector4 = new Vector3(controlData.ClampRightVertEyeAngle(eulerAngles2.x), ClampRightHorizEyeAngle(eulerAngles2.y), 0f);
				currentRightEyeLocalEuler = new Vector3(controlData.ClampRightVertEyeAngle(Mathf.SmoothDampAngle(currentRightEyeLocalEuler.x, vector4.x, ref rightCurrentSpeedX, rightVertDuration, Mathf.Max(a2, rightMaxSpeedVert), deltaTime)), ClampRightHorizEyeAngle(Mathf.SmoothDampAngle(currentRightEyeLocalEuler.y, vector4.y, ref rightCurrentSpeedY, rightHorizDuration, Mathf.Max(a, rightMaxSpeedHoriz), deltaTime)), vector4.z);
				rightEyeAnchor.localRotation = Quaternion.Inverse(rightEyeAnchor.parent.rotation) * eyesRootXform.rotation * Quaternion.Euler(currentRightEyeLocalEuler) * rightEyeRootFromAnchorQ;
				lastLeftEyeLocalRotation = leftEyeAnchor.localRotation;
				lastRightEyeLocalQ = rightEyeAnchor.localRotation;
			}
		}

		private void UpdateHeadMovement()
		{
			if (headControl == HeadControl.None || controlData.eyeControl == ControlData.EyeControl.None || ikWeight <= 0f)
			{
				return;
			}
			Vector3 localEulerAngles = headTargetPivotXform.localEulerAngles;
			Vector3 eulerAngles = Quaternion.LookRotation(headParentXform.InverseTransformPoint(GetCurrentHeadTargetPos())).eulerAngles;
			if (useHeadJitter)
			{
				headJitterTime += Time.deltaTime * 0.2f;
				Vector3 a = new Vector3(Utils.Fbm(headJitterNoiseVectors[3] * headJitterTime, 3), Utils.Fbm(headJitterNoiseVectors[4] * headJitterTime, 3), Utils.Fbm(headJitterNoiseVectors[5] * headJitterTime, 3));
				a = Vector3.Scale(a, headJitterRotationComponents) * 1f * 2f;
				eulerAngles += a;
			}
			eulerAngles = new Vector3(LimitVerticalHeadAngle(eulerAngles.x), LimitHorizontalHeadAngle(eulerAngles.y), 0f);
			if (headTweenMethod == HeadTweenMethod.SmoothDamping)
			{
				float num = Time.time - (timeOfHeadMovementStart + 1.5f * startHeadHorizDuration);
				if (num > 0f)
				{
					headHorizDuration = 0.1f + startHeadHorizDuration / (1f + num);
					headMaxSpeedHoriz = Mathf.Max(startHeadMaxSpeedHoriz, 150f) - startHeadMaxSpeedHoriz / (1f + num);
				}
				float num2 = Time.time - (timeOfHeadMovementStart + 1.5f * startHeadVertDuration);
				if (num2 > 0f)
				{
					headVertDuration = 0.1f + startHeadVertDuration / (1f + num2);
					headMaxSpeedVert = Mathf.Max(startHeadMaxSpeedVert, 150f) - startHeadMaxSpeedVert / (1f + num2);
				}
			}
			else if (headTweenMethod == HeadTweenMethod.CriticalDamping)
			{
				if (!isHeadTracking)
				{
					Vector3 eulerAngles2 = critDampTween.rotation.eulerAngles;
					isHeadTracking = Mathf.Abs(Mathf.DeltaAngle(eulerAngles2.x, eulerAngles.x)) < 2f && Mathf.Abs(Mathf.DeltaAngle(eulerAngles2.y, eulerAngles.y)) < 2f;
				}
				float num3 = ((headSpeed == HeadSpeed.Slow) ? 0.5f : 1f);
				float b = ((!isHeadTracking) ? 1 : 5);
				headTrackingFactor = Mathf.Lerp(headTrackingFactor, b, Time.deltaTime * 3f);
				critDampTween.omega = num3 * headSpeedModifier * headTrackingFactor * 3.5f;
			}
			float num4 = Mathf.Max(0.0001f, Time.deltaTime);
			if (headTweenMethod == HeadTweenMethod.SmoothDamping)
			{
				headTargetPivotXform.localEulerAngles = new Vector3(Mathf.SmoothDampAngle(localEulerAngles.x, eulerAngles.x, ref currentHeadVertSpeed, headVertDuration, headMaxSpeedVert, num4), Mathf.SmoothDampAngle(localEulerAngles.y, eulerAngles.y, ref currentHeadHorizSpeed, headHorizDuration, headMaxSpeedHoriz, num4), Mathf.SmoothDampAngle(localEulerAngles.z, eulerAngles.z, ref currentHeadZSpeed, headHorizDuration, headMaxSpeedHoriz, num4));
			}
			else if (headTweenMethod == HeadTweenMethod.CriticalDamping)
			{
				Quaternion target = Quaternion.Euler(eulerAngles);
				critDampTween.Step(target);
				headTargetPivotXform.localEulerAngles = critDampTween.rotation.eulerAngles;
			}
			headEulerSpeed = (headTargetPivotXform.localEulerAngles - lastHeadEuler) / num4;
			lastHeadEuler = headTargetPivotXform.localEulerAngles;
			maxHeadHorizSpeedSinceSaccadeStart = Mathf.Max(maxHeadHorizSpeedSinceSaccadeStart, Mathf.Abs(headEulerSpeed.y));
			maxHeadVertSpeedSinceSaccadeStart = Mathf.Max(maxHeadHorizSpeedSinceSaccadeStart, Mathf.Abs(headEulerSpeed.x));
		}
	}
	public class LookTargetController : MonoBehaviour
	{
		private enum State
		{
			LookingAtPlayer,
			LookingAroundIdly,
			LookingAtPoiDirectly,
			LookingAwayFromPlayer
		}

		public Transform viveEye;

		public Transform oculusCenter;

		public Transform oculusLeftEye;

		public Transform oculusRightEye;

		[Tooltip("Drag objects here for the actor to look at. If empty, actor will look in random directions.")]
		public Transform[] pointsOfInterest;

		[Tooltip("Ratio of how often to look at player vs elsewhere. 0: never, 1: always")]
		[Range(0f, 1f)]
		public float lookAtPlayerRatio = 0.1f;

		[Tooltip("How likely the actor is to look back at the player when player stares at actor.")]
		[Range(0f, 1f)]
		public float stareBackFactor;

		[Tooltip("If player is closer than this, notice him")]
		[Range(0f, 100f)]
		public float noticePlayerDistance;

		[Tooltip("If player is closer than this, look away (overrides noticing him)")]
		[Range(0f, 4f)]
		public float personalSpaceDistance;

		[Tooltip("Minimum time to look at a target")]
		[Range(1f, 100f)]
		public float minLookTime = 3f;

		[Tooltip("Maximum time to look at a target")]
		[Range(1f, 100f)]
		public float maxLookTime = 10f;

		[Tooltip("For 3rd person games, set this to the player's eye center transform")]
		[FormerlySerializedAs("playerEyeCenter")]
		public Transform thirdPersonPlayerEyeCenter;

		[Tooltip("Keep trying to track target even when it moves out of sight")]
		public bool keepTargetEvenWhenLost = true;

		[Header("Events")]
		public UnityEvent OnStartLookingAtPlayer;

		public UnityEvent OnStopLookingAtPlayer;

		private EyeAndHeadAnimator eyeAndHeadAnimator;

		private const float minLookAtMeTimeToReact = 4f;

		private Transform targetPOI;

		private Transform playerEyeCenterXform;

		private Transform playerLeftEyeXform;

		private Transform playerRightEyeXform;

		private Transform usedThirdPersonPlayerEyeCenter;

		private GameObject createdVRParentGO;

		private GameObject createdPlayerEyeCenterGO;

		private GameObject createdPlayerLeftEyeGO;

		private GameObject createdPlayerRightEyeGO;

		private float lastDistanceToPlayer = -1f;

		private float playerLookingAtMeTime;

		private float nextChangePOITime;

		private float stareBackDeadtime;

		private float timeOfLastNoticeCheck = -1000f;

		private float timeOfLastLookBackCheck = -1000f;

		private float timeOutsideOfAwarenessZone = 1000f;

		private float timeInsidePersonalSpace;

		private bool useNativeVRSupport;

		private bool useVR;

		private bool isInitialized;

		private State state = State.LookingAroundIdly;

		private void Awake()
		{
			SceneManager.sceneLoaded += OnSceneLoaded;
			if (GameManager.instance != null)
			{
				viveEye = GameManager.instance.objectRefrences.viveCenter;
				oculusCenter = GameManager.instance.objectRefrences.oculusCenter;
				oculusLeftEye = GameManager.instance.objectRefrences.oculusLeftEye;
				oculusRightEye = GameManager.instance.objectRefrences.oculusRightEye;
			}
		}

		public void Blink()
		{
			eyeAndHeadAnimator.Blink();
		}

		private void ChangeStateTo(State newState)
		{
			if (state != 0 && newState == State.LookingAtPlayer && OnStartLookingAtPlayer != null)
			{
				OnStartLookingAtPlayer.Invoke();
			}
			if (state == State.LookingAtPlayer && newState != 0 && OnStopLookingAtPlayer != null)
			{
				OnStopLookingAtPlayer.Invoke();
			}
			state = newState;
		}

		private Vector3 ChooseNextHeadTargetPoint()
		{
			bool flag = eyeAndHeadAnimator.controlData.eyelidControl == ControlData.EyelidControl.Bones;
			float x = UnityEngine.Random.Range(-0.5f * (flag ? 6f : 3f), flag ? 6f : 4f);
			float y = UnityEngine.Random.Range(-10f, 10f);
			Vector3 vector = ((eyeAndHeadAnimator.headWeight <= 0f) ? eyeAndHeadAnimator.GetHeadDirection() : eyeAndHeadAnimator.headParentXform.forward);
			Vector3 vector2 = Quaternion.Euler(x, y, 0f) * vector;
			return eyeAndHeadAnimator.GetOwnEyeCenter() + 2f * eyeAndHeadAnimator.eyeDistanceScale * UnityEngine.Random.Range(3f, 5f) * vector2;
		}

		private Transform ChooseNextHeadTargetPOI()
		{
			if (pointsOfInterest == null || pointsOfInterest.Length == 0)
			{
				return null;
			}
			int num = 0;
			for (int i = 0; i < pointsOfInterest.Length; i++)
			{
				if (pointsOfInterest[i] != null && pointsOfInterest[i] != targetPOI && eyeAndHeadAnimator.CanGetIntoView(pointsOfInterest[i].position) && pointsOfInterest[i].gameObject.activeInHierarchy)
				{
					num++;
				}
			}
			if (num == 0)
			{
				return targetPOI;
			}
			int num2 = UnityEngine.Random.Range(0, num);
			int num3 = 0;
			for (int j = 0; j < pointsOfInterest.Length; j++)
			{
				if (pointsOfInterest[j] != null && pointsOfInterest[j] != targetPOI && eyeAndHeadAnimator.CanGetIntoView(pointsOfInterest[j].position) && pointsOfInterest[j].gameObject.activeInHierarchy)
				{
					if (num3 == num2)
					{
						return pointsOfInterest[j];
					}
					num3++;
				}
			}
			return null;
		}

		public void ClearLookTarget()
		{
			eyeAndHeadAnimator.ClearLookTarget();
			nextChangePOITime = -1f;
		}

		private Transform FindPlayerCamera()
		{
			if (thirdPersonPlayerEyeCenter != null)
			{
				return thirdPersonPlayerEyeCenter;
			}
			if (Camera.main != null)
			{
				return Camera.main.transform;
			}
			Camera[] array = UnityEngine.Object.FindObjectsOfType<Camera>();
			foreach (Camera camera in array)
			{
				if (camera.targetTexture == null)
				{
					return camera.transform;
				}
			}
			return null;
		}

		public void Initialize()
		{
			if (isInitialized)
			{
				return;
			}
			if (createdVRParentGO != null)
			{
				DestroyNotifier component = createdVRParentGO.GetComponent<DestroyNotifier>();
				if (component != null)
				{
					component.OnDestroyedEvent -= OnPlayerEyesParentDestroyed;
				}
				UnityEngine.Object.Destroy(createdVRParentGO);
				createdVRParentGO = null;
				createdPlayerEyeCenterGO = null;
				createdPlayerLeftEyeGO = null;
				createdPlayerRightEyeGO = null;
			}
			eyeAndHeadAnimator = GetComponent<EyeAndHeadAnimator>();
			eyeAndHeadAnimator.Initialize();
			eyeAndHeadAnimator.OnTargetDestroyed += OnTargetDestroyed;
			eyeAndHeadAnimator.OnCannotGetTargetIntoView += OnCannotGetTargetIntoView;
			eyeAndHeadAnimator.OnTargetOutOfSight += OnTargetOutOfSight;
			eyeAndHeadAnimator.OnUpdate2Finished += VeryLateUpdate;
			useNativeVRSupport = false;
			LookAroundIdly();
			nextChangePOITime = 0f;
			isInitialized = true;
		}

		public bool IsLookingAtPlayer()
		{
			return state == State.LookingAtPlayer;
		}

		public bool IsPlayerInView()
		{
			if (playerEyeCenterXform != null)
			{
				return eyeAndHeadAnimator.IsInView(playerEyeCenterXform.position);
			}
			return false;
		}

		public void LookAtPlayer(float duration = -1f, float headLatency = 0.075f)
		{
			if (playerLeftEyeXform != null && playerRightEyeXform != null)
			{
				eyeAndHeadAnimator.LookAtFace(playerLeftEyeXform, playerRightEyeXform, headLatency);
			}
			else
			{
				if (!(playerEyeCenterXform != null))
				{
					return;
				}
				eyeAndHeadAnimator.LookAtFace(playerEyeCenterXform, headLatency);
			}
			nextChangePOITime = ((duration >= 0f) ? (Time.time + duration) : (-1f));
			targetPOI = null;
			timeOutsideOfAwarenessZone = 0f;
			ChangeStateTo(State.LookingAtPlayer);
		}

		public void LookAroundIdly()
		{
			if (state == State.LookingAtPlayer)
			{
				stareBackDeadtime = UnityEngine.Random.Range(10f, 30f);
			}
			targetPOI = ChooseNextHeadTargetPOI();
			if (targetPOI != null)
			{
				eyeAndHeadAnimator.LookAtAreaAround(targetPOI);
			}
			else
			{
				eyeAndHeadAnimator.LookAtAreaAround(ChooseNextHeadTargetPoint());
			}
			nextChangePOITime = Time.time + UnityEngine.Random.Range(Mathf.Min(minLookTime, maxLookTime), Mathf.Max(minLookTime, maxLookTime));
			ChangeStateTo(State.LookingAroundIdly);
		}

		public void LookAtPoiDirectly(Transform poiXform, float duration = -1f, float headLatency = 0.075f)
		{
			eyeAndHeadAnimator.LookAtSpecificThing(poiXform, headLatency);
			nextChangePOITime = ((duration >= 0f) ? (Time.time + duration) : (-1f));
			ChangeStateTo(State.LookingAtPoiDirectly);
		}

		public void LookAtPoiDirectly(Vector3 poi, float duration = -1f, float headLatency = 0.075f)
		{
			eyeAndHeadAnimator.LookAtSpecificThing(poi, headLatency);
			nextChangePOITime = ((duration >= 0f) ? (Time.time + duration) : (-1f));
			ChangeStateTo(State.LookingAtPoiDirectly);
		}

		private void LookAwayFromPlayer()
		{
			if (!(playerEyeCenterXform == null))
			{
				stareBackDeadtime = UnityEngine.Random.Range(5f, 10f);
				bool flag = eyeAndHeadAnimator.headParentXform.InverseTransformPoint(playerEyeCenterXform.position).x < 0f;
				Vector3 point = eyeAndHeadAnimator.headParentXform.TransformPoint(eyeAndHeadAnimator.GetOwnEyeCenter() + 10f * (Quaternion.Euler(0f, flag ? 50 : (-50), 0f) * Vector3.forward));
				eyeAndHeadAnimator.LookAtAreaAround(point);
				nextChangePOITime = Time.time + UnityEngine.Random.Range(Mathf.Min(minLookTime, maxLookTime), Mathf.Max(minLookTime, maxLookTime));
				ChangeStateTo(State.LookingAwayFromPlayer);
			}
		}

		private void OnCannotGetTargetIntoView()
		{
			if (((state != State.LookingAtPoiDirectly && (state != 0 || nextChangePOITime != -1f)) || !keepTargetEvenWhenLost) && eyeAndHeadAnimator.CanChangePointOfAttention())
			{
				OnTargetLost();
			}
		}

		private void OnDestroy()
		{
			if (createdVRParentGO != null)
			{
				DestroyNotifier component = createdVRParentGO.GetComponent<DestroyNotifier>();
				if (component != null)
				{
					component.OnDestroyedEvent -= OnPlayerEyesParentDestroyed;
				}
				UnityEngine.Object.Destroy(createdVRParentGO);
			}
			SceneManager.sceneLoaded -= OnSceneLoaded;
		}

		private void OnPlayerEyesParentDestroyed(DestroyNotifier destroyNotifier)
		{
			if (destroyNotifier.gameObject != createdVRParentGO)
			{
				UnityEngine.Debug.LogWarning("Received OnPlayerEyesParentDestroyed from unknown gameObject " + destroyNotifier, destroyNotifier.gameObject);
				return;
			}
			createdVRParentGO = null;
			createdPlayerEyeCenterGO = null;
			createdPlayerLeftEyeGO = null;
			createdPlayerRightEyeGO = null;
			isInitialized = false;
			Initialize();
		}

		private void OnSceneLoaded(Scene scene, LoadSceneMode loadSceneMode)
		{
			isInitialized = false;
			Initialize();
		}

		private void OnTargetDestroyed()
		{
			OnTargetLost();
		}

		private void OnTargetLost()
		{
			if (UnityEngine.Random.value <= lookAtPlayerRatio && IsPlayerInView())
			{
				LookAtPlayer(UnityEngine.Random.Range(Mathf.Min(minLookTime, maxLookTime), Mathf.Max(minLookTime, maxLookTime)));
			}
			else
			{
				LookAroundIdly();
			}
		}

		private void OnTargetOutOfSight()
		{
			if (state == State.LookingAroundIdly)
			{
				OnTargetLost();
			}
		}

		private void Start()
		{
			if (!isInitialized)
			{
				Initialize();
			}
		}

		private void UpdateNativeVREyePositions()
		{
			if (useNativeVRSupport && usedThirdPersonPlayerEyeCenter == null)
			{
				playerEyeCenterXform.localPosition = InputTracking.GetLocalPosition(XRNode.CenterEye);
				playerLeftEyeXform.localPosition = InputTracking.GetLocalPosition(XRNode.LeftEye);
				playerRightEyeXform.localPosition = InputTracking.GetLocalPosition(XRNode.RightEye);
				playerEyeCenterXform.localRotation = InputTracking.GetLocalRotation(XRNode.CenterEye);
				playerLeftEyeXform.localRotation = InputTracking.GetLocalRotation(XRNode.LeftEye);
				playerRightEyeXform.localRotation = InputTracking.GetLocalRotation(XRNode.RightEye);
			}
		}

		private void UpdatePlayerEyeTransformReferences()
		{
			if (thirdPersonPlayerEyeCenter == usedThirdPersonPlayerEyeCenter)
			{
				return;
			}
			if (thirdPersonPlayerEyeCenter != null)
			{
				if (Utils.IsEqualOrDescendant(base.transform, thirdPersonPlayerEyeCenter))
				{
					UnityEngine.Debug.LogError("Player Eye Center should be part of the player character who this character is supposed to look at, not part of this character itself!");
				}
				playerEyeCenterXform = thirdPersonPlayerEyeCenter;
				playerLeftEyeXform = (playerRightEyeXform = null);
			}
			else if (useNativeVRSupport)
			{
				playerEyeCenterXform = createdPlayerEyeCenterGO.transform;
				playerLeftEyeXform = createdPlayerLeftEyeGO.transform;
				playerRightEyeXform = createdPlayerRightEyeGO.transform;
			}
			else if (useVR)
			{
				GameObject gameObject = GameObject.Find("OVRCameraRig");
				if (gameObject != null)
				{
					playerLeftEyeXform = Utils.FindChildInHierarchy(gameObject, "LeftEyeAnchor").transform;
					playerRightEyeXform = Utils.FindChildInHierarchy(gameObject, "RightEyeAnchor").transform;
					playerEyeCenterXform = Utils.FindChildInHierarchy(gameObject, "CenterEyeAnchor").transform;
				}
				else
				{
					playerEyeCenterXform = FindPlayerCamera();
					playerLeftEyeXform = (playerRightEyeXform = null);
				}
			}
			else
			{
				playerEyeCenterXform = FindPlayerCamera();
				playerLeftEyeXform = (playerRightEyeXform = null);
			}
			usedThirdPersonPlayerEyeCenter = thirdPersonPlayerEyeCenter;
		}

		private void VeryLateUpdate()
		{
			if (usedThirdPersonPlayerEyeCenter == null)
			{
				if (viveEye.gameObject.activeInHierarchy)
				{
					thirdPersonPlayerEyeCenter = viveEye;
					playerEyeCenterXform = viveEye;
					playerLeftEyeXform = viveEye;
					playerRightEyeXform = viveEye;
					usedThirdPersonPlayerEyeCenter = viveEye;
				}
				else if (oculusCenter.gameObject.activeInHierarchy)
				{
					thirdPersonPlayerEyeCenter = oculusCenter;
					playerEyeCenterXform = oculusCenter;
					playerLeftEyeXform = oculusLeftEye;
					playerRightEyeXform = oculusRightEye;
					usedThirdPersonPlayerEyeCenter = thirdPersonPlayerEyeCenter;
				}
			}
			if (!isInitialized)
			{
				return;
			}
			if (nextChangePOITime >= 0f && Time.time >= nextChangePOITime && eyeAndHeadAnimator.CanChangePointOfAttention())
			{
				if (UnityEngine.Random.value <= lookAtPlayerRatio)
				{
					LookAtPlayer(UnityEngine.Random.Range(Mathf.Min(minLookTime, maxLookTime), Mathf.Max(minLookTime, maxLookTime)));
				}
				else
				{
					LookAroundIdly();
				}
			}
			else
			{
				if (playerEyeCenterXform == null)
				{
					return;
				}
				bool flag = false;
				bool flag2 = false;
				bool flag3 = false;
				Vector3 position = playerEyeCenterXform.position;
				float num = Vector3.Distance(eyeAndHeadAnimator.GetOwnEyeCenter(), position);
				bool flag4 = eyeAndHeadAnimator.IsInView(playerEyeCenterXform.position);
				bool num2 = flag4 && num < noticePlayerDistance;
				bool flag5 = flag4 && num < personalSpaceDistance;
				if (num2)
				{
					if (Time.time - timeOfLastNoticeCheck > 0.1f && state != 0)
					{
						timeOfLastNoticeCheck = Time.time;
						bool num3 = lastDistanceToPlayer > num;
						float t = (noticePlayerDistance - num) / noticePlayerDistance;
						float num4 = Mathf.Lerp(0.1f, 0.5f, t);
						flag2 = num3 && timeOutsideOfAwarenessZone > 1f && UnityEngine.Random.value < num4;
					}
				}
				else
				{
					timeOutsideOfAwarenessZone += Time.deltaTime;
				}
				if (flag5)
				{
					timeInsidePersonalSpace += Time.deltaTime * Mathf.Clamp01((personalSpaceDistance - num) / (0.5f * personalSpaceDistance));
					if (timeInsidePersonalSpace >= 1f)
					{
						flag3 = true;
					}
				}
				else
				{
					timeInsidePersonalSpace = 0f;
				}
				if (flag3 && state != State.LookingAwayFromPlayer)
				{
					LookAwayFromPlayer();
					return;
				}
				if (stareBackFactor > 0f && playerEyeCenterXform != null)
				{
					float stareAngleTargetAtMe = eyeAndHeadAnimator.GetStareAngleTargetAtMe(playerEyeCenterXform);
					bool flag6 = stareAngleTargetAtMe < 15f;
					playerLookingAtMeTime = ((flag4 && flag6) ? Mathf.Min(10f, playerLookingAtMeTime + Mathf.Cos((float)Math.PI / 180f * stareAngleTargetAtMe) * Time.deltaTime) : Mathf.Max(0f, playerLookingAtMeTime - Time.deltaTime));
					if (!eyeAndHeadAnimator.IsLookingAtFace())
					{
						if (stareBackDeadtime > 0f)
						{
							stareBackDeadtime -= Time.deltaTime;
						}
						if (stareBackDeadtime <= 0f && Time.time - timeOfLastLookBackCheck > 0.1f && playerLookingAtMeTime > 4f && eyeAndHeadAnimator.CanChangePointOfAttention() && flag6)
						{
							timeOfLastLookBackCheck = Time.time;
							float num5 = stareBackFactor * 2f * (Mathf.Min(10f, playerLookingAtMeTime) - 4f) / 6f;
							flag = UnityEngine.Random.value < num5;
						}
					}
				}
				if (flag || flag2)
				{
					LookAtPlayer(UnityEngine.Random.Range(Mathf.Min(minLookTime, maxLookTime), Mathf.Max(minLookTime, maxLookTime)));
				}
				lastDistanceToPlayer = num;
			}
		}
	}
	[Serializable]
	public struct SerializableQuaternion
	{
		public float x;

		public float y;

		public float z;

		public float w;

		public SerializableQuaternion(float rX, float rY, float rZ, float rW)
		{
			x = rX;
			y = rY;
			z = rZ;
			w = rW;
		}

		public override string ToString()
		{
			return $"[{x}, {y}, {z}, {w}]";
		}

		public static implicit operator Quaternion(SerializableQuaternion rValue)
		{
			return new Quaternion(rValue.x, rValue.y, rValue.z, rValue.w);
		}

		public static implicit operator SerializableQuaternion(Quaternion rValue)
		{
			return new SerializableQuaternion(rValue.x, rValue.y, rValue.z, rValue.w);
		}
	}
	[Serializable]
	public struct SerializableVector3
	{
		public float x;

		public float y;

		public float z;

		public SerializableVector3(float rX, float rY, float rZ)
		{
			x = rX;
			y = rY;
			z = rZ;
		}

		public override string ToString()
		{
			return $"[{x}, {y}, {z}]";
		}

		public static implicit operator Vector3(SerializableVector3 rValue)
		{
			return new Vector3(rValue.x, rValue.y, rValue.z);
		}

		public static implicit operator SerializableVector3(Vector3 rValue)
		{
			return new SerializableVector3(rValue.x, rValue.y, rValue.z);
		}
	}
	public class Utils
	{
		private static readonly Dictionary<string, GameObject> dummyObjects = new Dictionary<string, GameObject>();

		public static bool CanGetTransformFromPath(Transform startXform, string path)
		{
			if (string.IsNullOrEmpty(path))
			{
				return true;
			}
			if (null != GetTransformFromPath(startXform, path))
			{
				return true;
			}
			UnityEngine.Debug.LogWarning(startXform.name + ": Cannot find path " + path, startXform.gameObject);
			return false;
		}

		public static float EaseSineIn(float t, float b, float c, float d)
		{
			return (0f - c) * Mathf.Cos(t / d * ((float)Math.PI / 2f)) + c + b;
		}

		public static float Fbm(Vector2 coord, int octave)
		{
			float num = 0f;
			float num2 = 1f;
			for (int i = 0; i < octave; i++)
			{
				num += num2 * (Mathf.PerlinNoise(coord.x, coord.y) - 0.5f);
				coord *= 2f;
				num2 *= 0.5f;
			}
			return num;
		}

		public static GameObject FindChildInHierarchy(GameObject go, string name)
		{
			if (go.name == name)
			{
				return go;
			}
			foreach (Transform item in go.transform)
			{
				GameObject gameObject = FindChildInHierarchy(item.gameObject, name);
				if (gameObject != null)
				{
					return gameObject;
				}
			}
			return null;
		}

		public static Transform GetCommonAncestor(Transform xform1, Transform xform2)
		{
			List<Transform> list = new List<Transform> { xform1 };
			while (xform1.parent != null)
			{
				xform1 = xform1.parent;
				list.Add(xform1);
			}
			while (xform2.parent != null && !list.Contains(xform2))
			{
				xform2 = xform2.parent;
			}
			if (!list.Contains(xform2))
			{
				return null;
			}
			return xform2;
		}

		public static string GetPathForTransform(Transform startXform, Transform targetXform)
		{
			List<string> list = new List<string>();
			Transform transform = targetXform;
			while (transform != startXform && transform != null)
			{
				list.Add(transform.name);
				transform = transform.parent;
			}
			list.Reverse();
			return string.Join("/", list.ToArray());
		}

		public static Transform GetTransformFromPath(Transform startXform, string path)
		{
			if (string.IsNullOrEmpty(path))
			{
				return null;
			}
			return startXform.Find(path);
		}

		public static bool IsEqualOrDescendant(Transform ancestor, Transform descendant)
		{
			if (ancestor == descendant)
			{
				return true;
			}
			foreach (Transform item in ancestor.transform)
			{
				if (IsEqualOrDescendant(item, descendant))
				{
					return true;
				}
			}
			return false;
		}

		public static float NormalizedDegAngle(float degrees)
		{
			int num = (int)(degrees / 360f);
			degrees -= (float)(num * 360);
			if (degrees > 180f)
			{
				return degrees - 360f;
			}
			if (degrees < -180f)
			{
				return degrees + 360f;
			}
			return degrees;
		}

		public static void PlaceDummyObject(string name, Vector3 pos, float scale = 0.1f, Quaternion? rotation = null)
		{
			GameObject gameObject;
			if (dummyObjects.ContainsKey(name))
			{
				gameObject = dummyObjects[name];
			}
			else
			{
				gameObject = GameObject.CreatePrimitive(PrimitiveType.Cube);
				gameObject.transform.localScale = scale * Vector3.one;
				gameObject.GetComponent<Renderer>().material = Resources.Load("DummyObjectMaterial") as Material;
				UnityEngine.Object.Destroy(gameObject.GetComponent<Collider>());
				gameObject.name = name;
				dummyObjects[name] = gameObject;
			}
			gameObject.transform.position = pos;
			gameObject.transform.rotation = rotation ?? Quaternion.identity;
		}
	}
}
namespace ProBuilder2.Examples
{
	public class CameraControls : MonoBehaviour
	{
		private const string INPUT_MOUSE_SCROLLWHEEL = "Mouse ScrollWheel";

		private const string INPUT_MOUSE_X = "Mouse X";

		private const string INPUT_MOUSE_Y = "Mouse Y";

		private const float MIN_CAM_DISTANCE = 10f;

		private const float MAX_CAM_DISTANCE = 40f;

		[Range(2f, 15f)]
		public float orbitSpeed = 6f;

		[Range(0.3f, 2f)]
		public float zoomSpeed = 0.8f;

		private float distance;

		public float idleRotation = 1f;

		private Vector2 dir = new Vector2(0.8f, 0.2f);

		private void Start()
		{
			distance = Vector3.Distance(base.transform.position, Vector3.zero);
		}

		private void LateUpdate()
		{
			Vector3 eulerAngles = base.transform.localRotation.eulerAngles;
			eulerAngles.z = 0f;
			if (Input.GetMouseButton(0))
			{
				float axis = Input.GetAxis("Mouse X");
				float num = 0f - Input.GetAxis("Mouse Y");
				eulerAngles.x += num * orbitSpeed;
				eulerAngles.y += axis * orbitSpeed;
				dir.x = axis;
				dir.y = num;
				dir.Normalize();
			}
			else
			{
				eulerAngles.y += Time.deltaTime * idleRotation * dir.x;
				eulerAngles.x += Time.deltaTime * Mathf.PerlinNoise(Time.time, 0f) * idleRotation * dir.y;
			}
			base.transform.localRotation = Quaternion.Euler(eulerAngles);
			base.transform.position = base.transform.localRotation * (Vector3.forward * (0f - distance));
			if (Input.GetAxis("Mouse ScrollWheel") != 0f)
			{
				float axis2 = Input.GetAxis("Mouse ScrollWheel");
				distance -= axis2 * (distance / 40f) * (zoomSpeed * 1000f) * Time.deltaTime;
				distance = Mathf.Clamp(distance, 10f, 40f);
				base.transform.position = base.transform.localRotation * (Vector3.forward * (0f - distance));
			}
		}
	}
}
namespace MirzaBeig.Shaders.ImageEffects
{
	[Serializable]
	[ExecuteInEditMode]
	public class Sharpen : IEBase
	{
		[Range(-2f, 2f)]
		public float strength = 0.5f;

		[Range(0f, 8f)]
		public float edgeMult = 0.2f;

		private void Awake()
		{
			base.shader = Shader.Find("Hidden/Mirza Beig/Image Effects/Sharpen");
		}

		private void Start()
		{
		}

		private void Update()
		{
		}

		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			base.material.SetFloat("_strength", strength);
			base.material.SetFloat("_edgeMult", edgeMult);
			blit(source, destination);
		}
	}
	[Serializable]
	[ExecuteInEditMode]
	public class IEBase : MonoBehaviour
	{
		private Material _material;

		private Camera _camera;

		protected Material material
		{
			get
			{
				if (!_material)
				{
					_material = new Material(shader);
					_material.hideFlags = HideFlags.HideAndDontSave;
				}
				return _material;
			}
		}

		protected Shader shader { get; set; }

		protected Camera camera
		{
			get
			{
				if (!_camera)
				{
					_camera = GetComponent<Camera>();
				}
				return _camera;
			}
		}

		private void Awake()
		{
		}

		private void Start()
		{
		}

		private void Update()
		{
		}

		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
		}

		protected void blit(RenderTexture source, RenderTexture destination)
		{
			Graphics.Blit(source, destination, material);
		}

		private void OnDisable()
		{
			if ((bool)_material)
			{
				UnityEngine.Object.DestroyImmediate(_material);
			}
		}
	}
}
namespace MirzaBeig.Scripting.Effects
{
	public class AttractionParticleAffector : ParticleAffector
	{
		[Header("Affector Controls")]
		public float arrivalRadius = 1f;

		public float arrivedRadius = 0.5f;

		private float arrivalRadiusSqr;

		private float arrivedRadiusSqr;

		protected override void Awake()
		{
			base.Awake();
		}

		protected override void Start()
		{
			base.Start();
		}

		protected override void Update()
		{
			base.Update();
		}

		protected override void LateUpdate()
		{
			float x = base.transform.lossyScale.x;
			arrivalRadiusSqr = arrivalRadius * arrivalRadius * x;
			arrivedRadiusSqr = arrivedRadius * arrivedRadius * x;
			base.LateUpdate();
		}

		protected override Vector3 GetForce()
		{
			if (parameters.distanceToAffectorCenterSqr < arrivedRadiusSqr)
			{
				Vector3 result = default(Vector3);
				result.x = 0f;
				result.y = 0f;
				result.z = 0f;
				return result;
			}
			if (parameters.distanceToAffectorCenterSqr < arrivalRadiusSqr)
			{
				float num = 1f - parameters.distanceToAffectorCenterSqr / arrivalRadiusSqr;
				return Vector3.Normalize(parameters.scaledDirectionToAffectorCenter) * num;
			}
			return Vector3.Normalize(parameters.scaledDirectionToAffectorCenter);
		}

		protected override void OnDrawGizmosSelected()
		{
			if (base.enabled)
			{
				base.OnDrawGizmosSelected();
				float x = base.transform.lossyScale.x;
				float num = arrivalRadius * x;
				float num2 = arrivedRadius * x;
				Vector3 center = base.transform.position + offset;
				Gizmos.color = Color.yellow;
				Gizmos.DrawWireSphere(center, num);
				Gizmos.color = Color.red;
				Gizmos.DrawWireSphere(center, num2);
			}
		}
	}
	[Serializable]
	public class ParticleAffectorMT : MonoBehaviour
	{
		public float force = 1f;

		public float speed = 1f;

		private ParticleSystem particleSystem;

		private ParticleSystem.Particle[] particles;

		private float randomX;

		private float randomY;

		private float randomZ;

		private float offsetX;

		private float offsetY;

		private float offsetZ;

		private float deltaTime;

		private Thread t;

		private readonly object locker = new object();

		private bool processing;

		private bool isDoneAssigning;

		private void Awake()
		{
		}

		private void Start()
		{
			particleSystem = GetComponent<ParticleSystem>();
			randomX = UnityEngine.Random.Range(-32f, 32f);
			randomY = UnityEngine.Random.Range(-32f, 32f);
			randomZ = UnityEngine.Random.Range(-32f, 32f);
			t = new Thread(process);
			t.Start();
			isDoneAssigning = true;
		}

		private void LateUpdate()
		{
			lock (locker)
			{
				if (!processing && isDoneAssigning)
				{
					particles = new ParticleSystem.Particle[particleSystem.particleCount];
					particleSystem.GetParticles(particles);
					float time = Time.time;
					deltaTime = Time.deltaTime;
					offsetX = time * speed * randomX;
					offsetY = time * speed * randomY;
					offsetZ = time * speed * randomZ;
					processing = true;
					isDoneAssigning = false;
				}
			}
			if (t.ThreadState == System.Threading.ThreadState.Stopped)
			{
				t = new Thread(process);
				t.Start();
			}
			lock (locker)
			{
				if (!processing && !isDoneAssigning)
				{
					particleSystem.SetParticles(particles, particles.Length);
					isDoneAssigning = true;
				}
			}
		}

		private void process()
		{
			lock (locker)
			{
				if (processing)
				{
					for (int i = 0; i < particles.Length; i++)
					{
						ParticleSystem.Particle particle = particles[i];
						Vector3 position = particle.position;
						Vector3 vector = new Vector3(Noise.perlin(offsetX + position.x, offsetX + position.y, offsetX + position.z), Noise.perlin(offsetY + position.x, offsetY + position.y, offsetY + position.z), Noise.perlin(offsetZ + position.x, offsetZ + position.y, offsetZ + position.z)) * force;
						vector *= deltaTime;
						particle.velocity += vector;
						particles[i] = particle;
					}
					processing = false;
				}
			}
		}

		private void OnDisable()
		{
		}

		private void OnApplicationQuit()
		{
		}
	}
	[Serializable]
	public class TurbulenceParticleAffectorMT : MonoBehaviour
	{
		public float force = 1f;

		public float speed = 1f;

		private ParticleSystem particleSystem;

		private ParticleSystem.Particle[] particles;

		private float randomX;

		private float randomY;

		private float randomZ;

		private float offsetX;

		private float offsetY;

		private float offsetZ;

		private float deltaTime;

		private Thread t;

		private readonly object locker = new object();

		private bool processing;

		private bool isDoneAssigning;

		private void Awake()
		{
		}

		private void Start()
		{
			particleSystem = GetComponent<ParticleSystem>();
			randomX = UnityEngine.Random.Range(-32f, 32f);
			randomY = UnityEngine.Random.Range(-32f, 32f);
			randomZ = UnityEngine.Random.Range(-32f, 32f);
			t = new Thread(process);
			t.Start();
			isDoneAssigning = true;
		}

		private void LateUpdate()
		{
			lock (locker)
			{
				if (!processing && isDoneAssigning)
				{
					particles = new ParticleSystem.Particle[particleSystem.particleCount];
					particleSystem.GetParticles(particles);
					float time = Time.time;
					deltaTime = Time.deltaTime;
					offsetX = time * speed * randomX;
					offsetY = time * speed * randomY;
					offsetZ = time * speed * randomZ;
					processing = true;
					isDoneAssigning = false;
				}
			}
			if (t.ThreadState == System.Threading.ThreadState.Stopped)
			{
				t = new Thread(process);
				t.Start();
			}
			lock (locker)
			{
				if (!processing && !isDoneAssigning)
				{
					particleSystem.SetParticles(particles, particles.Length);
					isDoneAssigning = true;
				}
			}
		}

		private void process()
		{
			lock (locker)
			{
				if (processing)
				{
					for (int i = 0; i < particles.Length; i++)
					{
						ParticleSystem.Particle particle = particles[i];
						Vector3 position = particle.position;
						Vector3 vector = new Vector3(Noise.perlin(offsetX + position.x, offsetX + position.y, offsetX + position.z), Noise.perlin(offsetY + position.x, offsetY + position.y, offsetY + position.z), Noise.perlin(offsetZ + position.x, offsetZ + position.y, offsetZ + position.z)) * force;
						vector *= deltaTime;
						particle.velocity += vector;
						particles[i] = particle;
					}
					processing = false;
				}
			}
		}

		private void OnDisable()
		{
		}

		private void OnApplicationQuit()
		{
		}
	}
	[Serializable]
	public static class Noise
	{
		private static float F3 = 1f / 3f;

		private static float G3 = 1f / 6f;

		private static byte[] perm = new byte[512]
		{
			151, 160, 137, 91, 90, 15, 131, 13, 201, 95,
			96, 53, 194, 233, 7, 225, 140, 36, 103, 30,
			69, 142, 8, 99, 37, 240, 21, 10, 23, 190,
			6, 148, 247, 120, 234, 75, 0, 26, 197, 62,
			94, 252, 219, 203, 117, 35, 11, 32, 57, 177,
			33, 88, 237, 149, 56, 87, 174, 20, 125, 136,
			171, 168, 68, 175, 74, 165, 71, 134, 139, 48,
			27, 166, 77, 146, 158, 231, 83, 111, 229, 122,
			60, 211, 133, 230, 220, 105, 92, 41, 55, 46,
			245, 40, 244, 102, 143, 54, 65, 25, 63, 161,
			1, 216, 80, 73, 209, 76, 132, 187, 208, 89,
			18, 169, 200, 196, 135, 130, 116, 188, 159, 86,
			164, 100, 109, 198, 173, 186, 3, 64, 52, 217,
			226, 250, 124, 123, 5, 202, 38, 147, 118, 126,
			255, 82, 85, 212, 207, 206, 59, 227, 47, 16,
			58, 17, 182, 189, 28, 42, 223, 183, 170, 213,
			119, 248, 152, 2, 44, 154, 163, 70, 221, 153,
			101, 155, 167, 43, 172, 9, 129, 22, 39, 253,
			19, 98, 108, 110, 79, 113, 224, 232, 178, 185,
			112, 104, 218, 246, 97, 228, 251, 34, 242, 193,
			238, 210, 144, 12, 191, 179, 162, 241, 81, 51,
			145, 235, 249, 14, 239, 107, 49, 192, 214, 31,
			181, 199, 106, 157, 184, 84, 204, 176, 115, 121,
			50, 45, 127, 4, 150, 254, 138, 236, 205, 93,
			222, 114, 67, 29, 24, 72, 243, 141, 128, 195,
			78, 66, 215, 61, 156, 180, 151, 160, 137, 91,
			90, 15, 131, 13, 201, 95, 96, 53, 194, 233,
			7, 225, 140, 36, 103, 30, 69, 142, 8, 99,
			37, 240, 21, 10, 23, 190, 6, 148, 247, 120,
			234, 75, 0, 26, 197, 62, 94, 252, 219, 203,
			117, 35, 11, 32, 57, 177, 33, 88, 237, 149,
			56, 87, 174, 20, 125, 136, 171, 168, 68, 175,
			74, 165, 71, 134, 139, 48, 27, 166, 77, 146,
			158, 231, 83, 111, 229, 122, 60, 211, 133, 230,
			220, 105, 92, 41, 55, 46, 245, 40, 244, 102,
			143, 54, 65, 25, 63, 161, 1, 216, 80, 73,
			209, 76, 132, 187, 208, 89, 18, 169, 200, 196,
			135, 130, 116, 188, 159, 86, 164, 100, 109, 198,
			173, 186, 3, 64, 52, 217, 226, 250, 124, 123,
			5, 202, 38, 147, 118, 126, 255, 82, 85, 212,
			207, 206, 59, 227, 47, 16, 58, 17, 182, 189,
			28, 42, 223, 183, 170, 213, 119, 248, 152, 2,
			44, 154, 163, 70, 221, 153, 101, 155, 167, 43,
			172, 9, 129, 22, 39, 253, 19, 98, 108, 110,
			79, 113, 224, 232, 178, 185, 112, 104, 218, 246,
			97, 228, 251, 34, 242, 193, 238, 210, 144, 12,
			191, 179, 162, 241, 81, 51, 145, 235, 249, 14,
			239, 107, 49, 192, 214, 31, 181, 199, 106, 157,
			184, 84, 204, 176, 115, 121, 50, 45, 127, 4,
			150, 254, 138, 236, 205, 93, 222, 114, 67, 29,
			24, 72, 243, 141, 128, 195, 78, 66, 215, 61,
			156, 180
		};

		private static float smooth(float t)
		{
			return t * t * (3f - 2f * t);
		}

		private static float fade(float t)
		{
			return t * t * t * (t * (t * 6f - 15f) + 10f);
		}

		private static int floor(float x)
		{
			if (!(x > 0f))
			{
				return (int)x - 1;
			}
			return (int)x;
		}

		private static float lerp(float from, float to, float t)
		{
			return from + t * (to - from);
		}

		private static float grad(int hash, float x, float y, float z)
		{
			return (hash & 0xF) switch
			{
				0 => x + y, 
				1 => 0f - x + y, 
				2 => x - y, 
				3 => 0f - x - y, 
				4 => x + x, 
				5 => 0f - x + x, 
				6 => x - x, 
				7 => 0f - x - x, 
				8 => y + x, 
				9 => 0f - y + x, 
				10 => y - x, 
				11 => 0f - y - x, 
				12 => y + z, 
				13 => 0f - y + x, 
				14 => y - x, 
				15 => 0f - y - z, 
				_ => 0f, 
			};
		}

		public static float perlin(float x, float y, float z)
		{
			int num = ((x > 0f) ? ((int)x) : ((int)x - 1));
			int num2 = ((y > 0f) ? ((int)y) : ((int)y - 1));
			int num3 = ((z > 0f) ? ((int)z) : ((int)z - 1));
			float num4 = x - (float)num;
			float num5 = y - (float)num2;
			float num6 = z - (float)num3;
			float num7 = num4 - 1f;
			float num8 = num5 - 1f;
			float num9 = num6 - 1f;
			int num10 = (num + 1) & 0xFF;
			int num11 = (num2 + 1) & 0xFF;
			int num12 = (num3 + 1) & 0xFF;
			num &= 0xFF;
			num2 &= 0xFF;
			num3 &= 0xFF;
			float num13 = num6 * num6 * num6 * (num6 * (num6 * 6f - 15f) + 10f);
			float num14 = num5 * num5 * num5 * (num5 * (num5 * 6f - 15f) + 10f);
			float num15 = num4 * num4 * num4 * (num4 * (num4 * 6f - 15f) + 10f);
			float num16 = (perm[num + perm[num2 + perm[num3]]] & 0xF) switch
			{
				0 => num4 + num5, 
				1 => 0f - num4 + num5, 
				2 => num4 - num5, 
				3 => 0f - num4 - num5, 
				4 => num4 + num4, 
				5 => 0f - num4 + num4, 
				6 => num4 - num4, 
				7 => 0f - num4 - num4, 
				8 => num5 + num4, 
				9 => 0f - num5 + num4, 
				10 => num5 - num4, 
				11 => 0f - num5 - num4, 
				12 => num5 + num6, 
				13 => 0f - num5 + num4, 
				14 => num5 - num4, 
				15 => 0f - num5 - num6, 
				_ => 0f, 
			};
			float num17 = num16 + num13 * ((perm[num + perm[num2 + perm[num12]]] & 0xF) switch
			{
				0 => num4 + num5, 
				1 => 0f - num4 + num5, 
				2 => num4 - num5, 
				3 => 0f - num4 - num5, 
				4 => num4 + num4, 
				5 => 0f - num4 + num4, 
				6 => num4 - num4, 
				7 => 0f - num4 - num4, 
				8 => num5 + num4, 
				9 => 0f - num5 + num4, 
				10 => num5 - num4, 
				11 => 0f - num5 - num4, 
				12 => num5 + num9, 
				13 => 0f - num5 + num4, 
				14 => num5 - num4, 
				15 => 0f - num5 - num9, 
				_ => 0f, 
			} - num16);
			num16 = (perm[num + perm[num11 + perm[num3]]] & 0xF) switch
			{
				0 => num4 + num8, 
				1 => 0f - num4 + num8, 
				2 => num4 - num8, 
				3 => 0f - num4 - num8, 
				4 => num4 + num4, 
				5 => 0f - num4 + num4, 
				6 => num4 - num4, 
				7 => 0f - num4 - num4, 
				8 => num8 + num4, 
				9 => 0f - num8 + num4, 
				10 => num8 - num4, 
				11 => 0f - num8 - num4, 
				12 => num8 + num6, 
				13 => 0f - num8 + num4, 
				14 => num8 - num4, 
				15 => 0f - num8 - num6, 
				_ => 0f, 
			};
			float num18 = num16 + num13 * ((perm[num + perm[num11 + perm[num12]]] & 0xF) switch
			{
				0 => num4 + num8, 
				1 => 0f - num4 + num8, 
				2 => num4 - num8, 
				3 => 0f - num4 - num8, 
				4 => num4 + num4, 
				5 => 0f - num4 + num4, 
				6 => num4 - num4, 
				7 => 0f - num4 - num4, 
				8 => num8 + num4, 
				9 => 0f - num8 + num4, 
				10 => num8 - num4, 
				11 => 0f - num8 - num4, 
				12 => num8 + num9, 
				13 => 0f - num8 + num4, 
				14 => num8 - num4, 
				15 => 0f - num8 - num9, 
				_ => 0f, 
			} - num16);
			float num19 = num17 + num14 * (num18 - num17);
			num16 = (perm[num10 + perm[num2 + perm[num3]]] & 0xF) switch
			{
				0 => num7 + num5, 
				1 => 0f - num7 + num5, 
				2 => num7 - num5, 
				3 => 0f - num7 - num5, 
				4 => num7 + num7, 
				5 => 0f - num7 + num7, 
				6 => num7 - num7, 
				7 => 0f - num7 - num7, 
				8 => num5 + num7, 
				9 => 0f - num5 + num7, 
				10 => num5 - num7, 
				11 => 0f - num5 - num7, 
				12 => num5 + num6, 
				13 => 0f - num5 + num7, 
				14 => num5 - num7, 
				15 => 0f - num5 - num6, 
				_ => 0f, 
			};
			num17 = num16 + num13 * ((perm[num10 + perm[num2 + perm[num12]]] & 0xF) switch
			{
				0 => num7 + num5, 
				1 => 0f - num7 + num5, 
				2 => num7 - num5, 
				3 => 0f - num7 - num5, 
				4 => num7 + num7, 
				5 => 0f - num7 + num7, 
				6 => num7 - num7, 
				7 => 0f - num7 - num7, 
				8 => num5 + num7, 
				9 => 0f - num5 + num7, 
				10 => num5 - num7, 
				11 => 0f - num5 - num7, 
				12 => num5 + num9, 
				13 => 0f - num5 + num7, 
				14 => num5 - num7, 
				15 => 0f - num5 - num9, 
				_ => 0f, 
			} - num16);
			num16 = (perm[num10 + perm[num11 + perm[num3]]] & 0xF) switch
			{
				0 => num7 + num8, 
				1 => 0f - num7 + num8, 
				2 => num7 - num8, 
				3 => 0f - num7 - num8, 
				4 => num7 + num7, 
				5 => 0f - num7 + num7, 
				6 => num7 - num7, 
				7 => 0f - num7 - num7, 
				8 => num8 + num7, 
				9 => 0f - num8 + num7, 
				10 => num8 - num7, 
				11 => 0f - num8 - num7, 
				12 => num8 + num6, 
				13 => 0f - num8 + num7, 
				14 => num8 - num7, 
				15 => 0f - num8 - num6, 
				_ => 0f, 
			};
			num18 = num16 + num13 * ((perm[num10 + perm[num11 + perm[num12]]] & 0xF) switch
			{
				0 => num7 + num8, 
				1 => 0f - num7 + num8, 
				2 => num7 - num8, 
				3 => 0f - num7 - num8, 
				4 => num7 + num7, 
				5 => 0f - num7 + num7, 
				6 => num7 - num7, 
				7 => 0f - num7 - num7, 
				8 => num8 + num7, 
				9 => 0f - num8 + num7, 
				10 => num8 - num7, 
				11 => 0f - num8 - num7, 
				12 => num8 + num9, 
				13 => 0f - num8 + num7, 
				14 => num8 - num7, 
				15 => 0f - num8 - num9, 
				_ => 0f, 
			} - num16);
			float num20 = num17 + num14 * (num18 - num17);
			return 0.936f * (num19 + num15 * (num20 - num19));
		}

		public static float simplex(float x, float y, float z)
		{
			float num = (x + y + z) * F3;
			float num2 = x + num;
			float num3 = y + num;
			float num4 = z + num;
			int num5 = ((num2 > 0f) ? ((int)num2) : ((int)num2 - 1));
			int num6 = ((num3 > 0f) ? ((int)num3) : ((int)num3 - 1));
			int num7 = ((num4 > 0f) ? ((int)num4) : ((int)num4 - 1));
			float num8 = (float)(num5 + num6 + num7) * G3;
			float num9 = (float)num5 - num8;
			float num10 = (float)num6 - num8;
			float num11 = (float)num7 - num8;
			float num12 = x - num9;
			float num13 = y - num10;
			float num14 = z - num11;
			int num15;
			int num16;
			int num17;
			int num18;
			int num19;
			int num20;
			if (num12 >= num13)
			{
				if (num13 >= num14)
				{
					num15 = 1;
					num16 = 0;
					num17 = 0;
					num18 = 1;
					num19 = 1;
					num20 = 0;
				}
				else if (num12 >= num14)
				{
					num15 = 1;
					num16 = 0;
					num17 = 0;
					num18 = 1;
					num19 = 0;
					num20 = 1;
				}
				else
				{
					num15 = 0;
					num16 = 0;
					num17 = 1;
					num18 = 1;
					num19 = 0;
					num20 = 1;
				}
			}
			else if (num13 < num14)
			{
				num15 = 0;
				num16 = 0;
				num17 = 1;
				num18 = 0;
				num19 = 1;
				num20 = 1;
			}
			else if (num12 < num14)
			{
				num15 = 0;
				num16 = 1;
				num17 = 0;
				num18 = 0;
				num19 = 1;
				num20 = 1;
			}
			else
			{
				num15 = 0;
				num16 = 1;
				num17 = 0;
				num18 = 1;
				num19 = 1;
				num20 = 0;
			}
			float num21 = num12 - (float)num15 + G3;
			float num22 = num13 - (float)num16 + G3;
			float num23 = num14 - (float)num17 + G3;
			float num24 = num12 - (float)num18 + 2f * G3;
			float num25 = num13 - (float)num19 + 2f * G3;
			float num26 = num14 - (float)num20 + 2f * G3;
			float num27 = num12 - 1f + 3f * G3;
			float num28 = num13 - 1f + 3f * G3;
			float num29 = num14 - 1f + 3f * G3;
			int num30 = num5 & 0xFF;
			int num31 = num6 & 0xFF;
			int num32 = num7 & 0xFF;
			float num33 = 0.6f - num12 * num12 - num13 * num13 - num14 * num14;
			float num34;
			if (num33 < 0f)
			{
				num34 = 0f;
			}
			else
			{
				num33 *= num33;
				num34 = num33 * num33 * (perm[num30 + perm[num31 + perm[num32]]] & 0xF) switch
				{
					0 => num12 + num13, 
					1 => 0f - num12 + num13, 
					2 => num12 - num13, 
					3 => 0f - num12 - num13, 
					4 => num12 + num12, 
					5 => 0f - num12 + num12, 
					6 => num12 - num12, 
					7 => 0f - num12 - num12, 
					8 => num13 + num12, 
					9 => 0f - num13 + num12, 
					10 => num13 - num12, 
					11 => 0f - num13 - num12, 
					12 => num13 + num14, 
					13 => 0f - num13 + num12, 
					14 => num13 - num12, 
					15 => 0f - num13 - num14, 
					_ => 0f, 
				};
			}
			float num35 = 0.6f - num21 * num21 - num22 * num22 - num23 * num23;
			float num36;
			if (num35 < 0f)
			{
				num36 = 0f;
			}
			else
			{
				num35 *= num35;
				num36 = num35 * num35 * (perm[num30 + num15 + perm[num31 + num16 + perm[num32 + num17]]] & 0xF) switch
				{
					0 => num21 + num22, 
					1 => 0f - num21 + num22, 
					2 => num21 - num22, 
					3 => 0f - num21 - num22, 
					4 => num21 + num21, 
					5 => 0f - num21 + num21, 
					6 => num21 - num21, 
					7 => 0f - num21 - num21, 
					8 => num22 + num21, 
					9 => 0f - num22 + num21, 
					10 => num22 - num21, 
					11 => 0f - num22 - num21, 
					12 => num22 + num23, 
					13 => 0f - num22 + num21, 
					14 => num22 - num21, 
					15 => 0f - num22 - num23, 
					_ => 0f, 
				};
			}
			float num37 = 0.6f - num24 * num24 - num25 * num25 - num26 * num26;
			float num38;
			if (num37 < 0f)
			{
				num38 = 0f;
			}
			else
			{
				num37 *= num37;
				num38 = num37 * num37 * (perm[num30 + num18 + perm[num31 + num19 + perm[num32 + num20]]] & 0xF) switch
				{
					0 => num24 + num25, 
					1 => 0f - num24 + num25, 
					2 => num24 - num25, 
					3 => 0f - num24 - num25, 
					4 => num24 + num24, 
					5 => 0f - num24 + num24, 
					6 => num24 - num24, 
					7 => 0f - num24 - num24, 
					8 => num25 + num24, 
					9 => 0f - num25 + num24, 
					10 => num25 - num24, 
					11 => 0f - num25 - num24, 
					12 => num25 + num26, 
					13 => 0f - num25 + num24, 
					14 => num25 - num24, 
					15 => 0f - num25 - num26, 
					_ => 0f, 
				};
			}
			float num39 = 0.6f - num27 * num27 - num28 * num28 - num29 * num29;
			float num40;
			if (num39 < 0f)
			{
				num40 = 0f;
			}
			else
			{
				num39 *= num39;
				num40 = num39 * num39 * (perm[num30 + 1 + perm[num31 + 1 + perm[num32 + 1]]] & 0xF) switch
				{
					0 => num27 + num28, 
					1 => 0f - num27 + num28, 
					2 => num27 - num28, 
					3 => 0f - num27 - num28, 
					4 => num27 + num27, 
					5 => 0f - num27 + num27, 
					6 => num27 - num27, 
					7 => 0f - num27 - num27, 
					8 => num28 + num27, 
					9 => 0f - num28 + num27, 
					10 => num28 - num27, 
					11 => 0f - num28 - num27, 
					12 => num28 + num29, 
					13 => 0f - num28 + num27, 
					14 => num28 - num27, 
					15 => 0f - num28 - num29, 
					_ => 0f, 
				};
			}
			return 32f * (num34 + num36 + num38 + num40);
		}

		public static float octavePerlin(float x, float y, float z, float frequency, int octaves, float lacunarity, float persistence)
		{
			if (octaves < 2)
			{
				return perlin(x * frequency, y * frequency, z * frequency);
			}
			float num = 0f;
			float num2 = 1f;
			float num3 = 0f;
			for (int i = 0; i < octaves; i++)
			{
				num += perlin(x * frequency, y * frequency, z * frequency) * num2;
				num3 += num2;
				frequency *= lacunarity;
				num2 *= persistence;
			}
			return num / num3;
		}

		public static float octaveSimplex(float x, float y, float z, float frequency, int octaves, float lacunarity, float persistence)
		{
			if (octaves < 2)
			{
				return simplex(x * frequency, y * frequency, z * frequency);
			}
			float num = 0f;
			float num2 = 1f;
			float num3 = 0f;
			for (int i = 0; i < octaves; i++)
			{
				num += simplex(x * frequency, y * frequency, z * frequency) * num2;
				num3 += num2;
				frequency *= lacunarity;
				num2 *= persistence;
			}
			return num / num3;
		}

		public static float perlinUnoptimized(float x, float y, float z)
		{
			int num = floor(x);
			int num2 = floor(y);
			int num3 = floor(z);
			float num4 = x - (float)num;
			float num5 = y - (float)num2;
			float num6 = z - (float)num3;
			float x2 = num4 - 1f;
			float y2 = num5 - 1f;
			float z2 = num6 - 1f;
			int num7 = (num + 1) & 0xFF;
			int num8 = (num2 + 1) & 0xFF;
			int num9 = (num3 + 1) & 0xFF;
			num &= 0xFF;
			num2 &= 0xFF;
			num3 &= 0xFF;
			float t = fade(num6);
			float t2 = fade(num5);
			float t3 = fade(num4);
			float from = grad(perm[num + perm[num2 + perm[num3]]], num4, num5, num6);
			float to = grad(perm[num + perm[num2 + perm[num9]]], num4, num5, z2);
			float from2 = lerp(from, to, t);
			float from3 = grad(perm[num + perm[num8 + perm[num3]]], num4, y2, num6);
			to = grad(perm[num + perm[num8 + perm[num9]]], num4, y2, z2);
			float to2 = lerp(from3, to, t);
			float from4 = lerp(from2, to2, t2);
			float from5 = grad(perm[num7 + perm[num2 + perm[num3]]], x2, num5, num6);
			to = grad(perm[num7 + perm[num2 + perm[num9]]], x2, num5, z2);
			float from6 = lerp(from5, to, t);
			float from7 = grad(perm[num7 + perm[num8 + perm[num3]]], x2, y2, num6);
			to = grad(perm[num7 + perm[num8 + perm[num9]]], x2, y2, z2);
			to2 = lerp(from7, to, t);
			float to3 = lerp(from6, to2, t2);
			return 0.936f * lerp(from4, to3, t3);
		}

		public static float simplexUnoptimized(float x, float y, float z)
		{
			float num = (x + y + z) * F3;
			float x2 = x + num;
			float x3 = y + num;
			float x4 = z + num;
			int num2 = floor(x2);
			int num3 = floor(x3);
			int num4 = floor(x4);
			float num5 = (float)(num2 + num3 + num4) * G3;
			float num6 = (float)num2 - num5;
			float num7 = (float)num3 - num5;
			float num8 = (float)num4 - num5;
			float num9 = x - num6;
			float num10 = y - num7;
			float num11 = z - num8;
			int num12;
			int num13;
			int num14;
			int num15;
			int num16;
			int num17;
			if (num9 >= num10)
			{
				if (num10 >= num11)
				{
					num12 = 1;
					num13 = 0;
					num14 = 0;
					num15 = 1;
					num16 = 1;
					num17 = 0;
				}
				else if (num9 >= num11)
				{
					num12 = 1;
					num13 = 0;
					num14 = 0;
					num15 = 1;
					num16 = 0;
					num17 = 1;
				}
				else
				{
					num12 = 0;
					num13 = 0;
					num14 = 1;
					num15 = 1;
					num16 = 0;
					num17 = 1;
				}
			}
			else if (num10 < num11)
			{
				num12 = 0;
				num13 = 0;
				num14 = 1;
				num15 = 0;
				num16 = 1;
				num17 = 1;
			}
			else if (num9 < num11)
			{
				num12 = 0;
				num13 = 1;
				num14 = 0;
				num15 = 0;
				num16 = 1;
				num17 = 1;
			}
			else
			{
				num12 = 0;
				num13 = 1;
				num14 = 0;
				num15 = 1;
				num16 = 1;
				num17 = 0;
			}
			float num18 = num9 - (float)num12 + G3;
			float num19 = num10 - (float)num13 + G3;
			float num20 = num11 - (float)num14 + G3;
			float num21 = num9 - (float)num15 + 2f * G3;
			float num22 = num10 - (float)num16 + 2f * G3;
			float num23 = num11 - (float)num17 + 2f * G3;
			float num24 = num9 - 1f + 3f * G3;
			float num25 = num10 - 1f + 3f * G3;
			float num26 = num11 - 1f + 3f * G3;
			int num27 = num2 & 0xFF;
			int num28 = num3 & 0xFF;
			int num29 = num4 & 0xFF;
			float num30 = 0.6f - num9 * num9 - num10 * num10 - num11 * num11;
			float num31;
			if (num30 < 0f)
			{
				num31 = 0f;
			}
			else
			{
				num30 *= num30;
				num31 = num30 * num30 * grad(perm[num27 + perm[num28 + perm[num29]]], num9, num10, num11);
			}
			float num32 = 0.6f - num18 * num18 - num19 * num19 - num20 * num20;
			float num33;
			if (num32 < 0f)
			{
				num33 = 0f;
			}
			else
			{
				num32 *= num32;
				num33 = num32 * num32 * grad(perm[num27 + num12 + perm[num28 + num13 + perm[num29 + num14]]], num18, num19, num20);
			}
			float num34 = 0.6f - num21 * num21 - num22 * num22 - num23 * num23;
			float num35;
			if (num34 < 0f)
			{
				num35 = 0f;
			}
			else
			{
				num34 *= num34;
				num35 = num34 * num34 * grad(perm[num27 + num15 + perm[num28 + num16 + perm[num29 + num17]]], num21, num22, num23);
			}
			float num36 = 0.6f - num24 * num24 - num25 * num25 - num26 * num26;
			float num37;
			if (num36 < 0f)
			{
				num37 = 0f;
			}
			else
			{
				num36 *= num36;
				num37 = num36 * num36 * grad(perm[num27 + 1 + perm[num28 + 1 + perm[num29 + 1]]], num24, num25, num26);
			}
			return 32f * (num31 + num33 + num35 + num37);
		}
	}
	public abstract class ParticleAffector : MonoBehaviour
	{
		protected struct GetForceParameters
		{
			public float distanceToAffectorCenterSqr;

			public Vector3 scaledDirectionToAffectorCenter;

			public Vector3 particlePosition;
		}

		[Header("Common Controls")]
		public float radius = float.PositiveInfinity;

		public float force = 5f;

		public Vector3 offset = Vector3.zero;

		private float _radius;

		private float radiusSqr;

		private float forceDeltaTime;

		private Vector3 transformPosition;

		private float[] particleSystemExternalForcesMultipliers;

		public AnimationCurve scaleForceByDistance = new AnimationCurve(new Keyframe(0f, 1f), new Keyframe(1f, 1f));

		private ParticleSystem particleSystem;

		public List<ParticleSystem> _particleSystems;

		private int particleSystemsCount;

		private List<ParticleSystem> particleSystems = new List<ParticleSystem>();

		private ParticleSystem.Particle[][] particleSystemParticles;

		private ParticleSystem.MainModule[] particleSystemMainModules;

		private Renderer[] particleSystemRenderers;

		protected ParticleSystem currentParticleSystem;

		protected GetForceParameters parameters;

		public bool alwaysUpdate;

		public float scaledRadius => radius * base.transform.lossyScale.x;

		protected virtual void Awake()
		{
		}

		protected virtual void Start()
		{
			particleSystem = GetComponent<ParticleSystem>();
		}

		protected virtual void PerParticleSystemSetup()
		{
		}

		protected virtual Vector3 GetForce()
		{
			return Vector3.zero;
		}

		protected virtual void Update()
		{
		}

		public void AddParticleSystem(ParticleSystem particleSystem)
		{
			_particleSystems.Add(particleSystem);
		}

		public void RemoveParticleSystem(ParticleSystem particleSystem)
		{
			_particleSystems.Remove(particleSystem);
		}

		protected virtual void LateUpdate()
		{
			_radius = scaledRadius;
			radiusSqr = _radius * _radius;
			forceDeltaTime = force * Time.deltaTime;
			transformPosition = base.transform.position + offset;
			if (_particleSystems.Count != 0)
			{
				if (particleSystems.Count != _particleSystems.Count)
				{
					particleSystems.Clear();
					particleSystems.AddRange(_particleSystems);
				}
				else
				{
					for (int i = 0; i < _particleSystems.Count; i++)
					{
						particleSystems[i] = _particleSystems[i];
					}
				}
			}
			else if ((bool)particleSystem)
			{
				if (particleSystems.Count == 1)
				{
					particleSystems[0] = particleSystem;
				}
				else
				{
					particleSystems.Clear();
					particleSystems.Add(particleSystem);
				}
			}
			else
			{
				particleSystems.Clear();
				particleSystems.AddRange(UnityEngine.Object.FindObjectsOfType<ParticleSystem>());
			}
			parameters = default(GetForceParameters);
			particleSystemsCount = particleSystems.Count;
			if (particleSystemParticles == null || particleSystemParticles.Length < particleSystemsCount)
			{
				particleSystemParticles = new ParticleSystem.Particle[particleSystemsCount][];
				particleSystemMainModules = new ParticleSystem.MainModule[particleSystemsCount];
				particleSystemRenderers = new Renderer[particleSystemsCount];
				particleSystemExternalForcesMultipliers = new float[particleSystemsCount];
				for (int j = 0; j < particleSystemsCount; j++)
				{
					particleSystemMainModules[j] = particleSystems[j].main;
					particleSystemRenderers[j] = particleSystems[j].GetComponent<Renderer>();
					particleSystemExternalForcesMultipliers[j] = particleSystems[j].externalForces.multiplier;
				}
			}
			for (int k = 0; k < particleSystemsCount; k++)
			{
				if (!particleSystemRenderers[k].isVisible && !alwaysUpdate)
				{
					continue;
				}
				int maxParticles = particleSystemMainModules[k].maxParticles;
				if (particleSystemParticles[k] == null || particleSystemParticles[k].Length < maxParticles)
				{
					particleSystemParticles[k] = new ParticleSystem.Particle[maxParticles];
				}
				currentParticleSystem = particleSystems[k];
				PerParticleSystemSetup();
				int particles = currentParticleSystem.GetParticles(particleSystemParticles[k]);
				ParticleSystemSimulationSpace simulationSpace = particleSystemMainModules[k].simulationSpace;
				ParticleSystemScalingMode scalingMode = particleSystemMainModules[k].scalingMode;
				Transform transform = currentParticleSystem.transform;
				Transform customSimulationSpace = particleSystemMainModules[k].customSimulationSpace;
				if (simulationSpace == ParticleSystemSimulationSpace.World)
				{
					for (int l = 0; l < particles; l++)
					{
						parameters.particlePosition = particleSystemParticles[k][l].position;
						parameters.scaledDirectionToAffectorCenter.x = transformPosition.x - parameters.particlePosition.x;
						parameters.scaledDirectionToAffectorCenter.y = transformPosition.y - parameters.particlePosition.y;
						parameters.scaledDirectionToAffectorCenter.z = transformPosition.z - parameters.particlePosition.z;
						parameters.distanceToAffectorCenterSqr = parameters.scaledDirectionToAffectorCenter.sqrMagnitude;
						if (parameters.distanceToAffectorCenterSqr < radiusSqr)
						{
							float time = parameters.distanceToAffectorCenterSqr / radiusSqr;
							float num = scaleForceByDistance.Evaluate(time);
							Vector3 vector = GetForce();
							float num2 = forceDeltaTime * num * particleSystemExternalForcesMultipliers[k];
							vector.x *= num2;
							vector.y *= num2;
							vector.z *= num2;
							Vector3 velocity = particleSystemParticles[k][l].velocity;
							velocity.x += vector.x;
							velocity.y += vector.y;
							velocity.z += vector.z;
							particleSystemParticles[k][l].velocity = velocity;
						}
					}
				}
				else
				{
					Vector3 zero = Vector3.zero;
					Quaternion identity = Quaternion.identity;
					Vector3 one = Vector3.one;
					Transform transform2 = transform;
					switch (simulationSpace)
					{
					case ParticleSystemSimulationSpace.Local:
						zero = transform2.position;
						identity = transform2.rotation;
						one = transform2.localScale;
						break;
					case ParticleSystemSimulationSpace.Custom:
						transform2 = customSimulationSpace;
						zero = transform2.position;
						identity = transform2.rotation;
						one = transform2.localScale;
						break;
					default:
						throw new NotSupportedException($"Unsupported scaling mode '{simulationSpace}'.");
					}
					for (int m = 0; m < particles; m++)
					{
						parameters.particlePosition = particleSystemParticles[k][m].position;
						if (simulationSpace == ParticleSystemSimulationSpace.Local || simulationSpace == ParticleSystemSimulationSpace.Custom)
						{
							switch (scalingMode)
							{
							case ParticleSystemScalingMode.Hierarchy:
								parameters.particlePosition = transform2.TransformPoint(particleSystemParticles[k][m].position);
								break;
							case ParticleSystemScalingMode.Local:
								parameters.particlePosition = Vector3.Scale(parameters.particlePosition, one);
								parameters.particlePosition = identity * parameters.particlePosition;
								parameters.particlePosition += zero;
								break;
							case ParticleSystemScalingMode.Shape:
								parameters.particlePosition = identity * parameters.particlePosition;
								parameters.particlePosition += zero;
								break;
							default:
								throw new NotSupportedException($"Unsupported scaling mode '{scalingMode}'.");
							}
						}
						parameters.scaledDirectionToAffectorCenter.x = transformPosition.x - parameters.particlePosition.x;
						parameters.scaledDirectionToAffectorCenter.y = transformPosition.y - parameters.particlePosition.y;
						parameters.scaledDirectionToAffectorCenter.z = transformPosition.z - parameters.particlePosition.z;
						parameters.distanceToAffectorCenterSqr = parameters.scaledDirectionToAffectorCenter.sqrMagnitude;
						if (!(parameters.distanceToAffectorCenterSqr < radiusSqr))
						{
							continue;
						}
						float time2 = parameters.distanceToAffectorCenterSqr / radiusSqr;
						float num3 = scaleForceByDistance.Evaluate(time2);
						Vector3 vector2 = GetForce();
						float num4 = forceDeltaTime * num3 * particleSystemExternalForcesMultipliers[k];
						vector2.x *= num4;
						vector2.y *= num4;
						vector2.z *= num4;
						if (simulationSpace == ParticleSystemSimulationSpace.Local || simulationSpace == ParticleSystemSimulationSpace.Custom)
						{
							switch (scalingMode)
							{
							case ParticleSystemScalingMode.Hierarchy:
								vector2 = transform2.InverseTransformVector(vector2);
								break;
							case ParticleSystemScalingMode.Local:
								vector2 = Quaternion.Inverse(identity) * vector2;
								vector2 = Vector3.Scale(vector2, new Vector3(1f / one.x, 1f / one.y, 1f / one.z));
								break;
							case ParticleSystemScalingMode.Shape:
								vector2 = Quaternion.Inverse(identity) * vector2;
								break;
							default:
								throw new NotSupportedException($"Unsupported scaling mode '{scalingMode}'.");
							}
						}
						Vector3 velocity2 = particleSystemParticles[k][m].velocity;
						velocity2.x += vector2.x;
						velocity2.y += vector2.y;
						velocity2.z += vector2.z;
						particleSystemParticles[k][m].velocity = velocity2;
					}
				}
				currentParticleSystem.SetParticles(particleSystemParticles[k], particles);
			}
		}

		private void OnApplicationQuit()
		{
		}

		protected virtual void OnDrawGizmosSelected()
		{
			Gizmos.color = Color.green;
			Gizmos.DrawWireSphere(base.transform.position + offset, scaledRadius);
		}
	}
	public class TurbulenceParticleAffector : ParticleAffector
	{
		public enum NoiseType
		{
			PseudoPerlin,
			Perlin,
			Simplex,
			OctavePerlin,
			OctaveSimplex
		}

		[Header("Affector Controls")]
		public float speed = 1f;

		[Range(0f, 8f)]
		public float frequency = 1f;

		public NoiseType noiseType = NoiseType.Perlin;

		[Header("Octave Variant-Only Controls")]
		[Range(1f, 8f)]
		public int octaves = 1;

		[Range(0f, 4f)]
		public float lacunarity = 2f;

		[Range(0f, 1f)]
		public float persistence = 0.5f;

		private float time;

		private float randomX;

		private float randomY;

		private float randomZ;

		private float offsetX;

		private float offsetY;

		private float offsetZ;

		protected override void Awake()
		{
			base.Awake();
		}

		protected override void Start()
		{
			base.Start();
			randomX = UnityEngine.Random.Range(-32f, 32f);
			randomY = UnityEngine.Random.Range(-32f, 32f);
			randomZ = UnityEngine.Random.Range(-32f, 32f);
		}

		protected override void Update()
		{
			time = Time.time;
			base.Update();
		}

		protected override void LateUpdate()
		{
			offsetX = time * speed + randomX;
			offsetY = time * speed + randomY;
			offsetZ = time * speed + randomZ;
			base.LateUpdate();
		}

		protected override Vector3 GetForce()
		{
			float num = parameters.particlePosition.x + offsetX;
			float num2 = parameters.particlePosition.y + offsetX;
			float num3 = parameters.particlePosition.z + offsetX;
			float num4 = parameters.particlePosition.x + offsetY;
			float num5 = parameters.particlePosition.y + offsetY;
			float num6 = parameters.particlePosition.z + offsetY;
			float num7 = parameters.particlePosition.x + offsetZ;
			float num8 = parameters.particlePosition.y + offsetZ;
			float num9 = parameters.particlePosition.z + offsetZ;
			Vector3 result = default(Vector3);
			switch (noiseType)
			{
			case NoiseType.PseudoPerlin:
			{
				float t = Mathf.PerlinNoise(num * frequency, num5 * frequency);
				float t2 = Mathf.PerlinNoise(num * frequency, num6 * frequency);
				float t3 = Mathf.PerlinNoise(num * frequency, num4 * frequency);
				t = Mathf.Lerp(-1f, 1f, t);
				t2 = Mathf.Lerp(-1f, 1f, t2);
				t3 = Mathf.Lerp(-1f, 1f, t3);
				Vector3 vector = Vector3.right * t;
				Vector3 vector2 = Vector3.up * t2;
				Vector3 vector3 = Vector3.forward * t3;
				return vector + vector2 + vector3;
			}
			default:
				result.x = Noise.perlin(num * frequency, num2 * frequency, num3 * frequency);
				result.y = Noise.perlin(num4 * frequency, num5 * frequency, num6 * frequency);
				result.z = Noise.perlin(num7 * frequency, num8 * frequency, num9 * frequency);
				return result;
			case NoiseType.Simplex:
				result.x = Noise.simplex(num * frequency, num2 * frequency, num3 * frequency);
				result.y = Noise.simplex(num4 * frequency, num5 * frequency, num6 * frequency);
				result.z = Noise.simplex(num7 * frequency, num8 * frequency, num9 * frequency);
				break;
			case NoiseType.OctavePerlin:
				result.x = Noise.octavePerlin(num, num2, num3, frequency, octaves, lacunarity, persistence);
				result.y = Noise.octavePerlin(num4, num5, num6, frequency, octaves, lacunarity, persistence);
				result.z = Noise.octavePerlin(num7, num8, num9, frequency, octaves, lacunarity, persistence);
				break;
			case NoiseType.OctaveSimplex:
				result.x = Noise.octaveSimplex(num, num2, num3, frequency, octaves, lacunarity, persistence);
				result.y = Noise.octaveSimplex(num4, num5, num6, frequency, octaves, lacunarity, persistence);
				result.z = Noise.octaveSimplex(num7, num8, num9, frequency, octaves, lacunarity, persistence);
				break;
			}
			return result;
		}

		protected override void OnDrawGizmosSelected()
		{
			if (base.enabled)
			{
				base.OnDrawGizmosSelected();
			}
		}
	}
	public class VortexParticleAffector : ParticleAffector
	{
		private Vector3 axisOfRotation;

		[Header("Affector Controls")]
		public Vector3 axisOfRotationOffset = Vector3.zero;

		protected override void Awake()
		{
			base.Awake();
		}

		protected override void Start()
		{
			base.Start();
		}

		protected override void Update()
		{
			base.Update();
		}

		protected override void LateUpdate()
		{
			base.LateUpdate();
		}

		private void UpdateAxisOfRotation()
		{
			axisOfRotation = Quaternion.Euler(axisOfRotationOffset) * base.transform.up;
		}

		protected override void PerParticleSystemSetup()
		{
			UpdateAxisOfRotation();
		}

		protected override Vector3 GetForce()
		{
			return Vector3.Normalize(Vector3.Cross(axisOfRotation, parameters.scaledDirectionToAffectorCenter));
		}

		protected override void OnDrawGizmosSelected()
		{
			if (base.enabled)
			{
				base.OnDrawGizmosSelected();
				Gizmos.color = Color.red;
				Vector3 vector;
				if (UnityEngine.Application.isPlaying && base.enabled)
				{
					UpdateAxisOfRotation();
					vector = axisOfRotation;
				}
				else
				{
					vector = Quaternion.Euler(axisOfRotationOffset) * base.transform.up;
				}
				Gizmos.DrawLine(base.transform.position + offset, base.transform.position + offset + vector * base.scaledRadius);
			}
		}
	}
	[RequireComponent(typeof(ParticleSystem))]
	public class ParticleFlocking : MonoBehaviour
	{
		public struct Voxel
		{
			public Bounds bounds;

			public int[] particles;

			public int particleCount;
		}

		[Header("N^2 Mode Settings")]
		public float maxDistance = 0.5f;

		[Header("Forces")]
		public float cohesion = 0.5f;

		public float separation = 0.25f;

		[Header("Voxel Mode Settings")]
		public bool useVoxels = true;

		public bool voxelLocalCenterFromBounds = true;

		public float voxelVolume = 8f;

		public int voxelsPerAxis = 5;

		private int previousVoxelsPerAxisValue;

		private Voxel[] voxels;

		private ParticleSystem particleSystem;

		private ParticleSystem.Particle[] particles;

		private Vector3[] particlePositions;

		private ParticleSystem.MainModule particleSystemMainModule;

		[Header("General Performance Settings")]
		[Range(0f, 1f)]
		public float delay;

		private float timer;

		public bool alwaysUpdate;

		private bool visible;

		private void Start()
		{
			particleSystem = GetComponent<ParticleSystem>();
			particleSystemMainModule = particleSystem.main;
		}

		private void OnBecameVisible()
		{
			visible = true;
		}

		private void OnBecameInvisible()
		{
			visible = false;
		}

		private void buildVoxelGrid()
		{
			int num = voxelsPerAxis * voxelsPerAxis * voxelsPerAxis;
			voxels = new Voxel[num];
			float num2 = voxelVolume / (float)voxelsPerAxis;
			float num3 = num2 / 2f;
			float num4 = voxelVolume / 2f;
			Vector3 position = base.transform.position;
			int num5 = 0;
			for (int i = 0; i < voxelsPerAxis; i++)
			{
				float x = 0f - num4 + num3 + (float)i * num2;
				for (int j = 0; j < voxelsPerAxis; j++)
				{
					float y = 0f - num4 + num3 + (float)j * num2;
					for (int k = 0; k < voxelsPerAxis; k++)
					{
						float z = 0f - num4 + num3 + (float)k * num2;
						voxels[num5].particleCount = 0;
						voxels[num5].bounds = new Bounds(position + new Vector3(x, y, z), Vector3.one * num2);
						num5++;
					}
				}
			}
		}

		private void LateUpdate()
		{
			if (!alwaysUpdate && !visible)
			{
				return;
			}
			if (useVoxels)
			{
				int num = voxelsPerAxis * voxelsPerAxis * voxelsPerAxis;
				if (voxels == null || voxels.Length < num)
				{
					buildVoxelGrid();
				}
			}
			int maxParticles = particleSystemMainModule.maxParticles;
			if (particles == null || particles.Length < maxParticles)
			{
				particles = new ParticleSystem.Particle[maxParticles];
				particlePositions = new Vector3[maxParticles];
				if (useVoxels)
				{
					for (int i = 0; i < voxels.Length; i++)
					{
						voxels[i].particles = new int[maxParticles];
					}
				}
			}
			timer += Time.deltaTime;
			if (!(timer >= delay))
			{
				return;
			}
			float num2 = timer;
			timer = 0f;
			particleSystem.GetParticles(particles);
			int particleCount = particleSystem.particleCount;
			float num3 = cohesion * num2;
			float num4 = separation * num2;
			for (int j = 0; j < particleCount; j++)
			{
				particlePositions[j] = particles[j].position;
			}
			if (useVoxels)
			{
				int num5 = voxels.Length;
				float num6 = voxelVolume / (float)voxelsPerAxis;
				for (int k = 0; k < particleCount; k++)
				{
					for (int l = 0; l < num5; l++)
					{
						if (voxels[l].bounds.Contains(particlePositions[k]))
						{
							voxels[l].particles[voxels[l].particleCount] = k;
							voxels[l].particleCount++;
							break;
						}
					}
				}
				for (int m = 0; m < num5; m++)
				{
					if (voxels[m].particleCount <= 1)
					{
						continue;
					}
					for (int n = 0; n < voxels[m].particleCount; n++)
					{
						Vector3 vector = particlePositions[voxels[m].particles[n]];
						Vector3 vector2;
						if (voxelLocalCenterFromBounds)
						{
							vector2 = voxels[m].bounds.center - particlePositions[voxels[m].particles[n]];
						}
						else
						{
							for (int num7 = 0; num7 < voxels[m].particleCount; num7++)
							{
								if (num7 != n)
								{
									vector += particlePositions[voxels[m].particles[num7]];
								}
							}
							vector /= (float)voxels[m].particleCount;
							vector2 = vector - particlePositions[voxels[m].particles[n]];
						}
						float sqrMagnitude = vector2.sqrMagnitude;
						vector2.Normalize();
						Vector3 zero = Vector3.zero;
						zero += vector2 * num3;
						zero -= vector2 * ((1f - sqrMagnitude / num6) * num4);
						Vector3 velocity = particles[voxels[m].particles[n]].velocity;
						velocity.x += zero.x;
						velocity.y += zero.y;
						velocity.z += zero.z;
						particles[voxels[m].particles[n]].velocity = velocity;
					}
					voxels[m].particleCount = 0;
				}
			}
			else
			{
				float num8 = maxDistance * maxDistance;
				Vector3 vector4 = default(Vector3);
				for (int num9 = 0; num9 < particleCount; num9++)
				{
					int num10 = 1;
					Vector3 vector3 = particlePositions[num9];
					for (int num11 = 0; num11 < particleCount; num11++)
					{
						if (num11 != num9)
						{
							vector4.x = particlePositions[num9].x - particlePositions[num11].x;
							vector4.y = particlePositions[num9].y - particlePositions[num11].y;
							vector4.z = particlePositions[num9].z - particlePositions[num11].z;
							if (Vector3.SqrMagnitude(vector4) <= num8)
							{
								num10++;
								vector3 += particlePositions[num11];
							}
						}
					}
					if (num10 != 1)
					{
						vector3 /= (float)num10;
						Vector3 vector5 = vector3 - particlePositions[num9];
						float sqrMagnitude2 = vector5.sqrMagnitude;
						vector5.Normalize();
						Vector3 zero2 = Vector3.zero;
						zero2 += vector5 * num3;
						zero2 -= vector5 * ((1f - sqrMagnitude2 / num8) * num4);
						Vector3 velocity2 = particles[num9].velocity;
						velocity2.x += zero2.x;
						velocity2.y += zero2.y;
						velocity2.z += zero2.z;
						particles[num9].velocity = velocity2;
					}
				}
			}
			particleSystem.SetParticles(particles, particleCount);
		}

		private void OnDrawGizmosSelected()
		{
			float num = voxelVolume / (float)voxelsPerAxis;
			float num2 = num / 2f;
			float num3 = voxelVolume / 2f;
			Vector3 position = base.transform.position;
			Gizmos.color = Color.red;
			Gizmos.DrawWireCube(position, Vector3.one * voxelVolume);
			Gizmos.color = Color.white;
			for (int i = 0; i < voxelsPerAxis; i++)
			{
				float x = 0f - num3 + num2 + (float)i * num;
				for (int j = 0; j < voxelsPerAxis; j++)
				{
					float y = 0f - num3 + num2 + (float)j * num;
					for (int k = 0; k < voxelsPerAxis; k++)
					{
						float z = 0f - num3 + num2 + (float)k * num;
						Gizmos.DrawWireCube(position + new Vector3(x, y, z), Vector3.one * num);
					}
				}
			}
		}
	}
	[AddComponentMenu("Effects/Particle Force Fields/Attraction Particle Force Field")]
	public class AttractionParticleForceField : ParticleForceField
	{
		[Header("ForceField Controls")]
		[Tooltip("Tether force based on linear inverse particle distance to force field center.")]
		public float arrivalRadius = 1f;

		[Tooltip("Dead zone from force field center in which no additional force is applied.")]
		public float arrivedRadius = 0.5f;

		private float arrivalRadiusSqr;

		private float arrivedRadiusSqr;

		protected override void Awake()
		{
			base.Awake();
		}

		protected override void Start()
		{
			base.Start();
		}

		protected override void Update()
		{
			base.Update();
		}

		protected override void LateUpdate()
		{
			float x = base.transform.lossyScale.x;
			arrivalRadiusSqr = arrivalRadius * arrivalRadius * x;
			arrivedRadiusSqr = arrivedRadius * arrivedRadius * x;
			base.LateUpdate();
		}

		protected override Vector3 GetForce()
		{
			if (parameters.distanceToForceFieldCenterSqr < arrivedRadiusSqr)
			{
				Vector3 result = default(Vector3);
				result.x = 0f;
				result.y = 0f;
				result.z = 0f;
				return result;
			}
			if (parameters.distanceToForceFieldCenterSqr < arrivalRadiusSqr)
			{
				float num = 1f - parameters.distanceToForceFieldCenterSqr / arrivalRadiusSqr;
				return Vector3.Normalize(parameters.scaledDirectionToForceFieldCenter) * num;
			}
			return Vector3.Normalize(parameters.scaledDirectionToForceFieldCenter);
		}

		protected override void OnDrawGizmosSelected()
		{
			if (base.enabled)
			{
				base.OnDrawGizmosSelected();
				float x = base.transform.lossyScale.x;
				float num = arrivalRadius * x;
				float num2 = arrivedRadius * x;
				Vector3 vector = base.transform.position + center;
				Gizmos.color = Color.yellow;
				Gizmos.DrawWireSphere(vector, num);
				Gizmos.color = Color.red;
				Gizmos.DrawWireSphere(vector, num2);
			}
		}
	}
	[Serializable]
	public static class Noise2
	{
		private static float F3 = 1f / 3f;

		private static float G3 = 1f / 6f;

		private static byte[] perm = new byte[512]
		{
			151, 160, 137, 91, 90, 15, 131, 13, 201, 95,
			96, 53, 194, 233, 7, 225, 140, 36, 103, 30,
			69, 142, 8, 99, 37, 240, 21, 10, 23, 190,
			6, 148, 247, 120, 234, 75, 0, 26, 197, 62,
			94, 252, 219, 203, 117, 35, 11, 32, 57, 177,
			33, 88, 237, 149, 56, 87, 174, 20, 125, 136,
			171, 168, 68, 175, 74, 165, 71, 134, 139, 48,
			27, 166, 77, 146, 158, 231, 83, 111, 229, 122,
			60, 211, 133, 230, 220, 105, 92, 41, 55, 46,
			245, 40, 244, 102, 143, 54, 65, 25, 63, 161,
			1, 216, 80, 73, 209, 76, 132, 187, 208, 89,
			18, 169, 200, 196, 135, 130, 116, 188, 159, 86,
			164, 100, 109, 198, 173, 186, 3, 64, 52, 217,
			226, 250, 124, 123, 5, 202, 38, 147, 118, 126,
			255, 82, 85, 212, 207, 206, 59, 227, 47, 16,
			58, 17, 182, 189, 28, 42, 223, 183, 170, 213,
			119, 248, 152, 2, 44, 154, 163, 70, 221, 153,
			101, 155, 167, 43, 172, 9, 129, 22, 39, 253,
			19, 98, 108, 110, 79, 113, 224, 232, 178, 185,
			112, 104, 218, 246, 97, 228, 251, 34, 242, 193,
			238, 210, 144, 12, 191, 179, 162, 241, 81, 51,
			145, 235, 249, 14, 239, 107, 49, 192, 214, 31,
			181, 199, 106, 157, 184, 84, 204, 176, 115, 121,
			50, 45, 127, 4, 150, 254, 138, 236, 205, 93,
			222, 114, 67, 29, 24, 72, 243, 141, 128, 195,
			78, 66, 215, 61, 156, 180, 151, 160, 137, 91,
			90, 15, 131, 13, 201, 95, 96, 53, 194, 233,
			7, 225, 140, 36, 103, 30, 69, 142, 8, 99,
			37, 240, 21, 10, 23, 190, 6, 148, 247, 120,
			234, 75, 0, 26, 197, 62, 94, 252, 219, 203,
			117, 35, 11, 32, 57, 177, 33, 88, 237, 149,
			56, 87, 174, 20, 125, 136, 171, 168, 68, 175,
			74, 165, 71, 134, 139, 48, 27, 166, 77, 146,
			158, 231, 83, 111, 229, 122, 60, 211, 133, 230,
			220, 105, 92, 41, 55, 46, 245, 40, 244, 102,
			143, 54, 65, 25, 63, 161, 1, 216, 80, 73,
			209, 76, 132, 187, 208, 89, 18, 169, 200, 196,
			135, 130, 116, 188, 159, 86, 164, 100, 109, 198,
			173, 186, 3, 64, 52, 217, 226, 250, 124, 123,
			5, 202, 38, 147, 118, 126, 255, 82, 85, 212,
			207, 206, 59, 227, 47, 16, 58, 17, 182, 189,
			28, 42, 223, 183, 170, 213, 119, 248, 152, 2,
			44, 154, 163, 70, 221, 153, 101, 155, 167, 43,
			172, 9, 129, 22, 39, 253, 19, 98, 108, 110,
			79, 113, 224, 232, 178, 185, 112, 104, 218, 246,
			97, 228, 251, 34, 242, 193, 238, 210, 144, 12,
			191, 179, 162, 241, 81, 51, 145, 235, 249, 14,
			239, 107, 49, 192, 214, 31, 181, 199, 106, 157,
			184, 84, 204, 176, 115, 121, 50, 45, 127, 4,
			150, 254, 138, 236, 205, 93, 222, 114, 67, 29,
			24, 72, 243, 141, 128, 195, 78, 66, 215, 61,
			156, 180
		};

		private static float smooth(float t)
		{
			return t * t * (3f - 2f * t);
		}

		private static float fade(float t)
		{
			return t * t * t * (t * (t * 6f - 15f) + 10f);
		}

		private static int floor(float x)
		{
			if (!(x > 0f))
			{
				return (int)x - 1;
			}
			return (int)x;
		}

		private static float lerp(float from, float to, float t)
		{
			return from + t * (to - from);
		}

		private static float grad(int hash, float x, float y, float z)
		{
			return (hash & 0xF) switch
			{
				0 => x + y, 
				1 => 0f - x + y, 
				2 => x - y, 
				3 => 0f - x - y, 
				4 => x + x, 
				5 => 0f - x + x, 
				6 => x - x, 
				7 => 0f - x - x, 
				8 => y + x, 
				9 => 0f - y + x, 
				10 => y - x, 
				11 => 0f - y - x, 
				12 => y + z, 
				13 => 0f - y + x, 
				14 => y - x, 
				15 => 0f - y - z, 
				_ => 0f, 
			};
		}

		public static float perlin(float x, float y, float z)
		{
			int num = ((x > 0f) ? ((int)x) : ((int)x - 1));
			int num2 = ((y > 0f) ? ((int)y) : ((int)y - 1));
			int num3 = ((z > 0f) ? ((int)z) : ((int)z - 1));
			float num4 = x - (float)num;
			float num5 = y - (float)num2;
			float num6 = z - (float)num3;
			float num7 = num4 - 1f;
			float num8 = num5 - 1f;
			float num9 = num6 - 1f;
			int num10 = (num + 1) & 0xFF;
			int num11 = (num2 + 1) & 0xFF;
			int num12 = (num3 + 1) & 0xFF;
			num &= 0xFF;
			num2 &= 0xFF;
			num3 &= 0xFF;
			float num13 = num6 * num6 * num6 * (num6 * (num6 * 6f - 15f) + 10f);
			float num14 = num5 * num5 * num5 * (num5 * (num5 * 6f - 15f) + 10f);
			float num15 = num4 * num4 * num4 * (num4 * (num4 * 6f - 15f) + 10f);
			float num16 = (perm[num + perm[num2 + perm[num3]]] & 0xF) switch
			{
				0 => num4 + num5, 
				1 => 0f - num4 + num5, 
				2 => num4 - num5, 
				3 => 0f - num4 - num5, 
				4 => num4 + num4, 
				5 => 0f - num4 + num4, 
				6 => num4 - num4, 
				7 => 0f - num4 - num4, 
				8 => num5 + num4, 
				9 => 0f - num5 + num4, 
				10 => num5 - num4, 
				11 => 0f - num5 - num4, 
				12 => num5 + num6, 
				13 => 0f - num5 + num4, 
				14 => num5 - num4, 
				15 => 0f - num5 - num6, 
				_ => 0f, 
			};
			float num17 = num16 + num13 * ((perm[num + perm[num2 + perm[num12]]] & 0xF) switch
			{
				0 => num4 + num5, 
				1 => 0f - num4 + num5, 
				2 => num4 - num5, 
				3 => 0f - num4 - num5, 
				4 => num4 + num4, 
				5 => 0f - num4 + num4, 
				6 => num4 - num4, 
				7 => 0f - num4 - num4, 
				8 => num5 + num4, 
				9 => 0f - num5 + num4, 
				10 => num5 - num4, 
				11 => 0f - num5 - num4, 
				12 => num5 + num9, 
				13 => 0f - num5 + num4, 
				14 => num5 - num4, 
				15 => 0f - num5 - num9, 
				_ => 0f, 
			} - num16);
			num16 = (perm[num + perm[num11 + perm[num3]]] & 0xF) switch
			{
				0 => num4 + num8, 
				1 => 0f - num4 + num8, 
				2 => num4 - num8, 
				3 => 0f - num4 - num8, 
				4 => num4 + num4, 
				5 => 0f - num4 + num4, 
				6 => num4 - num4, 
				7 => 0f - num4 - num4, 
				8 => num8 + num4, 
				9 => 0f - num8 + num4, 
				10 => num8 - num4, 
				11 => 0f - num8 - num4, 
				12 => num8 + num6, 
				13 => 0f - num8 + num4, 
				14 => num8 - num4, 
				15 => 0f - num8 - num6, 
				_ => 0f, 
			};
			float num18 = num16 + num13 * ((perm[num + perm[num11 + perm[num12]]] & 0xF) switch
			{
				0 => num4 + num8, 
				1 => 0f - num4 + num8, 
				2 => num4 - num8, 
				3 => 0f - num4 - num8, 
				4 => num4 + num4, 
				5 => 0f - num4 + num4, 
				6 => num4 - num4, 
				7 => 0f - num4 - num4, 
				8 => num8 + num4, 
				9 => 0f - num8 + num4, 
				10 => num8 - num4, 
				11 => 0f - num8 - num4, 
				12 => num8 + num9, 
				13 => 0f - num8 + num4, 
				14 => num8 - num4, 
				15 => 0f - num8 - num9, 
				_ => 0f, 
			} - num16);
			float num19 = num17 + num14 * (num18 - num17);
			num16 = (perm[num10 + perm[num2 + perm[num3]]] & 0xF) switch
			{
				0 => num7 + num5, 
				1 => 0f - num7 + num5, 
				2 => num7 - num5, 
				3 => 0f - num7 - num5, 
				4 => num7 + num7, 
				5 => 0f - num7 + num7, 
				6 => num7 - num7, 
				7 => 0f - num7 - num7, 
				8 => num5 + num7, 
				9 => 0f - num5 + num7, 
				10 => num5 - num7, 
				11 => 0f - num5 - num7, 
				12 => num5 + num6, 
				13 => 0f - num5 + num7, 
				14 => num5 - num7, 
				15 => 0f - num5 - num6, 
				_ => 0f, 
			};
			num17 = num16 + num13 * ((perm[num10 + perm[num2 + perm[num12]]] & 0xF) switch
			{
				0 => num7 + num5, 
				1 => 0f - num7 + num5, 
				2 => num7 - num5, 
				3 => 0f - num7 - num5, 
				4 => num7 + num7, 
				5 => 0f - num7 + num7, 
				6 => num7 - num7, 
				7 => 0f - num7 - num7, 
				8 => num5 + num7, 
				9 => 0f - num5 + num7, 
				10 => num5 - num7, 
				11 => 0f - num5 - num7, 
				12 => num5 + num9, 
				13 => 0f - num5 + num7, 
				14 => num5 - num7, 
				15 => 0f - num5 - num9, 
				_ => 0f, 
			} - num16);
			num16 = (perm[num10 + perm[num11 + perm[num3]]] & 0xF) switch
			{
				0 => num7 + num8, 
				1 => 0f - num7 + num8, 
				2 => num7 - num8, 
				3 => 0f - num7 - num8, 
				4 => num7 + num7, 
				5 => 0f - num7 + num7, 
				6 => num7 - num7, 
				7 => 0f - num7 - num7, 
				8 => num8 + num7, 
				9 => 0f - num8 + num7, 
				10 => num8 - num7, 
				11 => 0f - num8 - num7, 
				12 => num8 + num6, 
				13 => 0f - num8 + num7, 
				14 => num8 - num7, 
				15 => 0f - num8 - num6, 
				_ => 0f, 
			};
			num18 = num16 + num13 * ((perm[num10 + perm[num11 + perm[num12]]] & 0xF) switch
			{
				0 => num7 + num8, 
				1 => 0f - num7 + num8, 
				2 => num7 - num8, 
				3 => 0f - num7 - num8, 
				4 => num7 + num7, 
				5 => 0f - num7 + num7, 
				6 => num7 - num7, 
				7 => 0f - num7 - num7, 
				8 => num8 + num7, 
				9 => 0f - num8 + num7, 
				10 => num8 - num7, 
				11 => 0f - num8 - num7, 
				12 => num8 + num9, 
				13 => 0f - num8 + num7, 
				14 => num8 - num7, 
				15 => 0f - num8 - num9, 
				_ => 0f, 
			} - num16);
			float num20 = num17 + num14 * (num18 - num17);
			return 0.936f * (num19 + num15 * (num20 - num19));
		}

		public static float simplex(float x, float y, float z)
		{
			float num = (x + y + z) * F3;
			float num2 = x + num;
			float num3 = y + num;
			float num4 = z + num;
			int num5 = ((num2 > 0f) ? ((int)num2) : ((int)num2 - 1));
			int num6 = ((num3 > 0f) ? ((int)num3) : ((int)num3 - 1));
			int num7 = ((num4 > 0f) ? ((int)num4) : ((int)num4 - 1));
			float num8 = (float)(num5 + num6 + num7) * G3;
			float num9 = (float)num5 - num8;
			float num10 = (float)num6 - num8;
			float num11 = (float)num7 - num8;
			float num12 = x - num9;
			float num13 = y - num10;
			float num14 = z - num11;
			int num15;
			int num16;
			int num17;
			int num18;
			int num19;
			int num20;
			if (num12 >= num13)
			{
				if (num13 >= num14)
				{
					num15 = 1;
					num16 = 0;
					num17 = 0;
					num18 = 1;
					num19 = 1;
					num20 = 0;
				}
				else if (num12 >= num14)
				{
					num15 = 1;
					num16 = 0;
					num17 = 0;
					num18 = 1;
					num19 = 0;
					num20 = 1;
				}
				else
				{
					num15 = 0;
					num16 = 0;
					num17 = 1;
					num18 = 1;
					num19 = 0;
					num20 = 1;
				}
			}
			else if (num13 < num14)
			{
				num15 = 0;
				num16 = 0;
				num17 = 1;
				num18 = 0;
				num19 = 1;
				num20 = 1;
			}
			else if (num12 < num14)
			{
				num15 = 0;
				num16 = 1;
				num17 = 0;
				num18 = 0;
				num19 = 1;
				num20 = 1;
			}
			else
			{
				num15 = 0;
				num16 = 1;
				num17 = 0;
				num18 = 1;
				num19 = 1;
				num20 = 0;
			}
			float num21 = num12 - (float)num15 + G3;
			float num22 = num13 - (float)num16 + G3;
			float num23 = num14 - (float)num17 + G3;
			float num24 = num12 - (float)num18 + 2f * G3;
			float num25 = num13 - (float)num19 + 2f * G3;
			float num26 = num14 - (float)num20 + 2f * G3;
			float num27 = num12 - 1f + 3f * G3;
			float num28 = num13 - 1f + 3f * G3;
			float num29 = num14 - 1f + 3f * G3;
			int num30 = num5 & 0xFF;
			int num31 = num6 & 0xFF;
			int num32 = num7 & 0xFF;
			float num33 = 0.6f - num12 * num12 - num13 * num13 - num14 * num14;
			float num34;
			if (num33 < 0f)
			{
				num34 = 0f;
			}
			else
			{
				num33 *= num33;
				num34 = num33 * num33 * (perm[num30 + perm[num31 + perm[num32]]] & 0xF) switch
				{
					0 => num12 + num13, 
					1 => 0f - num12 + num13, 
					2 => num12 - num13, 
					3 => 0f - num12 - num13, 
					4 => num12 + num12, 
					5 => 0f - num12 + num12, 
					6 => num12 - num12, 
					7 => 0f - num12 - num12, 
					8 => num13 + num12, 
					9 => 0f - num13 + num12, 
					10 => num13 - num12, 
					11 => 0f - num13 - num12, 
					12 => num13 + num14, 
					13 => 0f - num13 + num12, 
					14 => num13 - num12, 
					15 => 0f - num13 - num14, 
					_ => 0f, 
				};
			}
			float num35 = 0.6f - num21 * num21 - num22 * num22 - num23 * num23;
			float num36;
			if (num35 < 0f)
			{
				num36 = 0f;
			}
			else
			{
				num35 *= num35;
				num36 = num35 * num35 * (perm[num30 + num15 + perm[num31 + num16 + perm[num32 + num17]]] & 0xF) switch
				{
					0 => num21 + num22, 
					1 => 0f - num21 + num22, 
					2 => num21 - num22, 
					3 => 0f - num21 - num22, 
					4 => num21 + num21, 
					5 => 0f - num21 + num21, 
					6 => num21 - num21, 
					7 => 0f - num21 - num21, 
					8 => num22 + num21, 
					9 => 0f - num22 + num21, 
					10 => num22 - num21, 
					11 => 0f - num22 - num21, 
					12 => num22 + num23, 
					13 => 0f - num22 + num21, 
					14 => num22 - num21, 
					15 => 0f - num22 - num23, 
					_ => 0f, 
				};
			}
			float num37 = 0.6f - num24 * num24 - num25 * num25 - num26 * num26;
			float num38;
			if (num37 < 0f)
			{
				num38 = 0f;
			}
			else
			{
				num37 *= num37;
				num38 = num37 * num37 * (perm[num30 + num18 + perm[num31 + num19 + perm[num32 + num20]]] & 0xF) switch
				{
					0 => num24 + num25, 
					1 => 0f - num24 + num25, 
					2 => num24 - num25, 
					3 => 0f - num24 - num25, 
					4 => num24 + num24, 
					5 => 0f - num24 + num24, 
					6 => num24 - num24, 
					7 => 0f - num24 - num24, 
					8 => num25 + num24, 
					9 => 0f - num25 + num24, 
					10 => num25 - num24, 
					11 => 0f - num25 - num24, 
					12 => num25 + num26, 
					13 => 0f - num25 + num24, 
					14 => num25 - num24, 
					15 => 0f - num25 - num26, 
					_ => 0f, 
				};
			}
			float num39 = 0.6f - num27 * num27 - num28 * num28 - num29 * num29;
			float num40;
			if (num39 < 0f)
			{
				num40 = 0f;
			}
			else
			{
				num39 *= num39;
				num40 = num39 * num39 * (perm[num30 + 1 + perm[num31 + 1 + perm[num32 + 1]]] & 0xF) switch
				{
					0 => num27 + num28, 
					1 => 0f - num27 + num28, 
					2 => num27 - num28, 
					3 => 0f - num27 - num28, 
					4 => num27 + num27, 
					5 => 0f - num27 + num27, 
					6 => num27 - num27, 
					7 => 0f - num27 - num27, 
					8 => num28 + num27, 
					9 => 0f - num28 + num27, 
					10 => num28 - num27, 
					11 => 0f - num28 - num27, 
					12 => num28 + num29, 
					13 => 0f - num28 + num27, 
					14 => num28 - num27, 
					15 => 0f - num28 - num29, 
					_ => 0f, 
				};
			}
			return 32f * (num34 + num36 + num38 + num40);
		}

		public static float octavePerlin(float x, float y, float z, float frequency, int octaves, float lacunarity, float persistence)
		{
			if (octaves < 2)
			{
				return perlin(x * frequency, y * frequency, z * frequency);
			}
			float num = 0f;
			float num2 = 1f;
			float num3 = 0f;
			for (int i = 0; i < octaves; i++)
			{
				num += perlin(x * frequency, y * frequency, z * frequency) * num2;
				num3 += num2;
				frequency *= lacunarity;
				num2 *= persistence;
			}
			return num / num3;
		}

		public static float octaveSimplex(float x, float y, float z, float frequency, int octaves, float lacunarity, float persistence)
		{
			if (octaves < 2)
			{
				return simplex(x * frequency, y * frequency, z * frequency);
			}
			float num = 0f;
			float num2 = 1f;
			float num3 = 0f;
			for (int i = 0; i < octaves; i++)
			{
				num += simplex(x * frequency, y * frequency, z * frequency) * num2;
				num3 += num2;
				frequency *= lacunarity;
				num2 *= persistence;
			}
			return num / num3;
		}

		public static float perlinUnoptimized(float x, float y, float z)
		{
			int num = floor(x);
			int num2 = floor(y);
			int num3 = floor(z);
			float num4 = x - (float)num;
			float num5 = y - (float)num2;
			float num6 = z - (float)num3;
			float x2 = num4 - 1f;
			float y2 = num5 - 1f;
			float z2 = num6 - 1f;
			int num7 = (num + 1) & 0xFF;
			int num8 = (num2 + 1) & 0xFF;
			int num9 = (num3 + 1) & 0xFF;
			num &= 0xFF;
			num2 &= 0xFF;
			num3 &= 0xFF;
			float t = fade(num6);
			float t2 = fade(num5);
			float t3 = fade(num4);
			float from = grad(perm[num + perm[num2 + perm[num3]]], num4, num5, num6);
			float to = grad(perm[num + perm[num2 + perm[num9]]], num4, num5, z2);
			float from2 = lerp(from, to, t);
			float from3 = grad(perm[num + perm[num8 + perm[num3]]], num4, y2, num6);
			to = grad(perm[num + perm[num8 + perm[num9]]], num4, y2, z2);
			float to2 = lerp(from3, to, t);
			float from4 = lerp(from2, to2, t2);
			float from5 = grad(perm[num7 + perm[num2 + perm[num3]]], x2, num5, num6);
			to = grad(perm[num7 + perm[num2 + perm[num9]]], x2, num5, z2);
			float from6 = lerp(from5, to, t);
			float from7 = grad(perm[num7 + perm[num8 + perm[num3]]], x2, y2, num6);
			to = grad(perm[num7 + perm[num8 + perm[num9]]], x2, y2, z2);
			to2 = lerp(from7, to, t);
			float to3 = lerp(from6, to2, t2);
			return 0.936f * lerp(from4, to3, t3);
		}

		public static float simplexUnoptimized(float x, float y, float z)
		{
			float num = (x + y + z) * F3;
			float x2 = x + num;
			float x3 = y + num;
			float x4 = z + num;
			int num2 = floor(x2);
			int num3 = floor(x3);
			int num4 = floor(x4);
			float num5 = (float)(num2 + num3 + num4) * G3;
			float num6 = (float)num2 - num5;
			float num7 = (float)num3 - num5;
			float num8 = (float)num4 - num5;
			float num9 = x - num6;
			float num10 = y - num7;
			float num11 = z - num8;
			int num12;
			int num13;
			int num14;
			int num15;
			int num16;
			int num17;
			if (num9 >= num10)
			{
				if (num10 >= num11)
				{
					num12 = 1;
					num13 = 0;
					num14 = 0;
					num15 = 1;
					num16 = 1;
					num17 = 0;
				}
				else if (num9 >= num11)
				{
					num12 = 1;
					num13 = 0;
					num14 = 0;
					num15 = 1;
					num16 = 0;
					num17 = 1;
				}
				else
				{
					num12 = 0;
					num13 = 0;
					num14 = 1;
					num15 = 1;
					num16 = 0;
					num17 = 1;
				}
			}
			else if (num10 < num11)
			{
				num12 = 0;
				num13 = 0;
				num14 = 1;
				num15 = 0;
				num16 = 1;
				num17 = 1;
			}
			else if (num9 < num11)
			{
				num12 = 0;
				num13 = 1;
				num14 = 0;
				num15 = 0;
				num16 = 1;
				num17 = 1;
			}
			else
			{
				num12 = 0;
				num13 = 1;
				num14 = 0;
				num15 = 1;
				num16 = 1;
				num17 = 0;
			}
			float num18 = num9 - (float)num12 + G3;
			float num19 = num10 - (float)num13 + G3;
			float num20 = num11 - (float)num14 + G3;
			float num21 = num9 - (float)num15 + 2f * G3;
			float num22 = num10 - (float)num16 + 2f * G3;
			float num23 = num11 - (float)num17 + 2f * G3;
			float num24 = num9 - 1f + 3f * G3;
			float num25 = num10 - 1f + 3f * G3;
			float num26 = num11 - 1f + 3f * G3;
			int num27 = num2 & 0xFF;
			int num28 = num3 & 0xFF;
			int num29 = num4 & 0xFF;
			float num30 = 0.6f - num9 * num9 - num10 * num10 - num11 * num11;
			float num31;
			if (num30 < 0f)
			{
				num31 = 0f;
			}
			else
			{
				num30 *= num30;
				num31 = num30 * num30 * grad(perm[num27 + perm[num28 + perm[num29]]], num9, num10, num11);
			}
			float num32 = 0.6f - num18 * num18 - num19 * num19 - num20 * num20;
			float num33;
			if (num32 < 0f)
			{
				num33 = 0f;
			}
			else
			{
				num32 *= num32;
				num33 = num32 * num32 * grad(perm[num27 + num12 + perm[num28 + num13 + perm[num29 + num14]]], num18, num19, num20);
			}
			float num34 = 0.6f - num21 * num21 - num22 * num22 - num23 * num23;
			float num35;
			if (num34 < 0f)
			{
				num35 = 0f;
			}
			else
			{
				num34 *= num34;
				num35 = num34 * num34 * grad(perm[num27 + num15 + perm[num28 + num16 + perm[num29 + num17]]], num21, num22, num23);
			}
			float num36 = 0.6f - num24 * num24 - num25 * num25 - num26 * num26;
			float num37;
			if (num36 < 0f)
			{
				num37 = 0f;
			}
			else
			{
				num36 *= num36;
				num37 = num36 * num36 * grad(perm[num27 + 1 + perm[num28 + 1 + perm[num29 + 1]]], num24, num25, num26);
			}
			return 32f * (num31 + num33 + num35 + num37);
		}
	}
	public abstract class ParticleForceField : MonoBehaviour
	{
		protected struct GetForceParameters
		{
			public float distanceToForceFieldCenterSqr;

			public Vector3 scaledDirectionToForceFieldCenter;

			public Vector3 particlePosition;
		}

		[Header("Common Controls")]
		[Tooltip("Force field spherical range.")]
		public float radius = float.PositiveInfinity;

		[Tooltip("Maximum baseline force.")]
		public float force = 5f;

		[Tooltip("Internal force field position offset.")]
		public Vector3 center = Vector3.zero;

		private float _radius;

		private float radiusSqr;

		private float forceDeltaTime;

		private Vector3 transformPosition;

		private float[] particleSystemExternalForcesMultipliers;

		[Tooltip("Force scale as determined by distance to individual particles.")]
		public AnimationCurve forceOverDistance = new AnimationCurve(new Keyframe(0f, 1f), new Keyframe(1f, 1f));

		private ParticleSystem particleSystem;

		[Tooltip("If nothing no particle systems are assigned, this force field will operate globally on ALL particle systems in the scene (NOT recommended).\n\nIf attached to a particle system, the force field will operate only on that system.\n\nIf specific particle systems are assigned, then the force field will operate on those systems only, even if attached to a particle system.")]
		public List<ParticleSystem> _particleSystems;

		private int particleSystemsCount;

		private List<ParticleSystem> particleSystems = new List<ParticleSystem>();

		private ParticleSystem.Particle[][] particleSystemParticles;

		private ParticleSystem.MainModule[] particleSystemMainModules;

		private Renderer[] particleSystemRenderers;

		protected ParticleSystem currentParticleSystem;

		protected GetForceParameters parameters;

		[Tooltip("If TRUE, update even if target particle system(s) are invisible/offscreen.\n\nIf FALSE, update only if particles of the target system(s) are visible/onscreen.")]
		public bool alwaysUpdate;

		public float scaledRadius => radius * base.transform.lossyScale.x;

		protected virtual void Awake()
		{
		}

		protected virtual void Start()
		{
			particleSystem = GetComponent<ParticleSystem>();
		}

		protected virtual void PerParticleSystemSetup()
		{
		}

		protected virtual Vector3 GetForce()
		{
			return Vector3.zero;
		}

		protected virtual void Update()
		{
		}

		public void AddParticleSystem(ParticleSystem particleSystem)
		{
			_particleSystems.Add(particleSystem);
		}

		public void RemoveParticleSystem(ParticleSystem particleSystem)
		{
			_particleSystems.Remove(particleSystem);
		}

		protected virtual void LateUpdate()
		{
			_radius = scaledRadius;
			radiusSqr = _radius * _radius;
			forceDeltaTime = force * Time.deltaTime;
			transformPosition = base.transform.position + center;
			if (_particleSystems.Count != 0)
			{
				if (particleSystems.Count != _particleSystems.Count)
				{
					particleSystems.Clear();
					particleSystems.AddRange(_particleSystems);
				}
				else
				{
					for (int i = 0; i < _particleSystems.Count; i++)
					{
						particleSystems[i] = _particleSystems[i];
					}
				}
			}
			else if ((bool)particleSystem)
			{
				if (particleSystems.Count == 1)
				{
					particleSystems[0] = particleSystem;
				}
				else
				{
					particleSystems.Clear();
					particleSystems.Add(particleSystem);
				}
			}
			else
			{
				particleSystems.Clear();
				particleSystems.AddRange(UnityEngine.Object.FindObjectsOfType<ParticleSystem>());
			}
			parameters = default(GetForceParameters);
			particleSystemsCount = particleSystems.Count;
			if (particleSystemParticles == null || particleSystemParticles.Length < particleSystemsCount)
			{
				particleSystemParticles = new ParticleSystem.Particle[particleSystemsCount][];
				particleSystemMainModules = new ParticleSystem.MainModule[particleSystemsCount];
				particleSystemRenderers = new Renderer[particleSystemsCount];
				particleSystemExternalForcesMultipliers = new float[particleSystemsCount];
				for (int j = 0; j < particleSystemsCount; j++)
				{
					particleSystemMainModules[j] = particleSystems[j].main;
					particleSystemRenderers[j] = particleSystems[j].GetComponent<Renderer>();
					particleSystemExternalForcesMultipliers[j] = particleSystems[j].externalForces.multiplier;
				}
			}
			for (int k = 0; k < particleSystemsCount; k++)
			{
				if (!particleSystemRenderers[k].isVisible && !alwaysUpdate)
				{
					continue;
				}
				int maxParticles = particleSystemMainModules[k].maxParticles;
				if (particleSystemParticles[k] == null || particleSystemParticles[k].Length < maxParticles)
				{
					particleSystemParticles[k] = new ParticleSystem.Particle[maxParticles];
				}
				currentParticleSystem = particleSystems[k];
				PerParticleSystemSetup();
				int particles = currentParticleSystem.GetParticles(particleSystemParticles[k]);
				ParticleSystemSimulationSpace simulationSpace = particleSystemMainModules[k].simulationSpace;
				ParticleSystemScalingMode scalingMode = particleSystemMainModules[k].scalingMode;
				Transform transform = currentParticleSystem.transform;
				Transform customSimulationSpace = particleSystemMainModules[k].customSimulationSpace;
				if (simulationSpace == ParticleSystemSimulationSpace.World)
				{
					for (int l = 0; l < particles; l++)
					{
						parameters.particlePosition = particleSystemParticles[k][l].position;
						parameters.scaledDirectionToForceFieldCenter.x = transformPosition.x - parameters.particlePosition.x;
						parameters.scaledDirectionToForceFieldCenter.y = transformPosition.y - parameters.particlePosition.y;
						parameters.scaledDirectionToForceFieldCenter.z = transformPosition.z - parameters.particlePosition.z;
						parameters.distanceToForceFieldCenterSqr = parameters.scaledDirectionToForceFieldCenter.sqrMagnitude;
						if (parameters.distanceToForceFieldCenterSqr < radiusSqr)
						{
							float time = parameters.distanceToForceFieldCenterSqr / radiusSqr;
							float num = forceOverDistance.Evaluate(time);
							Vector3 vector = GetForce();
							float num2 = forceDeltaTime * num * particleSystemExternalForcesMultipliers[k];
							vector.x *= num2;
							vector.y *= num2;
							vector.z *= num2;
							Vector3 velocity = particleSystemParticles[k][l].velocity;
							velocity.x += vector.x;
							velocity.y += vector.y;
							velocity.z += vector.z;
							particleSystemParticles[k][l].velocity = velocity;
						}
					}
				}
				else
				{
					Vector3 zero = Vector3.zero;
					Quaternion identity = Quaternion.identity;
					Vector3 one = Vector3.one;
					Transform transform2 = transform;
					switch (simulationSpace)
					{
					case ParticleSystemSimulationSpace.Local:
						zero = transform2.position;
						identity = transform2.rotation;
						one = transform2.localScale;
						break;
					case ParticleSystemSimulationSpace.Custom:
						transform2 = customSimulationSpace;
						zero = transform2.position;
						identity = transform2.rotation;
						one = transform2.localScale;
						break;
					default:
						throw new NotSupportedException($"Unsupported scaling mode '{simulationSpace}'.");
					}
					for (int m = 0; m < particles; m++)
					{
						parameters.particlePosition = particleSystemParticles[k][m].position;
						if (simulationSpace == ParticleSystemSimulationSpace.Local || simulationSpace == ParticleSystemSimulationSpace.Custom)
						{
							switch (scalingMode)
							{
							case ParticleSystemScalingMode.Hierarchy:
								parameters.particlePosition = transform2.TransformPoint(particleSystemParticles[k][m].position);
								break;
							case ParticleSystemScalingMode.Local:
								parameters.particlePosition = Vector3.Scale(parameters.particlePosition, one);
								parameters.particlePosition = identity * parameters.particlePosition;
								parameters.particlePosition += zero;
								break;
							case ParticleSystemScalingMode.Shape:
								parameters.particlePosition = identity * parameters.particlePosition;
								parameters.particlePosition += zero;
								break;
							default:
								throw new NotSupportedException($"Unsupported scaling mode '{scalingMode}'.");
							}
						}
						parameters.scaledDirectionToForceFieldCenter.x = transformPosition.x - parameters.particlePosition.x;
						parameters.scaledDirectionToForceFieldCenter.y = transformPosition.y - parameters.particlePosition.y;
						parameters.scaledDirectionToForceFieldCenter.z = transformPosition.z - parameters.particlePosition.z;
						parameters.distanceToForceFieldCenterSqr = parameters.scaledDirectionToForceFieldCenter.sqrMagnitude;
						if (!(parameters.distanceToForceFieldCenterSqr < radiusSqr))
						{
							continue;
						}
						float time2 = parameters.distanceToForceFieldCenterSqr / radiusSqr;
						float num3 = forceOverDistance.Evaluate(time2);
						Vector3 vector2 = GetForce();
						float num4 = forceDeltaTime * num3 * particleSystemExternalForcesMultipliers[k];
						vector2.x *= num4;
						vector2.y *= num4;
						vector2.z *= num4;
						if (simulationSpace == ParticleSystemSimulationSpace.Local || simulationSpace == ParticleSystemSimulationSpace.Custom)
						{
							switch (scalingMode)
							{
							case ParticleSystemScalingMode.Hierarchy:
								vector2 = transform2.InverseTransformVector(vector2);
								break;
							case ParticleSystemScalingMode.Local:
								vector2 = Quaternion.Inverse(identity) * vector2;
								vector2 = Vector3.Scale(vector2, new Vector3(1f / one.x, 1f / one.y, 1f / one.z));
								break;
							case ParticleSystemScalingMode.Shape:
								vector2 = Quaternion.Inverse(identity) * vector2;
								break;
							default:
								throw new NotSupportedException($"Unsupported scaling mode '{scalingMode}'.");
							}
						}
						Vector3 velocity2 = particleSystemParticles[k][m].velocity;
						velocity2.x += vector2.x;
						velocity2.y += vector2.y;
						velocity2.z += vector2.z;
						particleSystemParticles[k][m].velocity = velocity2;
					}
				}
				currentParticleSystem.SetParticles(particleSystemParticles[k], particles);
			}
		}

		private void OnApplicationQuit()
		{
		}

		protected virtual void OnDrawGizmosSelected()
		{
			Gizmos.color = Color.green;
			Gizmos.DrawWireSphere(base.transform.position + center, scaledRadius);
		}
	}
	[AddComponentMenu("Effects/Particle Force Fields/Turbulence Particle Force Field")]
	public class TurbulenceParticleForceField : ParticleForceField
	{
		public enum NoiseType
		{
			PseudoPerlin,
			Perlin,
			Simplex,
			OctavePerlin,
			OctaveSimplex
		}

		[Header("ForceField Controls")]
		[Tooltip("Noise texture mutation speed.")]
		public float scrollSpeed = 1f;

		[Range(0f, 8f)]
		[Tooltip("Noise texture detail amplifier.")]
		public float frequency = 1f;

		public NoiseType noiseType = NoiseType.Perlin;

		[Header("Octave Variant-Only Controls")]
		[Range(1f, 8f)]
		[Tooltip("Overlapping noise iterations. 1 = no additional iterations.")]
		public int octaves = 1;

		[Range(0f, 4f)]
		[Tooltip("Frequency scale per-octave. Can be used to change the overlap every iteration.")]
		public float octaveMultiplier = 0.5f;

		[Range(0f, 1f)]
		[Tooltip("Amplitude scale per-octave. Can be used to change the overlap every iteration.")]
		public float octaveScale = 2f;

		private float time;

		private float randomX;

		private float randomY;

		private float randomZ;

		private float offsetX;

		private float offsetY;

		private float offsetZ;

		protected override void Awake()
		{
			base.Awake();
		}

		protected override void Start()
		{
			base.Start();
			randomX = UnityEngine.Random.Range(-32f, 32f);
			randomY = UnityEngine.Random.Range(-32f, 32f);
			randomZ = UnityEngine.Random.Range(-32f, 32f);
		}

		protected override void Update()
		{
			time = Time.time;
			base.Update();
		}

		protected override void LateUpdate()
		{
			offsetX = time * scrollSpeed + randomX;
			offsetY = time * scrollSpeed + randomY;
			offsetZ = time * scrollSpeed + randomZ;
			base.LateUpdate();
		}

		protected override Vector3 GetForce()
		{
			float num = parameters.particlePosition.x + offsetX;
			float num2 = parameters.particlePosition.y + offsetX;
			float num3 = parameters.particlePosition.z + offsetX;
			float num4 = parameters.particlePosition.x + offsetY;
			float num5 = parameters.particlePosition.y + offsetY;
			float num6 = parameters.particlePosition.z + offsetY;
			float num7 = parameters.particlePosition.x + offsetZ;
			float num8 = parameters.particlePosition.y + offsetZ;
			float num9 = parameters.particlePosition.z + offsetZ;
			Vector3 result = default(Vector3);
			switch (noiseType)
			{
			case NoiseType.PseudoPerlin:
			{
				float t = Mathf.PerlinNoise(num * frequency, num5 * frequency);
				float t2 = Mathf.PerlinNoise(num * frequency, num6 * frequency);
				float t3 = Mathf.PerlinNoise(num * frequency, num4 * frequency);
				t = Mathf.Lerp(-1f, 1f, t);
				t2 = Mathf.Lerp(-1f, 1f, t2);
				t3 = Mathf.Lerp(-1f, 1f, t3);
				Vector3 vector = Vector3.right * t;
				Vector3 vector2 = Vector3.up * t2;
				Vector3 vector3 = Vector3.forward * t3;
				return vector + vector2 + vector3;
			}
			default:
				result.x = Noise2.perlin(num * frequency, num2 * frequency, num3 * frequency);
				result.y = Noise2.perlin(num4 * frequency, num5 * frequency, num6 * frequency);
				result.z = Noise2.perlin(num7 * frequency, num8 * frequency, num9 * frequency);
				return result;
			case NoiseType.Simplex:
				result.x = Noise2.simplex(num * frequency, num2 * frequency, num3 * frequency);
				result.y = Noise2.simplex(num4 * frequency, num5 * frequency, num6 * frequency);
				result.z = Noise2.simplex(num7 * frequency, num8 * frequency, num9 * frequency);
				break;
			case NoiseType.OctavePerlin:
				result.x = Noise2.octavePerlin(num, num2, num3, frequency, octaves, octaveMultiplier, octaveScale);
				result.y = Noise2.octavePerlin(num4, num5, num6, frequency, octaves, octaveMultiplier, octaveScale);
				result.z = Noise2.octavePerlin(num7, num8, num9, frequency, octaves, octaveMultiplier, octaveScale);
				break;
			case NoiseType.OctaveSimplex:
				result.x = Noise2.octaveSimplex(num, num2, num3, frequency, octaves, octaveMultiplier, octaveScale);
				result.y = Noise2.octaveSimplex(num4, num5, num6, frequency, octaves, octaveMultiplier, octaveScale);
				result.z = Noise2.octaveSimplex(num7, num8, num9, frequency, octaves, octaveMultiplier, octaveScale);
				break;
			}
			return result;
		}

		protected override void OnDrawGizmosSelected()
		{
			if (base.enabled)
			{
				base.OnDrawGizmosSelected();
			}
		}
	}
	[AddComponentMenu("Effects/Particle Force Fields/Vortex Particle Force Field")]
	public class VortexParticleForceField : ParticleForceField
	{
		private Vector3 axisOfRotation;

		[Header("ForceField Controls")]
		[Tooltip("Internal offset for the axis of rotation.\n\nUseful if the force field and particle system are on the same game object, and you need a seperate rotation for the system, and the affector, but don't want to make the two different game objects.")]
		public Vector3 axisOfRotationOffset = Vector3.zero;

		protected override void Awake()
		{
			base.Awake();
		}

		protected override void Start()
		{
			base.Start();
		}

		protected override void Update()
		{
			base.Update();
		}

		protected override void LateUpdate()
		{
			base.LateUpdate();
		}

		private void UpdateAxisOfRotation()
		{
			axisOfRotation = Quaternion.Euler(axisOfRotationOffset) * base.transform.up;
		}

		protected override void PerParticleSystemSetup()
		{
			UpdateAxisOfRotation();
		}

		protected override Vector3 GetForce()
		{
			return Vector3.Normalize(Vector3.Cross(axisOfRotation, parameters.scaledDirectionToForceFieldCenter));
		}

		protected override void OnDrawGizmosSelected()
		{
			if (base.enabled)
			{
				base.OnDrawGizmosSelected();
				Gizmos.color = Color.red;
				Vector3 vector;
				if (UnityEngine.Application.isPlaying && base.enabled)
				{
					UpdateAxisOfRotation();
					vector = axisOfRotation;
				}
				else
				{
					vector = Quaternion.Euler(axisOfRotationOffset) * base.transform.up;
				}
				Vector3 vector2 = base.transform.position + center;
				Gizmos.DrawLine(vector2, vector2 + vector * base.scaledRadius);
			}
		}
	}
	[Serializable]
	[RequireComponent(typeof(ParticleSystem))]
	public class ParticleLights : MonoBehaviour
	{
		private ParticleSystem ps;

		private List<Light> lights = new List<Light>();

		public float scale = 2f;

		[Range(0f, 8f)]
		public float intensity = 8f;

		public Color colour = Color.white;

		[Range(0f, 1f)]
		public float colourFromParticle = 1f;

		public LightShadows shadows;

		private GameObject template;

		private void Awake()
		{
		}

		private void Start()
		{
			ps = GetComponent<ParticleSystem>();
			template = new GameObject();
			template.transform.SetParent(base.transform);
			template.name = "Template";
		}

		private void Update()
		{
		}

		private void LateUpdate()
		{
			ParticleSystem.Particle[] array = new ParticleSystem.Particle[ps.particleCount];
			int particles = ps.GetParticles(array);
			if (lights.Count != particles)
			{
				for (int i = 0; i < lights.Count; i++)
				{
					UnityEngine.Object.Destroy(lights[i].gameObject);
				}
				lights.Clear();
				for (int j = 0; j < particles; j++)
				{
					GameObject gameObject = UnityEngine.Object.Instantiate(template, base.transform);
					gameObject.name = "- " + (j + 1);
					lights.Add(gameObject.AddComponent<Light>());
				}
			}
			bool flag = ps.main.simulationSpace == ParticleSystemSimulationSpace.World;
			for (int k = 0; k < particles; k++)
			{
				ParticleSystem.Particle particle = array[k];
				Light light = lights[k];
				light.range = particle.GetCurrentSize(ps) * scale;
				light.color = Color.Lerp(colour, particle.GetCurrentColor(ps), colourFromParticle);
				light.intensity = intensity;
				light.shadows = shadows;
				light.transform.position = (flag ? particle.position : ps.transform.TransformPoint(particle.position));
			}
		}
	}
	[RequireComponent(typeof(ParticleSystem))]
	[AddComponentMenu("Effects/Particle Plexus")]
	public class ParticlePlexus : MonoBehaviour
	{
		public float maxDistance = 1f;

		public int maxConnections = 5;

		public int maxLineRenderers = 100;

		[Range(0f, 1f)]
		public float widthFromParticle = 0.125f;

		[Range(0f, 1f)]
		public float colourFromParticle = 1f;

		[Range(0f, 1f)]
		public float alphaFromParticle = 1f;

		private ParticleSystem particleSystem;

		private ParticleSystem.Particle[] particles;

		private Vector3[] particlePositions;

		private Color[] particleColours;

		private float[] particleSizes;

		private ParticleSystem.MainModule particleSystemMainModule;

		public LineRenderer lineRendererTemplate;

		private List<LineRenderer> lineRenderers = new List<LineRenderer>();

		private Transform _transform;

		[Header("General Performance Settings")]
		[Range(0f, 1f)]
		public float delay;

		private float timer;

		public bool alwaysUpdate;

		private bool visible;

		private void Start()
		{
			particleSystem = GetComponent<ParticleSystem>();
			particleSystemMainModule = particleSystem.main;
			_transform = base.transform;
		}

		private void OnDisable()
		{
			for (int i = 0; i < lineRenderers.Count; i++)
			{
				lineRenderers[i].enabled = false;
			}
		}

		private void OnBecameVisible()
		{
			visible = true;
		}

		private void OnBecameInvisible()
		{
			visible = false;
		}

		private void LateUpdate()
		{
			int num = lineRenderers.Count;
			if (num > maxLineRenderers)
			{
				for (int i = maxLineRenderers; i < num; i++)
				{
					UnityEngine.Object.Destroy(lineRenderers[i].gameObject);
				}
				lineRenderers.RemoveRange(maxLineRenderers, num - maxLineRenderers);
				num -= num - maxLineRenderers;
			}
			if (!alwaysUpdate && !visible)
			{
				return;
			}
			int maxParticles = particleSystemMainModule.maxParticles;
			if (particles == null || particles.Length < maxParticles)
			{
				particles = new ParticleSystem.Particle[maxParticles];
				particlePositions = new Vector3[maxParticles];
				particleColours = new Color[maxParticles];
				particleSizes = new float[maxParticles];
			}
			timer += Time.deltaTime;
			if (!(timer >= delay))
			{
				return;
			}
			timer = 0f;
			int num2 = 0;
			if (maxConnections > 0 && maxLineRenderers > 0)
			{
				particleSystem.GetParticles(particles);
				int particleCount = particleSystem.particleCount;
				float num3 = maxDistance * maxDistance;
				ParticleSystemSimulationSpace simulationSpace = particleSystemMainModule.simulationSpace;
				ParticleSystemScalingMode scalingMode = particleSystemMainModule.scalingMode;
				Transform customSimulationSpace = particleSystemMainModule.customSimulationSpace;
				Color startColor = lineRendererTemplate.startColor;
				Color endColor = lineRendererTemplate.endColor;
				float a = lineRendererTemplate.startWidth * lineRendererTemplate.widthMultiplier;
				float a2 = lineRendererTemplate.endWidth * lineRendererTemplate.widthMultiplier;
				for (int j = 0; j < particleCount; j++)
				{
					particlePositions[j] = particles[j].position;
					particleColours[j] = particles[j].GetCurrentColor(particleSystem);
					particleSizes[j] = particles[j].GetCurrentSize(particleSystem);
				}
				Vector3 vector = default(Vector3);
				if (simulationSpace == ParticleSystemSimulationSpace.World)
				{
					for (int k = 0; k < particleCount; k++)
					{
						if (num2 == maxLineRenderers)
						{
							break;
						}
						Color b = particleColours[k];
						Color startColor2 = Color.LerpUnclamped(startColor, b, colourFromParticle);
						startColor2.a = Mathf.LerpUnclamped(startColor.a, b.a, alphaFromParticle);
						float startWidth = Mathf.LerpUnclamped(a, particleSizes[k], widthFromParticle);
						int num4 = 0;
						for (int l = k + 1; l < particleCount; l++)
						{
							vector.x = particlePositions[k].x - particlePositions[l].x;
							vector.y = particlePositions[k].y - particlePositions[l].y;
							vector.z = particlePositions[k].z - particlePositions[l].z;
							if (vector.x * vector.x + vector.y * vector.y + vector.z * vector.z <= num3)
							{
								LineRenderer item;
								if (num2 == num)
								{
									item = UnityEngine.Object.Instantiate(lineRendererTemplate, _transform, worldPositionStays: false);
									lineRenderers.Add(item);
									num++;
								}
								item = lineRenderers[num2];
								item.enabled = true;
								item.SetPosition(0, particlePositions[k]);
								item.SetPosition(1, particlePositions[l]);
								item.startColor = startColor2;
								b = particleColours[l];
								Color endColor2 = Color.LerpUnclamped(endColor, b, colourFromParticle);
								endColor2.a = Mathf.LerpUnclamped(endColor.a, b.a, alphaFromParticle);
								item.endColor = endColor2;
								item.startWidth = startWidth;
								item.endWidth = Mathf.LerpUnclamped(a2, particleSizes[l], widthFromParticle);
								num2++;
								num4++;
								if (num4 == maxConnections || num2 == maxLineRenderers)
								{
									break;
								}
							}
						}
					}
				}
				else
				{
					Vector3 zero = Vector3.zero;
					Quaternion identity = Quaternion.identity;
					Vector3 one = Vector3.one;
					Transform transform = _transform;
					switch (simulationSpace)
					{
					case ParticleSystemSimulationSpace.Local:
						zero = transform.position;
						identity = transform.rotation;
						one = transform.localScale;
						break;
					case ParticleSystemSimulationSpace.Custom:
						transform = customSimulationSpace;
						zero = transform.position;
						identity = transform.rotation;
						one = transform.localScale;
						break;
					default:
						throw new NotSupportedException($"Unsupported scaling mode '{simulationSpace}'.");
					}
					Vector3 vector2 = Vector3.zero;
					Vector3 vector3 = Vector3.zero;
					for (int m = 0; m < particleCount; m++)
					{
						if (num2 == maxLineRenderers)
						{
							break;
						}
						if (simulationSpace == ParticleSystemSimulationSpace.Local || simulationSpace == ParticleSystemSimulationSpace.Custom)
						{
							switch (scalingMode)
							{
							case ParticleSystemScalingMode.Hierarchy:
								vector2 = transform.TransformPoint(particlePositions[m]);
								break;
							case ParticleSystemScalingMode.Local:
								vector2.x = particlePositions[m].x * one.x;
								vector2.y = particlePositions[m].y * one.y;
								vector2.z = particlePositions[m].z * one.z;
								vector2 = identity * vector2;
								vector2.x += zero.x;
								vector2.y += zero.y;
								vector2.z += zero.z;
								break;
							case ParticleSystemScalingMode.Shape:
								vector2 = identity * particlePositions[m];
								vector2.x += zero.x;
								vector2.y += zero.y;
								vector2.z += zero.z;
								break;
							default:
								throw new NotSupportedException($"Unsupported scaling mode '{scalingMode}'.");
							}
						}
						Color b2 = particleColours[m];
						Color startColor3 = Color.LerpUnclamped(startColor, b2, colourFromParticle);
						startColor3.a = Mathf.LerpUnclamped(startColor.a, b2.a, alphaFromParticle);
						float startWidth2 = Mathf.LerpUnclamped(a, particleSizes[m], widthFromParticle);
						int num5 = 0;
						for (int n = m + 1; n < particleCount; n++)
						{
							if (simulationSpace == ParticleSystemSimulationSpace.Local || simulationSpace == ParticleSystemSimulationSpace.Custom)
							{
								switch (scalingMode)
								{
								case ParticleSystemScalingMode.Hierarchy:
									vector3 = transform.TransformPoint(particlePositions[n]);
									break;
								case ParticleSystemScalingMode.Local:
									vector3.x = particlePositions[n].x * one.x;
									vector3.y = particlePositions[n].y * one.y;
									vector3.z = particlePositions[n].z * one.z;
									vector3 = identity * vector3;
									vector3.x += zero.x;
									vector3.y += zero.y;
									vector3.z += zero.z;
									break;
								case ParticleSystemScalingMode.Shape:
									vector3 = identity * particlePositions[n];
									vector3.x += zero.x;
									vector3.y += zero.y;
									vector3.z += zero.z;
									break;
								default:
									throw new NotSupportedException($"Unsupported scaling mode '{scalingMode}'.");
								}
							}
							vector.x = particlePositions[m].x - particlePositions[n].x;
							vector.y = particlePositions[m].y - particlePositions[n].y;
							vector.z = particlePositions[m].z - particlePositions[n].z;
							if (vector.x * vector.x + vector.y * vector.y + vector.z * vector.z <= num3)
							{
								LineRenderer item2;
								if (num2 == num)
								{
									item2 = UnityEngine.Object.Instantiate(lineRendererTemplate, _transform, worldPositionStays: false);
									lineRenderers.Add(item2);
									num++;
								}
								item2 = lineRenderers[num2];
								item2.enabled = true;
								item2.SetPosition(0, vector2);
								item2.SetPosition(1, vector3);
								item2.startColor = startColor3;
								b2 = particleColours[n];
								Color endColor3 = Color.LerpUnclamped(endColor, b2, colourFromParticle);
								endColor3.a = Mathf.LerpUnclamped(endColor.a, b2.a, alphaFromParticle);
								item2.endColor = endColor3;
								item2.startWidth = startWidth2;
								item2.endWidth = Mathf.LerpUnclamped(a2, particleSizes[n], widthFromParticle);
								num2++;
								num5++;
								if (num5 == maxConnections || num2 == maxLineRenderers)
								{
									break;
								}
							}
						}
					}
				}
			}
			for (int num6 = num2; num6 < num; num6++)
			{
				if (lineRenderers[num6].enabled)
				{
					lineRenderers[num6].enabled = false;
				}
			}
		}
	}
	public static class CreateLUT
	{
		public static void fromGradient(int steps, Gradient gradient, ref Texture2D texture)
		{
			if ((bool)texture)
			{
				UnityEngine.Object.Destroy(texture);
			}
			texture = new Texture2D(steps, 1);
			texture.SetPixel(0, 0, gradient.Evaluate(0f));
			texture.SetPixel(steps - 1, 0, gradient.Evaluate(1f));
			for (int i = 1; i < steps - 1; i++)
			{
				Color color = gradient.Evaluate((float)i / (float)steps);
				texture.SetPixel(i, 0, color);
			}
			texture.Apply();
		}

		public static void fromAnimationCurve(int steps, AnimationCurve curve, ref Texture2D texture)
		{
			if ((bool)texture)
			{
				UnityEngine.Object.Destroy(texture);
			}
			texture = new Texture2D(steps, 1);
			texture.SetPixel(0, 0, new Color(0f, 0f, 0f, curve.Evaluate(0f)));
			texture.SetPixel(steps - 1, 0, new Color(0f, 0f, 0f, curve.Evaluate(1f)));
			for (int i = 1; i < steps - 1; i++)
			{
				float a = curve.Evaluate((float)i / (float)steps);
				texture.SetPixel(i, 0, new Color(0f, 0f, 0f, a));
			}
			texture.Apply();
		}
	}
}
namespace MirzaBeig.ParticleSystems
{
	[RequireComponent(typeof(Light))]
	public class AnimatedLight : MonoBehaviour
	{
		private Light light;

		public float duration = 1f;

		private bool evaluating = true;

		public Gradient colourOverLifetime;

		public AnimationCurve intensityOverLifetime = new AnimationCurve(new Keyframe(0f, 0f), new Keyframe(0.5f, 1f), new Keyframe(1f, 0f));

		public bool loop = true;

		public bool autoDestruct;

		private Color startColour;

		private float startIntensity;

		public float time { get; set; }

		private void Awake()
		{
			light = GetComponent<Light>();
		}

		private void Start()
		{
			startColour = light.color;
			startIntensity = light.intensity;
			light.color = startColour * colourOverLifetime.Evaluate(0f);
			light.intensity = startIntensity * intensityOverLifetime.Evaluate(0f);
		}

		private void OnEnable()
		{
		}

		private void OnDisable()
		{
			light.color = startColour;
			light.intensity = startIntensity;
			time = 0f;
			evaluating = true;
			light.color = startColour * colourOverLifetime.Evaluate(0f);
			light.intensity = startIntensity * intensityOverLifetime.Evaluate(0f);
		}

		private void Update()
		{
			if (!evaluating)
			{
				return;
			}
			if (time < duration)
			{
				time += Time.deltaTime;
				if (time > duration)
				{
					if (autoDestruct)
					{
						UnityEngine.Object.Destroy(base.gameObject);
					}
					else if (loop)
					{
						time = 0f;
					}
					else
					{
						time = duration;
						evaluating = false;
					}
				}
			}
			if (time <= duration)
			{
				float num = time / duration;
				light.color = startColour * colourOverLifetime.Evaluate(num);
				light.intensity = startIntensity * intensityOverLifetime.Evaluate(num);
			}
		}
	}
	public class Billboard : MonoBehaviour
	{
		private void LateUpdate()
		{
			base.transform.LookAt(Camera.main.transform.position);
		}
	}
	public class DestroyAfterTime : MonoBehaviour
	{
		public float time = 2f;

		private void Start()
		{
			UnityEngine.Object.Destroy(base.gameObject, time);
		}
	}
	public class DestroyOnParticlesDead : ParticleSystems
	{
		protected override void Awake()
		{
			base.Awake();
		}

		protected override void Start()
		{
			base.Start();
			base.onParticleSystemsDeadEvent += onParticleSystemsDead;
		}

		private void onParticleSystemsDead()
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}

		protected override void Update()
		{
			base.Update();
		}

		protected override void LateUpdate()
		{
			base.LateUpdate();
		}
	}
	public class DestroyOnTrailsDestroyed : TrailRenderers
	{
		protected override void Awake()
		{
			base.Awake();
		}

		protected override void Start()
		{
			base.Start();
		}

		protected override void Update()
		{
			base.Update();
			bool flag = true;
			for (int i = 0; i < trailRenderers.Length; i++)
			{
				if (trailRenderers[i] != null)
				{
					flag = false;
					break;
				}
			}
			if (flag)
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
		}
	}
	public class IgnoreTimeScale : MonoBehaviour
	{
		private ParticleSystem particleSystem;

		private void Awake()
		{
		}

		private void Start()
		{
			particleSystem = GetComponent<ParticleSystem>();
		}

		private void Update()
		{
			particleSystem.Simulate(Time.unscaledDeltaTime, withChildren: true, restart: false);
		}
	}
	public class ParticleSystems : MonoBehaviour
	{
		public delegate void onParticleSystemsDeadEventHandler();

		public ParticleSystem[] particleSystems { get; set; }

		public event onParticleSystemsDeadEventHandler onParticleSystemsDeadEvent;

		protected virtual void Awake()
		{
			particleSystems = GetComponentsInChildren<ParticleSystem>();
		}

		protected virtual void Start()
		{
		}

		protected virtual void Update()
		{
		}

		protected virtual void LateUpdate()
		{
			if (this.onParticleSystemsDeadEvent != null && !isAlive())
			{
				this.onParticleSystemsDeadEvent();
			}
		}

		public void reset()
		{
			for (int i = 0; i < particleSystems.Length; i++)
			{
				particleSystems[i].time = 0f;
			}
		}

		public void play()
		{
			for (int i = 0; i < particleSystems.Length; i++)
			{
				particleSystems[i].Play(withChildren: false);
			}
		}

		public void pause()
		{
			for (int i = 0; i < particleSystems.Length; i++)
			{
				particleSystems[i].Pause(withChildren: false);
			}
		}

		public void stop()
		{
			for (int i = 0; i < particleSystems.Length; i++)
			{
				particleSystems[i].Stop(withChildren: false);
			}
		}

		public void clear()
		{
			for (int i = 0; i < particleSystems.Length; i++)
			{
				particleSystems[i].Clear(withChildren: false);
			}
		}

		public void setLoop(bool loop)
		{
			for (int i = 0; i < particleSystems.Length; i++)
			{
				ParticleSystem.MainModule main = particleSystems[i].main;
				main.loop = loop;
			}
		}

		public void setPlaybackSpeed(float speed)
		{
			for (int i = 0; i < particleSystems.Length; i++)
			{
				ParticleSystem.MainModule main = particleSystems[i].main;
				main.simulationSpeed = speed;
			}
		}

		public void simulate(float time, bool reset = false)
		{
			for (int i = 0; i < particleSystems.Length; i++)
			{
				particleSystems[i].Simulate(time, withChildren: false, reset);
			}
		}

		public bool isAlive()
		{
			for (int i = 0; i < particleSystems.Length; i++)
			{
				if ((bool)particleSystems[i] && particleSystems[i].IsAlive())
				{
					return true;
				}
			}
			return false;
		}

		public bool isPlaying(bool checkAll = false)
		{
			if (particleSystems.Length == 0)
			{
				return false;
			}
			if (!checkAll)
			{
				return particleSystems[0].isPlaying;
			}
			for (int i = 0; i < 0; i++)
			{
				if (!particleSystems[i].isPlaying)
				{
					return false;
				}
			}
			return true;
		}

		public int getParticleCount()
		{
			int num = 0;
			for (int i = 0; i < particleSystems.Length; i++)
			{
				if ((bool)particleSystems[i])
				{
					num += particleSystems[i].particleCount;
				}
			}
			return num;
		}
	}
	public class ParticleSystemsSimulationSpeed : ParticleSystems
	{
		public float speed = 1f;

		protected override void Awake()
		{
			base.Awake();
		}

		protected override void Start()
		{
			base.Start();
		}

		protected override void Update()
		{
			base.Update();
			setPlaybackSpeed(speed);
		}

		protected override void LateUpdate()
		{
			base.LateUpdate();
		}
	}
	[Serializable]
	public class PerlinNoise
	{
		private Vector2 offset;

		public float amplitude = 1f;

		public float frequency = 1f;

		public bool unscaledTime;

		public void init()
		{
			offset.x = UnityEngine.Random.Range(-32f, 32f);
			offset.y = UnityEngine.Random.Range(-32f, 32f);
		}

		public float GetValue(float time)
		{
			float num = time * frequency;
			return (Mathf.PerlinNoise(num + offset.x, num + offset.y) - 0.5f) * amplitude;
		}
	}
	[Serializable]
	public class PerlinNoiseXYZ
	{
		public PerlinNoise x;

		public PerlinNoise y;

		public PerlinNoise z;

		public bool unscaledTime;

		public float amplitudeScale = 1f;

		public float frequencyScale = 1f;

		public void init()
		{
			x.init();
			y.init();
			z.init();
		}

		public Vector3 GetXYZ(float time)
		{
			float time2 = time * frequencyScale;
			return new Vector3(x.GetValue(time2), y.GetValue(time2), z.GetValue(time2)) * amplitudeScale;
		}
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(Renderer))]
	public class RendererSortingOrder : MonoBehaviour
	{
		public int sortingOrder;

		private void Awake()
		{
		}

		private void Start()
		{
			GetComponent<Renderer>().sortingOrder = sortingOrder;
		}

		private void Update()
		{
		}
	}
	public class Rotator : MonoBehaviour
	{
		public Vector3 localRotationSpeed;

		public Vector3 worldRotationSpeed;

		public bool executeInEditMode;

		public bool unscaledTime;

		private void Awake()
		{
		}

		private void Start()
		{
		}

		private void OnRenderObject()
		{
			if (executeInEditMode && !UnityEngine.Application.isPlaying)
			{
				rotate();
			}
		}

		private void Update()
		{
			if (UnityEngine.Application.isPlaying)
			{
				rotate();
			}
		}

		private void rotate()
		{
			float num = ((!unscaledTime) ? Time.deltaTime : Time.unscaledDeltaTime);
			if (localRotationSpeed != Vector3.zero)
			{
				base.transform.Rotate(localRotationSpeed * num, Space.Self);
			}
			if (worldRotationSpeed != Vector3.zero)
			{
				base.transform.Rotate(worldRotationSpeed * num, Space.World);
			}
		}
	}
	public class TrailRenderers : MonoBehaviour
	{
		[HideInInspector]
		public TrailRenderer[] trailRenderers;

		protected virtual void Awake()
		{
		}

		protected virtual void Start()
		{
			trailRenderers = GetComponentsInChildren<TrailRenderer>();
		}

		protected virtual void Update()
		{
		}

		public void setAutoDestruct(bool value)
		{
			for (int i = 0; i < trailRenderers.Length; i++)
			{
				trailRenderers[i].autodestruct = value;
			}
		}
	}
	public class TransformNoise : MonoBehaviour
	{
		public PerlinNoiseXYZ positionNoise;

		public PerlinNoiseXYZ rotationNoise;

		public bool unscaledTime;

		private float time;

		private void Start()
		{
			positionNoise.init();
			rotationNoise.init();
		}

		private void Update()
		{
			time = ((!unscaledTime) ? Time.time : Time.unscaledTime);
			base.transform.localPosition = positionNoise.GetXYZ(time);
			base.transform.localEulerAngles = rotationNoise.GetXYZ(time);
		}
	}
}
namespace MirzaBeig.ParticleSystems.Demos
{
	[Serializable]
	public class DemoManager_XPTitles : MonoBehaviour
	{
		private LoopingParticleSystemsManager list;

		public Text particleCountText;

		public Text currentParticleSystemText;

		private Rotator cameraRotator;

		private void Awake()
		{
			(list = GetComponent<LoopingParticleSystemsManager>()).Init();
		}

		private void Start()
		{
			cameraRotator = Camera.main.GetComponentInParent<Rotator>();
			updateCurrentParticleSystemNameText();
		}

		public void ToggleRotation()
		{
			cameraRotator.enabled = !cameraRotator.enabled;
		}

		public void ResetRotation()
		{
			cameraRotator.transform.eulerAngles = Vector3.zero;
		}

		private void Update()
		{
			if (Input.GetAxis("Mouse ScrollWheel") < 0f)
			{
				Next();
			}
			else if (Input.GetAxis("Mouse ScrollWheel") > 0f)
			{
				previous();
			}
		}

		private void LateUpdate()
		{
			if ((bool)particleCountText)
			{
				particleCountText.text = "PARTICLE COUNT: ";
				particleCountText.text += list.GetParticleCount();
			}
		}

		public void Next()
		{
			list.Next();
			updateCurrentParticleSystemNameText();
		}

		public void previous()
		{
			list.Previous();
			updateCurrentParticleSystemNameText();
		}

		private void updateCurrentParticleSystemNameText()
		{
			if ((bool)currentParticleSystemText)
			{
				currentParticleSystemText.text = list.GetCurrentPrefabName(shorten: true);
			}
		}
	}
	public enum CameraShakeTarget
	{
		Position,
		Rotation
	}
	public enum CameraShakeAmplitudeCurve
	{
		Constant,
		FadeInOut25,
		FadeInOut50,
		FadeInOut75
	}
	public enum CameraShakeAmplitudeOverDistanceCurve
	{
		Constant,
		LinearFadeIn,
		LinearFadeOut
	}
	public class CameraShake : MonoBehaviour
	{
		[Serializable]
		public class Shake
		{
			public float amplitude = 1f;

			public float frequency = 1f;

			public float duration;

			[HideInInspector]
			public CameraShakeTarget target;

			private float timeRemaining;

			private Vector2 perlinNoiseX;

			private Vector2 perlinNoiseY;

			private Vector2 perlinNoiseZ;

			[HideInInspector]
			public Vector3 noise;

			public AnimationCurve amplitudeOverLifetimeCurve = new AnimationCurve(new Keyframe(0f, 1f), new Keyframe(1f, 0f));

			public void Init()
			{
				timeRemaining = duration;
				ApplyRandomSeed();
			}

			private void Init(float amplitude, float frequency, float duration, CameraShakeTarget target)
			{
				this.amplitude = amplitude;
				this.frequency = frequency;
				this.duration = duration;
				timeRemaining = duration;
				this.target = target;
				ApplyRandomSeed();
			}

			public void ApplyRandomSeed()
			{
				float num = 32f;
				perlinNoiseX.x = UnityEngine.Random.Range(0f - num, num);
				perlinNoiseX.y = UnityEngine.Random.Range(0f - num, num);
				perlinNoiseY.x = UnityEngine.Random.Range(0f - num, num);
				perlinNoiseY.y = UnityEngine.Random.Range(0f - num, num);
				perlinNoiseZ.x = UnityEngine.Random.Range(0f - num, num);
				perlinNoiseZ.y = UnityEngine.Random.Range(0f - num, num);
			}

			public Shake(float amplitude, float frequency, float duration, CameraShakeTarget target, AnimationCurve amplitudeOverLifetimeCurve)
			{
				Init(amplitude, frequency, duration, target);
				this.amplitudeOverLifetimeCurve = amplitudeOverLifetimeCurve;
			}

			public Shake(float amplitude, float frequency, float duration, CameraShakeTarget target, CameraShakeAmplitudeCurve amplitudeOverLifetimeCurve)
			{
				Init(amplitude, frequency, duration, target);
				switch (amplitudeOverLifetimeCurve)
				{
				case CameraShakeAmplitudeCurve.Constant:
					this.amplitudeOverLifetimeCurve = AnimationCurve.Linear(0f, 1f, 1f, 1f);
					break;
				case CameraShakeAmplitudeCurve.FadeInOut25:
					this.amplitudeOverLifetimeCurve = new AnimationCurve(new Keyframe(0f, 0f), new Keyframe(0.25f, 1f), new Keyframe(1f, 0f));
					break;
				case CameraShakeAmplitudeCurve.FadeInOut50:
					this.amplitudeOverLifetimeCurve = new AnimationCurve(new Keyframe(0f, 0f), new Keyframe(0.5f, 1f), new Keyframe(1f, 0f));
					break;
				case CameraShakeAmplitudeCurve.FadeInOut75:
					this.amplitudeOverLifetimeCurve = new AnimationCurve(new Keyframe(0f, 0f), new Keyframe(0.75f, 1f), new Keyframe(1f, 0f));
					break;
				default:
					throw new Exception("Unknown enum.");
				}
			}

			public bool IsAlive()
			{
				return timeRemaining > 0f;
			}

			public void Update()
			{
				if (!(timeRemaining < 0f))
				{
					Vector2 vector = Time.deltaTime * new Vector2(frequency, frequency);
					perlinNoiseX += vector;
					perlinNoiseY += vector;
					perlinNoiseZ += vector;
					noise.x = Mathf.PerlinNoise(perlinNoiseX.x, perlinNoiseX.y) - 0.5f;
					noise.y = Mathf.PerlinNoise(perlinNoiseY.x, perlinNoiseY.y) - 0.5f;
					noise.z = Mathf.PerlinNoise(perlinNoiseZ.x, perlinNoiseZ.y) - 0.5f;
					float num = amplitudeOverLifetimeCurve.Evaluate(1f - timeRemaining / duration);
					noise *= amplitude * num;
					timeRemaining -= Time.deltaTime;
				}
			}
		}

		public float smoothDampTime = 0.025f;

		private Vector3 smoothDampPositionVelocity;

		private float smoothDampRotationVelocityX;

		private float smoothDampRotationVelocityY;

		private float smoothDampRotationVelocityZ;

		private List<Shake> shakes = new List<Shake>();

		private void Start()
		{
		}

		public void Add(float amplitude, float frequency, float duration, CameraShakeTarget target, AnimationCurve amplitudeOverLifetimeCurve)
		{
			shakes.Add(new Shake(amplitude, frequency, duration, target, amplitudeOverLifetimeCurve));
		}

		public void Add(float amplitude, float frequency, float duration, CameraShakeTarget target, CameraShakeAmplitudeCurve amplitudeOverLifetimeCurve)
		{
			shakes.Add(new Shake(amplitude, frequency, duration, target, amplitudeOverLifetimeCurve));
		}

		private void Update()
		{
			if (Input.GetKeyDown(KeyCode.F))
			{
				Add(0.25f, 1f, 2f, CameraShakeTarget.Position, CameraShakeAmplitudeCurve.FadeInOut25);
			}
			if (Input.GetKeyDown(KeyCode.G))
			{
				Add(15f, 1f, 2f, CameraShakeTarget.Rotation, CameraShakeAmplitudeCurve.FadeInOut25);
			}
			Input.GetKey(KeyCode.H);
			Vector3 zero = Vector3.zero;
			Vector3 zero2 = Vector3.zero;
			for (int i = 0; i < shakes.Count; i++)
			{
				shakes[i].Update();
				if (shakes[i].target == CameraShakeTarget.Position)
				{
					zero += shakes[i].noise;
				}
				else
				{
					zero2 += shakes[i].noise;
				}
			}
			shakes.RemoveAll((Shake x) => !x.IsAlive());
			base.transform.localPosition = Vector3.SmoothDamp(base.transform.localPosition, zero, ref smoothDampPositionVelocity, smoothDampTime);
			Vector3 localEulerAngles = base.transform.localEulerAngles;
			localEulerAngles.x = Mathf.SmoothDampAngle(localEulerAngles.x, zero2.x, ref smoothDampRotationVelocityX, smoothDampTime);
			localEulerAngles.y = Mathf.SmoothDampAngle(localEulerAngles.y, zero2.y, ref smoothDampRotationVelocityY, smoothDampTime);
			localEulerAngles.z = Mathf.SmoothDampAngle(localEulerAngles.z, zero2.z, ref smoothDampRotationVelocityZ, smoothDampTime);
			base.transform.localEulerAngles = localEulerAngles;
		}
	}
	public class DemoManager : MonoBehaviour
	{
		public enum ParticleMode
		{
			looping,
			oneshot
		}

		public enum Level
		{
			none,
			basic
		}

		public Transform cameraRotationTransform;

		public Transform cameraTranslationTransform;

		public Vector3 cameraLookAtPosition = new Vector3(0f, 3f, 0f);

		public MouseFollow mouse;

		private Vector3 targetCameraPosition;

		private Vector3 targetCameraRotation;

		private Vector3 cameraPositionStart;

		private Vector3 cameraRotationStart;

		private Vector2 input;

		private Vector3 cameraRotation;

		public float cameraMoveAmount = 2f;

		public float cameraRotateAmount = 2f;

		public float cameraMoveSpeed = 12f;

		public float cameraRotationSpeed = 12f;

		public Vector2 cameraAngleLimits = new Vector2(-8f, 60f);

		public GameObject[] levels;

		public Level currentLevel = Level.basic;

		public ParticleMode particleMode;

		public bool advancedRendering = true;

		public Toggle loopingParticleModeToggle;

		public Toggle oneshotParticleModeToggle;

		public Toggle advancedRenderingToggle;

		private Toggle[] levelToggles;

		public ToggleGroup levelTogglesContainer;

		private LoopingParticleSystemsManager loopingParticleSystems;

		private OneshotParticleSystemsManager oneshotParticleSystems;

		public GameObject ui;

		public Text particleCountText;

		public Text currentParticleSystemText;

		public Text particleSpawnInstructionText;

		public Slider timeScaleSlider;

		public Text timeScaleSliderValueText;

		public Camera mainCamera;

		public MonoBehaviour[] mainCameraPostEffects;

		private Vector3 cameraPositionSmoothDampVelocity;

		private Vector3 cameraRotationSmoothDampVelocity;

		private void Awake()
		{
			loopingParticleSystems = UnityEngine.Object.FindObjectOfType<LoopingParticleSystemsManager>();
			oneshotParticleSystems = UnityEngine.Object.FindObjectOfType<OneshotParticleSystemsManager>();
			loopingParticleSystems.Init();
			oneshotParticleSystems.Init();
		}

		private void Start()
		{
			cameraPositionStart = cameraTranslationTransform.localPosition;
			cameraRotationStart = cameraRotationTransform.localEulerAngles;
			ResetCameraTransformTargets();
			switch (particleMode)
			{
			case ParticleMode.looping:
				SetToLoopingParticleMode(set: true);
				loopingParticleModeToggle.isOn = true;
				oneshotParticleModeToggle.isOn = false;
				break;
			case ParticleMode.oneshot:
				SetToOneshotParticleMode(set: true);
				loopingParticleModeToggle.isOn = false;
				oneshotParticleModeToggle.isOn = true;
				break;
			default:
				MonoBehaviour.print("Unknown case.");
				break;
			}
			SetAdvancedRendering(advancedRendering);
			advancedRenderingToggle.isOn = advancedRendering;
			levelToggles = levelTogglesContainer.GetComponentsInChildren<Toggle>(includeInactive: true);
			for (int i = 0; i < levels.Length; i++)
			{
				if (i == (int)currentLevel)
				{
					levels[i].SetActive(value: true);
					levelToggles[i].isOn = true;
				}
				else
				{
					levels[i].SetActive(value: false);
					levelToggles[i].isOn = false;
				}
			}
			UpdateCurrentParticleSystemNameText();
			timeScaleSlider.onValueChanged.AddListener(OnTimeScaleSliderValueChanged);
			OnTimeScaleSliderValueChanged(timeScaleSlider.value);
		}

		public void OnTimeScaleSliderValueChanged(float value)
		{
			Time.timeScale = value;
			timeScaleSliderValueText.text = value.ToString("0.00");
		}

		public void SetToLoopingParticleMode(bool set)
		{
			if (set)
			{
				oneshotParticleSystems.Clear();
				loopingParticleSystems.gameObject.SetActive(value: true);
				oneshotParticleSystems.gameObject.SetActive(value: false);
				particleSpawnInstructionText.gameObject.SetActive(value: false);
				particleMode = ParticleMode.looping;
				UpdateCurrentParticleSystemNameText();
			}
		}

		public void SetToOneshotParticleMode(bool set)
		{
			if (set)
			{
				loopingParticleSystems.gameObject.SetActive(value: false);
				oneshotParticleSystems.gameObject.SetActive(value: true);
				particleSpawnInstructionText.gameObject.SetActive(value: true);
				particleMode = ParticleMode.oneshot;
				UpdateCurrentParticleSystemNameText();
			}
		}

		public void SetLevel(Level level)
		{
			for (int i = 0; i < levels.Length; i++)
			{
				if (i == (int)level)
				{
					levels[i].SetActive(value: true);
				}
				else
				{
					levels[i].SetActive(value: false);
				}
			}
			currentLevel = level;
		}

		public void SetLevelFromToggle(Toggle toggle)
		{
			if (toggle.isOn)
			{
				SetLevel((Level)Array.IndexOf(levelToggles, toggle));
			}
		}

		public void SetAdvancedRendering(bool value)
		{
			advancedRendering = value;
			mainCamera.allowHDR = value;
			if (value)
			{
				QualitySettings.SetQualityLevel(32, applyExpensiveChanges: true);
				mainCamera.renderingPath = RenderingPath.UsePlayerSettings;
				mouse.gameObject.SetActive(value: true);
			}
			else
			{
				QualitySettings.SetQualityLevel(0, applyExpensiveChanges: true);
				mainCamera.renderingPath = RenderingPath.VertexLit;
				mouse.gameObject.SetActive(value: false);
			}
			for (int i = 0; i < mainCameraPostEffects.Length; i++)
			{
				if ((bool)mainCameraPostEffects[i])
				{
					mainCameraPostEffects[i].enabled = value;
				}
			}
		}

		public static Vector3 DampVector3(Vector3 from, Vector3 to, float speed, float dt)
		{
			return Vector3.Lerp(from, to, 1f - Mathf.Exp((0f - speed) * dt));
		}

		private void Update()
		{
			input.x = Input.GetAxis("Horizontal");
			input.y = Input.GetAxis("Vertical");
			if (Input.GetKey(KeyCode.LeftShift))
			{
				targetCameraPosition.z += input.y * cameraMoveAmount;
				targetCameraPosition.z = Mathf.Clamp(targetCameraPosition.z, -6.3f, -1f);
			}
			else
			{
				targetCameraRotation.y += input.x * cameraRotateAmount;
				targetCameraRotation.x += input.y * cameraRotateAmount;
				targetCameraRotation.x = Mathf.Clamp(targetCameraRotation.x, cameraAngleLimits.x, cameraAngleLimits.y);
			}
			cameraTranslationTransform.localPosition = Vector3.SmoothDamp(cameraTranslationTransform.localPosition, targetCameraPosition, ref cameraPositionSmoothDampVelocity, 1f / cameraMoveSpeed, float.PositiveInfinity, Time.unscaledDeltaTime);
			cameraRotation = Vector3.SmoothDamp(cameraRotation, targetCameraRotation, ref cameraRotationSmoothDampVelocity, 1f / cameraRotationSpeed, float.PositiveInfinity, Time.unscaledDeltaTime);
			cameraRotationTransform.localEulerAngles = cameraRotation;
			cameraTranslationTransform.LookAt(cameraLookAtPosition);
			if (Input.GetAxis("Mouse ScrollWheel") < 0f)
			{
				Next();
			}
			else if (Input.GetAxis("Mouse ScrollWheel") > 0f)
			{
				Previous();
			}
			if (Input.GetKeyDown(KeyCode.U))
			{
				ui.SetActive(!ui.activeSelf);
			}
			if (Input.GetKeyDown(KeyCode.O))
			{
				if (particleMode == ParticleMode.looping)
				{
					SetToOneshotParticleMode(set: true);
				}
				else
				{
					SetToLoopingParticleMode(set: true);
				}
			}
			if (Input.GetKeyDown(KeyCode.L))
			{
				SetLevel((Level)((int)(currentLevel + 1) % Enum.GetNames(typeof(Level)).Length));
			}
			else
			{
				Input.GetKey(KeyCode.R);
			}
			if (particleMode == ParticleMode.oneshot)
			{
				Vector3 mousePosition = Input.mousePosition;
				if (Input.GetMouseButtonDown(0))
				{
					CameraShake cameraShake = UnityEngine.Object.FindObjectOfType<CameraShake>();
					cameraShake.Add(0.2f, 5f, 0.2f, CameraShakeTarget.Position, CameraShakeAmplitudeCurve.FadeInOut25);
					cameraShake.Add(4f, 5f, 0.5f, CameraShakeTarget.Rotation, CameraShakeAmplitudeCurve.FadeInOut25);
					oneshotParticleSystems.InstantiateParticlePrefab(mousePosition, mouse.distanceFromCamera);
				}
				if (Input.GetMouseButton(1))
				{
					oneshotParticleSystems.InstantiateParticlePrefab(mousePosition, mouse.distanceFromCamera);
				}
			}
			if (Input.GetKeyDown(KeyCode.R))
			{
				ResetCameraTransformTargets();
			}
		}

		private void LateUpdate()
		{
			particleCountText.text = "PARTICLE COUNT: ";
			if (particleMode == ParticleMode.looping)
			{
				particleCountText.text += loopingParticleSystems.GetParticleCount();
			}
			else if (particleMode == ParticleMode.oneshot)
			{
				particleCountText.text += oneshotParticleSystems.GetParticleCount();
			}
		}

		private void ResetCameraTransformTargets()
		{
			targetCameraPosition = cameraPositionStart;
			targetCameraRotation = cameraRotationStart;
		}

		private void UpdateCurrentParticleSystemNameText()
		{
			if (particleMode == ParticleMode.looping)
			{
				currentParticleSystemText.text = loopingParticleSystems.GetCurrentPrefabName(shorten: true);
			}
			else if (particleMode == ParticleMode.oneshot)
			{
				currentParticleSystemText.text = oneshotParticleSystems.GetCurrentPrefabName(shorten: true);
			}
		}

		public void Next()
		{
			if (particleMode == ParticleMode.looping)
			{
				loopingParticleSystems.Next();
			}
			else if (particleMode == ParticleMode.oneshot)
			{
				oneshotParticleSystems.Next();
			}
			UpdateCurrentParticleSystemNameText();
		}

		public void Previous()
		{
			if (particleMode == ParticleMode.looping)
			{
				loopingParticleSystems.Previous();
			}
			else if (particleMode == ParticleMode.oneshot)
			{
				oneshotParticleSystems.Previous();
			}
			UpdateCurrentParticleSystemNameText();
		}
	}
	public class FPSDisplay : MonoBehaviour
	{
		private float timer;

		public float updateTime = 1f;

		private int frameCount;

		private float fpsAccum;

		private Text fpsText;

		private void Awake()
		{
		}

		private void Start()
		{
			fpsText = GetComponent<Text>();
		}

		private void Update()
		{
			frameCount++;
			timer += Time.deltaTime;
			fpsAccum += 1f / Time.deltaTime;
			if (timer >= updateTime)
			{
				timer = 0f;
				int num = Mathf.RoundToInt(fpsAccum / (float)frameCount);
				fpsText.text = "Average FPS: " + num;
				frameCount = 0;
				fpsAccum = 0f;
			}
		}
	}
	public class FPSTest : MonoBehaviour
	{
		public int targetFPS1 = 60;

		public int targetFPS2 = 10;

		private int previousVSyncCount;

		private void Awake()
		{
		}

		private void Start()
		{
		}

		private void Update()
		{
			if (Input.GetKey(KeyCode.Space))
			{
				UnityEngine.Application.targetFrameRate = targetFPS2;
				previousVSyncCount = QualitySettings.vSyncCount;
				QualitySettings.vSyncCount = 0;
			}
			else if (Input.GetKeyUp(KeyCode.Space))
			{
				UnityEngine.Application.targetFrameRate = targetFPS1;
				QualitySettings.vSyncCount = previousVSyncCount;
			}
		}
	}
	public class LoopingParticleSystemsManager : ParticleManager
	{
		protected override void Awake()
		{
			base.Awake();
		}

		protected override void Start()
		{
			base.Start();
			particlePrefabs[currentParticlePrefabIndex].gameObject.SetActive(value: true);
		}

		public override void Next()
		{
			particlePrefabs[currentParticlePrefabIndex].gameObject.SetActive(value: false);
			base.Next();
			particlePrefabs[currentParticlePrefabIndex].gameObject.SetActive(value: true);
		}

		public override void Previous()
		{
			particlePrefabs[currentParticlePrefabIndex].gameObject.SetActive(value: false);
			base.Previous();
			particlePrefabs[currentParticlePrefabIndex].gameObject.SetActive(value: true);
		}

		protected override void Update()
		{
			base.Update();
		}

		public override int GetParticleCount()
		{
			return particlePrefabs[currentParticlePrefabIndex].getParticleCount();
		}
	}
	public class MouseFollow : MonoBehaviour
	{
		public float speed = 8f;

		public float distanceFromCamera = 5f;

		public bool ignoreTimeScale;

		private void Awake()
		{
		}

		private void Start()
		{
		}

		private void Update()
		{
			Vector3 mousePosition = Input.mousePosition;
			mousePosition.z = distanceFromCamera;
			Vector3 b = Camera.main.ScreenToWorldPoint(mousePosition);
			float num = ((!ignoreTimeScale) ? Time.deltaTime : Time.unscaledDeltaTime);
			Vector3 position = Vector3.Lerp(base.transform.position, b, 1f - Mathf.Exp((0f - speed) * num));
			base.transform.position = position;
		}

		private void LateUpdate()
		{
		}
	}
	public class OneshotParticleSystemsManager : ParticleManager
	{
		public LayerMask mouseRaycastLayerMask;

		private List<ParticleSystems> spawnedPrefabs;

		public bool disableSpawn { get; set; }

		protected override void Awake()
		{
			base.Awake();
		}

		protected override void Start()
		{
			base.Start();
			disableSpawn = false;
			spawnedPrefabs = new List<ParticleSystems>();
		}

		private void OnEnable()
		{
		}

		public void Clear()
		{
			if (spawnedPrefabs == null)
			{
				return;
			}
			for (int i = 0; i < spawnedPrefabs.Count; i++)
			{
				if ((bool)spawnedPrefabs[i])
				{
					UnityEngine.Object.Destroy(spawnedPrefabs[i].gameObject);
				}
			}
			spawnedPrefabs.Clear();
		}

		protected override void Update()
		{
			base.Update();
		}

		public void InstantiateParticlePrefab(Vector2 mousePosition, float maxDistance)
		{
			if (spawnedPrefabs != null && !disableSpawn)
			{
				Vector3 position = mousePosition;
				position.z = maxDistance;
				Vector3 vector = Camera.main.ScreenToWorldPoint(position);
				Vector3 direction = vector - Camera.main.transform.position;
				Physics.Raycast(Camera.main.transform.position + Camera.main.transform.forward * 0.01f, direction, out var hitInfo, maxDistance);
				Vector3 position2 = ((!hitInfo.collider) ? vector : hitInfo.point);
				ParticleSystems particleSystems = particlePrefabs[currentParticlePrefabIndex];
				ParticleSystems particleSystems2 = UnityEngine.Object.Instantiate(particleSystems, position2, particleSystems.transform.rotation);
				particleSystems2.gameObject.SetActive(value: true);
				particleSystems2.transform.parent = base.transform;
				spawnedPrefabs.Add(particleSystems2);
			}
		}

		public void Randomize()
		{
			currentParticlePrefabIndex = UnityEngine.Random.Range(0, particlePrefabs.Count);
		}

		public override int GetParticleCount()
		{
			int num = 0;
			if (spawnedPrefabs != null)
			{
				for (int i = 0; i < spawnedPrefabs.Count; i++)
				{
					if ((bool)spawnedPrefabs[i])
					{
						num += spawnedPrefabs[i].getParticleCount();
					}
					else
					{
						spawnedPrefabs.RemoveAt(i);
					}
				}
			}
			return num;
		}
	}
	public class ParticleManager : MonoBehaviour
	{
		protected List<ParticleSystems> particlePrefabs;

		public int currentParticlePrefabIndex;

		public List<ParticleSystems> particlePrefabsAppend;

		public int prefabNameUnderscoreCountCutoff = 4;

		public bool disableChildrenAtStart = true;

		private bool initialized;

		public void Init()
		{
			particlePrefabs = GetComponentsInChildren<ParticleSystems>(includeInactive: true).ToList();
			particlePrefabs.AddRange(particlePrefabsAppend);
			if (disableChildrenAtStart)
			{
				for (int i = 0; i < particlePrefabs.Count; i++)
				{
					particlePrefabs[i].gameObject.SetActive(value: false);
				}
			}
			initialized = true;
		}

		protected virtual void Awake()
		{
		}

		protected virtual void Start()
		{
			if (initialized)
			{
				Init();
			}
		}

		public virtual void Next()
		{
			currentParticlePrefabIndex++;
			if (currentParticlePrefabIndex > particlePrefabs.Count - 1)
			{
				currentParticlePrefabIndex = 0;
			}
		}

		public virtual void Previous()
		{
			currentParticlePrefabIndex--;
			if (currentParticlePrefabIndex < 0)
			{
				currentParticlePrefabIndex = particlePrefabs.Count - 1;
			}
		}

		public string GetCurrentPrefabName(bool shorten = false)
		{
			string text = particlePrefabs[currentParticlePrefabIndex].name;
			if (shorten)
			{
				int num = 0;
				for (int i = 0; i < prefabNameUnderscoreCountCutoff; i++)
				{
					num = text.IndexOf("_", num) + 1;
					if (num == 0)
					{
						MonoBehaviour.print("Iteration of underscore not found.");
						break;
					}
				}
				text = text.Substring(num, text.Length - num);
			}
			return "PARTICLE SYSTEM: #" + (currentParticlePrefabIndex + 1).ToString("00") + " / " + particlePrefabs.Count.ToString("00") + " (" + text + ")";
		}

		public virtual int GetParticleCount()
		{
			return 0;
		}

		protected virtual void Update()
		{
		}
	}
}
namespace MirzaBeig.Demos
{
	public class MouseRotateCamera : MonoBehaviour
	{
		public float maxRotation = 5f;

		public float speed = 2f;

		public bool unscaledTime;

		private void Awake()
		{
		}

		private void Start()
		{
		}

		private void Update()
		{
		}

		private void LateUpdate()
		{
			Vector2 vector = Input.mousePosition;
			float num = (float)Screen.width / 2f;
			float num2 = (float)Screen.height / 2f;
			float num3 = (vector.x - num) / num;
			float num4 = (vector.y - num2) / num2;
			Vector3 localEulerAngles = base.transform.localEulerAngles;
			localEulerAngles.y = num3 * (0f - maxRotation);
			localEulerAngles.x = num4 * maxRotation;
			float t = ((!unscaledTime) ? Time.deltaTime : Time.unscaledDeltaTime) * speed;
			localEulerAngles.x = Mathf.LerpAngle(base.transform.localEulerAngles.x, localEulerAngles.x, t);
			localEulerAngles.y = Mathf.LerpAngle(base.transform.localEulerAngles.y, localEulerAngles.y, t);
			base.transform.localEulerAngles = localEulerAngles;
		}
	}
}
namespace MirzaBeig.Demos.Wallpapers
{
	public class GravityClockInteractivityUVFX : MonoBehaviour
	{
		public GameObject forceAffectors;

		public GameObject forceAffectors2;

		public ParticleSystem gravityClockPrefab;

		private ParticleSystem gravityClock;

		public bool enableGravityClockVisualEffects = true;

		public bool enableGravityClockAttractionForce = true;

		private void Awake()
		{
		}

		private void Start()
		{
		}

		private void Update()
		{
		}

		public void SetGravityClockVisualEffectsActive(bool value)
		{
			if (value)
			{
				if (enableGravityClockVisualEffects)
				{
					gravityClock = UnityEngine.Object.Instantiate(gravityClockPrefab, base.transform);
					gravityClock.transform.localPosition = Vector3.zero;
				}
			}
			else if ((bool)gravityClock)
			{
				gravityClock.Stop();
				gravityClock.transform.SetParent(null, worldPositionStays: true);
			}
		}

		public void SetGravityClockAttractionForceActive(bool value)
		{
			if (value)
			{
				if (enableGravityClockAttractionForce)
				{
					forceAffectors.gameObject.SetActive(value: true);
					forceAffectors2.gameObject.SetActive(value: true);
				}
			}
			else
			{
				forceAffectors.gameObject.SetActive(value: false);
				forceAffectors2.gameObject.SetActive(value: false);
			}
		}
	}
}
namespace MirzaBeig.Demos.ParticlePlayground
{
	public class BillboardCameraPlaneUVFX : MonoBehaviour
	{
		private Transform cameraTransform;

		private void Awake()
		{
		}

		private void Start()
		{
			cameraTransform = Camera.main.transform;
		}

		private void Update()
		{
		}

		private void LateUpdate()
		{
			base.transform.forward = -cameraTransform.forward;
		}
	}
}
namespace DigitalOpus.MB.Core
{
	public class MBVersionConcrete : MBVersionInterface
	{
		private Vector2 _HALF_UV = new Vector2(0.5f, 0.5f);

		public string version()
		{
			return "3.26.0";
		}

		public int GetMajorVersion()
		{
			return int.Parse(UnityEngine.Application.unityVersion.Split('.')[0]);
		}

		public int GetMinorVersion()
		{
			return int.Parse(UnityEngine.Application.unityVersion.Split('.')[1]);
		}

		public bool GetActive(GameObject go)
		{
			return go.activeInHierarchy;
		}

		public void SetActive(GameObject go, bool isActive)
		{
			go.SetActive(isActive);
		}

		public void SetActiveRecursively(GameObject go, bool isActive)
		{
			go.SetActive(isActive);
		}

		public UnityEngine.Object[] FindSceneObjectsOfType(Type t)
		{
			return UnityEngine.Object.FindObjectsOfType(t);
		}

		public void OptimizeMesh(Mesh m)
		{
		}

		public bool IsRunningAndMeshNotReadWriteable(Mesh m)
		{
			if (UnityEngine.Application.isPlaying)
			{
				return !m.isReadable;
			}
			return false;
		}

		public Vector2[] GetMeshUV1s(Mesh m, MB2_LogLevel LOG_LEVEL)
		{
			if (LOG_LEVEL >= MB2_LogLevel.warn)
			{
				MB2_Log.LogDebug("UV1 does not exist in Unity 5+");
			}
			Vector2[] array = m.uv;
			if (array.Length == 0)
			{
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					MB2_Log.LogDebug("Mesh " + m?.ToString() + " has no uv1s. Generating");
				}
				if (LOG_LEVEL >= MB2_LogLevel.warn)
				{
					UnityEngine.Debug.LogWarning("Mesh " + m?.ToString() + " didn't have uv1s. Generating uv1s.");
				}
				array = new Vector2[m.vertexCount];
				for (int i = 0; i < array.Length; i++)
				{
					array[i] = _HALF_UV;
				}
			}
			return array;
		}

		public Vector2[] GetMeshUV3orUV4(Mesh m, bool get3, MB2_LogLevel LOG_LEVEL)
		{
			Vector2[] array = ((!get3) ? m.uv4 : m.uv3);
			if (array.Length == 0)
			{
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					MB2_Log.LogDebug("Mesh " + m?.ToString() + " has no uv" + (get3 ? "3" : "4") + ". Generating");
				}
				array = new Vector2[m.vertexCount];
				for (int i = 0; i < array.Length; i++)
				{
					array[i] = _HALF_UV;
				}
			}
			return array;
		}

		public void MeshClear(Mesh m, bool t)
		{
			m.Clear(t);
		}

		public void MeshAssignUV3(Mesh m, Vector2[] uv3s)
		{
			m.uv3 = uv3s;
		}

		public void MeshAssignUV4(Mesh m, Vector2[] uv4s)
		{
			m.uv4 = uv4s;
		}

		public Vector4 GetLightmapTilingOffset(Renderer r)
		{
			return r.lightmapScaleOffset;
		}

		public Transform[] GetBones(Renderer r)
		{
			if (r is SkinnedMeshRenderer)
			{
				return ((SkinnedMeshRenderer)r).bones;
			}
			if (r is MeshRenderer)
			{
				return new Transform[1] { r.transform };
			}
			UnityEngine.Debug.LogError("Could not getBones. Object does not have a renderer");
			return null;
		}

		public int GetBlendShapeFrameCount(Mesh m, int shapeIndex)
		{
			return m.GetBlendShapeFrameCount(shapeIndex);
		}

		public float GetBlendShapeFrameWeight(Mesh m, int shapeIndex, int frameIndex)
		{
			return m.GetBlendShapeFrameWeight(shapeIndex, frameIndex);
		}

		public void GetBlendShapeFrameVertices(Mesh m, int shapeIndex, int frameIndex, Vector3[] vs, Vector3[] ns, Vector3[] ts)
		{
			m.GetBlendShapeFrameVertices(shapeIndex, frameIndex, vs, ns, ts);
		}

		public void ClearBlendShapes(Mesh m)
		{
			m.ClearBlendShapes();
		}

		public void AddBlendShapeFrame(Mesh m, string nm, float wt, Vector3[] vs, Vector3[] ns, Vector3[] ts)
		{
			m.AddBlendShapeFrame(nm, wt, vs, ns, ts);
		}

		public int MaxMeshVertexCount()
		{
			return 2147483646;
		}

		public void SetMeshIndexFormatAndClearMesh(Mesh m, int numVerts, bool vertices, bool justClearTriangles)
		{
			if (vertices && numVerts > 65534 && m.indexFormat == UnityEngine.Rendering.IndexFormat.UInt16)
			{
				MBVersion.MeshClear(m, t: false);
				m.indexFormat = UnityEngine.Rendering.IndexFormat.UInt32;
			}
			else if (vertices && numVerts <= 65534 && m.indexFormat == UnityEngine.Rendering.IndexFormat.UInt32)
			{
				MBVersion.MeshClear(m, t: false);
				m.indexFormat = UnityEngine.Rendering.IndexFormat.UInt16;
			}
			else if (justClearTriangles)
			{
				MBVersion.MeshClear(m, t: true);
			}
			else
			{
				MBVersion.MeshClear(m, t: false);
			}
		}
	}
	[Serializable]
	public class GrouperData
	{
		public bool clusterOnLMIndex;

		public bool clusterByLODLevel;

		public Vector3 origin;

		public Vector3 cellSize;

		public int pieNumSegments = 4;

		public Vector3 pieAxis = Vector3.up;

		public int height = 1;

		public float maxDistBetweenClusters = 1f;

		public bool includeCellsWithOnlyOneRenderer = true;
	}
	[Serializable]
	public abstract class MB3_MeshBakerGrouperCore
	{
		public GrouperData d;

		public abstract Dictionary<string, List<Renderer>> FilterIntoGroups(List<GameObject> selection);

		public abstract void DrawGizmos(Bounds sourceObjectBounds);

		public void DoClustering(MB3_TextureBaker tb, MB3_MeshBakerGrouper grouper)
		{
			Dictionary<string, List<Renderer>> dictionary = FilterIntoGroups(tb.GetObjectsToCombine());
			if (d.clusterOnLMIndex)
			{
				Dictionary<string, List<Renderer>> dictionary2 = new Dictionary<string, List<Renderer>>();
				foreach (string key4 in dictionary.Keys)
				{
					List<Renderer> gaws = dictionary[key4];
					Dictionary<int, List<Renderer>> dictionary3 = GroupByLightmapIndex(gaws);
					foreach (int key5 in dictionary3.Keys)
					{
						string key = key4 + "-LM-" + key5;
						dictionary2.Add(key, dictionary3[key5]);
					}
				}
				dictionary = dictionary2;
			}
			if (d.clusterByLODLevel)
			{
				Dictionary<string, List<Renderer>> dictionary4 = new Dictionary<string, List<Renderer>>();
				foreach (string key6 in dictionary.Keys)
				{
					foreach (Renderer r in dictionary[key6])
					{
						if (r == null)
						{
							continue;
						}
						bool flag = false;
						LODGroup componentInParent = r.GetComponentInParent<LODGroup>();
						if (componentInParent != null)
						{
							LOD[] lODs = componentInParent.GetLODs();
							for (int i = 0; i < lODs.Length; i++)
							{
								if (Array.Find(lODs[i].renderers, (Renderer x) => x == r) != null)
								{
									flag = true;
									string key2 = $"{key6}_LOD{i}";
									if (!dictionary4.TryGetValue(key2, out var value))
									{
										value = new List<Renderer>();
										dictionary4.Add(key2, value);
									}
									if (!value.Contains(r))
									{
										value.Add(r);
									}
								}
							}
						}
						if (!flag)
						{
							string key3 = $"{key6}_LOD0";
							if (!dictionary4.TryGetValue(key3, out var value2))
							{
								value2 = new List<Renderer>();
								dictionary4.Add(key3, value2);
							}
							if (!value2.Contains(r))
							{
								value2.Add(r);
							}
						}
					}
				}
				dictionary = dictionary4;
			}
			int num = 0;
			foreach (string key7 in dictionary.Keys)
			{
				List<Renderer> list = dictionary[key7];
				if (list.Count > 1 || grouper.data.includeCellsWithOnlyOneRenderer)
				{
					AddMeshBaker(tb, key7, list);
				}
				else
				{
					num++;
				}
			}
			UnityEngine.Debug.Log($"Found {dictionary.Count} cells with Renderers. Not creating bakers for {num} because there is only one mesh in the cell. Creating {dictionary.Count - num} bakers.");
		}

		private Dictionary<int, List<Renderer>> GroupByLightmapIndex(List<Renderer> gaws)
		{
			Dictionary<int, List<Renderer>> dictionary = new Dictionary<int, List<Renderer>>();
			for (int i = 0; i < gaws.Count; i++)
			{
				List<Renderer> list = null;
				if (dictionary.ContainsKey(gaws[i].lightmapIndex))
				{
					list = dictionary[gaws[i].lightmapIndex];
				}
				else
				{
					list = new List<Renderer>();
					dictionary.Add(gaws[i].lightmapIndex, list);
				}
				list.Add(gaws[i]);
			}
			return dictionary;
		}

		private void AddMeshBaker(MB3_TextureBaker tb, string key, List<Renderer> gaws)
		{
			int num = 0;
			for (int i = 0; i < gaws.Count; i++)
			{
				Mesh mesh = MB_Utility.GetMesh(gaws[i].gameObject);
				if (mesh != null)
				{
					num += mesh.vertexCount;
				}
			}
			GameObject gameObject = new GameObject("MeshBaker-" + key);
			gameObject.transform.position = Vector3.zero;
			MB3_MeshBakerCommon mB3_MeshBakerCommon;
			if (num >= 65535)
			{
				mB3_MeshBakerCommon = gameObject.AddComponent<MB3_MultiMeshBaker>();
				mB3_MeshBakerCommon.useObjsToMeshFromTexBaker = false;
			}
			else
			{
				mB3_MeshBakerCommon = gameObject.AddComponent<MB3_MeshBaker>();
				mB3_MeshBakerCommon.useObjsToMeshFromTexBaker = false;
			}
			mB3_MeshBakerCommon.textureBakeResults = tb.textureBakeResults;
			mB3_MeshBakerCommon.transform.parent = tb.transform;
			for (int j = 0; j < gaws.Count; j++)
			{
				mB3_MeshBakerCommon.GetObjectsToCombine().Add(gaws[j].gameObject);
			}
		}
	}
	[Serializable]
	public class MB3_MeshBakerGrouperNone : MB3_MeshBakerGrouperCore
	{
		public MB3_MeshBakerGrouperNone(GrouperData d)
		{
			base.d = d;
		}

		public override Dictionary<string, List<Renderer>> FilterIntoGroups(List<GameObject> selection)
		{
			UnityEngine.Debug.Log("Filtering into groups none");
			Dictionary<string, List<Renderer>> dictionary = new Dictionary<string, List<Renderer>>();
			List<Renderer> list = new List<Renderer>();
			for (int i = 0; i < selection.Count; i++)
			{
				if (selection[i] != null)
				{
					list.Add(selection[i].GetComponent<Renderer>());
				}
			}
			dictionary.Add("MeshBaker", list);
			return dictionary;
		}

		public override void DrawGizmos(Bounds sourceObjectBounds)
		{
		}
	}
	[Serializable]
	public class MB3_MeshBakerGrouperGrid : MB3_MeshBakerGrouperCore
	{
		public MB3_MeshBakerGrouperGrid(GrouperData d)
		{
			base.d = d;
		}

		public override Dictionary<string, List<Renderer>> FilterIntoGroups(List<GameObject> selection)
		{
			Dictionary<string, List<Renderer>> dictionary = new Dictionary<string, List<Renderer>>();
			if (d.cellSize.x <= 0f || d.cellSize.y <= 0f || d.cellSize.z <= 0f)
			{
				UnityEngine.Debug.LogError("cellSize x,y,z must all be greater than zero.");
				return dictionary;
			}
			UnityEngine.Debug.Log("Collecting renderers in each cell");
			foreach (GameObject item in selection)
			{
				if (item == null)
				{
					continue;
				}
				Renderer component = item.GetComponent<Renderer>();
				if (component is MeshRenderer || component is SkinnedMeshRenderer)
				{
					Vector3 center = component.bounds.center;
					center.x = Mathf.Floor((center.x - d.origin.x) / d.cellSize.x) * d.cellSize.x;
					center.y = Mathf.Floor((center.y - d.origin.y) / d.cellSize.y) * d.cellSize.y;
					center.z = Mathf.Floor((center.z - d.origin.z) / d.cellSize.z) * d.cellSize.z;
					List<Renderer> list = null;
					string key = center.ToString();
					if (dictionary.ContainsKey(key))
					{
						list = dictionary[key];
					}
					else
					{
						list = new List<Renderer>();
						dictionary.Add(key, list);
					}
					if (!list.Contains(component))
					{
						list.Add(component);
					}
				}
			}
			return dictionary;
		}

		public override void DrawGizmos(Bounds sourceObjectBounds)
		{
			Vector3 cellSize = d.cellSize;
			if (cellSize.x <= 1E-05f || cellSize.y <= 1E-05f || cellSize.z <= 1E-05f)
			{
				return;
			}
			Vector3 vector = sourceObjectBounds.center - sourceObjectBounds.extents;
			Vector3 origin = d.origin;
			origin.x %= cellSize.x;
			origin.y %= cellSize.y;
			origin.z %= cellSize.z;
			vector.x = Mathf.Round(vector.x / cellSize.x) * cellSize.x + origin.x;
			vector.y = Mathf.Round(vector.y / cellSize.y) * cellSize.y + origin.y;
			vector.z = Mathf.Round(vector.z / cellSize.z) * cellSize.z + origin.z;
			if (vector.x > sourceObjectBounds.center.x - sourceObjectBounds.extents.x)
			{
				vector.x -= cellSize.x;
			}
			if (vector.y > sourceObjectBounds.center.y - sourceObjectBounds.extents.y)
			{
				vector.y -= cellSize.y;
			}
			if (vector.z > sourceObjectBounds.center.z - sourceObjectBounds.extents.z)
			{
				vector.z -= cellSize.z;
			}
			Vector3 vector2 = vector;
			if (Mathf.CeilToInt(sourceObjectBounds.size.x / cellSize.x + sourceObjectBounds.size.y / cellSize.y + sourceObjectBounds.size.z / cellSize.z) > 200)
			{
				Gizmos.DrawWireCube(d.origin + cellSize / 2f, cellSize);
				return;
			}
			while (vector.x < sourceObjectBounds.center.x + sourceObjectBounds.extents.x)
			{
				vector.y = vector2.y;
				while (vector.y < sourceObjectBounds.center.y + sourceObjectBounds.extents.y)
				{
					vector.z = vector2.z;
					while (vector.z < sourceObjectBounds.center.z + sourceObjectBounds.extents.z)
					{
						Gizmos.DrawWireCube(vector + cellSize / 2f, cellSize);
						vector.z += cellSize.z;
					}
					vector.y += cellSize.y;
				}
				vector.x += cellSize.x;
			}
		}
	}
	[Serializable]
	public class MB3_MeshBakerGrouperPie : MB3_MeshBakerGrouperCore
	{
		public MB3_MeshBakerGrouperPie(GrouperData data)
		{
			d = data;
		}

		public override Dictionary<string, List<Renderer>> FilterIntoGroups(List<GameObject> selection)
		{
			Dictionary<string, List<Renderer>> dictionary = new Dictionary<string, List<Renderer>>();
			if (d.pieNumSegments == 0)
			{
				UnityEngine.Debug.LogError("pieNumSegments must be greater than zero.");
				return dictionary;
			}
			if (d.pieAxis.magnitude <= 1E-06f)
			{
				UnityEngine.Debug.LogError("Pie axis must have length greater than zero.");
				return dictionary;
			}
			d.pieAxis.Normalize();
			Quaternion quaternion = Quaternion.FromToRotation(d.pieAxis, Vector3.up);
			UnityEngine.Debug.Log("Collecting renderers in each cell");
			foreach (GameObject item in selection)
			{
				if (item == null)
				{
					continue;
				}
				Renderer component = item.GetComponent<Renderer>();
				if (!(component is MeshRenderer) && !(component is SkinnedMeshRenderer))
				{
					continue;
				}
				Vector3 vector = component.bounds.center - d.origin;
				vector.Normalize();
				vector = quaternion * vector;
				float num = 0f;
				if (Mathf.Abs(vector.x) < 0.0001f && Mathf.Abs(vector.z) < 0.0001f)
				{
					num = 0f;
				}
				else
				{
					num = Mathf.Atan2(vector.x, vector.z) * 57.29578f;
					if (num < 0f)
					{
						num = 360f + num;
					}
				}
				int num2 = Mathf.FloorToInt(num / 360f * (float)d.pieNumSegments);
				List<Renderer> list = null;
				string key = "seg_" + num2;
				if (dictionary.ContainsKey(key))
				{
					list = dictionary[key];
				}
				else
				{
					list = new List<Renderer>();
					dictionary.Add(key, list);
				}
				if (!list.Contains(component))
				{
					list.Add(component);
				}
			}
			return dictionary;
		}

		public override void DrawGizmos(Bounds sourceObjectBounds)
		{
			if (!(d.pieAxis.magnitude < 0.1f) && d.pieNumSegments >= 1)
			{
				float magnitude = sourceObjectBounds.extents.magnitude;
				DrawCircle(d.pieAxis, d.origin, magnitude, 24);
				Quaternion quaternion = Quaternion.FromToRotation(Vector3.up, d.pieAxis);
				Quaternion quaternion2 = Quaternion.AngleAxis(180f / (float)d.pieNumSegments, Vector3.up);
				Vector3 vector = Vector3.forward;
				for (int i = 0; i < d.pieNumSegments; i++)
				{
					Vector3 vector2 = quaternion * vector;
					Gizmos.DrawLine(d.origin, d.origin + vector2 * magnitude);
					vector = quaternion2 * vector;
					vector = quaternion2 * vector;
				}
			}
		}

		public static void DrawCircle(Vector3 axis, Vector3 center, float radius, int subdiv)
		{
			Quaternion quaternion = Quaternion.AngleAxis(360 / subdiv, axis);
			Vector3 vector = new Vector3(axis.y, 0f - axis.x, axis.z);
			vector.Normalize();
			vector *= radius;
			for (int i = 0; i < subdiv + 1; i++)
			{
				Vector3 vector2 = quaternion * vector;
				Gizmos.DrawLine(center + vector, center + vector2);
				vector = vector2;
			}
		}
	}
	[Serializable]
	public class MB3_MeshBakerGrouperKMeans : MB3_MeshBakerGrouperCore
	{
		public int numClusters = 4;

		public Vector3[] clusterCenters = new Vector3[0];

		public float[] clusterSizes = new float[0];

		public MB3_MeshBakerGrouperKMeans(GrouperData data)
		{
			d = data;
		}

		public override Dictionary<string, List<Renderer>> FilterIntoGroups(List<GameObject> selection)
		{
			Dictionary<string, List<Renderer>> dictionary = new Dictionary<string, List<Renderer>>();
			List<GameObject> list = new List<GameObject>();
			int num = 20;
			foreach (GameObject item in selection)
			{
				if (!(item == null))
				{
					GameObject gameObject = item;
					Renderer component = gameObject.GetComponent<Renderer>();
					if (component is MeshRenderer || component is SkinnedMeshRenderer)
					{
						list.Add(gameObject);
					}
				}
			}
			if (list.Count > 0 && num > 0 && num < list.Count)
			{
				MB3_KMeansClustering mB3_KMeansClustering = new MB3_KMeansClustering(list, num);
				mB3_KMeansClustering.Cluster();
				clusterCenters = new Vector3[num];
				clusterSizes = new float[num];
				for (int i = 0; i < num; i++)
				{
					List<Renderer> cluster = mB3_KMeansClustering.GetCluster(i, out clusterCenters[i], out clusterSizes[i]);
					if (cluster.Count > 0)
					{
						dictionary.Add("Cluster_" + i, cluster);
					}
				}
			}
			return dictionary;
		}

		public override void DrawGizmos(Bounds sceneObjectBounds)
		{
			if (clusterCenters != null && clusterSizes != null && clusterCenters.Length == clusterSizes.Length)
			{
				for (int i = 0; i < clusterSizes.Length; i++)
				{
					Gizmos.DrawWireSphere(clusterCenters[i], clusterSizes[i]);
				}
			}
		}
	}
	[Serializable]
	public class MB3_MeshBakerGrouperCluster : MB3_MeshBakerGrouperCore
	{
		public MB3_AgglomerativeClustering cluster;

		private float _lastMaxDistBetweenClusters;

		public float _ObjsExtents = 10f;

		public float _minDistBetweenClusters = 0.001f;

		private List<MB3_AgglomerativeClustering.ClusterNode> _clustersToDraw = new List<MB3_AgglomerativeClustering.ClusterNode>();

		private float[] _radii;

		public MB3_MeshBakerGrouperCluster(GrouperData data, List<GameObject> gos)
		{
			d = data;
		}

		public override Dictionary<string, List<Renderer>> FilterIntoGroups(List<GameObject> selection)
		{
			Dictionary<string, List<Renderer>> dictionary = new Dictionary<string, List<Renderer>>();
			for (int i = 0; i < _clustersToDraw.Count; i++)
			{
				MB3_AgglomerativeClustering.ClusterNode clusterNode = _clustersToDraw[i];
				List<Renderer> list = new List<Renderer>();
				for (int j = 0; j < clusterNode.leafs.Length; j++)
				{
					Renderer component = cluster.clusters[clusterNode.leafs[j]].leaf.go.GetComponent<Renderer>();
					if (component is MeshRenderer || component is SkinnedMeshRenderer)
					{
						list.Add(component);
					}
				}
				dictionary.Add("Cluster_" + i, list);
			}
			return dictionary;
		}

		public void BuildClusters(List<GameObject> gos, ProgressUpdateCancelableDelegate progFunc)
		{
			if (gos.Count == 0)
			{
				UnityEngine.Debug.LogWarning("No objects to cluster. Add some objects to the list of Objects To Combine.");
				return;
			}
			if (cluster == null)
			{
				cluster = new MB3_AgglomerativeClustering();
			}
			List<MB3_AgglomerativeClustering.item_s> list = new List<MB3_AgglomerativeClustering.item_s>();
			int i;
			for (i = 0; i < gos.Count; i++)
			{
				if (gos[i] != null && list.Find((MB3_AgglomerativeClustering.item_s x) => x.go == gos[i]) == null)
				{
					Renderer component = gos[i].GetComponent<Renderer>();
					if (component != null && (component is MeshRenderer || component is SkinnedMeshRenderer))
					{
						MB3_AgglomerativeClustering.item_s item_s = new MB3_AgglomerativeClustering.item_s();
						item_s.go = gos[i];
						item_s.coord = component.bounds.center;
						list.Add(item_s);
					}
				}
			}
			cluster.items = list;
			cluster.agglomerate(progFunc);
			if (!cluster.wasCanceled)
			{
				_BuildListOfClustersToDraw(progFunc, out var smallest, out var largest);
				d.maxDistBetweenClusters = Mathf.Lerp(smallest, largest, 0.9f);
			}
		}

		private void _BuildListOfClustersToDraw(ProgressUpdateCancelableDelegate progFunc, out float smallest, out float largest)
		{
			_clustersToDraw.Clear();
			if (cluster.clusters == null)
			{
				smallest = 1f;
				largest = 10f;
				return;
			}
			progFunc?.Invoke("Building Clusters To Draw A:", 0f);
			List<MB3_AgglomerativeClustering.ClusterNode> list = new List<MB3_AgglomerativeClustering.ClusterNode>();
			largest = 1f;
			smallest = 10000000f;
			for (int i = 0; i < cluster.clusters.Length; i++)
			{
				MB3_AgglomerativeClustering.ClusterNode clusterNode = cluster.clusters[i];
				if (clusterNode.distToMergedCentroid <= d.maxDistBetweenClusters)
				{
					if (d.includeCellsWithOnlyOneRenderer)
					{
						_clustersToDraw.Add(clusterNode);
					}
					else if (clusterNode.leaf == null)
					{
						_clustersToDraw.Add(clusterNode);
					}
				}
				if (clusterNode.distToMergedCentroid > largest)
				{
					largest = clusterNode.distToMergedCentroid;
				}
				if (clusterNode.height > 0 && clusterNode.distToMergedCentroid < smallest)
				{
					smallest = clusterNode.distToMergedCentroid;
				}
			}
			progFunc?.Invoke("Building Clusters To Draw B:", 0f);
			for (int j = 0; j < _clustersToDraw.Count; j++)
			{
				list.Add(_clustersToDraw[j].cha);
				list.Add(_clustersToDraw[j].chb);
			}
			for (int k = 0; k < list.Count; k++)
			{
				_clustersToDraw.Remove(list[k]);
			}
			_radii = new float[_clustersToDraw.Count];
			progFunc?.Invoke("Building Clusters To Draw C:", 0f);
			for (int l = 0; l < _radii.Length; l++)
			{
				MB3_AgglomerativeClustering.ClusterNode clusterNode2 = _clustersToDraw[l];
				Bounds bounds = new Bounds(clusterNode2.centroid, Vector3.one);
				for (int m = 0; m < clusterNode2.leafs.Length; m++)
				{
					Renderer component = cluster.clusters[clusterNode2.leafs[m]].leaf.go.GetComponent<Renderer>();
					if (component != null)
					{
						bounds.Encapsulate(component.bounds);
					}
				}
				_radii[l] = bounds.extents.magnitude;
			}
			progFunc?.Invoke("Building Clusters To Draw D:", 0f);
			_ObjsExtents = largest + 1f;
			_minDistBetweenClusters = Mathf.Lerp(smallest, 0f, 0.9f);
			if (_ObjsExtents < 2f)
			{
				_ObjsExtents = 2f;
			}
		}

		public override void DrawGizmos(Bounds sceneObjectBounds)
		{
			if (cluster != null && cluster.clusters != null)
			{
				if (_lastMaxDistBetweenClusters != d.maxDistBetweenClusters)
				{
					_BuildListOfClustersToDraw(null, out var _, out var _);
					_lastMaxDistBetweenClusters = d.maxDistBetweenClusters;
				}
				for (int i = 0; i < _clustersToDraw.Count; i++)
				{
					Gizmos.color = Color.white;
					Gizmos.DrawWireSphere(_clustersToDraw[i].centroid, _radii[i]);
				}
			}
		}
	}
	public interface TextureBlender
	{
		bool DoesShaderNameMatch(string shaderName);

		void OnBeforeTintTexture(Material sourceMat, string shaderTexturePropertyName);

		Color OnBlendTexturePixel(string shaderPropertyName, Color pixelColor);

		bool NonTexturePropertiesAreEqual(Material a, Material b);

		void SetNonTexturePropertyValuesOnResultMaterial(Material resultMaterial);

		Color GetColorIfNoTexture(Material m, ShaderTextureProperty texPropertyName);
	}
	public class TextureBlenderFallback : TextureBlender
	{
		private bool m_doTintColor;

		private Color m_tintColor;

		private Color m_defaultColor = Color.white;

		public bool DoesShaderNameMatch(string shaderName)
		{
			return true;
		}

		public void OnBeforeTintTexture(Material sourceMat, string shaderTexturePropertyName)
		{
			if (shaderTexturePropertyName.Equals("_MainTex"))
			{
				m_doTintColor = true;
				m_tintColor = Color.white;
				if (sourceMat.HasProperty("_Color"))
				{
					m_tintColor = sourceMat.GetColor("_Color");
				}
				else if (sourceMat.HasProperty("_TintColor"))
				{
					m_tintColor = sourceMat.GetColor("_TintColor");
				}
			}
			else
			{
				m_doTintColor = false;
			}
		}

		public Color OnBlendTexturePixel(string shaderPropertyName, Color pixelColor)
		{
			if (m_doTintColor)
			{
				return new Color(pixelColor.r * m_tintColor.r, pixelColor.g * m_tintColor.g, pixelColor.b * m_tintColor.b, pixelColor.a * m_tintColor.a);
			}
			return pixelColor;
		}

		public bool NonTexturePropertiesAreEqual(Material a, Material b)
		{
			if (a.HasProperty("_Color"))
			{
				if (_compareColor(a, b, m_defaultColor, "_Color"))
				{
					return true;
				}
			}
			else if (a.HasProperty("_TintColor") && _compareColor(a, b, m_defaultColor, "_TintColor"))
			{
				return true;
			}
			return false;
		}

		public void SetNonTexturePropertyValuesOnResultMaterial(Material resultMaterial)
		{
			if (resultMaterial.HasProperty("_Color"))
			{
				resultMaterial.SetColor("_Color", m_defaultColor);
			}
			else if (resultMaterial.HasProperty("_TintColor"))
			{
				resultMaterial.SetColor("_TintColor", m_defaultColor);
			}
		}

		public Color GetColorIfNoTexture(Material mat, ShaderTextureProperty texProperty)
		{
			if (texProperty.isNormalMap)
			{
				return new Color(0.5f, 0.5f, 1f);
			}
			if (texProperty.name.Equals("_MainTex"))
			{
				if (mat != null && mat.HasProperty("_Color"))
				{
					try
					{
						return mat.GetColor("_Color");
					}
					catch (Exception)
					{
					}
				}
				else if (mat != null && mat.HasProperty("_TintColor"))
				{
					try
					{
						return mat.GetColor("_TintColor");
					}
					catch (Exception)
					{
					}
				}
			}
			else if (texProperty.name.Equals("_SpecGlossMap"))
			{
				if (mat != null && mat.HasProperty("_SpecColor"))
				{
					try
					{
						Color color = mat.GetColor("_SpecColor");
						if (mat.HasProperty("_Glossiness"))
						{
							try
							{
								color.a = mat.GetFloat("_Glossiness");
							}
							catch (Exception)
							{
							}
						}
						UnityEngine.Debug.LogWarning(color);
						return color;
					}
					catch (Exception)
					{
					}
				}
			}
			else if (texProperty.name.Equals("_MetallicGlossMap"))
			{
				if (mat != null && mat.HasProperty("_Metallic"))
				{
					try
					{
						float @float = mat.GetFloat("_Metallic");
						Color result = new Color(@float, @float, @float);
						if (mat.HasProperty("_Glossiness"))
						{
							try
							{
								result.a = mat.GetFloat("_Glossiness");
							}
							catch (Exception)
							{
							}
						}
						return result;
					}
					catch (Exception)
					{
					}
				}
			}
			else
			{
				if (texProperty.name.Equals("_ParallaxMap"))
				{
					return new Color(0f, 0f, 0f, 0f);
				}
				if (texProperty.name.Equals("_OcclusionMap"))
				{
					return new Color(1f, 1f, 1f, 1f);
				}
				if (texProperty.name.Equals("_EmissionMap"))
				{
					if (mat != null && mat.HasProperty("_EmissionScaleUI"))
					{
						if (mat.HasProperty("_EmissionColor") && mat.HasProperty("_EmissionColorUI"))
						{
							try
							{
								Color color2 = mat.GetColor("_EmissionColor");
								Color color3 = mat.GetColor("_EmissionColorUI");
								float float2 = mat.GetFloat("_EmissionScaleUI");
								if (color2 == new Color(0f, 0f, 0f, 0f) && color3 == new Color(1f, 1f, 1f, 1f))
								{
									return new Color(float2, float2, float2, float2);
								}
								return color3;
							}
							catch (Exception)
							{
							}
						}
						else
						{
							try
							{
								float float3 = mat.GetFloat("_EmissionScaleUI");
								return new Color(float3, float3, float3, float3);
							}
							catch (Exception)
							{
							}
						}
					}
				}
				else if (texProperty.name.Equals("_DetailMask"))
				{
					return new Color(0f, 0f, 0f, 0f);
				}
			}
			return new Color(1f, 1f, 1f, 0f);
		}

		public static bool _compareColor(Material a, Material b, Color defaultVal, string propertyName)
		{
			Color color = defaultVal;
			Color color2 = defaultVal;
			if (a.HasProperty(propertyName))
			{
				color = a.GetColor(propertyName);
			}
			if (b.HasProperty(propertyName))
			{
				color2 = b.GetColor(propertyName);
			}
			if (color != color2)
			{
				return false;
			}
			return true;
		}

		public static bool _compareFloat(Material a, Material b, float defaultVal, string propertyName)
		{
			float num = defaultVal;
			float num2 = defaultVal;
			if (a.HasProperty(propertyName))
			{
				num = a.GetFloat(propertyName);
			}
			if (b.HasProperty(propertyName))
			{
				num2 = b.GetFloat(propertyName);
			}
			if (num != num2)
			{
				return false;
			}
			return true;
		}
	}
	public class TextureBlenderLegacyBumpDiffuse : TextureBlender
	{
		private bool doColor;

		private Color m_tintColor;

		private Color m_defaultTintColor = Color.white;

		public bool DoesShaderNameMatch(string shaderName)
		{
			if (shaderName.Equals("Legacy Shaders/Bumped Diffuse"))
			{
				return true;
			}
			if (shaderName.Equals("Bumped Diffuse"))
			{
				return true;
			}
			return false;
		}

		public void OnBeforeTintTexture(Material sourceMat, string shaderTexturePropertyName)
		{
			if (shaderTexturePropertyName.EndsWith("_MainTex"))
			{
				doColor = true;
				m_tintColor = sourceMat.GetColor("_Color");
			}
			else
			{
				doColor = false;
			}
		}

		public Color OnBlendTexturePixel(string propertyToDoshaderPropertyName, Color pixelColor)
		{
			if (doColor)
			{
				return new Color(pixelColor.r * m_tintColor.r, pixelColor.g * m_tintColor.g, pixelColor.b * m_tintColor.b, pixelColor.a * m_tintColor.a);
			}
			return pixelColor;
		}

		public bool NonTexturePropertiesAreEqual(Material a, Material b)
		{
			return TextureBlenderFallback._compareColor(a, b, m_defaultTintColor, "_Color");
		}

		public void SetNonTexturePropertyValuesOnResultMaterial(Material resultMaterial)
		{
			resultMaterial.SetColor("_Color", Color.white);
		}

		public Color GetColorIfNoTexture(Material m, ShaderTextureProperty texPropertyName)
		{
			if (texPropertyName.name.Equals("_BumpMap"))
			{
				return new Color(0.5f, 0.5f, 1f);
			}
			if (texPropertyName.name.Equals("_MainTex") && m != null && m.HasProperty("_Color"))
			{
				try
				{
					return m.GetColor("_Color");
				}
				catch (Exception)
				{
				}
			}
			return new Color(1f, 1f, 1f, 0f);
		}
	}
	public class TextureBlenderLegacyDiffuse : TextureBlender
	{
		private bool doColor;

		private Color m_tintColor;

		private Color m_defaultTintColor = Color.white;

		public bool DoesShaderNameMatch(string shaderName)
		{
			if (shaderName.Equals("Legacy Shaders/Diffuse"))
			{
				return true;
			}
			if (shaderName.Equals("Diffuse"))
			{
				return true;
			}
			return false;
		}

		public void OnBeforeTintTexture(Material sourceMat, string shaderTexturePropertyName)
		{
			if (shaderTexturePropertyName.EndsWith("_MainTex"))
			{
				doColor = true;
				m_tintColor = sourceMat.GetColor("_Color");
			}
			else
			{
				doColor = false;
			}
		}

		public Color OnBlendTexturePixel(string propertyToDoshaderPropertyName, Color pixelColor)
		{
			if (doColor)
			{
				return new Color(pixelColor.r * m_tintColor.r, pixelColor.g * m_tintColor.g, pixelColor.b * m_tintColor.b, pixelColor.a * m_tintColor.a);
			}
			return pixelColor;
		}

		public bool NonTexturePropertiesAreEqual(Material a, Material b)
		{
			return TextureBlenderFallback._compareColor(a, b, m_defaultTintColor, "_Color");
		}

		public void SetNonTexturePropertyValuesOnResultMaterial(Material resultMaterial)
		{
			resultMaterial.SetColor("_Color", Color.white);
		}

		public Color GetColorIfNoTexture(Material m, ShaderTextureProperty texPropertyName)
		{
			if (texPropertyName.name.Equals("_MainTex") && m != null && m.HasProperty("_Color"))
			{
				try
				{
					return m.GetColor("_Color");
				}
				catch (Exception)
				{
				}
			}
			return new Color(1f, 1f, 1f, 0f);
		}
	}
	public class TextureBlenderMaterialPropertyCacheHelper
	{
		private struct MaterialPropertyPair
		{
			public Material material;

			public string property;

			public MaterialPropertyPair(Material m, string prop)
			{
				material = m;
				property = prop;
			}

			public override bool Equals(object obj)
			{
				if (!(obj is MaterialPropertyPair materialPropertyPair))
				{
					return false;
				}
				if (!material.Equals(materialPropertyPair.material))
				{
					return false;
				}
				if (property != materialPropertyPair.property)
				{
					return false;
				}
				return true;
			}

			public override int GetHashCode()
			{
				return base.GetHashCode();
			}
		}

		private Dictionary<MaterialPropertyPair, object> nonTexturePropertyValuesForSourceMaterials = new Dictionary<MaterialPropertyPair, object>();

		private bool AllNonTexturePropertyValuesAreEqual(string prop)
		{
			bool flag = false;
			object obj = null;
			foreach (MaterialPropertyPair key in nonTexturePropertyValuesForSourceMaterials.Keys)
			{
				if (key.property.Equals(prop))
				{
					if (!flag)
					{
						obj = nonTexturePropertyValuesForSourceMaterials[key];
						flag = true;
					}
					else if (!obj.Equals(nonTexturePropertyValuesForSourceMaterials[key]))
					{
						return false;
					}
				}
			}
			return true;
		}

		public void CacheMaterialProperty(Material m, string property, object value)
		{
			nonTexturePropertyValuesForSourceMaterials[new MaterialPropertyPair(m, property)] = value;
		}

		public object GetValueIfAllSourceAreTheSameOrDefault(string property, object defaultValue)
		{
			if (AllNonTexturePropertyValuesAreEqual(property))
			{
				foreach (MaterialPropertyPair key in nonTexturePropertyValuesForSourceMaterials.Keys)
				{
					if (key.property.Equals(property))
					{
						return nonTexturePropertyValuesForSourceMaterials[key];
					}
				}
			}
			return defaultValue;
		}
	}
	public class TextureBlenderStandardMetallic : TextureBlender
	{
		private enum Prop
		{
			doColor,
			doMetallic,
			doEmission,
			doBump,
			doNone
		}

		private static Color NeutralNormalMap = new Color(0.5f, 0.5f, 1f);

		private TextureBlenderMaterialPropertyCacheHelper sourceMaterialPropertyCache = new TextureBlenderMaterialPropertyCacheHelper();

		private Color m_tintColor;

		private float m_glossiness;

		private float m_glossMapScale;

		private float m_metallic;

		private bool m_hasMetallicGlossMap;

		private float m_bumpScale;

		private bool m_shaderDoesEmission;

		private Color m_emissionColor;

		private Prop propertyToDo = Prop.doNone;

		private Color m_generatingTintedAtlasColor = Color.white;

		private float m_generatingTintedAtlasMetallic;

		private float m_generatingTintedAtlasGlossiness = 1f;

		private float m_generatingTintedAtlasGlossMapScale = 1f;

		private float m_generatingTintedAtlasBumpScale = 1f;

		private Color m_generatingTintedAtlasEmission = Color.white;

		private Color m_notGeneratingAtlasDefaultColor = Color.white;

		private float m_notGeneratingAtlasDefaultMetallic;

		private float m_notGeneratingAtlasDefaultGlossiness = 0.5f;

		private Color m_notGeneratingAtlasDefaultEmisionColor = Color.black;

		public bool DoesShaderNameMatch(string shaderName)
		{
			return shaderName.Equals("Standard");
		}

		public void OnBeforeTintTexture(Material sourceMat, string shaderTexturePropertyName)
		{
			if (shaderTexturePropertyName.Equals("_MainTex"))
			{
				propertyToDo = Prop.doColor;
				if (sourceMat.HasProperty("_Color"))
				{
					m_tintColor = sourceMat.GetColor("_Color");
				}
				else
				{
					m_tintColor = m_generatingTintedAtlasColor;
				}
			}
			else if (shaderTexturePropertyName.Equals("_MetallicGlossMap"))
			{
				propertyToDo = Prop.doMetallic;
				m_metallic = m_generatingTintedAtlasMetallic;
				if (sourceMat.GetTexture("_MetallicGlossMap") != null)
				{
					m_hasMetallicGlossMap = true;
				}
				else
				{
					m_hasMetallicGlossMap = false;
				}
				if (sourceMat.HasProperty("_Metallic"))
				{
					m_metallic = sourceMat.GetFloat("_Metallic");
				}
				else
				{
					m_metallic = 0f;
				}
				if (sourceMat.HasProperty("_GlossMapScale"))
				{
					m_glossMapScale = sourceMat.GetFloat("_GlossMapScale");
				}
				else
				{
					m_glossMapScale = 1f;
				}
				if (sourceMat.HasProperty("_Glossiness"))
				{
					m_glossiness = sourceMat.GetFloat("_Glossiness");
				}
				else
				{
					m_glossiness = 0f;
				}
			}
			else if (shaderTexturePropertyName.Equals("_BumpMap"))
			{
				propertyToDo = Prop.doBump;
				if (sourceMat.HasProperty(shaderTexturePropertyName))
				{
					if (sourceMat.HasProperty("_BumpScale"))
					{
						m_bumpScale = sourceMat.GetFloat("_BumpScale");
					}
				}
				else
				{
					m_bumpScale = m_generatingTintedAtlasBumpScale;
				}
			}
			else if (shaderTexturePropertyName.Equals("_EmissionMap"))
			{
				propertyToDo = Prop.doEmission;
				m_shaderDoesEmission = sourceMat.IsKeywordEnabled("_EMISSION");
				if (sourceMat.HasProperty("_EmissionColor"))
				{
					m_emissionColor = sourceMat.GetColor("_EmissionColor");
				}
				else
				{
					m_emissionColor = m_notGeneratingAtlasDefaultEmisionColor;
				}
			}
			else
			{
				propertyToDo = Prop.doNone;
			}
		}

		public Color OnBlendTexturePixel(string propertyToDoshaderPropertyName, Color pixelColor)
		{
			if (propertyToDo == Prop.doColor)
			{
				return new Color(pixelColor.r * m_tintColor.r, pixelColor.g * m_tintColor.g, pixelColor.b * m_tintColor.b, pixelColor.a * m_tintColor.a);
			}
			if (propertyToDo == Prop.doMetallic)
			{
				if (m_hasMetallicGlossMap)
				{
					pixelColor = new Color(pixelColor.r, pixelColor.g, pixelColor.b, pixelColor.a * m_glossMapScale);
					return pixelColor;
				}
				return new Color(m_metallic, 0f, 0f, m_glossiness);
			}
			if (propertyToDo == Prop.doBump)
			{
				return Color.Lerp(NeutralNormalMap, pixelColor, m_bumpScale);
			}
			if (propertyToDo == Prop.doEmission)
			{
				if (m_shaderDoesEmission)
				{
					return new Color(pixelColor.r * m_emissionColor.r, pixelColor.g * m_emissionColor.g, pixelColor.b * m_emissionColor.b, pixelColor.a * m_emissionColor.a);
				}
				return Color.black;
			}
			return pixelColor;
		}

		public bool NonTexturePropertiesAreEqual(Material a, Material b)
		{
			if (!TextureBlenderFallback._compareColor(a, b, m_notGeneratingAtlasDefaultColor, "_Color"))
			{
				return false;
			}
			if (!TextureBlenderFallback._compareFloat(a, b, m_notGeneratingAtlasDefaultGlossiness, "_Glossiness"))
			{
				return false;
			}
			bool flag = a.HasProperty("_MetallicGlossMap") && a.GetTexture("_MetallicGlossMap") != null;
			bool flag2 = b.HasProperty("_MetallicGlossMap") && b.GetTexture("_MetallicGlossMap") != null;
			if (flag && flag2)
			{
				if (!TextureBlenderFallback._compareFloat(a, b, m_notGeneratingAtlasDefaultMetallic, "_GlossMapScale"))
				{
					return false;
				}
			}
			else
			{
				if (flag || flag2)
				{
					return false;
				}
				if (!TextureBlenderFallback._compareFloat(a, b, m_notGeneratingAtlasDefaultMetallic, "_Metallic"))
				{
					return false;
				}
			}
			if (a.IsKeywordEnabled("_EMISSION") != b.IsKeywordEnabled("_EMISSION"))
			{
				return false;
			}
			if (a.IsKeywordEnabled("_EMISSION") && !TextureBlenderFallback._compareColor(a, b, m_notGeneratingAtlasDefaultEmisionColor, "_EmissionColor"))
			{
				return false;
			}
			return true;
		}

		public void SetNonTexturePropertyValuesOnResultMaterial(Material resultMaterial)
		{
			if (resultMaterial.GetTexture("_MainTex") != null)
			{
				resultMaterial.SetColor("_Color", m_generatingTintedAtlasColor);
			}
			else
			{
				resultMaterial.SetColor("_Color", (Color)sourceMaterialPropertyCache.GetValueIfAllSourceAreTheSameOrDefault("_Color", m_notGeneratingAtlasDefaultColor));
			}
			if (resultMaterial.GetTexture("_MetallicGlossMap") != null)
			{
				resultMaterial.SetFloat("_Metallic", m_generatingTintedAtlasMetallic);
				resultMaterial.SetFloat("_GlossMapScale", m_generatingTintedAtlasGlossMapScale);
				resultMaterial.SetFloat("_Glossiness", m_generatingTintedAtlasGlossiness);
			}
			else
			{
				resultMaterial.SetFloat("_Metallic", (float)sourceMaterialPropertyCache.GetValueIfAllSourceAreTheSameOrDefault("_Metallic", m_notGeneratingAtlasDefaultMetallic));
				resultMaterial.SetFloat("_Glossiness", (float)sourceMaterialPropertyCache.GetValueIfAllSourceAreTheSameOrDefault("_Glossiness", m_notGeneratingAtlasDefaultGlossiness));
			}
			if (resultMaterial.GetTexture("_BumpMap") != null)
			{
				resultMaterial.SetFloat("_BumpScale", m_generatingTintedAtlasBumpScale);
			}
			if (resultMaterial.GetTexture("_EmissionMap") != null)
			{
				resultMaterial.EnableKeyword("_EMISSION");
				resultMaterial.SetColor("_EmissionColor", m_generatingTintedAtlasEmission);
			}
			else
			{
				resultMaterial.DisableKeyword("_EMISSION");
				resultMaterial.SetColor("_EmissionColor", (Color)sourceMaterialPropertyCache.GetValueIfAllSourceAreTheSameOrDefault("_EmissionColor", m_notGeneratingAtlasDefaultEmisionColor));
			}
		}

		public Color GetColorIfNoTexture(Material mat, ShaderTextureProperty texPropertyName)
		{
			if (texPropertyName.name.Equals("_BumpMap"))
			{
				return new Color(0.5f, 0.5f, 1f);
			}
			if (texPropertyName.name.Equals("_MainTex"))
			{
				if (mat != null && mat.HasProperty("_Color"))
				{
					try
					{
						Color color = mat.GetColor("_Color");
						sourceMaterialPropertyCache.CacheMaterialProperty(mat, "_Color", color);
					}
					catch (Exception)
					{
					}
					return Color.white;
				}
			}
			else
			{
				if (texPropertyName.name.Equals("_MetallicGlossMap"))
				{
					if (mat != null && mat.HasProperty("_Metallic"))
					{
						try
						{
							float @float = mat.GetFloat("_Metallic");
							Color color2 = new Color(@float, @float, @float);
							if (mat.HasProperty("_Glossiness"))
							{
								try
								{
									color2.a = mat.GetFloat("_Glossiness");
								}
								catch (Exception)
								{
								}
							}
							sourceMaterialPropertyCache.CacheMaterialProperty(mat, "_Metallic", @float);
							sourceMaterialPropertyCache.CacheMaterialProperty(mat, "_Glossiness", color2.a);
						}
						catch (Exception)
						{
						}
						return new Color(0f, 0f, 0f, 0.5f);
					}
					return new Color(0f, 0f, 0f, 0.5f);
				}
				if (texPropertyName.name.Equals("_ParallaxMap"))
				{
					return new Color(0f, 0f, 0f, 0f);
				}
				if (texPropertyName.name.Equals("_OcclusionMap"))
				{
					return new Color(1f, 1f, 1f, 1f);
				}
				if (texPropertyName.name.Equals("_EmissionMap"))
				{
					if (mat != null)
					{
						if (!mat.IsKeywordEnabled("_EMISSION"))
						{
							return Color.black;
						}
						if (!mat.HasProperty("_EmissionColor"))
						{
							return Color.black;
						}
						try
						{
							Color color3 = mat.GetColor("_EmissionColor");
							sourceMaterialPropertyCache.CacheMaterialProperty(mat, "_EmissionColor", color3);
						}
						catch (Exception)
						{
						}
					}
				}
				else if (texPropertyName.name.Equals("_DetailMask"))
				{
					return new Color(0f, 0f, 0f, 0f);
				}
			}
			return new Color(1f, 1f, 1f, 0f);
		}
	}
	public class TextureBlenderStandardMetallicRoughness : TextureBlender
	{
		private enum Prop
		{
			doColor,
			doMetallic,
			doRoughness,
			doEmission,
			doBump,
			doNone
		}

		private static Color NeutralNormalMap = new Color(0.5f, 0.5f, 1f);

		private TextureBlenderMaterialPropertyCacheHelper sourceMaterialPropertyCache = new TextureBlenderMaterialPropertyCacheHelper();

		private Color m_tintColor;

		private float m_roughness;

		private float m_metallic;

		private bool m_hasMetallicGlossMap;

		private bool m_hasSpecGlossMap;

		private float m_bumpScale;

		private bool m_shaderDoesEmission;

		private Color m_emissionColor;

		private Prop propertyToDo = Prop.doNone;

		private Color m_generatingTintedAtlasColor = Color.white;

		private float m_generatingTintedAtlasMetallic;

		private float m_generatingTintedAtlasRoughness = 0.5f;

		private float m_generatingTintedAtlasBumpScale = 1f;

		private Color m_generatingTintedAtlasEmission = Color.white;

		private Color m_notGeneratingAtlasDefaultColor = Color.white;

		private float m_notGeneratingAtlasDefaultMetallic;

		private float m_notGeneratingAtlasDefaultGlossiness = 0.5f;

		private Color m_notGeneratingAtlasDefaultEmisionColor = Color.black;

		public bool DoesShaderNameMatch(string shaderName)
		{
			return shaderName.Equals("Standard (Roughness setup)");
		}

		public void OnBeforeTintTexture(Material sourceMat, string shaderTexturePropertyName)
		{
			if (shaderTexturePropertyName.Equals("_MainTex"))
			{
				propertyToDo = Prop.doColor;
				if (sourceMat.HasProperty("_Color"))
				{
					m_tintColor = sourceMat.GetColor("_Color");
				}
				else
				{
					m_tintColor = m_generatingTintedAtlasColor;
				}
			}
			else if (shaderTexturePropertyName.Equals("_MetallicGlossMap"))
			{
				propertyToDo = Prop.doMetallic;
				m_metallic = m_generatingTintedAtlasMetallic;
				if (sourceMat.GetTexture("_MetallicGlossMap") != null)
				{
					m_hasMetallicGlossMap = true;
				}
				else
				{
					m_hasMetallicGlossMap = false;
				}
				if (sourceMat.HasProperty("_Metallic"))
				{
					m_metallic = sourceMat.GetFloat("_Metallic");
				}
				else
				{
					m_metallic = 0f;
				}
			}
			else if (shaderTexturePropertyName.Equals("_SpecGlossMap"))
			{
				propertyToDo = Prop.doRoughness;
				m_roughness = m_generatingTintedAtlasRoughness;
				if (sourceMat.GetTexture("_SpecGlossMap") != null)
				{
					m_hasSpecGlossMap = true;
				}
				else
				{
					m_hasSpecGlossMap = false;
				}
				if (sourceMat.HasProperty("_Glossiness"))
				{
					m_roughness = sourceMat.GetFloat("_Glossiness");
				}
				else
				{
					m_roughness = 1f;
				}
			}
			else if (shaderTexturePropertyName.Equals("_BumpMap"))
			{
				propertyToDo = Prop.doBump;
				if (sourceMat.HasProperty(shaderTexturePropertyName))
				{
					if (sourceMat.HasProperty("_BumpScale"))
					{
						m_bumpScale = sourceMat.GetFloat("_BumpScale");
					}
				}
				else
				{
					m_bumpScale = m_generatingTintedAtlasBumpScale;
				}
			}
			else if (shaderTexturePropertyName.Equals("_EmissionMap"))
			{
				propertyToDo = Prop.doEmission;
				m_shaderDoesEmission = sourceMat.IsKeywordEnabled("_EMISSION");
				if (sourceMat.HasProperty("_EmissionColor"))
				{
					m_emissionColor = sourceMat.GetColor("_EmissionColor");
				}
				else
				{
					m_emissionColor = m_notGeneratingAtlasDefaultEmisionColor;
				}
			}
			else
			{
				propertyToDo = Prop.doNone;
			}
		}

		public Color OnBlendTexturePixel(string propertyToDoshaderPropertyName, Color pixelColor)
		{
			if (propertyToDo == Prop.doColor)
			{
				return new Color(pixelColor.r * m_tintColor.r, pixelColor.g * m_tintColor.g, pixelColor.b * m_tintColor.b, pixelColor.a * m_tintColor.a);
			}
			if (propertyToDo == Prop.doMetallic)
			{
				if (m_hasMetallicGlossMap)
				{
					return pixelColor;
				}
				return new Color(m_metallic, 0f, 0f, m_roughness);
			}
			if (propertyToDo == Prop.doRoughness)
			{
				if (m_hasSpecGlossMap)
				{
					return pixelColor;
				}
				return new Color(m_roughness, 0f, 0f, 0f);
			}
			if (propertyToDo == Prop.doBump)
			{
				return Color.Lerp(NeutralNormalMap, pixelColor, m_bumpScale);
			}
			if (propertyToDo == Prop.doEmission)
			{
				if (m_shaderDoesEmission)
				{
					return new Color(pixelColor.r * m_emissionColor.r, pixelColor.g * m_emissionColor.g, pixelColor.b * m_emissionColor.b, pixelColor.a * m_emissionColor.a);
				}
				return Color.black;
			}
			return pixelColor;
		}

		public bool NonTexturePropertiesAreEqual(Material a, Material b)
		{
			if (!TextureBlenderFallback._compareColor(a, b, m_notGeneratingAtlasDefaultColor, "_Color"))
			{
				return false;
			}
			bool num = a.HasProperty("_MetallicGlossMap") && a.GetTexture("_MetallicGlossMap") != null;
			bool flag = b.HasProperty("_MetallicGlossMap") && b.GetTexture("_MetallicGlossMap") != null;
			if (!num && !flag)
			{
				if (!TextureBlenderFallback._compareFloat(a, b, m_notGeneratingAtlasDefaultMetallic, "_Metallic"))
				{
					return false;
				}
				bool num2 = a.HasProperty("_SpecGlossMap") && a.GetTexture("_SpecGlossMap") != null;
				bool flag2 = b.HasProperty("_SpecGlossMap") && b.GetTexture("_SpecGlossMap") != null;
				if (!num2 && !flag2)
				{
					if (!TextureBlenderFallback._compareFloat(a, b, m_generatingTintedAtlasRoughness, "_Glossiness"))
					{
						return false;
					}
					if (!TextureBlenderFallback._compareFloat(a, b, m_generatingTintedAtlasBumpScale, "_bumpScale"))
					{
						return false;
					}
					if (!TextureBlenderFallback._compareFloat(a, b, m_generatingTintedAtlasRoughness, "_Glossiness"))
					{
						return false;
					}
					if (a.IsKeywordEnabled("_EMISSION") != b.IsKeywordEnabled("_EMISSION"))
					{
						return false;
					}
					if (a.IsKeywordEnabled("_EMISSION") && !TextureBlenderFallback._compareColor(a, b, m_generatingTintedAtlasEmission, "_EmissionColor"))
					{
						return false;
					}
					return true;
				}
				return false;
			}
			return false;
		}

		public void SetNonTexturePropertyValuesOnResultMaterial(Material resultMaterial)
		{
			if (resultMaterial.GetTexture("_MainTex") != null)
			{
				resultMaterial.SetColor("_Color", m_generatingTintedAtlasColor);
			}
			else
			{
				resultMaterial.SetColor("_Color", (Color)sourceMaterialPropertyCache.GetValueIfAllSourceAreTheSameOrDefault("_Color", m_notGeneratingAtlasDefaultColor));
			}
			if (resultMaterial.GetTexture("_MetallicGlossMap") != null)
			{
				resultMaterial.SetFloat("_Metallic", m_generatingTintedAtlasMetallic);
			}
			else
			{
				resultMaterial.SetFloat("_Metallic", (float)sourceMaterialPropertyCache.GetValueIfAllSourceAreTheSameOrDefault("_Metallic", m_notGeneratingAtlasDefaultMetallic));
			}
			if (!(resultMaterial.GetTexture("_SpecGlossMap") != null))
			{
				resultMaterial.SetFloat("_Glossiness", (float)sourceMaterialPropertyCache.GetValueIfAllSourceAreTheSameOrDefault("_Glossiness", m_notGeneratingAtlasDefaultGlossiness));
			}
			if (resultMaterial.GetTexture("_BumpMap") != null)
			{
				resultMaterial.SetFloat("_BumpScale", m_generatingTintedAtlasBumpScale);
			}
			else
			{
				resultMaterial.SetFloat("_BumpScale", m_generatingTintedAtlasBumpScale);
			}
			if (resultMaterial.GetTexture("_EmissionMap") != null)
			{
				resultMaterial.EnableKeyword("_EMISSION");
				resultMaterial.SetColor("_EmissionColor", Color.white);
			}
			else
			{
				resultMaterial.DisableKeyword("_EMISSION");
				resultMaterial.SetColor("_EmissionColor", (Color)sourceMaterialPropertyCache.GetValueIfAllSourceAreTheSameOrDefault("_EmissionColor", m_notGeneratingAtlasDefaultEmisionColor));
			}
		}

		public Color GetColorIfNoTexture(Material mat, ShaderTextureProperty texPropertyName)
		{
			if (texPropertyName.name.Equals("_BumpMap"))
			{
				return new Color(0.5f, 0.5f, 1f);
			}
			if (texPropertyName.name.Equals("_MainTex"))
			{
				if (mat != null && mat.HasProperty("_Color"))
				{
					try
					{
						Color color = mat.GetColor("_Color");
						sourceMaterialPropertyCache.CacheMaterialProperty(mat, "_Color", color);
					}
					catch (Exception)
					{
					}
					return Color.white;
				}
			}
			else
			{
				if (texPropertyName.name.Equals("_MetallicGlossMap"))
				{
					if (mat != null && mat.HasProperty("_Metallic"))
					{
						try
						{
							float @float = mat.GetFloat("_Metallic");
							sourceMaterialPropertyCache.CacheMaterialProperty(mat, "_Metallic", @float);
						}
						catch (Exception)
						{
						}
						return new Color(0f, 0f, 0f, 0.5f);
					}
					return new Color(0f, 0f, 0f, 0.5f);
				}
				if (texPropertyName.name.Equals("_SpecGlossMap"))
				{
					bool flag = false;
					try
					{
						Color color2 = new Color(0f, 0f, 0f, 0.5f);
						if (mat.HasProperty("_Glossiness"))
						{
							try
							{
								flag = true;
								color2.a = mat.GetFloat("_Glossiness");
							}
							catch (Exception)
							{
							}
						}
						sourceMaterialPropertyCache.CacheMaterialProperty(mat, "_Glossiness", color2.a);
						return new Color(0f, 0f, 0f, 0.5f);
					}
					catch (Exception)
					{
					}
					if (!flag)
					{
						return new Color(0f, 0f, 0f, 0.5f);
					}
				}
				else
				{
					if (texPropertyName.name.Equals("_ParallaxMap"))
					{
						return new Color(0f, 0f, 0f, 0f);
					}
					if (texPropertyName.name.Equals("_OcclusionMap"))
					{
						return new Color(1f, 1f, 1f, 1f);
					}
					if (texPropertyName.name.Equals("_EmissionMap"))
					{
						if (mat != null)
						{
							if (!mat.IsKeywordEnabled("_EMISSION"))
							{
								return Color.black;
							}
							if (!mat.HasProperty("_EmissionColor"))
							{
								return Color.black;
							}
							try
							{
								Color color3 = mat.GetColor("_EmissionColor");
								sourceMaterialPropertyCache.CacheMaterialProperty(mat, "_EmissionColor", color3);
							}
							catch (Exception)
							{
							}
						}
					}
					else if (texPropertyName.name.Equals("_DetailMask"))
					{
						return new Color(0f, 0f, 0f, 0f);
					}
				}
			}
			return new Color(1f, 1f, 1f, 0f);
		}
	}
	public class TextureBlenderStandardSpecular : TextureBlender
	{
		private enum Prop
		{
			doColor,
			doSpecular,
			doEmission,
			doBump,
			doNone
		}

		private static Color NeutralNormalMap = new Color(0.5f, 0.5f, 1f);

		private TextureBlenderMaterialPropertyCacheHelper sourceMaterialPropertyCache = new TextureBlenderMaterialPropertyCacheHelper();

		private Color m_tintColor;

		private float m_glossiness;

		private float m_SpecGlossMapScale;

		private Color m_specColor;

		private bool m_hasSpecGlossMap;

		private float m_bumpScale;

		private bool m_shaderDoesEmission;

		private Color m_emissionColor;

		private Prop propertyToDo = Prop.doNone;

		private Color m_generatingTintedAtlaColor = Color.white;

		private Color m_generatingTintedAtlaSpecular = Color.black;

		private float m_generatingTintedAtlaGlossiness = 1f;

		private float m_generatingTintedAtlaSpecGlossMapScale = 1f;

		private float m_generatingTintedAtlaBumpScale = 1f;

		private Color m_generatingTintedAtlaEmission = Color.white;

		private Color m_notGeneratingAtlasDefaultColor = Color.white;

		private Color m_notGeneratingAtlasDefaultSpecularColor = new Color(0f, 0f, 0f, 1f);

		private float m_notGeneratingAtlasDefaultGlossiness = 0.5f;

		private Color m_notGeneratingAtlasDefaultEmisionColor = Color.black;

		public bool DoesShaderNameMatch(string shaderName)
		{
			return shaderName.Equals("Standard (Specular setup)");
		}

		public void OnBeforeTintTexture(Material sourceMat, string shaderTexturePropertyName)
		{
			if (shaderTexturePropertyName.Equals("_MainTex"))
			{
				propertyToDo = Prop.doColor;
				if (sourceMat.HasProperty("_Color"))
				{
					m_tintColor = sourceMat.GetColor("_Color");
				}
				else
				{
					m_tintColor = m_generatingTintedAtlaColor;
				}
			}
			else if (shaderTexturePropertyName.Equals("_SpecGlossMap"))
			{
				propertyToDo = Prop.doSpecular;
				m_specColor = m_generatingTintedAtlaSpecular;
				if (sourceMat.GetTexture("_SpecGlossMap") != null)
				{
					m_hasSpecGlossMap = true;
				}
				else
				{
					m_hasSpecGlossMap = false;
				}
				if (sourceMat.HasProperty("_SpecColor"))
				{
					m_specColor = sourceMat.GetColor("_SpecColor");
				}
				else
				{
					m_specColor = new Color(0f, 0f, 0f, 1f);
				}
				if (sourceMat.HasProperty("_GlossMapScale"))
				{
					m_SpecGlossMapScale = sourceMat.GetFloat("_GlossMapScale");
				}
				else
				{
					m_SpecGlossMapScale = 1f;
				}
				if (sourceMat.HasProperty("_Glossiness"))
				{
					m_glossiness = sourceMat.GetFloat("_Glossiness");
				}
				else
				{
					m_glossiness = 0f;
				}
			}
			else if (shaderTexturePropertyName.Equals("_BumpMap"))
			{
				propertyToDo = Prop.doBump;
				if (sourceMat.HasProperty(shaderTexturePropertyName))
				{
					if (sourceMat.HasProperty("_BumpScale"))
					{
						m_bumpScale = sourceMat.GetFloat("_BumpScale");
					}
				}
				else
				{
					m_bumpScale = m_generatingTintedAtlaBumpScale;
				}
			}
			else if (shaderTexturePropertyName.Equals("_EmissionMap"))
			{
				propertyToDo = Prop.doEmission;
				m_shaderDoesEmission = sourceMat.IsKeywordEnabled("_EMISSION");
				if (sourceMat.HasProperty("_EmissionColor"))
				{
					m_emissionColor = sourceMat.GetColor("_EmissionColor");
				}
				else
				{
					m_generatingTintedAtlaColor = m_notGeneratingAtlasDefaultEmisionColor;
				}
			}
			else
			{
				propertyToDo = Prop.doNone;
			}
		}

		public Color OnBlendTexturePixel(string propertyToDoshaderPropertyName, Color pixelColor)
		{
			if (propertyToDo == Prop.doColor)
			{
				return new Color(pixelColor.r * m_tintColor.r, pixelColor.g * m_tintColor.g, pixelColor.b * m_tintColor.b, pixelColor.a * m_tintColor.a);
			}
			if (propertyToDo == Prop.doSpecular)
			{
				if (m_hasSpecGlossMap)
				{
					pixelColor = new Color(pixelColor.r, pixelColor.g, pixelColor.b, pixelColor.a * m_SpecGlossMapScale);
					return pixelColor;
				}
				Color specColor = m_specColor;
				specColor.a = m_glossiness;
				return specColor;
			}
			if (propertyToDo == Prop.doBump)
			{
				return Color.Lerp(NeutralNormalMap, pixelColor, m_bumpScale);
			}
			if (propertyToDo == Prop.doEmission)
			{
				if (m_shaderDoesEmission)
				{
					return new Color(pixelColor.r * m_emissionColor.r, pixelColor.g * m_emissionColor.g, pixelColor.b * m_emissionColor.b, pixelColor.a * m_emissionColor.a);
				}
				return Color.black;
			}
			return pixelColor;
		}

		public bool NonTexturePropertiesAreEqual(Material a, Material b)
		{
			if (!TextureBlenderFallback._compareColor(a, b, m_generatingTintedAtlaColor, "_Color"))
			{
				return false;
			}
			if (!TextureBlenderFallback._compareColor(a, b, m_generatingTintedAtlaSpecular, "_SpecColor"))
			{
				return false;
			}
			bool flag = a.HasProperty("_SpecGlossMap") && a.GetTexture("_SpecGlossMap") != null;
			bool flag2 = b.HasProperty("_SpecGlossMap") && b.GetTexture("_SpecGlossMap") != null;
			if (flag && flag2)
			{
				if (!TextureBlenderFallback._compareFloat(a, b, m_generatingTintedAtlaSpecGlossMapScale, "_GlossMapScale"))
				{
					return false;
				}
			}
			else
			{
				if (flag || flag2)
				{
					return false;
				}
				if (!TextureBlenderFallback._compareFloat(a, b, m_generatingTintedAtlaGlossiness, "_Glossiness"))
				{
					return false;
				}
			}
			if (!TextureBlenderFallback._compareFloat(a, b, m_generatingTintedAtlaBumpScale, "_BumpScale"))
			{
				return false;
			}
			if (a.IsKeywordEnabled("_EMISSION") != b.IsKeywordEnabled("_EMISSION"))
			{
				return false;
			}
			if (a.IsKeywordEnabled("_EMISSION") && !TextureBlenderFallback._compareColor(a, b, m_generatingTintedAtlaEmission, "_EmissionColor"))
			{
				return false;
			}
			return true;
		}

		public void SetNonTexturePropertyValuesOnResultMaterial(Material resultMaterial)
		{
			if (resultMaterial.GetTexture("_MainTex") != null)
			{
				resultMaterial.SetColor("_Color", m_generatingTintedAtlaColor);
			}
			else
			{
				resultMaterial.SetColor("_Color", (Color)sourceMaterialPropertyCache.GetValueIfAllSourceAreTheSameOrDefault("_Color", m_notGeneratingAtlasDefaultColor));
			}
			if (resultMaterial.GetTexture("_SpecGlossMap") != null)
			{
				resultMaterial.SetColor("_SpecColor", m_generatingTintedAtlaSpecular);
				resultMaterial.SetFloat("_GlossMapScale", m_generatingTintedAtlaSpecGlossMapScale);
				resultMaterial.SetFloat("_Glossiness", m_generatingTintedAtlaGlossiness);
			}
			else
			{
				resultMaterial.SetColor("_SpecColor", (Color)sourceMaterialPropertyCache.GetValueIfAllSourceAreTheSameOrDefault("_SpecColor", m_notGeneratingAtlasDefaultSpecularColor));
				resultMaterial.SetFloat("_Glossiness", (float)sourceMaterialPropertyCache.GetValueIfAllSourceAreTheSameOrDefault("_Glossiness", m_notGeneratingAtlasDefaultGlossiness));
			}
			if (resultMaterial.GetTexture("_BumpMap") != null)
			{
				resultMaterial.SetFloat("_BumpScale", m_generatingTintedAtlaBumpScale);
			}
			else
			{
				resultMaterial.SetFloat("_BumpScale", m_generatingTintedAtlaBumpScale);
			}
			if (resultMaterial.GetTexture("_EmissionMap") != null)
			{
				resultMaterial.EnableKeyword("_EMISSION");
				resultMaterial.SetColor("_EmissionColor", Color.white);
			}
			else
			{
				resultMaterial.DisableKeyword("_EMISSION");
				resultMaterial.SetColor("_EmissionColor", (Color)sourceMaterialPropertyCache.GetValueIfAllSourceAreTheSameOrDefault("_EmissionColor", m_notGeneratingAtlasDefaultEmisionColor));
			}
		}

		public Color GetColorIfNoTexture(Material mat, ShaderTextureProperty texPropertyName)
		{
			if (texPropertyName.name.Equals("_BumpMap"))
			{
				return new Color(0.5f, 0.5f, 1f);
			}
			if (texPropertyName.name.Equals("_MainTex"))
			{
				if (mat != null && mat.HasProperty("_Color"))
				{
					try
					{
						Color color = mat.GetColor("_Color");
						sourceMaterialPropertyCache.CacheMaterialProperty(mat, "_Color", color);
					}
					catch (Exception)
					{
					}
					return Color.white;
				}
			}
			else
			{
				if (texPropertyName.name.Equals("_SpecGlossMap"))
				{
					if (mat != null && mat.HasProperty("_SpecColor"))
					{
						try
						{
							Color color2 = mat.GetColor("_SpecColor");
							if (mat.HasProperty("_Glossiness"))
							{
								try
								{
									color2.a = mat.GetFloat("_Glossiness");
								}
								catch (Exception)
								{
								}
							}
							sourceMaterialPropertyCache.CacheMaterialProperty(mat, "_SpecColor", color2);
							sourceMaterialPropertyCache.CacheMaterialProperty(mat, "_Glossiness", color2.a);
						}
						catch (Exception)
						{
						}
					}
					return new Color(0f, 0f, 0f, 0.5f);
				}
				if (texPropertyName.name.Equals("_ParallaxMap"))
				{
					return new Color(0f, 0f, 0f, 0f);
				}
				if (texPropertyName.name.Equals("_OcclusionMap"))
				{
					return new Color(1f, 1f, 1f, 1f);
				}
				if (texPropertyName.name.Equals("_EmissionMap"))
				{
					if (mat != null)
					{
						if (!mat.IsKeywordEnabled("_EMISSION"))
						{
							return Color.black;
						}
						if (!mat.HasProperty("_EmissionColor"))
						{
							return Color.black;
						}
						try
						{
							Color color3 = mat.GetColor("_EmissionColor");
							sourceMaterialPropertyCache.CacheMaterialProperty(mat, "_EmissionColor", color3);
						}
						catch (Exception)
						{
						}
					}
				}
				else if (texPropertyName.name.Equals("_DetailMask"))
				{
					return new Color(0f, 0f, 0f, 0f);
				}
			}
			return new Color(1f, 1f, 1f, 0f);
		}
	}
	public delegate void ProgressUpdateDelegate(string msg, float progress);
	public delegate bool ProgressUpdateCancelableDelegate(string msg, float progress);
	public enum MB_ObjsToCombineTypes
	{
		prefabOnly,
		sceneObjOnly,
		dontCare
	}
	public enum MB_OutputOptions
	{
		bakeIntoPrefab,
		bakeMeshsInPlace,
		bakeTextureAtlasesOnly,
		bakeIntoSceneObject
	}
	public enum MB_RenderType
	{
		meshRenderer,
		skinnedMeshRenderer
	}
	public enum MB2_OutputOptions
	{
		bakeIntoSceneObject,
		bakeMeshAssetsInPlace,
		bakeIntoPrefab
	}
	public enum MB2_LightmapOptions
	{
		preserve_current_lightmapping,
		ignore_UV2,
		copy_UV2_unchanged,
		generate_new_UV2_layout,
		copy_UV2_unchanged_to_separate_rects
	}
	public enum MB2_PackingAlgorithmEnum
	{
		UnitysPackTextures,
		MeshBakerTexturePacker,
		MeshBakerTexturePacker_Fast,
		MeshBakerTexturePacker_Horizontal,
		MeshBakerTexturePacker_Vertical
	}
	public enum MB_TextureTilingTreatment
	{
		none,
		considerUVs,
		edgeToEdgeX,
		edgeToEdgeY,
		edgeToEdgeXY,
		unknown
	}
	public enum MB2_ValidationLevel
	{
		none,
		quick,
		robust
	}
	public interface MB2_EditorMethodsInterface
	{
		void Clear();

		void RestoreReadFlagsAndFormats(ProgressUpdateDelegate progressInfo);

		void SetReadWriteFlag(Texture2D tx, bool isReadable, bool addToList);

		void AddTextureFormat(Texture2D tx, bool isNormalMap);

		void SaveAtlasToAssetDatabase(Texture2D atlas, ShaderTextureProperty texPropertyName, int atlasNum, Material resMat);

		bool IsNormalMap(Texture2D tx);

		string GetPlatformString();

		void SetTextureSize(Texture2D tx, int size);

		bool IsCompressed(Texture2D tx);

		void CheckBuildSettings(long estimatedAtlasSize);

		bool CheckPrefabTypes(MB_ObjsToCombineTypes prefabType, List<GameObject> gos);

		bool ValidateSkinnedMeshes(List<GameObject> mom);

		void CommitChangesToAssets();

		void OnPreTextureBake();

		void OnPostTextureBake();

		void Destroy(UnityEngine.Object o);
	}
	public enum MB2_LogLevel
	{
		none,
		error,
		warn,
		info,
		debug,
		trace
	}
	public class MB2_Log
	{
		public static void Log(MB2_LogLevel l, string msg, MB2_LogLevel currentThreshold)
		{
			if (l <= currentThreshold)
			{
				if (l == MB2_LogLevel.error)
				{
					UnityEngine.Debug.LogError(msg);
				}
				if (l == MB2_LogLevel.warn)
				{
					UnityEngine.Debug.LogWarning($"frm={Time.frameCount} WARN {msg}");
				}
				if (l == MB2_LogLevel.info)
				{
					UnityEngine.Debug.Log($"frm={Time.frameCount} INFO {msg}");
				}
				if (l == MB2_LogLevel.debug)
				{
					UnityEngine.Debug.Log($"frm={Time.frameCount} DEBUG {msg}");
				}
				if (l == MB2_LogLevel.trace)
				{
					UnityEngine.Debug.Log($"frm={Time.frameCount} TRACE {msg}");
				}
			}
		}

		public static string Error(string msg, params object[] args)
		{
			string arg = string.Format(msg, args);
			string text = $"f={Time.frameCount} ERROR {arg}";
			UnityEngine.Debug.LogError(text);
			return text;
		}

		public static string Warn(string msg, params object[] args)
		{
			string arg = string.Format(msg, args);
			string text = $"f={Time.frameCount} WARN {arg}";
			UnityEngine.Debug.LogWarning(text);
			return text;
		}

		public static string Info(string msg, params object[] args)
		{
			string arg = string.Format(msg, args);
			string text = $"f={Time.frameCount} INFO {arg}";
			UnityEngine.Debug.Log(text);
			return text;
		}

		public static string LogDebug(string msg, params object[] args)
		{
			string arg = string.Format(msg, args);
			string text = $"f={Time.frameCount} DEBUG {arg}";
			UnityEngine.Debug.Log(text);
			return text;
		}

		public static string Trace(string msg, params object[] args)
		{
			string arg = string.Format(msg, args);
			string text = $"f={Time.frameCount} TRACE {arg}";
			UnityEngine.Debug.Log(text);
			return text;
		}
	}
	public class ObjectLog
	{
		private int pos;

		private string[] logMessages;

		private void _CacheLogMessage(string msg)
		{
			if (logMessages.Length != 0)
			{
				logMessages[pos] = msg;
				pos++;
				if (pos >= logMessages.Length)
				{
					pos = 0;
				}
			}
		}

		public ObjectLog(short bufferSize)
		{
			logMessages = new string[bufferSize];
		}

		public void Log(MB2_LogLevel l, string msg, MB2_LogLevel currentThreshold)
		{
			MB2_Log.Log(l, msg, currentThreshold);
			_CacheLogMessage(msg);
		}

		public void Error(string msg, params object[] args)
		{
			_CacheLogMessage(MB2_Log.Error(msg, args));
		}

		public void Warn(string msg, params object[] args)
		{
			_CacheLogMessage(MB2_Log.Warn(msg, args));
		}

		public void Info(string msg, params object[] args)
		{
			_CacheLogMessage(MB2_Log.Info(msg, args));
		}

		public void LogDebug(string msg, params object[] args)
		{
			_CacheLogMessage(MB2_Log.LogDebug(msg, args));
		}

		public void Trace(string msg, params object[] args)
		{
			_CacheLogMessage(MB2_Log.Trace(msg, args));
		}

		public string Dump()
		{
			StringBuilder stringBuilder = new StringBuilder();
			int num = 0;
			if (logMessages[logMessages.Length - 1] != null)
			{
				num = pos;
			}
			for (int i = 0; i < logMessages.Length; i++)
			{
				int num2 = (num + i) % logMessages.Length;
				if (logMessages[num2] == null)
				{
					break;
				}
				stringBuilder.AppendLine(logMessages[num2]);
			}
			return stringBuilder.ToString();
		}
	}
	public interface MBVersionInterface
	{
		string version();

		int GetMajorVersion();

		int GetMinorVersion();

		bool GetActive(GameObject go);

		void SetActive(GameObject go, bool isActive);

		void SetActiveRecursively(GameObject go, bool isActive);

		UnityEngine.Object[] FindSceneObjectsOfType(Type t);

		bool IsRunningAndMeshNotReadWriteable(Mesh m);

		Vector2[] GetMeshUV3orUV4(Mesh m, bool get3, MB2_LogLevel LOG_LEVEL);

		void MeshClear(Mesh m, bool t);

		void MeshAssignUV3(Mesh m, Vector2[] uv3s);

		void MeshAssignUV4(Mesh m, Vector2[] uv4s);

		Vector4 GetLightmapTilingOffset(Renderer r);

		Transform[] GetBones(Renderer r);

		void OptimizeMesh(Mesh m);

		int GetBlendShapeFrameCount(Mesh m, int shapeIndex);

		float GetBlendShapeFrameWeight(Mesh m, int shapeIndex, int frameIndex);

		void GetBlendShapeFrameVertices(Mesh m, int shapeIndex, int frameIndex, Vector3[] vs, Vector3[] ns, Vector3[] ts);

		void ClearBlendShapes(Mesh m);

		void AddBlendShapeFrame(Mesh m, string nm, float wt, Vector3[] vs, Vector3[] ns, Vector3[] ts);

		int MaxMeshVertexCount();

		void SetMeshIndexFormatAndClearMesh(Mesh m, int numVerts, bool vertices, bool justClearTriangles);
	}
	public class MBVersion
	{
		private static MBVersionInterface _MBVersion;

		private static MBVersionInterface _CreateMBVersionConcrete()
		{
			return (MBVersionInterface)Activator.CreateInstance(typeof(MBVersionConcrete));
		}

		public static string version()
		{
			if (_MBVersion == null)
			{
				_MBVersion = _CreateMBVersionConcrete();
			}
			return _MBVersion.version();
		}

		public static int GetMajorVersion()
		{
			if (_MBVersion == null)
			{
				_MBVersion = _CreateMBVersionConcrete();
			}
			return _MBVersion.GetMajorVersion();
		}

		public static int GetMinorVersion()
		{
			if (_MBVersion == null)
			{
				_MBVersion = _CreateMBVersionConcrete();
			}
			return _MBVersion.GetMinorVersion();
		}

		public static bool GetActive(GameObject go)
		{
			if (_MBVersion == null)
			{
				_MBVersion = _CreateMBVersionConcrete();
			}
			return _MBVersion.GetActive(go);
		}

		public static void SetActive(GameObject go, bool isActive)
		{
			if (_MBVersion == null)
			{
				_MBVersion = _CreateMBVersionConcrete();
			}
			_MBVersion.SetActive(go, isActive);
		}

		public static void SetActiveRecursively(GameObject go, bool isActive)
		{
			if (_MBVersion == null)
			{
				_MBVersion = _CreateMBVersionConcrete();
			}
			_MBVersion.SetActiveRecursively(go, isActive);
		}

		public static UnityEngine.Object[] FindSceneObjectsOfType(Type t)
		{
			if (_MBVersion == null)
			{
				_MBVersion = _CreateMBVersionConcrete();
			}
			return _MBVersion.FindSceneObjectsOfType(t);
		}

		public static bool IsRunningAndMeshNotReadWriteable(Mesh m)
		{
			if (_MBVersion == null)
			{
				_MBVersion = _CreateMBVersionConcrete();
			}
			return _MBVersion.IsRunningAndMeshNotReadWriteable(m);
		}

		public static Vector2[] GetMeshUV3orUV4(Mesh m, bool get3, MB2_LogLevel LOG_LEVEL)
		{
			if (_MBVersion == null)
			{
				_MBVersion = _CreateMBVersionConcrete();
			}
			return _MBVersion.GetMeshUV3orUV4(m, get3, LOG_LEVEL);
		}

		public static void MeshClear(Mesh m, bool t)
		{
			if (_MBVersion == null)
			{
				_MBVersion = _CreateMBVersionConcrete();
			}
			_MBVersion.MeshClear(m, t);
		}

		public static void MeshAssignUV3(Mesh m, Vector2[] uv3s)
		{
			if (_MBVersion == null)
			{
				_MBVersion = _CreateMBVersionConcrete();
			}
			_MBVersion.MeshAssignUV3(m, uv3s);
		}

		public static void MeshAssignUV4(Mesh m, Vector2[] uv4s)
		{
			if (_MBVersion == null)
			{
				_MBVersion = _CreateMBVersionConcrete();
			}
			_MBVersion.MeshAssignUV4(m, uv4s);
		}

		public static Vector4 GetLightmapTilingOffset(Renderer r)
		{
			if (_MBVersion == null)
			{
				_MBVersion = _CreateMBVersionConcrete();
			}
			return _MBVersion.GetLightmapTilingOffset(r);
		}

		public static Transform[] GetBones(Renderer r)
		{
			if (_MBVersion == null)
			{
				_MBVersion = _CreateMBVersionConcrete();
			}
			return _MBVersion.GetBones(r);
		}

		public static void OptimizeMesh(Mesh m)
		{
			if (_MBVersion == null)
			{
				_MBVersion = _CreateMBVersionConcrete();
			}
			_MBVersion.OptimizeMesh(m);
		}

		public static int GetBlendShapeFrameCount(Mesh m, int shapeIndex)
		{
			if (_MBVersion == null)
			{
				_MBVersion = _CreateMBVersionConcrete();
			}
			return _MBVersion.GetBlendShapeFrameCount(m, shapeIndex);
		}

		public static float GetBlendShapeFrameWeight(Mesh m, int shapeIndex, int frameIndex)
		{
			if (_MBVersion == null)
			{
				_MBVersion = _CreateMBVersionConcrete();
			}
			return _MBVersion.GetBlendShapeFrameWeight(m, shapeIndex, frameIndex);
		}

		public static void GetBlendShapeFrameVertices(Mesh m, int shapeIndex, int frameIndex, Vector3[] vs, Vector3[] ns, Vector3[] ts)
		{
			if (_MBVersion == null)
			{
				_MBVersion = _CreateMBVersionConcrete();
			}
			_MBVersion.GetBlendShapeFrameVertices(m, shapeIndex, frameIndex, vs, ns, ts);
		}

		public static void ClearBlendShapes(Mesh m)
		{
			if (_MBVersion == null)
			{
				_MBVersion = _CreateMBVersionConcrete();
			}
			_MBVersion.ClearBlendShapes(m);
		}

		public static void AddBlendShapeFrame(Mesh m, string nm, float wt, Vector3[] vs, Vector3[] ns, Vector3[] ts)
		{
			if (_MBVersion == null)
			{
				_MBVersion = _CreateMBVersionConcrete();
			}
			_MBVersion.AddBlendShapeFrame(m, nm, wt, vs, ns, ts);
		}

		public static int MaxMeshVertexCount()
		{
			if (_MBVersion == null)
			{
				_MBVersion = _CreateMBVersionConcrete();
			}
			return _MBVersion.MaxMeshVertexCount();
		}

		public static void SetMeshIndexFormatAndClearMesh(Mesh m, int numVerts, bool vertices, bool justClearTriangles)
		{
			if (_MBVersion == null)
			{
				_MBVersion = _CreateMBVersionConcrete();
			}
			_MBVersion.SetMeshIndexFormatAndClearMesh(m, numVerts, vertices, justClearTriangles);
		}
	}
	[Serializable]
	public class MB3_AgglomerativeClustering
	{
		[Serializable]
		public class ClusterNode
		{
			public item_s leaf;

			public ClusterNode cha;

			public ClusterNode chb;

			public int height;

			public float distToMergedCentroid;

			public Vector3 centroid;

			public int[] leafs;

			public int idx;

			public bool isUnclustered = true;

			public ClusterNode(item_s ii, int index)
			{
				leaf = ii;
				idx = index;
				leafs = new int[1];
				leafs[0] = index;
				centroid = ii.coord;
				height = 0;
			}

			public ClusterNode(ClusterNode a, ClusterNode b, int index, int h, float dist, ClusterNode[] clusters)
			{
				cha = a;
				chb = b;
				idx = index;
				leafs = new int[a.leafs.Length + b.leafs.Length];
				Array.Copy(a.leafs, leafs, a.leafs.Length);
				Array.Copy(b.leafs, 0, leafs, a.leafs.Length, b.leafs.Length);
				Vector3 zero = Vector3.zero;
				for (int i = 0; i < leafs.Length; i++)
				{
					zero += clusters[leafs[i]].centroid;
				}
				centroid = zero / leafs.Length;
				height = h;
				distToMergedCentroid = dist;
			}
		}

		[Serializable]
		public class item_s
		{
			public GameObject go;

			public Vector3 coord;
		}

		public class ClusterDistance
		{
			public ClusterNode a;

			public ClusterNode b;

			public ClusterDistance(ClusterNode aa, ClusterNode bb)
			{
				a = aa;
				b = bb;
			}
		}

		public List<item_s> items = new List<item_s>();

		public ClusterNode[] clusters;

		public bool wasCanceled;

		private const int MAX_PRIORITY_Q_SIZE = 2048;

		private float euclidean_distance(Vector3 a, Vector3 b)
		{
			return Vector3.Distance(a, b);
		}

		public bool agglomerate(ProgressUpdateCancelableDelegate progFunc)
		{
			wasCanceled = true;
			if (progFunc != null)
			{
				wasCanceled = progFunc("Filling Priority Queue:", 0f);
			}
			if (items.Count <= 1)
			{
				clusters = new ClusterNode[0];
				return false;
			}
			clusters = new ClusterNode[items.Count * 2 - 1];
			for (int i = 0; i < items.Count; i++)
			{
				clusters[i] = new ClusterNode(items[i], i);
			}
			int num = items.Count;
			List<ClusterNode> list = new List<ClusterNode>();
			for (int j = 0; j < num; j++)
			{
				clusters[j].isUnclustered = true;
				list.Add(clusters[j]);
			}
			int num2 = 0;
			new Stopwatch().Start();
			float num3 = 0f;
			long num4 = GC.GetTotalMemory(forceFullCollection: false) / 1000000;
			PriorityQueue<float, ClusterDistance> priorityQueue = new PriorityQueue<float, ClusterDistance>();
			int num5 = 0;
			while (list.Count > 1)
			{
				int num6 = 0;
				num2++;
				if (priorityQueue.Count == 0)
				{
					num5++;
					num4 = GC.GetTotalMemory(forceFullCollection: false) / 1000000;
					if (progFunc != null)
					{
						wasCanceled = progFunc("Refilling Q:" + (float)(items.Count - list.Count) * 100f / (float)items.Count + " unclustered:" + list.Count + " inQ:" + priorityQueue.Count + " usedMem:" + num4, (float)(items.Count - list.Count) / (float)items.Count);
					}
					num3 = _RefillPriorityQWithSome(priorityQueue, list, clusters, progFunc);
					if (priorityQueue.Count == 0)
					{
						break;
					}
				}
				KeyValuePair<float, ClusterDistance> keyValuePair = priorityQueue.Dequeue();
				while (!keyValuePair.Value.a.isUnclustered || !keyValuePair.Value.b.isUnclustered)
				{
					if (priorityQueue.Count == 0)
					{
						num5++;
						num4 = GC.GetTotalMemory(forceFullCollection: false) / 1000000;
						if (progFunc != null)
						{
							wasCanceled = progFunc("Creating clusters:" + (float)(items.Count - list.Count) * 100f / (float)items.Count + " unclustered:" + list.Count + " inQ:" + priorityQueue.Count + " usedMem:" + num4, (float)(items.Count - list.Count) / (float)items.Count);
						}
						num3 = _RefillPriorityQWithSome(priorityQueue, list, clusters, progFunc);
						if (priorityQueue.Count == 0)
						{
							break;
						}
					}
					keyValuePair = priorityQueue.Dequeue();
					num6++;
				}
				num++;
				ClusterNode clusterNode = new ClusterNode(keyValuePair.Value.a, keyValuePair.Value.b, num - 1, num2, keyValuePair.Key, clusters);
				list.Remove(keyValuePair.Value.a);
				list.Remove(keyValuePair.Value.b);
				keyValuePair.Value.a.isUnclustered = false;
				keyValuePair.Value.b.isUnclustered = false;
				int num7 = num - 1;
				if (num7 == clusters.Length)
				{
					UnityEngine.Debug.LogError("how did this happen");
				}
				clusters[num7] = clusterNode;
				list.Add(clusterNode);
				clusterNode.isUnclustered = true;
				for (int k = 0; k < list.Count - 1; k++)
				{
					float num8 = euclidean_distance(clusterNode.centroid, list[k].centroid);
					if (num8 < num3)
					{
						priorityQueue.Add(new KeyValuePair<float, ClusterDistance>(num8, new ClusterDistance(clusterNode, list[k])));
					}
				}
				if (wasCanceled)
				{
					break;
				}
				num4 = GC.GetTotalMemory(forceFullCollection: false) / 1000000;
				if (progFunc != null)
				{
					wasCanceled = progFunc("Creating clusters:" + (float)(items.Count - list.Count) * 100f / (float)items.Count + " unclustered:" + list.Count + " inQ:" + priorityQueue.Count + " usedMem:" + num4, (float)(items.Count - list.Count) / (float)items.Count);
				}
			}
			if (progFunc != null)
			{
				wasCanceled = progFunc("Finished clustering:", 100f);
			}
			if (wasCanceled)
			{
				return false;
			}
			return true;
		}

		private float _RefillPriorityQWithSome(PriorityQueue<float, ClusterDistance> pq, List<ClusterNode> unclustered, ClusterNode[] clusters, ProgressUpdateCancelableDelegate progFunc)
		{
			List<float> list = new List<float>(2048);
			for (int i = 0; i < unclustered.Count; i++)
			{
				for (int j = i + 1; j < unclustered.Count; j++)
				{
					list.Add(euclidean_distance(unclustered[i].centroid, unclustered[j].centroid));
				}
				wasCanceled = progFunc("Refilling Queue Part A:", (float)i / ((float)unclustered.Count * 2f));
				if (wasCanceled)
				{
					return 10f;
				}
			}
			if (list.Count == 0)
			{
				return 1E+11f;
			}
			float num = NthSmallestElement(list, 2048);
			for (int k = 0; k < unclustered.Count; k++)
			{
				for (int l = k + 1; l < unclustered.Count; l++)
				{
					int idx = unclustered[k].idx;
					int idx2 = unclustered[l].idx;
					float num2 = euclidean_distance(unclustered[k].centroid, unclustered[l].centroid);
					if (num2 <= num)
					{
						pq.Add(new KeyValuePair<float, ClusterDistance>(num2, new ClusterDistance(clusters[idx], clusters[idx2])));
					}
				}
				wasCanceled = progFunc("Refilling Queue Part B:", (float)(unclustered.Count + k) / ((float)unclustered.Count * 2f));
				if (wasCanceled)
				{
					return 10f;
				}
			}
			return num;
		}

		public int TestRun(List<GameObject> gos)
		{
			List<item_s> list = new List<item_s>();
			for (int i = 0; i < gos.Count; i++)
			{
				item_s item_s = new item_s();
				item_s.go = gos[i];
				item_s.coord = gos[i].transform.position;
				list.Add(item_s);
			}
			items = list;
			if (items.Count > 0)
			{
				agglomerate(null);
			}
			return 0;
		}

		public static void Main()
		{
			List<float> list = new List<float>();
			list.AddRange(new float[10] { 19f, 18f, 17f, 16f, 15f, 10f, 11f, 12f, 13f, 14f });
			UnityEngine.Debug.Log("Loop quick select 10 times.");
			UnityEngine.Debug.Log(NthSmallestElement(list, 0));
		}

		public static T NthSmallestElement<T>(List<T> array, int n) where T : IComparable<T>
		{
			if (n < 0)
			{
				n = 0;
			}
			if (n > array.Count - 1)
			{
				n = array.Count - 1;
			}
			if (array.Count == 0)
			{
				throw new ArgumentException("Array is empty.", "array");
			}
			if (array.Count == 1)
			{
				return array[0];
			}
			return QuickSelectSmallest(array, n)[n];
		}

		private static List<T> QuickSelectSmallest<T>(List<T> input, int n) where T : IComparable<T>
		{
			int num = 0;
			int num2 = input.Count - 1;
			int pivotIndex = n;
			System.Random random = new System.Random();
			while (num2 > num)
			{
				pivotIndex = QuickSelectPartition(input, num, num2, pivotIndex);
				if (pivotIndex == n)
				{
					break;
				}
				if (pivotIndex > n)
				{
					num2 = pivotIndex - 1;
				}
				else
				{
					num = pivotIndex + 1;
				}
				pivotIndex = random.Next(num, num2);
			}
			return input;
		}

		private static int QuickSelectPartition<T>(List<T> array, int startIndex, int endIndex, int pivotIndex) where T : IComparable<T>
		{
			T other = array[pivotIndex];
			Swap(array, pivotIndex, endIndex);
			for (int i = startIndex; i < endIndex; i++)
			{
				if (array[i].CompareTo(other) <= 0)
				{
					Swap(array, i, startIndex);
					startIndex++;
				}
			}
			Swap(array, endIndex, startIndex);
			return startIndex;
		}

		private static void Swap<T>(List<T> array, int index1, int index2)
		{
			if (index1 != index2)
			{
				T value = array[index1];
				array[index1] = array[index2];
				array[index2] = value;
			}
		}
	}
	public class MB3_CopyBoneWeights
	{
		public static void CopyBoneWeightsFromSeamMeshToOtherMeshes(float radius, Mesh seamMesh, Mesh[] targetMeshes)
		{
			List<int> list = new List<int>();
			if (seamMesh == null)
			{
				UnityEngine.Debug.LogError($"The SeamMesh cannot be null");
				return;
			}
			if (seamMesh.vertexCount == 0)
			{
				UnityEngine.Debug.LogError("The seam mesh has no vertices. Check that the Asset Importer for the seam mesh does not have 'Optimize Mesh' checked.");
				return;
			}
			Vector3[] vertices = seamMesh.vertices;
			BoneWeight[] boneWeights = seamMesh.boneWeights;
			Vector3[] normals = seamMesh.normals;
			Vector4[] tangents = seamMesh.tangents;
			Vector2[] uv = seamMesh.uv;
			if (uv.Length != vertices.Length)
			{
				UnityEngine.Debug.LogError("The seam mesh needs uvs to identify which vertices are part of the seam. Vertices with UV > .5 are part of the seam. Vertices with UV < .5 are not part of the seam.");
				return;
			}
			for (int i = 0; i < uv.Length; i++)
			{
				if (uv[i].x > 0.5f && uv[i].y > 0.5f)
				{
					list.Add(i);
				}
			}
			UnityEngine.Debug.Log($"The seam mesh has {seamMesh.vertices.Length} vertices of which {list.Count} are seam vertices.");
			if (list.Count == 0)
			{
				UnityEngine.Debug.LogError("None of the vertices in the Seam Mesh were marked as seam vertices. To mark a vertex as a seam vertex the UV must be greater than (.5,.5). Vertices with UV less than (.5,.5) are excluded.");
				return;
			}
			bool flag = false;
			for (int j = 0; j < targetMeshes.Length; j++)
			{
				if (targetMeshes[j] == null)
				{
					UnityEngine.Debug.LogError($"Mesh {j} was null");
					flag = true;
				}
				if (radius < 0f)
				{
					UnityEngine.Debug.LogError("radius must be zero or positive.");
				}
			}
			if (flag)
			{
				return;
			}
			for (int k = 0; k < targetMeshes.Length; k++)
			{
				Mesh obj = targetMeshes[k];
				Vector3[] vertices2 = obj.vertices;
				BoneWeight[] boneWeights2 = obj.boneWeights;
				Vector3[] normals2 = obj.normals;
				Vector4[] tangents2 = obj.tangents;
				int num = 0;
				for (int l = 0; l < vertices2.Length; l++)
				{
					for (int m = 0; m < list.Count; m++)
					{
						int num2 = list[m];
						if (Vector3.Distance(vertices2[l], vertices[num2]) <= radius)
						{
							num++;
							boneWeights2[l] = boneWeights[num2];
							vertices2[l] = vertices[num2];
							if (normals2.Length == vertices2.Length && normals.Length == normals.Length)
							{
								normals2[l] = normals[num2];
							}
							if (tangents2.Length == vertices2.Length && tangents.Length == vertices.Length)
							{
								tangents2[l] = tangents[num2];
							}
						}
					}
				}
				if (num > 0)
				{
					targetMeshes[k].vertices = vertices2;
					targetMeshes[k].boneWeights = boneWeights2;
					targetMeshes[k].normals = normals2;
					targetMeshes[k].tangents = tangents2;
				}
				UnityEngine.Debug.Log(string.Format("Copied boneweights for {1} vertices in mesh {0} that matched positions in the seam mesh.", targetMeshes[k].name, num));
			}
		}
	}
	[Serializable]
	public abstract class MB3_MeshCombiner
	{
		public delegate void GenerateUV2Delegate(Mesh m, float hardAngle, float packMargin);

		public class MBBlendShapeKey
		{
			public int gameObjecID;

			public int blendShapeIndexInSrc;

			public MBBlendShapeKey(int srcSkinnedMeshRenderGameObjectID, int blendShapeIndexInSource)
			{
				gameObjecID = srcSkinnedMeshRenderGameObjectID;
				blendShapeIndexInSrc = blendShapeIndexInSource;
			}

			public override bool Equals(object obj)
			{
				if (!(obj is MBBlendShapeKey) || obj == null)
				{
					return false;
				}
				MBBlendShapeKey mBBlendShapeKey = (MBBlendShapeKey)obj;
				if (gameObjecID == mBBlendShapeKey.gameObjecID)
				{
					return blendShapeIndexInSrc == mBBlendShapeKey.blendShapeIndexInSrc;
				}
				return false;
			}

			public override int GetHashCode()
			{
				return (23 * 31 + gameObjecID) * 31 + blendShapeIndexInSrc;
			}
		}

		public class MBBlendShapeValue
		{
			public GameObject combinedMeshGameObject;

			public int blendShapeIndex;
		}

		[SerializeField]
		protected MB2_LogLevel _LOG_LEVEL = MB2_LogLevel.info;

		[SerializeField]
		protected MB2_ValidationLevel _validationLevel = MB2_ValidationLevel.robust;

		[SerializeField]
		protected string _name;

		[SerializeField]
		protected MB2_TextureBakeResults _textureBakeResults;

		[SerializeField]
		protected GameObject _resultSceneObject;

		[SerializeField]
		protected Renderer _targetRenderer;

		[SerializeField]
		protected MB_RenderType _renderType;

		[SerializeField]
		protected MB2_OutputOptions _outputOption;

		[SerializeField]
		protected MB2_LightmapOptions _lightmapOption = MB2_LightmapOptions.ignore_UV2;

		[SerializeField]
		protected bool _doNorm = true;

		[SerializeField]
		protected bool _doTan = true;

		[SerializeField]
		protected bool _doCol;

		[SerializeField]
		protected bool _doUV = true;

		[SerializeField]
		protected bool _doUV3;

		[SerializeField]
		protected bool _doUV4;

		[SerializeField]
		protected bool _doBlendShapes;

		[SerializeField]
		protected bool _recenterVertsToBoundsCenter;

		[SerializeField]
		public bool _optimizeAfterBake = true;

		[SerializeField]
		public float uv2UnwrappingParamsHardAngle = 60f;

		[SerializeField]
		public float uv2UnwrappingParamsPackMargin = 0.005f;

		protected bool _usingTemporaryTextureBakeResult;

		public static bool EVAL_VERSION => false;

		public virtual MB2_LogLevel LOG_LEVEL
		{
			get
			{
				return _LOG_LEVEL;
			}
			set
			{
				_LOG_LEVEL = value;
			}
		}

		public virtual MB2_ValidationLevel validationLevel
		{
			get
			{
				return _validationLevel;
			}
			set
			{
				_validationLevel = value;
			}
		}

		public string name
		{
			get
			{
				return _name;
			}
			set
			{
				_name = value;
			}
		}

		public virtual MB2_TextureBakeResults textureBakeResults
		{
			get
			{
				return _textureBakeResults;
			}
			set
			{
				_textureBakeResults = value;
			}
		}

		public virtual GameObject resultSceneObject
		{
			get
			{
				return _resultSceneObject;
			}
			set
			{
				_resultSceneObject = value;
			}
		}

		public virtual Renderer targetRenderer
		{
			get
			{
				return _targetRenderer;
			}
			set
			{
				if (_targetRenderer != null && _targetRenderer != value)
				{
					UnityEngine.Debug.LogWarning("Previous targetRenderer was not null. Combined mesh may be being used by more than one Renderer");
				}
				_targetRenderer = value;
			}
		}

		public virtual MB_RenderType renderType
		{
			get
			{
				return _renderType;
			}
			set
			{
				_renderType = value;
			}
		}

		public virtual MB2_OutputOptions outputOption
		{
			get
			{
				return _outputOption;
			}
			set
			{
				_outputOption = value;
			}
		}

		public virtual MB2_LightmapOptions lightmapOption
		{
			get
			{
				return _lightmapOption;
			}
			set
			{
				_lightmapOption = value;
			}
		}

		public virtual bool doNorm
		{
			get
			{
				return _doNorm;
			}
			set
			{
				_doNorm = value;
			}
		}

		public virtual bool doTan
		{
			get
			{
				return _doTan;
			}
			set
			{
				_doTan = value;
			}
		}

		public virtual bool doCol
		{
			get
			{
				return _doCol;
			}
			set
			{
				_doCol = value;
			}
		}

		public virtual bool doUV
		{
			get
			{
				return _doUV;
			}
			set
			{
				_doUV = value;
			}
		}

		public virtual bool doUV1
		{
			get
			{
				return false;
			}
			set
			{
			}
		}

		public virtual bool doUV3
		{
			get
			{
				return _doUV3;
			}
			set
			{
				_doUV3 = value;
			}
		}

		public virtual bool doUV4
		{
			get
			{
				return _doUV4;
			}
			set
			{
				_doUV4 = value;
			}
		}

		public virtual bool doBlendShapes
		{
			get
			{
				return _doBlendShapes;
			}
			set
			{
				_doBlendShapes = value;
			}
		}

		public virtual bool recenterVertsToBoundsCenter
		{
			get
			{
				return _recenterVertsToBoundsCenter;
			}
			set
			{
				_recenterVertsToBoundsCenter = value;
			}
		}

		public bool optimizeAfterBake
		{
			get
			{
				return _optimizeAfterBake;
			}
			set
			{
				_optimizeAfterBake = value;
			}
		}

		public virtual bool doUV2()
		{
			if (_lightmapOption != MB2_LightmapOptions.copy_UV2_unchanged && _lightmapOption != 0)
			{
				return _lightmapOption == MB2_LightmapOptions.copy_UV2_unchanged_to_separate_rects;
			}
			return true;
		}

		public abstract int GetLightmapIndex();

		public abstract void ClearBuffers();

		public abstract void ClearMesh();

		public abstract void DestroyMesh();

		public abstract void DestroyMeshEditor(MB2_EditorMethodsInterface editorMethods);

		public abstract List<GameObject> GetObjectsInCombined();

		public abstract int GetNumObjectsInCombined();

		public abstract int GetNumVerticesFor(GameObject go);

		public abstract int GetNumVerticesFor(int instanceID);

		public abstract Dictionary<MBBlendShapeKey, MBBlendShapeValue> BuildSourceBlendShapeToCombinedIndexMap();

		public virtual void Apply()
		{
			Apply(null);
		}

		public abstract void Apply(GenerateUV2Delegate uv2GenerationMethod);

		public abstract void Apply(bool triangles, bool vertices, bool normals, bool tangents, bool uvs, bool uv2, bool uv3, bool uv4, bool colors, bool bones = false, bool blendShapeFlag = false, GenerateUV2Delegate uv2GenerationMethod = null);

		public abstract void UpdateGameObjects(GameObject[] gos, bool recalcBounds = true, bool updateVertices = true, bool updateNormals = true, bool updateTangents = true, bool updateUV = false, bool updateUV2 = false, bool updateUV3 = false, bool updateUV4 = false, bool updateColors = false, bool updateSkinningInfo = false);

		public abstract bool AddDeleteGameObjects(GameObject[] gos, GameObject[] deleteGOs, bool disableRendererInSource = true);

		public abstract bool AddDeleteGameObjectsByID(GameObject[] gos, int[] deleteGOinstanceIDs, bool disableRendererInSource);

		public abstract bool CombinedMeshContains(GameObject go);

		public abstract void UpdateSkinnedMeshApproximateBounds();

		public abstract void UpdateSkinnedMeshApproximateBoundsFromBones();

		public abstract void CheckIntegrity();

		public abstract void UpdateSkinnedMeshApproximateBoundsFromBounds();

		public static void UpdateSkinnedMeshApproximateBoundsFromBonesStatic(Transform[] bs, SkinnedMeshRenderer smr)
		{
			Vector3 position = bs[0].position;
			Vector3 position2 = bs[0].position;
			for (int i = 1; i < bs.Length; i++)
			{
				Vector3 position3 = bs[i].position;
				if (position3.x < position2.x)
				{
					position2.x = position3.x;
				}
				if (position3.y < position2.y)
				{
					position2.y = position3.y;
				}
				if (position3.z < position2.z)
				{
					position2.z = position3.z;
				}
				if (position3.x > position.x)
				{
					position.x = position3.x;
				}
				if (position3.y > position.y)
				{
					position.y = position3.y;
				}
				if (position3.z > position.z)
				{
					position.z = position3.z;
				}
			}
			Vector3 vector = (position + position2) / 2f;
			Vector3 vector2 = position - position2;
			Matrix4x4 worldToLocalMatrix = smr.worldToLocalMatrix;
			Bounds localBounds = new Bounds(worldToLocalMatrix * vector, worldToLocalMatrix * vector2);
			smr.localBounds = localBounds;
		}

		public static void UpdateSkinnedMeshApproximateBoundsFromBoundsStatic(List<GameObject> objectsInCombined, SkinnedMeshRenderer smr)
		{
			Bounds b = default(Bounds);
			Bounds bounds = default(Bounds);
			if (MB_Utility.GetBounds(objectsInCombined[0], out b))
			{
				bounds = b;
				for (int i = 1; i < objectsInCombined.Count; i++)
				{
					if (MB_Utility.GetBounds(objectsInCombined[i], out b))
					{
						bounds.Encapsulate(b);
						continue;
					}
					UnityEngine.Debug.LogError("Could not get bounds. Not updating skinned mesh bounds");
					return;
				}
				smr.localBounds = bounds;
			}
			else
			{
				UnityEngine.Debug.LogError("Could not get bounds. Not updating skinned mesh bounds");
			}
		}

		protected virtual bool _CreateTemporaryTextrueBakeResult(GameObject[] gos, List<Material> matsOnTargetRenderer)
		{
			if (GetNumObjectsInCombined() > 0)
			{
				UnityEngine.Debug.LogError("Can't add objects if there are already objects in combined mesh when 'Texture Bake Result' is not set. Perhaps enable 'Clear Buffers After Bake'");
				return false;
			}
			_usingTemporaryTextureBakeResult = true;
			_textureBakeResults = MB2_TextureBakeResults.CreateForMaterialsOnRenderer(gos, matsOnTargetRenderer);
			return true;
		}

		public abstract List<Material> GetMaterialsOnTargetRenderer();
	}
	[Serializable]
	public class MB3_MeshCombinerSingle : MB3_MeshCombiner
	{
		[Serializable]
		public class SerializableIntArray
		{
			public int[] data;

			public SerializableIntArray()
			{
			}

			public SerializableIntArray(int len)
			{
				data = new int[len];
			}
		}

		[Serializable]
		public class MB_DynamicGameObject : IComparable<MB_DynamicGameObject>
		{
			public int instanceID;

			public string name;

			public int vertIdx;

			public int blendShapeIdx;

			public int numVerts;

			public int numBlendShapes;

			public int[] indexesOfBonesUsed = new int[0];

			public int lightmapIndex = -1;

			public Vector4 lightmapTilingOffset = new Vector4(1f, 1f, 0f, 0f);

			public Vector3 meshSize = Vector3.one;

			public bool show = true;

			public bool invertTriangles;

			public int[] submeshTriIdxs;

			public int[] submeshNumTris;

			public int[] targetSubmeshIdxs;

			public Rect[] uvRects;

			public Rect[] encapsulatingRect;

			public Rect[] sourceMaterialTiling;

			public Rect[] obUVRects;

			public bool _beingDeleted;

			public int _triangleIdxAdjustment;

			[NonSerialized]
			public SerializableIntArray[] _tmpSubmeshTris;

			[NonSerialized]
			public Transform[] _tmpCachedBones;

			[NonSerialized]
			public Matrix4x4[] _tmpCachedBindposes;

			[NonSerialized]
			public BoneWeight[] _tmpCachedBoneWeights;

			[NonSerialized]
			public int[] _tmpIndexesOfSourceBonesUsed;

			public int CompareTo(MB_DynamicGameObject b)
			{
				return vertIdx - b.vertIdx;
			}
		}

		public class MeshChannels
		{
			public Vector3[] vertices;

			public Vector3[] normals;

			public Vector4[] tangents;

			public Vector2[] uv0raw;

			public Vector2[] uv0modified;

			public Vector2[] uv2;

			public Vector2[] uv3;

			public Vector2[] uv4;

			public Color[] colors;

			public BoneWeight[] boneWeights;

			public Matrix4x4[] bindPoses;

			public int[] triangles;

			public MBBlendShape[] blendShapes;
		}

		[Serializable]
		public class MBBlendShapeFrame
		{
			public float frameWeight;

			public Vector3[] vertices;

			public Vector3[] normals;

			public Vector3[] tangents;
		}

		[Serializable]
		public class MBBlendShape
		{
			public int gameObjectID;

			public string name;

			public int indexInSource;

			public MBBlendShapeFrame[] frames;
		}

		public class MeshChannelsCache
		{
			private MB3_MeshCombinerSingle mc;

			protected Dictionary<int, MeshChannels> meshID2MeshChannels = new Dictionary<int, MeshChannels>();

			private Vector2 _HALF_UV = new Vector2(0.5f, 0.5f);

			public MeshChannelsCache(MB3_MeshCombinerSingle mcs)
			{
				mc = mcs;
			}

			internal Vector3[] GetVertices(Mesh m)
			{
				if (!meshID2MeshChannels.TryGetValue(m.GetInstanceID(), out var value))
				{
					value = new MeshChannels();
					meshID2MeshChannels.Add(m.GetInstanceID(), value);
				}
				if (value.vertices == null)
				{
					value.vertices = m.vertices;
				}
				return value.vertices;
			}

			internal Vector3[] GetNormals(Mesh m)
			{
				if (!meshID2MeshChannels.TryGetValue(m.GetInstanceID(), out var value))
				{
					value = new MeshChannels();
					meshID2MeshChannels.Add(m.GetInstanceID(), value);
				}
				if (value.normals == null)
				{
					value.normals = _getMeshNormals(m);
				}
				return value.normals;
			}

			internal Vector4[] GetTangents(Mesh m)
			{
				if (!meshID2MeshChannels.TryGetValue(m.GetInstanceID(), out var value))
				{
					value = new MeshChannels();
					meshID2MeshChannels.Add(m.GetInstanceID(), value);
				}
				if (value.tangents == null)
				{
					value.tangents = _getMeshTangents(m);
				}
				return value.tangents;
			}

			internal Vector2[] GetUv0Raw(Mesh m)
			{
				if (!meshID2MeshChannels.TryGetValue(m.GetInstanceID(), out var value))
				{
					value = new MeshChannels();
					meshID2MeshChannels.Add(m.GetInstanceID(), value);
				}
				if (value.uv0raw == null)
				{
					value.uv0raw = _getMeshUVs(m);
				}
				return value.uv0raw;
			}

			internal Vector2[] GetUv0Modified(Mesh m)
			{
				if (!meshID2MeshChannels.TryGetValue(m.GetInstanceID(), out var value))
				{
					value = new MeshChannels();
					meshID2MeshChannels.Add(m.GetInstanceID(), value);
				}
				if (value.uv0modified == null)
				{
					value.uv0modified = null;
				}
				return value.uv0modified;
			}

			internal Vector2[] GetUv2(Mesh m)
			{
				if (!meshID2MeshChannels.TryGetValue(m.GetInstanceID(), out var value))
				{
					value = new MeshChannels();
					meshID2MeshChannels.Add(m.GetInstanceID(), value);
				}
				if (value.uv2 == null)
				{
					value.uv2 = _getMeshUV2s(m);
				}
				return value.uv2;
			}

			internal Vector2[] GetUv3(Mesh m)
			{
				if (!meshID2MeshChannels.TryGetValue(m.GetInstanceID(), out var value))
				{
					value = new MeshChannels();
					meshID2MeshChannels.Add(m.GetInstanceID(), value);
				}
				if (value.uv3 == null)
				{
					value.uv3 = MBVersion.GetMeshUV3orUV4(m, get3: true, mc.LOG_LEVEL);
				}
				return value.uv3;
			}

			internal Vector2[] GetUv4(Mesh m)
			{
				if (!meshID2MeshChannels.TryGetValue(m.GetInstanceID(), out var value))
				{
					value = new MeshChannels();
					meshID2MeshChannels.Add(m.GetInstanceID(), value);
				}
				if (value.uv4 == null)
				{
					value.uv4 = MBVersion.GetMeshUV3orUV4(m, get3: false, mc.LOG_LEVEL);
				}
				return value.uv4;
			}

			internal Color[] GetColors(Mesh m)
			{
				if (!meshID2MeshChannels.TryGetValue(m.GetInstanceID(), out var value))
				{
					value = new MeshChannels();
					meshID2MeshChannels.Add(m.GetInstanceID(), value);
				}
				if (value.colors == null)
				{
					value.colors = _getMeshColors(m);
				}
				return value.colors;
			}

			internal Matrix4x4[] GetBindposes(Renderer r)
			{
				Mesh mesh = MB_Utility.GetMesh(r.gameObject);
				if (!meshID2MeshChannels.TryGetValue(mesh.GetInstanceID(), out var value))
				{
					value = new MeshChannels();
					meshID2MeshChannels.Add(mesh.GetInstanceID(), value);
				}
				if (value.bindPoses == null)
				{
					value.bindPoses = _getBindPoses(r);
				}
				return value.bindPoses;
			}

			internal BoneWeight[] GetBoneWeights(Renderer r, int numVertsInMeshBeingAdded)
			{
				Mesh mesh = MB_Utility.GetMesh(r.gameObject);
				if (!meshID2MeshChannels.TryGetValue(mesh.GetInstanceID(), out var value))
				{
					value = new MeshChannels();
					meshID2MeshChannels.Add(mesh.GetInstanceID(), value);
				}
				if (value.boneWeights == null)
				{
					value.boneWeights = _getBoneWeights(r, numVertsInMeshBeingAdded);
				}
				return value.boneWeights;
			}

			internal int[] GetTriangles(Mesh m)
			{
				if (!meshID2MeshChannels.TryGetValue(m.GetInstanceID(), out var value))
				{
					value = new MeshChannels();
					meshID2MeshChannels.Add(m.GetInstanceID(), value);
				}
				if (value.triangles == null)
				{
					value.triangles = m.triangles;
				}
				return value.triangles;
			}

			internal MBBlendShape[] GetBlendShapes(Mesh m, int gameObjectID)
			{
				if (MBVersion.GetMajorVersion() > 5 || (MBVersion.GetMajorVersion() == 5 && MBVersion.GetMinorVersion() >= 3))
				{
					if (!meshID2MeshChannels.TryGetValue(m.GetInstanceID(), out var value))
					{
						value = new MeshChannels();
						meshID2MeshChannels.Add(m.GetInstanceID(), value);
					}
					if (value.blendShapes == null)
					{
						MBBlendShape[] array = new MBBlendShape[m.blendShapeCount];
						int vertexCount = m.vertexCount;
						for (int i = 0; i < array.Length; i++)
						{
							MBBlendShape mBBlendShape = (array[i] = new MBBlendShape());
							mBBlendShape.frames = new MBBlendShapeFrame[MBVersion.GetBlendShapeFrameCount(m, i)];
							mBBlendShape.name = m.GetBlendShapeName(i);
							mBBlendShape.indexInSource = i;
							mBBlendShape.gameObjectID = gameObjectID;
							for (int j = 0; j < mBBlendShape.frames.Length; j++)
							{
								MBBlendShapeFrame mBBlendShapeFrame = (mBBlendShape.frames[j] = new MBBlendShapeFrame());
								mBBlendShapeFrame.frameWeight = MBVersion.GetBlendShapeFrameWeight(m, i, j);
								mBBlendShapeFrame.vertices = new Vector3[vertexCount];
								mBBlendShapeFrame.normals = new Vector3[vertexCount];
								mBBlendShapeFrame.tangents = new Vector3[vertexCount];
								MBVersion.GetBlendShapeFrameVertices(m, i, j, mBBlendShapeFrame.vertices, mBBlendShapeFrame.normals, mBBlendShapeFrame.tangents);
							}
						}
						value.blendShapes = array;
						return value.blendShapes;
					}
					MBBlendShape[] array2 = new MBBlendShape[value.blendShapes.Length];
					for (int k = 0; k < array2.Length; k++)
					{
						array2[k] = new MBBlendShape();
						array2[k].name = value.blendShapes[k].name;
						array2[k].indexInSource = value.blendShapes[k].indexInSource;
						array2[k].frames = value.blendShapes[k].frames;
						array2[k].gameObjectID = gameObjectID;
					}
					return array2;
				}
				return new MBBlendShape[0];
			}

			private Color[] _getMeshColors(Mesh m)
			{
				Color[] array = m.colors;
				if (array.Length == 0)
				{
					if (mc.LOG_LEVEL >= MB2_LogLevel.debug)
					{
						MB2_Log.LogDebug("Mesh " + m?.ToString() + " has no colors. Generating");
					}
					if (mc.LOG_LEVEL >= MB2_LogLevel.warn)
					{
						UnityEngine.Debug.LogWarning("Mesh " + m?.ToString() + " didn't have colors. Generating an array of white colors");
					}
					array = new Color[m.vertexCount];
					for (int i = 0; i < array.Length; i++)
					{
						array[i] = Color.white;
					}
				}
				return array;
			}

			private Vector3[] _getMeshNormals(Mesh m)
			{
				Vector3[] normals = m.normals;
				if (normals.Length == 0)
				{
					if (mc.LOG_LEVEL >= MB2_LogLevel.debug)
					{
						MB2_Log.LogDebug("Mesh " + m?.ToString() + " has no normals. Generating");
					}
					if (mc.LOG_LEVEL >= MB2_LogLevel.warn)
					{
						UnityEngine.Debug.LogWarning("Mesh " + m?.ToString() + " didn't have normals. Generating normals.");
					}
					Mesh mesh = UnityEngine.Object.Instantiate(m);
					mesh.RecalculateNormals();
					normals = mesh.normals;
					MB_Utility.Destroy(mesh);
				}
				return normals;
			}

			private Vector4[] _getMeshTangents(Mesh m)
			{
				Vector4[] array = m.tangents;
				if (array.Length == 0)
				{
					if (mc.LOG_LEVEL >= MB2_LogLevel.debug)
					{
						MB2_Log.LogDebug("Mesh " + m?.ToString() + " has no tangents. Generating");
					}
					if (mc.LOG_LEVEL >= MB2_LogLevel.warn)
					{
						UnityEngine.Debug.LogWarning("Mesh " + m?.ToString() + " didn't have tangents. Generating tangents.");
					}
					Vector3[] vertices = m.vertices;
					Vector2[] uv0Raw = GetUv0Raw(m);
					Vector3[] normals = _getMeshNormals(m);
					array = new Vector4[m.vertexCount];
					for (int i = 0; i < m.subMeshCount; i++)
					{
						int[] triangles = m.GetTriangles(i);
						_generateTangents(triangles, vertices, uv0Raw, normals, array);
					}
				}
				return array;
			}

			private Vector2[] _getMeshUVs(Mesh m)
			{
				Vector2[] array = m.uv;
				if (array.Length == 0)
				{
					if (mc.LOG_LEVEL >= MB2_LogLevel.debug)
					{
						MB2_Log.LogDebug("Mesh " + m?.ToString() + " has no uvs. Generating");
					}
					if (mc.LOG_LEVEL >= MB2_LogLevel.warn)
					{
						UnityEngine.Debug.LogWarning("Mesh " + m?.ToString() + " didn't have uvs. Generating uvs.");
					}
					array = new Vector2[m.vertexCount];
					for (int i = 0; i < array.Length; i++)
					{
						array[i] = _HALF_UV;
					}
				}
				return array;
			}

			private Vector2[] _getMeshUV2s(Mesh m)
			{
				Vector2[] array = m.uv2;
				if (array.Length == 0)
				{
					if (mc.LOG_LEVEL >= MB2_LogLevel.debug)
					{
						MB2_Log.LogDebug("Mesh " + m?.ToString() + " has no uv2s. Generating");
					}
					if (mc.LOG_LEVEL >= MB2_LogLevel.warn)
					{
						UnityEngine.Debug.LogWarning("Mesh " + m?.ToString() + " didn't have uv2s. Generating uv2s.");
					}
					if (mc._lightmapOption == MB2_LightmapOptions.copy_UV2_unchanged_to_separate_rects)
					{
						UnityEngine.Debug.LogError("Mesh " + m?.ToString() + " did not have a UV2 channel. Nothing to copy when trying to copy UV2 to separate rects. The combined mesh will not lightmap properly. Try using generate new uv2 layout.");
					}
					array = new Vector2[m.vertexCount];
					for (int i = 0; i < array.Length; i++)
					{
						array[i] = _HALF_UV;
					}
				}
				return array;
			}

			public static Matrix4x4[] _getBindPoses(Renderer r)
			{
				if (r is SkinnedMeshRenderer)
				{
					return ((SkinnedMeshRenderer)r).sharedMesh.bindposes;
				}
				if (r is MeshRenderer)
				{
					Matrix4x4 identity = Matrix4x4.identity;
					return new Matrix4x4[1] { identity };
				}
				UnityEngine.Debug.LogError("Could not _getBindPoses. Object does not have a renderer");
				return null;
			}

			public static BoneWeight[] _getBoneWeights(Renderer r, int numVertsInMeshBeingAdded)
			{
				if (r is SkinnedMeshRenderer)
				{
					return ((SkinnedMeshRenderer)r).sharedMesh.boneWeights;
				}
				if (r is MeshRenderer)
				{
					BoneWeight boneWeight = default(BoneWeight);
					int num2 = (boneWeight.boneIndex3 = 0);
					int num4 = (boneWeight.boneIndex2 = num2);
					int boneIndex = (boneWeight.boneIndex1 = num4);
					boneWeight.boneIndex0 = boneIndex;
					boneWeight.weight0 = 1f;
					float num7 = (boneWeight.weight3 = 0f);
					float weight = (boneWeight.weight2 = num7);
					boneWeight.weight1 = weight;
					BoneWeight[] array = new BoneWeight[numVertsInMeshBeingAdded];
					for (int i = 0; i < array.Length; i++)
					{
						array[i] = boneWeight;
					}
					return array;
				}
				UnityEngine.Debug.LogError("Could not _getBoneWeights. Object does not have a renderer");
				return null;
			}

			private void _generateTangents(int[] triangles, Vector3[] verts, Vector2[] uvs, Vector3[] normals, Vector4[] outTangents)
			{
				int num = triangles.Length;
				int num2 = verts.Length;
				Vector3[] array = new Vector3[num2];
				Vector3[] array2 = new Vector3[num2];
				for (int i = 0; i < num; i += 3)
				{
					int num3 = triangles[i];
					int num4 = triangles[i + 1];
					int num5 = triangles[i + 2];
					Vector3 vector = verts[num3];
					Vector3 vector2 = verts[num4];
					Vector3 vector3 = verts[num5];
					Vector2 vector4 = uvs[num3];
					Vector2 vector5 = uvs[num4];
					Vector2 vector6 = uvs[num5];
					float num6 = vector2.x - vector.x;
					float num7 = vector3.x - vector.x;
					float num8 = vector2.y - vector.y;
					float num9 = vector3.y - vector.y;
					float num10 = vector2.z - vector.z;
					float num11 = vector3.z - vector.z;
					float num12 = vector5.x - vector4.x;
					float num13 = vector6.x - vector4.x;
					float num14 = vector5.y - vector4.y;
					float num15 = vector6.y - vector4.y;
					float num16 = num12 * num15 - num13 * num14;
					if (num16 == 0f)
					{
						UnityEngine.Debug.LogError("Could not compute tangents. All UVs need to form a valid triangles in UV space. If any UV triangles are collapsed, tangents cannot be generated.");
						return;
					}
					float num17 = 1f / num16;
					Vector3 vector7 = new Vector3((num15 * num6 - num14 * num7) * num17, (num15 * num8 - num14 * num9) * num17, (num15 * num10 - num14 * num11) * num17);
					Vector3 vector8 = new Vector3((num12 * num7 - num13 * num6) * num17, (num12 * num9 - num13 * num8) * num17, (num12 * num11 - num13 * num10) * num17);
					array[num3] += vector7;
					array[num4] += vector7;
					array[num5] += vector7;
					array2[num3] += vector8;
					array2[num4] += vector8;
					array2[num5] += vector8;
				}
				for (int j = 0; j < num2; j++)
				{
					Vector3 vector9 = normals[j];
					Vector3 vector10 = array[j];
					Vector3 normalized = (vector10 - vector9 * Vector3.Dot(vector9, vector10)).normalized;
					outTangents[j] = new Vector4(normalized.x, normalized.y, normalized.z);
					outTangents[j].w = ((Vector3.Dot(Vector3.Cross(vector9, vector10), array2[j]) < 0f) ? (-1f) : 1f);
				}
			}
		}

		public struct BoneAndBindpose
		{
			public Transform bone;

			public Matrix4x4 bindPose;

			public BoneAndBindpose(Transform t, Matrix4x4 bp)
			{
				bone = t;
				bindPose = bp;
			}

			public override bool Equals(object obj)
			{
				if (obj is BoneAndBindpose && bone == ((BoneAndBindpose)obj).bone && bindPose == ((BoneAndBindpose)obj).bindPose)
				{
					return true;
				}
				return false;
			}

			public override int GetHashCode()
			{
				return (bone.GetInstanceID() % int.MaxValue) ^ (int)bindPose[0, 0];
			}
		}

		[SerializeField]
		protected List<GameObject> objectsInCombinedMesh = new List<GameObject>();

		[SerializeField]
		private int lightmapIndex = -1;

		[SerializeField]
		private List<MB_DynamicGameObject> mbDynamicObjectsInCombinedMesh = new List<MB_DynamicGameObject>();

		private Dictionary<int, MB_DynamicGameObject> _instance2combined_map = new Dictionary<int, MB_DynamicGameObject>();

		[SerializeField]
		private Vector3[] verts = new Vector3[0];

		[SerializeField]
		private Vector3[] normals = new Vector3[0];

		[SerializeField]
		private Vector4[] tangents = new Vector4[0];

		[SerializeField]
		private Vector2[] uvs = new Vector2[0];

		[SerializeField]
		private Vector2[] uv2s = new Vector2[0];

		[SerializeField]
		private Vector2[] uv3s = new Vector2[0];

		[SerializeField]
		private Vector2[] uv4s = new Vector2[0];

		[SerializeField]
		private Color[] colors = new Color[0];

		[SerializeField]
		private Matrix4x4[] bindPoses = new Matrix4x4[0];

		[SerializeField]
		private Transform[] bones = new Transform[0];

		[SerializeField]
		internal MBBlendShape[] blendShapes = new MBBlendShape[0];

		[SerializeField]
		internal MBBlendShape[] blendShapesInCombined = new MBBlendShape[0];

		[SerializeField]
		private SerializableIntArray[] submeshTris = new SerializableIntArray[0];

		[SerializeField]
		private Mesh _mesh;

		private BoneWeight[] boneWeights = new BoneWeight[0];

		private GameObject[] empty = new GameObject[0];

		private int[] emptyIDs = new int[0];

		public override MB2_TextureBakeResults textureBakeResults
		{
			set
			{
				if (mbDynamicObjectsInCombinedMesh.Count > 0 && _textureBakeResults != value && _textureBakeResults != null && LOG_LEVEL >= MB2_LogLevel.warn)
				{
					UnityEngine.Debug.LogWarning("If Texture Bake Result is changed then objects currently in combined mesh may be invalid.");
				}
				_textureBakeResults = value;
			}
		}

		public override MB_RenderType renderType
		{
			set
			{
				if (value == MB_RenderType.skinnedMeshRenderer && _renderType == MB_RenderType.meshRenderer && boneWeights.Length != verts.Length)
				{
					UnityEngine.Debug.LogError("Can't set the render type to SkinnedMeshRenderer without clearing the mesh first. Try deleteing the CombinedMesh scene object.");
				}
				_renderType = value;
			}
		}

		public override GameObject resultSceneObject
		{
			set
			{
				if (_resultSceneObject != value)
				{
					_targetRenderer = null;
					if (_mesh != null && _LOG_LEVEL >= MB2_LogLevel.warn)
					{
						UnityEngine.Debug.LogWarning("Result Scene Object was changed when this mesh baker component had a reference to a mesh. If mesh is being used by another object make sure to reset the mesh to none before baking to avoid overwriting the other mesh.");
					}
				}
				_resultSceneObject = value;
			}
		}

		private MB_DynamicGameObject instance2Combined_MapGet(int gameObjectID)
		{
			return _instance2combined_map[gameObjectID];
		}

		private void instance2Combined_MapAdd(int gameObjectID, MB_DynamicGameObject dgo)
		{
			_instance2combined_map.Add(gameObjectID, dgo);
		}

		private void instance2Combined_MapRemove(int gameObjectID)
		{
			_instance2combined_map.Remove(gameObjectID);
		}

		private bool instance2Combined_MapTryGetValue(int gameObjectID, out MB_DynamicGameObject dgo)
		{
			return _instance2combined_map.TryGetValue(gameObjectID, out dgo);
		}

		private int instance2Combined_MapCount()
		{
			return _instance2combined_map.Count;
		}

		private void instance2Combined_MapClear()
		{
			_instance2combined_map.Clear();
		}

		private bool instance2Combined_MapContainsKey(int gameObjectID)
		{
			return _instance2combined_map.ContainsKey(gameObjectID);
		}

		public override int GetNumObjectsInCombined()
		{
			return mbDynamicObjectsInCombinedMesh.Count;
		}

		public override List<GameObject> GetObjectsInCombined()
		{
			List<GameObject> list = new List<GameObject>();
			list.AddRange(objectsInCombinedMesh);
			return list;
		}

		public Mesh GetMesh()
		{
			if (_mesh == null)
			{
				_mesh = new Mesh();
			}
			return _mesh;
		}

		public void SetMesh(Mesh m)
		{
			_mesh = m;
		}

		public Transform[] GetBones()
		{
			return bones;
		}

		public override int GetLightmapIndex()
		{
			if (lightmapOption == MB2_LightmapOptions.generate_new_UV2_layout || lightmapOption == MB2_LightmapOptions.preserve_current_lightmapping)
			{
				return lightmapIndex;
			}
			return -1;
		}

		public override int GetNumVerticesFor(GameObject go)
		{
			return GetNumVerticesFor(go.GetInstanceID());
		}

		public override int GetNumVerticesFor(int instanceID)
		{
			if (instance2Combined_MapTryGetValue(instanceID, out var dgo))
			{
				return dgo.numVerts;
			}
			return -1;
		}

		public override Dictionary<MBBlendShapeKey, MBBlendShapeValue> BuildSourceBlendShapeToCombinedIndexMap()
		{
			Dictionary<MBBlendShapeKey, MBBlendShapeValue> dictionary = new Dictionary<MBBlendShapeKey, MBBlendShapeValue>();
			for (int i = 0; i < blendShapesInCombined.Length; i++)
			{
				MBBlendShapeValue mBBlendShapeValue = new MBBlendShapeValue();
				mBBlendShapeValue.combinedMeshGameObject = _targetRenderer.gameObject;
				mBBlendShapeValue.blendShapeIndex = i;
				dictionary.Add(new MBBlendShapeKey(blendShapesInCombined[i].gameObjectID, blendShapesInCombined[i].indexInSource), mBBlendShapeValue);
			}
			return dictionary;
		}

		private void _initialize(int numResultMats)
		{
			if (mbDynamicObjectsInCombinedMesh.Count == 0)
			{
				lightmapIndex = -1;
			}
			if (_mesh == null)
			{
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					MB2_Log.LogDebug("_initialize Creating new Mesh");
				}
				_mesh = GetMesh();
			}
			if (instance2Combined_MapCount() != mbDynamicObjectsInCombinedMesh.Count)
			{
				instance2Combined_MapClear();
				for (int i = 0; i < mbDynamicObjectsInCombinedMesh.Count; i++)
				{
					if (mbDynamicObjectsInCombinedMesh[i] != null)
					{
						instance2Combined_MapAdd(mbDynamicObjectsInCombinedMesh[i].instanceID, mbDynamicObjectsInCombinedMesh[i]);
					}
				}
				boneWeights = _mesh.boneWeights;
			}
			if (objectsInCombinedMesh.Count == 0 && submeshTris.Length != numResultMats)
			{
				submeshTris = new SerializableIntArray[numResultMats];
				for (int j = 0; j < submeshTris.Length; j++)
				{
					submeshTris[j] = new SerializableIntArray(0);
				}
			}
			if (mbDynamicObjectsInCombinedMesh.Count > 0 && mbDynamicObjectsInCombinedMesh[0].indexesOfBonesUsed.Length == 0 && renderType == MB_RenderType.skinnedMeshRenderer && boneWeights.Length != 0)
			{
				for (int k = 0; k < mbDynamicObjectsInCombinedMesh.Count; k++)
				{
					MB_DynamicGameObject mB_DynamicGameObject = mbDynamicObjectsInCombinedMesh[k];
					HashSet<int> hashSet = new HashSet<int>();
					for (int l = mB_DynamicGameObject.vertIdx; l < mB_DynamicGameObject.vertIdx + mB_DynamicGameObject.numVerts; l++)
					{
						if (boneWeights[l].weight0 > 0f)
						{
							hashSet.Add(boneWeights[l].boneIndex0);
						}
						if (boneWeights[l].weight1 > 0f)
						{
							hashSet.Add(boneWeights[l].boneIndex1);
						}
						if (boneWeights[l].weight2 > 0f)
						{
							hashSet.Add(boneWeights[l].boneIndex2);
						}
						if (boneWeights[l].weight3 > 0f)
						{
							hashSet.Add(boneWeights[l].boneIndex3);
						}
					}
					mB_DynamicGameObject.indexesOfBonesUsed = new int[hashSet.Count];
					hashSet.CopyTo(mB_DynamicGameObject.indexesOfBonesUsed);
				}
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					UnityEngine.Debug.Log("Baker used old systems that duplicated bones. Upgrading to new system by building indexesOfBonesUsed");
				}
			}
			if (LOG_LEVEL >= MB2_LogLevel.trace)
			{
				UnityEngine.Debug.Log($"_initialize numObjsInCombined={mbDynamicObjectsInCombinedMesh.Count}");
			}
		}

		private bool _collectMaterialTriangles(Mesh m, MB_DynamicGameObject dgo, Material[] sharedMaterials, OrderedDictionary sourceMats2submeshIdx_map)
		{
			int num = m.subMeshCount;
			if (sharedMaterials.Length < num)
			{
				num = sharedMaterials.Length;
			}
			dgo._tmpSubmeshTris = new SerializableIntArray[num];
			dgo.targetSubmeshIdxs = new int[num];
			for (int i = 0; i < num; i++)
			{
				if (_textureBakeResults.doMultiMaterial)
				{
					if (!sourceMats2submeshIdx_map.Contains(sharedMaterials[i]))
					{
						UnityEngine.Debug.LogError("Object " + dgo.name + " has a material that was not found in the result materials maping. " + sharedMaterials[i]);
						return false;
					}
					dgo.targetSubmeshIdxs[i] = (int)sourceMats2submeshIdx_map[sharedMaterials[i]];
				}
				else
				{
					dgo.targetSubmeshIdxs[i] = 0;
				}
				dgo._tmpSubmeshTris[i] = new SerializableIntArray();
				dgo._tmpSubmeshTris[i].data = m.GetTriangles(i);
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					MB2_Log.LogDebug("Collecting triangles for: " + dgo.name + " submesh:" + i + " maps to submesh:" + dgo.targetSubmeshIdxs[i] + " added:" + dgo._tmpSubmeshTris[i].data.Length, LOG_LEVEL);
				}
			}
			return true;
		}

		private bool _collectOutOfBoundsUVRects2(Mesh m, MB_DynamicGameObject dgo, Material[] sharedMaterials, OrderedDictionary sourceMats2submeshIdx_map, Dictionary<int, MB_Utility.MeshAnalysisResult[]> meshAnalysisResults, MeshChannelsCache meshChannelCache)
		{
			if (_textureBakeResults == null)
			{
				UnityEngine.Debug.LogError("Need to bake textures into combined material");
				return false;
			}
			if (meshAnalysisResults.TryGetValue(m.GetInstanceID(), out var value))
			{
				dgo.obUVRects = new Rect[sharedMaterials.Length];
				for (int i = 0; i < dgo.obUVRects.Length; i++)
				{
					dgo.obUVRects[i] = value[i].uvRect;
				}
			}
			else
			{
				int subMeshCount = m.subMeshCount;
				int num = subMeshCount;
				if (sharedMaterials.Length < subMeshCount)
				{
					num = sharedMaterials.Length;
				}
				dgo.obUVRects = new Rect[num];
				value = new MB_Utility.MeshAnalysisResult[subMeshCount];
				for (int j = 0; j < subMeshCount; j++)
				{
					int num2 = dgo.targetSubmeshIdxs[j];
					if (_textureBakeResults.resultMaterials[num2].considerMeshUVs)
					{
						MB_Utility.hasOutOfBoundsUVs(meshChannelCache.GetUv0Raw(m), m, ref value[j], j);
						Rect uvRect = value[j].uvRect;
						if (j < num)
						{
							dgo.obUVRects[j] = uvRect;
						}
					}
				}
				meshAnalysisResults.Add(m.GetInstanceID(), value);
			}
			return true;
		}

		private bool _validateTextureBakeResults()
		{
			if (_textureBakeResults == null)
			{
				UnityEngine.Debug.LogError("Texture Bake Results is null. Can't combine meshes.");
				return false;
			}
			if (_textureBakeResults.materialsAndUVRects == null || _textureBakeResults.materialsAndUVRects.Length == 0)
			{
				UnityEngine.Debug.LogError("Texture Bake Results has no materials in material to sourceUVRect map. Try baking materials. Can't combine meshes.");
				return false;
			}
			if (_textureBakeResults.resultMaterials == null || _textureBakeResults.resultMaterials.Length == 0)
			{
				UnityEngine.Debug.LogError("Texture Bake Results has no result materials. Try baking materials. Can't combine meshes.");
				return false;
			}
			return true;
		}

		private bool _validateMeshFlags()
		{
			if (mbDynamicObjectsInCombinedMesh.Count > 0 && ((!_doNorm && doNorm) || (!_doTan && doTan) || (!_doCol && doCol) || (!_doUV && doUV) || (!_doUV3 && doUV3) || (!_doUV4 && doUV4)))
			{
				UnityEngine.Debug.LogError("The channels have changed. There are already objects in the combined mesh that were added with a different set of channels.");
				return false;
			}
			_doNorm = doNorm;
			_doTan = doTan;
			_doCol = doCol;
			_doUV = doUV;
			_doUV3 = doUV3;
			_doUV4 = doUV4;
			return true;
		}

		private bool _showHide(GameObject[] goToShow, GameObject[] goToHide)
		{
			if (goToShow == null)
			{
				goToShow = empty;
			}
			if (goToHide == null)
			{
				goToHide = empty;
			}
			int numResultMats = _textureBakeResults.resultMaterials.Length;
			_initialize(numResultMats);
			for (int i = 0; i < goToHide.Length; i++)
			{
				if (!instance2Combined_MapContainsKey(goToHide[i].GetInstanceID()))
				{
					if (LOG_LEVEL >= MB2_LogLevel.warn)
					{
						UnityEngine.Debug.LogWarning("Trying to hide an object " + goToHide[i]?.ToString() + " that is not in combined mesh. Did you initially bake with 'clear buffers after bake' enabled?");
					}
					return false;
				}
			}
			for (int j = 0; j < goToShow.Length; j++)
			{
				if (!instance2Combined_MapContainsKey(goToShow[j].GetInstanceID()))
				{
					if (LOG_LEVEL >= MB2_LogLevel.warn)
					{
						UnityEngine.Debug.LogWarning("Trying to show an object " + goToShow[j]?.ToString() + " that is not in combined mesh. Did you initially bake with 'clear buffers after bake' enabled?");
					}
					return false;
				}
			}
			for (int k = 0; k < goToHide.Length; k++)
			{
				_instance2combined_map[goToHide[k].GetInstanceID()].show = false;
			}
			for (int l = 0; l < goToShow.Length; l++)
			{
				_instance2combined_map[goToShow[l].GetInstanceID()].show = true;
			}
			return true;
		}

		private bool _addToCombined(GameObject[] goToAdd, int[] goToDelete, bool disableRendererInSource)
		{
			Stopwatch stopwatch = null;
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				stopwatch = new Stopwatch();
				stopwatch.Start();
			}
			if (!_validateTextureBakeResults())
			{
				return false;
			}
			if (!_validateMeshFlags())
			{
				return false;
			}
			if (!ValidateTargRendererAndMeshAndResultSceneObj())
			{
				return false;
			}
			if (outputOption != MB2_OutputOptions.bakeMeshAssetsInPlace && renderType == MB_RenderType.skinnedMeshRenderer && (_targetRenderer == null || !(_targetRenderer is SkinnedMeshRenderer)))
			{
				UnityEngine.Debug.LogError("Target renderer must be set and must be a SkinnedMeshRenderer");
				return false;
			}
			if (_doBlendShapes && renderType != MB_RenderType.skinnedMeshRenderer)
			{
				UnityEngine.Debug.LogError("If doBlendShapes is set then RenderType must be skinnedMeshRenderer.");
				return false;
			}
			GameObject[] _goToAdd;
			if (goToAdd == null)
			{
				_goToAdd = empty;
			}
			else
			{
				_goToAdd = (GameObject[])goToAdd.Clone();
			}
			int[] array = ((goToDelete != null) ? ((int[])goToDelete.Clone()) : emptyIDs);
			if (_mesh == null)
			{
				DestroyMesh();
			}
			MB2_TextureBakeResults.Material2AtlasRectangleMapper material2AtlasRectangleMapper = new MB2_TextureBakeResults.Material2AtlasRectangleMapper(textureBakeResults);
			int num = _textureBakeResults.resultMaterials.Length;
			_initialize(num);
			if (submeshTris.Length != num)
			{
				UnityEngine.Debug.LogError("The number of submeshes " + submeshTris.Length + " in the combined mesh was not equal to the number of result materials " + num + " in the Texture Bake Result");
				return false;
			}
			if (_mesh.vertexCount > 0 && _instance2combined_map.Count == 0)
			{
				UnityEngine.Debug.LogWarning("There were vertices in the combined mesh but nothing in the MeshBaker buffers. If you are trying to bake in the editor and modify at runtime, make sure 'Clear Buffers After Bake' is unchecked.");
			}
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				MB2_Log.LogDebug("==== Calling _addToCombined objs adding:" + _goToAdd.Length + " objs deleting:" + array.Length + " fixOutOfBounds:" + textureBakeResults.DoAnyResultMatsUseConsiderMeshUVs() + " doMultiMaterial:" + textureBakeResults.doMultiMaterial + " disableRenderersInSource:" + disableRendererInSource, LOG_LEVEL);
			}
			if (_textureBakeResults.resultMaterials == null || _textureBakeResults.resultMaterials.Length == 0)
			{
				UnityEngine.Debug.LogError("No resultMaterials in this TextureBakeResults. Try baking textures.");
				return false;
			}
			OrderedDictionary orderedDictionary = new OrderedDictionary();
			for (int j = 0; j < num; j++)
			{
				MB_MultiMaterial mB_MultiMaterial = _textureBakeResults.resultMaterials[j];
				for (int k = 0; k < mB_MultiMaterial.sourceMaterials.Count; k++)
				{
					if (mB_MultiMaterial.sourceMaterials[k] == null)
					{
						UnityEngine.Debug.LogError("Found null material in source materials for combined mesh materials " + j);
						return false;
					}
					if (!orderedDictionary.Contains(mB_MultiMaterial.sourceMaterials[k]))
					{
						orderedDictionary.Add(mB_MultiMaterial.sourceMaterials[k], j);
					}
				}
			}
			int num2 = 0;
			int[] array2 = new int[num];
			int num3 = 0;
			List<MB_DynamicGameObject>[] array3 = null;
			HashSet<int> hashSet = new HashSet<int>();
			HashSet<BoneAndBindpose> hashSet2 = new HashSet<BoneAndBindpose>();
			if (renderType == MB_RenderType.skinnedMeshRenderer && array.Length != 0)
			{
				array3 = _buildBoneIdx2dgoMap();
			}
			for (int l = 0; l < array.Length; l++)
			{
				if (instance2Combined_MapTryGetValue(array[l], out var dgo))
				{
					num2 += dgo.numVerts;
					num3 += dgo.numBlendShapes;
					if (renderType == MB_RenderType.skinnedMeshRenderer)
					{
						for (int m = 0; m < dgo.indexesOfBonesUsed.Length; m++)
						{
							if (array3[dgo.indexesOfBonesUsed[m]].Contains(dgo))
							{
								array3[dgo.indexesOfBonesUsed[m]].Remove(dgo);
								if (array3[dgo.indexesOfBonesUsed[m]].Count == 0)
								{
									hashSet.Add(dgo.indexesOfBonesUsed[m]);
								}
							}
						}
					}
					for (int n = 0; n < dgo.submeshNumTris.Length; n++)
					{
						array2[n] += dgo.submeshNumTris[n];
					}
				}
				else if (LOG_LEVEL >= MB2_LogLevel.warn)
				{
					UnityEngine.Debug.LogWarning("Trying to delete an object that is not in combined mesh");
				}
			}
			List<MB_DynamicGameObject> list = new List<MB_DynamicGameObject>();
			Dictionary<int, MB_Utility.MeshAnalysisResult[]> dictionary = new Dictionary<int, MB_Utility.MeshAnalysisResult[]>();
			MeshChannelsCache meshChannelsCache = new MeshChannelsCache(this);
			int num4 = 0;
			int[] array4 = new int[num];
			int num5 = 0;
			Dictionary<Transform, int> dictionary2 = new Dictionary<Transform, int>();
			for (int num6 = 0; num6 < bones.Length; num6++)
			{
				dictionary2.Add(bones[num6], num6);
			}
			int i;
			for (i = 0; i < _goToAdd.Length; i++)
			{
				if (!instance2Combined_MapContainsKey(_goToAdd[i].GetInstanceID()) || Array.FindIndex(array, (int o) => o == _goToAdd[i].GetInstanceID()) != -1)
				{
					MB_DynamicGameObject mB_DynamicGameObject = new MB_DynamicGameObject();
					GameObject gameObject = _goToAdd[i];
					Material[] gOMaterials = MB_Utility.GetGOMaterials(gameObject);
					if (LOG_LEVEL >= MB2_LogLevel.trace)
					{
						UnityEngine.Debug.Log($"Getting {gOMaterials.Length} shared materials for {gameObject}");
					}
					if (gOMaterials == null)
					{
						UnityEngine.Debug.LogError("Object " + gameObject.name + " does not have a Renderer");
						_goToAdd[i] = null;
						return false;
					}
					Mesh mesh = MB_Utility.GetMesh(gameObject);
					if (mesh == null)
					{
						UnityEngine.Debug.LogError("Object " + gameObject.name + " MeshFilter or SkinedMeshRenderer had no mesh");
						_goToAdd[i] = null;
						return false;
					}
					if (MBVersion.IsRunningAndMeshNotReadWriteable(mesh))
					{
						UnityEngine.Debug.LogError("Object " + gameObject.name + " Mesh Importer has read/write flag set to 'false'. This needs to be set to 'true' in order to read data from this mesh.");
						_goToAdd[i] = null;
						return false;
					}
					MB_TextureTilingTreatment[] array5 = new MB_TextureTilingTreatment[gOMaterials.Length];
					Rect[] array6 = new Rect[gOMaterials.Length];
					Rect[] array7 = new Rect[gOMaterials.Length];
					Rect[] array8 = new Rect[gOMaterials.Length];
					string errorMsg = "";
					for (int num7 = 0; num7 < gOMaterials.Length; num7++)
					{
						object obj = orderedDictionary[gOMaterials[num7]];
						if (obj == null)
						{
							UnityEngine.Debug.LogError("Source object " + gameObject.name + " used a material " + gOMaterials[num7]?.ToString() + " that was not in the baked materials.");
							return false;
						}
						int idxInResultMats = (int)obj;
						if (!material2AtlasRectangleMapper.TryMapMaterialToUVRect(gOMaterials[num7], mesh, num7, idxInResultMats, meshChannelsCache, dictionary, out array5[num7], out array6[num7], out array7[num7], out array8[num7], ref errorMsg, LOG_LEVEL))
						{
							UnityEngine.Debug.LogError(errorMsg);
							_goToAdd[i] = null;
							return false;
						}
					}
					if (!(_goToAdd[i] != null))
					{
						continue;
					}
					list.Add(mB_DynamicGameObject);
					mB_DynamicGameObject.name = $"{_goToAdd[i].ToString()} {_goToAdd[i].GetInstanceID()}";
					mB_DynamicGameObject.instanceID = _goToAdd[i].GetInstanceID();
					mB_DynamicGameObject.uvRects = array6;
					mB_DynamicGameObject.encapsulatingRect = array7;
					mB_DynamicGameObject.sourceMaterialTiling = array8;
					mB_DynamicGameObject.numVerts = mesh.vertexCount;
					if (_doBlendShapes)
					{
						mB_DynamicGameObject.numBlendShapes = mesh.blendShapeCount;
					}
					Renderer renderer = MB_Utility.GetRenderer(gameObject);
					if (renderType == MB_RenderType.skinnedMeshRenderer)
					{
						_CollectBonesToAddForDGO(mB_DynamicGameObject, dictionary2, hashSet, hashSet2, renderer, meshChannelsCache);
					}
					if (lightmapIndex == -1)
					{
						lightmapIndex = renderer.lightmapIndex;
					}
					if (lightmapOption == MB2_LightmapOptions.preserve_current_lightmapping)
					{
						if (lightmapIndex != renderer.lightmapIndex && LOG_LEVEL >= MB2_LogLevel.warn)
						{
							UnityEngine.Debug.LogWarning("Object " + gameObject.name + " has a different lightmap index. Lightmapping will not work.");
						}
						if (!MBVersion.GetActive(gameObject) && LOG_LEVEL >= MB2_LogLevel.warn)
						{
							UnityEngine.Debug.LogWarning("Object " + gameObject.name + " is inactive. Can only get lightmap index of active objects.");
						}
						if (renderer.lightmapIndex == -1 && LOG_LEVEL >= MB2_LogLevel.warn)
						{
							UnityEngine.Debug.LogWarning("Object " + gameObject.name + " does not have an index to a lightmap.");
						}
					}
					mB_DynamicGameObject.lightmapIndex = renderer.lightmapIndex;
					mB_DynamicGameObject.lightmapTilingOffset = MBVersion.GetLightmapTilingOffset(renderer);
					if (!_collectMaterialTriangles(mesh, mB_DynamicGameObject, gOMaterials, orderedDictionary))
					{
						return false;
					}
					mB_DynamicGameObject.meshSize = renderer.bounds.size;
					mB_DynamicGameObject.submeshNumTris = new int[num];
					mB_DynamicGameObject.submeshTriIdxs = new int[num];
					if (textureBakeResults.DoAnyResultMatsUseConsiderMeshUVs() && !_collectOutOfBoundsUVRects2(mesh, mB_DynamicGameObject, gOMaterials, orderedDictionary, dictionary, meshChannelsCache))
					{
						return false;
					}
					num4 += mB_DynamicGameObject.numVerts;
					num5 += mB_DynamicGameObject.numBlendShapes;
					for (int num8 = 0; num8 < mB_DynamicGameObject._tmpSubmeshTris.Length; num8++)
					{
						array4[mB_DynamicGameObject.targetSubmeshIdxs[num8]] += mB_DynamicGameObject._tmpSubmeshTris[num8].data.Length;
					}
					mB_DynamicGameObject.invertTriangles = IsMirrored(gameObject.transform.localToWorldMatrix);
				}
				else
				{
					if (LOG_LEVEL >= MB2_LogLevel.warn)
					{
						UnityEngine.Debug.LogWarning("Object " + _goToAdd[i].name + " has already been added");
					}
					_goToAdd[i] = null;
				}
			}
			for (int num9 = 0; num9 < _goToAdd.Length; num9++)
			{
				if (_goToAdd[num9] != null && disableRendererInSource)
				{
					MB_Utility.DisableRendererInSource(_goToAdd[num9]);
					if (LOG_LEVEL == MB2_LogLevel.trace)
					{
						UnityEngine.Debug.Log("Disabling renderer on " + _goToAdd[num9].name + " id=" + _goToAdd[num9].GetInstanceID());
					}
				}
			}
			int num10 = verts.Length + num4 - num2;
			int num11 = bindPoses.Length + hashSet2.Count - hashSet.Count;
			int[] array9 = new int[num];
			int num12 = blendShapes.Length + num5 - num3;
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log("Verts adding:" + num4 + " deleting:" + num2 + " submeshes:" + array9.Length + " bones:" + num11 + " blendShapes:" + num12);
			}
			for (int num13 = 0; num13 < array9.Length; num13++)
			{
				array9[num13] = submeshTris[num13].data.Length + array4[num13] - array2[num13];
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					MB2_Log.LogDebug("    submesh :" + num13 + " already contains:" + submeshTris[num13].data.Length + " tris to be Added:" + array4[num13] + " tris to be Deleted:" + array2[num13]);
				}
			}
			if (num10 >= MBVersion.MaxMeshVertexCount())
			{
				UnityEngine.Debug.LogError("Cannot add objects. Resulting mesh will have more than " + MBVersion.MaxMeshVertexCount() + " vertices. Try using a Multi-MeshBaker component. This will split the combined mesh into several meshes. You don't have to re-configure the MB2_TextureBaker. Just remove the MB2_MeshBaker component and add a MB2_MultiMeshBaker component.");
				return false;
			}
			Vector3[] destinationArray = null;
			Vector4[] destinationArray2 = null;
			Vector2[] destinationArray3 = null;
			Vector2[] destinationArray4 = null;
			Vector2[] destinationArray5 = null;
			Vector2[] destinationArray6 = null;
			Color[] destinationArray7 = null;
			MBBlendShape[] array10 = null;
			Vector3[] destinationArray8 = new Vector3[num10];
			if (_doNorm)
			{
				destinationArray = new Vector3[num10];
			}
			if (_doTan)
			{
				destinationArray2 = new Vector4[num10];
			}
			if (_doUV)
			{
				destinationArray3 = new Vector2[num10];
			}
			if (_doUV3)
			{
				destinationArray5 = new Vector2[num10];
			}
			if (_doUV4)
			{
				destinationArray6 = new Vector2[num10];
			}
			if (doUV2())
			{
				destinationArray4 = new Vector2[num10];
			}
			if (_doCol)
			{
				destinationArray7 = new Color[num10];
			}
			if (_doBlendShapes)
			{
				array10 = new MBBlendShape[num12];
			}
			BoneWeight[] array11 = new BoneWeight[num10];
			Matrix4x4[] array12 = new Matrix4x4[num11];
			Transform[] array13 = new Transform[num11];
			SerializableIntArray[] array14 = new SerializableIntArray[num];
			for (int num14 = 0; num14 < array14.Length; num14++)
			{
				array14[num14] = new SerializableIntArray(array9[num14]);
			}
			for (int num15 = 0; num15 < array.Length; num15++)
			{
				MB_DynamicGameObject dgo2 = null;
				if (instance2Combined_MapTryGetValue(array[num15], out dgo2))
				{
					dgo2._beingDeleted = true;
				}
			}
			mbDynamicObjectsInCombinedMesh.Sort();
			int num16 = 0;
			int num17 = 0;
			int[] array15 = new int[num];
			int num18 = 0;
			for (int num19 = 0; num19 < mbDynamicObjectsInCombinedMesh.Count; num19++)
			{
				MB_DynamicGameObject mB_DynamicGameObject2 = mbDynamicObjectsInCombinedMesh[num19];
				if (!mB_DynamicGameObject2._beingDeleted)
				{
					if (LOG_LEVEL >= MB2_LogLevel.debug)
					{
						MB2_Log.LogDebug("Copying obj in combined arrays idx:" + num19, LOG_LEVEL);
					}
					Array.Copy(verts, mB_DynamicGameObject2.vertIdx, destinationArray8, num16, mB_DynamicGameObject2.numVerts);
					if (_doNorm)
					{
						Array.Copy(normals, mB_DynamicGameObject2.vertIdx, destinationArray, num16, mB_DynamicGameObject2.numVerts);
					}
					if (_doTan)
					{
						Array.Copy(tangents, mB_DynamicGameObject2.vertIdx, destinationArray2, num16, mB_DynamicGameObject2.numVerts);
					}
					if (_doUV)
					{
						Array.Copy(uvs, mB_DynamicGameObject2.vertIdx, destinationArray3, num16, mB_DynamicGameObject2.numVerts);
					}
					if (_doUV3)
					{
						Array.Copy(uv3s, mB_DynamicGameObject2.vertIdx, destinationArray5, num16, mB_DynamicGameObject2.numVerts);
					}
					if (_doUV4)
					{
						Array.Copy(uv4s, mB_DynamicGameObject2.vertIdx, destinationArray6, num16, mB_DynamicGameObject2.numVerts);
					}
					if (doUV2())
					{
						Array.Copy(uv2s, mB_DynamicGameObject2.vertIdx, destinationArray4, num16, mB_DynamicGameObject2.numVerts);
					}
					if (_doCol)
					{
						Array.Copy(colors, mB_DynamicGameObject2.vertIdx, destinationArray7, num16, mB_DynamicGameObject2.numVerts);
					}
					if (_doBlendShapes)
					{
						Array.Copy(blendShapes, mB_DynamicGameObject2.blendShapeIdx, array10, num17, mB_DynamicGameObject2.numBlendShapes);
					}
					if (renderType == MB_RenderType.skinnedMeshRenderer)
					{
						Array.Copy(boneWeights, mB_DynamicGameObject2.vertIdx, array11, num16, mB_DynamicGameObject2.numVerts);
					}
					for (int num20 = 0; num20 < num; num20++)
					{
						int[] data = submeshTris[num20].data;
						int num21 = mB_DynamicGameObject2.submeshTriIdxs[num20];
						int num22 = mB_DynamicGameObject2.submeshNumTris[num20];
						if (LOG_LEVEL >= MB2_LogLevel.debug)
						{
							MB2_Log.LogDebug("    Adjusting submesh triangles submesh:" + num20 + " startIdx:" + num21 + " num:" + num22 + " nsubmeshTris:" + array14.Length + " targSubmeshTidx:" + array15.Length, LOG_LEVEL);
						}
						for (int num23 = num21; num23 < num21 + num22; num23++)
						{
							data[num23] -= num18;
						}
						Array.Copy(data, num21, array14[num20].data, array15[num20], num22);
					}
					mB_DynamicGameObject2.vertIdx = num16;
					mB_DynamicGameObject2.blendShapeIdx = num17;
					for (int num24 = 0; num24 < array15.Length; num24++)
					{
						mB_DynamicGameObject2.submeshTriIdxs[num24] = array15[num24];
						array15[num24] += mB_DynamicGameObject2.submeshNumTris[num24];
					}
					num17 += mB_DynamicGameObject2.numBlendShapes;
					num16 += mB_DynamicGameObject2.numVerts;
				}
				else
				{
					if (LOG_LEVEL >= MB2_LogLevel.debug)
					{
						MB2_Log.LogDebug("Not copying obj: " + num19, LOG_LEVEL);
					}
					num18 += mB_DynamicGameObject2.numVerts;
				}
			}
			if (renderType == MB_RenderType.skinnedMeshRenderer)
			{
				_CopyBonesWeAreKeepingToNewBonesArrayAndAdjustBWIndexes(hashSet, hashSet2, array13, array12, array11, num2);
			}
			for (int num25 = mbDynamicObjectsInCombinedMesh.Count - 1; num25 >= 0; num25--)
			{
				if (mbDynamicObjectsInCombinedMesh[num25]._beingDeleted)
				{
					instance2Combined_MapRemove(mbDynamicObjectsInCombinedMesh[num25].instanceID);
					objectsInCombinedMesh.RemoveAt(num25);
					mbDynamicObjectsInCombinedMesh.RemoveAt(num25);
				}
			}
			verts = destinationArray8;
			if (_doNorm)
			{
				normals = destinationArray;
			}
			if (_doTan)
			{
				tangents = destinationArray2;
			}
			if (_doUV)
			{
				uvs = destinationArray3;
			}
			if (_doUV3)
			{
				uv3s = destinationArray5;
			}
			if (_doUV4)
			{
				uv4s = destinationArray6;
			}
			if (doUV2())
			{
				uv2s = destinationArray4;
			}
			if (_doCol)
			{
				colors = destinationArray7;
			}
			if (_doBlendShapes)
			{
				blendShapes = array10;
			}
			if (renderType == MB_RenderType.skinnedMeshRenderer)
			{
				boneWeights = array11;
			}
			int num26 = bones.Length - hashSet.Count;
			bindPoses = array12;
			bones = array13;
			submeshTris = array14;
			int num27 = 0;
			foreach (BoneAndBindpose item in hashSet2)
			{
				array13[num26 + num27] = item.bone;
				array12[num26 + num27] = item.bindPose;
				num27++;
			}
			for (int num28 = 0; num28 < list.Count; num28++)
			{
				MB_DynamicGameObject mB_DynamicGameObject3 = list[num28];
				GameObject gameObject2 = _goToAdd[num28];
				int num29 = num16;
				int index = num17;
				Mesh mesh2 = MB_Utility.GetMesh(gameObject2);
				Matrix4x4 localToWorldMatrix = gameObject2.transform.localToWorldMatrix;
				Matrix4x4 matrix4x = localToWorldMatrix;
				float num31 = (matrix4x[2, 3] = 0f);
				float value = (matrix4x[1, 3] = num31);
				matrix4x[0, 3] = value;
				destinationArray8 = meshChannelsCache.GetVertices(mesh2);
				Vector3[] array16 = null;
				Vector4[] array17 = null;
				if (_doNorm)
				{
					array16 = meshChannelsCache.GetNormals(mesh2);
				}
				if (_doTan)
				{
					array17 = meshChannelsCache.GetTangents(mesh2);
				}
				if (renderType != MB_RenderType.skinnedMeshRenderer)
				{
					for (int num33 = 0; num33 < destinationArray8.Length; num33++)
					{
						int num34 = num29 + num33;
						verts[num29 + num33] = localToWorldMatrix.MultiplyPoint3x4(destinationArray8[num33]);
						if (_doNorm)
						{
							normals[num34] = matrix4x.MultiplyPoint3x4(array16[num33]);
							normals[num34] = normals[num34].normalized;
						}
						if (_doTan)
						{
							float w = array17[num33].w;
							Vector3 vector = matrix4x.MultiplyPoint3x4(array17[num33]);
							vector.Normalize();
							tangents[num34] = vector;
							tangents[num34].w = w;
						}
					}
				}
				else
				{
					if (_doNorm)
					{
						array16.CopyTo(normals, num29);
					}
					if (_doTan)
					{
						array17.CopyTo(tangents, num29);
					}
					destinationArray8.CopyTo(verts, num29);
				}
				int subMeshCount = mesh2.subMeshCount;
				if (mB_DynamicGameObject3.uvRects.Length < subMeshCount)
				{
					if (LOG_LEVEL >= MB2_LogLevel.debug)
					{
						MB2_Log.LogDebug("Mesh " + mB_DynamicGameObject3.name + " has more submeshes than materials");
					}
					subMeshCount = mB_DynamicGameObject3.uvRects.Length;
				}
				else if (mB_DynamicGameObject3.uvRects.Length > subMeshCount && LOG_LEVEL >= MB2_LogLevel.warn)
				{
					UnityEngine.Debug.LogWarning("Mesh " + mB_DynamicGameObject3.name + " has fewer submeshes than materials");
				}
				if (_doUV)
				{
					_copyAndAdjustUVsFromMesh(mB_DynamicGameObject3, mesh2, num29, meshChannelsCache);
				}
				if (doUV2())
				{
					_copyAndAdjustUV2FromMesh(mB_DynamicGameObject3, mesh2, num29, meshChannelsCache);
				}
				if (_doUV3)
				{
					destinationArray5 = meshChannelsCache.GetUv3(mesh2);
					destinationArray5.CopyTo(uv3s, num29);
				}
				if (_doUV4)
				{
					destinationArray6 = meshChannelsCache.GetUv4(mesh2);
					destinationArray6.CopyTo(uv4s, num29);
				}
				if (_doCol)
				{
					destinationArray7 = meshChannelsCache.GetColors(mesh2);
					destinationArray7.CopyTo(colors, num29);
				}
				if (_doBlendShapes)
				{
					array10 = meshChannelsCache.GetBlendShapes(mesh2, mB_DynamicGameObject3.instanceID);
					array10.CopyTo(blendShapes, index);
				}
				if (renderType == MB_RenderType.skinnedMeshRenderer)
				{
					Renderer renderer2 = MB_Utility.GetRenderer(gameObject2);
					_AddBonesToNewBonesArrayAndAdjustBWIndexes(mB_DynamicGameObject3, renderer2, num29, array13, array11, meshChannelsCache);
				}
				for (int num35 = 0; num35 < array15.Length; num35++)
				{
					mB_DynamicGameObject3.submeshTriIdxs[num35] = array15[num35];
				}
				for (int num36 = 0; num36 < mB_DynamicGameObject3._tmpSubmeshTris.Length; num36++)
				{
					int[] data2 = mB_DynamicGameObject3._tmpSubmeshTris[num36].data;
					for (int num37 = 0; num37 < data2.Length; num37++)
					{
						data2[num37] += num29;
					}
					if (mB_DynamicGameObject3.invertTriangles)
					{
						for (int num38 = 0; num38 < data2.Length; num38 += 3)
						{
							int num39 = data2[num38];
							data2[num38] = data2[num38 + 1];
							data2[num38 + 1] = num39;
						}
					}
					int num40 = mB_DynamicGameObject3.targetSubmeshIdxs[num36];
					data2.CopyTo(submeshTris[num40].data, array15[num40]);
					mB_DynamicGameObject3.submeshNumTris[num40] += data2.Length;
					array15[num40] += data2.Length;
				}
				mB_DynamicGameObject3.vertIdx = num16;
				mB_DynamicGameObject3.blendShapeIdx = num17;
				instance2Combined_MapAdd(gameObject2.GetInstanceID(), mB_DynamicGameObject3);
				objectsInCombinedMesh.Add(gameObject2);
				mbDynamicObjectsInCombinedMesh.Add(mB_DynamicGameObject3);
				num16 += destinationArray8.Length;
				if (_doBlendShapes)
				{
					num17 += array10.Length;
				}
				for (int num41 = 0; num41 < mB_DynamicGameObject3._tmpSubmeshTris.Length; num41++)
				{
					mB_DynamicGameObject3._tmpSubmeshTris[num41] = null;
				}
				mB_DynamicGameObject3._tmpSubmeshTris = null;
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					MB2_Log.LogDebug("Added to combined:" + mB_DynamicGameObject3.name + " verts:" + destinationArray8.Length + " bindPoses:" + array12.Length, LOG_LEVEL);
				}
			}
			if (lightmapOption == MB2_LightmapOptions.copy_UV2_unchanged_to_separate_rects)
			{
				_copyUV2unchangedToSeparateRects();
			}
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				MB2_Log.LogDebug("===== _addToCombined completed. Verts in buffer: " + verts.Length + " time(ms): " + stopwatch.ElapsedMilliseconds, LOG_LEVEL);
			}
			return true;
		}

		private void _copyAndAdjustUVsFromMesh(MB_DynamicGameObject dgo, Mesh mesh, int vertsIdx, MeshChannelsCache meshChannelsCache)
		{
			Vector2[] uv0Raw = meshChannelsCache.GetUv0Raw(mesh);
			int[] array = new int[uv0Raw.Length];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = -1;
			}
			bool flag = false;
			for (int j = 0; j < dgo.targetSubmeshIdxs.Length; j++)
			{
				int[] array2 = ((dgo._tmpSubmeshTris == null) ? mesh.GetTriangles(j) : dgo._tmpSubmeshTris[j].data);
				if (LOG_LEVEL >= MB2_LogLevel.trace)
				{
					UnityEngine.Debug.Log($"Build UV transform for mesh {dgo.name} submesh {j} encapsulatingRect {dgo.encapsulatingRect[j]}");
				}
				Rect rect = MB3_TextureCombinerMerging.BuildTransformMeshUV2AtlasRect(textureBakeResults.resultMaterials[dgo.targetSubmeshIdxs[j]].considerMeshUVs, dgo.uvRects[j], (dgo.obUVRects == null) ? new Rect(0f, 0f, 1f, 1f) : dgo.obUVRects[j], dgo.sourceMaterialTiling[j], dgo.encapsulatingRect[j]);
				foreach (int num in array2)
				{
					if (array[num] == -1)
					{
						array[num] = j;
						Vector2 vector = uv0Raw[num];
						vector.x = rect.x + vector.x * rect.width;
						vector.y = rect.y + vector.y * rect.height;
						uvs[vertsIdx + num] = vector;
					}
					if (array[num] != j)
					{
						flag = true;
					}
				}
			}
			if (flag && LOG_LEVEL >= MB2_LogLevel.warn)
			{
				UnityEngine.Debug.LogWarning(dgo.name + "has submeshes which share verticies. Adjusted uvs may not map correctly in combined atlas.");
			}
			if (LOG_LEVEL >= MB2_LogLevel.trace)
			{
				UnityEngine.Debug.Log($"_copyAndAdjustUVsFromMesh copied {uv0Raw.Length} verts");
			}
		}

		private void _copyAndAdjustUV2FromMesh(MB_DynamicGameObject dgo, Mesh mesh, int vertsIdx, MeshChannelsCache meshChannelsCache)
		{
			Vector2[] uv = meshChannelsCache.GetUv2(mesh);
			if (lightmapOption == MB2_LightmapOptions.preserve_current_lightmapping)
			{
				Vector4 lightmapTilingOffset = dgo.lightmapTilingOffset;
				Vector2 vector = new Vector2(lightmapTilingOffset.x, lightmapTilingOffset.y);
				Vector2 vector2 = new Vector2(lightmapTilingOffset.z, lightmapTilingOffset.w);
				Vector2 vector3 = default(Vector2);
				for (int i = 0; i < uv.Length; i++)
				{
					vector3.x = vector.x * uv[i].x;
					vector3.y = vector.y * uv[i].y;
					uv2s[vertsIdx + i] = vector2 + vector3;
				}
				if (LOG_LEVEL >= MB2_LogLevel.trace)
				{
					UnityEngine.Debug.Log("_copyAndAdjustUV2FromMesh copied and modify for preserve current lightmapping " + uv.Length);
				}
			}
			else
			{
				uv.CopyTo(uv2s, vertsIdx);
				if (LOG_LEVEL >= MB2_LogLevel.trace)
				{
					UnityEngine.Debug.Log("_copyAndAdjustUV2FromMesh copied without modifying " + uv.Length);
				}
			}
		}

		public override void UpdateSkinnedMeshApproximateBounds()
		{
			UpdateSkinnedMeshApproximateBoundsFromBounds();
		}

		public override void UpdateSkinnedMeshApproximateBoundsFromBones()
		{
			if (outputOption == MB2_OutputOptions.bakeMeshAssetsInPlace)
			{
				if (LOG_LEVEL >= MB2_LogLevel.warn)
				{
					UnityEngine.Debug.LogWarning("Can't UpdateSkinnedMeshApproximateBounds when output type is bakeMeshAssetsInPlace");
				}
			}
			else if (bones.Length == 0)
			{
				if (verts.Length != 0 && LOG_LEVEL >= MB2_LogLevel.warn)
				{
					UnityEngine.Debug.LogWarning("No bones in SkinnedMeshRenderer. Could not UpdateSkinnedMeshApproximateBounds.");
				}
			}
			else if (_targetRenderer == null)
			{
				if (LOG_LEVEL >= MB2_LogLevel.warn)
				{
					UnityEngine.Debug.LogWarning("Target Renderer is not set. No point in calling UpdateSkinnedMeshApproximateBounds.");
				}
			}
			else if (!_targetRenderer.GetType().Equals(typeof(SkinnedMeshRenderer)))
			{
				if (LOG_LEVEL >= MB2_LogLevel.warn)
				{
					UnityEngine.Debug.LogWarning("Target Renderer is not a SkinnedMeshRenderer. No point in calling UpdateSkinnedMeshApproximateBounds.");
				}
			}
			else
			{
				MB3_MeshCombiner.UpdateSkinnedMeshApproximateBoundsFromBonesStatic(bones, (SkinnedMeshRenderer)targetRenderer);
			}
		}

		public override void UpdateSkinnedMeshApproximateBoundsFromBounds()
		{
			if (outputOption == MB2_OutputOptions.bakeMeshAssetsInPlace)
			{
				if (LOG_LEVEL >= MB2_LogLevel.warn)
				{
					UnityEngine.Debug.LogWarning("Can't UpdateSkinnedMeshApproximateBoundsFromBounds when output type is bakeMeshAssetsInPlace");
				}
			}
			else if (verts.Length == 0 || mbDynamicObjectsInCombinedMesh.Count == 0)
			{
				if (verts.Length != 0 && LOG_LEVEL >= MB2_LogLevel.warn)
				{
					UnityEngine.Debug.LogWarning("Nothing in SkinnedMeshRenderer. Could not UpdateSkinnedMeshApproximateBoundsFromBounds.");
				}
			}
			else if (_targetRenderer == null)
			{
				if (LOG_LEVEL >= MB2_LogLevel.warn)
				{
					UnityEngine.Debug.LogWarning("Target Renderer is not set. No point in calling UpdateSkinnedMeshApproximateBoundsFromBounds.");
				}
			}
			else if (!_targetRenderer.GetType().Equals(typeof(SkinnedMeshRenderer)))
			{
				if (LOG_LEVEL >= MB2_LogLevel.warn)
				{
					UnityEngine.Debug.LogWarning("Target Renderer is not a SkinnedMeshRenderer. No point in calling UpdateSkinnedMeshApproximateBoundsFromBounds.");
				}
			}
			else
			{
				MB3_MeshCombiner.UpdateSkinnedMeshApproximateBoundsFromBoundsStatic(objectsInCombinedMesh, (SkinnedMeshRenderer)targetRenderer);
			}
		}

		private int _getNumBones(Renderer r)
		{
			if (renderType == MB_RenderType.skinnedMeshRenderer)
			{
				if (r is SkinnedMeshRenderer)
				{
					return ((SkinnedMeshRenderer)r).bones.Length;
				}
				if (r is MeshRenderer)
				{
					return 1;
				}
				UnityEngine.Debug.LogError("Could not _getNumBones. Object does not have a renderer");
				return 0;
			}
			return 0;
		}

		private Transform[] _getBones(Renderer r)
		{
			return MBVersion.GetBones(r);
		}

		public override void Apply(GenerateUV2Delegate uv2GenerationMethod)
		{
			bool flag = false;
			if (renderType == MB_RenderType.skinnedMeshRenderer)
			{
				flag = true;
			}
			Apply(triangles: true, vertices: true, _doNorm, _doTan, _doUV, doUV2(), _doUV3, _doUV4, doCol, flag, doBlendShapes, uv2GenerationMethod);
		}

		public virtual void ApplyShowHide()
		{
			if (_validationLevel >= MB2_ValidationLevel.quick && !ValidateTargRendererAndMeshAndResultSceneObj())
			{
				return;
			}
			if (_mesh != null)
			{
				if (renderType == MB_RenderType.meshRenderer)
				{
					MBVersion.MeshClear(_mesh, t: true);
					_mesh.vertices = verts;
				}
				SerializableIntArray[] submeshTrisWithShowHideApplied = GetSubmeshTrisWithShowHideApplied();
				if (textureBakeResults.doMultiMaterial)
				{
					int num2 = (_mesh.subMeshCount = _numNonZeroLengthSubmeshTris(submeshTrisWithShowHideApplied));
					int numNonZeroLengthSubmeshTris = num2;
					int num3 = 0;
					for (int i = 0; i < submeshTrisWithShowHideApplied.Length; i++)
					{
						if (submeshTrisWithShowHideApplied[i].data.Length != 0)
						{
							_mesh.SetTriangles(submeshTrisWithShowHideApplied[i].data, num3);
							num3++;
						}
					}
					_updateMaterialsOnTargetRenderer(submeshTrisWithShowHideApplied, numNonZeroLengthSubmeshTris);
				}
				else
				{
					_mesh.triangles = submeshTrisWithShowHideApplied[0].data;
				}
				if (renderType == MB_RenderType.skinnedMeshRenderer)
				{
					if (verts.Length == 0)
					{
						targetRenderer.enabled = false;
					}
					else
					{
						targetRenderer.enabled = true;
					}
					bool updateWhenOffscreen = ((SkinnedMeshRenderer)targetRenderer).updateWhenOffscreen;
					((SkinnedMeshRenderer)targetRenderer).updateWhenOffscreen = true;
					((SkinnedMeshRenderer)targetRenderer).updateWhenOffscreen = updateWhenOffscreen;
				}
				if (LOG_LEVEL >= MB2_LogLevel.trace)
				{
					UnityEngine.Debug.Log("ApplyShowHide");
				}
			}
			else
			{
				UnityEngine.Debug.LogError("Need to add objects to this meshbaker before calling ApplyShowHide");
			}
		}

		public override void Apply(bool triangles, bool vertices, bool normals, bool tangents, bool uvs, bool uv2, bool uv3, bool uv4, bool colors, bool bones = false, bool blendShapesFlag = false, GenerateUV2Delegate uv2GenerationMethod = null)
		{
			Stopwatch stopwatch = null;
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				stopwatch = new Stopwatch();
				stopwatch.Start();
			}
			if (_validationLevel >= MB2_ValidationLevel.quick && !ValidateTargRendererAndMeshAndResultSceneObj())
			{
				return;
			}
			if (_mesh != null)
			{
				if (LOG_LEVEL >= MB2_LogLevel.trace)
				{
					UnityEngine.Debug.Log($"Apply called tri={triangles} vert={vertices} norm={normals} tan={tangents} uv={uvs} col={colors} uv3={uv3} uv4={uv4} uv2={uv2} bone={bones} blendShape{blendShapes} meshID={_mesh.GetInstanceID()}");
				}
				if (triangles || _mesh.vertexCount != verts.Length)
				{
					bool justClearTriangles = triangles && !vertices && !normals && !tangents && !uvs && !colors && !uv3 && !uv4 && !uv2 && !bones;
					MBVersion.SetMeshIndexFormatAndClearMesh(_mesh, verts.Length, vertices, justClearTriangles);
				}
				if (vertices)
				{
					Vector3[] array = verts;
					if (verts.Length != 0)
					{
						if (_recenterVertsToBoundsCenter && _renderType == MB_RenderType.meshRenderer)
						{
							array = new Vector3[verts.Length];
							Vector3 vector = verts[0];
							Vector3 vector2 = verts[0];
							for (int i = 1; i < verts.Length; i++)
							{
								Vector3 vector3 = verts[i];
								if (vector.x < vector3.x)
								{
									vector.x = vector3.x;
								}
								if (vector.y < vector3.y)
								{
									vector.y = vector3.y;
								}
								if (vector.z < vector3.z)
								{
									vector.z = vector3.z;
								}
								if (vector2.x > vector3.x)
								{
									vector2.x = vector3.x;
								}
								if (vector2.y > vector3.y)
								{
									vector2.y = vector3.y;
								}
								if (vector2.z > vector3.z)
								{
									vector2.z = vector3.z;
								}
							}
							Vector3 vector4 = (vector + vector2) / 2f;
							for (int j = 0; j < verts.Length; j++)
							{
								array[j] = verts[j] - vector4;
							}
							targetRenderer.transform.position = vector4;
						}
						else
						{
							targetRenderer.transform.position = Vector3.zero;
						}
					}
					_mesh.vertices = array;
				}
				if (triangles && (bool)_textureBakeResults)
				{
					if (_textureBakeResults == null)
					{
						UnityEngine.Debug.LogError("Texture Bake Result was not set.");
					}
					else
					{
						SerializableIntArray[] submeshTrisWithShowHideApplied = GetSubmeshTrisWithShowHideApplied();
						int num2 = (_mesh.subMeshCount = _numNonZeroLengthSubmeshTris(submeshTrisWithShowHideApplied));
						int numNonZeroLengthSubmeshTris = num2;
						int num3 = 0;
						for (int k = 0; k < submeshTrisWithShowHideApplied.Length; k++)
						{
							if (submeshTrisWithShowHideApplied[k].data.Length != 0)
							{
								_mesh.SetTriangles(submeshTrisWithShowHideApplied[k].data, num3);
								num3++;
							}
						}
						_updateMaterialsOnTargetRenderer(submeshTrisWithShowHideApplied, numNonZeroLengthSubmeshTris);
					}
				}
				if (normals)
				{
					if (_doNorm)
					{
						_mesh.normals = this.normals;
					}
					else
					{
						UnityEngine.Debug.LogError("normal flag was set in Apply but MeshBaker didn't generate normals");
					}
				}
				if (tangents)
				{
					if (_doTan)
					{
						_mesh.tangents = this.tangents;
					}
					else
					{
						UnityEngine.Debug.LogError("tangent flag was set in Apply but MeshBaker didn't generate tangents");
					}
				}
				if (uvs)
				{
					if (_doUV)
					{
						_mesh.uv = this.uvs;
					}
					else
					{
						UnityEngine.Debug.LogError("uv flag was set in Apply but MeshBaker didn't generate uvs");
					}
				}
				if (colors)
				{
					if (_doCol)
					{
						_mesh.colors = this.colors;
					}
					else
					{
						UnityEngine.Debug.LogError("color flag was set in Apply but MeshBaker didn't generate colors");
					}
				}
				if (uv3)
				{
					if (_doUV3)
					{
						MBVersion.MeshAssignUV3(_mesh, uv3s);
					}
					else
					{
						UnityEngine.Debug.LogError("uv3 flag was set in Apply but MeshBaker didn't generate uv3s");
					}
				}
				if (uv4)
				{
					if (_doUV4)
					{
						MBVersion.MeshAssignUV4(_mesh, uv4s);
					}
					else
					{
						UnityEngine.Debug.LogError("uv4 flag was set in Apply but MeshBaker didn't generate uv4s");
					}
				}
				if (uv2)
				{
					if (doUV2())
					{
						_mesh.uv2 = uv2s;
					}
					else
					{
						UnityEngine.Debug.LogError("uv2 flag was set in Apply but lightmapping option was set to " + lightmapOption);
					}
				}
				bool flag = false;
				if (renderType != MB_RenderType.skinnedMeshRenderer && lightmapOption == MB2_LightmapOptions.generate_new_UV2_layout)
				{
					if (uv2GenerationMethod != null)
					{
						uv2GenerationMethod(_mesh, uv2UnwrappingParamsHardAngle, uv2UnwrappingParamsPackMargin);
						if (LOG_LEVEL >= MB2_LogLevel.trace)
						{
							UnityEngine.Debug.Log("generating new UV2 layout for the combined mesh ");
						}
					}
					else
					{
						UnityEngine.Debug.LogError("No GenerateUV2Delegate method was supplied. UV2 cannot be generated.");
					}
					flag = true;
				}
				else if (renderType == MB_RenderType.skinnedMeshRenderer && lightmapOption == MB2_LightmapOptions.generate_new_UV2_layout && LOG_LEVEL >= MB2_LogLevel.warn)
				{
					UnityEngine.Debug.LogWarning("UV2 cannot be generated for SkinnedMeshRenderer objects.");
				}
				if (renderType != MB_RenderType.skinnedMeshRenderer && lightmapOption == MB2_LightmapOptions.generate_new_UV2_layout && !flag)
				{
					UnityEngine.Debug.LogError("Failed to generate new UV2 layout. Only works in editor.");
				}
				if (renderType == MB_RenderType.skinnedMeshRenderer)
				{
					if (verts.Length == 0)
					{
						targetRenderer.enabled = false;
					}
					else
					{
						targetRenderer.enabled = true;
					}
					bool updateWhenOffscreen = ((SkinnedMeshRenderer)targetRenderer).updateWhenOffscreen;
					((SkinnedMeshRenderer)targetRenderer).updateWhenOffscreen = true;
					((SkinnedMeshRenderer)targetRenderer).updateWhenOffscreen = updateWhenOffscreen;
				}
				if (bones)
				{
					_mesh.bindposes = bindPoses;
					_mesh.boneWeights = boneWeights;
				}
				if (blendShapesFlag && (MBVersion.GetMajorVersion() > 5 || (MBVersion.GetMajorVersion() == 5 && MBVersion.GetMinorVersion() >= 3)))
				{
					if (blendShapesInCombined.Length != blendShapes.Length)
					{
						blendShapesInCombined = new MBBlendShape[blendShapes.Length];
					}
					Vector3[] array2 = new Vector3[verts.Length];
					Vector3[] array3 = new Vector3[verts.Length];
					Vector3[] array4 = new Vector3[verts.Length];
					MBVersion.ClearBlendShapes(_mesh);
					for (int l = 0; l < blendShapes.Length; l++)
					{
						MB_DynamicGameObject mB_DynamicGameObject = instance2Combined_MapGet(blendShapes[l].gameObjectID);
						if (mB_DynamicGameObject != null)
						{
							for (int m = 0; m < blendShapes[l].frames.Length; m++)
							{
								MBBlendShapeFrame mBBlendShapeFrame = blendShapes[l].frames[m];
								int vertIdx = mB_DynamicGameObject.vertIdx;
								Array.Copy(mBBlendShapeFrame.vertices, 0, array2, vertIdx, blendShapes[l].frames[m].vertices.Length);
								Array.Copy(mBBlendShapeFrame.normals, 0, array3, vertIdx, blendShapes[l].frames[m].normals.Length);
								Array.Copy(mBBlendShapeFrame.tangents, 0, array4, vertIdx, blendShapes[l].frames[m].tangents.Length);
								MBVersion.AddBlendShapeFrame(_mesh, blendShapes[l].name + blendShapes[l].gameObjectID, mBBlendShapeFrame.frameWeight, array2, array3, array4);
								_ZeroArray(array2, vertIdx, blendShapes[l].frames[m].vertices.Length);
								_ZeroArray(array3, vertIdx, blendShapes[l].frames[m].normals.Length);
								_ZeroArray(array4, vertIdx, blendShapes[l].frames[m].tangents.Length);
							}
						}
						else
						{
							UnityEngine.Debug.LogError("InstanceID in blend shape that was not in instance2combinedMap");
						}
						blendShapesInCombined[l] = blendShapes[l];
					}
					((SkinnedMeshRenderer)_targetRenderer).sharedMesh = null;
					((SkinnedMeshRenderer)_targetRenderer).sharedMesh = _mesh;
				}
				if (triangles || vertices)
				{
					if (LOG_LEVEL >= MB2_LogLevel.trace)
					{
						UnityEngine.Debug.Log("recalculating bounds on mesh.");
					}
					_mesh.RecalculateBounds();
				}
				if (_optimizeAfterBake && !UnityEngine.Application.isPlaying)
				{
					MBVersion.OptimizeMesh(_mesh);
				}
			}
			else
			{
				UnityEngine.Debug.LogError("Need to add objects to this meshbaker before calling Apply or ApplyAll");
			}
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log("Apply Complete time: " + stopwatch.ElapsedMilliseconds + " vertices: " + _mesh.vertexCount);
			}
		}

		private int _numNonZeroLengthSubmeshTris(SerializableIntArray[] subTris)
		{
			int num = 0;
			for (int i = 0; i < subTris.Length; i++)
			{
				if (subTris[i].data.Length != 0)
				{
					num++;
				}
			}
			return num;
		}

		private void _updateMaterialsOnTargetRenderer(SerializableIntArray[] subTris, int numNonZeroLengthSubmeshTris)
		{
			if (subTris.Length != textureBakeResults.resultMaterials.Length)
			{
				UnityEngine.Debug.LogError("Mismatch between number of submeshes and number of result materials");
			}
			Material[] array = new Material[numNonZeroLengthSubmeshTris];
			int num = 0;
			for (int i = 0; i < subTris.Length; i++)
			{
				if (subTris[i].data.Length != 0)
				{
					array[num] = _textureBakeResults.resultMaterials[i].combinedMaterial;
					num++;
				}
			}
			targetRenderer.materials = array;
		}

		public SerializableIntArray[] GetSubmeshTrisWithShowHideApplied()
		{
			bool flag = false;
			for (int i = 0; i < mbDynamicObjectsInCombinedMesh.Count; i++)
			{
				if (!mbDynamicObjectsInCombinedMesh[i].show)
				{
					flag = true;
					break;
				}
			}
			if (flag)
			{
				int[] array = new int[submeshTris.Length];
				SerializableIntArray[] array2 = new SerializableIntArray[submeshTris.Length];
				for (int j = 0; j < mbDynamicObjectsInCombinedMesh.Count; j++)
				{
					MB_DynamicGameObject mB_DynamicGameObject = mbDynamicObjectsInCombinedMesh[j];
					if (mB_DynamicGameObject.show)
					{
						for (int k = 0; k < mB_DynamicGameObject.submeshNumTris.Length; k++)
						{
							array[k] += mB_DynamicGameObject.submeshNumTris[k];
						}
					}
				}
				for (int l = 0; l < array2.Length; l++)
				{
					array2[l] = new SerializableIntArray(array[l]);
				}
				int[] array3 = new int[array2.Length];
				for (int m = 0; m < mbDynamicObjectsInCombinedMesh.Count; m++)
				{
					MB_DynamicGameObject mB_DynamicGameObject2 = mbDynamicObjectsInCombinedMesh[m];
					if (!mB_DynamicGameObject2.show)
					{
						continue;
					}
					for (int n = 0; n < submeshTris.Length; n++)
					{
						int[] data = submeshTris[n].data;
						int num = mB_DynamicGameObject2.submeshTriIdxs[n];
						int num2 = num + mB_DynamicGameObject2.submeshNumTris[n];
						for (int num3 = num; num3 < num2; num3++)
						{
							array2[n].data[array3[n]] = data[num3];
							array3[n]++;
						}
					}
				}
				return array2;
			}
			return submeshTris;
		}

		public override void UpdateGameObjects(GameObject[] gos, bool recalcBounds = true, bool updateVertices = true, bool updateNormals = true, bool updateTangents = true, bool updateUV = false, bool updateUV2 = false, bool updateUV3 = false, bool updateUV4 = false, bool updateColors = false, bool updateSkinningInfo = false)
		{
			_updateGameObjects(gos, recalcBounds, updateVertices, updateNormals, updateTangents, updateUV, updateUV2, updateUV3, updateUV4, updateColors, updateSkinningInfo);
		}

		private void _updateGameObjects(GameObject[] gos, bool recalcBounds, bool updateVertices, bool updateNormals, bool updateTangents, bool updateUV, bool updateUV2, bool updateUV3, bool updateUV4, bool updateColors, bool updateSkinningInfo)
		{
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log("UpdateGameObjects called on " + gos.Length + " objects.");
			}
			int numResultMats = 1;
			if (textureBakeResults.doMultiMaterial)
			{
				numResultMats = textureBakeResults.resultMaterials.Length;
			}
			_initialize(numResultMats);
			if (_mesh.vertexCount > 0 && _instance2combined_map.Count == 0)
			{
				UnityEngine.Debug.LogWarning("There were vertices in the combined mesh but nothing in the MeshBaker buffers. If you are trying to bake in the editor and modify at runtime, make sure 'Clear Buffers After Bake' is unchecked.");
			}
			MeshChannelsCache meshChannelCache = new MeshChannelsCache(this);
			for (int i = 0; i < gos.Length; i++)
			{
				_updateGameObject(gos[i], updateVertices, updateNormals, updateTangents, updateUV, updateUV2, updateUV3, updateUV4, updateColors, updateSkinningInfo, meshChannelCache);
			}
			if (recalcBounds)
			{
				_mesh.RecalculateBounds();
			}
		}

		private void _updateGameObject(GameObject go, bool updateVertices, bool updateNormals, bool updateTangents, bool updateUV, bool updateUV2, bool updateUV3, bool updateUV4, bool updateColors, bool updateSkinningInfo, MeshChannelsCache meshChannelCache)
		{
			MB_DynamicGameObject dgo = null;
			if (!instance2Combined_MapTryGetValue(go.GetInstanceID(), out dgo))
			{
				UnityEngine.Debug.LogError("Object " + go.name + " has not been added");
				return;
			}
			Mesh mesh = MB_Utility.GetMesh(go);
			if (dgo.numVerts != mesh.vertexCount)
			{
				UnityEngine.Debug.LogError("Object " + go.name + " source mesh has been modified since being added. To update it must have the same number of verts");
				return;
			}
			if (_doUV && updateUV)
			{
				_copyAndAdjustUVsFromMesh(dgo, mesh, dgo.vertIdx, meshChannelCache);
			}
			if (doUV2() && updateUV2)
			{
				_copyAndAdjustUV2FromMesh(dgo, mesh, dgo.vertIdx, meshChannelCache);
			}
			if (renderType == MB_RenderType.skinnedMeshRenderer && updateSkinningInfo)
			{
				Renderer renderer = MB_Utility.GetRenderer(go);
				BoneWeight[] array = meshChannelCache.GetBoneWeights(renderer, dgo.numVerts);
				Transform[] array2 = _getBones(renderer);
				int num = dgo.vertIdx;
				bool flag = false;
				for (int i = 0; i < array.Length; i++)
				{
					if (array2[array[i].boneIndex0] != bones[boneWeights[num].boneIndex0])
					{
						flag = true;
						break;
					}
					boneWeights[num].weight0 = array[i].weight0;
					boneWeights[num].weight1 = array[i].weight1;
					boneWeights[num].weight2 = array[i].weight2;
					boneWeights[num].weight3 = array[i].weight3;
					num++;
				}
				if (flag)
				{
					UnityEngine.Debug.LogError("Detected that some of the boneweights reference different bones than when initial added. Boneweights must reference the same bones " + dgo.name);
				}
			}
			Matrix4x4 localToWorldMatrix = go.transform.localToWorldMatrix;
			if (updateVertices)
			{
				Vector3[] vertices = meshChannelCache.GetVertices(mesh);
				for (int j = 0; j < vertices.Length; j++)
				{
					verts[dgo.vertIdx + j] = localToWorldMatrix.MultiplyPoint3x4(vertices[j]);
				}
			}
			float num3 = (localToWorldMatrix[2, 3] = 0f);
			float value = (localToWorldMatrix[1, 3] = num3);
			localToWorldMatrix[0, 3] = value;
			if (_doNorm && updateNormals)
			{
				Vector3[] array3 = meshChannelCache.GetNormals(mesh);
				for (int k = 0; k < array3.Length; k++)
				{
					int num5 = dgo.vertIdx + k;
					normals[num5] = localToWorldMatrix.MultiplyPoint3x4(array3[k]);
					normals[num5] = normals[num5].normalized;
				}
			}
			if (_doTan && updateTangents)
			{
				Vector4[] array4 = meshChannelCache.GetTangents(mesh);
				for (int l = 0; l < array4.Length; l++)
				{
					int num6 = dgo.vertIdx + l;
					float w = array4[l].w;
					Vector3 vector = localToWorldMatrix.MultiplyPoint3x4(array4[l]);
					vector.Normalize();
					tangents[num6] = vector;
					tangents[num6].w = w;
				}
			}
			if (_doCol && updateColors)
			{
				Color[] array5 = meshChannelCache.GetColors(mesh);
				for (int m = 0; m < array5.Length; m++)
				{
					colors[dgo.vertIdx + m] = array5[m];
				}
			}
			if (_doUV3 && updateUV3)
			{
				Vector2[] uv = meshChannelCache.GetUv3(mesh);
				for (int n = 0; n < uv.Length; n++)
				{
					uv3s[dgo.vertIdx + n] = uv[n];
				}
			}
			if (_doUV4 && updateUV4)
			{
				Vector2[] uv2 = meshChannelCache.GetUv4(mesh);
				for (int num7 = 0; num7 < uv2.Length; num7++)
				{
					uv4s[dgo.vertIdx + num7] = uv2[num7];
				}
			}
		}

		public bool ShowHideGameObjects(GameObject[] toShow, GameObject[] toHide)
		{
			if (textureBakeResults == null)
			{
				UnityEngine.Debug.LogError("TextureBakeResults must be set.");
				return false;
			}
			return _showHide(toShow, toHide);
		}

		public override bool AddDeleteGameObjects(GameObject[] gos, GameObject[] deleteGOs, bool disableRendererInSource = true)
		{
			int[] array = null;
			if (deleteGOs != null)
			{
				array = new int[deleteGOs.Length];
				for (int i = 0; i < deleteGOs.Length; i++)
				{
					if (deleteGOs[i] == null)
					{
						UnityEngine.Debug.LogError("The " + i + "th object on the list of objects to delete is 'Null'");
					}
					else
					{
						array[i] = deleteGOs[i].GetInstanceID();
					}
				}
			}
			return AddDeleteGameObjectsByID(gos, array, disableRendererInSource);
		}

		public override bool AddDeleteGameObjectsByID(GameObject[] gos, int[] deleteGOinstanceIDs, bool disableRendererInSource)
		{
			if (validationLevel > MB2_ValidationLevel.none)
			{
				if (gos != null)
				{
					for (int i = 0; i < gos.Length; i++)
					{
						if (gos[i] == null)
						{
							UnityEngine.Debug.LogError("The " + i + "th object on the list of objects to combine is 'None'. Use Command-Delete on Mac OS X; Delete or Shift-Delete on Windows to remove this one element.");
							return false;
						}
						if (validationLevel < MB2_ValidationLevel.robust)
						{
							continue;
						}
						for (int j = i + 1; j < gos.Length; j++)
						{
							if (gos[i] == gos[j])
							{
								UnityEngine.Debug.LogError("GameObject " + gos[i]?.ToString() + " appears twice in list of game objects to add");
								return false;
							}
						}
					}
				}
				if (deleteGOinstanceIDs != null && validationLevel >= MB2_ValidationLevel.robust)
				{
					for (int k = 0; k < deleteGOinstanceIDs.Length; k++)
					{
						for (int l = k + 1; l < deleteGOinstanceIDs.Length; l++)
						{
							if (deleteGOinstanceIDs[k] == deleteGOinstanceIDs[l])
							{
								UnityEngine.Debug.LogError("GameObject " + deleteGOinstanceIDs[k] + "appears twice in list of game objects to delete");
								return false;
							}
						}
					}
				}
			}
			if (_usingTemporaryTextureBakeResult && gos != null && gos.Length != 0)
			{
				MB_Utility.Destroy(_textureBakeResults);
				_textureBakeResults = null;
				_usingTemporaryTextureBakeResult = false;
			}
			if (_textureBakeResults == null && gos != null && gos.Length != 0 && gos[0] != null && !_CreateTemporaryTextrueBakeResult(gos, GetMaterialsOnTargetRenderer()))
			{
				return false;
			}
			BuildSceneMeshObject(gos);
			if (!_addToCombined(gos, deleteGOinstanceIDs, disableRendererInSource))
			{
				UnityEngine.Debug.LogError("Failed to add/delete objects to combined mesh");
				return false;
			}
			if (targetRenderer != null)
			{
				if (renderType == MB_RenderType.skinnedMeshRenderer)
				{
					SkinnedMeshRenderer obj = (SkinnedMeshRenderer)targetRenderer;
					obj.sharedMesh = _mesh;
					obj.bones = bones;
					UpdateSkinnedMeshApproximateBoundsFromBounds();
				}
				targetRenderer.lightmapIndex = GetLightmapIndex();
			}
			return true;
		}

		public override bool CombinedMeshContains(GameObject go)
		{
			return objectsInCombinedMesh.Contains(go);
		}

		public override void ClearBuffers()
		{
			verts = new Vector3[0];
			normals = new Vector3[0];
			tangents = new Vector4[0];
			uvs = new Vector2[0];
			uv2s = new Vector2[0];
			uv3s = new Vector2[0];
			uv4s = new Vector2[0];
			colors = new Color[0];
			bones = new Transform[0];
			bindPoses = new Matrix4x4[0];
			boneWeights = new BoneWeight[0];
			submeshTris = new SerializableIntArray[0];
			blendShapes = new MBBlendShape[0];
			if (blendShapesInCombined == null)
			{
				blendShapesInCombined = new MBBlendShape[0];
			}
			else
			{
				for (int i = 0; i < blendShapesInCombined.Length; i++)
				{
					blendShapesInCombined[i].frames = new MBBlendShapeFrame[0];
				}
			}
			mbDynamicObjectsInCombinedMesh.Clear();
			objectsInCombinedMesh.Clear();
			instance2Combined_MapClear();
			if (_usingTemporaryTextureBakeResult)
			{
				MB_Utility.Destroy(_textureBakeResults);
				_textureBakeResults = null;
				_usingTemporaryTextureBakeResult = false;
			}
			if (LOG_LEVEL >= MB2_LogLevel.trace)
			{
				MB2_Log.LogDebug("ClearBuffers called");
			}
		}

		public override void ClearMesh()
		{
			if (_mesh != null)
			{
				MBVersion.MeshClear(_mesh, t: false);
			}
			else
			{
				_mesh = new Mesh();
			}
			ClearBuffers();
		}

		public override void DestroyMesh()
		{
			if (_mesh != null)
			{
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					MB2_Log.LogDebug("Destroying Mesh");
				}
				MB_Utility.Destroy(_mesh);
			}
			_mesh = new Mesh();
			ClearBuffers();
		}

		public override void DestroyMeshEditor(MB2_EditorMethodsInterface editorMethods)
		{
			if (_mesh != null)
			{
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					MB2_Log.LogDebug("Destroying Mesh");
				}
				editorMethods.Destroy(_mesh);
			}
			_mesh = new Mesh();
			ClearBuffers();
		}

		public bool ValidateTargRendererAndMeshAndResultSceneObj()
		{
			if (_resultSceneObject == null)
			{
				if (_LOG_LEVEL >= MB2_LogLevel.error)
				{
					UnityEngine.Debug.LogError("Result Scene Object was not set.");
				}
				return false;
			}
			if (_targetRenderer == null)
			{
				if (_LOG_LEVEL >= MB2_LogLevel.error)
				{
					UnityEngine.Debug.LogError("Target Renderer was not set.");
				}
				return false;
			}
			if (_targetRenderer.transform.parent != _resultSceneObject.transform)
			{
				if (_LOG_LEVEL >= MB2_LogLevel.error)
				{
					UnityEngine.Debug.LogError("Target Renderer game object is not a child of Result Scene Object was not set.");
				}
				return false;
			}
			if (_renderType == MB_RenderType.skinnedMeshRenderer && !(_targetRenderer is SkinnedMeshRenderer))
			{
				if (_LOG_LEVEL >= MB2_LogLevel.error)
				{
					UnityEngine.Debug.LogError("Render Type is skinned mesh renderer but Target Renderer is not.");
				}
				return false;
			}
			if (_renderType == MB_RenderType.meshRenderer)
			{
				if (!(_targetRenderer is MeshRenderer))
				{
					if (_LOG_LEVEL >= MB2_LogLevel.error)
					{
						UnityEngine.Debug.LogError("Render Type is mesh renderer but Target Renderer is not.");
					}
					return false;
				}
				MeshFilter component = _targetRenderer.GetComponent<MeshFilter>();
				if (_mesh != component.sharedMesh)
				{
					if (_LOG_LEVEL >= MB2_LogLevel.error)
					{
						UnityEngine.Debug.LogError("Target renderer mesh is not equal to mesh.");
					}
					return false;
				}
			}
			return true;
		}

		internal static Renderer BuildSceneHierarchPreBake(MB3_MeshCombinerSingle mom, GameObject root, Mesh m, bool createNewChild = false, GameObject[] objsToBeAdded = null)
		{
			if (mom._LOG_LEVEL >= MB2_LogLevel.trace)
			{
				UnityEngine.Debug.Log("Building Scene Hierarchy createNewChild=" + createNewChild);
			}
			MeshFilter meshFilter = null;
			MeshRenderer meshRenderer = null;
			SkinnedMeshRenderer skinnedMeshRenderer = null;
			Transform transform = null;
			if (root == null)
			{
				UnityEngine.Debug.LogError("root was null.");
				return null;
			}
			if (mom.textureBakeResults == null)
			{
				UnityEngine.Debug.LogError("textureBakeResults must be set.");
				return null;
			}
			if (root.GetComponent<Renderer>() != null)
			{
				UnityEngine.Debug.LogError("root game object cannot have a renderer component");
				return null;
			}
			if (!createNewChild)
			{
				if (mom.targetRenderer != null && mom.targetRenderer.transform.parent == root.transform)
				{
					transform = mom.targetRenderer.transform;
				}
				else
				{
					Renderer[] componentsInChildren = root.GetComponentsInChildren<Renderer>();
					if (componentsInChildren.Length == 1)
					{
						if (componentsInChildren[0].transform.parent != root.transform)
						{
							UnityEngine.Debug.LogError("Target Renderer is not an immediate child of Result Scene Object. Try using a game object with no children as the Result Scene Object..");
						}
						transform = componentsInChildren[0].transform;
					}
				}
			}
			if (transform != null && transform.parent != root.transform)
			{
				transform = null;
			}
			GameObject gameObject;
			if (transform == null)
			{
				gameObject = new GameObject(mom.name + "-mesh");
				gameObject.transform.parent = root.transform;
				transform = gameObject.transform;
			}
			transform.parent = root.transform;
			gameObject = transform.gameObject;
			if (mom.renderType == MB_RenderType.skinnedMeshRenderer)
			{
				MeshRenderer component = gameObject.GetComponent<MeshRenderer>();
				if (component != null)
				{
					MB_Utility.Destroy(component);
				}
				MeshFilter component2 = gameObject.GetComponent<MeshFilter>();
				if (component2 != null)
				{
					MB_Utility.Destroy(component2);
				}
				skinnedMeshRenderer = gameObject.GetComponent<SkinnedMeshRenderer>();
				if (skinnedMeshRenderer == null)
				{
					skinnedMeshRenderer = gameObject.AddComponent<SkinnedMeshRenderer>();
				}
			}
			else
			{
				SkinnedMeshRenderer component3 = gameObject.GetComponent<SkinnedMeshRenderer>();
				if (component3 != null)
				{
					MB_Utility.Destroy(component3);
				}
				meshFilter = gameObject.GetComponent<MeshFilter>();
				if (meshFilter == null)
				{
					meshFilter = gameObject.AddComponent<MeshFilter>();
				}
				meshRenderer = gameObject.GetComponent<MeshRenderer>();
				if (meshRenderer == null)
				{
					meshRenderer = gameObject.AddComponent<MeshRenderer>();
				}
			}
			if (mom.renderType == MB_RenderType.skinnedMeshRenderer)
			{
				skinnedMeshRenderer.bones = mom.GetBones();
				bool updateWhenOffscreen = skinnedMeshRenderer.updateWhenOffscreen;
				skinnedMeshRenderer.updateWhenOffscreen = true;
				skinnedMeshRenderer.updateWhenOffscreen = updateWhenOffscreen;
			}
			_ConfigureSceneHierarch(mom, root, meshRenderer, meshFilter, skinnedMeshRenderer, m, objsToBeAdded);
			if (mom.renderType == MB_RenderType.skinnedMeshRenderer)
			{
				return skinnedMeshRenderer;
			}
			return meshRenderer;
		}

		public static void BuildPrefabHierarchy(MB3_MeshCombinerSingle mom, GameObject instantiatedPrefabRoot, Mesh m, bool createNewChild = false, GameObject[] objsToBeAdded = null)
		{
			SkinnedMeshRenderer skinnedMeshRenderer = null;
			MeshRenderer meshRenderer = null;
			MeshFilter meshFilter = null;
			GameObject gameObject = new GameObject(mom.name + "-mesh");
			gameObject.transform.parent = instantiatedPrefabRoot.transform;
			Transform transform = gameObject.transform;
			transform.parent = instantiatedPrefabRoot.transform;
			gameObject = transform.gameObject;
			if (mom.renderType == MB_RenderType.skinnedMeshRenderer)
			{
				MeshRenderer component = gameObject.GetComponent<MeshRenderer>();
				if (component != null)
				{
					MB_Utility.Destroy(component);
				}
				MeshFilter component2 = gameObject.GetComponent<MeshFilter>();
				if (component2 != null)
				{
					MB_Utility.Destroy(component2);
				}
				skinnedMeshRenderer = gameObject.GetComponent<SkinnedMeshRenderer>();
				if (skinnedMeshRenderer == null)
				{
					skinnedMeshRenderer = gameObject.AddComponent<SkinnedMeshRenderer>();
				}
			}
			else
			{
				SkinnedMeshRenderer component3 = gameObject.GetComponent<SkinnedMeshRenderer>();
				if (component3 != null)
				{
					MB_Utility.Destroy(component3);
				}
				meshFilter = gameObject.GetComponent<MeshFilter>();
				if (meshFilter == null)
				{
					meshFilter = gameObject.AddComponent<MeshFilter>();
				}
				meshRenderer = gameObject.GetComponent<MeshRenderer>();
				if (meshRenderer == null)
				{
					meshRenderer = gameObject.AddComponent<MeshRenderer>();
				}
			}
			if (mom.renderType == MB_RenderType.skinnedMeshRenderer)
			{
				skinnedMeshRenderer.bones = mom.GetBones();
				bool updateWhenOffscreen = skinnedMeshRenderer.updateWhenOffscreen;
				skinnedMeshRenderer.updateWhenOffscreen = true;
				skinnedMeshRenderer.updateWhenOffscreen = updateWhenOffscreen;
				skinnedMeshRenderer.sharedMesh = m;
			}
			_ConfigureSceneHierarch(mom, instantiatedPrefabRoot, meshRenderer, meshFilter, skinnedMeshRenderer, m, objsToBeAdded);
			if (mom.targetRenderer != null)
			{
				Material[] array = new Material[mom.targetRenderer.sharedMaterials.Length];
				for (int i = 0; i < array.Length; i++)
				{
					array[i] = mom.targetRenderer.sharedMaterials[i];
				}
				if (mom.renderType == MB_RenderType.skinnedMeshRenderer)
				{
					skinnedMeshRenderer.sharedMaterial = null;
					skinnedMeshRenderer.sharedMaterials = array;
				}
				else
				{
					meshRenderer.sharedMaterial = null;
					meshRenderer.sharedMaterials = array;
				}
			}
		}

		private static void _ConfigureSceneHierarch(MB3_MeshCombinerSingle mom, GameObject root, MeshRenderer mr, MeshFilter mf, SkinnedMeshRenderer smr, Mesh m, GameObject[] objsToBeAdded = null)
		{
			GameObject gameObject;
			if (mom.renderType == MB_RenderType.skinnedMeshRenderer)
			{
				gameObject = smr.gameObject;
				smr.lightmapIndex = mom.GetLightmapIndex();
			}
			else
			{
				gameObject = mr.gameObject;
				mf.sharedMesh = m;
				mr.lightmapIndex = mom.GetLightmapIndex();
			}
			if (mom.lightmapOption == MB2_LightmapOptions.preserve_current_lightmapping || mom.lightmapOption == MB2_LightmapOptions.generate_new_UV2_layout)
			{
				gameObject.isStatic = true;
			}
			if (objsToBeAdded == null || objsToBeAdded.Length == 0 || !(objsToBeAdded[0] != null))
			{
				return;
			}
			bool flag = true;
			bool flag2 = true;
			string tag = objsToBeAdded[0].tag;
			int layer = objsToBeAdded[0].layer;
			for (int i = 0; i < objsToBeAdded.Length; i++)
			{
				if (objsToBeAdded[i] != null)
				{
					if (!objsToBeAdded[i].tag.Equals(tag))
					{
						flag = false;
					}
					if (objsToBeAdded[i].layer != layer)
					{
						flag2 = false;
					}
				}
			}
			if (flag)
			{
				root.tag = tag;
				gameObject.tag = tag;
			}
			if (flag2)
			{
				root.layer = layer;
				gameObject.layer = layer;
			}
		}

		public void BuildSceneMeshObject(GameObject[] gos = null, bool createNewChild = false)
		{
			if (_resultSceneObject == null)
			{
				_resultSceneObject = new GameObject("CombinedMesh-" + base.name);
			}
			_targetRenderer = BuildSceneHierarchPreBake(this, _resultSceneObject, GetMesh(), createNewChild, gos);
		}

		private bool IsMirrored(Matrix4x4 tm)
		{
			Vector3 lhs = tm.GetRow(0);
			Vector3 rhs = tm.GetRow(1);
			Vector3 rhs2 = tm.GetRow(2);
			lhs.Normalize();
			rhs.Normalize();
			rhs2.Normalize();
			if (!(Vector3.Dot(Vector3.Cross(lhs, rhs), rhs2) >= 0f))
			{
				return true;
			}
			return false;
		}

		public override void CheckIntegrity()
		{
			if (!MB_Utility.DO_INTEGRITY_CHECKS)
			{
				return;
			}
			if (renderType == MB_RenderType.skinnedMeshRenderer)
			{
				for (int i = 0; i < mbDynamicObjectsInCombinedMesh.Count; i++)
				{
					MB_DynamicGameObject mB_DynamicGameObject = mbDynamicObjectsInCombinedMesh[i];
					HashSet<int> hashSet = new HashSet<int>();
					HashSet<int> hashSet2 = new HashSet<int>();
					for (int j = mB_DynamicGameObject.vertIdx; j < mB_DynamicGameObject.vertIdx + mB_DynamicGameObject.numVerts; j++)
					{
						hashSet.Add(boneWeights[j].boneIndex0);
						hashSet.Add(boneWeights[j].boneIndex1);
						hashSet.Add(boneWeights[j].boneIndex2);
						hashSet.Add(boneWeights[j].boneIndex3);
					}
					for (int k = 0; k < mB_DynamicGameObject.indexesOfBonesUsed.Length; k++)
					{
						hashSet2.Add(mB_DynamicGameObject.indexesOfBonesUsed[k]);
					}
					hashSet2.ExceptWith(hashSet);
					if (hashSet2.Count > 0)
					{
						UnityEngine.Debug.LogError("The bone indexes were not the same. " + hashSet.Count + " " + hashSet2.Count);
					}
					for (int l = 0; l < mB_DynamicGameObject.indexesOfBonesUsed.Length; l++)
					{
						if (l < 0 || l > bones.Length)
						{
							UnityEngine.Debug.LogError("Bone index was out of bounds.");
						}
					}
					if (renderType == MB_RenderType.skinnedMeshRenderer && mB_DynamicGameObject.indexesOfBonesUsed.Length < 1)
					{
						UnityEngine.Debug.Log("DGO had no bones");
					}
				}
			}
			if (doBlendShapes && renderType != MB_RenderType.skinnedMeshRenderer)
			{
				UnityEngine.Debug.LogError("Blend shapes can only be used with skinned meshes.");
			}
		}

		private void _ZeroArray(Vector3[] arr, int idx, int length)
		{
			int num = idx + length;
			for (int i = idx; i < num; i++)
			{
				arr[i] = Vector3.zero;
			}
		}

		private List<MB_DynamicGameObject>[] _buildBoneIdx2dgoMap()
		{
			List<MB_DynamicGameObject>[] array = new List<MB_DynamicGameObject>[bones.Length];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = new List<MB_DynamicGameObject>();
			}
			for (int j = 0; j < mbDynamicObjectsInCombinedMesh.Count; j++)
			{
				MB_DynamicGameObject mB_DynamicGameObject = mbDynamicObjectsInCombinedMesh[j];
				for (int k = 0; k < mB_DynamicGameObject.indexesOfBonesUsed.Length; k++)
				{
					array[mB_DynamicGameObject.indexesOfBonesUsed[k]].Add(mB_DynamicGameObject);
				}
			}
			return array;
		}

		private void _CollectBonesToAddForDGO(MB_DynamicGameObject dgo, Dictionary<Transform, int> bone2idx, HashSet<int> boneIdxsToDelete, HashSet<BoneAndBindpose> bonesToAdd, Renderer r, MeshChannelsCache meshChannelCache)
		{
			Matrix4x4[] array = (dgo._tmpCachedBindposes = meshChannelCache.GetBindposes(r));
			BoneWeight[] array2 = (dgo._tmpCachedBoneWeights = meshChannelCache.GetBoneWeights(r, dgo.numVerts));
			Transform[] array3 = (dgo._tmpCachedBones = _getBones(r));
			HashSet<int> hashSet = new HashSet<int>();
			for (int i = 0; i < array2.Length; i++)
			{
				hashSet.Add(array2[i].boneIndex0);
				hashSet.Add(array2[i].boneIndex1);
				hashSet.Add(array2[i].boneIndex2);
				hashSet.Add(array2[i].boneIndex3);
			}
			int[] array4 = new int[hashSet.Count];
			hashSet.CopyTo(array4);
			for (int j = 0; j < array4.Length; j++)
			{
				bool flag = false;
				int num = array4[j];
				if (bone2idx.TryGetValue(array3[num], out var value) && array3[num] == bones[value] && !boneIdxsToDelete.Contains(value) && array[num] == bindPoses[value])
				{
					flag = true;
				}
				if (!flag)
				{
					BoneAndBindpose item = new BoneAndBindpose(array3[num], array[num]);
					if (!bonesToAdd.Contains(item))
					{
						bonesToAdd.Add(item);
					}
				}
			}
			dgo._tmpIndexesOfSourceBonesUsed = array4;
		}

		private void _CopyBonesWeAreKeepingToNewBonesArrayAndAdjustBWIndexes(HashSet<int> boneIdxsToDeleteHS, HashSet<BoneAndBindpose> bonesToAdd, Transform[] nbones, Matrix4x4[] nbindPoses, BoneWeight[] nboneWeights, int totalDeleteVerts)
		{
			if (boneIdxsToDeleteHS.Count > 0)
			{
				int[] array = new int[boneIdxsToDeleteHS.Count];
				boneIdxsToDeleteHS.CopyTo(array);
				Array.Sort(array);
				int[] array2 = new int[bones.Length];
				int num = 0;
				int num2 = 0;
				for (int i = 0; i < bones.Length; i++)
				{
					if (num2 < array.Length && array[num2] == i)
					{
						num2++;
						array2[i] = -1;
						continue;
					}
					array2[i] = num;
					nbones[num] = bones[i];
					nbindPoses[num] = bindPoses[i];
					num++;
				}
				int num3 = boneWeights.Length - totalDeleteVerts;
				for (int j = 0; j < num3; j++)
				{
					nboneWeights[j].boneIndex0 = array2[nboneWeights[j].boneIndex0];
					nboneWeights[j].boneIndex1 = array2[nboneWeights[j].boneIndex1];
					nboneWeights[j].boneIndex2 = array2[nboneWeights[j].boneIndex2];
					nboneWeights[j].boneIndex3 = array2[nboneWeights[j].boneIndex3];
				}
				for (int k = 0; k < mbDynamicObjectsInCombinedMesh.Count; k++)
				{
					MB_DynamicGameObject mB_DynamicGameObject = mbDynamicObjectsInCombinedMesh[k];
					for (int l = 0; l < mB_DynamicGameObject.indexesOfBonesUsed.Length; l++)
					{
						mB_DynamicGameObject.indexesOfBonesUsed[l] = array2[mB_DynamicGameObject.indexesOfBonesUsed[l]];
					}
				}
			}
			else
			{
				Array.Copy(bones, nbones, bones.Length);
				Array.Copy(bindPoses, nbindPoses, bindPoses.Length);
			}
		}

		private void _AddBonesToNewBonesArrayAndAdjustBWIndexes(MB_DynamicGameObject dgo, Renderer r, int vertsIdx, Transform[] nbones, BoneWeight[] nboneWeights, MeshChannelsCache meshChannelCache)
		{
			Transform[] tmpCachedBones = dgo._tmpCachedBones;
			Matrix4x4[] tmpCachedBindposes = dgo._tmpCachedBindposes;
			BoneWeight[] tmpCachedBoneWeights = dgo._tmpCachedBoneWeights;
			int[] array = new int[tmpCachedBones.Length];
			for (int i = 0; i < dgo._tmpIndexesOfSourceBonesUsed.Length; i++)
			{
				int num = dgo._tmpIndexesOfSourceBonesUsed[i];
				for (int j = 0; j < nbones.Length; j++)
				{
					if (tmpCachedBones[num] == nbones[j] && tmpCachedBindposes[num] == bindPoses[j])
					{
						array[num] = j;
						break;
					}
				}
			}
			for (int k = 0; k < tmpCachedBoneWeights.Length; k++)
			{
				int num2 = vertsIdx + k;
				nboneWeights[num2].boneIndex0 = array[tmpCachedBoneWeights[k].boneIndex0];
				nboneWeights[num2].boneIndex1 = array[tmpCachedBoneWeights[k].boneIndex1];
				nboneWeights[num2].boneIndex2 = array[tmpCachedBoneWeights[k].boneIndex2];
				nboneWeights[num2].boneIndex3 = array[tmpCachedBoneWeights[k].boneIndex3];
				nboneWeights[num2].weight0 = tmpCachedBoneWeights[k].weight0;
				nboneWeights[num2].weight1 = tmpCachedBoneWeights[k].weight1;
				nboneWeights[num2].weight2 = tmpCachedBoneWeights[k].weight2;
				nboneWeights[num2].weight3 = tmpCachedBoneWeights[k].weight3;
			}
			for (int l = 0; l < dgo._tmpIndexesOfSourceBonesUsed.Length; l++)
			{
				dgo._tmpIndexesOfSourceBonesUsed[l] = array[dgo._tmpIndexesOfSourceBonesUsed[l]];
			}
			dgo.indexesOfBonesUsed = dgo._tmpIndexesOfSourceBonesUsed;
			dgo._tmpIndexesOfSourceBonesUsed = null;
			dgo._tmpCachedBones = null;
			dgo._tmpCachedBindposes = null;
			dgo._tmpCachedBoneWeights = null;
		}

		private void _copyUV2unchangedToSeparateRects()
		{
			int padding = 16;
			List<Vector2> list = new List<Vector2>();
			float num = 1E+11f;
			float num2 = 0f;
			for (int i = 0; i < mbDynamicObjectsInCombinedMesh.Count; i++)
			{
				float magnitude = mbDynamicObjectsInCombinedMesh[i].meshSize.magnitude;
				if (magnitude > num2)
				{
					num2 = magnitude;
				}
				if (magnitude < num)
				{
					num = magnitude;
				}
			}
			float num3 = 1000f;
			float num4 = 10f;
			float num5 = 0f;
			float num6 = 1f;
			if (num2 - num > num3 - num4)
			{
				num6 = (num3 - num4) / (num2 - num);
				num5 = num4 - num * num6;
			}
			else
			{
				num6 = num3 / num2;
			}
			for (int j = 0; j < mbDynamicObjectsInCombinedMesh.Count; j++)
			{
				float magnitude2 = mbDynamicObjectsInCombinedMesh[j].meshSize.magnitude;
				magnitude2 = magnitude2 * num6 + num5;
				Vector2 item = Vector2.one * magnitude2;
				list.Add(item);
			}
			AtlasPackingResult[] rects = new MB2_TexturePackerRegular
			{
				atlasMustBePowerOfTwo = false
			}.GetRects(list, 8192, 8192, padding);
			for (int k = 0; k < mbDynamicObjectsInCombinedMesh.Count; k++)
			{
				MB_DynamicGameObject mB_DynamicGameObject = mbDynamicObjectsInCombinedMesh[k];
				float x;
				float num7 = (x = uv2s[mB_DynamicGameObject.vertIdx].x);
				float y;
				float num8 = (y = uv2s[mB_DynamicGameObject.vertIdx].y);
				int num9 = mB_DynamicGameObject.vertIdx + mB_DynamicGameObject.numVerts;
				for (int l = mB_DynamicGameObject.vertIdx; l < num9; l++)
				{
					if (uv2s[l].x < num7)
					{
						num7 = uv2s[l].x;
					}
					if (uv2s[l].x > x)
					{
						x = uv2s[l].x;
					}
					if (uv2s[l].y < num8)
					{
						num8 = uv2s[l].y;
					}
					if (uv2s[l].y > y)
					{
						y = uv2s[l].y;
					}
				}
				Rect rect = rects[0].rects[k];
				for (int m = mB_DynamicGameObject.vertIdx; m < num9; m++)
				{
					float num10 = x - num7;
					float num11 = y - num8;
					if (num10 == 0f)
					{
						num10 = 1f;
					}
					if (num11 == 0f)
					{
						num11 = 1f;
					}
					uv2s[m].x = (uv2s[m].x - num7) / num10 * rect.width + rect.x;
					uv2s[m].y = (uv2s[m].y - num8) / num11 * rect.height + rect.y;
				}
			}
		}

		public override List<Material> GetMaterialsOnTargetRenderer()
		{
			List<Material> list = new List<Material>();
			if (_targetRenderer != null)
			{
				list.AddRange(_targetRenderer.sharedMaterials);
			}
			return list;
		}
	}
	[Serializable]
	public class MB3_MultiMeshCombiner : MB3_MeshCombiner
	{
		[Serializable]
		public class CombinedMesh
		{
			public MB3_MeshCombinerSingle combinedMesh;

			public int extraSpace = -1;

			public int numVertsInListToDelete;

			public int numVertsInListToAdd;

			public List<GameObject> gosToAdd;

			public List<int> gosToDelete;

			public List<GameObject> gosToUpdate;

			public bool isDirty;

			public CombinedMesh(int maxNumVertsInMesh, GameObject resultSceneObject, MB2_LogLevel ll)
			{
				combinedMesh = new MB3_MeshCombinerSingle();
				combinedMesh.resultSceneObject = resultSceneObject;
				combinedMesh.LOG_LEVEL = ll;
				extraSpace = maxNumVertsInMesh;
				numVertsInListToDelete = 0;
				numVertsInListToAdd = 0;
				gosToAdd = new List<GameObject>();
				gosToDelete = new List<int>();
				gosToUpdate = new List<GameObject>();
			}

			public bool isEmpty()
			{
				List<GameObject> list = new List<GameObject>();
				list.AddRange(combinedMesh.GetObjectsInCombined());
				for (int i = 0; i < gosToDelete.Count; i++)
				{
					for (int j = 0; j < list.Count; j++)
					{
						if (list[j].GetInstanceID() == gosToDelete[i])
						{
							list.RemoveAt(j);
							break;
						}
					}
				}
				if (list.Count == 0)
				{
					return true;
				}
				return false;
			}
		}

		private static GameObject[] empty = new GameObject[0];

		private static int[] emptyIDs = new int[0];

		public Dictionary<int, CombinedMesh> obj2MeshCombinerMap = new Dictionary<int, CombinedMesh>();

		[SerializeField]
		public List<CombinedMesh> meshCombiners = new List<CombinedMesh>();

		[SerializeField]
		private int _maxVertsInMesh = 65535;

		public override MB2_LogLevel LOG_LEVEL
		{
			get
			{
				return _LOG_LEVEL;
			}
			set
			{
				_LOG_LEVEL = value;
				for (int i = 0; i < meshCombiners.Count; i++)
				{
					meshCombiners[i].combinedMesh.LOG_LEVEL = value;
				}
			}
		}

		public override MB2_ValidationLevel validationLevel
		{
			get
			{
				return _validationLevel;
			}
			set
			{
				_validationLevel = value;
				for (int i = 0; i < meshCombiners.Count; i++)
				{
					meshCombiners[i].combinedMesh.validationLevel = _validationLevel;
				}
			}
		}

		public int maxVertsInMesh
		{
			get
			{
				return _maxVertsInMesh;
			}
			set
			{
				if (obj2MeshCombinerMap.Count <= 0)
				{
					if (value < 3)
					{
						UnityEngine.Debug.LogError("Max verts in mesh must be greater than three.");
					}
					else if (value > MBVersion.MaxMeshVertexCount())
					{
						UnityEngine.Debug.LogError("Meshes in unity cannot have more than " + MBVersion.MaxMeshVertexCount() + " vertices.");
					}
					else
					{
						_maxVertsInMesh = value;
					}
				}
			}
		}

		public override int GetNumObjectsInCombined()
		{
			return obj2MeshCombinerMap.Count;
		}

		public override int GetNumVerticesFor(GameObject go)
		{
			CombinedMesh value = null;
			if (obj2MeshCombinerMap.TryGetValue(go.GetInstanceID(), out value))
			{
				return value.combinedMesh.GetNumVerticesFor(go);
			}
			return -1;
		}

		public override int GetNumVerticesFor(int gameObjectID)
		{
			CombinedMesh value = null;
			if (obj2MeshCombinerMap.TryGetValue(gameObjectID, out value))
			{
				return value.combinedMesh.GetNumVerticesFor(gameObjectID);
			}
			return -1;
		}

		public override List<GameObject> GetObjectsInCombined()
		{
			List<GameObject> list = new List<GameObject>();
			for (int i = 0; i < meshCombiners.Count; i++)
			{
				list.AddRange(meshCombiners[i].combinedMesh.GetObjectsInCombined());
			}
			return list;
		}

		public override int GetLightmapIndex()
		{
			if (meshCombiners.Count > 0)
			{
				return meshCombiners[0].combinedMesh.GetLightmapIndex();
			}
			return -1;
		}

		public override bool CombinedMeshContains(GameObject go)
		{
			return obj2MeshCombinerMap.ContainsKey(go.GetInstanceID());
		}

		private bool _validateTextureBakeResults()
		{
			if (_textureBakeResults == null)
			{
				UnityEngine.Debug.LogError("Texture Bake Results is null. Can't combine meshes.");
				return false;
			}
			if (_textureBakeResults.materialsAndUVRects == null || _textureBakeResults.materialsAndUVRects.Length == 0)
			{
				UnityEngine.Debug.LogError("Texture Bake Results has no materials in material to sourceUVRect map. Try baking materials. Can't combine meshes.");
				return false;
			}
			if (_textureBakeResults.resultMaterials == null || _textureBakeResults.resultMaterials.Length == 0)
			{
				UnityEngine.Debug.LogError("Texture Bake Results has no result materials. Try baking materials. Can't combine meshes.");
				return false;
			}
			return true;
		}

		public override void Apply(GenerateUV2Delegate uv2GenerationMethod)
		{
			for (int i = 0; i < meshCombiners.Count; i++)
			{
				if (meshCombiners[i].isDirty)
				{
					meshCombiners[i].combinedMesh.Apply(uv2GenerationMethod);
					meshCombiners[i].isDirty = false;
				}
			}
		}

		public override void Apply(bool triangles, bool vertices, bool normals, bool tangents, bool uvs, bool uv2, bool uv3, bool uv4, bool colors, bool bones = false, bool blendShapesFlag = false, GenerateUV2Delegate uv2GenerationMethod = null)
		{
			for (int i = 0; i < meshCombiners.Count; i++)
			{
				if (meshCombiners[i].isDirty)
				{
					meshCombiners[i].combinedMesh.Apply(triangles, vertices, normals, tangents, uvs, uv2, uv3, uv4, colors, bones, blendShapesFlag, uv2GenerationMethod);
					meshCombiners[i].isDirty = false;
				}
			}
		}

		public override void UpdateSkinnedMeshApproximateBounds()
		{
			for (int i = 0; i < meshCombiners.Count; i++)
			{
				meshCombiners[i].combinedMesh.UpdateSkinnedMeshApproximateBounds();
			}
		}

		public override void UpdateSkinnedMeshApproximateBoundsFromBones()
		{
			for (int i = 0; i < meshCombiners.Count; i++)
			{
				meshCombiners[i].combinedMesh.UpdateSkinnedMeshApproximateBoundsFromBones();
			}
		}

		public override void UpdateSkinnedMeshApproximateBoundsFromBounds()
		{
			for (int i = 0; i < meshCombiners.Count; i++)
			{
				meshCombiners[i].combinedMesh.UpdateSkinnedMeshApproximateBoundsFromBounds();
			}
		}

		public override void UpdateGameObjects(GameObject[] gos, bool recalcBounds = true, bool updateVertices = true, bool updateNormals = true, bool updateTangents = true, bool updateUV = false, bool updateUV2 = false, bool updateUV3 = false, bool updateUV4 = false, bool updateColors = false, bool updateSkinningInfo = false)
		{
			if (gos == null)
			{
				UnityEngine.Debug.LogError("list of game objects cannot be null");
				return;
			}
			for (int i = 0; i < meshCombiners.Count; i++)
			{
				meshCombiners[i].gosToUpdate.Clear();
			}
			for (int j = 0; j < gos.Length; j++)
			{
				CombinedMesh value = null;
				obj2MeshCombinerMap.TryGetValue(gos[j].GetInstanceID(), out value);
				if (value != null)
				{
					value.gosToUpdate.Add(gos[j]);
				}
				else
				{
					UnityEngine.Debug.LogWarning("Object " + gos[j]?.ToString() + " is not in the combined mesh.");
				}
			}
			for (int k = 0; k < meshCombiners.Count; k++)
			{
				if (meshCombiners[k].gosToUpdate.Count > 0)
				{
					meshCombiners[k].isDirty = true;
					GameObject[] gos2 = meshCombiners[k].gosToUpdate.ToArray();
					meshCombiners[k].combinedMesh.UpdateGameObjects(gos2, recalcBounds, updateVertices, updateNormals, updateTangents, updateUV, updateUV2, updateUV3, updateUV4, updateColors, updateSkinningInfo);
				}
			}
		}

		public override bool AddDeleteGameObjects(GameObject[] gos, GameObject[] deleteGOs, bool disableRendererInSource = true)
		{
			int[] array = null;
			if (deleteGOs != null)
			{
				array = new int[deleteGOs.Length];
				for (int i = 0; i < deleteGOs.Length; i++)
				{
					if (deleteGOs[i] == null)
					{
						UnityEngine.Debug.LogError("The " + i + "th object on the list of objects to delete is 'Null'");
					}
					else
					{
						array[i] = deleteGOs[i].GetInstanceID();
					}
				}
			}
			return AddDeleteGameObjectsByID(gos, array, disableRendererInSource);
		}

		public override bool AddDeleteGameObjectsByID(GameObject[] gos, int[] deleteGOinstanceIDs, bool disableRendererInSource = true)
		{
			if (_usingTemporaryTextureBakeResult && gos != null && gos.Length != 0)
			{
				MB_Utility.Destroy(_textureBakeResults);
				_textureBakeResults = null;
				_usingTemporaryTextureBakeResult = false;
			}
			if (_textureBakeResults == null && gos != null && gos.Length != 0 && gos[0] != null && !_CreateTemporaryTextrueBakeResult(gos, GetMaterialsOnTargetRenderer()))
			{
				return false;
			}
			if (!_validate(gos, deleteGOinstanceIDs))
			{
				return false;
			}
			_distributeAmongBakers(gos, deleteGOinstanceIDs);
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				MB2_Log.LogDebug("MB2_MultiMeshCombiner.AddDeleteGameObjects numCombinedMeshes: " + meshCombiners.Count + " added:" + gos?.ToString() + " deleted:" + deleteGOinstanceIDs?.ToString() + " disableRendererInSource:" + disableRendererInSource + " maxVertsPerCombined:" + _maxVertsInMesh);
			}
			return _bakeStep1(gos, deleteGOinstanceIDs, disableRendererInSource);
		}

		private bool _validate(GameObject[] gos, int[] deleteGOinstanceIDs)
		{
			if (_validationLevel == MB2_ValidationLevel.none)
			{
				return true;
			}
			if (_maxVertsInMesh < 3)
			{
				UnityEngine.Debug.LogError("Invalid value for maxVertsInMesh=" + _maxVertsInMesh);
			}
			_validateTextureBakeResults();
			if (gos != null)
			{
				for (int i = 0; i < gos.Length; i++)
				{
					if (gos[i] == null)
					{
						UnityEngine.Debug.LogError("The " + i + "th object on the list of objects to combine is 'None'. Use Command-Delete on Mac OS X; Delete or Shift-Delete on Windows to remove this one element.");
						return false;
					}
					if (_validationLevel < MB2_ValidationLevel.robust)
					{
						continue;
					}
					for (int j = i + 1; j < gos.Length; j++)
					{
						if (gos[i] == gos[j])
						{
							UnityEngine.Debug.LogError("GameObject " + gos[i]?.ToString() + "appears twice in list of game objects to add");
							return false;
						}
					}
					if (!obj2MeshCombinerMap.ContainsKey(gos[i].GetInstanceID()))
					{
						continue;
					}
					bool flag = false;
					if (deleteGOinstanceIDs != null)
					{
						for (int k = 0; k < deleteGOinstanceIDs.Length; k++)
						{
							if (deleteGOinstanceIDs[k] == gos[i].GetInstanceID())
							{
								flag = true;
							}
						}
					}
					if (!flag)
					{
						UnityEngine.Debug.LogError("GameObject " + gos[i]?.ToString() + " is already in the combined mesh " + gos[i].GetInstanceID());
						return false;
					}
				}
			}
			if (deleteGOinstanceIDs != null && _validationLevel >= MB2_ValidationLevel.robust)
			{
				for (int l = 0; l < deleteGOinstanceIDs.Length; l++)
				{
					for (int m = l + 1; m < deleteGOinstanceIDs.Length; m++)
					{
						if (deleteGOinstanceIDs[l] == deleteGOinstanceIDs[m])
						{
							UnityEngine.Debug.LogError("GameObject " + deleteGOinstanceIDs[l] + "appears twice in list of game objects to delete");
							return false;
						}
					}
					if (!obj2MeshCombinerMap.ContainsKey(deleteGOinstanceIDs[l]))
					{
						UnityEngine.Debug.LogWarning("GameObject with instance ID " + deleteGOinstanceIDs[l] + " on the list of objects to delete is not in the combined mesh.");
					}
				}
			}
			return true;
		}

		private void _distributeAmongBakers(GameObject[] gos, int[] deleteGOinstanceIDs)
		{
			if (gos == null)
			{
				gos = empty;
			}
			if (deleteGOinstanceIDs == null)
			{
				deleteGOinstanceIDs = emptyIDs;
			}
			if (resultSceneObject == null)
			{
				resultSceneObject = new GameObject("CombinedMesh-" + base.name);
			}
			for (int i = 0; i < meshCombiners.Count; i++)
			{
				meshCombiners[i].extraSpace = _maxVertsInMesh - meshCombiners[i].combinedMesh.GetMesh().vertexCount;
			}
			for (int j = 0; j < deleteGOinstanceIDs.Length; j++)
			{
				CombinedMesh value = null;
				if (obj2MeshCombinerMap.TryGetValue(deleteGOinstanceIDs[j], out value))
				{
					if (LOG_LEVEL >= MB2_LogLevel.debug)
					{
						MB2_Log.LogDebug("MB2_MultiMeshCombiner.Removing " + deleteGOinstanceIDs[j] + " from meshCombiner " + meshCombiners.IndexOf(value));
					}
					value.numVertsInListToDelete += value.combinedMesh.GetNumVerticesFor(deleteGOinstanceIDs[j]);
					value.gosToDelete.Add(deleteGOinstanceIDs[j]);
				}
				else
				{
					UnityEngine.Debug.LogWarning("Object " + deleteGOinstanceIDs[j] + " in the list of objects to delete is not in the combined mesh.");
				}
			}
			for (int k = 0; k < gos.Length; k++)
			{
				GameObject gameObject = gos[k];
				int vertexCount = MB_Utility.GetMesh(gameObject).vertexCount;
				CombinedMesh combinedMesh = null;
				for (int l = 0; l < meshCombiners.Count; l++)
				{
					if (meshCombiners[l].extraSpace + meshCombiners[l].numVertsInListToDelete - meshCombiners[l].numVertsInListToAdd > vertexCount)
					{
						combinedMesh = meshCombiners[l];
						if (LOG_LEVEL >= MB2_LogLevel.debug)
						{
							MB2_Log.LogDebug("MB2_MultiMeshCombiner.Added " + gos[k]?.ToString() + " to combinedMesh " + l, LOG_LEVEL);
						}
						break;
					}
				}
				if (combinedMesh == null)
				{
					combinedMesh = new CombinedMesh(maxVertsInMesh, _resultSceneObject, _LOG_LEVEL);
					_setMBValues(combinedMesh.combinedMesh);
					meshCombiners.Add(combinedMesh);
					if (LOG_LEVEL >= MB2_LogLevel.debug)
					{
						MB2_Log.LogDebug("MB2_MultiMeshCombiner.Created new combinedMesh");
					}
				}
				combinedMesh.gosToAdd.Add(gameObject);
				combinedMesh.numVertsInListToAdd += vertexCount;
			}
		}

		private bool _bakeStep1(GameObject[] gos, int[] deleteGOinstanceIDs, bool disableRendererInSource)
		{
			for (int i = 0; i < meshCombiners.Count; i++)
			{
				CombinedMesh combinedMesh = meshCombiners[i];
				if (combinedMesh.combinedMesh.targetRenderer == null)
				{
					combinedMesh.combinedMesh.resultSceneObject = _resultSceneObject;
					combinedMesh.combinedMesh.BuildSceneMeshObject(gos, createNewChild: true);
					if (_LOG_LEVEL >= MB2_LogLevel.debug)
					{
						MB2_Log.LogDebug("BuildSO combiner {0} goID {1} targetRenID {2} meshID {3}", i, combinedMesh.combinedMesh.targetRenderer.gameObject.GetInstanceID(), combinedMesh.combinedMesh.targetRenderer.GetInstanceID(), combinedMesh.combinedMesh.GetMesh().GetInstanceID());
					}
				}
				else if (combinedMesh.combinedMesh.targetRenderer.transform.parent != resultSceneObject.transform)
				{
					UnityEngine.Debug.LogError("targetRender objects must be children of resultSceneObject");
					return false;
				}
				if (combinedMesh.gosToAdd.Count > 0 || combinedMesh.gosToDelete.Count > 0)
				{
					combinedMesh.combinedMesh.AddDeleteGameObjectsByID(combinedMesh.gosToAdd.ToArray(), combinedMesh.gosToDelete.ToArray(), disableRendererInSource);
					if (_LOG_LEVEL >= MB2_LogLevel.debug)
					{
						MB2_Log.LogDebug("Baked combiner {0} obsAdded {1} objsRemoved {2} goID {3} targetRenID {4} meshID {5}", i, combinedMesh.gosToAdd.Count, combinedMesh.gosToDelete.Count, combinedMesh.combinedMesh.targetRenderer.gameObject.GetInstanceID(), combinedMesh.combinedMesh.targetRenderer.GetInstanceID(), combinedMesh.combinedMesh.GetMesh().GetInstanceID());
					}
				}
				Renderer renderer = combinedMesh.combinedMesh.targetRenderer;
				Mesh mesh = combinedMesh.combinedMesh.GetMesh();
				if (renderer is MeshRenderer)
				{
					renderer.gameObject.GetComponent<MeshFilter>().sharedMesh = mesh;
				}
				else
				{
					((SkinnedMeshRenderer)renderer).sharedMesh = mesh;
				}
			}
			for (int j = 0; j < meshCombiners.Count; j++)
			{
				CombinedMesh combinedMesh2 = meshCombiners[j];
				for (int k = 0; k < combinedMesh2.gosToDelete.Count; k++)
				{
					obj2MeshCombinerMap.Remove(combinedMesh2.gosToDelete[k]);
				}
			}
			for (int l = 0; l < meshCombiners.Count; l++)
			{
				CombinedMesh combinedMesh3 = meshCombiners[l];
				for (int m = 0; m < combinedMesh3.gosToAdd.Count; m++)
				{
					obj2MeshCombinerMap.Add(combinedMesh3.gosToAdd[m].GetInstanceID(), combinedMesh3);
				}
				if (combinedMesh3.gosToAdd.Count > 0 || combinedMesh3.gosToDelete.Count > 0)
				{
					combinedMesh3.gosToDelete.Clear();
					combinedMesh3.gosToAdd.Clear();
					combinedMesh3.numVertsInListToDelete = 0;
					combinedMesh3.numVertsInListToAdd = 0;
					combinedMesh3.isDirty = true;
				}
			}
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				string text = "Meshes in combined:";
				for (int n = 0; n < meshCombiners.Count; n++)
				{
					text = text + " mesh" + n + "(" + meshCombiners[n].combinedMesh.GetObjectsInCombined().Count + ")\n";
				}
				text = text + "children in result: " + resultSceneObject.transform.childCount;
				MB2_Log.LogDebug(text, LOG_LEVEL);
			}
			if (meshCombiners.Count > 0)
			{
				return true;
			}
			return false;
		}

		public override Dictionary<MBBlendShapeKey, MBBlendShapeValue> BuildSourceBlendShapeToCombinedIndexMap()
		{
			Dictionary<MBBlendShapeKey, MBBlendShapeValue> dictionary = new Dictionary<MBBlendShapeKey, MBBlendShapeValue>();
			for (int i = 0; i < meshCombiners.Count; i++)
			{
				for (int j = 0; j < meshCombiners[i].combinedMesh.blendShapes.Length; j++)
				{
					MB3_MeshCombinerSingle.MBBlendShape mBBlendShape = meshCombiners[i].combinedMesh.blendShapes[j];
					MBBlendShapeValue mBBlendShapeValue = new MBBlendShapeValue();
					mBBlendShapeValue.combinedMeshGameObject = meshCombiners[i].combinedMesh.targetRenderer.gameObject;
					mBBlendShapeValue.blendShapeIndex = j;
					dictionary.Add(new MBBlendShapeKey(mBBlendShape.gameObjectID, mBBlendShape.indexInSource), mBBlendShapeValue);
				}
			}
			return dictionary;
		}

		public override void ClearBuffers()
		{
			for (int i = 0; i < meshCombiners.Count; i++)
			{
				meshCombiners[i].combinedMesh.ClearBuffers();
			}
			obj2MeshCombinerMap.Clear();
		}

		public override void ClearMesh()
		{
			DestroyMesh();
		}

		public override void DestroyMesh()
		{
			for (int i = 0; i < meshCombiners.Count; i++)
			{
				if (meshCombiners[i].combinedMesh.targetRenderer != null)
				{
					MB_Utility.Destroy(meshCombiners[i].combinedMesh.targetRenderer.gameObject);
				}
				meshCombiners[i].combinedMesh.ClearMesh();
			}
			obj2MeshCombinerMap.Clear();
			meshCombiners.Clear();
		}

		public override void DestroyMeshEditor(MB2_EditorMethodsInterface editorMethods)
		{
			for (int i = 0; i < meshCombiners.Count; i++)
			{
				if (meshCombiners[i].combinedMesh.targetRenderer != null)
				{
					editorMethods.Destroy(meshCombiners[i].combinedMesh.targetRenderer.gameObject);
				}
				meshCombiners[i].combinedMesh.ClearMesh();
			}
			obj2MeshCombinerMap.Clear();
			meshCombiners.Clear();
		}

		private void _setMBValues(MB3_MeshCombinerSingle targ)
		{
			targ.validationLevel = _validationLevel;
			targ.renderType = renderType;
			targ.outputOption = MB2_OutputOptions.bakeIntoSceneObject;
			targ.lightmapOption = lightmapOption;
			targ.textureBakeResults = textureBakeResults;
			targ.doNorm = doNorm;
			targ.doTan = doTan;
			targ.doCol = doCol;
			targ.doUV = doUV;
			targ.doUV3 = doUV3;
			targ.doUV4 = doUV4;
			targ.doBlendShapes = doBlendShapes;
			targ.optimizeAfterBake = base.optimizeAfterBake;
			targ.recenterVertsToBoundsCenter = recenterVertsToBoundsCenter;
			targ.uv2UnwrappingParamsHardAngle = uv2UnwrappingParamsHardAngle;
			targ.uv2UnwrappingParamsPackMargin = uv2UnwrappingParamsPackMargin;
		}

		public override List<Material> GetMaterialsOnTargetRenderer()
		{
			HashSet<Material> hashSet = new HashSet<Material>();
			for (int i = 0; i < meshCombiners.Count; i++)
			{
				hashSet.UnionWith(meshCombiners[i].combinedMesh.GetMaterialsOnTargetRenderer());
			}
			return new List<Material>(hashSet);
		}

		public override void CheckIntegrity()
		{
			if (MB_Utility.DO_INTEGRITY_CHECKS)
			{
				for (int i = 0; i < meshCombiners.Count; i++)
				{
					meshCombiners[i].combinedMesh.CheckIntegrity();
				}
			}
		}
	}
	public class PriorityQueue<TPriority, TValue> : ICollection<KeyValuePair<TPriority, TValue>>, IEnumerable<KeyValuePair<TPriority, TValue>>, IEnumerable
	{
		public List<KeyValuePair<TPriority, TValue>> _baseHeap;

		private IComparer<TPriority> _comparer;

		public bool IsEmpty => _baseHeap.Count == 0;

		public int Count => _baseHeap.Count;

		public bool IsReadOnly => false;

		public PriorityQueue()
			: this((IComparer<TPriority>)Comparer<TPriority>.Default)
		{
		}

		public PriorityQueue(int capacity)
			: this(capacity, (IComparer<TPriority>)Comparer<TPriority>.Default)
		{
		}

		public PriorityQueue(int capacity, IComparer<TPriority> comparer)
		{
			if (comparer == null)
			{
				throw new ArgumentNullException();
			}
			_baseHeap = new List<KeyValuePair<TPriority, TValue>>(capacity);
			_comparer = comparer;
		}

		public PriorityQueue(IComparer<TPriority> comparer)
		{
			if (comparer == null)
			{
				throw new ArgumentNullException();
			}
			_baseHeap = new List<KeyValuePair<TPriority, TValue>>();
			_comparer = comparer;
		}

		public PriorityQueue(IEnumerable<KeyValuePair<TPriority, TValue>> data)
			: this(data, (IComparer<TPriority>)Comparer<TPriority>.Default)
		{
		}

		public PriorityQueue(IEnumerable<KeyValuePair<TPriority, TValue>> data, IComparer<TPriority> comparer)
		{
			if (data == null || comparer == null)
			{
				throw new ArgumentNullException();
			}
			_comparer = comparer;
			_baseHeap = new List<KeyValuePair<TPriority, TValue>>(data);
			for (int num = _baseHeap.Count / 2 - 1; num >= 0; num--)
			{
				HeapifyFromBeginningToEnd(num);
			}
		}

		public static PriorityQueue<TPriority, TValue> MergeQueues(PriorityQueue<TPriority, TValue> pq1, PriorityQueue<TPriority, TValue> pq2)
		{
			if (pq1 == null || pq2 == null)
			{
				throw new ArgumentNullException();
			}
			if (pq1._comparer != pq2._comparer)
			{
				throw new InvalidOperationException("Priority queues to be merged must have equal comparers");
			}
			return MergeQueues(pq1, pq2, pq1._comparer);
		}

		public static PriorityQueue<TPriority, TValue> MergeQueues(PriorityQueue<TPriority, TValue> pq1, PriorityQueue<TPriority, TValue> pq2, IComparer<TPriority> comparer)
		{
			if (pq1 == null || pq2 == null || comparer == null)
			{
				throw new ArgumentNullException();
			}
			PriorityQueue<TPriority, TValue> priorityQueue = new PriorityQueue<TPriority, TValue>(pq1.Count + pq2.Count, pq1._comparer);
			priorityQueue._baseHeap.AddRange(pq1._baseHeap);
			priorityQueue._baseHeap.AddRange(pq2._baseHeap);
			for (int num = priorityQueue._baseHeap.Count / 2 - 1; num >= 0; num--)
			{
				priorityQueue.HeapifyFromBeginningToEnd(num);
			}
			return priorityQueue;
		}

		public void Enqueue(TPriority priority, TValue value)
		{
			Insert(priority, value);
		}

		public KeyValuePair<TPriority, TValue> Dequeue()
		{
			if (!IsEmpty)
			{
				KeyValuePair<TPriority, TValue> result = _baseHeap[0];
				DeleteRoot();
				return result;
			}
			throw new InvalidOperationException("Priority queue is empty");
		}

		public TValue DequeueValue()
		{
			return Dequeue().Value;
		}

		public KeyValuePair<TPriority, TValue> Peek()
		{
			if (!IsEmpty)
			{
				return _baseHeap[0];
			}
			throw new InvalidOperationException("Priority queue is empty");
		}

		public TValue PeekValue()
		{
			return Peek().Value;
		}

		private void ExchangeElements(int pos1, int pos2)
		{
			KeyValuePair<TPriority, TValue> value = _baseHeap[pos1];
			_baseHeap[pos1] = _baseHeap[pos2];
			_baseHeap[pos2] = value;
		}

		private void Insert(TPriority priority, TValue value)
		{
			KeyValuePair<TPriority, TValue> item = new KeyValuePair<TPriority, TValue>(priority, value);
			_baseHeap.Add(item);
			HeapifyFromEndToBeginning(_baseHeap.Count - 1);
		}

		private int HeapifyFromEndToBeginning(int pos)
		{
			if (pos >= _baseHeap.Count)
			{
				return -1;
			}
			while (pos > 0)
			{
				int num = (pos - 1) / 2;
				if (_comparer.Compare(_baseHeap[num].Key, _baseHeap[pos].Key) <= 0)
				{
					break;
				}
				ExchangeElements(num, pos);
				pos = num;
			}
			return pos;
		}

		private void DeleteRoot()
		{
			if (_baseHeap.Count <= 1)
			{
				_baseHeap.Clear();
				return;
			}
			_baseHeap[0] = _baseHeap[_baseHeap.Count - 1];
			_baseHeap.RemoveAt(_baseHeap.Count - 1);
			HeapifyFromBeginningToEnd(0);
		}

		private void HeapifyFromBeginningToEnd(int pos)
		{
			if (pos >= _baseHeap.Count)
			{
				return;
			}
			while (true)
			{
				int num = pos;
				int num2 = 2 * pos + 1;
				int num3 = 2 * pos + 2;
				if (num2 < _baseHeap.Count && _comparer.Compare(_baseHeap[num].Key, _baseHeap[num2].Key) > 0)
				{
					num = num2;
				}
				if (num3 < _baseHeap.Count && _comparer.Compare(_baseHeap[num].Key, _baseHeap[num3].Key) > 0)
				{
					num = num3;
				}
				if (num != pos)
				{
					ExchangeElements(num, pos);
					pos = num;
					continue;
				}
				break;
			}
		}

		public void Add(KeyValuePair<TPriority, TValue> item)
		{
			Enqueue(item.Key, item.Value);
		}

		public void Clear()
		{
			_baseHeap.Clear();
		}

		public bool Contains(KeyValuePair<TPriority, TValue> item)
		{
			return _baseHeap.Contains(item);
		}

		public bool TryFindValue(TPriority item, out TValue foundVersion)
		{
			for (int i = 0; i < _baseHeap.Count; i++)
			{
				if (_comparer.Compare(item, _baseHeap[i].Key) == 0)
				{
					foundVersion = _baseHeap[i].Value;
					return true;
				}
			}
			foundVersion = default(TValue);
			return false;
		}

		public void CopyTo(KeyValuePair<TPriority, TValue>[] array, int arrayIndex)
		{
			_baseHeap.CopyTo(array, arrayIndex);
		}

		public bool Remove(KeyValuePair<TPriority, TValue> item)
		{
			int num = _baseHeap.IndexOf(item);
			if (num < 0)
			{
				return false;
			}
			_baseHeap[num] = _baseHeap[_baseHeap.Count - 1];
			_baseHeap.RemoveAt(_baseHeap.Count - 1);
			if (HeapifyFromEndToBeginning(num) == num)
			{
				HeapifyFromBeginningToEnd(num);
			}
			return true;
		}

		public IEnumerator<KeyValuePair<TPriority, TValue>> GetEnumerator()
		{
			return _baseHeap.GetEnumerator();
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}
	}
	public struct DVector2
	{
		private static double epsilon = 1E-05;

		public double x;

		public double y;

		public static DVector2 Subtract(DVector2 a, DVector2 b)
		{
			return new DVector2(a.x - b.x, a.y - b.y);
		}

		public DVector2(double xx, double yy)
		{
			x = xx;
			y = yy;
		}

		public DVector2(DVector2 r)
		{
			x = r.x;
			y = r.y;
		}

		public Vector2 GetVector2()
		{
			return new Vector2((float)x, (float)y);
		}

		public bool IsContainedIn(DRect r)
		{
			if (x >= r.x && y >= r.y && x <= r.x + r.width && y <= r.y + r.height)
			{
				return true;
			}
			return false;
		}

		public bool IsContainedInWithMargin(DRect r)
		{
			if (x >= r.x - epsilon && y >= r.y - epsilon && x <= r.x + r.width + epsilon && y <= r.y + r.height + epsilon)
			{
				return true;
			}
			return false;
		}

		public override string ToString()
		{
			return $"({x},{y})";
		}

		public string ToString(string formatS)
		{
			return $"({x.ToString(formatS)},{y.ToString(formatS)})";
		}

		public static double Distance(DVector2 a, DVector2 b)
		{
			double num = b.x - a.x;
			double num2 = b.y - a.y;
			return Math.Sqrt(num * num + num2 * num2);
		}
	}
	public struct DRect
	{
		public double x;

		public double y;

		public double width;

		public double height;

		public DVector2 minD => new DVector2(x, y);

		public DVector2 maxD => new DVector2(x + width, y + height);

		public Vector2 min => new Vector2((float)x, (float)y);

		public Vector2 max => new Vector2((float)(x + width), (float)(y + height));

		public Vector2 size => new Vector2((float)width, (float)height);

		public DVector2 center => new DVector2(x + width / 2.0, y + height / 2.0);

		public DRect(Rect r)
		{
			x = r.x;
			y = r.y;
			width = r.width;
			height = r.height;
		}

		public DRect(Vector2 o, Vector2 s)
		{
			x = o.x;
			y = o.y;
			width = s.x;
			height = s.y;
		}

		public DRect(DRect r)
		{
			x = r.x;
			y = r.y;
			width = r.width;
			height = r.height;
		}

		public DRect(float xx, float yy, float w, float h)
		{
			x = xx;
			y = yy;
			width = w;
			height = h;
		}

		public DRect(double xx, double yy, double w, double h)
		{
			x = xx;
			y = yy;
			width = w;
			height = h;
		}

		public Rect GetRect()
		{
			return new Rect((float)x, (float)y, (float)width, (float)height);
		}

		public override bool Equals(object obj)
		{
			DRect dRect = (DRect)obj;
			if (dRect.x == x && dRect.y == y && dRect.width == width && dRect.height == height)
			{
				return true;
			}
			return false;
		}

		public static bool operator ==(DRect a, DRect b)
		{
			return a.Equals(b);
		}

		public static bool operator !=(DRect a, DRect b)
		{
			return !a.Equals(b);
		}

		public override string ToString()
		{
			return string.Format("(x={0},y={1},w={2},h={3})", x.ToString("F5"), y.ToString("F5"), width.ToString("F5"), height.ToString("F5"));
		}

		public void Expand(float amt)
		{
			x -= amt;
			y -= amt;
			width += amt * 2f;
			height += amt * 2f;
		}

		public bool Encloses(DRect smallToTestIfFits)
		{
			double num = smallToTestIfFits.x;
			double num2 = smallToTestIfFits.y;
			double num3 = smallToTestIfFits.x + smallToTestIfFits.width;
			double num4 = smallToTestIfFits.y + smallToTestIfFits.height;
			double num5 = x;
			double num6 = y;
			double num7 = x + width;
			double num8 = y + height;
			if (num5 <= num && num <= num7 && num5 <= num3 && num3 <= num7 && num6 <= num2 && num2 <= num8 && num6 <= num4)
			{
				return num4 <= num8;
			}
			return false;
		}

		public override int GetHashCode()
		{
			return x.GetHashCode() ^ y.GetHashCode() ^ width.GetHashCode() ^ height.GetHashCode();
		}
	}
	public class MB3_UVTransformUtility
	{
		public static void Test()
		{
			DRect t = new DRect(0.5, 0.5, 2.0, 2.0);
			DRect t2 = new DRect(0.25, 0.25, 3.0, 3.0);
			DRect r = InverseTransform(ref t);
			DRect r2 = InverseTransform(ref t2);
			DRect r3 = CombineTransforms(ref t, ref r2);
			UnityEngine.Debug.Log(r);
			UnityEngine.Debug.Log(r3);
			UnityEngine.Debug.Log("one mat trans " + TransformPoint(ref t, new Vector2(1f, 1f)).ToString());
			UnityEngine.Debug.Log("one inv mat trans " + TransformPoint(ref r, new Vector2(1f, 1f)).ToString("f4"));
			UnityEngine.Debug.Log("zero " + TransformPoint(ref r3, new Vector2(0f, 0f)).ToString("f4"));
			UnityEngine.Debug.Log("one " + TransformPoint(ref r3, new Vector2(1f, 1f)).ToString("f4"));
		}

		public static float TransformX(DRect r, double x)
		{
			return (float)(r.width * x + r.x);
		}

		public static DRect CombineTransforms(ref DRect r1, ref DRect r2)
		{
			return new DRect(r1.x * r2.width + r2.x, r1.y * r2.height + r2.y, r1.width * r2.width, r1.height * r2.height);
		}

		public static Rect CombineTransforms(ref Rect r1, ref Rect r2)
		{
			return new Rect(r1.x * r2.width + r2.x, r1.y * r2.height + r2.y, r1.width * r2.width, r1.height * r2.height);
		}

		public static DRect InverseTransform(ref DRect t)
		{
			DRect result = default(DRect);
			result.x = (0.0 - t.x) / t.width;
			result.y = (0.0 - t.y) / t.height;
			result.width = 1.0 / t.width;
			result.height = 1.0 / t.height;
			return result;
		}

		public static DRect GetShiftTransformToFitBinA(ref DRect A, ref DRect B)
		{
			DVector2 center = A.center;
			DVector2 center2 = B.center;
			DVector2 dVector = DVector2.Subtract(center, center2);
			double xx = Convert.ToInt32(dVector.x);
			double yy = Convert.ToInt32(dVector.y);
			return new DRect(xx, yy, 1.0, 1.0);
		}

		public static DRect GetEncapsulatingRectShifted(ref DRect uvRect1, ref DRect willBeIn)
		{
			DVector2 center = uvRect1.center;
			DVector2 center2 = willBeIn.center;
			DVector2 dVector = DVector2.Subtract(center, center2);
			double num = Convert.ToInt32(dVector.x);
			double num2 = Convert.ToInt32(dVector.y);
			DRect dRect = new DRect(willBeIn);
			dRect.x += num;
			dRect.y += num2;
			double x = uvRect1.x;
			double y = uvRect1.y;
			double num3 = uvRect1.x + uvRect1.width;
			double num4 = uvRect1.y + uvRect1.height;
			double x2 = dRect.x;
			double y2 = dRect.y;
			double num5 = dRect.x + dRect.width;
			double num6 = dRect.y + dRect.height;
			double num7;
			double num8 = (num7 = x);
			double num9;
			double num10 = (num9 = y);
			if (x2 < num8)
			{
				num8 = x2;
			}
			if (x < num8)
			{
				num8 = x;
			}
			if (y2 < num10)
			{
				num10 = y2;
			}
			if (y < num10)
			{
				num10 = y;
			}
			if (num5 > num7)
			{
				num7 = num5;
			}
			if (num3 > num7)
			{
				num7 = num3;
			}
			if (num6 > num9)
			{
				num9 = num6;
			}
			if (num4 > num9)
			{
				num9 = num4;
			}
			return new DRect(num8, num10, num7 - num8, num9 - num10);
		}

		public static DRect GetEncapsulatingRect(ref DRect uvRect1, ref DRect uvRect2)
		{
			double x = uvRect1.x;
			double y = uvRect1.y;
			double num = uvRect1.x + uvRect1.width;
			double num2 = uvRect1.y + uvRect1.height;
			double x2 = uvRect2.x;
			double y2 = uvRect2.y;
			double num3 = uvRect2.x + uvRect2.width;
			double num4 = uvRect2.y + uvRect2.height;
			double num5;
			double num6 = (num5 = x);
			double num7;
			double num8 = (num7 = y);
			if (x2 < num6)
			{
				num6 = x2;
			}
			if (x < num6)
			{
				num6 = x;
			}
			if (y2 < num8)
			{
				num8 = y2;
			}
			if (y < num8)
			{
				num8 = y;
			}
			if (num3 > num5)
			{
				num5 = num3;
			}
			if (num > num5)
			{
				num5 = num;
			}
			if (num4 > num7)
			{
				num7 = num4;
			}
			if (num2 > num7)
			{
				num7 = num2;
			}
			return new DRect(num6, num8, num5 - num6, num7 - num8);
		}

		public static bool RectContainsShifted(ref DRect bucket, ref DRect tryFit)
		{
			DVector2 center = bucket.center;
			DVector2 center2 = tryFit.center;
			DVector2 dVector = DVector2.Subtract(center, center2);
			double num = Convert.ToInt32(dVector.x);
			double num2 = Convert.ToInt32(dVector.y);
			DRect smallToTestIfFits = new DRect(tryFit);
			smallToTestIfFits.x += num;
			smallToTestIfFits.y += num2;
			return bucket.Encloses(smallToTestIfFits);
		}

		public static bool RectContainsShifted(ref Rect bucket, ref Rect tryFit)
		{
			Vector2 center = bucket.center;
			Vector2 center2 = tryFit.center;
			Vector2 vector = center - center2;
			float num = Convert.ToInt32(vector.x);
			float num2 = Convert.ToInt32(vector.y);
			Rect smallToTestIfFits = new Rect(tryFit);
			smallToTestIfFits.x += num;
			smallToTestIfFits.y += num2;
			return RectContains(ref bucket, ref smallToTestIfFits);
		}

		public static bool LineSegmentContainsShifted(float bucketOffset, float bucketLength, float tryFitOffset, float tryFitLength)
		{
			float num = bucketOffset + bucketLength / 2f;
			float num2 = tryFitOffset + tryFitLength / 2f;
			float num3 = Convert.ToInt32(num - num2);
			tryFitOffset += num3;
			float num4 = tryFitLength + tryFitOffset;
			float num5 = bucketOffset - 0.01f;
			float num6 = bucketOffset + bucketLength + 0.01f;
			if (num5 <= tryFitLength && tryFitLength <= num6 && num5 <= num4)
			{
				return num4 <= num6;
			}
			return false;
		}

		public static bool RectContains(ref DRect bigRect, ref DRect smallToTestIfFits)
		{
			double x = smallToTestIfFits.x;
			double y = smallToTestIfFits.y;
			double num = smallToTestIfFits.x + smallToTestIfFits.width;
			double num2 = smallToTestIfFits.y + smallToTestIfFits.height;
			double num3 = bigRect.x - 0.009999999776482582;
			double num4 = bigRect.y - 0.009999999776482582;
			double num5 = bigRect.x + bigRect.width + 0.009999999776482582;
			double num6 = bigRect.y + bigRect.height + 0.009999999776482582;
			if (num3 <= x && x <= num5 && num3 <= num && num <= num5 && num4 <= y && y <= num6 && num4 <= num2)
			{
				return num2 <= num6;
			}
			return false;
		}

		public static bool RectContains(ref Rect bigRect, ref Rect smallToTestIfFits)
		{
			float x = smallToTestIfFits.x;
			float y = smallToTestIfFits.y;
			float num = smallToTestIfFits.x + smallToTestIfFits.width;
			float num2 = smallToTestIfFits.y + smallToTestIfFits.height;
			float num3 = bigRect.x - 0.01f;
			float num4 = bigRect.y - 0.01f;
			float num5 = bigRect.x + bigRect.width + 0.01f;
			float num6 = bigRect.y + bigRect.height + 0.01f;
			if (num3 <= x && x <= num5 && num3 <= num && num <= num5 && num4 <= y && y <= num6 && num4 <= num2)
			{
				return num2 <= num6;
			}
			return false;
		}

		public static Vector2 TransformPoint(ref DRect r, Vector2 p)
		{
			return new Vector2((float)(r.width * (double)p.x + r.x), (float)(r.height * (double)p.y + r.y));
		}

		public static DVector2 TransformPoint(ref DRect r, DVector2 p)
		{
			return new DVector2(r.width * p.x + r.x, r.height * p.y + r.y);
		}
	}
	public static class MB_TGAWriter
	{
		public static void Write(Color[] pixels, int width, int height, string path)
		{
			if (File.Exists(path))
			{
				File.Delete(path);
			}
			FileStream output = File.Create(path);
			Write(pixels, width, height, output);
		}

		public static void Write(Color[] pixels, int width, int height, Stream output)
		{
			byte[] array = new byte[pixels.Length * 4];
			int num = 0;
			int num2 = 0;
			for (int i = 0; i < height; i++)
			{
				for (int j = 0; j < width; j++)
				{
					Color color = pixels[num];
					array[num2] = (byte)(color.b * 255f);
					array[num2 + 1] = (byte)(color.g * 255f);
					array[num2 + 2] = (byte)(color.r * 255f);
					array[num2 + 3] = (byte)(color.a * 255f);
					num++;
					num2 += 4;
				}
			}
			byte[] buffer = new byte[18]
			{
				0,
				0,
				2,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				(byte)((uint)width & 0xFFu),
				(byte)((width & 0xFF00) >> 8),
				(byte)((uint)height & 0xFFu),
				(byte)((height & 0xFF00) >> 8),
				32,
				0
			};
			using BinaryWriter binaryWriter = new BinaryWriter(output);
			binaryWriter.Write(buffer);
			binaryWriter.Write(array);
		}
	}
	public class MB_Utility
	{
		public struct MeshAnalysisResult
		{
			public Rect uvRect;

			public bool hasOutOfBoundsUVs;

			public bool hasOverlappingSubmeshVerts;

			public bool hasOverlappingSubmeshTris;

			public bool hasUVs;

			public float submeshArea;
		}

		private class MB_Triangle
		{
			private int submeshIdx;

			private int[] vs = new int[3];

			public bool isSame(object obj)
			{
				MB_Triangle mB_Triangle = (MB_Triangle)obj;
				if (vs[0] == mB_Triangle.vs[0] && vs[1] == mB_Triangle.vs[1] && vs[2] == mB_Triangle.vs[2] && submeshIdx != mB_Triangle.submeshIdx)
				{
					return true;
				}
				return false;
			}

			public bool sharesVerts(MB_Triangle obj)
			{
				if ((vs[0] == obj.vs[0] || vs[0] == obj.vs[1] || vs[0] == obj.vs[2]) && submeshIdx != obj.submeshIdx)
				{
					return true;
				}
				if ((vs[1] == obj.vs[0] || vs[1] == obj.vs[1] || vs[1] == obj.vs[2]) && submeshIdx != obj.submeshIdx)
				{
					return true;
				}
				if ((vs[2] == obj.vs[0] || vs[2] == obj.vs[1] || vs[2] == obj.vs[2]) && submeshIdx != obj.submeshIdx)
				{
					return true;
				}
				return false;
			}

			public void Initialize(int[] ts, int idx, int sIdx)
			{
				vs[0] = ts[idx];
				vs[1] = ts[idx + 1];
				vs[2] = ts[idx + 2];
				submeshIdx = sIdx;
				Array.Sort(vs);
			}
		}

		public static bool DO_INTEGRITY_CHECKS;

		public static Texture2D createTextureCopy(Texture2D source)
		{
			Texture2D texture2D = new Texture2D(source.width, source.height, TextureFormat.ARGB32, mipChain: true);
			texture2D.SetPixels(source.GetPixels());
			return texture2D;
		}

		public static bool ArrayBIsSubsetOfA(object[] a, object[] b)
		{
			for (int i = 0; i < b.Length; i++)
			{
				bool flag = false;
				for (int j = 0; j < a.Length; j++)
				{
					if (a[j] == b[i])
					{
						flag = true;
						break;
					}
				}
				if (!flag)
				{
					return false;
				}
			}
			return true;
		}

		public static Material[] GetGOMaterials(GameObject go)
		{
			if (go == null)
			{
				return null;
			}
			Material[] array = null;
			Mesh mesh = null;
			MeshRenderer component = go.GetComponent<MeshRenderer>();
			if (component != null)
			{
				array = component.sharedMaterials;
				MeshFilter component2 = go.GetComponent<MeshFilter>();
				if (component2 == null)
				{
					throw new Exception("Object " + go?.ToString() + " has a MeshRenderer but no MeshFilter.");
				}
				mesh = component2.sharedMesh;
			}
			SkinnedMeshRenderer component3 = go.GetComponent<SkinnedMeshRenderer>();
			if (component3 != null)
			{
				array = component3.sharedMaterials;
				mesh = component3.sharedMesh;
			}
			if (array == null)
			{
				UnityEngine.Debug.LogError("Object " + go.name + " does not have a MeshRenderer or a SkinnedMeshRenderer component");
				return new Material[0];
			}
			if (mesh == null)
			{
				UnityEngine.Debug.LogError("Object " + go.name + " has a MeshRenderer or SkinnedMeshRenderer but no mesh.");
				return new Material[0];
			}
			if (mesh.subMeshCount < array.Length)
			{
				UnityEngine.Debug.LogWarning("Object " + go?.ToString() + " has only " + mesh.subMeshCount + " submeshes and has " + array.Length + " materials. Extra materials do nothing.");
				Material[] array2 = new Material[mesh.subMeshCount];
				Array.Copy(array, array2, array2.Length);
				array = array2;
			}
			return array;
		}

		public static Mesh GetMesh(GameObject go)
		{
			if (go == null)
			{
				return null;
			}
			MeshFilter component = go.GetComponent<MeshFilter>();
			if (component != null)
			{
				return component.sharedMesh;
			}
			SkinnedMeshRenderer component2 = go.GetComponent<SkinnedMeshRenderer>();
			if (component2 != null)
			{
				return component2.sharedMesh;
			}
			return null;
		}

		public static void SetMesh(GameObject go, Mesh m)
		{
			if (go == null)
			{
				return;
			}
			MeshFilter component = go.GetComponent<MeshFilter>();
			if (component != null)
			{
				component.sharedMesh = m;
				return;
			}
			SkinnedMeshRenderer component2 = go.GetComponent<SkinnedMeshRenderer>();
			if (component2 != null)
			{
				component2.sharedMesh = m;
			}
		}

		public static Renderer GetRenderer(GameObject go)
		{
			if (go == null)
			{
				return null;
			}
			MeshRenderer component = go.GetComponent<MeshRenderer>();
			if (component != null)
			{
				return component;
			}
			SkinnedMeshRenderer component2 = go.GetComponent<SkinnedMeshRenderer>();
			if (component2 != null)
			{
				return component2;
			}
			return null;
		}

		public static void DisableRendererInSource(GameObject go)
		{
			if (go == null)
			{
				return;
			}
			MeshRenderer component = go.GetComponent<MeshRenderer>();
			if (component != null)
			{
				component.enabled = false;
				return;
			}
			SkinnedMeshRenderer component2 = go.GetComponent<SkinnedMeshRenderer>();
			if (component2 != null)
			{
				component2.enabled = false;
			}
		}

		public static bool hasOutOfBoundsUVs(Mesh m, ref Rect uvBounds)
		{
			MeshAnalysisResult putResultHere = default(MeshAnalysisResult);
			bool result = hasOutOfBoundsUVs(m, ref putResultHere);
			uvBounds = putResultHere.uvRect;
			return result;
		}

		public static bool hasOutOfBoundsUVs(Mesh m, ref MeshAnalysisResult putResultHere, int submeshIndex = -1, int uvChannel = 0)
		{
			if (m == null)
			{
				putResultHere.hasOutOfBoundsUVs = false;
				return putResultHere.hasOutOfBoundsUVs;
			}
			return hasOutOfBoundsUVs(uvChannel switch
			{
				0 => m.uv, 
				1 => m.uv2, 
				2 => m.uv3, 
				_ => m.uv4, 
			}, m, ref putResultHere, submeshIndex);
		}

		public static bool hasOutOfBoundsUVs(Vector2[] uvs, Mesh m, ref MeshAnalysisResult putResultHere, int submeshIndex = -1)
		{
			putResultHere.hasUVs = true;
			if (uvs.Length == 0)
			{
				putResultHere.hasUVs = false;
				putResultHere.hasOutOfBoundsUVs = false;
				putResultHere.uvRect = default(Rect);
				return putResultHere.hasOutOfBoundsUVs;
			}
			if (submeshIndex >= m.subMeshCount)
			{
				putResultHere.hasOutOfBoundsUVs = false;
				putResultHere.uvRect = default(Rect);
				return putResultHere.hasOutOfBoundsUVs;
			}
			float num;
			float x;
			float num2;
			float y;
			if (submeshIndex >= 0)
			{
				int[] triangles = m.GetTriangles(submeshIndex);
				if (triangles.Length == 0)
				{
					putResultHere.hasOutOfBoundsUVs = false;
					putResultHere.uvRect = default(Rect);
					return putResultHere.hasOutOfBoundsUVs;
				}
				num = (x = uvs[triangles[0]].x);
				num2 = (y = uvs[triangles[0]].y);
				foreach (int num3 in triangles)
				{
					if (uvs[num3].x < num)
					{
						num = uvs[num3].x;
					}
					if (uvs[num3].x > x)
					{
						x = uvs[num3].x;
					}
					if (uvs[num3].y < num2)
					{
						num2 = uvs[num3].y;
					}
					if (uvs[num3].y > y)
					{
						y = uvs[num3].y;
					}
				}
			}
			else
			{
				num = (x = uvs[0].x);
				num2 = (y = uvs[0].y);
				for (int j = 0; j < uvs.Length; j++)
				{
					if (uvs[j].x < num)
					{
						num = uvs[j].x;
					}
					if (uvs[j].x > x)
					{
						x = uvs[j].x;
					}
					if (uvs[j].y < num2)
					{
						num2 = uvs[j].y;
					}
					if (uvs[j].y > y)
					{
						y = uvs[j].y;
					}
				}
			}
			Rect uvRect = default(Rect);
			uvRect.x = num;
			uvRect.y = num2;
			uvRect.width = x - num;
			uvRect.height = y - num2;
			if (x > 1f || num < 0f || y > 1f || num2 < 0f)
			{
				putResultHere.hasOutOfBoundsUVs = true;
			}
			else
			{
				putResultHere.hasOutOfBoundsUVs = false;
			}
			putResultHere.uvRect = uvRect;
			return putResultHere.hasOutOfBoundsUVs;
		}

		public static void setSolidColor(Texture2D t, Color c)
		{
			Color[] pixels = t.GetPixels();
			for (int i = 0; i < pixels.Length; i++)
			{
				pixels[i] = c;
			}
			t.SetPixels(pixels);
			t.Apply();
		}

		public static Texture2D resampleTexture(Texture2D source, int newWidth, int newHeight)
		{
			TextureFormat format = source.format;
			if (format == TextureFormat.ARGB32 || format == TextureFormat.RGBA32 || format == TextureFormat.BGRA32 || format == TextureFormat.RGB24 || format == TextureFormat.Alpha8 || format == TextureFormat.DXT1)
			{
				Texture2D texture2D = new Texture2D(newWidth, newHeight, TextureFormat.ARGB32, mipChain: true);
				float num = newWidth;
				float num2 = newHeight;
				for (int i = 0; i < newWidth; i++)
				{
					for (int j = 0; j < newHeight; j++)
					{
						float u = (float)i / num;
						float v = (float)j / num2;
						texture2D.SetPixel(i, j, source.GetPixelBilinear(u, v));
					}
				}
				texture2D.Apply();
				return texture2D;
			}
			UnityEngine.Debug.LogError("Can only resize textures in formats ARGB32, RGBA32, BGRA32, RGB24, Alpha8 or DXT");
			return null;
		}

		public static bool AreAllSharedMaterialsDistinct(Material[] sharedMaterials)
		{
			for (int i = 0; i < sharedMaterials.Length; i++)
			{
				for (int j = i + 1; j < sharedMaterials.Length; j++)
				{
					if (sharedMaterials[i] == sharedMaterials[j])
					{
						return false;
					}
				}
			}
			return true;
		}

		public static int doSubmeshesShareVertsOrTris(Mesh m, ref MeshAnalysisResult mar)
		{
			MB_Triangle mB_Triangle = new MB_Triangle();
			MB_Triangle mB_Triangle2 = new MB_Triangle();
			int[][] array = new int[m.subMeshCount][];
			for (int i = 0; i < m.subMeshCount; i++)
			{
				array[i] = m.GetTriangles(i);
			}
			bool flag = false;
			bool flag2 = false;
			for (int j = 0; j < m.subMeshCount; j++)
			{
				int[] array2 = array[j];
				for (int k = j + 1; k < m.subMeshCount; k++)
				{
					int[] array3 = array[k];
					for (int l = 0; l < array2.Length; l += 3)
					{
						mB_Triangle.Initialize(array2, l, j);
						for (int n = 0; n < array3.Length; n += 3)
						{
							mB_Triangle2.Initialize(array3, n, k);
							if (mB_Triangle.isSame(mB_Triangle2))
							{
								flag2 = true;
								break;
							}
							if (mB_Triangle.sharesVerts(mB_Triangle2))
							{
								flag = true;
								break;
							}
						}
					}
				}
			}
			if (flag2)
			{
				mar.hasOverlappingSubmeshVerts = true;
				mar.hasOverlappingSubmeshTris = true;
				return 2;
			}
			if (flag)
			{
				mar.hasOverlappingSubmeshVerts = true;
				mar.hasOverlappingSubmeshTris = false;
				return 1;
			}
			mar.hasOverlappingSubmeshTris = false;
			mar.hasOverlappingSubmeshVerts = false;
			return 0;
		}

		public static bool GetBounds(GameObject go, out Bounds b)
		{
			if (go == null)
			{
				UnityEngine.Debug.LogError("go paramater was null");
				b = new Bounds(Vector3.zero, Vector3.zero);
				return false;
			}
			Renderer renderer = GetRenderer(go);
			if (renderer == null)
			{
				UnityEngine.Debug.LogError("GetBounds must be called on an object with a Renderer");
				b = new Bounds(Vector3.zero, Vector3.zero);
				return false;
			}
			if (renderer is MeshRenderer)
			{
				b = renderer.bounds;
				return true;
			}
			if (renderer is SkinnedMeshRenderer)
			{
				b = renderer.bounds;
				return true;
			}
			UnityEngine.Debug.LogError("GetBounds must be called on an object with a MeshRender or a SkinnedMeshRenderer.");
			b = new Bounds(Vector3.zero, Vector3.zero);
			return false;
		}

		public static void Destroy(UnityEngine.Object o)
		{
			if (UnityEngine.Application.isPlaying)
			{
				UnityEngine.Object.Destroy(o);
			}
			else
			{
				UnityEngine.Object.DestroyImmediate(o, allowDestroyingAssets: false);
			}
		}
	}
	[Serializable]
	public struct AtlasPadding
	{
		public int topBottom;

		public int leftRight;

		public AtlasPadding(int p)
		{
			topBottom = p;
			leftRight = p;
		}

		public AtlasPadding(int px, int py)
		{
			topBottom = py;
			leftRight = px;
		}
	}
	[Serializable]
	public class AtlasPackingResult
	{
		public int atlasX;

		public int atlasY;

		public int usedW;

		public int usedH;

		public Rect[] rects;

		public AtlasPadding[] padding;

		public int[] srcImgIdxs;

		public object data;

		public AtlasPackingResult(AtlasPadding[] pds)
		{
			padding = pds;
		}

		public void CalcUsedWidthAndHeight()
		{
			float num = 0f;
			float num2 = 0f;
			float num3 = 0f;
			float num4 = 0f;
			for (int i = 0; i < rects.Length; i++)
			{
				num3 += (float)padding[i].leftRight * 2f;
				num4 += (float)padding[i].topBottom * 2f;
				num = Mathf.Max(num, rects[i].x + rects[i].width);
				num2 = Mathf.Max(num2, rects[i].y + rects[i].height);
			}
			usedW = Mathf.CeilToInt(num * (float)atlasX + num3);
			usedH = Mathf.CeilToInt(num2 * (float)atlasY + num4);
			if (usedW > atlasX)
			{
				usedW = atlasX;
			}
			if (usedH > atlasY)
			{
				usedH = atlasY;
			}
		}

		public override string ToString()
		{
			return $"numRects: {rects.Length}, atlasX: {atlasX} atlasY: {atlasY} usedW: {usedW} usedH: {usedH}";
		}
	}
	public abstract class MB2_TexturePacker
	{
		internal enum NodeType
		{
			Container,
			maxDim,
			regular
		}

		internal class PixRect
		{
			public int x;

			public int y;

			public int w;

			public int h;

			public PixRect()
			{
			}

			public PixRect(int xx, int yy, int ww, int hh)
			{
				x = xx;
				y = yy;
				w = ww;
				h = hh;
			}

			public override string ToString()
			{
				return $"x={x},y={y},w={w},h={h}";
			}
		}

		internal class Image
		{
			public int imgId;

			public int w;

			public int h;

			public int x;

			public int y;

			public Image(int id, int tw, int th, AtlasPadding padding, int minImageSizeX, int minImageSizeY)
			{
				imgId = id;
				w = Mathf.Max(tw + padding.leftRight * 2, minImageSizeX);
				h = Mathf.Max(th + padding.topBottom * 2, minImageSizeY);
			}

			public Image(Image im)
			{
				imgId = im.imgId;
				w = im.w;
				h = im.h;
				x = im.x;
				y = im.y;
			}
		}

		internal class ImgIDComparer : IComparer<Image>
		{
			public int Compare(Image x, Image y)
			{
				if (x.imgId > y.imgId)
				{
					return 1;
				}
				if (x.imgId == y.imgId)
				{
					return 0;
				}
				return -1;
			}
		}

		internal class ImageHeightComparer : IComparer<Image>
		{
			public int Compare(Image x, Image y)
			{
				if (x.h > y.h)
				{
					return -1;
				}
				if (x.h == y.h)
				{
					return 0;
				}
				return 1;
			}
		}

		internal class ImageWidthComparer : IComparer<Image>
		{
			public int Compare(Image x, Image y)
			{
				if (x.w > y.w)
				{
					return -1;
				}
				if (x.w == y.w)
				{
					return 0;
				}
				return 1;
			}
		}

		internal class ImageAreaComparer : IComparer<Image>
		{
			public int Compare(Image x, Image y)
			{
				int num = x.w * x.h;
				int num2 = y.w * y.h;
				if (num > num2)
				{
					return -1;
				}
				if (num == num2)
				{
					return 0;
				}
				return 1;
			}
		}

		public MB2_LogLevel LOG_LEVEL = MB2_LogLevel.info;

		public bool atlasMustBePowerOfTwo = true;

		public static int RoundToNearestPositivePowerOfTwo(int x)
		{
			int num = (int)Mathf.Pow(2f, Mathf.RoundToInt(Mathf.Log(x) / Mathf.Log(2f)));
			if (num == 0 || num == 1)
			{
				num = 2;
			}
			return num;
		}

		public static int CeilToNearestPowerOfTwo(int x)
		{
			int num = (int)Mathf.Pow(2f, Mathf.Ceil(Mathf.Log(x) / Mathf.Log(2f)));
			if (num == 0 || num == 1)
			{
				num = 2;
			}
			return num;
		}

		public abstract AtlasPackingResult[] GetRects(List<Vector2> imgWidthHeights, int maxDimensionX, int maxDimensionY, int padding);

		public abstract AtlasPackingResult[] GetRects(List<Vector2> imgWidthHeights, List<AtlasPadding> paddings, int maxDimensionX, int maxDimensionY, bool doMultiAtlas);

		internal bool ScaleAtlasToFitMaxDim(Vector2 rootWH, List<Image> images, int maxDimensionX, int maxDimensionY, AtlasPadding padding, int minImageSizeX, int minImageSizeY, int masterImageSizeX, int masterImageSizeY, ref int outW, ref int outH, out float padX, out float padY, out int newMinSizeX, out int newMinSizeY)
		{
			newMinSizeX = minImageSizeX;
			newMinSizeY = minImageSizeY;
			bool result = false;
			padX = (float)padding.leftRight / (float)outW;
			if (rootWH.x > (float)maxDimensionX)
			{
				padX = (float)padding.leftRight / (float)maxDimensionX;
				float num = (float)maxDimensionX / rootWH.x;
				if (LOG_LEVEL >= MB2_LogLevel.warn)
				{
					UnityEngine.Debug.LogWarning("Packing exceeded atlas width shrinking to " + num);
				}
				for (int i = 0; i < images.Count; i++)
				{
					Image image = images[i];
					if ((float)image.w * num < (float)masterImageSizeX)
					{
						if (LOG_LEVEL >= MB2_LogLevel.debug)
						{
							UnityEngine.Debug.Log("Small images are being scaled to zero. Will need to redo packing with larger minTexSizeX.");
						}
						result = true;
						newMinSizeX = Mathf.CeilToInt((float)minImageSizeX / num);
					}
					int num2 = (int)((float)(image.x + image.w) * num);
					image.x = (int)(num * (float)image.x);
					image.w = num2 - image.x;
				}
				outW = maxDimensionX;
			}
			padY = (float)padding.topBottom / (float)outH;
			if (rootWH.y > (float)maxDimensionY)
			{
				padY = (float)padding.topBottom / (float)maxDimensionY;
				float num3 = (float)maxDimensionY / rootWH.y;
				if (LOG_LEVEL >= MB2_LogLevel.warn)
				{
					UnityEngine.Debug.LogWarning("Packing exceeded atlas height shrinking to " + num3);
				}
				for (int j = 0; j < images.Count; j++)
				{
					Image image2 = images[j];
					if ((float)image2.h * num3 < (float)masterImageSizeY)
					{
						if (LOG_LEVEL >= MB2_LogLevel.debug)
						{
							UnityEngine.Debug.Log("Small images are being scaled to zero. Will need to redo packing with larger minTexSizeY.");
						}
						result = true;
						newMinSizeY = Mathf.CeilToInt((float)minImageSizeY / num3);
					}
					int num4 = (int)((float)(image2.y + image2.h) * num3);
					image2.y = (int)(num3 * (float)image2.y);
					image2.h = num4 - image2.y;
				}
				outH = maxDimensionY;
			}
			return result;
		}

		public void normalizeRects(AtlasPackingResult rr, AtlasPadding padding)
		{
			for (int i = 0; i < rr.rects.Length; i++)
			{
				rr.rects[i].x = (rr.rects[i].x + (float)padding.leftRight) / (float)rr.atlasX;
				rr.rects[i].y = (rr.rects[i].y + (float)padding.topBottom) / (float)rr.atlasY;
				rr.rects[i].width = (rr.rects[i].width - (float)(padding.leftRight * 2)) / (float)rr.atlasX;
				rr.rects[i].height = (rr.rects[i].height - (float)(padding.topBottom * 2)) / (float)rr.atlasY;
			}
		}
	}
	public class MB2_TexturePackerRegular : MB2_TexturePacker
	{
		private class ProbeResult
		{
			public int w;

			public int h;

			public int outW;

			public int outH;

			public Node root;

			public bool largerOrEqualToMaxDim;

			public float efficiency;

			public float squareness;

			public float totalAtlasArea;

			public int numAtlases;

			public void Set(int ww, int hh, int outw, int outh, Node r, bool fits, float e, float sq)
			{
				w = ww;
				h = hh;
				outW = outw;
				outH = outh;
				root = r;
				largerOrEqualToMaxDim = fits;
				efficiency = e;
				squareness = sq;
			}

			public float GetScore(bool doPowerOfTwoScore)
			{
				float num = (largerOrEqualToMaxDim ? 1f : 0f);
				if (doPowerOfTwoScore)
				{
					return num * 2f + efficiency;
				}
				return squareness + 2f * efficiency + num;
			}

			public void PrintTree()
			{
				printTree(root, "  ");
			}
		}

		internal class Node
		{
			internal NodeType isFullAtlas;

			internal Node[] child = new Node[2];

			internal PixRect r;

			internal Image img;

			private ProbeResult bestRoot;

			internal Node(NodeType rootType)
			{
				isFullAtlas = rootType;
			}

			private bool isLeaf()
			{
				if (child[0] == null || child[1] == null)
				{
					return true;
				}
				return false;
			}

			internal Node Insert(Image im, bool handed)
			{
				int num;
				int num2;
				if (handed)
				{
					num = 0;
					num2 = 1;
				}
				else
				{
					num = 1;
					num2 = 0;
				}
				if (!isLeaf())
				{
					Node node = child[num].Insert(im, handed);
					if (node != null)
					{
						return node;
					}
					return child[num2].Insert(im, handed);
				}
				if (img != null)
				{
					return null;
				}
				if (r.w < im.w || r.h < im.h)
				{
					return null;
				}
				if (r.w == im.w && r.h == im.h)
				{
					img = im;
					return this;
				}
				child[num] = new Node(NodeType.regular);
				child[num2] = new Node(NodeType.regular);
				int num3 = r.w - im.w;
				int num4 = r.h - im.h;
				if (num3 > num4)
				{
					child[num].r = new PixRect(r.x, r.y, im.w, r.h);
					child[num2].r = new PixRect(r.x + im.w, r.y, r.w - im.w, r.h);
				}
				else
				{
					child[num].r = new PixRect(r.x, r.y, r.w, im.h);
					child[num2].r = new PixRect(r.x, r.y + im.h, r.w, r.h - im.h);
				}
				return child[num].Insert(im, handed);
			}
		}

		private ProbeResult bestRoot;

		public int atlasY;

		private static void printTree(Node r, string spc)
		{
			UnityEngine.Debug.Log(spc + "Nd img=" + (r.img != null) + " r=" + r.r);
			if (r.child[0] != null)
			{
				printTree(r.child[0], spc + "      ");
			}
			if (r.child[1] != null)
			{
				printTree(r.child[1], spc + "      ");
			}
		}

		private static void flattenTree(Node r, List<Image> putHere)
		{
			if (r.img != null)
			{
				r.img.x = r.r.x;
				r.img.y = r.r.y;
				putHere.Add(r.img);
			}
			if (r.child[0] != null)
			{
				flattenTree(r.child[0], putHere);
			}
			if (r.child[1] != null)
			{
				flattenTree(r.child[1], putHere);
			}
		}

		private static void drawGizmosNode(Node r)
		{
			Vector3 size = new Vector3(r.r.w, r.r.h, 0f);
			Vector3 center = new Vector3((float)r.r.x + size.x / 2f, (float)(-r.r.y) - size.y / 2f, 0f);
			Gizmos.color = Color.yellow;
			Gizmos.DrawWireCube(center, size);
			if (r.img != null)
			{
				Gizmos.color = new Color(UnityEngine.Random.value, UnityEngine.Random.value, UnityEngine.Random.value);
				size = new Vector3(r.img.w, r.img.h, 0f);
				Gizmos.DrawCube(new Vector3((float)r.r.x + size.x / 2f, (float)(-r.r.y) - size.y / 2f, 0f), size);
			}
			if (r.child[0] != null)
			{
				Gizmos.color = Color.red;
				drawGizmosNode(r.child[0]);
			}
			if (r.child[1] != null)
			{
				Gizmos.color = Color.green;
				drawGizmosNode(r.child[1]);
			}
		}

		private static Texture2D createFilledTex(Color c, int w, int h)
		{
			Texture2D texture2D = new Texture2D(w, h);
			for (int i = 0; i < w; i++)
			{
				for (int j = 0; j < h; j++)
				{
					texture2D.SetPixel(i, j, c);
				}
			}
			texture2D.Apply();
			return texture2D;
		}

		public void DrawGizmos()
		{
			if (bestRoot != null)
			{
				drawGizmosNode(bestRoot.root);
				Gizmos.color = Color.yellow;
				Vector3 size = new Vector3(bestRoot.outW, -bestRoot.outH, 0f);
				Gizmos.DrawWireCube(new Vector3(size.x / 2f, size.y / 2f, 0f), size);
			}
		}

		private bool ProbeSingleAtlas(Image[] imgsToAdd, int idealAtlasW, int idealAtlasH, float imgArea, int maxAtlasDimX, int maxAtlasDimY, ProbeResult pr)
		{
			Node node = new Node(NodeType.maxDim);
			node.r = new PixRect(0, 0, idealAtlasW, idealAtlasH);
			for (int i = 0; i < imgsToAdd.Length; i++)
			{
				if (node.Insert(imgsToAdd[i], handed: false) == null)
				{
					return false;
				}
				if (i != imgsToAdd.Length - 1)
				{
					continue;
				}
				int x = 0;
				int y = 0;
				GetExtent(node, ref x, ref y);
				int num = x;
				int num2 = y;
				bool fits;
				float e;
				float sq;
				if (atlasMustBePowerOfTwo)
				{
					num = Mathf.Min(MB2_TexturePacker.CeilToNearestPowerOfTwo(x), maxAtlasDimX);
					num2 = Mathf.Min(MB2_TexturePacker.CeilToNearestPowerOfTwo(y), maxAtlasDimY);
					if (num2 < num / 2)
					{
						num2 = num / 2;
					}
					if (num < num2 / 2)
					{
						num = num2 / 2;
					}
					fits = x <= maxAtlasDimX && y <= maxAtlasDimY;
					float num3 = Mathf.Max(1f, (float)x / (float)maxAtlasDimX);
					float num4 = Mathf.Max(1f, (float)y / (float)maxAtlasDimY);
					float num5 = (float)num * num3 * (float)num2 * num4;
					e = 1f - (num5 - imgArea) / num5;
					sq = 1f;
				}
				else
				{
					e = 1f - ((float)(x * y) - imgArea) / (float)(x * y);
					sq = ((x >= y) ? ((float)y / (float)x) : ((float)x / (float)y));
					fits = x <= maxAtlasDimX && y <= maxAtlasDimY;
				}
				pr.Set(x, y, num, num2, node, fits, e, sq);
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					MB2_Log.LogDebug("Probe success efficiency w=" + x + " h=" + y + " e=" + e + " sq=" + sq + " fits=" + fits);
				}
				return true;
			}
			UnityEngine.Debug.LogError("Should never get here.");
			return false;
		}

		private bool ProbeMultiAtlas(Image[] imgsToAdd, int idealAtlasW, int idealAtlasH, float imgArea, int maxAtlasDimX, int maxAtlasDimY, ProbeResult pr)
		{
			int num = 0;
			Node node = new Node(NodeType.maxDim);
			node.r = new PixRect(0, 0, idealAtlasW, idealAtlasH);
			for (int i = 0; i < imgsToAdd.Length; i++)
			{
				if (node.Insert(imgsToAdd[i], handed: false) == null)
				{
					if (imgsToAdd[i].x > idealAtlasW && imgsToAdd[i].y > idealAtlasH)
					{
						return false;
					}
					Node obj = new Node(NodeType.Container)
					{
						r = new PixRect(0, 0, node.r.w + idealAtlasW, idealAtlasH)
					};
					Node node2 = new Node(NodeType.maxDim)
					{
						r = new PixRect(node.r.w, 0, idealAtlasW, idealAtlasH)
					};
					obj.child[1] = node2;
					obj.child[0] = node;
					node = obj;
					node.Insert(imgsToAdd[i], handed: false);
					num++;
				}
			}
			pr.numAtlases = num;
			pr.root = node;
			pr.totalAtlasArea = num * maxAtlasDimX * maxAtlasDimY;
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				MB2_Log.LogDebug("Probe success efficiency numAtlases=" + num + " totalArea=" + pr.totalAtlasArea);
			}
			return true;
		}

		internal void GetExtent(Node r, ref int x, ref int y)
		{
			if (r.img != null)
			{
				if (r.r.x + r.img.w > x)
				{
					x = r.r.x + r.img.w;
				}
				if (r.r.y + r.img.h > y)
				{
					y = r.r.y + r.img.h;
				}
			}
			if (r.child[0] != null)
			{
				GetExtent(r.child[0], ref x, ref y);
			}
			if (r.child[1] != null)
			{
				GetExtent(r.child[1], ref x, ref y);
			}
		}

		private int StepWidthHeight(int oldVal, int step, int maxDim)
		{
			if (atlasMustBePowerOfTwo && oldVal < maxDim)
			{
				return oldVal * 2;
			}
			int num = oldVal + step;
			if (num > maxDim && oldVal < maxDim)
			{
				num = maxDim;
			}
			return num;
		}

		public override AtlasPackingResult[] GetRects(List<Vector2> imgWidthHeights, int maxDimensionX, int maxDimensionY, int atPadding)
		{
			List<AtlasPadding> list = new List<AtlasPadding>();
			for (int i = 0; i < imgWidthHeights.Count; i++)
			{
				AtlasPadding item = default(AtlasPadding);
				item.leftRight = (item.topBottom = atPadding);
				list.Add(item);
			}
			return GetRects(imgWidthHeights, list, maxDimensionX, maxDimensionY, doMultiAtlas: false);
		}

		public override AtlasPackingResult[] GetRects(List<Vector2> imgWidthHeights, List<AtlasPadding> paddings, int maxDimensionX, int maxDimensionY, bool doMultiAtlas)
		{
			int num = 0;
			int num2 = 0;
			for (int i = 0; i < paddings.Count; i++)
			{
				num = Mathf.Max(num, paddings[i].leftRight);
				num2 = Mathf.Max(num2, paddings[i].topBottom);
			}
			if (doMultiAtlas)
			{
				return _GetRectsMultiAtlas(imgWidthHeights, paddings, maxDimensionX, maxDimensionY, 2 + num * 2, 2 + num2 * 2, 2 + num * 2, 2 + num2 * 2);
			}
			AtlasPackingResult atlasPackingResult = _GetRectsSingleAtlas(imgWidthHeights, paddings, maxDimensionX, maxDimensionY, 2 + num * 2, 2 + num2 * 2, 2 + num * 2, 2 + num2 * 2, 0);
			if (atlasPackingResult == null)
			{
				return null;
			}
			return new AtlasPackingResult[1] { atlasPackingResult };
		}

		private AtlasPackingResult _GetRectsSingleAtlas(List<Vector2> imgWidthHeights, List<AtlasPadding> paddings, int maxDimensionX, int maxDimensionY, int minImageSizeX, int minImageSizeY, int masterImageSizeX, int masterImageSizeY, int recursionDepth)
		{
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log($"_GetRects numImages={imgWidthHeights.Count}, maxDimension={maxDimensionX}, minImageSizeX={minImageSizeX}, minImageSizeY={minImageSizeY}, masterImageSizeX={masterImageSizeX}, masterImageSizeY={masterImageSizeY}, recursionDepth={recursionDepth}");
			}
			if (recursionDepth > 10)
			{
				if (LOG_LEVEL >= MB2_LogLevel.error)
				{
					UnityEngine.Debug.LogError("Maximum recursion depth reached. Couldn't find packing for these textures.");
				}
				return null;
			}
			float num = 0f;
			int num2 = 0;
			int num3 = 0;
			Image[] array = new Image[imgWidthHeights.Count];
			for (int i = 0; i < array.Length; i++)
			{
				int tw = (int)imgWidthHeights[i].x;
				int th = (int)imgWidthHeights[i].y;
				Image image = (array[i] = new Image(i, tw, th, paddings[i], minImageSizeX, minImageSizeY));
				num += (float)(image.w * image.h);
				num2 = Mathf.Max(num2, image.w);
				num3 = Mathf.Max(num3, image.h);
			}
			if ((float)num3 / (float)num2 > 2f)
			{
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					MB2_Log.LogDebug("Using height Comparer");
				}
				Array.Sort(array, new ImageHeightComparer());
			}
			else if ((double)((float)num3 / (float)num2) < 0.5)
			{
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					MB2_Log.LogDebug("Using width Comparer");
				}
				Array.Sort(array, new ImageWidthComparer());
			}
			else
			{
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					MB2_Log.LogDebug("Using area Comparer");
				}
				Array.Sort(array, new ImageAreaComparer());
			}
			int num4 = (int)Mathf.Sqrt(num);
			int num6;
			int num5;
			if (atlasMustBePowerOfTwo)
			{
				num6 = (num5 = MB2_TexturePacker.RoundToNearestPositivePowerOfTwo(num4));
				if (num2 > num6)
				{
					num6 = MB2_TexturePacker.CeilToNearestPowerOfTwo(num6);
				}
				if (num3 > num5)
				{
					num5 = MB2_TexturePacker.CeilToNearestPowerOfTwo(num5);
				}
			}
			else
			{
				num6 = num4;
				num5 = num4;
				if (num2 > num4)
				{
					num6 = num2;
					num5 = Mathf.Max(Mathf.CeilToInt(num / (float)num2), num3);
				}
				if (num3 > num4)
				{
					num6 = Mathf.Max(Mathf.CeilToInt(num / (float)num3), num2);
					num5 = num3;
				}
			}
			if (num6 == 0)
			{
				num6 = 4;
			}
			if (num5 == 0)
			{
				num5 = 4;
			}
			int num7 = (int)((float)num6 * 0.15f);
			int num8 = (int)((float)num5 * 0.15f);
			if (num7 == 0)
			{
				num7 = 1;
			}
			if (num8 == 0)
			{
				num8 = 1;
			}
			int num9 = 2;
			int num10 = num6;
			int num11 = num5;
			while (num9 >= 1 && num11 < num4 * 1000)
			{
				bool flag = false;
				num9 = 0;
				num10 = num6;
				while (!flag && num10 < num4 * 1000)
				{
					ProbeResult probeResult = new ProbeResult();
					if (LOG_LEVEL >= MB2_LogLevel.trace)
					{
						UnityEngine.Debug.Log("Probing h=" + num11 + " w=" + num10);
					}
					if (ProbeSingleAtlas(array, num10, num11, num, maxDimensionX, maxDimensionY, probeResult))
					{
						flag = true;
						if (bestRoot == null)
						{
							bestRoot = probeResult;
						}
						else if (probeResult.GetScore(atlasMustBePowerOfTwo) > bestRoot.GetScore(atlasMustBePowerOfTwo))
						{
							bestRoot = probeResult;
						}
					}
					else
					{
						num9++;
						num10 = StepWidthHeight(num10, num7, maxDimensionX);
						if (LOG_LEVEL >= MB2_LogLevel.trace)
						{
							MB2_Log.LogDebug("increasing Width h=" + num11 + " w=" + num10);
						}
					}
				}
				num11 = StepWidthHeight(num11, num8, maxDimensionY);
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					MB2_Log.LogDebug("increasing Height h=" + num11 + " w=" + num10);
				}
			}
			if (bestRoot == null)
			{
				return null;
			}
			int num12 = 0;
			int num13 = 0;
			if (atlasMustBePowerOfTwo)
			{
				num12 = Mathf.Min(MB2_TexturePacker.CeilToNearestPowerOfTwo(bestRoot.w), maxDimensionX);
				num13 = Mathf.Min(MB2_TexturePacker.CeilToNearestPowerOfTwo(bestRoot.h), maxDimensionY);
				if (num13 < num12 / 2)
				{
					num13 = num12 / 2;
				}
				if (num12 < num13 / 2)
				{
					num12 = num13 / 2;
				}
			}
			else
			{
				num12 = Mathf.Min(bestRoot.w, maxDimensionX);
				num13 = Mathf.Min(bestRoot.h, maxDimensionY);
			}
			bestRoot.outW = num12;
			bestRoot.outH = num13;
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log("Best fit found: atlasW=" + num12 + " atlasH" + num13 + " w=" + bestRoot.w + " h=" + bestRoot.h + " efficiency=" + bestRoot.efficiency + " squareness=" + bestRoot.squareness + " fits in max dimension=" + bestRoot.largerOrEqualToMaxDim);
			}
			List<Image> list = new List<Image>();
			flattenTree(bestRoot.root, list);
			list.Sort(new ImgIDComparer());
			Vector2 rootWH = new Vector2(bestRoot.w, bestRoot.h);
			if (!ScaleAtlasToFitMaxDim(rootWH, list, maxDimensionX, maxDimensionY, paddings[0], minImageSizeX, minImageSizeY, masterImageSizeX, masterImageSizeY, ref num12, ref num13, out var padX, out var padY, out var newMinSizeX, out var newMinSizeY))
			{
				AtlasPackingResult atlasPackingResult = new AtlasPackingResult(paddings.ToArray());
				atlasPackingResult.rects = new Rect[list.Count];
				atlasPackingResult.srcImgIdxs = new int[list.Count];
				atlasPackingResult.atlasX = num12;
				atlasPackingResult.atlasY = num13;
				atlasPackingResult.usedW = -1;
				atlasPackingResult.usedH = -1;
				for (int j = 0; j < list.Count; j++)
				{
					Image image2 = list[j];
					Rect rect = (atlasPackingResult.rects[j] = new Rect((float)image2.x / (float)num12 + padX, (float)image2.y / (float)num13 + padY, (float)image2.w / (float)num12 - padX * 2f, (float)image2.h / (float)num13 - padY * 2f));
					atlasPackingResult.srcImgIdxs[j] = image2.imgId;
					if (LOG_LEVEL >= MB2_LogLevel.debug)
					{
						MB2_Log.LogDebug("Image: " + j + " imgID=" + image2.imgId + " x=" + rect.x * (float)num12 + " y=" + rect.y * (float)num13 + " w=" + rect.width * (float)num12 + " h=" + rect.height * (float)num13 + " padding=" + paddings[j]);
					}
				}
				atlasPackingResult.CalcUsedWidthAndHeight();
				return atlasPackingResult;
			}
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log("==================== REDOING PACKING ================");
			}
			return _GetRectsSingleAtlas(imgWidthHeights, paddings, maxDimensionX, maxDimensionY, newMinSizeX, newMinSizeY, masterImageSizeX, masterImageSizeY, recursionDepth + 1);
		}

		private AtlasPackingResult[] _GetRectsMultiAtlas(List<Vector2> imgWidthHeights, List<AtlasPadding> paddings, int maxDimensionPassedX, int maxDimensionPassedY, int minImageSizeX, int minImageSizeY, int masterImageSizeX, int masterImageSizeY)
		{
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log($"_GetRects numImages={imgWidthHeights.Count}, maxDimensionX={maxDimensionPassedX}, maxDimensionY={maxDimensionPassedY} minImageSizeX={minImageSizeX}, minImageSizeY={minImageSizeY}, masterImageSizeX={masterImageSizeX}, masterImageSizeY={masterImageSizeY}");
			}
			float num = 0f;
			int a = 0;
			int a2 = 0;
			Image[] array = new Image[imgWidthHeights.Count];
			int num2 = maxDimensionPassedX;
			int num3 = maxDimensionPassedY;
			if (atlasMustBePowerOfTwo)
			{
				num2 = MB2_TexturePacker.RoundToNearestPositivePowerOfTwo(num2);
				num3 = MB2_TexturePacker.RoundToNearestPositivePowerOfTwo(num3);
			}
			for (int i = 0; i < array.Length; i++)
			{
				int a3 = (int)imgWidthHeights[i].x;
				int a4 = (int)imgWidthHeights[i].y;
				a3 = Mathf.Min(a3, num2 - paddings[i].leftRight * 2);
				a4 = Mathf.Min(a4, num3 - paddings[i].topBottom * 2);
				Image image = (array[i] = new Image(i, a3, a4, paddings[i], minImageSizeX, minImageSizeY));
				num += (float)(image.w * image.h);
				a = Mathf.Max(a, image.w);
				a2 = Mathf.Max(a2, image.h);
			}
			int num4;
			int num5;
			if (atlasMustBePowerOfTwo)
			{
				num4 = MB2_TexturePacker.RoundToNearestPositivePowerOfTwo(num3);
				num5 = MB2_TexturePacker.RoundToNearestPositivePowerOfTwo(num2);
			}
			else
			{
				num4 = num3;
				num5 = num2;
			}
			if (num5 == 0)
			{
				num5 = 4;
			}
			if (num4 == 0)
			{
				num4 = 4;
			}
			ProbeResult probeResult = new ProbeResult();
			Array.Sort(array, new ImageHeightComparer());
			if (ProbeMultiAtlas(array, num5, num4, num, num2, num3, probeResult))
			{
				bestRoot = probeResult;
			}
			Array.Sort(array, new ImageWidthComparer());
			if (ProbeMultiAtlas(array, num5, num4, num, num2, num3, probeResult) && probeResult.totalAtlasArea < bestRoot.totalAtlasArea)
			{
				bestRoot = probeResult;
			}
			Array.Sort(array, new ImageAreaComparer());
			if (ProbeMultiAtlas(array, num5, num4, num, num2, num3, probeResult) && probeResult.totalAtlasArea < bestRoot.totalAtlasArea)
			{
				bestRoot = probeResult;
			}
			if (bestRoot == null)
			{
				return null;
			}
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log("Best fit found: w=" + bestRoot.w + " h=" + bestRoot.h + " efficiency=" + bestRoot.efficiency + " squareness=" + bestRoot.squareness + " fits in max dimension=" + bestRoot.largerOrEqualToMaxDim);
			}
			List<AtlasPackingResult> list = new List<AtlasPackingResult>();
			List<Node> list2 = new List<Node>();
			Stack<Node> stack = new Stack<Node>();
			for (Node node = bestRoot.root; node != null; node = node.child[0])
			{
				stack.Push(node);
			}
			while (stack.Count > 0)
			{
				Node node = stack.Pop();
				if (node.isFullAtlas == NodeType.maxDim)
				{
					list2.Add(node);
				}
				if (node.child[1] != null)
				{
					for (node = node.child[1]; node != null; node = node.child[0])
					{
						stack.Push(node);
					}
				}
			}
			for (int j = 0; j < list2.Count; j++)
			{
				List<Image> list3 = new List<Image>();
				flattenTree(list2[j], list3);
				Rect[] array2 = new Rect[list3.Count];
				int[] array3 = new int[list3.Count];
				for (int k = 0; k < list3.Count; k++)
				{
					array2[k] = new Rect(list3[k].x - list2[j].r.x, list3[k].y, list3[k].w, list3[k].h);
					array3[k] = list3[k].imgId;
				}
				AtlasPackingResult atlasPackingResult = new AtlasPackingResult(paddings.ToArray());
				GetExtent(list2[j], ref atlasPackingResult.usedW, ref atlasPackingResult.usedH);
				atlasPackingResult.usedW -= list2[j].r.x;
				int w = list2[j].r.w;
				int h = list2[j].r.h;
				if (atlasMustBePowerOfTwo)
				{
					w = Mathf.Min(MB2_TexturePacker.CeilToNearestPowerOfTwo(atlasPackingResult.usedW), list2[j].r.w);
					h = Mathf.Min(MB2_TexturePacker.CeilToNearestPowerOfTwo(atlasPackingResult.usedH), list2[j].r.h);
					if (h < w / 2)
					{
						h = w / 2;
					}
					if (w < h / 2)
					{
						w = h / 2;
					}
				}
				else
				{
					w = atlasPackingResult.usedW;
					h = atlasPackingResult.usedH;
				}
				atlasPackingResult.atlasY = h;
				atlasPackingResult.atlasX = w;
				atlasPackingResult.rects = array2;
				atlasPackingResult.srcImgIdxs = array3;
				atlasPackingResult.CalcUsedWidthAndHeight();
				list.Add(atlasPackingResult);
				normalizeRects(atlasPackingResult, paddings[j]);
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					MB2_Log.LogDebug($"Done GetRects ");
				}
			}
			return list.ToArray();
		}
	}
	public class MB2_TexturePackerHorizontalVert : MB2_TexturePacker
	{
		public enum TexturePackingOrientation
		{
			horizontal,
			vertical
		}

		public TexturePackingOrientation packingOrientation;

		public bool stretchImagesToEdges = true;

		public override AtlasPackingResult[] GetRects(List<Vector2> imgWidthHeights, int maxDimensionX, int maxDimensionY, int padding)
		{
			List<AtlasPadding> list = new List<AtlasPadding>();
			for (int i = 0; i < imgWidthHeights.Count; i++)
			{
				AtlasPadding item = default(AtlasPadding);
				if (packingOrientation == TexturePackingOrientation.horizontal)
				{
					item.leftRight = 0;
					item.topBottom = 8;
				}
				else
				{
					item.leftRight = 8;
					item.topBottom = 0;
				}
				list.Add(item);
			}
			return GetRects(imgWidthHeights, list, maxDimensionX, maxDimensionY, doMultiAtlas: false);
		}

		public override AtlasPackingResult[] GetRects(List<Vector2> imgWidthHeights, List<AtlasPadding> paddings, int maxDimensionX, int maxDimensionY, bool doMultiAtlas)
		{
			int num = 0;
			int num2 = 0;
			for (int i = 0; i < paddings.Count; i++)
			{
				num = Mathf.Max(num, paddings[i].leftRight);
				num2 = Mathf.Max(num2, paddings[i].topBottom);
			}
			if (doMultiAtlas)
			{
				if (packingOrientation == TexturePackingOrientation.vertical)
				{
					return _GetRectsMultiAtlasVertical(imgWidthHeights, paddings, maxDimensionX, maxDimensionY, 2 + num * 2, 2 + num2 * 2, 2 + num * 2, 2 + num2 * 2);
				}
				return _GetRectsMultiAtlasHorizontal(imgWidthHeights, paddings, maxDimensionX, maxDimensionY, 2 + num * 2, 2 + num2 * 2, 2 + num * 2, 2 + num2 * 2);
			}
			AtlasPackingResult atlasPackingResult = _GetRectsSingleAtlas(imgWidthHeights, paddings, maxDimensionX, maxDimensionY, 2 + num * 2, 2 + num2 * 2, 2 + num * 2, 2 + num2 * 2, 0);
			if (atlasPackingResult == null)
			{
				return null;
			}
			return new AtlasPackingResult[1] { atlasPackingResult };
		}

		private AtlasPackingResult _GetRectsSingleAtlas(List<Vector2> imgWidthHeights, List<AtlasPadding> paddings, int maxDimensionX, int maxDimensionY, int minImageSizeX, int minImageSizeY, int masterImageSizeX, int masterImageSizeY, int recursionDepth)
		{
			AtlasPackingResult atlasPackingResult = new AtlasPackingResult(paddings.ToArray());
			List<Rect> list = new List<Rect>();
			int num = 0;
			int num2 = 0;
			int num3 = 0;
			List<Image> list2 = new List<Image>();
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log("Packing rects for: " + imgWidthHeights.Count);
			}
			for (int i = 0; i < imgWidthHeights.Count; i++)
			{
				Image image = new Image(i, (int)imgWidthHeights[i].x, (int)imgWidthHeights[i].y, paddings[i], minImageSizeX, minImageSizeY);
				if (packingOrientation == TexturePackingOrientation.vertical)
				{
					image.h -= paddings[i].topBottom * 2;
					image.x = num;
					image.y = 0;
					list.Add(new Rect(image.w, image.h, num, 0f));
					num += image.w;
					num2 = Mathf.Max(num2, image.h);
				}
				else
				{
					image.w -= paddings[i].leftRight * 2;
					image.y = num;
					image.x = 0;
					list.Add(new Rect(image.w, image.h, 0f, num));
					num += image.h;
					num3 = Mathf.Max(num3, image.w);
				}
				list2.Add(image);
			}
			Vector2 rootWH = ((packingOrientation != TexturePackingOrientation.vertical) ? new Vector2(num3, num) : new Vector2(num, num2));
			int outW = (int)rootWH.x;
			int outH = (int)rootWH.y;
			if (packingOrientation != TexturePackingOrientation.vertical)
			{
				outH = ((!atlasMustBePowerOfTwo) ? Mathf.Min(outH, maxDimensionY) : Mathf.Min(MB2_TexturePacker.CeilToNearestPowerOfTwo(outH), maxDimensionY));
			}
			else
			{
				outW = ((!atlasMustBePowerOfTwo) ? Mathf.Min(outW, maxDimensionX) : Mathf.Min(MB2_TexturePacker.CeilToNearestPowerOfTwo(outW), maxDimensionX));
			}
			if (!ScaleAtlasToFitMaxDim(rootWH, list2, maxDimensionX, maxDimensionY, paddings[0], minImageSizeX, minImageSizeY, masterImageSizeX, masterImageSizeY, ref outW, ref outH, out var padX, out var padY, out var _, out var _))
			{
				atlasPackingResult = new AtlasPackingResult(paddings.ToArray());
				atlasPackingResult.rects = new Rect[list2.Count];
				atlasPackingResult.srcImgIdxs = new int[list2.Count];
				atlasPackingResult.atlasX = outW;
				atlasPackingResult.atlasY = outH;
				for (int j = 0; j < list2.Count; j++)
				{
					Image image2 = list2[j];
					Rect rect = ((packingOrientation != TexturePackingOrientation.vertical) ? (atlasPackingResult.rects[j] = new Rect((float)image2.x / (float)outW, (float)image2.y / (float)outH + padY, stretchImagesToEdges ? 1f : ((float)image2.w / (float)outW), (float)image2.h / (float)outH - padY * 2f)) : (atlasPackingResult.rects[j] = new Rect((float)image2.x / (float)outW + padX, (float)image2.y / (float)outH, (float)image2.w / (float)outW - padX * 2f, stretchImagesToEdges ? 1f : ((float)image2.h / (float)outH))));
					atlasPackingResult.srcImgIdxs[j] = image2.imgId;
					if (LOG_LEVEL >= MB2_LogLevel.debug)
					{
						MB2_Log.LogDebug("Image: " + j + " imgID=" + image2.imgId + " x=" + rect.x * (float)outW + " y=" + rect.y * (float)outH + " w=" + rect.width * (float)outW + " h=" + rect.height * (float)outH + " padding=" + paddings[j].ToString() + " outW=" + outW + " outH=" + outH);
					}
				}
				atlasPackingResult.CalcUsedWidthAndHeight();
				return atlasPackingResult;
			}
			UnityEngine.Debug.Log("Packing failed returning null atlas result");
			return null;
		}

		private AtlasPackingResult[] _GetRectsMultiAtlasVertical(List<Vector2> imgWidthHeights, List<AtlasPadding> paddings, int maxDimensionPassedX, int maxDimensionPassedY, int minImageSizeX, int minImageSizeY, int masterImageSizeX, int masterImageSizeY)
		{
			List<AtlasPackingResult> list = new List<AtlasPackingResult>();
			int num = 0;
			int num2 = 0;
			int atlasX = 0;
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log("Packing rects for: " + imgWidthHeights.Count);
			}
			List<Image> list2 = new List<Image>();
			for (int i = 0; i < imgWidthHeights.Count; i++)
			{
				Image image = new Image(i, (int)imgWidthHeights[i].x, (int)imgWidthHeights[i].y, paddings[i], minImageSizeX, minImageSizeY);
				image.h -= paddings[i].topBottom * 2;
				list2.Add(image);
			}
			list2.Sort(new ImageWidthComparer());
			List<Image> list3 = new List<Image>();
			List<Rect> list4 = new List<Rect>();
			int spaceRemaining = maxDimensionPassedX;
			while (list2.Count > 0 || list3.Count > 0)
			{
				Image image2 = PopLargestThatFits(list2, spaceRemaining, maxDimensionPassedX, list3.Count == 0);
				if (image2 == null)
				{
					if (LOG_LEVEL >= MB2_LogLevel.debug)
					{
						UnityEngine.Debug.Log("Atlas filled creating a new atlas ");
					}
					AtlasPackingResult atlasPackingResult = new AtlasPackingResult(paddings.ToArray());
					atlasPackingResult.atlasX = atlasX;
					atlasPackingResult.atlasY = num2;
					Rect[] array = new Rect[list3.Count];
					int[] array2 = new int[list3.Count];
					for (int j = 0; j < list3.Count; j++)
					{
						Rect rect = new Rect(list3[j].x, list3[j].y, list3[j].w, stretchImagesToEdges ? num2 : list3[j].h);
						array[j] = rect;
						array2[j] = list3[j].imgId;
					}
					atlasPackingResult.rects = array;
					atlasPackingResult.srcImgIdxs = array2;
					atlasPackingResult.CalcUsedWidthAndHeight();
					list3.Clear();
					list4.Clear();
					num = 0;
					num2 = 0;
					list.Add(atlasPackingResult);
					spaceRemaining = maxDimensionPassedX;
				}
				else
				{
					image2.x = num;
					image2.y = 0;
					list3.Add(image2);
					list4.Add(new Rect(num, 0f, image2.w, image2.h));
					num += image2.w;
					num2 = Mathf.Max(num2, image2.h);
					atlasX = num;
					spaceRemaining = maxDimensionPassedX - num;
				}
			}
			for (int k = 0; k < list.Count; k++)
			{
				int atlasX2 = list[k].atlasX;
				int outH = Mathf.Min(list[k].atlasY, maxDimensionPassedY);
				atlasX2 = ((!atlasMustBePowerOfTwo) ? Mathf.Min(atlasX2, maxDimensionPassedX) : Mathf.Min(MB2_TexturePacker.CeilToNearestPowerOfTwo(atlasX2), maxDimensionPassedX));
				list[k].atlasX = atlasX2;
				ScaleAtlasToFitMaxDim(new Vector2(list[k].atlasX, list[k].atlasY), list3, maxDimensionPassedX, maxDimensionPassedY, paddings[0], minImageSizeX, minImageSizeY, masterImageSizeX, masterImageSizeY, ref atlasX2, ref outH, out var _, out var _, out var _, out var _);
			}
			for (int l = 0; l < list.Count; l++)
			{
				normalizeRects(list[l], paddings[l]);
				list[l].CalcUsedWidthAndHeight();
			}
			return list.ToArray();
		}

		private AtlasPackingResult[] _GetRectsMultiAtlasHorizontal(List<Vector2> imgWidthHeights, List<AtlasPadding> paddings, int maxDimensionPassedX, int maxDimensionPassedY, int minImageSizeX, int minImageSizeY, int masterImageSizeX, int masterImageSizeY)
		{
			List<AtlasPackingResult> list = new List<AtlasPackingResult>();
			int num = 0;
			int atlasY = 0;
			int num2 = 0;
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log("Packing rects for: " + imgWidthHeights.Count);
			}
			List<Image> list2 = new List<Image>();
			for (int i = 0; i < imgWidthHeights.Count; i++)
			{
				Image image = new Image(i, (int)imgWidthHeights[i].x, (int)imgWidthHeights[i].y, paddings[i], minImageSizeX, minImageSizeY);
				image.w -= paddings[i].leftRight * 2;
				list2.Add(image);
			}
			list2.Sort(new ImageHeightComparer());
			List<Image> list3 = new List<Image>();
			List<Rect> list4 = new List<Rect>();
			int spaceRemaining = maxDimensionPassedY;
			while (list2.Count > 0 || list3.Count > 0)
			{
				Image image2 = PopLargestThatFits(list2, spaceRemaining, maxDimensionPassedY, list3.Count == 0);
				if (image2 == null)
				{
					if (LOG_LEVEL >= MB2_LogLevel.debug)
					{
						UnityEngine.Debug.Log("Atlas filled creating a new atlas ");
					}
					AtlasPackingResult atlasPackingResult = new AtlasPackingResult(paddings.ToArray());
					atlasPackingResult.atlasX = num2;
					atlasPackingResult.atlasY = atlasY;
					Rect[] array = new Rect[list3.Count];
					int[] array2 = new int[list3.Count];
					for (int j = 0; j < list3.Count; j++)
					{
						Rect rect = new Rect(list3[j].x, list3[j].y, stretchImagesToEdges ? num2 : list3[j].w, list3[j].h);
						array[j] = rect;
						array2[j] = list3[j].imgId;
					}
					atlasPackingResult.rects = array;
					atlasPackingResult.srcImgIdxs = array2;
					list3.Clear();
					list4.Clear();
					num = 0;
					atlasY = 0;
					list.Add(atlasPackingResult);
					spaceRemaining = maxDimensionPassedY;
				}
				else
				{
					image2.x = 0;
					image2.y = num;
					list3.Add(image2);
					list4.Add(new Rect(0f, num, image2.w, image2.h));
					num += image2.h;
					num2 = Mathf.Max(num2, image2.w);
					atlasY = num;
					spaceRemaining = maxDimensionPassedY - num;
				}
			}
			for (int k = 0; k < list.Count; k++)
			{
				int atlasY2 = list[k].atlasY;
				int outW = Mathf.Min(list[k].atlasX, maxDimensionPassedX);
				atlasY2 = ((!atlasMustBePowerOfTwo) ? Mathf.Min(atlasY2, maxDimensionPassedY) : Mathf.Min(MB2_TexturePacker.CeilToNearestPowerOfTwo(atlasY2), maxDimensionPassedY));
				list[k].atlasY = atlasY2;
				ScaleAtlasToFitMaxDim(new Vector2(list[k].atlasX, list[k].atlasY), list3, maxDimensionPassedX, maxDimensionPassedY, paddings[0], minImageSizeX, minImageSizeY, masterImageSizeX, masterImageSizeY, ref outW, ref atlasY2, out var _, out var _, out var _, out var _);
			}
			for (int l = 0; l < list.Count; l++)
			{
				normalizeRects(list[l], paddings[l]);
				list[l].CalcUsedWidthAndHeight();
			}
			return list.ToArray();
		}

		private Image PopLargestThatFits(List<Image> images, int spaceRemaining, int maxDim, bool emptyAtlas)
		{
			if (images.Count == 0)
			{
				return null;
			}
			int num = ((packingOrientation != TexturePackingOrientation.vertical) ? images[0].h : images[0].w);
			if (images.Count > 0 && num >= maxDim)
			{
				if (emptyAtlas)
				{
					Image result = images[0];
					images.RemoveAt(0);
					return result;
				}
				return null;
			}
			int i;
			for (i = 0; i < images.Count; i++)
			{
				if (num < spaceRemaining)
				{
					break;
				}
			}
			if (i < images.Count)
			{
				Image result2 = images[i];
				images.RemoveAt(i);
				return result2;
			}
			return null;
		}
	}
	internal interface MB_ITextureCombinerPacker
	{
		IEnumerator ConvertTexturesToReadableFormats(ProgressUpdateDelegate progressInfo, MB3_TextureCombiner.CombineTexturesIntoAtlasesCoroutineResult result, MB3_TextureCombinerPipeline.TexturePipelineData data, MB3_TextureCombiner combiner, MB2_EditorMethodsInterface textureEditorMethods, MB2_LogLevel LOG_LEVEL);

		AtlasPackingResult[] CalculateAtlasRectangles(MB3_TextureCombinerPipeline.TexturePipelineData data, bool doMultiAtlas, MB2_LogLevel LOG_LEVEL);

		IEnumerator CreateAtlases(ProgressUpdateDelegate progressInfo, MB3_TextureCombinerPipeline.TexturePipelineData data, MB3_TextureCombiner combiner, AtlasPackingResult packedAtlasRects, Texture2D[] atlases, MB2_EditorMethodsInterface textureEditorMethods, MB2_LogLevel LOG_LEVEL);
	}
	internal abstract class MB3_TextureCombinerPackerRoot : MB_ITextureCombinerPacker
	{
		internal static void CreateTemporaryTexturesForAtlas(List<MB_TexSet> distinctMaterialTextures, MB3_TextureCombiner combiner, int propIdx, MB3_TextureCombinerPipeline.TexturePipelineData data)
		{
			for (int i = 0; i < data.distinctMaterialTextures.Count; i++)
			{
				MB_TexSet mB_TexSet = data.distinctMaterialTextures[i];
				if (mB_TexSet.ts[propIdx].isNull)
				{
					Color colorForTemporaryTexture = data.nonTexturePropertyBlender.GetColorForTemporaryTexture(mB_TexSet.matsAndGOs.mats[0].mat, data.texPropertyNames[propIdx]);
					mB_TexSet.CreateColoredTexToReplaceNull(data.texPropertyNames[propIdx].name, propIdx, data._fixOutOfBoundsUVs, combiner, colorForTemporaryTexture);
				}
			}
		}

		public static AtlasPackingResult[] CalculateAtlasRectanglesStatic(MB3_TextureCombinerPipeline.TexturePipelineData data, bool doMultiAtlas, MB2_LogLevel LOG_LEVEL)
		{
			List<Vector2> list = new List<Vector2>();
			for (int i = 0; i < data.distinctMaterialTextures.Count; i++)
			{
				list.Add(new Vector2(data.distinctMaterialTextures[i].idealWidth, data.distinctMaterialTextures[i].idealHeight));
			}
			MB2_TexturePacker mB2_TexturePacker = MB3_TextureCombinerPipeline.CreateTexturePacker(data._packingAlgorithm);
			mB2_TexturePacker.atlasMustBePowerOfTwo = data._meshBakerTexturePackerForcePowerOfTwo;
			List<AtlasPadding> list2 = new List<AtlasPadding>();
			for (int j = 0; j < list.Count; j++)
			{
				AtlasPadding item = default(AtlasPadding);
				item.topBottom = data._atlasPadding;
				item.leftRight = data._atlasPadding;
				if (data._packingAlgorithm == MB2_PackingAlgorithmEnum.MeshBakerTexturePacker_Horizontal)
				{
					item.leftRight = 0;
				}
				if (data._packingAlgorithm == MB2_PackingAlgorithmEnum.MeshBakerTexturePacker_Vertical)
				{
					item.topBottom = 0;
				}
				list2.Add(item);
			}
			return mB2_TexturePacker.GetRects(list, list2, data._maxAtlasWidth, data._maxAtlasHeight, doMultiAtlas: false);
		}

		public static void MakeProceduralTexturesReadable(ProgressUpdateDelegate progressInfo, MB3_TextureCombiner.CombineTexturesIntoAtlasesCoroutineResult result, MB3_TextureCombinerPipeline.TexturePipelineData data, MB3_TextureCombiner combiner, MB2_EditorMethodsInterface textureEditorMethods, MB2_LogLevel LOG_LEVEL)
		{
			UnityEngine.Debug.LogError("TODO this should be done as close to textures being used as possible due to memory issues.");
		}

		public virtual IEnumerator ConvertTexturesToReadableFormats(ProgressUpdateDelegate progressInfo, MB3_TextureCombiner.CombineTexturesIntoAtlasesCoroutineResult result, MB3_TextureCombinerPipeline.TexturePipelineData data, MB3_TextureCombiner combiner, MB2_EditorMethodsInterface textureEditorMethods, MB2_LogLevel LOG_LEVEL)
		{
			for (int i = 0; i < data.distinctMaterialTextures.Count; i++)
			{
				for (int j = 0; j < data.texPropertyNames.Count; j++)
				{
					MeshBakerMaterialTexture meshBakerMaterialTexture = data.distinctMaterialTextures[i].ts[j];
					if (!meshBakerMaterialTexture.isNull && textureEditorMethods != null)
					{
						Texture texture2D = meshBakerMaterialTexture.GetTexture2D();
						progressInfo?.Invoke($"Convert texture {texture2D} to readable format ", 0.5f);
						textureEditorMethods.AddTextureFormat((Texture2D)texture2D, data.texPropertyNames[j].isNormalMap);
					}
				}
			}
			yield break;
		}

		public virtual AtlasPackingResult[] CalculateAtlasRectangles(MB3_TextureCombinerPipeline.TexturePipelineData data, bool doMultiAtlas, MB2_LogLevel LOG_LEVEL)
		{
			return CalculateAtlasRectanglesStatic(data, doMultiAtlas, LOG_LEVEL);
		}

		public abstract IEnumerator CreateAtlases(ProgressUpdateDelegate progressInfo, MB3_TextureCombinerPipeline.TexturePipelineData data, MB3_TextureCombiner combiner, AtlasPackingResult packedAtlasRects, Texture2D[] atlases, MB2_EditorMethodsInterface textureEditorMethods, MB2_LogLevel LOG_LEVEL);
	}
	[Serializable]
	public class ShaderTextureProperty
	{
		public string name;

		public bool isNormalMap;

		public ShaderTextureProperty(string n, bool norm)
		{
			name = n;
			isNormalMap = norm;
		}

		public override bool Equals(object obj)
		{
			if (!(obj is ShaderTextureProperty))
			{
				return false;
			}
			ShaderTextureProperty shaderTextureProperty = (ShaderTextureProperty)obj;
			if (!name.Equals(shaderTextureProperty.name))
			{
				return false;
			}
			if (isNormalMap != shaderTextureProperty.isNormalMap)
			{
				return false;
			}
			return true;
		}

		public override int GetHashCode()
		{
			return base.GetHashCode();
		}

		public static string[] GetNames(List<ShaderTextureProperty> props)
		{
			string[] array = new string[props.Count];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = props[i].name;
			}
			return array;
		}
	}
	[Serializable]
	public class MB3_TextureCombiner
	{
		private class TemporaryTexture
		{
			internal string property;

			internal Texture2D texture;

			public TemporaryTexture(string prop, Texture2D tex)
			{
				property = prop;
				texture = tex;
			}
		}

		public class CombineTexturesIntoAtlasesCoroutineResult
		{
			public bool success = true;

			public bool isFinished;
		}

		public MB2_LogLevel LOG_LEVEL = MB2_LogLevel.info;

		[SerializeField]
		protected MB2_TextureBakeResults _textureBakeResults;

		[SerializeField]
		protected int _atlasPadding = 1;

		[SerializeField]
		protected int _maxAtlasSize = 1;

		[SerializeField]
		protected int _maxAtlasWidthOverride = 4096;

		[SerializeField]
		protected int _maxAtlasHeightOverride = 4096;

		[SerializeField]
		protected bool _useMaxAtlasWidthOverride;

		[SerializeField]
		protected bool _useMaxAtlasHeightOverride;

		[SerializeField]
		protected bool _resizePowerOfTwoTextures;

		[SerializeField]
		protected bool _fixOutOfBoundsUVs;

		[SerializeField]
		protected int _maxTilingBakeSize = 1024;

		[SerializeField]
		protected bool _saveAtlasesAsAssets;

		[SerializeField]
		protected MB2_PackingAlgorithmEnum _packingAlgorithm;

		[SerializeField]
		protected bool _meshBakerTexturePackerForcePowerOfTwo = true;

		[SerializeField]
		protected List<ShaderTextureProperty> _customShaderPropNames = new List<ShaderTextureProperty>();

		[SerializeField]
		protected bool _normalizeTexelDensity;

		[SerializeField]
		protected bool _considerNonTextureProperties;

		private List<TemporaryTexture> _temporaryTextures = new List<TemporaryTexture>();

		public static bool _RunCorutineWithoutPauseIsRunning;

		public MB2_TextureBakeResults textureBakeResults
		{
			get
			{
				return _textureBakeResults;
			}
			set
			{
				_textureBakeResults = value;
			}
		}

		public int atlasPadding
		{
			get
			{
				return _atlasPadding;
			}
			set
			{
				_atlasPadding = value;
			}
		}

		public int maxAtlasSize
		{
			get
			{
				return _maxAtlasSize;
			}
			set
			{
				_maxAtlasSize = value;
			}
		}

		public virtual int maxAtlasWidthOverride
		{
			get
			{
				return _maxAtlasWidthOverride;
			}
			set
			{
				_maxAtlasWidthOverride = value;
			}
		}

		public virtual int maxAtlasHeightOverride
		{
			get
			{
				return _maxAtlasHeightOverride;
			}
			set
			{
				_maxAtlasHeightOverride = value;
			}
		}

		public virtual bool useMaxAtlasWidthOverride
		{
			get
			{
				return _useMaxAtlasWidthOverride;
			}
			set
			{
				_useMaxAtlasWidthOverride = value;
			}
		}

		public virtual bool useMaxAtlasHeightOverride
		{
			get
			{
				return _useMaxAtlasHeightOverride;
			}
			set
			{
				_useMaxAtlasHeightOverride = value;
			}
		}

		public bool resizePowerOfTwoTextures
		{
			get
			{
				return _resizePowerOfTwoTextures;
			}
			set
			{
				_resizePowerOfTwoTextures = value;
			}
		}

		public bool fixOutOfBoundsUVs
		{
			get
			{
				return _fixOutOfBoundsUVs;
			}
			set
			{
				_fixOutOfBoundsUVs = value;
			}
		}

		public int maxTilingBakeSize
		{
			get
			{
				return _maxTilingBakeSize;
			}
			set
			{
				_maxTilingBakeSize = value;
			}
		}

		public bool saveAtlasesAsAssets
		{
			get
			{
				return _saveAtlasesAsAssets;
			}
			set
			{
				_saveAtlasesAsAssets = value;
			}
		}

		public MB2_PackingAlgorithmEnum packingAlgorithm
		{
			get
			{
				return _packingAlgorithm;
			}
			set
			{
				_packingAlgorithm = value;
			}
		}

		public bool meshBakerTexturePackerForcePowerOfTwo
		{
			get
			{
				return _meshBakerTexturePackerForcePowerOfTwo;
			}
			set
			{
				_meshBakerTexturePackerForcePowerOfTwo = value;
			}
		}

		public List<ShaderTextureProperty> customShaderPropNames
		{
			get
			{
				return _customShaderPropNames;
			}
			set
			{
				_customShaderPropNames = value;
			}
		}

		public bool considerNonTextureProperties
		{
			get
			{
				return _considerNonTextureProperties;
			}
			set
			{
				_considerNonTextureProperties = value;
			}
		}

		public static void RunCorutineWithoutPause(IEnumerator cor, int recursionDepth)
		{
			if (recursionDepth == 0)
			{
				_RunCorutineWithoutPauseIsRunning = true;
			}
			if (recursionDepth > 20)
			{
				UnityEngine.Debug.LogError("Recursion Depth Exceeded.");
				return;
			}
			while (cor.MoveNext())
			{
				object current = cor.Current;
				if (!(current is YieldInstruction) && current != null && current is IEnumerator)
				{
					RunCorutineWithoutPause((IEnumerator)cor.Current, recursionDepth + 1);
				}
			}
			if (recursionDepth == 0)
			{
				_RunCorutineWithoutPauseIsRunning = false;
			}
		}

		public bool CombineTexturesIntoAtlases(ProgressUpdateDelegate progressInfo, MB_AtlasesAndRects resultAtlasesAndRects, Material resultMaterial, List<GameObject> objsToMesh, List<Material> allowedMaterialsFilter, MB2_EditorMethodsInterface textureEditorMethods = null, List<AtlasPackingResult> packingResults = null, bool onlyPackRects = false)
		{
			CombineTexturesIntoAtlasesCoroutineResult combineTexturesIntoAtlasesCoroutineResult = new CombineTexturesIntoAtlasesCoroutineResult();
			RunCorutineWithoutPause(_CombineTexturesIntoAtlases(progressInfo, combineTexturesIntoAtlasesCoroutineResult, resultAtlasesAndRects, resultMaterial, objsToMesh, allowedMaterialsFilter, textureEditorMethods, packingResults, onlyPackRects), 0);
			return combineTexturesIntoAtlasesCoroutineResult.success;
		}

		public IEnumerator CombineTexturesIntoAtlasesCoroutine(ProgressUpdateDelegate progressInfo, MB_AtlasesAndRects resultAtlasesAndRects, Material resultMaterial, List<GameObject> objsToMesh, List<Material> allowedMaterialsFilter, MB2_EditorMethodsInterface textureEditorMethods = null, CombineTexturesIntoAtlasesCoroutineResult coroutineResult = null, float maxTimePerFrame = 0.01f, List<AtlasPackingResult> packingResults = null, bool onlyPackRects = false)
		{
			if (!_RunCorutineWithoutPauseIsRunning && (MBVersion.GetMajorVersion() < 5 || (MBVersion.GetMajorVersion() == 5 && MBVersion.GetMinorVersion() < 3)))
			{
				UnityEngine.Debug.LogError("Running the texture combiner as a coroutine only works in Unity 5.3 and higher");
				yield return null;
			}
			coroutineResult.success = true;
			coroutineResult.isFinished = false;
			if (maxTimePerFrame <= 0f)
			{
				UnityEngine.Debug.LogError("maxTimePerFrame must be a value greater than zero");
				coroutineResult.isFinished = true;
			}
			else
			{
				yield return _CombineTexturesIntoAtlases(progressInfo, coroutineResult, resultAtlasesAndRects, resultMaterial, objsToMesh, allowedMaterialsFilter, textureEditorMethods, packingResults, onlyPackRects);
				coroutineResult.isFinished = true;
			}
		}

		private IEnumerator _CombineTexturesIntoAtlases(ProgressUpdateDelegate progressInfo, CombineTexturesIntoAtlasesCoroutineResult result, MB_AtlasesAndRects resultAtlasesAndRects, Material resultMaterial, List<GameObject> objsToMesh, List<Material> allowedMaterialsFilter, MB2_EditorMethodsInterface textureEditorMethods, List<AtlasPackingResult> atlasPackingResult, bool onlyPackRects)
		{
			Stopwatch sw = new Stopwatch();
			sw.Start();
			try
			{
				_temporaryTextures.Clear();
				MeshBakerMaterialTexture.readyToBuildAtlases = false;
				if (textureEditorMethods != null)
				{
					textureEditorMethods.Clear();
					textureEditorMethods.OnPreTextureBake();
				}
				if (objsToMesh == null || objsToMesh.Count == 0)
				{
					UnityEngine.Debug.LogError("No meshes to combine. Please assign some meshes to combine.");
					result.success = false;
					yield break;
				}
				if (_atlasPadding < 0)
				{
					UnityEngine.Debug.LogError("Atlas padding must be zero or greater.");
					result.success = false;
					yield break;
				}
				if (_maxTilingBakeSize < 2 || _maxTilingBakeSize > 4096)
				{
					UnityEngine.Debug.LogError("Invalid value for max tiling bake size.");
					result.success = false;
					yield break;
				}
				for (int i = 0; i < objsToMesh.Count; i++)
				{
					Material[] gOMaterials = MB_Utility.GetGOMaterials(objsToMesh[i]);
					for (int j = 0; j < gOMaterials.Length; j++)
					{
						if (gOMaterials[j] == null)
						{
							UnityEngine.Debug.LogError("Game object " + objsToMesh[i]?.ToString() + " has a null material");
							result.success = false;
							yield break;
						}
					}
				}
				progressInfo?.Invoke("Collecting textures for " + objsToMesh.Count + " meshes.", 0.01f);
				MB3_TextureCombinerPipeline.TexturePipelineData texturePipelineData = LoadPipelineData(resultMaterial, new List<ShaderTextureProperty>(), objsToMesh, allowedMaterialsFilter, new List<MB_TexSet>());
				if (!MB3_TextureCombinerPipeline._CollectPropertyNames(texturePipelineData, LOG_LEVEL))
				{
					result.success = false;
					yield break;
				}
				if (_fixOutOfBoundsUVs && (_packingAlgorithm == MB2_PackingAlgorithmEnum.MeshBakerTexturePacker_Horizontal || _packingAlgorithm == MB2_PackingAlgorithmEnum.MeshBakerTexturePacker_Vertical) && LOG_LEVEL >= MB2_LogLevel.info)
				{
					UnityEngine.Debug.LogWarning("'Consider Mesh UVs' is enabled but packing algorithm is MeshBakerTexturePacker_Horizontal or MeshBakerTexturePacker_Vertical. It is recommended to use these packers without using 'Consider Mesh UVs'");
				}
				texturePipelineData.nonTexturePropertyBlender.LoadTextureBlendersIfNeeded(texturePipelineData.resultMaterial);
				if (onlyPackRects)
				{
					yield return __RunTexturePacker(result, texturePipelineData, textureEditorMethods, atlasPackingResult);
				}
				else
				{
					yield return __CombineTexturesIntoAtlases(progressInfo, result, resultAtlasesAndRects, texturePipelineData, textureEditorMethods);
				}
			}
			finally
			{
				MB3_TextureCombiner mB3_TextureCombiner = this;
				mB3_TextureCombiner._destroyAllTemporaryTextures();
				mB3_TextureCombiner._restoreProceduralMaterials();
				if (textureEditorMethods != null)
				{
					textureEditorMethods.RestoreReadFlagsAndFormats(progressInfo);
					textureEditorMethods.OnPostTextureBake();
				}
				if (mB3_TextureCombiner.LOG_LEVEL >= MB2_LogLevel.debug)
				{
					UnityEngine.Debug.Log("===== Done creating atlases for " + resultMaterial?.ToString() + " Total time to create atlases " + sw.Elapsed.ToString());
				}
			}
		}

		private MB3_TextureCombinerPipeline.TexturePipelineData LoadPipelineData(Material resultMaterial, List<ShaderTextureProperty> texPropertyNames, List<GameObject> objsToMesh, List<Material> allowedMaterialsFilter, List<MB_TexSet> distinctMaterialTextures)
		{
			MB3_TextureCombinerPipeline.TexturePipelineData texturePipelineData = new MB3_TextureCombinerPipeline.TexturePipelineData();
			texturePipelineData._textureBakeResults = _textureBakeResults;
			texturePipelineData._atlasPadding = _atlasPadding;
			if (_packingAlgorithm == MB2_PackingAlgorithmEnum.MeshBakerTexturePacker_Vertical && _useMaxAtlasHeightOverride)
			{
				texturePipelineData._maxAtlasHeight = _maxAtlasHeightOverride;
				texturePipelineData._useMaxAtlasHeightOverride = true;
			}
			else
			{
				texturePipelineData._maxAtlasHeight = _maxAtlasSize;
			}
			if (_packingAlgorithm == MB2_PackingAlgorithmEnum.MeshBakerTexturePacker_Horizontal && _useMaxAtlasWidthOverride)
			{
				texturePipelineData._maxAtlasWidth = _maxAtlasWidthOverride;
				texturePipelineData._useMaxAtlasWidthOverride = true;
			}
			else
			{
				texturePipelineData._maxAtlasWidth = _maxAtlasSize;
			}
			texturePipelineData._resizePowerOfTwoTextures = _resizePowerOfTwoTextures;
			texturePipelineData._fixOutOfBoundsUVs = _fixOutOfBoundsUVs;
			texturePipelineData._maxTilingBakeSize = _maxTilingBakeSize;
			texturePipelineData._saveAtlasesAsAssets = _saveAtlasesAsAssets;
			texturePipelineData._packingAlgorithm = _packingAlgorithm;
			texturePipelineData._meshBakerTexturePackerForcePowerOfTwo = _meshBakerTexturePackerForcePowerOfTwo;
			texturePipelineData._customShaderPropNames = _customShaderPropNames;
			texturePipelineData._normalizeTexelDensity = _normalizeTexelDensity;
			texturePipelineData._considerNonTextureProperties = _considerNonTextureProperties;
			texturePipelineData.nonTexturePropertyBlender = new MB3_TextureCombinerNonTextureProperties(LOG_LEVEL, _considerNonTextureProperties);
			texturePipelineData.resultMaterial = resultMaterial;
			texturePipelineData.distinctMaterialTextures = distinctMaterialTextures;
			texturePipelineData.allObjsToMesh = objsToMesh;
			texturePipelineData.allowedMaterialsFilter = allowedMaterialsFilter;
			texturePipelineData.texPropertyNames = texPropertyNames;
			return texturePipelineData;
		}

		private IEnumerator __CombineTexturesIntoAtlases(ProgressUpdateDelegate progressInfo, CombineTexturesIntoAtlasesCoroutineResult result, MB_AtlasesAndRects resultAtlasesAndRects, MB3_TextureCombinerPipeline.TexturePipelineData data, MB2_EditorMethodsInterface textureEditorMethods)
		{
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log("__CombineTexturesIntoAtlases texture properties in shader:" + data.texPropertyNames.Count + " objsToMesh:" + data.allObjsToMesh.Count + " _fixOutOfBoundsUVs:" + data._fixOutOfBoundsUVs);
			}
			progressInfo?.Invoke("Collecting textures ", 0.01f);
			List<GameObject> usedObjsToMesh = new List<GameObject>();
			yield return MB3_TextureCombinerPipeline.__Step1_CollectDistinctMatTexturesAndUsedObjects(progressInfo, result, data, this, textureEditorMethods, usedObjsToMesh, LOG_LEVEL);
			if (!result.success)
			{
				yield break;
			}
			if (MB3_MeshCombiner.EVAL_VERSION)
			{
				bool flag = true;
				for (int i = 0; i < data.distinctMaterialTextures.Count; i++)
				{
					for (int j = 0; j < data.distinctMaterialTextures[i].matsAndGOs.mats.Count; j++)
					{
						if (!data.distinctMaterialTextures[i].matsAndGOs.mats[j].mat.shader.name.EndsWith("Diffuse") && !data.distinctMaterialTextures[i].matsAndGOs.mats[j].mat.shader.name.EndsWith("Bumped Diffuse"))
						{
							UnityEngine.Debug.LogError("The free version of Mesh Baker only works with Diffuse and Bumped Diffuse Shaders. The full version can be used with any shader. Material " + data.distinctMaterialTextures[i].matsAndGOs.mats[j].mat.name + " uses shader " + data.distinctMaterialTextures[i].matsAndGOs.mats[j].mat.shader.name);
							flag = false;
						}
					}
				}
				if (!flag)
				{
					result.success = false;
					yield break;
				}
			}
			yield return MB3_TextureCombinerPipeline.CalculateIdealSizesForTexturesInAtlasAndPadding(progressInfo, result, data, this, textureEditorMethods, LOG_LEVEL);
			if (result.success)
			{
				StringBuilder report = MB3_TextureCombinerPipeline.GenerateReport(data);
				MB_ITextureCombinerPacker texturePaker = MB3_TextureCombinerPipeline.CreatePacker(data.OnlyOneTextureInAtlasReuseTextures(), data._packingAlgorithm);
				yield return texturePaker.ConvertTexturesToReadableFormats(progressInfo, result, data, this, textureEditorMethods, LOG_LEVEL);
				if (result.success)
				{
					AtlasPackingResult[] array = texturePaker.CalculateAtlasRectangles(data, doMultiAtlas: false, LOG_LEVEL);
					yield return MB3_TextureCombinerPipeline.__Step3_BuildAndSaveAtlasesAndStoreResults(result, progressInfo, data, this, texturePaker, array[0], textureEditorMethods, resultAtlasesAndRects, report, LOG_LEVEL);
				}
			}
		}

		private IEnumerator __RunTexturePacker(CombineTexturesIntoAtlasesCoroutineResult result, MB3_TextureCombinerPipeline.TexturePipelineData data, MB2_EditorMethodsInterface textureEditorMethods, List<AtlasPackingResult> packingResult)
		{
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log("__RunTexturePacker texture properties in shader:" + data.texPropertyNames.Count + " objsToMesh:" + data.allObjsToMesh.Count + " _fixOutOfBoundsUVs:" + data._fixOutOfBoundsUVs);
			}
			List<GameObject> usedObjsToMesh = new List<GameObject>();
			yield return MB3_TextureCombinerPipeline.__Step1_CollectDistinctMatTexturesAndUsedObjects(null, result, data, this, textureEditorMethods, usedObjsToMesh, LOG_LEVEL);
			if (!result.success)
			{
				yield break;
			}
			data.allTexturesAreNullAndSameColor = new MB3_TextureCombinerPipeline.CreateAtlasForProperty[data.texPropertyNames.Count];
			yield return MB3_TextureCombinerPipeline.CalculateIdealSizesForTexturesInAtlasAndPadding(null, result, data, this, textureEditorMethods, LOG_LEVEL);
			if (result.success)
			{
				MB_ITextureCombinerPacker texturePacker = MB3_TextureCombinerPipeline.CreatePacker(data.OnlyOneTextureInAtlasReuseTextures(), data._packingAlgorithm);
				AtlasPackingResult[] array = MB3_TextureCombinerPipeline.__Step3_RunTexturePacker(data, texturePacker, LOG_LEVEL);
				for (int i = 0; i < array.Length; i++)
				{
					packingResult.Add(array[i]);
				}
			}
		}

		internal int _getNumTemporaryTextures()
		{
			return _temporaryTextures.Count;
		}

		public Texture2D _createTemporaryTexture(string propertyName, int w, int h, TextureFormat texFormat, bool mipMaps)
		{
			Texture2D texture2D = new Texture2D(w, h, texFormat, mipMaps);
			texture2D.name = $"tmp{_temporaryTextures.Count}_{w}x{h}";
			MB_Utility.setSolidColor(texture2D, Color.clear);
			TemporaryTexture item = new TemporaryTexture(propertyName, texture2D);
			_temporaryTextures.Add(item);
			return texture2D;
		}

		internal Texture2D _createTextureCopy(string propertyName, Texture2D t)
		{
			Texture2D texture2D = MB_Utility.createTextureCopy(t);
			texture2D.name = $"tmpCopy{_temporaryTextures.Count}_{texture2D.width}x{texture2D.height}";
			TemporaryTexture item = new TemporaryTexture(propertyName, texture2D);
			_temporaryTextures.Add(item);
			return texture2D;
		}

		internal Texture2D _resizeTexture(string propertyName, Texture2D t, int w, int h)
		{
			Texture2D texture2D = MB_Utility.resampleTexture(t, w, h);
			texture2D.name = $"tmpResampled{_temporaryTextures.Count}_{w}x{h}";
			TemporaryTexture item = new TemporaryTexture(propertyName, texture2D);
			_temporaryTextures.Add(item);
			return texture2D;
		}

		internal void _destroyAllTemporaryTextures()
		{
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log("Destroying " + _temporaryTextures.Count + " temporary textures");
			}
			for (int i = 0; i < _temporaryTextures.Count; i++)
			{
				MB_Utility.Destroy(_temporaryTextures[i].texture);
			}
			_temporaryTextures.Clear();
		}

		internal void _destroyTemporaryTextures(string propertyName)
		{
			int num = 0;
			for (int num2 = _temporaryTextures.Count - 1; num2 >= 0; num2--)
			{
				if (_temporaryTextures[num2].property.Equals(propertyName))
				{
					num++;
					MB_Utility.Destroy(_temporaryTextures[num2].texture);
					_temporaryTextures.RemoveAt(num2);
				}
			}
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log("Destroying " + num + " temporary textures " + propertyName + " num remaining " + _temporaryTextures.Count);
			}
		}

		public void _restoreProceduralMaterials()
		{
		}

		public void SuggestTreatment(List<GameObject> objsToMesh, Material[] resultMaterials, List<ShaderTextureProperty> _customShaderPropNames)
		{
			this._customShaderPropNames = _customShaderPropNames;
			StringBuilder stringBuilder = new StringBuilder();
			Dictionary<int, MB_Utility.MeshAnalysisResult[]> dictionary = new Dictionary<int, MB_Utility.MeshAnalysisResult[]>();
			for (int i = 0; i < objsToMesh.Count; i++)
			{
				GameObject gameObject = objsToMesh[i];
				if (gameObject == null)
				{
					continue;
				}
				Material[] gOMaterials = MB_Utility.GetGOMaterials(objsToMesh[i]);
				if (gOMaterials.Length > 1)
				{
					stringBuilder.AppendFormat("\nObject {0} uses {1} materials. Possible treatments:\n", objsToMesh[i].name, gOMaterials.Length);
					stringBuilder.AppendFormat("  1) Collapse the submeshes together into one submesh in the combined mesh. Each of the original submesh materials will map to a different UV rectangle in the atlas(es) used by the combined material.\n");
					stringBuilder.AppendFormat("  2) Use the multiple materials feature to map submeshes in the source mesh to submeshes in the combined mesh.\n");
				}
				Mesh mesh = MB_Utility.GetMesh(gameObject);
				if (!dictionary.TryGetValue(mesh.GetInstanceID(), out var value))
				{
					value = new MB_Utility.MeshAnalysisResult[mesh.subMeshCount];
					MB_Utility.doSubmeshesShareVertsOrTris(mesh, ref value[0]);
					for (int j = 0; j < mesh.subMeshCount; j++)
					{
						MB_Utility.hasOutOfBoundsUVs(mesh, ref value[j], j);
						value[j].hasOverlappingSubmeshTris = value[0].hasOverlappingSubmeshTris;
						value[j].hasOverlappingSubmeshVerts = value[0].hasOverlappingSubmeshVerts;
					}
					dictionary.Add(mesh.GetInstanceID(), value);
				}
				for (int k = 0; k < gOMaterials.Length; k++)
				{
					if (value[k].hasOutOfBoundsUVs)
					{
						DRect dRect = new DRect(value[k].uvRect);
						stringBuilder.AppendFormat("\nObject {0} submesh={1} material={2} uses UVs outside the range 0,0 .. 1,1 to create tiling that tiles the box {3},{4} .. {5},{6}. This is a problem because the UVs outside the 0,0 .. 1,1 rectangle will pick up neighboring textures in the atlas. Possible Treatments:\n", gameObject, k, gOMaterials[k], dRect.x.ToString("G4"), dRect.y.ToString("G4"), (dRect.x + dRect.width).ToString("G4"), (dRect.y + dRect.height).ToString("G4"));
						stringBuilder.AppendFormat("    1) Ignore the problem. The tiling may not affect result significantly.\n");
						stringBuilder.AppendFormat("    2) Use the 'fix out of bounds UVs' feature to bake the tiling and scale the UVs to fit in the 0,0 .. 1,1 rectangle.\n");
						stringBuilder.AppendFormat("    3) Use the Multiple Materials feature to map the material on this submesh to its own submesh in the combined mesh. No other materials should map to this submesh. This will result in only one texture in the atlas(es) and the UVs should tile correctly.\n");
						stringBuilder.AppendFormat("    4) Combine only meshes that use the same (or subset of) the set of materials on this mesh. The original material(s) can be applied to the result\n");
					}
				}
				if (value[0].hasOverlappingSubmeshVerts)
				{
					stringBuilder.AppendFormat("\nObject {0} has submeshes that share vertices. This is a problem because each vertex can have only one UV coordinate and may be required to map to different positions in the various atlases that are generated. Possible treatments:\n", objsToMesh[i]);
					stringBuilder.AppendFormat(" 1) Ignore the problem. The vertices may not affect the result.\n");
					stringBuilder.AppendFormat(" 2) Use the Multiple Materials feature to map the submeshs that overlap to their own submeshs in the combined mesh. No other materials should map to this submesh. This will result in only one texture in the atlas(es) and the UVs should tile correctly.\n");
					stringBuilder.AppendFormat(" 3) Combine only meshes that use the same (or subset of) the set of materials on this mesh. The original material(s) can be applied to the result\n");
				}
			}
			Dictionary<Material, List<GameObject>> dictionary2 = new Dictionary<Material, List<GameObject>>();
			for (int l = 0; l < objsToMesh.Count; l++)
			{
				if (!(objsToMesh[l] != null))
				{
					continue;
				}
				Material[] gOMaterials2 = MB_Utility.GetGOMaterials(objsToMesh[l]);
				for (int m = 0; m < gOMaterials2.Length; m++)
				{
					if (gOMaterials2[m] != null)
					{
						if (!dictionary2.TryGetValue(gOMaterials2[m], out var value2))
						{
							value2 = new List<GameObject>();
							dictionary2.Add(gOMaterials2[m], value2);
						}
						if (!value2.Contains(objsToMesh[l]))
						{
							value2.Add(objsToMesh[l]);
						}
					}
				}
			}
			for (int n = 0; n < resultMaterials.Length; n++)
			{
				string shaderName = ((resultMaterials[n] != null) ? "None" : resultMaterials[n].shader.name);
				MB3_TextureCombinerPipeline.TexturePipelineData texturePipelineData = LoadPipelineData(resultMaterials[n], new List<ShaderTextureProperty>(), objsToMesh, new List<Material>(), new List<MB_TexSet>());
				MB3_TextureCombinerPipeline._CollectPropertyNames(texturePipelineData, LOG_LEVEL);
				foreach (Material key in dictionary2.Keys)
				{
					for (int num = 0; num < texturePipelineData.texPropertyNames.Count; num++)
					{
						if (!key.HasProperty(texturePipelineData.texPropertyNames[num].name))
						{
							continue;
						}
						Texture textureConsideringStandardShaderKeywords = MB3_TextureCombinerPipeline.GetTextureConsideringStandardShaderKeywords(shaderName, key, texturePipelineData.texPropertyNames[num].name);
						if (textureConsideringStandardShaderKeywords != null)
						{
							Vector2 textureOffset = key.GetTextureOffset(texturePipelineData.texPropertyNames[num].name);
							Vector3 vector = key.GetTextureScale(texturePipelineData.texPropertyNames[num].name);
							if (textureOffset.x < 0f || textureOffset.x + vector.x > 1f || textureOffset.y < 0f || textureOffset.y + vector.y > 1f)
							{
								stringBuilder.AppendFormat("\nMaterial {0} used by objects {1} uses texture {2} that is tiled (scale={3} offset={4}). If there is more than one texture in the atlas  then Mesh Baker will bake the tiling into the atlas. If the baked tiling is large then quality can be lost. Possible treatments:\n", key, PrintList(dictionary2[key]), textureConsideringStandardShaderKeywords, vector, textureOffset);
								stringBuilder.AppendFormat("  1) Use the baked tiling.\n");
								stringBuilder.AppendFormat("  2) Use the Multiple Materials feature to map the material on this object/submesh to its own submesh in the combined mesh. No other materials should map to this submesh. The original material can be applied to this submesh.\n");
								stringBuilder.AppendFormat("  3) Combine only meshes that use the same (or subset of) the set of textures on this mesh. The original material can be applied to the result.\n");
							}
						}
					}
				}
			}
			string text = "";
			text = ((stringBuilder.Length != 0) ? ("====== There are possible problems with these meshes that may prevent them from combining well. TREATMENT SUGGESTIONS (copy and paste to text editor if too big) =====\n" + stringBuilder.ToString()) : "====== No problems detected. These meshes should combine well ====\n  If there are problems with the combined meshes please report the problem to digitalOpus.ca so we can improve Mesh Baker.");
			UnityEngine.Debug.Log(text);
		}

		private string PrintList(List<GameObject> gos)
		{
			StringBuilder stringBuilder = new StringBuilder();
			for (int i = 0; i < gos.Count; i++)
			{
				stringBuilder.Append(gos[i]?.ToString() + ",");
			}
			return stringBuilder.ToString();
		}
	}
	public class MeshBakerMaterialTexture
	{
		private Texture2D _t;

		public float texelDensity;

		internal static bool readyToBuildAtlases;

		private DRect encapsulatingSamplingRect;

		public Texture2D t
		{
			set
			{
				_t = value;
			}
		}

		public DRect matTilingRect { get; private set; }

		public bool isNull => _t == null;

		public int width
		{
			get
			{
				if (_t != null)
				{
					return _t.width;
				}
				throw new Exception("Texture was null. can't get width");
			}
		}

		public int height
		{
			get
			{
				if (_t != null)
				{
					return _t.height;
				}
				throw new Exception("Texture was null. can't get height");
			}
		}

		public MeshBakerMaterialTexture()
		{
		}

		public MeshBakerMaterialTexture(Texture tx)
		{
			if (tx is Texture2D)
			{
				_t = (Texture2D)tx;
			}
			else if (!(tx == null))
			{
				UnityEngine.Debug.LogError("An error occured. Texture must be Texture2D " + tx);
			}
		}

		public MeshBakerMaterialTexture(Texture tx, Vector2 matTilingOffset, Vector2 matTilingScale, float texelDens)
		{
			if (tx is Texture2D)
			{
				_t = (Texture2D)tx;
			}
			else if (!(tx == null))
			{
				UnityEngine.Debug.LogError("An error occured. Texture must be Texture2D " + tx);
			}
			matTilingRect = new DRect(matTilingOffset, matTilingScale);
			texelDensity = texelDens;
		}

		public DRect GetEncapsulatingSamplingRect()
		{
			return encapsulatingSamplingRect;
		}

		public void SetEncapsulatingSamplingRect(MB_TexSet ts, DRect r)
		{
			encapsulatingSamplingRect = r;
		}

		public Texture2D GetTexture2D()
		{
			if (!readyToBuildAtlases)
			{
				UnityEngine.Debug.LogError("This function should not be called before Step3. For steps 1 and 2 should always call methods like isNull, width, height");
				throw new Exception("GetTexture2D called before ready to build atlases");
			}
			return _t;
		}

		public string GetTexName()
		{
			if (_t != null)
			{
				return _t.name;
			}
			return "null";
		}

		public bool AreTexturesEqual(MeshBakerMaterialTexture b)
		{
			if (_t == b._t)
			{
				return true;
			}
			return false;
		}
	}
	public class MatAndTransformToMerged
	{
		public Material mat;

		public string objName;

		public DRect obUVRectIfTilingSame { get; private set; }

		public DRect samplingRectMatAndUVTiling { get; private set; }

		public DRect materialTiling { get; private set; }

		public MatAndTransformToMerged(DRect obUVrect, bool fixOutOfBoundsUVs)
		{
			_init(obUVrect, fixOutOfBoundsUVs, null);
		}

		public MatAndTransformToMerged(DRect obUVrect, bool fixOutOfBoundsUVs, Material m)
		{
			_init(obUVrect, fixOutOfBoundsUVs, m);
		}

		private void _init(DRect obUVrect, bool fixOutOfBoundsUVs, Material m)
		{
			if (fixOutOfBoundsUVs)
			{
				obUVRectIfTilingSame = obUVrect;
			}
			else
			{
				obUVRectIfTilingSame = new DRect(0f, 0f, 1f, 1f);
			}
			mat = m;
		}

		public override bool Equals(object obj)
		{
			if (obj is MatAndTransformToMerged)
			{
				MatAndTransformToMerged matAndTransformToMerged = (MatAndTransformToMerged)obj;
				if (matAndTransformToMerged.mat == mat && matAndTransformToMerged.obUVRectIfTilingSame == obUVRectIfTilingSame)
				{
					return true;
				}
			}
			return false;
		}

		public override int GetHashCode()
		{
			return mat.GetHashCode() ^ obUVRectIfTilingSame.GetHashCode() ^ samplingRectMatAndUVTiling.GetHashCode();
		}

		public string GetMaterialName()
		{
			if (mat != null)
			{
				return mat.name;
			}
			if (objName != null)
			{
				return $"[matFor: {objName}]";
			}
			return "Unknown";
		}

		public void AssignInitialValuesForMaterialTilingAndSamplingRectMatAndUVTiling(bool allTexturesUseSameMatTiling, DRect matTiling)
		{
			if (allTexturesUseSameMatTiling)
			{
				materialTiling = matTiling;
			}
			else
			{
				materialTiling = new DRect(0f, 0f, 1f, 1f);
			}
			DRect r = materialTiling;
			DRect r2 = obUVRectIfTilingSame;
			samplingRectMatAndUVTiling = MB3_UVTransformUtility.CombineTransforms(ref r2, ref r);
		}
	}
	public class MatsAndGOs
	{
		public List<MatAndTransformToMerged> mats;

		public List<GameObject> gos;
	}
	public class MB_TexSet
	{
		private interface PipelineVariation
		{
			void GetRectsForTextureBakeResults(out Rect allPropsUseSameTiling_encapsulatingSamplingRect, out Rect propsUseDifferntTiling_obUVRect);

			void SetTilingTreatmentAndAdjustEncapsulatingSamplingRect(MB_TextureTilingTreatment newTilingTreatment);

			Rect GetMaterialTilingRectForTextureBakerResults(int materialIndex);

			void AdjustResultMaterialNonTextureProperties(Material resultMaterial, List<ShaderTextureProperty> props);
		}

		private class PipelineVariationAllTexturesUseSameMatTiling : PipelineVariation
		{
			private MB_TexSet texSet;

			public PipelineVariationAllTexturesUseSameMatTiling(MB_TexSet ts)
			{
				texSet = ts;
			}

			public void GetRectsForTextureBakeResults(out Rect allPropsUseSameTiling_encapsulatingSamplingRect, out Rect propsUseDifferntTiling_obUVRect)
			{
				propsUseDifferntTiling_obUVRect = new Rect(0f, 0f, 0f, 0f);
				allPropsUseSameTiling_encapsulatingSamplingRect = texSet.GetEncapsulatingSamplingRectIfTilingSame();
				if (texSet.tilingTreatment == MB_TextureTilingTreatment.edgeToEdgeX)
				{
					allPropsUseSameTiling_encapsulatingSamplingRect.x = 0f;
					allPropsUseSameTiling_encapsulatingSamplingRect.width = 1f;
				}
				else if (texSet.tilingTreatment == MB_TextureTilingTreatment.edgeToEdgeY)
				{
					allPropsUseSameTiling_encapsulatingSamplingRect.y = 0f;
					allPropsUseSameTiling_encapsulatingSamplingRect.height = 1f;
				}
				else if (texSet.tilingTreatment == MB_TextureTilingTreatment.edgeToEdgeXY)
				{
					allPropsUseSameTiling_encapsulatingSamplingRect = new Rect(0f, 0f, 1f, 1f);
				}
			}

			public void SetTilingTreatmentAndAdjustEncapsulatingSamplingRect(MB_TextureTilingTreatment newTilingTreatment)
			{
				if (texSet.tilingTreatment == MB_TextureTilingTreatment.edgeToEdgeX)
				{
					MeshBakerMaterialTexture[] ts = texSet.ts;
					foreach (MeshBakerMaterialTexture obj in ts)
					{
						DRect encapsulatingSamplingRect = obj.GetEncapsulatingSamplingRect();
						encapsulatingSamplingRect.width = 1.0;
						obj.SetEncapsulatingSamplingRect(texSet, encapsulatingSamplingRect);
					}
				}
				else if (texSet.tilingTreatment == MB_TextureTilingTreatment.edgeToEdgeY)
				{
					MeshBakerMaterialTexture[] ts = texSet.ts;
					foreach (MeshBakerMaterialTexture obj2 in ts)
					{
						DRect encapsulatingSamplingRect2 = obj2.GetEncapsulatingSamplingRect();
						encapsulatingSamplingRect2.height = 1.0;
						obj2.SetEncapsulatingSamplingRect(texSet, encapsulatingSamplingRect2);
					}
				}
				else if (texSet.tilingTreatment == MB_TextureTilingTreatment.edgeToEdgeXY)
				{
					MeshBakerMaterialTexture[] ts = texSet.ts;
					foreach (MeshBakerMaterialTexture obj3 in ts)
					{
						DRect encapsulatingSamplingRect3 = obj3.GetEncapsulatingSamplingRect();
						encapsulatingSamplingRect3.height = 1.0;
						encapsulatingSamplingRect3.width = 1.0;
						obj3.SetEncapsulatingSamplingRect(texSet, encapsulatingSamplingRect3);
					}
				}
			}

			public Rect GetMaterialTilingRectForTextureBakerResults(int materialIndex)
			{
				return texSet.matsAndGOs.mats[materialIndex].materialTiling.GetRect();
			}

			public void AdjustResultMaterialNonTextureProperties(Material resultMaterial, List<ShaderTextureProperty> props)
			{
			}
		}

		private class PipelineVariationSomeTexturesUseDifferentMatTiling : PipelineVariation
		{
			private MB_TexSet texSet;

			public PipelineVariationSomeTexturesUseDifferentMatTiling(MB_TexSet ts)
			{
				texSet = ts;
			}

			public void GetRectsForTextureBakeResults(out Rect allPropsUseSameTiling_encapsulatingSamplingRect, out Rect propsUseDifferntTiling_obUVRect)
			{
				allPropsUseSameTiling_encapsulatingSamplingRect = new Rect(0f, 0f, 0f, 0f);
				propsUseDifferntTiling_obUVRect = texSet.obUVrect.GetRect();
				if (texSet.tilingTreatment == MB_TextureTilingTreatment.edgeToEdgeX)
				{
					propsUseDifferntTiling_obUVRect.x = 0f;
					propsUseDifferntTiling_obUVRect.width = 1f;
				}
				else if (texSet.tilingTreatment == MB_TextureTilingTreatment.edgeToEdgeY)
				{
					propsUseDifferntTiling_obUVRect.y = 0f;
					propsUseDifferntTiling_obUVRect.height = 1f;
				}
				else if (texSet.tilingTreatment == MB_TextureTilingTreatment.edgeToEdgeXY)
				{
					propsUseDifferntTiling_obUVRect = new Rect(0f, 0f, 1f, 1f);
				}
			}

			public void SetTilingTreatmentAndAdjustEncapsulatingSamplingRect(MB_TextureTilingTreatment newTilingTreatment)
			{
				if (texSet.tilingTreatment == MB_TextureTilingTreatment.edgeToEdgeX)
				{
					MeshBakerMaterialTexture[] ts = texSet.ts;
					foreach (MeshBakerMaterialTexture obj in ts)
					{
						DRect encapsulatingSamplingRect = obj.GetEncapsulatingSamplingRect();
						encapsulatingSamplingRect.width = 1.0;
						obj.SetEncapsulatingSamplingRect(texSet, encapsulatingSamplingRect);
					}
				}
				else if (texSet.tilingTreatment == MB_TextureTilingTreatment.edgeToEdgeY)
				{
					MeshBakerMaterialTexture[] ts = texSet.ts;
					foreach (MeshBakerMaterialTexture obj2 in ts)
					{
						DRect encapsulatingSamplingRect2 = obj2.GetEncapsulatingSamplingRect();
						encapsulatingSamplingRect2.height = 1.0;
						obj2.SetEncapsulatingSamplingRect(texSet, encapsulatingSamplingRect2);
					}
				}
				else if (texSet.tilingTreatment == MB_TextureTilingTreatment.edgeToEdgeXY)
				{
					MeshBakerMaterialTexture[] ts = texSet.ts;
					foreach (MeshBakerMaterialTexture obj3 in ts)
					{
						DRect encapsulatingSamplingRect3 = obj3.GetEncapsulatingSamplingRect();
						encapsulatingSamplingRect3.height = 1.0;
						encapsulatingSamplingRect3.width = 1.0;
						obj3.SetEncapsulatingSamplingRect(texSet, encapsulatingSamplingRect3);
					}
				}
			}

			public Rect GetMaterialTilingRectForTextureBakerResults(int materialIndex)
			{
				return new Rect(0f, 0f, 0f, 0f);
			}

			public void AdjustResultMaterialNonTextureProperties(Material resultMaterial, List<ShaderTextureProperty> props)
			{
				if (!texSet.thisIsOnlyTexSetInAtlas)
				{
					return;
				}
				for (int i = 0; i < props.Count; i++)
				{
					if (resultMaterial.HasProperty(props[i].name))
					{
						resultMaterial.SetTextureOffset(props[i].name, texSet.ts[i].matTilingRect.min);
						resultMaterial.SetTextureScale(props[i].name, texSet.ts[i].matTilingRect.size);
					}
				}
			}
		}

		public MeshBakerMaterialTexture[] ts;

		public MatsAndGOs matsAndGOs;

		public int idealWidth;

		public int idealHeight;

		private PipelineVariation pipelineVariation;

		public bool allTexturesUseSameMatTiling { get; private set; }

		public bool thisIsOnlyTexSetInAtlas { get; private set; }

		public MB_TextureTilingTreatment tilingTreatment { get; private set; }

		public Vector2 obUVoffset { get; private set; }

		public Vector2 obUVscale { get; private set; }

		internal DRect obUVrect => new DRect(obUVoffset, obUVscale);

		public MB_TexSet(MeshBakerMaterialTexture[] tss, Vector2 uvOffset, Vector2 uvScale, MB_TextureTilingTreatment treatment)
		{
			ts = tss;
			tilingTreatment = treatment;
			obUVoffset = uvOffset;
			obUVscale = uvScale;
			allTexturesUseSameMatTiling = false;
			thisIsOnlyTexSetInAtlas = false;
			matsAndGOs = new MatsAndGOs();
			matsAndGOs.mats = new List<MatAndTransformToMerged>();
			matsAndGOs.gos = new List<GameObject>();
			pipelineVariation = new PipelineVariationSomeTexturesUseDifferentMatTiling(this);
		}

		internal bool IsEqual(object obj, bool fixOutOfBoundsUVs, MB3_TextureCombinerNonTextureProperties resultMaterialTextureBlender)
		{
			if (!(obj is MB_TexSet))
			{
				return false;
			}
			MB_TexSet mB_TexSet = (MB_TexSet)obj;
			if (mB_TexSet.ts.Length != ts.Length)
			{
				return false;
			}
			for (int i = 0; i < ts.Length; i++)
			{
				if (ts[i].matTilingRect != mB_TexSet.ts[i].matTilingRect)
				{
					return false;
				}
				if (!ts[i].AreTexturesEqual(mB_TexSet.ts[i]))
				{
					return false;
				}
				if (!resultMaterialTextureBlender.NonTexturePropertiesAreEqual(matsAndGOs.mats[0].mat, mB_TexSet.matsAndGOs.mats[0].mat))
				{
					return false;
				}
			}
			if (fixOutOfBoundsUVs && (obUVoffset.x != mB_TexSet.obUVoffset.x || obUVoffset.y != mB_TexSet.obUVoffset.y))
			{
				return false;
			}
			if (fixOutOfBoundsUVs && (obUVscale.x != mB_TexSet.obUVscale.x || obUVscale.y != mB_TexSet.obUVscale.y))
			{
				return false;
			}
			return true;
		}

		private Rect GetEncapsulatingSamplingRectIfTilingSame()
		{
			if (ts.Length != 0)
			{
				return ts[0].GetEncapsulatingSamplingRect().GetRect();
			}
			return new Rect(0f, 0f, 1f, 1f);
		}

		public void SetEncapsulatingSamplingRectWhenMergingTexSets(DRect newEncapsulatingSamplingRect)
		{
			for (int i = 0; i < ts.Length; i++)
			{
				ts[i].SetEncapsulatingSamplingRect(this, newEncapsulatingSamplingRect);
			}
		}

		public void SetEncapsulatingSamplingRectForTesting(int propIdx, DRect newEncapsulatingSamplingRect)
		{
			ts[propIdx].SetEncapsulatingSamplingRect(this, newEncapsulatingSamplingRect);
		}

		public void SetEncapsulatingRect(int propIdx, bool considerMeshUVs)
		{
			if (considerMeshUVs)
			{
				ts[propIdx].SetEncapsulatingSamplingRect(this, obUVrect);
			}
			else
			{
				ts[propIdx].SetEncapsulatingSamplingRect(this, new DRect(0f, 0f, 1f, 1f));
			}
		}

		public void CreateColoredTexToReplaceNull(string propName, int propIdx, bool considerMeshUVs, MB3_TextureCombiner combiner, Color col)
		{
			MeshBakerMaterialTexture obj = ts[propIdx];
			obj.t = combiner._createTemporaryTexture(propName, 16, 16, TextureFormat.ARGB32, mipMaps: true);
			MB_Utility.setSolidColor(obj.GetTexture2D(), col);
		}

		public void SetThisIsOnlyTexSetInAtlasTrue()
		{
			thisIsOnlyTexSetInAtlas = true;
		}

		public void SetAllTexturesUseSameMatTilingTrue()
		{
			allTexturesUseSameMatTiling = true;
			pipelineVariation = new PipelineVariationAllTexturesUseSameMatTiling(this);
		}

		public void AdjustResultMaterialNonTextureProperties(Material resultMaterial, List<ShaderTextureProperty> props)
		{
			pipelineVariation.AdjustResultMaterialNonTextureProperties(resultMaterial, props);
		}

		public void SetTilingTreatmentAndAdjustEncapsulatingSamplingRect(MB_TextureTilingTreatment newTilingTreatment)
		{
			tilingTreatment = newTilingTreatment;
			pipelineVariation.SetTilingTreatmentAndAdjustEncapsulatingSamplingRect(newTilingTreatment);
		}

		internal void GetRectsForTextureBakeResults(out Rect allPropsUseSameTiling_encapsulatingSamplingRect, out Rect propsUseDifferntTiling_obUVRect)
		{
			pipelineVariation.GetRectsForTextureBakeResults(out allPropsUseSameTiling_encapsulatingSamplingRect, out propsUseDifferntTiling_obUVRect);
		}

		internal Rect GetMaterialTilingRectForTextureBakerResults(int materialIndex)
		{
			return pipelineVariation.GetMaterialTilingRectForTextureBakerResults(materialIndex);
		}

		internal void CalcInitialFullSamplingRects(bool fixOutOfBoundsUVs)
		{
			DRect r = new DRect(0f, 0f, 1f, 1f);
			if (fixOutOfBoundsUVs)
			{
				r = obUVrect;
			}
			for (int i = 0; i < ts.Length; i++)
			{
				if (!ts[i].isNull)
				{
					DRect r2 = ts[i].matTilingRect;
					DRect r3 = ((!fixOutOfBoundsUVs) ? new DRect(0.0, 0.0, 1.0, 1.0) : obUVrect);
					ts[i].SetEncapsulatingSamplingRect(this, MB3_UVTransformUtility.CombineTransforms(ref r3, ref r2));
					r = ts[i].GetEncapsulatingSamplingRect();
				}
			}
			for (int j = 0; j < ts.Length; j++)
			{
				if (ts[j].isNull)
				{
					ts[j].SetEncapsulatingSamplingRect(this, r);
				}
			}
		}

		internal void CalcMatAndUVSamplingRects()
		{
			DRect matTiling = new DRect(0f, 0f, 1f, 1f);
			if (allTexturesUseSameMatTiling)
			{
				for (int i = 0; i < ts.Length; i++)
				{
					if (!ts[i].isNull)
					{
						matTiling = ts[i].matTilingRect;
						break;
					}
				}
			}
			for (int j = 0; j < matsAndGOs.mats.Count; j++)
			{
				matsAndGOs.mats[j].AssignInitialValuesForMaterialTilingAndSamplingRectMatAndUVTiling(allTexturesUseSameMatTiling, matTiling);
			}
		}

		public bool AllTexturesAreSameForMerge(MB_TexSet other, bool considerNonTextureProperties, MB3_TextureCombinerNonTextureProperties resultMaterialTextureBlender)
		{
			if (other.ts.Length != ts.Length)
			{
				return false;
			}
			if (!other.allTexturesUseSameMatTiling || !allTexturesUseSameMatTiling)
			{
				return false;
			}
			int num = -1;
			for (int i = 0; i < ts.Length; i++)
			{
				if (!ts[i].AreTexturesEqual(other.ts[i]))
				{
					return false;
				}
				if (num == -1 && !ts[i].isNull)
				{
					num = i;
				}
				if (considerNonTextureProperties && !resultMaterialTextureBlender.NonTexturePropertiesAreEqual(matsAndGOs.mats[0].mat, other.matsAndGOs.mats[0].mat))
				{
					return false;
				}
			}
			if (num != -1)
			{
				for (int j = 0; j < ts.Length; j++)
				{
					if (!ts[j].AreTexturesEqual(other.ts[j]))
					{
						return false;
					}
				}
			}
			return true;
		}

		internal void DrawRectsToMergeGizmos(Color encC, Color innerC)
		{
			DRect A = ts[0].GetEncapsulatingSamplingRect();
			A.Expand(0.05f);
			Gizmos.color = encC;
			Gizmos.DrawWireCube(A.center.GetVector2(), A.size);
			for (int i = 0; i < matsAndGOs.mats.Count; i++)
			{
				DRect B = matsAndGOs.mats[i].samplingRectMatAndUVTiling;
				DRect r = MB3_UVTransformUtility.GetShiftTransformToFitBinA(ref A, ref B);
				Vector2 vector = MB3_UVTransformUtility.TransformPoint(ref r, B.min);
				B.x = vector.x;
				B.y = vector.y;
				Gizmos.color = innerC;
				Gizmos.DrawWireCube(B.center.GetVector2(), B.size);
			}
		}

		internal string GetDescription()
		{
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.AppendFormat("[GAME_OBJS=");
			for (int i = 0; i < matsAndGOs.gos.Count; i++)
			{
				stringBuilder.AppendFormat("{0},", matsAndGOs.gos[i].name);
			}
			stringBuilder.AppendFormat("MATS=");
			for (int j = 0; j < matsAndGOs.mats.Count; j++)
			{
				stringBuilder.AppendFormat("{0},", matsAndGOs.mats[j].GetMaterialName());
			}
			stringBuilder.Append("]");
			return stringBuilder.ToString();
		}

		internal string GetMatSubrectDescriptions()
		{
			StringBuilder stringBuilder = new StringBuilder();
			for (int i = 0; i < matsAndGOs.mats.Count; i++)
			{
				stringBuilder.AppendFormat("\n    {0}={1},", matsAndGOs.mats[i].GetMaterialName(), matsAndGOs.mats[i].samplingRectMatAndUVTiling);
			}
			return stringBuilder.ToString();
		}
	}
	public class MB3_TextureCombinerMerging
	{
		private bool _considerNonTextureProperties;

		private MB3_TextureCombinerNonTextureProperties resultMaterialTextureBlender;

		private bool fixOutOfBoundsUVs = true;

		public MB2_LogLevel LOG_LEVEL = MB2_LogLevel.info;

		private static bool LOG_LEVEL_TRACE_MERGE_MAT_SUBRECTS;

		public static Rect BuildTransformMeshUV2AtlasRect(bool considerMeshUVs, Rect _atlasRect, Rect _obUVRect, Rect _sourceMaterialTiling, Rect _encapsulatingRect)
		{
			DRect r = new DRect(_atlasRect);
			DRect t = ((!considerMeshUVs) ? new DRect(0.0, 0.0, 1.0, 1.0) : new DRect(_obUVRect));
			DRect r2 = new DRect(_sourceMaterialTiling);
			DRect t2 = new DRect(_encapsulatingRect);
			DRect r3 = MB3_UVTransformUtility.InverseTransform(ref t2);
			DRect r4 = MB3_UVTransformUtility.InverseTransform(ref t);
			DRect B = MB3_UVTransformUtility.CombineTransforms(ref t, ref r2);
			DRect r5 = MB3_UVTransformUtility.GetShiftTransformToFitBinA(ref t2, ref B);
			B = MB3_UVTransformUtility.CombineTransforms(ref B, ref r5);
			DRect r6 = MB3_UVTransformUtility.CombineTransforms(ref B, ref r3);
			DRect r7 = MB3_UVTransformUtility.CombineTransforms(ref r4, ref r6);
			return MB3_UVTransformUtility.CombineTransforms(ref r7, ref r).GetRect();
		}

		public MB3_TextureCombinerMerging(bool considerNonTextureProps, MB3_TextureCombinerNonTextureProperties resultMaterialTexBlender, bool fixObUVs, MB2_LogLevel logLevel)
		{
			LOG_LEVEL = logLevel;
			_considerNonTextureProperties = considerNonTextureProps;
			resultMaterialTextureBlender = resultMaterialTexBlender;
			fixOutOfBoundsUVs = fixObUVs;
		}

		public void MergeOverlappingDistinctMaterialTexturesAndCalcMaterialSubrects(List<MB_TexSet> distinctMaterialTextures)
		{
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log("MergeOverlappingDistinctMaterialTexturesAndCalcMaterialSubrects");
			}
			int num = 0;
			for (int i = 0; i < distinctMaterialTextures.Count; i++)
			{
				MB_TexSet mB_TexSet = distinctMaterialTextures[i];
				int num2 = -1;
				bool flag = true;
				DRect dRect = default(DRect);
				for (int j = 0; j < mB_TexSet.ts.Length; j++)
				{
					if (num2 != -1)
					{
						if (!mB_TexSet.ts[j].isNull && dRect != mB_TexSet.ts[j].matTilingRect)
						{
							flag = false;
						}
					}
					else if (!mB_TexSet.ts[j].isNull)
					{
						num2 = j;
						dRect = mB_TexSet.ts[j].matTilingRect;
					}
				}
				if (LOG_LEVEL >= MB2_LogLevel.debug || LOG_LEVEL_TRACE_MERGE_MAT_SUBRECTS)
				{
					if (flag)
					{
						UnityEngine.Debug.LogFormat("TextureSet {0} allTexturesUseSameMatTiling = {1}", i, flag);
					}
					else
					{
						UnityEngine.Debug.Log($"Textures in material(s) do not all use the same material tiling. This set of textures will not be considered for merge: {mB_TexSet.GetDescription()} ");
					}
				}
				if (flag)
				{
					mB_TexSet.SetAllTexturesUseSameMatTilingTrue();
				}
			}
			for (int k = 0; k < distinctMaterialTextures.Count; k++)
			{
				MB_TexSet mB_TexSet2 = distinctMaterialTextures[k];
				for (int l = 0; l < mB_TexSet2.matsAndGOs.mats.Count; l++)
				{
					if (mB_TexSet2.matsAndGOs.gos.Count > 0)
					{
						mB_TexSet2.matsAndGOs.mats[l].objName = mB_TexSet2.matsAndGOs.gos[0].name;
					}
					else if (mB_TexSet2.ts[0] != null)
					{
						mB_TexSet2.matsAndGOs.mats[l].objName = $"[objWithTx:{mB_TexSet2.ts[0].GetTexName()} atlasBlock:{k} matIdx{l}]";
					}
					else
					{
						mB_TexSet2.matsAndGOs.mats[l].objName = string.Format("[objWithTx:{0} atlasBlock:{1} matIdx{2}]", "Unknown", k, l);
					}
				}
				mB_TexSet2.CalcInitialFullSamplingRects(fixOutOfBoundsUVs);
				mB_TexSet2.CalcMatAndUVSamplingRects();
			}
			List<int> list = new List<int>();
			for (int m = 0; m < distinctMaterialTextures.Count; m++)
			{
				MB_TexSet mB_TexSet3 = distinctMaterialTextures[m];
				for (int n = m + 1; n < distinctMaterialTextures.Count; n++)
				{
					MB_TexSet mB_TexSet4 = distinctMaterialTextures[n];
					if (!mB_TexSet4.AllTexturesAreSameForMerge(mB_TexSet3, _considerNonTextureProperties, resultMaterialTextureBlender))
					{
						continue;
					}
					double num3 = 0.0;
					double num4 = 0.0;
					DRect dRect2 = default(DRect);
					int num5 = -1;
					for (int num6 = 0; num6 < mB_TexSet3.ts.Length; num6++)
					{
						if (!mB_TexSet3.ts[num6].isNull && num5 == -1)
						{
							num5 = num6;
						}
					}
					if (num5 != -1)
					{
						DRect uvRect = mB_TexSet4.matsAndGOs.mats[0].samplingRectMatAndUVTiling;
						for (int num7 = 1; num7 < mB_TexSet4.matsAndGOs.mats.Count; num7++)
						{
							DRect willBeIn = mB_TexSet4.matsAndGOs.mats[num7].samplingRectMatAndUVTiling;
							uvRect = MB3_UVTransformUtility.GetEncapsulatingRectShifted(ref uvRect, ref willBeIn);
						}
						DRect uvRect2 = mB_TexSet3.matsAndGOs.mats[0].samplingRectMatAndUVTiling;
						for (int num8 = 1; num8 < mB_TexSet3.matsAndGOs.mats.Count; num8++)
						{
							DRect willBeIn2 = mB_TexSet3.matsAndGOs.mats[num8].samplingRectMatAndUVTiling;
							uvRect2 = MB3_UVTransformUtility.GetEncapsulatingRectShifted(ref uvRect2, ref willBeIn2);
						}
						dRect2 = MB3_UVTransformUtility.GetEncapsulatingRectShifted(ref uvRect, ref uvRect2);
						num3 += dRect2.width * dRect2.height;
						num4 += uvRect.width * uvRect.height + uvRect2.width * uvRect2.height;
					}
					else
					{
						dRect2 = new DRect(0f, 0f, 1f, 1f);
					}
					if (num3 < num4)
					{
						num++;
						StringBuilder stringBuilder = null;
						if (LOG_LEVEL >= MB2_LogLevel.info)
						{
							stringBuilder = new StringBuilder();
							stringBuilder.AppendFormat("About To Merge:\n   TextureSet1 {0}\n   TextureSet2 {1}\n", mB_TexSet4.GetDescription(), mB_TexSet3.GetDescription());
							if (LOG_LEVEL >= MB2_LogLevel.trace)
							{
								for (int num9 = 0; num9 < mB_TexSet4.matsAndGOs.mats.Count; num9++)
								{
									stringBuilder.AppendFormat("tx1 Mat {0} matAndMeshUVRect {1} fullSamplingRect {2}\n", mB_TexSet4.matsAndGOs.mats[num9].mat, mB_TexSet4.matsAndGOs.mats[num9].samplingRectMatAndUVTiling, mB_TexSet4.ts[0].GetEncapsulatingSamplingRect());
								}
								for (int num10 = 0; num10 < mB_TexSet3.matsAndGOs.mats.Count; num10++)
								{
									stringBuilder.AppendFormat("tx2 Mat {0} matAndMeshUVRect {1} fullSamplingRect {2}\n", mB_TexSet3.matsAndGOs.mats[num10].mat, mB_TexSet3.matsAndGOs.mats[num10].samplingRectMatAndUVTiling, mB_TexSet3.ts[0].GetEncapsulatingSamplingRect());
								}
							}
						}
						for (int num11 = 0; num11 < mB_TexSet3.matsAndGOs.gos.Count; num11++)
						{
							if (!mB_TexSet4.matsAndGOs.gos.Contains(mB_TexSet3.matsAndGOs.gos[num11]))
							{
								mB_TexSet4.matsAndGOs.gos.Add(mB_TexSet3.matsAndGOs.gos[num11]);
							}
						}
						for (int num12 = 0; num12 < mB_TexSet3.matsAndGOs.mats.Count; num12++)
						{
							mB_TexSet4.matsAndGOs.mats.Add(mB_TexSet3.matsAndGOs.mats[num12]);
						}
						mB_TexSet4.SetEncapsulatingSamplingRectWhenMergingTexSets(dRect2);
						if (!list.Contains(m))
						{
							list.Add(m);
						}
						if (LOG_LEVEL < MB2_LogLevel.debug)
						{
							break;
						}
						if (LOG_LEVEL >= MB2_LogLevel.trace)
						{
							stringBuilder.AppendFormat("=== After Merge TextureSet {0}\n", mB_TexSet4.GetDescription());
							for (int num13 = 0; num13 < mB_TexSet4.matsAndGOs.mats.Count; num13++)
							{
								stringBuilder.AppendFormat("tx1 Mat {0} matAndMeshUVRect {1} fullSamplingRect {2}\n", mB_TexSet4.matsAndGOs.mats[num13].mat, mB_TexSet4.matsAndGOs.mats[num13].samplingRectMatAndUVTiling, mB_TexSet4.ts[0].GetEncapsulatingSamplingRect());
							}
							if (MB3_MeshBakerRoot.DO_INTEGRITY_CHECKS && MB3_MeshBakerRoot.DO_INTEGRITY_CHECKS)
							{
								DoIntegrityCheckMergedEncapsulatingSamplingRects(distinctMaterialTextures);
							}
						}
						UnityEngine.Debug.Log(stringBuilder.ToString());
						break;
					}
					if (LOG_LEVEL >= MB2_LogLevel.debug)
					{
						UnityEngine.Debug.Log($"Considered merging {mB_TexSet4.GetDescription()} and {mB_TexSet3.GetDescription()} but there was not enough overlap. It is more efficient to bake these to separate rectangles.");
					}
				}
			}
			for (int num14 = list.Count - 1; num14 >= 0; num14--)
			{
				distinctMaterialTextures.RemoveAt(list[num14]);
			}
			list.Clear();
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log($"MergeOverlappingDistinctMaterialTexturesAndCalcMaterialSubrects complete merged {num} now have {distinctMaterialTextures.Count}");
			}
			if (MB3_MeshBakerRoot.DO_INTEGRITY_CHECKS)
			{
				DoIntegrityCheckMergedEncapsulatingSamplingRects(distinctMaterialTextures);
			}
		}

		public void DoIntegrityCheckMergedEncapsulatingSamplingRects(List<MB_TexSet> distinctMaterialTextures)
		{
			if (!MB3_MeshBakerRoot.DO_INTEGRITY_CHECKS)
			{
				return;
			}
			for (int i = 0; i < distinctMaterialTextures.Count; i++)
			{
				MB_TexSet mB_TexSet = distinctMaterialTextures[i];
				if (!mB_TexSet.allTexturesUseSameMatTiling)
				{
					continue;
				}
				for (int j = 0; j < mB_TexSet.matsAndGOs.mats.Count; j++)
				{
					MatAndTransformToMerged matAndTransformToMerged = mB_TexSet.matsAndGOs.mats[j];
					DRect obUVRectIfTilingSame = matAndTransformToMerged.obUVRectIfTilingSame;
					DRect materialTiling = matAndTransformToMerged.materialTiling;
					if (!MB2_TextureBakeResults.IsMeshAndMaterialRectEnclosedByAtlasRect(mB_TexSet.tilingTreatment, obUVRectIfTilingSame.GetRect(), materialTiling.GetRect(), mB_TexSet.ts[0].GetEncapsulatingSamplingRect().GetRect(), MB2_LogLevel.info))
					{
						string[] obj = new string[11]
						{
							"mesh ",
							mB_TexSet.matsAndGOs.mats[j].objName,
							"\n uv=",
							null,
							null,
							null,
							null,
							null,
							null,
							null,
							null
						};
						DRect dRect = obUVRectIfTilingSame;
						obj[3] = dRect.ToString();
						obj[4] = "\n mat=";
						obj[5] = materialTiling.GetRect().ToString("f5");
						obj[6] = "\n samplingRect=";
						obj[7] = mB_TexSet.matsAndGOs.mats[j].samplingRectMatAndUVTiling.GetRect().ToString("f4");
						obj[8] = "\n encapsulatingRect ";
						obj[9] = mB_TexSet.ts[0].GetEncapsulatingSamplingRect().GetRect().ToString("f4");
						obj[10] = "\n";
						UnityEngine.Debug.LogErrorFormat(string.Concat(obj));
						UnityEngine.Debug.LogErrorFormat(string.Format("Integrity check failed. " + mB_TexSet.matsAndGOs.mats[j].objName + " Encapsulating sampling rect failed to contain potentialRect\n"));
						MB2_TextureBakeResults.IsMeshAndMaterialRectEnclosedByAtlasRect(mB_TexSet.tilingTreatment, obUVRectIfTilingSame.GetRect(), materialTiling.GetRect(), mB_TexSet.ts[0].GetEncapsulatingSamplingRect().GetRect(), MB2_LogLevel.trace);
					}
				}
			}
		}
	}
	public class MB3_TextureCombinerNonTextureProperties
	{
		public interface MaterialProperty
		{
			string PropertyName { get; set; }

			MaterialPropertyValueAveraged GetAverageCalculator();

			object GetDefaultValue();
		}

		public class MaterialPropertyFloat : MaterialProperty
		{
			private MaterialPropertyValueAveragedFloat _averageCalc;

			private float _defaultValue;

			public string PropertyName { get; set; }

			public MaterialPropertyFloat(string name, float defValue)
			{
				_averageCalc = new MaterialPropertyValueAveragedFloat();
				_defaultValue = defValue;
				PropertyName = name;
			}

			public MaterialPropertyValueAveraged GetAverageCalculator()
			{
				return _averageCalc;
			}

			public object GetDefaultValue()
			{
				return _defaultValue;
			}
		}

		public class MaterialPropertyColor : MaterialProperty
		{
			private MaterialPropertyValueAveragedColor _averageCalc;

			private Color _defaultValue;

			public string PropertyName { get; set; }

			public MaterialPropertyColor(string name, Color defaultVal)
			{
				_averageCalc = new MaterialPropertyValueAveragedColor();
				_defaultValue = defaultVal;
				PropertyName = name;
			}

			public MaterialPropertyValueAveraged GetAverageCalculator()
			{
				return _averageCalc;
			}

			public object GetDefaultValue()
			{
				return _defaultValue;
			}
		}

		public interface MaterialPropertyValueAveraged
		{
			void TryGetPropValueFromMaterialAndBlendIntoAverage(Material mat, MaterialProperty property);

			object GetAverage();

			int NumValues();

			void SetAverageValueOrDefaultOnMaterial(Material mat, MaterialProperty property);
		}

		public class MaterialPropertyValueAveragedFloat : MaterialPropertyValueAveraged
		{
			public float averageVal;

			public int numValues;

			public void TryGetPropValueFromMaterialAndBlendIntoAverage(Material mat, MaterialProperty property)
			{
				if (mat.HasProperty(property.PropertyName))
				{
					float @float = mat.GetFloat(property.PropertyName);
					averageVal = averageVal * (float)numValues / (float)(numValues + 1) + @float / (float)(numValues + 1);
					numValues++;
				}
			}

			public object GetAverage()
			{
				return averageVal;
			}

			public int NumValues()
			{
				return numValues;
			}

			public void SetAverageValueOrDefaultOnMaterial(Material mat, MaterialProperty property)
			{
				if (mat.HasProperty(property.PropertyName))
				{
					if (numValues > 0)
					{
						mat.SetFloat(property.PropertyName, averageVal);
					}
					else
					{
						mat.SetFloat(property.PropertyName, (float)property.GetDefaultValue());
					}
				}
			}
		}

		public class MaterialPropertyValueAveragedColor : MaterialPropertyValueAveraged
		{
			public Color averageVal;

			public int numValues;

			public void TryGetPropValueFromMaterialAndBlendIntoAverage(Material mat, MaterialProperty property)
			{
				if (mat.HasProperty(property.PropertyName))
				{
					Color color = mat.GetColor(property.PropertyName);
					averageVal = averageVal * numValues / (numValues + 1) + color / (numValues + 1);
					numValues++;
				}
			}

			public object GetAverage()
			{
				return averageVal;
			}

			public int NumValues()
			{
				return numValues;
			}

			public void SetAverageValueOrDefaultOnMaterial(Material mat, MaterialProperty property)
			{
				if (mat.HasProperty(property.PropertyName))
				{
					if (numValues > 0)
					{
						mat.SetColor(property.PropertyName, averageVal);
					}
					else
					{
						mat.SetColor(property.PropertyName, (Color)property.GetDefaultValue());
					}
				}
			}
		}

		public struct TexPropertyNameColorPair
		{
			public string name;

			public Color color;

			public TexPropertyNameColorPair(string nm, Color col)
			{
				name = nm;
				color = col;
			}
		}

		private interface NonTextureProperties
		{
			bool NonTexturePropertiesAreEqual(Material a, Material b);

			Texture2D TintTextureWithTextureCombiner(Texture2D t, MB_TexSet sourceMaterial, ShaderTextureProperty shaderPropertyName);

			void AdjustNonTextureProperties(Material resultMat, List<ShaderTextureProperty> texPropertyNames, List<MB_TexSet> distinctMaterialTextures, MB2_EditorMethodsInterface editorMethods);

			Color GetColorForTemporaryTexture(Material matIfBlender, ShaderTextureProperty texProperty);

			Color GetColorAsItWouldAppearInAtlasIfNoTexture(Material matIfBlender, ShaderTextureProperty texProperty);
		}

		private class NonTexturePropertiesDontBlendProps : NonTextureProperties
		{
			private MB3_TextureCombinerNonTextureProperties _textureProperties;

			public NonTexturePropertiesDontBlendProps(MB3_TextureCombinerNonTextureProperties textureProperties)
			{
				_textureProperties = textureProperties;
			}

			public bool NonTexturePropertiesAreEqual(Material a, Material b)
			{
				return true;
			}

			public Texture2D TintTextureWithTextureCombiner(Texture2D t, MB_TexSet sourceMaterial, ShaderTextureProperty shaderPropertyName)
			{
				UnityEngine.Debug.LogError("TintTextureWithTextureCombiner should never be called if resultMaterialTextureBlender is null");
				return t;
			}

			public void AdjustNonTextureProperties(Material resultMat, List<ShaderTextureProperty> texPropertyNames, List<MB_TexSet> distinctMaterialTextures, MB2_EditorMethodsInterface editorMethods)
			{
				if (resultMat == null || texPropertyNames == null)
				{
					return;
				}
				for (int i = 0; i < _textureProperties._nonTextureProperties.Length; i++)
				{
					MaterialProperty materialProperty = _textureProperties._nonTextureProperties[i];
					if (resultMat.HasProperty(materialProperty.PropertyName))
					{
						materialProperty.GetAverageCalculator().SetAverageValueOrDefaultOnMaterial(resultMat, materialProperty);
					}
				}
				editorMethods?.CommitChangesToAssets();
			}

			public Color GetColorAsItWouldAppearInAtlasIfNoTexture(Material matIfBlender, ShaderTextureProperty texProperty)
			{
				return Color.white;
			}

			public Color GetColorForTemporaryTexture(Material matIfBlender, ShaderTextureProperty texProperty)
			{
				if (texProperty.isNormalMap)
				{
					return NEUTRAL_NORMAL_MAP_COLOR;
				}
				if (_textureProperties.textureProperty2DefaultColorMap.ContainsKey(texProperty.name))
				{
					return _textureProperties.textureProperty2DefaultColorMap[texProperty.name];
				}
				return new Color(1f, 1f, 1f, 0f);
			}
		}

		private class NonTexturePropertiesBlendProps : NonTextureProperties
		{
			private MB3_TextureCombinerNonTextureProperties _textureProperties;

			private TextureBlender resultMaterialTextureBlender;

			public NonTexturePropertiesBlendProps(MB3_TextureCombinerNonTextureProperties textureProperties, TextureBlender resultMats)
			{
				resultMaterialTextureBlender = resultMats;
				_textureProperties = textureProperties;
			}

			public bool NonTexturePropertiesAreEqual(Material a, Material b)
			{
				return resultMaterialTextureBlender.NonTexturePropertiesAreEqual(a, b);
			}

			public Texture2D TintTextureWithTextureCombiner(Texture2D t, MB_TexSet sourceMaterial, ShaderTextureProperty shaderPropertyName)
			{
				resultMaterialTextureBlender.OnBeforeTintTexture(sourceMaterial.matsAndGOs.mats[0].mat, shaderPropertyName.name);
				if (_textureProperties.LOG_LEVEL >= MB2_LogLevel.trace)
				{
					UnityEngine.Debug.Log($"Blending texture {t.name} mat {sourceMaterial.matsAndGOs.mats[0].mat} with non-texture properties using TextureBlender {resultMaterialTextureBlender}");
				}
				for (int i = 0; i < t.height; i++)
				{
					Color[] pixels = t.GetPixels(0, i, t.width, 1);
					for (int j = 0; j < pixels.Length; j++)
					{
						pixels[j] = resultMaterialTextureBlender.OnBlendTexturePixel(shaderPropertyName.name, pixels[j]);
					}
					t.SetPixels(0, i, t.width, 1, pixels);
				}
				t.Apply();
				return t;
			}

			public void AdjustNonTextureProperties(Material resultMat, List<ShaderTextureProperty> texPropertyNames, List<MB_TexSet> distinctMaterialTextures, MB2_EditorMethodsInterface editorMethods)
			{
				if (!(resultMat == null) && texPropertyNames != null)
				{
					if (_textureProperties.LOG_LEVEL >= MB2_LogLevel.debug)
					{
						UnityEngine.Debug.Log("Adjusting non texture properties using TextureBlender for shader: " + resultMat.shader.name);
					}
					resultMaterialTextureBlender.SetNonTexturePropertyValuesOnResultMaterial(resultMat);
					editorMethods?.CommitChangesToAssets();
				}
			}

			public Color GetColorAsItWouldAppearInAtlasIfNoTexture(Material matIfBlender, ShaderTextureProperty texProperty)
			{
				resultMaterialTextureBlender.OnBeforeTintTexture(matIfBlender, texProperty.name);
				Color colorForTemporaryTexture = GetColorForTemporaryTexture(matIfBlender, texProperty);
				return resultMaterialTextureBlender.OnBlendTexturePixel(texProperty.name, colorForTemporaryTexture);
			}

			public Color GetColorForTemporaryTexture(Material matIfBlender, ShaderTextureProperty texProperty)
			{
				return resultMaterialTextureBlender.GetColorIfNoTexture(matIfBlender, texProperty);
			}
		}

		public static Color NEUTRAL_NORMAL_MAP_COLOR = new Color(0.5f, 0.5f, 1f);

		private TexPropertyNameColorPair[] defaultTextureProperty2DefaultColorMap = new TexPropertyNameColorPair[6]
		{
			new TexPropertyNameColorPair("_MainTex", new Color(1f, 1f, 1f, 0f)),
			new TexPropertyNameColorPair("_MetallicGlossMap", new Color(0f, 0f, 0f, 1f)),
			new TexPropertyNameColorPair("_ParallaxMap", new Color(0f, 0f, 0f, 0f)),
			new TexPropertyNameColorPair("_OcclusionMap", new Color(1f, 1f, 1f, 1f)),
			new TexPropertyNameColorPair("_EmissionMap", new Color(0f, 0f, 0f, 0f)),
			new TexPropertyNameColorPair("_DetailMask", new Color(0f, 0f, 0f, 0f))
		};

		private MaterialProperty[] _nonTextureProperties = new MaterialProperty[8]
		{
			new MaterialPropertyColor("_Color", Color.white),
			new MaterialPropertyFloat("_Glossiness", 0.5f),
			new MaterialPropertyFloat("_GlossMapScale", 1f),
			new MaterialPropertyFloat("_Metallic", 0f),
			new MaterialPropertyFloat("_BumpScale", 0.1f),
			new MaterialPropertyFloat("_Parallax", 0.02f),
			new MaterialPropertyFloat("_OcclusionStrength", 1f),
			new MaterialPropertyColor("_EmissionColor", Color.black)
		};

		private MB2_LogLevel LOG_LEVEL = MB2_LogLevel.info;

		private bool _considerNonTextureProperties;

		private TextureBlender resultMaterialTextureBlender;

		private TextureBlender[] textureBlenders = new TextureBlender[0];

		private Dictionary<string, Color> textureProperty2DefaultColorMap = new Dictionary<string, Color>();

		private NonTextureProperties _nonTexturePropertiesBlender;

		public MB3_TextureCombinerNonTextureProperties(MB2_LogLevel ll, bool considerNonTextureProps)
		{
			LOG_LEVEL = ll;
			_considerNonTextureProperties = considerNonTextureProps;
			textureProperty2DefaultColorMap = new Dictionary<string, Color>();
			for (int i = 0; i < defaultTextureProperty2DefaultColorMap.Length; i++)
			{
				textureProperty2DefaultColorMap.Add(defaultTextureProperty2DefaultColorMap[i].name, defaultTextureProperty2DefaultColorMap[i].color);
				_nonTexturePropertiesBlender = new NonTexturePropertiesDontBlendProps(this);
			}
		}

		internal void CollectAverageValuesOfNonTextureProperties(Material resultMaterial, Material mat)
		{
			for (int i = 0; i < _nonTextureProperties.Length; i++)
			{
				MaterialProperty materialProperty = _nonTextureProperties[i];
				if (resultMaterial.HasProperty(materialProperty.PropertyName))
				{
					materialProperty.GetAverageCalculator().TryGetPropValueFromMaterialAndBlendIntoAverage(mat, materialProperty);
				}
			}
		}

		internal void LoadTextureBlendersIfNeeded(Material resultMaterial)
		{
			if (_considerNonTextureProperties)
			{
				LoadTextureBlenders();
				FindBestTextureBlender(resultMaterial);
			}
		}

		private static bool InterfaceFilter(Type typeObj, object criteriaObj)
		{
			return typeObj.ToString() == criteriaObj.ToString();
		}

		private void FindBestTextureBlender(Material resultMaterial)
		{
			resultMaterialTextureBlender = FindMatchingTextureBlender(resultMaterial.shader.name);
			if (resultMaterialTextureBlender != null)
			{
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					UnityEngine.Debug.Log("Using _considerNonTextureProperties found a TextureBlender for result material. Using: " + resultMaterialTextureBlender);
				}
			}
			else
			{
				if (LOG_LEVEL >= MB2_LogLevel.error)
				{
					UnityEngine.Debug.LogWarning("Using _considerNonTextureProperties could not find a TextureBlender that matches the shader on the result material. Using the Fallback Texture Blender.");
				}
				resultMaterialTextureBlender = new TextureBlenderFallback();
			}
			_nonTexturePropertiesBlender = new NonTexturePropertiesBlendProps(this, resultMaterialTextureBlender);
		}

		private void LoadTextureBlenders()
		{
			string filterCriteria = "DigitalOpus.MB.Core.TextureBlender";
			TypeFilter filter = InterfaceFilter;
			List<Type> list = new List<Type>();
			Assembly[] assemblies = AppDomain.CurrentDomain.GetAssemblies();
			foreach (Assembly assembly in assemblies)
			{
				IEnumerable enumerable = null;
				try
				{
					enumerable = assembly.GetTypes();
				}
				catch (Exception ex)
				{
					ex.Equals(null);
				}
				if (enumerable == null)
				{
					continue;
				}
				Type[] types = assembly.GetTypes();
				foreach (Type type in types)
				{
					if (type.FindInterfaces(filter, filterCriteria).Length != 0)
					{
						list.Add(type);
					}
				}
			}
			TextureBlender textureBlender = null;
			List<TextureBlender> list2 = new List<TextureBlender>();
			foreach (Type item in list)
			{
				if (!item.IsAbstract && !item.IsInterface)
				{
					TextureBlender textureBlender2 = (TextureBlender)Activator.CreateInstance(item);
					if (textureBlender2 is TextureBlenderFallback)
					{
						textureBlender = textureBlender2;
					}
					else
					{
						list2.Add(textureBlender2);
					}
				}
			}
			if (textureBlender != null)
			{
				list2.Add(textureBlender);
			}
			textureBlenders = list2.ToArray();
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log($"Loaded {textureBlenders.Length} TextureBlenders.");
			}
		}

		internal bool NonTexturePropertiesAreEqual(Material a, Material b)
		{
			return _nonTexturePropertiesBlender.NonTexturePropertiesAreEqual(a, b);
		}

		internal Texture2D TintTextureWithTextureCombiner(Texture2D t, MB_TexSet sourceMaterial, ShaderTextureProperty shaderPropertyName)
		{
			return _nonTexturePropertiesBlender.TintTextureWithTextureCombiner(t, sourceMaterial, shaderPropertyName);
		}

		internal void AdjustNonTextureProperties(Material resultMat, List<ShaderTextureProperty> texPropertyNames, List<MB_TexSet> distinctMaterialTextures, MB2_EditorMethodsInterface editorMethods)
		{
			if (!(resultMat == null) && texPropertyNames != null)
			{
				_nonTexturePropertiesBlender.AdjustNonTextureProperties(resultMat, texPropertyNames, distinctMaterialTextures, editorMethods);
			}
		}

		internal Color GetColorAsItWouldAppearInAtlasIfNoTexture(Material matIfBlender, ShaderTextureProperty texProperty)
		{
			return _nonTexturePropertiesBlender.GetColorAsItWouldAppearInAtlasIfNoTexture(matIfBlender, texProperty);
		}

		internal Color GetColorForTemporaryTexture(Material matIfBlender, ShaderTextureProperty texProperty)
		{
			return _nonTexturePropertiesBlender.GetColorForTemporaryTexture(matIfBlender, texProperty);
		}

		private TextureBlender FindMatchingTextureBlender(string shaderName)
		{
			for (int i = 0; i < textureBlenders.Length; i++)
			{
				if (textureBlenders[i].DoesShaderNameMatch(shaderName))
				{
					return textureBlenders[i];
				}
			}
			return null;
		}
	}
	internal class MB3_TextureCombinerPackerMeshBaker : MB3_TextureCombinerPackerRoot
	{
		public override IEnumerator CreateAtlases(ProgressUpdateDelegate progressInfo, MB3_TextureCombinerPipeline.TexturePipelineData data, MB3_TextureCombiner combiner, AtlasPackingResult packedAtlasRects, Texture2D[] atlases, MB2_EditorMethodsInterface textureEditorMethods, MB2_LogLevel LOG_LEVEL)
		{
			Rect[] uvRects = packedAtlasRects.rects;
			int atlasSizeX = packedAtlasRects.atlasX;
			int atlasSizeY = packedAtlasRects.atlasY;
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log("Generated atlas will be " + atlasSizeX + "x" + atlasSizeY);
			}
			for (int propIdx = 0; propIdx < data.numAtlases; propIdx++)
			{
				ShaderTextureProperty property = data.texPropertyNames[propIdx];
				Texture2D texture2D;
				if (!MB3_TextureCombinerPipeline._ShouldWeCreateAtlasForThisProperty(propIdx, data._considerNonTextureProperties, data.allTexturesAreNullAndSameColor))
				{
					texture2D = null;
					if (LOG_LEVEL >= MB2_LogLevel.debug)
					{
						UnityEngine.Debug.Log("=== Not creating atlas for " + property.name + " because textures are null and default value parameters are the same.");
					}
				}
				else
				{
					if (LOG_LEVEL >= MB2_LogLevel.debug)
					{
						UnityEngine.Debug.Log("=== Creating atlas for " + property.name);
					}
					GC.Collect();
					MB3_TextureCombinerPackerRoot.CreateTemporaryTexturesForAtlas(data.distinctMaterialTextures, combiner, propIdx, data);
					Color[][] atlasPixels = new Color[atlasSizeY][];
					for (int i = 0; i < atlasPixels.Length; i++)
					{
						atlasPixels[i] = new Color[atlasSizeX];
					}
					bool isNormalMap = false;
					if (property.isNormalMap)
					{
						isNormalMap = true;
					}
					for (int texSetIdx = 0; texSetIdx < data.distinctMaterialTextures.Count; texSetIdx++)
					{
						MB_TexSet mB_TexSet = data.distinctMaterialTextures[texSetIdx];
						MeshBakerMaterialTexture meshBakerMaterialTexture = mB_TexSet.ts[propIdx];
						string text = "Creating Atlas '" + property.name + "' texture " + meshBakerMaterialTexture.GetTexName();
						progressInfo?.Invoke(text, 0.01f);
						if (LOG_LEVEL >= MB2_LogLevel.trace)
						{
							UnityEngine.Debug.Log($"Adding texture {meshBakerMaterialTexture.GetTexName()} to atlas {property.name} for texSet {texSetIdx} srcMat {mB_TexSet.matsAndGOs.mats[0].GetMaterialName()}");
						}
						Rect rect = uvRects[texSetIdx];
						Texture2D texture2D2 = mB_TexSet.ts[propIdx].GetTexture2D();
						int targX = Mathf.RoundToInt(rect.x * (float)atlasSizeX);
						int targY = Mathf.RoundToInt(rect.y * (float)atlasSizeY);
						int num = Mathf.RoundToInt(rect.width * (float)atlasSizeX);
						int num2 = Mathf.RoundToInt(rect.height * (float)atlasSizeY);
						if (num == 0 || num2 == 0)
						{
							Rect rect2 = rect;
							UnityEngine.Debug.LogError("Image in atlas has no height or width " + rect2.ToString());
						}
						progressInfo?.Invoke(text + " set ReadWrite flag", 0.01f);
						textureEditorMethods?.SetReadWriteFlag(texture2D2, isReadable: true, addToList: true);
						progressInfo?.Invoke(text + "Copying to atlas: '" + meshBakerMaterialTexture.GetTexName() + "'", 0.02f);
						DRect encapsulatingSamplingRect = mB_TexSet.ts[propIdx].GetEncapsulatingSamplingRect();
						yield return CopyScaledAndTiledToAtlas(mB_TexSet.ts[propIdx], mB_TexSet, property, encapsulatingSamplingRect, targX, targY, num, num2, packedAtlasRects.padding[texSetIdx], atlasPixels, isNormalMap, data, combiner, progressInfo, LOG_LEVEL);
					}
					yield return data.numAtlases;
					progressInfo?.Invoke("Applying changes to atlas: '" + property.name + "'", 0.03f);
					texture2D = new Texture2D(atlasSizeX, atlasSizeY, TextureFormat.ARGB32, mipChain: true);
					for (int j = 0; j < atlasPixels.Length; j++)
					{
						texture2D.SetPixels(0, j, atlasSizeX, 1, atlasPixels[j]);
					}
					texture2D.Apply();
					if (LOG_LEVEL >= MB2_LogLevel.debug)
					{
						UnityEngine.Debug.Log("Saving atlas " + property.name + " w=" + texture2D.width + " h=" + texture2D.height);
					}
				}
				atlases[propIdx] = texture2D;
				progressInfo?.Invoke("Saving atlas: '" + property.name + "'", 0.04f);
				new Stopwatch().Start();
				if (data._saveAtlasesAsAssets && textureEditorMethods != null)
				{
					textureEditorMethods.SaveAtlasToAssetDatabase(atlases[propIdx], data.texPropertyNames[propIdx], propIdx, data.resultMaterial);
				}
				else
				{
					data.resultMaterial.SetTexture(data.texPropertyNames[propIdx].name, atlases[propIdx]);
				}
				data.resultMaterial.SetTextureOffset(data.texPropertyNames[propIdx].name, Vector2.zero);
				data.resultMaterial.SetTextureScale(data.texPropertyNames[propIdx].name, Vector2.one);
				combiner._destroyTemporaryTextures(data.texPropertyNames[propIdx].name);
			}
		}

		internal static IEnumerator CopyScaledAndTiledToAtlas(MeshBakerMaterialTexture source, MB_TexSet sourceMaterial, ShaderTextureProperty shaderPropertyName, DRect srcSamplingRect, int targX, int targY, int targW, int targH, AtlasPadding padding, Color[][] atlasPixels, bool isNormalMap, MB3_TextureCombinerPipeline.TexturePipelineData data, MB3_TextureCombiner combiner, ProgressUpdateDelegate progressInfo = null, MB2_LogLevel LOG_LEVEL = MB2_LogLevel.info)
		{
			Texture2D texture2D = source.GetTexture2D();
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log($"CopyScaledAndTiledToAtlas: {texture2D} inAtlasX={targX} inAtlasY={targY} inAtlasW={targW} inAtlasH={targH} paddX={padding.leftRight} paddY={padding.topBottom} srcSamplingRect={srcSamplingRect}");
			}
			float num = targW;
			float num2 = targH;
			float num3 = (float)srcSamplingRect.width;
			float num4 = (float)srcSamplingRect.height;
			float num5 = (float)srcSamplingRect.x;
			float num6 = (float)srcSamplingRect.y;
			int w = (int)num;
			int h = (int)num2;
			if (data._considerNonTextureProperties)
			{
				texture2D = combiner._createTextureCopy(shaderPropertyName.name, texture2D);
				texture2D = data.nonTexturePropertyBlender.TintTextureWithTextureCombiner(texture2D, sourceMaterial, shaderPropertyName);
			}
			for (int k = 0; k < w; k++)
			{
				if (progressInfo != null && w > 0)
				{
					progressInfo("CopyScaledAndTiledToAtlas " + ((float)k / (float)w * 100f).ToString("F0"), 0.2f);
				}
				for (int l = 0; l < h; l++)
				{
					float u = (float)k / num * num3 + num5;
					float v = (float)l / num2 * num4 + num6;
					atlasPixels[targY + l][targX + k] = texture2D.GetPixelBilinear(u, v);
				}
			}
			for (int m = 0; m < w; m++)
			{
				for (int n = 1; n <= padding.topBottom; n++)
				{
					atlasPixels[targY - n][targX + m] = atlasPixels[targY][targX + m];
					atlasPixels[targY + h - 1 + n][targX + m] = atlasPixels[targY + h - 1][targX + m];
				}
			}
			for (int num7 = 0; num7 < h; num7++)
			{
				for (int num8 = 1; num8 <= padding.leftRight; num8++)
				{
					atlasPixels[targY + num7][targX - num8] = atlasPixels[targY + num7][targX];
					atlasPixels[targY + num7][targX + w + num8 - 1] = atlasPixels[targY + num7][targX + w - 1];
				}
			}
			for (int i = 1; i <= padding.leftRight; i++)
			{
				for (int j = 1; j <= padding.topBottom; j++)
				{
					atlasPixels[targY - j][targX - i] = atlasPixels[targY][targX];
					atlasPixels[targY + h - 1 + j][targX - i] = atlasPixels[targY + h - 1][targX];
					atlasPixels[targY + h - 1 + j][targX + w + i - 1] = atlasPixels[targY + h - 1][targX + w - 1];
					atlasPixels[targY - j][targX + w + i - 1] = atlasPixels[targY][targX + w - 1];
					yield return null;
				}
				yield return null;
			}
		}
	}
	internal class MB3_TextureCombinerPackerMeshBakerFast : MB_ITextureCombinerPacker
	{
		public IEnumerator ConvertTexturesToReadableFormats(ProgressUpdateDelegate progressInfo, MB3_TextureCombiner.CombineTexturesIntoAtlasesCoroutineResult result, MB3_TextureCombinerPipeline.TexturePipelineData data, MB3_TextureCombiner combiner, MB2_EditorMethodsInterface textureEditorMethods, MB2_LogLevel LOG_LEVEL)
		{
			yield break;
		}

		public virtual AtlasPackingResult[] CalculateAtlasRectangles(MB3_TextureCombinerPipeline.TexturePipelineData data, bool doMultiAtlas, MB2_LogLevel LOG_LEVEL)
		{
			return MB3_TextureCombinerPackerRoot.CalculateAtlasRectanglesStatic(data, doMultiAtlas, LOG_LEVEL);
		}

		public IEnumerator CreateAtlases(ProgressUpdateDelegate progressInfo, MB3_TextureCombinerPipeline.TexturePipelineData data, MB3_TextureCombiner combiner, AtlasPackingResult packedAtlasRects, Texture2D[] atlases, MB2_EditorMethodsInterface textureEditorMethods, MB2_LogLevel LOG_LEVEL)
		{
			Rect[] rects = packedAtlasRects.rects;
			int atlasX = packedAtlasRects.atlasX;
			int atlasY = packedAtlasRects.atlasY;
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log("Generated atlas will be " + atlasX + "x" + atlasY);
			}
			GameObject gameObject = null;
			try
			{
				gameObject = new GameObject("MBrenderAtlasesGO");
				MB3_AtlasPackerRenderTexture mB3_AtlasPackerRenderTexture = gameObject.AddComponent<MB3_AtlasPackerRenderTexture>();
				gameObject.AddComponent<Camera>();
				if (data._considerNonTextureProperties && LOG_LEVEL >= MB2_LogLevel.warn)
				{
					UnityEngine.Debug.LogWarning("Blend Non-Texture Properties has limited functionality when used with Mesh Baker Texture Packer Fast.");
				}
				for (int i = 0; i < data.numAtlases; i++)
				{
					Texture2D texture2D;
					if (!MB3_TextureCombinerPipeline._ShouldWeCreateAtlasForThisProperty(i, data._considerNonTextureProperties, data.allTexturesAreNullAndSameColor))
					{
						texture2D = null;
						if (LOG_LEVEL >= MB2_LogLevel.debug)
						{
							UnityEngine.Debug.Log("Not creating atlas for " + data.texPropertyNames[i].name + " because textures are null and default value parameters are the same.");
						}
					}
					else
					{
						GC.Collect();
						MB3_TextureCombinerPackerRoot.CreateTemporaryTexturesForAtlas(data.distinctMaterialTextures, combiner, i, data);
						progressInfo?.Invoke("Creating Atlas '" + data.texPropertyNames[i].name + "'", 0.01f);
						if (LOG_LEVEL >= MB2_LogLevel.debug)
						{
							UnityEngine.Debug.Log("About to render " + data.texPropertyNames[i].name + " isNormal=" + data.texPropertyNames[i].isNormalMap);
						}
						mB3_AtlasPackerRenderTexture.LOG_LEVEL = LOG_LEVEL;
						mB3_AtlasPackerRenderTexture.width = atlasX;
						mB3_AtlasPackerRenderTexture.height = atlasY;
						mB3_AtlasPackerRenderTexture.padding = data._atlasPadding;
						mB3_AtlasPackerRenderTexture.rects = rects;
						mB3_AtlasPackerRenderTexture.textureSets = data.distinctMaterialTextures;
						mB3_AtlasPackerRenderTexture.indexOfTexSetToRender = i;
						mB3_AtlasPackerRenderTexture.texPropertyName = data.texPropertyNames[i];
						mB3_AtlasPackerRenderTexture.isNormalMap = data.texPropertyNames[i].isNormalMap;
						mB3_AtlasPackerRenderTexture.fixOutOfBoundsUVs = data._fixOutOfBoundsUVs;
						mB3_AtlasPackerRenderTexture.considerNonTextureProperties = data._considerNonTextureProperties;
						mB3_AtlasPackerRenderTexture.resultMaterialTextureBlender = data.nonTexturePropertyBlender;
						texture2D = mB3_AtlasPackerRenderTexture.OnRenderAtlas(combiner);
						if (LOG_LEVEL >= MB2_LogLevel.debug)
						{
							UnityEngine.Debug.Log("Saving atlas " + data.texPropertyNames[i].name + " w=" + texture2D.width + " h=" + texture2D.height + " id=" + texture2D.GetInstanceID());
						}
					}
					atlases[i] = texture2D;
					progressInfo?.Invoke("Saving atlas: '" + data.texPropertyNames[i].name + "'", 0.04f);
					if (data._saveAtlasesAsAssets && textureEditorMethods != null)
					{
						textureEditorMethods.SaveAtlasToAssetDatabase(atlases[i], data.texPropertyNames[i], i, data.resultMaterial);
					}
					else
					{
						data.resultMaterial.SetTexture(data.texPropertyNames[i].name, atlases[i]);
					}
					data.resultMaterial.SetTextureOffset(data.texPropertyNames[i].name, Vector2.zero);
					data.resultMaterial.SetTextureScale(data.texPropertyNames[i].name, Vector2.one);
					combiner._destroyTemporaryTextures(data.texPropertyNames[i].name);
				}
			}
			catch (Exception exception)
			{
				UnityEngine.Debug.LogException(exception);
			}
			finally
			{
				if (gameObject != null)
				{
					MB_Utility.Destroy(gameObject);
				}
			}
			yield break;
		}
	}
	internal class MB3_TextureCombinerPackerMeshBakerHorizontalVertical : MB3_TextureCombinerPackerMeshBaker
	{
		private interface IPipeline
		{
			MB2_PackingAlgorithmEnum GetPackingAlg();

			void SortTexSetIntoBins(MB_TexSet texSet, List<MB_TexSet> horizontalVert, List<MB_TexSet> regular, int maxAtlasWidth, int maxAtlasHeight);

			MB_TextureTilingTreatment GetEdge2EdgeTreatment();

			void InitializeAtlasPadding(ref AtlasPadding padding, int paddingValue);

			void MergeAtlasPackingResultStackBonAInternal(AtlasPackingResult a, AtlasPackingResult b, out Rect AatlasToFinal, out Rect BatlasToFinal, bool stretchBToAtlasWidth, int maxWidthDim, int maxHeightDim, out int atlasX, out int atlasY);

			void GetExtraRoomForRegularAtlas(int usedHorizontalVertWidth, int usedHorizontalVertHeight, int maxAtlasWidth, int maxAtlasHeight, out int atlasRegularMaxWidth, out int atlasRegularMaxHeight);
		}

		private class VerticalPipeline : IPipeline
		{
			public MB2_PackingAlgorithmEnum GetPackingAlg()
			{
				return MB2_PackingAlgorithmEnum.MeshBakerTexturePacker_Vertical;
			}

			public void SortTexSetIntoBins(MB_TexSet texSet, List<MB_TexSet> horizontalVert, List<MB_TexSet> regular, int maxAtlasWidth, int maxAtlasHeight)
			{
				if (texSet.idealHeight >= maxAtlasHeight && texSet.ts[0].GetEncapsulatingSamplingRect().height > 1.0)
				{
					horizontalVert.Add(texSet);
				}
				else
				{
					regular.Add(texSet);
				}
			}

			public MB_TextureTilingTreatment GetEdge2EdgeTreatment()
			{
				return MB_TextureTilingTreatment.edgeToEdgeY;
			}

			public void InitializeAtlasPadding(ref AtlasPadding padding, int paddingValue)
			{
				padding.topBottom = 0;
				padding.leftRight = paddingValue;
			}

			public void MergeAtlasPackingResultStackBonAInternal(AtlasPackingResult a, AtlasPackingResult b, out Rect AatlasToFinal, out Rect BatlasToFinal, bool stretchBToAtlasWidth, int maxWidthDim, int maxHeightDim, out int atlasX, out int atlasY)
			{
				float num = a.usedW + b.usedW;
				if (num > (float)maxWidthDim)
				{
					float num2 = (float)maxWidthDim / num;
					float num3 = (float)Mathf.FloorToInt((float)a.usedW * num2) / (float)maxWidthDim;
					num2 = num3;
					float width = 1f - num3;
					AatlasToFinal = new Rect(0f, 0f, num2, 1f);
					BatlasToFinal = new Rect(num3, 0f, width, 1f);
				}
				else
				{
					float num4 = (float)a.usedW / num;
					AatlasToFinal = new Rect(0f, 0f, num4, 1f);
					BatlasToFinal = new Rect(num4, 0f, (float)b.usedW / num, 1f);
				}
				if (a.atlasX > b.atlasX)
				{
					if (!stretchBToAtlasWidth)
					{
						BatlasToFinal.width = (float)b.atlasX / (float)a.atlasX;
					}
				}
				else if (b.atlasX > a.atlasX)
				{
					AatlasToFinal.width = (float)a.atlasX / (float)b.atlasX;
				}
				atlasX = a.usedW + b.usedW;
				atlasY = Mathf.Max(a.usedH, b.usedH);
			}

			public void GetExtraRoomForRegularAtlas(int usedHorizontalVertWidth, int usedHorizontalVertHeight, int maxAtlasWidth, int maxAtlasHeight, out int atlasRegularMaxWidth, out int atlasRegularMaxHeight)
			{
				atlasRegularMaxWidth = maxAtlasWidth - usedHorizontalVertWidth;
				atlasRegularMaxHeight = maxAtlasHeight;
			}
		}

		private class HorizontalPipeline : IPipeline
		{
			public MB2_PackingAlgorithmEnum GetPackingAlg()
			{
				return MB2_PackingAlgorithmEnum.MeshBakerTexturePacker_Horizontal;
			}

			public void SortTexSetIntoBins(MB_TexSet texSet, List<MB_TexSet> horizontalVert, List<MB_TexSet> regular, int maxAtlasWidth, int maxAtlasHeight)
			{
				if (texSet.idealWidth >= maxAtlasWidth && texSet.ts[0].GetEncapsulatingSamplingRect().width > 1.0)
				{
					horizontalVert.Add(texSet);
				}
				else
				{
					regular.Add(texSet);
				}
			}

			public MB_TextureTilingTreatment GetEdge2EdgeTreatment()
			{
				return MB_TextureTilingTreatment.edgeToEdgeX;
			}

			public void InitializeAtlasPadding(ref AtlasPadding padding, int paddingValue)
			{
				padding.topBottom = paddingValue;
				padding.leftRight = 0;
			}

			public void MergeAtlasPackingResultStackBonAInternal(AtlasPackingResult a, AtlasPackingResult b, out Rect AatlasToFinal, out Rect BatlasToFinal, bool stretchBToAtlasWidth, int maxWidthDim, int maxHeightDim, out int atlasX, out int atlasY)
			{
				float num = a.usedH + b.usedH;
				if (num > (float)maxHeightDim)
				{
					float num2 = (float)maxHeightDim / num;
					float num3 = (float)Mathf.FloorToInt((float)a.usedH * num2) / (float)maxHeightDim;
					num2 = num3;
					float height = 1f - num3;
					AatlasToFinal = new Rect(0f, 0f, 1f, num2);
					BatlasToFinal = new Rect(0f, num3, 1f, height);
				}
				else
				{
					float num4 = (float)a.usedH / num;
					AatlasToFinal = new Rect(0f, 0f, 1f, num4);
					BatlasToFinal = new Rect(0f, num4, 1f, (float)b.usedH / num);
				}
				if (a.atlasX > b.atlasX)
				{
					if (!stretchBToAtlasWidth)
					{
						BatlasToFinal.width = (float)b.atlasX / (float)a.atlasX;
					}
				}
				else if (b.atlasX > a.atlasX)
				{
					AatlasToFinal.width = (float)a.atlasX / (float)b.atlasX;
				}
				atlasX = Mathf.Max(a.usedW, b.usedW);
				atlasY = a.usedH + b.usedH;
			}

			public void GetExtraRoomForRegularAtlas(int usedHorizontalVertWidth, int usedHorizontalVertHeight, int maxAtlasWidth, int maxAtlasHeight, out int atlasRegularMaxWidth, out int atlasRegularMaxHeight)
			{
				atlasRegularMaxWidth = maxAtlasWidth;
				atlasRegularMaxHeight = maxAtlasHeight - usedHorizontalVertHeight;
			}
		}

		public enum AtlasDirection
		{
			horizontal,
			vertical
		}

		private AtlasDirection _atlasDirection;

		public MB3_TextureCombinerPackerMeshBakerHorizontalVertical(AtlasDirection ad)
		{
			_atlasDirection = ad;
		}

		public override AtlasPackingResult[] CalculateAtlasRectangles(MB3_TextureCombinerPipeline.TexturePipelineData data, bool doMultiAtlas, MB2_LogLevel LOG_LEVEL)
		{
			IPipeline pipeline = ((_atlasDirection != 0) ? ((IPipeline)new VerticalPipeline()) : ((IPipeline)new HorizontalPipeline()));
			UnityEngine.Debug.LogError("TODO handle max atlas dimension when not using override");
			if (_atlasDirection == AtlasDirection.horizontal)
			{
				if (data._useMaxAtlasWidthOverride)
				{
				}
			}
			else
			{
				_ = data._useMaxAtlasHeightOverride;
			}
			List<MB_TexSet> list = new List<MB_TexSet>();
			List<MB_TexSet> list2 = new List<MB_TexSet>();
			for (int i = 0; i < data.distinctMaterialTextures.Count; i++)
			{
				pipeline.SortTexSetIntoBins(data.distinctMaterialTextures[i], list, list2, data._maxAtlasWidth, data._maxAtlasHeight);
			}
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log($"Splitting list of distinctMaterialTextures numHorizontalVertical={list.Count} numRegular={list2.Count}");
			}
			AtlasPackingResult[] array;
			if (list.Count > 0)
			{
				MB2_PackingAlgorithmEnum packingAlg = pipeline.GetPackingAlg();
				List<Vector2> list3 = new List<Vector2>();
				for (int j = 0; j < list.Count; j++)
				{
					list[j].SetTilingTreatmentAndAdjustEncapsulatingSamplingRect(pipeline.GetEdge2EdgeTreatment());
					list3.Add(new Vector2(list[j].idealWidth, list[j].idealHeight));
				}
				MB2_TexturePacker mB2_TexturePacker = MB3_TextureCombinerPipeline.CreateTexturePacker(packingAlg);
				mB2_TexturePacker.atlasMustBePowerOfTwo = false;
				List<AtlasPadding> list4 = new List<AtlasPadding>();
				for (int k = 0; k < list3.Count; k++)
				{
					AtlasPadding padding = default(AtlasPadding);
					pipeline.InitializeAtlasPadding(ref padding, data._atlasPadding);
					list4.Add(padding);
				}
				mB2_TexturePacker.LOG_LEVEL = MB2_LogLevel.trace;
				array = mB2_TexturePacker.GetRects(list3, list4, data._maxAtlasWidth, data._maxAtlasHeight, doMultiAtlas: false);
				if (LOG_LEVEL >= MB2_LogLevel.trace)
				{
					UnityEngine.Debug.Log($"Packed {list.Count} textures with edgeToEdge tiling into an atlas of size {array[0].atlasX} by {array[0].atlasY} usedW {array[0].usedW} usedH {array[0].usedH}");
				}
			}
			else
			{
				array = new AtlasPackingResult[0];
			}
			AtlasPackingResult[] array2;
			if (list2.Count > 0)
			{
				MB2_PackingAlgorithmEnum packingAlg = MB2_PackingAlgorithmEnum.MeshBakerTexturePacker;
				List<Vector2> list5 = new List<Vector2>();
				for (int l = 0; l < list2.Count; l++)
				{
					list5.Add(new Vector2(list2[l].idealWidth, list2[l].idealHeight));
				}
				MB2_TexturePacker mB2_TexturePacker = MB3_TextureCombinerPipeline.CreateTexturePacker(MB2_PackingAlgorithmEnum.MeshBakerTexturePacker);
				mB2_TexturePacker.atlasMustBePowerOfTwo = false;
				List<AtlasPadding> list6 = new List<AtlasPadding>();
				for (int m = 0; m < list5.Count; m++)
				{
					AtlasPadding item = default(AtlasPadding);
					item.topBottom = data._atlasPadding;
					item.leftRight = data._atlasPadding;
					list6.Add(item);
				}
				int usedHorizontalVertWidth = 0;
				int usedHorizontalVertHeight = 0;
				if (array.Length != 0)
				{
					usedHorizontalVertHeight = array[0].atlasY;
					usedHorizontalVertWidth = array[0].atlasX;
				}
				pipeline.GetExtraRoomForRegularAtlas(usedHorizontalVertWidth, usedHorizontalVertHeight, data._maxAtlasWidth, data._maxAtlasHeight, out var atlasRegularMaxWidth, out var atlasRegularMaxHeight);
				array2 = mB2_TexturePacker.GetRects(list5, list6, atlasRegularMaxWidth, atlasRegularMaxHeight, doMultiAtlas: false);
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					UnityEngine.Debug.Log($"Packed {list2.Count} textures without edgeToEdge tiling into an atlas of size {array2[0].atlasX} by {array2[0].atlasY} usedW {array2[0].usedW} usedH {array2[0].usedH}");
				}
			}
			else
			{
				array2 = new AtlasPackingResult[0];
			}
			AtlasPackingResult atlasPackingResult = null;
			if (array.Length == 0 && array2.Length == 0)
			{
				return null;
			}
			if (array.Length != 0 && array2.Length != 0)
			{
				atlasPackingResult = MergeAtlasPackingResultStackBonA(array[0], array2[0], data._maxAtlasWidth, data._maxAtlasHeight, stretchBToAtlasWidth: true, pipeline);
			}
			else if (array.Length != 0)
			{
				atlasPackingResult = array[0];
			}
			else if (array2.Length != 0)
			{
				atlasPackingResult = array2[0];
			}
			list.AddRange(list2);
			data.distinctMaterialTextures = list;
			if (atlasPackingResult != null)
			{
				return new AtlasPackingResult[1] { atlasPackingResult };
			}
			return new AtlasPackingResult[0];
		}

		public static AtlasPackingResult TestStackRectanglesHorizontal(AtlasPackingResult a, AtlasPackingResult b, int maxHeightDim, int maxWidthDim, bool stretchBToAtlasWidth)
		{
			return MergeAtlasPackingResultStackBonA(a, b, maxWidthDim, maxHeightDim, stretchBToAtlasWidth, new HorizontalPipeline());
		}

		public static AtlasPackingResult TestStackRectanglesVertical(AtlasPackingResult a, AtlasPackingResult b, int maxHeightDim, int maxWidthDim, bool stretchBToAtlasWidth)
		{
			return MergeAtlasPackingResultStackBonA(a, b, maxWidthDim, maxHeightDim, stretchBToAtlasWidth, new VerticalPipeline());
		}

		private static AtlasPackingResult MergeAtlasPackingResultStackBonA(AtlasPackingResult a, AtlasPackingResult b, int maxWidthDim, int maxHeightDim, bool stretchBToAtlasWidth, IPipeline pipeline)
		{
			pipeline.MergeAtlasPackingResultStackBonAInternal(a, b, out var AatlasToFinal, out var BatlasToFinal, stretchBToAtlasWidth, maxWidthDim, maxHeightDim, out var atlasX, out var atlasY);
			Rect[] array = new Rect[a.rects.Length + b.rects.Length];
			AtlasPadding[] array2 = new AtlasPadding[a.rects.Length + b.rects.Length];
			int[] array3 = new int[a.rects.Length + b.rects.Length];
			Array.Copy(a.padding, array2, a.padding.Length);
			Array.Copy(b.padding, 0, array2, a.padding.Length, b.padding.Length);
			Array.Copy(a.srcImgIdxs, array3, a.srcImgIdxs.Length);
			Array.Copy(b.srcImgIdxs, 0, array3, a.srcImgIdxs.Length, b.srcImgIdxs.Length);
			Array.Copy(a.rects, array, a.rects.Length);
			for (int i = 0; i < a.rects.Length; i++)
			{
				Rect rect = a.rects[i];
				rect.x = AatlasToFinal.x + rect.x * AatlasToFinal.width;
				rect.y = AatlasToFinal.y + rect.y * AatlasToFinal.height;
				rect.width *= AatlasToFinal.width;
				rect.height *= AatlasToFinal.height;
				array[i] = rect;
				array3[i] = a.srcImgIdxs[i];
			}
			for (int j = 0; j < b.rects.Length; j++)
			{
				Rect rect2 = b.rects[j];
				rect2.x = BatlasToFinal.x + rect2.x * BatlasToFinal.width;
				rect2.y = BatlasToFinal.y + rect2.y * BatlasToFinal.height;
				rect2.width *= BatlasToFinal.width;
				rect2.height *= BatlasToFinal.height;
				array[a.rects.Length + j] = rect2;
				array3[a.rects.Length + j] = b.srcImgIdxs[j];
			}
			AtlasPackingResult atlasPackingResult = new AtlasPackingResult(array2);
			atlasPackingResult.atlasX = atlasX;
			atlasPackingResult.atlasY = atlasY;
			atlasPackingResult.padding = array2;
			atlasPackingResult.rects = array;
			atlasPackingResult.srcImgIdxs = array3;
			atlasPackingResult.CalcUsedWidthAndHeight();
			return atlasPackingResult;
		}
	}
	internal class MB3_TextureCombinerPackerOneTextureInAtlas : MB_ITextureCombinerPacker
	{
		public IEnumerator ConvertTexturesToReadableFormats(ProgressUpdateDelegate progressInfo, MB3_TextureCombiner.CombineTexturesIntoAtlasesCoroutineResult result, MB3_TextureCombinerPipeline.TexturePipelineData data, MB3_TextureCombiner combiner, MB2_EditorMethodsInterface textureEditorMethods, MB2_LogLevel LOG_LEVEL)
		{
			yield break;
		}

		public AtlasPackingResult[] CalculateAtlasRectangles(MB3_TextureCombinerPipeline.TexturePipelineData data, bool doMultiAtlas, MB2_LogLevel LOG_LEVEL)
		{
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log("Only one image per atlas. Will re-use original texture");
			}
			AtlasPackingResult[] array = new AtlasPackingResult[1];
			AtlasPadding[] pds = new AtlasPadding[1]
			{
				new AtlasPadding(data._atlasPadding)
			};
			array[0] = new AtlasPackingResult(pds);
			array[0].rects = new Rect[1];
			array[0].srcImgIdxs = new int[1];
			array[0].rects[0] = new Rect(0f, 0f, 1f, 1f);
			MeshBakerMaterialTexture meshBakerMaterialTexture = null;
			if (data.distinctMaterialTextures[0].ts.Length != 0)
			{
				meshBakerMaterialTexture = data.distinctMaterialTextures[0].ts[0];
			}
			if (meshBakerMaterialTexture == null || meshBakerMaterialTexture.isNull)
			{
				array[0].atlasX = 16;
				array[0].atlasY = 16;
				array[0].usedW = 16;
				array[0].usedH = 16;
			}
			else
			{
				array[0].atlasX = meshBakerMaterialTexture.width;
				array[0].atlasY = meshBakerMaterialTexture.height;
				array[0].usedW = meshBakerMaterialTexture.width;
				array[0].usedH = meshBakerMaterialTexture.height;
			}
			return array;
		}

		public IEnumerator CreateAtlases(ProgressUpdateDelegate progressInfo, MB3_TextureCombinerPipeline.TexturePipelineData data, MB3_TextureCombiner combiner, AtlasPackingResult packedAtlasRects, Texture2D[] atlases, MB2_EditorMethodsInterface textureEditorMethods, MB2_LogLevel LOG_LEVEL)
		{
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log("Only one image per atlas. Will re-use original texture");
			}
			for (int i = 0; i < data.numAtlases; i++)
			{
				MeshBakerMaterialTexture meshBakerMaterialTexture = data.distinctMaterialTextures[0].ts[i];
				atlases[i] = meshBakerMaterialTexture.GetTexture2D();
				data.resultMaterial.SetTexture(data.texPropertyNames[i].name, atlases[i]);
				data.resultMaterial.SetTextureScale(data.texPropertyNames[i].name, Vector2.one);
				data.resultMaterial.SetTextureOffset(data.texPropertyNames[i].name, Vector2.zero);
			}
			yield break;
		}
	}
	internal class MB3_TextureCombinerPackerUnity : MB3_TextureCombinerPackerRoot
	{
		public override AtlasPackingResult[] CalculateAtlasRectangles(MB3_TextureCombinerPipeline.TexturePipelineData data, bool doMultiAtlas, MB2_LogLevel LOG_LEVEL)
		{
			return new AtlasPackingResult[1]
			{
				new AtlasPackingResult(new AtlasPadding[0])
			};
		}

		public override IEnumerator CreateAtlases(ProgressUpdateDelegate progressInfo, MB3_TextureCombinerPipeline.TexturePipelineData data, MB3_TextureCombiner combiner, AtlasPackingResult packedAtlasRects, Texture2D[] atlases, MB2_EditorMethodsInterface textureEditorMethods, MB2_LogLevel LOG_LEVEL)
		{
			_ = packedAtlasRects.rects;
			long num = 0L;
			int w = 1;
			int h = 1;
			Rect[] array = null;
			for (int i = 0; i < data.numAtlases; i++)
			{
				ShaderTextureProperty shaderTextureProperty = data.texPropertyNames[i];
				Texture2D texture2D;
				if (!MB3_TextureCombinerPipeline._ShouldWeCreateAtlasForThisProperty(i, data._considerNonTextureProperties, data.allTexturesAreNullAndSameColor))
				{
					texture2D = null;
				}
				else
				{
					if (LOG_LEVEL >= MB2_LogLevel.debug)
					{
						UnityEngine.Debug.LogWarning("Beginning loop " + i + " num temporary textures " + combiner._getNumTemporaryTextures());
					}
					MB3_TextureCombinerPackerRoot.CreateTemporaryTexturesForAtlas(data.distinctMaterialTextures, combiner, i, data);
					Texture2D[] array2 = new Texture2D[data.distinctMaterialTextures.Count];
					for (int j = 0; j < data.distinctMaterialTextures.Count; j++)
					{
						MB_TexSet mB_TexSet = data.distinctMaterialTextures[j];
						int idealWidth = mB_TexSet.idealWidth;
						int idealHeight = mB_TexSet.idealHeight;
						Texture2D texture2D2 = mB_TexSet.ts[i].GetTexture2D();
						progressInfo?.Invoke("Adjusting for scale and offset " + texture2D2, 0.01f);
						textureEditorMethods?.SetReadWriteFlag(texture2D2, isReadable: true, addToList: true);
						texture2D2 = GetAdjustedForScaleAndOffset2(shaderTextureProperty.name, mB_TexSet.ts[i], mB_TexSet.obUVoffset, mB_TexSet.obUVscale, data, combiner, LOG_LEVEL);
						if (texture2D2.width != idealWidth || texture2D2.height != idealHeight)
						{
							progressInfo?.Invoke("Resizing texture '" + texture2D2?.ToString() + "'", 0.01f);
							if (LOG_LEVEL >= MB2_LogLevel.debug)
							{
								UnityEngine.Debug.LogWarning("Copying and resizing texture " + shaderTextureProperty.name + " from " + texture2D2.width + "x" + texture2D2.height + " to " + idealWidth + "x" + idealHeight);
							}
							texture2D2 = combiner._resizeTexture(shaderTextureProperty.name, texture2D2, idealWidth, idealHeight);
						}
						num += texture2D2.width * texture2D2.height;
						if (data._considerNonTextureProperties)
						{
							texture2D2 = combiner._createTextureCopy(shaderTextureProperty.name, texture2D2);
							data.nonTexturePropertyBlender.TintTextureWithTextureCombiner(texture2D2, data.distinctMaterialTextures[j], shaderTextureProperty);
						}
						array2[j] = texture2D2;
					}
					textureEditorMethods?.CheckBuildSettings(num);
					if (Math.Sqrt(num) > 3500.0 && LOG_LEVEL >= MB2_LogLevel.warn)
					{
						UnityEngine.Debug.LogWarning("The maximum possible atlas size is 4096. Textures may be shrunk");
					}
					texture2D = new Texture2D(1, 1, TextureFormat.ARGB32, mipChain: true);
					progressInfo?.Invoke("Packing texture atlas " + shaderTextureProperty.name, 0.25f);
					if (i == 0)
					{
						progressInfo?.Invoke("Estimated min size of atlases: " + Math.Sqrt(num).ToString("F0"), 0.1f);
						if (LOG_LEVEL >= MB2_LogLevel.info)
						{
							UnityEngine.Debug.Log("Estimated atlas minimum size:" + Math.Sqrt(num).ToString("F0"));
						}
						int maximumAtlasSize = 4096;
						array = texture2D.PackTextures(array2, data._atlasPadding, maximumAtlasSize, makeNoLongerReadable: false);
						if (LOG_LEVEL >= MB2_LogLevel.info)
						{
							UnityEngine.Debug.Log("After pack textures atlas size " + texture2D.width + " " + texture2D.height);
						}
						w = texture2D.width;
						h = texture2D.height;
						texture2D.Apply();
					}
					else
					{
						progressInfo?.Invoke("Copying Textures Into: " + shaderTextureProperty.name, 0.1f);
						texture2D = _copyTexturesIntoAtlas(array2, data._atlasPadding, array, w, h, combiner);
					}
				}
				atlases[i] = texture2D;
				if (data._saveAtlasesAsAssets)
				{
					textureEditorMethods?.SaveAtlasToAssetDatabase(atlases[i], shaderTextureProperty, i, data.resultMaterial);
				}
				data.resultMaterial.SetTextureOffset(shaderTextureProperty.name, Vector2.zero);
				data.resultMaterial.SetTextureScale(shaderTextureProperty.name, Vector2.one);
				combiner._destroyTemporaryTextures(shaderTextureProperty.name);
				GC.Collect();
			}
			packedAtlasRects.rects = array;
			yield break;
		}

		internal static Texture2D _copyTexturesIntoAtlas(Texture2D[] texToPack, int padding, Rect[] rs, int w, int h, MB3_TextureCombiner combiner)
		{
			Texture2D texture2D = new Texture2D(w, h, TextureFormat.ARGB32, mipChain: true);
			MB_Utility.setSolidColor(texture2D, Color.clear);
			for (int i = 0; i < rs.Length; i++)
			{
				Rect rect = rs[i];
				Texture2D texture2D2 = texToPack[i];
				Texture2D texture2D3 = null;
				int x = Mathf.RoundToInt(rect.x * (float)w);
				int y = Mathf.RoundToInt(rect.y * (float)h);
				int num = Mathf.RoundToInt(rect.width * (float)w);
				int num2 = Mathf.RoundToInt(rect.height * (float)h);
				if (texture2D2.width != num && texture2D2.height != num2)
				{
					texture2D3 = (texture2D2 = MB_Utility.resampleTexture(texture2D2, num, num2));
				}
				texture2D.SetPixels(x, y, num, num2, texture2D2.GetPixels());
				if (texture2D3 != null)
				{
					MB_Utility.Destroy(texture2D3);
				}
			}
			texture2D.Apply();
			return texture2D;
		}

		internal static Texture2D GetAdjustedForScaleAndOffset2(string propertyName, MeshBakerMaterialTexture source, Vector2 obUVoffset, Vector2 obUVscale, MB3_TextureCombinerPipeline.TexturePipelineData data, MB3_TextureCombiner combiner, MB2_LogLevel LOG_LEVEL)
		{
			Texture2D texture2D = source.GetTexture2D();
			if (source.matTilingRect.x == 0.0 && source.matTilingRect.y == 0.0 && source.matTilingRect.width == 1.0 && source.matTilingRect.height == 1.0)
			{
				if (!data._fixOutOfBoundsUVs)
				{
					return texture2D;
				}
				if (obUVoffset.x == 0f && obUVoffset.y == 0f && obUVscale.x == 1f && obUVscale.y == 1f)
				{
					return texture2D;
				}
			}
			Vector2 adjustedForScaleAndOffset2Dimensions = MB3_TextureCombinerPipeline.GetAdjustedForScaleAndOffset2Dimensions(source, obUVoffset, obUVscale, data, LOG_LEVEL);
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				string[] obj = new string[6]
				{
					"GetAdjustedForScaleAndOffset2: ",
					texture2D?.ToString(),
					" ",
					null,
					null,
					null
				};
				Vector2 vector = obUVoffset;
				obj[3] = vector.ToString();
				obj[4] = " ";
				vector = obUVscale;
				obj[5] = vector.ToString();
				UnityEngine.Debug.LogWarning(string.Concat(obj));
			}
			float x = adjustedForScaleAndOffset2Dimensions.x;
			float y = adjustedForScaleAndOffset2Dimensions.y;
			float num = (float)source.matTilingRect.width;
			float num2 = (float)source.matTilingRect.height;
			float num3 = (float)source.matTilingRect.x;
			float num4 = (float)source.matTilingRect.y;
			if (data._fixOutOfBoundsUVs)
			{
				num *= obUVscale.x;
				num2 *= obUVscale.y;
				num3 = (float)(source.matTilingRect.x * (double)obUVscale.x + (double)obUVoffset.x);
				num4 = (float)(source.matTilingRect.y * (double)obUVscale.y + (double)obUVoffset.y);
			}
			Texture2D texture2D2 = combiner._createTemporaryTexture(propertyName, (int)x, (int)y, TextureFormat.ARGB32, mipMaps: true);
			for (int i = 0; i < texture2D2.width; i++)
			{
				for (int j = 0; j < texture2D2.height; j++)
				{
					float u = (float)i / x * num + num3;
					float v = (float)j / y * num2 + num4;
					texture2D2.SetPixel(i, j, texture2D.GetPixelBilinear(u, v));
				}
			}
			texture2D2.Apply();
			return texture2D2;
		}
	}
	public class MB3_TextureCombinerPipeline
	{
		public struct CreateAtlasForProperty
		{
			public bool allTexturesAreNull;

			public bool allTexturesAreSame;

			public bool allNonTexturePropsAreSame;

			public override string ToString()
			{
				return $"AllTexturesNull={allTexturesAreNull} areSame={allTexturesAreSame} nonTexPropsAreSame={allNonTexturePropsAreSame}";
			}
		}

		internal class TexturePipelineData
		{
			internal MB2_TextureBakeResults _textureBakeResults;

			internal int _atlasPadding = 1;

			internal int _maxAtlasWidth = 1;

			internal int _maxAtlasHeight = 1;

			internal bool _useMaxAtlasHeightOverride;

			internal bool _useMaxAtlasWidthOverride;

			internal bool _resizePowerOfTwoTextures;

			internal bool _fixOutOfBoundsUVs;

			internal int _maxTilingBakeSize = 1024;

			internal bool _saveAtlasesAsAssets;

			internal MB2_PackingAlgorithmEnum _packingAlgorithm;

			internal bool _meshBakerTexturePackerForcePowerOfTwo = true;

			internal List<ShaderTextureProperty> _customShaderPropNames = new List<ShaderTextureProperty>();

			internal bool _normalizeTexelDensity;

			internal bool _considerNonTextureProperties;

			internal MB3_TextureCombinerNonTextureProperties nonTexturePropertyBlender;

			internal List<MB_TexSet> distinctMaterialTextures;

			internal List<GameObject> allObjsToMesh;

			internal List<Material> allowedMaterialsFilter;

			internal List<ShaderTextureProperty> texPropertyNames;

			internal CreateAtlasForProperty[] allTexturesAreNullAndSameColor;

			internal Material resultMaterial;

			internal int numAtlases
			{
				get
				{
					if (texPropertyNames != null)
					{
						return texPropertyNames.Count;
					}
					return 0;
				}
			}

			internal bool OnlyOneTextureInAtlasReuseTextures()
			{
				if (distinctMaterialTextures != null && distinctMaterialTextures.Count == 1 && distinctMaterialTextures[0].thisIsOnlyTexSetInAtlas && !_fixOutOfBoundsUVs && !_considerNonTextureProperties)
				{
					return true;
				}
				return false;
			}
		}

		public static bool USE_EXPERIMENTAL_HOIZONTALVERTICAL = false;

		public static ShaderTextureProperty[] shaderTexPropertyNames = new ShaderTextureProperty[19]
		{
			new ShaderTextureProperty("_MainTex", norm: false),
			new ShaderTextureProperty("_BumpMap", norm: true),
			new ShaderTextureProperty("_Normal", norm: true),
			new ShaderTextureProperty("_BumpSpecMap", norm: false),
			new ShaderTextureProperty("_DecalTex", norm: false),
			new ShaderTextureProperty("_Detail", norm: false),
			new ShaderTextureProperty("_GlossMap", norm: false),
			new ShaderTextureProperty("_Illum", norm: false),
			new ShaderTextureProperty("_LightTextureB0", norm: false),
			new ShaderTextureProperty("_ParallaxMap", norm: false),
			new ShaderTextureProperty("_ShadowOffset", norm: false),
			new ShaderTextureProperty("_TranslucencyMap", norm: false),
			new ShaderTextureProperty("_SpecMap", norm: false),
			new ShaderTextureProperty("_SpecGlossMap", norm: false),
			new ShaderTextureProperty("_TranspMap", norm: false),
			new ShaderTextureProperty("_MetallicGlossMap", norm: false),
			new ShaderTextureProperty("_OcclusionMap", norm: false),
			new ShaderTextureProperty("_EmissionMap", norm: false),
			new ShaderTextureProperty("_DetailMask", norm: false)
		};

		internal static bool _ShouldWeCreateAtlasForThisProperty(int propertyIndex, bool considerNonTextureProperties, CreateAtlasForProperty[] allTexturesAreNullAndSameColor)
		{
			CreateAtlasForProperty createAtlasForProperty = allTexturesAreNullAndSameColor[propertyIndex];
			if (considerNonTextureProperties)
			{
				if (!createAtlasForProperty.allNonTexturePropsAreSame || !createAtlasForProperty.allTexturesAreNull)
				{
					return true;
				}
				return false;
			}
			if (!createAtlasForProperty.allTexturesAreNull)
			{
				return true;
			}
			return false;
		}

		internal static bool _CollectPropertyNames(TexturePipelineData data, MB2_LogLevel LOG_LEVEL)
		{
			int i;
			for (i = 0; i < data.texPropertyNames.Count; i++)
			{
				ShaderTextureProperty shaderTextureProperty = data._customShaderPropNames.Find((ShaderTextureProperty x) => x.name.Equals(data.texPropertyNames[i].name));
				if (shaderTextureProperty != null)
				{
					data._customShaderPropNames.Remove(shaderTextureProperty);
				}
			}
			Material resultMaterial = data.resultMaterial;
			if (resultMaterial == null)
			{
				UnityEngine.Debug.LogError("Please assign a result material. The combined mesh will use this material.");
				return false;
			}
			string text = "";
			for (int j = 0; j < shaderTexPropertyNames.Length; j++)
			{
				if (resultMaterial.HasProperty(shaderTexPropertyNames[j].name))
				{
					text = text + ", " + shaderTexPropertyNames[j].name;
					if (!data.texPropertyNames.Contains(shaderTexPropertyNames[j]))
					{
						data.texPropertyNames.Add(shaderTexPropertyNames[j]);
					}
					if (resultMaterial.GetTextureOffset(shaderTexPropertyNames[j].name) != new Vector2(0f, 0f) && LOG_LEVEL >= MB2_LogLevel.warn)
					{
						UnityEngine.Debug.LogWarning("Result material has non-zero offset. This is may be incorrect.");
					}
					if (resultMaterial.GetTextureScale(shaderTexPropertyNames[j].name) != new Vector2(1f, 1f) && LOG_LEVEL >= MB2_LogLevel.warn)
					{
						UnityEngine.Debug.LogWarning("Result material should have tiling of 1,1");
					}
				}
			}
			for (int k = 0; k < data._customShaderPropNames.Count; k++)
			{
				if (resultMaterial.HasProperty(data._customShaderPropNames[k].name))
				{
					text = text + ", " + data._customShaderPropNames[k].name;
					data.texPropertyNames.Add(data._customShaderPropNames[k]);
					if (resultMaterial.GetTextureOffset(data._customShaderPropNames[k].name) != new Vector2(0f, 0f) && LOG_LEVEL >= MB2_LogLevel.warn)
					{
						UnityEngine.Debug.LogWarning("Result material has non-zero offset. This is probably incorrect.");
					}
					if (resultMaterial.GetTextureScale(data._customShaderPropNames[k].name) != new Vector2(1f, 1f) && LOG_LEVEL >= MB2_LogLevel.warn)
					{
						UnityEngine.Debug.LogWarning("Result material should probably have tiling of 1,1.");
					}
				}
				else if (LOG_LEVEL >= MB2_LogLevel.warn)
				{
					UnityEngine.Debug.LogWarning("Result material shader does not use property " + data._customShaderPropNames[k].name + " in the list of custom shader property names");
				}
			}
			return true;
		}

		internal static bool _ShouldWeCreateAtlasForThisProperty(int propertyIndex, CreateAtlasForProperty[] allTexturesAreNullAndSameColor, TexturePipelineData data)
		{
			CreateAtlasForProperty createAtlasForProperty = allTexturesAreNullAndSameColor[propertyIndex];
			if (data._considerNonTextureProperties)
			{
				if (!createAtlasForProperty.allNonTexturePropsAreSame || !createAtlasForProperty.allTexturesAreNull)
				{
					return true;
				}
				return false;
			}
			if (!createAtlasForProperty.allTexturesAreNull)
			{
				return true;
			}
			return false;
		}

		public static Texture GetTextureConsideringStandardShaderKeywords(string shaderName, Material mat, string propertyName)
		{
			if ((shaderName.Equals("Standard") || shaderName.Equals("Standard (Specular setup)") || shaderName.Equals("Standard (Roughness setup")) && propertyName.Equals("_EmissionMap"))
			{
				if (mat.IsKeywordEnabled("_EMISSION"))
				{
					return mat.GetTexture(propertyName);
				}
				return null;
			}
			return mat.GetTexture(propertyName);
		}

		internal static IEnumerator __Step1_CollectDistinctMatTexturesAndUsedObjects(ProgressUpdateDelegate progressInfo, MB3_TextureCombiner.CombineTexturesIntoAtlasesCoroutineResult result, TexturePipelineData data, MB3_TextureCombiner combiner, MB2_EditorMethodsInterface textureEditorMethods, List<GameObject> usedObjsToMesh, MB2_LogLevel LOG_LEVEL)
		{
			Stopwatch stopwatch = new Stopwatch();
			stopwatch.Start();
			bool flag = false;
			Dictionary<int, MB_Utility.MeshAnalysisResult[]> dictionary = new Dictionary<int, MB_Utility.MeshAnalysisResult[]>();
			for (int i = 0; i < data.allObjsToMesh.Count; i++)
			{
				GameObject gameObject = data.allObjsToMesh[i];
				progressInfo?.Invoke("Collecting textures for " + gameObject, (float)i / (float)data.allObjsToMesh.Count / 2f);
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					UnityEngine.Debug.Log("Collecting textures for object " + gameObject);
				}
				if (gameObject == null)
				{
					UnityEngine.Debug.LogError("The list of objects to mesh contained nulls.");
					result.success = false;
					yield break;
				}
				Mesh mesh = MB_Utility.GetMesh(gameObject);
				if (mesh == null)
				{
					UnityEngine.Debug.LogError("Object " + gameObject.name + " in the list of objects to mesh has no mesh.");
					result.success = false;
					yield break;
				}
				Material[] gOMaterials = MB_Utility.GetGOMaterials(gameObject);
				if (gOMaterials.Length == 0)
				{
					UnityEngine.Debug.LogError("Object " + gameObject.name + " in the list of objects has no materials.");
					result.success = false;
					yield break;
				}
				if (!dictionary.TryGetValue(mesh.GetInstanceID(), out var value))
				{
					value = new MB_Utility.MeshAnalysisResult[mesh.subMeshCount];
					for (int j = 0; j < mesh.subMeshCount; j++)
					{
						MB_Utility.hasOutOfBoundsUVs(mesh, ref value[j], j);
						if (data._normalizeTexelDensity)
						{
							value[j].submeshArea = GetSubmeshArea(mesh, j);
						}
						if (data._fixOutOfBoundsUVs && !value[j].hasUVs)
						{
							value[j].uvRect = new Rect(0f, 0f, 1f, 1f);
							UnityEngine.Debug.LogWarning("Mesh for object " + gameObject?.ToString() + " has no UV channel but 'consider UVs' is enabled. Assuming UVs will be generated filling 0,0,1,1 rectangle.");
						}
					}
					dictionary.Add(mesh.GetInstanceID(), value);
				}
				if (data._fixOutOfBoundsUVs && LOG_LEVEL >= MB2_LogLevel.trace)
				{
					string[] obj = new string[8]
					{
						"Mesh Analysis for object ",
						gameObject?.ToString(),
						" numSubmesh=",
						value.Length.ToString(),
						" HasOBUV=",
						value[0].hasOutOfBoundsUVs.ToString(),
						" UVrectSubmesh0=",
						null
					};
					Rect uvRect = value[0].uvRect;
					obj[7] = uvRect.ToString();
					UnityEngine.Debug.Log(string.Concat(obj));
				}
				for (int k = 0; k < gOMaterials.Length; k++)
				{
					progressInfo?.Invoke($"Collecting textures for {gameObject} submesh {k}", (float)i / (float)data.allObjsToMesh.Count / 2f);
					Material material = gOMaterials[k];
					if (data.allowedMaterialsFilter != null && !data.allowedMaterialsFilter.Contains(material))
					{
						continue;
					}
					flag = flag || value[k].hasOutOfBoundsUVs;
					if (material.name.Contains("(Instance)"))
					{
						UnityEngine.Debug.LogError("The sharedMaterial on object " + gameObject.name + " has been 'Instanced'. This was probably caused by a script accessing the meshRender.material property in the editor.  The material to UV Rectangle mapping will be incorrect. To fix this recreate the object from its prefab or re-assign its material from the correct asset.");
						result.success = false;
						yield break;
					}
					if (data._fixOutOfBoundsUVs && !MB_Utility.AreAllSharedMaterialsDistinct(gOMaterials) && LOG_LEVEL >= MB2_LogLevel.warn)
					{
						UnityEngine.Debug.LogWarning("Object " + gameObject.name + " uses the same material on multiple submeshes. This may generate strange resultAtlasesAndRects especially when used with fix out of bounds uvs. Try duplicating the material.");
					}
					MeshBakerMaterialTexture[] array = new MeshBakerMaterialTexture[data.texPropertyNames.Count];
					for (int l = 0; l < data.texPropertyNames.Count; l++)
					{
						Texture texture = null;
						Vector2 matTilingScale = Vector2.one;
						Vector2 matTilingOffset = Vector2.zero;
						float texelDens = 0f;
						if (material.HasProperty(data.texPropertyNames[l].name))
						{
							Texture textureConsideringStandardShaderKeywords = GetTextureConsideringStandardShaderKeywords(data.resultMaterial.shader.name, material, data.texPropertyNames[l].name);
							if (textureConsideringStandardShaderKeywords != null)
							{
								if (!(textureConsideringStandardShaderKeywords is Texture2D))
								{
									UnityEngine.Debug.LogError("Object " + gameObject.name + " in the list of objects to mesh uses a Texture that is not a Texture2D. Cannot build atlases.");
									result.success = false;
									yield break;
								}
								texture = textureConsideringStandardShaderKeywords;
								TextureFormat format = ((Texture2D)texture).format;
								bool flag2 = false;
								if (!UnityEngine.Application.isPlaying && textureEditorMethods != null)
								{
									flag2 = textureEditorMethods.IsNormalMap((Texture2D)texture);
								}
								if ((format != TextureFormat.ARGB32 && format != TextureFormat.RGBA32 && format != TextureFormat.BGRA32 && format != TextureFormat.RGB24 && format != TextureFormat.Alpha8) || flag2)
								{
									if (UnityEngine.Application.isPlaying && data._packingAlgorithm != MB2_PackingAlgorithmEnum.MeshBakerTexturePacker_Fast)
									{
										UnityEngine.Debug.LogError("Object " + gameObject.name + " in the list of objects to mesh uses Texture " + texture.name + " uses format " + format.ToString() + " that is not in: ARGB32, RGBA32, BGRA32, RGB24, Alpha8 or DXT. These textures cannot be resized at runtime. Try changing texture format. If format says 'compressed' try changing it to 'truecolor'");
										result.success = false;
										yield break;
									}
									texture = (Texture2D)material.GetTexture(data.texPropertyNames[l].name);
								}
							}
							if (texture != null && data._normalizeTexelDensity)
							{
								texelDens = ((value[l].submeshArea != 0f) ? ((float)(texture.width * texture.height) / value[l].submeshArea) : 0f);
							}
							matTilingScale = material.GetTextureScale(data.texPropertyNames[l].name);
							matTilingOffset = material.GetTextureOffset(data.texPropertyNames[l].name);
						}
						array[l] = new MeshBakerMaterialTexture(texture, matTilingOffset, matTilingScale, texelDens);
					}
					data.nonTexturePropertyBlender.CollectAverageValuesOfNonTextureProperties(data.resultMaterial, material);
					Vector2 vector = new Vector2(value[k].uvRect.width, value[k].uvRect.height);
					Vector2 vector2 = new Vector2(value[k].uvRect.x, value[k].uvRect.y);
					MB_TextureTilingTreatment treatment = MB_TextureTilingTreatment.none;
					if (data._fixOutOfBoundsUVs)
					{
						treatment = MB_TextureTilingTreatment.considerUVs;
					}
					MB_TexSet setOfTexs = new MB_TexSet(array, vector2, vector, treatment);
					MatAndTransformToMerged item = new MatAndTransformToMerged(new DRect(vector2, vector), data._fixOutOfBoundsUVs, material);
					setOfTexs.matsAndGOs.mats.Add(item);
					MB_TexSet mB_TexSet = data.distinctMaterialTextures.Find((MB_TexSet x) => x.IsEqual(setOfTexs, data._fixOutOfBoundsUVs, data.nonTexturePropertyBlender));
					if (mB_TexSet != null)
					{
						setOfTexs = mB_TexSet;
					}
					else
					{
						data.distinctMaterialTextures.Add(setOfTexs);
					}
					if (!setOfTexs.matsAndGOs.mats.Contains(item))
					{
						setOfTexs.matsAndGOs.mats.Add(item);
					}
					if (!setOfTexs.matsAndGOs.gos.Contains(gameObject))
					{
						setOfTexs.matsAndGOs.gos.Add(gameObject);
						if (!usedObjsToMesh.Contains(gameObject))
						{
							usedObjsToMesh.Add(gameObject);
						}
					}
				}
			}
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log($"Step1_CollectDistinctTextures collected {data.distinctMaterialTextures.Count} sets of textures fixOutOfBoundsUV={data._fixOutOfBoundsUVs} considerNonTextureProperties={data._considerNonTextureProperties}");
			}
			if (data.distinctMaterialTextures.Count == 0)
			{
				UnityEngine.Debug.LogError("None of the source object materials matched any of the allowed materials for this submesh.");
				result.success = false;
				yield break;
			}
			new MB3_TextureCombinerMerging(data._considerNonTextureProperties, data.nonTexturePropertyBlender, data._fixOutOfBoundsUVs, LOG_LEVEL).MergeOverlappingDistinctMaterialTexturesAndCalcMaterialSubrects(data.distinctMaterialTextures);
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log("Total time Step1_CollectDistinctTextures " + stopwatch.ElapsedMilliseconds.ToString("f5"));
			}
		}

		private static CreateAtlasForProperty[] CalculateAllTexturesAreNullAndSameColor(TexturePipelineData data, MB2_LogLevel LOG_LEVEL)
		{
			CreateAtlasForProperty[] array = new CreateAtlasForProperty[data.texPropertyNames.Count];
			for (int i = 0; i < data.texPropertyNames.Count; i++)
			{
				MeshBakerMaterialTexture meshBakerMaterialTexture = data.distinctMaterialTextures[0].ts[i];
				Color color = Color.black;
				if (data._considerNonTextureProperties)
				{
					color = data.nonTexturePropertyBlender.GetColorAsItWouldAppearInAtlasIfNoTexture(data.distinctMaterialTextures[0].matsAndGOs.mats[0].mat, data.texPropertyNames[i]);
				}
				int num = 0;
				int num2 = 0;
				int num3 = 0;
				for (int j = 0; j < data.distinctMaterialTextures.Count; j++)
				{
					if (!data.distinctMaterialTextures[j].ts[i].isNull)
					{
						num++;
					}
					if (meshBakerMaterialTexture.AreTexturesEqual(data.distinctMaterialTextures[j].ts[i]))
					{
						num2++;
					}
					if (data._considerNonTextureProperties && data.nonTexturePropertyBlender.GetColorAsItWouldAppearInAtlasIfNoTexture(data.distinctMaterialTextures[j].matsAndGOs.mats[0].mat, data.texPropertyNames[i]) == color)
					{
						num3++;
					}
				}
				array[i].allTexturesAreNull = num == 0;
				array[i].allTexturesAreSame = num2 == data.distinctMaterialTextures.Count;
				array[i].allNonTexturePropsAreSame = num3 == data.distinctMaterialTextures.Count;
				if (LOG_LEVEL >= MB2_LogLevel.trace)
				{
					UnityEngine.Debug.Log($"AllTexturesAreNullAndSameColor prop: {data.texPropertyNames[i].name} createAtlas:{_ShouldWeCreateAtlasForThisProperty(i, data._considerNonTextureProperties, array)}  val:{array[i]}");
				}
			}
			return array;
		}

		internal static IEnumerator CalculateIdealSizesForTexturesInAtlasAndPadding(ProgressUpdateDelegate progressInfo, MB3_TextureCombiner.CombineTexturesIntoAtlasesCoroutineResult result, TexturePipelineData data, MB3_TextureCombiner combiner, MB2_EditorMethodsInterface textureEditorMethods, MB2_LogLevel LOG_LEVEL)
		{
			Stopwatch stopwatch = new Stopwatch();
			stopwatch.Start();
			MeshBakerMaterialTexture.readyToBuildAtlases = true;
			data.allTexturesAreNullAndSameColor = CalculateAllTexturesAreNullAndSameColor(data, LOG_LEVEL);
			int num = data._atlasPadding;
			if (data.distinctMaterialTextures.Count == 1 && !data._fixOutOfBoundsUVs && !data._considerNonTextureProperties)
			{
				if (LOG_LEVEL >= MB2_LogLevel.info)
				{
					UnityEngine.Debug.Log("All objects use the same textures in this set of atlases. Original textures will be reused instead of creating atlases.");
				}
				num = 0;
				data.distinctMaterialTextures[0].SetThisIsOnlyTexSetInAtlasTrue();
				data.distinctMaterialTextures[0].SetTilingTreatmentAndAdjustEncapsulatingSamplingRect(MB_TextureTilingTreatment.edgeToEdgeXY);
			}
			for (int i = 0; i < data.distinctMaterialTextures.Count; i++)
			{
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					UnityEngine.Debug.Log("Calculating ideal sizes for texSet TexSet " + i + " of " + data.distinctMaterialTextures.Count);
				}
				MB_TexSet mB_TexSet = data.distinctMaterialTextures[i];
				mB_TexSet.idealWidth = 1;
				mB_TexSet.idealHeight = 1;
				int num2 = 1;
				int num3 = 1;
				for (int j = 0; j < data.texPropertyNames.Count; j++)
				{
					if (!_ShouldWeCreateAtlasForThisProperty(j, data._considerNonTextureProperties, data.allTexturesAreNullAndSameColor))
					{
						continue;
					}
					MeshBakerMaterialTexture meshBakerMaterialTexture = mB_TexSet.ts[j];
					if (LOG_LEVEL >= MB2_LogLevel.trace)
					{
						UnityEngine.Debug.Log($"Calculating ideal size for texSet {i} property {data.texPropertyNames[j].name}");
					}
					if (!meshBakerMaterialTexture.matTilingRect.size.Equals(Vector2.one) && data.distinctMaterialTextures.Count > 1 && LOG_LEVEL >= MB2_LogLevel.warn)
					{
						UnityEngine.Debug.LogWarning("Texture " + meshBakerMaterialTexture.GetTexName() + "is tiled by " + meshBakerMaterialTexture.matTilingRect.size.ToString() + " tiling will be baked into a texture with maxSize:" + data._maxTilingBakeSize);
					}
					if (!mB_TexSet.obUVscale.Equals(Vector2.one) && data.distinctMaterialTextures.Count > 1 && data._fixOutOfBoundsUVs && LOG_LEVEL >= MB2_LogLevel.warn)
					{
						UnityEngine.Debug.LogWarning("Texture " + meshBakerMaterialTexture.GetTexName() + " has out of bounds UVs that effectively tile by " + mB_TexSet.obUVscale.ToString() + " tiling will be baked into a texture with maxSize:" + data._maxTilingBakeSize);
					}
					if (meshBakerMaterialTexture.isNull)
					{
						mB_TexSet.SetEncapsulatingRect(j, data._fixOutOfBoundsUVs);
						if (LOG_LEVEL >= MB2_LogLevel.trace)
						{
							UnityEngine.Debug.Log($"No source texture creating a 16x16 texture for {data.texPropertyNames[j].name} texSet {i} srcMat {mB_TexSet.matsAndGOs.mats[0].GetMaterialName()}");
						}
					}
					if (meshBakerMaterialTexture.isNull)
					{
						continue;
					}
					Vector2 adjustedForScaleAndOffset2Dimensions = GetAdjustedForScaleAndOffset2Dimensions(meshBakerMaterialTexture, mB_TexSet.obUVoffset, mB_TexSet.obUVscale, data, LOG_LEVEL);
					if ((int)(adjustedForScaleAndOffset2Dimensions.x * adjustedForScaleAndOffset2Dimensions.y) > num2 * num3)
					{
						if (LOG_LEVEL >= MB2_LogLevel.trace)
						{
							string[] obj = new string[8]
							{
								"    matTex ",
								meshBakerMaterialTexture.GetTexName(),
								" ",
								null,
								null,
								null,
								null,
								null
							};
							Vector2 vector = adjustedForScaleAndOffset2Dimensions;
							obj[3] = vector.ToString();
							obj[4] = " has a bigger size than ";
							obj[5] = num2.ToString();
							obj[6] = " ";
							obj[7] = num3.ToString();
							UnityEngine.Debug.Log(string.Concat(obj));
						}
						num2 = (int)adjustedForScaleAndOffset2Dimensions.x;
						num3 = (int)adjustedForScaleAndOffset2Dimensions.y;
					}
				}
				if (data._resizePowerOfTwoTextures)
				{
					if (num2 <= num * 5)
					{
						UnityEngine.Debug.LogWarning(string.Format("Some of the textures have widths close to the size of the padding. It is not recommended to use _resizePowerOfTwoTextures with widths this small.", mB_TexSet.ToString()));
					}
					if (num3 <= num * 5)
					{
						UnityEngine.Debug.LogWarning(string.Format("Some of the textures have heights close to the size of the padding. It is not recommended to use _resizePowerOfTwoTextures with heights this small.", mB_TexSet.ToString()));
					}
					if (IsPowerOfTwo(num2))
					{
						num2 -= num * 2;
					}
					if (IsPowerOfTwo(num3))
					{
						num3 -= num * 2;
					}
					if (num2 < 1)
					{
						num2 = 1;
					}
					if (num3 < 1)
					{
						num3 = 1;
					}
				}
				if (LOG_LEVEL >= MB2_LogLevel.trace)
				{
					UnityEngine.Debug.Log("    Ideal size is " + num2 + " " + num3);
				}
				mB_TexSet.idealWidth = num2;
				mB_TexSet.idealHeight = num3;
			}
			data._atlasPadding = num;
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log("Total time Step2 Calculate Ideal Sizes part1: " + stopwatch.Elapsed.ToString());
			}
			yield break;
		}

		internal static AtlasPackingResult[] __Step3_RunTexturePacker(TexturePipelineData data, MB_ITextureCombinerPacker texturePacker, MB2_LogLevel LOG_LEVEL)
		{
			AtlasPackingResult[] array = texturePacker.CalculateAtlasRectangles(data, doMultiAtlas: true, LOG_LEVEL);
			for (int i = 0; i < array.Length; i++)
			{
				List<MatsAndGOs> list = new List<MatsAndGOs>();
				array[i].data = list;
				for (int j = 0; j < array[i].srcImgIdxs.Length; j++)
				{
					MB_TexSet mB_TexSet = data.distinctMaterialTextures[array[i].srcImgIdxs[j]];
					list.Add(mB_TexSet.matsAndGOs);
				}
			}
			return array;
		}

		internal static MB_ITextureCombinerPacker CreatePacker(bool onlyOneTextureInAtlasReuseTextures, MB2_PackingAlgorithmEnum packingAlgorithm)
		{
			if (onlyOneTextureInAtlasReuseTextures)
			{
				return new MB3_TextureCombinerPackerOneTextureInAtlas();
			}
			switch (packingAlgorithm)
			{
			case MB2_PackingAlgorithmEnum.UnitysPackTextures:
				return new MB3_TextureCombinerPackerUnity();
			case MB2_PackingAlgorithmEnum.MeshBakerTexturePacker_Horizontal:
				if (USE_EXPERIMENTAL_HOIZONTALVERTICAL)
				{
					return new MB3_TextureCombinerPackerMeshBakerHorizontalVertical(MB3_TextureCombinerPackerMeshBakerHorizontalVertical.AtlasDirection.horizontal);
				}
				return new MB3_TextureCombinerPackerMeshBaker();
			case MB2_PackingAlgorithmEnum.MeshBakerTexturePacker_Vertical:
				if (USE_EXPERIMENTAL_HOIZONTALVERTICAL)
				{
					return new MB3_TextureCombinerPackerMeshBakerHorizontalVertical(MB3_TextureCombinerPackerMeshBakerHorizontalVertical.AtlasDirection.vertical);
				}
				return new MB3_TextureCombinerPackerMeshBaker();
			case MB2_PackingAlgorithmEnum.MeshBakerTexturePacker:
				return new MB3_TextureCombinerPackerMeshBaker();
			default:
				return new MB3_TextureCombinerPackerMeshBakerFast();
			}
		}

		internal static IEnumerator __Step3_BuildAndSaveAtlasesAndStoreResults(MB3_TextureCombiner.CombineTexturesIntoAtlasesCoroutineResult result, ProgressUpdateDelegate progressInfo, TexturePipelineData data, MB3_TextureCombiner combiner, MB_ITextureCombinerPacker packer, AtlasPackingResult atlasPackingResult, MB2_EditorMethodsInterface textureEditorMethods, MB_AtlasesAndRects resultAtlasesAndRects, StringBuilder report, MB2_LogLevel LOG_LEVEL)
		{
			Stopwatch sw = new Stopwatch();
			sw.Start();
			GC.Collect();
			Texture2D[] atlases = new Texture2D[data.numAtlases];
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log("time Step 3 Create And Save Atlases part 1 " + sw.Elapsed.ToString());
			}
			yield return packer.CreateAtlases(progressInfo, data, combiner, atlasPackingResult, atlases, textureEditorMethods, LOG_LEVEL);
			float num = sw.ElapsedMilliseconds;
			data.nonTexturePropertyBlender.AdjustNonTextureProperties(data.resultMaterial, data.texPropertyNames, data.distinctMaterialTextures, textureEditorMethods);
			if (data.distinctMaterialTextures.Count > 0)
			{
				data.distinctMaterialTextures[0].AdjustResultMaterialNonTextureProperties(data.resultMaterial, data.texPropertyNames);
			}
			progressInfo?.Invoke("Building Report", 0.7f);
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.AppendLine("---- Atlases ------");
			for (int i = 0; i < data.numAtlases; i++)
			{
				if (atlases[i] != null)
				{
					stringBuilder.AppendLine("Created Atlas For: " + data.texPropertyNames[i].name + " h=" + atlases[i].height + " w=" + atlases[i].width);
				}
				else if (!_ShouldWeCreateAtlasForThisProperty(i, data._considerNonTextureProperties, data.allTexturesAreNullAndSameColor))
				{
					stringBuilder.AppendLine("Did not create atlas for " + data.texPropertyNames[i].name + " because all source textures were null.");
				}
			}
			report.Append(stringBuilder.ToString());
			List<MB_MaterialAndUVRect> list = new List<MB_MaterialAndUVRect>();
			for (int j = 0; j < data.distinctMaterialTextures.Count; j++)
			{
				MB_TexSet mB_TexSet = data.distinctMaterialTextures[j];
				List<MatAndTransformToMerged> mats = mB_TexSet.matsAndGOs.mats;
				mB_TexSet.GetRectsForTextureBakeResults(out var allPropsUseSameTiling_encapsulatingSamplingRect, out var propsUseDifferntTiling_obUVRect);
				for (int k = 0; k < mats.Count; k++)
				{
					Rect materialTilingRectForTextureBakerResults = mB_TexSet.GetMaterialTilingRectForTextureBakerResults(k);
					MB_MaterialAndUVRect item = new MB_MaterialAndUVRect(mats[k].mat, atlasPackingResult.rects[j], mB_TexSet.allTexturesUseSameMatTiling, materialTilingRectForTextureBakerResults, allPropsUseSameTiling_encapsulatingSamplingRect, propsUseDifferntTiling_obUVRect, mB_TexSet.tilingTreatment, mats[k].objName);
					if (!list.Contains(item))
					{
						list.Add(item);
					}
				}
			}
			resultAtlasesAndRects.atlases = atlases;
			resultAtlasesAndRects.texPropertyNames = ShaderTextureProperty.GetNames(data.texPropertyNames);
			resultAtlasesAndRects.mat2rect_map = list;
			progressInfo?.Invoke("Restoring Texture Formats & Read Flags", 0.8f);
			combiner._destroyAllTemporaryTextures();
			textureEditorMethods?.RestoreReadFlagsAndFormats(progressInfo);
			if (report != null && LOG_LEVEL >= MB2_LogLevel.info)
			{
				UnityEngine.Debug.Log(report.ToString());
			}
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log("Time Step 3 Create And Save Atlases part 3 " + ((float)sw.ElapsedMilliseconds - num).ToString("f5"));
			}
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log("Total time Step 3 Create And Save Atlases " + sw.Elapsed.ToString());
			}
		}

		internal static StringBuilder GenerateReport(TexturePipelineData data)
		{
			StringBuilder stringBuilder = new StringBuilder();
			if (data.numAtlases > 0)
			{
				stringBuilder = new StringBuilder();
				stringBuilder.AppendLine("Report");
				for (int i = 0; i < data.distinctMaterialTextures.Count; i++)
				{
					MB_TexSet mB_TexSet = data.distinctMaterialTextures[i];
					stringBuilder.AppendLine("----------");
					stringBuilder.Append("This set of textures will be resized to:" + mB_TexSet.idealWidth + "x" + mB_TexSet.idealHeight + "\n");
					for (int j = 0; j < mB_TexSet.ts.Length; j++)
					{
						if (!mB_TexSet.ts[j].isNull)
						{
							stringBuilder.Append("   [" + data.texPropertyNames[j].name + " " + mB_TexSet.ts[j].GetTexName() + " " + mB_TexSet.ts[j].width + "x" + mB_TexSet.ts[j].height + "]");
							if (mB_TexSet.ts[j].matTilingRect.size != Vector2.one || mB_TexSet.ts[j].matTilingRect.min != Vector2.zero)
							{
								stringBuilder.AppendFormat(" material scale {0} offset{1} ", mB_TexSet.ts[j].matTilingRect.size.ToString("G4"), mB_TexSet.ts[j].matTilingRect.min.ToString("G4"));
							}
							if (mB_TexSet.obUVscale != Vector2.one || mB_TexSet.obUVoffset != Vector2.zero)
							{
								stringBuilder.AppendFormat(" obUV scale {0} offset{1} ", mB_TexSet.obUVscale.ToString("G4"), mB_TexSet.obUVoffset.ToString("G4"));
							}
							stringBuilder.AppendLine("");
						}
						else
						{
							stringBuilder.Append("   [" + data.texPropertyNames[j].name + " null ");
							if (!_ShouldWeCreateAtlasForThisProperty(j, data._considerNonTextureProperties, data.allTexturesAreNullAndSameColor))
							{
								stringBuilder.Append("no atlas will be created all textures null]\n");
							}
							else
							{
								stringBuilder.AppendFormat("a 16x16 texture will be created]\n");
							}
						}
					}
					stringBuilder.AppendLine("");
					stringBuilder.Append("Materials using:");
					for (int k = 0; k < mB_TexSet.matsAndGOs.mats.Count; k++)
					{
						stringBuilder.Append(mB_TexSet.matsAndGOs.mats[k].mat.name + ", ");
					}
					stringBuilder.AppendLine("");
				}
			}
			return stringBuilder;
		}

		internal static MB2_TexturePacker CreateTexturePacker(MB2_PackingAlgorithmEnum _packingAlgorithm)
		{
			switch (_packingAlgorithm)
			{
			case MB2_PackingAlgorithmEnum.MeshBakerTexturePacker:
				return new MB2_TexturePackerRegular();
			case MB2_PackingAlgorithmEnum.MeshBakerTexturePacker_Fast:
				return new MB2_TexturePackerRegular();
			case MB2_PackingAlgorithmEnum.MeshBakerTexturePacker_Horizontal:
				return new MB2_TexturePackerHorizontalVert
				{
					packingOrientation = MB2_TexturePackerHorizontalVert.TexturePackingOrientation.horizontal
				};
			case MB2_PackingAlgorithmEnum.MeshBakerTexturePacker_Vertical:
				return new MB2_TexturePackerHorizontalVert
				{
					packingOrientation = MB2_TexturePackerHorizontalVert.TexturePackingOrientation.vertical
				};
			default:
				UnityEngine.Debug.LogError("packing algorithm must be one of the MeshBaker options to create a Texture Packer");
				return null;
			}
		}

		internal static Vector2 GetAdjustedForScaleAndOffset2Dimensions(MeshBakerMaterialTexture source, Vector2 obUVoffset, Vector2 obUVscale, TexturePipelineData data, MB2_LogLevel LOG_LEVEL)
		{
			if (source.matTilingRect.x == 0.0 && source.matTilingRect.y == 0.0 && source.matTilingRect.width == 1.0 && source.matTilingRect.height == 1.0)
			{
				if (!data._fixOutOfBoundsUVs)
				{
					return new Vector2(source.width, source.height);
				}
				if (obUVoffset.x == 0f && obUVoffset.y == 0f && obUVscale.x == 1f && obUVscale.y == 1f)
				{
					return new Vector2(source.width, source.height);
				}
			}
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				string[] obj = new string[6]
				{
					"GetAdjustedForScaleAndOffset2Dimensions: ",
					source.GetTexName(),
					" ",
					null,
					null,
					null
				};
				Vector2 vector = obUVoffset;
				obj[3] = vector.ToString();
				obj[4] = " ";
				vector = obUVscale;
				obj[5] = vector.ToString();
				UnityEngine.Debug.Log(string.Concat(obj));
			}
			Rect rect = source.GetEncapsulatingSamplingRect().GetRect();
			float num = rect.width * (float)source.width;
			float num2 = rect.height * (float)source.height;
			if (num > (float)data._maxTilingBakeSize)
			{
				num = data._maxTilingBakeSize;
			}
			if (num2 > (float)data._maxTilingBakeSize)
			{
				num2 = data._maxTilingBakeSize;
			}
			if (num < 1f)
			{
				num = 1f;
			}
			if (num2 < 1f)
			{
				num2 = 1f;
			}
			return new Vector2(num, num2);
		}

		internal static Color32 ConvertNormalFormatFromUnity_ToStandard(Color32 c)
		{
			Vector3 zero = Vector3.zero;
			zero.x = (float)(int)c.a * 2f - 1f;
			zero.y = (float)(int)c.g * 2f - 1f;
			zero.z = Mathf.Sqrt(1f - zero.x * zero.x - zero.y * zero.y);
			Color32 result = default(Color32);
			result.a = 1;
			result.r = (byte)((zero.x + 1f) * 0.5f);
			result.g = (byte)((zero.y + 1f) * 0.5f);
			result.b = (byte)((zero.z + 1f) * 0.5f);
			return result;
		}

		internal static float GetSubmeshArea(Mesh m, int submeshIdx)
		{
			if (submeshIdx >= m.subMeshCount || submeshIdx < 0)
			{
				return 0f;
			}
			Vector3[] vertices = m.vertices;
			int[] indices = m.GetIndices(submeshIdx);
			float num = 0f;
			for (int i = 0; i < indices.Length; i += 3)
			{
				Vector3 vector = vertices[indices[i]];
				Vector3 vector2 = vertices[indices[i + 1]];
				Vector3 vector3 = vertices[indices[i + 2]];
				num += Vector3.Cross(vector2 - vector, vector3 - vector).magnitude / 2f;
			}
			return num;
		}

		internal static bool IsPowerOfTwo(int x)
		{
			return (x & (x - 1)) == 0;
		}
	}
}
namespace YoutubeLight
{
	public class VideoNotAvailableException : Exception
	{
		public VideoNotAvailableException()
		{
		}

		public VideoNotAvailableException(string message)
			: base(message)
		{
		}
	}
	public class YoutubeParseException : Exception
	{
		public YoutubeParseException(string message, Exception innerException)
			: base(message, innerException)
		{
		}
	}
	internal static class HTTPHelperYoutube
	{
		public static string HtmlDecode(string value)
		{
			return value.DecodeHtmlChars();
		}

		public static string DecodeHtmlChars(this string source)
		{
			string[] array = source.Split(new string[1] { "&#x" }, StringSplitOptions.None);
			for (int i = 1; i < array.Length; i++)
			{
				int num = array[i].IndexOf(';');
				string value = array[i].Substring(0, num);
				try
				{
					int num2 = Convert.ToInt32(value, 16);
					array[i] = (char)num2 + array[i].Substring(num + 1);
				}
				catch
				{
				}
			}
			return string.Join("", array);
		}

		public static IDictionary<string, string> ParseQueryString(string s)
		{
			if (s.Contains("?"))
			{
				s = s.Substring(s.IndexOf('?') + 1);
			}
			Dictionary<string, string> dictionary = new Dictionary<string, string>();
			string[] array = Regex.Split(s, "&");
			for (int i = 0; i < array.Length; i++)
			{
				string[] array2 = Regex.Split(array[i], "=");
				dictionary.Add(array2[0], (array2.Length == 2) ? UrlDecode(array2[1]) : string.Empty);
			}
			return dictionary;
		}

		public static string ReplaceQueryStringParameter(string currentPageUrl, string paramToReplace, string newValue)
		{
			IDictionary<string, string> dictionary = ParseQueryString(currentPageUrl);
			dictionary[paramToReplace] = newValue;
			StringBuilder stringBuilder = new StringBuilder();
			bool flag = true;
			foreach (KeyValuePair<string, string> item in dictionary)
			{
				if (!flag)
				{
					stringBuilder.Append("&");
				}
				stringBuilder.Append(item.Key);
				stringBuilder.Append("=");
				stringBuilder.Append(item.Value);
				flag = false;
			}
			return new UriBuilder(currentPageUrl)
			{
				Query = stringBuilder.ToString()
			}.ToString();
		}

		public static string UrlDecode(string url)
		{
			return WWW.UnEscapeURL(url);
		}
	}
	internal static class MagicHands
	{
		private static string ApplyOperation(string cipher, string op)
		{
			switch (op[0])
			{
			case 'r':
				return new string(cipher.ToCharArray().Reverse().ToArray());
			case 'w':
			{
				int opIndex2 = GetOpIndex(op);
				return SwapFirstChar(cipher, opIndex2);
			}
			case 's':
			{
				int opIndex = GetOpIndex(op);
				return cipher.Substring(opIndex);
			}
			default:
				throw new NotImplementedException("Couldn't find cipher operation.");
			}
		}

		public static string DecipherWithOperations(string cipher, string operations)
		{
			return operations.Split(new string[1] { " " }, StringSplitOptions.RemoveEmptyEntries).Aggregate(cipher, ApplyOperation);
		}

		private static string GetFunctionFromLine(string currentLine)
		{
			return new Regex("\\w+\\.(?<functionID>\\w+)\\(").Match(currentLine).Groups["functionID"].Value;
		}

		private static int GetOpIndex(string op)
		{
			return int.Parse(new Regex(".(\\d+)").Match(op).Result("$1"));
		}

		private static string SwapFirstChar(string cipher, int index)
		{
			return new StringBuilder(cipher)
			{
				[0] = cipher[index],
				[index] = cipher[0]
			}.ToString();
		}
	}
	public class RequestResolver : MonoBehaviour
	{
		private class ExtractionInfo
		{
			public bool RequiresDecryption { get; set; }

			public Uri Uri { get; set; }
		}

		private const string RateBypassFlag = "ratebypass";

		private const string SignatureQuery = "signature";

		public List<VideoInfo> videoInfos;

		private string urlResult;

		private bool downloadString;

		public IEnumerator DecryptDownloadUrl(Action<string> callback, VideoInfo videoInfo)
		{
			IDictionary<string, string> dictionary = HTTPHelperYoutube.ParseQueryString(videoInfo.DownloadUrl);
			if (dictionary.ContainsKey("signature"))
			{
				string encryptedSignature = dictionary["signature"];
				string url = $"http://s.ytimg.com/yts/jsbin/player-{videoInfo.HtmlPlayerVersion}.js";
				yield return StartCoroutine(DownloadUrl(url));
				string input = urlResult;
				string pattern = "\\\"signature\",\\s?([a-zA-Z0-9\\$]+)\\(";
				string text = Regex.Match(input, pattern).Groups[1].Value;
				if (text.Contains("$"))
				{
					text = "\\" + text;
				}
				string pattern2 = "(?!h\\.)" + text + "=function\\(\\w+\\)\\{.*?\\}";
				string[] array = Regex.Match(input, pattern2, RegexOptions.Singleline).Value.Split(';');
				string text2 = "";
				string text3 = "";
				string text4 = "";
				string text5 = "";
				foreach (string item in array.Skip(1).Take(array.Length - 2))
				{
					if (!string.IsNullOrEmpty(text2) && !string.IsNullOrEmpty(text3) && !string.IsNullOrEmpty(text4))
					{
						break;
					}
					string functionFromLine = GetFunctionFromLine(item);
					string pattern3 = $"{functionFromLine}:\\bfunction\\b\\(\\w+\\)";
					string pattern4 = $"{functionFromLine}:\\bfunction\\b\\([a],b\\).(\\breturn\\b)?.?\\w+\\.";
					string pattern5 = $"{functionFromLine}:\\bfunction\\b\\(\\w+\\,\\w\\).\\bvar\\b.\\bc=a\\b";
					if (Regex.Match(input, pattern3).Success)
					{
						text2 = functionFromLine;
					}
					if (Regex.Match(input, pattern4).Success)
					{
						text3 = functionFromLine;
					}
					if (Regex.Match(input, pattern5).Success)
					{
						text4 = functionFromLine;
					}
				}
				foreach (string item2 in array.Skip(1).Take(array.Length - 2))
				{
					string functionFromLine = GetFunctionFromLine(item2);
					Match match;
					if ((match = Regex.Match(item2, "\\(\\w+,(?<index>\\d+)\\)")).Success && functionFromLine == text4)
					{
						text5 = text5 + "w" + match.Groups["index"].Value + " ";
					}
					if ((match = Regex.Match(item2, "\\(\\w+,(?<index>\\d+)\\)")).Success && functionFromLine == text3)
					{
						text5 = text5 + "s" + match.Groups["index"].Value + " ";
					}
					if (functionFromLine == text2)
					{
						text5 += "r ";
					}
				}
				text5 = text5.Trim();
				string newValue = MagicHands.DecipherWithOperations(encryptedSignature, text5);
				videoInfo.DownloadUrl = HTTPHelperYoutube.ReplaceQueryStringParameter(videoInfo.DownloadUrl, "signature", newValue);
				videoInfo.RequiresDecryption = false;
				callback(videoInfo.DownloadUrl);
			}
			else
			{
				yield return null;
			}
		}

		private static string GetFunctionFromLine(string currentLine)
		{
			return new Regex("\\w+\\.(?<functionID>\\w+)\\(").Match(currentLine).Groups["functionID"].Value;
		}

		public IEnumerator WebGlRequest(Action<string> callback, string id, string host)
		{
			UnityEngine.Debug.Log(host + "getvideo.php?videoid=" + id + "&type=Download");
			WWW request = new WWW(host + "getvideo.php?videoid=" + id + "&type=Download");
			yield return request;
			callback(request.text);
		}

		public IEnumerator GetDownloadUrls(Action callback, string videoUrl, bool decryptSignature = true)
		{
			if (videoUrl == null)
			{
				throw new ArgumentNullException("videoUrl");
			}
			if (!Uri.TryCreate(videoUrl, UriKind.Absolute, out var result) || (!(result.Scheme == Uri.UriSchemeHttp) && !(result.Scheme == Uri.UriSchemeHttps)))
			{
				videoUrl = "https://youtube.com/watch?v=" + videoUrl;
			}
			if (!TryNormalizeYoutubeUrl(videoUrl, out videoUrl))
			{
				throw new ArgumentException("URL is not a valid youtube URL!");
			}
			yield return StartCoroutine(DownloadUrl(videoUrl));
			string text = urlResult;
			if (IsVideoUnavailable(text))
			{
				throw new VideoNotAvailableException();
			}
			JObject json = JObject.Parse(new Regex("ytplayer\\.config\\s*=\\s*(\\{.+?\\});", RegexOptions.Multiline).Match(text).Result("$1"));
			List<VideoInfo> list = GetVideoInfos(videoTitle: GetVideoTitle(json), extractionInfos: ExtractDownloadUrls(json)).ToList();
			string html5PlayerVersion = GetHtml5PlayerVersion(json);
			foreach (VideoInfo item in list)
			{
				item.HtmlPlayerVersion = html5PlayerVersion;
				if (decryptSignature && item.RequiresDecryption)
				{
					UnityEngine.Debug.LogWarning("TO DECRYPT I RECOMMEND TO USE THE VIDEO INFO, not by here, made this to work with WebGl");
				}
			}
			videoInfos = list;
			callback();
		}

		public static bool TryNormalizeYoutubeUrl(string url, out string normalizedUrl)
		{
			url = url.Trim();
			url = url.Replace("youtu.be/", "youtube.com/watch?v=");
			url = url.Replace("www.youtube", "youtube");
			url = url.Replace("youtube.com/embed/", "youtube.com/watch?v=");
			if (url.Contains("/v/"))
			{
				url = "https://youtube.com" + new Uri(url).AbsolutePath.Replace("/v/", "/watch?v=");
			}
			url = url.Replace("/watch#", "/watch?");
			if (!HTTPHelperYoutube.ParseQueryString(url).TryGetValue("v", out var value))
			{
				normalizedUrl = null;
				return false;
			}
			normalizedUrl = "https://youtube.com/watch?v=" + value;
			return true;
		}

		private static IEnumerable<ExtractionInfo> ExtractDownloadUrls(JObject json)
		{
			string[] first = GetStreamMap(json).Split(',');
			string[] second = GetAdaptiveStreamMap(json).Split(',');
			first = Enumerable.Concat(first, second).ToArray();
			string[] array = first;
			for (int i = 0; i < array.Length; i++)
			{
				IDictionary<string, string> dictionary = HTTPHelperYoutube.ParseQueryString(array[i]);
				bool requiresDecryption = false;
				string text;
				if (dictionary.ContainsKey("s") || dictionary.ContainsKey("sig"))
				{
					requiresDecryption = dictionary.ContainsKey("s");
					string arg = (dictionary.ContainsKey("s") ? dictionary["s"] : dictionary["sig"]);
					text = string.Format("{0}&{1}={2}", dictionary["url"], "signature", arg);
					string text2 = (dictionary.ContainsKey("fallback_host") ? ("&fallback_host=" + dictionary["fallback_host"]) : string.Empty);
					text += text2;
				}
				else
				{
					text = dictionary["url"];
				}
				text = HTTPHelperYoutube.UrlDecode(text);
				text = HTTPHelperYoutube.UrlDecode(text);
				if (!HTTPHelperYoutube.ParseQueryString(text).ContainsKey("ratebypass"))
				{
					text += string.Format("&{0}={1}", "ratebypass", "yes");
				}
				yield return new ExtractionInfo
				{
					RequiresDecryption = requiresDecryption,
					Uri = new Uri(text)
				};
			}
		}

		private static string GetAdaptiveStreamMap(JObject json)
		{
			JToken jToken = json["args"]["adaptive_fmts"];
			if (jToken == null)
			{
				jToken = json["args"]["url_encoded_fmt_stream_map"];
			}
			return jToken.ToString();
		}

		private static string GetHtml5PlayerVersion(JObject json)
		{
			Regex regex = new Regex("player-(.+?).js");
			string input = json["assets"]["js"].ToString();
			return regex.Match(input).Result("$1");
		}

		private static string GetStreamMap(JObject json)
		{
			string text = json["args"]["url_encoded_fmt_stream_map"]?.ToString();
			if (text == null || text.Contains("been+removed"))
			{
				throw new VideoNotAvailableException("Video is removed or has an age restriction.");
			}
			return text;
		}

		private static IEnumerable<VideoInfo> GetVideoInfos(IEnumerable<ExtractionInfo> extractionInfos, string videoTitle)
		{
			List<VideoInfo> list = new List<VideoInfo>();
			foreach (ExtractionInfo extractionInfo in extractionInfos)
			{
				string s = HTTPHelperYoutube.ParseQueryString(extractionInfo.Uri.Query)["itag"];
				int formatCode = int.Parse(s);
				VideoInfo videoInfo2 = VideoInfo.Defaults.SingleOrDefault((VideoInfo videoInfo) => videoInfo.FormatCode == formatCode);
				videoInfo2 = ((videoInfo2 == null) ? new VideoInfo(formatCode)
				{
					DownloadUrl = extractionInfo.Uri.ToString()
				} : new VideoInfo(videoInfo2)
				{
					DownloadUrl = extractionInfo.Uri.ToString(),
					Title = videoTitle,
					RequiresDecryption = extractionInfo.RequiresDecryption
				});
				list.Add(videoInfo2);
			}
			return list;
		}

		private static string GetVideoTitle(JObject json)
		{
			JToken jToken = json["args"]["title"];
			if (jToken != null)
			{
				return jToken.ToString();
			}
			return string.Empty;
		}

		private static bool IsVideoUnavailable(string pageSource)
		{
			return pageSource.Contains("<div id=\"watch-player-unavailable\">");
		}

		private IEnumerator DownloadUrl(string url)
		{
			Dictionary<string, string> dictionary = new Dictionary<string, string>();
			dictionary.Add("User-Agent", "Golang_Spider_Bot/3.0");
			WWW request = new WWW(url, null, dictionary);
			yield return request;
			urlResult = request.text;
			UnityEngine.Debug.Log("result ok");
			downloadString = true;
		}

		private static void ThrowYoutubeParseException(Exception innerException, string videoUrl)
		{
			throw new YoutubeParseException("Could not parse the Youtube page for URL " + videoUrl + "\nThis may be due to a change of the Youtube page structure.\nPlease report this bug at kelvinparkour@gmail.com with a subject message 'Parse Error' ", innerException);
		}
	}
	public enum AudioType
	{
		Aac,
		Mp3,
		Vorbis,
		Unknown
	}
	public enum VideoType
	{
		Mobile,
		Flash,
		Mp4,
		WebM,
		Unknown
	}
	public enum AdaptiveType
	{
		None,
		Audio,
		Video
	}
	public class VideoInfo
	{
		internal static IEnumerable<VideoInfo> Defaults = new List<VideoInfo>
		{
			new VideoInfo(5, VideoType.Flash, 240, is3D: false, AudioType.Mp3, 64, AdaptiveType.None),
			new VideoInfo(6, VideoType.Flash, 270, is3D: false, AudioType.Mp3, 64, AdaptiveType.None),
			new VideoInfo(13, VideoType.Mobile, 0, is3D: false, AudioType.Aac, 0, AdaptiveType.None),
			new VideoInfo(17, VideoType.Mobile, 144, is3D: false, AudioType.Aac, 24, AdaptiveType.None),
			new VideoInfo(18, VideoType.Mp4, 360, is3D: false, AudioType.Aac, 96, AdaptiveType.None),
			new VideoInfo(22, VideoType.Mp4, 720, is3D: false, AudioType.Aac, 192, AdaptiveType.None),
			new VideoInfo(34, VideoType.Flash, 360, is3D: false, AudioType.Aac, 128, AdaptiveType.None),
			new VideoInfo(35, VideoType.Flash, 480, is3D: false, AudioType.Aac, 128, AdaptiveType.None),
			new VideoInfo(36, VideoType.Mobile, 240, is3D: false, AudioType.Aac, 38, AdaptiveType.None),
			new VideoInfo(37, VideoType.Mp4, 1080, is3D: false, AudioType.Aac, 192, AdaptiveType.None),
			new VideoInfo(38, VideoType.Mp4, 3072, is3D: false, AudioType.Aac, 192, AdaptiveType.None),
			new VideoInfo(43, VideoType.WebM, 360, is3D: false, AudioType.Vorbis, 128, AdaptiveType.None),
			new VideoInfo(44, VideoType.WebM, 480, is3D: false, AudioType.Vorbis, 128, AdaptiveType.None),
			new VideoInfo(45, VideoType.WebM, 720, is3D: false, AudioType.Vorbis, 192, AdaptiveType.None),
			new VideoInfo(46, VideoType.WebM, 1080, is3D: false, AudioType.Vorbis, 192, AdaptiveType.None),
			new VideoInfo(82, VideoType.Mp4, 360, is3D: true, AudioType.Aac, 96, AdaptiveType.None),
			new VideoInfo(83, VideoType.Mp4, 240, is3D: true, AudioType.Aac, 96, AdaptiveType.None),
			new VideoInfo(84, VideoType.Mp4, 720, is3D: true, AudioType.Aac, 152, AdaptiveType.None),
			new VideoInfo(85, VideoType.Mp4, 520, is3D: true, AudioType.Aac, 152, AdaptiveType.None),
			new VideoInfo(100, VideoType.WebM, 360, is3D: true, AudioType.Vorbis, 128, AdaptiveType.None),
			new VideoInfo(101, VideoType.WebM, 360, is3D: true, AudioType.Vorbis, 192, AdaptiveType.None),
			new VideoInfo(102, VideoType.WebM, 720, is3D: true, AudioType.Vorbis, 192, AdaptiveType.None),
			new VideoInfo(133, VideoType.Mp4, 240, is3D: false, AudioType.Unknown, 0, AdaptiveType.Video),
			new VideoInfo(134, VideoType.Mp4, 360, is3D: false, AudioType.Unknown, 0, AdaptiveType.Video),
			new VideoInfo(135, VideoType.Mp4, 480, is3D: false, AudioType.Unknown, 0, AdaptiveType.Video),
			new VideoInfo(136, VideoType.Mp4, 720, is3D: false, AudioType.Unknown, 0, AdaptiveType.Video),
			new VideoInfo(137, VideoType.Mp4, 1080, is3D: false, AudioType.Unknown, 0, AdaptiveType.Video),
			new VideoInfo(138, VideoType.Mp4, 2160, is3D: false, AudioType.Unknown, 0, AdaptiveType.Video),
			new VideoInfo(160, VideoType.Mp4, 144, is3D: false, AudioType.Unknown, 0, AdaptiveType.Video),
			new VideoInfo(242, VideoType.WebM, 240, is3D: false, AudioType.Unknown, 0, AdaptiveType.Video),
			new VideoInfo(243, VideoType.WebM, 360, is3D: false, AudioType.Unknown, 0, AdaptiveType.Video),
			new VideoInfo(244, VideoType.WebM, 480, is3D: false, AudioType.Unknown, 0, AdaptiveType.Video),
			new VideoInfo(247, VideoType.WebM, 720, is3D: false, AudioType.Unknown, 0, AdaptiveType.Video),
			new VideoInfo(248, VideoType.WebM, 1080, is3D: false, AudioType.Unknown, 0, AdaptiveType.Video),
			new VideoInfo(264, VideoType.Mp4, 1440, is3D: false, AudioType.Unknown, 0, AdaptiveType.Video),
			new VideoInfo(271, VideoType.WebM, 1440, is3D: false, AudioType.Unknown, 0, AdaptiveType.Video),
			new VideoInfo(272, VideoType.WebM, 2160, is3D: false, AudioType.Unknown, 0, AdaptiveType.Video),
			new VideoInfo(278, VideoType.WebM, 144, is3D: false, AudioType.Unknown, 0, AdaptiveType.Video),
			new VideoInfo(139, VideoType.Mp4, 0, is3D: false, AudioType.Aac, 48, AdaptiveType.Audio),
			new VideoInfo(140, VideoType.Mp4, 0, is3D: false, AudioType.Aac, 128, AdaptiveType.Audio),
			new VideoInfo(141, VideoType.Mp4, 0, is3D: false, AudioType.Aac, 256, AdaptiveType.Audio),
			new VideoInfo(171, VideoType.WebM, 0, is3D: false, AudioType.Vorbis, 128, AdaptiveType.Audio),
			new VideoInfo(172, VideoType.WebM, 0, is3D: false, AudioType.Vorbis, 192, AdaptiveType.Audio)
		};

		public AdaptiveType AdaptiveType { get; private set; }

		public int AudioBitrate { get; private set; }

		public string AudioExtension => AudioType switch
		{
			AudioType.Aac => ".aac", 
			AudioType.Mp3 => ".mp3", 
			AudioType.Vorbis => ".ogg", 
			_ => null, 
		};

		public AudioType AudioType { get; private set; }

		public bool CanExtractAudio => VideoType == VideoType.Flash;

		public string DownloadUrl { get; internal set; }

		public int FormatCode { get; private set; }

		public bool Is3D { get; private set; }

		public bool RequiresDecryption { get; internal set; }

		public int Resolution { get; private set; }

		public string Title { get; internal set; }

		public string VideoExtension => VideoType switch
		{
			VideoType.Mp4 => ".mp4", 
			VideoType.Mobile => ".3gp", 
			VideoType.Flash => ".flv", 
			VideoType.WebM => ".webm", 
			_ => null, 
		};

		public VideoType VideoType { get; private set; }

		internal string HtmlPlayerVersion { get; set; }

		internal VideoInfo(int formatCode)
			: this(formatCode, VideoType.Unknown, 0, is3D: false, AudioType.Unknown, 0, AdaptiveType.None)
		{
		}

		internal VideoInfo(VideoInfo info)
			: this(info.FormatCode, info.VideoType, info.Resolution, info.Is3D, info.AudioType, info.AudioBitrate, info.AdaptiveType)
		{
		}

		private VideoInfo(int formatCode, VideoType videoType, int resolution, bool is3D, AudioType audioType, int audioBitrate, AdaptiveType adaptiveType)
		{
			FormatCode = formatCode;
			VideoType = videoType;
			Resolution = resolution;
			Is3D = is3D;
			AudioType = audioType;
			AudioBitrate = audioBitrate;
			AdaptiveType = adaptiveType;
		}

		public override string ToString()
		{
			return $"Full Title: {Title + VideoExtension}, Type: {VideoType}, Resolution: {Resolution}p";
		}
	}
	public abstract class Downloader
	{
		public int? BytesToDownload { get; private set; }

		public string SavePath { get; private set; }

		public VideoInfo Video { get; private set; }

		public event EventHandler DownloadFinished;

		public event EventHandler DownloadStarted;

		protected Downloader(VideoInfo video, string savePath, int? bytesToDownload = null)
		{
			if (video == null)
			{
				throw new ArgumentNullException("video");
			}
			if (savePath == null)
			{
				throw new ArgumentNullException("savePath");
			}
			Video = video;
			SavePath = savePath;
			BytesToDownload = bytesToDownload;
		}

		public abstract void Execute();

		protected void OnDownloadFinished(EventArgs e)
		{
			if (this.DownloadFinished != null)
			{
				this.DownloadFinished(this, e);
			}
		}

		protected void OnDownloadStarted(EventArgs e)
		{
			if (this.DownloadStarted != null)
			{
				this.DownloadStarted(this, e);
			}
		}
	}
}
namespace SimpleJSON
{
	public enum JSONNodeType
	{
		Array = 1,
		Object,
		String,
		Number,
		NullValue,
		Boolean,
		None
	}
	public enum JSONTextMode
	{
		Compact,
		Indent
	}
	public abstract class JSONNode
	{
		internal static StringBuilder m_EscapeBuilder = new StringBuilder();

		public virtual JSONNode this[int aIndex]
		{
			get
			{
				return null;
			}
			set
			{
			}
		}

		public virtual JSONNode this[string aKey]
		{
			get
			{
				return null;
			}
			set
			{
			}
		}

		public virtual string Value
		{
			get
			{
				return "";
			}
			set
			{
			}
		}

		public virtual int Count => 0;

		public virtual bool IsNumber => false;

		public virtual bool IsString => false;

		public virtual bool IsBoolean => false;

		public virtual bool IsNull => false;

		public virtual bool IsArray => false;

		public virtual bool IsObject => false;

		public virtual IEnumerable<JSONNode> Children
		{
			get
			{
				yield break;
			}
		}

		public IEnumerable<JSONNode> DeepChildren
		{
			get
			{
				foreach (JSONNode child in Children)
				{
					foreach (JSONNode deepChild in child.DeepChildren)
					{
						yield return deepChild;
					}
				}
			}
		}

		public abstract JSONNodeType Tag { get; }

		public virtual double AsDouble
		{
			get
			{
				double result = 0.0;
				if (double.TryParse(Value, out result))
				{
					return result;
				}
				return 0.0;
			}
			set
			{
				Value = value.ToString();
			}
		}

		public virtual int AsInt
		{
			get
			{
				return (int)AsDouble;
			}
			set
			{
				AsDouble = value;
			}
		}

		public virtual float AsFloat
		{
			get
			{
				return (float)AsDouble;
			}
			set
			{
				AsDouble = value;
			}
		}

		public virtual bool AsBool
		{
			get
			{
				bool result = false;
				if (bool.TryParse(Value, out result))
				{
					return result;
				}
				return !string.IsNullOrEmpty(Value);
			}
			set
			{
				Value = (value ? "true" : "false");
			}
		}

		public virtual JSONArray AsArray => this as JSONArray;

		public virtual JSONObject AsObject => this as JSONObject;

		public virtual void Add(string aKey, JSONNode aItem)
		{
		}

		public virtual void Add(JSONNode aItem)
		{
			Add("", aItem);
		}

		public virtual JSONNode Remove(string aKey)
		{
			return null;
		}

		public virtual JSONNode Remove(int aIndex)
		{
			return null;
		}

		public virtual JSONNode Remove(JSONNode aNode)
		{
			return aNode;
		}

		public override string ToString()
		{
			StringBuilder stringBuilder = new StringBuilder();
			WriteToStringBuilder(stringBuilder, 0, 0, JSONTextMode.Compact);
			return stringBuilder.ToString();
		}

		public virtual string ToString(int aIndent)
		{
			StringBuilder stringBuilder = new StringBuilder();
			WriteToStringBuilder(stringBuilder, 0, aIndent, JSONTextMode.Indent);
			return stringBuilder.ToString();
		}

		internal abstract void WriteToStringBuilder(StringBuilder aSB, int aIndent, int aIndentInc, JSONTextMode aMode);

		public static implicit operator JSONNode(string s)
		{
			return new JSONString(s);
		}

		public static implicit operator string(JSONNode d)
		{
			if (!(d == null))
			{
				return d.Value;
			}
			return null;
		}

		public static implicit operator JSONNode(double n)
		{
			return new JSONNumber(n);
		}

		public static implicit operator double(JSONNode d)
		{
			if (!(d == null))
			{
				return d.AsDouble;
			}
			return 0.0;
		}

		public static implicit operator JSONNode(float n)
		{
			return new JSONNumber(n);
		}

		public static implicit operator float(JSONNode d)
		{
			if (!(d == null))
			{
				return d.AsFloat;
			}
			return 0f;
		}

		public static implicit operator JSONNode(int n)
		{
			return new JSONNumber(n);
		}

		public static implicit operator int(JSONNode d)
		{
			if (!(d == null))
			{
				return d.AsInt;
			}
			return 0;
		}

		public static implicit operator JSONNode(bool b)
		{
			return new JSONBool(b);
		}

		public static implicit operator bool(JSONNode d)
		{
			if (!(d == null))
			{
				return d.AsBool;
			}
			return false;
		}

		public static bool operator ==(JSONNode a, object b)
		{
			if ((object)a == b)
			{
				return true;
			}
			bool num = a is JSONNull || (object)a == null || a is JSONLazyCreator;
			bool flag = b is JSONNull || b == null || b is JSONLazyCreator;
			if (num && flag)
			{
				return true;
			}
			return a.Equals(b);
		}

		public static bool operator !=(JSONNode a, object b)
		{
			return !(a == b);
		}

		public override bool Equals(object obj)
		{
			return (object)this == obj;
		}

		public override int GetHashCode()
		{
			return base.GetHashCode();
		}

		internal static string Escape(string aText)
		{
			m_EscapeBuilder.Length = 0;
			if (m_EscapeBuilder.Capacity < aText.Length + aText.Length / 10)
			{
				m_EscapeBuilder.Capacity = aText.Length + aText.Length / 10;
			}
			foreach (char c in aText)
			{
				switch (c)
				{
				case '\\':
					m_EscapeBuilder.Append("\\\\");
					break;
				case '"':
					m_EscapeBuilder.Append("\\\"");
					break;
				case '\n':
					m_EscapeBuilder.Append("\\n");
					break;
				case '\r':
					m_EscapeBuilder.Append("\\r");
					break;
				case '\t':
					m_EscapeBuilder.Append("\\t");
					break;
				case '\b':
					m_EscapeBuilder.Append("\\b");
					break;
				case '\f':
					m_EscapeBuilder.Append("\\f");
					break;
				default:
					m_EscapeBuilder.Append(c);
					break;
				}
			}
			string result = m_EscapeBuilder.ToString();
			m_EscapeBuilder.Length = 0;
			return result;
		}

		private static void ParseElement(JSONNode ctx, string token, string tokenName, bool quoted)
		{
			if (quoted)
			{
				ctx.Add(tokenName, token);
				return;
			}
			string text = token.ToLower();
			switch (text)
			{
			case "false":
			case "true":
				ctx.Add(tokenName, text == "true");
				return;
			case "null":
				ctx.Add(tokenName, null);
				return;
			}
			if (double.TryParse(token, out var result))
			{
				ctx.Add(tokenName, result);
			}
			else
			{
				ctx.Add(tokenName, token);
			}
		}

		public static JSONNode Parse(string aJSON)
		{
			Stack<JSONNode> stack = new Stack<JSONNode>();
			JSONNode jSONNode = null;
			int i = 0;
			StringBuilder stringBuilder = new StringBuilder();
			string text = "";
			bool flag = false;
			bool flag2 = false;
			for (; i < aJSON.Length; i++)
			{
				switch (aJSON[i])
				{
				case '{':
					if (flag)
					{
						stringBuilder.Append(aJSON[i]);
						break;
					}
					stack.Push(new JSONObject());
					if (jSONNode != null)
					{
						jSONNode.Add(text, stack.Peek());
					}
					text = "";
					stringBuilder.Length = 0;
					jSONNode = stack.Peek();
					break;
				case '[':
					if (flag)
					{
						stringBuilder.Append(aJSON[i]);
						break;
					}
					stack.Push(new JSONArray());
					if (jSONNode != null)
					{
						jSONNode.Add(text, stack.Peek());
					}
					text = "";
					stringBuilder.Length = 0;
					jSONNode = stack.Peek();
					break;
				case ']':
				case '}':
					if (flag)
					{
						stringBuilder.Append(aJSON[i]);
						break;
					}
					if (stack.Count == 0)
					{
						throw new Exception("JSON Parse: Too many closing brackets");
					}
					stack.Pop();
					if (stringBuilder.Length > 0 || flag2)
					{
						ParseElement(jSONNode, stringBuilder.ToString(), text, flag2);
						flag2 = false;
					}
					text = "";
					stringBuilder.Length = 0;
					if (stack.Count > 0)
					{
						jSONNode = stack.Peek();
					}
					break;
				case ':':
					if (flag)
					{
						stringBuilder.Append(aJSON[i]);
						break;
					}
					text = stringBuilder.ToString();
					stringBuilder.Length = 0;
					flag2 = false;
					break;
				case '"':
					flag = !flag;
					flag2 = flag2 || flag;
					break;
				case ',':
					if (flag)
					{
						stringBuilder.Append(aJSON[i]);
						break;
					}
					if (stringBuilder.Length > 0 || flag2)
					{
						ParseElement(jSONNode, stringBuilder.ToString(), text, flag2);
						flag2 = false;
					}
					text = "";
					stringBuilder.Length = 0;
					flag2 = false;
					break;
				case '\t':
				case ' ':
					if (flag)
					{
						stringBuilder.Append(aJSON[i]);
					}
					break;
				case '\\':
					i++;
					if (flag)
					{
						char c = aJSON[i];
						switch (c)
						{
						case 't':
							stringBuilder.Append('\t');
							break;
						case 'r':
							stringBuilder.Append('\r');
							break;
						case 'n':
							stringBuilder.Append('\n');
							break;
						case 'b':
							stringBuilder.Append('\b');
							break;
						case 'f':
							stringBuilder.Append('\f');
							break;
						case 'u':
						{
							string s = aJSON.Substring(i + 1, 4);
							stringBuilder.Append((char)int.Parse(s, NumberStyles.AllowHexSpecifier));
							i += 4;
							break;
						}
						default:
							stringBuilder.Append(c);
							break;
						}
					}
					break;
				default:
					stringBuilder.Append(aJSON[i]);
					break;
				case '\n':
				case '\r':
					break;
				}
			}
			if (flag)
			{
				throw new Exception("JSON Parse: Quotation marks seems to be messed up.");
			}
			return jSONNode;
		}

		public virtual void Serialize(BinaryWriter aWriter)
		{
		}

		public void SaveToStream(Stream aData)
		{
			BinaryWriter aWriter = new BinaryWriter(aData);
			Serialize(aWriter);
		}

		public void SaveToCompressedStream(Stream aData)
		{
			throw new Exception("Can't use compressed functions. You need include the SharpZipLib and uncomment the define at the top of SimpleJSON");
		}

		public void SaveToCompressedFile(string aFileName)
		{
			throw new Exception("Can't use compressed functions. You need include the SharpZipLib and uncomment the define at the top of SimpleJSON");
		}

		public string SaveToCompressedBase64()
		{
			throw new Exception("Can't use compressed functions. You need include the SharpZipLib and uncomment the define at the top of SimpleJSON");
		}

		public void SaveToFile(string aFileName)
		{
			Directory.CreateDirectory(new FileInfo(aFileName).Directory.FullName);
			using FileStream aData = File.OpenWrite(aFileName);
			SaveToStream(aData);
		}

		public string SaveToBase64()
		{
			using MemoryStream memoryStream = new MemoryStream();
			SaveToStream(memoryStream);
			memoryStream.Position = 0L;
			return Convert.ToBase64String(memoryStream.ToArray());
		}

		public static JSONNode Deserialize(BinaryReader aReader)
		{
			JSONNodeType jSONNodeType = (JSONNodeType)aReader.ReadByte();
			switch (jSONNodeType)
			{
			case JSONNodeType.Array:
			{
				int num2 = aReader.ReadInt32();
				JSONArray jSONArray = new JSONArray();
				for (int j = 0; j < num2; j++)
				{
					jSONArray.Add(Deserialize(aReader));
				}
				return jSONArray;
			}
			case JSONNodeType.Object:
			{
				int num = aReader.ReadInt32();
				JSONObject jSONObject = new JSONObject();
				for (int i = 0; i < num; i++)
				{
					string aKey = aReader.ReadString();
					JSONNode aItem = Deserialize(aReader);
					jSONObject.Add(aKey, aItem);
				}
				return jSONObject;
			}
			case JSONNodeType.String:
				return new JSONString(aReader.ReadString());
			case JSONNodeType.Number:
				return new JSONNumber(aReader.ReadDouble());
			case JSONNodeType.Boolean:
				return new JSONBool(aReader.ReadBoolean());
			case JSONNodeType.NullValue:
				return new JSONNull();
			default:
				throw new Exception("Error deserializing JSON. Unknown tag: " + jSONNodeType);
			}
		}

		public static JSONNode LoadFromCompressedFile(string aFileName)
		{
			throw new Exception("Can't use compressed functions. You need include the SharpZipLib and uncomment the define at the top of SimpleJSON");
		}

		public static JSONNode LoadFromCompressedStream(Stream aData)
		{
			throw new Exception("Can't use compressed functions. You need include the SharpZipLib and uncomment the define at the top of SimpleJSON");
		}

		public static JSONNode LoadFromCompressedBase64(string aBase64)
		{
			throw new Exception("Can't use compressed functions. You need include the SharpZipLib and uncomment the define at the top of SimpleJSON");
		}

		public static JSONNode LoadFromStream(Stream aData)
		{
			using BinaryReader aReader = new BinaryReader(aData);
			return Deserialize(aReader);
		}

		public static JSONNode LoadFromFile(string aFileName)
		{
			using FileStream aData = File.OpenRead(aFileName);
			return LoadFromStream(aData);
		}

		public static JSONNode LoadFromBase64(string aBase64)
		{
			return LoadFromStream(new MemoryStream(Convert.FromBase64String(aBase64))
			{
				Position = 0L
			});
		}
	}
	public class JSONArray : JSONNode, IEnumerable
	{
		private List<JSONNode> m_List = new List<JSONNode>();

		public bool inline;

		public override JSONNodeType Tag => JSONNodeType.Array;

		public override bool IsArray => true;

		public override JSONNode this[int aIndex]
		{
			get
			{
				if (aIndex < 0 || aIndex >= m_List.Count)
				{
					return new JSONLazyCreator(this);
				}
				return m_List[aIndex];
			}
			set
			{
				if (value == null)
				{
					value = new JSONNull();
				}
				if (aIndex < 0 || aIndex >= m_List.Count)
				{
					m_List.Add(value);
				}
				else
				{
					m_List[aIndex] = value;
				}
			}
		}

		public override JSONNode this[string aKey]
		{
			get
			{
				return new JSONLazyCreator(this);
			}
			set
			{
				if (value == null)
				{
					value = new JSONNull();
				}
				m_List.Add(value);
			}
		}

		public override int Count => m_List.Count;

		public override IEnumerable<JSONNode> Children
		{
			get
			{
				foreach (JSONNode item in m_List)
				{
					yield return item;
				}
			}
		}

		public override void Add(string aKey, JSONNode aItem)
		{
			if (aItem == null)
			{
				aItem = new JSONNull();
			}
			m_List.Add(aItem);
		}

		public override JSONNode Remove(int aIndex)
		{
			if (aIndex < 0 || aIndex >= m_List.Count)
			{
				return null;
			}
			JSONNode result = m_List[aIndex];
			m_List.RemoveAt(aIndex);
			return result;
		}

		public override JSONNode Remove(JSONNode aNode)
		{
			m_List.Remove(aNode);
			return aNode;
		}

		public IEnumerator GetEnumerator()
		{
			foreach (JSONNode item in m_List)
			{
				yield return item;
			}
		}

		public override void Serialize(BinaryWriter aWriter)
		{
			aWriter.Write((byte)1);
			aWriter.Write(m_List.Count);
			for (int i = 0; i < m_List.Count; i++)
			{
				m_List[i].Serialize(aWriter);
			}
		}

		internal override void WriteToStringBuilder(StringBuilder aSB, int aIndent, int aIndentInc, JSONTextMode aMode)
		{
			aSB.Append('[');
			int count = m_List.Count;
			if (inline)
			{
				aMode = JSONTextMode.Compact;
			}
			for (int i = 0; i < count; i++)
			{
				if (i > 0)
				{
					aSB.Append(',');
				}
				if (aMode == JSONTextMode.Indent)
				{
					aSB.AppendLine();
				}
				if (aMode == JSONTextMode.Indent)
				{
					aSB.Append(' ', aIndent + aIndentInc);
				}
				m_List[i].WriteToStringBuilder(aSB, aIndent + aIndentInc, aIndentInc, aMode);
			}
			if (aMode == JSONTextMode.Indent)
			{
				aSB.AppendLine().Append(' ', aIndent);
			}
			aSB.Append(']');
		}
	}
	public class JSONObject : JSONNode, IEnumerable
	{
		private Dictionary<string, JSONNode> m_Dict = new Dictionary<string, JSONNode>();

		public bool inline;

		public override JSONNodeType Tag => JSONNodeType.Object;

		public override bool IsObject => true;

		public override JSONNode this[string aKey]
		{
			get
			{
				if (m_Dict.ContainsKey(aKey))
				{
					return m_Dict[aKey];
				}
				return new JSONLazyCreator(this, aKey);
			}
			set
			{
				if (value == null)
				{
					value = new JSONNull();
				}
				if (m_Dict.ContainsKey(aKey))
				{
					m_Dict[aKey] = value;
				}
				else
				{
					m_Dict.Add(aKey, value);
				}
			}
		}

		public override JSONNode this[int aIndex]
		{
			get
			{
				if (aIndex < 0 || aIndex >= m_Dict.Count)
				{
					return null;
				}
				return m_Dict.ElementAt(aIndex).Value;
			}
			set
			{
				if (value == null)
				{
					value = new JSONNull();
				}
				if (aIndex >= 0 && aIndex < m_Dict.Count)
				{
					string key = m_Dict.ElementAt(aIndex).Key;
					m_Dict[key] = value;
				}
			}
		}

		public override int Count => m_Dict.Count;

		public override IEnumerable<JSONNode> Children
		{
			get
			{
				foreach (KeyValuePair<string, JSONNode> item in m_Dict)
				{
					yield return item.Value;
				}
			}
		}

		public override void Add(string aKey, JSONNode aItem)
		{
			if (aItem == null)
			{
				aItem = new JSONNull();
			}
			if (!string.IsNullOrEmpty(aKey))
			{
				if (m_Dict.ContainsKey(aKey))
				{
					m_Dict[aKey] = aItem;
				}
				else
				{
					m_Dict.Add(aKey, aItem);
				}
			}
			else
			{
				m_Dict.Add(Guid.NewGuid().ToString(), aItem);
			}
		}

		public override JSONNode Remove(string aKey)
		{
			if (!m_Dict.ContainsKey(aKey))
			{
				return null;
			}
			JSONNode result = m_Dict[aKey];
			m_Dict.Remove(aKey);
			return result;
		}

		public override JSONNode Remove(int aIndex)
		{
			if (aIndex < 0 || aIndex >= m_Dict.Count)
			{
				return null;
			}
			KeyValuePair<string, JSONNode> keyValuePair = m_Dict.ElementAt(aIndex);
			m_Dict.Remove(keyValuePair.Key);
			return keyValuePair.Value;
		}

		public override JSONNode Remove(JSONNode aNode)
		{
			try
			{
				KeyValuePair<string, JSONNode> keyValuePair = m_Dict.Where((KeyValuePair<string, JSONNode> k) => k.Value == aNode).First();
				m_Dict.Remove(keyValuePair.Key);
				return aNode;
			}
			catch
			{
				return null;
			}
		}

		public IEnumerator GetEnumerator()
		{
			foreach (KeyValuePair<string, JSONNode> item in m_Dict)
			{
				yield return item;
			}
		}

		public override void Serialize(BinaryWriter aWriter)
		{
			aWriter.Write((byte)2);
			aWriter.Write(m_Dict.Count);
			foreach (string key in m_Dict.Keys)
			{
				aWriter.Write(key);
				m_Dict[key].Serialize(aWriter);
			}
		}

		internal override void WriteToStringBuilder(StringBuilder aSB, int aIndent, int aIndentInc, JSONTextMode aMode)
		{
			aSB.Append('{');
			bool flag = true;
			if (inline)
			{
				aMode = JSONTextMode.Compact;
			}
			foreach (KeyValuePair<string, JSONNode> item in m_Dict)
			{
				if (!flag)
				{
					aSB.Append(',');
				}
				flag = false;
				if (aMode == JSONTextMode.Indent)
				{
					aSB.AppendLine();
				}
				if (aMode == JSONTextMode.Indent)
				{
					aSB.Append(' ', aIndent + aIndentInc);
				}
				aSB.Append('"').Append(JSONNode.Escape(item.Key)).Append('"');
				if (aMode == JSONTextMode.Compact)
				{
					aSB.Append(':');
				}
				else
				{
					aSB.Append(" : ");
				}
				item.Value.WriteToStringBuilder(aSB, aIndent + aIndentInc, aIndentInc, aMode);
			}
			if (aMode == JSONTextMode.Indent)
			{
				aSB.AppendLine().Append(' ', aIndent);
			}
			aSB.Append('}');
		}
	}
	public class JSONString : JSONNode
	{
		private string m_Data;

		public override JSONNodeType Tag => JSONNodeType.String;

		public override bool IsString => true;

		public override string Value
		{
			get
			{
				return m_Data;
			}
			set
			{
				m_Data = value;
			}
		}

		public JSONString(string aData)
		{
			m_Data = aData;
		}

		public override void Serialize(BinaryWriter aWriter)
		{
			aWriter.Write((byte)3);
			aWriter.Write(m_Data);
		}

		internal override void WriteToStringBuilder(StringBuilder aSB, int aIndent, int aIndentInc, JSONTextMode aMode)
		{
			aSB.Append('"').Append(JSONNode.Escape(m_Data)).Append('"');
		}

		public override bool Equals(object obj)
		{
			if (base.Equals(obj))
			{
				return true;
			}
			if (obj is string text)
			{
				return m_Data == text;
			}
			JSONString jSONString = obj as JSONString;
			if (jSONString != null)
			{
				return m_Data == jSONString.m_Data;
			}
			return false;
		}

		public override int GetHashCode()
		{
			return m_Data.GetHashCode();
		}
	}
	public class JSONNumber : JSONNode
	{
		private double m_Data;

		public override JSONNodeType Tag => JSONNodeType.Number;

		public override bool IsNumber => true;

		public override string Value
		{
			get
			{
				return m_Data.ToString();
			}
			set
			{
				if (double.TryParse(value, out var result))
				{
					m_Data = result;
				}
			}
		}

		public override double AsDouble
		{
			get
			{
				return m_Data;
			}
			set
			{
				m_Data = value;
			}
		}

		public JSONNumber(double aData)
		{
			m_Data = aData;
		}

		public JSONNumber(string aData)
		{
			Value = aData;
		}

		public override void Serialize(BinaryWriter aWriter)
		{
			aWriter.Write((byte)4);
			aWriter.Write(m_Data);
		}

		internal override void WriteToStringBuilder(StringBuilder aSB, int aIndent, int aIndentInc, JSONTextMode aMode)
		{
			aSB.Append(m_Data);
		}

		private static bool IsNumeric(object value)
		{
			if (!(value is int) && !(value is uint) && !(value is float) && !(value is double) && !(value is decimal) && !(value is long) && !(value is ulong) && !(value is short) && !(value is ushort) && !(value is sbyte))
			{
				return value is byte;
			}
			return true;
		}

		public override bool Equals(object obj)
		{
			if (obj == null)
			{
				return false;
			}
			if (base.Equals(obj))
			{
				return true;
			}
			JSONNumber jSONNumber = obj as JSONNumber;
			if (jSONNumber != null)
			{
				return m_Data == jSONNumber.m_Data;
			}
			if (IsNumeric(obj))
			{
				return Convert.ToDouble(obj) == m_Data;
			}
			return false;
		}

		public override int GetHashCode()
		{
			return m_Data.GetHashCode();
		}
	}
	public class JSONBool : JSONNode
	{
		private bool m_Data;

		public override JSONNodeType Tag => JSONNodeType.Boolean;

		public override bool IsBoolean => true;

		public override string Value
		{
			get
			{
				return m_Data.ToString();
			}
			set
			{
				if (bool.TryParse(value, out var result))
				{
					m_Data = result;
				}
			}
		}

		public override bool AsBool
		{
			get
			{
				return m_Data;
			}
			set
			{
				m_Data = value;
			}
		}

		public JSONBool(bool aData)
		{
			m_Data = aData;
		}

		public JSONBool(string aData)
		{
			Value = aData;
		}

		public override void Serialize(BinaryWriter aWriter)
		{
			aWriter.Write((byte)6);
			aWriter.Write(m_Data);
		}

		internal override void WriteToStringBuilder(StringBuilder aSB, int aIndent, int aIndentInc, JSONTextMode aMode)
		{
			aSB.Append(m_Data ? "true" : "false");
		}

		public override bool Equals(object obj)
		{
			if (obj == null)
			{
				return false;
			}
			if (obj is bool)
			{
				return m_Data == (bool)obj;
			}
			return false;
		}

		public override int GetHashCode()
		{
			return m_Data.GetHashCode();
		}
	}
	public class JSONNull : JSONNode
	{
		public override JSONNodeType Tag => JSONNodeType.NullValue;

		public override bool IsNull => true;

		public override string Value
		{
			get
			{
				return "null";
			}
			set
			{
			}
		}

		public override bool AsBool
		{
			get
			{
				return false;
			}
			set
			{
			}
		}

		public override bool Equals(object obj)
		{
			if ((object)this == obj)
			{
				return true;
			}
			return obj is JSONNull;
		}

		public override int GetHashCode()
		{
			return 0;
		}

		public override void Serialize(BinaryWriter aWriter)
		{
			aWriter.Write((byte)5);
		}

		internal override void WriteToStringBuilder(StringBuilder aSB, int aIndent, int aIndentInc, JSONTextMode aMode)
		{
			aSB.Append("null");
		}
	}
	internal class JSONLazyCreator : JSONNode
	{
		private JSONNode m_Node;

		private string m_Key;

		public override JSONNodeType Tag => JSONNodeType.None;

		public override JSONNode this[int aIndex]
		{
			get
			{
				return new JSONLazyCreator(this);
			}
			set
			{
				JSONArray jSONArray = new JSONArray();
				jSONArray.Add(value);
				Set(jSONArray);
			}
		}

		public override JSONNode this[string aKey]
		{
			get
			{
				return new JSONLazyCreator(this, aKey);
			}
			set
			{
				JSONObject jSONObject = new JSONObject();
				jSONObject.Add(aKey, value);
				Set(jSONObject);
			}
		}

		public override int AsInt
		{
			get
			{
				JSONNumber aVal = new JSONNumber(0.0);
				Set(aVal);
				return 0;
			}
			set
			{
				JSONNumber aVal = new JSONNumber(value);
				Set(aVal);
			}
		}

		public override float AsFloat
		{
			get
			{
				JSONNumber aVal = new JSONNumber(0.0);
				Set(aVal);
				return 0f;
			}
			set
			{
				JSONNumber aVal = new JSONNumber(value);
				Set(aVal);
			}
		}

		public override double AsDouble
		{
			get
			{
				JSONNumber aVal = new JSONNumber(0.0);
				Set(aVal);
				return 0.0;
			}
			set
			{
				JSONNumber aVal = new JSONNumber(value);
				Set(aVal);
			}
		}

		public override bool AsBool
		{
			get
			{
				JSONBool aVal = new JSONBool(aData: false);
				Set(aVal);
				return false;
			}
			set
			{
				JSONBool aVal = new JSONBool(value);
				Set(aVal);
			}
		}

		public override JSONArray AsArray
		{
			get
			{
				JSONArray jSONArray = new JSONArray();
				Set(jSONArray);
				return jSONArray;
			}
		}

		public override JSONObject AsObject
		{
			get
			{
				JSONObject jSONObject = new JSONObject();
				Set(jSONObject);
				return jSONObject;
			}
		}

		public JSONLazyCreator(JSONNode aNode)
		{
			m_Node = aNode;
			m_Key = null;
		}

		public JSONLazyCreator(JSONNode aNode, string aKey)
		{
			m_Node = aNode;
			m_Key = aKey;
		}

		private void Set(JSONNode aVal)
		{
			if (m_Key == null)
			{
				m_Node.Add(aVal);
			}
			else
			{
				m_Node.Add(m_Key, aVal);
			}
			m_Node = null;
		}

		public override void Add(JSONNode aItem)
		{
			JSONArray jSONArray = new JSONArray();
			jSONArray.Add(aItem);
			Set(jSONArray);
		}

		public override void Add(string aKey, JSONNode aItem)
		{
			JSONObject jSONObject = new JSONObject();
			jSONObject.Add(aKey, aItem);
			Set(jSONObject);
		}

		public static bool operator ==(JSONLazyCreator a, object b)
		{
			if (b == null)
			{
				return true;
			}
			return (object)a == b;
		}

		public static bool operator !=(JSONLazyCreator a, object b)
		{
			return !(a == b);
		}

		public override bool Equals(object obj)
		{
			if (obj == null)
			{
				return true;
			}
			return (object)this == obj;
		}

		public override int GetHashCode()
		{
			return 0;
		}

		internal override void WriteToStringBuilder(StringBuilder aSB, int aIndent, int aIndentInc, JSONTextMode aMode)
		{
			aSB.Append("null");
		}
	}
	public static class JSON
	{
		public static JSONNode Parse(string aJSON)
		{
			return JSONNode.Parse(aJSON);
		}
	}
}
namespace UnityStandardAssets.Water
{
	[ExecuteInEditMode]
	[RequireComponent(typeof(WaterBase))]
	public class Displace : MonoBehaviour
	{
		public void Awake()
		{
			if (base.enabled)
			{
				OnEnable();
			}
			else
			{
				OnDisable();
			}
		}

		public void OnEnable()
		{
			Shader.EnableKeyword("WATER_VERTEX_DISPLACEMENT_ON");
			Shader.DisableKeyword("WATER_VERTEX_DISPLACEMENT_OFF");
		}

		public void OnDisable()
		{
			Shader.EnableKeyword("WATER_VERTEX_DISPLACEMENT_OFF");
			Shader.DisableKeyword("WATER_VERTEX_DISPLACEMENT_ON");
		}
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(WaterBase))]
	public class GerstnerDisplace : Displace
	{
	}
	public class MeshContainer
	{
		public Mesh mesh;

		public Vector3[] vertices;

		public Vector3[] normals;

		public MeshContainer(Mesh m)
		{
			mesh = m;
			vertices = m.vertices;
			normals = m.normals;
		}

		public void Update()
		{
			mesh.vertices = vertices;
			mesh.normals = normals;
		}
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(WaterBase))]
	public class PlanarReflection : MonoBehaviour
	{
		public LayerMask reflectionMask;

		public bool reflectSkybox;

		public Color clearColor = Color.grey;

		public string reflectionSampler = "_ReflectionTex";

		public float clipPlaneOffset = 0.07f;

		private Vector3 m_Oldpos;

		private Camera m_ReflectionCamera;

		private Material m_SharedMaterial;

		private Dictionary<Camera, bool> m_HelperCameras;

		public void Start()
		{
			m_SharedMaterial = ((WaterBase)base.gameObject.GetComponent(typeof(WaterBase))).sharedMaterial;
		}

		private Camera CreateReflectionCameraFor(Camera cam)
		{
			string text = base.gameObject.name + "Reflection" + cam.name;
			GameObject gameObject = GameObject.Find(text);
			if (!gameObject)
			{
				gameObject = new GameObject(text, typeof(Camera));
			}
			if (!gameObject.GetComponent(typeof(Camera)))
			{
				gameObject.AddComponent(typeof(Camera));
			}
			Camera component = gameObject.GetComponent<Camera>();
			component.backgroundColor = clearColor;
			component.clearFlags = (reflectSkybox ? CameraClearFlags.Skybox : CameraClearFlags.Color);
			SetStandardCameraParameter(component, reflectionMask);
			if (!component.targetTexture)
			{
				component.targetTexture = CreateTextureFor(cam);
			}
			return component;
		}

		private void SetStandardCameraParameter(Camera cam, LayerMask mask)
		{
			cam.cullingMask = (int)mask & ~(1 << LayerMask.NameToLayer("Water"));
			cam.backgroundColor = Color.black;
			cam.enabled = false;
		}

		private RenderTexture CreateTextureFor(Camera cam)
		{
			return new RenderTexture(Mathf.FloorToInt((float)cam.pixelWidth * 0.5f), Mathf.FloorToInt((float)cam.pixelHeight * 0.5f), 24)
			{
				hideFlags = HideFlags.DontSave
			};
		}

		public void RenderHelpCameras(Camera currentCam)
		{
			if (m_HelperCameras == null)
			{
				m_HelperCameras = new Dictionary<Camera, bool>();
			}
			if (!m_HelperCameras.ContainsKey(currentCam))
			{
				m_HelperCameras.Add(currentCam, value: false);
			}
			if (!m_HelperCameras[currentCam])
			{
				if (!m_ReflectionCamera)
				{
					m_ReflectionCamera = CreateReflectionCameraFor(currentCam);
				}
				RenderReflectionFor(currentCam, m_ReflectionCamera);
				m_HelperCameras[currentCam] = true;
			}
		}

		public void LateUpdate()
		{
			if (m_HelperCameras != null)
			{
				m_HelperCameras.Clear();
			}
		}

		public void WaterTileBeingRendered(Transform tr, Camera currentCam)
		{
			RenderHelpCameras(currentCam);
			if ((bool)m_ReflectionCamera && (bool)m_SharedMaterial)
			{
				m_SharedMaterial.SetTexture(reflectionSampler, m_ReflectionCamera.targetTexture);
			}
		}

		public void OnEnable()
		{
			Shader.EnableKeyword("WATER_REFLECTIVE");
			Shader.DisableKeyword("WATER_SIMPLE");
		}

		public void OnDisable()
		{
			Shader.EnableKeyword("WATER_SIMPLE");
			Shader.DisableKeyword("WATER_REFLECTIVE");
		}

		private void RenderReflectionFor(Camera cam, Camera reflectCamera)
		{
			if (!reflectCamera || ((bool)m_SharedMaterial && !m_SharedMaterial.HasProperty(reflectionSampler)))
			{
				return;
			}
			reflectCamera.cullingMask = (int)reflectionMask & ~(1 << LayerMask.NameToLayer("Water"));
			SaneCameraSettings(reflectCamera);
			reflectCamera.backgroundColor = clearColor;
			reflectCamera.clearFlags = (reflectSkybox ? CameraClearFlags.Skybox : CameraClearFlags.Color);
			if (reflectSkybox && (bool)cam.gameObject.GetComponent(typeof(Skybox)))
			{
				Skybox skybox = (Skybox)reflectCamera.gameObject.GetComponent(typeof(Skybox));
				if (!skybox)
				{
					skybox = (Skybox)reflectCamera.gameObject.AddComponent(typeof(Skybox));
				}
				skybox.material = ((Skybox)cam.GetComponent(typeof(Skybox))).material;
			}
			GL.invertCulling = true;
			Transform transform = base.transform;
			Vector3 eulerAngles = cam.transform.eulerAngles;
			reflectCamera.transform.eulerAngles = new Vector3(0f - eulerAngles.x, eulerAngles.y, eulerAngles.z);
			reflectCamera.transform.position = cam.transform.position;
			Vector3 position = transform.transform.position;
			position.y = transform.position.y;
			Vector3 up = transform.transform.up;
			float w = 0f - Vector3.Dot(up, position) - clipPlaneOffset;
			Vector4 plane = new Vector4(up.x, up.y, up.z, w);
			Matrix4x4 zero = Matrix4x4.zero;
			zero = CalculateReflectionMatrix(zero, plane);
			m_Oldpos = cam.transform.position;
			Vector3 position2 = zero.MultiplyPoint(m_Oldpos);
			reflectCamera.worldToCameraMatrix = cam.worldToCameraMatrix * zero;
			Vector4 clipPlane = CameraSpacePlane(reflectCamera, position, up, 1f);
			Matrix4x4 projectionMatrix = cam.projectionMatrix;
			projectionMatrix = CalculateObliqueMatrix(projectionMatrix, clipPlane);
			reflectCamera.projectionMatrix = projectionMatrix;
			reflectCamera.transform.position = position2;
			Vector3 eulerAngles2 = cam.transform.eulerAngles;
			reflectCamera.transform.eulerAngles = new Vector3(0f - eulerAngles2.x, eulerAngles2.y, eulerAngles2.z);
			reflectCamera.Render();
			GL.invertCulling = false;
		}

		private void SaneCameraSettings(Camera helperCam)
		{
			helperCam.depthTextureMode = DepthTextureMode.None;
			helperCam.backgroundColor = Color.black;
			helperCam.clearFlags = CameraClearFlags.Color;
			helperCam.renderingPath = RenderingPath.Forward;
		}

		private static Matrix4x4 CalculateObliqueMatrix(Matrix4x4 projection, Vector4 clipPlane)
		{
			Vector4 b = projection.inverse * new Vector4(Sgn(clipPlane.x), Sgn(clipPlane.y), 1f, 1f);
			Vector4 vector = clipPlane * (2f / Vector4.Dot(clipPlane, b));
			projection[2] = vector.x - projection[3];
			projection[6] = vector.y - projection[7];
			projection[10] = vector.z - projection[11];
			projection[14] = vector.w - projection[15];
			return projection;
		}

		private static Matrix4x4 CalculateReflectionMatrix(Matrix4x4 reflectionMat, Vector4 plane)
		{
			reflectionMat.m00 = 1f - 2f * plane[0] * plane[0];
			reflectionMat.m01 = -2f * plane[0] * plane[1];
			reflectionMat.m02 = -2f * plane[0] * plane[2];
			reflectionMat.m03 = -2f * plane[3] * plane[0];
			reflectionMat.m10 = -2f * plane[1] * plane[0];
			reflectionMat.m11 = 1f - 2f * plane[1] * plane[1];
			reflectionMat.m12 = -2f * plane[1] * plane[2];
			reflectionMat.m13 = -2f * plane[3] * plane[1];
			reflectionMat.m20 = -2f * plane[2] * plane[0];
			reflectionMat.m21 = -2f * plane[2] * plane[1];
			reflectionMat.m22 = 1f - 2f * plane[2] * plane[2];
			reflectionMat.m23 = -2f * plane[3] * plane[2];
			reflectionMat.m30 = 0f;
			reflectionMat.m31 = 0f;
			reflectionMat.m32 = 0f;
			reflectionMat.m33 = 1f;
			return reflectionMat;
		}

		private static float Sgn(float a)
		{
			if (a > 0f)
			{
				return 1f;
			}
			if (a < 0f)
			{
				return -1f;
			}
			return 0f;
		}

		private Vector4 CameraSpacePlane(Camera cam, Vector3 pos, Vector3 normal, float sideSign)
		{
			Vector3 point = pos + normal * clipPlaneOffset;
			Matrix4x4 worldToCameraMatrix = cam.worldToCameraMatrix;
			Vector3 lhs = worldToCameraMatrix.MultiplyPoint(point);
			Vector3 rhs = worldToCameraMatrix.MultiplyVector(normal).normalized * sideSign;
			return new Vector4(rhs.x, rhs.y, rhs.z, 0f - Vector3.Dot(lhs, rhs));
		}
	}
	[RequireComponent(typeof(WaterBase))]
	[ExecuteInEditMode]
	public class SpecularLighting : MonoBehaviour
	{
		public Transform specularLight;

		private WaterBase m_WaterBase;

		public void Start()
		{
			m_WaterBase = (WaterBase)base.gameObject.GetComponent(typeof(WaterBase));
		}

		public void Update()
		{
			if (!m_WaterBase)
			{
				m_WaterBase = (WaterBase)base.gameObject.GetComponent(typeof(WaterBase));
			}
			if ((bool)specularLight && (bool)m_WaterBase.sharedMaterial)
			{
				m_WaterBase.sharedMaterial.SetVector("_WorldLightDir", specularLight.transform.forward);
			}
		}
	}
	[ExecuteInEditMode]
	public class Water : MonoBehaviour
	{
		public enum WaterMode
		{
			Simple,
			Reflective,
			Refractive
		}

		public WaterMode waterMode = WaterMode.Refractive;

		public bool disablePixelLights = true;

		public int textureSize = 256;

		public float clipPlaneOffset = 0.07f;

		public LayerMask reflectLayers = -1;

		public LayerMask refractLayers = -1;

		private Dictionary<Camera, Camera> m_ReflectionCameras = new Dictionary<Camera, Camera>();

		private Dictionary<Camera, Camera> m_RefractionCameras = new Dictionary<Camera, Camera>();

		private RenderTexture m_ReflectionTexture;

		private RenderTexture m_RefractionTexture;

		private WaterMode m_HardwareWaterSupport = WaterMode.Refractive;

		private int m_OldReflectionTextureSize;

		private int m_OldRefractionTextureSize;

		private static bool s_InsideWater;

		public void OnWillRenderObject()
		{
			if (!base.enabled || !GetComponent<Renderer>() || !GetComponent<Renderer>().sharedMaterial || !GetComponent<Renderer>().enabled)
			{
				return;
			}
			Camera current = Camera.current;
			if ((bool)current && !s_InsideWater)
			{
				s_InsideWater = true;
				m_HardwareWaterSupport = FindHardwareWaterSupport();
				WaterMode waterMode = GetWaterMode();
				CreateWaterObjects(current, out var reflectionCamera, out var refractionCamera);
				Vector3 position = base.transform.position;
				Vector3 up = base.transform.up;
				int pixelLightCount = QualitySettings.pixelLightCount;
				if (disablePixelLights)
				{
					QualitySettings.pixelLightCount = 0;
				}
				UpdateCameraModes(current, reflectionCamera);
				UpdateCameraModes(current, refractionCamera);
				if (waterMode >= WaterMode.Reflective)
				{
					float w = 0f - Vector3.Dot(up, position) - clipPlaneOffset;
					Vector4 plane = new Vector4(up.x, up.y, up.z, w);
					Matrix4x4 reflectionMat = Matrix4x4.zero;
					CalculateReflectionMatrix(ref reflectionMat, plane);
					Vector3 position2 = current.transform.position;
					Vector3 position3 = reflectionMat.MultiplyPoint(position2);
					reflectionCamera.worldToCameraMatrix = current.worldToCameraMatrix * reflectionMat;
					Vector4 clipPlane = CameraSpacePlane(reflectionCamera, position, up, 1f);
					reflectionCamera.projectionMatrix = current.CalculateObliqueMatrix(clipPlane);
					reflectionCamera.cullingMatrix = current.projectionMatrix * current.worldToCameraMatrix;
					reflectionCamera.cullingMask = -17 & reflectLayers.value;
					reflectionCamera.targetTexture = m_ReflectionTexture;
					bool invertCulling = GL.invertCulling;
					GL.invertCulling = !invertCulling;
					reflectionCamera.transform.position = position3;
					Vector3 eulerAngles = current.transform.eulerAngles;
					reflectionCamera.transform.eulerAngles = new Vector3(0f - eulerAngles.x, eulerAngles.y, eulerAngles.z);
					reflectionCamera.Render();
					reflectionCamera.transform.position = position2;
					GL.invertCulling = invertCulling;
					GetComponent<Renderer>().sharedMaterial.SetTexture("_ReflectionTex", m_ReflectionTexture);
				}
				if (waterMode >= WaterMode.Refractive)
				{
					refractionCamera.worldToCameraMatrix = current.worldToCameraMatrix;
					Vector4 clipPlane2 = CameraSpacePlane(refractionCamera, position, up, -1f);
					refractionCamera.projectionMatrix = current.CalculateObliqueMatrix(clipPlane2);
					refractionCamera.cullingMatrix = current.projectionMatrix * current.worldToCameraMatrix;
					refractionCamera.cullingMask = -17 & refractLayers.value;
					refractionCamera.targetTexture = m_RefractionTexture;
					refractionCamera.transform.position = current.transform.position;
					refractionCamera.transform.rotation = current.transform.rotation;
					refractionCamera.Render();
					GetComponent<Renderer>().sharedMaterial.SetTexture("_RefractionTex", m_RefractionTexture);
				}
				if (disablePixelLights)
				{
					QualitySettings.pixelLightCount = pixelLightCount;
				}
				switch (waterMode)
				{
				case WaterMode.Simple:
					Shader.EnableKeyword("WATER_SIMPLE");
					Shader.DisableKeyword("WATER_REFLECTIVE");
					Shader.DisableKeyword("WATER_REFRACTIVE");
					break;
				case WaterMode.Reflective:
					Shader.DisableKeyword("WATER_SIMPLE");
					Shader.EnableKeyword("WATER_REFLECTIVE");
					Shader.DisableKeyword("WATER_REFRACTIVE");
					break;
				case WaterMode.Refractive:
					Shader.DisableKeyword("WATER_SIMPLE");
					Shader.DisableKeyword("WATER_REFLECTIVE");
					Shader.EnableKeyword("WATER_REFRACTIVE");
					break;
				}
				s_InsideWater = false;
			}
		}

		private void OnDisable()
		{
			if ((bool)m_ReflectionTexture)
			{
				UnityEngine.Object.DestroyImmediate(m_ReflectionTexture);
				m_ReflectionTexture = null;
			}
			if ((bool)m_RefractionTexture)
			{
				UnityEngine.Object.DestroyImmediate(m_RefractionTexture);
				m_RefractionTexture = null;
			}
			foreach (KeyValuePair<Camera, Camera> reflectionCamera in m_ReflectionCameras)
			{
				UnityEngine.Object.DestroyImmediate(reflectionCamera.Value.gameObject);
			}
			m_ReflectionCameras.Clear();
			foreach (KeyValuePair<Camera, Camera> refractionCamera in m_RefractionCameras)
			{
				UnityEngine.Object.DestroyImmediate(refractionCamera.Value.gameObject);
			}
			m_RefractionCameras.Clear();
		}

		private void Update()
		{
			if ((bool)GetComponent<Renderer>())
			{
				Material sharedMaterial = GetComponent<Renderer>().sharedMaterial;
				if ((bool)sharedMaterial)
				{
					Vector4 vector = sharedMaterial.GetVector("WaveSpeed");
					float @float = sharedMaterial.GetFloat("_WaveScale");
					Vector4 value = new Vector4(@float, @float, @float * 0.4f, @float * 0.45f);
					double num = (double)Time.timeSinceLevelLoad / 20.0;
					Vector4 value2 = new Vector4((float)Math.IEEERemainder((double)(vector.x * value.x) * num, 1.0), (float)Math.IEEERemainder((double)(vector.y * value.y) * num, 1.0), (float)Math.IEEERemainder((double)(vector.z * value.z) * num, 1.0), (float)Math.IEEERemainder((double)(vector.w * value.w) * num, 1.0));
					sharedMaterial.SetVector("_WaveOffset", value2);
					sharedMaterial.SetVector("_WaveScale4", value);
				}
			}
		}

		private void UpdateCameraModes(Camera src, Camera dest)
		{
			if (dest == null)
			{
				return;
			}
			dest.clearFlags = src.clearFlags;
			dest.backgroundColor = src.backgroundColor;
			if (src.clearFlags == CameraClearFlags.Skybox)
			{
				Skybox component = src.GetComponent<Skybox>();
				Skybox component2 = dest.GetComponent<Skybox>();
				if (!component || !component.material)
				{
					component2.enabled = false;
				}
				else
				{
					component2.enabled = true;
					component2.material = component.material;
				}
			}
			dest.farClipPlane = src.farClipPlane;
			dest.nearClipPlane = src.nearClipPlane;
			dest.orthographic = src.orthographic;
			dest.fieldOfView = src.fieldOfView;
			dest.aspect = src.aspect;
			dest.orthographicSize = src.orthographicSize;
		}

		private void CreateWaterObjects(Camera currentCamera, out Camera reflectionCamera, out Camera refractionCamera)
		{
			WaterMode waterMode = GetWaterMode();
			reflectionCamera = null;
			refractionCamera = null;
			if (waterMode >= WaterMode.Reflective)
			{
				if (!m_ReflectionTexture || m_OldReflectionTextureSize != textureSize)
				{
					if ((bool)m_ReflectionTexture)
					{
						UnityEngine.Object.DestroyImmediate(m_ReflectionTexture);
					}
					m_ReflectionTexture = new RenderTexture(textureSize, textureSize, 16);
					m_ReflectionTexture.name = "__WaterReflection" + GetInstanceID();
					m_ReflectionTexture.isPowerOfTwo = true;
					m_ReflectionTexture.hideFlags = HideFlags.DontSave;
					m_OldReflectionTextureSize = textureSize;
				}
				m_ReflectionCameras.TryGetValue(currentCamera, out reflectionCamera);
				if (!reflectionCamera)
				{
					GameObject gameObject = new GameObject("Water Refl Camera id" + GetInstanceID() + " for " + currentCamera.GetInstanceID(), typeof(Camera), typeof(Skybox));
					reflectionCamera = gameObject.GetComponent<Camera>();
					reflectionCamera.enabled = false;
					reflectionCamera.transform.position = base.transform.position;
					reflectionCamera.transform.rotation = base.transform.rotation;
					reflectionCamera.gameObject.AddComponent<FlareLayer>();
					gameObject.hideFlags = HideFlags.HideAndDontSave;
					m_ReflectionCameras[currentCamera] = reflectionCamera;
				}
			}
			if (waterMode < WaterMode.Refractive)
			{
				return;
			}
			if (!m_RefractionTexture || m_OldRefractionTextureSize != textureSize)
			{
				if ((bool)m_RefractionTexture)
				{
					UnityEngine.Object.DestroyImmediate(m_RefractionTexture);
				}
				m_RefractionTexture = new RenderTexture(textureSize, textureSize, 16);
				m_RefractionTexture.name = "__WaterRefraction" + GetInstanceID();
				m_RefractionTexture.isPowerOfTwo = true;
				m_RefractionTexture.hideFlags = HideFlags.DontSave;
				m_OldRefractionTextureSize = textureSize;
			}
			m_RefractionCameras.TryGetValue(currentCamera, out refractionCamera);
			if (!refractionCamera)
			{
				GameObject gameObject2 = new GameObject("Water Refr Camera id" + GetInstanceID() + " for " + currentCamera.GetInstanceID(), typeof(Camera), typeof(Skybox));
				refractionCamera = gameObject2.GetComponent<Camera>();
				refractionCamera.enabled = false;
				refractionCamera.transform.position = base.transform.position;
				refractionCamera.transform.rotation = base.transform.rotation;
				refractionCamera.gameObject.AddComponent<FlareLayer>();
				gameObject2.hideFlags = HideFlags.HideAndDontSave;
				m_RefractionCameras[currentCamera] = refractionCamera;
			}
		}

		private WaterMode GetWaterMode()
		{
			if (m_HardwareWaterSupport < waterMode)
			{
				return m_HardwareWaterSupport;
			}
			return waterMode;
		}

		private WaterMode FindHardwareWaterSupport()
		{
			if (!GetComponent<Renderer>())
			{
				return WaterMode.Simple;
			}
			Material sharedMaterial = GetComponent<Renderer>().sharedMaterial;
			if (!sharedMaterial)
			{
				return WaterMode.Simple;
			}
			string text = sharedMaterial.GetTag("WATERMODE", searchFallbacks: false);
			if (text == "Refractive")
			{
				return WaterMode.Refractive;
			}
			if (text == "Reflective")
			{
				return WaterMode.Reflective;
			}
			return WaterMode.Simple;
		}

		private Vector4 CameraSpacePlane(Camera cam, Vector3 pos, Vector3 normal, float sideSign)
		{
			Vector3 point = pos + normal * clipPlaneOffset;
			Matrix4x4 worldToCameraMatrix = cam.worldToCameraMatrix;
			Vector3 lhs = worldToCameraMatrix.MultiplyPoint(point);
			Vector3 rhs = worldToCameraMatrix.MultiplyVector(normal).normalized * sideSign;
			return new Vector4(rhs.x, rhs.y, rhs.z, 0f - Vector3.Dot(lhs, rhs));
		}

		private static void CalculateReflectionMatrix(ref Matrix4x4 reflectionMat, Vector4 plane)
		{
			reflectionMat.m00 = 1f - 2f * plane[0] * plane[0];
			reflectionMat.m01 = -2f * plane[0] * plane[1];
			reflectionMat.m02 = -2f * plane[0] * plane[2];
			reflectionMat.m03 = -2f * plane[3] * plane[0];
			reflectionMat.m10 = -2f * plane[1] * plane[0];
			reflectionMat.m11 = 1f - 2f * plane[1] * plane[1];
			reflectionMat.m12 = -2f * plane[1] * plane[2];
			reflectionMat.m13 = -2f * plane[3] * plane[1];
			reflectionMat.m20 = -2f * plane[2] * plane[0];
			reflectionMat.m21 = -2f * plane[2] * plane[1];
			reflectionMat.m22 = 1f - 2f * plane[2] * plane[2];
			reflectionMat.m23 = -2f * plane[3] * plane[2];
			reflectionMat.m30 = 0f;
			reflectionMat.m31 = 0f;
			reflectionMat.m32 = 0f;
			reflectionMat.m33 = 1f;
		}
	}
	public enum WaterQuality
	{
		High = 2,
		Medium = 1,
		Low = 0
	}
	[ExecuteInEditMode]
	public class WaterBase : MonoBehaviour
	{
		public Material sharedMaterial;

		public WaterQuality waterQuality = WaterQuality.High;

		public bool edgeBlend = true;

		public void UpdateShader()
		{
			if (waterQuality > WaterQuality.Medium)
			{
				sharedMaterial.shader.maximumLOD = 501;
			}
			else if (waterQuality > WaterQuality.Low)
			{
				sharedMaterial.shader.maximumLOD = 301;
			}
			else
			{
				sharedMaterial.shader.maximumLOD = 201;
			}
			if (!SystemInfo.SupportsRenderTextureFormat(RenderTextureFormat.Depth))
			{
				edgeBlend = false;
			}
			if (edgeBlend)
			{
				Shader.EnableKeyword("WATER_EDGEBLEND_ON");
				Shader.DisableKeyword("WATER_EDGEBLEND_OFF");
				if ((bool)Camera.main)
				{
					Camera.main.depthTextureMode |= DepthTextureMode.Depth;
				}
			}
			else
			{
				Shader.EnableKeyword("WATER_EDGEBLEND_OFF");
				Shader.DisableKeyword("WATER_EDGEBLEND_ON");
			}
		}

		public void WaterTileBeingRendered(Transform tr, Camera currentCam)
		{
			if ((bool)currentCam && edgeBlend)
			{
				currentCam.depthTextureMode |= DepthTextureMode.Depth;
			}
		}

		public void Update()
		{
			if ((bool)sharedMaterial)
			{
				UpdateShader();
			}
		}
	}
	[ExecuteInEditMode]
	public class WaterTile : MonoBehaviour
	{
		public PlanarReflection reflection;

		public WaterBase waterBase;

		public void Start()
		{
			AcquireComponents();
		}

		private void AcquireComponents()
		{
			if (!reflection)
			{
				if ((bool)base.transform.parent)
				{
					reflection = base.transform.parent.GetComponent<PlanarReflection>();
				}
				else
				{
					reflection = base.transform.GetComponent<PlanarReflection>();
				}
			}
			if (!waterBase)
			{
				if ((bool)base.transform.parent)
				{
					waterBase = base.transform.parent.GetComponent<WaterBase>();
				}
				else
				{
					waterBase = base.transform.GetComponent<WaterBase>();
				}
			}
		}

		public void OnWillRenderObject()
		{
			if ((bool)reflection)
			{
				reflection.WaterTileBeingRendered(base.transform, Camera.current);
			}
			if ((bool)waterBase)
			{
				waterBase.WaterTileBeingRendered(base.transform, Camera.current);
			}
		}
	}
}
namespace UnityStandardAssets.ImageEffects
{
	public enum AAMode
	{
		FXAA2,
		FXAA3Console,
		FXAA1PresetA,
		FXAA1PresetB,
		NFAA,
		SSAA,
		DLAA
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(Camera))]
	[AddComponentMenu("Image Effects/Other/Antialiasing")]
	public class Antialiasing : PostEffectsBase
	{
		public AAMode mode = AAMode.FXAA3Console;

		public bool showGeneratedNormals;

		public float offsetScale = 0.2f;

		public float blurRadius = 18f;

		public float edgeThresholdMin = 0.05f;

		public float edgeThreshold = 0.2f;

		public float edgeSharpness = 4f;

		public bool dlaaSharp;

		public Shader ssaaShader;

		private Material ssaa;

		public Shader dlaaShader;

		private Material dlaa;

		public Shader nfaaShader;

		private Material nfaa;

		public Shader shaderFXAAPreset2;

		private Material materialFXAAPreset2;

		public Shader shaderFXAAPreset3;

		private Material materialFXAAPreset3;

		public Shader shaderFXAAII;

		private Material materialFXAAII;

		public Shader shaderFXAAIII;

		private Material materialFXAAIII;

		public Material CurrentAAMaterial()
		{
			Material material = null;
			return mode switch
			{
				AAMode.FXAA3Console => materialFXAAIII, 
				AAMode.FXAA2 => materialFXAAII, 
				AAMode.FXAA1PresetA => materialFXAAPreset2, 
				AAMode.FXAA1PresetB => materialFXAAPreset3, 
				AAMode.NFAA => nfaa, 
				AAMode.SSAA => ssaa, 
				AAMode.DLAA => dlaa, 
				_ => null, 
			};
		}

		public override bool CheckResources()
		{
			CheckSupport(needDepth: false);
			materialFXAAPreset2 = CreateMaterial(shaderFXAAPreset2, materialFXAAPreset2);
			materialFXAAPreset3 = CreateMaterial(shaderFXAAPreset3, materialFXAAPreset3);
			materialFXAAII = CreateMaterial(shaderFXAAII, materialFXAAII);
			materialFXAAIII = CreateMaterial(shaderFXAAIII, materialFXAAIII);
			nfaa = CreateMaterial(nfaaShader, nfaa);
			ssaa = CreateMaterial(ssaaShader, ssaa);
			dlaa = CreateMaterial(dlaaShader, dlaa);
			if (!ssaaShader.isSupported)
			{
				NotSupported();
				ReportAutoDisable();
			}
			return isSupported;
		}

		public void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			if (!CheckResources())
			{
				Graphics.Blit(source, destination);
			}
			else if (mode == AAMode.FXAA3Console && materialFXAAIII != null)
			{
				materialFXAAIII.SetFloat("_EdgeThresholdMin", edgeThresholdMin);
				materialFXAAIII.SetFloat("_EdgeThreshold", edgeThreshold);
				materialFXAAIII.SetFloat("_EdgeSharpness", edgeSharpness);
				Graphics.Blit(source, destination, materialFXAAIII);
			}
			else if (mode == AAMode.FXAA1PresetB && materialFXAAPreset3 != null)
			{
				Graphics.Blit(source, destination, materialFXAAPreset3);
			}
			else if (mode == AAMode.FXAA1PresetA && materialFXAAPreset2 != null)
			{
				source.anisoLevel = 4;
				Graphics.Blit(source, destination, materialFXAAPreset2);
				source.anisoLevel = 0;
			}
			else if (mode == AAMode.FXAA2 && materialFXAAII != null)
			{
				Graphics.Blit(source, destination, materialFXAAII);
			}
			else if (mode == AAMode.SSAA && ssaa != null)
			{
				Graphics.Blit(source, destination, ssaa);
			}
			else if (mode == AAMode.DLAA && dlaa != null)
			{
				source.anisoLevel = 0;
				RenderTexture temporary = RenderTexture.GetTemporary(source.width, source.height);
				Graphics.Blit(source, temporary, dlaa, 0);
				Graphics.Blit(temporary, destination, dlaa, (!dlaaSharp) ? 1 : 2);
				RenderTexture.ReleaseTemporary(temporary);
			}
			else if (mode == AAMode.NFAA && nfaa != null)
			{
				source.anisoLevel = 0;
				nfaa.SetFloat("_OffsetScale", offsetScale);
				nfaa.SetFloat("_BlurRadius", blurRadius);
				Graphics.Blit(source, destination, nfaa, showGeneratedNormals ? 1 : 0);
			}
			else
			{
				Graphics.Blit(source, destination);
			}
		}
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(Camera))]
	[AddComponentMenu("Image Effects/Bloom and Glow/Bloom")]
	public class Bloom : PostEffectsBase
	{
		public enum LensFlareStyle
		{
			Ghosting,
			Anamorphic,
			Combined
		}

		public enum TweakMode
		{
			Basic,
			Complex
		}

		public enum HDRBloomMode
		{
			Auto,
			On,
			Off
		}

		public enum BloomScreenBlendMode
		{
			Screen,
			Add
		}

		public enum BloomQuality
		{
			Cheap,
			High
		}

		public TweakMode tweakMode;

		public BloomScreenBlendMode screenBlendMode = BloomScreenBlendMode.Add;

		public HDRBloomMode hdr;

		private bool doHdr;

		public float sepBlurSpread = 2.5f;

		public BloomQuality quality = BloomQuality.High;

		public float bloomIntensity = 0.5f;

		public float bloomThreshold = 0.5f;

		public Color bloomThresholdColor = Color.white;

		public int bloomBlurIterations = 2;

		public int hollywoodFlareBlurIterations = 2;

		public float flareRotation;

		public LensFlareStyle lensflareMode = LensFlareStyle.Anamorphic;

		public float hollyStretchWidth = 2.5f;

		public float lensflareIntensity;

		public float lensflareThreshold = 0.3f;

		public float lensFlareSaturation = 0.75f;

		public Color flareColorA = new Color(0.4f, 0.4f, 0.8f, 0.75f);

		public Color flareColorB = new Color(0.4f, 0.8f, 0.8f, 0.75f);

		public Color flareColorC = new Color(0.8f, 0.4f, 0.8f, 0.75f);

		public Color flareColorD = new Color(0.8f, 0.4f, 0f, 0.75f);

		public Texture2D lensFlareVignetteMask;

		public Shader lensFlareShader;

		private Material lensFlareMaterial;

		public Shader screenBlendShader;

		private Material screenBlend;

		public Shader blurAndFlaresShader;

		private Material blurAndFlaresMaterial;

		public Shader brightPassFilterShader;

		private Material brightPassFilterMaterial;

		public override bool CheckResources()
		{
			CheckSupport(needDepth: false);
			screenBlend = CheckShaderAndCreateMaterial(screenBlendShader, screenBlend);
			lensFlareMaterial = CheckShaderAndCreateMaterial(lensFlareShader, lensFlareMaterial);
			blurAndFlaresMaterial = CheckShaderAndCreateMaterial(blurAndFlaresShader, blurAndFlaresMaterial);
			brightPassFilterMaterial = CheckShaderAndCreateMaterial(brightPassFilterShader, brightPassFilterMaterial);
			if (!isSupported)
			{
				ReportAutoDisable();
			}
			return isSupported;
		}

		public void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			if (!CheckResources())
			{
				Graphics.Blit(source, destination);
				return;
			}
			doHdr = false;
			if (hdr == HDRBloomMode.Auto)
			{
				doHdr = source.format == RenderTextureFormat.ARGBHalf && GetComponent<Camera>().allowHDR;
			}
			else
			{
				doHdr = hdr == HDRBloomMode.On;
			}
			doHdr = doHdr && supportHDRTextures;
			BloomScreenBlendMode bloomScreenBlendMode = screenBlendMode;
			if (doHdr)
			{
				bloomScreenBlendMode = BloomScreenBlendMode.Add;
			}
			RenderTextureFormat format = (doHdr ? RenderTextureFormat.ARGBHalf : RenderTextureFormat.Default);
			int width = source.width / 2;
			int height = source.height / 2;
			int width2 = source.width / 4;
			int height2 = source.height / 4;
			float num = 1f * (float)source.width / (1f * (float)source.height);
			float num2 = 0.001953125f;
			RenderTexture temporary = RenderTexture.GetTemporary(width2, height2, 0, format);
			RenderTexture temporary2 = RenderTexture.GetTemporary(width, height, 0, format);
			if (quality > BloomQuality.Cheap)
			{
				Graphics.Blit(source, temporary2, screenBlend, 2);
				RenderTexture temporary3 = RenderTexture.GetTemporary(width2, height2, 0, format);
				Graphics.Blit(temporary2, temporary3, screenBlend, 2);
				Graphics.Blit(temporary3, temporary, screenBlend, 6);
				RenderTexture.ReleaseTemporary(temporary3);
			}
			else
			{
				Graphics.Blit(source, temporary2);
				Graphics.Blit(temporary2, temporary, screenBlend, 6);
			}
			RenderTexture.ReleaseTemporary(temporary2);
			RenderTexture renderTexture = RenderTexture.GetTemporary(width2, height2, 0, format);
			BrightFilter(bloomThreshold * bloomThresholdColor, temporary, renderTexture);
			if (bloomBlurIterations < 1)
			{
				bloomBlurIterations = 1;
			}
			else if (bloomBlurIterations > 10)
			{
				bloomBlurIterations = 10;
			}
			for (int i = 0; i < bloomBlurIterations; i++)
			{
				float num3 = (1f + (float)i * 0.25f) * sepBlurSpread;
				RenderTexture temporary4 = RenderTexture.GetTemporary(width2, height2, 0, format);
				blurAndFlaresMaterial.SetVector("_Offsets", new Vector4(0f, num3 * num2, 0f, 0f));
				Graphics.Blit(renderTexture, temporary4, blurAndFlaresMaterial, 4);
				RenderTexture.ReleaseTemporary(renderTexture);
				renderTexture = temporary4;
				temporary4 = RenderTexture.GetTemporary(width2, height2, 0, format);
				blurAndFlaresMaterial.SetVector("_Offsets", new Vector4(num3 / num * num2, 0f, 0f, 0f));
				Graphics.Blit(renderTexture, temporary4, blurAndFlaresMaterial, 4);
				RenderTexture.ReleaseTemporary(renderTexture);
				renderTexture = temporary4;
				if (quality > BloomQuality.Cheap)
				{
					if (i == 0)
					{
						Graphics.SetRenderTarget(temporary);
						GL.Clear(clearDepth: false, clearColor: true, Color.black);
						Graphics.Blit(renderTexture, temporary);
					}
					else
					{
						temporary.MarkRestoreExpected();
						Graphics.Blit(renderTexture, temporary, screenBlend, 10);
					}
				}
			}
			if (quality > BloomQuality.Cheap)
			{
				Graphics.SetRenderTarget(renderTexture);
				GL.Clear(clearDepth: false, clearColor: true, Color.black);
				Graphics.Blit(temporary, renderTexture, screenBlend, 6);
			}
			if (lensflareIntensity > Mathf.Epsilon)
			{
				RenderTexture temporary5 = RenderTexture.GetTemporary(width2, height2, 0, format);
				if (lensflareMode == LensFlareStyle.Ghosting)
				{
					BrightFilter(lensflareThreshold, renderTexture, temporary5);
					if (quality > BloomQuality.Cheap)
					{
						blurAndFlaresMaterial.SetVector("_Offsets", new Vector4(0f, 1.5f / (1f * (float)temporary.height), 0f, 0f));
						Graphics.SetRenderTarget(temporary);
						GL.Clear(clearDepth: false, clearColor: true, Color.black);
						Graphics.Blit(temporary5, temporary, blurAndFlaresMaterial, 4);
						blurAndFlaresMaterial.SetVector("_Offsets", new Vector4(1.5f / (1f * (float)temporary.width), 0f, 0f, 0f));
						Graphics.SetRenderTarget(temporary5);
						GL.Clear(clearDepth: false, clearColor: true, Color.black);
						Graphics.Blit(temporary, temporary5, blurAndFlaresMaterial, 4);
					}
					Vignette(0.975f, temporary5, temporary5);
					BlendFlares(temporary5, renderTexture);
				}
				else
				{
					float num4 = 1f * Mathf.Cos(flareRotation);
					float num5 = 1f * Mathf.Sin(flareRotation);
					float num6 = hollyStretchWidth * 1f / num * num2;
					blurAndFlaresMaterial.SetVector("_Offsets", new Vector4(num4, num5, 0f, 0f));
					blurAndFlaresMaterial.SetVector("_Threshhold", new Vector4(lensflareThreshold, 1f, 0f, 0f));
					blurAndFlaresMaterial.SetVector("_TintColor", new Vector4(flareColorA.r, flareColorA.g, flareColorA.b, flareColorA.a) * flareColorA.a * lensflareIntensity);
					blurAndFlaresMaterial.SetFloat("_Saturation", lensFlareSaturation);
					temporary.DiscardContents();
					Graphics.Blit(temporary5, temporary, blurAndFlaresMaterial, 2);
					temporary5.DiscardContents();
					Graphics.Blit(temporary, temporary5, blurAndFlaresMaterial, 3);
					blurAndFlaresMaterial.SetVector("_Offsets", new Vector4(num4 * num6, num5 * num6, 0f, 0f));
					blurAndFlaresMaterial.SetFloat("_StretchWidth", hollyStretchWidth);
					temporary.DiscardContents();
					Graphics.Blit(temporary5, temporary, blurAndFlaresMaterial, 1);
					blurAndFlaresMaterial.SetFloat("_StretchWidth", hollyStretchWidth * 2f);
					temporary5.DiscardContents();
					Graphics.Blit(temporary, temporary5, blurAndFlaresMaterial, 1);
					blurAndFlaresMaterial.SetFloat("_StretchWidth", hollyStretchWidth * 4f);
					temporary.DiscardContents();
					Graphics.Blit(temporary5, temporary, blurAndFlaresMaterial, 1);
					for (int j = 0; j < hollywoodFlareBlurIterations; j++)
					{
						num6 = hollyStretchWidth * 2f / num * num2;
						blurAndFlaresMaterial.SetVector("_Offsets", new Vector4(num6 * num4, num6 * num5, 0f, 0f));
						temporary5.DiscardContents();
						Graphics.Blit(temporary, temporary5, blurAndFlaresMaterial, 4);
						blurAndFlaresMaterial.SetVector("_Offsets", new Vector4(num6 * num4, num6 * num5, 0f, 0f));
						temporary.DiscardContents();
						Graphics.Blit(temporary5, temporary, blurAndFlaresMaterial, 4);
					}
					if (lensflareMode == LensFlareStyle.Anamorphic)
					{
						AddTo(1f, temporary, renderTexture);
					}
					else
					{
						Vignette(1f, temporary, temporary5);
						BlendFlares(temporary5, temporary);
						AddTo(1f, temporary, renderTexture);
					}
				}
				RenderTexture.ReleaseTemporary(temporary5);
			}
			int pass = (int)bloomScreenBlendMode;
			screenBlend.SetFloat("_Intensity", bloomIntensity);
			screenBlend.SetTexture("_ColorBuffer", source);
			if (quality > BloomQuality.Cheap)
			{
				RenderTexture temporary6 = RenderTexture.GetTemporary(width, height, 0, format);
				Graphics.Blit(renderTexture, temporary6);
				Graphics.Blit(temporary6, destination, screenBlend, pass);
				RenderTexture.ReleaseTemporary(temporary6);
			}
			else
			{
				Graphics.Blit(renderTexture, destination, screenBlend, pass);
			}
			RenderTexture.ReleaseTemporary(temporary);
			RenderTexture.ReleaseTemporary(renderTexture);
		}

		private void AddTo(float intensity_, RenderTexture from, RenderTexture to)
		{
			screenBlend.SetFloat("_Intensity", intensity_);
			to.MarkRestoreExpected();
			Graphics.Blit(from, to, screenBlend, 9);
		}

		private void BlendFlares(RenderTexture from, RenderTexture to)
		{
			lensFlareMaterial.SetVector("colorA", new Vector4(flareColorA.r, flareColorA.g, flareColorA.b, flareColorA.a) * lensflareIntensity);
			lensFlareMaterial.SetVector("colorB", new Vector4(flareColorB.r, flareColorB.g, flareColorB.b, flareColorB.a) * lensflareIntensity);
			lensFlareMaterial.SetVector("colorC", new Vector4(flareColorC.r, flareColorC.g, flareColorC.b, flareColorC.a) * lensflareIntensity);
			lensFlareMaterial.SetVector("colorD", new Vector4(flareColorD.r, flareColorD.g, flareColorD.b, flareColorD.a) * lensflareIntensity);
			to.MarkRestoreExpected();
			Graphics.Blit(from, to, lensFlareMaterial);
		}

		private void BrightFilter(float thresh, RenderTexture from, RenderTexture to)
		{
			brightPassFilterMaterial.SetVector("_Threshhold", new Vector4(thresh, thresh, thresh, thresh));
			Graphics.Blit(from, to, brightPassFilterMaterial, 0);
		}

		private void BrightFilter(Color threshColor, RenderTexture from, RenderTexture to)
		{
			brightPassFilterMaterial.SetVector("_Threshhold", threshColor);
			Graphics.Blit(from, to, brightPassFilterMaterial, 1);
		}

		private void Vignette(float amount, RenderTexture from, RenderTexture to)
		{
			if ((bool)lensFlareVignetteMask)
			{
				screenBlend.SetTexture("_ColorBuffer", lensFlareVignetteMask);
				to.MarkRestoreExpected();
				Graphics.Blit((from == to) ? null : from, to, screenBlend, (from == to) ? 7 : 3);
			}
			else if (from != to)
			{
				Graphics.SetRenderTarget(to);
				GL.Clear(clearDepth: false, clearColor: true, Color.black);
				Graphics.Blit(from, to);
			}
		}
	}
	public enum LensflareStyle34
	{
		Ghosting,
		Anamorphic,
		Combined
	}
	public enum TweakMode34
	{
		Basic,
		Complex
	}
	public enum HDRBloomMode
	{
		Auto,
		On,
		Off
	}
	public enum BloomScreenBlendMode
	{
		Screen,
		Add
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(Camera))]
	[AddComponentMenu("Image Effects/Bloom and Glow/BloomAndFlares (3.5, Deprecated)")]
	public class BloomAndFlares : PostEffectsBase
	{
		public TweakMode34 tweakMode;

		public BloomScreenBlendMode screenBlendMode = BloomScreenBlendMode.Add;

		public HDRBloomMode hdr;

		private bool doHdr;

		public float sepBlurSpread = 1.5f;

		public float useSrcAlphaAsMask = 0.5f;

		public float bloomIntensity = 1f;

		public float bloomThreshold = 0.5f;

		public int bloomBlurIterations = 2;

		public bool lensflares;

		public int hollywoodFlareBlurIterations = 2;

		public LensflareStyle34 lensflareMode = LensflareStyle34.Anamorphic;

		public float hollyStretchWidth = 3.5f;

		public float lensflareIntensity = 1f;

		public float lensflareThreshold = 0.3f;

		public Color flareColorA = new Color(0.4f, 0.4f, 0.8f, 0.75f);

		public Color flareColorB = new Color(0.4f, 0.8f, 0.8f, 0.75f);

		public Color flareColorC = new Color(0.8f, 0.4f, 0.8f, 0.75f);

		public Color flareColorD = new Color(0.8f, 0.4f, 0f, 0.75f);

		public Texture2D lensFlareVignetteMask;

		public Shader lensFlareShader;

		private Material lensFlareMaterial;

		public Shader vignetteShader;

		private Material vignetteMaterial;

		public Shader separableBlurShader;

		private Material separableBlurMaterial;

		public Shader addBrightStuffOneOneShader;

		private Material addBrightStuffBlendOneOneMaterial;

		public Shader screenBlendShader;

		private Material screenBlend;

		public Shader hollywoodFlaresShader;

		private Material hollywoodFlaresMaterial;

		public Shader brightPassFilterShader;

		private Material brightPassFilterMaterial;

		public override bool CheckResources()
		{
			CheckSupport(needDepth: false);
			screenBlend = CheckShaderAndCreateMaterial(screenBlendShader, screenBlend);
			lensFlareMaterial = CheckShaderAndCreateMaterial(lensFlareShader, lensFlareMaterial);
			vignetteMaterial = CheckShaderAndCreateMaterial(vignetteShader, vignetteMaterial);
			separableBlurMaterial = CheckShaderAndCreateMaterial(separableBlurShader, separableBlurMaterial);
			addBrightStuffBlendOneOneMaterial = CheckShaderAndCreateMaterial(addBrightStuffOneOneShader, addBrightStuffBlendOneOneMaterial);
			hollywoodFlaresMaterial = CheckShaderAndCreateMaterial(hollywoodFlaresShader, hollywoodFlaresMaterial);
			brightPassFilterMaterial = CheckShaderAndCreateMaterial(brightPassFilterShader, brightPassFilterMaterial);
			if (!isSupported)
			{
				ReportAutoDisable();
			}
			return isSupported;
		}

		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			if (!CheckResources())
			{
				Graphics.Blit(source, destination);
				return;
			}
			doHdr = false;
			if (hdr == HDRBloomMode.Auto)
			{
				doHdr = source.format == RenderTextureFormat.ARGBHalf && GetComponent<Camera>().allowHDR;
			}
			else
			{
				doHdr = hdr == HDRBloomMode.On;
			}
			doHdr = doHdr && supportHDRTextures;
			BloomScreenBlendMode pass = screenBlendMode;
			if (doHdr)
			{
				pass = BloomScreenBlendMode.Add;
			}
			RenderTextureFormat format = (doHdr ? RenderTextureFormat.ARGBHalf : RenderTextureFormat.Default);
			RenderTexture temporary = RenderTexture.GetTemporary(source.width / 2, source.height / 2, 0, format);
			RenderTexture temporary2 = RenderTexture.GetTemporary(source.width / 4, source.height / 4, 0, format);
			RenderTexture temporary3 = RenderTexture.GetTemporary(source.width / 4, source.height / 4, 0, format);
			RenderTexture temporary4 = RenderTexture.GetTemporary(source.width / 4, source.height / 4, 0, format);
			float num = 1f * (float)source.width / (1f * (float)source.height);
			float num2 = 0.001953125f;
			Graphics.Blit(source, temporary, screenBlend, 2);
			Graphics.Blit(temporary, temporary2, screenBlend, 2);
			RenderTexture.ReleaseTemporary(temporary);
			BrightFilter(bloomThreshold, useSrcAlphaAsMask, temporary2, temporary3);
			temporary2.DiscardContents();
			if (bloomBlurIterations < 1)
			{
				bloomBlurIterations = 1;
			}
			for (int i = 0; i < bloomBlurIterations; i++)
			{
				float num3 = (1f + (float)i * 0.5f) * sepBlurSpread;
				separableBlurMaterial.SetVector("offsets", new Vector4(0f, num3 * num2, 0f, 0f));
				RenderTexture obj = ((i == 0) ? temporary3 : temporary2);
				Graphics.Blit(obj, temporary4, separableBlurMaterial);
				obj.DiscardContents();
				separableBlurMaterial.SetVector("offsets", new Vector4(num3 / num * num2, 0f, 0f, 0f));
				Graphics.Blit(temporary4, temporary2, separableBlurMaterial);
				temporary4.DiscardContents();
			}
			if (lensflares)
			{
				if (lensflareMode == LensflareStyle34.Ghosting)
				{
					BrightFilter(lensflareThreshold, 0f, temporary2, temporary4);
					temporary2.DiscardContents();
					Vignette(0.975f, temporary4, temporary3);
					temporary4.DiscardContents();
					BlendFlares(temporary3, temporary2);
					temporary3.DiscardContents();
				}
				else
				{
					hollywoodFlaresMaterial.SetVector("_threshold", new Vector4(lensflareThreshold, 1f / (1f - lensflareThreshold), 0f, 0f));
					hollywoodFlaresMaterial.SetVector("tintColor", new Vector4(flareColorA.r, flareColorA.g, flareColorA.b, flareColorA.a) * flareColorA.a * lensflareIntensity);
					Graphics.Blit(temporary4, temporary3, hollywoodFlaresMaterial, 2);
					temporary4.DiscardContents();
					Graphics.Blit(temporary3, temporary4, hollywoodFlaresMaterial, 3);
					temporary3.DiscardContents();
					hollywoodFlaresMaterial.SetVector("offsets", new Vector4(sepBlurSpread * 1f / num * num2, 0f, 0f, 0f));
					hollywoodFlaresMaterial.SetFloat("stretchWidth", hollyStretchWidth);
					Graphics.Blit(temporary4, temporary3, hollywoodFlaresMaterial, 1);
					temporary4.DiscardContents();
					hollywoodFlaresMaterial.SetFloat("stretchWidth", hollyStretchWidth * 2f);
					Graphics.Blit(temporary3, temporary4, hollywoodFlaresMaterial, 1);
					temporary3.DiscardContents();
					hollywoodFlaresMaterial.SetFloat("stretchWidth", hollyStretchWidth * 4f);
					Graphics.Blit(temporary4, temporary3, hollywoodFlaresMaterial, 1);
					temporary4.DiscardContents();
					if (lensflareMode == LensflareStyle34.Anamorphic)
					{
						for (int j = 0; j < hollywoodFlareBlurIterations; j++)
						{
							separableBlurMaterial.SetVector("offsets", new Vector4(hollyStretchWidth * 2f / num * num2, 0f, 0f, 0f));
							Graphics.Blit(temporary3, temporary4, separableBlurMaterial);
							temporary3.DiscardContents();
							separableBlurMaterial.SetVector("offsets", new Vector4(hollyStretchWidth * 2f / num * num2, 0f, 0f, 0f));
							Graphics.Blit(temporary4, temporary3, separableBlurMaterial);
							temporary4.DiscardContents();
						}
						AddTo(1f, temporary3, temporary2);
						temporary3.DiscardContents();
					}
					else
					{
						for (int k = 0; k < hollywoodFlareBlurIterations; k++)
						{
							separableBlurMaterial.SetVector("offsets", new Vector4(hollyStretchWidth * 2f / num * num2, 0f, 0f, 0f));
							Graphics.Blit(temporary3, temporary4, separableBlurMaterial);
							temporary3.DiscardContents();
							separableBlurMaterial.SetVector("offsets", new Vector4(hollyStretchWidth * 2f / num * num2, 0f, 0f, 0f));
							Graphics.Blit(temporary4, temporary3, separableBlurMaterial);
							temporary4.DiscardContents();
						}
						Vignette(1f, temporary3, temporary4);
						temporary3.DiscardContents();
						BlendFlares(temporary4, temporary3);
						temporary4.DiscardContents();
						AddTo(1f, temporary3, temporary2);
						temporary3.DiscardContents();
					}
				}
			}
			screenBlend.SetFloat("_Intensity", bloomIntensity);
			screenBlend.SetTexture("_ColorBuffer", source);
			Graphics.Blit(temporary2, destination, screenBlend, (int)pass);
			RenderTexture.ReleaseTemporary(temporary2);
			RenderTexture.ReleaseTemporary(temporary3);
			RenderTexture.ReleaseTemporary(temporary4);
		}

		private void AddTo(float intensity_, RenderTexture from, RenderTexture to)
		{
			addBrightStuffBlendOneOneMaterial.SetFloat("_Intensity", intensity_);
			Graphics.Blit(from, to, addBrightStuffBlendOneOneMaterial);
		}

		private void BlendFlares(RenderTexture from, RenderTexture to)
		{
			lensFlareMaterial.SetVector("colorA", new Vector4(flareColorA.r, flareColorA.g, flareColorA.b, flareColorA.a) * lensflareIntensity);
			lensFlareMaterial.SetVector("colorB", new Vector4(flareColorB.r, flareColorB.g, flareColorB.b, flareColorB.a) * lensflareIntensity);
			lensFlareMaterial.SetVector("colorC", new Vector4(flareColorC.r, flareColorC.g, flareColorC.b, flareColorC.a) * lensflareIntensity);
			lensFlareMaterial.SetVector("colorD", new Vector4(flareColorD.r, flareColorD.g, flareColorD.b, flareColorD.a) * lensflareIntensity);
			Graphics.Blit(from, to, lensFlareMaterial);
		}

		private void BrightFilter(float thresh, float useAlphaAsMask, RenderTexture from, RenderTexture to)
		{
			if (doHdr)
			{
				brightPassFilterMaterial.SetVector("threshold", new Vector4(thresh, 1f, 0f, 0f));
			}
			else
			{
				brightPassFilterMaterial.SetVector("threshold", new Vector4(thresh, 1f / (1f - thresh), 0f, 0f));
			}
			brightPassFilterMaterial.SetFloat("useSrcAlphaAsMask", useAlphaAsMask);
			Graphics.Blit(from, to, brightPassFilterMaterial);
		}

		private void Vignette(float amount, RenderTexture from, RenderTexture to)
		{
			if ((bool)lensFlareVignetteMask)
			{
				screenBlend.SetTexture("_ColorBuffer", lensFlareVignetteMask);
				Graphics.Blit(from, to, screenBlend, 3);
			}
			else
			{
				vignetteMaterial.SetFloat("vignetteIntensity", amount);
				Graphics.Blit(from, to, vignetteMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(Camera))]
	[AddComponentMenu("Image Effects/Bloom and Glow/Bloom (Optimized)")]
	public class BloomOptimized : PostEffectsBase
	{
		public enum Resolution
		{
			Low,
			High
		}

		public enum BlurType
		{
			Standard,
			Sgx
		}

		[Range(0f, 1.5f)]
		public float threshold = 0.25f;

		[Range(0f, 2.5f)]
		public float intensity = 0.75f;

		[Range(0.25f, 5.5f)]
		public float blurSize = 1f;

		private Resolution resolution;

		[Range(1f, 4f)]
		public int blurIterations = 1;

		public BlurType blurType;

		public Shader fastBloomShader;

		private Material fastBloomMaterial;

		public override bool CheckResources()
		{
			CheckSupport(needDepth: false);
			fastBloomMaterial = CheckShaderAndCreateMaterial(fastBloomShader, fastBloomMaterial);
			if (!isSupported)
			{
				ReportAutoDisable();
			}
			return isSupported;
		}

		private void OnDisable()
		{
			if ((bool)fastBloomMaterial)
			{
				UnityEngine.Object.DestroyImmediate(fastBloomMaterial);
			}
		}

		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			if (!CheckResources())
			{
				Graphics.Blit(source, destination);
				return;
			}
			int num = ((resolution == Resolution.Low) ? 4 : 2);
			float num2 = ((resolution == Resolution.Low) ? 0.5f : 1f);
			fastBloomMaterial.SetVector("_Parameter", new Vector4(blurSize * num2, 0f, threshold, intensity));
			source.filterMode = FilterMode.Bilinear;
			int width = source.width / num;
			int height = source.height / num;
			RenderTexture renderTexture = RenderTexture.GetTemporary(width, height, 0, source.format);
			renderTexture.filterMode = FilterMode.Bilinear;
			Graphics.Blit(source, renderTexture, fastBloomMaterial, 1);
			int num3 = ((blurType != 0) ? 2 : 0);
			for (int i = 0; i < blurIterations; i++)
			{
				fastBloomMaterial.SetVector("_Parameter", new Vector4(blurSize * num2 + (float)i * 1f, 0f, threshold, intensity));
				RenderTexture temporary = RenderTexture.GetTemporary(width, height, 0, source.format);
				temporary.filterMode = FilterMode.Bilinear;
				Graphics.Blit(renderTexture, temporary, fastBloomMaterial, 2 + num3);
				RenderTexture.ReleaseTemporary(renderTexture);
				renderTexture = temporary;
				temporary = RenderTexture.GetTemporary(width, height, 0, source.format);
				temporary.filterMode = FilterMode.Bilinear;
				Graphics.Blit(renderTexture, temporary, fastBloomMaterial, 3 + num3);
				RenderTexture.ReleaseTemporary(renderTexture);
				renderTexture = temporary;
			}
			fastBloomMaterial.SetTexture("_Bloom", renderTexture);
			Graphics.Blit(source, destination, fastBloomMaterial, 0);
			RenderTexture.ReleaseTemporary(renderTexture);
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Image Effects/Blur/Blur")]
	public class Blur : MonoBehaviour
	{
		[Range(0f, 10f)]
		public int iterations = 3;

		[Range(0f, 1f)]
		public float blurSpread = 0.6f;

		public Shader blurShader;

		private static Material m_Material;

		protected Material material
		{
			get
			{
				if (m_Material == null)
				{
					m_Material = new Material(blurShader);
					m_Material.hideFlags = HideFlags.DontSave;
				}
				return m_Material;
			}
		}

		protected void OnDisable()
		{
			if ((bool)m_Material)
			{
				UnityEngine.Object.DestroyImmediate(m_Material);
			}
		}

		protected void Start()
		{
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
			else if (!blurShader || !material.shader.isSupported)
			{
				base.enabled = false;
			}
		}

		public void FourTapCone(RenderTexture source, RenderTexture dest, int iteration)
		{
			float num = 0.5f + (float)iteration * blurSpread;
			Graphics.BlitMultiTap(source, dest, material, new Vector2(0f - num, 0f - num), new Vector2(0f - num, num), new Vector2(num, num), new Vector2(num, 0f - num));
		}

		private void DownSample4x(RenderTexture source, RenderTexture dest)
		{
			float num = 1f;
			Graphics.BlitMultiTap(source, dest, material, new Vector2(0f - num, 0f - num), new Vector2(0f - num, num), new Vector2(num, num), new Vector2(num, 0f - num));
		}

		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			int width = source.width / 4;
			int height = source.height / 4;
			RenderTexture renderTexture = RenderTexture.GetTemporary(width, height, 0);
			DownSample4x(source, renderTexture);
			for (int i = 0; i < iterations; i++)
			{
				RenderTexture temporary = RenderTexture.GetTemporary(width, height, 0);
				FourTapCone(renderTexture, temporary, i);
				RenderTexture.ReleaseTemporary(renderTexture);
				renderTexture = temporary;
			}
			Graphics.Blit(renderTexture, destination);
			RenderTexture.ReleaseTemporary(renderTexture);
		}
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(Camera))]
	[AddComponentMenu("Image Effects/Blur/Blur (Optimized)")]
	public class BlurOptimized : PostEffectsBase
	{
		public enum BlurType
		{
			StandardGauss,
			SgxGauss
		}

		[Range(0f, 2f)]
		public int downsample = 1;

		[Range(0f, 10f)]
		public float blurSize = 3f;

		[Range(1f, 4f)]
		public int blurIterations = 2;

		public BlurType blurType;

		public Shader blurShader;

		private Material blurMaterial;

		public override bool CheckResources()
		{
			CheckSupport(needDepth: false);
			blurMaterial = CheckShaderAndCreateMaterial(blurShader, blurMaterial);
			if (!isSupported)
			{
				ReportAutoDisable();
			}
			return isSupported;
		}

		public void OnDisable()
		{
			if ((bool)blurMaterial)
			{
				UnityEngine.Object.DestroyImmediate(blurMaterial);
			}
		}

		public void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			if (!CheckResources())
			{
				Graphics.Blit(source, destination);
				return;
			}
			float num = 1f / (1f * (float)(1 << downsample));
			blurMaterial.SetVector("_Parameter", new Vector4(blurSize * num, (0f - blurSize) * num, 0f, 0f));
			source.filterMode = FilterMode.Bilinear;
			int width = source.width >> downsample;
			int height = source.height >> downsample;
			RenderTexture renderTexture = RenderTexture.GetTemporary(width, height, 0, source.format);
			renderTexture.filterMode = FilterMode.Bilinear;
			Graphics.Blit(source, renderTexture, blurMaterial, 0);
			int num2 = ((blurType != 0) ? 2 : 0);
			for (int i = 0; i < blurIterations; i++)
			{
				float num3 = (float)i * 1f;
				blurMaterial.SetVector("_Parameter", new Vector4(blurSize * num + num3, (0f - blurSize) * num - num3, 0f, 0f));
				RenderTexture temporary = RenderTexture.GetTemporary(width, height, 0, source.format);
				temporary.filterMode = FilterMode.Bilinear;
				Graphics.Blit(renderTexture, temporary, blurMaterial, 1 + num2);
				RenderTexture.ReleaseTemporary(renderTexture);
				renderTexture = temporary;
				temporary = RenderTexture.GetTemporary(width, height, 0, source.format);
				temporary.filterMode = FilterMode.Bilinear;
				Graphics.Blit(renderTexture, temporary, blurMaterial, 2 + num2);
				RenderTexture.ReleaseTemporary(renderTexture);
				renderTexture = temporary;
			}
			Graphics.Blit(renderTexture, destination);
			RenderTexture.ReleaseTemporary(renderTexture);
		}
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(Camera))]
	[AddComponentMenu("Image Effects/Camera/Camera Motion Blur")]
	public class CameraMotionBlur : PostEffectsBase
	{
		public enum MotionBlurFilter
		{
			CameraMotion,
			LocalBlur,
			Reconstruction,
			ReconstructionDX11,
			ReconstructionDisc
		}

		private static float MAX_RADIUS = 10f;

		public MotionBlurFilter filterType = MotionBlurFilter.Reconstruction;

		public bool preview;

		public Vector3 previewScale = Vector3.one;

		public float movementScale;

		public float rotationScale = 1f;

		public float maxVelocity = 8f;

		public float minVelocity = 0.1f;

		public float velocityScale = 0.375f;

		public float softZDistance = 0.005f;

		public int velocityDownsample = 1;

		public LayerMask excludeLayers = 0;

		private GameObject tmpCam;

		public Shader shader;

		public Shader dx11MotionBlurShader;

		public Shader replacementClear;

		private Material motionBlurMaterial;

		private Material dx11MotionBlurMaterial;

		public Texture2D noiseTexture;

		public float jitter = 0.05f;

		public bool showVelocity;

		public float showVelocityScale = 1f;

		private Matrix4x4 currentViewProjMat;

		private Matrix4x4[] currentStereoViewProjMat;

		private Matrix4x4 prevViewProjMat;

		private Matrix4x4[] prevStereoViewProjMat;

		private int prevFrameCount;

		private bool wasActive;

		private Vector3 prevFrameForward = Vector3.forward;

		private Vector3 prevFrameUp = Vector3.up;

		private Vector3 prevFramePos = Vector3.zero;

		private Camera _camera;

		private void CalculateViewProjection()
		{
			Matrix4x4 worldToCameraMatrix = _camera.worldToCameraMatrix;
			Matrix4x4 gPUProjectionMatrix = GL.GetGPUProjectionMatrix(_camera.projectionMatrix, renderIntoTexture: true);
			currentViewProjMat = gPUProjectionMatrix * worldToCameraMatrix;
			if (_camera.stereoEnabled)
			{
				for (int i = 0; i < 2; i++)
				{
					Matrix4x4 stereoViewMatrix = _camera.GetStereoViewMatrix((i != 0) ? Camera.StereoscopicEye.Right : Camera.StereoscopicEye.Left);
					Matrix4x4 stereoProjectionMatrix = _camera.GetStereoProjectionMatrix((i != 0) ? Camera.StereoscopicEye.Right : Camera.StereoscopicEye.Left);
					stereoProjectionMatrix = GL.GetGPUProjectionMatrix(stereoProjectionMatrix, renderIntoTexture: true);
					currentStereoViewProjMat[i] = stereoProjectionMatrix * stereoViewMatrix;
				}
			}
		}

		private new void Start()
		{
			CheckResources();
			if (_camera == null)
			{
				_camera = GetComponent<Camera>();
			}
			wasActive = base.gameObject.activeInHierarchy;
			currentStereoViewProjMat = new Matrix4x4[2];
			prevStereoViewProjMat = new Matrix4x4[2];
			CalculateViewProjection();
			Remember();
			wasActive = false;
		}

		private void OnEnable()
		{
			if (_camera == null)
			{
				_camera = GetComponent<Camera>();
			}
			_camera.depthTextureMode |= DepthTextureMode.Depth;
		}

		private void OnDisable()
		{
			if (null != motionBlurMaterial)
			{
				UnityEngine.Object.DestroyImmediate(motionBlurMaterial);
				motionBlurMaterial = null;
			}
			if (null != dx11MotionBlurMaterial)
			{
				UnityEngine.Object.DestroyImmediate(dx11MotionBlurMaterial);
				dx11MotionBlurMaterial = null;
			}
			if (null != tmpCam)
			{
				UnityEngine.Object.DestroyImmediate(tmpCam);
				tmpCam = null;
			}
		}

		public override bool CheckResources()
		{
			CheckSupport(needDepth: true, needHdr: true);
			motionBlurMaterial = CheckShaderAndCreateMaterial(shader, motionBlurMaterial);
			if (supportDX11 && filterType == MotionBlurFilter.ReconstructionDX11)
			{
				dx11MotionBlurMaterial = CheckShaderAndCreateMaterial(dx11MotionBlurShader, dx11MotionBlurMaterial);
			}
			if (!isSupported)
			{
				ReportAutoDisable();
			}
			return isSupported;
		}

		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			if (!CheckResources())
			{
				Graphics.Blit(source, destination);
				return;
			}
			if (filterType == MotionBlurFilter.CameraMotion)
			{
				StartFrame();
			}
			RenderTextureFormat format = (SystemInfo.SupportsRenderTextureFormat(RenderTextureFormat.RGHalf) ? RenderTextureFormat.RGHalf : RenderTextureFormat.ARGBHalf);
			RenderTexture temporary = RenderTexture.GetTemporary(divRoundUp(source.width, velocityDownsample), divRoundUp(source.height, velocityDownsample), 0, format);
			int num = 1;
			int num2 = 1;
			maxVelocity = Mathf.Max(2f, maxVelocity);
			float num3 = maxVelocity;
			bool flag = filterType == MotionBlurFilter.ReconstructionDX11 && dx11MotionBlurMaterial == null;
			if (filterType == MotionBlurFilter.Reconstruction || flag || filterType == MotionBlurFilter.ReconstructionDisc)
			{
				maxVelocity = Mathf.Min(maxVelocity, MAX_RADIUS);
				num = divRoundUp(temporary.width, (int)maxVelocity);
				num2 = divRoundUp(temporary.height, (int)maxVelocity);
				num3 = temporary.width / num;
			}
			else
			{
				num = divRoundUp(temporary.width, (int)maxVelocity);
				num2 = divRoundUp(temporary.height, (int)maxVelocity);
				num3 = temporary.width / num;
			}
			RenderTexture temporary2 = RenderTexture.GetTemporary(num, num2, 0, format);
			RenderTexture temporary3 = RenderTexture.GetTemporary(num, num2, 0, format);
			temporary.filterMode = FilterMode.Point;
			temporary2.filterMode = FilterMode.Point;
			temporary3.filterMode = FilterMode.Point;
			if ((bool)noiseTexture)
			{
				noiseTexture.filterMode = FilterMode.Point;
			}
			source.wrapMode = TextureWrapMode.Clamp;
			temporary.wrapMode = TextureWrapMode.Clamp;
			temporary3.wrapMode = TextureWrapMode.Clamp;
			temporary2.wrapMode = TextureWrapMode.Clamp;
			CalculateViewProjection();
			if (base.gameObject.activeInHierarchy && !wasActive)
			{
				Remember();
			}
			wasActive = base.gameObject.activeInHierarchy;
			Matrix4x4 matrix4x = Matrix4x4.Inverse(currentViewProjMat);
			motionBlurMaterial.SetMatrix("_InvViewProj", matrix4x);
			motionBlurMaterial.SetMatrix("_PrevViewProj", prevViewProjMat);
			motionBlurMaterial.SetMatrix("_ToPrevViewProjCombined", prevViewProjMat * matrix4x);
			if (_camera.stereoEnabled)
			{
				Matrix4x4[] array = new Matrix4x4[2]
				{
					Matrix4x4.Inverse(currentStereoViewProjMat[0]),
					Matrix4x4.Inverse(currentStereoViewProjMat[1])
				};
				Matrix4x4 value = prevStereoViewProjMat[0] * array[0];
				motionBlurMaterial.SetMatrix("_StereoToPrevViewProjCombined0", value);
				motionBlurMaterial.SetMatrix("_StereoToPrevViewProjCombined1", prevStereoViewProjMat[1] * array[1]);
			}
			motionBlurMaterial.SetFloat("_MaxVelocity", num3);
			motionBlurMaterial.SetFloat("_MaxRadiusOrKInPaper", num3);
			motionBlurMaterial.SetFloat("_MinVelocity", minVelocity);
			motionBlurMaterial.SetFloat("_VelocityScale", velocityScale);
			motionBlurMaterial.SetFloat("_Jitter", jitter);
			motionBlurMaterial.SetTexture("_NoiseTex", noiseTexture);
			motionBlurMaterial.SetTexture("_VelTex", temporary);
			motionBlurMaterial.SetTexture("_NeighbourMaxTex", temporary3);
			motionBlurMaterial.SetTexture("_TileTexDebug", temporary2);
			if (preview)
			{
				Matrix4x4 worldToCameraMatrix = _camera.worldToCameraMatrix;
				Matrix4x4 identity = Matrix4x4.identity;
				identity.SetTRS(previewScale * 0.3333f, Quaternion.identity, Vector3.one);
				Matrix4x4 gPUProjectionMatrix = GL.GetGPUProjectionMatrix(_camera.projectionMatrix, renderIntoTexture: true);
				prevViewProjMat = gPUProjectionMatrix * identity * worldToCameraMatrix;
				motionBlurMaterial.SetMatrix("_PrevViewProj", prevViewProjMat);
				motionBlurMaterial.SetMatrix("_ToPrevViewProjCombined", prevViewProjMat * matrix4x);
			}
			if (filterType == MotionBlurFilter.CameraMotion)
			{
				Vector4 zero = Vector4.zero;
				float num4 = Vector3.Dot(base.transform.up, Vector3.up);
				Vector3 rhs = prevFramePos - base.transform.position;
				float magnitude = rhs.magnitude;
				float num5 = 1f;
				num5 = Vector3.Angle(base.transform.up, prevFrameUp) / _camera.fieldOfView * ((float)source.width * 0.75f);
				zero.x = rotationScale * num5;
				num5 = Vector3.Angle(base.transform.forward, prevFrameForward) / _camera.fieldOfView * ((float)source.width * 0.75f);
				zero.y = rotationScale * num4 * num5;
				num5 = Vector3.Angle(base.transform.forward, prevFrameForward) / _camera.fieldOfView * ((float)source.width * 0.75f);
				zero.z = rotationScale * (1f - num4) * num5;
				if (magnitude > Mathf.Epsilon && movementScale > Mathf.Epsilon)
				{
					zero.w = movementScale * Vector3.Dot(base.transform.forward, rhs) * ((float)source.width * 0.5f);
					zero.x += movementScale * Vector3.Dot(base.transform.up, rhs) * ((float)source.width * 0.5f);
					zero.y += movementScale * Vector3.Dot(base.transform.right, rhs) * ((float)source.width * 0.5f);
				}
				if (preview)
				{
					motionBlurMaterial.SetVector("_BlurDirectionPacked", new Vector4(previewScale.y, previewScale.x, 0f, previewScale.z) * 0.5f * _camera.fieldOfView);
				}
				else
				{
					motionBlurMaterial.SetVector("_BlurDirectionPacked", zero);
				}
			}
			else
			{
				Graphics.Blit(source, temporary, motionBlurMaterial, 0);
				Camera camera = null;
				if (excludeLayers.value != 0)
				{
					camera = GetTmpCam();
				}
				if ((bool)camera && excludeLayers.value != 0 && (bool)replacementClear && replacementClear.isSupported)
				{
					camera.targetTexture = temporary;
					camera.cullingMask = excludeLayers;
					camera.RenderWithShader(replacementClear, "");
				}
			}
			if (!preview && Time.frameCount != prevFrameCount)
			{
				prevFrameCount = Time.frameCount;
				Remember();
			}
			source.filterMode = FilterMode.Bilinear;
			if (showVelocity)
			{
				motionBlurMaterial.SetFloat("_DisplayVelocityScale", showVelocityScale);
				Graphics.Blit(temporary, destination, motionBlurMaterial, 1);
			}
			else if (filterType == MotionBlurFilter.ReconstructionDX11 && !flag)
			{
				dx11MotionBlurMaterial.SetFloat("_MinVelocity", minVelocity);
				dx11MotionBlurMaterial.SetFloat("_VelocityScale", velocityScale);
				dx11MotionBlurMaterial.SetFloat("_Jitter", jitter);
				dx11MotionBlurMaterial.SetTexture("_NoiseTex", noiseTexture);
				dx11MotionBlurMaterial.SetTexture("_VelTex", temporary);
				dx11MotionBlurMaterial.SetTexture("_NeighbourMaxTex", temporary3);
				dx11MotionBlurMaterial.SetFloat("_SoftZDistance", Mathf.Max(0.00025f, softZDistance));
				dx11MotionBlurMaterial.SetFloat("_MaxRadiusOrKInPaper", num3);
				Graphics.Blit(temporary, temporary2, dx11MotionBlurMaterial, 0);
				Graphics.Blit(temporary2, temporary3, dx11MotionBlurMaterial, 1);
				Graphics.Blit(source, destination, dx11MotionBlurMaterial, 2);
			}
			else if (filterType == MotionBlurFilter.Reconstruction || flag)
			{
				motionBlurMaterial.SetFloat("_SoftZDistance", Mathf.Max(0.00025f, softZDistance));
				Graphics.Blit(temporary, temporary2, motionBlurMaterial, 2);
				Graphics.Blit(temporary2, temporary3, motionBlurMaterial, 3);
				Graphics.Blit(source, destination, motionBlurMaterial, 4);
			}
			else if (filterType == MotionBlurFilter.CameraMotion)
			{
				Graphics.Blit(source, destination, motionBlurMaterial, 6);
			}
			else if (filterType == MotionBlurFilter.ReconstructionDisc)
			{
				motionBlurMaterial.SetFloat("_SoftZDistance", Mathf.Max(0.00025f, softZDistance));
				Graphics.Blit(temporary, temporary2, motionBlurMaterial, 2);
				Graphics.Blit(temporary2, temporary3, motionBlurMaterial, 3);
				Graphics.Blit(source, destination, motionBlurMaterial, 7);
			}
			else
			{
				Graphics.Blit(source, destination, motionBlurMaterial, 5);
			}
			RenderTexture.ReleaseTemporary(temporary);
			RenderTexture.ReleaseTemporary(temporary2);
			RenderTexture.ReleaseTemporary(temporary3);
		}

		private void Remember()
		{
			prevViewProjMat = currentViewProjMat;
			prevFrameForward = base.transform.forward;
			prevFrameUp = base.transform.up;
			prevFramePos = base.transform.position;
			prevStereoViewProjMat[0] = currentStereoViewProjMat[0];
			prevStereoViewProjMat[1] = currentStereoViewProjMat[1];
		}

		private Camera GetTmpCam()
		{
			if (tmpCam == null)
			{
				string text = "_" + _camera.name + "_MotionBlurTmpCam";
				GameObject gameObject = GameObject.Find(text);
				if (null == gameObject)
				{
					tmpCam = new GameObject(text, typeof(Camera));
				}
				else
				{
					tmpCam = gameObject;
				}
			}
			tmpCam.hideFlags = HideFlags.DontSave;
			tmpCam.transform.position = _camera.transform.position;
			tmpCam.transform.rotation = _camera.transform.rotation;
			tmpCam.transform.localScale = _camera.transform.localScale;
			tmpCam.GetComponent<Camera>().CopyFrom(_camera);
			tmpCam.GetComponent<Camera>().enabled = false;
			tmpCam.GetComponent<Camera>().depthTextureMode = DepthTextureMode.None;
			tmpCam.GetComponent<Camera>().clearFlags = CameraClearFlags.Nothing;
			return tmpCam.GetComponent<Camera>();
		}

		private void StartFrame()
		{
			prevFramePos = Vector3.Slerp(prevFramePos, base.transform.position, 0.75f);
		}

		private static int divRoundUp(int x, int d)
		{
			return (x + d - 1) / d;
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Image Effects/Color Adjustments/Color Correction (Curves, Saturation)")]
	public class ColorCorrectionCurves : PostEffectsBase
	{
		public enum ColorCorrectionMode
		{
			Simple,
			Advanced
		}

		public AnimationCurve redChannel = new AnimationCurve(new Keyframe(0f, 0f), new Keyframe(1f, 1f));

		public AnimationCurve greenChannel = new AnimationCurve(new Keyframe(0f, 0f), new Keyframe(1f, 1f));

		public AnimationCurve blueChannel = new AnimationCurve(new Keyframe(0f, 0f), new Keyframe(1f, 1f));

		public bool useDepthCorrection;

		public AnimationCurve zCurve = new AnimationCurve(new Keyframe(0f, 0f), new Keyframe(1f, 1f));

		public AnimationCurve depthRedChannel = new AnimationCurve(new Keyframe(0f, 0f), new Keyframe(1f, 1f));

		public AnimationCurve depthGreenChannel = new AnimationCurve(new Keyframe(0f, 0f), new Keyframe(1f, 1f));

		public AnimationCurve depthBlueChannel = new AnimationCurve(new Keyframe(0f, 0f), new Keyframe(1f, 1f));

		private Material ccMaterial;

		private Material ccDepthMaterial;

		private Material selectiveCcMaterial;

		private Texture2D rgbChannelTex;

		private Texture2D rgbDepthChannelTex;

		private Texture2D zCurveTex;

		public float saturation = 1f;

		public bool selectiveCc;

		public Color selectiveFromColor = Color.white;

		public Color selectiveToColor = Color.white;

		public ColorCorrectionMode mode;

		public bool updateTextures = true;

		public Shader colorCorrectionCurvesShader;

		public Shader simpleColorCorrectionCurvesShader;

		public Shader colorCorrectionSelectiveShader;

		private bool updateTexturesOnStartup = true;

		private new void Start()
		{
			base.Start();
			updateTexturesOnStartup = true;
		}

		private void Awake()
		{
		}

		public override bool CheckResources()
		{
			CheckSupport(mode == ColorCorrectionMode.Advanced);
			ccMaterial = CheckShaderAndCreateMaterial(simpleColorCorrectionCurvesShader, ccMaterial);
			ccDepthMaterial = CheckShaderAndCreateMaterial(colorCorrectionCurvesShader, ccDepthMaterial);
			selectiveCcMaterial = CheckShaderAndCreateMaterial(colorCorrectionSelectiveShader, selectiveCcMaterial);
			if (!rgbChannelTex)
			{
				rgbChannelTex = new Texture2D(256, 4, TextureFormat.ARGB32, mipChain: false, linear: true);
			}
			if (!rgbDepthChannelTex)
			{
				rgbDepthChannelTex = new Texture2D(256, 4, TextureFormat.ARGB32, mipChain: false, linear: true);
			}
			if (!zCurveTex)
			{
				zCurveTex = new Texture2D(256, 1, TextureFormat.ARGB32, mipChain: false, linear: true);
			}
			rgbChannelTex.hideFlags = HideFlags.DontSave;
			rgbDepthChannelTex.hideFlags = HideFlags.DontSave;
			zCurveTex.hideFlags = HideFlags.DontSave;
			rgbChannelTex.wrapMode = TextureWrapMode.Clamp;
			rgbDepthChannelTex.wrapMode = TextureWrapMode.Clamp;
			zCurveTex.wrapMode = TextureWrapMode.Clamp;
			if (!isSupported)
			{
				ReportAutoDisable();
			}
			return isSupported;
		}

		public void UpdateParameters()
		{
			CheckResources();
			if (redChannel != null && greenChannel != null && blueChannel != null)
			{
				for (float num = 0f; num <= 1f; num += 0.003921569f)
				{
					float num2 = Mathf.Clamp(redChannel.Evaluate(num), 0f, 1f);
					float num3 = Mathf.Clamp(greenChannel.Evaluate(num), 0f, 1f);
					float num4 = Mathf.Clamp(blueChannel.Evaluate(num), 0f, 1f);
					rgbChannelTex.SetPixel((int)Mathf.Floor(num * 255f), 0, new Color(num2, num2, num2));
					rgbChannelTex.SetPixel((int)Mathf.Floor(num * 255f), 1, new Color(num3, num3, num3));
					rgbChannelTex.SetPixel((int)Mathf.Floor(num * 255f), 2, new Color(num4, num4, num4));
					float num5 = Mathf.Clamp(zCurve.Evaluate(num), 0f, 1f);
					zCurveTex.SetPixel((int)Mathf.Floor(num * 255f), 0, new Color(num5, num5, num5));
					num2 = Mathf.Clamp(depthRedChannel.Evaluate(num), 0f, 1f);
					num3 = Mathf.Clamp(depthGreenChannel.Evaluate(num), 0f, 1f);
					num4 = Mathf.Clamp(depthBlueChannel.Evaluate(num), 0f, 1f);
					rgbDepthChannelTex.SetPixel((int)Mathf.Floor(num * 255f), 0, new Color(num2, num2, num2));
					rgbDepthChannelTex.SetPixel((int)Mathf.Floor(num * 255f), 1, new Color(num3, num3, num3));
					rgbDepthChannelTex.SetPixel((int)Mathf.Floor(num * 255f), 2, new Color(num4, num4, num4));
				}
				rgbChannelTex.Apply();
				rgbDepthChannelTex.Apply();
				zCurveTex.Apply();
			}
		}

		private void UpdateTextures()
		{
			UpdateParameters();
		}

		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			if (!CheckResources())
			{
				Graphics.Blit(source, destination);
				return;
			}
			if (updateTexturesOnStartup)
			{
				UpdateParameters();
				updateTexturesOnStartup = false;
			}
			if (useDepthCorrection)
			{
				GetComponent<Camera>().depthTextureMode |= DepthTextureMode.Depth;
			}
			RenderTexture renderTexture = destination;
			if (selectiveCc)
			{
				renderTexture = RenderTexture.GetTemporary(source.width, source.height);
			}
			if (useDepthCorrection)
			{
				ccDepthMaterial.SetTexture("_RgbTex", rgbChannelTex);
				ccDepthMaterial.SetTexture("_ZCurve", zCurveTex);
				ccDepthMaterial.SetTexture("_RgbDepthTex", rgbDepthChannelTex);
				ccDepthMaterial.SetFloat("_Saturation", saturation);
				Graphics.Blit(source, renderTexture, ccDepthMaterial);
			}
			else
			{
				ccMaterial.SetTexture("_RgbTex", rgbChannelTex);
				ccMaterial.SetFloat("_Saturation", saturation);
				Graphics.Blit(source, renderTexture, ccMaterial);
			}
			if (selectiveCc)
			{
				selectiveCcMaterial.SetColor("selColor", selectiveFromColor);
				selectiveCcMaterial.SetColor("targetColor", selectiveToColor);
				Graphics.Blit(renderTexture, destination, selectiveCcMaterial);
				RenderTexture.ReleaseTemporary(renderTexture);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Image Effects/Color Adjustments/Color Correction (3D Lookup Texture)")]
	public class ColorCorrectionLookup : PostEffectsBase
	{
		public Shader shader;

		private Material material;

		public Texture3D converted3DLut;

		public string basedOnTempTex = "";

		public override bool CheckResources()
		{
			CheckSupport(needDepth: false);
			material = CheckShaderAndCreateMaterial(shader, material);
			if (!isSupported || !SystemInfo.supports3DTextures)
			{
				ReportAutoDisable();
			}
			return isSupported;
		}

		private void OnDisable()
		{
			if ((bool)material)
			{
				UnityEngine.Object.DestroyImmediate(material);
				material = null;
			}
		}

		private void OnDestroy()
		{
			if ((bool)converted3DLut)
			{
				UnityEngine.Object.DestroyImmediate(converted3DLut);
			}
			converted3DLut = null;
		}

		public void SetIdentityLut()
		{
			int num = 16;
			Color[] array = new Color[num * num * num];
			float num2 = 1f / (1f * (float)num - 1f);
			for (int i = 0; i < num; i++)
			{
				for (int j = 0; j < num; j++)
				{
					for (int k = 0; k < num; k++)
					{
						array[i + j * num + k * num * num] = new Color((float)i * 1f * num2, (float)j * 1f * num2, (float)k * 1f * num2, 1f);
					}
				}
			}
			if ((bool)converted3DLut)
			{
				UnityEngine.Object.DestroyImmediate(converted3DLut);
			}
			converted3DLut = new Texture3D(num, num, num, TextureFormat.ARGB32, mipChain: false);
			converted3DLut.SetPixels(array);
			converted3DLut.Apply();
			basedOnTempTex = "";
		}

		public bool ValidDimensions(Texture2D tex2d)
		{
			if (!tex2d)
			{
				return false;
			}
			if (tex2d.height != Mathf.FloorToInt(Mathf.Sqrt(tex2d.width)))
			{
				return false;
			}
			return true;
		}

		public void Convert(Texture2D temp2DTex, string path)
		{
			if ((bool)temp2DTex)
			{
				int num = temp2DTex.width * temp2DTex.height;
				num = temp2DTex.height;
				if (!ValidDimensions(temp2DTex))
				{
					UnityEngine.Debug.LogWarning("The given 2D texture " + temp2DTex.name + " cannot be used as a 3D LUT.");
					basedOnTempTex = "";
					return;
				}
				Color[] pixels = temp2DTex.GetPixels();
				Color[] array = new Color[pixels.Length];
				for (int i = 0; i < num; i++)
				{
					for (int j = 0; j < num; j++)
					{
						for (int k = 0; k < num; k++)
						{
							int num2 = num - j - 1;
							array[i + j * num + k * num * num] = pixels[k * num + i + num2 * num * num];
						}
					}
				}
				if ((bool)converted3DLut)
				{
					UnityEngine.Object.DestroyImmediate(converted3DLut);
				}
				converted3DLut = new Texture3D(num, num, num, TextureFormat.ARGB32, mipChain: false);
				converted3DLut.SetPixels(array);
				converted3DLut.Apply();
				basedOnTempTex = path;
			}
			else
			{
				UnityEngine.Debug.LogError("Couldn't color correct with 3D LUT texture. Image Effect will be disabled.");
			}
		}

		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			if (!CheckResources() || !SystemInfo.supports3DTextures)
			{
				Graphics.Blit(source, destination);
				return;
			}
			if (converted3DLut == null)
			{
				SetIdentityLut();
			}
			int width = converted3DLut.width;
			converted3DLut.wrapMode = TextureWrapMode.Clamp;
			material.SetFloat("_Scale", (float)(width - 1) / (1f * (float)width));
			material.SetFloat("_Offset", 1f / (2f * (float)width));
			material.SetTexture("_ClutTex", converted3DLut);
			Graphics.Blit(source, destination, material, (QualitySettings.activeColorSpace == ColorSpace.Linear) ? 1 : 0);
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Image Effects/Color Adjustments/Color Correction (Ramp)")]
	public class ColorCorrectionRamp : ImageEffectBase
	{
		public Texture textureRamp;

		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			base.material.SetTexture("_RampTex", textureRamp);
			Graphics.Blit(source, destination, base.material);
		}
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(Camera))]
	[AddComponentMenu("Image Effects/Color Adjustments/Contrast Enhance (Unsharp Mask)")]
	public class ContrastEnhance : PostEffectsBase
	{
		[Range(0f, 1f)]
		public float intensity = 0.5f;

		[Range(0f, 0.999f)]
		public float threshold;

		private Material separableBlurMaterial;

		private Material contrastCompositeMaterial;

		[Range(0f, 1f)]
		public float blurSpread = 1f;

		public Shader separableBlurShader;

		public Shader contrastCompositeShader;

		public override bool CheckResources()
		{
			CheckSupport(needDepth: false);
			contrastCompositeMaterial = CheckShaderAndCreateMaterial(contrastCompositeShader, contrastCompositeMaterial);
			separableBlurMaterial = CheckShaderAndCreateMaterial(separableBlurShader, separableBlurMaterial);
			if (!isSupported)
			{
				ReportAutoDisable();
			}
			return isSupported;
		}

		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			if (!CheckResources())
			{
				Graphics.Blit(source, destination);
				return;
			}
			int width = source.width;
			int height = source.height;
			RenderTexture temporary = RenderTexture.GetTemporary(width / 2, height / 2, 0);
			Graphics.Blit(source, temporary);
			RenderTexture temporary2 = RenderTexture.GetTemporary(width / 4, height / 4, 0);
			Graphics.Blit(temporary, temporary2);
			RenderTexture.ReleaseTemporary(temporary);
			separableBlurMaterial.SetVector("offsets", new Vector4(0f, blurSpread * 1f / (float)temporary2.height, 0f, 0f));
			RenderTexture temporary3 = RenderTexture.GetTemporary(width / 4, height / 4, 0);
			Graphics.Blit(temporary2, temporary3, separableBlurMaterial);
			RenderTexture.ReleaseTemporary(temporary2);
			separableBlurMaterial.SetVector("offsets", new Vector4(blurSpread * 1f / (float)temporary2.width, 0f, 0f, 0f));
			temporary2 = RenderTexture.GetTemporary(width / 4, height / 4, 0);
			Graphics.Blit(temporary3, temporary2, separableBlurMaterial);
			RenderTexture.ReleaseTemporary(temporary3);
			contrastCompositeMaterial.SetTexture("_MainTexBlurred", temporary2);
			contrastCompositeMaterial.SetFloat("intensity", intensity);
			contrastCompositeMaterial.SetFloat("threshold", threshold);
			Graphics.Blit(source, destination, contrastCompositeMaterial);
			RenderTexture.ReleaseTemporary(temporary2);
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Image Effects/Color Adjustments/Contrast Stretch")]
	public class ContrastStretch : MonoBehaviour
	{
		[Range(0.0001f, 1f)]
		public float adaptationSpeed = 0.02f;

		[Range(0f, 1f)]
		public float limitMinimum = 0.2f;

		[Range(0f, 1f)]
		public float limitMaximum = 0.6f;

		private RenderTexture[] adaptRenderTex = new RenderTexture[2];

		private int curAdaptIndex;

		public Shader shaderLum;

		private Material m_materialLum;

		public Shader shaderReduce;

		private Material m_materialReduce;

		public Shader shaderAdapt;

		private Material m_materialAdapt;

		public Shader shaderApply;

		private Material m_materialApply;

		protected Material materialLum
		{
			get
			{
				if (m_materialLum == null)
				{
					m_materialLum = new Material(shaderLum);
					m_materialLum.hideFlags = HideFlags.HideAndDontSave;
				}
				return m_materialLum;
			}
		}

		protected Material materialReduce
		{
			get
			{
				if (m_materialReduce == null)
				{
					m_materialReduce = new Material(shaderReduce);
					m_materialReduce.hideFlags = HideFlags.HideAndDontSave;
				}
				return m_materialReduce;
			}
		}

		protected Material materialAdapt
		{
			get
			{
				if (m_materialAdapt == null)
				{
					m_materialAdapt = new Material(shaderAdapt);
					m_materialAdapt.hideFlags = HideFlags.HideAndDontSave;
				}
				return m_materialAdapt;
			}
		}

		protected Material materialApply
		{
			get
			{
				if (m_materialApply == null)
				{
					m_materialApply = new Material(shaderApply);
					m_materialApply.hideFlags = HideFlags.HideAndDontSave;
				}
				return m_materialApply;
			}
		}

		private void Start()
		{
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
			else if (!shaderAdapt.isSupported || !shaderApply.isSupported || !shaderLum.isSupported || !shaderReduce.isSupported)
			{
				base.enabled = false;
			}
		}

		private void OnEnable()
		{
			for (int i = 0; i < 2; i++)
			{
				if (!adaptRenderTex[i])
				{
					adaptRenderTex[i] = new RenderTexture(1, 1, 0);
					adaptRenderTex[i].hideFlags = HideFlags.HideAndDontSave;
				}
			}
		}

		private void OnDisable()
		{
			for (int i = 0; i < 2; i++)
			{
				UnityEngine.Object.DestroyImmediate(adaptRenderTex[i]);
				adaptRenderTex[i] = null;
			}
			if ((bool)m_materialLum)
			{
				UnityEngine.Object.DestroyImmediate(m_materialLum);
			}
			if ((bool)m_materialReduce)
			{
				UnityEngine.Object.DestroyImmediate(m_materialReduce);
			}
			if ((bool)m_materialAdapt)
			{
				UnityEngine.Object.DestroyImmediate(m_materialAdapt);
			}
			if ((bool)m_materialApply)
			{
				UnityEngine.Object.DestroyImmediate(m_materialApply);
			}
		}

		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			RenderTexture renderTexture = RenderTexture.GetTemporary(source.width / 1, source.height / 1);
			Graphics.Blit(source, renderTexture, materialLum);
			while (renderTexture.width > 1 || renderTexture.height > 1)
			{
				int num = renderTexture.width / 2;
				if (num < 1)
				{
					num = 1;
				}
				int num2 = renderTexture.height / 2;
				if (num2 < 1)
				{
					num2 = 1;
				}
				RenderTexture temporary = RenderTexture.GetTemporary(num, num2);
				Graphics.Blit(renderTexture, temporary, materialReduce);
				RenderTexture.ReleaseTemporary(renderTexture);
				renderTexture = temporary;
			}
			CalculateAdaptation(renderTexture);
			materialApply.SetTexture("_AdaptTex", adaptRenderTex[curAdaptIndex]);
			Graphics.Blit(source, destination, materialApply);
			RenderTexture.ReleaseTemporary(renderTexture);
		}

		private void CalculateAdaptation(Texture curTexture)
		{
			int num = curAdaptIndex;
			curAdaptIndex = (curAdaptIndex + 1) % 2;
			float value = 1f - Mathf.Pow(1f - adaptationSpeed, 30f * Time.deltaTime);
			value = Mathf.Clamp(value, 0.01f, 1f);
			materialAdapt.SetTexture("_CurTex", curTexture);
			materialAdapt.SetVector("_AdaptParams", new Vector4(value, limitMinimum, limitMaximum, 0f));
			Graphics.SetRenderTarget(adaptRenderTex[curAdaptIndex]);
			GL.Clear(clearDepth: false, clearColor: true, Color.black);
			Graphics.Blit(adaptRenderTex[num], adaptRenderTex[curAdaptIndex], materialAdapt);
		}
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(Camera))]
	[AddComponentMenu("Image Effects/Edge Detection/Crease Shading")]
	public class CreaseShading : PostEffectsBase
	{
		public float intensity = 0.5f;

		public int softness = 1;

		public float spread = 1f;

		public Shader blurShader;

		private Material blurMaterial;

		public Shader depthFetchShader;

		private Material depthFetchMaterial;

		public Shader creaseApplyShader;

		private Material creaseApplyMaterial;

		public override bool CheckResources()
		{
			CheckSupport(needDepth: true);
			blurMaterial = CheckShaderAndCreateMaterial(blurShader, blurMaterial);
			depthFetchMaterial = CheckShaderAndCreateMaterial(depthFetchShader, depthFetchMaterial);
			creaseApplyMaterial = CheckShaderAndCreateMaterial(creaseApplyShader, creaseApplyMaterial);
			if (!isSupported)
			{
				ReportAutoDisable();
			}
			return isSupported;
		}

		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			if (!CheckResources())
			{
				Graphics.Blit(source, destination);
				return;
			}
			int width = source.width;
			int height = source.height;
			float num = 1f * (float)width / (1f * (float)height);
			float num2 = 0.001953125f;
			RenderTexture temporary = RenderTexture.GetTemporary(width, height, 0);
			RenderTexture renderTexture = RenderTexture.GetTemporary(width / 2, height / 2, 0);
			Graphics.Blit(source, temporary, depthFetchMaterial);
			Graphics.Blit(temporary, renderTexture);
			for (int i = 0; i < softness; i++)
			{
				RenderTexture temporary2 = RenderTexture.GetTemporary(width / 2, height / 2, 0);
				blurMaterial.SetVector("offsets", new Vector4(0f, spread * num2, 0f, 0f));
				Graphics.Blit(renderTexture, temporary2, blurMaterial);
				RenderTexture.ReleaseTemporary(renderTexture);
				renderTexture = temporary2;
				temporary2 = RenderTexture.GetTemporary(width / 2, height / 2, 0);
				blurMaterial.SetVector("offsets", new Vector4(spread * num2 / num, 0f, 0f, 0f));
				Graphics.Blit(renderTexture, temporary2, blurMaterial);
				RenderTexture.ReleaseTemporary(renderTexture);
				renderTexture = temporary2;
			}
			creaseApplyMaterial.SetTexture("_HrDepthTex", temporary);
			creaseApplyMaterial.SetTexture("_LrDepthTex", renderTexture);
			creaseApplyMaterial.SetFloat("intensity", intensity);
			Graphics.Blit(source, destination, creaseApplyMaterial);
			RenderTexture.ReleaseTemporary(temporary);
			RenderTexture.ReleaseTemporary(renderTexture);
		}
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(Camera))]
	[AddComponentMenu("Image Effects/Camera/Depth of Field (Lens Blur, Scatter, DX11)")]
	public class DepthOfField : PostEffectsBase
	{
		public enum BlurType
		{
			DiscBlur,
			DX11
		}

		public enum BlurSampleCount
		{
			Low,
			Medium,
			High
		}

		public bool visualizeFocus;

		public float focalLength = 10f;

		public float focalSize = 0.05f;

		public float aperture = 0.5f;

		public Transform focalTransform;

		public float maxBlurSize = 2f;

		public bool highResolution;

		public BlurType blurType;

		public BlurSampleCount blurSampleCount = BlurSampleCount.High;

		public bool nearBlur;

		public float foregroundOverlap = 1f;

		public Shader dofHdrShader;

		private Material dofHdrMaterial;

		public Shader dx11BokehShader;

		private Material dx11bokehMaterial;

		public float dx11BokehThreshold = 0.5f;

		public float dx11SpawnHeuristic = 0.0875f;

		public Texture2D dx11BokehTexture;

		public float dx11BokehScale = 1.2f;

		public float dx11BokehIntensity = 2.5f;

		private float focalDistance01 = 10f;

		private ComputeBuffer cbDrawArgs;

		private ComputeBuffer cbPoints;

		private float internalBlurWidth = 1f;

		private Camera cachedCamera;

		public override bool CheckResources()
		{
			CheckSupport(needDepth: true);
			dofHdrMaterial = CheckShaderAndCreateMaterial(dofHdrShader, dofHdrMaterial);
			if (supportDX11 && blurType == BlurType.DX11)
			{
				dx11bokehMaterial = CheckShaderAndCreateMaterial(dx11BokehShader, dx11bokehMaterial);
				CreateComputeResources();
			}
			if (!isSupported)
			{
				ReportAutoDisable();
			}
			return isSupported;
		}

		private void OnEnable()
		{
			cachedCamera = GetComponent<Camera>();
			cachedCamera.depthTextureMode |= DepthTextureMode.Depth;
		}

		private void OnDisable()
		{
			ReleaseComputeResources();
			if ((bool)dofHdrMaterial)
			{
				UnityEngine.Object.DestroyImmediate(dofHdrMaterial);
			}
			dofHdrMaterial = null;
			if ((bool)dx11bokehMaterial)
			{
				UnityEngine.Object.DestroyImmediate(dx11bokehMaterial);
			}
			dx11bokehMaterial = null;
		}

		private void ReleaseComputeResources()
		{
			if (cbDrawArgs != null)
			{
				cbDrawArgs.Release();
			}
			cbDrawArgs = null;
			if (cbPoints != null)
			{
				cbPoints.Release();
			}
			cbPoints = null;
		}

		private void CreateComputeResources()
		{
			if (cbDrawArgs == null)
			{
				cbDrawArgs = new ComputeBuffer(1, 16, ComputeBufferType.DrawIndirect);
				int[] data = new int[4] { 0, 1, 0, 0 };
				cbDrawArgs.SetData(data);
			}
			if (cbPoints == null)
			{
				cbPoints = new ComputeBuffer(90000, 28, ComputeBufferType.Append);
			}
		}

		private float FocalDistance01(float worldDist)
		{
			return cachedCamera.WorldToViewportPoint((worldDist - cachedCamera.nearClipPlane) * cachedCamera.transform.forward + cachedCamera.transform.position).z / (cachedCamera.farClipPlane - cachedCamera.nearClipPlane);
		}

		private void WriteCoc(RenderTexture fromTo, bool fgDilate)
		{
			dofHdrMaterial.SetTexture("_FgOverlap", null);
			if (nearBlur && fgDilate)
			{
				int width = fromTo.width / 2;
				int height = fromTo.height / 2;
				RenderTexture temporary = RenderTexture.GetTemporary(width, height, 0, fromTo.format);
				Graphics.Blit(fromTo, temporary, dofHdrMaterial, 4);
				float num = internalBlurWidth * foregroundOverlap;
				dofHdrMaterial.SetVector("_Offsets", new Vector4(0f, num, 0f, num));
				RenderTexture temporary2 = RenderTexture.GetTemporary(width, height, 0, fromTo.format);
				Graphics.Blit(temporary, temporary2, dofHdrMaterial, 2);
				RenderTexture.ReleaseTemporary(temporary);
				dofHdrMaterial.SetVector("_Offsets", new Vector4(num, 0f, 0f, num));
				temporary = RenderTexture.GetTemporary(width, height, 0, fromTo.format);
				Graphics.Blit(temporary2, temporary, dofHdrMaterial, 2);
				RenderTexture.ReleaseTemporary(temporary2);
				dofHdrMaterial.SetTexture("_FgOverlap", temporary);
				fromTo.MarkRestoreExpected();
				Graphics.Blit(fromTo, fromTo, dofHdrMaterial, 13);
				RenderTexture.ReleaseTemporary(temporary);
			}
			else
			{
				fromTo.MarkRestoreExpected();
				Graphics.Blit(fromTo, fromTo, dofHdrMaterial, 0);
			}
		}

		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			if (!CheckResources())
			{
				Graphics.Blit(source, destination);
				return;
			}
			if (aperture < 0f)
			{
				aperture = 0f;
			}
			if (maxBlurSize < 0.1f)
			{
				maxBlurSize = 0.1f;
			}
			focalSize = Mathf.Clamp(focalSize, 0f, 2f);
			internalBlurWidth = Mathf.Max(maxBlurSize, 0f);
			focalDistance01 = (focalTransform ? (cachedCamera.WorldToViewportPoint(focalTransform.position).z / cachedCamera.farClipPlane) : FocalDistance01(focalLength));
			dofHdrMaterial.SetVector("_CurveParams", new Vector4(1f, focalSize, 1f / (1f - aperture) - 1f, focalDistance01));
			RenderTexture renderTexture = null;
			RenderTexture renderTexture2 = null;
			RenderTexture renderTexture3 = null;
			RenderTexture renderTexture4 = null;
			float num = internalBlurWidth * foregroundOverlap;
			if (visualizeFocus)
			{
				WriteCoc(source, fgDilate: true);
				Graphics.Blit(source, destination, dofHdrMaterial, 16);
			}
			else if (blurType == BlurType.DX11 && (bool)dx11bokehMaterial)
			{
				if (highResolution)
				{
					internalBlurWidth = ((internalBlurWidth < 0.1f) ? 0.1f : internalBlurWidth);
					num = internalBlurWidth * foregroundOverlap;
					renderTexture = RenderTexture.GetTemporary(source.width, source.height, 0, source.format);
					RenderTexture temporary = RenderTexture.GetTemporary(source.width, source.height, 0, source.format);
					WriteCoc(source, fgDilate: false);
					renderTexture3 = RenderTexture.GetTemporary(source.width >> 1, source.height >> 1, 0, source.format);
					renderTexture4 = RenderTexture.GetTemporary(source.width >> 1, source.height >> 1, 0, source.format);
					Graphics.Blit(source, renderTexture3, dofHdrMaterial, 15);
					dofHdrMaterial.SetVector("_Offsets", new Vector4(0f, 1.5f, 0f, 1.5f));
					Graphics.Blit(renderTexture3, renderTexture4, dofHdrMaterial, 19);
					dofHdrMaterial.SetVector("_Offsets", new Vector4(1.5f, 0f, 0f, 1.5f));
					Graphics.Blit(renderTexture4, renderTexture3, dofHdrMaterial, 19);
					if (nearBlur)
					{
						Graphics.Blit(source, renderTexture4, dofHdrMaterial, 4);
					}
					dx11bokehMaterial.SetTexture("_BlurredColor", renderTexture3);
					dx11bokehMaterial.SetFloat("_SpawnHeuristic", dx11SpawnHeuristic);
					dx11bokehMaterial.SetVector("_BokehParams", new Vector4(dx11BokehScale, dx11BokehIntensity, Mathf.Clamp(dx11BokehThreshold, 0.005f, 4f), internalBlurWidth));
					dx11bokehMaterial.SetTexture("_FgCocMask", nearBlur ? renderTexture4 : null);
					Graphics.SetRandomWriteTarget(1, cbPoints);
					Graphics.Blit(source, renderTexture, dx11bokehMaterial, 0);
					Graphics.ClearRandomWriteTargets();
					if (nearBlur)
					{
						dofHdrMaterial.SetVector("_Offsets", new Vector4(0f, num, 0f, num));
						Graphics.Blit(renderTexture4, renderTexture3, dofHdrMaterial, 2);
						dofHdrMaterial.SetVector("_Offsets", new Vector4(num, 0f, 0f, num));
						Graphics.Blit(renderTexture3, renderTexture4, dofHdrMaterial, 2);
						Graphics.Blit(renderTexture4, renderTexture, dofHdrMaterial, 3);
					}
					Graphics.Blit(renderTexture, temporary, dofHdrMaterial, 20);
					dofHdrMaterial.SetVector("_Offsets", new Vector4(internalBlurWidth, 0f, 0f, internalBlurWidth));
					Graphics.Blit(renderTexture, source, dofHdrMaterial, 5);
					dofHdrMaterial.SetVector("_Offsets", new Vector4(0f, internalBlurWidth, 0f, internalBlurWidth));
					Graphics.Blit(source, temporary, dofHdrMaterial, 21);
					Graphics.SetRenderTarget(temporary);
					ComputeBuffer.CopyCount(cbPoints, cbDrawArgs, 0);
					dx11bokehMaterial.SetBuffer("pointBuffer", cbPoints);
					dx11bokehMaterial.SetTexture("_MainTex", dx11BokehTexture);
					dx11bokehMaterial.SetVector("_Screen", new Vector3(1f / (1f * (float)source.width), 1f / (1f * (float)source.height), internalBlurWidth));
					dx11bokehMaterial.SetPass(2);
					Graphics.DrawProceduralIndirectNow(MeshTopology.Points, cbDrawArgs);
					Graphics.Blit(temporary, destination);
					RenderTexture.ReleaseTemporary(temporary);
					RenderTexture.ReleaseTemporary(renderTexture3);
					RenderTexture.ReleaseTemporary(renderTexture4);
				}
				else
				{
					renderTexture = RenderTexture.GetTemporary(source.width >> 1, source.height >> 1, 0, source.format);
					renderTexture2 = RenderTexture.GetTemporary(source.width >> 1, source.height >> 1, 0, source.format);
					num = internalBlurWidth * foregroundOverlap;
					WriteCoc(source, fgDilate: false);
					source.filterMode = FilterMode.Bilinear;
					Graphics.Blit(source, renderTexture, dofHdrMaterial, 6);
					renderTexture3 = RenderTexture.GetTemporary(renderTexture.width >> 1, renderTexture.height >> 1, 0, renderTexture.format);
					renderTexture4 = RenderTexture.GetTemporary(renderTexture.width >> 1, renderTexture.height >> 1, 0, renderTexture.format);
					Graphics.Blit(renderTexture, renderTexture3, dofHdrMaterial, 15);
					dofHdrMaterial.SetVector("_Offsets", new Vector4(0f, 1.5f, 0f, 1.5f));
					Graphics.Blit(renderTexture3, renderTexture4, dofHdrMaterial, 19);
					dofHdrMaterial.SetVector("_Offsets", new Vector4(1.5f, 0f, 0f, 1.5f));
					Graphics.Blit(renderTexture4, renderTexture3, dofHdrMaterial, 19);
					RenderTexture renderTexture5 = null;
					if (nearBlur)
					{
						renderTexture5 = RenderTexture.GetTemporary(source.width >> 1, source.height >> 1, 0, source.format);
						Graphics.Blit(source, renderTexture5, dofHdrMaterial, 4);
					}
					dx11bokehMaterial.SetTexture("_BlurredColor", renderTexture3);
					dx11bokehMaterial.SetFloat("_SpawnHeuristic", dx11SpawnHeuristic);
					dx11bokehMaterial.SetVector("_BokehParams", new Vector4(dx11BokehScale, dx11BokehIntensity, Mathf.Clamp(dx11BokehThreshold, 0.005f, 4f), internalBlurWidth));
					dx11bokehMaterial.SetTexture("_FgCocMask", renderTexture5);
					Graphics.SetRandomWriteTarget(1, cbPoints);
					Graphics.Blit(renderTexture, renderTexture2, dx11bokehMaterial, 0);
					Graphics.ClearRandomWriteTargets();
					RenderTexture.ReleaseTemporary(renderTexture3);
					RenderTexture.ReleaseTemporary(renderTexture4);
					if (nearBlur)
					{
						dofHdrMaterial.SetVector("_Offsets", new Vector4(0f, num, 0f, num));
						Graphics.Blit(renderTexture5, renderTexture, dofHdrMaterial, 2);
						dofHdrMaterial.SetVector("_Offsets", new Vector4(num, 0f, 0f, num));
						Graphics.Blit(renderTexture, renderTexture5, dofHdrMaterial, 2);
						Graphics.Blit(renderTexture5, renderTexture2, dofHdrMaterial, 3);
					}
					dofHdrMaterial.SetVector("_Offsets", new Vector4(internalBlurWidth, 0f, 0f, internalBlurWidth));
					Graphics.Blit(renderTexture2, renderTexture, dofHdrMaterial, 5);
					dofHdrMaterial.SetVector("_Offsets", new Vector4(0f, internalBlurWidth, 0f, internalBlurWidth));
					Graphics.Blit(renderTexture, renderTexture2, dofHdrMaterial, 5);
					Graphics.SetRenderTarget(renderTexture2);
					ComputeBuffer.CopyCount(cbPoints, cbDrawArgs, 0);
					dx11bokehMaterial.SetBuffer("pointBuffer", cbPoints);
					dx11bokehMaterial.SetTexture("_MainTex", dx11BokehTexture);
					dx11bokehMaterial.SetVector("_Screen", new Vector3(1f / (1f * (float)renderTexture2.width), 1f / (1f * (float)renderTexture2.height), internalBlurWidth));
					dx11bokehMaterial.SetPass(1);
					Graphics.DrawProceduralIndirectNow(MeshTopology.Points, cbDrawArgs);
					dofHdrMaterial.SetTexture("_LowRez", renderTexture2);
					dofHdrMaterial.SetTexture("_FgOverlap", renderTexture5);
					dofHdrMaterial.SetVector("_Offsets", 1f * (float)source.width / (1f * (float)renderTexture2.width) * internalBlurWidth * Vector4.one);
					Graphics.Blit(source, destination, dofHdrMaterial, 9);
					if ((bool)renderTexture5)
					{
						RenderTexture.ReleaseTemporary(renderTexture5);
					}
				}
			}
			else
			{
				source.filterMode = FilterMode.Bilinear;
				if (highResolution)
				{
					internalBlurWidth *= 2f;
				}
				WriteCoc(source, fgDilate: true);
				renderTexture = RenderTexture.GetTemporary(source.width >> 1, source.height >> 1, 0, source.format);
				renderTexture2 = RenderTexture.GetTemporary(source.width >> 1, source.height >> 1, 0, source.format);
				int pass = ((blurSampleCount == BlurSampleCount.High || blurSampleCount == BlurSampleCount.Medium) ? 17 : 11);
				if (highResolution)
				{
					dofHdrMaterial.SetVector("_Offsets", new Vector4(0f, internalBlurWidth, 0.025f, internalBlurWidth));
					Graphics.Blit(source, destination, dofHdrMaterial, pass);
				}
				else
				{
					dofHdrMaterial.SetVector("_Offsets", new Vector4(0f, internalBlurWidth, 0.1f, internalBlurWidth));
					Graphics.Blit(source, renderTexture, dofHdrMaterial, 6);
					Graphics.Blit(renderTexture, renderTexture2, dofHdrMaterial, pass);
					dofHdrMaterial.SetTexture("_LowRez", renderTexture2);
					dofHdrMaterial.SetTexture("_FgOverlap", null);
					dofHdrMaterial.SetVector("_Offsets", Vector4.one * (1f * (float)source.width / (1f * (float)renderTexture2.width)) * internalBlurWidth);
					Graphics.Blit(source, destination, dofHdrMaterial, (blurSampleCount == BlurSampleCount.High) ? 18 : 12);
				}
			}
			if ((bool)renderTexture)
			{
				RenderTexture.ReleaseTemporary(renderTexture);
			}
			if ((bool)renderTexture2)
			{
				RenderTexture.ReleaseTemporary(renderTexture2);
			}
		}
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(Camera))]
	[AddComponentMenu("Image Effects/Camera/Depth of Field (deprecated)")]
	public class DepthOfFieldDeprecated : PostEffectsBase
	{
		public enum Dof34QualitySetting
		{
			OnlyBackground = 1,
			BackgroundAndForeground
		}

		public enum DofResolution
		{
			High = 2,
			Medium,
			Low
		}

		public enum DofBlurriness
		{
			Low = 1,
			High = 2,
			VeryHigh = 4
		}

		public enum BokehDestination
		{
			Background = 1,
			Foreground,
			BackgroundAndForeground
		}

		private static int SMOOTH_DOWNSAMPLE_PASS = 6;

		private static float BOKEH_EXTRA_BLUR = 2f;

		public Dof34QualitySetting quality = Dof34QualitySetting.OnlyBackground;

		public DofResolution resolution = DofResolution.Low;

		public bool simpleTweakMode = true;

		public float focalPoint = 1f;

		public float smoothness = 0.5f;

		public float focalZDistance;

		public float focalZStartCurve = 1f;

		public float focalZEndCurve = 1f;

		private float focalStartCurve = 2f;

		private float focalEndCurve = 2f;

		private float focalDistance01 = 0.1f;

		public Transform objectFocus;

		public float focalSize;

		public DofBlurriness bluriness = DofBlurriness.High;

		public float maxBlurSpread = 1.75f;

		public float foregroundBlurExtrude = 1.15f;

		public Shader dofBlurShader;

		private Material dofBlurMaterial;

		public Shader dofShader;

		private Material dofMaterial;

		public bool visualize;

		public BokehDestination bokehDestination = BokehDestination.Background;

		private float widthOverHeight = 1.25f;

		private float oneOverBaseSize = 0.001953125f;

		public bool bokeh;

		public bool bokehSupport = true;

		public Shader bokehShader;

		public Texture2D bokehTexture;

		public float bokehScale = 2.4f;

		public float bokehIntensity = 0.15f;

		public float bokehThresholdContrast = 0.1f;

		public float bokehThresholdLuminance = 0.55f;

		public int bokehDownsample = 1;

		private Material bokehMaterial;

		private Camera _camera;

		private RenderTexture foregroundTexture;

		private RenderTexture mediumRezWorkTexture;

		private RenderTexture finalDefocus;

		private RenderTexture lowRezWorkTexture;

		private RenderTexture bokehSource;

		private RenderTexture bokehSource2;

		private void CreateMaterials()
		{
			dofBlurMaterial = CheckShaderAndCreateMaterial(dofBlurShader, dofBlurMaterial);
			dofMaterial = CheckShaderAndCreateMaterial(dofShader, dofMaterial);
			bokehSupport = bokehShader.isSupported;
			if (bokeh && bokehSupport && (bool)bokehShader)
			{
				bokehMaterial = CheckShaderAndCreateMaterial(bokehShader, bokehMaterial);
			}
		}

		public override bool CheckResources()
		{
			CheckSupport(needDepth: true);
			dofBlurMaterial = CheckShaderAndCreateMaterial(dofBlurShader, dofBlurMaterial);
			dofMaterial = CheckShaderAndCreateMaterial(dofShader, dofMaterial);
			bokehSupport = bokehShader.isSupported;
			if (bokeh && bokehSupport && (bool)bokehShader)
			{
				bokehMaterial = CheckShaderAndCreateMaterial(bokehShader, bokehMaterial);
			}
			if (!isSupported)
			{
				ReportAutoDisable();
			}
			return isSupported;
		}

		private void OnDisable()
		{
			Quads.Cleanup();
		}

		private void OnEnable()
		{
			_camera = GetComponent<Camera>();
			_camera.depthTextureMode |= DepthTextureMode.Depth;
		}

		private float FocalDistance01(float worldDist)
		{
			return _camera.WorldToViewportPoint((worldDist - _camera.nearClipPlane) * _camera.transform.forward + _camera.transform.position).z / (_camera.farClipPlane - _camera.nearClipPlane);
		}

		private int GetDividerBasedOnQuality()
		{
			int result = 1;
			if (resolution == DofResolution.Medium)
			{
				result = 2;
			}
			else if (resolution == DofResolution.Low)
			{
				result = 2;
			}
			return result;
		}

		private int GetLowResolutionDividerBasedOnQuality(int baseDivider)
		{
			int num = baseDivider;
			if (resolution == DofResolution.High)
			{
				num *= 2;
			}
			if (resolution == DofResolution.Low)
			{
				num *= 2;
			}
			return num;
		}

		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			if (!CheckResources())
			{
				Graphics.Blit(source, destination);
				return;
			}
			if (smoothness < 0.1f)
			{
				smoothness = 0.1f;
			}
			bokeh = bokeh && bokehSupport;
			float num = (bokeh ? BOKEH_EXTRA_BLUR : 1f);
			bool flag = quality > Dof34QualitySetting.OnlyBackground;
			float num2 = focalSize / (_camera.farClipPlane - _camera.nearClipPlane);
			if (simpleTweakMode)
			{
				focalDistance01 = (objectFocus ? (_camera.WorldToViewportPoint(objectFocus.position).z / _camera.farClipPlane) : FocalDistance01(focalPoint));
				focalStartCurve = focalDistance01 * smoothness;
				focalEndCurve = focalStartCurve;
				flag = flag && focalPoint > _camera.nearClipPlane + Mathf.Epsilon;
			}
			else
			{
				if ((bool)objectFocus)
				{
					Vector3 vector = _camera.WorldToViewportPoint(objectFocus.position);
					vector.z /= _camera.farClipPlane;
					focalDistance01 = vector.z;
				}
				else
				{
					focalDistance01 = FocalDistance01(focalZDistance);
				}
				focalStartCurve = focalZStartCurve;
				focalEndCurve = focalZEndCurve;
				flag = flag && focalPoint > _camera.nearClipPlane + Mathf.Epsilon;
			}
			widthOverHeight = 1f * (float)source.width / (1f * (float)source.height);
			oneOverBaseSize = 0.001953125f;
			dofMaterial.SetFloat("_ForegroundBlurExtrude", foregroundBlurExtrude);
			dofMaterial.SetVector("_CurveParams", new Vector4(simpleTweakMode ? (1f / focalStartCurve) : focalStartCurve, simpleTweakMode ? (1f / focalEndCurve) : focalEndCurve, num2 * 0.5f, focalDistance01));
			dofMaterial.SetVector("_InvRenderTargetSize", new Vector4(1f / (1f * (float)source.width), 1f / (1f * (float)source.height), 0f, 0f));
			int dividerBasedOnQuality = GetDividerBasedOnQuality();
			int lowResolutionDividerBasedOnQuality = GetLowResolutionDividerBasedOnQuality(dividerBasedOnQuality);
			AllocateTextures(flag, source, dividerBasedOnQuality, lowResolutionDividerBasedOnQuality);
			Graphics.Blit(source, source, dofMaterial, 3);
			Downsample(source, mediumRezWorkTexture);
			Blur(mediumRezWorkTexture, mediumRezWorkTexture, DofBlurriness.Low, 4, maxBlurSpread);
			if (bokeh && (BokehDestination.Foreground & bokehDestination) != 0)
			{
				dofMaterial.SetVector("_Threshhold", new Vector4(bokehThresholdContrast, bokehThresholdLuminance, 0.95f, 0f));
				Graphics.Blit(mediumRezWorkTexture, bokehSource2, dofMaterial, 11);
				Graphics.Blit(mediumRezWorkTexture, lowRezWorkTexture);
				Blur(lowRezWorkTexture, lowRezWorkTexture, bluriness, 0, maxBlurSpread * num);
			}
			else
			{
				Downsample(mediumRezWorkTexture, lowRezWorkTexture);
				Blur(lowRezWorkTexture, lowRezWorkTexture, bluriness, 0, maxBlurSpread);
			}
			dofBlurMaterial.SetTexture("_TapLow", lowRezWorkTexture);
			dofBlurMaterial.SetTexture("_TapMedium", mediumRezWorkTexture);
			Graphics.Blit(null, finalDefocus, dofBlurMaterial, 3);
			if (bokeh && (BokehDestination.Foreground & bokehDestination) != 0)
			{
				AddBokeh(bokehSource2, bokehSource, finalDefocus);
			}
			dofMaterial.SetTexture("_TapLowBackground", finalDefocus);
			dofMaterial.SetTexture("_TapMedium", mediumRezWorkTexture);
			Graphics.Blit(source, flag ? foregroundTexture : destination, dofMaterial, visualize ? 2 : 0);
			if (flag)
			{
				Graphics.Blit(foregroundTexture, source, dofMaterial, 5);
				Downsample(source, mediumRezWorkTexture);
				BlurFg(mediumRezWorkTexture, mediumRezWorkTexture, DofBlurriness.Low, 2, maxBlurSpread);
				if (bokeh && (BokehDestination.Foreground & bokehDestination) != 0)
				{
					dofMaterial.SetVector("_Threshhold", new Vector4(bokehThresholdContrast * 0.5f, bokehThresholdLuminance, 0f, 0f));
					Graphics.Blit(mediumRezWorkTexture, bokehSource2, dofMaterial, 11);
					Graphics.Blit(mediumRezWorkTexture, lowRezWorkTexture);
					BlurFg(lowRezWorkTexture, lowRezWorkTexture, bluriness, 1, maxBlurSpread * num);
				}
				else
				{
					BlurFg(mediumRezWorkTexture, lowRezWorkTexture, bluriness, 1, maxBlurSpread);
				}
				Graphics.Blit(lowRezWorkTexture, finalDefocus);
				dofMaterial.SetTexture("_TapLowForeground", finalDefocus);
				Graphics.Blit(source, destination, dofMaterial, visualize ? 1 : 4);
				if (bokeh && (BokehDestination.Foreground & bokehDestination) != 0)
				{
					AddBokeh(bokehSource2, bokehSource, destination);
				}
			}
			ReleaseTextures();
		}

		private void Blur(RenderTexture from, RenderTexture to, DofBlurriness iterations, int blurPass, float spread)
		{
			RenderTexture temporary = RenderTexture.GetTemporary(to.width, to.height);
			if (iterations > DofBlurriness.Low)
			{
				BlurHex(from, to, blurPass, spread, temporary);
				if (iterations > DofBlurriness.High)
				{
					dofBlurMaterial.SetVector("offsets", new Vector4(0f, spread * oneOverBaseSize, 0f, 0f));
					Graphics.Blit(to, temporary, dofBlurMaterial, blurPass);
					dofBlurMaterial.SetVector("offsets", new Vector4(spread / widthOverHeight * oneOverBaseSize, 0f, 0f, 0f));
					Graphics.Blit(temporary, to, dofBlurMaterial, blurPass);
				}
			}
			else
			{
				dofBlurMaterial.SetVector("offsets", new Vector4(0f, spread * oneOverBaseSize, 0f, 0f));
				Graphics.Blit(from, temporary, dofBlurMaterial, blurPass);
				dofBlurMaterial.SetVector("offsets", new Vector4(spread / widthOverHeight * oneOverBaseSize, 0f, 0f, 0f));
				Graphics.Blit(temporary, to, dofBlurMaterial, blurPass);
			}
			RenderTexture.ReleaseTemporary(temporary);
		}

		private void BlurFg(RenderTexture from, RenderTexture to, DofBlurriness iterations, int blurPass, float spread)
		{
			dofBlurMaterial.SetTexture("_TapHigh", from);
			RenderTexture temporary = RenderTexture.GetTemporary(to.width, to.height);
			if (iterations > DofBlurriness.Low)
			{
				BlurHex(from, to, blurPass, spread, temporary);
				if (iterations > DofBlurriness.High)
				{
					dofBlurMaterial.SetVector("offsets", new Vector4(0f, spread * oneOverBaseSize, 0f, 0f));
					Graphics.Blit(to, temporary, dofBlurMaterial, blurPass);
					dofBlurMaterial.SetVector("offsets", new Vector4(spread / widthOverHeight * oneOverBaseSize, 0f, 0f, 0f));
					Graphics.Blit(temporary, to, dofBlurMaterial, blurPass);
				}
			}
			else
			{
				dofBlurMaterial.SetVector("offsets", new Vector4(0f, spread * oneOverBaseSize, 0f, 0f));
				Graphics.Blit(from, temporary, dofBlurMaterial, blurPass);
				dofBlurMaterial.SetVector("offsets", new Vector4(spread / widthOverHeight * oneOverBaseSize, 0f, 0f, 0f));
				Graphics.Blit(temporary, to, dofBlurMaterial, blurPass);
			}
			RenderTexture.ReleaseTemporary(temporary);
		}

		private void BlurHex(RenderTexture from, RenderTexture to, int blurPass, float spread, RenderTexture tmp)
		{
			dofBlurMaterial.SetVector("offsets", new Vector4(0f, spread * oneOverBaseSize, 0f, 0f));
			Graphics.Blit(from, tmp, dofBlurMaterial, blurPass);
			dofBlurMaterial.SetVector("offsets", new Vector4(spread / widthOverHeight * oneOverBaseSize, 0f, 0f, 0f));
			Graphics.Blit(tmp, to, dofBlurMaterial, blurPass);
			dofBlurMaterial.SetVector("offsets", new Vector4(spread / widthOverHeight * oneOverBaseSize, spread * oneOverBaseSize, 0f, 0f));
			Graphics.Blit(to, tmp, dofBlurMaterial, blurPass);
			dofBlurMaterial.SetVector("offsets", new Vector4(spread / widthOverHeight * oneOverBaseSize, (0f - spread) * oneOverBaseSize, 0f, 0f));
			Graphics.Blit(tmp, to, dofBlurMaterial, blurPass);
		}

		private void Downsample(RenderTexture from, RenderTexture to)
		{
			dofMaterial.SetVector("_InvRenderTargetSize", new Vector4(1f / (1f * (float)to.width), 1f / (1f * (float)to.height), 0f, 0f));
			Graphics.Blit(from, to, dofMaterial, SMOOTH_DOWNSAMPLE_PASS);
		}

		private void AddBokeh(RenderTexture bokehInfo, RenderTexture tempTex, RenderTexture finalTarget)
		{
			if (!bokehMaterial)
			{
				return;
			}
			Mesh[] meshes = Quads.GetMeshes(tempTex.width, tempTex.height);
			RenderTexture.active = tempTex;
			GL.Clear(clearDepth: false, clearColor: true, new Color(0f, 0f, 0f, 0f));
			GL.PushMatrix();
			GL.LoadIdentity();
			bokehInfo.filterMode = FilterMode.Point;
			float num = (float)bokehInfo.width * 1f / ((float)bokehInfo.height * 1f);
			float num2 = 2f / (1f * (float)bokehInfo.width);
			num2 += bokehScale * maxBlurSpread * BOKEH_EXTRA_BLUR * oneOverBaseSize;
			bokehMaterial.SetTexture("_Source", bokehInfo);
			bokehMaterial.SetTexture("_MainTex", bokehTexture);
			bokehMaterial.SetVector("_ArScale", new Vector4(num2, num2 * num, 0.5f, 0.5f * num));
			bokehMaterial.SetFloat("_Intensity", bokehIntensity);
			bokehMaterial.SetPass(0);
			Mesh[] array = meshes;
			foreach (Mesh mesh in array)
			{
				if ((bool)mesh)
				{
					Graphics.DrawMeshNow(mesh, Matrix4x4.identity);
				}
			}
			GL.PopMatrix();
			Graphics.Blit(tempTex, finalTarget, dofMaterial, 8);
			bokehInfo.filterMode = FilterMode.Bilinear;
		}

		private void ReleaseTextures()
		{
			if ((bool)foregroundTexture)
			{
				RenderTexture.ReleaseTemporary(foregroundTexture);
			}
			if ((bool)finalDefocus)
			{
				RenderTexture.ReleaseTemporary(finalDefocus);
			}
			if ((bool)mediumRezWorkTexture)
			{
				RenderTexture.ReleaseTemporary(mediumRezWorkTexture);
			}
			if ((bool)lowRezWorkTexture)
			{
				RenderTexture.ReleaseTemporary(lowRezWorkTexture);
			}
			if ((bool)bokehSource)
			{
				RenderTexture.ReleaseTemporary(bokehSource);
			}
			if ((bool)bokehSource2)
			{
				RenderTexture.ReleaseTemporary(bokehSource2);
			}
		}

		private void AllocateTextures(bool blurForeground, RenderTexture source, int divider, int lowTexDivider)
		{
			foregroundTexture = null;
			if (blurForeground)
			{
				foregroundTexture = RenderTexture.GetTemporary(source.width, source.height, 0);
			}
			mediumRezWorkTexture = RenderTexture.GetTemporary(source.width / divider, source.height / divider, 0);
			finalDefocus = RenderTexture.GetTemporary(source.width / divider, source.height / divider, 0);
			lowRezWorkTexture = RenderTexture.GetTemporary(source.width / lowTexDivider, source.height / lowTexDivider, 0);
			bokehSource = null;
			bokehSource2 = null;
			if (bokeh)
			{
				bokehSource = RenderTexture.GetTemporary(source.width / (lowTexDivider * bokehDownsample), source.height / (lowTexDivider * bokehDownsample), 0, RenderTextureFormat.ARGBHalf);
				bokehSource2 = RenderTexture.GetTemporary(source.width / (lowTexDivider * bokehDownsample), source.height / (lowTexDivider * bokehDownsample), 0, RenderTextureFormat.ARGBHalf);
				bokehSource.filterMode = FilterMode.Bilinear;
				bokehSource2.filterMode = FilterMode.Bilinear;
				RenderTexture.active = bokehSource2;
				GL.Clear(clearDepth: false, clearColor: true, new Color(0f, 0f, 0f, 0f));
			}
			source.filterMode = FilterMode.Bilinear;
			finalDefocus.filterMode = FilterMode.Bilinear;
			mediumRezWorkTexture.filterMode = FilterMode.Bilinear;
			lowRezWorkTexture.filterMode = FilterMode.Bilinear;
			if ((bool)foregroundTexture)
			{
				foregroundTexture.filterMode = FilterMode.Bilinear;
			}
		}
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(Camera))]
	[AddComponentMenu("Image Effects/Edge Detection/Edge Detection")]
	public class EdgeDetection : PostEffectsBase
	{
		public enum EdgeDetectMode
		{
			TriangleDepthNormals,
			RobertsCrossDepthNormals,
			SobelDepth,
			SobelDepthThin,
			TriangleLuminance
		}

		public EdgeDetectMode mode = EdgeDetectMode.SobelDepthThin;

		public float sensitivityDepth = 1f;

		public float sensitivityNormals = 1f;

		public float lumThreshold = 0.2f;

		public float edgeExp = 1f;

		public float sampleDist = 1f;

		public float edgesOnly;

		public Color edgesOnlyBgColor = Color.white;

		public Shader edgeDetectShader;

		private Material edgeDetectMaterial;

		private EdgeDetectMode oldMode = EdgeDetectMode.SobelDepthThin;

		public override bool CheckResources()
		{
			CheckSupport(needDepth: true);
			edgeDetectMaterial = CheckShaderAndCreateMaterial(edgeDetectShader, edgeDetectMaterial);
			if (mode != oldMode)
			{
				SetCameraFlag();
			}
			oldMode = mode;
			if (!isSupported)
			{
				ReportAutoDisable();
			}
			return isSupported;
		}

		private new void Start()
		{
			oldMode = mode;
		}

		private void SetCameraFlag()
		{
			if (mode == EdgeDetectMode.SobelDepth || mode == EdgeDetectMode.SobelDepthThin)
			{
				GetComponent<Camera>().depthTextureMode |= DepthTextureMode.Depth;
			}
			else if (mode == EdgeDetectMode.TriangleDepthNormals || mode == EdgeDetectMode.RobertsCrossDepthNormals)
			{
				GetComponent<Camera>().depthTextureMode |= DepthTextureMode.DepthNormals;
			}
		}

		private void OnEnable()
		{
			SetCameraFlag();
		}

		[ImageEffectOpaque]
		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			if (!CheckResources())
			{
				Graphics.Blit(source, destination);
				return;
			}
			Vector2 vector = new Vector2(sensitivityDepth, sensitivityNormals);
			edgeDetectMaterial.SetVector("_Sensitivity", new Vector4(vector.x, vector.y, 1f, vector.y));
			edgeDetectMaterial.SetFloat("_BgFade", edgesOnly);
			edgeDetectMaterial.SetFloat("_SampleDistance", sampleDist);
			edgeDetectMaterial.SetVector("_BgColor", edgesOnlyBgColor);
			edgeDetectMaterial.SetFloat("_Exponent", edgeExp);
			edgeDetectMaterial.SetFloat("_Threshold", lumThreshold);
			Graphics.Blit(source, destination, edgeDetectMaterial, (int)mode);
		}
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(Camera))]
	[AddComponentMenu("Image Effects/Displacement/Fisheye")]
	public class Fisheye : PostEffectsBase
	{
		[Range(0f, 1.5f)]
		public float strengthX = 0.05f;

		[Range(0f, 1.5f)]
		public float strengthY = 0.05f;

		public Shader fishEyeShader;

		private Material fisheyeMaterial;

		public override bool CheckResources()
		{
			CheckSupport(needDepth: false);
			fisheyeMaterial = CheckShaderAndCreateMaterial(fishEyeShader, fisheyeMaterial);
			if (!isSupported)
			{
				ReportAutoDisable();
			}
			return isSupported;
		}

		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			if (!CheckResources())
			{
				Graphics.Blit(source, destination);
				return;
			}
			float num = 5f / 32f;
			float num2 = (float)source.width * 1f / ((float)source.height * 1f);
			fisheyeMaterial.SetVector("intensity", new Vector4(strengthX * num2 * num, strengthY * num, strengthX * num2 * num, strengthY * num));
			Graphics.Blit(source, destination, fisheyeMaterial);
		}
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(Camera))]
	[AddComponentMenu("Image Effects/Rendering/Global Fog")]
	internal class GlobalFog : PostEffectsBase
	{
		[Tooltip("Apply distance-based fog?")]
		public bool distanceFog = true;

		[Tooltip("Exclude far plane pixels from distance-based fog? (Skybox or clear color)")]
		public bool excludeFarPixels = true;

		[Tooltip("Distance fog is based on radial distance from camera when checked")]
		public bool useRadialDistance;

		[Tooltip("Apply height-based fog?")]
		public bool heightFog = true;

		[Tooltip("Fog top Y coordinate")]
		public float height = 1f;

		[Range(0.001f, 10f)]
		public float heightDensity = 2f;

		[Tooltip("Push fog away from the camera by this amount")]
		public float startDistance;

		public Shader fogShader;

		private Material fogMaterial;

		public override bool CheckResources()
		{
			CheckSupport(needDepth: true);
			fogMaterial = CheckShaderAndCreateMaterial(fogShader, fogMaterial);
			if (!isSupported)
			{
				ReportAutoDisable();
			}
			return isSupported;
		}

		[ImageEffectOpaque]
		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			if (!CheckResources() || (!distanceFog && !heightFog))
			{
				Graphics.Blit(source, destination);
				return;
			}
			Camera component = GetComponent<Camera>();
			Transform obj = component.transform;
			Vector3[] array = new Vector3[4];
			component.CalculateFrustumCorners(new Rect(0f, 0f, 1f, 1f), component.farClipPlane, component.stereoActiveEye, array);
			Vector3 vector = obj.TransformVector(array[0]);
			Vector3 vector2 = obj.TransformVector(array[1]);
			Vector3 vector3 = obj.TransformVector(array[2]);
			Vector3 vector4 = obj.TransformVector(array[3]);
			Matrix4x4 identity = Matrix4x4.identity;
			identity.SetRow(0, vector);
			identity.SetRow(1, vector4);
			identity.SetRow(2, vector2);
			identity.SetRow(3, vector3);
			Vector3 position = obj.position;
			float num = position.y - height;
			float z = ((num <= 0f) ? 1f : 0f);
			float y = (excludeFarPixels ? 1f : 2f);
			fogMaterial.SetMatrix("_FrustumCornersWS", identity);
			fogMaterial.SetVector("_CameraWS", position);
			fogMaterial.SetVector("_HeightParams", new Vector4(height, num, z, heightDensity * 0.5f));
			fogMaterial.SetVector("_DistanceParams", new Vector4(0f - Mathf.Max(startDistance, 0f), y, 0f, 0f));
			FogMode fogMode = RenderSettings.fogMode;
			float fogDensity = RenderSettings.fogDensity;
			float fogStartDistance = RenderSettings.fogStartDistance;
			float fogEndDistance = RenderSettings.fogEndDistance;
			bool flag = fogMode == FogMode.Linear;
			float num2 = (flag ? (fogEndDistance - fogStartDistance) : 0f);
			float num3 = ((Mathf.Abs(num2) > 0.0001f) ? (1f / num2) : 0f);
			Vector4 value = default(Vector4);
			value.x = fogDensity * 1.2011224f;
			value.y = fogDensity * 1.442695f;
			value.z = (flag ? (0f - num3) : 0f);
			value.w = (flag ? (fogEndDistance * num3) : 0f);
			fogMaterial.SetVector("_SceneFogParams", value);
			fogMaterial.SetVector("_SceneFogMode", new Vector4((float)fogMode, useRadialDistance ? 1 : 0, 0f, 0f));
			int num4 = 0;
			Graphics.Blit(pass: (!distanceFog || !heightFog) ? (distanceFog ? 1 : 2) : 0, source: source, dest: destination, mat: fogMaterial);
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Image Effects/Color Adjustments/Grayscale")]
	public class Grayscale : ImageEffectBase
	{
		public Texture textureRamp;

		[Range(-1f, 1f)]
		public float rampOffset;

		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			base.material.SetTexture("_RampTex", textureRamp);
			base.material.SetFloat("_RampOffset", rampOffset);
			Graphics.Blit(source, destination, base.material);
		}
	}
	[RequireComponent(typeof(Camera))]
	[AddComponentMenu("")]
	public class ImageEffectBase : MonoBehaviour
	{
		public Shader shader;

		private Material m_Material;

		protected Material material
		{
			get
			{
				if (m_Material == null)
				{
					m_Material = new Material(shader);
					m_Material.hideFlags = HideFlags.HideAndDontSave;
				}
				return m_Material;
			}
		}

		protected virtual void Start()
		{
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
			else if (!shader || !shader.isSupported)
			{
				base.enabled = false;
			}
		}

		protected virtual void OnDisable()
		{
			if ((bool)m_Material)
			{
				UnityEngine.Object.DestroyImmediate(m_Material);
			}
		}
	}
	[AddComponentMenu("")]
	public class ImageEffects
	{
		public static void RenderDistortion(Material material, RenderTexture source, RenderTexture destination, float angle, Vector2 center, Vector2 radius)
		{
			if (source.texelSize.y < 0f)
			{
				center.y = 1f - center.y;
				angle = 0f - angle;
			}
			Matrix4x4 value = Matrix4x4.TRS(Vector3.zero, Quaternion.Euler(0f, 0f, angle), Vector3.one);
			material.SetMatrix("_RotationMatrix", value);
			material.SetVector("_CenterRadius", new Vector4(center.x, center.y, radius.x, radius.y));
			material.SetFloat("_Angle", angle * ((float)Math.PI / 180f));
			Graphics.Blit(source, destination, material);
		}

		[Obsolete("Use Graphics.Blit(source,dest) instead")]
		public static void Blit(RenderTexture source, RenderTexture dest)
		{
			Graphics.Blit(source, dest);
		}

		[Obsolete("Use Graphics.Blit(source, destination, material) instead")]
		public static void BlitWithMaterial(Material material, RenderTexture source, RenderTexture dest)
		{
			Graphics.Blit(source, dest, material);
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Image Effects/Blur/Motion Blur (Color Accumulation)")]
	[RequireComponent(typeof(Camera))]
	public class MotionBlur : ImageEffectBase
	{
		[Range(0f, 0.92f)]
		public float blurAmount = 0.8f;

		public bool extraBlur;

		private RenderTexture accumTexture;

		protected override void Start()
		{
			base.Start();
		}

		protected override void OnDisable()
		{
			base.OnDisable();
			UnityEngine.Object.DestroyImmediate(accumTexture);
		}

		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			if (accumTexture == null || accumTexture.width != source.width || accumTexture.height != source.height)
			{
				UnityEngine.Object.DestroyImmediate(accumTexture);
				accumTexture = new RenderTexture(source.width, source.height, 0);
				accumTexture.hideFlags = HideFlags.HideAndDontSave;
				Graphics.Blit(source, accumTexture);
			}
			if (extraBlur)
			{
				RenderTexture temporary = RenderTexture.GetTemporary(source.width / 4, source.height / 4, 0);
				accumTexture.MarkRestoreExpected();
				Graphics.Blit(accumTexture, temporary);
				Graphics.Blit(temporary, accumTexture);
				RenderTexture.ReleaseTemporary(temporary);
			}
			blurAmount = Mathf.Clamp(blurAmount, 0f, 0.92f);
			base.material.SetTexture("_MainTex", accumTexture);
			base.material.SetFloat("_AccumOrig", 1f - blurAmount);
			accumTexture.MarkRestoreExpected();
			Graphics.Blit(source, accumTexture, base.material);
			Graphics.Blit(accumTexture, destination);
		}
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(Camera))]
	[AddComponentMenu("Image Effects/Noise/Noise And Grain (Filmic)")]
	public class NoiseAndGrain : PostEffectsBase
	{
		public float intensityMultiplier = 0.25f;

		public float generalIntensity = 0.5f;

		public float blackIntensity = 1f;

		public float whiteIntensity = 1f;

		public float midGrey = 0.2f;

		public bool dx11Grain;

		public float softness;

		public bool monochrome;

		public Vector3 intensities = new Vector3(1f, 1f, 1f);

		public Vector3 tiling = new Vector3(64f, 64f, 64f);

		public float monochromeTiling = 64f;

		public FilterMode filterMode = FilterMode.Bilinear;

		public Texture2D noiseTexture;

		public Shader noiseShader;

		private Material noiseMaterial;

		public Shader dx11NoiseShader;

		private Material dx11NoiseMaterial;

		private static float TILE_AMOUNT = 64f;

		public override bool CheckResources()
		{
			CheckSupport(needDepth: false);
			noiseMaterial = CheckShaderAndCreateMaterial(noiseShader, noiseMaterial);
			if (dx11Grain && supportDX11)
			{
				dx11NoiseMaterial = CheckShaderAndCreateMaterial(dx11NoiseShader, dx11NoiseMaterial);
			}
			if (!isSupported)
			{
				ReportAutoDisable();
			}
			return isSupported;
		}

		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			if (!CheckResources() || null == noiseTexture)
			{
				Graphics.Blit(source, destination);
				if (null == noiseTexture)
				{
					UnityEngine.Debug.LogWarning("Noise & Grain effect failing as noise texture is not assigned. please assign.", base.transform);
				}
				return;
			}
			softness = Mathf.Clamp(softness, 0f, 0.99f);
			if (dx11Grain && supportDX11)
			{
				dx11NoiseMaterial.SetFloat("_DX11NoiseTime", Time.frameCount);
				dx11NoiseMaterial.SetTexture("_NoiseTex", noiseTexture);
				dx11NoiseMaterial.SetVector("_NoisePerChannel", monochrome ? Vector3.one : intensities);
				dx11NoiseMaterial.SetVector("_MidGrey", new Vector3(midGrey, 1f / (1f - midGrey), -1f / midGrey));
				dx11NoiseMaterial.SetVector("_NoiseAmount", new Vector3(generalIntensity, blackIntensity, whiteIntensity) * intensityMultiplier);
				if (softness > Mathf.Epsilon)
				{
					RenderTexture temporary = RenderTexture.GetTemporary((int)((float)source.width * (1f - softness)), (int)((float)source.height * (1f - softness)));
					DrawNoiseQuadGrid(source, temporary, dx11NoiseMaterial, noiseTexture, monochrome ? 3 : 2);
					dx11NoiseMaterial.SetTexture("_NoiseTex", temporary);
					Graphics.Blit(source, destination, dx11NoiseMaterial, 4);
					RenderTexture.ReleaseTemporary(temporary);
				}
				else
				{
					DrawNoiseQuadGrid(source, destination, dx11NoiseMaterial, noiseTexture, monochrome ? 1 : 0);
				}
				return;
			}
			if ((bool)noiseTexture)
			{
				noiseTexture.wrapMode = TextureWrapMode.Repeat;
				noiseTexture.filterMode = filterMode;
			}
			noiseMaterial.SetTexture("_NoiseTex", noiseTexture);
			noiseMaterial.SetVector("_NoisePerChannel", monochrome ? Vector3.one : intensities);
			noiseMaterial.SetVector("_NoiseTilingPerChannel", monochrome ? (Vector3.one * monochromeTiling) : tiling);
			noiseMaterial.SetVector("_MidGrey", new Vector3(midGrey, 1f / (1f - midGrey), -1f / midGrey));
			noiseMaterial.SetVector("_NoiseAmount", new Vector3(generalIntensity, blackIntensity, whiteIntensity) * intensityMultiplier);
			if (softness > Mathf.Epsilon)
			{
				RenderTexture temporary2 = RenderTexture.GetTemporary((int)((float)source.width * (1f - softness)), (int)((float)source.height * (1f - softness)));
				DrawNoiseQuadGrid(source, temporary2, noiseMaterial, noiseTexture, 2);
				noiseMaterial.SetTexture("_NoiseTex", temporary2);
				Graphics.Blit(source, destination, noiseMaterial, 1);
				RenderTexture.ReleaseTemporary(temporary2);
			}
			else
			{
				DrawNoiseQuadGrid(source, destination, noiseMaterial, noiseTexture, 0);
			}
		}

		private static void DrawNoiseQuadGrid(RenderTexture source, RenderTexture dest, Material fxMaterial, Texture2D noise, int passNr)
		{
			RenderTexture.active = dest;
			float num = (float)noise.width * 1f;
			float num2 = 1f * (float)source.width / TILE_AMOUNT;
			fxMaterial.SetTexture("_MainTex", source);
			GL.PushMatrix();
			GL.LoadOrtho();
			float num3 = 1f * (float)source.width / (1f * (float)source.height);
			float num4 = 1f / num2;
			float num5 = num4 * num3;
			float num6 = num / ((float)noise.width * 1f);
			fxMaterial.SetPass(passNr);
			GL.Begin(7);
			for (float num7 = 0f; num7 < 1f; num7 += num4)
			{
				for (float num8 = 0f; num8 < 1f; num8 += num5)
				{
					float num9 = UnityEngine.Random.Range(0f, 1f);
					float num10 = UnityEngine.Random.Range(0f, 1f);
					num9 = Mathf.Floor(num9 * num) / num;
					num10 = Mathf.Floor(num10 * num) / num;
					float num11 = 1f / num;
					GL.MultiTexCoord2(0, num9, num10);
					GL.MultiTexCoord2(1, 0f, 0f);
					GL.Vertex3(num7, num8, 0.1f);
					GL.MultiTexCoord2(0, num9 + num6 * num11, num10);
					GL.MultiTexCoord2(1, 1f, 0f);
					GL.Vertex3(num7 + num4, num8, 0.1f);
					GL.MultiTexCoord2(0, num9 + num6 * num11, num10 + num6 * num11);
					GL.MultiTexCoord2(1, 1f, 1f);
					GL.Vertex3(num7 + num4, num8 + num5, 0.1f);
					GL.MultiTexCoord2(0, num9, num10 + num6 * num11);
					GL.MultiTexCoord2(1, 0f, 1f);
					GL.Vertex3(num7, num8 + num5, 0.1f);
				}
			}
			GL.End();
			GL.PopMatrix();
		}
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(Camera))]
	[AddComponentMenu("Image Effects/Noise/Noise and Scratches")]
	public class NoiseAndScratches : MonoBehaviour
	{
		public bool monochrome = true;

		private bool rgbFallback;

		[Range(0f, 5f)]
		public float grainIntensityMin = 0.1f;

		[Range(0f, 5f)]
		public float grainIntensityMax = 0.2f;

		[Range(0.1f, 50f)]
		public float grainSize = 2f;

		[Range(0f, 5f)]
		public float scratchIntensityMin = 0.05f;

		[Range(0f, 5f)]
		public float scratchIntensityMax = 0.25f;

		[Range(1f, 30f)]
		public float scratchFPS = 10f;

		[Range(0f, 1f)]
		public float scratchJitter = 0.01f;

		public Texture grainTexture;

		public Texture scratchTexture;

		public Shader shaderRGB;

		public Shader shaderYUV;

		private Material m_MaterialRGB;

		private Material m_MaterialYUV;

		private float scratchTimeLeft;

		private float scratchX;

		private float scratchY;

		protected Material material
		{
			get
			{
				if (m_MaterialRGB == null)
				{
					m_MaterialRGB = new Material(shaderRGB);
					m_MaterialRGB.hideFlags = HideFlags.HideAndDontSave;
				}
				if (m_MaterialYUV == null && !rgbFallback)
				{
					m_MaterialYUV = new Material(shaderYUV);
					m_MaterialYUV.hideFlags = HideFlags.HideAndDontSave;
				}
				if (rgbFallback || monochrome)
				{
					return m_MaterialRGB;
				}
				return m_MaterialYUV;
			}
		}

		protected void Start()
		{
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
			else if (shaderRGB == null || shaderYUV == null)
			{
				UnityEngine.Debug.Log("Noise shaders are not set up! Disabling noise effect.");
				base.enabled = false;
			}
			else if (!shaderRGB.isSupported)
			{
				base.enabled = false;
			}
			else if (!shaderYUV.isSupported)
			{
				rgbFallback = true;
			}
		}

		protected void OnDisable()
		{
			if ((bool)m_MaterialRGB)
			{
				UnityEngine.Object.DestroyImmediate(m_MaterialRGB);
			}
			if ((bool)m_MaterialYUV)
			{
				UnityEngine.Object.DestroyImmediate(m_MaterialYUV);
			}
		}

		private void SanitizeParameters()
		{
			grainIntensityMin = Mathf.Clamp(grainIntensityMin, 0f, 5f);
			grainIntensityMax = Mathf.Clamp(grainIntensityMax, 0f, 5f);
			scratchIntensityMin = Mathf.Clamp(scratchIntensityMin, 0f, 5f);
			scratchIntensityMax = Mathf.Clamp(scratchIntensityMax, 0f, 5f);
			scratchFPS = Mathf.Clamp(scratchFPS, 1f, 30f);
			scratchJitter = Mathf.Clamp(scratchJitter, 0f, 1f);
			grainSize = Mathf.Clamp(grainSize, 0.1f, 50f);
		}

		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			SanitizeParameters();
			if (scratchTimeLeft <= 0f)
			{
				scratchTimeLeft = UnityEngine.Random.value * 2f / scratchFPS;
				scratchX = UnityEngine.Random.value;
				scratchY = UnityEngine.Random.value;
			}
			scratchTimeLeft -= Time.deltaTime;
			Material material = this.material;
			material.SetTexture("_GrainTex", grainTexture);
			material.SetTexture("_ScratchTex", scratchTexture);
			float num = 1f / grainSize;
			material.SetVector("_GrainOffsetScale", new Vector4(UnityEngine.Random.value, UnityEngine.Random.value, (float)Screen.width / (float)grainTexture.width * num, (float)Screen.height / (float)grainTexture.height * num));
			material.SetVector("_ScratchOffsetScale", new Vector4(scratchX + UnityEngine.Random.value * scratchJitter, scratchY + UnityEngine.Random.value * scratchJitter, (float)Screen.width / (float)scratchTexture.width, (float)Screen.height / (float)scratchTexture.height));
			material.SetVector("_Intensity", new Vector4(UnityEngine.Random.Range(grainIntensityMin, grainIntensityMax), UnityEngine.Random.Range(scratchIntensityMin, scratchIntensityMax), 0f, 0f));
			Graphics.Blit(source, destination, material);
		}
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(Camera))]
	public class PostEffectsBase : MonoBehaviour
	{
		protected bool supportHDRTextures = true;

		protected bool supportDX11;

		protected bool isSupported = true;

		private List<Material> createdMaterials = new List<Material>();

		protected Material CheckShaderAndCreateMaterial(Shader s, Material m2Create)
		{
			if (!s)
			{
				UnityEngine.Debug.Log("Missing shader in " + ToString());
				base.enabled = false;
				return null;
			}
			if (s.isSupported && (bool)m2Create && m2Create.shader == s)
			{
				return m2Create;
			}
			if (!s.isSupported)
			{
				NotSupported();
				UnityEngine.Debug.Log("The shader " + s.ToString() + " on effect " + ToString() + " is not supported on this platform!");
				return null;
			}
			m2Create = new Material(s);
			createdMaterials.Add(m2Create);
			m2Create.hideFlags = HideFlags.DontSave;
			return m2Create;
		}

		protected Material CreateMaterial(Shader s, Material m2Create)
		{
			if (!s)
			{
				UnityEngine.Debug.Log("Missing shader in " + ToString());
				return null;
			}
			if ((bool)m2Create && m2Create.shader == s && s.isSupported)
			{
				return m2Create;
			}
			if (!s.isSupported)
			{
				return null;
			}
			m2Create = new Material(s);
			createdMaterials.Add(m2Create);
			m2Create.hideFlags = HideFlags.DontSave;
			return m2Create;
		}

		private void OnEnable()
		{
			isSupported = true;
		}

		private void OnDestroy()
		{
			RemoveCreatedMaterials();
		}

		private void RemoveCreatedMaterials()
		{
			while (createdMaterials.Count > 0)
			{
				Material obj = createdMaterials[0];
				createdMaterials.RemoveAt(0);
				UnityEngine.Object.Destroy(obj);
			}
		}

		protected bool CheckSupport()
		{
			return CheckSupport(needDepth: false);
		}

		public virtual bool CheckResources()
		{
			UnityEngine.Debug.LogWarning("CheckResources () for " + ToString() + " should be overwritten.");
			return isSupported;
		}

		protected void Start()
		{
			CheckResources();
		}

		protected bool CheckSupport(bool needDepth)
		{
			isSupported = true;
			supportHDRTextures = SystemInfo.SupportsRenderTextureFormat(RenderTextureFormat.ARGBHalf);
			supportDX11 = SystemInfo.graphicsShaderLevel >= 50 && SystemInfo.supportsComputeShaders;
			if (!SystemInfo.supportsImageEffects)
			{
				NotSupported();
				return false;
			}
			if (needDepth && !SystemInfo.SupportsRenderTextureFormat(RenderTextureFormat.Depth))
			{
				NotSupported();
				return false;
			}
			if (needDepth)
			{
				GetComponent<Camera>().depthTextureMode |= DepthTextureMode.Depth;
			}
			return true;
		}

		protected bool CheckSupport(bool needDepth, bool needHdr)
		{
			if (!CheckSupport(needDepth))
			{
				return false;
			}
			if (needHdr && !supportHDRTextures)
			{
				NotSupported();
				return false;
			}
			return true;
		}

		public bool Dx11Support()
		{
			return supportDX11;
		}

		protected void ReportAutoDisable()
		{
			UnityEngine.Debug.LogWarning("The image effect " + ToString() + " has been disabled as it's not supported on the current platform.");
		}

		private bool CheckShader(Shader s)
		{
			UnityEngine.Debug.Log("The shader " + s.ToString() + " on effect " + ToString() + " is not part of the Unity 3.2+ effects suite anymore. For best performance and quality, please ensure you are using the latest Standard Assets Image Effects (Pro only) package.");
			if (!s.isSupported)
			{
				NotSupported();
				return false;
			}
			return false;
		}

		protected void NotSupported()
		{
			base.enabled = false;
			isSupported = false;
		}

		protected void DrawBorder(RenderTexture dest, Material material)
		{
			RenderTexture.active = dest;
			bool flag = true;
			GL.PushMatrix();
			GL.LoadOrtho();
			for (int i = 0; i < material.passCount; i++)
			{
				material.SetPass(i);
				float y;
				float y2;
				if (flag)
				{
					y = 1f;
					y2 = 0f;
				}
				else
				{
					y = 0f;
					y2 = 1f;
				}
				float x = 0f + 1f / ((float)dest.width * 1f);
				float y3 = 0f;
				float y4 = 1f;
				GL.Begin(7);
				GL.TexCoord2(0f, y);
				GL.Vertex3(0f, y3, 0.1f);
				GL.TexCoord2(1f, y);
				GL.Vertex3(x, y3, 0.1f);
				GL.TexCoord2(1f, y2);
				GL.Vertex3(x, y4, 0.1f);
				GL.TexCoord2(0f, y2);
				GL.Vertex3(0f, y4, 0.1f);
				float x2 = 1f - 1f / ((float)dest.width * 1f);
				x = 1f;
				y3 = 0f;
				y4 = 1f;
				GL.TexCoord2(0f, y);
				GL.Vertex3(x2, y3, 0.1f);
				GL.TexCoord2(1f, y);
				GL.Vertex3(x, y3, 0.1f);
				GL.TexCoord2(1f, y2);
				GL.Vertex3(x, y4, 0.1f);
				GL.TexCoord2(0f, y2);
				GL.Vertex3(x2, y4, 0.1f);
				x = 1f;
				y3 = 0f;
				y4 = 0f + 1f / ((float)dest.height * 1f);
				GL.TexCoord2(0f, y);
				GL.Vertex3(0f, y3, 0.1f);
				GL.TexCoord2(1f, y);
				GL.Vertex3(x, y3, 0.1f);
				GL.TexCoord2(1f, y2);
				GL.Vertex3(x, y4, 0.1f);
				GL.TexCoord2(0f, y2);
				GL.Vertex3(0f, y4, 0.1f);
				x = 1f;
				y3 = 1f - 1f / ((float)dest.height * 1f);
				y4 = 1f;
				GL.TexCoord2(0f, y);
				GL.Vertex3(0f, y3, 0.1f);
				GL.TexCoord2(1f, y);
				GL.Vertex3(x, y3, 0.1f);
				GL.TexCoord2(1f, y2);
				GL.Vertex3(x, y4, 0.1f);
				GL.TexCoord2(0f, y2);
				GL.Vertex3(0f, y4, 0.1f);
				GL.End();
			}
			GL.PopMatrix();
		}
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(Camera))]
	internal class PostEffectsHelper : MonoBehaviour
	{
		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			UnityEngine.Debug.Log("OnRenderImage in Helper called ...");
		}

		private static void DrawLowLevelPlaneAlignedWithCamera(float dist, RenderTexture source, RenderTexture dest, Material material, Camera cameraForProjectionMatrix)
		{
			RenderTexture.active = dest;
			material.SetTexture("_MainTex", source);
			bool flag = true;
			GL.PushMatrix();
			GL.LoadIdentity();
			GL.LoadProjectionMatrix(cameraForProjectionMatrix.projectionMatrix);
			float f = cameraForProjectionMatrix.fieldOfView * 0.5f * ((float)Math.PI / 180f);
			float num = Mathf.Cos(f) / Mathf.Sin(f);
			float aspect = cameraForProjectionMatrix.aspect;
			float num2 = aspect / (0f - num);
			float num3 = aspect / num;
			float num4 = 1f / (0f - num);
			float num5 = 1f / num;
			float num6 = 1f;
			num2 *= dist * num6;
			num3 *= dist * num6;
			num4 *= dist * num6;
			num5 *= dist * num6;
			float z = 0f - dist;
			for (int i = 0; i < material.passCount; i++)
			{
				material.SetPass(i);
				GL.Begin(7);
				float y;
				float y2;
				if (flag)
				{
					y = 1f;
					y2 = 0f;
				}
				else
				{
					y = 0f;
					y2 = 1f;
				}
				GL.TexCoord2(0f, y);
				GL.Vertex3(num2, num4, z);
				GL.TexCoord2(1f, y);
				GL.Vertex3(num3, num4, z);
				GL.TexCoord2(1f, y2);
				GL.Vertex3(num3, num5, z);
				GL.TexCoord2(0f, y2);
				GL.Vertex3(num2, num5, z);
				GL.End();
			}
			GL.PopMatrix();
		}

		private static void DrawBorder(RenderTexture dest, Material material)
		{
			RenderTexture.active = dest;
			bool flag = true;
			GL.PushMatrix();
			GL.LoadOrtho();
			for (int i = 0; i < material.passCount; i++)
			{
				material.SetPass(i);
				float y;
				float y2;
				if (flag)
				{
					y = 1f;
					y2 = 0f;
				}
				else
				{
					y = 0f;
					y2 = 1f;
				}
				float x = 0f + 1f / ((float)dest.width * 1f);
				float y3 = 0f;
				float y4 = 1f;
				GL.Begin(7);
				GL.TexCoord2(0f, y);
				GL.Vertex3(0f, y3, 0.1f);
				GL.TexCoord2(1f, y);
				GL.Vertex3(x, y3, 0.1f);
				GL.TexCoord2(1f, y2);
				GL.Vertex3(x, y4, 0.1f);
				GL.TexCoord2(0f, y2);
				GL.Vertex3(0f, y4, 0.1f);
				float x2 = 1f - 1f / ((float)dest.width * 1f);
				x = 1f;
				y3 = 0f;
				y4 = 1f;
				GL.TexCoord2(0f, y);
				GL.Vertex3(x2, y3, 0.1f);
				GL.TexCoord2(1f, y);
				GL.Vertex3(x, y3, 0.1f);
				GL.TexCoord2(1f, y2);
				GL.Vertex3(x, y4, 0.1f);
				GL.TexCoord2(0f, y2);
				GL.Vertex3(x2, y4, 0.1f);
				x = 1f;
				y3 = 0f;
				y4 = 0f + 1f / ((float)dest.height * 1f);
				GL.TexCoord2(0f, y);
				GL.Vertex3(0f, y3, 0.1f);
				GL.TexCoord2(1f, y);
				GL.Vertex3(x, y3, 0.1f);
				GL.TexCoord2(1f, y2);
				GL.Vertex3(x, y4, 0.1f);
				GL.TexCoord2(0f, y2);
				GL.Vertex3(0f, y4, 0.1f);
				x = 1f;
				y3 = 1f - 1f / ((float)dest.height * 1f);
				y4 = 1f;
				GL.TexCoord2(0f, y);
				GL.Vertex3(0f, y3, 0.1f);
				GL.TexCoord2(1f, y);
				GL.Vertex3(x, y3, 0.1f);
				GL.TexCoord2(1f, y2);
				GL.Vertex3(x, y4, 0.1f);
				GL.TexCoord2(0f, y2);
				GL.Vertex3(0f, y4, 0.1f);
				GL.End();
			}
			GL.PopMatrix();
		}

		private static void DrawLowLevelQuad(float x1, float x2, float y1, float y2, RenderTexture source, RenderTexture dest, Material material)
		{
			RenderTexture.active = dest;
			material.SetTexture("_MainTex", source);
			bool flag = true;
			GL.PushMatrix();
			GL.LoadOrtho();
			for (int i = 0; i < material.passCount; i++)
			{
				material.SetPass(i);
				GL.Begin(7);
				float y3;
				float y4;
				if (flag)
				{
					y3 = 1f;
					y4 = 0f;
				}
				else
				{
					y3 = 0f;
					y4 = 1f;
				}
				GL.TexCoord2(0f, y3);
				GL.Vertex3(x1, y1, 0.1f);
				GL.TexCoord2(1f, y3);
				GL.Vertex3(x2, y1, 0.1f);
				GL.TexCoord2(1f, y4);
				GL.Vertex3(x2, y2, 0.1f);
				GL.TexCoord2(0f, y4);
				GL.Vertex3(x1, y2, 0.1f);
				GL.End();
			}
			GL.PopMatrix();
		}
	}
	internal class Quads
	{
		private static Mesh[] meshes;

		private static int currentQuads;

		private static bool HasMeshes()
		{
			if (meshes == null)
			{
				return false;
			}
			Mesh[] array = meshes;
			foreach (Mesh mesh in array)
			{
				if (null == mesh)
				{
					return false;
				}
			}
			return true;
		}

		public static void Cleanup()
		{
			if (meshes == null)
			{
				return;
			}
			for (int i = 0; i < meshes.Length; i++)
			{
				if (null != meshes[i])
				{
					UnityEngine.Object.DestroyImmediate(meshes[i]);
					meshes[i] = null;
				}
			}
			meshes = null;
		}

		public static Mesh[] GetMeshes(int totalWidth, int totalHeight)
		{
			if (HasMeshes() && currentQuads == totalWidth * totalHeight)
			{
				return meshes;
			}
			int num = 10833;
			int num2 = (currentQuads = totalWidth * totalHeight);
			meshes = new Mesh[Mathf.CeilToInt(1f * (float)num2 / (1f * (float)num))];
			int num3 = 0;
			int num4 = 0;
			for (num3 = 0; num3 < num2; num3 += num)
			{
				int triCount = Mathf.FloorToInt(Mathf.Clamp(num2 - num3, 0, num));
				meshes[num4] = GetMesh(triCount, num3, totalWidth, totalHeight);
				num4++;
			}
			return meshes;
		}

		private static Mesh GetMesh(int triCount, int triOffset, int totalWidth, int totalHeight)
		{
			Mesh mesh = new Mesh();
			mesh.hideFlags = HideFlags.DontSave;
			Vector3[] array = new Vector3[triCount * 4];
			Vector2[] array2 = new Vector2[triCount * 4];
			Vector2[] array3 = new Vector2[triCount * 4];
			int[] array4 = new int[triCount * 6];
			for (int i = 0; i < triCount; i++)
			{
				int num = i * 4;
				int num2 = i * 6;
				int num3 = triOffset + i;
				float num4 = Mathf.Floor(num3 % totalWidth) / (float)totalWidth;
				float num5 = Mathf.Floor(num3 / totalWidth) / (float)totalHeight;
				array[num + 3] = (array[num + 2] = (array[num + 1] = (array[num] = new Vector3(num4 * 2f - 1f, num5 * 2f - 1f, 1f))));
				array2[num] = new Vector2(0f, 0f);
				array2[num + 1] = new Vector2(1f, 0f);
				array2[num + 2] = new Vector2(0f, 1f);
				array2[num + 3] = new Vector2(1f, 1f);
				array3[num] = new Vector2(num4, num5);
				array3[num + 1] = new Vector2(num4, num5);
				array3[num + 2] = new Vector2(num4, num5);
				array3[num + 3] = new Vector2(num4, num5);
				array4[num2] = num;
				array4[num2 + 1] = num + 1;
				array4[num2 + 2] = num + 2;
				array4[num2 + 3] = num + 1;
				array4[num2 + 4] = num + 2;
				array4[num2 + 5] = num + 3;
			}
			mesh.vertices = array;
			mesh.triangles = array4;
			mesh.uv = array2;
			mesh.uv2 = array3;
			return mesh;
		}
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(Camera))]
	[AddComponentMenu("Image Effects/Other/Screen Overlay")]
	public class ScreenOverlay : PostEffectsBase
	{
		public enum OverlayBlendMode
		{
			Additive,
			ScreenBlend,
			Multiply,
			Overlay,
			AlphaBlend
		}

		public OverlayBlendMode blendMode = OverlayBlendMode.Overlay;

		public float intensity = 1f;

		public Texture2D texture;

		public Shader overlayShader;

		private Material overlayMaterial;

		public override bool CheckResources()
		{
			CheckSupport(needDepth: false);
			overlayMaterial = CheckShaderAndCreateMaterial(overlayShader, overlayMaterial);
			if (!isSupported)
			{
				ReportAutoDisable();
			}
			return isSupported;
		}

		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			if (!CheckResources())
			{
				Graphics.Blit(source, destination);
				return;
			}
			Vector4 value = new Vector4(1f, 0f, 0f, 1f);
			overlayMaterial.SetVector("_UV_Transform", value);
			overlayMaterial.SetFloat("_Intensity", intensity);
			overlayMaterial.SetTexture("_Overlay", texture);
			Graphics.Blit(source, destination, overlayMaterial, (int)blendMode);
		}
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(Camera))]
	[AddComponentMenu("Image Effects/Rendering/Screen Space Ambient Obscurance")]
	internal class ScreenSpaceAmbientObscurance : PostEffectsBase
	{
		[Range(0f, 3f)]
		public float intensity = 0.5f;

		[Range(0.1f, 3f)]
		public float radius = 0.2f;

		[Range(0f, 3f)]
		public int blurIterations = 1;

		[Range(0f, 5f)]
		public float blurFilterDistance = 1.25f;

		[Range(0f, 1f)]
		public int downsample;

		public Texture2D rand;

		public Shader aoShader;

		private Material aoMaterial;

		public override bool CheckResources()
		{
			CheckSupport(needDepth: true);
			aoMaterial = CheckShaderAndCreateMaterial(aoShader, aoMaterial);
			if (!isSupported)
			{
				ReportAutoDisable();
			}
			return isSupported;
		}

		private void OnDisable()
		{
			if ((bool)aoMaterial)
			{
				UnityEngine.Object.DestroyImmediate(aoMaterial);
			}
			aoMaterial = null;
		}

		[ImageEffectOpaque]
		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			if (!CheckResources())
			{
				Graphics.Blit(source, destination);
				return;
			}
			Camera component = GetComponent<Camera>();
			Matrix4x4 projectionMatrix = component.projectionMatrix;
			Matrix4x4 inverse = projectionMatrix.inverse;
			Vector4 value = new Vector4(-2f / projectionMatrix[0, 0], -2f / projectionMatrix[1, 1], (1f - projectionMatrix[0, 2]) / projectionMatrix[0, 0], (1f + projectionMatrix[1, 2]) / projectionMatrix[1, 1]);
			if (component.stereoEnabled)
			{
				Matrix4x4 stereoProjectionMatrix = component.GetStereoProjectionMatrix(Camera.StereoscopicEye.Left);
				Matrix4x4 stereoProjectionMatrix2 = component.GetStereoProjectionMatrix(Camera.StereoscopicEye.Right);
				Vector4 value2 = new Vector4(-2f / stereoProjectionMatrix[0, 0], -2f / stereoProjectionMatrix[1, 1], (1f - stereoProjectionMatrix[0, 2]) / stereoProjectionMatrix[0, 0], (1f + stereoProjectionMatrix[1, 2]) / stereoProjectionMatrix[1, 1]);
				Vector4 value3 = new Vector4(-2f / stereoProjectionMatrix2[0, 0], -2f / stereoProjectionMatrix2[1, 1], (1f - stereoProjectionMatrix2[0, 2]) / stereoProjectionMatrix2[0, 0], (1f + stereoProjectionMatrix2[1, 2]) / stereoProjectionMatrix2[1, 1]);
				aoMaterial.SetVector("_ProjInfoLeft", value2);
				aoMaterial.SetVector("_ProjInfoRight", value3);
			}
			aoMaterial.SetVector("_ProjInfo", value);
			aoMaterial.SetMatrix("_ProjectionInv", inverse);
			aoMaterial.SetTexture("_Rand", rand);
			aoMaterial.SetFloat("_Radius", radius);
			aoMaterial.SetFloat("_Radius2", radius * radius);
			aoMaterial.SetFloat("_Intensity", intensity);
			aoMaterial.SetFloat("_BlurFilterDistance", blurFilterDistance);
			int width = source.width;
			int height = source.height;
			RenderTexture renderTexture = RenderTexture.GetTemporary(width >> downsample, height >> downsample);
			Graphics.Blit(source, renderTexture, aoMaterial, 0);
			if (downsample > 0)
			{
				RenderTexture temporary = RenderTexture.GetTemporary(width, height);
				Graphics.Blit(renderTexture, temporary, aoMaterial, 4);
				RenderTexture.ReleaseTemporary(renderTexture);
				renderTexture = temporary;
			}
			for (int i = 0; i < blurIterations; i++)
			{
				aoMaterial.SetVector("_Axis", new Vector2(1f, 0f));
				RenderTexture temporary = RenderTexture.GetTemporary(width, height);
				Graphics.Blit(renderTexture, temporary, aoMaterial, 1);
				RenderTexture.ReleaseTemporary(renderTexture);
				aoMaterial.SetVector("_Axis", new Vector2(0f, 1f));
				renderTexture = RenderTexture.GetTemporary(width, height);
				Graphics.Blit(temporary, renderTexture, aoMaterial, 1);
				RenderTexture.ReleaseTemporary(temporary);
			}
			aoMaterial.SetTexture("_AOTex", renderTexture);
			Graphics.Blit(source, destination, aoMaterial, 2);
			RenderTexture.ReleaseTemporary(renderTexture);
		}
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(Camera))]
	[AddComponentMenu("Image Effects/Rendering/Screen Space Ambient Occlusion")]
	public class ScreenSpaceAmbientOcclusion : MonoBehaviour
	{
		public enum SSAOSamples
		{
			Low,
			Medium,
			High
		}

		[Range(0.05f, 1f)]
		public float m_Radius = 0.4f;

		public SSAOSamples m_SampleCount = SSAOSamples.Medium;

		[Range(0.5f, 4f)]
		public float m_OcclusionIntensity = 1.5f;

		[Range(0f, 4f)]
		public int m_Blur = 2;

		[Range(1f, 6f)]
		public int m_Downsampling = 2;

		[Range(0.2f, 2f)]
		public float m_OcclusionAttenuation = 1f;

		[Range(1E-05f, 0.5f)]
		public float m_MinZ = 0.01f;

		public Shader m_SSAOShader;

		private Material m_SSAOMaterial;

		public Texture2D m_RandomTexture;

		private bool m_Supported;

		private static Material CreateMaterial(Shader shader)
		{
			if (!shader)
			{
				return null;
			}
			return new Material(shader)
			{
				hideFlags = HideFlags.HideAndDontSave
			};
		}

		private static void DestroyMaterial(Material mat)
		{
			if ((bool)mat)
			{
				UnityEngine.Object.DestroyImmediate(mat);
				mat = null;
			}
		}

		private void OnDisable()
		{
			DestroyMaterial(m_SSAOMaterial);
		}

		private void Start()
		{
			if (!SystemInfo.supportsImageEffects || !SystemInfo.SupportsRenderTextureFormat(RenderTextureFormat.Depth))
			{
				m_Supported = false;
				base.enabled = false;
				return;
			}
			CreateMaterials();
			if (!m_SSAOMaterial || m_SSAOMaterial.passCount != 5)
			{
				m_Supported = false;
				base.enabled = false;
			}
			else
			{
				m_Supported = true;
			}
		}

		private void OnEnable()
		{
			GetComponent<Camera>().depthTextureMode |= DepthTextureMode.DepthNormals;
		}

		private void CreateMaterials()
		{
			if (!m_SSAOMaterial && m_SSAOShader.isSupported)
			{
				m_SSAOMaterial = CreateMaterial(m_SSAOShader);
				m_SSAOMaterial.SetTexture("_RandomTexture", m_RandomTexture);
			}
		}

		[ImageEffectOpaque]
		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			if (!m_Supported || !m_SSAOShader.isSupported)
			{
				base.enabled = false;
				return;
			}
			CreateMaterials();
			m_Downsampling = Mathf.Clamp(m_Downsampling, 1, 6);
			m_Radius = Mathf.Clamp(m_Radius, 0.05f, 1f);
			m_MinZ = Mathf.Clamp(m_MinZ, 1E-05f, 0.5f);
			m_OcclusionIntensity = Mathf.Clamp(m_OcclusionIntensity, 0.5f, 4f);
			m_OcclusionAttenuation = Mathf.Clamp(m_OcclusionAttenuation, 0.2f, 2f);
			m_Blur = Mathf.Clamp(m_Blur, 0, 4);
			RenderTexture renderTexture = RenderTexture.GetTemporary(source.width / m_Downsampling, source.height / m_Downsampling, 0);
			float fieldOfView = GetComponent<Camera>().fieldOfView;
			float farClipPlane = GetComponent<Camera>().farClipPlane;
			float num = Mathf.Tan(fieldOfView * ((float)Math.PI / 180f) * 0.5f) * farClipPlane;
			float x = num * GetComponent<Camera>().aspect;
			m_SSAOMaterial.SetVector("_FarCorner", new Vector3(x, num, farClipPlane));
			int num2;
			int num3;
			if ((bool)m_RandomTexture)
			{
				num2 = m_RandomTexture.width;
				num3 = m_RandomTexture.height;
			}
			else
			{
				num2 = 1;
				num3 = 1;
			}
			m_SSAOMaterial.SetVector("_NoiseScale", new Vector3((float)renderTexture.width / (float)num2, (float)renderTexture.height / (float)num3, 0f));
			m_SSAOMaterial.SetVector("_Params", new Vector4(m_Radius, m_MinZ, 1f / m_OcclusionAttenuation, m_OcclusionIntensity));
			bool num4 = m_Blur > 0;
			Graphics.Blit(num4 ? null : source, renderTexture, m_SSAOMaterial, (int)m_SampleCount);
			if (num4)
			{
				RenderTexture temporary = RenderTexture.GetTemporary(source.width, source.height, 0);
				m_SSAOMaterial.SetVector("_TexelOffsetScale", new Vector4((float)m_Blur / (float)source.width, 0f, 0f, 0f));
				m_SSAOMaterial.SetTexture("_SSAO", renderTexture);
				Graphics.Blit(null, temporary, m_SSAOMaterial, 3);
				RenderTexture.ReleaseTemporary(renderTexture);
				RenderTexture temporary2 = RenderTexture.GetTemporary(source.width, source.height, 0);
				m_SSAOMaterial.SetVector("_TexelOffsetScale", new Vector4(0f, (float)m_Blur / (float)source.height, 0f, 0f));
				m_SSAOMaterial.SetTexture("_SSAO", temporary);
				Graphics.Blit(source, temporary2, m_SSAOMaterial, 3);
				RenderTexture.ReleaseTemporary(temporary);
				renderTexture = temporary2;
			}
			m_SSAOMaterial.SetTexture("_SSAO", renderTexture);
			Graphics.Blit(source, destination, m_SSAOMaterial, 4);
			RenderTexture.ReleaseTemporary(renderTexture);
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Image Effects/Color Adjustments/Sepia Tone")]
	public class SepiaTone : ImageEffectBase
	{
		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			Graphics.Blit(source, destination, base.material);
		}
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(Camera))]
	[AddComponentMenu("Image Effects/Rendering/Sun Shafts")]
	public class SunShafts : PostEffectsBase
	{
		public enum SunShaftsResolution
		{
			Low,
			Normal,
			High
		}

		public enum ShaftsScreenBlendMode
		{
			Screen,
			Add
		}

		public SunShaftsResolution resolution = SunShaftsResolution.Normal;

		public ShaftsScreenBlendMode screenBlendMode;

		public Transform sunTransform;

		public int radialBlurIterations = 2;

		public Color sunColor = Color.white;

		public Color sunThreshold = new Color(0.87f, 0.74f, 0.65f);

		public float sunShaftBlurRadius = 2.5f;

		public float sunShaftIntensity = 1.15f;

		public float maxRadius = 0.75f;

		public bool useDepthTexture = true;

		public Shader sunShaftsShader;

		private Material sunShaftsMaterial;

		public Shader simpleClearShader;

		private Material simpleClearMaterial;

		public override bool CheckResources()
		{
			CheckSupport(useDepthTexture);
			sunShaftsMaterial = CheckShaderAndCreateMaterial(sunShaftsShader, sunShaftsMaterial);
			simpleClearMaterial = CheckShaderAndCreateMaterial(simpleClearShader, simpleClearMaterial);
			if (!isSupported)
			{
				ReportAutoDisable();
			}
			return isSupported;
		}

		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			if (!CheckResources())
			{
				Graphics.Blit(source, destination);
				return;
			}
			if (useDepthTexture)
			{
				GetComponent<Camera>().depthTextureMode |= DepthTextureMode.Depth;
			}
			int num = 4;
			if (resolution == SunShaftsResolution.Normal)
			{
				num = 2;
			}
			else if (resolution == SunShaftsResolution.High)
			{
				num = 1;
			}
			Vector3 vector = Vector3.one * 0.5f;
			vector = ((!sunTransform) ? new Vector3(0.5f, 0.5f, 0f) : GetComponent<Camera>().WorldToViewportPoint(sunTransform.position));
			int width = source.width / num;
			int height = source.height / num;
			RenderTexture temporary = RenderTexture.GetTemporary(width, height, 0);
			sunShaftsMaterial.SetVector("_BlurRadius4", new Vector4(1f, 1f, 0f, 0f) * sunShaftBlurRadius);
			sunShaftsMaterial.SetVector("_SunPosition", new Vector4(vector.x, vector.y, vector.z, maxRadius));
			sunShaftsMaterial.SetVector("_SunThreshold", sunThreshold);
			if (!useDepthTexture)
			{
				RenderTextureFormat format = (GetComponent<Camera>().allowHDR ? RenderTextureFormat.DefaultHDR : RenderTextureFormat.Default);
				RenderTexture renderTexture = (RenderTexture.active = RenderTexture.GetTemporary(source.width, source.height, 0, format));
				GL.ClearWithSkybox(clearDepth: false, GetComponent<Camera>());
				sunShaftsMaterial.SetTexture("_Skybox", renderTexture);
				Graphics.Blit(source, temporary, sunShaftsMaterial, 3);
				RenderTexture.ReleaseTemporary(renderTexture);
			}
			else
			{
				Graphics.Blit(source, temporary, sunShaftsMaterial, 2);
			}
			DrawBorder(temporary, simpleClearMaterial);
			radialBlurIterations = Mathf.Clamp(radialBlurIterations, 1, 4);
			float num2 = sunShaftBlurRadius * 0.0013020834f;
			sunShaftsMaterial.SetVector("_BlurRadius4", new Vector4(num2, num2, 0f, 0f));
			sunShaftsMaterial.SetVector("_SunPosition", new Vector4(vector.x, vector.y, vector.z, maxRadius));
			for (int i = 0; i < radialBlurIterations; i++)
			{
				RenderTexture temporary3 = RenderTexture.GetTemporary(width, height, 0);
				Graphics.Blit(temporary, temporary3, sunShaftsMaterial, 1);
				RenderTexture.ReleaseTemporary(temporary);
				num2 = sunShaftBlurRadius * (((float)i * 2f + 1f) * 6f) / 768f;
				sunShaftsMaterial.SetVector("_BlurRadius4", new Vector4(num2, num2, 0f, 0f));
				temporary = RenderTexture.GetTemporary(width, height, 0);
				Graphics.Blit(temporary3, temporary, sunShaftsMaterial, 1);
				RenderTexture.ReleaseTemporary(temporary3);
				num2 = sunShaftBlurRadius * (((float)i * 2f + 2f) * 6f) / 768f;
				sunShaftsMaterial.SetVector("_BlurRadius4", new Vector4(num2, num2, 0f, 0f));
			}
			if (vector.z >= 0f)
			{
				sunShaftsMaterial.SetVector("_SunColor", new Vector4(sunColor.r, sunColor.g, sunColor.b, sunColor.a) * sunShaftIntensity);
			}
			else
			{
				sunShaftsMaterial.SetVector("_SunColor", Vector4.zero);
			}
			sunShaftsMaterial.SetTexture("_ColorBuffer", temporary);
			Graphics.Blit(source, destination, sunShaftsMaterial, (screenBlendMode != 0) ? 4 : 0);
			RenderTexture.ReleaseTemporary(temporary);
		}
	}
	[RequireComponent(typeof(Camera))]
	[AddComponentMenu("Image Effects/Camera/Tilt Shift (Lens Blur)")]
	internal class TiltShift : PostEffectsBase
	{
		public enum TiltShiftMode
		{
			TiltShiftMode,
			IrisMode
		}

		public enum TiltShiftQuality
		{
			Preview,
			Low,
			Normal,
			High
		}

		public TiltShiftMode mode;

		public TiltShiftQuality quality = TiltShiftQuality.Normal;

		[Range(0f, 15f)]
		public float blurArea = 1f;

		[Range(0f, 25f)]
		public float maxBlurSize = 5f;

		[Range(0f, 1f)]
		public int downsample;

		public Shader tiltShiftShader;

		private Material tiltShiftMaterial;

		public override bool CheckResources()
		{
			CheckSupport(needDepth: false);
			tiltShiftMaterial = CheckShaderAndCreateMaterial(tiltShiftShader, tiltShiftMaterial);
			if (!isSupported)
			{
				ReportAutoDisable();
			}
			return isSupported;
		}

		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			if (!CheckResources())
			{
				Graphics.Blit(source, destination);
				return;
			}
			tiltShiftMaterial.SetFloat("_BlurSize", (maxBlurSize < 0f) ? 0f : maxBlurSize);
			tiltShiftMaterial.SetFloat("_BlurArea", blurArea);
			source.filterMode = FilterMode.Bilinear;
			RenderTexture renderTexture = destination;
			if ((float)downsample > 0f)
			{
				renderTexture = RenderTexture.GetTemporary(source.width >> downsample, source.height >> downsample, 0, source.format);
				renderTexture.filterMode = FilterMode.Bilinear;
			}
			int num = (int)quality;
			num *= 2;
			Graphics.Blit(source, renderTexture, tiltShiftMaterial, (mode == TiltShiftMode.TiltShiftMode) ? num : (num + 1));
			if (downsample > 0)
			{
				tiltShiftMaterial.SetTexture("_Blurred", renderTexture);
				Graphics.Blit(source, destination, tiltShiftMaterial, 8);
			}
			if (renderTexture != destination)
			{
				RenderTexture.ReleaseTemporary(renderTexture);
			}
		}
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(Camera))]
	[AddComponentMenu("Image Effects/Color Adjustments/Tonemapping")]
	public class Tonemapping : PostEffectsBase
	{
		public enum TonemapperType
		{
			SimpleReinhard,
			UserCurve,
			Hable,
			Photographic,
			OptimizedHejiDawson,
			AdaptiveReinhard,
			AdaptiveReinhardAutoWhite
		}

		public enum AdaptiveTexSize
		{
			Square16 = 0x10,
			Square32 = 0x20,
			Square64 = 0x40,
			Square128 = 0x80,
			Square256 = 0x100,
			Square512 = 0x200,
			Square1024 = 0x400
		}

		public TonemapperType type = TonemapperType.Photographic;

		public AdaptiveTexSize adaptiveTextureSize = AdaptiveTexSize.Square256;

		public AnimationCurve remapCurve;

		private Texture2D curveTex;

		public float exposureAdjustment = 1.5f;

		public float middleGrey = 0.4f;

		public float white = 2f;

		public float adaptionSpeed = 1.5f;

		public Shader tonemapper;

		public bool validRenderTextureFormat = true;

		private Material tonemapMaterial;

		private RenderTexture rt;

		private RenderTextureFormat rtFormat = RenderTextureFormat.ARGBHalf;

		public override bool CheckResources()
		{
			CheckSupport(needDepth: false, needHdr: true);
			tonemapMaterial = CheckShaderAndCreateMaterial(tonemapper, tonemapMaterial);
			if (!curveTex && type == TonemapperType.UserCurve)
			{
				curveTex = new Texture2D(256, 1, TextureFormat.ARGB32, mipChain: false, linear: true);
				curveTex.filterMode = FilterMode.Bilinear;
				curveTex.wrapMode = TextureWrapMode.Clamp;
				curveTex.hideFlags = HideFlags.DontSave;
			}
			if (!isSupported)
			{
				ReportAutoDisable();
			}
			return isSupported;
		}

		public float UpdateCurve()
		{
			float num = 1f;
			if (remapCurve.keys.Length < 1)
			{
				remapCurve = new AnimationCurve(new Keyframe(0f, 0f), new Keyframe(2f, 1f));
			}
			if (remapCurve != null)
			{
				if (remapCurve.length > 0)
				{
					num = remapCurve[remapCurve.length - 1].time;
				}
				for (float num2 = 0f; num2 <= 1f; num2 += 0.003921569f)
				{
					float num3 = remapCurve.Evaluate(num2 * 1f * num);
					curveTex.SetPixel((int)Mathf.Floor(num2 * 255f), 0, new Color(num3, num3, num3));
				}
				curveTex.Apply();
			}
			return 1f / num;
		}

		private void OnDisable()
		{
			if ((bool)rt)
			{
				UnityEngine.Object.DestroyImmediate(rt);
				rt = null;
			}
			if ((bool)tonemapMaterial)
			{
				UnityEngine.Object.DestroyImmediate(tonemapMaterial);
				tonemapMaterial = null;
			}
			if ((bool)curveTex)
			{
				UnityEngine.Object.DestroyImmediate(curveTex);
				curveTex = null;
			}
		}

		private bool CreateInternalRenderTexture()
		{
			if ((bool)rt)
			{
				return false;
			}
			rtFormat = (SystemInfo.SupportsRenderTextureFormat(RenderTextureFormat.RGHalf) ? RenderTextureFormat.RGHalf : RenderTextureFormat.ARGBHalf);
			rt = new RenderTexture(1, 1, 0, rtFormat);
			rt.hideFlags = HideFlags.DontSave;
			return true;
		}

		[ImageEffectTransformsToLDR]
		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			if (!CheckResources())
			{
				Graphics.Blit(source, destination);
				return;
			}
			exposureAdjustment = ((exposureAdjustment < 0.001f) ? 0.001f : exposureAdjustment);
			if (type == TonemapperType.UserCurve)
			{
				float value = UpdateCurve();
				tonemapMaterial.SetFloat("_RangeScale", value);
				tonemapMaterial.SetTexture("_Curve", curveTex);
				Graphics.Blit(source, destination, tonemapMaterial, 4);
				return;
			}
			if (type == TonemapperType.SimpleReinhard)
			{
				tonemapMaterial.SetFloat("_ExposureAdjustment", exposureAdjustment);
				Graphics.Blit(source, destination, tonemapMaterial, 6);
				return;
			}
			if (type == TonemapperType.Hable)
			{
				tonemapMaterial.SetFloat("_ExposureAdjustment", exposureAdjustment);
				Graphics.Blit(source, destination, tonemapMaterial, 5);
				return;
			}
			if (type == TonemapperType.Photographic)
			{
				tonemapMaterial.SetFloat("_ExposureAdjustment", exposureAdjustment);
				Graphics.Blit(source, destination, tonemapMaterial, 8);
				return;
			}
			if (type == TonemapperType.OptimizedHejiDawson)
			{
				tonemapMaterial.SetFloat("_ExposureAdjustment", 0.5f * exposureAdjustment);
				Graphics.Blit(source, destination, tonemapMaterial, 7);
				return;
			}
			bool flag = CreateInternalRenderTexture();
			RenderTexture temporary = RenderTexture.GetTemporary((int)adaptiveTextureSize, (int)adaptiveTextureSize, 0, rtFormat);
			Graphics.Blit(source, temporary);
			int num = (int)Mathf.Log((float)temporary.width * 1f, 2f);
			int num2 = 2;
			RenderTexture[] array = new RenderTexture[num];
			for (int i = 0; i < num; i++)
			{
				array[i] = RenderTexture.GetTemporary(temporary.width / num2, temporary.width / num2, 0, rtFormat);
				num2 *= 2;
			}
			RenderTexture source2 = array[num - 1];
			Graphics.Blit(temporary, array[0], tonemapMaterial, 1);
			if (type == TonemapperType.AdaptiveReinhardAutoWhite)
			{
				for (int j = 0; j < num - 1; j++)
				{
					Graphics.Blit(array[j], array[j + 1], tonemapMaterial, 9);
					source2 = array[j + 1];
				}
			}
			else if (type == TonemapperType.AdaptiveReinhard)
			{
				for (int k = 0; k < num - 1; k++)
				{
					Graphics.Blit(array[k], array[k + 1]);
					source2 = array[k + 1];
				}
			}
			adaptionSpeed = ((adaptionSpeed < 0.001f) ? 0.001f : adaptionSpeed);
			tonemapMaterial.SetFloat("_AdaptionSpeed", adaptionSpeed);
			rt.MarkRestoreExpected();
			Graphics.Blit(source2, rt, tonemapMaterial, flag ? 3 : 2);
			middleGrey = ((middleGrey < 0.001f) ? 0.001f : middleGrey);
			tonemapMaterial.SetVector("_HdrParams", new Vector4(middleGrey, middleGrey, middleGrey, white * white));
			tonemapMaterial.SetTexture("_SmallTex", rt);
			if (type == TonemapperType.AdaptiveReinhard)
			{
				Graphics.Blit(source, destination, tonemapMaterial, 0);
			}
			else if (type == TonemapperType.AdaptiveReinhardAutoWhite)
			{
				Graphics.Blit(source, destination, tonemapMaterial, 10);
			}
			else
			{
				UnityEngine.Debug.LogError("No valid adaptive tonemapper type found!");
				Graphics.Blit(source, destination);
			}
			for (int l = 0; l < num; l++)
			{
				RenderTexture.ReleaseTemporary(array[l]);
			}
			RenderTexture.ReleaseTemporary(temporary);
		}
	}
	internal class Triangles
	{
		private static Mesh[] meshes;

		private static int currentTris;

		private static bool HasMeshes()
		{
			if (meshes == null)
			{
				return false;
			}
			for (int i = 0; i < meshes.Length; i++)
			{
				if (null == meshes[i])
				{
					return false;
				}
			}
			return true;
		}

		private static void Cleanup()
		{
			if (meshes == null)
			{
				return;
			}
			for (int i = 0; i < meshes.Length; i++)
			{
				if (null != meshes[i])
				{
					UnityEngine.Object.DestroyImmediate(meshes[i]);
					meshes[i] = null;
				}
			}
			meshes = null;
		}

		private static Mesh[] GetMeshes(int totalWidth, int totalHeight)
		{
			if (HasMeshes() && currentTris == totalWidth * totalHeight)
			{
				return meshes;
			}
			int num = 21666;
			int num2 = (currentTris = totalWidth * totalHeight);
			meshes = new Mesh[Mathf.CeilToInt(1f * (float)num2 / (1f * (float)num))];
			int num3 = 0;
			int num4 = 0;
			for (num3 = 0; num3 < num2; num3 += num)
			{
				int triCount = Mathf.FloorToInt(Mathf.Clamp(num2 - num3, 0, num));
				meshes[num4] = GetMesh(triCount, num3, totalWidth, totalHeight);
				num4++;
			}
			return meshes;
		}

		private static Mesh GetMesh(int triCount, int triOffset, int totalWidth, int totalHeight)
		{
			Mesh mesh = new Mesh();
			mesh.hideFlags = HideFlags.DontSave;
			Vector3[] array = new Vector3[triCount * 3];
			Vector2[] array2 = new Vector2[triCount * 3];
			Vector2[] array3 = new Vector2[triCount * 3];
			int[] array4 = new int[triCount * 3];
			for (int i = 0; i < triCount; i++)
			{
				int num = i * 3;
				int num2 = triOffset + i;
				float num3 = Mathf.Floor(num2 % totalWidth) / (float)totalWidth;
				float num4 = Mathf.Floor(num2 / totalWidth) / (float)totalHeight;
				array[num + 2] = (array[num + 1] = (array[num] = new Vector3(num3 * 2f - 1f, num4 * 2f - 1f, 1f)));
				array2[num] = new Vector2(0f, 0f);
				array2[num + 1] = new Vector2(1f, 0f);
				array2[num + 2] = new Vector2(0f, 1f);
				array3[num] = new Vector2(num3, num4);
				array3[num + 1] = new Vector2(num3, num4);
				array3[num + 2] = new Vector2(num3, num4);
				array4[num] = num;
				array4[num + 1] = num + 1;
				array4[num + 2] = num + 2;
			}
			mesh.vertices = array;
			mesh.triangles = array4;
			mesh.uv = array2;
			mesh.uv2 = array3;
			return mesh;
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Image Effects/Displacement/Twirl")]
	public class Twirl : ImageEffectBase
	{
		public Vector2 radius = new Vector2(0.3f, 0.3f);

		[Range(0f, 360f)]
		public float angle = 50f;

		public Vector2 center = new Vector2(0.5f, 0.5f);

		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			ImageEffects.RenderDistortion(base.material, source, destination, angle, center, radius);
		}
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(Camera))]
	[AddComponentMenu("Image Effects/Camera/Vignette and Chromatic Aberration")]
	public class VignetteAndChromaticAberration : PostEffectsBase
	{
		public enum AberrationMode
		{
			Simple,
			Advanced
		}

		public AberrationMode mode;

		public float intensity = 0.036f;

		public float chromaticAberration = 0.2f;

		public float axialAberration = 0.5f;

		public float blur;

		public float blurSpread = 0.75f;

		public float luminanceDependency = 0.25f;

		public float blurDistance = 2.5f;

		public Shader vignetteShader;

		public Shader separableBlurShader;

		public Shader chromAberrationShader;

		private Material m_VignetteMaterial;

		private Material m_SeparableBlurMaterial;

		private Material m_ChromAberrationMaterial;

		public override bool CheckResources()
		{
			CheckSupport(needDepth: false);
			m_VignetteMaterial = CheckShaderAndCreateMaterial(vignetteShader, m_VignetteMaterial);
			m_SeparableBlurMaterial = CheckShaderAndCreateMaterial(separableBlurShader, m_SeparableBlurMaterial);
			m_ChromAberrationMaterial = CheckShaderAndCreateMaterial(chromAberrationShader, m_ChromAberrationMaterial);
			if (!isSupported)
			{
				ReportAutoDisable();
			}
			return isSupported;
		}

		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			if (!CheckResources())
			{
				Graphics.Blit(source, destination);
				return;
			}
			int width = source.width;
			int height = source.height;
			bool flag = Mathf.Abs(blur) > 0f || Mathf.Abs(intensity) > 0f;
			float num = 1f * (float)width / (1f * (float)height);
			RenderTexture renderTexture = null;
			RenderTexture renderTexture2 = null;
			if (flag)
			{
				renderTexture = RenderTexture.GetTemporary(width, height, 0, source.format);
				if (Mathf.Abs(blur) > 0f)
				{
					renderTexture2 = RenderTexture.GetTemporary(width / 2, height / 2, 0, source.format);
					Graphics.Blit(source, renderTexture2, m_ChromAberrationMaterial, 0);
					for (int i = 0; i < 2; i++)
					{
						m_SeparableBlurMaterial.SetVector("offsets", new Vector4(0f, blurSpread * 0.001953125f, 0f, 0f));
						RenderTexture temporary = RenderTexture.GetTemporary(width / 2, height / 2, 0, source.format);
						Graphics.Blit(renderTexture2, temporary, m_SeparableBlurMaterial);
						RenderTexture.ReleaseTemporary(renderTexture2);
						m_SeparableBlurMaterial.SetVector("offsets", new Vector4(blurSpread * 0.001953125f / num, 0f, 0f, 0f));
						renderTexture2 = RenderTexture.GetTemporary(width / 2, height / 2, 0, source.format);
						Graphics.Blit(temporary, renderTexture2, m_SeparableBlurMaterial);
						RenderTexture.ReleaseTemporary(temporary);
					}
				}
				m_VignetteMaterial.SetFloat("_Intensity", 1f / (1f - intensity) - 1f);
				m_VignetteMaterial.SetFloat("_Blur", 1f / (1f - blur) - 1f);
				m_VignetteMaterial.SetTexture("_VignetteTex", renderTexture2);
				Graphics.Blit(source, renderTexture, m_VignetteMaterial, 0);
			}
			m_ChromAberrationMaterial.SetFloat("_ChromaticAberration", chromaticAberration);
			m_ChromAberrationMaterial.SetFloat("_AxialAberration", axialAberration);
			m_ChromAberrationMaterial.SetVector("_BlurDistance", new Vector2(0f - blurDistance, blurDistance));
			m_ChromAberrationMaterial.SetFloat("_Luminance", 1f / Mathf.Max(Mathf.Epsilon, luminanceDependency));
			if (flag)
			{
				renderTexture.wrapMode = TextureWrapMode.Clamp;
			}
			else
			{
				source.wrapMode = TextureWrapMode.Clamp;
			}
			Graphics.Blit(flag ? renderTexture : source, destination, m_ChromAberrationMaterial, (mode != AberrationMode.Advanced) ? 1 : 2);
			RenderTexture.ReleaseTemporary(renderTexture);
			RenderTexture.ReleaseTemporary(renderTexture2);
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Image Effects/Displacement/Vortex")]
	public class Vortex : ImageEffectBase
	{
		public Vector2 radius = new Vector2(0.4f, 0.4f);

		public float angle = 50f;

		public Vector2 center = new Vector2(0.5f, 0.5f);

		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			ImageEffects.RenderDistortion(base.material, source, destination, angle, center, radius);
		}
	}
}
namespace UnityStandardAssets.Utility
{
	public class ActivateTrigger : MonoBehaviour
	{
		public enum Mode
		{
			Trigger,
			Replace,
			Activate,
			Enable,
			Animate,
			Deactivate
		}

		public Mode action = Mode.Activate;

		public UnityEngine.Object target;

		public GameObject source;

		public int triggerCount = 1;

		public bool repeatTrigger;

		private void DoActivateTrigger()
		{
			triggerCount--;
			if (triggerCount != 0 && !repeatTrigger)
			{
				return;
			}
			UnityEngine.Object obj = target ?? base.gameObject;
			Behaviour behaviour = obj as Behaviour;
			GameObject gameObject = obj as GameObject;
			if (behaviour != null)
			{
				gameObject = behaviour.gameObject;
			}
			switch (action)
			{
			case Mode.Trigger:
				if (gameObject != null)
				{
					gameObject.BroadcastMessage("DoActivateTrigger");
				}
				break;
			case Mode.Replace:
				if (source != null && gameObject != null)
				{
					UnityEngine.Object.Instantiate(source, gameObject.transform.position, gameObject.transform.rotation);
					UnityEngine.Object.DestroyObject(gameObject);
				}
				break;
			case Mode.Activate:
				if (gameObject != null)
				{
					gameObject.SetActive(value: true);
				}
				break;
			case Mode.Enable:
				if (behaviour != null)
				{
					behaviour.enabled = true;
				}
				break;
			case Mode.Animate:
				if (gameObject != null)
				{
					gameObject.GetComponent<Animation>().Play();
				}
				break;
			case Mode.Deactivate:
				if (gameObject != null)
				{
					gameObject.SetActive(value: false);
				}
				break;
			}
		}

		private void OnTriggerEnter(Collider other)
		{
			DoActivateTrigger();
		}
	}
	public class AutoMobileShaderSwitch : MonoBehaviour
	{
		[Serializable]
		public class ReplacementDefinition
		{
			public Shader original;

			public Shader replacement;
		}

		[Serializable]
		public class ReplacementList
		{
			public ReplacementDefinition[] items = new ReplacementDefinition[0];
		}

		[SerializeField]
		private ReplacementList m_ReplacementList;

		private void OnEnable()
		{
			Renderer[] array = UnityEngine.Object.FindObjectsOfType<Renderer>();
			UnityEngine.Debug.Log(array.Length + " renderers");
			List<Material> list = new List<Material>();
			List<Material> list2 = new List<Material>();
			int num = 0;
			int num2 = 0;
			ReplacementDefinition[] items = m_ReplacementList.items;
			foreach (ReplacementDefinition replacementDefinition in items)
			{
				Renderer[] array2 = array;
				foreach (Renderer renderer in array2)
				{
					Material[] array3 = null;
					for (int k = 0; k < renderer.sharedMaterials.Length; k++)
					{
						Material material = renderer.sharedMaterials[k];
						if (material.shader == replacementDefinition.original)
						{
							if (array3 == null)
							{
								array3 = renderer.materials;
							}
							if (!list.Contains(material))
							{
								list.Add(material);
								Material material2 = UnityEngine.Object.Instantiate(material);
								material2.shader = replacementDefinition.replacement;
								list2.Add(material2);
								num++;
							}
							UnityEngine.Debug.Log("replacing " + renderer.gameObject.name + " renderer " + k + " with " + list2[list.IndexOf(material)].name);
							array3[k] = list2[list.IndexOf(material)];
							num2++;
						}
					}
					if (array3 != null)
					{
						renderer.materials = array3;
					}
				}
			}
			UnityEngine.Debug.Log(num2 + " material instances replaced");
			UnityEngine.Debug.Log(num + " materials replaced");
			for (int l = 0; l < list.Count; l++)
			{
				UnityEngine.Debug.Log(list[l].name + " (" + list[l].shader.name + ") replaced with " + list2[l].name + " (" + list2[l].shader.name + ")");
			}
		}
	}
	public class AutoMoveAndRotate : MonoBehaviour
	{
		[Serializable]
		public class Vector3andSpace
		{
			public Vector3 value;

			public Space space = Space.Self;
		}

		public Vector3andSpace moveUnitsPerSecond;

		public Vector3andSpace rotateDegreesPerSecond;

		public bool ignoreTimescale;

		private float m_LastRealTime;

		private void Start()
		{
			m_LastRealTime = Time.realtimeSinceStartup;
		}

		private void Update()
		{
			float num = Time.deltaTime;
			if (ignoreTimescale)
			{
				num = Time.realtimeSinceStartup - m_LastRealTime;
				m_LastRealTime = Time.realtimeSinceStartup;
			}
			base.transform.Translate(moveUnitsPerSecond.value * num, moveUnitsPerSecond.space);
			base.transform.Rotate(rotateDegreesPerSecond.value * num, moveUnitsPerSecond.space);
		}
	}
	public class CameraRefocus
	{
		public Camera Camera;

		public Vector3 Lookatpoint;

		public Transform Parent;

		private Vector3 m_OrigCameraPos;

		private bool m_Refocus;

		public CameraRefocus(Camera camera, Transform parent, Vector3 origCameraPos)
		{
			m_OrigCameraPos = origCameraPos;
			Camera = camera;
			Parent = parent;
		}

		public void ChangeCamera(Camera camera)
		{
			Camera = camera;
		}

		public void ChangeParent(Transform parent)
		{
			Parent = parent;
		}

		public void GetFocusPoint()
		{
			if (Physics.Raycast(Parent.transform.position + m_OrigCameraPos, Parent.transform.forward, out var hitInfo, 100f))
			{
				Lookatpoint = hitInfo.point;
				m_Refocus = true;
			}
			else
			{
				m_Refocus = false;
			}
		}

		public void SetFocusPoint()
		{
			if (m_Refocus)
			{
				Camera.transform.LookAt(Lookatpoint);
			}
		}
	}
	[Serializable]
	public class CurveControlledBob
	{
		public float HorizontalBobRange = 0.33f;

		public float VerticalBobRange = 0.33f;

		public AnimationCurve Bobcurve = new AnimationCurve(new Keyframe(0f, 0f), new Keyframe(0.5f, 1f), new Keyframe(1f, 0f), new Keyframe(1.5f, -1f), new Keyframe(2f, 0f));

		public float VerticaltoHorizontalRatio = 1f;

		private float m_CyclePositionX;

		private float m_CyclePositionY;

		private float m_BobBaseInterval;

		private Vector3 m_OriginalCameraPosition;

		private float m_Time;

		public void Setup(Camera camera, float bobBaseInterval)
		{
			m_BobBaseInterval = bobBaseInterval;
			m_OriginalCameraPosition = camera.transform.localPosition;
			m_Time = Bobcurve[Bobcurve.length - 1].time;
		}

		public Vector3 DoHeadBob(float speed)
		{
			float x = m_OriginalCameraPosition.x + Bobcurve.Evaluate(m_CyclePositionX) * HorizontalBobRange;
			float y = m_OriginalCameraPosition.y + Bobcurve.Evaluate(m_CyclePositionY) * VerticalBobRange;
			m_CyclePositionX += speed * Time.deltaTime / m_BobBaseInterval;
			m_CyclePositionY += speed * Time.deltaTime / m_BobBaseInterval * VerticaltoHorizontalRatio;
			if (m_CyclePositionX > m_Time)
			{
				m_CyclePositionX -= m_Time;
			}
			if (m_CyclePositionY > m_Time)
			{
				m_CyclePositionY -= m_Time;
			}
			return new Vector3(x, y, 0f);
		}
	}
	public class DragRigidbody : MonoBehaviour
	{
		private const float k_Spring = 50f;

		private const float k_Damper = 5f;

		private const float k_Drag = 10f;

		private const float k_AngularDrag = 5f;

		private const float k_Distance = 0.2f;

		private const bool k_AttachToCenterOfMass = false;

		private SpringJoint m_SpringJoint;

		private void Update()
		{
			if (!Input.GetMouseButtonDown(0))
			{
				return;
			}
			Camera camera = FindCamera();
			RaycastHit hitInfo = default(RaycastHit);
			if (Physics.Raycast(camera.ScreenPointToRay(Input.mousePosition).origin, camera.ScreenPointToRay(Input.mousePosition).direction, out hitInfo, 100f, -5) && (bool)hitInfo.rigidbody && !hitInfo.rigidbody.isKinematic)
			{
				if (!m_SpringJoint)
				{
					GameObject gameObject = new GameObject("Rigidbody dragger");
					Rigidbody rigidbody = gameObject.AddComponent<Rigidbody>();
					m_SpringJoint = gameObject.AddComponent<SpringJoint>();
					rigidbody.isKinematic = true;
				}
				m_SpringJoint.transform.position = hitInfo.point;
				m_SpringJoint.anchor = Vector3.zero;
				m_SpringJoint.spring = 50f;
				m_SpringJoint.damper = 5f;
				m_SpringJoint.maxDistance = 0.2f;
				m_SpringJoint.connectedBody = hitInfo.rigidbody;
				StartCoroutine("DragObject", hitInfo.distance);
			}
		}

		private IEnumerator DragObject(float distance)
		{
			float oldDrag = m_SpringJoint.connectedBody.drag;
			float oldAngularDrag = m_SpringJoint.connectedBody.angularDrag;
			m_SpringJoint.connectedBody.drag = 10f;
			m_SpringJoint.connectedBody.angularDrag = 5f;
			Camera mainCamera = FindCamera();
			while (Input.GetMouseButton(0))
			{
				Ray ray = mainCamera.ScreenPointToRay(Input.mousePosition);
				m_SpringJoint.transform.position = ray.GetPoint(distance);
				yield return null;
			}
			if ((bool)m_SpringJoint.connectedBody)
			{
				m_SpringJoint.connectedBody.drag = oldDrag;
				m_SpringJoint.connectedBody.angularDrag = oldAngularDrag;
				m_SpringJoint.connectedBody = null;
			}
		}

		private Camera FindCamera()
		{
			if ((bool)GetComponent<Camera>())
			{
				return GetComponent<Camera>();
			}
			return Camera.main;
		}
	}
	public class DynamicShadowSettings : MonoBehaviour
	{
		public Light sunLight;

		public float minHeight = 10f;

		public float minShadowDistance = 80f;

		public float minShadowBias = 1f;

		public float maxHeight = 1000f;

		public float maxShadowDistance = 10000f;

		public float maxShadowBias = 0.1f;

		public float adaptTime = 1f;

		private float m_SmoothHeight;

		private float m_ChangeSpeed;

		private float m_OriginalStrength = 1f;

		private void Start()
		{
			m_OriginalStrength = sunLight.shadowStrength;
		}

		private void Update()
		{
			Ray ray = new Ray(Camera.main.transform.position, -Vector3.up);
			float num = base.transform.position.y;
			if (Physics.Raycast(ray, out var hitInfo))
			{
				num = hitInfo.distance;
			}
			if (Mathf.Abs(num - m_SmoothHeight) > 1f)
			{
				m_SmoothHeight = Mathf.SmoothDamp(m_SmoothHeight, num, ref m_ChangeSpeed, adaptTime);
			}
			float num2 = Mathf.InverseLerp(minHeight, maxHeight, m_SmoothHeight);
			QualitySettings.shadowDistance = Mathf.Lerp(minShadowDistance, maxShadowDistance, num2);
			sunLight.shadowBias = Mathf.Lerp(minShadowBias, maxShadowBias, 1f - (1f - num2) * (1f - num2));
			sunLight.shadowStrength = Mathf.Lerp(m_OriginalStrength, 0f, num2);
		}
	}
	[Serializable]
	public class FOVKick
	{
		public Camera Camera;

		[HideInInspector]
		public float originalFov;

		public float FOVIncrease = 3f;

		public float TimeToIncrease = 1f;

		public float TimeToDecrease = 1f;

		public AnimationCurve IncreaseCurve;

		public void Setup(Camera camera)
		{
			CheckStatus(camera);
			Camera = camera;
			originalFov = camera.fieldOfView;
		}

		private void CheckStatus(Camera camera)
		{
			if (camera == null)
			{
				throw new Exception("FOVKick camera is null, please supply the camera to the constructor");
			}
			if (IncreaseCurve == null)
			{
				throw new Exception("FOVKick Increase curve is null, please define the curve for the field of view kicks");
			}
		}

		public void ChangeCamera(Camera camera)
		{
			Camera = camera;
		}

		public IEnumerator FOVKickUp()
		{
			float t = Mathf.Abs((Camera.fieldOfView - originalFov) / FOVIncrease);
			while (t < TimeToIncrease)
			{
				Camera.fieldOfView = originalFov + IncreaseCurve.Evaluate(t / TimeToIncrease) * FOVIncrease;
				t += Time.deltaTime;
				yield return new WaitForEndOfFrame();
			}
		}

		public IEnumerator FOVKickDown()
		{
			float t = Mathf.Abs((Camera.fieldOfView - originalFov) / FOVIncrease);
			while (t > 0f)
			{
				Camera.fieldOfView = originalFov + IncreaseCurve.Evaluate(t / TimeToDecrease) * FOVIncrease;
				t -= Time.deltaTime;
				yield return new WaitForEndOfFrame();
			}
			Camera.fieldOfView = originalFov;
		}
	}
	[RequireComponent(typeof(Text))]
	public class FPSCounter : MonoBehaviour
	{
		private const float fpsMeasurePeriod = 0.5f;

		private int m_FpsAccumulator;

		private float m_FpsNextPeriod;

		private int m_CurrentFps;

		private const string display = "{0} FPS";

		private Text m_Text;

		private void Start()
		{
			m_FpsNextPeriod = Time.realtimeSinceStartup + 0.5f;
			m_Text = GetComponent<Text>();
		}

		private void Update()
		{
			m_FpsAccumulator++;
			if (Time.realtimeSinceStartup > m_FpsNextPeriod)
			{
				m_CurrentFps = (int)((float)m_FpsAccumulator / 0.5f);
				m_FpsAccumulator = 0;
				m_FpsNextPeriod += 0.5f;
				m_Text.text = $"{m_CurrentFps} FPS";
			}
		}
	}
	public class FollowTarget : MonoBehaviour
	{
		public Transform target;

		public Vector3 offset = new Vector3(0f, 7.5f, 0f);

		private void LateUpdate()
		{
			base.transform.position = target.position + offset;
		}
	}
	[Serializable]
	public class LerpControlledBob
	{
		public float BobDuration;

		public float BobAmount;

		private float m_Offset;

		public float Offset()
		{
			return m_Offset;
		}

		public IEnumerator DoBobCycle()
		{
			float t2 = 0f;
			while (t2 < BobDuration)
			{
				m_Offset = Mathf.Lerp(0f, BobAmount, t2 / BobDuration);
				t2 += Time.deltaTime;
				yield return new WaitForFixedUpdate();
			}
			t2 = 0f;
			while (t2 < BobDuration)
			{
				m_Offset = Mathf.Lerp(BobAmount, 0f, t2 / BobDuration);
				t2 += Time.deltaTime;
				yield return new WaitForFixedUpdate();
			}
			m_Offset = 0f;
		}
	}
	public class ObjectResetter : MonoBehaviour
	{
		private Vector3 originalPosition;

		private Quaternion originalRotation;

		private List<Transform> originalStructure;

		private Rigidbody Rigidbody;

		private void Start()
		{
			originalStructure = new List<Transform>(GetComponentsInChildren<Transform>());
			originalPosition = base.transform.position;
			originalRotation = base.transform.rotation;
			Rigidbody = GetComponent<Rigidbody>();
		}

		public void DelayedReset(float delay)
		{
			StartCoroutine(ResetCoroutine(delay));
		}

		public IEnumerator ResetCoroutine(float delay)
		{
			yield return new WaitForSeconds(delay);
			Transform[] componentsInChildren = GetComponentsInChildren<Transform>();
			foreach (Transform transform in componentsInChildren)
			{
				if (!originalStructure.Contains(transform))
				{
					transform.parent = null;
				}
			}
			base.transform.position = originalPosition;
			base.transform.rotation = originalRotation;
			if ((bool)Rigidbody)
			{
				Rigidbody.velocity = Vector3.zero;
				Rigidbody.angularVelocity = Vector3.zero;
			}
			SendMessage("Reset");
		}
	}
	public class ParticleSystemDestroyer : MonoBehaviour
	{
		public float minDuration = 8f;

		public float maxDuration = 10f;

		private float m_MaxLifetime;

		private bool m_EarlyStop;

		private IEnumerator Start()
		{
			ParticleSystem[] systems = GetComponentsInChildren<ParticleSystem>();
			ParticleSystem[] array = systems;
			foreach (ParticleSystem particleSystem in array)
			{
				m_MaxLifetime = Mathf.Max(particleSystem.main.startLifetime.constant, m_MaxLifetime);
			}
			float stopTime = Time.time + UnityEngine.Random.Range(minDuration, maxDuration);
			while (Time.time < stopTime || m_EarlyStop)
			{
				yield return null;
			}
			UnityEngine.Debug.Log("stopping " + base.name);
			array = systems;
			for (int i = 0; i < array.Length; i++)
			{
				ParticleSystem.EmissionModule emission = array[i].emission;
				emission.enabled = false;
			}
			BroadcastMessage("Extinguish", SendMessageOptions.DontRequireReceiver);
			yield return new WaitForSeconds(m_MaxLifetime);
			UnityEngine.Object.Destroy(base.gameObject);
		}

		public void Stop()
		{
			m_EarlyStop = true;
		}
	}
	public class PlatformSpecificContent : MonoBehaviour
	{
		private enum BuildTargetGroup
		{
			Standalone,
			Mobile
		}

		[SerializeField]
		private BuildTargetGroup m_BuildTargetGroup;

		[SerializeField]
		private GameObject[] m_Content = new GameObject[0];

		[SerializeField]
		private MonoBehaviour[] m_MonoBehaviours = new MonoBehaviour[0];

		[SerializeField]
		private bool m_ChildrenOfThisObject;

		private void OnEnable()
		{
			CheckEnableContent();
		}

		private void CheckEnableContent()
		{
			if (m_BuildTargetGroup == BuildTargetGroup.Mobile)
			{
				EnableContent(enabled: true);
			}
			else
			{
				EnableContent(enabled: false);
			}
		}

		private void EnableContent(bool enabled)
		{
			if (m_Content.Length != 0)
			{
				GameObject[] content = m_Content;
				foreach (GameObject gameObject in content)
				{
					if (gameObject != null)
					{
						gameObject.SetActive(enabled);
					}
				}
			}
			if (m_ChildrenOfThisObject)
			{
				foreach (Transform item in base.transform)
				{
					item.gameObject.SetActive(enabled);
				}
			}
			if (m_MonoBehaviours.Length != 0)
			{
				MonoBehaviour[] monoBehaviours = m_MonoBehaviours;
				for (int i = 0; i < monoBehaviours.Length; i++)
				{
					monoBehaviours[i].enabled = enabled;
				}
			}
		}
	}
	public class SimpleMouseRotator : MonoBehaviour
	{
		public Vector2 rotationRange = new Vector3(70f, 70f);

		public float rotationSpeed = 10f;

		public float dampingTime = 0.2f;

		public bool autoZeroVerticalOnMobile = true;

		public bool autoZeroHorizontalOnMobile;

		public bool relative = true;

		private Vector3 m_TargetAngles;

		private Vector3 m_FollowAngles;

		private Vector3 m_FollowVelocity;

		private Quaternion m_OriginalRotation;

		private void Start()
		{
			m_OriginalRotation = base.transform.localRotation;
		}

		private void Update()
		{
			base.transform.localRotation = m_OriginalRotation;
			if (relative)
			{
				float axis = CrossPlatformInputManager.GetAxis("Mouse X");
				float axis2 = CrossPlatformInputManager.GetAxis("Mouse Y");
				if (m_TargetAngles.y > 180f)
				{
					m_TargetAngles.y -= 360f;
					m_FollowAngles.y -= 360f;
				}
				if (m_TargetAngles.x > 180f)
				{
					m_TargetAngles.x -= 360f;
					m_FollowAngles.x -= 360f;
				}
				if (m_TargetAngles.y < -180f)
				{
					m_TargetAngles.y += 360f;
					m_FollowAngles.y += 360f;
				}
				if (m_TargetAngles.x < -180f)
				{
					m_TargetAngles.x += 360f;
					m_FollowAngles.x += 360f;
				}
				if (autoZeroHorizontalOnMobile)
				{
					m_TargetAngles.y = Mathf.Lerp((0f - rotationRange.y) * 0.5f, rotationRange.y * 0.5f, axis * 0.5f + 0.5f);
				}
				else
				{
					m_TargetAngles.y += axis * rotationSpeed;
				}
				if (autoZeroVerticalOnMobile)
				{
					m_TargetAngles.x = Mathf.Lerp((0f - rotationRange.x) * 0.5f, rotationRange.x * 0.5f, axis2 * 0.5f + 0.5f);
				}
				else
				{
					m_TargetAngles.x += axis2 * rotationSpeed;
				}
				m_TargetAngles.y = Mathf.Clamp(m_TargetAngles.y, (0f - rotationRange.y) * 0.5f, rotationRange.y * 0.5f);
				m_TargetAngles.x = Mathf.Clamp(m_TargetAngles.x, (0f - rotationRange.x) * 0.5f, rotationRange.x * 0.5f);
			}
			else
			{
				float axis = Input.mousePosition.x;
				float axis2 = Input.mousePosition.y;
				m_TargetAngles.y = Mathf.Lerp((0f - rotationRange.y) * 0.5f, rotationRange.y * 0.5f, axis / (float)Screen.width);
				m_TargetAngles.x = Mathf.Lerp((0f - rotationRange.x) * 0.5f, rotationRange.x * 0.5f, axis2 / (float)Screen.height);
			}
			m_FollowAngles = Vector3.SmoothDamp(m_FollowAngles, m_TargetAngles, ref m_FollowVelocity, dampingTime);
			base.transform.localRotation = m_OriginalRotation * Quaternion.Euler(0f - m_FollowAngles.x, m_FollowAngles.y, 0f);
		}
	}
	public class SmoothFollow : MonoBehaviour
	{
		[SerializeField]
		private Transform target;

		[SerializeField]
		private float distance = 10f;

		[SerializeField]
		private float height = 5f;

		[SerializeField]
		private float rotationDamping;

		[SerializeField]
		private float heightDamping;

		private void Start()
		{
		}

		private void LateUpdate()
		{
			if ((bool)target)
			{
				float y = target.eulerAngles.y;
				float b = target.position.y + height;
				float y2 = base.transform.eulerAngles.y;
				float y3 = base.transform.position.y;
				y2 = Mathf.LerpAngle(y2, y, rotationDamping * Time.deltaTime);
				y3 = Mathf.Lerp(y3, b, heightDamping * Time.deltaTime);
				Quaternion quaternion = Quaternion.Euler(0f, y2, 0f);
				base.transform.position = target.position;
				base.transform.position -= quaternion * Vector3.forward * distance;
				base.transform.position = new Vector3(base.transform.position.x, y3, base.transform.position.z);
				base.transform.LookAt(target);
			}
		}
	}
	public class TimedObjectActivator : MonoBehaviour
	{
		public enum Action
		{
			Activate,
			Deactivate,
			Destroy,
			ReloadLevel,
			Call
		}

		[Serializable]
		public class Entry
		{
			public GameObject target;

			public Action action;

			public float delay;
		}

		[Serializable]
		public class Entries
		{
			public Entry[] entries;
		}

		public Entries entries = new Entries();

		private void Awake()
		{
			Entry[] array = entries.entries;
			foreach (Entry entry in array)
			{
				switch (entry.action)
				{
				case Action.Activate:
					StartCoroutine(Activate(entry));
					break;
				case Action.Deactivate:
					StartCoroutine(Deactivate(entry));
					break;
				case Action.Destroy:
					UnityEngine.Object.Destroy(entry.target, entry.delay);
					break;
				case Action.ReloadLevel:
					StartCoroutine(ReloadLevel(entry));
					break;
				}
			}
		}

		private IEnumerator Activate(Entry entry)
		{
			yield return new WaitForSeconds(entry.delay);
			entry.target.SetActive(value: true);
		}

		private IEnumerator Deactivate(Entry entry)
		{
			yield return new WaitForSeconds(entry.delay);
			entry.target.SetActive(value: false);
		}

		private IEnumerator ReloadLevel(Entry entry)
		{
			yield return new WaitForSeconds(entry.delay);
			SceneManager.LoadScene(SceneManager.GetSceneAt(0).name);
		}
	}
	public class TimedObjectDestructor : MonoBehaviour
	{
		[SerializeField]
		private float m_TimeOut = 1f;

		[SerializeField]
		private bool m_DetachChildren;

		private void Awake()
		{
			Invoke("DestroyNow", m_TimeOut);
		}

		private void DestroyNow()
		{
			if (m_DetachChildren)
			{
				base.transform.DetachChildren();
			}
			UnityEngine.Object.DestroyObject(base.gameObject);
		}
	}
	public class WaypointCircuit : MonoBehaviour
	{
		[Serializable]
		public class WaypointList
		{
			public WaypointCircuit circuit;

			public Transform[] items = new Transform[0];
		}

		public struct RoutePoint
		{
			public Vector3 position;

			public Vector3 direction;

			public RoutePoint(Vector3 position, Vector3 direction)
			{
				this.position = position;
				this.direction = direction;
			}
		}

		public WaypointList waypointList = new WaypointList();

		[SerializeField]
		private bool smoothRoute = true;

		private int numPoints;

		private Vector3[] points;

		private float[] distances;

		public float editorVisualisationSubsteps = 100f;

		private int p0n;

		private int p1n;

		private int p2n;

		private int p3n;

		private float i;

		private Vector3 P0;

		private Vector3 P1;

		private Vector3 P2;

		private Vector3 P3;

		public float Length { get; private set; }

		public Transform[] Waypoints => waypointList.items;

		private void Awake()
		{
			if (Waypoints.Length > 1)
			{
				CachePositionsAndDistances();
			}
			numPoints = Waypoints.Length;
		}

		public RoutePoint GetRoutePoint(float dist)
		{
			Vector3 routePosition = GetRoutePosition(dist);
			return new RoutePoint(routePosition, (GetRoutePosition(dist + 0.1f) - routePosition).normalized);
		}

		public Vector3 GetRoutePosition(float dist)
		{
			int i = 0;
			if (Length == 0f)
			{
				Length = distances[distances.Length - 1];
			}
			for (dist = Mathf.Repeat(dist, Length); distances[i] < dist; i++)
			{
			}
			p1n = (i - 1 + numPoints) % numPoints;
			p2n = i;
			this.i = Mathf.InverseLerp(distances[p1n], distances[p2n], dist);
			if (smoothRoute)
			{
				p0n = (i - 2 + numPoints) % numPoints;
				p3n = (i + 1) % numPoints;
				p2n %= numPoints;
				P0 = points[p0n];
				P1 = points[p1n];
				P2 = points[p2n];
				P3 = points[p3n];
				return CatmullRom(P0, P1, P2, P3, this.i);
			}
			p1n = (i - 1 + numPoints) % numPoints;
			p2n = i;
			return Vector3.Lerp(points[p1n], points[p2n], this.i);
		}

		private Vector3 CatmullRom(Vector3 p0, Vector3 p1, Vector3 p2, Vector3 p3, float i)
		{
			return 0.5f * (2f * p1 + (-p0 + p2) * i + (2f * p0 - 5f * p1 + 4f * p2 - p3) * i * i + (-p0 + 3f * p1 - 3f * p2 + p3) * i * i * i);
		}

		private void CachePositionsAndDistances()
		{
			points = new Vector3[Waypoints.Length + 1];
			distances = new float[Waypoints.Length + 1];
			float num = 0f;
			for (int i = 0; i < points.Length; i++)
			{
				Transform transform = Waypoints[i % Waypoints.Length];
				Transform transform2 = Waypoints[(i + 1) % Waypoints.Length];
				if (transform != null && transform2 != null)
				{
					Vector3 position = transform.position;
					Vector3 position2 = transform2.position;
					points[i] = Waypoints[i % Waypoints.Length].position;
					distances[i] = num;
					num += (position - position2).magnitude;
				}
			}
		}

		private void OnDrawGizmos()
		{
			DrawGizmos(selected: false);
		}

		private void OnDrawGizmosSelected()
		{
			DrawGizmos(selected: true);
		}

		private void DrawGizmos(bool selected)
		{
			waypointList.circuit = this;
			if (Waypoints.Length <= 1)
			{
				return;
			}
			numPoints = Waypoints.Length;
			CachePositionsAndDistances();
			Length = distances[distances.Length - 1];
			Gizmos.color = (selected ? Color.yellow : new Color(1f, 1f, 0f, 0.5f));
			Vector3 from = Waypoints[0].position;
			if (smoothRoute)
			{
				for (float num = 0f; num < Length; num += Length / editorVisualisationSubsteps)
				{
					Vector3 routePosition = GetRoutePosition(num + 1f);
					Gizmos.DrawLine(from, routePosition);
					from = routePosition;
				}
				Gizmos.DrawLine(from, Waypoints[0].position);
			}
			else
			{
				for (int i = 0; i < Waypoints.Length; i++)
				{
					Vector3 position = Waypoints[(i + 1) % Waypoints.Length].position;
					Gizmos.DrawLine(from, position);
					from = position;
				}
			}
		}
	}
	public class WaypointProgressTracker : MonoBehaviour
	{
		public enum ProgressStyle
		{
			SmoothAlongRoute,
			PointToPoint
		}

		[SerializeField]
		private WaypointCircuit circuit;

		[SerializeField]
		private float lookAheadForTargetOffset = 5f;

		[SerializeField]
		private float lookAheadForTargetFactor = 0.1f;

		[SerializeField]
		private float lookAheadForSpeedOffset = 10f;

		[SerializeField]
		private float lookAheadForSpeedFactor = 0.2f;

		[SerializeField]
		private ProgressStyle progressStyle;

		[SerializeField]
		private float pointToPointThreshold = 4f;

		public Transform target;

		private float progressDistance;

		private int progressNum;

		private Vector3 lastPosition;

		private float speed;

		public WaypointCircuit.RoutePoint targetPoint { get; private set; }

		public WaypointCircuit.RoutePoint speedPoint { get; private set; }

		public WaypointCircuit.RoutePoint progressPoint { get; private set; }

		private void Start()
		{
			if (target == null)
			{
				target = new GameObject(base.name + " Waypoint Target").transform;
			}
			Reset();
		}

		public void Reset()
		{
			progressDistance = 0f;
			progressNum = 0;
			if (progressStyle == ProgressStyle.PointToPoint)
			{
				target.position = circuit.Waypoints[progressNum].position;
				target.rotation = circuit.Waypoints[progressNum].rotation;
			}
		}

		private void Update()
		{
			if (progressStyle == ProgressStyle.SmoothAlongRoute)
			{
				if (Time.deltaTime > 0f)
				{
					speed = Mathf.Lerp(speed, (lastPosition - base.transform.position).magnitude / Time.deltaTime, Time.deltaTime);
				}
				target.position = circuit.GetRoutePoint(progressDistance + lookAheadForTargetOffset + lookAheadForTargetFactor * speed).position;
				target.rotation = Quaternion.LookRotation(circuit.GetRoutePoint(progressDistance + lookAheadForSpeedOffset + lookAheadForSpeedFactor * speed).direction);
				progressPoint = circuit.GetRoutePoint(progressDistance);
				Vector3 lhs = progressPoint.position - base.transform.position;
				if (Vector3.Dot(lhs, progressPoint.direction) < 0f)
				{
					progressDistance += lhs.magnitude * 0.5f;
				}
				lastPosition = base.transform.position;
			}
			else
			{
				if ((target.position - base.transform.position).magnitude < pointToPointThreshold)
				{
					progressNum = (progressNum + 1) % circuit.Waypoints.Length;
				}
				target.position = circuit.Waypoints[progressNum].position;
				target.rotation = circuit.Waypoints[progressNum].rotation;
				progressPoint = circuit.GetRoutePoint(progressDistance);
				Vector3 lhs2 = progressPoint.position - base.transform.position;
				if (Vector3.Dot(lhs2, progressPoint.direction) < 0f)
				{
					progressDistance += lhs2.magnitude;
				}
				lastPosition = base.transform.position;
			}
		}

		private void OnDrawGizmos()
		{
			if (UnityEngine.Application.isPlaying)
			{
				Gizmos.color = Color.green;
				Gizmos.DrawLine(base.transform.position, target.position);
				Gizmos.DrawWireSphere(circuit.GetRoutePosition(progressDistance), 1f);
				Gizmos.color = Color.yellow;
				Gizmos.DrawLine(target.position, target.position + target.forward);
			}
		}
	}
}
namespace UnityStandardAssets.CrossPlatformInput
{
	public class AxisTouchButton : MonoBehaviour, IPointerDownHandler, IEventSystemHandler, IPointerUpHandler
	{
		public string axisName = "Horizontal";

		public float axisValue = 1f;

		public float responseSpeed = 3f;

		public float returnToCentreSpeed = 3f;

		private AxisTouchButton m_PairedWith;

		private CrossPlatformInputManager.VirtualAxis m_Axis;

		private void OnEnable()
		{
			if (!CrossPlatformInputManager.AxisExists(axisName))
			{
				m_Axis = new CrossPlatformInputManager.VirtualAxis(axisName);
				CrossPlatformInputManager.RegisterVirtualAxis(m_Axis);
			}
			else
			{
				m_Axis = CrossPlatformInputManager.VirtualAxisReference(axisName);
			}
			FindPairedButton();
		}

		private void FindPairedButton()
		{
			if (!(UnityEngine.Object.FindObjectsOfType(typeof(AxisTouchButton)) is AxisTouchButton[] array))
			{
				return;
			}
			for (int i = 0; i < array.Length; i++)
			{
				if (array[i].axisName == axisName && array[i] != this)
				{
					m_PairedWith = array[i];
				}
			}
		}

		private void OnDisable()
		{
			m_Axis.Remove();
		}

		public void OnPointerDown(PointerEventData data)
		{
			if (m_PairedWith == null)
			{
				FindPairedButton();
			}
			m_Axis.Update(Mathf.MoveTowards(m_Axis.GetValue, axisValue, responseSpeed * Time.deltaTime));
		}

		public void OnPointerUp(PointerEventData data)
		{
			m_Axis.Update(Mathf.MoveTowards(m_Axis.GetValue, 0f, responseSpeed * Time.deltaTime));
		}
	}
	public class ButtonHandler : MonoBehaviour
	{
		public string Name;

		private void OnEnable()
		{
		}

		public void SetDownState()
		{
			CrossPlatformInputManager.SetButtonDown(Name);
		}

		public void SetUpState()
		{
			CrossPlatformInputManager.SetButtonUp(Name);
		}

		public void SetAxisPositiveState()
		{
			CrossPlatformInputManager.SetAxisPositive(Name);
		}

		public void SetAxisNeutralState()
		{
			CrossPlatformInputManager.SetAxisZero(Name);
		}

		public void SetAxisNegativeState()
		{
			CrossPlatformInputManager.SetAxisNegative(Name);
		}

		public void Update()
		{
		}
	}
	public static class CrossPlatformInputManager
	{
		public enum ActiveInputMethod
		{
			Hardware,
			Touch
		}

		public class VirtualAxis
		{
			private float m_Value;

			public string name { get; private set; }

			public bool matchWithInputManager { get; private set; }

			public float GetValue => m_Value;

			public float GetValueRaw => m_Value;

			public VirtualAxis(string name)
				: this(name, matchToInputSettings: true)
			{
			}

			public VirtualAxis(string name, bool matchToInputSettings)
			{
				this.name = name;
				matchWithInputManager = matchToInputSettings;
			}

			public void Remove()
			{
				UnRegisterVirtualAxis(name);
			}

			public void Update(float value)
			{
				m_Value = value;
			}
		}

		public class VirtualButton
		{
			private int m_LastPressedFrame = -5;

			private int m_ReleasedFrame = -5;

			private bool m_Pressed;

			public string name { get; private set; }

			public bool matchWithInputManager { get; private set; }

			public bool GetButton => m_Pressed;

			public bool GetButtonDown => m_LastPressedFrame - Time.frameCount == -1;

			public bool GetButtonUp => m_ReleasedFrame == Time.frameCount - 1;

			public VirtualButton(string name)
				: this(name, matchToInputSettings: true)
			{
			}

			public VirtualButton(string name, bool matchToInputSettings)
			{
				this.name = name;
				matchWithInputManager = matchToInputSettings;
			}

			public void Pressed()
			{
				if (!m_Pressed)
				{
					m_Pressed = true;
					m_LastPressedFrame = Time.frameCount;
				}
			}

			public void Released()
			{
				m_Pressed = false;
				m_ReleasedFrame = Time.frameCount;
			}

			public void Remove()
			{
				UnRegisterVirtualButton(name);
			}
		}

		private static VirtualInput activeInput;

		private static VirtualInput s_TouchInput;

		private static VirtualInput s_HardwareInput;

		public static Vector3 mousePosition => activeInput.MousePosition();

		static CrossPlatformInputManager()
		{
			s_TouchInput = new MobileInput();
			s_HardwareInput = new StandaloneInput();
			activeInput = s_TouchInput;
		}

		public static void SwitchActiveInputMethod(ActiveInputMethod activeInputMethod)
		{
			switch (activeInputMethod)
			{
			case ActiveInputMethod.Hardware:
				activeInput = s_HardwareInput;
				break;
			case ActiveInputMethod.Touch:
				activeInput = s_TouchInput;
				break;
			}
		}

		public static bool AxisExists(string name)
		{
			return activeInput.AxisExists(name);
		}

		public static bool ButtonExists(string name)
		{
			return activeInput.ButtonExists(name);
		}

		public static void RegisterVirtualAxis(VirtualAxis axis)
		{
			activeInput.RegisterVirtualAxis(axis);
		}

		public static void RegisterVirtualButton(VirtualButton button)
		{
			activeInput.RegisterVirtualButton(button);
		}

		public static void UnRegisterVirtualAxis(string name)
		{
			if (name == null)
			{
				throw new ArgumentNullException("name");
			}
			activeInput.UnRegisterVirtualAxis(name);
		}

		public static void UnRegisterVirtualButton(string name)
		{
			activeInput.UnRegisterVirtualButton(name);
		}

		public static VirtualAxis VirtualAxisReference(string name)
		{
			return activeInput.VirtualAxisReference(name);
		}

		public static float GetAxis(string name)
		{
			return GetAxis(name, raw: false);
		}

		public static float GetAxisRaw(string name)
		{
			return GetAxis(name, raw: true);
		}

		private static float GetAxis(string name, bool raw)
		{
			return activeInput.GetAxis(name, raw);
		}

		public static bool GetButton(string name)
		{
			return activeInput.GetButton(name);
		}

		public static bool GetButtonDown(string name)
		{
			return activeInput.GetButtonDown(name);
		}

		public static bool GetButtonUp(string name)
		{
			return activeInput.GetButtonUp(name);
		}

		public static void SetButtonDown(string name)
		{
			activeInput.SetButtonDown(name);
		}

		public static void SetButtonUp(string name)
		{
			activeInput.SetButtonUp(name);
		}

		public static void SetAxisPositive(string name)
		{
			activeInput.SetAxisPositive(name);
		}

		public static void SetAxisNegative(string name)
		{
			activeInput.SetAxisNegative(name);
		}

		public static void SetAxisZero(string name)
		{
			activeInput.SetAxisZero(name);
		}

		public static void SetAxis(string name, float value)
		{
			activeInput.SetAxis(name, value);
		}

		public static void SetVirtualMousePositionX(float f)
		{
			activeInput.SetVirtualMousePositionX(f);
		}

		public static void SetVirtualMousePositionY(float f)
		{
			activeInput.SetVirtualMousePositionY(f);
		}

		public static void SetVirtualMousePositionZ(float f)
		{
			activeInput.SetVirtualMousePositionZ(f);
		}
	}
	public class InputAxisScrollbar : MonoBehaviour
	{
		public string axis;

		private void Update()
		{
		}

		public void HandleInput(float value)
		{
			CrossPlatformInputManager.SetAxis(axis, value * 2f - 1f);
		}
	}
	public class Joystick : MonoBehaviour, IPointerDownHandler, IEventSystemHandler, IPointerUpHandler, IDragHandler
	{
		public enum AxisOption
		{
			Both,
			OnlyHorizontal,
			OnlyVertical
		}

		public int MovementRange = 100;

		public AxisOption axesToUse;

		public string horizontalAxisName = "Horizontal";

		public string verticalAxisName = "Vertical";

		private Vector3 m_StartPos;

		private bool m_UseX;

		private bool m_UseY;

		private CrossPlatformInputManager.VirtualAxis m_HorizontalVirtualAxis;

		private CrossPlatformInputManager.VirtualAxis m_VerticalVirtualAxis;

		private void OnEnable()
		{
			CreateVirtualAxes();
		}

		private void Start()
		{
			m_StartPos = base.transform.position;
		}

		private void UpdateVirtualAxes(Vector3 value)
		{
			Vector3 vector = m_StartPos - value;
			vector.y = 0f - vector.y;
			vector /= (float)MovementRange;
			if (m_UseX)
			{
				m_HorizontalVirtualAxis.Update(0f - vector.x);
			}
			if (m_UseY)
			{
				m_VerticalVirtualAxis.Update(vector.y);
			}
		}

		private void CreateVirtualAxes()
		{
			m_UseX = axesToUse == AxisOption.Both || axesToUse == AxisOption.OnlyHorizontal;
			m_UseY = axesToUse == AxisOption.Both || axesToUse == AxisOption.OnlyVertical;
			if (m_UseX)
			{
				m_HorizontalVirtualAxis = new CrossPlatformInputManager.VirtualAxis(horizontalAxisName);
				CrossPlatformInputManager.RegisterVirtualAxis(m_HorizontalVirtualAxis);
			}
			if (m_UseY)
			{
				m_VerticalVirtualAxis = new CrossPlatformInputManager.VirtualAxis(verticalAxisName);
				CrossPlatformInputManager.RegisterVirtualAxis(m_VerticalVirtualAxis);
			}
		}

		public void OnDrag(PointerEventData data)
		{
			Vector3 zero = Vector3.zero;
			if (m_UseX)
			{
				int value = (int)(data.position.x - m_StartPos.x);
				value = Mathf.Clamp(value, -MovementRange, MovementRange);
				zero.x = value;
			}
			if (m_UseY)
			{
				int value2 = (int)(data.position.y - m_StartPos.y);
				value2 = Mathf.Clamp(value2, -MovementRange, MovementRange);
				zero.y = value2;
			}
			base.transform.position = new Vector3(m_StartPos.x + zero.x, m_StartPos.y + zero.y, m_StartPos.z + zero.z);
			UpdateVirtualAxes(base.transform.position);
		}

		public void OnPointerUp(PointerEventData data)
		{
			base.transform.position = m_StartPos;
			UpdateVirtualAxes(m_StartPos);
		}

		public void OnPointerDown(PointerEventData data)
		{
		}

		private void OnDisable()
		{
			if (m_UseX)
			{
				m_HorizontalVirtualAxis.Remove();
			}
			if (m_UseY)
			{
				m_VerticalVirtualAxis.Remove();
			}
		}
	}
	[ExecuteInEditMode]
	public class MobileControlRig : MonoBehaviour
	{
		private void OnEnable()
		{
			CheckEnableControlRig();
		}

		private void Start()
		{
			if (UnityEngine.Object.FindObjectOfType<EventSystem>() == null)
			{
				GameObject obj = new GameObject("EventSystem");
				obj.AddComponent<EventSystem>();
				obj.AddComponent<StandaloneInputModule>();
			}
		}

		private void CheckEnableControlRig()
		{
			EnableControlRig(enabled: true);
		}

		private void EnableControlRig(bool enabled)
		{
			foreach (Transform item in base.transform)
			{
				item.gameObject.SetActive(enabled);
			}
		}
	}
	public class TiltInput : MonoBehaviour
	{
		public enum AxisOptions
		{
			ForwardAxis,
			SidewaysAxis
		}

		[Serializable]
		public class AxisMapping
		{
			public enum MappingType
			{
				NamedAxis,
				MousePositionX,
				MousePositionY,
				MousePositionZ
			}

			public MappingType type;

			public string axisName;
		}

		public AxisMapping mapping;

		public AxisOptions tiltAroundAxis;

		public float fullTiltAngle = 25f;

		public float centreAngleOffset;

		private CrossPlatformInputManager.VirtualAxis m_SteerAxis;

		private void OnEnable()
		{
			if (mapping.type == AxisMapping.MappingType.NamedAxis)
			{
				m_SteerAxis = new CrossPlatformInputManager.VirtualAxis(mapping.axisName);
				CrossPlatformInputManager.RegisterVirtualAxis(m_SteerAxis);
			}
		}

		private void Update()
		{
			float value = 0f;
			if (Input.acceleration != Vector3.zero)
			{
				switch (tiltAroundAxis)
				{
				case AxisOptions.ForwardAxis:
					value = Mathf.Atan2(Input.acceleration.x, 0f - Input.acceleration.y) * 57.29578f + centreAngleOffset;
					break;
				case AxisOptions.SidewaysAxis:
					value = Mathf.Atan2(Input.acceleration.z, 0f - Input.acceleration.y) * 57.29578f + centreAngleOffset;
					break;
				}
			}
			float num = Mathf.InverseLerp(0f - fullTiltAngle, fullTiltAngle, value) * 2f - 1f;
			switch (mapping.type)
			{
			case AxisMapping.MappingType.NamedAxis:
				m_SteerAxis.Update(num);
				break;
			case AxisMapping.MappingType.MousePositionX:
				CrossPlatformInputManager.SetVirtualMousePositionX(num * (float)Screen.width);
				break;
			case AxisMapping.MappingType.MousePositionY:
				CrossPlatformInputManager.SetVirtualMousePositionY(num * (float)Screen.width);
				break;
			case AxisMapping.MappingType.MousePositionZ:
				CrossPlatformInputManager.SetVirtualMousePositionZ(num * (float)Screen.width);
				break;
			}
		}

		private void OnDisable()
		{
			m_SteerAxis.Remove();
		}
	}
	[RequireComponent(typeof(Image))]
	public class TouchPad : MonoBehaviour, IPointerDownHandler, IEventSystemHandler, IPointerUpHandler
	{
		public enum AxisOption
		{
			Both,
			OnlyHorizontal,
			OnlyVertical
		}

		public enum ControlStyle
		{
			Absolute,
			Relative,
			Swipe
		}

		public AxisOption axesToUse;

		public ControlStyle controlStyle;

		public string horizontalAxisName = "Horizontal";

		public string verticalAxisName = "Vertical";

		public float Xsensitivity = 1f;

		public float Ysensitivity = 1f;

		private Vector3 m_StartPos;

		private Vector2 m_PreviousDelta;

		private Vector3 m_JoytickOutput;

		private bool m_UseX;

		private bool m_UseY;

		private CrossPlatformInputManager.VirtualAxis m_HorizontalVirtualAxis;

		private CrossPlatformInputManager.VirtualAxis m_VerticalVirtualAxis;

		private bool m_Dragging;

		private int m_Id = -1;

		private Vector2 m_PreviousTouchPos;

		private Vector3 m_Center;

		private Image m_Image;

		private void OnEnable()
		{
			CreateVirtualAxes();
		}

		private void Start()
		{
			m_Image = GetComponent<Image>();
			m_Center = m_Image.transform.position;
		}

		private void CreateVirtualAxes()
		{
			m_UseX = axesToUse == AxisOption.Both || axesToUse == AxisOption.OnlyHorizontal;
			m_UseY = axesToUse == AxisOption.Both || axesToUse == AxisOption.OnlyVertical;
			if (m_UseX)
			{
				m_HorizontalVirtualAxis = new CrossPlatformInputManager.VirtualAxis(horizontalAxisName);
				CrossPlatformInputManager.RegisterVirtualAxis(m_HorizontalVirtualAxis);
			}
			if (m_UseY)
			{
				m_VerticalVirtualAxis = new CrossPlatformInputManager.VirtualAxis(verticalAxisName);
				CrossPlatformInputManager.RegisterVirtualAxis(m_VerticalVirtualAxis);
			}
		}

		private void UpdateVirtualAxes(Vector3 value)
		{
			value = value.normalized;
			if (m_UseX)
			{
				m_HorizontalVirtualAxis.Update(value.x);
			}
			if (m_UseY)
			{
				m_VerticalVirtualAxis.Update(value.y);
			}
		}

		public void OnPointerDown(PointerEventData data)
		{
			m_Dragging = true;
			m_Id = data.pointerId;
			if (controlStyle != 0)
			{
				m_Center = data.position;
			}
		}

		private void Update()
		{
			if (m_Dragging && Input.touchCount >= m_Id + 1 && m_Id != -1)
			{
				if (controlStyle == ControlStyle.Swipe)
				{
					m_Center = m_PreviousTouchPos;
					m_PreviousTouchPos = Input.touches[m_Id].position;
				}
				Vector2 normalized = new Vector2(Input.touches[m_Id].position.x - m_Center.x, Input.touches[m_Id].position.y - m_Center.y).normalized;
				normalized.x *= Xsensitivity;
				normalized.y *= Ysensitivity;
				UpdateVirtualAxes(new Vector3(normalized.x, normalized.y, 0f));
			}
		}

		public void OnPointerUp(PointerEventData data)
		{
			m_Dragging = false;
			m_Id = -1;
			UpdateVirtualAxes(Vector3.zero);
		}

		private void OnDisable()
		{
			if (CrossPlatformInputManager.AxisExists(horizontalAxisName))
			{
				CrossPlatformInputManager.UnRegisterVirtualAxis(horizontalAxisName);
			}
			if (CrossPlatformInputManager.AxisExists(verticalAxisName))
			{
				CrossPlatformInputManager.UnRegisterVirtualAxis(verticalAxisName);
			}
		}
	}
	public abstract class VirtualInput
	{
		protected Dictionary<string, CrossPlatformInputManager.VirtualAxis> m_VirtualAxes = new Dictionary<string, CrossPlatformInputManager.VirtualAxis>();

		protected Dictionary<string, CrossPlatformInputManager.VirtualButton> m_VirtualButtons = new Dictionary<string, CrossPlatformInputManager.VirtualButton>();

		protected List<string> m_AlwaysUseVirtual = new List<string>();

		public Vector3 virtualMousePosition { get; private set; }

		public bool AxisExists(string name)
		{
			return m_VirtualAxes.ContainsKey(name);
		}

		public bool ButtonExists(string name)
		{
			return m_VirtualButtons.ContainsKey(name);
		}

		public void RegisterVirtualAxis(CrossPlatformInputManager.VirtualAxis axis)
		{
			if (m_VirtualAxes.ContainsKey(axis.name))
			{
				UnityEngine.Debug.LogError("There is already a virtual axis named " + axis.name + " registered.");
				return;
			}
			m_VirtualAxes.Add(axis.name, axis);
			if (!axis.matchWithInputManager)
			{
				m_AlwaysUseVirtual.Add(axis.name);
			}
		}

		public void RegisterVirtualButton(CrossPlatformInputManager.VirtualButton button)
		{
			if (m_VirtualButtons.ContainsKey(button.name))
			{
				UnityEngine.Debug.LogError("There is already a virtual button named " + button.name + " registered.");
				return;
			}
			m_VirtualButtons.Add(button.name, button);
			if (!button.matchWithInputManager)
			{
				m_AlwaysUseVirtual.Add(button.name);
			}
		}

		public void UnRegisterVirtualAxis(string name)
		{
			if (m_VirtualAxes.ContainsKey(name))
			{
				m_VirtualAxes.Remove(name);
			}
		}

		public void UnRegisterVirtualButton(string name)
		{
			if (m_VirtualButtons.ContainsKey(name))
			{
				m_VirtualButtons.Remove(name);
			}
		}

		public CrossPlatformInputManager.VirtualAxis VirtualAxisReference(string name)
		{
			if (!m_VirtualAxes.ContainsKey(name))
			{
				return null;
			}
			return m_VirtualAxes[name];
		}

		public void SetVirtualMousePositionX(float f)
		{
			virtualMousePosition = new Vector3(f, virtualMousePosition.y, virtualMousePosition.z);
		}

		public void SetVirtualMousePositionY(float f)
		{
			virtualMousePosition = new Vector3(virtualMousePosition.x, f, virtualMousePosition.z);
		}

		public void SetVirtualMousePositionZ(float f)
		{
			virtualMousePosition = new Vector3(virtualMousePosition.x, virtualMousePosition.y, f);
		}

		public abstract float GetAxis(string name, bool raw);

		public abstract bool GetButton(string name);

		public abstract bool GetButtonDown(string name);

		public abstract bool GetButtonUp(string name);

		public abstract void SetButtonDown(string name);

		public abstract void SetButtonUp(string name);

		public abstract void SetAxisPositive(string name);

		public abstract void SetAxisNegative(string name);

		public abstract void SetAxisZero(string name);

		public abstract void SetAxis(string name, float value);

		public abstract Vector3 MousePosition();
	}
}
namespace UnityStandardAssets.CrossPlatformInput.PlatformSpecific
{
	public class MobileInput : VirtualInput
	{
		private void AddButton(string name)
		{
			CrossPlatformInputManager.RegisterVirtualButton(new CrossPlatformInputManager.VirtualButton(name));
		}

		private void AddAxes(string name)
		{
			CrossPlatformInputManager.RegisterVirtualAxis(new CrossPlatformInputManager.VirtualAxis(name));
		}

		public override float GetAxis(string name, bool raw)
		{
			if (!m_VirtualAxes.ContainsKey(name))
			{
				AddAxes(name);
			}
			return m_VirtualAxes[name].GetValue;
		}

		public override void SetButtonDown(string name)
		{
			if (!m_VirtualButtons.ContainsKey(name))
			{
				AddButton(name);
			}
			m_VirtualButtons[name].Pressed();
		}

		public override void SetButtonUp(string name)
		{
			if (!m_VirtualButtons.ContainsKey(name))
			{
				AddButton(name);
			}
			m_VirtualButtons[name].Released();
		}

		public override void SetAxisPositive(string name)
		{
			if (!m_VirtualAxes.ContainsKey(name))
			{
				AddAxes(name);
			}
			m_VirtualAxes[name].Update(1f);
		}

		public override void SetAxisNegative(string name)
		{
			if (!m_VirtualAxes.ContainsKey(name))
			{
				AddAxes(name);
			}
			m_VirtualAxes[name].Update(-1f);
		}

		public override void SetAxisZero(string name)
		{
			if (!m_VirtualAxes.ContainsKey(name))
			{
				AddAxes(name);
			}
			m_VirtualAxes[name].Update(0f);
		}

		public override void SetAxis(string name, float value)
		{
			if (!m_VirtualAxes.ContainsKey(name))
			{
				AddAxes(name);
			}
			m_VirtualAxes[name].Update(value);
		}

		public override bool GetButtonDown(string name)
		{
			if (m_VirtualButtons.ContainsKey(name))
			{
				return m_VirtualButtons[name].GetButtonDown;
			}
			AddButton(name);
			return m_VirtualButtons[name].GetButtonDown;
		}

		public override bool GetButtonUp(string name)
		{
			if (m_VirtualButtons.ContainsKey(name))
			{
				return m_VirtualButtons[name].GetButtonUp;
			}
			AddButton(name);
			return m_VirtualButtons[name].GetButtonUp;
		}

		public override bool GetButton(string name)
		{
			if (m_VirtualButtons.ContainsKey(name))
			{
				return m_VirtualButtons[name].GetButton;
			}
			AddButton(name);
			return m_VirtualButtons[name].GetButton;
		}

		public override Vector3 MousePosition()
		{
			return base.virtualMousePosition;
		}
	}
	public class StandaloneInput : VirtualInput
	{
		public override float GetAxis(string name, bool raw)
		{
			if (!raw)
			{
				return Input.GetAxis(name);
			}
			return Input.GetAxisRaw(name);
		}

		public override bool GetButton(string name)
		{
			return Input.GetButton(name);
		}

		public override bool GetButtonDown(string name)
		{
			return Input.GetButtonDown(name);
		}

		public override bool GetButtonUp(string name)
		{
			return Input.GetButtonUp(name);
		}

		public override void SetButtonDown(string name)
		{
			throw new Exception(" This is not possible to be called for standalone input. Please check your platform and code where this is called");
		}

		public override void SetButtonUp(string name)
		{
			throw new Exception(" This is not possible to be called for standalone input. Please check your platform and code where this is called");
		}

		public override void SetAxisPositive(string name)
		{
			throw new Exception(" This is not possible to be called for standalone input. Please check your platform and code where this is called");
		}

		public override void SetAxisNegative(string name)
		{
			throw new Exception(" This is not possible to be called for standalone input. Please check your platform and code where this is called");
		}

		public override void SetAxisZero(string name)
		{
			throw new Exception(" This is not possible to be called for standalone input. Please check your platform and code where this is called");
		}

		public override void SetAxis(string name, float value)
		{
			throw new Exception(" This is not possible to be called for standalone input. Please check your platform and code where this is called");
		}

		public override Vector3 MousePosition()
		{
			return Input.mousePosition;
		}
	}
}
namespace UnityStandardAssets.Vehicles.Ball
{
	public class Ball : MonoBehaviour
	{
		[SerializeField]
		private float m_MovePower = 5f;

		[SerializeField]
		private bool m_UseTorque = true;

		[SerializeField]
		private float m_MaxAngularVelocity = 25f;

		[SerializeField]
		private float m_JumpPower = 2f;

		private const float k_GroundRayLength = 1f;

		private Rigidbody m_Rigidbody;

		private void Start()
		{
			m_Rigidbody = GetComponent<Rigidbody>();
			GetComponent<Rigidbody>().maxAngularVelocity = m_MaxAngularVelocity;
		}

		public void Move(Vector3 moveDirection, bool jump)
		{
			if (m_UseTorque)
			{
				m_Rigidbody.AddTorque(new Vector3(moveDirection.z, 0f, 0f - moveDirection.x) * m_MovePower);
			}
			else
			{
				m_Rigidbody.AddForce(moveDirection * m_MovePower);
			}
			if (Physics.Raycast(base.transform.position, -Vector3.up, 1f) && jump)
			{
				m_Rigidbody.AddForce(Vector3.up * m_JumpPower, ForceMode.Impulse);
			}
		}
	}
	public class BallUserControl : MonoBehaviour
	{
		private Ball ball;

		private Vector3 move;

		private Transform cam;

		private Vector3 camForward;

		private bool jump;

		private void Awake()
		{
			ball = GetComponent<Ball>();
			if (Camera.main != null)
			{
				cam = Camera.main.transform;
			}
			else
			{
				UnityEngine.Debug.LogWarning("Warning: no main camera found. Ball needs a Camera tagged \"MainCamera\", for camera-relative controls.");
			}
		}

		private void Update()
		{
			float axis = CrossPlatformInputManager.GetAxis("Horizontal");
			float axis2 = CrossPlatformInputManager.GetAxis("Vertical");
			jump = CrossPlatformInputManager.GetButton("Jump");
			if (cam != null)
			{
				camForward = Vector3.Scale(cam.forward, new Vector3(1f, 0f, 1f)).normalized;
				move = (axis2 * camForward + axis * cam.right).normalized;
			}
			else
			{
				move = (axis2 * Vector3.forward + axis * Vector3.right).normalized;
			}
		}

		private void FixedUpdate()
		{
			ball.Move(move, jump);
			jump = false;
		}
	}
}
namespace UnityStandardAssets.Characters.ThirdPerson
{
	[RequireComponent(typeof(NavMeshAgent))]
	[RequireComponent(typeof(ThirdPersonCharacter))]
	public class AICharacterControl : MonoBehaviour
	{
		public Transform target;

		public NavMeshAgent agent { get; private set; }

		public ThirdPersonCharacter character { get; private set; }

		private void Start()
		{
			agent = GetComponentInChildren<NavMeshAgent>();
			character = GetComponent<ThirdPersonCharacter>();
			agent.updateRotation = false;
			agent.updatePosition = true;
		}

		private void Update()
		{
			if (target != null)
			{
				agent.SetDestination(target.position);
			}
			if (agent.remainingDistance > agent.stoppingDistance)
			{
				character.Move(agent.desiredVelocity, crouch: false, jump: false);
			}
			else
			{
				character.Move(Vector3.zero, crouch: false, jump: false);
			}
		}

		public void SetTarget(Transform target)
		{
			this.target = target;
		}
	}
	[RequireComponent(typeof(Rigidbody))]
	[RequireComponent(typeof(CapsuleCollider))]
	[RequireComponent(typeof(Animator))]
	public class ThirdPersonCharacter : MonoBehaviour
	{
		[SerializeField]
		private float m_MovingTurnSpeed = 360f;

		[SerializeField]
		private float m_StationaryTurnSpeed = 180f;

		[SerializeField]
		private float m_JumpPower = 12f;

		[Range(1f, 4f)]
		[SerializeField]
		private float m_GravityMultiplier = 2f;

		[SerializeField]
		private float m_RunCycleLegOffset = 0.2f;

		[SerializeField]
		private float m_MoveSpeedMultiplier = 1f;

		[SerializeField]
		private float m_AnimSpeedMultiplier = 1f;

		[SerializeField]
		private float m_GroundCheckDistance = 0.1f;

		private Rigidbody m_Rigidbody;

		private Animator m_Animator;

		private bool m_IsGrounded;

		private float m_OrigGroundCheckDistance;

		private const float k_Half = 0.5f;

		private float m_TurnAmount;

		private float m_ForwardAmount;

		private Vector3 m_GroundNormal;

		private float m_CapsuleHeight;

		private Vector3 m_CapsuleCenter;

		private CapsuleCollider m_Capsule;

		private bool m_Crouching;

		private void Start()
		{
			m_Animator = GetComponent<Animator>();
			m_Rigidbody = GetComponent<Rigidbody>();
			m_Capsule = GetComponent<CapsuleCollider>();
			m_CapsuleHeight = m_Capsule.height;
			m_CapsuleCenter = m_Capsule.center;
			m_Rigidbody.constraints = RigidbodyConstraints.FreezeRotation;
			m_OrigGroundCheckDistance = m_GroundCheckDistance;
		}

		public void Move(Vector3 move, bool crouch, bool jump)
		{
			if (move.magnitude > 1f)
			{
				move.Normalize();
			}
			move = base.transform.InverseTransformDirection(move);
			CheckGroundStatus();
			move = Vector3.ProjectOnPlane(move, m_GroundNormal);
			m_TurnAmount = Mathf.Atan2(move.x, move.z);
			m_ForwardAmount = move.z;
			ApplyExtraTurnRotation();
			if (m_IsGrounded)
			{
				HandleGroundedMovement(crouch, jump);
			}
			else
			{
				HandleAirborneMovement();
			}
			ScaleCapsuleForCrouching(crouch);
			PreventStandingInLowHeadroom();
			UpdateAnimator(move);
		}

		private void ScaleCapsuleForCrouching(bool crouch)
		{
			if (m_IsGrounded && crouch)
			{
				if (!m_Crouching)
				{
					m_Capsule.height /= 2f;
					m_Capsule.center /= 2f;
					m_Crouching = true;
				}
			}
			else if (Physics.SphereCast(new Ray(m_Rigidbody.position + Vector3.up * m_Capsule.radius * 0.5f, Vector3.up), maxDistance: m_CapsuleHeight - m_Capsule.radius * 0.5f, radius: m_Capsule.radius * 0.5f, layerMask: -1, queryTriggerInteraction: QueryTriggerInteraction.Ignore))
			{
				m_Crouching = true;
			}
			else
			{
				m_Capsule.height = m_CapsuleHeight;
				m_Capsule.center = m_CapsuleCenter;
				m_Crouching = false;
			}
		}

		private void PreventStandingInLowHeadroom()
		{
			if (!m_Crouching && Physics.SphereCast(new Ray(m_Rigidbody.position + Vector3.up * m_Capsule.radius * 0.5f, Vector3.up), maxDistance: m_CapsuleHeight - m_Capsule.radius * 0.5f, radius: m_Capsule.radius * 0.5f, layerMask: -1, queryTriggerInteraction: QueryTriggerInteraction.Ignore))
			{
				m_Crouching = true;
			}
		}

		private void UpdateAnimator(Vector3 move)
		{
			m_Animator.SetFloat("Forward", m_ForwardAmount, 0.1f, Time.deltaTime);
			m_Animator.SetFloat("Turn", m_TurnAmount, 0.1f, Time.deltaTime);
			m_Animator.SetBool("Crouch", m_Crouching);
			m_Animator.SetBool("OnGround", m_IsGrounded);
			if (!m_IsGrounded)
			{
				m_Animator.SetFloat("Jump", m_Rigidbody.velocity.y);
			}
			float value = (float)((Mathf.Repeat(m_Animator.GetCurrentAnimatorStateInfo(0).normalizedTime + m_RunCycleLegOffset, 1f) < 0.5f) ? 1 : (-1)) * m_ForwardAmount;
			if (m_IsGrounded)
			{
				m_Animator.SetFloat("JumpLeg", value);
			}
			if (m_IsGrounded && move.magnitude > 0f)
			{
				m_Animator.speed = m_AnimSpeedMultiplier;
			}
			else
			{
				m_Animator.speed = 1f;
			}
		}

		private void HandleAirborneMovement()
		{
			Vector3 force = Physics.gravity * m_GravityMultiplier - Physics.gravity;
			m_Rigidbody.AddForce(force);
			m_GroundCheckDistance = ((m_Rigidbody.velocity.y < 0f) ? m_OrigGroundCheckDistance : 0.01f);
		}

		private void HandleGroundedMovement(bool crouch, bool jump)
		{
			if (jump && !crouch && m_Animator.GetCurrentAnimatorStateInfo(0).IsName("Grounded"))
			{
				m_Rigidbody.velocity = new Vector3(m_Rigidbody.velocity.x, m_JumpPower, m_Rigidbody.velocity.z);
				m_IsGrounded = false;
				m_Animator.applyRootMotion = false;
				m_GroundCheckDistance = 0.1f;
			}
		}

		private void ApplyExtraTurnRotation()
		{
			float num = Mathf.Lerp(m_StationaryTurnSpeed, m_MovingTurnSpeed, m_ForwardAmount);
			base.transform.Rotate(0f, m_TurnAmount * num * Time.deltaTime, 0f);
		}

		public void OnAnimatorMove()
		{
			if (m_IsGrounded && Time.deltaTime > 0f)
			{
				Vector3 velocity = m_Animator.deltaPosition * m_MoveSpeedMultiplier / Time.deltaTime;
				velocity.y = m_Rigidbody.velocity.y;
				m_Rigidbody.velocity = velocity;
			}
		}

		private void CheckGroundStatus()
		{
			if (Physics.Raycast(base.transform.position + Vector3.up * 0.1f, Vector3.down, out var hitInfo, m_GroundCheckDistance))
			{
				m_GroundNormal = hitInfo.normal;
				m_IsGrounded = true;
				m_Animator.applyRootMotion = true;
			}
			else
			{
				m_IsGrounded = false;
				m_GroundNormal = Vector3.up;
				m_Animator.applyRootMotion = false;
			}
		}
	}
	[RequireComponent(typeof(ThirdPersonCharacter))]
	public class ThirdPersonUserControl : MonoBehaviour
	{
		private ThirdPersonCharacter m_Character;

		private Transform m_Cam;

		private Vector3 m_CamForward;

		private Vector3 m_Move;

		private bool m_Jump;

		private void Start()
		{
			if (Camera.main != null)
			{
				m_Cam = Camera.main.transform;
			}
			else
			{
				UnityEngine.Debug.LogWarning("Warning: no main camera found. Third person character needs a Camera tagged \"MainCamera\", for camera-relative controls.", base.gameObject);
			}
			m_Character = GetComponent<ThirdPersonCharacter>();
		}

		private void Update()
		{
			if (!m_Jump)
			{
				m_Jump = CrossPlatformInputManager.GetButtonDown("Jump");
			}
		}

		private void FixedUpdate()
		{
			float axis = CrossPlatformInputManager.GetAxis("Horizontal");
			float axis2 = CrossPlatformInputManager.GetAxis("Vertical");
			bool key = Input.GetKey(KeyCode.C);
			if (m_Cam != null)
			{
				m_CamForward = Vector3.Scale(m_Cam.forward, new Vector3(1f, 0f, 1f)).normalized;
				m_Move = axis2 * m_CamForward + axis * m_Cam.right;
			}
			else
			{
				m_Move = axis2 * Vector3.forward + axis * Vector3.right;
			}
			m_Character.Move(m_Move, key, m_Jump);
			m_Jump = false;
		}
	}
}
namespace UnityStandardAssets.Characters.FirstPerson
{
	[RequireComponent(typeof(CharacterController))]
	[RequireComponent(typeof(AudioSource))]
	public class FirstPersonController : MonoBehaviour
	{
		[SerializeField]
		private bool m_IsWalking;

		[SerializeField]
		private float m_WalkSpeed;

		[SerializeField]
		private float m_RunSpeed;

		[SerializeField]
		[Range(0f, 1f)]
		private float m_RunstepLenghten;

		[SerializeField]
		private float m_JumpSpeed;

		[SerializeField]
		private float m_StickToGroundForce;

		[SerializeField]
		private float m_GravityMultiplier;

		[SerializeField]
		private MouseLook m_MouseLook;

		[SerializeField]
		private bool m_UseFovKick;

		[SerializeField]
		private FOVKick m_FovKick = new FOVKick();

		[SerializeField]
		private bool m_UseHeadBob;

		[SerializeField]
		private CurveControlledBob m_HeadBob = new CurveControlledBob();

		[SerializeField]
		private LerpControlledBob m_JumpBob = new LerpControlledBob();

		[SerializeField]
		private float m_StepInterval;

		[SerializeField]
		private AudioClip[] m_FootstepSounds;

		[SerializeField]
		private AudioClip m_JumpSound;

		[SerializeField]
		private AudioClip m_LandSound;

		private Camera m_Camera;

		private bool m_Jump;

		private float m_YRotation;

		private Vector2 m_Input;

		private Vector3 m_MoveDir = Vector3.zero;

		private CharacterController m_CharacterController;

		private CollisionFlags m_CollisionFlags;

		private bool m_PreviouslyGrounded;

		private Vector3 m_OriginalCameraPosition;

		private float m_StepCycle;

		private float m_NextStep;

		private bool m_Jumping;

		private AudioSource m_AudioSource;

		private void Start()
		{
			m_CharacterController = GetComponent<CharacterController>();
			m_Camera = Camera.main;
			m_OriginalCameraPosition = m_Camera.transform.localPosition;
			m_FovKick.Setup(m_Camera);
			m_HeadBob.Setup(m_Camera, m_StepInterval);
			m_StepCycle = 0f;
			m_NextStep = m_StepCycle / 2f;
			m_Jumping = false;
			m_AudioSource = GetComponent<AudioSource>();
			m_MouseLook.Init(base.transform, m_Camera.transform);
		}

		private void Update()
		{
			RotateView();
			if (!m_Jump)
			{
				m_Jump = CrossPlatformInputManager.GetButtonDown("Jump");
			}
			if (!m_PreviouslyGrounded && m_CharacterController.isGrounded)
			{
				StartCoroutine(m_JumpBob.DoBobCycle());
				PlayLandingSound();
				m_MoveDir.y = 0f;
				m_Jumping = false;
			}
			if (!m_CharacterController.isGrounded && !m_Jumping && m_PreviouslyGrounded)
			{
				m_MoveDir.y = 0f;
			}
			m_PreviouslyGrounded = m_CharacterController.isGrounded;
		}

		private void PlayLandingSound()
		{
			m_AudioSource.clip = m_LandSound;
			m_AudioSource.Play();
			m_NextStep = m_StepCycle + 0.5f;
		}

		private void FixedUpdate()
		{
			GetInput(out var speed);
			Vector3 vector = base.transform.forward * m_Input.y + base.transform.right * m_Input.x;
			Physics.SphereCast(base.transform.position, m_CharacterController.radius, Vector3.down, out var hitInfo, m_CharacterController.height / 2f, -1, QueryTriggerInteraction.Ignore);
			vector = Vector3.ProjectOnPlane(vector, hitInfo.normal).normalized;
			m_MoveDir.x = vector.x * speed;
			m_MoveDir.z = vector.z * speed;
			if (m_CharacterController.isGrounded)
			{
				m_MoveDir.y = 0f - m_StickToGroundForce;
				if (m_Jump)
				{
					m_MoveDir.y = m_JumpSpeed;
					PlayJumpSound();
					m_Jump = false;
					m_Jumping = true;
				}
			}
			else
			{
				m_MoveDir += Physics.gravity * m_GravityMultiplier * Time.fixedDeltaTime;
			}
			m_CollisionFlags = m_CharacterController.Move(m_MoveDir * Time.fixedDeltaTime);
			ProgressStepCycle(speed);
			UpdateCameraPosition(speed);
			m_MouseLook.UpdateCursorLock();
		}

		private void PlayJumpSound()
		{
			m_AudioSource.clip = m_JumpSound;
			m_AudioSource.Play();
		}

		private void ProgressStepCycle(float speed)
		{
			if (m_CharacterController.velocity.sqrMagnitude > 0f && (m_Input.x != 0f || m_Input.y != 0f))
			{
				m_StepCycle += (m_CharacterController.velocity.magnitude + speed * (m_IsWalking ? 1f : m_RunstepLenghten)) * Time.fixedDeltaTime;
			}
			if (m_StepCycle > m_NextStep)
			{
				m_NextStep = m_StepCycle + m_StepInterval;
				PlayFootStepAudio();
			}
		}

		private void PlayFootStepAudio()
		{
			if (m_CharacterController.isGrounded)
			{
				int num = UnityEngine.Random.Range(1, m_FootstepSounds.Length);
				m_AudioSource.clip = m_FootstepSounds[num];
				m_AudioSource.PlayOneShot(m_AudioSource.clip);
				m_FootstepSounds[num] = m_FootstepSounds[0];
				m_FootstepSounds[0] = m_AudioSource.clip;
			}
		}

		private void UpdateCameraPosition(float speed)
		{
			if (m_UseHeadBob)
			{
				Vector3 localPosition;
				if (m_CharacterController.velocity.magnitude > 0f && m_CharacterController.isGrounded)
				{
					m_Camera.transform.localPosition = m_HeadBob.DoHeadBob(m_CharacterController.velocity.magnitude + speed * (m_IsWalking ? 1f : m_RunstepLenghten));
					localPosition = m_Camera.transform.localPosition;
					localPosition.y = m_Camera.transform.localPosition.y - m_JumpBob.Offset();
				}
				else
				{
					localPosition = m_Camera.transform.localPosition;
					localPosition.y = m_OriginalCameraPosition.y - m_JumpBob.Offset();
				}
				m_Camera.transform.localPosition = localPosition;
			}
		}

		private void GetInput(out float speed)
		{
			float axis = CrossPlatformInputManager.GetAxis("Horizontal");
			float axis2 = CrossPlatformInputManager.GetAxis("Vertical");
			bool isWalking = m_IsWalking;
			speed = (m_IsWalking ? m_WalkSpeed : m_RunSpeed);
			m_Input = new Vector2(axis, axis2);
			if (m_Input.sqrMagnitude > 1f)
			{
				m_Input.Normalize();
			}
			if (m_IsWalking != isWalking && m_UseFovKick && m_CharacterController.velocity.sqrMagnitude > 0f)
			{
				StopAllCoroutines();
				StartCoroutine((!m_IsWalking) ? m_FovKick.FOVKickUp() : m_FovKick.FOVKickDown());
			}
		}

		private void RotateView()
		{
			m_MouseLook.LookRotation(base.transform, m_Camera.transform);
		}

		private void OnControllerColliderHit(ControllerColliderHit hit)
		{
			Rigidbody attachedRigidbody = hit.collider.attachedRigidbody;
			if (m_CollisionFlags != CollisionFlags.Below && !(attachedRigidbody == null) && !attachedRigidbody.isKinematic)
			{
				attachedRigidbody.AddForceAtPosition(m_CharacterController.velocity * 0.1f, hit.point, ForceMode.Impulse);
			}
		}
	}
	public class HeadBob : MonoBehaviour
	{
		public Camera Camera;

		public CurveControlledBob motionBob = new CurveControlledBob();

		public LerpControlledBob jumpAndLandingBob = new LerpControlledBob();

		public RigidbodyFirstPersonController rigidbodyFirstPersonController;

		public float StrideInterval;

		[Range(0f, 1f)]
		public float RunningStrideLengthen;

		private bool m_PreviouslyGrounded;

		private Vector3 m_OriginalCameraPosition;

		private void Start()
		{
			motionBob.Setup(Camera, StrideInterval);
			m_OriginalCameraPosition = Camera.transform.localPosition;
		}

		private void Update()
		{
			Vector3 localPosition;
			if (rigidbodyFirstPersonController.Velocity.magnitude > 0f && rigidbodyFirstPersonController.Grounded)
			{
				Camera.transform.localPosition = motionBob.DoHeadBob(rigidbodyFirstPersonController.Velocity.magnitude * (rigidbodyFirstPersonController.Running ? RunningStrideLengthen : 1f));
				localPosition = Camera.transform.localPosition;
				localPosition.y = Camera.transform.localPosition.y - jumpAndLandingBob.Offset();
			}
			else
			{
				localPosition = Camera.transform.localPosition;
				localPosition.y = m_OriginalCameraPosition.y - jumpAndLandingBob.Offset();
			}
			Camera.transform.localPosition = localPosition;
			if (!m_PreviouslyGrounded && rigidbodyFirstPersonController.Grounded)
			{
				StartCoroutine(jumpAndLandingBob.DoBobCycle());
			}
			m_PreviouslyGrounded = rigidbodyFirstPersonController.Grounded;
		}
	}
	[Serializable]
	public class MouseLook
	{
		public float XSensitivity = 2f;

		public float YSensitivity = 2f;

		public bool clampVerticalRotation = true;

		public float MinimumX = -90f;

		public float MaximumX = 90f;

		public bool smooth;

		public float smoothTime = 5f;

		public bool lockCursor = true;

		private Quaternion m_CharacterTargetRot;

		private Quaternion m_CameraTargetRot;

		private bool m_cursorIsLocked = true;

		public void Init(Transform character, Transform camera)
		{
			m_CharacterTargetRot = character.localRotation;
			m_CameraTargetRot = camera.localRotation;
		}

		public void LookRotation(Transform character, Transform camera)
		{
			float y = CrossPlatformInputManager.GetAxis("Mouse X") * XSensitivity;
			float num = CrossPlatformInputManager.GetAxis("Mouse Y") * YSensitivity;
			m_CharacterTargetRot *= Quaternion.Euler(0f, y, 0f);
			m_CameraTargetRot *= Quaternion.Euler(0f - num, 0f, 0f);
			if (clampVerticalRotation)
			{
				m_CameraTargetRot = ClampRotationAroundXAxis(m_CameraTargetRot);
			}
			if (smooth)
			{
				character.localRotation = Quaternion.Slerp(character.localRotation, m_CharacterTargetRot, smoothTime * Time.deltaTime);
				camera.localRotation = Quaternion.Slerp(camera.localRotation, m_CameraTargetRot, smoothTime * Time.deltaTime);
			}
			else
			{
				character.localRotation = m_CharacterTargetRot;
				camera.localRotation = m_CameraTargetRot;
			}
			UpdateCursorLock();
		}

		public void SetCursorLock(bool value)
		{
			lockCursor = value;
			if (!lockCursor)
			{
				Cursor.lockState = CursorLockMode.None;
				Cursor.visible = true;
			}
		}

		public void UpdateCursorLock()
		{
			if (lockCursor)
			{
				InternalLockUpdate();
			}
		}

		private void InternalLockUpdate()
		{
			if (Input.GetKeyUp(KeyCode.Escape))
			{
				m_cursorIsLocked = false;
			}
			else if (Input.GetMouseButtonUp(0))
			{
				m_cursorIsLocked = true;
			}
			if (m_cursorIsLocked)
			{
				Cursor.lockState = CursorLockMode.Locked;
				Cursor.visible = false;
			}
			else if (!m_cursorIsLocked)
			{
				Cursor.lockState = CursorLockMode.None;
				Cursor.visible = true;
			}
		}

		private Quaternion ClampRotationAroundXAxis(Quaternion q)
		{
			q.x /= q.w;
			q.y /= q.w;
			q.z /= q.w;
			q.w = 1f;
			float value = 114.59156f * Mathf.Atan(q.x);
			value = Mathf.Clamp(value, MinimumX, MaximumX);
			q.x = Mathf.Tan((float)Math.PI / 360f * value);
			return q;
		}
	}
	[RequireComponent(typeof(Rigidbody))]
	[RequireComponent(typeof(CapsuleCollider))]
	public class RigidbodyFirstPersonController : MonoBehaviour
	{
		[Serializable]
		public class MovementSettings
		{
			public float ForwardSpeed = 8f;

			public float BackwardSpeed = 4f;

			public float StrafeSpeed = 4f;

			public float RunMultiplier = 2f;

			public KeyCode RunKey = KeyCode.LeftShift;

			public float JumpForce = 30f;

			public AnimationCurve SlopeCurveModifier = new AnimationCurve(new Keyframe(-90f, 1f), new Keyframe(0f, 1f), new Keyframe(90f, 0f));

			[HideInInspector]
			public float CurrentTargetSpeed = 8f;

			public void UpdateDesiredTargetSpeed(Vector2 input)
			{
				if (!(input == Vector2.zero))
				{
					if (input.x > 0f || input.x < 0f)
					{
						CurrentTargetSpeed = StrafeSpeed;
					}
					if (input.y < 0f)
					{
						CurrentTargetSpeed = BackwardSpeed;
					}
					if (input.y > 0f)
					{
						CurrentTargetSpeed = ForwardSpeed;
					}
				}
			}
		}

		[Serializable]
		public class AdvancedSettings
		{
			public float groundCheckDistance = 0.01f;

			public float stickToGroundHelperDistance = 0.5f;

			public float slowDownRate = 20f;

			public bool airControl;

			[Tooltip("set it to 0.1 or more if you get stuck in wall")]
			public float shellOffset;
		}

		public Camera cam;

		public MovementSettings movementSettings = new MovementSettings();

		public MouseLook mouseLook = new MouseLook();

		public AdvancedSettings advancedSettings = new AdvancedSettings();

		private Rigidbody m_RigidBody;

		private CapsuleCollider m_Capsule;

		private float m_YRotation;

		private Vector3 m_GroundContactNormal;

		private bool m_Jump;

		private bool m_PreviouslyGrounded;

		private bool m_Jumping;

		private bool m_IsGrounded;

		public Vector3 Velocity => m_RigidBody.velocity;

		public bool Grounded => m_IsGrounded;

		public bool Jumping => m_Jumping;

		public bool Running => false;

		private void Start()
		{
			m_RigidBody = GetComponent<Rigidbody>();
			m_Capsule = GetComponent<CapsuleCollider>();
			mouseLook.Init(base.transform, cam.transform);
		}

		private void Update()
		{
			RotateView();
			if (CrossPlatformInputManager.GetButtonDown("Jump") && !m_Jump)
			{
				m_Jump = true;
			}
		}

		private void FixedUpdate()
		{
			GroundCheck();
			Vector2 input = GetInput();
			if ((Mathf.Abs(input.x) > float.Epsilon || Mathf.Abs(input.y) > float.Epsilon) && (advancedSettings.airControl || m_IsGrounded))
			{
				Vector3 vector = cam.transform.forward * input.y + cam.transform.right * input.x;
				vector = Vector3.ProjectOnPlane(vector, m_GroundContactNormal).normalized;
				vector.x *= movementSettings.CurrentTargetSpeed;
				vector.z *= movementSettings.CurrentTargetSpeed;
				vector.y *= movementSettings.CurrentTargetSpeed;
				if (m_RigidBody.velocity.sqrMagnitude < movementSettings.CurrentTargetSpeed * movementSettings.CurrentTargetSpeed)
				{
					m_RigidBody.AddForce(vector * SlopeMultiplier(), ForceMode.Impulse);
				}
			}
			if (m_IsGrounded)
			{
				m_RigidBody.drag = 5f;
				if (m_Jump)
				{
					m_RigidBody.drag = 0f;
					m_RigidBody.velocity = new Vector3(m_RigidBody.velocity.x, 0f, m_RigidBody.velocity.z);
					m_RigidBody.AddForce(new Vector3(0f, movementSettings.JumpForce, 0f), ForceMode.Impulse);
					m_Jumping = true;
				}
				if (!m_Jumping && Mathf.Abs(input.x) < float.Epsilon && Mathf.Abs(input.y) < float.Epsilon && m_RigidBody.velocity.magnitude < 1f)
				{
					m_RigidBody.Sleep();
				}
			}
			else
			{
				m_RigidBody.drag = 0f;
				if (m_PreviouslyGrounded && !m_Jumping)
				{
					StickToGroundHelper();
				}
			}
			m_Jump = false;
		}

		private float SlopeMultiplier()
		{
			float time = Vector3.Angle(m_GroundContactNormal, Vector3.up);
			return movementSettings.SlopeCurveModifier.Evaluate(time);
		}

		private void StickToGroundHelper()
		{
			if (Physics.SphereCast(base.transform.position, m_Capsule.radius * (1f - advancedSettings.shellOffset), Vector3.down, out var hitInfo, m_Capsule.height / 2f - m_Capsule.radius + advancedSettings.stickToGroundHelperDistance, -1, QueryTriggerInteraction.Ignore) && Mathf.Abs(Vector3.Angle(hitInfo.normal, Vector3.up)) < 85f)
			{
				m_RigidBody.velocity = Vector3.ProjectOnPlane(m_RigidBody.velocity, hitInfo.normal);
			}
		}

		private Vector2 GetInput()
		{
			Vector2 vector = default(Vector2);
			vector.x = CrossPlatformInputManager.GetAxis("Horizontal");
			vector.y = CrossPlatformInputManager.GetAxis("Vertical");
			Vector2 vector2 = vector;
			movementSettings.UpdateDesiredTargetSpeed(vector2);
			return vector2;
		}

		private void RotateView()
		{
			if (!(Mathf.Abs(Time.timeScale) < float.Epsilon))
			{
				float y = base.transform.eulerAngles.y;
				mouseLook.LookRotation(base.transform, cam.transform);
				if (m_IsGrounded || advancedSettings.airControl)
				{
					Quaternion quaternion = Quaternion.AngleAxis(base.transform.eulerAngles.y - y, Vector3.up);
					m_RigidBody.velocity = quaternion * m_RigidBody.velocity;
				}
			}
		}

		private void GroundCheck()
		{
			m_PreviouslyGrounded = m_IsGrounded;
			if (Physics.SphereCast(base.transform.position, m_Capsule.radius * (1f - advancedSettings.shellOffset), Vector3.down, out var hitInfo, m_Capsule.height / 2f - m_Capsule.radius + advancedSettings.groundCheckDistance, -1, QueryTriggerInteraction.Ignore))
			{
				m_IsGrounded = true;
				m_GroundContactNormal = hitInfo.normal;
			}
			else
			{
				m_IsGrounded = false;
				m_GroundContactNormal = Vector3.up;
			}
			if (!m_PreviouslyGrounded && m_IsGrounded && m_Jumping)
			{
				m_Jumping = false;
			}
		}
	}
}
namespace UnityStandardAssets.Cameras
{
	public abstract class AbstractTargetFollower : MonoBehaviour
	{
		public enum UpdateType
		{
			FixedUpdate,
			LateUpdate,
			ManualUpdate
		}

		[SerializeField]
		protected Transform m_Target;

		[SerializeField]
		private bool m_AutoTargetPlayer = true;

		[SerializeField]
		private UpdateType m_UpdateType;

		protected Rigidbody targetRigidbody;

		public Transform Target => m_Target;

		protected virtual void Start()
		{
			if (m_AutoTargetPlayer)
			{
				FindAndTargetPlayer();
			}
			if (!(m_Target == null))
			{
				targetRigidbody = m_Target.GetComponent<Rigidbody>();
			}
		}

		private void FixedUpdate()
		{
			if (m_AutoTargetPlayer && (m_Target == null || !m_Target.gameObject.activeSelf))
			{
				FindAndTargetPlayer();
			}
			if (m_UpdateType == UpdateType.FixedUpdate)
			{
				FollowTarget(Time.deltaTime);
			}
		}

		private void LateUpdate()
		{
			if (m_AutoTargetPlayer && (m_Target == null || !m_Target.gameObject.activeSelf))
			{
				FindAndTargetPlayer();
			}
			if (m_UpdateType == UpdateType.LateUpdate)
			{
				FollowTarget(Time.deltaTime);
			}
		}

		public void ManualUpdate()
		{
			if (m_AutoTargetPlayer && (m_Target == null || !m_Target.gameObject.activeSelf))
			{
				FindAndTargetPlayer();
			}
			if (m_UpdateType == UpdateType.ManualUpdate)
			{
				FollowTarget(Time.deltaTime);
			}
		}

		protected abstract void FollowTarget(float deltaTime);

		public void FindAndTargetPlayer()
		{
			GameObject gameObject = GameObject.FindGameObjectWithTag("Player");
			if ((bool)gameObject)
			{
				SetTarget(gameObject.transform);
			}
		}

		public virtual void SetTarget(Transform newTransform)
		{
			m_Target = newTransform;
		}
	}
	[ExecuteInEditMode]
	public class AutoCam : PivotBasedCameraRig
	{
		[SerializeField]
		private float m_MoveSpeed = 3f;

		[SerializeField]
		private float m_TurnSpeed = 1f;

		[SerializeField]
		private float m_RollSpeed = 0.2f;

		[SerializeField]
		private bool m_FollowVelocity;

		[SerializeField]
		private bool m_FollowTilt = true;

		[SerializeField]
		private float m_SpinTurnLimit = 90f;

		[SerializeField]
		private float m_TargetVelocityLowerLimit = 4f;

		[SerializeField]
		private float m_SmoothTurnTime = 0.2f;

		private float m_LastFlatAngle;

		private float m_CurrentTurnAmount;

		private float m_TurnSpeedVelocityChange;

		private Vector3 m_RollUp = Vector3.up;

		protected override void FollowTarget(float deltaTime)
		{
			if (!(deltaTime > 0f) || m_Target == null)
			{
				return;
			}
			Vector3 forward = m_Target.forward;
			Vector3 up = m_Target.up;
			if (m_FollowVelocity && UnityEngine.Application.isPlaying)
			{
				if (targetRigidbody.velocity.magnitude > m_TargetVelocityLowerLimit)
				{
					forward = targetRigidbody.velocity.normalized;
					up = Vector3.up;
				}
				else
				{
					up = Vector3.up;
				}
				m_CurrentTurnAmount = Mathf.SmoothDamp(m_CurrentTurnAmount, 1f, ref m_TurnSpeedVelocityChange, m_SmoothTurnTime);
			}
			else
			{
				float num = Mathf.Atan2(forward.x, forward.z) * 57.29578f;
				if (m_SpinTurnLimit > 0f)
				{
					float value = Mathf.Abs(Mathf.DeltaAngle(m_LastFlatAngle, num)) / deltaTime;
					float num2 = Mathf.InverseLerp(m_SpinTurnLimit, m_SpinTurnLimit * 0.75f, value);
					float smoothTime = ((m_CurrentTurnAmount > num2) ? 0.1f : 1f);
					if (UnityEngine.Application.isPlaying)
					{
						m_CurrentTurnAmount = Mathf.SmoothDamp(m_CurrentTurnAmount, num2, ref m_TurnSpeedVelocityChange, smoothTime);
					}
					else
					{
						m_CurrentTurnAmount = num2;
					}
				}
				else
				{
					m_CurrentTurnAmount = 1f;
				}
				m_LastFlatAngle = num;
			}
			base.transform.position = Vector3.Lerp(base.transform.position, m_Target.position, deltaTime * m_MoveSpeed);
			if (!m_FollowTilt)
			{
				forward.y = 0f;
				if (forward.sqrMagnitude < float.Epsilon)
				{
					forward = base.transform.forward;
				}
			}
			Quaternion b = Quaternion.LookRotation(forward, m_RollUp);
			m_RollUp = ((m_RollSpeed > 0f) ? Vector3.Slerp(m_RollUp, up, m_RollSpeed * deltaTime) : Vector3.up);
			base.transform.rotation = Quaternion.Lerp(base.transform.rotation, b, m_TurnSpeed * m_CurrentTurnAmount * deltaTime);
		}
	}
	public class FreeLookCam : PivotBasedCameraRig
	{
		[SerializeField]
		private float m_MoveSpeed = 1f;

		[Range(0f, 10f)]
		[SerializeField]
		private float m_TurnSpeed = 1.5f;

		[SerializeField]
		private float m_TurnSmoothing;

		[SerializeField]
		private float m_TiltMax = 75f;

		[SerializeField]
		private float m_TiltMin = 45f;

		[SerializeField]
		private bool m_LockCursor;

		[SerializeField]
		private bool m_VerticalAutoReturn;

		private float m_LookAngle;

		private float m_TiltAngle;

		private const float k_LookDistance = 100f;

		private Vector3 m_PivotEulers;

		private Quaternion m_PivotTargetRot;

		private Quaternion m_TransformTargetRot;

		protected override void Awake()
		{
			base.Awake();
			Cursor.lockState = (m_LockCursor ? CursorLockMode.Locked : CursorLockMode.None);
			Cursor.visible = !m_LockCursor;
			m_PivotEulers = m_Pivot.rotation.eulerAngles;
			m_PivotTargetRot = m_Pivot.transform.localRotation;
			m_TransformTargetRot = base.transform.localRotation;
		}

		protected void Update()
		{
			HandleRotationMovement();
			if (m_LockCursor && Input.GetMouseButtonUp(0))
			{
				Cursor.lockState = (m_LockCursor ? CursorLockMode.Locked : CursorLockMode.None);
				Cursor.visible = !m_LockCursor;
			}
		}

		private void OnDisable()
		{
			Cursor.lockState = CursorLockMode.None;
			Cursor.visible = true;
		}

		protected override void FollowTarget(float deltaTime)
		{
			if (!(m_Target == null))
			{
				base.transform.position = Vector3.Lerp(base.transform.position, m_Target.position, deltaTime * m_MoveSpeed);
			}
		}

		private void HandleRotationMovement()
		{
			if (!(Time.timeScale < float.Epsilon))
			{
				float axis = CrossPlatformInputManager.GetAxis("Mouse X");
				float axis2 = CrossPlatformInputManager.GetAxis("Mouse Y");
				m_LookAngle += axis * m_TurnSpeed;
				m_TransformTargetRot = Quaternion.Euler(0f, m_LookAngle, 0f);
				if (m_VerticalAutoReturn)
				{
					m_TiltAngle = ((axis2 > 0f) ? Mathf.Lerp(0f, 0f - m_TiltMin, axis2) : Mathf.Lerp(0f, m_TiltMax, 0f - axis2));
				}
				else
				{
					m_TiltAngle -= axis2 * m_TurnSpeed;
					m_TiltAngle = Mathf.Clamp(m_TiltAngle, 0f - m_TiltMin, m_TiltMax);
				}
				m_PivotTargetRot = Quaternion.Euler(m_TiltAngle, m_PivotEulers.y, m_PivotEulers.z);
				if (m_TurnSmoothing > 0f)
				{
					m_Pivot.localRotation = Quaternion.Slerp(m_Pivot.localRotation, m_PivotTargetRot, m_TurnSmoothing * Time.deltaTime);
					base.transform.localRotation = Quaternion.Slerp(base.transform.localRotation, m_TransformTargetRot, m_TurnSmoothing * Time.deltaTime);
				}
				else
				{
					m_Pivot.localRotation = m_PivotTargetRot;
					base.transform.localRotation = m_TransformTargetRot;
				}
			}
		}
	}
	public class HandHeldCam : LookatTarget
	{
		[SerializeField]
		private float m_SwaySpeed = 0.5f;

		[SerializeField]
		private float m_BaseSwayAmount = 0.5f;

		[SerializeField]
		private float m_TrackingSwayAmount = 0.5f;

		[Range(-1f, 1f)]
		[SerializeField]
		private float m_TrackingBias;

		protected override void FollowTarget(float deltaTime)
		{
			base.FollowTarget(deltaTime);
			float num = Mathf.PerlinNoise(0f, Time.time * m_SwaySpeed) - 0.5f;
			float num2 = Mathf.PerlinNoise(0f, Time.time * m_SwaySpeed + 100f) - 0.5f;
			num *= m_BaseSwayAmount;
			num2 *= m_BaseSwayAmount;
			float num3 = Mathf.PerlinNoise(0f, Time.time * m_SwaySpeed) - 0.5f + m_TrackingBias;
			float num4 = Mathf.PerlinNoise(0f, Time.time * m_SwaySpeed + 100f) - 0.5f + m_TrackingBias;
			num3 *= (0f - m_TrackingSwayAmount) * m_FollowVelocity.x;
			num4 *= m_TrackingSwayAmount * m_FollowVelocity.y;
			base.transform.Rotate(num + num3, num2 + num4, 0f);
		}
	}
	public class LookatTarget : AbstractTargetFollower
	{
		[SerializeField]
		private Vector2 m_RotationRange;

		[SerializeField]
		private float m_FollowSpeed = 1f;

		private Vector3 m_FollowAngles;

		private Quaternion m_OriginalRotation;

		protected Vector3 m_FollowVelocity;

		protected override void Start()
		{
			base.Start();
			m_OriginalRotation = base.transform.localRotation;
		}

		protected override void FollowTarget(float deltaTime)
		{
			base.transform.localRotation = m_OriginalRotation;
			Vector3 vector = base.transform.InverseTransformPoint(m_Target.position);
			float value = Mathf.Atan2(vector.x, vector.z) * 57.29578f;
			value = Mathf.Clamp(value, (0f - m_RotationRange.y) * 0.5f, m_RotationRange.y * 0.5f);
			base.transform.localRotation = m_OriginalRotation * Quaternion.Euler(0f, value, 0f);
			vector = base.transform.InverseTransformPoint(m_Target.position);
			float value2 = Mathf.Atan2(vector.y, vector.z) * 57.29578f;
			value2 = Mathf.Clamp(value2, (0f - m_RotationRange.x) * 0.5f, m_RotationRange.x * 0.5f);
			m_FollowAngles = Vector3.SmoothDamp(target: new Vector3(m_FollowAngles.x + Mathf.DeltaAngle(m_FollowAngles.x, value2), m_FollowAngles.y + Mathf.DeltaAngle(m_FollowAngles.y, value)), current: m_FollowAngles, currentVelocity: ref m_FollowVelocity, smoothTime: m_FollowSpeed);
			base.transform.localRotation = m_OriginalRotation * Quaternion.Euler(0f - m_FollowAngles.x, m_FollowAngles.y, 0f);
		}
	}
	public abstract class PivotBasedCameraRig : AbstractTargetFollower
	{
		protected Transform m_Cam;

		protected Transform m_Pivot;

		protected Vector3 m_LastTargetPosition;

		protected virtual void Awake()
		{
			m_Cam = GetComponentInChildren<Camera>().transform;
			m_Pivot = m_Cam.parent;
		}
	}
	public class ProtectCameraFromWallClip : MonoBehaviour
	{
		public class RayHitComparer : IComparer
		{
			public int Compare(object x, object y)
			{
				return ((RaycastHit)x).distance.CompareTo(((RaycastHit)y).distance);
			}
		}

		public float clipMoveTime = 0.05f;

		public float returnTime = 0.4f;

		public float sphereCastRadius = 0.1f;

		public bool visualiseInEditor;

		public float closestDistance = 0.5f;

		public string dontClipTag = "Player";

		private Transform m_Cam;

		private Transform m_Pivot;

		private float m_OriginalDist;

		private float m_MoveVelocity;

		private float m_CurrentDist;

		private Ray m_Ray;

		private RaycastHit[] m_Hits;

		private RayHitComparer m_RayHitComparer;

		public bool protecting { get; private set; }

		private void Start()
		{
			m_Cam = GetComponentInChildren<Camera>().transform;
			m_Pivot = m_Cam.parent;
			m_OriginalDist = m_Cam.localPosition.magnitude;
			m_CurrentDist = m_OriginalDist;
			m_RayHitComparer = new RayHitComparer();
		}

		private void LateUpdate()
		{
			float num = m_OriginalDist;
			m_Ray.origin = m_Pivot.position + m_Pivot.forward * sphereCastRadius;
			m_Ray.direction = -m_Pivot.forward;
			Collider[] array = Physics.OverlapSphere(m_Ray.origin, sphereCastRadius);
			bool flag = false;
			bool flag2 = false;
			for (int i = 0; i < array.Length; i++)
			{
				if (!array[i].isTrigger && (!(array[i].attachedRigidbody != null) || !array[i].attachedRigidbody.CompareTag(dontClipTag)))
				{
					flag = true;
					break;
				}
			}
			if (flag)
			{
				m_Ray.origin += m_Pivot.forward * sphereCastRadius;
				m_Hits = Physics.RaycastAll(m_Ray, m_OriginalDist - sphereCastRadius);
			}
			else
			{
				m_Hits = Physics.SphereCastAll(m_Ray, sphereCastRadius, m_OriginalDist + sphereCastRadius);
			}
			Array.Sort(m_Hits, m_RayHitComparer);
			float num2 = float.PositiveInfinity;
			for (int j = 0; j < m_Hits.Length; j++)
			{
				if (m_Hits[j].distance < num2 && !m_Hits[j].collider.isTrigger && (!(m_Hits[j].collider.attachedRigidbody != null) || !m_Hits[j].collider.attachedRigidbody.CompareTag(dontClipTag)))
				{
					num2 = m_Hits[j].distance;
					num = 0f - m_Pivot.InverseTransformPoint(m_Hits[j].point).z;
					flag2 = true;
				}
			}
			if (flag2)
			{
				UnityEngine.Debug.DrawRay(m_Ray.origin, -m_Pivot.forward * (num + sphereCastRadius), Color.red);
			}
			protecting = flag2;
			m_CurrentDist = Mathf.SmoothDamp(m_CurrentDist, num, ref m_MoveVelocity, (m_CurrentDist > num) ? clipMoveTime : returnTime);
			m_CurrentDist = Mathf.Clamp(m_CurrentDist, closestDistance, m_OriginalDist);
			m_Cam.localPosition = -Vector3.forward * m_CurrentDist;
		}
	}
	public class TargetFieldOfView : AbstractTargetFollower
	{
		[SerializeField]
		private float m_FovAdjustTime = 1f;

		[SerializeField]
		private float m_ZoomAmountMultiplier = 2f;

		[SerializeField]
		private bool m_IncludeEffectsInSize;

		private float m_BoundSize;

		private float m_FovAdjustVelocity;

		private Camera m_Cam;

		private Transform m_LastTarget;

		protected override void Start()
		{
			base.Start();
			m_BoundSize = MaxBoundsExtent(m_Target, m_IncludeEffectsInSize);
			m_Cam = GetComponentInChildren<Camera>();
		}

		protected override void FollowTarget(float deltaTime)
		{
			float magnitude = (m_Target.position - base.transform.position).magnitude;
			float target = Mathf.Atan2(m_BoundSize, magnitude) * 57.29578f * m_ZoomAmountMultiplier;
			m_Cam.fieldOfView = Mathf.SmoothDamp(m_Cam.fieldOfView, target, ref m_FovAdjustVelocity, m_FovAdjustTime);
		}

		public override void SetTarget(Transform newTransform)
		{
			base.SetTarget(newTransform);
			m_BoundSize = MaxBoundsExtent(newTransform, m_IncludeEffectsInSize);
		}

		public static float MaxBoundsExtent(Transform obj, bool includeEffects)
		{
			Renderer[] componentsInChildren = obj.GetComponentsInChildren<Renderer>();
			Bounds bounds = default(Bounds);
			bool flag = false;
			Renderer[] array = componentsInChildren;
			foreach (Renderer renderer in array)
			{
				if (!(renderer is TrailRenderer) && !(renderer is ParticleSystemRenderer))
				{
					if (!flag)
					{
						flag = true;
						bounds = renderer.bounds;
					}
					else
					{
						bounds.Encapsulate(renderer.bounds);
					}
				}
			}
			return Mathf.Max(bounds.extents.x, bounds.extents.y, bounds.extents.z);
		}
	}
}
namespace UnityStandardAssets._2D
{
	public class Camera2DFollow : MonoBehaviour
	{
		public Transform target;

		public float damping = 1f;

		public float lookAheadFactor = 3f;

		public float lookAheadReturnSpeed = 0.5f;

		public float lookAheadMoveThreshold = 0.1f;

		private float m_OffsetZ;

		private Vector3 m_LastTargetPosition;

		private Vector3 m_CurrentVelocity;

		private Vector3 m_LookAheadPos;

		private void Start()
		{
			m_LastTargetPosition = target.position;
			m_OffsetZ = (base.transform.position - target.position).z;
			base.transform.parent = null;
		}

		private void Update()
		{
			float x = (target.position - m_LastTargetPosition).x;
			if (Mathf.Abs(x) > lookAheadMoveThreshold)
			{
				m_LookAheadPos = lookAheadFactor * Vector3.right * Mathf.Sign(x);
			}
			else
			{
				m_LookAheadPos = Vector3.MoveTowards(m_LookAheadPos, Vector3.zero, Time.deltaTime * lookAheadReturnSpeed);
			}
			Vector3 vector = target.position + m_LookAheadPos + Vector3.forward * m_OffsetZ;
			Vector3 position = Vector3.SmoothDamp(base.transform.position, vector, ref m_CurrentVelocity, damping);
			base.transform.position = position;
			m_LastTargetPosition = target.position;
		}
	}
	public class CameraFollow : MonoBehaviour
	{
		public float xMargin = 1f;

		public float yMargin = 1f;

		public float xSmooth = 8f;

		public float ySmooth = 8f;

		public Vector2 maxXAndY;

		public Vector2 minXAndY;

		private Transform m_Player;

		private void Awake()
		{
			m_Player = GameObject.FindGameObjectWithTag("Player").transform;
		}

		private bool CheckXMargin()
		{
			return Mathf.Abs(base.transform.position.x - m_Player.position.x) > xMargin;
		}

		private bool CheckYMargin()
		{
			return Mathf.Abs(base.transform.position.y - m_Player.position.y) > yMargin;
		}

		private void Update()
		{
			TrackPlayer();
		}

		private void TrackPlayer()
		{
			float value = base.transform.position.x;
			float value2 = base.transform.position.y;
			if (CheckXMargin())
			{
				value = Mathf.Lerp(base.transform.position.x, m_Player.position.x, xSmooth * Time.deltaTime);
			}
			if (CheckYMargin())
			{
				value2 = Mathf.Lerp(base.transform.position.y, m_Player.position.y, ySmooth * Time.deltaTime);
			}
			value = Mathf.Clamp(value, minXAndY.x, maxXAndY.x);
			value2 = Mathf.Clamp(value2, minXAndY.y, maxXAndY.y);
			base.transform.position = new Vector3(value, value2, base.transform.position.z);
		}
	}
	[RequireComponent(typeof(PlatformerCharacter2D))]
	public class Platformer2DUserControl : MonoBehaviour
	{
		private PlatformerCharacter2D m_Character;

		private bool m_Jump;

		private void Awake()
		{
			m_Character = GetComponent<PlatformerCharacter2D>();
		}

		private void Update()
		{
			if (!m_Jump)
			{
				m_Jump = CrossPlatformInputManager.GetButtonDown("Jump");
			}
		}

		private void FixedUpdate()
		{
			bool key = Input.GetKey(KeyCode.LeftControl);
			float axis = CrossPlatformInputManager.GetAxis("Horizontal");
			m_Character.Move(axis, key, m_Jump);
			m_Jump = false;
		}
	}
	public class PlatformerCharacter2D : MonoBehaviour
	{
		[SerializeField]
		private float m_MaxSpeed = 10f;

		[SerializeField]
		private float m_JumpForce = 400f;

		[Range(0f, 1f)]
		[SerializeField]
		private float m_CrouchSpeed = 0.36f;

		[SerializeField]
		private bool m_AirControl;

		[SerializeField]
		private LayerMask m_WhatIsGround;

		private Transform m_GroundCheck;

		private const float k_GroundedRadius = 0.2f;

		private bool m_Grounded;

		private Transform m_CeilingCheck;

		private const float k_CeilingRadius = 0.01f;

		private Animator m_Anim;

		private Rigidbody2D m_Rigidbody2D;

		private bool m_FacingRight = true;

		private void Awake()
		{
			m_GroundCheck = base.transform.Find("GroundCheck");
			m_CeilingCheck = base.transform.Find("CeilingCheck");
			m_Anim = GetComponent<Animator>();
			m_Rigidbody2D = GetComponent<Rigidbody2D>();
		}

		private void FixedUpdate()
		{
			m_Grounded = false;
			Collider2D[] array = Physics2D.OverlapCircleAll(m_GroundCheck.position, 0.2f, m_WhatIsGround);
			for (int i = 0; i < array.Length; i++)
			{
				if (array[i].gameObject != base.gameObject)
				{
					m_Grounded = true;
				}
			}
			m_Anim.SetBool("Ground", m_Grounded);
			m_Anim.SetFloat("vSpeed", m_Rigidbody2D.velocity.y);
		}

		public void Move(float move, bool crouch, bool jump)
		{
			if (!crouch && m_Anim.GetBool("Crouch") && (bool)Physics2D.OverlapCircle(m_CeilingCheck.position, 0.01f, m_WhatIsGround))
			{
				crouch = true;
			}
			m_Anim.SetBool("Crouch", crouch);
			if (m_Grounded || m_AirControl)
			{
				move = (crouch ? (move * m_CrouchSpeed) : move);
				m_Anim.SetFloat("Speed", Mathf.Abs(move));
				m_Rigidbody2D.velocity = new Vector2(move * m_MaxSpeed, m_Rigidbody2D.velocity.y);
				if (move > 0f && !m_FacingRight)
				{
					Flip();
				}
				else if (move < 0f && m_FacingRight)
				{
					Flip();
				}
			}
			if (m_Grounded && jump && m_Anim.GetBool("Ground"))
			{
				m_Grounded = false;
				m_Anim.SetBool("Ground", value: false);
				m_Rigidbody2D.AddForce(new Vector2(0f, m_JumpForce));
			}
		}

		private void Flip()
		{
			m_FacingRight = !m_FacingRight;
			Vector3 localScale = base.transform.localScale;
			localScale.x *= -1f;
			base.transform.localScale = localScale;
		}
	}
	public class Restarter : MonoBehaviour
	{
		private void OnTriggerEnter2D(Collider2D other)
		{
			if (other.tag == "Player")
			{
				SceneManager.LoadScene(SceneManager.GetSceneAt(0).name);
			}
		}
	}
}
namespace UnityStandardAssets.CinematicEffects
{
	[ExecuteInEditMode]
	[RequireComponent(typeof(Camera))]
	[AddComponentMenu("Image Effects/Cinematic/RFX1_Bloom")]
	[ImageEffectAllowedInSceneView]
	public class RFX1_Bloom : MonoBehaviour
	{
		[Serializable]
		public struct Settings
		{
			[SerializeField]
			[Tooltip("Filters out pixels under this level of brightness.")]
			public float threshold;

			[SerializeField]
			[Range(0f, 1f)]
			[Tooltip("Makes transition between under/over-threshold gradual.")]
			public float softKnee;

			[SerializeField]
			[Range(1f, 7f)]
			[Tooltip("Changes extent of veiling effects in a screen resolution-independent fashion.")]
			public float radius;

			[SerializeField]
			[Tooltip("Blend factor of the result image.")]
			public float intensity;

			[SerializeField]
			[Tooltip("Controls filter quality and buffer resolution.")]
			public bool highQuality;

			[SerializeField]
			[Tooltip("Reduces flashing noise with an additional filter.")]
			public bool antiFlicker;

			[Tooltip("Dirtiness texture to add smudges or dust to the lens.")]
			public Texture dirtTexture;

			[RFX1_Min(0f)]
			[Tooltip("Amount of lens dirtiness.")]
			public float dirtIntensity;

			public float thresholdGamma
			{
				get
				{
					return Mathf.Max(0f, threshold);
				}
				set
				{
					threshold = value;
				}
			}

			public float thresholdLinear
			{
				get
				{
					return Mathf.GammaToLinearSpace(thresholdGamma);
				}
				set
				{
					threshold = Mathf.LinearToGammaSpace(value);
				}
			}

			public static Settings defaultSettings
			{
				get
				{
					Settings result = default(Settings);
					result.threshold = 0.9f;
					result.softKnee = 0.5f;
					result.radius = 2f;
					result.intensity = 0.7f;
					result.highQuality = true;
					result.antiFlicker = false;
					result.dirtTexture = null;
					result.dirtIntensity = 2.5f;
					return result;
				}
			}
		}

		[SerializeField]
		public Settings settings = Settings.defaultSettings;

		[SerializeField]
		[HideInInspector]
		private Shader m_Shader;

		private Material m_Material;

		private const int kMaxIterations = 16;

		private RenderTexture[] m_blurBuffer1 = new RenderTexture[16];

		private RenderTexture[] m_blurBuffer2 = new RenderTexture[16];

		private int m_Threshold;

		private int m_Curve;

		private int m_PrefilterOffs;

		private int m_SampleScale;

		private int m_Intensity;

		private int m_DirtTex;

		private int m_DirtIntensity;

		private int m_BaseTex;

		public Shader shader
		{
			get
			{
				if (m_Shader == null)
				{
					m_Shader = Shader.Find("Hidden/Image Effects/Cinematic/RFX1_Bloom");
				}
				return m_Shader;
			}
		}

		public Material material
		{
			get
			{
				if (m_Material == null)
				{
					m_Material = RFX1_ImageEffectHelper.CheckShaderAndCreateMaterial(shader);
				}
				return m_Material;
			}
		}

		private void Awake()
		{
			m_Threshold = Shader.PropertyToID("_Threshold");
			m_Curve = Shader.PropertyToID("_Curve");
			m_PrefilterOffs = Shader.PropertyToID("_PrefilterOffs");
			m_SampleScale = Shader.PropertyToID("_SampleScale");
			m_Intensity = Shader.PropertyToID("_Intensity");
			m_DirtTex = Shader.PropertyToID("_DirtTex");
			m_DirtIntensity = Shader.PropertyToID("_DirtIntensity");
			m_BaseTex = Shader.PropertyToID("_BaseTex");
		}

		private void OnEnable()
		{
			if (!RFX1_ImageEffectHelper.IsSupported(shader, needDepth: true, needHdr: false, this))
			{
				base.enabled = false;
			}
		}

		private void OnDisable()
		{
			if (m_Material != null)
			{
				UnityEngine.Object.DestroyImmediate(m_Material);
			}
			m_Material = null;
		}

		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			bool isMobilePlatform = UnityEngine.Application.isMobilePlatform;
			int num = source.width;
			int num2 = source.height;
			if (!settings.highQuality)
			{
				num /= 2;
				num2 /= 2;
			}
			RenderTextureFormat format = (isMobilePlatform ? RenderTextureFormat.Default : RenderTextureFormat.DefaultHDR);
			float num3 = Mathf.Log(num2, 2f) + settings.radius - 8f;
			int num4 = (int)num3;
			int num5 = Mathf.Clamp(num4, 1, 16);
			float thresholdLinear = settings.thresholdLinear;
			material.SetFloat(m_Threshold, thresholdLinear);
			float num6 = thresholdLinear * settings.softKnee + 1E-05f;
			Vector3 vector = new Vector3(thresholdLinear - num6, num6 * 2f, 0.25f / num6);
			material.SetVector(m_Curve, vector);
			bool flag = !settings.highQuality && settings.antiFlicker;
			material.SetFloat(m_PrefilterOffs, flag ? (-0.5f) : 0f);
			material.SetFloat(m_SampleScale, 0.5f + num3 - (float)num4);
			material.SetFloat(m_Intensity, Mathf.Max(0f, settings.intensity));
			bool flag2 = false;
			if (settings.dirtTexture != null)
			{
				material.SetTexture(m_DirtTex, settings.dirtTexture);
				material.SetFloat(m_DirtIntensity, settings.dirtIntensity);
				flag2 = true;
			}
			RenderTexture temporary = RenderTexture.GetTemporary(num, num2, 0, format);
			Graphics.Blit(source, temporary, material, settings.antiFlicker ? 1 : 0);
			RenderTexture renderTexture = temporary;
			for (int i = 0; i < num5; i++)
			{
				m_blurBuffer1[i] = RenderTexture.GetTemporary(renderTexture.width / 2, renderTexture.height / 2, 0, format);
				Graphics.Blit(renderTexture, m_blurBuffer1[i], material, (i == 0) ? (settings.antiFlicker ? 3 : 2) : 4);
				renderTexture = m_blurBuffer1[i];
			}
			for (int num7 = num5 - 2; num7 >= 0; num7--)
			{
				RenderTexture renderTexture2 = m_blurBuffer1[num7];
				material.SetTexture(m_BaseTex, renderTexture2);
				m_blurBuffer2[num7] = RenderTexture.GetTemporary(renderTexture2.width, renderTexture2.height, 0, format);
				Graphics.Blit(renderTexture, m_blurBuffer2[num7], material, settings.highQuality ? 6 : 5);
				renderTexture = m_blurBuffer2[num7];
			}
			int num8 = (flag2 ? 9 : 7);
			num8 += (settings.highQuality ? 1 : 0);
			material.SetTexture(m_BaseTex, source);
			Graphics.Blit(renderTexture, destination, material, num8);
			for (int j = 0; j < 16; j++)
			{
				if (m_blurBuffer1[j] != null)
				{
					RenderTexture.ReleaseTemporary(m_blurBuffer1[j]);
				}
				if (m_blurBuffer2[j] != null)
				{
					RenderTexture.ReleaseTemporary(m_blurBuffer2[j]);
				}
				m_blurBuffer1[j] = null;
				m_blurBuffer2[j] = null;
			}
			RenderTexture.ReleaseTemporary(temporary);
		}
	}
	public static class RFX1_ImageEffectHelper
	{
		public static bool supportsDX11
		{
			get
			{
				if (SystemInfo.graphicsShaderLevel >= 50)
				{
					return SystemInfo.supportsComputeShaders;
				}
				return false;
			}
		}

		public static bool IsSupported(Shader s, bool needDepth, bool needHdr, MonoBehaviour effect)
		{
			if (s == null || !s.isSupported)
			{
				UnityEngine.Debug.LogWarningFormat("Missing shader for image effect {0}", effect);
				return false;
			}
			if (!SystemInfo.supportsImageEffects)
			{
				UnityEngine.Debug.LogWarningFormat("Image effects aren't supported on this device ({0})", effect);
				return false;
			}
			if (needDepth && !SystemInfo.SupportsRenderTextureFormat(RenderTextureFormat.Depth))
			{
				UnityEngine.Debug.LogWarningFormat("Depth textures aren't supported on this device ({0})", effect);
				return false;
			}
			if (needHdr && !SystemInfo.SupportsRenderTextureFormat(RenderTextureFormat.ARGBHalf))
			{
				UnityEngine.Debug.LogWarningFormat("Floating point textures aren't supported on this device ({0})", effect);
				return false;
			}
			return true;
		}

		public static Material CheckShaderAndCreateMaterial(Shader s)
		{
			if (s == null || !s.isSupported)
			{
				return null;
			}
			return new Material(s)
			{
				hideFlags = HideFlags.DontSave
			};
		}
	}
	public sealed class RFX1_MinAttribute : PropertyAttribute
	{
		public readonly float min;

		public RFX1_MinAttribute(float min)
		{
			this.min = min;
		}
	}
	public class RFX1_RenderTextureUtility
	{
		private List<RenderTexture> m_TemporaryRTs = new List<RenderTexture>();

		public RenderTexture GetTemporaryRenderTexture(int width, int height, int depthBuffer = 0, RenderTextureFormat format = RenderTextureFormat.ARGBHalf, FilterMode filterMode = FilterMode.Bilinear)
		{
			RenderTexture temporary = RenderTexture.GetTemporary(width, height, depthBuffer, format);
			temporary.filterMode = filterMode;
			temporary.wrapMode = TextureWrapMode.Clamp;
			temporary.name = "RenderTextureUtilityTempTexture";
			m_TemporaryRTs.Add(temporary);
			return temporary;
		}

		public void ReleaseTemporaryRenderTexture(RenderTexture rt)
		{
			if (!(rt == null))
			{
				if (!m_TemporaryRTs.Contains(rt))
				{
					UnityEngine.Debug.LogErrorFormat("Attempting to remove texture that was not allocated: {0}", rt);
				}
				else
				{
					m_TemporaryRTs.Remove(rt);
					RenderTexture.ReleaseTemporary(rt);
				}
			}
		}

		public void ReleaseAllTemporaryRenderTextures()
		{
			for (int i = 0; i < m_TemporaryRTs.Count; i++)
			{
				RenderTexture.ReleaseTemporary(m_TemporaryRTs[i]);
			}
			m_TemporaryRTs.Clear();
		}
	}
}
namespace Kino
{
	[ExecuteInEditMode]
	[RequireComponent(typeof(Camera))]
	[AddComponentMenu("Kino Image Effects/Analog Glitch")]
	public class AnalogGlitch : MonoBehaviour
	{
		[SerializeField]
		[Range(0f, 1f)]
		private float _scanLineJitter;

		[SerializeField]
		[Range(0f, 1f)]
		private float _verticalJump;

		[SerializeField]
		[Range(0f, 1f)]
		private float _horizontalShake;

		[SerializeField]
		[Range(0f, 1f)]
		private float _colorDrift;

		[SerializeField]
		private Shader _shader;

		private Material _material;

		private float _verticalJumpTime;

		public float scanLineJitter
		{
			get
			{
				return _scanLineJitter;
			}
			set
			{
				_scanLineJitter = value;
			}
		}

		public float verticalJump
		{
			get
			{
				return _verticalJump;
			}
			set
			{
				_verticalJump = value;
			}
		}

		public float horizontalShake
		{
			get
			{
				return _horizontalShake;
			}
			set
			{
				_horizontalShake = value;
			}
		}

		public float colorDrift
		{
			get
			{
				return _colorDrift;
			}
			set
			{
				_colorDrift = value;
			}
		}

		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			if (_material == null)
			{
				_material = new Material(_shader);
				_material.hideFlags = HideFlags.DontSave;
			}
			_verticalJumpTime += Time.deltaTime * _verticalJump * 11.3f;
			float y = Mathf.Clamp01(1f - _scanLineJitter * 1.2f);
			float x = 0.002f + Mathf.Pow(_scanLineJitter, 3f) * 0.05f;
			_material.SetVector("_ScanLineJitter", new Vector2(x, y));
			Vector2 vector = new Vector2(_verticalJump, _verticalJumpTime);
			_material.SetVector("_VerticalJump", vector);
			_material.SetFloat("_HorizontalShake", _horizontalShake * 0.2f);
			Vector2 vector2 = new Vector2(_colorDrift * 0.04f, Time.time * 606.11f);
			_material.SetVector("_ColorDrift", vector2);
			Graphics.Blit(source, destination, _material);
		}

		private void Awake()
		{
			base.enabled = false;
		}
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(Camera))]
	[AddComponentMenu("Kino Image Effects/Digital Glitch")]
	public class DigitalGlitch : MonoBehaviour
	{
		[SerializeField]
		[Range(0f, 1f)]
		private float _intensity;

		[SerializeField]
		private Shader _shader;

		private Material _material;

		private Texture2D _noiseTexture;

		private RenderTexture _trashFrame1;

		private RenderTexture _trashFrame2;

		public float intensity
		{
			get
			{
				return _intensity;
			}
			set
			{
				_intensity = value;
			}
		}

		private static Color RandomColor()
		{
			return new Color(UnityEngine.Random.value, UnityEngine.Random.value, UnityEngine.Random.value, UnityEngine.Random.value);
		}

		private void SetUpResources()
		{
			if (!(_material != null))
			{
				_material = new Material(_shader);
				_material.hideFlags = HideFlags.DontSave;
				_noiseTexture = new Texture2D(64, 32, TextureFormat.ARGB32, mipChain: false);
				_noiseTexture.hideFlags = HideFlags.DontSave;
				_noiseTexture.wrapMode = TextureWrapMode.Clamp;
				_noiseTexture.filterMode = FilterMode.Point;
				_trashFrame1 = new RenderTexture(Screen.width, Screen.height, 0);
				_trashFrame2 = new RenderTexture(Screen.width, Screen.height, 0);
				_trashFrame1.hideFlags = HideFlags.DontSave;
				_trashFrame2.hideFlags = HideFlags.DontSave;
				UpdateNoiseTexture();
			}
		}

		private void UpdateNoiseTexture()
		{
			Color color = RandomColor();
			for (int i = 0; i < _noiseTexture.height; i++)
			{
				for (int j = 0; j < _noiseTexture.width; j++)
				{
					if (UnityEngine.Random.value > 0.89f)
					{
						color = RandomColor();
					}
					_noiseTexture.SetPixel(j, i, color);
				}
			}
			_noiseTexture.Apply();
		}

		private void Update()
		{
			if (UnityEngine.Random.value > Mathf.Lerp(0.9f, 0.5f, _intensity))
			{
				SetUpResources();
				UpdateNoiseTexture();
			}
		}

		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			SetUpResources();
			int frameCount = Time.frameCount;
			if (frameCount % 13 == 0)
			{
				Graphics.Blit(source, _trashFrame1);
			}
			if (frameCount % 73 == 0)
			{
				Graphics.Blit(source, _trashFrame2);
			}
			_material.SetFloat("_Intensity", _intensity);
			_material.SetTexture("_NoiseTex", _noiseTexture);
			RenderTexture value = ((UnityEngine.Random.value > 0.5f) ? _trashFrame1 : _trashFrame2);
			_material.SetTexture("_TrashTex", value);
			Graphics.Blit(source, destination, _material);
		}
	}
}
namespace Assets.ImagyVFX.Scripts.WiresConnector
{
	internal sealed class WiresConnector : MonoBehaviour
	{
		public GameObject WiresParticles;

		public GameObject LineRendererPrefab;

		public bool UseSkinnedMeshRenderer;

		public SkinnedMeshRenderer TargetSkinnedMeshRenderer;

		public float MaxDistance;

		public int MaxConnections;

		public int MaxLineRenderers;

		private ParticleSystem _particleSystem;

		private ParticleSystem.MainModule _particleSystemMainModule;

		private ParticleSystem.Particle[] _particles;

		private LineRenderer[] _lineRenderers;

		private Transform _psTransform;

		private void Start()
		{
			_lineRenderers = new LineRenderer[MaxLineRenderers];
			GameObject gameObject = UnityEngine.Object.Instantiate(WiresParticles, base.transform.position, WiresParticles.transform.rotation);
			gameObject.transform.parent = base.transform;
			_particleSystem = gameObject.GetComponent<ParticleSystem>();
			ParticleSystem.ShapeModule shape = _particleSystem.shape;
			if (UseSkinnedMeshRenderer)
			{
				shape.skinnedMeshRenderer = TargetSkinnedMeshRenderer;
			}
			_particleSystemMainModule = _particleSystem.main;
			_psTransform = _particleSystem.GetComponent<Transform>();
			int maxParticles = _particleSystemMainModule.maxParticles;
			_particles = new ParticleSystem.Particle[maxParticles];
		}

		private void LateUpdate()
		{
			if (_particleSystem == null)
			{
				UnityEngine.Object.Destroy(base.gameObject);
				return;
			}
			int particles = _particleSystem.GetParticles(_particles);
			int num = _lineRenderers.Length;
			int num2 = 0;
			for (int i = 0; i < particles; i++)
			{
				Vector3 position = _particles[i].position;
				int num3 = 0;
				for (int j = i + 1; j < particles; j++)
				{
					if (num3 == MaxConnections)
					{
						break;
					}
					if (num2 == MaxLineRenderers)
					{
						break;
					}
					Vector3 position2 = _particles[j].position;
					if (!(Vector3.Distance(position2, position) > MaxDistance))
					{
						LineRenderer component;
						if (_lineRenderers[num2] == null)
						{
							component = UnityEngine.Object.Instantiate(LineRendererPrefab, _psTransform.position, _psTransform.rotation).GetComponent<LineRenderer>();
							component.transform.parent = _psTransform.transform;
							_lineRenderers[num2] = component;
						}
						component = _lineRenderers[num2];
						component.enabled = true;
						component.SetPosition(0, position);
						component.SetPosition(1, position2);
						num2++;
						num3++;
					}
				}
			}
			int num4 = num - num2;
			for (int k = num2; k < num4; k++)
			{
				if (_lineRenderers[k] != null)
				{
					_lineRenderers[k].enabled = false;
				}
			}
		}

		private void Stop()
		{
			DestroyAllLines();
		}

		private void OnDestroy()
		{
			DestroyAllLines();
		}

		private void DestroyAllLines()
		{
			if (_lineRenderers == null)
			{
				return;
			}
			LineRenderer[] lineRenderers = _lineRenderers;
			foreach (LineRenderer lineRenderer in lineRenderers)
			{
				if (lineRenderer != null)
				{
					UnityEngine.Object.Destroy(lineRenderer);
				}
			}
		}
	}
}
namespace Assets.ImagyVFX.Scripts.Utils
{
	public class AnimationUtil : MonoBehaviour
	{
		public bool RotationOverLifeTime;

		public float RotationSpeed;

		public bool RotateZAxis;

		private void Start()
		{
		}

		private void Update()
		{
			if (RotationOverLifeTime && RotateZAxis)
			{
				base.transform.Rotate(Vector3.forward * RotationSpeed * Time.deltaTime);
			}
		}
	}
	internal sealed class CircularMovingUtil : MonoBehaviour
	{
		public float Freq;

		public float Omega;

		private float _unit;

		private void Update()
		{
			Vector3 position = base.transform.position;
			position.x += (float)((double)_unit * Math.Sin(Time.time * Freq) * (double)Omega);
			position.z += (float)((double)_unit * Math.Cos(Time.time * Freq) * (double)Omega);
			_unit += Time.deltaTime;
			base.transform.position = position;
		}
	}
	internal sealed class DemoInputConrtoller : MonoBehaviour
	{
		private const string SpaceButton = "space";

		private DemoPrefabController _demoController;

		private void Start()
		{
			_demoController = GetComponent<DemoPrefabController>();
		}

		private void Update()
		{
			if (Input.GetKeyDown("space"))
			{
				_demoController.SelectNextPrefab();
			}
		}
	}
	public sealed class DemoPrefabController : MonoBehaviour
	{
		public int StartNum;

		public GameObject[] Prefabs;

		private GameObject _currentInstance;

		private int _currentPrefabNum;

		public void SelectNextPrefab()
		{
			if (Prefabs.Length != 0)
			{
				_currentPrefabNum++;
				if (_currentPrefabNum >= Prefabs.Length)
				{
					_currentPrefabNum = 0;
				}
				ChangePrefab(_currentPrefabNum);
			}
		}

		public void SelectePrevPrefab()
		{
			if (Prefabs.Length != 0)
			{
				_currentPrefabNum--;
				if (_currentPrefabNum < 0)
				{
					_currentPrefabNum = Prefabs.Length - 1;
				}
				ChangePrefab(_currentPrefabNum);
			}
		}

		private void Start()
		{
			_currentPrefabNum = StartNum;
			ChangePrefab(_currentPrefabNum);
		}

		private void ChangePrefab(int num)
		{
			if (_currentInstance != null)
			{
				UnityEngine.Object.Destroy(_currentInstance);
			}
			_currentInstance = UnityEngine.Object.Instantiate(Prefabs[num]);
			_currentInstance.SetActive(value: true);
		}
	}
	[RequireComponent(typeof(Projector))]
	internal sealed class ProjectorTextureAnimation : MonoBehaviour
	{
		public int TilesX = 4;

		public int TilesY = 4;

		public float Fps = 30f;

		public AnimationCurve FrameOverTime = AnimationCurve.Linear(0f, 1f, 1f, 1f);

		private Projector _projector;

		private Material _projectorMaterial;

		private Material _originalMaterial;

		private float _animationLifeTime;

		private int _index;

		private int _countOfTextures;

		private int _currentNumOfTexture;

		private bool _isStarted;

		private bool _isCanceled;

		private float _animationStartTime;

		private void Start()
		{
			_projector = GetComponent<Projector>();
			if (_projector == null)
			{
				throw new InvalidOperationException("Could not get projector");
			}
			_animationLifeTime = (float)(TilesX * TilesY) / Fps;
			_index = TilesX - 1;
			_countOfTextures = TilesY * TilesX;
			Play();
		}

		private void Play()
		{
			if (!_isStarted && !(_projector == null) && !(_projector.material == null))
			{
				_originalMaterial = _projector.material;
				_projectorMaterial = UnityEngine.Object.Instantiate(_projector.material);
				_projector.material = _projectorMaterial;
				if (!(_originalMaterial == null))
				{
					Vector3 zero = Vector3.zero;
					Vector2 value = new Vector2(1f / (float)TilesX, 1f / (float)TilesY);
					_projectorMaterial.SetTextureScale("_MainTex", value);
					_projectorMaterial.SetTextureOffset("_MainTex", zero);
					_isStarted = true;
					StartCoroutine(UpdateCorutine());
				}
			}
		}

		private IEnumerator UpdateCorutine()
		{
			_animationStartTime = Time.time;
			while (!_isCanceled)
			{
				UpdateFrame();
				float value = (Time.time - _animationStartTime) / _animationLifeTime;
				float num = FrameOverTime.Evaluate(Mathf.Clamp01(value));
				yield return new WaitForSeconds(1f / (Fps * num));
			}
		}

		private void UpdateFrame()
		{
			_currentNumOfTexture++;
			_index++;
			if (_index >= _countOfTextures)
			{
				_index = 0;
			}
			if (_currentNumOfTexture == _countOfTextures)
			{
				_animationStartTime = Time.time;
				_currentNumOfTexture = 0;
			}
			Vector2 value = new Vector2((float)_index / (float)TilesX - (float)(_index / TilesX), 1f - (float)(_index / TilesX) / (float)TilesY);
			if (_projector != null)
			{
				_projectorMaterial.SetTextureOffset("_MainTex", value);
			}
		}

		private void Stop()
		{
			_isStarted = false;
			_isCanceled = true;
			StopAllCoroutines();
			_projector.material = _originalMaterial;
		}

		private void OnEnable()
		{
			Play();
		}

		private void OnDisable()
		{
			Stop();
		}

		private void OnDestroy()
		{
			Stop();
		}
	}
	internal sealed class UvAnimation : MonoBehaviour
	{
		public int TilesX = 4;

		public int TilesY = 4;

		public float Fps = 30f;

		public int StartFrameOffset;

		public bool IsLoop = true;

		public float StartDelay;

		public bool IsReverse;

		public bool IsBump;

		public AnimationCurve FrameOverTime = AnimationCurve.Linear(0f, 1f, 1f, 1f);

		private bool _isInizialised;

		private int _index;

		private int _count;

		private int _allCount;

		private float _animationLifeTime;

		private bool _isVisible;

		private bool _isCorutineStarted;

		private Renderer _currentRenderer;

		private Material _instanceMaterial;

		private float _animationStartTime;

		private bool _animationStoped;

		private void Start()
		{
			_currentRenderer = GetComponent<Renderer>();
			InitDefaultVariables();
			_isInizialised = true;
			_isVisible = true;
			Play();
		}

		private void InitDefaultVariables()
		{
			_currentRenderer = GetComponent<Renderer>();
			if (_currentRenderer == null)
			{
				throw new Exception("UvTextureAnimator can't get renderer");
			}
			if (!_currentRenderer.enabled)
			{
				_currentRenderer.enabled = true;
			}
			_allCount = 0;
			_animationStoped = false;
			_animationLifeTime = (float)(TilesX * TilesY) / Fps;
			_count = TilesY * TilesX;
			_index = TilesX - 1;
			Vector3 zero = Vector3.zero;
			StartFrameOffset -= StartFrameOffset / _count * _count;
			Vector2 value = new Vector2(1f / (float)TilesX, 1f / (float)TilesY);
			if (_currentRenderer != null)
			{
				_instanceMaterial = _currentRenderer.material;
				_instanceMaterial.SetTextureScale("_MainTex", value);
				_instanceMaterial.SetTextureOffset("_MainTex", zero);
				if (IsBump)
				{
					_instanceMaterial.SetTextureScale("_BumpMap", value);
					_instanceMaterial.SetTextureOffset("_BumpMap", zero);
				}
			}
		}

		private void Play()
		{
			if (!_isCorutineStarted)
			{
				if (StartDelay > 0.0001f)
				{
					Invoke("PlayDelay", StartDelay);
				}
				else
				{
					StartCoroutine(UpdateCorutine());
				}
				_isCorutineStarted = true;
			}
		}

		private void PlayDelay()
		{
			StartCoroutine(UpdateCorutine());
		}

		private void OnEnable()
		{
			if (_isInizialised)
			{
				InitDefaultVariables();
				_isVisible = true;
				Play();
			}
		}

		private void OnDisable()
		{
			_isCorutineStarted = false;
			_isVisible = false;
			StopAllCoroutines();
			CancelInvoke("PlayDelay");
		}

		private IEnumerator UpdateCorutine()
		{
			_animationStartTime = Time.time;
			while (_isVisible && (IsLoop || !_animationStoped))
			{
				if (!IsReverse)
				{
					UpdateFrame();
				}
				else
				{
					UpdateFrameReversed();
				}
				if (!IsLoop && _animationStoped)
				{
					break;
				}
				float value = (Time.time - _animationStartTime) / _animationLifeTime;
				float num = FrameOverTime.Evaluate(Mathf.Clamp01(value));
				yield return new WaitForSeconds(1f / (Fps * num));
			}
			_isCorutineStarted = false;
		}

		private void UpdateFrame()
		{
			_allCount++;
			_index++;
			if (_index >= _count)
			{
				_index = 0;
			}
			if (_count == _allCount)
			{
				_animationStartTime = Time.time;
				_allCount = 0;
				_animationStoped = true;
			}
			Vector2 value = new Vector2((float)_index / (float)TilesX - (float)(_index / TilesX), 1f - (float)(_index / TilesX) / (float)TilesY);
			if (_currentRenderer != null)
			{
				_instanceMaterial.SetTextureOffset("_MainTex", value);
				if (IsBump)
				{
					_instanceMaterial.SetTextureOffset("_BumpMap", value);
				}
			}
		}

		private void UpdateFrameReversed()
		{
			_allCount--;
			_index--;
			if (_index <= 0)
			{
				_index = _count;
			}
			if (_count == _allCount)
			{
				_animationStartTime = Time.time;
				_allCount = 0;
				_animationStoped = true;
			}
			Vector2 value = new Vector2((float)_index / (float)TilesX - (float)(_index / TilesX), 1f - (float)(_index / TilesX) / (float)TilesY);
			if (_currentRenderer != null)
			{
				_instanceMaterial.SetTextureOffset("_MainTex", value);
				if (IsBump)
				{
					_instanceMaterial.SetTextureOffset("_BumpMap", value);
				}
			}
		}

		private void OnDestroy()
		{
			if (_instanceMaterial != null)
			{
				UnityEngine.Object.Destroy(_instanceMaterial);
				_instanceMaterial = null;
			}
		}
	}
}
namespace Assets.ImagyVFX.Scripts.MoveableLineRenderer
{
	internal sealed class MoveableLineRenderer : MonoBehaviour
	{
		public GameObject LineRendererPrefab;

		public float MinVertexDistance = 1f;

		public float LifeTime = 0.3f;

		public float Scale = 1f;

		public float Speed = 1f;

		public float Height = 1f;

		public float Gravity;

		private LineRenderer _lineRenderer;

		private Point[] _points;

		private int _pointsCount;

		private void Start()
		{
			_lineRenderer = UnityEngine.Object.Instantiate(LineRendererPrefab).GetComponent<LineRenderer>();
			_lineRenderer.enabled = true;
			_lineRenderer.transform.parent = base.transform;
			_points = new Point[100];
		}

		private void Update()
		{
			RemoveOutdatedPoints();
			if (_pointsCount == 0)
			{
				_points[_pointsCount++] = new Point(base.transform.position);
				_points[_pointsCount++] = new Point(base.transform.position);
			}
			bool flag = false;
			float sqrMagnitude = (_points[1].Position - base.transform.position).sqrMagnitude;
			if (sqrMagnitude > MinVertexDistance * MinVertexDistance && sqrMagnitude > MinVertexDistance * MinVertexDistance)
			{
				flag = true;
			}
			if (flag)
			{
				if (_pointsCount == _points.Length)
				{
					Array.Resize(ref _points, _points.Length + 50);
				}
				InsertPoint();
			}
			ApplyTurbulence();
			_lineRenderer.positionCount = _pointsCount;
			_lineRenderer.SetPositions((from t in _points
				where t != null
				select t.Position).ToArray());
		}

		private void InsertPoint()
		{
			for (int num = _pointsCount; num > 0; num--)
			{
				_points[num] = _points[num - 1];
			}
			_points[0] = new Point(base.transform.position);
			_pointsCount++;
		}

		private void RemoveOutdatedPoints()
		{
			if (_pointsCount == 0)
			{
				return;
			}
			for (int num = _pointsCount - 1; num >= 0; num--)
			{
				Point point = _points[num];
				if (point == null || point.TimeAlive >= LifeTime)
				{
					_points[num] = null;
					_pointsCount--;
				}
			}
		}

		private void ApplyTurbulence()
		{
			for (int num = _pointsCount - 1; num >= 0; num--)
			{
				if (_points[num] != null)
				{
					Vector3 position = _points[num].Position;
					_points[num].Position = TurbulenceUtil.Calc(position, Speed, Scale, Height, Gravity);
				}
			}
		}
	}
	internal sealed class Point
	{
		public Vector3 Position;

		private readonly float _timeCreated;

		public float TimeAlive => Time.time - _timeCreated;

		public Point(Vector3 position)
		{
			Position = position;
			_timeCreated = Time.time;
		}
	}
	internal static class TurbulenceUtil
	{
		public static Vector3 Calc(Vector3 position, float speed, float scale, float height, float gravity)
		{
			float num = Time.deltaTime * speed;
			float x = position.x + num;
			float num2 = position.y + num;
			float y = position.z + num;
			position.x += (Mathf.PerlinNoise(num2, y) - 0.5f) * height;
			position.y += (Mathf.PerlinNoise(x, y) - 0.5f) * height - gravity;
			position.z += (Mathf.PerlinNoise(x, num2) - 0.5f) * height;
			return position;
		}
	}
}
namespace Assets.ImagyVFX.Scripts.Metaball
{
	internal sealed class MetaballController : MonoBehaviour
	{
		public GameObject MetaballParticles;

		public GameObject MetaballCamera;

		public Material MetaballCameraMaterial;

		private Camera _metaballCamera;

		private GameObject _instMetaballParticles;

		private GameObject _mainCamera;

		private MetaballPostProcessing _metaballPostProcessingComponent;

		private void Start()
		{
			_mainCamera = Camera.main.gameObject;
			Transform trMainCamera = _mainCamera.transform;
			InstantiateCamera(trMainCamera);
			SetupPostProcessing();
			InstantiateParticles();
		}

		private void InstantiateCamera(Transform trMainCamera)
		{
			_metaballCamera = UnityEngine.Object.Instantiate(MetaballCamera).GetComponent<Camera>();
			_metaballCamera.transform.position = trMainCamera.position;
			_metaballCamera.transform.rotation = trMainCamera.rotation;
			_metaballCamera.transform.parent = trMainCamera;
		}

		private void SetupPostProcessing()
		{
			_metaballPostProcessingComponent = _mainCamera.GetComponent<MetaballPostProcessing>();
			_metaballPostProcessingComponent.Init(_metaballCamera, MetaballCameraMaterial);
			_metaballPostProcessingComponent.enabled = true;
		}

		private void InstantiateParticles()
		{
			_instMetaballParticles = UnityEngine.Object.Instantiate(MetaballParticles);
			_instMetaballParticles.SetActive(value: true);
			_instMetaballParticles.transform.parent = base.transform;
			_instMetaballParticles.transform.position = base.transform.position;
		}

		private void OnDestroy()
		{
			_metaballPostProcessingComponent.enabled = false;
			if (_metaballCamera != null)
			{
				UnityEngine.Object.Destroy(_metaballCamera.gameObject);
			}
		}
	}
	internal sealed class MetaballPostProcessing : MonoBehaviour
	{
		private Material _material;

		private Camera _camera;

		private RenderTexture _renderTexture;

		public void Init(Camera camera, Material material)
		{
			_camera = camera;
			_material = material;
			_renderTexture = new RenderTexture(Screen.width, Screen.height, 24);
			_camera.enabled = false;
			_camera.targetTexture = _renderTexture;
		}

		private void OnRenderImage(RenderTexture src, RenderTexture dest)
		{
			_camera.Render();
			Graphics.Blit(_renderTexture, src, _material);
			Graphics.Blit(src, dest);
		}
	}
}
namespace Assets.ImagyVFX.Scripts.EffectsSequence
{
	internal sealed class EffectsSequence : MonoBehaviour
	{
		public SequencePart[] EffectParts;

		public bool IsLoopBack;

		private int _effectIndex;

		private void Start()
		{
			if (EffectParts.Length != 0)
			{
				RunEffect();
			}
		}

		private void RunEffect()
		{
			SequencePart sequencePart = EffectParts[_effectIndex++];
			sequencePart.Run(base.transform);
			Invoke("CallNext", sequencePart.CallNextDelay);
		}

		private void CallNext()
		{
			if (_effectIndex >= EffectParts.Length)
			{
				if (!IsLoopBack)
				{
					return;
				}
				_effectIndex = 0;
			}
			RunEffect();
		}
	}
	internal sealed class SequencePart : MonoBehaviour
	{
		public bool ShouldInstantiate = true;

		public GameObject EffectPrefab;

		public float LifeTime;

		public float CallNextDelay;

		public float Delay;

		private Transform _transformParent;

		public void Run(Transform transformParent)
		{
			_transformParent = transformParent;
			Invoke("InternalRun", Delay);
		}

		private void InternalRun()
		{
			GameObject gameObject = (ShouldInstantiate ? UnityEngine.Object.Instantiate(EffectPrefab) : base.gameObject);
			gameObject.SetActive(value: true);
			gameObject.transform.parent = _transformParent;
			if (ShouldInstantiate && EffectPrefab != null)
			{
				gameObject.transform.position = _transformParent.position + EffectPrefab.transform.position;
			}
			UnityEngine.Object.Destroy(gameObject, LifeTime);
		}
	}
}
namespace Assets.ImagyVFX.Scripts.CollisionUtils
{
	internal sealed class CollisionDetector : MonoBehaviour
	{
		public float CollisionDistance;

		private Transform _transform;

		public event Action<Vector3> CollisionDetected;

		private void Start()
		{
			_transform = base.transform;
		}

		private void FixedUpdate()
		{
			if (Physics.Raycast(_transform.position, -base.transform.up, out var hitInfo, CollisionDistance) && !(Vector3.Distance(_transform.position, hitInfo.point) > CollisionDistance) && this.CollisionDetected != null)
			{
				this.CollisionDetected(hitInfo.point);
			}
		}
	}
	[RequireComponent(typeof(CollisionDetector))]
	internal sealed class CollisionSpawner : MonoBehaviour
	{
		public GameObject CollisionEffectPrefab;

		public float LifeTime = 1f;

		public bool SpawnDecal;

		public GameObject DecalPrefab;

		private bool _isAlreadySpawned;

		private CollisionDetector _collisionDetector;

		private void Start()
		{
			_collisionDetector = GetComponent<CollisionDetector>();
			_collisionDetector.CollisionDetected += OnCollisionDetected;
		}

		private void OnCollisionDetected(Vector3 hit)
		{
			if (!_isAlreadySpawned)
			{
				InstantiateImpactEffect(hit);
				InstantiateDecal(hit);
				Invoke("Reset", LifeTime);
				_isAlreadySpawned = true;
			}
		}

		private void InstantiateImpactEffect(Vector3 pos)
		{
			GameObject obj = UnityEngine.Object.Instantiate(CollisionEffectPrefab, pos, CollisionEffectPrefab.transform.rotation);
			obj.transform.position = pos;
			UnityEngine.Object.Destroy(obj, LifeTime);
		}

		private void InstantiateDecal(Vector3 pos)
		{
			GameObject obj = UnityEngine.Object.Instantiate(DecalPrefab, pos, DecalPrefab.transform.rotation);
			obj.transform.position = pos;
			UnityEngine.Object.Destroy(obj, LifeTime);
		}

		private void Reset()
		{
			_isAlreadySpawned = false;
		}

		private void OnDestroy()
		{
			_collisionDetector.CollisionDetected -= OnCollisionDetected;
		}
	}
}
namespace VRUiKits.Utils
{
	public class ImageHoverOutline : MonoBehaviour, IPointerEnterHandler, IEventSystemHandler, IPointerExitHandler
	{
		public Image targetImage;

		public Color outlineColor = Color.black;

		public float outlineWidth = 1f;

		private UnityEngine.UI.Outline outline;

		private UnityEngine.UI.Outline _Outline
		{
			get
			{
				if (null == outline)
				{
					if (null == targetImage)
					{
						outline = null;
						return outline;
					}
					if (null == targetImage.GetComponent<UnityEngine.UI.Outline>())
					{
						targetImage.gameObject.AddComponent<UnityEngine.UI.Outline>();
					}
					outline = targetImage.GetComponent<UnityEngine.UI.Outline>();
					outline.effectColor = outlineColor;
					outline.effectDistance = new Vector2(outlineWidth, 0f - outlineWidth);
					outline.enabled = false;
				}
				return outline;
			}
		}

		public void OnPointerEnter(PointerEventData eventData)
		{
			if (null != _Outline)
			{
				_Outline.enabled = true;
			}
		}

		public void OnPointerExit(PointerEventData eventData)
		{
			if (null != _Outline)
			{
				_Outline.enabled = false;
			}
		}
	}
	public class TextHoverScale : MonoBehaviour, IPointerEnterHandler, IEventSystemHandler, IPointerExitHandler
	{
		public Text targetText;

		public float scale = 1.1f;

		private int originSize;

		private Text TargetText
		{
			get
			{
				if (null == targetText && null != GetComponentInChildren<Text>())
				{
					targetText = GetComponentInChildren<Text>();
				}
				return targetText;
			}
		}

		public void OnPointerEnter(PointerEventData eventData)
		{
			if (null != TargetText)
			{
				originSize = TargetText.fontSize;
				TargetText.fontSize = (int)Mathf.Round((float)TargetText.fontSize * scale);
			}
		}

		public void OnPointerExit(PointerEventData eventData)
		{
			if (null != TargetText)
			{
				TargetText.fontSize = originSize;
			}
		}
	}
	public class GazeInputModule : UIKitInputModule
	{
		public bool previewWithoutHeadset;

		public bool preventRepeatClick;

		public RaycastResult currentRaycast;

		public static GazeInputModule Instance;

		private PointerEventData pointerEventData;

		private PointerEventData lastPressedEventData;

		private GameObject currentTarget;

		private float currentClickTime;

		protected GazeInputModule()
		{
			Instance = this;
		}

		public override void Process()
		{
			GazeControl();
			HandleSelection();
		}

		private void GazeControl()
		{
			if (pointerEventData == null)
			{
				pointerEventData = new PointerEventData(base.eventSystem);
			}
			pointerEventData.position = new Vector2(XRSettings.eyeTextureWidth / 2, XRSettings.eyeTextureHeight / 2);
			pointerEventData.delta = Vector2.zero;
			List<RaycastResult> list = new List<RaycastResult>();
			base.eventSystem.RaycastAll(pointerEventData, list);
			RaycastResult raycastResult2 = (pointerEventData.pointerCurrentRaycast = BaseInputModule.FindFirstRaycast(list));
			currentRaycast = raycastResult2;
			ProcessMove(pointerEventData);
		}

		private void HandleSelection()
		{
			if (null != pointerEventData.pointerEnter)
			{
				GameObject eventHandler = ExecuteEvents.GetEventHandler<IPointerClickHandler>(pointerEventData.pointerEnter);
				if (currentTarget != eventHandler)
				{
					currentTarget = eventHandler;
					currentClickTime = Time.realtimeSinceStartup + delayTimeInSeconds + gazeTimeInSeconds;
					RaiseGazeChangeEvent(currentTarget);
					ReleaseLastPress();
				}
				if (null != currentTarget && Time.realtimeSinceStartup > currentClickTime)
				{
					GameObject pointerPress = ExecuteEvents.ExecuteHierarchy(currentTarget, pointerEventData, ExecuteEvents.pointerDownHandler);
					pointerEventData.pointerPress = pointerPress;
					ExecuteEvents.ExecuteHierarchy(currentTarget, pointerEventData, ExecuteEvents.pointerClickHandler);
					lastPressedEventData = pointerEventData;
					if (preventRepeatClick)
					{
						currentClickTime = float.MaxValue;
					}
					else
					{
						currentTarget = null;
					}
				}
			}
			else
			{
				currentTarget = null;
				RaiseGazeChangeEvent(currentTarget);
				ReleaseLastPress();
			}
		}

		private void ReleaseLastPress()
		{
			if (lastPressedEventData != null)
			{
				ExecuteEvents.Execute(lastPressedEventData.pointerPress, lastPressedEventData, ExecuteEvents.pointerUpHandler);
				lastPressedEventData = null;
			}
		}

		public override void ActivateModule()
		{
			base.ActivateModule();
			GameObject gameObject = base.eventSystem.currentSelectedGameObject;
			if (gameObject == null)
			{
				gameObject = base.eventSystem.firstSelectedGameObject;
			}
			base.eventSystem.SetSelectedGameObject(gameObject, GetBaseEventData());
		}

		public override void DeactivateModule()
		{
			base.DeactivateModule();
			ClearSelection();
		}

		protected void ClearSelection()
		{
			BaseEventData baseEventData = GetBaseEventData();
			base.eventSystem.SetSelectedGameObject(null, baseEventData);
		}

		protected virtual void ProcessMove(PointerEventData pointerEvent)
		{
			GameObject newEnterTarget = ((Cursor.lockState == CursorLockMode.Locked) ? null : pointerEvent.pointerCurrentRaycast.gameObject);
			HandlePointerExitAndEnter(pointerEvent, newEnterTarget);
		}
	}
	[RequireComponent(typeof(VREventSystemHelper))]
	public class LaserInputModule : UIKitInputModule
	{
		public VRPlatform platform;

		public Pointer pointer = Pointer.LeftHand;

		public OVRInput.Button trigger = OVRInput.Button.PrimaryIndexTrigger;

		private OVRInput.Controller activeController;

		private OVRCameraRig oculusRig;

		private GameObject currentTarget;

		private float currentClickTime;

		private static LaserInputModule _instance;

		private Camera helperCamera;

		private UIKitPointer controller;

		private bool triggerPressed;

		private bool triggerPressedLastFrame;

		private PointerEventData pointerEventData;

		private Vector3 lastRaycastHitPoint;

		private float pressedDistance;

		public Transform TargetControllerTransform
		{
			get
			{
				if (pointer == Pointer.LeftHand)
				{
					return oculusRig.leftHandAnchor;
				}
				if (pointer == Pointer.RightHand)
				{
					return oculusRig.rightHandAnchor;
				}
				return oculusRig.centerEyeAnchor;
			}
		}

		public static LaserInputModule instance => _instance;

		protected override void Awake()
		{
			base.Awake();
			if (_instance == null)
			{
				_instance = this;
			}
			else if (_instance != this)
			{
				UnityEngine.Debug.LogWarning("Trying to instantiate multiple UIKitLaserInputModule.");
				UnityEngine.Object.Destroy(base.gameObject);
			}
		}

		protected override void Start()
		{
			base.Start();
			helperCamera = new GameObject("Helper Camera").AddComponent<Camera>();
			helperCamera.transform.parent = base.transform;
			helperCamera.gameObject.AddComponent<PhysicsRaycaster>();
			helperCamera.cullingMask = 0;
			helperCamera.clearFlags = CameraClearFlags.Nothing;
			helperCamera.nearClipPlane = 0.01f;
			helperCamera.enabled = false;
			SetCanvasCamera();
			SetupHmd();
			SceneManager.sceneLoaded += OnSceneLoaded;
		}

		private void OnSceneLoaded(Scene scene, LoadSceneMode mode)
		{
			SetCanvasCamera();
			SetupHmd();
		}

		private void SetCanvasCamera()
		{
			if (null != helperCamera)
			{
				Canvas[] array = Resources.FindObjectsOfTypeAll<Canvas>();
				for (int i = 0; i < array.Length; i++)
				{
					array[i].worldCamera = helperCamera;
				}
			}
		}

		private void SetupHmd()
		{
			SetupOculus();
		}

		public void SetController(UIKitPointer _controller)
		{
			controller = _controller;
		}

		public void RemoveController(UIKitPointer _controller)
		{
			if (null != controller && controller == _controller)
			{
				controller = null;
			}
		}

		public override void Process()
		{
			if (null != controller)
			{
				UpdateHelperCamera();
				if (pointer == Pointer.Eye)
				{
					ProcessGazePointer();
					return;
				}
				CheckTriggerStatus();
				ProcessLaserPointer();
			}
		}

		private void UpdateHelperCamera()
		{
			helperCamera.transform.position = controller.transform.position;
			helperCamera.transform.rotation = controller.transform.rotation;
		}

		private void CheckTriggerStatus()
		{
			activeController = OVRInput.GetActiveController();
			if (activeController == OVRInput.Controller.Touch || activeController == OVRInput.Controller.LTouch || activeController == OVRInput.Controller.RTouch)
			{
				if (pointer == Pointer.LeftHand)
				{
					triggerPressed = OVRInput.Get(trigger, OVRInput.Controller.LTouch);
				}
				else if (pointer == Pointer.RightHand)
				{
					triggerPressed = OVRInput.Get(trigger, OVRInput.Controller.RTouch);
				}
			}
			else
			{
				triggerPressed = OVRInput.Get(trigger);
			}
		}

		private void ProcessGazePointer()
		{
			SendUpdateEventToSelectedObject();
			PointerEventData pointerEventData = GetPointerEventData();
			ProcessMove(pointerEventData);
			if (null != pointerEventData.pointerEnter)
			{
				GameObject eventHandler = ExecuteEvents.GetEventHandler<IPointerClickHandler>(pointerEventData.pointerEnter);
				if (currentTarget != eventHandler)
				{
					currentTarget = eventHandler;
					currentClickTime = Time.realtimeSinceStartup + delayTimeInSeconds + gazeTimeInSeconds;
					RaiseGazeChangeEvent(currentTarget);
				}
				if (null != currentTarget && Time.realtimeSinceStartup > currentClickTime)
				{
					ExecuteEvents.ExecuteHierarchy(currentTarget, pointerEventData, ExecuteEvents.pointerClickHandler);
					currentTarget = null;
					RaiseGazeChangeEvent(currentTarget);
				}
			}
			else
			{
				currentTarget = null;
				RaiseGazeChangeEvent(currentTarget);
			}
		}

		private void ProcessLaserPointer()
		{
			SendUpdateEventToSelectedObject();
			PointerEventData pointerEventData = GetPointerEventData();
			ProcessPress(pointerEventData);
			ProcessMove(pointerEventData);
			if (triggerPressed)
			{
				ProcessDrag(pointerEventData);
				if (!Mathf.Approximately(pointerEventData.scrollDelta.sqrMagnitude, 0f))
				{
					ExecuteEvents.ExecuteHierarchy(ExecuteEvents.GetEventHandler<IScrollHandler>(pointerEventData.pointerCurrentRaycast.gameObject), pointerEventData, ExecuteEvents.scrollHandler);
				}
			}
			triggerPressedLastFrame = triggerPressed;
		}

		private void ProcessPress(PointerEventData eventData)
		{
			GameObject gameObject = eventData.pointerCurrentRaycast.gameObject;
			if (TriggerPressedThisFrame())
			{
				eventData.eligibleForClick = true;
				eventData.delta = Vector2.zero;
				eventData.dragging = false;
				eventData.useDragThreshold = true;
				eventData.pressPosition = eventData.position;
				eventData.pointerPressRaycast = eventData.pointerCurrentRaycast;
				pressedDistance = 0f;
				if (eventData.pointerEnter != gameObject)
				{
					HandlePointerExitAndEnter(eventData, gameObject);
					eventData.pointerEnter = gameObject;
				}
				GameObject gameObject2 = ExecuteEvents.ExecuteHierarchy(gameObject, eventData, ExecuteEvents.pointerDownHandler);
				if (gameObject2 == null)
				{
					gameObject2 = ExecuteEvents.GetEventHandler<IPointerClickHandler>(gameObject);
				}
				float unscaledTime = Time.unscaledTime;
				if (gameObject2 == eventData.lastPress)
				{
					if (unscaledTime - eventData.clickTime < 0.3f)
					{
						int clickCount = eventData.clickCount + 1;
						eventData.clickCount = clickCount;
					}
					else
					{
						eventData.clickCount = 1;
					}
					eventData.clickTime = unscaledTime;
				}
				else
				{
					eventData.clickCount = 1;
				}
				eventData.pointerPress = gameObject2;
				eventData.rawPointerPress = gameObject;
				eventData.clickTime = unscaledTime;
				eventData.pointerDrag = ExecuteEvents.GetEventHandler<IDragHandler>(gameObject);
				if (eventData.pointerDrag != null)
				{
					ExecuteEvents.Execute(eventData.pointerDrag, eventData, ExecuteEvents.initializePotentialDrag);
				}
			}
			if (TriggerReleasedThisFrame())
			{
				ExecuteEvents.Execute(eventData.pointerPress, eventData, ExecuteEvents.pointerUpHandler);
				GameObject eventHandler = ExecuteEvents.GetEventHandler<IPointerClickHandler>(gameObject);
				if (eventData.pointerPress == eventHandler && eventData.eligibleForClick)
				{
					ExecuteEvents.Execute(eventData.pointerPress, eventData, ExecuteEvents.pointerClickHandler);
				}
				else if (eventData.pointerDrag != null && eventData.dragging)
				{
					ExecuteEvents.ExecuteHierarchy(gameObject, eventData, ExecuteEvents.dropHandler);
				}
				eventData.eligibleForClick = false;
				eventData.pointerPress = null;
				eventData.rawPointerPress = null;
				pressedDistance = 0f;
				if (eventData.pointerDrag != null && eventData.dragging)
				{
					ExecuteEvents.Execute(eventData.pointerDrag, eventData, ExecuteEvents.endDragHandler);
				}
				eventData.dragging = false;
				eventData.pointerDrag = null;
				ExecuteEvents.ExecuteHierarchy(eventData.pointerEnter, eventData, ExecuteEvents.pointerExitHandler);
				eventData.pointerEnter = null;
			}
		}

		private PointerEventData GetPointerEventData()
		{
			if (pointerEventData == null)
			{
				pointerEventData = new PointerEventData(base.eventSystem);
			}
			pointerEventData.Reset();
			pointerEventData.position = new Vector2(helperCamera.pixelWidth / 2, helperCamera.pixelHeight / 2);
			pointerEventData.scrollDelta = Vector2.zero;
			base.eventSystem.RaycastAll(pointerEventData, m_RaycastResultCache);
			RaycastResult pointerCurrentRaycast = BaseInputModule.FindFirstRaycast(m_RaycastResultCache);
			pointerEventData.pointerCurrentRaycast = pointerCurrentRaycast;
			Vector3 point = new Ray(helperCamera.transform.position, helperCamera.transform.forward).GetPoint(pointerCurrentRaycast.distance);
			Vector3 from = Vector3.Normalize(helperCamera.transform.position - point);
			Vector3 to = Vector3.Normalize(helperCamera.transform.position - lastRaycastHitPoint);
			pointerEventData.delta = new Vector2(Vector3.Angle(from, to), 0f);
			lastRaycastHitPoint = point;
			m_RaycastResultCache.Clear();
			return pointerEventData;
		}

		private bool TriggerReleasedThisFrame()
		{
			if (triggerPressedLastFrame)
			{
				return !triggerPressed;
			}
			return false;
		}

		private bool TriggerPressedThisFrame()
		{
			if (!triggerPressedLastFrame)
			{
				return triggerPressed;
			}
			return false;
		}

		private bool SendUpdateEventToSelectedObject()
		{
			if (base.eventSystem.currentSelectedGameObject == null)
			{
				return false;
			}
			BaseEventData baseEventData = GetBaseEventData();
			ExecuteEvents.Execute(base.eventSystem.currentSelectedGameObject, baseEventData, ExecuteEvents.updateSelectedHandler);
			return baseEventData.used;
		}

		public override void ActivateModule()
		{
			base.ActivateModule();
			GameObject gameObject = base.eventSystem.currentSelectedGameObject;
			if (gameObject == null)
			{
				gameObject = base.eventSystem.firstSelectedGameObject;
			}
			base.eventSystem.SetSelectedGameObject(gameObject, GetBaseEventData());
		}

		public override void DeactivateModule()
		{
			base.DeactivateModule();
			ClearSelection();
		}

		protected void ClearSelection()
		{
			BaseEventData baseEventData = GetBaseEventData();
			base.eventSystem.SetSelectedGameObject(null, baseEventData);
		}

		private bool ShouldStartDrag(float threshold, bool useDragThreshold)
		{
			if (!useDragThreshold)
			{
				return true;
			}
			return pressedDistance >= threshold;
		}

		protected virtual void ProcessMove(PointerEventData pointerEvent)
		{
			GameObject newEnterTarget = ((Cursor.lockState == CursorLockMode.Locked) ? null : pointerEvent.pointerCurrentRaycast.gameObject);
			HandlePointerExitAndEnter(pointerEvent, newEnterTarget);
		}

		private void ProcessDrag(PointerEventData eventData)
		{
			if (!eventData.IsPointerMoving() || eventData.pointerDrag == null)
			{
				return;
			}
			if (!eventData.dragging)
			{
				pressedDistance += eventData.delta.x;
				if (ShouldStartDrag(base.eventSystem.pixelDragThreshold, eventData.useDragThreshold))
				{
					ExecuteEvents.Execute(eventData.pointerDrag, eventData, ExecuteEvents.beginDragHandler);
					eventData.dragging = true;
				}
			}
			if (eventData.dragging)
			{
				if (eventData.pointerPress != eventData.pointerDrag)
				{
					ExecuteEvents.Execute(eventData.pointerPress, eventData, ExecuteEvents.pointerUpHandler);
					eventData.eligibleForClick = false;
					eventData.pointerPress = null;
					eventData.rawPointerPress = null;
				}
				ExecuteEvents.Execute(eventData.pointerDrag, eventData, ExecuteEvents.dragHandler);
			}
		}

		private void SetupOculus()
		{
			if (null != OVRManager.instance)
			{
				oculusRig = OVRManager.instance.GetComponent<OVRCameraRig>();
			}
			if (null == oculusRig)
			{
				oculusRig = UnityEngine.Object.FindObjectOfType<OVRCameraRig>();
			}
			if (null == oculusRig)
			{
				UnityEngine.Debug.LogError("Please import Oculus Utilities and put OVRCameraRig prefab into your scene");
			}
		}
	}
	public enum VRPlatform
	{
		NONE,
		OCULUS,
		VIVE,
		VIVE_STEAM2
	}
	public enum Pointer
	{
		RightHand,
		LeftHand,
		Eye
	}
	public class MouseInputModule : StandaloneInputModule
	{
		public override void Process()
		{
			bool flag = SendUpdateEventToSelectedObject();
			if (base.eventSystem.sendNavigationEvents)
			{
				if (!flag)
				{
					flag |= SendMoveEventToSelectedObject();
				}
				if (!flag)
				{
					SendSubmitEventToSelectedObject();
				}
			}
			ProcessMouseEvent();
		}

		protected new void ProcessMouseEvent()
		{
			MouseState mousePointerEventData = GetMousePointerEventData();
			bool pressed = mousePointerEventData.AnyPressesThisFrame();
			bool released = mousePointerEventData.AnyReleasesThisFrame();
			MouseButtonEventData eventData = mousePointerEventData.GetButtonState(PointerEventData.InputButton.Left).eventData;
			if (UseMouse(pressed, released, eventData.buttonData))
			{
				ProcessMousePress(eventData);
				ProcessMove(eventData.buttonData);
				ProcessDrag(eventData.buttonData);
				ProcessMousePress(mousePointerEventData.GetButtonState(PointerEventData.InputButton.Right).eventData);
				ProcessDrag(mousePointerEventData.GetButtonState(PointerEventData.InputButton.Right).eventData.buttonData);
				ProcessMousePress(mousePointerEventData.GetButtonState(PointerEventData.InputButton.Middle).eventData);
				ProcessDrag(mousePointerEventData.GetButtonState(PointerEventData.InputButton.Middle).eventData.buttonData);
				if (!Mathf.Approximately(eventData.buttonData.scrollDelta.sqrMagnitude, 0f))
				{
					ExecuteEvents.ExecuteHierarchy(ExecuteEvents.GetEventHandler<IScrollHandler>(eventData.buttonData.pointerCurrentRaycast.gameObject), eventData.buttonData, ExecuteEvents.scrollHandler);
				}
			}
		}

		private static bool UseMouse(bool pressed, bool released, PointerEventData pointerData)
		{
			if (pressed || released || pointerData.IsPointerMoving() || pointerData.IsScrolling())
			{
				return true;
			}
			return false;
		}

		protected new void ProcessMousePress(MouseButtonEventData data)
		{
			PointerEventData buttonData = data.buttonData;
			GameObject gameObject = buttonData.pointerCurrentRaycast.gameObject;
			if (data.PressedThisFrame())
			{
				buttonData.eligibleForClick = true;
				buttonData.delta = Vector2.zero;
				buttonData.dragging = false;
				buttonData.useDragThreshold = true;
				buttonData.pressPosition = buttonData.position;
				buttonData.pointerPressRaycast = buttonData.pointerCurrentRaycast;
				GameObject gameObject2 = ExecuteEvents.ExecuteHierarchy(gameObject, buttonData, ExecuteEvents.pointerDownHandler);
				if (gameObject2 == null)
				{
					gameObject2 = ExecuteEvents.GetEventHandler<IPointerClickHandler>(gameObject);
				}
				float unscaledTime = Time.unscaledTime;
				if (gameObject2 == buttonData.lastPress)
				{
					if (unscaledTime - buttonData.clickTime < 0.3f)
					{
						int clickCount = buttonData.clickCount + 1;
						buttonData.clickCount = clickCount;
					}
					else
					{
						buttonData.clickCount = 1;
					}
					buttonData.clickTime = unscaledTime;
				}
				else
				{
					buttonData.clickCount = 1;
				}
				buttonData.pointerPress = gameObject2;
				buttonData.rawPointerPress = gameObject;
				buttonData.clickTime = unscaledTime;
				buttonData.pointerDrag = ExecuteEvents.GetEventHandler<IDragHandler>(gameObject);
				if (buttonData.pointerDrag != null)
				{
					ExecuteEvents.Execute(buttonData.pointerDrag, buttonData, ExecuteEvents.initializePotentialDrag);
				}
			}
			if (data.ReleasedThisFrame())
			{
				ExecuteEvents.Execute(buttonData.pointerPress, buttonData, ExecuteEvents.pointerUpHandler);
				GameObject eventHandler = ExecuteEvents.GetEventHandler<IPointerClickHandler>(gameObject);
				if (buttonData.pointerPress == eventHandler && buttonData.eligibleForClick)
				{
					ExecuteEvents.Execute(buttonData.pointerPress, buttonData, ExecuteEvents.pointerClickHandler);
				}
				else if (buttonData.pointerDrag != null)
				{
					ExecuteEvents.ExecuteHierarchy(gameObject, buttonData, ExecuteEvents.dropHandler);
				}
				buttonData.eligibleForClick = false;
				buttonData.pointerPress = null;
				buttonData.rawPointerPress = null;
				if (buttonData.pointerDrag != null && buttonData.dragging)
				{
					ExecuteEvents.Execute(buttonData.pointerDrag, buttonData, ExecuteEvents.endDragHandler);
				}
				buttonData.dragging = false;
				buttonData.pointerDrag = null;
				if (gameObject != buttonData.pointerEnter)
				{
					HandlePointerExitAndEnter(buttonData, null);
					HandlePointerExitAndEnter(buttonData, gameObject);
				}
			}
		}
	}
	public class GazeProgressCircle : MonoBehaviour
	{
		public Image circle;

		private Coroutine fillCircle;

		private UIKitInputModule m_inputModule;

		private void Start()
		{
			m_inputModule = UnityEngine.Object.FindObjectOfType<UIKitInputModule>();
			m_inputModule.OnGazeChanged += HandleProgressCircle;
		}

		private void HandleProgressCircle(GameObject target)
		{
			if (fillCircle != null)
			{
				StopCoroutine(fillCircle);
			}
			ResetGazer();
			if (null != target)
			{
				fillCircle = StartCoroutine(FillCircle());
			}
		}

		private IEnumerator FillCircle()
		{
			float timer = 0f;
			circle.fillAmount = 0f;
			yield return new WaitForSeconds(m_inputModule.delayTimeInSeconds);
			while (timer < m_inputModule.gazeTimeInSeconds)
			{
				timer += Time.deltaTime;
				circle.fillAmount = timer / m_inputModule.gazeTimeInSeconds;
				yield return null;
			}
			circle.fillAmount = 1f;
			ResetGazer();
		}

		private void ResetGazer()
		{
			if (circle == null)
			{
				UnityEngine.Debug.LogError("Please assign target loading image, (ie. circle image)");
			}
			else
			{
				circle.fillAmount = 0f;
			}
		}
	}
	public class LaserPointer : MonoBehaviour
	{
		private LineRenderer lr;

		private void Awake()
		{
			lr = GetComponent<LineRenderer>();
		}

		private void LateUpdate()
		{
			lr.SetPosition(0, base.transform.position);
			Vector3 direction = base.transform.TransformDirection(Vector3.forward);
			if (Physics.Raycast(base.transform.position, direction, out var hitInfo))
			{
				if ((bool)hitInfo.collider)
				{
					lr.SetPosition(1, hitInfo.point);
				}
			}
			else
			{
				lr.SetPosition(1, base.transform.forward * 5000f);
			}
		}

		private void OnDisable()
		{
			if (null != lr)
			{
				lr.SetPosition(0, Vector3.zero);
				lr.SetPosition(1, Vector3.zero);
			}
		}
	}
	public class UIKitPointer : MonoBehaviour
	{
		public GameObject gazePointer;

		public GameObject laser;

		private Pointer? temp;

		[SerializeField]
		private bool allowAutoSwitchHand;

		private void Start()
		{
			if (!(null == LaserInputModule.instance))
			{
				LaserInputModule.instance.SetController(this);
			}
		}

		private void Update()
		{
			bool flag = LaserInputModule.instance.pointer == Pointer.Eye;
			if (temp != LaserInputModule.instance.pointer)
			{
				gazePointer.SetActive(flag);
				laser.SetActive(!flag);
				SetPointer(LaserInputModule.instance.pointer);
				temp = LaserInputModule.instance.pointer;
			}
			if (allowAutoSwitchHand)
			{
				if (OVRInput.GetDown(LaserInputModule.instance.trigger, OVRInput.Controller.RTouch) && LaserInputModule.instance.pointer != 0)
				{
					SetPointer(Pointer.RightHand);
				}
				else if (OVRInput.GetDown(LaserInputModule.instance.trigger, OVRInput.Controller.LTouch) && LaserInputModule.instance.pointer != Pointer.LeftHand)
				{
					SetPointer(Pointer.LeftHand);
				}
			}
		}

		private void SetPointer(Pointer targetPointer)
		{
			if (null != LaserInputModule.instance)
			{
				LaserInputModule.instance.pointer = targetPointer;
				base.transform.SetParent(LaserInputModule.instance.TargetControllerTransform);
				ResetTransform(base.transform);
			}
		}

		private void ResetTransform(Transform trans)
		{
			trans.localPosition = Vector3.zero;
			trans.localRotation = Quaternion.identity;
			trans.localScale = Vector3.one;
		}

		private void OnDestroy()
		{
			if (null != LaserInputModule.instance)
			{
				LaserInputModule.instance.RemoveController(this);
			}
		}

		private void OnEnable()
		{
			if (null != LaserInputModule.instance)
			{
				LaserInputModule.instance.SetController(this);
			}
		}

		private void OnDisable()
		{
			if (null != LaserInputModule.instance)
			{
				LaserInputModule.instance.RemoveController(this);
			}
		}
	}
	public class UIKitInputModule : BaseInputModule
	{
		public delegate void OnGazeChangedHandler(GameObject target);

		[HideInInspector]
		public float gazeTimeInSeconds = 1f;

		[HideInInspector]
		public float delayTimeInSeconds = 0.5f;

		public event OnGazeChangedHandler OnGazeChanged;

		protected void RaiseGazeChangeEvent(GameObject target)
		{
			if (this.OnGazeChanged != null)
			{
				this.OnGazeChanged(target);
			}
		}

		public override void Process()
		{
		}
	}
	[Serializable]
	public class Card
	{
		public string title;

		public string subtitle;

		public string description;

		public Sprite image;
	}
	public class CardItem : MonoBehaviour
	{
		public delegate void OnCardClickedHandler(Card card);

		public Transform title;

		public Transform subtitle;

		public Transform description;

		public Image image;

		private Card card;

		public Text Title
		{
			get
			{
				if (null != title)
				{
					return title.GetComponent<Text>();
				}
				return null;
			}
		}

		public Text Subtitle
		{
			get
			{
				if (null != subtitle)
				{
					return subtitle.GetComponent<Text>();
				}
				return null;
			}
		}

		public Text Description
		{
			get
			{
				if (null != description)
				{
					return description.GetComponent<Text>();
				}
				return null;
			}
		}

		public Card Card
		{
			get
			{
				return card;
			}
			set
			{
				card = value;
				if (null != Title)
				{
					Title.text = card.title;
				}
				if (null != Subtitle)
				{
					Subtitle.text = card.subtitle;
				}
				if (null != Description)
				{
					Description.text = card.description;
				}
				if (null != image)
				{
					image.sprite = card.image;
				}
			}
		}

		public event OnCardClickedHandler OnCardClicked;

		public void Awake()
		{
			if (null != GetComponent<Button>())
			{
				GetComponent<Button>().onClick.AddListener(delegate
				{
					this.OnCardClicked(card);
				});
			}
		}
	}
	public class CardListManager : MonoBehaviour
	{
		public Transform listContent;

		public GameObject itemTemplate;

		[HideInInspector]
		public List<Card> cardList = new List<Card>();

		private List<CardItem> cardItems = new List<CardItem>();

		[HideInInspector]
		public Card selectedCard;

		private void Awake()
		{
			itemTemplate.SetActive(value: false);
			PopulateList();
		}

		private void SetSelectedCard(Card card)
		{
			selectedCard = card;
		}

		public void Reset()
		{
			foreach (CardItem cardItem in cardItems)
			{
				Util.SafeDestroyGameObject(cardItem);
			}
			cardItems.Clear();
		}

		public void PopulateList()
		{
			for (int i = 0; i < cardList.Count; i++)
			{
				AddCardItem(cardList[i]);
			}
		}

		public void AddCardItem(Card card)
		{
			CardItem component = UnityEngine.Object.Instantiate(itemTemplate, listContent).GetComponent<CardItem>();
			component.Card = card;
			component.gameObject.SetActive(value: true);
			cardItems.Add(component);
			component.OnCardClicked += SetSelectedCard;
		}
	}
	public class InputFocusHelper : MonoBehaviour, ISelectHandler, IEventSystemHandler, IPointerClickHandler, IEndDragHandler
	{
		private InputField input;

		private int caretPosition;

		private int selectionAnchorPosition;

		private int selectionFocusPosition;

		private float originColorAlpha;

		private void Awake()
		{
			input = GetComponent<InputField>();
			originColorAlpha = input.selectionColor.a;
		}

		public void OnSelect(BaseEventData eventData)
		{
			KeyboardManager.Target = input;
			if (KeyboardManager.lastTarget != input)
			{
				StartCoroutine(ActivateInputFieldWithCaret(isMoveCaretToEnd: true));
			}
			else
			{
				StartCoroutine(ActivateInputFieldWithCaret(isMoveCaretToEnd: false));
			}
		}

		public void OnPointerClick(PointerEventData pointerEventData)
		{
			StorePositionInfo();
		}

		public virtual void OnEndDrag(PointerEventData eventData)
		{
			StorePositionInfo();
		}

		private IEnumerator ActivateInputFieldWithCaret(bool isMoveCaretToEnd)
		{
			SetSelectionAlpha(0f);
			yield return new WaitForEndOfFrame();
			input.MoveTextEnd(shift: false);
			if (!isMoveCaretToEnd)
			{
				SetPosition();
			}
			SetSelectionAlpha(originColorAlpha);
		}

		public void ForceActivate()
		{
			input.ActivateInputField();
		}

		public void StorePositionInfo()
		{
			caretPosition = input.caretPosition;
			selectionAnchorPosition = input.selectionAnchorPosition;
			selectionFocusPosition = input.selectionFocusPosition;
		}

		private void SetPosition()
		{
			input.caretPosition = caretPosition;
			input.selectionAnchorPosition = selectionAnchorPosition;
			input.selectionFocusPosition = selectionFocusPosition;
		}

		private void SetSelectionAlpha(float alpha)
		{
			Color selectionColor = input.selectionColor;
			selectionColor.a = alpha;
			input.selectionColor = selectionColor;
		}
	}
	public class UIKitInputField : MonoBehaviour, ISelectHandler, IEventSystemHandler, IPointerClickHandler, IDeselectHandler
	{
		public enum ContentType
		{
			Standard,
			Password
		}

		public RectTransform wrapper;

		public RectTransform m_textTransform;

		public RectTransform m_placeholderTransform;

		public RectTransform m_caretTransform;

		public string text;

		public int characterLimit;

		public ContentType contentType;

		[Range(0f, 4f)]
		public float caretBlinkRate = 0.85f;

		private float maxW_textComponent;

		private string displayedText;

		private string prevText = "";

		private Text textComponent;

		private Text caretText;

		private Text placeholder;

		private void Awake()
		{
			maxW_textComponent = wrapper.rect.width - 5f;
			textComponent = m_textTransform.GetComponent<Text>();
			placeholder = m_placeholderTransform.GetComponent<Text>();
			caretText = m_caretTransform.GetComponent<Text>();
		}

		public void OnSelect(BaseEventData eventData)
		{
			MobileKeyboardManager.Target = this;
			ForceCaretUpdate();
			m_caretTransform.gameObject.SetActive(value: true);
			StartCoroutine("BlinkCaret");
		}

		public void OnPointerClick(PointerEventData pointerEventData)
		{
			EventSystem.current.SetSelectedGameObject(base.gameObject);
		}

		public void OnDeselect(BaseEventData eventData)
		{
			m_caretTransform.gameObject.SetActive(value: false);
			StopCoroutine("BlinkCaret");
		}

		public void ForceCaretUpdate()
		{
			caretText.text = "";
		}

		private void LateUpdate()
		{
			if (characterLimit != 0 && text.Length > characterLimit)
			{
				text = text.Substring(0, characterLimit);
			}
			if (text == "")
			{
				placeholder.gameObject.SetActive(value: true);
			}
			else
			{
				placeholder.gameObject.SetActive(value: false);
			}
			if (!(prevText == text))
			{
				if (contentType == ContentType.Standard)
				{
					CalculateLengthOfText(text);
				}
				else if (contentType == ContentType.Password)
				{
					displayedText = new string('*', text.Length);
				}
				textComponent.text = displayedText;
				prevText = text;
			}
		}

		private void CalculateLengthOfText(string text)
		{
			int num = 0;
			displayedText = "";
			if (!(text != ""))
			{
				return;
			}
			Font font = textComponent.font;
			UnityEngine.CharacterInfo info = default(UnityEngine.CharacterInfo);
			font.RequestCharactersInTexture(text, textComponent.fontSize, textComponent.fontStyle);
			char[] array = text.ToCharArray();
			int num2 = text.Length - 1;
			while (num2 >= 0)
			{
				font.GetCharacterInfo(array[num2], out info, textComponent.fontSize, textComponent.fontStyle);
				num += info.advance;
				if ((float)num <= maxW_textComponent)
				{
					displayedText = array[num2] + displayedText;
					num2--;
					continue;
				}
				break;
			}
		}

		private IEnumerator BlinkCaret()
		{
			while (true)
			{
				if (caretText.text == "")
				{
					caretText.text = "|";
				}
				else
				{
					caretText.text = "";
				}
				yield return new WaitForSeconds(caretBlinkRate);
			}
		}
	}
	public class KeyboardExtentionMethods : MonoBehaviour
	{
		public GameObject symbols;

		public GameObject alphabets;

		private void Awake()
		{
			if (null == symbols || null == alphabets)
			{
				UnityEngine.Debug.LogError("Please assign Symbols and Alphabets game objects");
				return;
			}
			symbols.SetActive(value: false);
			alphabets.SetActive(value: true);
		}

		public void SwitchSymbols()
		{
			ToggleObject(symbols);
			ToggleObject(alphabets);
		}

		public void ToggleObject(GameObject go)
		{
			if (go.activeSelf)
			{
				go.SetActive(value: false);
			}
			else
			{
				go.SetActive(value: true);
			}
		}
	}
	public class KeyboardManager : MonoBehaviour
	{
		public delegate void OnInputValueUpdatedHandler(string value);

		[Header("User defined")]
		[Tooltip("If the character is uppercase at the initialization")]
		public bool isUppercase;

		[Header("Essentials")]
		public Transform keys;

		public static InputField lastTarget;

		private static InputField target;

		private Key[] keyList;

		private bool capslockFlag;

		public static InputField Target
		{
			get
			{
				GameObject currentSelectedGameObject = EventSystem.current.currentSelectedGameObject;
				if (null != currentSelectedGameObject && null != currentSelectedGameObject.GetComponent<InputField>())
				{
					return currentSelectedGameObject.GetComponent<InputField>();
				}
				if (null != target)
				{
					return target;
				}
				return null;
			}
			set
			{
				lastTarget = target;
				target = value;
			}
		}

		private string Input
		{
			get
			{
				if (null == Target)
				{
					return "";
				}
				return Target.text;
			}
			set
			{
				if (!(null == Target))
				{
					Target.text = value;
				}
			}
		}

		public event OnInputValueUpdatedHandler OnInputValueUpdated;

		private void Awake()
		{
			keyList = keys.GetComponentsInChildren<Key>(includeInactive: true);
		}

		private void Start()
		{
			Key[] array = keyList;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].OnKeyClicked += GenerateInput;
			}
			capslockFlag = isUppercase;
			CapsLock();
		}

		public void Backspace()
		{
			if (null != Target)
			{
				ForceInputFieldActivated();
				StartCoroutine(WaitTargetProcessEvent(delegate
				{
					Target.ProcessEvent(Event.KeyboardEvent("backspace"));
				}));
			}
		}

		public void Clear()
		{
			SetInput("");
		}

		public void CapsLock()
		{
			Key[] array = keyList;
			foreach (Key key in array)
			{
				if (key is Alphabet)
				{
					key.CapsLock(capslockFlag);
				}
			}
			capslockFlag = !capslockFlag;
		}

		public void Shift()
		{
			Key[] array = keyList;
			foreach (Key key in array)
			{
				if (key is Shift)
				{
					key.ShiftKey();
				}
			}
		}

		public void GenerateInput(string s)
		{
			if (null != Target)
			{
				ForceInputFieldActivated();
				StartCoroutine(WaitTargetProcessEvent(delegate
				{
					SimulateKeyboardEvent(s);
				}));
			}
		}

		public void SetInput(string s)
		{
			Input = s;
			if (null != Target)
			{
				ForceInputFieldActivated();
				Target.MoveTextEnd(shift: false);
				if (null != Target.GetComponent<InputFocusHelper>())
				{
					Target.GetComponent<InputFocusHelper>().StorePositionInfo();
				}
			}
		}

		private void ForceInputFieldActivated()
		{
			if (null != Target.GetComponent<InputFocusHelper>())
			{
				Target.GetComponent<InputFocusHelper>().ForceActivate();
			}
		}

		private IEnumerator WaitTargetProcessEvent(Action callback)
		{
			yield return new WaitUntil(() => Target.isFocused);
			callback();
			if (null != Target.GetComponent<InputFocusHelper>())
			{
				Target.GetComponent<InputFocusHelper>().StorePositionInfo();
			}
			if (this.OnInputValueUpdated != null)
			{
				this.OnInputValueUpdated(Input);
			}
		}

		private void SimulateKeyboardEvent(string s)
		{
			foreach (char character in s)
			{
				Event @event = Event.KeyboardEvent("");
				@event.character = character;
				Target.ProcessEvent(@event);
			}
			Target.ForceLabelUpdate();
		}
	}
	public class Alphabet : Key
	{
		public override void CapsLock(bool isUppercase)
		{
			if (isUppercase)
			{
				key.text = key.text.ToUpper();
			}
			else
			{
				key.text = key.text.ToLower();
			}
		}
	}
	public class Key : MonoBehaviour
	{
		public delegate void OnKeyClickedHandler(string key);

		protected Text key;

		public event OnKeyClickedHandler OnKeyClicked;

		public virtual void Awake()
		{
			key = base.transform.Find("Text").GetComponent<Text>();
			GetComponent<Button>().onClick.AddListener(delegate
			{
				this.OnKeyClicked(key.text);
			});
		}

		public virtual void CapsLock(bool isUppercase)
		{
		}

		public virtual void ShiftKey()
		{
		}
	}
	public class Number : Key
	{
	}
	public class Shift : Key
	{
		private Text subscript;

		public override void Awake()
		{
			base.Awake();
			subscript = base.transform.Find("Subscript").GetComponent<Text>();
		}

		public override void ShiftKey()
		{
			string text = key.text;
			key.text = subscript.text;
			subscript.text = text;
		}
	}
	public class Symbol : Key
	{
	}
	public class MobileKeyboardManager : MonoBehaviour
	{
		[Header("User defined")]
		[Tooltip("If the character is uppercase at the initialization")]
		public bool isUppercase;

		[Header("Essentials")]
		public Transform keys;

		private static UIKitInputField target;

		private Key[] keyList;

		private bool capslockFlag;

		public static UIKitInputField Target
		{
			get
			{
				GameObject currentSelectedGameObject = EventSystem.current.currentSelectedGameObject;
				if (null != currentSelectedGameObject && null != currentSelectedGameObject.GetComponent<UIKitInputField>())
				{
					return currentSelectedGameObject.GetComponent<UIKitInputField>();
				}
				if (null != target)
				{
					return target;
				}
				return null;
			}
			set
			{
				target = value;
			}
		}

		private string Input
		{
			get
			{
				if (null == Target)
				{
					return "";
				}
				return Target.text;
			}
			set
			{
				if (!(null == Target))
				{
					Target.text = value;
					EventSystem.current.SetSelectedGameObject(Target.gameObject);
				}
			}
		}

		private void Awake()
		{
			keyList = keys.GetComponentsInChildren<Key>(includeInactive: true);
		}

		private void Start()
		{
			Key[] array = keyList;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].OnKeyClicked += GenerateInput;
			}
			capslockFlag = isUppercase;
			CapsLock();
		}

		public void Backspace()
		{
			if (Input.Length > 0)
			{
				Input = Input.Remove(Input.Length - 1);
			}
		}

		public void Clear()
		{
			Input = "";
			if (null != Target)
			{
				Target.ForceCaretUpdate();
			}
		}

		public void CapsLock()
		{
			Key[] array = keyList;
			foreach (Key key in array)
			{
				if (key is Alphabet)
				{
					key.CapsLock(capslockFlag);
				}
			}
			capslockFlag = !capslockFlag;
		}

		public void Shift()
		{
			Key[] array = keyList;
			foreach (Key key in array)
			{
				if (key is Shift)
				{
					key.ShiftKey();
				}
			}
		}

		public void GenerateInput(string s)
		{
			Input += s;
		}
	}
	public class KeyboardSuggestions : MonoBehaviour
	{
		public KeyboardManager keyboardManager;

		public int maxNumberOfSuggestions = 3;

		private List<string> suggestions;

		private string pattern = "[^a-zA-Z]+";

		private SuggestionButton[] suggestionButtons;

		private void Awake()
		{
			if (SuggestionSetup.instance == null)
			{
				new SuggestionSetup(Resources.Load<TextAsset>("google-10000-english").text.Split('\n'));
			}
			suggestionButtons = GetComponentsInChildren<SuggestionButton>();
		}

		private void Start()
		{
			keyboardManager.OnInputValueUpdated += Suggest;
			SuggestionButton[] array = suggestionButtons;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].OnSuggestionClicked += SetSuggestionToCurrentInput;
			}
		}

		private void Suggest(string word)
		{
			if (!IsSkipSugestion())
			{
				string[] array = Regex.Split(word, pattern);
				if (array.Length != 0)
				{
					suggestions = SuggestionSetup.instance.GetSuggestions(array[array.Length - 1], maxNumberOfSuggestions);
					GenerateSuggestionsUI();
				}
			}
		}

		private bool IsSkipSugestion()
		{
			InputField target = KeyboardManager.Target;
			if (null != target && target.contentType == InputField.ContentType.Password)
			{
				suggestions = new List<string>();
				GenerateSuggestionsUI();
				return true;
			}
			return false;
		}

		private void GenerateSuggestionsUI()
		{
			for (int i = 0; i < suggestionButtons.Length; i++)
			{
				if (i >= suggestions.Count)
				{
					suggestionButtons[i].SetSuggestion("");
				}
				else
				{
					suggestionButtons[i].SetSuggestion(suggestions[i]);
				}
			}
		}

		private void SetSuggestionToCurrentInput(string word)
		{
			if (word != "" && null != KeyboardManager.Target)
			{
				string text = KeyboardManager.Target.text;
				string[] array = Regex.Split(text, pattern);
				if (array.Length != 0)
				{
					string text2 = Util.ReplaceLastOccurrence(text, array[array.Length - 1], word);
					text2 = text2.TrimEnd('\r', '\n');
					keyboardManager.SetInput(text2);
				}
			}
		}
	}
	public class SuggestionButton : MonoBehaviour
	{
		public delegate void OnSuggestionClickedHandler(string word);

		private Text suggestionText;

		public event OnSuggestionClickedHandler OnSuggestionClicked;

		private void Awake()
		{
			suggestionText = GetComponentInChildren<Text>();
			GetComponent<Button>().onClick.AddListener(delegate
			{
				this.OnSuggestionClicked(suggestionText.text);
			});
		}

		public void SetSuggestion(string word)
		{
			if (null != suggestionText)
			{
				suggestionText.text = word;
			}
		}
	}
	public class SuggestionSetup
	{
		public static SuggestionSetup instance;

		private Node root = new Node();

		private string[] textArray;

		public SuggestionSetup(string[] textArray)
		{
			this.textArray = textArray;
			PreProcess();
			instance = this;
		}

		private void PreProcess()
		{
			for (int i = 0; i < textArray.Length; i++)
			{
				Node node = root;
				string text = textArray[i];
				foreach (char key in text)
				{
					if (!node.nodes.ContainsKey(key))
					{
						node.nodes[key] = new Node();
					}
					node.indexes.Add(i);
					node = node.nodes[key];
				}
			}
		}

		public List<string> GetSuggestions(string word, int maxNumberOfSuggestions)
		{
			List<string> list = new List<string>();
			List<int> list2 = new List<int>();
			if (word.Length == 0)
			{
				return list;
			}
			Node node = root;
			foreach (char key in word)
			{
				if (node.nodes.ContainsKey(key))
				{
					node = node.nodes[key];
				}
			}
			list2 = node.indexes;
			foreach (int item in list2)
			{
				if (list.Count >= maxNumberOfSuggestions)
				{
					break;
				}
				string text = textArray[item];
				if (!(text == word))
				{
					list.Add(text);
				}
			}
			return list;
		}
	}
	public class Node
	{
		public Dictionary<char, Node> nodes = new Dictionary<char, Node>();

		public List<int> indexes = new List<int>();
	}
	public class Item : MonoBehaviour
	{
		public delegate void OnItemSelectedHandler(Item item);

		public Button button;

		protected Color normalColor;

		protected Color highlightedColor;

		public event OnItemSelectedHandler OnItemSelected;

		private void Awake()
		{
			if (null == button && null != GetComponent<Button>())
			{
				button = GetComponent<Button>();
			}
			else
			{
				UnityEngine.Debug.LogError("Item requires button to be assigned");
			}
			normalColor = button.colors.normalColor;
			highlightedColor = button.colors.highlightedColor;
			Deactivate();
			button.onClick.AddListener(delegate
			{
				if (this.OnItemSelected != null)
				{
					this.OnItemSelected(this);
				}
			});
		}

		public virtual void Activate()
		{
			ColorBlock colors = button.colors;
			colors.normalColor = button.colors.pressedColor;
			colors.highlightedColor = button.colors.pressedColor;
			button.colors = colors;
		}

		public virtual void Deactivate()
		{
			ColorBlock colors = button.colors;
			colors.normalColor = normalColor;
			colors.highlightedColor = highlightedColor;
			button.colors = colors;
		}

		public virtual void DeactivateSubMenu()
		{
		}
	}
	public class ListSelectionHelper : MonoBehaviour
	{
		public Transform list;

		public Item initialActivatedItem;

		[HideInInspector]
		public Item currentSelectedItem;

		private Item[] items;

		private void Awake()
		{
			items = list.GetComponentsInChildren<Item>();
		}

		private void Start()
		{
			Item[] array = items;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].OnItemSelected += SelectionHelper;
				if (null != initialActivatedItem)
				{
					initialActivatedItem.button.onClick.Invoke();
					currentSelectedItem = initialActivatedItem;
				}
			}
		}

		private void OnDisable()
		{
			Item[] array = items;
			foreach (Item item in array)
			{
				if (item is MenuItem)
				{
					item.DeactivateSubMenu();
				}
			}
			if (currentSelectedItem is MenuItem)
			{
				DeselectCurrentItem();
			}
		}

		private void SelectionHelper(Item item)
		{
			DeselectCurrentItem();
			item.Activate();
			currentSelectedItem = item;
		}

		public void DeselectCurrentItem()
		{
			if (null != currentSelectedItem)
			{
				currentSelectedItem.Deactivate();
			}
			currentSelectedItem = null;
		}
	}
	public class MenuItem : Item
	{
		public GameObject subMenu;

		public override void Activate()
		{
			base.Activate();
			if (null != subMenu)
			{
				subMenu.SetActive(value: true);
			}
		}

		public override void Deactivate()
		{
			base.Deactivate();
			DeactivateSubMenu();
		}

		public override void DeactivateSubMenu()
		{
			if (null != subMenu)
			{
				subMenu.SetActive(value: false);
			}
		}
	}
	public class TabItem : Item
	{
		public GameObject relatedPanel;

		public override void Activate()
		{
			base.Activate();
			if (null != relatedPanel)
			{
				if (!relatedPanel.activeSelf)
				{
					relatedPanel.SetActive(value: true);
				}
				Canvas component = relatedPanel.GetComponent<Canvas>();
				if (null != component)
				{
					component.enabled = true;
				}
				ToggleCanvasGroupBlockRaycast(enabled: true);
			}
		}

		public override void Deactivate()
		{
			base.Deactivate();
			if (null != relatedPanel)
			{
				Canvas component = relatedPanel.GetComponent<Canvas>();
				if (null != component)
				{
					component.enabled = false;
				}
				else
				{
					relatedPanel.SetActive(value: false);
				}
				ToggleCanvasGroupBlockRaycast(enabled: false);
			}
		}

		private void ToggleCanvasGroupBlockRaycast(bool enabled)
		{
			CanvasGroup component = relatedPanel.GetComponent<CanvasGroup>();
			if (null != component)
			{
				component.blocksRaycasts = enabled;
			}
		}
	}
	[Serializable]
	public struct Option
	{
		public string value;
	}
	public class OptionItem : MonoBehaviour
	{
		private Option option;

		public string Value => option.value;

		public Option Option
		{
			get
			{
				return option;
			}
			set
			{
				option = value;
				if ((bool)GetComponent<Text>())
				{
					GetComponent<Text>().text = option.value;
				}
			}
		}

		public void Activate()
		{
			base.gameObject.SetActive(value: true);
		}

		public void Deactivate()
		{
			base.gameObject.SetActive(value: false);
		}
	}
	public class OptionsManager : MonoBehaviour
	{
		public delegate void OnOptionSelectedHandler(int index);

		[Header("Template")]
		public GameObject optionTemplate;

		[HideInInspector]
		public List<Option> optionsList = new List<Option>();

		[HideInInspector]
		public string selectedValue;

		public int firstSelectedIndex;

		private int selectedIdx;

		private List<OptionItem> optionItems = new List<OptionItem>();

		public event OnOptionSelectedHandler OnOptionSelected;

		private void Awake()
		{
			optionTemplate.SetActive(value: false);
			PopulateOptions();
		}

		private void Start()
		{
			selectedIdx = Mathf.Clamp(firstSelectedIndex, 0, optionItems.Count - 1);
			ActivateOption(selectedIdx);
			OnOptionSelected += ActivateOption;
		}

		private void PopulateOptions()
		{
			Transform parent = optionTemplate.transform.parent;
			for (int i = 0; i < optionsList.Count; i++)
			{
				OptionItem component = UnityEngine.Object.Instantiate(optionTemplate, parent).GetComponent<OptionItem>();
				component.Option = optionsList[i];
				component.Deactivate();
				optionItems.Add(component);
			}
		}

		public void PrevOption()
		{
			if (selectedIdx != 0)
			{
				DeactivateOption(selectedIdx);
				selectedIdx--;
				this.OnOptionSelected(selectedIdx);
			}
		}

		public void NextOption()
		{
			if (selectedIdx < optionItems.Count - 1)
			{
				DeactivateOption(selectedIdx);
				selectedIdx++;
				this.OnOptionSelected(selectedIdx);
			}
		}

		private void ActivateOption(int i)
		{
			if (i >= 0 && i < optionItems.Count)
			{
				optionItems[i].Activate();
				selectedValue = optionItems[i].Value;
			}
		}

		private void DeactivateOption(int i)
		{
			if (i >= 0 && i < optionItems.Count)
			{
				optionItems[i].Deactivate();
			}
		}
	}
	public enum ButtonDeactiveStyle
	{
		Disabled,
		Hidden
	}
	public class Pagination : MonoBehaviour
	{
		[Header("Target")]
		public Transform targetObject;

		[Header("Pagination Buttons")]
		public ButtonDeactiveStyle buttonDeactiveStyle;

		public Button nextBtn;

		public Button prevBtn;

		private int currentPage;

		public int CurrentPage
		{
			get
			{
				return currentPage;
			}
			set
			{
				if (null == targetObject)
				{
					UnityEngine.Debug.LogError("Please assign the target object for pagination");
				}
				else if (targetObject.childCount <= 0)
				{
					PagintionBtnControl(nextEnabled: false, prevEnabled: false);
				}
				else if (value >= 0 && value < targetObject.childCount)
				{
					targetObject.GetChild(currentPage).gameObject.SetActive(value: false);
					currentPage = value;
					targetObject.GetChild(currentPage).gameObject.SetActive(value: true);
					if (currentPage == 0)
					{
						PagintionBtnControl(nextEnabled: true, prevEnabled: false);
					}
					else if (currentPage > 0 && currentPage < targetObject.childCount - 1)
					{
						PagintionBtnControl(nextEnabled: true, prevEnabled: true);
					}
					else
					{
						PagintionBtnControl(nextEnabled: false, prevEnabled: true);
					}
				}
			}
		}

		private void Start()
		{
			CurrentPage = 0;
			if (null != nextBtn)
			{
				nextBtn.onClick.AddListener(Next);
			}
			if (null != prevBtn)
			{
				prevBtn.onClick.AddListener(Prev);
			}
		}

		public void Next()
		{
			CurrentPage++;
		}

		public void Prev()
		{
			CurrentPage--;
		}

		private void PagintionBtnControl(bool nextEnabled, bool prevEnabled)
		{
			if (null != nextBtn)
			{
				switch (buttonDeactiveStyle)
				{
				case ButtonDeactiveStyle.Disabled:
					nextBtn.interactable = nextEnabled;
					break;
				case ButtonDeactiveStyle.Hidden:
					nextBtn.gameObject.SetActive(nextEnabled);
					break;
				}
			}
			if (null != prevBtn)
			{
				switch (buttonDeactiveStyle)
				{
				case ButtonDeactiveStyle.Disabled:
					prevBtn.interactable = prevEnabled;
					break;
				case ButtonDeactiveStyle.Hidden:
					prevBtn.gameObject.SetActive(prevEnabled);
					break;
				}
			}
		}
	}
	[RequireComponent(typeof(ProgressBarManager))]
	public class CircularProgressBar : MonoBehaviour
	{
		public Image circle;

		[Range(0f, 1f)]
		public float step = 0.1f;

		[Header("Value")]
		public Transform valueText;

		private float min;

		private float max = 1f;

		private ProgressBarManager progressBarManager;

		public Text ValueText => valueText.GetComponent<Text>();

		public float Value
		{
			get
			{
				return circle.fillAmount;
			}
			set
			{
				circle.fillAmount = value;
			}
		}

		private void Awake()
		{
			progressBarManager = GetComponent<ProgressBarManager>();
		}

		private void Start()
		{
			UpdateValueText(circle.fillAmount);
			progressBarManager.OnValueIsUpdating += UpdateValue;
			progressBarManager.OnValueStopUpgating += UpdateValueText;
		}

		public void IncreaseValue()
		{
			progressBarManager.IncreaseValue(Value, step, min, max);
		}

		public void DecreaseValue()
		{
			progressBarManager.DecreaseValue(Value, step, min, max);
		}

		private void UpdateValue(float newValue)
		{
			Value = newValue;
		}

		private void UpdateValueText(float newValue)
		{
			if (!(null == ValueText))
			{
				ValueText.text = (newValue * 100f).ToString("F0") + "%";
			}
		}
	}
	public class ProgressBarManager : MonoBehaviour
	{
		public delegate void OnValueUpdatedHandler(float updatedValue);

		private Coroutine slideCoroutine;

		public event OnValueUpdatedHandler OnValueIsUpdating;

		public event OnValueUpdatedHandler OnValueStopUpgating;

		public void IncreaseValue(float target, float step, float min, float max)
		{
			if (slideCoroutine != null)
			{
				StopCoroutine(slideCoroutine);
			}
			float toValue = Mathf.Clamp(target + step, min, max);
			slideCoroutine = StartCoroutine(SlideTo(target, toValue));
		}

		public void DecreaseValue(float target, float step, float min, float max)
		{
			if (slideCoroutine != null)
			{
				StopCoroutine(slideCoroutine);
			}
			float toValue = Mathf.Clamp(target - step, min, max);
			slideCoroutine = StartCoroutine(SlideTo(target, toValue));
		}

		private IEnumerator SlideTo(float target, float toValue, float time = 0.2f)
		{
			float fromValue = target;
			float elapsedTime = 0f;
			while (elapsedTime < time)
			{
				elapsedTime += Time.deltaTime;
				target = Mathf.Lerp(fromValue, toValue, elapsedTime / time);
				if (this.OnValueIsUpdating != null)
				{
					this.OnValueIsUpdating(target);
				}
				yield return null;
			}
			if (this.OnValueStopUpgating != null)
			{
				this.OnValueStopUpgating(target);
			}
		}
	}
	[RequireComponent(typeof(ProgressBarManager))]
	public class ScrollController : MonoBehaviour
	{
		public Scrollbar scrollbar;

		[Range(0f, 1f)]
		public float step = 0.5f;

		private float min;

		private float max = 1f;

		private ProgressBarManager progressBarManager;

		public float Value
		{
			get
			{
				return scrollbar.value;
			}
			set
			{
				scrollbar.value = value;
			}
		}

		private void Awake()
		{
			progressBarManager = GetComponent<ProgressBarManager>();
		}

		private void Start()
		{
			progressBarManager.OnValueIsUpdating += UpdateValue;
		}

		public void IncreaseValue()
		{
			progressBarManager.IncreaseValue(Value, step, min, max);
		}

		public void DecreaseValue()
		{
			progressBarManager.DecreaseValue(Value, step, min, max);
		}

		private void UpdateValue(float newValue)
		{
			Value = newValue;
		}
	}
	[RequireComponent(typeof(ProgressBarManager))]
	public class SliderProgressBar : MonoBehaviour
	{
		public enum ValueType
		{
			Percentage,
			Number
		}

		public Slider slider;

		public float step = 0.1f;

		[Header("Value")]
		public ValueType valuePresentedAs;

		public Transform valueText;

		[HideInInspector]
		public float roundedPercentage;

		[HideInInspector]
		public float roundedValue;

		private ProgressBarManager progressBarManager;

		public Text ValueText => valueText.GetComponent<Text>();

		public float Value
		{
			get
			{
				return slider.value;
			}
			set
			{
				slider.value = value;
			}
		}

		private void Awake()
		{
			progressBarManager = GetComponent<ProgressBarManager>();
		}

		private void Start()
		{
			CalculateValue(slider.value);
			UpdateValueText(slider.value);
			progressBarManager.OnValueIsUpdating += UpdateValue;
			progressBarManager.OnValueStopUpgating += CalculateValue;
			progressBarManager.OnValueStopUpgating += UpdateValueText;
		}

		public void IncreaseValue()
		{
			progressBarManager.IncreaseValue(Value, step, slider.minValue, slider.maxValue);
		}

		public void DecreaseValue()
		{
			progressBarManager.DecreaseValue(Value, step, slider.minValue, slider.maxValue);
		}

		private void UpdateValue(float newValue)
		{
			Value = newValue;
		}

		private void CalculateValue(float newValue)
		{
			float num = Mathf.InverseLerp(slider.minValue, slider.maxValue, newValue) * 100f;
			roundedPercentage = Mathf.Round(num * 1f) / 1f;
			roundedValue = Mathf.Round(newValue * 100f) / 100f;
		}

		private void UpdateValueText(float newValue)
		{
			if (!(null == ValueText))
			{
				switch (valuePresentedAs)
				{
				case ValueType.Percentage:
					ValueText.text = roundedPercentage + "%";
					break;
				case ValueType.Number:
					ValueText.text = roundedValue.ToString();
					break;
				}
			}
		}
	}
	public class RadialItem : MonoBehaviour
	{
		public Color normalColor;

		public Color hoverColor;

		public Sprite iconImage;

		public UnityEvent onClickEvent;

		public Transform icon;

		public Transform sector;

		private void OnValidate()
		{
			sector.GetComponent<Image>().color = normalColor;
			icon.GetComponent<Image>().sprite = iconImage;
		}

		public void AdjustFillSize(int total, int index, float radius)
		{
			sector.GetComponent<Image>().fillAmount = 1f / (float)total;
			float z = 360f / (float)total * ((float)index + 0.5f) + 180f;
			sector.transform.localRotation = Quaternion.Euler(0f, 0f, z);
			icon.localPosition = CalculateIconPosition((float)((double)(-2 * index) * Math.PI / (double)total), radius);
		}

		public void Activate()
		{
			sector.GetComponent<Image>().color = hoverColor;
		}

		public void Deactivate()
		{
			sector.GetComponent<Image>().color = normalColor;
		}

		public void Click()
		{
			if (onClickEvent != null)
			{
				onClickEvent.Invoke();
			}
		}

		private Vector3 CalculateIconPosition(float rotation, float radis)
		{
			float x = (float)((double)radis * Math.Sin(rotation));
			float y = (float)((double)radis * Math.Cos(rotation));
			return new Vector3(x, y, 0f);
		}
	}
	[ExecuteInEditMode]
	public class RadialMenuManager : MonoBehaviour
	{
		[Min(0f)]
		public float iconRadius;

		private Vector2 position;

		private RadialItem[] radialItems;

		private float currentAngle;

		private int previousSelection;

		public OVRInput.Controller controller;

		private void Awake()
		{
			radialItems = GetComponentsInChildren<RadialItem>();
			AdjustRadialItem();
		}

		private void Update()
		{
			if (UnityEngine.Application.isEditor && !UnityEngine.Application.isPlaying)
			{
				AdjustRadialItem();
				return;
			}
			position = OVRInput.Get(OVRInput.Axis2D.PrimaryThumbstick, controller);
			if (position == Vector2.zero)
			{
				Reset();
				return;
			}
			int currentSelection = GetCurrentSelection(position);
			ProcessSelection(currentSelection);
			ProcessPress(currentSelection);
		}

		private void AdjustRadialItem()
		{
			radialItems = GetComponentsInChildren<RadialItem>();
			int total = radialItems.Length;
			int num = 0;
			RadialItem[] array = radialItems;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].AdjustFillSize(total, num, iconRadius);
				num++;
			}
		}

		private int GetCurrentSelection(Vector2 position)
		{
			currentAngle = Mathf.Atan2(position.y, position.x) * 57.29578f;
			float num = 360 / radialItems.Length;
			currentAngle = (currentAngle - (90f - num / 2f) + 360f) % 360f;
			return (int)(currentAngle / num);
		}

		private void Reset()
		{
			radialItems[previousSelection].Deactivate();
			previousSelection = 0;
		}

		private void ProcessSelection(int selection)
		{
			if (selection <= radialItems.Length - 1)
			{
				radialItems[selection].Activate();
				if (previousSelection != selection)
				{
					radialItems[previousSelection].Deactivate();
				}
				previousSelection = selection;
			}
		}

		private void ProcessPress(int selection)
		{
			if (selection <= radialItems.Length - 1 && OVRInput.GetDown(OVRInput.Button.PrimaryThumbstick, controller))
			{
				radialItems[selection].Click();
			}
		}
	}
	public class Util : MonoBehaviour
	{
		public static T SafeDestroy<T>(T obj) where T : UnityEngine.Object
		{
			if (UnityEngine.Application.isEditor)
			{
				UnityEngine.Object.DestroyImmediate(obj);
			}
			else
			{
				UnityEngine.Object.Destroy(obj);
			}
			return null;
		}

		public static T SafeDestroyGameObject<T>(T component) where T : Component
		{
			if (component != null)
			{
				SafeDestroy(component.gameObject);
			}
			return null;
		}

		public static void DestroyChildren(Transform root)
		{
			for (int num = root.childCount - 1; num >= 0; num--)
			{
				SafeDestroyGameObject(root.GetChild(num));
			}
		}

		public static string ReplaceLastOccurrence(string Source, string Find, string Replace)
		{
			int num = Source.LastIndexOf(Find);
			if (num == -1)
			{
				return Source;
			}
			return Source.Remove(num, Find.Length).Insert(num, Replace);
		}
	}
	public class VREventSystemHelper : EventSystem
	{
		protected override void OnApplicationFocus(bool hasFocus)
		{
			base.OnApplicationFocus(hasFocus: true);
		}
	}
}
namespace VRUiKits.Demo
{
	public class ChangeColor : MonoBehaviour
	{
		private Material material;

		private Color color;

		private bool isClicked;

		private void Start()
		{
			material = GetComponent<MeshRenderer>().material;
		}

		public void PointerEnter()
		{
			color = material.color;
			material.color = Color.cyan;
			isClicked = false;
		}

		public void PointerLeave()
		{
			if (!isClicked)
			{
				material.color = color;
			}
		}

		public void PointerClick()
		{
			material.color = Color.blue;
			isClicked = true;
		}
	}
	public class FaceVRCamera : MonoBehaviour
	{
		public Transform vrCamera;

		public FaceCameraType type;

		private float distance;

		private void Awake()
		{
			distance = base.transform.position.z - vrCamera.position.z;
		}

		private void OnEnable()
		{
			if (type == FaceCameraType.OnToggle)
			{
				CalibratePosition();
			}
		}

		private void LateUpdate()
		{
			if (type == FaceCameraType.Always)
			{
				CalibratePosition();
			}
		}

		private void CalibratePosition()
		{
			base.transform.position = vrCamera.position + vrCamera.forward * distance;
			base.transform.rotation = Quaternion.LookRotation(base.transform.position - vrCamera.transform.position);
		}
	}
	public enum FaceCameraType
	{
		Always,
		OnToggle
	}
	public class KeyboardDisplay : MonoBehaviour
	{
		public Transform vrCamera;

		private Vector3 offset;

		private void Awake()
		{
			offset = base.transform.position - vrCamera.position;
		}

		private void OnEnable()
		{
			SetPosition();
		}

		private void SetPosition()
		{
			base.transform.position = vrCamera.position + offset;
		}
	}
	public class MouseLook : MonoBehaviour
	{
		public float speed = 3.5f;

		private float x;

		private float y;

		private void Update()
		{
			if (Input.GetMouseButton(0))
			{
				base.transform.Rotate(new Vector3(Input.GetAxis("Mouse Y") * speed, (0f - Input.GetAxis("Mouse X")) * speed, 0f));
				x = base.transform.rotation.eulerAngles.x;
				y = base.transform.rotation.eulerAngles.y;
				base.transform.rotation = Quaternion.Euler(x, y, 0f);
			}
		}
	}
	public class ToggleUIKitHelper : MonoBehaviour
	{
		public UIKitPointer pointer;

		public List<GameObject> objectsToToggle;

		public OVRInput.Button trigger = OVRInput.Button.Two;

		public OVRInput.Controller controller = OVRInput.Controller.LTouch;

		public void Pause()
		{
			if (!(LaserInputModule.instance == null))
			{
				Toggle(enabled: false);
			}
		}

		public void Run()
		{
			if (!(LaserInputModule.instance == null))
			{
				Toggle(enabled: true);
			}
		}

		private void Toggle(bool enabled)
		{
			pointer.gameObject.SetActive(enabled);
			foreach (GameObject item in objectsToToggle)
			{
				item.SetActive(enabled);
			}
		}

		private void LateUpdate()
		{
			if (OVRInput.GetDown(trigger, controller) && !(LaserInputModule.instance == null))
			{
				if (pointer.gameObject.activeSelf)
				{
					Pause();
				}
				else
				{
					Run();
				}
			}
		}
	}
}
namespace Glitchers.UserInterface
{
	public class CustomZTestUI : MonoBehaviour, IMaterialModifier
	{
		[Tooltip("LessEqual is 'normal'. Always is overlay. Never is hide.")]
		public CompareFunction comparison = CompareFunction.LessEqual;

		private Graphic m_Graphic;

		private Material m_RenderMaterial;

		private const string _propertyKey = "unity_GUIZTestMode";

		private static int? _propertyID;

		private static int PropertyID
		{
			get
			{
				if (!_propertyID.HasValue)
				{
					_propertyID = Shader.PropertyToID("unity_GUIZTestMode");
				}
				return _propertyID.Value;
			}
		}

		private void Awake()
		{
			m_Graphic = GetComponent<Graphic>();
		}

		private void OnEnable()
		{
			SetDirty();
		}

		private void OnDisable()
		{
			SetDirty();
		}

		private void SetDirty()
		{
			if (m_Graphic != null)
			{
				m_Graphic.SetMaterialDirty();
			}
		}

		public void SetOverlay(bool overlay)
		{
			comparison = (overlay ? CompareFunction.Always : CompareFunction.LessEqual);
			SetDirty();
		}

		Material IMaterialModifier.GetModifiedMaterial(Material baseMaterial)
		{
			if (m_RenderMaterial == null)
			{
				m_RenderMaterial = new Material(baseMaterial)
				{
					name = $"{baseMaterial.name} CustomZTestUI",
					hideFlags = HideFlags.HideAndDontSave
				};
			}
			m_RenderMaterial.SetInt(PropertyID, (int)comparison);
			return m_RenderMaterial;
		}
	}
}
namespace I2.Loc
{
	public static class ScriptLocalization
	{
		public static class Lobby
		{
			public static string Audio_Ambient => LocalizationManager.GetTranslation("Lobby/Audio_Ambient");

			public static string Audio_Game => LocalizationManager.GetTranslation("Lobby/Audio_Game");

			public static string Audio_Master => LocalizationManager.GetTranslation("Lobby/Audio_Master");

			public static string Audio_NodeHit => LocalizationManager.GetTranslation("Lobby/Audio_NodeHit");

			public static string Audio_SFX => LocalizationManager.GetTranslation("Lobby/Audio_SFX");

			public static string Audio_Title => LocalizationManager.GetTranslation("Lobby/Audio_Title");

			public static string Audio_Voice => LocalizationManager.GetTranslation("Lobby/Audio_Voice");

			public static string Bio_Origin => LocalizationManager.GetTranslation("Lobby/Bio_Origin");

			public static string Bio_Style => LocalizationManager.GetTranslation("Lobby/Bio_Style");

			public static string Bio_Title => LocalizationManager.GetTranslation("Lobby/Bio_Title");

			public static string CharacterSelect_Bio => LocalizationManager.GetTranslation("Lobby/CharacterSelect_Bio");

			public static string CharacterSelect_Select => LocalizationManager.GetTranslation("Lobby/CharacterSelect_Select");

			public static string CharacterSelect_Title => LocalizationManager.GetTranslation("Lobby/CharacterSelect_Title");

			public static string CheckWeb => LocalizationManager.GetTranslation("Lobby/CheckWeb");

			public static string Credits_Title => LocalizationManager.GetTranslation("Lobby/Credits_Title");

			public static string Custom_GoToEditor => LocalizationManager.GetTranslation("Lobby/Custom_GoToEditor");

			public static string Custom_Title => LocalizationManager.GetTranslation("Lobby/Custom_Title");

			public static string Dance => LocalizationManager.GetTranslation("Lobby/Dance");

			public static string Gameplay_Calibration => LocalizationManager.GetTranslation("Lobby/Gameplay_Calibration");

			public static string Gameplay_Calibration_Apply => LocalizationManager.GetTranslation("Lobby/Gameplay_Calibration_Apply");

			public static string Gameplay_Calibration_AutoHeight => LocalizationManager.GetTranslation("Lobby/Gameplay_Calibration_AutoHeight");

			public static string Gameplay_Calibration_CalibrateNow => LocalizationManager.GetTranslation("Lobby/Gameplay_Calibration_CalibrateNow");

			public static string Gameplay_Calibration_HeightCalibration => LocalizationManager.GetTranslation("Lobby/Gameplay_Calibration_HeightCalibration");

			public static string Gameplay_Calibration_Manual => LocalizationManager.GetTranslation("Lobby/Gameplay_Calibration_Manual");

			public static string Gameplay_Calibration_RoomOffset => LocalizationManager.GetTranslation("Lobby/Gameplay_Calibration_RoomOffset");

			public static string Gameplay_Calibration_Rotation => LocalizationManager.GetTranslation("Lobby/Gameplay_Calibration_Rotation");

			public static string Gameplay_Calibration_XOffset => LocalizationManager.GetTranslation("Lobby/Gameplay_Calibration_XOffset");

			public static string Gameplay_Calibration_ZOffset => LocalizationManager.GetTranslation("Lobby/Gameplay_Calibration_ZOffset");

			public static string Gameplay_Gameplay => LocalizationManager.GetTranslation("Lobby/Gameplay_Gameplay");

			public static string Gameplay_Holograms => LocalizationManager.GetTranslation("Lobby/Gameplay_Holograms");

			public static string Gameplay_Holograms_Info => LocalizationManager.GetTranslation("Lobby/Gameplay_Holograms_Info");

			public static string Gameplay_Lightshows => LocalizationManager.GetTranslation("Lobby/Gameplay_Lightshows");

			public static string Gameplay_Lightshows_Info => LocalizationManager.GetTranslation("Lobby/Gameplay_Lightshows_Info");

			public static string Gameplay_SkipIntros => LocalizationManager.GetTranslation("Lobby/Gameplay_SkipIntros");

			public static string Gameplay_SkipIntros_Info => LocalizationManager.GetTranslation("Lobby/Gameplay_SkipIntros_Info");

			public static string Gameplay_TauntParticles => LocalizationManager.GetTranslation("Lobby/Gameplay_TauntParticles");

			public static string Gameplay_TauntParticles_Info => LocalizationManager.GetTranslation("Lobby/Gameplay_TauntParticles_Info");

			public static string Gameplay_Title => LocalizationManager.GetTranslation("Lobby/Gameplay_Title");

			public static string Graphics_AdvGraphics => LocalizationManager.GetTranslation("Lobby/Graphics_AdvGraphics");

			public static string Graphics_AntiAliasing => LocalizationManager.GetTranslation("Lobby/Graphics_AntiAliasing");

			public static string Graphics_AntiAliasing_Info => LocalizationManager.GetTranslation("Lobby/Graphics_AntiAliasing_Info");

			public static string Graphics_Apply => LocalizationManager.GetTranslation("Lobby/Graphics_Apply");

			public static string Graphics_Colour_Double => LocalizationManager.GetTranslation("Lobby/Graphics_Colour_Double");

			public static string Graphics_Colour_Left => LocalizationManager.GetTranslation("Lobby/Graphics_Colour_Left");

			public static string Graphics_Colour_Reset => LocalizationManager.GetTranslation("Lobby/Graphics_Colour_Reset");

			public static string Graphics_Colour_Right => LocalizationManager.GetTranslation("Lobby/Graphics_Colour_Right");

			public static string Graphics_Colours => LocalizationManager.GetTranslation("Lobby/Graphics_Colours");

			public static string Graphics_Environments => LocalizationManager.GetTranslation("Lobby/Graphics_Environments");

			public static string Graphics_Environments_Info => LocalizationManager.GetTranslation("Lobby/Graphics_Environments_Info");

			public static string Graphics_Fog => LocalizationManager.GetTranslation("Lobby/Graphics_Fog");

			public static string Graphics_Fog_Info => LocalizationManager.GetTranslation("Lobby/Graphics_Fog_Info");

			public static string Graphics_Graphics => LocalizationManager.GetTranslation("Lobby/Graphics_Graphics");

			public static string Graphics_InGameUI => LocalizationManager.GetTranslation("Lobby/Graphics_InGameUI");

			public static string Graphics_InGameUI_Info => LocalizationManager.GetTranslation("Lobby/Graphics_InGameUI_Info");

			public static string Graphics_Particles => LocalizationManager.GetTranslation("Lobby/Graphics_Particles");

			public static string Graphics_Particles_Info => LocalizationManager.GetTranslation("Lobby/Graphics_Particles_Info");

			public static string Graphics_PostProcessing => LocalizationManager.GetTranslation("Lobby/Graphics_PostProcessing");

			public static string Graphics_PostProcessing_Info => LocalizationManager.GetTranslation("Lobby/Graphics_PostProcessing_Info");

			public static string Graphics_SmoothCam => LocalizationManager.GetTranslation("Lobby/Graphics_SmoothCam");

			public static string Graphics_SmoothCam_FOV => LocalizationManager.GetTranslation("Lobby/Graphics_SmoothCam_FOV");

			public static string Graphics_SmoothCam_FOV_Info => LocalizationManager.GetTranslation("Lobby/Graphics_SmoothCam_FOV_Info");

			public static string Graphics_SmoothCam_Info => LocalizationManager.GetTranslation("Lobby/Graphics_SmoothCam_Info");

			public static string Graphics_SmoothCam_Post => LocalizationManager.GetTranslation("Lobby/Graphics_SmoothCam_Post");

			public static string Graphics_SmoothCam_Post_Info => LocalizationManager.GetTranslation("Lobby/Graphics_SmoothCam_Post_Info");

			public static string Graphics_SmoothCam_Smoothness => LocalizationManager.GetTranslation("Lobby/Graphics_SmoothCam_Smoothness");

			public static string Graphics_SmoothCam_Smoothness_Info => LocalizationManager.GetTranslation("Lobby/Graphics_SmoothCam_Smoothness_Info");

			public static string Graphics_SmoothCamera => LocalizationManager.GetTranslation("Lobby/Graphics_SmoothCamera");

			public static string Graphics_Title => LocalizationManager.GetTranslation("Lobby/Graphics_Title");

			public static string Language_Current => LocalizationManager.GetTranslation("Lobby/Language_Current");

			public static string Language_English => LocalizationManager.GetTranslation("Lobby/Language_English");

			public static string Language_French => LocalizationManager.GetTranslation("Lobby/Language_French");

			public static string Language_German => LocalizationManager.GetTranslation("Lobby/Language_German");

			public static string Language_Italian => LocalizationManager.GetTranslation("Lobby/Language_Italian");

			public static string Language_Japanese => LocalizationManager.GetTranslation("Lobby/Language_Japanese");

			public static string Language_Korean => LocalizationManager.GetTranslation("Lobby/Language_Korean");

			public static string Language_Spanish => LocalizationManager.GetTranslation("Lobby/Language_Spanish");

			public static string Language_Title => LocalizationManager.GetTranslation("Lobby/Language_Title");

			public static string Leaderboards_Friends => LocalizationManager.GetTranslation("Lobby/Leaderboards_Friends");

			public static string Leaderboards_Global => LocalizationManager.GetTranslation("Lobby/Leaderboards_Global");

			public static string Leaderboards_Player => LocalizationManager.GetTranslation("Lobby/Leaderboards_Player");

			public static string Leaderboards_Rank => LocalizationManager.GetTranslation("Lobby/Leaderboards_Rank");

			public static string Leaderboards_Score => LocalizationManager.GetTranslation("Lobby/Leaderboards_Score");

			public static string Leaderboards_Title => LocalizationManager.GetTranslation("Lobby/Leaderboards_Title");

			public static string Main_Arcade => LocalizationManager.GetTranslation("Lobby/Main_Arcade");

			public static string Main_CustomSongs => LocalizationManager.GetTranslation("Lobby/Main_CustomSongs");

			public static string Main_HowToPlay => LocalizationManager.GetTranslation("Lobby/Main_HowToPlay");

			public static string Main_Title => LocalizationManager.GetTranslation("Lobby/Main_Title");

			public static string NoFail => LocalizationManager.GetTranslation("Lobby/NoFail");

			public static string Settings_Audio => LocalizationManager.GetTranslation("Lobby/Settings_Audio");

			public static string Settings_Credits => LocalizationManager.GetTranslation("Lobby/Settings_Credits");

			public static string Settings_Gameplay => LocalizationManager.GetTranslation("Lobby/Settings_Gameplay");

			public static string Settings_Graphics => LocalizationManager.GetTranslation("Lobby/Settings_Graphics");

			public static string Settings_Language => LocalizationManager.GetTranslation("Lobby/Settings_Language");

			public static string Settings_Title => LocalizationManager.GetTranslation("Lobby/Settings_Title");

			public static string SongSelect_Leaderboard => LocalizationManager.GetTranslation("Lobby/SongSelect_Leaderboard");

			public static string SongSelect_More => LocalizationManager.GetTranslation("Lobby/SongSelect_More");

			public static string SongSelect_Rank => LocalizationManager.GetTranslation("Lobby/SongSelect_Rank");

			public static string SongSelect_Title => LocalizationManager.GetTranslation("Lobby/SongSelect_Title");

			public static string Title_JoinDiscord => LocalizationManager.GetTranslation("Lobby/Title_JoinDiscord");

			public static string Title_Start => LocalizationManager.GetTranslation("Lobby/Title_Start");
		}

		public static string Accuracy => LocalizationManager.GetTranslation("Accuracy");

		public static string Back => LocalizationManager.GetTranslation("Back");

		public static string Back_To_Lobby => LocalizationManager.GetTranslation("Back_To_Lobby");

		public static string Battle => LocalizationManager.GetTranslation("Battle");

		public static string Core_Bio => LocalizationManager.GetTranslation("Core_Bio");

		public static string Core_Genre => LocalizationManager.GetTranslation("Core_Genre");

		public static string Core_Name => LocalizationManager.GetTranslation("Core_Name");

		public static string Core_Origin => LocalizationManager.GetTranslation("Core_Origin");

		public static string Core_Stage1 => LocalizationManager.GetTranslation("Core_Stage1");

		public static string Core_Stage2 => LocalizationManager.GetTranslation("Core_Stage2");

		public static string Core_Stage3 => LocalizationManager.GetTranslation("Core_Stage3");

		public static string Core_Stage4 => LocalizationManager.GetTranslation("Core_Stage4");

		public static string Core_Stage5 => LocalizationManager.GetTranslation("Core_Stage5");

		public static string Dance => LocalizationManager.GetTranslation("Dance");

		public static string Dre_Bio => LocalizationManager.GetTranslation("Dre_Bio");

		public static string Dre_Genre => LocalizationManager.GetTranslation("Dre_Genre");

		public static string Dre_Name => LocalizationManager.GetTranslation("Dre_Name");

		public static string Dre_Origin => LocalizationManager.GetTranslation("Dre_Origin");

		public static string Dre_Stage1 => LocalizationManager.GetTranslation("Dre_Stage1");

		public static string Dre_Stage2 => LocalizationManager.GetTranslation("Dre_Stage2");

		public static string Dre_Stage3 => LocalizationManager.GetTranslation("Dre_Stage3");

		public static string Dre_Stage4 => LocalizationManager.GetTranslation("Dre_Stage4");

		public static string Dre_Stage5 => LocalizationManager.GetTranslation("Dre_Stage5");

		public static string Easy => LocalizationManager.GetTranslation("Easy");

		public static string Flair => LocalizationManager.GetTranslation("Flair");

		public static string Game_Paused => LocalizationManager.GetTranslation("Game Paused");

		public static string Hard => LocalizationManager.GetTranslation("Hard");

		public static string HowToPlay_Basic => LocalizationManager.GetTranslation("HowToPlay_Basic");

		public static string HowToPlay_Cascades => LocalizationManager.GetTranslation("HowToPlay_Cascades");

		public static string HowToPlay_Double => LocalizationManager.GetTranslation("HowToPlay_Double");

		public static string HowToPlay_Flair => LocalizationManager.GetTranslation("HowToPlay_Flair");

		public static string HowToPlay_FlairTitle => LocalizationManager.GetTranslation("HowToPlay_FlairTitle");

		public static string HowToPlay_Sets => LocalizationManager.GetTranslation("HowToPlay_Sets");

		public static string Lais_Bio => LocalizationManager.GetTranslation("Lais_Bio");

		public static string Lais_Genre => LocalizationManager.GetTranslation("Lais_Genre");

		public static string Lais_Name => LocalizationManager.GetTranslation("Lais_Name");

		public static string Lais_Origin => LocalizationManager.GetTranslation("Lais_Origin");

		public static string Lais_Stage1 => LocalizationManager.GetTranslation("Lais_Stage1");

		public static string Lais_Stage2 => LocalizationManager.GetTranslation("Lais_Stage2");

		public static string Lais_Stage3 => LocalizationManager.GetTranslation("Lais_Stage3");

		public static string Lais_Stage4 => LocalizationManager.GetTranslation("Lais_Stage4");

		public static string Lais_Stage5 => LocalizationManager.GetTranslation("Lais_Stage5");

		public static string Leaderboards_Friends => LocalizationManager.GetTranslation("Leaderboards_Friends");

		public static string Leaderboards_Global => LocalizationManager.GetTranslation("Leaderboards_Global");

		public static string Leaderboards_Local => LocalizationManager.GetTranslation("Leaderboards_Local");

		public static string Leaderboards_Title => LocalizationManager.GetTranslation("Leaderboards_Title");

		public static string LiuWei_Name => LocalizationManager.GetTranslation("LiuWei_Name");

		public static string LiuWen_Genre => LocalizationManager.GetTranslation("LiuWen_Genre");

		public static string Liu_Bio => LocalizationManager.GetTranslation("Liu_Bio");

		public static string Liu_Origin => LocalizationManager.GetTranslation("Liu_Origin");

		public static string Liu_Stage1 => LocalizationManager.GetTranslation("Liu_Stage1");

		public static string Liu_Stage2 => LocalizationManager.GetTranslation("Liu_Stage2");

		public static string Liu_Stage3 => LocalizationManager.GetTranslation("Liu_Stage3");

		public static string Liu_Stage4 => LocalizationManager.GetTranslation("Liu_Stage4");

		public static string Liu_Stage5 => LocalizationManager.GetTranslation("Liu_Stage5");

		public static string Max_Multiplier => LocalizationManager.GetTranslation("Max_Multiplier");

		public static string Max_Streak => LocalizationManager.GetTranslation("Max_Streak");

		public static string Next_Stage => LocalizationManager.GetTranslation("Next_Stage");

		public static string Normal => LocalizationManager.GetTranslation("Normal");

		public static string Perfect_Cascades => LocalizationManager.GetTranslation("Perfect_Cascades");

		public static string Pyro_Bio => LocalizationManager.GetTranslation("Pyro_Bio");

		public static string Pyro_Genre => LocalizationManager.GetTranslation("Pyro_Genre");

		public static string Pyro_Name => LocalizationManager.GetTranslation("Pyro_Name");

		public static string Pyro_Origin => LocalizationManager.GetTranslation("Pyro_Origin");

		public static string Pyro_Stage1 => LocalizationManager.GetTranslation("Pyro_Stage1");

		public static string Pyro_Stage2 => LocalizationManager.GetTranslation("Pyro_Stage2");

		public static string Pyro_Stage3 => LocalizationManager.GetTranslation("Pyro_Stage3");

		public static string Pyro_Stage4 => LocalizationManager.GetTranslation("Pyro_Stage4");

		public static string Pyro_Stage5 => LocalizationManager.GetTranslation("Pyro_Stage5");

		public static string Rank => LocalizationManager.GetTranslation("Rank");

		public static string Remi_Bio => LocalizationManager.GetTranslation("Remi_Bio");

		public static string Remi_Genre => LocalizationManager.GetTranslation("Remi_Genre");

		public static string Remi_Name => LocalizationManager.GetTranslation("Remi_Name");

		public static string Remi_Origin => LocalizationManager.GetTranslation("Remi_Origin");

		public static string Remi_Stage1 => LocalizationManager.GetTranslation("Remi_Stage1");

		public static string Remi_Stage2 => LocalizationManager.GetTranslation("Remi_Stage2");

		public static string Remi_Stage3 => LocalizationManager.GetTranslation("Remi_Stage3");

		public static string Remi_Stage4 => LocalizationManager.GetTranslation("Remi_Stage4");

		public static string Remi_Stage5 => LocalizationManager.GetTranslation("Remi_Stage5");

		public static string Resume => LocalizationManager.GetTranslation("Resume");

		public static string Retry => LocalizationManager.GetTranslation("Retry");

		public static string ScoreEvent_Amazing => LocalizationManager.GetTranslation("ScoreEvent_Amazing");

		public static string ScoreEvent_Awesome => LocalizationManager.GetTranslation("ScoreEvent_Awesome");

		public static string ScoreEvent_Beautiful => LocalizationManager.GetTranslation("ScoreEvent_Beautiful");

		public static string ScoreEvent_Cool => LocalizationManager.GetTranslation("ScoreEvent_Cool");

		public static string ScoreEvent_Great => LocalizationManager.GetTranslation("ScoreEvent_Great");

		public static string ScoreEvent_Nice => LocalizationManager.GetTranslation("ScoreEvent_Nice");

		public static string ScoreEvent_Perfect => LocalizationManager.GetTranslation("ScoreEvent_Perfect");

		public static string ScoreEvent_Superb => LocalizationManager.GetTranslation("ScoreEvent_Superb");

		public static string Select => LocalizationManager.GetTranslation("Select");

		public static string Sets_Completed => LocalizationManager.GetTranslation("Sets_Completed");

		public static string Settings_AmbientMusic => LocalizationManager.GetTranslation("Settings_AmbientMusic");

		public static string Settings_Apply => LocalizationManager.GetTranslation("Settings_Apply");

		public static string Settings_Audio => LocalizationManager.GetTranslation("Settings_Audio");

		public static string Settings_AuraQuality => LocalizationManager.GetTranslation("Settings_AuraQuality");

		public static string Settings_Aura_Lighting => LocalizationManager.GetTranslation("Settings_Aura_Lighting");

		public static string Settings_Credits => LocalizationManager.GetTranslation("Settings_Credits");

		public static string Settings_DanceHolograms => LocalizationManager.GetTranslation("Settings_DanceHolograms");

		public static string Settings_DevConsole => LocalizationManager.GetTranslation("Settings_DevConsole");

		public static string Settings_GameMusic => LocalizationManager.GetTranslation("Settings_GameMusic");

		public static string Settings_Graphics => LocalizationManager.GetTranslation("Settings_Graphics");

		public static string Settings_GraphicsBlurb => LocalizationManager.GetTranslation("Settings_GraphicsBlurb");

		public static string Settings_Language => LocalizationManager.GetTranslation("Settings_Language");

		public static string Settings_Lightshows => LocalizationManager.GetTranslation("Settings_Lightshows");

		public static string Settings_MasterVolume => LocalizationManager.GetTranslation("Settings_MasterVolume");

		public static string Settings_Node_Hit_Sounds => LocalizationManager.GetTranslation("Settings_Node_Hit_Sounds");

		public static string Settings_Other => LocalizationManager.GetTranslation("Settings_Other");

		public static string Settings_SFX => LocalizationManager.GetTranslation("Settings_SFX");

		public static string Settings_TauntParticles => LocalizationManager.GetTranslation("Settings_TauntParticles");

		public static string Settings_Title => LocalizationManager.GetTranslation("Settings_Title");

		public static string Settings_Voice => LocalizationManager.GetTranslation("Settings_Voice");

		public static string Sonya_Bio => LocalizationManager.GetTranslation("Sonya_Bio");

		public static string Sonya_Genre => LocalizationManager.GetTranslation("Sonya_Genre");

		public static string Sonya_Name => LocalizationManager.GetTranslation("Sonya_Name");

		public static string Sonya_Origin => LocalizationManager.GetTranslation("Sonya_Origin");

		public static string Sonya_Stage1 => LocalizationManager.GetTranslation("Sonya_Stage1");

		public static string Sonya_Stage2 => LocalizationManager.GetTranslation("Sonya_Stage2");

		public static string Sonya_Stage3 => LocalizationManager.GetTranslation("Sonya_Stage3");

		public static string Sonya_Stage4 => LocalizationManager.GetTranslation("Sonya_Stage4");

		public static string Sonya_Stage5 => LocalizationManager.GetTranslation("Sonya_Stage5");

		public static string Stage => LocalizationManager.GetTranslation("Stage");

		public static string Stage_1 => LocalizationManager.GetTranslation("Stage_1");

		public static string Stage_2 => LocalizationManager.GetTranslation("Stage_2");

		public static string Stage_3 => LocalizationManager.GetTranslation("Stage_3");

		public static string Stage_Clear => LocalizationManager.GetTranslation("Stage_Clear");

		public static string Stage_Failed => LocalizationManager.GetTranslation("Stage_Failed");

		public static string Stop => LocalizationManager.GetTranslation("Stop");

		public static string Tutorial_Arrows => LocalizationManager.GetTranslation("Tutorial_Arrows");

		public static string Tutorial_Awesome => LocalizationManager.GetTranslation("Tutorial_Awesome");

		public static string Tutorial_Cascades => LocalizationManager.GetTranslation("Tutorial_Cascades");

		public static string Tutorial_Great => LocalizationManager.GetTranslation("Tutorial_Great");

		public static string Tutorial_GreenNode => LocalizationManager.GetTranslation("Tutorial_GreenNode");

		public static string Tutorial_Harder => LocalizationManager.GetTranslation("Tutorial_Harder");

		public static string Tutorial_Nice => LocalizationManager.GetTranslation("Tutorial_Nice");

		public static string Tutorial_PinkNode => LocalizationManager.GetTranslation("Tutorial_PinkNode");

		public static string Tutorial_Power => LocalizationManager.GetTranslation("Tutorial_Power");

		public static string Tutorial_Sets => LocalizationManager.GetTranslation("Tutorial_Sets");

		public static string Tutorial_Title_BasicNodes => LocalizationManager.GetTranslation("Tutorial_Title_BasicNodes");

		public static string Tutorial_Title_Cascades => LocalizationManager.GetTranslation("Tutorial_Title_Cascades");

		public static string Tutorial_Title_Dance => LocalizationManager.GetTranslation("Tutorial_Title_Dance");

		public static string Tutorial_Title_Power => LocalizationManager.GetTranslation("Tutorial_Title_Power");

		public static string Tutorial_Title_Sets => LocalizationManager.GetTranslation("Tutorial_Title_Sets");

		public static string Tutorial_Title_WideNodes => LocalizationManager.GetTranslation("Tutorial_Title_WideNodes");

		public static string Tutorial_Title_YellowNodes => LocalizationManager.GetTranslation("Tutorial_Title_YellowNodes");

		public static string Tutorial_TryAgain => LocalizationManager.GetTranslation("Tutorial_TryAgain");

		public static string Tutorial_Welcome => LocalizationManager.GetTranslation("Tutorial_Welcome");

		public static string Tutorial_Yellow => LocalizationManager.GetTranslation("Tutorial_Yellow");

		public static string UI_CharacterSelect_title => LocalizationManager.GetTranslation("UI_CharacterSelect_title");

		public static string UI_MainFont => LocalizationManager.GetTranslation("UI_MainFont");

		public static string UI_MainMenu_Custom => LocalizationManager.GetTranslation("UI_MainMenu_Custom");

		public static string UI_MainMenu_Editor => LocalizationManager.GetTranslation("UI_MainMenu_Editor");

		public static string UI_MainMenu_FreeDance => LocalizationManager.GetTranslation("UI_MainMenu_FreeDance");

		public static string UI_MainMenu_Mode => LocalizationManager.GetTranslation("UI_MainMenu_Mode");

		public static string UI_MainMenu_Start => LocalizationManager.GetTranslation("UI_MainMenu_Start");

		public static string UI_MainMenu_Tournament => LocalizationManager.GetTranslation("UI_MainMenu_Tournament");

		public static string UI_MainMenu_Tutorial => LocalizationManager.GetTranslation("UI_MainMenu_Tutorial");

		public static string UI_SongSelect_title => LocalizationManager.GetTranslation("UI_SongSelect_title");

		public static string UI_TitleFont => LocalizationManager.GetTranslation("UI_TitleFont");

		public static string Uriel_Bio => LocalizationManager.GetTranslation("Uriel_Bio");

		public static string Uriel_Name => LocalizationManager.GetTranslation("Uriel_Name");

		public static string Uriel_Origin => LocalizationManager.GetTranslation("Uriel_Origin");

		public static string Uriel_Stage1 => LocalizationManager.GetTranslation("Uriel_Stage1");

		public static string Uriel_Stage2 => LocalizationManager.GetTranslation("Uriel_Stage2");

		public static string Uriel_Stage3 => LocalizationManager.GetTranslation("Uriel_Stage3");

		public static string Uriel_Stage4 => LocalizationManager.GetTranslation("Uriel_Stage4");

		public static string Uriel_Stage5 => LocalizationManager.GetTranslation("Uriel_Stage5");

		public static string Yuri_Bio => LocalizationManager.GetTranslation("Yuri_Bio");

		public static string Yuri_Genre => LocalizationManager.GetTranslation("Yuri_Genre");

		public static string Yuri_Name => LocalizationManager.GetTranslation("Yuri_Name");

		public static string Yuri_Origin => LocalizationManager.GetTranslation("Yuri_Origin");

		public static string Yuri_Stage1 => LocalizationManager.GetTranslation("Yuri_Stage1");

		public static string Yuri_Stage2 => LocalizationManager.GetTranslation("Yuri_Stage2");

		public static string Yuri_Stage3 => LocalizationManager.GetTranslation("Yuri_Stage3");

		public static string Yuri_Stage4 => LocalizationManager.GetTranslation("Yuri_Stage4");

		public static string Yuri_Stage5 => LocalizationManager.GetTranslation("Yuri_Stage5");
	}
	public static class ScriptTerms
	{
		public static class Lobby
		{
			public const string Audio_Ambient = "Lobby/Audio_Ambient";

			public const string Audio_Game = "Lobby/Audio_Game";

			public const string Audio_Master = "Lobby/Audio_Master";

			public const string Audio_NodeHit = "Lobby/Audio_NodeHit";

			public const string Audio_SFX = "Lobby/Audio_SFX";

			public const string Audio_Title = "Lobby/Audio_Title";

			public const string Audio_Voice = "Lobby/Audio_Voice";

			public const string Bio_Origin = "Lobby/Bio_Origin";

			public const string Bio_Style = "Lobby/Bio_Style";

			public const string Bio_Title = "Lobby/Bio_Title";

			public const string CharacterSelect_Bio = "Lobby/CharacterSelect_Bio";

			public const string CharacterSelect_Select = "Lobby/CharacterSelect_Select";

			public const string CharacterSelect_Title = "Lobby/CharacterSelect_Title";

			public const string CheckWeb = "Lobby/CheckWeb";

			public const string Credits_Title = "Lobby/Credits_Title";

			public const string Custom_GoToEditor = "Lobby/Custom_GoToEditor";

			public const string Custom_Title = "Lobby/Custom_Title";

			public const string Dance = "Lobby/Dance";

			public const string Gameplay_Calibration = "Lobby/Gameplay_Calibration";

			public const string Gameplay_Calibration_Apply = "Lobby/Gameplay_Calibration_Apply";

			public const string Gameplay_Calibration_AutoHeight = "Lobby/Gameplay_Calibration_AutoHeight";

			public const string Gameplay_Calibration_CalibrateNow = "Lobby/Gameplay_Calibration_CalibrateNow";

			public const string Gameplay_Calibration_HeightCalibration = "Lobby/Gameplay_Calibration_HeightCalibration";

			public const string Gameplay_Calibration_Manual = "Lobby/Gameplay_Calibration_Manual";

			public const string Gameplay_Calibration_RoomOffset = "Lobby/Gameplay_Calibration_RoomOffset";

			public const string Gameplay_Calibration_Rotation = "Lobby/Gameplay_Calibration_Rotation";

			public const string Gameplay_Calibration_XOffset = "Lobby/Gameplay_Calibration_XOffset";

			public const string Gameplay_Calibration_ZOffset = "Lobby/Gameplay_Calibration_ZOffset";

			public const string Gameplay_Gameplay = "Lobby/Gameplay_Gameplay";

			public const string Gameplay_Holograms = "Lobby/Gameplay_Holograms";

			public const string Gameplay_Holograms_Info = "Lobby/Gameplay_Holograms_Info";

			public const string Gameplay_Lightshows = "Lobby/Gameplay_Lightshows";

			public const string Gameplay_Lightshows_Info = "Lobby/Gameplay_Lightshows_Info";

			public const string Gameplay_SkipIntros = "Lobby/Gameplay_SkipIntros";

			public const string Gameplay_SkipIntros_Info = "Lobby/Gameplay_SkipIntros_Info";

			public const string Gameplay_TauntParticles = "Lobby/Gameplay_TauntParticles";

			public const string Gameplay_TauntParticles_Info = "Lobby/Gameplay_TauntParticles_Info";

			public const string Gameplay_Title = "Lobby/Gameplay_Title";

			public const string Graphics_AdvGraphics = "Lobby/Graphics_AdvGraphics";

			public const string Graphics_AntiAliasing = "Lobby/Graphics_AntiAliasing";

			public const string Graphics_AntiAliasing_Info = "Lobby/Graphics_AntiAliasing_Info";

			public const string Graphics_Apply = "Lobby/Graphics_Apply";

			public const string Graphics_Colour_Double = "Lobby/Graphics_Colour_Double";

			public const string Graphics_Colour_Left = "Lobby/Graphics_Colour_Left";

			public const string Graphics_Colour_Reset = "Lobby/Graphics_Colour_Reset";

			public const string Graphics_Colour_Right = "Lobby/Graphics_Colour_Right";

			public const string Graphics_Colours = "Lobby/Graphics_Colours";

			public const string Graphics_Environments = "Lobby/Graphics_Environments";

			public const string Graphics_Environments_Info = "Lobby/Graphics_Environments_Info";

			public const string Graphics_Fog = "Lobby/Graphics_Fog";

			public const string Graphics_Fog_Info = "Lobby/Graphics_Fog_Info";

			public const string Graphics_Graphics = "Lobby/Graphics_Graphics";

			public const string Graphics_InGameUI = "Lobby/Graphics_InGameUI";

			public const string Graphics_InGameUI_Info = "Lobby/Graphics_InGameUI_Info";

			public const string Graphics_Particles = "Lobby/Graphics_Particles";

			public const string Graphics_Particles_Info = "Lobby/Graphics_Particles_Info";

			public const string Graphics_PostProcessing = "Lobby/Graphics_PostProcessing";

			public const string Graphics_PostProcessing_Info = "Lobby/Graphics_PostProcessing_Info";

			public const string Graphics_SmoothCam = "Lobby/Graphics_SmoothCam";

			public const string Graphics_SmoothCam_FOV = "Lobby/Graphics_SmoothCam_FOV";

			public const string Graphics_SmoothCam_FOV_Info = "Lobby/Graphics_SmoothCam_FOV_Info";

			public const string Graphics_SmoothCam_Info = "Lobby/Graphics_SmoothCam_Info";

			public const string Graphics_SmoothCam_Post = "Lobby/Graphics_SmoothCam_Post";

			public const string Graphics_SmoothCam_Post_Info = "Lobby/Graphics_SmoothCam_Post_Info";

			public const string Graphics_SmoothCam_Smoothness = "Lobby/Graphics_SmoothCam_Smoothness";

			public const string Graphics_SmoothCam_Smoothness_Info = "Lobby/Graphics_SmoothCam_Smoothness_Info";

			public const string Graphics_SmoothCamera = "Lobby/Graphics_SmoothCamera";

			public const string Graphics_Title = "Lobby/Graphics_Title";

			public const string Language_Current = "Lobby/Language_Current";

			public const string Language_English = "Lobby/Language_English";

			public const string Language_French = "Lobby/Language_French";

			public const string Language_German = "Lobby/Language_German";

			public const string Language_Italian = "Lobby/Language_Italian";

			public const string Language_Japanese = "Lobby/Language_Japanese";

			public const string Language_Korean = "Lobby/Language_Korean";

			public const string Language_Spanish = "Lobby/Language_Spanish";

			public const string Language_Title = "Lobby/Language_Title";

			public const string Leaderboards_Friends = "Lobby/Leaderboards_Friends";

			public const string Leaderboards_Global = "Lobby/Leaderboards_Global";

			public const string Leaderboards_Player = "Lobby/Leaderboards_Player";

			public const string Leaderboards_Rank = "Lobby/Leaderboards_Rank";

			public const string Leaderboards_Score = "Lobby/Leaderboards_Score";

			public const string Leaderboards_Title = "Lobby/Leaderboards_Title";

			public const string Main_Arcade = "Lobby/Main_Arcade";

			public const string Main_CustomSongs = "Lobby/Main_CustomSongs";

			public const string Main_HowToPlay = "Lobby/Main_HowToPlay";

			public const string Main_Title = "Lobby/Main_Title";

			public const string NoFail = "Lobby/NoFail";

			public const string Settings_Audio = "Lobby/Settings_Audio";

			public const string Settings_Credits = "Lobby/Settings_Credits";

			public const string Settings_Gameplay = "Lobby/Settings_Gameplay";

			public const string Settings_Graphics = "Lobby/Settings_Graphics";

			public const string Settings_Language = "Lobby/Settings_Language";

			public const string Settings_Title = "Lobby/Settings_Title";

			public const string SongSelect_Leaderboard = "Lobby/SongSelect_Leaderboard";

			public const string SongSelect_More = "Lobby/SongSelect_More";

			public const string SongSelect_Rank = "Lobby/SongSelect_Rank";

			public const string SongSelect_Title = "Lobby/SongSelect_Title";

			public const string Title_JoinDiscord = "Lobby/Title_JoinDiscord";

			public const string Title_Start = "Lobby/Title_Start";
		}

		public const string Accuracy = "Accuracy";

		public const string Back = "Back";

		public const string Back_To_Lobby = "Back_To_Lobby";

		public const string Battle = "Battle";

		public const string Core_Bio = "Core_Bio";

		public const string Core_Genre = "Core_Genre";

		public const string Core_Name = "Core_Name";

		public const string Core_Origin = "Core_Origin";

		public const string Core_Stage1 = "Core_Stage1";

		public const string Core_Stage2 = "Core_Stage2";

		public const string Core_Stage3 = "Core_Stage3";

		public const string Core_Stage4 = "Core_Stage4";

		public const string Core_Stage5 = "Core_Stage5";

		public const string Dance = "Dance";

		public const string Dre_Bio = "Dre_Bio";

		public const string Dre_Genre = "Dre_Genre";

		public const string Dre_Name = "Dre_Name";

		public const string Dre_Origin = "Dre_Origin";

		public const string Dre_Stage1 = "Dre_Stage1";

		public const string Dre_Stage2 = "Dre_Stage2";

		public const string Dre_Stage3 = "Dre_Stage3";

		public const string Dre_Stage4 = "Dre_Stage4";

		public const string Dre_Stage5 = "Dre_Stage5";

		public const string Easy = "Easy";

		public const string Flair = "Flair";

		public const string Game_Paused = "Game Paused";

		public const string Hard = "Hard";

		public const string HowToPlay_Basic = "HowToPlay_Basic";

		public const string HowToPlay_Cascades = "HowToPlay_Cascades";

		public const string HowToPlay_Double = "HowToPlay_Double";

		public const string HowToPlay_Flair = "HowToPlay_Flair";

		public const string HowToPlay_FlairTitle = "HowToPlay_FlairTitle";

		public const string HowToPlay_Sets = "HowToPlay_Sets";

		public const string Lais_Bio = "Lais_Bio";

		public const string Lais_Genre = "Lais_Genre";

		public const string Lais_Name = "Lais_Name";

		public const string Lais_Origin = "Lais_Origin";

		public const string Lais_Stage1 = "Lais_Stage1";

		public const string Lais_Stage2 = "Lais_Stage2";

		public const string Lais_Stage3 = "Lais_Stage3";

		public const string Lais_Stage4 = "Lais_Stage4";

		public const string Lais_Stage5 = "Lais_Stage5";

		public const string Leaderboards_Friends = "Leaderboards_Friends";

		public const string Leaderboards_Global = "Leaderboards_Global";

		public const string Leaderboards_Local = "Leaderboards_Local";

		public const string Leaderboards_Title = "Leaderboards_Title";

		public const string LiuWei_Name = "LiuWei_Name";

		public const string LiuWen_Genre = "LiuWen_Genre";

		public const string Liu_Bio = "Liu_Bio";

		public const string Liu_Origin = "Liu_Origin";

		public const string Liu_Stage1 = "Liu_Stage1";

		public const string Liu_Stage2 = "Liu_Stage2";

		public const string Liu_Stage3 = "Liu_Stage3";

		public const string Liu_Stage4 = "Liu_Stage4";

		public const string Liu_Stage5 = "Liu_Stage5";

		public const string Max_Multiplier = "Max_Multiplier";

		public const string Max_Streak = "Max_Streak";

		public const string Next_Stage = "Next_Stage";

		public const string Normal = "Normal";

		public const string Perfect_Cascades = "Perfect_Cascades";

		public const string Pyro_Bio = "Pyro_Bio";

		public const string Pyro_Genre = "Pyro_Genre";

		public const string Pyro_Name = "Pyro_Name";

		public const string Pyro_Origin = "Pyro_Origin";

		public const string Pyro_Stage1 = "Pyro_Stage1";

		public const string Pyro_Stage2 = "Pyro_Stage2";

		public const string Pyro_Stage3 = "Pyro_Stage3";

		public const string Pyro_Stage4 = "Pyro_Stage4";

		public const string Pyro_Stage5 = "Pyro_Stage5";

		public const string Rank = "Rank";

		public const string Remi_Bio = "Remi_Bio";

		public const string Remi_Genre = "Remi_Genre";

		public const string Remi_Name = "Remi_Name";

		public const string Remi_Origin = "Remi_Origin";

		public const string Remi_Stage1 = "Remi_Stage1";

		public const string Remi_Stage2 = "Remi_Stage2";

		public const string Remi_Stage3 = "Remi_Stage3";

		public const string Remi_Stage4 = "Remi_Stage4";

		public const string Remi_Stage5 = "Remi_Stage5";

		public const string Resume = "Resume";

		public const string Retry = "Retry";

		public const string ScoreEvent_Amazing = "ScoreEvent_Amazing";

		public const string ScoreEvent_Awesome = "ScoreEvent_Awesome";

		public const string ScoreEvent_Beautiful = "ScoreEvent_Beautiful";

		public const string ScoreEvent_Cool = "ScoreEvent_Cool";

		public const string ScoreEvent_Great = "ScoreEvent_Great";

		public const string ScoreEvent_Nice = "ScoreEvent_Nice";

		public const string ScoreEvent_Perfect = "ScoreEvent_Perfect";

		public const string ScoreEvent_Superb = "ScoreEvent_Superb";

		public const string Select = "Select";

		public const string Sets_Completed = "Sets_Completed";

		public const string Settings_AmbientMusic = "Settings_AmbientMusic";

		public const string Settings_Apply = "Settings_Apply";

		public const string Settings_Audio = "Settings_Audio";

		public const string Settings_AuraQuality = "Settings_AuraQuality";

		public const string Settings_Aura_Lighting = "Settings_Aura_Lighting";

		public const string Settings_Credits = "Settings_Credits";

		public const string Settings_DanceHolograms = "Settings_DanceHolograms";

		public const string Settings_DevConsole = "Settings_DevConsole";

		public const string Settings_GameMusic = "Settings_GameMusic";

		public const string Settings_Graphics = "Settings_Graphics";

		public const string Settings_GraphicsBlurb = "Settings_GraphicsBlurb";

		public const string Settings_Language = "Settings_Language";

		public const string Settings_Lightshows = "Settings_Lightshows";

		public const string Settings_MasterVolume = "Settings_MasterVolume";

		public const string Settings_Node_Hit_Sounds = "Settings_Node_Hit_Sounds";

		public const string Settings_Other = "Settings_Other";

		public const string Settings_SFX = "Settings_SFX";

		public const string Settings_TauntParticles = "Settings_TauntParticles";

		public const string Settings_Title = "Settings_Title";

		public const string Settings_Voice = "Settings_Voice";

		public const string Sonya_Bio = "Sonya_Bio";

		public const string Sonya_Genre = "Sonya_Genre";

		public const string Sonya_Name = "Sonya_Name";

		public const string Sonya_Origin = "Sonya_Origin";

		public const string Sonya_Stage1 = "Sonya_Stage1";

		public const string Sonya_Stage2 = "Sonya_Stage2";

		public const string Sonya_Stage3 = "Sonya_Stage3";

		public const string Sonya_Stage4 = "Sonya_Stage4";

		public const string Sonya_Stage5 = "Sonya_Stage5";

		public const string Stage = "Stage";

		public const string Stage_1 = "Stage_1";

		public const string Stage_2 = "Stage_2";

		public const string Stage_3 = "Stage_3";

		public const string Stage_Clear = "Stage_Clear";

		public const string Stage_Failed = "Stage_Failed";

		public const string Stop = "Stop";

		public const string Tutorial_Arrows = "Tutorial_Arrows";

		public const string Tutorial_Awesome = "Tutorial_Awesome";

		public const string Tutorial_Cascades = "Tutorial_Cascades";

		public const string Tutorial_Great = "Tutorial_Great";

		public const string Tutorial_GreenNode = "Tutorial_GreenNode";

		public const string Tutorial_Harder = "Tutorial_Harder";

		public const string Tutorial_Nice = "Tutorial_Nice";

		public const string Tutorial_PinkNode = "Tutorial_PinkNode";

		public const string Tutorial_Power = "Tutorial_Power";

		public const string Tutorial_Sets = "Tutorial_Sets";

		public const string Tutorial_Title_BasicNodes = "Tutorial_Title_BasicNodes";

		public const string Tutorial_Title_Cascades = "Tutorial_Title_Cascades";

		public const string Tutorial_Title_Dance = "Tutorial_Title_Dance";

		public const string Tutorial_Title_Power = "Tutorial_Title_Power";

		public const string Tutorial_Title_Sets = "Tutorial_Title_Sets";

		public const string Tutorial_Title_WideNodes = "Tutorial_Title_WideNodes";

		public const string Tutorial_Title_YellowNodes = "Tutorial_Title_YellowNodes";

		public const string Tutorial_TryAgain = "Tutorial_TryAgain";

		public const string Tutorial_Welcome = "Tutorial_Welcome";

		public const string Tutorial_Yellow = "Tutorial_Yellow";

		public const string UI_CharacterSelect_title = "UI_CharacterSelect_title";

		public const string UI_MainFont = "UI_MainFont";

		public const string UI_MainMenu_Custom = "UI_MainMenu_Custom";

		public const string UI_MainMenu_Editor = "UI_MainMenu_Editor";

		public const string UI_MainMenu_FreeDance = "UI_MainMenu_FreeDance";

		public const string UI_MainMenu_Mode = "UI_MainMenu_Mode";

		public const string UI_MainMenu_Start = "UI_MainMenu_Start";

		public const string UI_MainMenu_Tournament = "UI_MainMenu_Tournament";

		public const string UI_MainMenu_Tutorial = "UI_MainMenu_Tutorial";

		public const string UI_SongSelect_title = "UI_SongSelect_title";

		public const string UI_TitleFont = "UI_TitleFont";

		public const string Uriel_Bio = "Uriel_Bio";

		public const string Uriel_Name = "Uriel_Name";

		public const string Uriel_Origin = "Uriel_Origin";

		public const string Uriel_Stage1 = "Uriel_Stage1";

		public const string Uriel_Stage2 = "Uriel_Stage2";

		public const string Uriel_Stage3 = "Uriel_Stage3";

		public const string Uriel_Stage4 = "Uriel_Stage4";

		public const string Uriel_Stage5 = "Uriel_Stage5";

		public const string Yuri_Bio = "Yuri_Bio";

		public const string Yuri_Genre = "Yuri_Genre";

		public const string Yuri_Name = "Yuri_Name";

		public const string Yuri_Origin = "Yuri_Origin";

		public const string Yuri_Stage1 = "Yuri_Stage1";

		public const string Yuri_Stage2 = "Yuri_Stage2";

		public const string Yuri_Stage3 = "Yuri_Stage3";

		public const string Yuri_Stage4 = "Yuri_Stage4";

		public const string Yuri_Stage5 = "Yuri_Stage5";
	}
	public class CallbackNotification : MonoBehaviour
	{
		public void OnModifyLocalization()
		{
			if (!string.IsNullOrEmpty(Localize.MainTranslation))
			{
				string translation = LocalizationManager.GetTranslation("Color/Red");
				Localize.MainTranslation = Localize.MainTranslation.Replace("{PLAYER_COLOR}", translation);
			}
		}
	}
	public class Example_ChangeLanguage : MonoBehaviour
	{
		public void SetLanguage_English()
		{
			SetLanguage("English");
		}

		public void SetLanguage_French()
		{
			SetLanguage("French");
		}

		public void SetLanguage_Spanish()
		{
			SetLanguage("Spanish");
		}

		public void SetLanguage(string LangName)
		{
			if (LocalizationManager.HasLanguage(LangName))
			{
				LocalizationManager.CurrentLanguage = LangName;
			}
		}
	}
	public class Example_LocalizedString : MonoBehaviour
	{
		public LocalizedString _MyLocalizedString;

		public string _NormalString;

		[TermsPopup("")]
		public string _StringWithTermPopup;

		public void Start()
		{
			UnityEngine.Debug.Log(_MyLocalizedString);
			UnityEngine.Debug.Log(LocalizationManager.GetTranslation(_NormalString));
			UnityEngine.Debug.Log(LocalizationManager.GetTranslation(_StringWithTermPopup));
			UnityEngine.Debug.Log((string)(LocalizedString)"Term2");
			UnityEngine.Debug.Log(_MyLocalizedString);
			UnityEngine.Debug.Log((LocalizedString)"Term3");
			LocalizedString localizedString = "Term3";
			localizedString.mRTL_IgnoreArabicFix = true;
			UnityEngine.Debug.Log(localizedString);
			LocalizedString localizedString2 = "Term3";
			localizedString2.mRTL_ConvertNumbers = true;
			localizedString2.mRTL_MaxLineLength = 20;
			UnityEngine.Debug.Log(localizedString2);
			UnityEngine.Debug.Log(localizedString2);
		}
	}
	public class GlobalParametersExample : RegisterGlobalParameters
	{
		public override string GetParameterValue(string ParamName)
		{
			if (ParamName == "WINNER")
			{
				return "Javier";
			}
			if (ParamName == "NUM PLAYERS")
			{
				return 5.ToString();
			}
			return null;
		}
	}
	public class RealTimeTranslation : MonoBehaviour
	{
		private string OriginalText = "This is an example showing how to use the google translator to translate chat messages within the game.\nIt also supports multiline translations.";

		private string TranslatedText = string.Empty;

		private bool IsTranslating;

		public void OnGUI()
		{
			GUILayout.Label("Translate:");
			OriginalText = GUILayout.TextArea(OriginalText, GUILayout.Width(Screen.width));
			GUILayout.Space(10f);
			GUILayout.BeginHorizontal();
			if (GUILayout.Button("English -> Español", GUILayout.Height(100f)))
			{
				StartTranslating("en", "es");
			}
			if (GUILayout.Button("Español -> English", GUILayout.Height(100f)))
			{
				StartTranslating("es", "en");
			}
			GUILayout.EndHorizontal();
			GUILayout.Space(10f);
			GUILayout.BeginHorizontal();
			GUILayout.TextArea("Multiple Translation with 1 call:\n'This is an example' -> en,zh\n'Hola' -> en");
			if (GUILayout.Button("Multi Translate", GUILayout.ExpandHeight(expand: true)))
			{
				ExampleMultiTranslations_Async();
			}
			GUILayout.EndHorizontal();
			GUILayout.TextArea(TranslatedText, GUILayout.Width(Screen.width));
			GUILayout.Space(10f);
			if (IsTranslating)
			{
				GUILayout.Label("Contacting Google....");
			}
		}

		public void StartTranslating(string fromCode, string toCode)
		{
			IsTranslating = true;
			GoogleTranslation.Translate(OriginalText, fromCode, toCode, OnTranslationReady);
		}

		private void OnTranslationReady(string Translation, string errorMsg)
		{
			IsTranslating = false;
			if (errorMsg != null)
			{
				UnityEngine.Debug.LogError(errorMsg);
			}
			else
			{
				TranslatedText = Translation;
			}
		}

		public void ExampleMultiTranslations_Blocking()
		{
			Dictionary<string, TranslationQuery> dictionary = new Dictionary<string, TranslationQuery>();
			GoogleTranslation.AddQuery("This is an example", "en", "es", dictionary);
			GoogleTranslation.AddQuery("This is an example", "auto", "zh", dictionary);
			GoogleTranslation.AddQuery("Hola", "es", "en", dictionary);
			if (GoogleTranslation.ForceTranslate(dictionary))
			{
				UnityEngine.Debug.Log(GoogleTranslation.GetQueryResult("This is an example", "en", dictionary));
				UnityEngine.Debug.Log(GoogleTranslation.GetQueryResult("This is an example", "zh", dictionary));
				UnityEngine.Debug.Log(GoogleTranslation.GetQueryResult("This is an example", "", dictionary));
				UnityEngine.Debug.Log(dictionary["Hola"].Results[0]);
			}
		}

		public void ExampleMultiTranslations_Async()
		{
			IsTranslating = true;
			Dictionary<string, TranslationQuery> dictionary = new Dictionary<string, TranslationQuery>();
			GoogleTranslation.AddQuery("This is an example", "en", "es", dictionary);
			GoogleTranslation.AddQuery("This is an example", "auto", "zh", dictionary);
			GoogleTranslation.AddQuery("Hola", "es", "en", dictionary);
			GoogleTranslation.Translate(dictionary, OnMultitranslationReady);
		}

		private void OnMultitranslationReady(Dictionary<string, TranslationQuery> dict, string errorMsg)
		{
			if (!string.IsNullOrEmpty(errorMsg))
			{
				UnityEngine.Debug.LogError(errorMsg);
				return;
			}
			IsTranslating = false;
			TranslatedText = "";
			TranslatedText = TranslatedText + GoogleTranslation.GetQueryResult("This is an example", "es", dict) + "\n";
			TranslatedText = TranslatedText + GoogleTranslation.GetQueryResult("This is an example", "zh", dict) + "\n";
			TranslatedText = TranslatedText + GoogleTranslation.GetQueryResult("This is an example", "", dict) + "\n";
			TranslatedText += dict["Hola"].Results[0];
		}

		public bool IsWaitingForTranslation()
		{
			return IsTranslating;
		}

		public string GetTranslatedText()
		{
			return TranslatedText;
		}

		public void SetOriginalText(string text)
		{
			OriginalText = text;
		}
	}
	public class RegisterBundlesManager : MonoBehaviour, IResourceManager_Bundles
	{
		public void OnEnable()
		{
			if (!ResourceManager.pInstance.mBundleManagers.Contains(this))
			{
				ResourceManager.pInstance.mBundleManagers.Add(this);
			}
		}

		public void OnDisable()
		{
			ResourceManager.pInstance.mBundleManagers.Remove(this);
		}

		public virtual UnityEngine.Object LoadFromBundle(string path, Type assetType)
		{
			return null;
		}
	}
	public class ToggleLanguage : MonoBehaviour
	{
		private void Start()
		{
			Invoke("test", 3f);
		}

		private void test()
		{
			List<string> allLanguages = LocalizationManager.GetAllLanguages();
			int num = allLanguages.IndexOf(LocalizationManager.CurrentLanguage);
			if (num < 0)
			{
				num = 0;
			}
			else
			{
				num = (num + 1) % allLanguages.Count;
			}
			Invoke("test", 3f);
		}
	}
	public static class PersistentStorage
	{
		public enum eFileType
		{
			Raw,
			Persistent,
			Temporal,
			Streaming
		}

		private static I2CustomPersistentStorage mStorage;

		public static void SetSetting_String(string key, string value)
		{
			if (mStorage == null)
			{
				mStorage = new I2CustomPersistentStorage();
			}
			mStorage.SetSetting_String(key, value);
		}

		public static string GetSetting_String(string key, string defaultValue)
		{
			if (mStorage == null)
			{
				mStorage = new I2CustomPersistentStorage();
			}
			return mStorage.GetSetting_String(key, defaultValue);
		}

		public static void DeleteSetting(string key)
		{
			if (mStorage == null)
			{
				mStorage = new I2CustomPersistentStorage();
			}
			mStorage.DeleteSetting(key);
		}

		public static bool HasSetting(string key)
		{
			if (mStorage == null)
			{
				mStorage = new I2CustomPersistentStorage();
			}
			return mStorage.HasSetting(key);
		}

		public static void ForceSaveSettings()
		{
			if (mStorage == null)
			{
				mStorage = new I2CustomPersistentStorage();
			}
			mStorage.ForceSaveSettings();
		}

		public static bool CanAccessFiles()
		{
			if (mStorage == null)
			{
				mStorage = new I2CustomPersistentStorage();
			}
			return mStorage.CanAccessFiles();
		}

		public static bool SaveFile(eFileType fileType, string fileName, string data, bool logExceptions = true)
		{
			if (mStorage == null)
			{
				mStorage = new I2CustomPersistentStorage();
			}
			return mStorage.SaveFile(fileType, fileName, data, logExceptions);
		}

		public static string LoadFile(eFileType fileType, string fileName, bool logExceptions = true)
		{
			if (mStorage == null)
			{
				mStorage = new I2CustomPersistentStorage();
			}
			return mStorage.LoadFile(fileType, fileName, logExceptions);
		}

		public static bool DeleteFile(eFileType fileType, string fileName, bool logExceptions = true)
		{
			if (mStorage == null)
			{
				mStorage = new I2CustomPersistentStorage();
			}
			return mStorage.DeleteFile(fileType, fileName, logExceptions);
		}

		public static bool HasFile(eFileType fileType, string fileName, bool logExceptions = true)
		{
			if (mStorage == null)
			{
				mStorage = new I2CustomPersistentStorage();
			}
			return mStorage.HasFile(fileType, fileName, logExceptions);
		}
	}
	public abstract class I2BasePersistentStorage
	{
		public virtual void SetSetting_String(string key, string value)
		{
			try
			{
				int length = value.Length;
				int num = 8000;
				if (length <= num)
				{
					PlayerPrefs.SetString(key, value);
					return;
				}
				int num2 = Mathf.CeilToInt((float)length / (float)num);
				for (int i = 0; i < num2; i++)
				{
					int num3 = num * i;
					PlayerPrefs.SetString($"[I2split]{i}{key}", value.Substring(num3, Mathf.Min(num, length - num3)));
				}
				PlayerPrefs.SetString(key, "[$I2#@div$]" + num2);
			}
			catch (Exception)
			{
				UnityEngine.Debug.LogError("Error saving PlayerPrefs " + key);
			}
		}

		public virtual string GetSetting_String(string key, string defaultValue)
		{
			try
			{
				string text = PlayerPrefs.GetString(key, defaultValue);
				if (!string.IsNullOrEmpty(text) && text.StartsWith("[I2split]"))
				{
					int num = int.Parse(text.Substring("[I2split]".Length));
					text = "";
					for (int i = 0; i < num; i++)
					{
						text += PlayerPrefs.GetString($"[I2split]{i}{key}", "");
					}
				}
				return text;
			}
			catch (Exception)
			{
				UnityEngine.Debug.LogError("Error loading PlayerPrefs " + key);
				return defaultValue;
			}
		}

		public virtual void DeleteSetting(string key)
		{
			try
			{
				string @string = PlayerPrefs.GetString(key, null);
				if (!string.IsNullOrEmpty(@string) && @string.StartsWith("[I2split]"))
				{
					int num = int.Parse(@string.Substring("[I2split]".Length));
					for (int i = 0; i < num; i++)
					{
						PlayerPrefs.DeleteKey($"[I2split]{i}{key}");
					}
				}
				PlayerPrefs.DeleteKey(key);
			}
			catch (Exception)
			{
				UnityEngine.Debug.LogError("Error deleting PlayerPrefs " + key);
			}
		}

		public virtual void ForceSaveSettings()
		{
			PlayerPrefs.Save();
		}

		public virtual bool HasSetting(string key)
		{
			return PlayerPrefs.HasKey(key);
		}

		public virtual bool CanAccessFiles()
		{
			return true;
		}

		private string UpdateFilename(PersistentStorage.eFileType fileType, string fileName)
		{
			switch (fileType)
			{
			case PersistentStorage.eFileType.Persistent:
				fileName = UnityEngine.Application.persistentDataPath + "/" + fileName;
				break;
			case PersistentStorage.eFileType.Temporal:
				fileName = UnityEngine.Application.temporaryCachePath + "/" + fileName;
				break;
			case PersistentStorage.eFileType.Streaming:
				fileName = UnityEngine.Application.streamingAssetsPath + "/" + fileName;
				break;
			}
			return fileName;
		}

		public virtual bool SaveFile(PersistentStorage.eFileType fileType, string fileName, string data, bool logExceptions = true)
		{
			if (!CanAccessFiles())
			{
				return false;
			}
			try
			{
				fileName = UpdateFilename(fileType, fileName);
				File.WriteAllText(fileName, data, Encoding.UTF8);
				return true;
			}
			catch (Exception ex)
			{
				if (logExceptions)
				{
					UnityEngine.Debug.LogError("Error saving file '" + fileName + "'\n" + ex);
				}
				return false;
			}
		}

		public virtual string LoadFile(PersistentStorage.eFileType fileType, string fileName, bool logExceptions = true)
		{
			if (!CanAccessFiles())
			{
				return null;
			}
			try
			{
				fileName = UpdateFilename(fileType, fileName);
				return File.ReadAllText(fileName, Encoding.UTF8);
			}
			catch (Exception ex)
			{
				if (logExceptions)
				{
					UnityEngine.Debug.LogError("Error loading file '" + fileName + "'\n" + ex);
				}
				return null;
			}
		}

		public virtual bool DeleteFile(PersistentStorage.eFileType fileType, string fileName, bool logExceptions = true)
		{
			if (!CanAccessFiles())
			{
				return false;
			}
			try
			{
				fileName = UpdateFilename(fileType, fileName);
				File.Delete(fileName);
				return true;
			}
			catch (Exception ex)
			{
				if (logExceptions)
				{
					UnityEngine.Debug.LogError("Error deleting file '" + fileName + "'\n" + ex);
				}
				return false;
			}
		}

		public virtual bool HasFile(PersistentStorage.eFileType fileType, string fileName, bool logExceptions = true)
		{
			if (!CanAccessFiles())
			{
				return false;
			}
			try
			{
				fileName = UpdateFilename(fileType, fileName);
				return File.Exists(fileName);
			}
			catch (Exception ex)
			{
				if (logExceptions)
				{
					UnityEngine.Debug.LogError("Error requesting file '" + fileName + "'\n" + ex);
				}
				return false;
			}
		}
	}
	public class I2CustomPersistentStorage : I2BasePersistentStorage
	{
	}
	public class BaseSpecializationManager
	{
		public string[] mSpecializations;

		public Dictionary<string, string> mSpecializationsFallbacks;

		public virtual void InitializeSpecializations()
		{
			mSpecializations = new string[12]
			{
				"Any", "PC", "Touch", "Controller", "VR", "XBox", "PS4", "OculusVR", "ViveVR", "GearVR",
				"Android", "IOS"
			};
			mSpecializationsFallbacks = new Dictionary<string, string>
			{
				{ "XBox", "Controller" },
				{ "PS4", "Controller" },
				{ "OculusVR", "VR" },
				{ "ViveVR", "VR" },
				{ "GearVR", "VR" },
				{ "Android", "Touch" },
				{ "IOS", "Touch" }
			};
		}

		public virtual string GetCurrentSpecialization()
		{
			if (mSpecializations == null)
			{
				InitializeSpecializations();
			}
			return "Android";
		}

		public virtual string GetFallbackSpecialization(string specialization)
		{
			if (mSpecializationsFallbacks == null)
			{
				InitializeSpecializations();
			}
			if (mSpecializationsFallbacks.TryGetValue(specialization, out var value))
			{
				return value;
			}
			return "Any";
		}
	}
	public class SpecializationManager : BaseSpecializationManager
	{
		public static SpecializationManager Singleton = new SpecializationManager();

		private SpecializationManager()
		{
			InitializeSpecializations();
		}

		public static string GetSpecializedText(string text, string specialization = null)
		{
			int num = text.IndexOf("[i2s_");
			if (num < 0)
			{
				return text;
			}
			if (string.IsNullOrEmpty(specialization))
			{
				specialization = Singleton.GetCurrentSpecialization();
			}
			while (!string.IsNullOrEmpty(specialization) && specialization != "Any")
			{
				string text2 = "[i2s_" + specialization + "]";
				int num2 = text.IndexOf(text2);
				if (num2 < 0)
				{
					specialization = Singleton.GetFallbackSpecialization(specialization);
					continue;
				}
				num2 += text2.Length;
				int num3 = text.IndexOf("[i2s_", num2);
				if (num3 < 0)
				{
					num3 = text.Length;
				}
				return text.Substring(num2, num3 - num2);
			}
			return text.Substring(0, num);
		}

		public static string SetSpecializedText(string text, string newText, string specialization)
		{
			if (string.IsNullOrEmpty(specialization))
			{
				specialization = "Any";
			}
			if ((text == null || !text.Contains("[i2s_")) && specialization == "Any")
			{
				return newText;
			}
			Dictionary<string, string> specializations = GetSpecializations(text);
			specializations[specialization] = newText;
			return SetSpecializedText(specializations);
		}

		public static string SetSpecializedText(Dictionary<string, string> specializations)
		{
			if (!specializations.TryGetValue("Any", out var value))
			{
				value = string.Empty;
			}
			foreach (KeyValuePair<string, string> specialization in specializations)
			{
				if (specialization.Key != "Any" && !string.IsNullOrEmpty(specialization.Value))
				{
					value = value + "[i2s_" + specialization.Key + "]" + specialization.Value;
				}
			}
			return value;
		}

		public static Dictionary<string, string> GetSpecializations(string text, Dictionary<string, string> buffer = null)
		{
			if (buffer == null)
			{
				buffer = new Dictionary<string, string>();
			}
			else
			{
				buffer.Clear();
			}
			if (text == null)
			{
				buffer["Any"] = "";
				return buffer;
			}
			int num = 0;
			int num2 = text.IndexOf("[i2s_");
			if (num2 < 0)
			{
				num2 = text.Length;
			}
			buffer["Any"] = text.Substring(0, num2);
			for (num = num2; num < text.Length; num = num2)
			{
				num += "[i2s_".Length;
				int num3 = text.IndexOf(']', num);
				if (num3 < 0)
				{
					break;
				}
				string key = text.Substring(num, num3 - num);
				num = num3 + 1;
				num2 = text.IndexOf("[i2s_", num);
				if (num2 < 0)
				{
					num2 = text.Length;
				}
				string value = text.Substring(num, num2 - num);
				buffer[key] = value;
			}
			return buffer;
		}

		public static void AppendSpecializations(string text, List<string> list = null)
		{
			if (text == null)
			{
				return;
			}
			if (list == null)
			{
				list = new List<string>();
			}
			if (!list.Contains("Any"))
			{
				list.Add("Any");
			}
			int num = 0;
			while (num < text.Length)
			{
				num = text.IndexOf("[i2s_", num);
				if (num >= 0)
				{
					num += "[i2s_".Length;
					int num2 = text.IndexOf(']', num);
					if (num2 >= 0)
					{
						string item = text.Substring(num, num2 - num);
						if (!list.Contains(item))
						{
							list.Add(item);
						}
						continue;
					}
					break;
				}
				break;
			}
		}
	}
	[Serializable]
	public class EventCallback
	{
		public MonoBehaviour Target;

		public string MethodName = string.Empty;

		public void Execute(UnityEngine.Object Sender = null)
		{
			if (HasCallback() && UnityEngine.Application.isPlaying)
			{
				Target.gameObject.SendMessage(MethodName, Sender, SendMessageOptions.DontRequireReceiver);
			}
		}

		public bool HasCallback()
		{
			if (Target != null)
			{
				return !string.IsNullOrEmpty(MethodName);
			}
			return false;
		}
	}
	public enum ePluralType
	{
		Zero,
		One,
		Two,
		Few,
		Many,
		Plural
	}
	public static class GoogleLanguages
	{
		public struct LanguageCodeDef
		{
			public string Code;

			public string GoogleCode;

			public bool HasJoinedWords;

			public int PluralRule;
		}

		public static Dictionary<string, LanguageCodeDef> mLanguageDef = new Dictionary<string, LanguageCodeDef>(StringComparer.Ordinal)
		{
			{
				"Abkhazian",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ab",
					GoogleCode = "-"
				}
			},
			{
				"Afar",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "aa",
					GoogleCode = "-"
				}
			},
			{
				"Afrikaans",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "af"
				}
			},
			{
				"Akan",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ak",
					GoogleCode = "-"
				}
			},
			{
				"Albanian",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "sq"
				}
			},
			{
				"Amharic",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "am"
				}
			},
			{
				"Arabic",
				new LanguageCodeDef
				{
					PluralRule = 11,
					Code = "ar"
				}
			},
			{
				"Arabic/Algeria",
				new LanguageCodeDef
				{
					PluralRule = 11,
					Code = "ar-DZ",
					GoogleCode = "ar"
				}
			},
			{
				"Arabic/Bahrain",
				new LanguageCodeDef
				{
					PluralRule = 11,
					Code = "ar-BH",
					GoogleCode = "ar"
				}
			},
			{
				"Arabic/Egypt",
				new LanguageCodeDef
				{
					PluralRule = 11,
					Code = "ar-EG",
					GoogleCode = "ar"
				}
			},
			{
				"Arabic/Iraq",
				new LanguageCodeDef
				{
					PluralRule = 11,
					Code = "ar-IQ",
					GoogleCode = "ar"
				}
			},
			{
				"Arabic/Jordan",
				new LanguageCodeDef
				{
					PluralRule = 11,
					Code = "ar-JO",
					GoogleCode = "ar"
				}
			},
			{
				"Arabic/Kuwait",
				new LanguageCodeDef
				{
					PluralRule = 11,
					Code = "ar-KW",
					GoogleCode = "ar"
				}
			},
			{
				"Arabic/Lebanon",
				new LanguageCodeDef
				{
					PluralRule = 11,
					Code = "ar-LB",
					GoogleCode = "ar"
				}
			},
			{
				"Arabic/Libya",
				new LanguageCodeDef
				{
					PluralRule = 11,
					Code = "ar-LY",
					GoogleCode = "ar"
				}
			},
			{
				"Arabic/Morocco",
				new LanguageCodeDef
				{
					PluralRule = 11,
					Code = "ar-MA",
					GoogleCode = "ar"
				}
			},
			{
				"Arabic/Oman",
				new LanguageCodeDef
				{
					PluralRule = 11,
					Code = "ar-OM",
					GoogleCode = "ar"
				}
			},
			{
				"Arabic/Qatar",
				new LanguageCodeDef
				{
					PluralRule = 11,
					Code = "ar-QA",
					GoogleCode = "ar"
				}
			},
			{
				"Arabic/Saudi Arabia",
				new LanguageCodeDef
				{
					PluralRule = 11,
					Code = "ar-SA",
					GoogleCode = "ar"
				}
			},
			{
				"Arabic/Syria",
				new LanguageCodeDef
				{
					PluralRule = 11,
					Code = "ar-SY",
					GoogleCode = "ar"
				}
			},
			{
				"Arabic/Tunisia",
				new LanguageCodeDef
				{
					PluralRule = 11,
					Code = "ar-TN",
					GoogleCode = "ar"
				}
			},
			{
				"Arabic/U.A.E.",
				new LanguageCodeDef
				{
					PluralRule = 11,
					Code = "ar-AE",
					GoogleCode = "ar"
				}
			},
			{
				"Arabic/Yemen",
				new LanguageCodeDef
				{
					PluralRule = 11,
					Code = "ar-YE",
					GoogleCode = "ar"
				}
			},
			{
				"Aragonese",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "an",
					GoogleCode = "-"
				}
			},
			{
				"Armenian",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "hy"
				}
			},
			{
				"Assamese",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "as",
					GoogleCode = "-"
				}
			},
			{
				"Avaric",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "av",
					GoogleCode = "-"
				}
			},
			{
				"Avestan",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ae",
					GoogleCode = "-"
				}
			},
			{
				"Aymara",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ay",
					GoogleCode = "-"
				}
			},
			{
				"Azerbaijani",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "az"
				}
			},
			{
				"Bambara",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "bm",
					GoogleCode = "-"
				}
			},
			{
				"Bashkir",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ba",
					GoogleCode = "-"
				}
			},
			{
				"Basque",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "eu"
				}
			},
			{
				"Basque/Spain",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "eu-ES",
					GoogleCode = "eu"
				}
			},
			{
				"Belarusian",
				new LanguageCodeDef
				{
					PluralRule = 6,
					Code = "be"
				}
			},
			{
				"Bengali",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "bn"
				}
			},
			{
				"Bihari",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "bh",
					GoogleCode = "-"
				}
			},
			{
				"Bislama",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "bi",
					GoogleCode = "-"
				}
			},
			{
				"Bosnian",
				new LanguageCodeDef
				{
					PluralRule = 6,
					Code = "bs"
				}
			},
			{
				"Breton",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "br",
					GoogleCode = "-"
				}
			},
			{
				"Bulgariaa",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "bg"
				}
			},
			{
				"Burmese",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "my"
				}
			},
			{
				"Catalan",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ca"
				}
			},
			{
				"Chamorro",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ch",
					GoogleCode = "-"
				}
			},
			{
				"Chechen",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ce",
					GoogleCode = "-"
				}
			},
			{
				"Chichewa",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ny"
				}
			},
			{
				"Chinese",
				new LanguageCodeDef
				{
					PluralRule = 0,
					Code = "zh",
					GoogleCode = "zh-CN",
					HasJoinedWords = true
				}
			},
			{
				"Chinese/Hong Kong",
				new LanguageCodeDef
				{
					PluralRule = 0,
					Code = "zh-HK",
					GoogleCode = "zh-TW",
					HasJoinedWords = true
				}
			},
			{
				"Chinese/Macau",
				new LanguageCodeDef
				{
					PluralRule = 0,
					Code = "zh-MO",
					GoogleCode = "zh-CN",
					HasJoinedWords = true
				}
			},
			{
				"Chinese/PRC",
				new LanguageCodeDef
				{
					PluralRule = 0,
					Code = "zh-CN",
					GoogleCode = "zh-CN",
					HasJoinedWords = true
				}
			},
			{
				"Chinese/Simplified",
				new LanguageCodeDef
				{
					PluralRule = 0,
					Code = "zh-CN",
					GoogleCode = "zh-CN",
					HasJoinedWords = true
				}
			},
			{
				"Chinese/Singapore",
				new LanguageCodeDef
				{
					PluralRule = 0,
					Code = "zh-SG",
					GoogleCode = "zh-CN",
					HasJoinedWords = true
				}
			},
			{
				"Chinese/Taiwan",
				new LanguageCodeDef
				{
					PluralRule = 0,
					Code = "zh-TW",
					GoogleCode = "zh-TW",
					HasJoinedWords = true
				}
			},
			{
				"Chinese/Traditional",
				new LanguageCodeDef
				{
					PluralRule = 0,
					Code = "zh-TW",
					GoogleCode = "zh-TW",
					HasJoinedWords = true
				}
			},
			{
				"Chuvash",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "cv",
					GoogleCode = "-"
				}
			},
			{
				"Cornish",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "kw",
					GoogleCode = "-"
				}
			},
			{
				"Corsican",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "co"
				}
			},
			{
				"Cree",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "cr",
					GoogleCode = "-"
				}
			},
			{
				"Croatian",
				new LanguageCodeDef
				{
					PluralRule = 6,
					Code = "hr"
				}
			},
			{
				"Croatian/Bosnia and Herzegovina",
				new LanguageCodeDef
				{
					PluralRule = 5,
					Code = "hr-BA",
					GoogleCode = "hr"
				}
			},
			{
				"Czech",
				new LanguageCodeDef
				{
					PluralRule = 7,
					Code = "cs"
				}
			},
			{
				"Danish",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "da"
				}
			},
			{
				"Divehi",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "dv",
					GoogleCode = "-"
				}
			},
			{
				"Dutch",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "nl"
				}
			},
			{
				"Dutch/Belgium",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "nl-BE",
					GoogleCode = "nl"
				}
			},
			{
				"Dutch/Netherlands",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "nl-NL",
					GoogleCode = "nl"
				}
			},
			{
				"Dzongkha",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "dz",
					GoogleCode = "-"
				}
			},
			{
				"English",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "en"
				}
			},
			{
				"English/Australia",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "en-AU",
					GoogleCode = "en"
				}
			},
			{
				"English/Belize",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "en-BZ",
					GoogleCode = "en"
				}
			},
			{
				"English/Canada",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "en-CA",
					GoogleCode = "en"
				}
			},
			{
				"English/Caribbean",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "en-CB",
					GoogleCode = "en"
				}
			},
			{
				"English/Ireland",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "en-IE",
					GoogleCode = "en"
				}
			},
			{
				"English/Jamaica",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "en-JM",
					GoogleCode = "en"
				}
			},
			{
				"English/New Zealand",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "en-NZ",
					GoogleCode = "en"
				}
			},
			{
				"English/Republic of the Philippines",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "en-PH",
					GoogleCode = "en"
				}
			},
			{
				"English/South Africa",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "en-ZA",
					GoogleCode = "en"
				}
			},
			{
				"English/Trinidad",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "en-TT",
					GoogleCode = "en"
				}
			},
			{
				"English/United Kingdom",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "en-GB",
					GoogleCode = "en"
				}
			},
			{
				"English/United States",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "en-US",
					GoogleCode = "en"
				}
			},
			{
				"English/Zimbabwe",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "en-ZW",
					GoogleCode = "en"
				}
			},
			{
				"Esperanto",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "eo"
				}
			},
			{
				"Estonian",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "et"
				}
			},
			{
				"Ewe",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ee",
					GoogleCode = "-"
				}
			},
			{
				"Faeroese",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "fo",
					GoogleCode = "-"
				}
			},
			{
				"Fijian",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "fj",
					GoogleCode = "-"
				}
			},
			{
				"Finnish",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "fi"
				}
			},
			{
				"French",
				new LanguageCodeDef
				{
					PluralRule = 2,
					Code = "fr"
				}
			},
			{
				"French/Belgium",
				new LanguageCodeDef
				{
					PluralRule = 2,
					Code = "fr-BE",
					GoogleCode = "fr"
				}
			},
			{
				"French/Canada",
				new LanguageCodeDef
				{
					PluralRule = 2,
					Code = "fr-CA",
					GoogleCode = "fr"
				}
			},
			{
				"French/France",
				new LanguageCodeDef
				{
					PluralRule = 2,
					Code = "fr-FR",
					GoogleCode = "fr"
				}
			},
			{
				"French/Luxembourg",
				new LanguageCodeDef
				{
					PluralRule = 2,
					Code = "fr-LU",
					GoogleCode = "fr"
				}
			},
			{
				"French/Principality of Monaco",
				new LanguageCodeDef
				{
					PluralRule = 2,
					Code = "fr-MC",
					GoogleCode = "fr"
				}
			},
			{
				"French/Switzerland",
				new LanguageCodeDef
				{
					PluralRule = 2,
					Code = "fr-CH",
					GoogleCode = "fr"
				}
			},
			{
				"Fulah",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ff",
					GoogleCode = "-"
				}
			},
			{
				"Galician",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "gl"
				}
			},
			{
				"Galician/Spain",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "gl-ES",
					GoogleCode = "gl"
				}
			},
			{
				"Georgian",
				new LanguageCodeDef
				{
					PluralRule = 0,
					Code = "ka"
				}
			},
			{
				"German",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "de"
				}
			},
			{
				"German/Austria",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "de-AT",
					GoogleCode = "de"
				}
			},
			{
				"German/Germany",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "de-DE",
					GoogleCode = "de"
				}
			},
			{
				"German/Liechtenstein",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "de-LI",
					GoogleCode = "de"
				}
			},
			{
				"German/Luxembourg",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "de-LU",
					GoogleCode = "de"
				}
			},
			{
				"German/Switzerland",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "de-CH",
					GoogleCode = "de"
				}
			},
			{
				"Greek",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "el"
				}
			},
			{
				"Guaraní",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "gn",
					GoogleCode = "-"
				}
			},
			{
				"Gujarati",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "gu"
				}
			},
			{
				"Haitian",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ht"
				}
			},
			{
				"Hausa",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ha"
				}
			},
			{
				"Hebrew",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "he",
					GoogleCode = "iw"
				}
			},
			{
				"Herero",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "hz",
					GoogleCode = "-"
				}
			},
			{
				"Hindi",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "hi"
				}
			},
			{
				"Hiri Motu",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ho",
					GoogleCode = "-"
				}
			},
			{
				"Hungarian",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "hu"
				}
			},
			{
				"Interlingua",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ia",
					GoogleCode = "-"
				}
			},
			{
				"Indonesian",
				new LanguageCodeDef
				{
					PluralRule = 0,
					Code = "id"
				}
			},
			{
				"Interlingue",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ie",
					GoogleCode = "-"
				}
			},
			{
				"Irish",
				new LanguageCodeDef
				{
					PluralRule = 10,
					Code = "ga"
				}
			},
			{
				"Igbo",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ig"
				}
			},
			{
				"Inupiaq",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ik",
					GoogleCode = "-"
				}
			},
			{
				"Ido",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "io",
					GoogleCode = "-"
				}
			},
			{
				"Icelandic",
				new LanguageCodeDef
				{
					PluralRule = 14,
					Code = "is"
				}
			},
			{
				"Italian",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "it"
				}
			},
			{
				"Italian/Italy",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "it-IT",
					GoogleCode = "it"
				}
			},
			{
				"Italian/Switzerland",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "it-CH",
					GoogleCode = "it"
				}
			},
			{
				"Inuktitut",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "iu",
					GoogleCode = "-"
				}
			},
			{
				"Japanese",
				new LanguageCodeDef
				{
					PluralRule = 0,
					Code = "ja",
					HasJoinedWords = true
				}
			},
			{
				"Javanese",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "jv"
				}
			},
			{
				"Kalaallisut",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "kl",
					GoogleCode = "-"
				}
			},
			{
				"Kannada",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "kn"
				}
			},
			{
				"Kanuri",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "kr",
					GoogleCode = "-"
				}
			},
			{
				"Kashmiri",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ks",
					GoogleCode = "-"
				}
			},
			{
				"Kazakh",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "kk"
				}
			},
			{
				"Central Khmer",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "km"
				}
			},
			{
				"Kikuyu",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ki",
					GoogleCode = "-"
				}
			},
			{
				"Kinyarwanda",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "rw",
					GoogleCode = "-"
				}
			},
			{
				"Kirghiz",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ky"
				}
			},
			{
				"Komi",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "kv",
					GoogleCode = "-"
				}
			},
			{
				"Kongo",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "kg",
					GoogleCode = "-"
				}
			},
			{
				"Korean",
				new LanguageCodeDef
				{
					PluralRule = 0,
					Code = "ko"
				}
			},
			{
				"Kurdish",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ku"
				}
			},
			{
				"Kuanyama",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "kj",
					GoogleCode = "-"
				}
			},
			{
				"Latin",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "la"
				}
			},
			{
				"Luxembourgish",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "lb"
				}
			},
			{
				"Ganda",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "lg",
					GoogleCode = "-"
				}
			},
			{
				"Limburgan",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "li",
					GoogleCode = "-"
				}
			},
			{
				"Lingala",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ln",
					GoogleCode = "-"
				}
			},
			{
				"Lao",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "lo"
				}
			},
			{
				"Latvian",
				new LanguageCodeDef
				{
					PluralRule = 5,
					Code = "lv"
				}
			},
			{
				"Luba-Katanga",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "lu",
					GoogleCode = "-"
				}
			},
			{
				"Lithuanian",
				new LanguageCodeDef
				{
					PluralRule = 5,
					Code = "lt"
				}
			},
			{
				"Manx",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "gv",
					GoogleCode = "-"
				}
			},
			{
				"Macedonian",
				new LanguageCodeDef
				{
					PluralRule = 13,
					Code = "mk"
				}
			},
			{
				"Malagasy",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "mg"
				}
			},
			{
				"Malay",
				new LanguageCodeDef
				{
					PluralRule = 0,
					Code = "ms"
				}
			},
			{
				"Malay/Brunei Darussalam",
				new LanguageCodeDef
				{
					PluralRule = 0,
					Code = "ms-BN",
					GoogleCode = "ms"
				}
			},
			{
				"Malay/Malaysia",
				new LanguageCodeDef
				{
					PluralRule = 0,
					Code = "ms-MY",
					GoogleCode = "ms"
				}
			},
			{
				"Malayalam",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ml"
				}
			},
			{
				"Maltese",
				new LanguageCodeDef
				{
					PluralRule = 12,
					Code = "mt"
				}
			},
			{
				"Maori",
				new LanguageCodeDef
				{
					PluralRule = 2,
					Code = "mi"
				}
			},
			{
				"Marathi",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "mr"
				}
			},
			{
				"Marshallese",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "mh",
					GoogleCode = "-"
				}
			},
			{
				"Mongolian",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "mn"
				}
			},
			{
				"Nauru",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "na",
					GoogleCode = "-"
				}
			},
			{
				"Navajo",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "nv",
					GoogleCode = "-"
				}
			},
			{
				"North Ndebele",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "nd",
					GoogleCode = "-"
				}
			},
			{
				"Nepali",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ne"
				}
			},
			{
				"Ndonga",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ng",
					GoogleCode = "-"
				}
			},
			{
				"Northern Sotho",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ns",
					GoogleCode = "st"
				}
			},
			{
				"Norwegian",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "nb",
					GoogleCode = "no"
				}
			},
			{
				"Norwegian/Nynorsk",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "nn",
					GoogleCode = "no"
				}
			},
			{
				"Sichuan Yi",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ii",
					GoogleCode = "-"
				}
			},
			{
				"South Ndebele",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "nr",
					GoogleCode = "-"
				}
			},
			{
				"Occitan",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "oc",
					GoogleCode = "-"
				}
			},
			{
				"Ojibwa",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "oj",
					GoogleCode = "-"
				}
			},
			{
				"Church\u00a0Slavic",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "cu",
					GoogleCode = "-"
				}
			},
			{
				"Oromo",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "om",
					GoogleCode = "-"
				}
			},
			{
				"Oriya",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "or",
					GoogleCode = "-"
				}
			},
			{
				"Ossetian",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "os",
					GoogleCode = "-"
				}
			},
			{
				"Pali",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "pi",
					GoogleCode = "-"
				}
			},
			{
				"Pashto",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ps"
				}
			},
			{
				"Persian",
				new LanguageCodeDef
				{
					PluralRule = 0,
					Code = "fa"
				}
			},
			{
				"Polish",
				new LanguageCodeDef
				{
					PluralRule = 8,
					Code = "pl"
				}
			},
			{
				"Portuguese",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "pt"
				}
			},
			{
				"Portuguese/Brazil",
				new LanguageCodeDef
				{
					PluralRule = 2,
					Code = "pt-BR",
					GoogleCode = "pt"
				}
			},
			{
				"Portuguese/Portugal",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "pt-PT",
					GoogleCode = "pt"
				}
			},
			{
				"Punjabi",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "pa"
				}
			},
			{
				"Quechua",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "qu",
					GoogleCode = "-"
				}
			},
			{
				"Quechua/Bolivia",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "qu-BO",
					GoogleCode = "-"
				}
			},
			{
				"Quechua/Ecuador",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "qu-EC",
					GoogleCode = "-"
				}
			},
			{
				"Quechua/Peru",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "qu-PE",
					GoogleCode = "-"
				}
			},
			{
				"Rhaeto-Romanic",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "rm",
					GoogleCode = "ro"
				}
			},
			{
				"Romanian",
				new LanguageCodeDef
				{
					PluralRule = 4,
					Code = "ro"
				}
			},
			{
				"Rundi",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "rn",
					GoogleCode = "-"
				}
			},
			{
				"Russian",
				new LanguageCodeDef
				{
					PluralRule = 6,
					Code = "ru"
				}
			},
			{
				"Russian/Republic of Moldova",
				new LanguageCodeDef
				{
					PluralRule = 6,
					Code = "ru-MO",
					GoogleCode = "ru"
				}
			},
			{
				"Sanskrit",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "sa",
					GoogleCode = "-"
				}
			},
			{
				"Sardinian",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "sc",
					GoogleCode = "-"
				}
			},
			{
				"Sindhi",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "sd"
				}
			},
			{
				"Northern Sami",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "se",
					GoogleCode = "-"
				}
			},
			{
				"Samoan",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "sm"
				}
			},
			{
				"Sango",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "sg",
					GoogleCode = "-"
				}
			},
			{
				"Serbian",
				new LanguageCodeDef
				{
					PluralRule = 6,
					Code = "sr"
				}
			},
			{
				"Serbian/Bosnia and Herzegovina",
				new LanguageCodeDef
				{
					PluralRule = 5,
					Code = "sr-BA",
					GoogleCode = "sr"
				}
			},
			{
				"Serbian/Serbia and Montenegro",
				new LanguageCodeDef
				{
					PluralRule = 5,
					Code = "sr-SP",
					GoogleCode = "sr"
				}
			},
			{
				"Scottish Gaelic",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "gd"
				}
			},
			{
				"Shona",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "sn"
				}
			},
			{
				"Sinhala",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "si"
				}
			},
			{
				"Slovak",
				new LanguageCodeDef
				{
					PluralRule = 7,
					Code = "sk"
				}
			},
			{
				"Slovenian",
				new LanguageCodeDef
				{
					PluralRule = 9,
					Code = "sl"
				}
			},
			{
				"Somali",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "so"
				}
			},
			{
				"Southern Sotho",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "st"
				}
			},
			{
				"Spanish",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "es"
				}
			},
			{
				"Spanish/Argentina",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "es-AR",
					GoogleCode = "es"
				}
			},
			{
				"Spanish/Bolivia",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "es-BO",
					GoogleCode = "es"
				}
			},
			{
				"Spanish/Castilian",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "es-ES",
					GoogleCode = "es"
				}
			},
			{
				"Spanish/Chile",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "es-CL",
					GoogleCode = "es"
				}
			},
			{
				"Spanish/Colombia",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "es-CO",
					GoogleCode = "es"
				}
			},
			{
				"Spanish/Costa Rica",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "es-CR",
					GoogleCode = "es"
				}
			},
			{
				"Spanish/Dominican Republic",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "es-DO",
					GoogleCode = "es"
				}
			},
			{
				"Spanish/Ecuador",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "es-EC",
					GoogleCode = "es"
				}
			},
			{
				"Spanish/El Salvador",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "es-SV",
					GoogleCode = "es"
				}
			},
			{
				"Spanish/Guatemala",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "es-GT",
					GoogleCode = "es"
				}
			},
			{
				"Spanish/Honduras",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "es-HN",
					GoogleCode = "es"
				}
			},
			{
				"Spanish/Mexico",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "es-MX",
					GoogleCode = "es"
				}
			},
			{
				"Spanish/Nicaragua",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "es-NI",
					GoogleCode = "es"
				}
			},
			{
				"Spanish/Panama",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "es-PA",
					GoogleCode = "es"
				}
			},
			{
				"Spanish/Paraguay",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "es-PY",
					GoogleCode = "es"
				}
			},
			{
				"Spanish/Peru",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "es-PE",
					GoogleCode = "es"
				}
			},
			{
				"Spanish/Puerto Rico",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "es-PR",
					GoogleCode = "es"
				}
			},
			{
				"Spanish/Spain",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "es-ES",
					GoogleCode = "es"
				}
			},
			{
				"Spanish/Uruguay",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "es-UY",
					GoogleCode = "es"
				}
			},
			{
				"Spanish/Venezuela",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "es-VE",
					GoogleCode = "es"
				}
			},
			{
				"Spanish/Latin Americas",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "es-US",
					GoogleCode = "es"
				}
			},
			{
				"Sundanese",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "su"
				}
			},
			{
				"Swahili",
				new LanguageCodeDef
				{
					Code = "sw"
				}
			},
			{
				"Swati",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ss",
					GoogleCode = "-"
				}
			},
			{
				"Swedish",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "sv"
				}
			},
			{
				"Swedish/Finland",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "sv-FI",
					GoogleCode = "sv"
				}
			},
			{
				"Swedish/Sweden",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "sv-SE",
					GoogleCode = "sv"
				}
			},
			{
				"Tamil",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ta"
				}
			},
			{
				"Tatar",
				new LanguageCodeDef
				{
					PluralRule = 0,
					Code = "tt",
					GoogleCode = "-"
				}
			},
			{
				"Telugu",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "te"
				}
			},
			{
				"Tajik",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "tg"
				}
			},
			{
				"Thai",
				new LanguageCodeDef
				{
					PluralRule = 0,
					Code = "th",
					HasJoinedWords = true
				}
			},
			{
				"Tigrinya",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ti",
					GoogleCode = "-"
				}
			},
			{
				"Tibetan",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "bo",
					GoogleCode = "-"
				}
			},
			{
				"Turkmen",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "tk",
					GoogleCode = "-"
				}
			},
			{
				"Tagalog",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "tl"
				}
			},
			{
				"Tswana",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "tn",
					GoogleCode = "-"
				}
			},
			{
				"Tonga",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "to",
					GoogleCode = "-"
				}
			},
			{
				"Turkish",
				new LanguageCodeDef
				{
					PluralRule = 0,
					Code = "tr"
				}
			},
			{
				"Tsonga",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ts",
					GoogleCode = "-"
				}
			},
			{
				"Twi",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "tw",
					GoogleCode = "-"
				}
			},
			{
				"Tahitian",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ty",
					GoogleCode = "-"
				}
			},
			{
				"Uighur",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ug",
					GoogleCode = "-"
				}
			},
			{
				"Ukrainian",
				new LanguageCodeDef
				{
					PluralRule = 6,
					Code = "uk"
				}
			},
			{
				"Urdu",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ur"
				}
			},
			{
				"Uzbek",
				new LanguageCodeDef
				{
					PluralRule = 2,
					Code = "uz"
				}
			},
			{
				"Venda",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ve",
					GoogleCode = "-"
				}
			},
			{
				"Vietnamese",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "vi"
				}
			},
			{
				"Volapük",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "vo",
					GoogleCode = "-"
				}
			},
			{
				"Walloon",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "wa",
					GoogleCode = "-"
				}
			},
			{
				"Welsh",
				new LanguageCodeDef
				{
					PluralRule = 16,
					Code = "cy"
				}
			},
			{
				"Wolof",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "wo",
					GoogleCode = "-"
				}
			},
			{
				"Frisian",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "fy"
				}
			},
			{
				"Xhosa",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "xh"
				}
			},
			{
				"Yiddish",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "yi"
				}
			},
			{
				"Yoruba",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "yo"
				}
			},
			{
				"Zhuang",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "za",
					GoogleCode = "-"
				}
			},
			{
				"Zulu",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "zu"
				}
			}
		};

		public static string GetLanguageCode(string Filter, bool ShowWarnings = false)
		{
			if (string.IsNullOrEmpty(Filter))
			{
				return string.Empty;
			}
			string[] filters = Filter.ToLowerInvariant().Split(" /(),".ToCharArray());
			foreach (KeyValuePair<string, LanguageCodeDef> item in mLanguageDef)
			{
				if (LanguageMatchesFilter(item.Key, filters))
				{
					return item.Value.Code;
				}
			}
			if (ShowWarnings)
			{
				UnityEngine.Debug.Log($"Language '{Filter}' not recognized. Please, add the language code to GoogleTranslation.cs");
			}
			return string.Empty;
		}

		public static List<string> GetLanguagesForDropdown(string Filter, string CodesToExclude)
		{
			string[] filters = Filter.ToLowerInvariant().Split(" /(),".ToCharArray());
			List<string> list = new List<string>();
			foreach (KeyValuePair<string, LanguageCodeDef> item in mLanguageDef)
			{
				if (string.IsNullOrEmpty(Filter) || LanguageMatchesFilter(item.Key, filters))
				{
					string text = string.Concat("[" + item.Value.Code + "]");
					if (!CodesToExclude.Contains(text))
					{
						list.Add(item.Key + " " + text);
					}
				}
			}
			for (int num = list.Count - 2; num >= 0; num--)
			{
				string text2 = list[num].Substring(0, list[num].IndexOf(" ["));
				if (list[num + 1].StartsWith(text2))
				{
					list[num] = text2 + "/" + list[num];
					list.Insert(num + 1, text2 + "/");
				}
			}
			return list;
		}

		private static bool LanguageMatchesFilter(string Language, string[] Filters)
		{
			Language = Language.ToLowerInvariant();
			int i = 0;
			for (int num = Filters.Length; i < num; i++)
			{
				if (Filters[i] != "")
				{
					if (!Language.Contains(Filters[i].ToLower()))
					{
						return false;
					}
					Language = Language.Remove(Language.IndexOf(Filters[i]), Filters[i].Length);
				}
			}
			return true;
		}

		public static string GetFormatedLanguageName(string Language)
		{
			string empty = string.Empty;
			int num = Language.IndexOf(" [");
			if (num > 0)
			{
				Language = Language.Substring(0, num);
			}
			num = Language.IndexOf('/');
			if (num > 0)
			{
				empty = Language.Substring(0, num);
				if (Language == empty + "/" + empty)
				{
					return empty;
				}
				Language = Language.Replace("/", " (") + ")";
			}
			return Language;
		}

		public static string GetCodedLanguage(string Language, string code)
		{
			string languageCode = GetLanguageCode(Language);
			if (string.Compare(code, languageCode, StringComparison.OrdinalIgnoreCase) == 0)
			{
				return Language;
			}
			return Language + " [" + code + "]";
		}

		public static void UnPackCodeFromLanguageName(string CodedLanguage, out string Language, out string code)
		{
			if (string.IsNullOrEmpty(CodedLanguage))
			{
				Language = string.Empty;
				code = string.Empty;
				return;
			}
			int num = CodedLanguage.IndexOf("[");
			if (num < 0)
			{
				Language = CodedLanguage;
				code = GetLanguageCode(Language);
			}
			else
			{
				Language = CodedLanguage.Substring(0, num).Trim();
				code = CodedLanguage.Substring(num + 1, CodedLanguage.IndexOf("]", num) - num - 1);
			}
		}

		public static string GetGoogleLanguageCode(string InternationalCode)
		{
			foreach (KeyValuePair<string, LanguageCodeDef> item in mLanguageDef)
			{
				if (InternationalCode == item.Value.Code)
				{
					if (item.Value.GoogleCode == "-")
					{
						return null;
					}
					return (!string.IsNullOrEmpty(item.Value.GoogleCode)) ? item.Value.GoogleCode : InternationalCode;
				}
			}
			return InternationalCode;
		}

		public static string GetLanguageName(string code, bool useParenthesesForRegion = false, bool allowDiscardRegion = true)
		{
			foreach (KeyValuePair<string, LanguageCodeDef> item in mLanguageDef)
			{
				if (!(code == item.Value.Code))
				{
					continue;
				}
				string text = item.Key;
				if (useParenthesesForRegion)
				{
					int num = text.IndexOf('/');
					if (num > 0)
					{
						text = text.Substring(0, num) + " (" + text.Substring(num + 1) + ")";
					}
				}
				return text;
			}
			if (allowDiscardRegion)
			{
				int num2 = code.IndexOf("-");
				if (num2 > 0)
				{
					return GetLanguageName(code.Substring(0, num2), useParenthesesForRegion, allowDiscardRegion: false);
				}
			}
			return null;
		}

		public static List<string> GetAllInternationalCodes()
		{
			HashSet<string> hashSet = new HashSet<string>();
			foreach (KeyValuePair<string, LanguageCodeDef> item in mLanguageDef)
			{
				hashSet.Add(item.Value.Code);
			}
			return new List<string>(hashSet);
		}

		public static bool LanguageCode_HasJoinedWord(string languageCode)
		{
			foreach (KeyValuePair<string, LanguageCodeDef> item in mLanguageDef)
			{
				if (languageCode == item.Value.GoogleCode || languageCode == item.Value.Code)
				{
					return item.Value.HasJoinedWords;
				}
			}
			return false;
		}

		private static int GetPluralRule(string langCode)
		{
			if (langCode.Length > 2)
			{
				langCode = langCode.Substring(0, 2);
			}
			langCode = langCode.ToLower();
			foreach (KeyValuePair<string, LanguageCodeDef> item in mLanguageDef)
			{
				if (item.Value.Code == langCode)
				{
					return item.Value.PluralRule;
				}
			}
			return 0;
		}

		public static bool LanguageHasPluralType(string langCode, string pluralType)
		{
			switch (pluralType)
			{
			case "Plural":
			case "Zero":
			case "One":
				return true;
			default:
				switch (GetPluralRule(langCode))
				{
				case 3:
					if (!(pluralType == "Two"))
					{
						return pluralType == "Few";
					}
					return true;
				case 4:
				case 5:
				case 6:
				case 7:
				case 8:
					return pluralType == "Few";
				case 9:
					if (!(pluralType == "Two"))
					{
						return pluralType == "Few";
					}
					return true;
				case 10:
				case 11:
				case 15:
				case 16:
					if (!(pluralType == "Two") && !(pluralType == "Few"))
					{
						return pluralType == "Many";
					}
					return true;
				case 12:
					if (!(pluralType == "Few"))
					{
						return pluralType == "Many";
					}
					return true;
				case 13:
					return pluralType == "Two";
				default:
					return false;
				}
			}
		}

		public static ePluralType GetPluralType(string langCode, int n)
		{
			switch (n)
			{
			case 0:
				return ePluralType.Zero;
			case 1:
				return ePluralType.One;
			default:
				switch (GetPluralRule(langCode))
				{
				case 0:
					return ePluralType.Plural;
				case 1:
					if (n != 1)
					{
						return ePluralType.Plural;
					}
					return ePluralType.One;
				case 2:
					if (n > 1)
					{
						return ePluralType.Plural;
					}
					return ePluralType.One;
				case 3:
					switch (n)
					{
					default:
						if (!inRange(n, 3, 10) && !inRange(n, 13, 19))
						{
							return ePluralType.Plural;
						}
						return ePluralType.Few;
					case 2:
					case 12:
						return ePluralType.Two;
					case 1:
					case 11:
						return ePluralType.One;
					}
				case 4:
					if (n != 1)
					{
						if (!inRange(n % 100, 1, 19))
						{
							return ePluralType.Plural;
						}
						return ePluralType.Few;
					}
					return ePluralType.One;
				case 5:
					if (n % 10 != 1 || n % 100 == 11)
					{
						if (n % 10 < 2 || (n % 100 >= 10 && n % 100 < 20))
						{
							return ePluralType.Plural;
						}
						return ePluralType.Few;
					}
					return ePluralType.One;
				case 6:
					if (n % 10 != 1 || n % 100 == 11)
					{
						if (!inRange(n % 10, 2, 4) || inRange(n % 100, 12, 14))
						{
							return ePluralType.Plural;
						}
						return ePluralType.Few;
					}
					return ePluralType.One;
				case 7:
					if (n != 1)
					{
						if (!inRange(n, 2, 4))
						{
							return ePluralType.Plural;
						}
						return ePluralType.Few;
					}
					return ePluralType.One;
				case 8:
					if (n != 1)
					{
						if (!inRange(n % 10, 2, 4) || inRange(n % 100, 12, 14))
						{
							return ePluralType.Plural;
						}
						return ePluralType.Few;
					}
					return ePluralType.One;
				case 9:
					if (n % 100 != 1)
					{
						if (n % 100 != 2)
						{
							if (!inRange(n % 100, 3, 4))
							{
								return ePluralType.Plural;
							}
							return ePluralType.Few;
						}
						return ePluralType.Two;
					}
					return ePluralType.One;
				case 10:
					switch (n)
					{
					default:
						if (!inRange(n, 3, 6))
						{
							if (!inRange(n, 7, 10))
							{
								return ePluralType.Plural;
							}
							return ePluralType.Many;
						}
						return ePluralType.Few;
					case 2:
						return ePluralType.Two;
					case 1:
						return ePluralType.One;
					}
				case 11:
					switch (n)
					{
					default:
						if (!inRange(n % 100, 3, 10))
						{
							if (n % 100 < 11)
							{
								return ePluralType.Plural;
							}
							return ePluralType.Many;
						}
						return ePluralType.Few;
					case 2:
						return ePluralType.Two;
					case 1:
						return ePluralType.One;
					case 0:
						return ePluralType.Zero;
					}
				case 12:
					if (n != 1)
					{
						if (!inRange(n % 100, 1, 10))
						{
							if (!inRange(n % 100, 11, 19))
							{
								return ePluralType.Plural;
							}
							return ePluralType.Many;
						}
						return ePluralType.Few;
					}
					return ePluralType.One;
				case 13:
					if (n % 10 != 1)
					{
						if (n % 10 != 2)
						{
							return ePluralType.Plural;
						}
						return ePluralType.Two;
					}
					return ePluralType.One;
				case 14:
					if (n % 10 != 1 || n % 100 == 11)
					{
						return ePluralType.Plural;
					}
					return ePluralType.One;
				case 15:
					if (n % 10 != 1 || n % 100 == 11 || n % 100 == 71 || n % 100 == 91)
					{
						if (n % 10 != 2 || n % 100 == 12 || n % 100 == 72 || n % 100 == 92)
						{
							if ((n % 10 != 3 && n % 10 != 4 && n % 10 != 9) || n % 100 == 13 || n % 100 == 14 || n % 100 == 19 || n % 100 == 73 || n % 100 == 74 || n % 100 == 79 || n % 100 == 93 || n % 100 == 94 || n % 100 == 99)
							{
								if (n % 1000000 != 0)
								{
									return ePluralType.Plural;
								}
								return ePluralType.Many;
							}
							return ePluralType.Few;
						}
						return ePluralType.Two;
					}
					return ePluralType.One;
				case 16:
					return n switch
					{
						6 => ePluralType.Many, 
						3 => ePluralType.Few, 
						2 => ePluralType.Two, 
						1 => ePluralType.One, 
						0 => ePluralType.Zero, 
						_ => ePluralType.Plural, 
					};
				default:
					return ePluralType.Plural;
				}
			}
		}

		public static int GetPluralTestNumber(string langCode, ePluralType pluralType)
		{
			switch (pluralType)
			{
			case ePluralType.Zero:
				return 0;
			case ePluralType.One:
				return 1;
			case ePluralType.Few:
				return 3;
			case ePluralType.Many:
				switch (GetPluralRule(langCode))
				{
				case 10:
					return 8;
				case 11:
				case 12:
					return 13;
				case 15:
					return 1000000;
				default:
					return 6;
				}
			default:
				return 936;
			}
		}

		private static bool inRange(int amount, int min, int max)
		{
			if (amount >= min)
			{
				return amount <= max;
			}
			return false;
		}
	}
	public static class GoogleTranslation
	{
		public delegate void fnOnTranslated(string Translation, string Error);

		public delegate void fnOnTranslationReady(Dictionary<string, TranslationQuery> dict, string error);

		private static List<UnityWebRequest> mCurrentTranslations = new List<UnityWebRequest>();

		private static List<TranslationJob> mTranslationJobs = new List<TranslationJob>();

		public static bool CanTranslate()
		{
			if (LocalizationManager.Sources.Count > 0)
			{
				return !string.IsNullOrEmpty(LocalizationManager.GetWebServiceURL());
			}
			return false;
		}

		public static void Translate(string text, string LanguageCodeFrom, string LanguageCodeTo, fnOnTranslated OnTranslationReady)
		{
			LocalizationManager.InitializeIfNeeded();
			if (!CanTranslate())
			{
				OnTranslationReady(null, "WebService is not set correctly or needs to be reinstalled");
				return;
			}
			if (LanguageCodeTo == LanguageCodeFrom)
			{
				OnTranslationReady(text, null);
				return;
			}
			Dictionary<string, TranslationQuery> queries = new Dictionary<string, TranslationQuery>();
			if (string.IsNullOrEmpty(LanguageCodeTo))
			{
				OnTranslationReady(string.Empty, null);
				return;
			}
			CreateQueries(text, LanguageCodeFrom, LanguageCodeTo, queries);
			Translate(queries, delegate(Dictionary<string, TranslationQuery> results, string error)
			{
				if (!string.IsNullOrEmpty(error) || results.Count == 0)
				{
					OnTranslationReady(null, error);
				}
				else
				{
					string translation = RebuildTranslation(text, queries, LanguageCodeTo);
					OnTranslationReady(translation, null);
				}
			});
		}

		public static string ForceTranslate(string text, string LanguageCodeFrom, string LanguageCodeTo)
		{
			Dictionary<string, TranslationQuery> dictionary = new Dictionary<string, TranslationQuery>();
			AddQuery(text, LanguageCodeFrom, LanguageCodeTo, dictionary);
			TranslationJob_Main translationJob_Main = new TranslationJob_Main(dictionary, null);
			while (true)
			{
				switch (translationJob_Main.GetState())
				{
				case TranslationJob.eJobState.Running:
					break;
				case TranslationJob.eJobState.Failed:
					return null;
				default:
					return GetQueryResult(text, "", dictionary);
				}
			}
		}

		public static void Translate(Dictionary<string, TranslationQuery> requests, fnOnTranslationReady OnTranslationReady, bool usePOST = true)
		{
			AddTranslationJob(new TranslationJob_Main(requests, OnTranslationReady));
		}

		public static bool ForceTranslate(Dictionary<string, TranslationQuery> requests, bool usePOST = true)
		{
			TranslationJob_Main translationJob_Main = new TranslationJob_Main(requests, null);
			while (true)
			{
				switch (translationJob_Main.GetState())
				{
				case TranslationJob.eJobState.Running:
					break;
				case TranslationJob.eJobState.Failed:
					return false;
				default:
					return true;
				}
			}
		}

		public static List<string> ConvertTranslationRequest(Dictionary<string, TranslationQuery> requests, bool encodeGET)
		{
			List<string> list = new List<string>();
			StringBuilder stringBuilder = new StringBuilder();
			foreach (KeyValuePair<string, TranslationQuery> request in requests)
			{
				TranslationQuery value = request.Value;
				if (stringBuilder.Length > 0)
				{
					stringBuilder.Append("<I2Loc>");
				}
				stringBuilder.Append(GoogleLanguages.GetGoogleLanguageCode(value.LanguageCode));
				stringBuilder.Append(":");
				for (int i = 0; i < value.TargetLanguagesCode.Length; i++)
				{
					if (i != 0)
					{
						stringBuilder.Append(",");
					}
					stringBuilder.Append(GoogleLanguages.GetGoogleLanguageCode(value.TargetLanguagesCode[i]));
				}
				stringBuilder.Append("=");
				string text = ((TitleCase(value.Text) == value.Text) ? value.Text.ToLowerInvariant() : value.Text);
				if (!encodeGET)
				{
					stringBuilder.Append(text);
					continue;
				}
				stringBuilder.Append(Uri.EscapeDataString(text));
				if (stringBuilder.Length > 4000)
				{
					list.Add(stringBuilder.ToString());
					stringBuilder.Length = 0;
				}
			}
			list.Add(stringBuilder.ToString());
			return list;
		}

		private static void AddTranslationJob(TranslationJob job)
		{
			mTranslationJobs.Add(job);
			if (mTranslationJobs.Count == 1)
			{
				CoroutineManager.Start(WaitForTranslations());
			}
		}

		private static IEnumerator WaitForTranslations()
		{
			while (mTranslationJobs.Count > 0)
			{
				TranslationJob[] array = mTranslationJobs.ToArray();
				foreach (TranslationJob translationJob in array)
				{
					if (translationJob.GetState() != 0)
					{
						mTranslationJobs.Remove(translationJob);
					}
				}
				yield return null;
			}
		}

		public static string ParseTranslationResult(string html, Dictionary<string, TranslationQuery> requests)
		{
			if (html.StartsWith("<!DOCTYPE html>") || html.StartsWith("<HTML>"))
			{
				if (html.Contains("The script completed but did not return anything"))
				{
					return "The current Google WebService is not supported.\nPlease, delete the WebService from the Google Drive and Install the latest version.";
				}
				if (html.Contains("Service invoked too many times in a short time"))
				{
					return "";
				}
				return "There was a problem contacting the WebService. Please try again later\n" + html;
			}
			string[] array = html.Split(new string[1] { "<I2Loc>" }, StringSplitOptions.None);
			string[] separator = new string[1] { "<i2>" };
			int num = 0;
			string[] array2 = requests.Keys.ToArray();
			foreach (string text in array2)
			{
				TranslationQuery value = FindQueryFromOrigText(text, requests);
				string text2 = array[num++];
				if (value.Tags != null)
				{
					for (int num2 = value.Tags.Length - 1; num2 >= 0; num2--)
					{
						text2 = text2.Replace(GetGoogleNoTranslateTag(num2), value.Tags[num2]);
					}
				}
				value.Results = text2.Split(separator, StringSplitOptions.None);
				if (TitleCase(text) == text)
				{
					for (int j = 0; j < value.Results.Length; j++)
					{
						value.Results[j] = TitleCase(value.Results[j]);
					}
				}
				requests[value.OrigText] = value;
			}
			return null;
		}

		public static bool IsTranslating()
		{
			if (mCurrentTranslations.Count <= 0)
			{
				return mTranslationJobs.Count > 0;
			}
			return true;
		}

		public static void CancelCurrentGoogleTranslations()
		{
			mCurrentTranslations.Clear();
			foreach (TranslationJob mTranslationJob in mTranslationJobs)
			{
				mTranslationJob.Dispose();
			}
			mTranslationJobs.Clear();
		}

		public static void CreateQueries(string text, string LanguageCodeFrom, string LanguageCodeTo, Dictionary<string, TranslationQuery> dict)
		{
			if (!text.Contains("[i2s_"))
			{
				CreateQueries_Plurals(text, LanguageCodeFrom, LanguageCodeTo, dict);
				return;
			}
			foreach (KeyValuePair<string, string> specialization in SpecializationManager.GetSpecializations(text))
			{
				CreateQueries_Plurals(specialization.Value, LanguageCodeFrom, LanguageCodeTo, dict);
			}
		}

		private static void CreateQueries_Plurals(string text, string LanguageCodeFrom, string LanguageCodeTo, Dictionary<string, TranslationQuery> dict)
		{
			bool flag = text.Contains("{[#");
			bool flag2 = text.Contains("[i2p_");
			if (!HasParameters(text) || (!flag && !flag2))
			{
				AddQuery(text, LanguageCodeFrom, LanguageCodeTo, dict);
				return;
			}
			bool forceTag = flag;
			for (ePluralType ePluralType2 = ePluralType.Zero; ePluralType2 <= ePluralType.Plural; ePluralType2++)
			{
				string pluralType = ePluralType2.ToString();
				if (GoogleLanguages.LanguageHasPluralType(LanguageCodeTo, pluralType))
				{
					string text2 = GetPluralText(text, pluralType);
					int pluralTestNumber = GoogleLanguages.GetPluralTestNumber(LanguageCodeTo, ePluralType2);
					string pluralParameter = GetPluralParameter(text2, forceTag);
					if (!string.IsNullOrEmpty(pluralParameter))
					{
						text2 = text2.Replace(pluralParameter, pluralTestNumber.ToString());
					}
					AddQuery(text2, LanguageCodeFrom, LanguageCodeTo, dict);
				}
			}
		}

		public static void AddQuery(string text, string LanguageCodeFrom, string LanguageCodeTo, Dictionary<string, TranslationQuery> dict)
		{
			if (string.IsNullOrEmpty(text))
			{
				return;
			}
			if (!dict.ContainsKey(text))
			{
				TranslationQuery translationQuery = default(TranslationQuery);
				translationQuery.OrigText = text;
				translationQuery.LanguageCode = LanguageCodeFrom;
				translationQuery.TargetLanguagesCode = new string[1] { LanguageCodeTo };
				TranslationQuery query = translationQuery;
				query.Text = text;
				ParseNonTranslatableElements(ref query);
				dict[text] = query;
			}
			else
			{
				TranslationQuery value = dict[text];
				if (Array.IndexOf(value.TargetLanguagesCode, LanguageCodeTo) < 0)
				{
					value.TargetLanguagesCode = Enumerable.Concat(value.TargetLanguagesCode, new string[1] { LanguageCodeTo }).Distinct().ToArray();
				}
				dict[text] = value;
			}
		}

		private static string GetTranslation(string text, string LanguageCodeTo, Dictionary<string, TranslationQuery> dict)
		{
			if (!dict.ContainsKey(text))
			{
				return null;
			}
			TranslationQuery translationQuery = dict[text];
			int num = Array.IndexOf(translationQuery.TargetLanguagesCode, LanguageCodeTo);
			if (num < 0)
			{
				return "";
			}
			if (translationQuery.Results == null)
			{
				return "";
			}
			return translationQuery.Results[num];
		}

		private static TranslationQuery FindQueryFromOrigText(string origText, Dictionary<string, TranslationQuery> dict)
		{
			foreach (KeyValuePair<string, TranslationQuery> item in dict)
			{
				if (item.Value.OrigText == origText)
				{
					return item.Value;
				}
			}
			return default(TranslationQuery);
		}

		public static bool HasParameters(string text)
		{
			int num = text.IndexOf("{[");
			if (num < 0)
			{
				return false;
			}
			return text.IndexOf("]}", num) > 0;
		}

		public static string GetPluralParameter(string text, bool forceTag)
		{
			int num = text.IndexOf("{[#");
			if (num < 0)
			{
				if (forceTag)
				{
					return null;
				}
				num = text.IndexOf("{[");
			}
			if (num < 0)
			{
				return null;
			}
			int num2 = text.IndexOf("]}", num + 2);
			if (num2 < 0)
			{
				return null;
			}
			return text.Substring(num, num2 - num + 2);
		}

		public static string GetPluralText(string text, string pluralType)
		{
			pluralType = "[i2p_" + pluralType + "]";
			int num = text.IndexOf(pluralType);
			if (num >= 0)
			{
				num += pluralType.Length;
				int num2 = text.IndexOf("[i2p_", num);
				if (num2 < 0)
				{
					num2 = text.Length;
				}
				return text.Substring(num, num2 - num);
			}
			num = text.IndexOf("[i2p_");
			if (num < 0)
			{
				return text;
			}
			if (num > 0)
			{
				return text.Substring(0, num);
			}
			num = text.IndexOf("]");
			if (num < 0)
			{
				return text;
			}
			num++;
			int num3 = text.IndexOf("[i2p_", num);
			if (num3 < 0)
			{
				num3 = text.Length;
			}
			return text.Substring(num, num3 - num);
		}

		private static int FindClosingTag(string tag, MatchCollection matches, int startIndex)
		{
			int i = startIndex;
			for (int count = matches.Count; i < count; i++)
			{
				string captureMatch = I2Utils.GetCaptureMatch(matches[i]);
				if (captureMatch[0] == '/' && tag.StartsWith(captureMatch.Substring(1)))
				{
					return i;
				}
			}
			return -1;
		}

		private static string GetGoogleNoTranslateTag(int tagNumber)
		{
			if (tagNumber < 70)
			{
				return "++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++".Substring(0, tagNumber + 1);
			}
			string text = "";
			for (int i = -1; i < tagNumber; i++)
			{
				text += "+";
			}
			return text;
		}

		private static void ParseNonTranslatableElements(ref TranslationQuery query)
		{
			MatchCollection matchCollection = Regex.Matches(query.Text, "\\{\\[(.*?)]}|\\[(.*?)]|\\<(.*?)>");
			if (matchCollection == null || matchCollection.Count == 0)
			{
				return;
			}
			string text = query.Text;
			List<string> list = new List<string>();
			int i = 0;
			for (int count = matchCollection.Count; i < count; i++)
			{
				string captureMatch = I2Utils.GetCaptureMatch(matchCollection[i]);
				int num = FindClosingTag(captureMatch, matchCollection, i);
				if (num < 0)
				{
					string text2 = matchCollection[i].ToString();
					if (text2.StartsWith("{[") && text2.EndsWith("]}"))
					{
						text = text.Replace(text2, GetGoogleNoTranslateTag(list.Count) + " ");
						list.Add(text2);
					}
				}
				else if (captureMatch == "i2nt")
				{
					string text3 = query.Text.Substring(matchCollection[i].Index, matchCollection[num].Index - matchCollection[i].Index + matchCollection[num].Length);
					text = text.Replace(text3, GetGoogleNoTranslateTag(list.Count) + " ");
					list.Add(text3);
				}
				else
				{
					string text4 = matchCollection[i].ToString();
					text = text.Replace(text4, GetGoogleNoTranslateTag(list.Count) + " ");
					list.Add(text4);
					string text5 = matchCollection[num].ToString();
					text = text.Replace(text5, GetGoogleNoTranslateTag(list.Count) + " ");
					list.Add(text5);
				}
			}
			query.Text = text;
			query.Tags = list.ToArray();
		}

		public static string GetQueryResult(string text, string LanguageCodeTo, Dictionary<string, TranslationQuery> dict)
		{
			if (!dict.ContainsKey(text))
			{
				return null;
			}
			TranslationQuery translationQuery = dict[text];
			if (translationQuery.Results == null || translationQuery.Results.Length < 0)
			{
				return null;
			}
			if (string.IsNullOrEmpty(LanguageCodeTo))
			{
				return translationQuery.Results[0];
			}
			int num = Array.IndexOf(translationQuery.TargetLanguagesCode, LanguageCodeTo);
			if (num < 0)
			{
				return null;
			}
			return translationQuery.Results[num];
		}

		public static string RebuildTranslation(string text, Dictionary<string, TranslationQuery> dict, string LanguageCodeTo)
		{
			if (!text.Contains("[i2s_"))
			{
				return RebuildTranslation_Plural(text, dict, LanguageCodeTo);
			}
			Dictionary<string, string> specializations = SpecializationManager.GetSpecializations(text);
			Dictionary<string, string> dictionary = new Dictionary<string, string>();
			foreach (KeyValuePair<string, string> item in specializations)
			{
				dictionary[item.Key] = RebuildTranslation_Plural(item.Value, dict, LanguageCodeTo);
			}
			return SpecializationManager.SetSpecializedText(dictionary);
		}

		private static string RebuildTranslation_Plural(string text, Dictionary<string, TranslationQuery> dict, string LanguageCodeTo)
		{
			bool flag = text.Contains("{[#");
			bool flag2 = text.Contains("[i2p_");
			if (!HasParameters(text) || (!flag && !flag2))
			{
				return GetTranslation(text, LanguageCodeTo, dict);
			}
			StringBuilder stringBuilder = new StringBuilder();
			string text2 = null;
			bool forceTag = flag;
			for (ePluralType ePluralType2 = ePluralType.Plural; ePluralType2 >= ePluralType.Zero; ePluralType2--)
			{
				string text3 = ePluralType2.ToString();
				if (!GoogleLanguages.LanguageHasPluralType(LanguageCodeTo, text3))
				{
					continue;
				}
				string text4 = GetPluralText(text, text3);
				int pluralTestNumber = GoogleLanguages.GetPluralTestNumber(LanguageCodeTo, ePluralType2);
				string pluralParameter = GetPluralParameter(text4, forceTag);
				if (!string.IsNullOrEmpty(pluralParameter))
				{
					text4 = text4.Replace(pluralParameter, pluralTestNumber.ToString());
				}
				string text5 = GetTranslation(text4, LanguageCodeTo, dict);
				if (!string.IsNullOrEmpty(pluralParameter))
				{
					text5 = text5.Replace(pluralTestNumber.ToString(), pluralParameter);
				}
				if (ePluralType2 == ePluralType.Plural)
				{
					text2 = text5;
				}
				else
				{
					if (text5 == text2)
					{
						continue;
					}
					stringBuilder.AppendFormat("[i2p_{0}]", text3);
				}
				stringBuilder.Append(text5);
			}
			return stringBuilder.ToString();
		}

		public static string UppercaseFirst(string s)
		{
			if (string.IsNullOrEmpty(s))
			{
				return string.Empty;
			}
			char[] array = s.ToLower().ToCharArray();
			array[0] = char.ToUpper(array[0]);
			return new string(array);
		}

		public static string TitleCase(string s)
		{
			if (string.IsNullOrEmpty(s))
			{
				return string.Empty;
			}
			return CultureInfo.CurrentCulture.TextInfo.ToTitleCase(s);
		}
	}
	public struct TranslationQuery
	{
		public string OrigText;

		public string Text;

		public string LanguageCode;

		public string[] TargetLanguagesCode;

		public string[] Results;

		public string[] Tags;
	}
	public class TranslationJob : IDisposable
	{
		public enum eJobState
		{
			Running,
			Succeeded,
			Failed
		}

		public eJobState mJobState;

		public virtual eJobState GetState()
		{
			return mJobState;
		}

		public virtual void Dispose()
		{
		}
	}
	public class TranslationJob_WWW : TranslationJob
	{
		public UnityWebRequest www;

		public override void Dispose()
		{
			if (www != null)
			{
				www.Dispose();
			}
			www = null;
		}
	}
	public class TranslationJob_GET : TranslationJob_WWW
	{
		private Dictionary<string, TranslationQuery> _requests;

		private GoogleTranslation.fnOnTranslationReady _OnTranslationReady;

		private List<string> mQueries;

		public string mErrorMessage;

		public TranslationJob_GET(Dictionary<string, TranslationQuery> requests, GoogleTranslation.fnOnTranslationReady OnTranslationReady)
		{
			_requests = requests;
			_OnTranslationReady = OnTranslationReady;
			mQueries = GoogleTranslation.ConvertTranslationRequest(requests, encodeGET: true);
			GetState();
		}

		private void ExecuteNextQuery()
		{
			if (mQueries.Count == 0)
			{
				mJobState = eJobState.Succeeded;
				return;
			}
			int index = mQueries.Count - 1;
			string arg = mQueries[index];
			mQueries.RemoveAt(index);
			string uri = $"{LocalizationManager.GetWebServiceURL()}?action=Translate&list={arg}";
			www = UnityWebRequest.Get(uri);
			I2Utils.SendWebRequest(www);
		}

		public override eJobState GetState()
		{
			if (www != null && www.isDone)
			{
				ProcessResult(www.downloadHandler.data, www.error);
				www.Dispose();
				www = null;
			}
			if (www == null)
			{
				ExecuteNextQuery();
			}
			return mJobState;
		}

		public void ProcessResult(byte[] bytes, string errorMsg)
		{
			if (string.IsNullOrEmpty(errorMsg))
			{
				errorMsg = GoogleTranslation.ParseTranslationResult(Encoding.UTF8.GetString(bytes, 0, bytes.Length), _requests);
				if (string.IsNullOrEmpty(errorMsg))
				{
					if (_OnTranslationReady != null)
					{
						_OnTranslationReady(_requests, null);
					}
					return;
				}
			}
			mJobState = eJobState.Failed;
			mErrorMessage = errorMsg;
		}
	}
	public class TranslationJob_Main : TranslationJob
	{
		private TranslationJob_WEB mWeb;

		private TranslationJob_POST mPost;

		private TranslationJob_GET mGet;

		private Dictionary<string, TranslationQuery> _requests;

		private GoogleTranslation.fnOnTranslationReady _OnTranslationReady;

		public string mErrorMessage;

		public TranslationJob_Main(Dictionary<string, TranslationQuery> requests, GoogleTranslation.fnOnTranslationReady OnTranslationReady)
		{
			_requests = requests;
			_OnTranslationReady = OnTranslationReady;
			mPost = new TranslationJob_POST(requests, OnTranslationReady);
		}

		public override eJobState GetState()
		{
			if (mWeb != null)
			{
				switch (mWeb.GetState())
				{
				case eJobState.Running:
					return eJobState.Running;
				case eJobState.Succeeded:
					mJobState = eJobState.Succeeded;
					break;
				case eJobState.Failed:
					mWeb.Dispose();
					mWeb = null;
					mPost = new TranslationJob_POST(_requests, _OnTranslationReady);
					break;
				}
			}
			if (mPost != null)
			{
				switch (mPost.GetState())
				{
				case eJobState.Running:
					return eJobState.Running;
				case eJobState.Succeeded:
					mJobState = eJobState.Succeeded;
					break;
				case eJobState.Failed:
					mPost.Dispose();
					mPost = null;
					mGet = new TranslationJob_GET(_requests, _OnTranslationReady);
					break;
				}
			}
			if (mGet != null)
			{
				switch (mGet.GetState())
				{
				case eJobState.Running:
					return eJobState.Running;
				case eJobState.Succeeded:
					mJobState = eJobState.Succeeded;
					break;
				case eJobState.Failed:
					mErrorMessage = mGet.mErrorMessage;
					if (_OnTranslationReady != null)
					{
						_OnTranslationReady(_requests, mErrorMessage);
					}
					mGet.Dispose();
					mGet = null;
					break;
				}
			}
			return mJobState;
		}

		public override void Dispose()
		{
			if (mPost != null)
			{
				mPost.Dispose();
			}
			if (mGet != null)
			{
				mGet.Dispose();
			}
			mPost = null;
			mGet = null;
		}
	}
	public class TranslationJob_POST : TranslationJob_WWW
	{
		private Dictionary<string, TranslationQuery> _requests;

		private GoogleTranslation.fnOnTranslationReady _OnTranslationReady;

		public TranslationJob_POST(Dictionary<string, TranslationQuery> requests, GoogleTranslation.fnOnTranslationReady OnTranslationReady)
		{
			_requests = requests;
			_OnTranslationReady = OnTranslationReady;
			List<string> list = GoogleTranslation.ConvertTranslationRequest(requests, encodeGET: false);
			WWWForm wWWForm = new WWWForm();
			wWWForm.AddField("action", "Translate");
			wWWForm.AddField("list", list[0]);
			www = UnityWebRequest.Post(LocalizationManager.GetWebServiceURL(), wWWForm);
			I2Utils.SendWebRequest(www);
		}

		public override eJobState GetState()
		{
			if (www != null && www.isDone)
			{
				ProcessResult(www.downloadHandler.data, www.error);
				www.Dispose();
				www = null;
			}
			return mJobState;
		}

		public void ProcessResult(byte[] bytes, string errorMsg)
		{
			if (!string.IsNullOrEmpty(errorMsg))
			{
				mJobState = eJobState.Failed;
				return;
			}
			errorMsg = GoogleTranslation.ParseTranslationResult(Encoding.UTF8.GetString(bytes, 0, bytes.Length), _requests);
			if (_OnTranslationReady != null)
			{
				_OnTranslationReady(_requests, errorMsg);
			}
			mJobState = eJobState.Succeeded;
		}
	}
	public class TranslationJob_WEB : TranslationJob_WWW
	{
		private Dictionary<string, TranslationQuery> _requests;

		private GoogleTranslation.fnOnTranslationReady _OnTranslationReady;

		public string mErrorMessage;

		private string mCurrentBatch_ToLanguageCode;

		private string mCurrentBatch_FromLanguageCode;

		private List<string> mCurrentBatch_Text;

		private List<KeyValuePair<string, string>> mQueries;

		public TranslationJob_WEB(Dictionary<string, TranslationQuery> requests, GoogleTranslation.fnOnTranslationReady OnTranslationReady)
		{
			_requests = requests;
			_OnTranslationReady = OnTranslationReady;
			FindAllQueries();
			ExecuteNextBatch();
		}

		private void FindAllQueries()
		{
			mQueries = new List<KeyValuePair<string, string>>();
			foreach (KeyValuePair<string, TranslationQuery> request in _requests)
			{
				string[] targetLanguagesCode = request.Value.TargetLanguagesCode;
				foreach (string text in targetLanguagesCode)
				{
					mQueries.Add(new KeyValuePair<string, string>(request.Value.OrigText, request.Value.LanguageCode + ":" + text));
				}
			}
			mQueries.Sort((KeyValuePair<string, string> a, KeyValuePair<string, string> b) => a.Value.CompareTo(b.Value));
		}

		private void ExecuteNextBatch()
		{
			if (mQueries.Count == 0)
			{
				mJobState = eJobState.Succeeded;
				return;
			}
			mCurrentBatch_Text = new List<string>();
			string text = null;
			int num = 200;
			StringBuilder stringBuilder = new StringBuilder();
			int i;
			for (i = 0; i < mQueries.Count; i++)
			{
				string key = mQueries[i].Key;
				string value = mQueries[i].Value;
				if (text == null || value == text)
				{
					if (i != 0)
					{
						stringBuilder.Append("|||");
					}
					stringBuilder.Append(key);
					mCurrentBatch_Text.Add(key);
					text = value;
				}
				if (stringBuilder.Length > num)
				{
					break;
				}
			}
			mQueries.RemoveRange(0, i);
			string[] array = text.Split(':');
			mCurrentBatch_FromLanguageCode = array[0];
			mCurrentBatch_ToLanguageCode = array[1];
			string text2 = $"http://www.google.com/translate_t?hl=en&vi=c&ie=UTF8&oe=UTF8&submit=Translate&langpair={mCurrentBatch_FromLanguageCode}|{mCurrentBatch_ToLanguageCode}&text={Uri.EscapeUriString(stringBuilder.ToString())}";
			UnityEngine.Debug.Log(text2);
			www = UnityWebRequest.Get(text2);
			I2Utils.SendWebRequest(www);
		}

		public override eJobState GetState()
		{
			if (www != null && www.isDone)
			{
				ProcessResult(www.downloadHandler.data, www.error);
				www.Dispose();
				www = null;
			}
			if (www == null)
			{
				ExecuteNextBatch();
			}
			return mJobState;
		}

		public void ProcessResult(byte[] bytes, string errorMsg)
		{
			if (string.IsNullOrEmpty(errorMsg))
			{
				string @string = Encoding.UTF8.GetString(bytes, 0, bytes.Length);
				UnityEngine.Debug.Log(ParseTranslationResult(@string, "aab"));
				if (string.IsNullOrEmpty(errorMsg))
				{
					if (_OnTranslationReady != null)
					{
						_OnTranslationReady(_requests, null);
					}
					return;
				}
			}
			mJobState = eJobState.Failed;
			mErrorMessage = errorMsg;
		}

		private string ParseTranslationResult(string html, string OriginalText)
		{
			try
			{
				int num = html.IndexOf("TRANSLATED_TEXT='") + "TRANSLATED_TEXT='".Length;
				int num2 = html.IndexOf("';var", num);
				string input = html.Substring(num, num2 - num);
				input = Regex.Replace(input, "\\\\x([a-fA-F0-9]{2})", (Match match) => char.ConvertFromUtf32(int.Parse(match.Groups[1].Value, NumberStyles.HexNumber)));
				input = Regex.Replace(input, "&#(\\d+);", (Match match) => char.ConvertFromUtf32(int.Parse(match.Groups[1].Value)));
				input = input.Replace("<br>", "\n");
				if (OriginalText.ToUpper() == OriginalText)
				{
					input = input.ToUpper();
				}
				else if (GoogleTranslation.UppercaseFirst(OriginalText) == OriginalText)
				{
					input = GoogleTranslation.UppercaseFirst(input);
				}
				else if (GoogleTranslation.TitleCase(OriginalText) == OriginalText)
				{
					input = GoogleTranslation.TitleCase(input);
				}
				return input;
			}
			catch (Exception ex)
			{
				UnityEngine.Debug.LogError(ex.Message);
				return string.Empty;
			}
		}
	}
	public enum eLanguageDataFlags
	{
		DISABLED = 1,
		KEEP_LOADED = 2,
		NOT_LOADED = 4
	}
	[Serializable]
	public class LanguageData
	{
		public string Name;

		public string Code;

		public byte Flags;

		[NonSerialized]
		public bool Compressed;

		public bool IsEnabled()
		{
			return (Flags & 1) == 0;
		}

		public void SetEnabled(bool bEnabled)
		{
			if (bEnabled)
			{
				Flags = (byte)(Flags & 0xFFFFFFFEu);
			}
			else
			{
				Flags |= 1;
			}
		}

		public bool IsLoaded()
		{
			return (Flags & 4) == 0;
		}

		public bool CanBeUnloaded()
		{
			return (Flags & 2) == 0;
		}

		public void SetLoaded(bool loaded)
		{
			if (loaded)
			{
				Flags = (byte)(Flags & 0xFFFFFFFBu);
			}
			else
			{
				Flags |= 4;
			}
		}

		public void SetCanBeUnLoaded(bool allowUnloading)
		{
			if (allowUnloading)
			{
				Flags = (byte)(Flags & 0xFFFFFFFDu);
			}
			else
			{
				Flags |= 2;
			}
		}
	}
	[AddComponentMenu("I2/Localization/Source")]
	[ExecuteInEditMode]
	public class LanguageSource : MonoBehaviour, ISerializationCallbackReceiver, ILanguageSource
	{
		public delegate void fnOnSourceUpdated(LanguageSourceData source, bool ReceivedNewData, string errorMsg);

		public LanguageSourceData mSource = new LanguageSourceData();

		public int version;

		public bool NeverDestroy;

		public bool UserAgreesToHaveItOnTheScene;

		public bool UserAgreesToHaveItInsideThePluginsFolder;

		public bool GoogleLiveSyncIsUptoDate = true;

		public List<UnityEngine.Object> Assets = new List<UnityEngine.Object>();

		public string Google_WebServiceURL;

		public string Google_SpreadsheetKey;

		public string Google_SpreadsheetName;

		public string Google_LastUpdatedVersion;

		public LanguageSourceData.eGoogleUpdateFrequency GoogleUpdateFrequency = LanguageSourceData.eGoogleUpdateFrequency.Weekly;

		public float GoogleUpdateDelay = 5f;

		public List<LanguageData> mLanguages = new List<LanguageData>();

		public bool IgnoreDeviceLanguage;

		public LanguageSourceData.eAllowUnloadLanguages _AllowUnloadingLanguages;

		public List<TermData> mTerms = new List<TermData>();

		public bool CaseInsensitiveTerms;

		public LanguageSourceData.MissingTranslationAction OnMissingTranslation = LanguageSourceData.MissingTranslationAction.Fallback;

		public string mTerm_AppName;

		public LanguageSourceData SourceData
		{
			get
			{
				return mSource;
			}
			set
			{
				mSource = value;
			}
		}

		public event fnOnSourceUpdated Event_OnSourceUpdateFromGoogle;

		private void Awake()
		{
			mSource.owner = this;
			mSource.Awake();
		}

		private void OnDestroy()
		{
			NeverDestroy = false;
			if (!NeverDestroy)
			{
				mSource.OnDestroy();
			}
		}

		public string GetSourceName()
		{
			string text = base.gameObject.name;
			Transform parent = base.transform.parent;
			while ((bool)parent)
			{
				text = parent.name + "_" + text;
				parent = parent.parent;
			}
			return text;
		}

		public void OnBeforeSerialize()
		{
			version = 1;
		}

		public void OnAfterDeserialize()
		{
			if (version != 0 && mSource != null)
			{
				return;
			}
			mSource = new LanguageSourceData();
			mSource.owner = this;
			mSource.UserAgreesToHaveItOnTheScene = UserAgreesToHaveItOnTheScene;
			mSource.UserAgreesToHaveItInsideThePluginsFolder = UserAgreesToHaveItInsideThePluginsFolder;
			mSource.IgnoreDeviceLanguage = IgnoreDeviceLanguage;
			mSource._AllowUnloadingLanguages = _AllowUnloadingLanguages;
			mSource.CaseInsensitiveTerms = CaseInsensitiveTerms;
			mSource.OnMissingTranslation = OnMissingTranslation;
			mSource.mTerm_AppName = mTerm_AppName;
			mSource.GoogleLiveSyncIsUptoDate = GoogleLiveSyncIsUptoDate;
			mSource.Google_WebServiceURL = Google_WebServiceURL;
			mSource.Google_SpreadsheetKey = Google_SpreadsheetKey;
			mSource.Google_SpreadsheetName = Google_SpreadsheetName;
			mSource.Google_LastUpdatedVersion = Google_LastUpdatedVersion;
			mSource.GoogleUpdateFrequency = GoogleUpdateFrequency;
			mSource.GoogleUpdateDelay = GoogleUpdateDelay;
			mSource.Event_OnSourceUpdateFromGoogle += this.Event_OnSourceUpdateFromGoogle;
			if (mLanguages != null && mLanguages.Count > 0)
			{
				mSource.mLanguages.Clear();
				mSource.mLanguages.AddRange(mLanguages);
				mLanguages.Clear();
			}
			if (Assets != null && Assets.Count > 0)
			{
				mSource.Assets.Clear();
				mSource.Assets.AddRange(Assets);
				Assets.Clear();
			}
			if (mTerms != null && mTerms.Count > 0)
			{
				mSource.mTerms.Clear();
				for (int i = 0; i < mTerms.Count; i++)
				{
					mSource.mTerms.Add(mTerms[i]);
				}
				mTerms.Clear();
			}
			version = 1;
			this.Event_OnSourceUpdateFromGoogle = null;
		}
	}
	[CreateAssetMenu(fileName = "I2Languages", menuName = "I2 Localization/LanguageSource", order = 1)]
	public class LanguageSourceAsset : ScriptableObject, ILanguageSource
	{
		public LanguageSourceData mSource = new LanguageSourceData();

		public LanguageSourceData SourceData
		{
			get
			{
				return mSource;
			}
			set
			{
				mSource = value;
			}
		}
	}
	public interface ILanguageSource
	{
		LanguageSourceData SourceData { get; set; }
	}
	[Serializable]
	[ExecuteInEditMode]
	public class LanguageSourceData
	{
		public enum MissingTranslationAction
		{
			Empty,
			Fallback,
			ShowWarning,
			ShowTerm
		}

		public enum eAllowUnloadLanguages
		{
			Never,
			OnlyInDevice,
			EditorAndDevice
		}

		public enum eGoogleUpdateFrequency
		{
			Always,
			Never,
			Daily,
			Weekly,
			Monthly,
			OnlyOnce,
			EveryOtherDay
		}

		public enum eGoogleUpdateSynchronization
		{
			Manual,
			OnSceneLoaded,
			AsSoonAsDownloaded
		}

		[NonSerialized]
		public ILanguageSource owner;

		public bool UserAgreesToHaveItOnTheScene;

		public bool UserAgreesToHaveItInsideThePluginsFolder;

		public bool GoogleLiveSyncIsUptoDate = true;

		[NonSerialized]
		public bool mIsGlobalSource;

		public List<TermData> mTerms = new List<TermData>();

		public bool CaseInsensitiveTerms;

		[NonSerialized]
		public Dictionary<string, TermData> mDictionary = new Dictionary<string, TermData>(StringComparer.Ordinal);

		public MissingTranslationAction OnMissingTranslation = MissingTranslationAction.Fallback;

		public string mTerm_AppName;

		public List<LanguageData> mLanguages = new List<LanguageData>();

		public bool IgnoreDeviceLanguage;

		public eAllowUnloadLanguages _AllowUnloadingLanguages;

		public string Google_WebServiceURL;

		public string Google_SpreadsheetKey;

		public string Google_SpreadsheetName;

		public string Google_LastUpdatedVersion;

		public eGoogleUpdateFrequency GoogleUpdateFrequency = eGoogleUpdateFrequency.Weekly;

		public eGoogleUpdateFrequency GoogleInEditorCheckFrequency = eGoogleUpdateFrequency.Daily;

		public eGoogleUpdateSynchronization GoogleUpdateSynchronization = eGoogleUpdateSynchronization.OnSceneLoaded;

		public float GoogleUpdateDelay;

		public List<UnityEngine.Object> Assets = new List<UnityEngine.Object>();

		[NonSerialized]
		public Dictionary<string, UnityEngine.Object> mAssetDictionary = new Dictionary<string, UnityEngine.Object>(StringComparer.Ordinal);

		private string mDelayedGoogleData;

		public static string EmptyCategory = "Default";

		public static char[] CategorySeparators = "/\\".ToCharArray();

		public UnityEngine.Object ownerObject => owner as UnityEngine.Object;

		public event LanguageSource.fnOnSourceUpdated Event_OnSourceUpdateFromGoogle;

		public void Awake()
		{
			LocalizationManager.AddSource(this);
			UpdateDictionary();
			UpdateAssetDictionary();
			LocalizationManager.LocalizeAll(Force: true);
		}

		public void OnDestroy()
		{
			LocalizationManager.RemoveSource(this);
		}

		public bool IsEqualTo(LanguageSourceData Source)
		{
			if (Source.mLanguages.Count != mLanguages.Count)
			{
				return false;
			}
			int i = 0;
			for (int count = mLanguages.Count; i < count; i++)
			{
				if (Source.GetLanguageIndex(mLanguages[i].Name) < 0)
				{
					return false;
				}
			}
			if (Source.mTerms.Count != mTerms.Count)
			{
				return false;
			}
			for (int j = 0; j < mTerms.Count; j++)
			{
				if (Source.GetTermData(mTerms[j].Term) == null)
				{
					return false;
				}
			}
			return true;
		}

		internal bool ManagerHasASimilarSource()
		{
			int i = 0;
			for (int count = LocalizationManager.Sources.Count; i < count; i++)
			{
				LanguageSourceData languageSourceData = LocalizationManager.Sources[i];
				if (languageSourceData != null && languageSourceData.IsEqualTo(this) && languageSourceData != this)
				{
					return true;
				}
			}
			return false;
		}

		public void ClearAllData()
		{
			mTerms.Clear();
			mLanguages.Clear();
			mDictionary.Clear();
			mAssetDictionary.Clear();
		}

		public bool IsGlobalSource()
		{
			return mIsGlobalSource;
		}

		public void Editor_SetDirty()
		{
		}

		public void UpdateAssetDictionary()
		{
			Assets.RemoveAll((UnityEngine.Object x) => x == null);
			mAssetDictionary = (from o in Assets.Distinct()
				group o by o.name).ToDictionary((IGrouping<string, UnityEngine.Object> g) => g.Key, (IGrouping<string, UnityEngine.Object> g) => g.First());
		}

		public UnityEngine.Object FindAsset(string Name)
		{
			if (Assets != null)
			{
				if (mAssetDictionary == null || mAssetDictionary.Count != Assets.Count)
				{
					UpdateAssetDictionary();
				}
				if (mAssetDictionary.TryGetValue(Name, out var value))
				{
					return value;
				}
			}
			return null;
		}

		public bool HasAsset(UnityEngine.Object Obj)
		{
			return Assets.Contains(Obj);
		}

		public void AddAsset(UnityEngine.Object Obj)
		{
			if (!Assets.Contains(Obj))
			{
				Assets.Add(Obj);
				UpdateAssetDictionary();
			}
		}

		public string Export_I2CSV(string Category, char Separator = ',', bool specializationsAsRows = true)
		{
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.Append("Key[*]Type[*]Desc");
			foreach (LanguageData mLanguage in mLanguages)
			{
				stringBuilder.Append("[*]");
				if (!mLanguage.IsEnabled())
				{
					stringBuilder.Append('$');
				}
				stringBuilder.Append(GoogleLanguages.GetCodedLanguage(mLanguage.Name, mLanguage.Code));
			}
			stringBuilder.Append("[ln]");
			mTerms.Sort((TermData a, TermData b) => string.CompareOrdinal(a.Term, b.Term));
			int count = mLanguages.Count;
			bool flag = true;
			foreach (TermData mTerm in mTerms)
			{
				string term;
				if (string.IsNullOrEmpty(Category) || (Category == EmptyCategory && mTerm.Term.IndexOfAny(CategorySeparators) < 0))
				{
					term = mTerm.Term;
				}
				else
				{
					if (!mTerm.Term.StartsWith(Category + "/") || !(Category != mTerm.Term))
					{
						continue;
					}
					term = mTerm.Term.Substring(Category.Length + 1);
				}
				if (!flag)
				{
					stringBuilder.Append("[ln]");
				}
				flag = false;
				if (!specializationsAsRows)
				{
					AppendI2Term(stringBuilder, count, term, mTerm, Separator, null);
					continue;
				}
				List<string> allSpecializations = mTerm.GetAllSpecializations();
				for (int i = 0; i < allSpecializations.Count; i++)
				{
					if (i != 0)
					{
						stringBuilder.Append("[ln]");
					}
					string forceSpecialization = allSpecializations[i];
					AppendI2Term(stringBuilder, count, term, mTerm, Separator, forceSpecialization);
				}
			}
			return stringBuilder.ToString();
		}

		private static void AppendI2Term(StringBuilder Builder, int nLanguages, string Term, TermData termData, char Separator, string forceSpecialization)
		{
			AppendI2Text(Builder, Term);
			if (!string.IsNullOrEmpty(forceSpecialization) && forceSpecialization != "Any")
			{
				Builder.Append("[");
				Builder.Append(forceSpecialization);
				Builder.Append("]");
			}
			Builder.Append("[*]");
			Builder.Append(termData.TermType.ToString());
			Builder.Append("[*]");
			Builder.Append(termData.Description);
			for (int i = 0; i < Mathf.Min(nLanguages, termData.Languages.Length); i++)
			{
				Builder.Append("[*]");
				string text = termData.Languages[i];
				if (!string.IsNullOrEmpty(forceSpecialization))
				{
					text = termData.GetTranslation(i, forceSpecialization);
				}
				AppendI2Text(Builder, text);
			}
		}

		private static void AppendI2Text(StringBuilder Builder, string text)
		{
			if (!string.IsNullOrEmpty(text))
			{
				if (text.StartsWith("'") || text.StartsWith("="))
				{
					Builder.Append('\'');
				}
				Builder.Append(text);
			}
		}

		private string Export_Language_to_Cache(int langIndex, bool fillTermWithFallback)
		{
			if (!mLanguages[langIndex].IsLoaded())
			{
				return null;
			}
			StringBuilder stringBuilder = new StringBuilder();
			for (int i = 0; i < mTerms.Count; i++)
			{
				if (i > 0)
				{
					stringBuilder.Append("[i2t]");
				}
				TermData termData = mTerms[i];
				stringBuilder.Append(termData.Term);
				stringBuilder.Append("=");
				string Translation = termData.Languages[langIndex];
				if (OnMissingTranslation == MissingTranslationAction.Fallback && string.IsNullOrEmpty(Translation) && TryGetFallbackTranslation(termData, out Translation, langIndex, null, skipDisabled: true))
				{
					stringBuilder.Append("[i2fb]");
					if (fillTermWithFallback)
					{
						termData.Languages[langIndex] = Translation;
					}
				}
				if (!string.IsNullOrEmpty(Translation))
				{
					stringBuilder.Append(Translation);
				}
			}
			return stringBuilder.ToString();
		}

		public string Export_CSV(string Category, char Separator = ',', bool specializationsAsRows = true)
		{
			StringBuilder stringBuilder = new StringBuilder();
			int count = mLanguages.Count;
			stringBuilder.AppendFormat("Key{0}Type{0}Desc", Separator);
			foreach (LanguageData mLanguage in mLanguages)
			{
				stringBuilder.Append(Separator);
				if (!mLanguage.IsEnabled())
				{
					stringBuilder.Append('$');
				}
				AppendString(stringBuilder, GoogleLanguages.GetCodedLanguage(mLanguage.Name, mLanguage.Code), Separator);
			}
			stringBuilder.Append("\n");
			mTerms.Sort((TermData a, TermData b) => string.CompareOrdinal(a.Term, b.Term));
			foreach (TermData mTerm in mTerms)
			{
				string term;
				if (string.IsNullOrEmpty(Category) || (Category == EmptyCategory && mTerm.Term.IndexOfAny(CategorySeparators) < 0))
				{
					term = mTerm.Term;
				}
				else
				{
					if (!mTerm.Term.StartsWith(Category + "/") || !(Category != mTerm.Term))
					{
						continue;
					}
					term = mTerm.Term.Substring(Category.Length + 1);
				}
				if (specializationsAsRows)
				{
					foreach (string allSpecialization in mTerm.GetAllSpecializations())
					{
						AppendTerm(stringBuilder, count, term, mTerm, allSpecialization, Separator);
					}
				}
				else
				{
					AppendTerm(stringBuilder, count, term, mTerm, null, Separator);
				}
			}
			return stringBuilder.ToString();
		}

		private static void AppendTerm(StringBuilder Builder, int nLanguages, string Term, TermData termData, string specialization, char Separator)
		{
			AppendString(Builder, Term, Separator);
			if (!string.IsNullOrEmpty(specialization) && specialization != "Any")
			{
				Builder.AppendFormat("[{0}]", specialization);
			}
			Builder.Append(Separator);
			Builder.Append(termData.TermType.ToString());
			Builder.Append(Separator);
			AppendString(Builder, termData.Description, Separator);
			for (int i = 0; i < Mathf.Min(nLanguages, termData.Languages.Length); i++)
			{
				Builder.Append(Separator);
				string text = termData.Languages[i];
				if (!string.IsNullOrEmpty(specialization))
				{
					text = termData.GetTranslation(i, specialization);
				}
				AppendTranslation(Builder, text, Separator, null);
			}
			Builder.Append("\n");
		}

		private static void AppendString(StringBuilder Builder, string Text, char Separator)
		{
			if (!string.IsNullOrEmpty(Text))
			{
				Text = Text.Replace("\\n", "\n");
				if (Text.IndexOfAny((Separator + "\n\"").ToCharArray()) >= 0)
				{
					Text = Text.Replace("\"", "\"\"");
					Builder.AppendFormat("\"{0}\"", Text);
				}
				else
				{
					Builder.Append(Text);
				}
			}
		}

		private static void AppendTranslation(StringBuilder Builder, string Text, char Separator, string tags)
		{
			if (!string.IsNullOrEmpty(Text))
			{
				Text = Text.Replace("\\n", "\n");
				if (Text.IndexOfAny((Separator + "\n\"").ToCharArray()) >= 0)
				{
					Text = Text.Replace("\"", "\"\"");
					Builder.AppendFormat("\"{0}{1}\"", tags, Text);
				}
				else
				{
					Builder.Append(tags);
					Builder.Append(Text);
				}
			}
		}

		public UnityWebRequest Export_Google_CreateWWWcall(eSpreadsheetUpdateMode UpdateMode = eSpreadsheetUpdateMode.Replace)
		{
			string value = Export_Google_CreateData();
			WWWForm wWWForm = new WWWForm();
			wWWForm.AddField("key", Google_SpreadsheetKey);
			wWWForm.AddField("action", "SetLanguageSource");
			wWWForm.AddField("data", value);
			wWWForm.AddField("updateMode", UpdateMode.ToString());
			UnityWebRequest unityWebRequest = UnityWebRequest.Post(LocalizationManager.GetWebServiceURL(this), wWWForm);
			I2Utils.SendWebRequest(unityWebRequest);
			return unityWebRequest;
		}

		private string Export_Google_CreateData()
		{
			List<string> categories = GetCategories(OnlyMainCategory: true);
			StringBuilder stringBuilder = new StringBuilder();
			bool flag = true;
			foreach (string item in categories)
			{
				if (flag)
				{
					flag = false;
				}
				else
				{
					stringBuilder.Append("<I2Loc>");
				}
				bool specializationsAsRows = true;
				string value = Export_I2CSV(item, ',', specializationsAsRows);
				stringBuilder.Append(item);
				stringBuilder.Append("<I2Loc>");
				stringBuilder.Append(value);
			}
			return stringBuilder.ToString();
		}

		public string Import_CSV(string Category, string CSVstring, eSpreadsheetUpdateMode UpdateMode = eSpreadsheetUpdateMode.Replace, char Separator = ',')
		{
			List<string[]> cSV = LocalizationReader.ReadCSV(CSVstring, Separator);
			return Import_CSV(Category, cSV, UpdateMode);
		}

		public string Import_I2CSV(string Category, string I2CSVstring, eSpreadsheetUpdateMode UpdateMode = eSpreadsheetUpdateMode.Replace)
		{
			List<string[]> cSV = LocalizationReader.ReadI2CSV(I2CSVstring);
			return Import_CSV(Category, cSV, UpdateMode);
		}

		public string Import_CSV(string Category, List<string[]> CSV, eSpreadsheetUpdateMode UpdateMode = eSpreadsheetUpdateMode.Replace)
		{
			string[] array = CSV[0];
			int num = 1;
			int num2 = -1;
			int num3 = -1;
			string[] texts = new string[1] { "Key" };
			string[] texts2 = new string[1] { "Type" };
			string[] texts3 = new string[2] { "Desc", "Description" };
			if (array.Length > 1 && ArrayContains(array[0], texts))
			{
				if (UpdateMode == eSpreadsheetUpdateMode.Replace)
				{
					ClearAllData();
				}
				if (array.Length > 2)
				{
					if (ArrayContains(array[1], texts2))
					{
						num2 = 1;
						num = 2;
					}
					if (ArrayContains(array[1], texts3))
					{
						num3 = 1;
						num = 2;
					}
				}
				if (array.Length > 3)
				{
					if (ArrayContains(array[2], texts2))
					{
						num2 = 2;
						num = 3;
					}
					if (ArrayContains(array[2], texts3))
					{
						num3 = 2;
						num = 3;
					}
				}
				int num4 = Mathf.Max(array.Length - num, 0);
				int[] array2 = new int[num4];
				for (int i = 0; i < num4; i++)
				{
					if (string.IsNullOrEmpty(array[i + num]))
					{
						array2[i] = -1;
						continue;
					}
					string text = array[i + num];
					bool flag = true;
					if (text.StartsWith("$"))
					{
						flag = false;
						text = text.Substring(1);
					}
					GoogleLanguages.UnPackCodeFromLanguageName(text, out var Language, out var code);
					int num5 = -1;
					num5 = (string.IsNullOrEmpty(code) ? GetLanguageIndex(Language, AllowDiscartingRegion: true, SkipDisabled: false) : GetLanguageIndexFromCode(code));
					if (num5 < 0)
					{
						LanguageData languageData = new LanguageData();
						languageData.Name = Language;
						languageData.Code = code;
						languageData.Flags = (byte)(0u | ((!flag) ? 1u : 0u));
						mLanguages.Add(languageData);
						num5 = mLanguages.Count - 1;
					}
					array2[i] = num5;
				}
				num4 = mLanguages.Count;
				int j = 0;
				for (int count = mTerms.Count; j < count; j++)
				{
					TermData termData = mTerms[j];
					if (termData.Languages.Length < num4)
					{
						Array.Resize(ref termData.Languages, num4);
						Array.Resize(ref termData.Flags, num4);
					}
				}
				int k = 1;
				for (int count2 = CSV.Count; k < count2; k++)
				{
					array = CSV[k];
					string Term = (string.IsNullOrEmpty(Category) ? array[0] : (Category + "/" + array[0]));
					string text2 = null;
					if (Term.EndsWith("]"))
					{
						int num6 = Term.LastIndexOf('[');
						if (num6 > 0)
						{
							text2 = Term.Substring(num6 + 1, Term.Length - num6 - 2);
							if (text2 == "touch")
							{
								text2 = "Touch";
							}
							Term = Term.Remove(num6);
						}
					}
					ValidateFullTerm(ref Term);
					if (string.IsNullOrEmpty(Term))
					{
						continue;
					}
					TermData termData2 = GetTermData(Term);
					if (termData2 == null)
					{
						termData2 = new TermData();
						termData2.Term = Term;
						termData2.Languages = new string[mLanguages.Count];
						termData2.Flags = new byte[mLanguages.Count];
						for (int l = 0; l < mLanguages.Count; l++)
						{
							termData2.Languages[l] = string.Empty;
						}
						mTerms.Add(termData2);
						mDictionary.Add(Term, termData2);
					}
					else if (UpdateMode == eSpreadsheetUpdateMode.AddNewTerms)
					{
						continue;
					}
					if (num2 > 0)
					{
						termData2.TermType = GetTermType(array[num2]);
					}
					if (num3 > 0)
					{
						termData2.Description = array[num3];
					}
					for (int m = 0; m < array2.Length && m < array.Length - num; m++)
					{
						if (string.IsNullOrEmpty(array[m + num]))
						{
							continue;
						}
						int num7 = array2[m];
						if (num7 >= 0)
						{
							string text3 = array[m + num];
							if (text3 == "-")
							{
								text3 = string.Empty;
							}
							else if (text3 == "")
							{
								text3 = null;
							}
							termData2.SetTranslation(num7, text3, text2);
						}
					}
				}
				if (UnityEngine.Application.isPlaying)
				{
					SaveLanguages(HasUnloadedLanguages());
				}
				return string.Empty;
			}
			return "Bad Spreadsheet Format.\nFirst columns should be 'Key', 'Type' and 'Desc'";
		}

		private bool ArrayContains(string MainText, params string[] texts)
		{
			int i = 0;
			for (int num = texts.Length; i < num; i++)
			{
				if (MainText.IndexOf(texts[i], StringComparison.OrdinalIgnoreCase) >= 0)
				{
					return true;
				}
			}
			return false;
		}

		public static eTermType GetTermType(string type)
		{
			int i = 0;
			for (int num = 10; i <= num; i++)
			{
				eTermType eTermType2 = (eTermType)i;
				if (string.Equals(eTermType2.ToString(), type, StringComparison.OrdinalIgnoreCase))
				{
					return (eTermType)i;
				}
			}
			return eTermType.Text;
		}

		private void Import_Language_from_Cache(int langIndex, string langData, bool useFallback, bool onlyCurrentSpecialization)
		{
			int num = 0;
			while (num < langData.Length)
			{
				int num2 = langData.IndexOf("[i2t]", num);
				if (num2 < 0)
				{
					num2 = langData.Length;
				}
				int num3 = langData.IndexOf("=", num);
				if (num3 >= num2)
				{
					break;
				}
				string term = langData.Substring(num, num3 - num);
				num = num3 + 1;
				TermData termData = GetTermData(term);
				if (termData != null)
				{
					string text = null;
					if (num != num2)
					{
						text = langData.Substring(num, num2 - num);
						if (text.StartsWith("[i2fb]"))
						{
							text = (useFallback ? text.Substring(6) : null);
						}
						if (onlyCurrentSpecialization && text != null)
						{
							text = SpecializationManager.GetSpecializedText(text);
						}
					}
					termData.Languages[langIndex] = text;
				}
				num = num2 + 5;
			}
		}

		public static void FreeUnusedLanguages()
		{
			LanguageSourceData languageSourceData = LocalizationManager.Sources[0];
			int languageIndex = languageSourceData.GetLanguageIndex(LocalizationManager.CurrentLanguage);
			for (int i = 0; i < languageSourceData.mTerms.Count; i++)
			{
				TermData termData = languageSourceData.mTerms[i];
				for (int j = 0; j < termData.Languages.Length; j++)
				{
					if (j != languageIndex)
					{
						termData.Languages[j] = null;
					}
				}
			}
		}

		public void Import_Google_FromCache()
		{
			if (GoogleUpdateFrequency == eGoogleUpdateFrequency.Never || !I2Utils.IsPlaying())
			{
				return;
			}
			string sourcePlayerPrefName = GetSourcePlayerPrefName();
			string text = PersistentStorage.LoadFile(PersistentStorage.eFileType.Persistent, "I2Source_" + sourcePlayerPrefName + ".loc", logExceptions: false);
			if (string.IsNullOrEmpty(text))
			{
				return;
			}
			if (text.StartsWith("[i2e]", StringComparison.Ordinal))
			{
				text = StringObfucator.Decode(text.Substring(5, text.Length - 5));
			}
			bool flag = false;
			string text2 = Google_LastUpdatedVersion;
			if (PersistentStorage.HasSetting("I2SourceVersion_" + sourcePlayerPrefName))
			{
				text2 = PersistentStorage.GetSetting_String("I2SourceVersion_" + sourcePlayerPrefName, Google_LastUpdatedVersion);
				flag = IsNewerVersion(Google_LastUpdatedVersion, text2);
			}
			if (!flag)
			{
				PersistentStorage.DeleteFile(PersistentStorage.eFileType.Persistent, "I2Source_" + sourcePlayerPrefName + ".loc", logExceptions: false);
				PersistentStorage.DeleteSetting("I2SourceVersion_" + sourcePlayerPrefName);
				return;
			}
			if (text2.Length > 19)
			{
				text2 = string.Empty;
			}
			Google_LastUpdatedVersion = text2;
			Import_Google_Result(text, eSpreadsheetUpdateMode.Replace);
		}

		private bool IsNewerVersion(string currentVersion, string newVersion)
		{
			if (string.IsNullOrEmpty(newVersion))
			{
				return false;
			}
			if (string.IsNullOrEmpty(currentVersion))
			{
				return true;
			}
			if (!long.TryParse(newVersion, out var result) || !long.TryParse(currentVersion, out var result2))
			{
				return true;
			}
			return result > result2;
		}

		public void Import_Google(bool ForceUpdate, bool justCheck)
		{
			if ((!ForceUpdate && GoogleUpdateFrequency == eGoogleUpdateFrequency.Never) || !I2Utils.IsPlaying())
			{
				return;
			}
			eGoogleUpdateFrequency googleUpdateFrequency = GoogleUpdateFrequency;
			string sourcePlayerPrefName = GetSourcePlayerPrefName();
			if (!ForceUpdate && googleUpdateFrequency != 0)
			{
				string setting_String = PersistentStorage.GetSetting_String("LastGoogleUpdate_" + sourcePlayerPrefName, "");
				try
				{
					if (DateTime.TryParse(setting_String, out var result))
					{
						double totalDays = (DateTime.Now - result).TotalDays;
						switch (googleUpdateFrequency)
						{
						case eGoogleUpdateFrequency.Daily:
							if (totalDays < 1.0)
							{
								return;
							}
							break;
						case eGoogleUpdateFrequency.Weekly:
							if (totalDays < 8.0)
							{
								return;
							}
							break;
						case eGoogleUpdateFrequency.Monthly:
							if (totalDays < 31.0)
							{
								return;
							}
							break;
						case eGoogleUpdateFrequency.OnlyOnce:
							return;
						case eGoogleUpdateFrequency.EveryOtherDay:
							if (totalDays < 2.0)
							{
								return;
							}
							break;
						}
					}
				}
				catch (Exception)
				{
				}
			}
			PersistentStorage.SetSetting_String("LastGoogleUpdate_" + sourcePlayerPrefName, DateTime.Now.ToString());
			CoroutineManager.Start(Import_Google_Coroutine(justCheck));
		}

		private string GetSourcePlayerPrefName()
		{
			if (owner == null)
			{
				return null;
			}
			string text = (owner as UnityEngine.Object).name;
			if (!string.IsNullOrEmpty(Google_SpreadsheetKey))
			{
				text += Google_SpreadsheetKey;
			}
			if (Array.IndexOf(LocalizationManager.GlobalSources, (owner as UnityEngine.Object).name) >= 0)
			{
				return text;
			}
			return SceneManager.GetActiveScene().name + "_" + text;
		}

		private IEnumerator Import_Google_Coroutine(bool JustCheck)
		{
			UnityWebRequest www = Import_Google_CreateWWWcall(ForceUpdate: false, JustCheck);
			if (www == null)
			{
				yield break;
			}
			while (!www.isDone)
			{
				yield return null;
			}
			if (string.IsNullOrEmpty(www.error))
			{
				byte[] data = www.downloadHandler.data;
				string @string = Encoding.UTF8.GetString(data, 0, data.Length);
				bool flag = string.IsNullOrEmpty(@string) || @string == "\"\"";
				if (JustCheck)
				{
					if (!flag)
					{
						UnityEngine.Debug.LogWarning("Spreadsheet is not up-to-date and Google Live Synchronization is enabled\nWhen playing in the device the Spreadsheet will be downloaded and translations may not behave as what you see in the editor.\nTo fix this, Import or Export replace to Google");
						GoogleLiveSyncIsUptoDate = false;
					}
					yield break;
				}
				if (!flag)
				{
					mDelayedGoogleData = @string;
					switch (GoogleUpdateSynchronization)
					{
					case eGoogleUpdateSynchronization.AsSoonAsDownloaded:
						ApplyDownloadedDataFromGoogle();
						break;
					case eGoogleUpdateSynchronization.OnSceneLoaded:
						SceneManager.sceneLoaded += ApplyDownloadedDataOnSceneLoaded;
						break;
					}
					yield break;
				}
			}
			if (this.Event_OnSourceUpdateFromGoogle != null)
			{
				this.Event_OnSourceUpdateFromGoogle(this, ReceivedNewData: false, www.error);
			}
			UnityEngine.Debug.Log("Language Source was up-to-date with Google Spreadsheet");
		}

		private void ApplyDownloadedDataOnSceneLoaded(Scene scene, LoadSceneMode mode)
		{
			SceneManager.sceneLoaded -= ApplyDownloadedDataOnSceneLoaded;
			ApplyDownloadedDataFromGoogle();
		}

		public void ApplyDownloadedDataFromGoogle()
		{
			if (string.IsNullOrEmpty(mDelayedGoogleData))
			{
				return;
			}
			if (string.IsNullOrEmpty(Import_Google_Result(mDelayedGoogleData, eSpreadsheetUpdateMode.Replace, saveInPlayerPrefs: true)))
			{
				if (this.Event_OnSourceUpdateFromGoogle != null)
				{
					this.Event_OnSourceUpdateFromGoogle(this, ReceivedNewData: true, "");
				}
				LocalizationManager.LocalizeAll(Force: true);
				UnityEngine.Debug.Log("Done Google Sync");
			}
			else
			{
				if (this.Event_OnSourceUpdateFromGoogle != null)
				{
					this.Event_OnSourceUpdateFromGoogle(this, ReceivedNewData: false, "");
				}
				UnityEngine.Debug.Log("Done Google Sync: source was up-to-date");
			}
		}

		public UnityWebRequest Import_Google_CreateWWWcall(bool ForceUpdate, bool justCheck)
		{
			if (!HasGoogleSpreadsheet())
			{
				return null;
			}
			string text = PersistentStorage.GetSetting_String("I2SourceVersion_" + GetSourcePlayerPrefName(), Google_LastUpdatedVersion);
			if (text.Length > 19)
			{
				text = string.Empty;
			}
			if (IsNewerVersion(text, Google_LastUpdatedVersion))
			{
				Google_LastUpdatedVersion = text;
			}
			UnityWebRequest unityWebRequest = UnityWebRequest.Get(string.Format("{0}?key={1}&action=GetLanguageSource&version={2}", LocalizationManager.GetWebServiceURL(this), Google_SpreadsheetKey, ForceUpdate ? "0" : Google_LastUpdatedVersion));
			I2Utils.SendWebRequest(unityWebRequest);
			return unityWebRequest;
		}

		public bool HasGoogleSpreadsheet()
		{
			if (!string.IsNullOrEmpty(Google_WebServiceURL) && !string.IsNullOrEmpty(Google_SpreadsheetKey))
			{
				return !string.IsNullOrEmpty(LocalizationManager.GetWebServiceURL(this));
			}
			return false;
		}

		public string Import_Google_Result(string JsonString, eSpreadsheetUpdateMode UpdateMode, bool saveInPlayerPrefs = false)
		{
			try
			{
				string empty = string.Empty;
				if (string.IsNullOrEmpty(JsonString) || JsonString == "\"\"")
				{
					return empty;
				}
				int num = JsonString.IndexOf("version=", StringComparison.Ordinal);
				int num2 = JsonString.IndexOf("script_version=", StringComparison.Ordinal);
				if (num < 0 || num2 < 0)
				{
					return "Invalid Response from Google, Most likely the WebService needs to be updated";
				}
				num += "version=".Length;
				num2 += "script_version=".Length;
				string text = JsonString.Substring(num, JsonString.IndexOf(",", num, StringComparison.Ordinal) - num);
				int num3 = int.Parse(JsonString.Substring(num2, JsonString.IndexOf(",", num2, StringComparison.Ordinal) - num2));
				if (text.Length > 19)
				{
					text = string.Empty;
				}
				if (num3 != LocalizationManager.GetRequiredWebServiceVersion())
				{
					return "The current Google WebService is not supported.\nPlease, delete the WebService from the Google Drive and Install the latest version.";
				}
				if (saveInPlayerPrefs && !IsNewerVersion(Google_LastUpdatedVersion, text))
				{
					return "LanguageSource is up-to-date";
				}
				if (saveInPlayerPrefs)
				{
					string sourcePlayerPrefName = GetSourcePlayerPrefName();
					PersistentStorage.SaveFile(PersistentStorage.eFileType.Persistent, "I2Source_" + sourcePlayerPrefName + ".loc", "[i2e]" + StringObfucator.Encode(JsonString));
					PersistentStorage.SetSetting_String("I2SourceVersion_" + sourcePlayerPrefName, text);
					PersistentStorage.ForceSaveSettings();
				}
				Google_LastUpdatedVersion = text;
				if (UpdateMode == eSpreadsheetUpdateMode.Replace)
				{
					ClearAllData();
				}
				int num4 = JsonString.IndexOf("[i2category]", StringComparison.Ordinal);
				while (num4 > 0)
				{
					num4 += "[i2category]".Length;
					int num5 = JsonString.IndexOf("[/i2category]", num4, StringComparison.Ordinal);
					string category = JsonString.Substring(num4, num5 - num4);
					num5 += "[/i2category]".Length;
					int num6 = JsonString.IndexOf("[/i2csv]", num5, StringComparison.Ordinal);
					string i2CSVstring = JsonString.Substring(num5, num6 - num5);
					num4 = JsonString.IndexOf("[i2category]", num6, StringComparison.Ordinal);
					Import_I2CSV(category, i2CSVstring, UpdateMode);
					if (UpdateMode == eSpreadsheetUpdateMode.Replace)
					{
						UpdateMode = eSpreadsheetUpdateMode.Merge;
					}
				}
				GoogleLiveSyncIsUptoDate = true;
				if (I2Utils.IsPlaying())
				{
					SaveLanguages(unloadAll: true);
				}
				if (!string.IsNullOrEmpty(empty))
				{
					Editor_SetDirty();
				}
				return empty;
			}
			catch (Exception ex)
			{
				UnityEngine.Debug.LogWarning(ex);
				return ex.ToString();
			}
		}

		public int GetLanguageIndex(string language, bool AllowDiscartingRegion = true, bool SkipDisabled = true)
		{
			int i = 0;
			for (int count = mLanguages.Count; i < count; i++)
			{
				if ((!SkipDisabled || mLanguages[i].IsEnabled()) && string.Compare(mLanguages[i].Name, language, StringComparison.OrdinalIgnoreCase) == 0)
				{
					return i;
				}
			}
			if (AllowDiscartingRegion)
			{
				int num = -1;
				int num2 = 0;
				int j = 0;
				for (int count2 = mLanguages.Count; j < count2; j++)
				{
					if (!SkipDisabled || mLanguages[j].IsEnabled())
					{
						int commonWordInLanguageNames = GetCommonWordInLanguageNames(mLanguages[j].Name, language);
						if (commonWordInLanguageNames > num2)
						{
							num2 = commonWordInLanguageNames;
							num = j;
						}
					}
				}
				if (num >= 0)
				{
					return num;
				}
			}
			return -1;
		}

		public LanguageData GetLanguageData(string language, bool AllowDiscartingRegion = true)
		{
			int languageIndex = GetLanguageIndex(language, AllowDiscartingRegion, SkipDisabled: false);
			if (languageIndex >= 0)
			{
				return mLanguages[languageIndex];
			}
			return null;
		}

		public bool IsCurrentLanguage(int languageIndex)
		{
			return LocalizationManager.CurrentLanguage == mLanguages[languageIndex].Name;
		}

		public int GetLanguageIndexFromCode(string Code, bool exactMatch = true, bool ignoreDisabled = false)
		{
			int i = 0;
			for (int count = mLanguages.Count; i < count; i++)
			{
				if ((!ignoreDisabled || mLanguages[i].IsEnabled()) && string.Compare(mLanguages[i].Code, Code, StringComparison.OrdinalIgnoreCase) == 0)
				{
					return i;
				}
			}
			if (!exactMatch)
			{
				int j = 0;
				for (int count2 = mLanguages.Count; j < count2; j++)
				{
					if ((!ignoreDisabled || mLanguages[j].IsEnabled()) && string.Compare(mLanguages[j].Code, 0, Code, 0, 2, StringComparison.OrdinalIgnoreCase) == 0)
					{
						return j;
					}
				}
			}
			return -1;
		}

		public static int GetCommonWordInLanguageNames(string Language1, string Language2)
		{
			if (string.IsNullOrEmpty(Language1) || string.IsNullOrEmpty(Language2))
			{
				return 0;
			}
			char[] separator = "( )-/\\".ToCharArray();
			string[] array = Language1.ToLower().Split(separator);
			string[] array2 = Language2.ToLower().Split(separator);
			int num = 0;
			string[] array3 = array;
			foreach (string value in array3)
			{
				if (!string.IsNullOrEmpty(value) && array2.Contains(value))
				{
					num++;
				}
			}
			array3 = array2;
			foreach (string value2 in array3)
			{
				if (!string.IsNullOrEmpty(value2) && array.Contains(value2))
				{
					num++;
				}
			}
			return num;
		}

		public static bool AreTheSameLanguage(string Language1, string Language2)
		{
			Language1 = GetLanguageWithoutRegion(Language1);
			Language2 = GetLanguageWithoutRegion(Language2);
			return string.Compare(Language1, Language2, StringComparison.OrdinalIgnoreCase) == 0;
		}

		public static string GetLanguageWithoutRegion(string Language)
		{
			int num = Language.IndexOfAny("(/\\[,{".ToCharArray());
			if (num < 0)
			{
				return Language;
			}
			return Language.Substring(0, num).Trim();
		}

		public void AddLanguage(string LanguageName)
		{
			AddLanguage(LanguageName, GoogleLanguages.GetLanguageCode(LanguageName));
		}

		public void AddLanguage(string LanguageName, string LanguageCode)
		{
			if (GetLanguageIndex(LanguageName, AllowDiscartingRegion: false) < 0)
			{
				LanguageData languageData = new LanguageData();
				languageData.Name = LanguageName;
				languageData.Code = LanguageCode;
				mLanguages.Add(languageData);
				int count = mLanguages.Count;
				int i = 0;
				for (int count2 = mTerms.Count; i < count2; i++)
				{
					Array.Resize(ref mTerms[i].Languages, count);
					Array.Resize(ref mTerms[i].Flags, count);
				}
				Editor_SetDirty();
			}
		}

		public void RemoveLanguage(string LanguageName)
		{
			int languageIndex = GetLanguageIndex(LanguageName, AllowDiscartingRegion: false, SkipDisabled: false);
			if (languageIndex < 0)
			{
				return;
			}
			int count = mLanguages.Count;
			int i = 0;
			for (int count2 = mTerms.Count; i < count2; i++)
			{
				for (int j = languageIndex + 1; j < count; j++)
				{
					mTerms[i].Languages[j - 1] = mTerms[i].Languages[j];
					mTerms[i].Flags[j - 1] = mTerms[i].Flags[j];
				}
				Array.Resize(ref mTerms[i].Languages, count - 1);
				Array.Resize(ref mTerms[i].Flags, count - 1);
			}
			mLanguages.RemoveAt(languageIndex);
			Editor_SetDirty();
		}

		public List<string> GetLanguages(bool skipDisabled = true)
		{
			List<string> list = new List<string>();
			int i = 0;
			for (int count = mLanguages.Count; i < count; i++)
			{
				if (!skipDisabled || mLanguages[i].IsEnabled())
				{
					list.Add(mLanguages[i].Name);
				}
			}
			return list;
		}

		public List<string> GetLanguagesCode(bool allowRegions = true, bool skipDisabled = true)
		{
			List<string> list = new List<string>();
			int i = 0;
			for (int count = mLanguages.Count; i < count; i++)
			{
				if (!skipDisabled || mLanguages[i].IsEnabled())
				{
					string text = mLanguages[i].Code;
					if (!allowRegions && text != null && text.Length > 2)
					{
						text = text.Substring(0, 2);
					}
					if (!string.IsNullOrEmpty(text) && !list.Contains(text))
					{
						list.Add(text);
					}
				}
			}
			return list;
		}

		public bool IsLanguageEnabled(string Language)
		{
			int languageIndex = GetLanguageIndex(Language, AllowDiscartingRegion: false);
			if (languageIndex >= 0)
			{
				return mLanguages[languageIndex].IsEnabled();
			}
			return false;
		}

		public void EnableLanguage(string Language, bool bEnabled)
		{
			int languageIndex = GetLanguageIndex(Language, AllowDiscartingRegion: false, SkipDisabled: false);
			if (languageIndex >= 0)
			{
				mLanguages[languageIndex].SetEnabled(bEnabled);
			}
		}

		public bool AllowUnloadingLanguages()
		{
			return _AllowUnloadingLanguages != eAllowUnloadLanguages.Never;
		}

		private string GetSavedLanguageFileName(int languageIndex)
		{
			if (languageIndex < 0)
			{
				return null;
			}
			return "LangSource_" + GetSourcePlayerPrefName() + "_" + mLanguages[languageIndex].Name + ".loc";
		}

		public void LoadLanguage(int languageIndex, bool UnloadOtherLanguages, bool useFallback, bool onlyCurrentSpecialization, bool forceLoad)
		{
			if (!AllowUnloadingLanguages() || !PersistentStorage.CanAccessFiles())
			{
				return;
			}
			if (languageIndex >= 0 && (forceLoad || !mLanguages[languageIndex].IsLoaded()))
			{
				string savedLanguageFileName = GetSavedLanguageFileName(languageIndex);
				string text = PersistentStorage.LoadFile(PersistentStorage.eFileType.Temporal, savedLanguageFileName, logExceptions: false);
				if (!string.IsNullOrEmpty(text))
				{
					Import_Language_from_Cache(languageIndex, text, useFallback, onlyCurrentSpecialization);
					mLanguages[languageIndex].SetLoaded(loaded: true);
				}
			}
			if (!UnloadOtherLanguages || !I2Utils.IsPlaying())
			{
				return;
			}
			for (int i = 0; i < mLanguages.Count; i++)
			{
				if (i != languageIndex)
				{
					UnloadLanguage(i);
				}
			}
		}

		public void LoadAllLanguages(bool forceLoad = false)
		{
			for (int i = 0; i < mLanguages.Count; i++)
			{
				LoadLanguage(i, UnloadOtherLanguages: false, useFallback: false, onlyCurrentSpecialization: false, forceLoad);
			}
		}

		public void UnloadLanguage(int languageIndex)
		{
			if (!AllowUnloadingLanguages() || !PersistentStorage.CanAccessFiles() || !I2Utils.IsPlaying() || !mLanguages[languageIndex].IsLoaded() || !mLanguages[languageIndex].CanBeUnloaded() || IsCurrentLanguage(languageIndex) || !PersistentStorage.HasFile(PersistentStorage.eFileType.Temporal, GetSavedLanguageFileName(languageIndex)))
			{
				return;
			}
			foreach (TermData mTerm in mTerms)
			{
				mTerm.Languages[languageIndex] = null;
			}
			mLanguages[languageIndex].SetLoaded(loaded: false);
		}

		public void SaveLanguages(bool unloadAll, PersistentStorage.eFileType fileLocation = PersistentStorage.eFileType.Temporal)
		{
			if (!AllowUnloadingLanguages() || !PersistentStorage.CanAccessFiles())
			{
				return;
			}
			for (int i = 0; i < mLanguages.Count; i++)
			{
				string text = Export_Language_to_Cache(i, IsCurrentLanguage(i));
				if (!string.IsNullOrEmpty(text))
				{
					PersistentStorage.SaveFile(PersistentStorage.eFileType.Temporal, GetSavedLanguageFileName(i), text);
				}
			}
			if (!unloadAll)
			{
				return;
			}
			for (int j = 0; j < mLanguages.Count; j++)
			{
				if (unloadAll && !IsCurrentLanguage(j))
				{
					UnloadLanguage(j);
				}
			}
		}

		public bool HasUnloadedLanguages()
		{
			for (int i = 0; i < mLanguages.Count; i++)
			{
				if (!mLanguages[i].IsLoaded())
				{
					return true;
				}
			}
			return false;
		}

		public List<string> GetCategories(bool OnlyMainCategory = false, List<string> Categories = null)
		{
			if (Categories == null)
			{
				Categories = new List<string>();
			}
			foreach (TermData mTerm in mTerms)
			{
				string categoryFromFullTerm = GetCategoryFromFullTerm(mTerm.Term, OnlyMainCategory);
				if (!Categories.Contains(categoryFromFullTerm))
				{
					Categories.Add(categoryFromFullTerm);
				}
			}
			Categories.Sort();
			return Categories;
		}

		public static string GetKeyFromFullTerm(string FullTerm, bool OnlyMainCategory = false)
		{
			int num = (OnlyMainCategory ? FullTerm.IndexOfAny(CategorySeparators) : FullTerm.LastIndexOfAny(CategorySeparators));
			if (num >= 0)
			{
				return FullTerm.Substring(num + 1);
			}
			return FullTerm;
		}

		public static string GetCategoryFromFullTerm(string FullTerm, bool OnlyMainCategory = false)
		{
			int num = (OnlyMainCategory ? FullTerm.IndexOfAny(CategorySeparators) : FullTerm.LastIndexOfAny(CategorySeparators));
			if (num >= 0)
			{
				return FullTerm.Substring(0, num);
			}
			return EmptyCategory;
		}

		public static void DeserializeFullTerm(string FullTerm, out string Key, out string Category, bool OnlyMainCategory = false)
		{
			int num = (OnlyMainCategory ? FullTerm.IndexOfAny(CategorySeparators) : FullTerm.LastIndexOfAny(CategorySeparators));
			if (num < 0)
			{
				Category = EmptyCategory;
				Key = FullTerm;
			}
			else
			{
				Category = FullTerm.Substring(0, num);
				Key = FullTerm.Substring(num + 1);
			}
		}

		public void UpdateDictionary(bool force = false)
		{
			if (force || mDictionary == null || mDictionary.Count != mTerms.Count)
			{
				StringComparer stringComparer = (CaseInsensitiveTerms ? StringComparer.OrdinalIgnoreCase : StringComparer.Ordinal);
				if (mDictionary.Comparer != stringComparer)
				{
					mDictionary = new Dictionary<string, TermData>(stringComparer);
				}
				else
				{
					mDictionary.Clear();
				}
				int i = 0;
				for (int count = mTerms.Count; i < count; i++)
				{
					TermData termData = mTerms[i];
					ValidateFullTerm(ref termData.Term);
					mDictionary[termData.Term] = mTerms[i];
					mTerms[i].Validate();
				}
				if (I2Utils.IsPlaying())
				{
					SaveLanguages(unloadAll: true);
				}
			}
		}

		public string GetTranslation(string term, string overrideLanguage = null, string overrideSpecialization = null, bool skipDisabled = false, bool allowCategoryMistmatch = false)
		{
			if (TryGetTranslation(term, out var Translation, overrideLanguage, overrideSpecialization, skipDisabled, allowCategoryMistmatch))
			{
				return Translation;
			}
			return string.Empty;
		}

		public bool TryGetTranslation(string term, out string Translation, string overrideLanguage = null, string overrideSpecialization = null, bool skipDisabled = false, bool allowCategoryMistmatch = false)
		{
			int languageIndex = GetLanguageIndex((overrideLanguage == null) ? LocalizationManager.CurrentLanguage : overrideLanguage, AllowDiscartingRegion: true, SkipDisabled: false);
			if (languageIndex >= 0 && (!skipDisabled || mLanguages[languageIndex].IsEnabled()))
			{
				TermData termData = GetTermData(term, allowCategoryMistmatch);
				if (termData != null)
				{
					Translation = termData.GetTranslation(languageIndex, overrideSpecialization, editMode: true);
					if (Translation == "---")
					{
						Translation = string.Empty;
						return true;
					}
					if (!string.IsNullOrEmpty(Translation))
					{
						return true;
					}
					Translation = null;
				}
				if (OnMissingTranslation == MissingTranslationAction.ShowWarning)
				{
					Translation = $"<!-Missing Translation [{term}]-!>";
					return true;
				}
				if (OnMissingTranslation == MissingTranslationAction.Fallback && termData != null)
				{
					return TryGetFallbackTranslation(termData, out Translation, languageIndex, overrideSpecialization, skipDisabled);
				}
				if (OnMissingTranslation == MissingTranslationAction.Empty)
				{
					Translation = string.Empty;
					return true;
				}
				if (OnMissingTranslation == MissingTranslationAction.ShowTerm)
				{
					Translation = term;
					return true;
				}
			}
			Translation = null;
			return false;
		}

		private bool TryGetFallbackTranslation(TermData termData, out string Translation, int langIndex, string overrideSpecialization = null, bool skipDisabled = false)
		{
			string text = mLanguages[langIndex].Code;
			if (!string.IsNullOrEmpty(text))
			{
				if (text.Contains('-'))
				{
					text = text.Substring(0, text.IndexOf('-'));
				}
				for (int i = 0; i < mLanguages.Count; i++)
				{
					if (i != langIndex && mLanguages[i].Code.StartsWith(text) && (!skipDisabled || mLanguages[i].IsEnabled()))
					{
						Translation = termData.GetTranslation(i, overrideSpecialization, editMode: true);
						if (!string.IsNullOrEmpty(Translation))
						{
							return true;
						}
					}
				}
			}
			for (int j = 0; j < mLanguages.Count; j++)
			{
				if (j != langIndex && (!skipDisabled || mLanguages[j].IsEnabled()) && (text == null || !mLanguages[j].Code.StartsWith(text)))
				{
					Translation = termData.GetTranslation(j, overrideSpecialization, editMode: true);
					if (!string.IsNullOrEmpty(Translation))
					{
						return true;
					}
				}
			}
			Translation = null;
			return false;
		}

		public TermData AddTerm(string term)
		{
			return AddTerm(term, eTermType.Text);
		}

		public TermData GetTermData(string term, bool allowCategoryMistmatch = false)
		{
			if (string.IsNullOrEmpty(term))
			{
				return null;
			}
			if (mDictionary.Count == 0)
			{
				UpdateDictionary();
			}
			if (mDictionary.TryGetValue(term, out var value))
			{
				return value;
			}
			TermData termData = null;
			if (allowCategoryMistmatch)
			{
				string keyFromFullTerm = GetKeyFromFullTerm(term);
				foreach (KeyValuePair<string, TermData> item in mDictionary)
				{
					if (item.Value.IsTerm(keyFromFullTerm, allowCategoryMistmatch: true))
					{
						if (termData != null)
						{
							return null;
						}
						termData = item.Value;
					}
				}
			}
			return termData;
		}

		public bool ContainsTerm(string term)
		{
			return GetTermData(term) != null;
		}

		public List<string> GetTermsList(string Category = null)
		{
			if (mDictionary.Count != mTerms.Count)
			{
				UpdateDictionary();
			}
			if (string.IsNullOrEmpty(Category))
			{
				return new List<string>(mDictionary.Keys);
			}
			List<string> list = new List<string>();
			for (int i = 0; i < mTerms.Count; i++)
			{
				TermData termData = mTerms[i];
				if (GetCategoryFromFullTerm(termData.Term) == Category)
				{
					list.Add(termData.Term);
				}
			}
			return list;
		}

		public TermData AddTerm(string NewTerm, eTermType termType, bool SaveSource = true)
		{
			ValidateFullTerm(ref NewTerm);
			NewTerm = NewTerm.Trim();
			if (mLanguages.Count == 0)
			{
				AddLanguage("English", "en");
			}
			TermData termData = GetTermData(NewTerm);
			if (termData == null)
			{
				termData = new TermData();
				termData.Term = NewTerm;
				termData.TermType = termType;
				termData.Languages = new string[mLanguages.Count];
				termData.Flags = new byte[mLanguages.Count];
				mTerms.Add(termData);
				mDictionary.Add(NewTerm, termData);
			}
			return termData;
		}

		public void RemoveTerm(string term)
		{
			int i = 0;
			for (int count = mTerms.Count; i < count; i++)
			{
				if (mTerms[i].Term == term)
				{
					mTerms.RemoveAt(i);
					mDictionary.Remove(term);
					break;
				}
			}
		}

		public static void ValidateFullTerm(ref string Term)
		{
			Term = Term.Replace('\\', '/');
			Term = Term.Trim();
			if (Term.StartsWith(EmptyCategory, StringComparison.Ordinal) && Term.Length > EmptyCategory.Length && Term[EmptyCategory.Length] == '/')
			{
				Term = Term.Substring(EmptyCategory.Length + 1);
			}
			Term = I2Utils.GetValidTermName(Term, allowCategory: true);
		}
	}
	public enum eSpreadsheetUpdateMode
	{
		None,
		Replace,
		Merge,
		AddNewTerms
	}
	public class LocalizationReader
	{
		public static Dictionary<string, string> ReadTextAsset(TextAsset asset)
		{
			StringReader stringReader = new StringReader(Encoding.UTF8.GetString(asset.bytes, 0, asset.bytes.Length).Replace("\r\n", "\n").Replace("\r", "\n"));
			Dictionary<string, string> dictionary = new Dictionary<string, string>(StringComparer.Ordinal);
			string line;
			while ((line = stringReader.ReadLine()) != null)
			{
				if (TextAsset_ReadLine(line, out var key, out var value, out var _, out var _, out var _) && !string.IsNullOrEmpty(key) && !string.IsNullOrEmpty(value))
				{
					dictionary[key] = value;
				}
			}
			return dictionary;
		}

		public static bool TextAsset_ReadLine(string line, out string key, out string value, out string category, out string comment, out string termType)
		{
			key = string.Empty;
			category = string.Empty;
			comment = string.Empty;
			termType = string.Empty;
			value = string.Empty;
			int num = line.LastIndexOf("//");
			if (num >= 0)
			{
				comment = line.Substring(num + 2).Trim();
				comment = DecodeString(comment);
				line = line.Substring(0, num);
			}
			int num2 = line.IndexOf("=");
			if (num2 < 0)
			{
				return false;
			}
			key = line.Substring(0, num2).Trim();
			value = line.Substring(num2 + 1).Trim();
			value = value.Replace("\r\n", "\n").Replace("\n", "\\n");
			value = DecodeString(value);
			if (key.Length > 2 && key[0] == '[')
			{
				int num3 = key.IndexOf(']');
				if (num3 >= 0)
				{
					termType = key.Substring(1, num3 - 1);
					key = key.Substring(num3 + 1);
				}
			}
			ValidateFullTerm(ref key);
			return true;
		}

		public static string ReadCSVfile(string Path, Encoding encoding)
		{
			string text = string.Empty;
			using (StreamReader streamReader = new StreamReader(Path, encoding))
			{
				text = streamReader.ReadToEnd();
			}
			text = text.Replace("\r\n", "\n");
			return text.Replace("\r", "\n");
		}

		public static List<string[]> ReadCSV(string Text, char Separator = ',')
		{
			int iStart = 0;
			List<string[]> list = new List<string[]>();
			while (iStart < Text.Length)
			{
				string[] array = ParseCSVline(Text, ref iStart, Separator);
				if (array == null)
				{
					break;
				}
				list.Add(array);
			}
			return list;
		}

		private static string[] ParseCSVline(string Line, ref int iStart, char Separator)
		{
			List<string> list = new List<string>();
			int length = Line.Length;
			int iWordStart = iStart;
			bool flag = false;
			while (iStart < length)
			{
				char c = Line[iStart];
				if (flag)
				{
					if (c == '"')
					{
						if (iStart + 1 >= length || Line[iStart + 1] != '"')
						{
							flag = false;
						}
						else if (iStart + 2 < length && Line[iStart + 2] == '"')
						{
							flag = false;
							iStart += 2;
						}
						else
						{
							iStart++;
						}
					}
				}
				else if (c == '\n' || c == Separator)
				{
					AddCSVtoken(ref list, ref Line, iStart, ref iWordStart);
					if (c == '\n')
					{
						iStart++;
						break;
					}
				}
				else if (c == '"')
				{
					flag = true;
				}
				iStart++;
			}
			if (iStart > iWordStart)
			{
				AddCSVtoken(ref list, ref Line, iStart, ref iWordStart);
			}
			return list.ToArray();
		}

		private static void AddCSVtoken(ref List<string> list, ref string Line, int iEnd, ref int iWordStart)
		{
			string text = Line.Substring(iWordStart, iEnd - iWordStart);
			iWordStart = iEnd + 1;
			text = text.Replace("\"\"", "\"");
			if (text.Length > 1 && text[0] == '"' && text[text.Length - 1] == '"')
			{
				text = text.Substring(1, text.Length - 2);
			}
			list.Add(text);
		}

		public static List<string[]> ReadI2CSV(string Text)
		{
			string[] separator = new string[1] { "[*]" };
			string[] separator2 = new string[1] { "[ln]" };
			List<string[]> list = new List<string[]>();
			string[] array = Text.Split(separator2, StringSplitOptions.None);
			foreach (string text in array)
			{
				list.Add(text.Split(separator, StringSplitOptions.None));
			}
			return list;
		}

		public static void ValidateFullTerm(ref string Term)
		{
			Term = Term.Replace('\\', '/');
			int num = Term.IndexOf('/');
			if (num >= 0)
			{
				int startIndex;
				while ((startIndex = Term.LastIndexOf('/')) != num)
				{
					Term = Term.Remove(startIndex, 1);
				}
			}
		}

		public static string EncodeString(string str)
		{
			if (string.IsNullOrEmpty(str))
			{
				return string.Empty;
			}
			return str.Replace("\r\n", "<\\n>").Replace("\r", "<\\n>").Replace("\n", "<\\n>");
		}

		public static string DecodeString(string str)
		{
			if (string.IsNullOrEmpty(str))
			{
				return string.Empty;
			}
			return str.Replace("<\\n>", "\r\n");
		}
	}
	[AddComponentMenu("I2/Localization/I2 Localize")]
	public class Localize : MonoBehaviour
	{
		public enum TermModification
		{
			DontModify,
			ToUpper,
			ToLower,
			ToUpperFirst,
			ToTitle
		}

		public string mTerm = string.Empty;

		public string mTermSecondary = string.Empty;

		[NonSerialized]
		public string FinalTerm;

		[NonSerialized]
		public string FinalSecondaryTerm;

		public TermModification PrimaryTermModifier;

		public TermModification SecondaryTermModifier;

		public string TermPrefix;

		public string TermSuffix;

		public bool LocalizeOnAwake = true;

		private string LastLocalizedLanguage;

		public bool IgnoreRTL;

		public int MaxCharactersInRTL;

		public bool IgnoreNumbersInRTL = true;

		public bool CorrectAlignmentForRTL = true;

		public bool AddSpacesToJoinedLanguages;

		public bool AllowLocalizedParameters = true;

		public List<UnityEngine.Object> TranslatedObjects = new List<UnityEngine.Object>();

		[NonSerialized]
		public Dictionary<string, UnityEngine.Object> mAssetDictionary = new Dictionary<string, UnityEngine.Object>(StringComparer.Ordinal);

		public UnityEvent LocalizeEvent = new UnityEvent();

		public static string MainTranslation;

		public static string SecondaryTranslation;

		public static string CallBackTerm;

		public static string CallBackSecondaryTerm;

		public static Localize CurrentLocalizeComponent;

		public bool AlwaysForceLocalize;

		[SerializeField]
		public EventCallback LocalizeCallBack = new EventCallback();

		public bool mGUI_ShowReferences;

		public bool mGUI_ShowTems = true;

		public bool mGUI_ShowCallback;

		public ILocalizeTarget mLocalizeTarget;

		public string mLocalizeTargetName;

		public string Term
		{
			get
			{
				return mTerm;
			}
			set
			{
				SetTerm(value);
			}
		}

		public string SecondaryTerm
		{
			get
			{
				return mTermSecondary;
			}
			set
			{
				SetTerm(null, value);
			}
		}

		private void Awake()
		{
			UpdateAssetDictionary();
			FindTarget();
			if (LocalizeOnAwake)
			{
				OnLocalize();
			}
		}

		private void OnEnable()
		{
			OnLocalize();
		}

		public bool HasCallback()
		{
			if (LocalizeCallBack.HasCallback())
			{
				return true;
			}
			return LocalizeEvent.GetPersistentEventCount() > 0;
		}

		public void OnLocalize(bool Force = false)
		{
			if ((!Force && (!base.enabled || base.gameObject == null || !base.gameObject.activeInHierarchy)) || string.IsNullOrEmpty(LocalizationManager.CurrentLanguage) || (!AlwaysForceLocalize && !Force && !HasCallback() && LastLocalizedLanguage == LocalizationManager.CurrentLanguage))
			{
				return;
			}
			LastLocalizedLanguage = LocalizationManager.CurrentLanguage;
			if (string.IsNullOrEmpty(FinalTerm) || string.IsNullOrEmpty(FinalSecondaryTerm))
			{
				GetFinalTerms(out FinalTerm, out FinalSecondaryTerm);
			}
			bool flag = I2Utils.IsPlaying() && HasCallback();
			if (!flag && string.IsNullOrEmpty(FinalTerm) && string.IsNullOrEmpty(FinalSecondaryTerm))
			{
				return;
			}
			CallBackTerm = FinalTerm;
			CallBackSecondaryTerm = FinalSecondaryTerm;
			MainTranslation = ((string.IsNullOrEmpty(FinalTerm) || FinalTerm == "-") ? null : LocalizationManager.GetTranslation(FinalTerm, FixForRTL: false));
			SecondaryTranslation = ((string.IsNullOrEmpty(FinalSecondaryTerm) || FinalSecondaryTerm == "-") ? null : LocalizationManager.GetTranslation(FinalSecondaryTerm, FixForRTL: false));
			if (!flag && string.IsNullOrEmpty(FinalTerm) && string.IsNullOrEmpty(SecondaryTranslation))
			{
				return;
			}
			CurrentLocalizeComponent = this;
			LocalizeCallBack.Execute(this);
			LocalizeEvent.Invoke();
			LocalizationManager.ApplyLocalizationParams(ref MainTranslation, base.gameObject, AllowLocalizedParameters);
			if (!FindTarget())
			{
				return;
			}
			bool flag2 = LocalizationManager.IsRight2Left && !IgnoreRTL;
			if (MainTranslation != null)
			{
				switch (PrimaryTermModifier)
				{
				case TermModification.ToUpper:
					MainTranslation = MainTranslation.ToUpper();
					break;
				case TermModification.ToLower:
					MainTranslation = MainTranslation.ToLower();
					break;
				case TermModification.ToUpperFirst:
					MainTranslation = GoogleTranslation.UppercaseFirst(MainTranslation);
					break;
				case TermModification.ToTitle:
					MainTranslation = GoogleTranslation.TitleCase(MainTranslation);
					break;
				}
				if (!string.IsNullOrEmpty(TermPrefix))
				{
					MainTranslation = (flag2 ? (MainTranslation + TermPrefix) : (TermPrefix + MainTranslation));
				}
				if (!string.IsNullOrEmpty(TermSuffix))
				{
					MainTranslation = (flag2 ? (TermSuffix + MainTranslation) : (MainTranslation + TermSuffix));
				}
				if (AddSpacesToJoinedLanguages && LocalizationManager.HasJoinedWords && !string.IsNullOrEmpty(MainTranslation))
				{
					StringBuilder stringBuilder = new StringBuilder();
					stringBuilder.Append(MainTranslation[0]);
					int i = 1;
					for (int length = MainTranslation.Length; i < length; i++)
					{
						stringBuilder.Append(' ');
						stringBuilder.Append(MainTranslation[i]);
					}
					MainTranslation = stringBuilder.ToString();
				}
				if (flag2 && mLocalizeTarget.AllowMainTermToBeRTL() && !string.IsNullOrEmpty(MainTranslation))
				{
					MainTranslation = LocalizationManager.ApplyRTLfix(MainTranslation, MaxCharactersInRTL, IgnoreNumbersInRTL);
				}
			}
			if (SecondaryTranslation != null)
			{
				switch (SecondaryTermModifier)
				{
				case TermModification.ToUpper:
					SecondaryTranslation = SecondaryTranslation.ToUpper();
					break;
				case TermModification.ToLower:
					SecondaryTranslation = SecondaryTranslation.ToLower();
					break;
				case TermModification.ToUpperFirst:
					SecondaryTranslation = GoogleTranslation.UppercaseFirst(SecondaryTranslation);
					break;
				case TermModification.ToTitle:
					SecondaryTranslation = GoogleTranslation.TitleCase(SecondaryTranslation);
					break;
				}
				if (flag2 && mLocalizeTarget.AllowSecondTermToBeRTL() && !string.IsNullOrEmpty(SecondaryTranslation))
				{
					SecondaryTranslation = LocalizationManager.ApplyRTLfix(SecondaryTranslation);
				}
			}
			if (LocalizationManager.HighlightLocalizedTargets)
			{
				MainTranslation = "LOC:" + FinalTerm;
			}
			mLocalizeTarget.DoLocalize(this, MainTranslation, SecondaryTranslation);
			CurrentLocalizeComponent = null;
		}

		public bool FindTarget()
		{
			if (mLocalizeTarget != null && mLocalizeTarget.IsValid(this))
			{
				return true;
			}
			if (mLocalizeTarget != null)
			{
				UnityEngine.Object.DestroyImmediate(mLocalizeTarget);
				mLocalizeTarget = null;
				mLocalizeTargetName = null;
			}
			if (!string.IsNullOrEmpty(mLocalizeTargetName))
			{
				foreach (ILocalizeTargetDescriptor mLocalizeTarget in LocalizationManager.mLocalizeTargets)
				{
					if (mLocalizeTargetName == mLocalizeTarget.GetTargetType().ToString())
					{
						if (mLocalizeTarget.CanLocalize(this))
						{
							this.mLocalizeTarget = mLocalizeTarget.CreateTarget(this);
						}
						if (this.mLocalizeTarget != null)
						{
							return true;
						}
					}
				}
			}
			foreach (ILocalizeTargetDescriptor mLocalizeTarget2 in LocalizationManager.mLocalizeTargets)
			{
				if (mLocalizeTarget2.CanLocalize(this))
				{
					this.mLocalizeTarget = mLocalizeTarget2.CreateTarget(this);
					mLocalizeTargetName = mLocalizeTarget2.GetTargetType().ToString();
					if (this.mLocalizeTarget != null)
					{
						return true;
					}
				}
			}
			return false;
		}

		public void GetFinalTerms(out string primaryTerm, out string secondaryTerm)
		{
			primaryTerm = string.Empty;
			secondaryTerm = string.Empty;
			if (FindTarget())
			{
				if (mLocalizeTarget != null)
				{
					mLocalizeTarget.GetFinalTerms(this, mTerm, mTermSecondary, out primaryTerm, out secondaryTerm);
					primaryTerm = I2Utils.GetValidTermName(primaryTerm);
				}
				if (!string.IsNullOrEmpty(mTerm))
				{
					primaryTerm = mTerm;
				}
				if (!string.IsNullOrEmpty(mTermSecondary))
				{
					secondaryTerm = mTermSecondary;
				}
				if (primaryTerm != null)
				{
					primaryTerm = primaryTerm.Trim();
				}
				if (secondaryTerm != null)
				{
					secondaryTerm = secondaryTerm.Trim();
				}
			}
		}

		public string GetMainTargetsText()
		{
			string primaryTerm = null;
			string secondaryTerm = null;
			if (mLocalizeTarget != null)
			{
				mLocalizeTarget.GetFinalTerms(this, null, null, out primaryTerm, out secondaryTerm);
			}
			if (!string.IsNullOrEmpty(primaryTerm))
			{
				return primaryTerm;
			}
			return mTerm;
		}

		public void SetFinalTerms(string Main, string Secondary, out string primaryTerm, out string secondaryTerm, bool RemoveNonASCII)
		{
			primaryTerm = (RemoveNonASCII ? I2Utils.GetValidTermName(Main) : Main);
			secondaryTerm = Secondary;
		}

		public void SetTerm(string primary)
		{
			if (!string.IsNullOrEmpty(primary))
			{
				FinalTerm = (mTerm = primary);
			}
			OnLocalize(Force: true);
		}

		public void SetTerm(string primary, string secondary)
		{
			if (!string.IsNullOrEmpty(primary))
			{
				FinalTerm = (mTerm = primary);
			}
			FinalSecondaryTerm = (mTermSecondary = secondary);
			OnLocalize(Force: true);
		}

		internal T GetSecondaryTranslatedObj<T>(ref string mainTranslation, ref string secondaryTranslation) where T : UnityEngine.Object
		{
			DeserializeTranslation(mainTranslation, out var value, out var secondary);
			T val = null;
			if (!string.IsNullOrEmpty(secondary))
			{
				val = GetObject<T>(secondary);
				if (val != null)
				{
					mainTranslation = value;
					secondaryTranslation = secondary;
				}
			}
			if (val == null)
			{
				val = GetObject<T>(secondaryTranslation);
			}
			return val;
		}

		public void UpdateAssetDictionary()
		{
			TranslatedObjects.RemoveAll((UnityEngine.Object x) => x == null);
			mAssetDictionary = (from o in TranslatedObjects.Distinct()
				group o by o.name).ToDictionary((IGrouping<string, UnityEngine.Object> g) => g.Key, (IGrouping<string, UnityEngine.Object> g) => g.First());
		}

		internal T GetObject<T>(string Translation) where T : UnityEngine.Object
		{
			if (string.IsNullOrEmpty(Translation))
			{
				return null;
			}
			return GetTranslatedObject<T>(Translation);
		}

		private T GetTranslatedObject<T>(string Translation) where T : UnityEngine.Object
		{
			return FindTranslatedObject<T>(Translation);
		}

		private void DeserializeTranslation(string translation, out string value, out string secondary)
		{
			if (!string.IsNullOrEmpty(translation) && translation.Length > 1 && translation[0] == '[')
			{
				int num = translation.IndexOf(']');
				if (num > 0)
				{
					secondary = translation.Substring(1, num - 1);
					value = translation.Substring(num + 1);
					return;
				}
			}
			value = translation;
			secondary = string.Empty;
		}

		public T FindTranslatedObject<T>(string value) where T : UnityEngine.Object
		{
			if (string.IsNullOrEmpty(value))
			{
				return null;
			}
			if (mAssetDictionary == null || mAssetDictionary.Count != TranslatedObjects.Count)
			{
				UpdateAssetDictionary();
			}
			foreach (KeyValuePair<string, UnityEngine.Object> item in mAssetDictionary)
			{
				if (item.Value is T && value.EndsWith(item.Key, StringComparison.OrdinalIgnoreCase) && string.Compare(value, item.Key, StringComparison.OrdinalIgnoreCase) == 0)
				{
					return (T)item.Value;
				}
			}
			T val = LocalizationManager.FindAsset(value) as T;
			if ((bool)val)
			{
				return val;
			}
			return ResourceManager.pInstance.GetAsset<T>(value);
		}

		public bool HasTranslatedObject(UnityEngine.Object Obj)
		{
			if (TranslatedObjects.Contains(Obj))
			{
				return true;
			}
			return ResourceManager.pInstance.HasAsset(Obj);
		}

		public void AddTranslatedObject(UnityEngine.Object Obj)
		{
			if (!TranslatedObjects.Contains(Obj))
			{
				TranslatedObjects.Add(Obj);
				UpdateAssetDictionary();
			}
		}

		public void SetGlobalLanguage(string Language)
		{
			LocalizationManager.CurrentLanguage = Language;
		}
	}
	[AddComponentMenu("I2/Localization/Localize Dropdown")]
	public class LocalizeDropdown : MonoBehaviour
	{
		public List<string> _Terms = new List<string>();

		public void Start()
		{
			LocalizationManager.OnLocalizeEvent += OnLocalize;
			OnLocalize();
		}

		public void OnDestroy()
		{
			LocalizationManager.OnLocalizeEvent -= OnLocalize;
		}

		private void OnEnable()
		{
			if (_Terms.Count == 0)
			{
				FillValues();
			}
			OnLocalize();
		}

		public void OnLocalize()
		{
			if (base.enabled && !(base.gameObject == null) && base.gameObject.activeInHierarchy && !string.IsNullOrEmpty(LocalizationManager.CurrentLanguage))
			{
				UpdateLocalization();
			}
		}

		private void FillValues()
		{
			Dropdown component = GetComponent<Dropdown>();
			if (component == null && I2Utils.IsPlaying())
			{
				FillValuesTMPro();
				return;
			}
			foreach (Dropdown.OptionData option in component.options)
			{
				_Terms.Add(option.text);
			}
		}

		public void UpdateLocalization()
		{
			Dropdown component = GetComponent<Dropdown>();
			if (component == null)
			{
				UpdateLocalizationTMPro();
				return;
			}
			component.options.Clear();
			foreach (string term in _Terms)
			{
				string translation = LocalizationManager.GetTranslation(term);
				component.options.Add(new Dropdown.OptionData(translation));
			}
			component.RefreshShownValue();
		}

		public void UpdateLocalizationTMPro()
		{
			TMP_Dropdown component = GetComponent<TMP_Dropdown>();
			if (component == null)
			{
				return;
			}
			component.options.Clear();
			foreach (string term in _Terms)
			{
				string translation = LocalizationManager.GetTranslation(term);
				component.options.Add(new TMP_Dropdown.OptionData(translation));
			}
			component.RefreshShownValue();
		}

		private void FillValuesTMPro()
		{
			TMP_Dropdown component = GetComponent<TMP_Dropdown>();
			if (component == null)
			{
				return;
			}
			foreach (TMP_Dropdown.OptionData option in component.options)
			{
				_Terms.Add(option.text);
			}
		}
	}
	public static class LocalizationManager
	{
		public delegate object _GetParam(string param);

		public delegate void OnLocalizeCallback();

		private static string mCurrentLanguage;

		private static string mLanguageCode;

		private static CultureInfo mCurrentCulture;

		private static bool mChangeCultureInfo = false;

		public static bool IsRight2Left = false;

		public static bool HasJoinedWords = false;

		public static List<ILocalizationParamsManager> ParamManagers = new List<ILocalizationParamsManager>();

		private static string[] LanguagesRTL = new string[21]
		{
			"ar-DZ", "ar", "ar-BH", "ar-EG", "ar-IQ", "ar-JO", "ar-KW", "ar-LB", "ar-LY", "ar-MA",
			"ar-OM", "ar-QA", "ar-SA", "ar-SY", "ar-TN", "ar-AE", "ar-YE", "fa", "he", "ur",
			"ji"
		};

		public static List<LanguageSourceData> Sources = new List<LanguageSourceData>();

		public static string[] GlobalSources = new string[1] { "I2Languages" };

		private static string mCurrentDeviceLanguage;

		public static List<ILocalizeTargetDescriptor> mLocalizeTargets = new List<ILocalizeTargetDescriptor>();

		private static bool mLocalizeIsScheduled = false;

		private static bool mLocalizeIsScheduledWithForcedValue = false;

		public static bool HighlightLocalizedTargets = false;

		public static string CurrentLanguage
		{
			get
			{
				InitializeIfNeeded();
				return mCurrentLanguage;
			}
			set
			{
				InitializeIfNeeded();
				string supportedLanguage = GetSupportedLanguage(value);
				if (!string.IsNullOrEmpty(supportedLanguage) && mCurrentLanguage != supportedLanguage)
				{
					SetLanguageAndCode(supportedLanguage, GetLanguageCode(supportedLanguage));
				}
			}
		}

		public static string CurrentLanguageCode
		{
			get
			{
				InitializeIfNeeded();
				return mLanguageCode;
			}
			set
			{
				InitializeIfNeeded();
				if (mLanguageCode != value)
				{
					string languageFromCode = GetLanguageFromCode(value);
					if (!string.IsNullOrEmpty(languageFromCode))
					{
						SetLanguageAndCode(languageFromCode, value);
					}
				}
			}
		}

		public static string CurrentRegion
		{
			get
			{
				string currentLanguage = CurrentLanguage;
				int num = currentLanguage.IndexOfAny("/\\".ToCharArray());
				if (num > 0)
				{
					return currentLanguage.Substring(num + 1);
				}
				num = currentLanguage.IndexOfAny("[(".ToCharArray());
				int num2 = currentLanguage.LastIndexOfAny("])".ToCharArray());
				if (num > 0 && num != num2)
				{
					return currentLanguage.Substring(num + 1, num2 - num - 1);
				}
				return string.Empty;
			}
			set
			{
				string text = CurrentLanguage;
				int num = text.IndexOfAny("/\\".ToCharArray());
				if (num > 0)
				{
					CurrentLanguage = text.Substring(num + 1) + value;
					return;
				}
				num = text.IndexOfAny("[(".ToCharArray());
				int num2 = text.LastIndexOfAny("])".ToCharArray());
				if (num > 0 && num != num2)
				{
					text = text.Substring(num);
				}
				CurrentLanguage = text + "(" + value + ")";
			}
		}

		public static string CurrentRegionCode
		{
			get
			{
				string currentLanguageCode = CurrentLanguageCode;
				int num = currentLanguageCode.IndexOfAny(" -_/\\".ToCharArray());
				if (num >= 0)
				{
					return currentLanguageCode.Substring(num + 1);
				}
				return string.Empty;
			}
			set
			{
				string text = CurrentLanguageCode;
				int num = text.IndexOfAny(" -_/\\".ToCharArray());
				if (num > 0)
				{
					text = text.Substring(0, num);
				}
				CurrentLanguageCode = text + "-" + value;
			}
		}

		public static CultureInfo CurrentCulture => mCurrentCulture;

		public static event OnLocalizeCallback OnLocalizeEvent;

		public static void InitializeIfNeeded()
		{
			if (string.IsNullOrEmpty(mCurrentLanguage) || Sources.Count == 0)
			{
				AutoLoadGlobalParamManagers();
				UpdateSources();
				SelectStartupLanguage();
			}
		}

		public static string GetVersion()
		{
			return "2.8.13 f2";
		}

		public static int GetRequiredWebServiceVersion()
		{
			return 5;
		}

		public static string GetWebServiceURL(LanguageSourceData source = null)
		{
			if (source != null && !string.IsNullOrEmpty(source.Google_WebServiceURL))
			{
				return source.Google_WebServiceURL;
			}
			InitializeIfNeeded();
			for (int i = 0; i < Sources.Count; i++)
			{
				if (Sources[i] != null && !string.IsNullOrEmpty(Sources[i].Google_WebServiceURL))
				{
					return Sources[i].Google_WebServiceURL;
				}
			}
			return string.Empty;
		}

		public static void SetLanguageAndCode(string LanguageName, string LanguageCode, bool RememberLanguage = true, bool Force = false)
		{
			if (mCurrentLanguage != LanguageName || mLanguageCode != LanguageCode || Force)
			{
				if (RememberLanguage)
				{
					PersistentStorage.SetSetting_String("I2 Language", LanguageName);
				}
				mCurrentLanguage = LanguageName;
				mLanguageCode = LanguageCode;
				mCurrentCulture = CreateCultureForCode(LanguageCode);
				if (mChangeCultureInfo)
				{
					SetCurrentCultureInfo();
				}
				IsRight2Left = IsRTL(mLanguageCode);
				HasJoinedWords = GoogleLanguages.LanguageCode_HasJoinedWord(mLanguageCode);
				LocalizeAll(Force);
			}
		}

		private static CultureInfo CreateCultureForCode(string code)
		{
			try
			{
				return CultureInfo.CreateSpecificCulture(code);
			}
			catch (Exception)
			{
				return CultureInfo.InvariantCulture;
			}
		}

		public static void EnableChangingCultureInfo(bool bEnable)
		{
			if (!mChangeCultureInfo && bEnable)
			{
				SetCurrentCultureInfo();
			}
			mChangeCultureInfo = bEnable;
		}

		private static void SetCurrentCultureInfo()
		{
			Thread.CurrentThread.CurrentCulture = mCurrentCulture;
		}

		private static void SelectStartupLanguage()
		{
			if (Sources.Count == 0)
			{
				return;
			}
			string setting_String = PersistentStorage.GetSetting_String("I2 Language", string.Empty);
			string currentDeviceLanguage = GetCurrentDeviceLanguage();
			if (!string.IsNullOrEmpty(setting_String) && HasLanguage(setting_String, AllowDiscartingRegion: true, Initialize: false))
			{
				SetLanguageAndCode(setting_String, GetLanguageCode(setting_String));
				return;
			}
			if (!Sources[0].IgnoreDeviceLanguage)
			{
				string supportedLanguage = GetSupportedLanguage(currentDeviceLanguage, ignoreDisabled: true);
				if (!string.IsNullOrEmpty(supportedLanguage))
				{
					SetLanguageAndCode(supportedLanguage, GetLanguageCode(supportedLanguage), RememberLanguage: false);
					return;
				}
			}
			int i = 0;
			for (int count = Sources.Count; i < count; i++)
			{
				if (Sources[i].mLanguages.Count <= 0)
				{
					continue;
				}
				for (int j = 0; j < Sources[i].mLanguages.Count; j++)
				{
					if (Sources[i].mLanguages[j].IsEnabled())
					{
						SetLanguageAndCode(Sources[i].mLanguages[j].Name, Sources[i].mLanguages[j].Code, RememberLanguage: false);
						return;
					}
				}
			}
		}

		public static bool HasLanguage(string Language, bool AllowDiscartingRegion = true, bool Initialize = true, bool SkipDisabled = true)
		{
			if (Initialize)
			{
				InitializeIfNeeded();
			}
			int i = 0;
			for (int count = Sources.Count; i < count; i++)
			{
				if (Sources[i].GetLanguageIndex(Language, AllowDiscartingRegion: false, SkipDisabled) >= 0)
				{
					return true;
				}
			}
			if (AllowDiscartingRegion)
			{
				int j = 0;
				for (int count2 = Sources.Count; j < count2; j++)
				{
					if (Sources[j].GetLanguageIndex(Language, AllowDiscartingRegion: true, SkipDisabled) >= 0)
					{
						return true;
					}
				}
			}
			return false;
		}

		public static string GetSupportedLanguage(string Language, bool ignoreDisabled = false)
		{
			string languageCode = GoogleLanguages.GetLanguageCode(Language);
			if (!string.IsNullOrEmpty(languageCode))
			{
				int i = 0;
				for (int count = Sources.Count; i < count; i++)
				{
					int languageIndexFromCode = Sources[i].GetLanguageIndexFromCode(languageCode, exactMatch: true, ignoreDisabled);
					if (languageIndexFromCode >= 0)
					{
						return Sources[i].mLanguages[languageIndexFromCode].Name;
					}
				}
				int j = 0;
				for (int count2 = Sources.Count; j < count2; j++)
				{
					int languageIndexFromCode2 = Sources[j].GetLanguageIndexFromCode(languageCode, exactMatch: false, ignoreDisabled);
					if (languageIndexFromCode2 >= 0)
					{
						return Sources[j].mLanguages[languageIndexFromCode2].Name;
					}
				}
			}
			int k = 0;
			for (int count3 = Sources.Count; k < count3; k++)
			{
				int languageIndex = Sources[k].GetLanguageIndex(Language, AllowDiscartingRegion: false, ignoreDisabled);
				if (languageIndex >= 0)
				{
					return Sources[k].mLanguages[languageIndex].Name;
				}
			}
			int l = 0;
			for (int count4 = Sources.Count; l < count4; l++)
			{
				int languageIndex2 = Sources[l].GetLanguageIndex(Language, AllowDiscartingRegion: true, ignoreDisabled);
				if (languageIndex2 >= 0)
				{
					return Sources[l].mLanguages[languageIndex2].Name;
				}
			}
			return string.Empty;
		}

		public static string GetLanguageCode(string Language)
		{
			if (Sources.Count == 0)
			{
				UpdateSources();
			}
			int i = 0;
			for (int count = Sources.Count; i < count; i++)
			{
				int languageIndex = Sources[i].GetLanguageIndex(Language);
				if (languageIndex >= 0)
				{
					return Sources[i].mLanguages[languageIndex].Code;
				}
			}
			return string.Empty;
		}

		public static string GetLanguageFromCode(string Code, bool exactMatch = true)
		{
			if (Sources.Count == 0)
			{
				UpdateSources();
			}
			int i = 0;
			for (int count = Sources.Count; i < count; i++)
			{
				int languageIndexFromCode = Sources[i].GetLanguageIndexFromCode(Code, exactMatch);
				if (languageIndexFromCode >= 0)
				{
					return Sources[i].mLanguages[languageIndexFromCode].Name;
				}
			}
			return string.Empty;
		}

		public static List<string> GetAllLanguages(bool SkipDisabled = true)
		{
			if (Sources.Count == 0)
			{
				UpdateSources();
			}
			List<string> Languages = new List<string>();
			int i = 0;
			for (int count = Sources.Count; i < count; i++)
			{
				Languages.AddRange(from x in Sources[i].GetLanguages(SkipDisabled)
					where !Languages.Contains(x)
					select x);
			}
			return Languages;
		}

		public static List<string> GetAllLanguagesCode(bool allowRegions = true, bool SkipDisabled = true)
		{
			List<string> Languages = new List<string>();
			int i = 0;
			for (int count = Sources.Count; i < count; i++)
			{
				Languages.AddRange(from x in Sources[i].GetLanguagesCode(allowRegions, SkipDisabled)
					where !Languages.Contains(x)
					select x);
			}
			return Languages;
		}

		public static bool IsLanguageEnabled(string Language)
		{
			int i = 0;
			for (int count = Sources.Count; i < count; i++)
			{
				if (!Sources[i].IsLanguageEnabled(Language))
				{
					return false;
				}
			}
			return true;
		}

		private static void LoadCurrentLanguage()
		{
			for (int i = 0; i < Sources.Count; i++)
			{
				int languageIndex = Sources[i].GetLanguageIndex(mCurrentLanguage, AllowDiscartingRegion: true, SkipDisabled: false);
				Sources[i].LoadLanguage(languageIndex, UnloadOtherLanguages: true, useFallback: true, onlyCurrentSpecialization: true, forceLoad: false);
			}
		}

		public static void PreviewLanguage(string NewLanguage)
		{
			mCurrentLanguage = NewLanguage;
			mLanguageCode = GetLanguageCode(mCurrentLanguage);
			IsRight2Left = IsRTL(mLanguageCode);
			HasJoinedWords = GoogleLanguages.LanguageCode_HasJoinedWord(mLanguageCode);
		}

		public static void AutoLoadGlobalParamManagers()
		{
			LocalizationParamsManager[] array = UnityEngine.Object.FindObjectsOfType<LocalizationParamsManager>();
			foreach (LocalizationParamsManager localizationParamsManager in array)
			{
				if (localizationParamsManager._IsGlobalManager && !ParamManagers.Contains(localizationParamsManager))
				{
					UnityEngine.Debug.Log(localizationParamsManager);
					ParamManagers.Add(localizationParamsManager);
				}
			}
		}

		public static void ApplyLocalizationParams(ref string translation, bool allowLocalizedParameters = true)
		{
			ApplyLocalizationParams(ref translation, (string p) => GetLocalizationParam(p, null), allowLocalizedParameters);
		}

		public static void ApplyLocalizationParams(ref string translation, GameObject root, bool allowLocalizedParameters = true)
		{
			ApplyLocalizationParams(ref translation, (string p) => GetLocalizationParam(p, root), allowLocalizedParameters);
		}

		public static void ApplyLocalizationParams(ref string translation, Dictionary<string, object> parameters, bool allowLocalizedParameters = true)
		{
			ApplyLocalizationParams(ref translation, delegate(string p)
			{
				object value = null;
				return parameters.TryGetValue(p, out value) ? value : null;
			}, allowLocalizedParameters);
		}

		public static void ApplyLocalizationParams(ref string translation, _GetParam getParam, bool allowLocalizedParameters = true)
		{
			if (translation == null)
			{
				return;
			}
			string text = null;
			int num = 0;
			int length = translation.Length;
			int num2 = 0;
			while (num2 >= 0 && num2 < translation.Length)
			{
				int num3 = translation.IndexOf("{[", num2);
				if (num3 < 0)
				{
					break;
				}
				int num4 = translation.IndexOf("]}", num3);
				if (num4 < 0)
				{
					break;
				}
				int num5 = translation.IndexOf("{[", num3 + 1);
				if (num5 > 0 && num5 < num4)
				{
					num2 = num5;
					continue;
				}
				int num6 = ((translation[num3 + 2] == '#') ? 3 : 2);
				string param = translation.Substring(num3 + num6, num4 - num3 - num6);
				string text2 = (string)getParam(param);
				if (text2 != null && allowLocalizedParameters)
				{
					LanguageSourceData source;
					TermData termData = GetTermData(text2, out source);
					if (termData != null)
					{
						int languageIndex = source.GetLanguageIndex(CurrentLanguage);
						if (languageIndex >= 0)
						{
							text2 = termData.GetTranslation(languageIndex);
						}
					}
					string oldValue = translation.Substring(num3, num4 - num3 + 2);
					translation = translation.Replace(oldValue, text2);
					int result = 0;
					if (int.TryParse(text2, out result))
					{
						text = GoogleLanguages.GetPluralType(CurrentLanguageCode, result).ToString();
					}
					num2 = num3 + text2.Length;
				}
				else
				{
					num2 = num4 + 2;
				}
			}
			if (text != null)
			{
				string text3 = "[i2p_" + text + "]";
				num = translation.IndexOf(text3, StringComparison.OrdinalIgnoreCase);
				num = ((num >= 0) ? (num + text3.Length) : 0);
				length = translation.IndexOf("[i2p_", num + 1, StringComparison.OrdinalIgnoreCase);
				if (length < 0)
				{
					length = translation.Length;
				}
				translation = translation.Substring(num, length - num);
			}
		}

		internal static string GetLocalizationParam(string ParamName, GameObject root)
		{
			string text = null;
			if ((bool)root)
			{
				MonoBehaviour[] components = root.GetComponents<MonoBehaviour>();
				int i = 0;
				for (int num = components.Length; i < num; i++)
				{
					if (components[i] is ILocalizationParamsManager localizationParamsManager && components[i].enabled)
					{
						text = localizationParamsManager.GetParameterValue(ParamName);
						if (text != null)
						{
							return text;
						}
					}
				}
			}
			int j = 0;
			for (int count = ParamManagers.Count; j < count; j++)
			{
				text = ParamManagers[j].GetParameterValue(ParamName);
				if (text != null)
				{
					return text;
				}
			}
			return null;
		}

		private static string GetPluralType(MatchCollection matches, string langCode, _GetParam getParam)
		{
			int i = 0;
			for (int count = matches.Count; i < count; i++)
			{
				Match match = matches[i];
				string value = match.Groups[match.Groups.Count - 1].Value;
				string text = (string)getParam(value);
				if (text != null)
				{
					int result = 0;
					if (int.TryParse(text, out result))
					{
						return GoogleLanguages.GetPluralType(langCode, result).ToString();
					}
				}
			}
			return null;
		}

		public static string ApplyRTLfix(string line)
		{
			return ApplyRTLfix(line, 0, ignoreNumbers: true);
		}

		public static string ApplyRTLfix(string line, int maxCharacters, bool ignoreNumbers)
		{
			if (string.IsNullOrEmpty(line))
			{
				return line;
			}
			char c = line[0];
			if (c == '!' || c == '.' || c == '?')
			{
				line = line.Substring(1) + c;
			}
			int tagStart = -1;
			int num = 0;
			int num2 = 40000;
			num = 0;
			List<string> list = new List<string>();
			while (I2Utils.FindNextTag(line, num, out tagStart, out num))
			{
				string text = "@@" + (char)(num2 + list.Count) + "@@";
				list.Add(line.Substring(tagStart, num - tagStart + 1));
				line = line.Substring(0, tagStart) + text + line.Substring(num + 1);
				num = tagStart + 5;
			}
			line = line.Replace("\r\n", "\n");
			line = I2Utils.SplitLine(line, maxCharacters);
			line = RTLFixer.Fix(line, showTashkeel: true, !ignoreNumbers);
			for (int i = 0; i < list.Count; i++)
			{
				int length = line.Length;
				for (int j = 0; j < length; j++)
				{
					if (line[j] == '@' && line[j + 1] == '@' && line[j + 2] >= num2 && line[j + 3] == '@' && line[j + 4] == '@')
					{
						int num3 = line[j + 2] - num2;
						num3 = ((num3 % 2 != 0) ? (num3 - 1) : (num3 + 1));
						if (num3 >= list.Count)
						{
							num3 = list.Count - 1;
						}
						line = line.Substring(0, j) + list[num3] + line.Substring(j + 5);
						break;
					}
				}
			}
			return line;
		}

		public static string FixRTL_IfNeeded(string text, int maxCharacters = 0, bool ignoreNumber = false)
		{
			if (IsRight2Left)
			{
				return ApplyRTLfix(text, maxCharacters, ignoreNumber);
			}
			return text;
		}

		public static bool IsRTL(string Code)
		{
			return Array.IndexOf(LanguagesRTL, Code) >= 0;
		}

		public static bool UpdateSources()
		{
			UnregisterDeletededSources();
			RegisterSourceInResources();
			RegisterSceneSources();
			return Sources.Count > 0;
		}

		private static void UnregisterDeletededSources()
		{
			for (int num = Sources.Count - 1; num >= 0; num--)
			{
				if (Sources[num] == null)
				{
					RemoveSource(Sources[num]);
				}
			}
		}

		private static void RegisterSceneSources()
		{
			LanguageSource[] array = (LanguageSource[])Resources.FindObjectsOfTypeAll(typeof(LanguageSource));
			foreach (LanguageSource languageSource in array)
			{
				if (!Sources.Contains(languageSource.mSource))
				{
					if (languageSource.mSource.owner == null)
					{
						languageSource.mSource.owner = languageSource;
					}
					AddSource(languageSource.mSource);
				}
			}
		}

		private static void RegisterSourceInResources()
		{
			string[] globalSources = GlobalSources;
			foreach (string name in globalSources)
			{
				LanguageSourceAsset asset = ResourceManager.pInstance.GetAsset<LanguageSourceAsset>(name);
				if ((bool)asset && !Sources.Contains(asset.mSource))
				{
					if (!asset.mSource.mIsGlobalSource)
					{
						asset.mSource.mIsGlobalSource = true;
					}
					asset.mSource.owner = asset;
					AddSource(asset.mSource);
				}
			}
		}

		internal static void AddSource(LanguageSourceData Source)
		{
			if (Sources.Contains(Source))
			{
				return;
			}
			Sources.Add(Source);
			if (Source.HasGoogleSpreadsheet() && Source.GoogleUpdateFrequency != LanguageSourceData.eGoogleUpdateFrequency.Never)
			{
				Source.Import_Google_FromCache();
				bool justCheck = false;
				if (Source.GoogleUpdateDelay > 0f)
				{
					CoroutineManager.Start(Delayed_Import_Google(Source, Source.GoogleUpdateDelay, justCheck));
				}
				else
				{
					Source.Import_Google(ForceUpdate: false, justCheck);
				}
			}
			for (int i = 0; i < Source.mLanguages.Count(); i++)
			{
				Source.mLanguages[i].SetLoaded(loaded: true);
			}
			if (Source.mDictionary.Count == 0)
			{
				Source.UpdateDictionary(force: true);
			}
		}

		private static IEnumerator Delayed_Import_Google(LanguageSourceData source, float delay, bool justCheck)
		{
			yield return new WaitForSeconds(delay);
			source?.Import_Google(ForceUpdate: false, justCheck);
		}

		internal static void RemoveSource(LanguageSourceData Source)
		{
			Sources.Remove(Source);
		}

		public static bool IsGlobalSource(string SourceName)
		{
			return Array.IndexOf(GlobalSources, SourceName) >= 0;
		}

		public static LanguageSourceData GetSourceContaining(string term, bool fallbackToFirst = true)
		{
			if (!string.IsNullOrEmpty(term))
			{
				int i = 0;
				for (int count = Sources.Count; i < count; i++)
				{
					if (Sources[i].GetTermData(term) != null)
					{
						return Sources[i];
					}
				}
			}
			if (!fallbackToFirst || Sources.Count <= 0)
			{
				return null;
			}
			return Sources[0];
		}

		public static UnityEngine.Object FindAsset(string value)
		{
			int i = 0;
			for (int count = Sources.Count; i < count; i++)
			{
				UnityEngine.Object @object = Sources[i].FindAsset(value);
				if ((bool)@object)
				{
					return @object;
				}
			}
			return null;
		}

		public static void ApplyDownloadedDataFromGoogle()
		{
			int i = 0;
			for (int count = Sources.Count; i < count; i++)
			{
				Sources[i].ApplyDownloadedDataFromGoogle();
			}
		}

		public static string GetCurrentDeviceLanguage(bool force = false)
		{
			if (force || string.IsNullOrEmpty(mCurrentDeviceLanguage))
			{
				DetectDeviceLanguage();
			}
			return mCurrentDeviceLanguage;
		}

		private static void DetectDeviceLanguage()
		{
			try
			{
				mCurrentDeviceLanguage = new AndroidJavaClass("java/util/Locale").CallStatic<AndroidJavaObject>("getDefault", Array.Empty<object>()).Call<string>("toString", Array.Empty<object>());
				if (!string.IsNullOrEmpty(mCurrentDeviceLanguage))
				{
					mCurrentDeviceLanguage = mCurrentDeviceLanguage.Replace('_', '-');
					mCurrentDeviceLanguage = GoogleLanguages.GetLanguageName(mCurrentDeviceLanguage, useParenthesesForRegion: true);
					if (!string.IsNullOrEmpty(mCurrentDeviceLanguage))
					{
						return;
					}
				}
			}
			catch (Exception)
			{
			}
			mCurrentDeviceLanguage = UnityEngine.Application.systemLanguage.ToString();
			if (mCurrentDeviceLanguage == "ChineseSimplified")
			{
				mCurrentDeviceLanguage = "Chinese (Simplified)";
			}
			if (mCurrentDeviceLanguage == "ChineseTraditional")
			{
				mCurrentDeviceLanguage = "Chinese (Traditional)";
			}
		}

		public static void RegisterTarget(ILocalizeTargetDescriptor desc)
		{
			if (mLocalizeTargets.FindIndex((ILocalizeTargetDescriptor x) => x.Name == desc.Name) != -1)
			{
				return;
			}
			for (int i = 0; i < mLocalizeTargets.Count; i++)
			{
				if (mLocalizeTargets[i].Priority > desc.Priority)
				{
					mLocalizeTargets.Insert(i, desc);
					return;
				}
			}
			mLocalizeTargets.Add(desc);
		}

		public static string GetTranslation(string Term, bool FixForRTL = true, int maxLineLengthForRTL = 0, bool ignoreRTLnumbers = true, bool applyParameters = false, GameObject localParametersRoot = null, string overrideLanguage = null)
		{
			string Translation = null;
			TryGetTranslation(Term, out Translation, FixForRTL, maxLineLengthForRTL, ignoreRTLnumbers, applyParameters, localParametersRoot, overrideLanguage);
			return Translation;
		}

		public static string GetTermTranslation(string Term, bool FixForRTL = true, int maxLineLengthForRTL = 0, bool ignoreRTLnumbers = true, bool applyParameters = false, GameObject localParametersRoot = null, string overrideLanguage = null)
		{
			return GetTranslation(Term, FixForRTL, maxLineLengthForRTL, ignoreRTLnumbers, applyParameters, localParametersRoot, overrideLanguage);
		}

		public static bool TryGetTranslation(string Term, out string Translation, bool FixForRTL = true, int maxLineLengthForRTL = 0, bool ignoreRTLnumbers = true, bool applyParameters = false, GameObject localParametersRoot = null, string overrideLanguage = null)
		{
			Translation = null;
			if (string.IsNullOrEmpty(Term))
			{
				return false;
			}
			InitializeIfNeeded();
			int i = 0;
			for (int count = Sources.Count; i < count; i++)
			{
				if (Sources[i].TryGetTranslation(Term, out Translation, overrideLanguage))
				{
					if (applyParameters)
					{
						ApplyLocalizationParams(ref Translation, localParametersRoot);
					}
					if (IsRight2Left && FixForRTL)
					{
						Translation = ApplyRTLfix(Translation, maxLineLengthForRTL, ignoreRTLnumbers);
					}
					return true;
				}
			}
			return false;
		}

		public static T GetTranslatedObject<T>(string AssetName, Localize optionalLocComp = null) where T : UnityEngine.Object
		{
			if (optionalLocComp != null)
			{
				return optionalLocComp.FindTranslatedObject<T>(AssetName);
			}
			T val = FindAsset(AssetName) as T;
			if ((bool)val)
			{
				return val;
			}
			return ResourceManager.pInstance.GetAsset<T>(AssetName);
		}

		public static T GetTranslatedObjectByTermName<T>(string Term, Localize optionalLocComp = null) where T : UnityEngine.Object
		{
			return GetTranslatedObject<T>(GetTranslation(Term, FixForRTL: false));
		}

		public static string GetAppName(string languageCode)
		{
			if (!string.IsNullOrEmpty(languageCode))
			{
				for (int i = 0; i < Sources.Count; i++)
				{
					if (string.IsNullOrEmpty(Sources[i].mTerm_AppName))
					{
						continue;
					}
					int languageIndexFromCode = Sources[i].GetLanguageIndexFromCode(languageCode, exactMatch: false);
					if (languageIndexFromCode < 0)
					{
						continue;
					}
					TermData termData = Sources[i].GetTermData(Sources[i].mTerm_AppName);
					if (termData != null)
					{
						string translation = termData.GetTranslation(languageIndexFromCode);
						if (!string.IsNullOrEmpty(translation))
						{
							return translation;
						}
					}
				}
			}
			return UnityEngine.Application.productName;
		}

		public static void LocalizeAll(bool Force = false)
		{
			LoadCurrentLanguage();
			if (!UnityEngine.Application.isPlaying)
			{
				DoLocalizeAll(Force);
				return;
			}
			mLocalizeIsScheduledWithForcedValue |= Force;
			if (!mLocalizeIsScheduled)
			{
				CoroutineManager.Start(Coroutine_LocalizeAll());
			}
		}

		private static IEnumerator Coroutine_LocalizeAll()
		{
			mLocalizeIsScheduled = true;
			yield return null;
			mLocalizeIsScheduled = false;
			bool force = mLocalizeIsScheduledWithForcedValue;
			mLocalizeIsScheduledWithForcedValue = false;
			DoLocalizeAll(force);
		}

		private static void DoLocalizeAll(bool Force = false)
		{
			Localize[] array = (Localize[])Resources.FindObjectsOfTypeAll(typeof(Localize));
			int i = 0;
			for (int num = array.Length; i < num; i++)
			{
				array[i].OnLocalize(Force);
			}
			if (LocalizationManager.OnLocalizeEvent != null)
			{
				LocalizationManager.OnLocalizeEvent();
			}
		}

		public static List<string> GetCategories()
		{
			List<string> list = new List<string>();
			int i = 0;
			for (int count = Sources.Count; i < count; i++)
			{
				Sources[i].GetCategories(OnlyMainCategory: false, list);
			}
			return list;
		}

		public static List<string> GetTermsList(string Category = null)
		{
			if (Sources.Count == 0)
			{
				UpdateSources();
			}
			if (Sources.Count == 1)
			{
				return Sources[0].GetTermsList(Category);
			}
			HashSet<string> hashSet = new HashSet<string>();
			int i = 0;
			for (int count = Sources.Count; i < count; i++)
			{
				hashSet.UnionWith(Sources[i].GetTermsList(Category));
			}
			return new List<string>(hashSet);
		}

		public static TermData GetTermData(string term)
		{
			InitializeIfNeeded();
			int i = 0;
			for (int count = Sources.Count; i < count; i++)
			{
				TermData termData = Sources[i].GetTermData(term);
				if (termData != null)
				{
					return termData;
				}
			}
			return null;
		}

		public static TermData GetTermData(string term, out LanguageSourceData source)
		{
			InitializeIfNeeded();
			int i = 0;
			for (int count = Sources.Count; i < count; i++)
			{
				TermData termData = Sources[i].GetTermData(term);
				if (termData != null)
				{
					source = Sources[i];
					return termData;
				}
			}
			source = null;
			return null;
		}
	}
	public abstract class ILocalizeTarget : ScriptableObject
	{
		public abstract bool IsValid(Localize cmp);

		public abstract void GetFinalTerms(Localize cmp, string Main, string Secondary, out string primaryTerm, out string secondaryTerm);

		public abstract void DoLocalize(Localize cmp, string mainTranslation, string secondaryTranslation);

		public abstract bool CanUseSecondaryTerm();

		public abstract bool AllowMainTermToBeRTL();

		public abstract bool AllowSecondTermToBeRTL();

		public abstract eTermType GetPrimaryTermType(Localize cmp);

		public abstract eTermType GetSecondaryTermType(Localize cmp);
	}
	public abstract class LocalizeTarget<T> : ILocalizeTarget where T : UnityEngine.Object
	{
		public T mTarget;

		public override bool IsValid(Localize cmp)
		{
			if (mTarget != null)
			{
				Component component = mTarget as Component;
				if (component != null && component.gameObject != cmp.gameObject)
				{
					mTarget = null;
				}
			}
			if (mTarget == null)
			{
				mTarget = cmp.GetComponent<T>();
			}
			return mTarget != null;
		}
	}
	public abstract class ILocalizeTargetDescriptor
	{
		public string Name;

		public int Priority;

		public abstract bool CanLocalize(Localize cmp);

		public abstract ILocalizeTarget CreateTarget(Localize cmp);

		public abstract Type GetTargetType();
	}
	public abstract class LocalizeTargetDesc<T> : ILocalizeTargetDescriptor where T : ILocalizeTarget
	{
		public override ILocalizeTarget CreateTarget(Localize cmp)
		{
			return ScriptableObject.CreateInstance<T>();
		}

		public override Type GetTargetType()
		{
			return typeof(T);
		}
	}
	public class LocalizeTargetDesc_Type<T, G> : LocalizeTargetDesc<G> where T : UnityEngine.Object where G : LocalizeTarget<T>
	{
		public override bool CanLocalize(Localize cmp)
		{
			return cmp.GetComponent<T>() != null;
		}

		public override ILocalizeTarget CreateTarget(Localize cmp)
		{
			T component = cmp.GetComponent<T>();
			if (component == null)
			{
				return null;
			}
			G val = ScriptableObject.CreateInstance<G>();
			val.mTarget = component;
			return val;
		}
	}
	public class LocalizeTarget_TextMeshPro_Label : LocalizeTarget<TextMeshPro>
	{
		private TextAlignmentOptions mAlignment_RTL = TextAlignmentOptions.Right;

		private TextAlignmentOptions mAlignment_LTR = TextAlignmentOptions.Left;

		private bool mAlignmentWasRTL;

		private bool mInitializeAlignment = true;

		static LocalizeTarget_TextMeshPro_Label()
		{
			AutoRegister();
		}

		[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
		private static void AutoRegister()
		{
			LocalizationManager.RegisterTarget(new LocalizeTargetDesc_Type<TextMeshPro, LocalizeTarget_TextMeshPro_Label>
			{
				Name = "TextMeshPro Label",
				Priority = 100
			});
		}

		public override eTermType GetPrimaryTermType(Localize cmp)
		{
			return eTermType.Text;
		}

		public override eTermType GetSecondaryTermType(Localize cmp)
		{
			return eTermType.Font;
		}

		public override bool CanUseSecondaryTerm()
		{
			return true;
		}

		public override bool AllowMainTermToBeRTL()
		{
			return true;
		}

		public override bool AllowSecondTermToBeRTL()
		{
			return false;
		}

		public override void GetFinalTerms(Localize cmp, string Main, string Secondary, out string primaryTerm, out string secondaryTerm)
		{
			primaryTerm = (mTarget ? mTarget.text : null);
			secondaryTerm = ((mTarget.font != null) ? mTarget.font.name : string.Empty);
		}

		public override void DoLocalize(Localize cmp, string mainTranslation, string secondaryTranslation)
		{
			TMP_FontAsset secondaryTranslatedObj = cmp.GetSecondaryTranslatedObj<TMP_FontAsset>(ref mainTranslation, ref secondaryTranslation);
			if (secondaryTranslatedObj != null)
			{
				SetFont(mTarget, secondaryTranslatedObj);
			}
			else
			{
				Material secondaryTranslatedObj2 = cmp.GetSecondaryTranslatedObj<Material>(ref mainTranslation, ref secondaryTranslation);
				if (secondaryTranslatedObj2 != null && mTarget.fontMaterial != secondaryTranslatedObj2)
				{
					if (!secondaryTranslatedObj2.name.StartsWith(mTarget.font.name, StringComparison.Ordinal))
					{
						secondaryTranslatedObj = GetTMPFontFromMaterial(cmp, secondaryTranslation.EndsWith(secondaryTranslatedObj2.name, StringComparison.Ordinal) ? secondaryTranslation : secondaryTranslatedObj2.name);
						if (secondaryTranslatedObj != null)
						{
							SetFont(mTarget, secondaryTranslatedObj);
						}
					}
					SetMaterial(mTarget, secondaryTranslatedObj2);
				}
			}
			if (mInitializeAlignment)
			{
				mInitializeAlignment = false;
				mAlignmentWasRTL = LocalizationManager.IsRight2Left;
				InitAlignment_TMPro(mAlignmentWasRTL, mTarget.alignment, out mAlignment_LTR, out mAlignment_RTL);
			}
			else
			{
				InitAlignment_TMPro(mAlignmentWasRTL, mTarget.alignment, out var alignLTR, out var alignRTL);
				if ((mAlignmentWasRTL && mAlignment_RTL != alignRTL) || (!mAlignmentWasRTL && mAlignment_LTR != alignLTR))
				{
					mAlignment_LTR = alignLTR;
					mAlignment_RTL = alignRTL;
				}
				mAlignmentWasRTL = LocalizationManager.IsRight2Left;
			}
			if (mainTranslation == null || !(mTarget.text != mainTranslation))
			{
				return;
			}
			if (mainTranslation != null && cmp.CorrectAlignmentForRTL)
			{
				mTarget.alignment = (LocalizationManager.IsRight2Left ? mAlignment_RTL : mAlignment_LTR);
				mTarget.isRightToLeftText = LocalizationManager.IsRight2Left;
				if (LocalizationManager.IsRight2Left)
				{
					mainTranslation = I2Utils.ReverseText(mainTranslation);
				}
			}
			mTarget.text = mainTranslation;
		}

		internal static TMP_FontAsset GetTMPFontFromMaterial(Localize cmp, string matName)
		{
			string text = " .\\/-[]()";
			int num = matName.Length - 1;
			while (num > 0)
			{
				while (num > 0 && text.IndexOf(matName[num]) >= 0)
				{
					num--;
				}
				if (num <= 0)
				{
					break;
				}
				string translation = matName.Substring(0, num + 1);
				TMP_FontAsset @object = cmp.GetObject<TMP_FontAsset>(translation);
				if (@object != null)
				{
					return @object;
				}
				while (num > 0 && text.IndexOf(matName[num]) < 0)
				{
					num--;
				}
			}
			return null;
		}

		internal static void InitAlignment_TMPro(bool isRTL, TextAlignmentOptions alignment, out TextAlignmentOptions alignLTR, out TextAlignmentOptions alignRTL)
		{
			alignLTR = (alignRTL = alignment);
			if (isRTL)
			{
				switch (alignment)
				{
				case TextAlignmentOptions.TopRight:
					alignLTR = TextAlignmentOptions.TopLeft;
					break;
				case TextAlignmentOptions.Right:
					alignLTR = TextAlignmentOptions.Left;
					break;
				case TextAlignmentOptions.BottomRight:
					alignLTR = TextAlignmentOptions.BottomLeft;
					break;
				case TextAlignmentOptions.BaselineRight:
					alignLTR = TextAlignmentOptions.BaselineLeft;
					break;
				case TextAlignmentOptions.MidlineRight:
					alignLTR = TextAlignmentOptions.MidlineLeft;
					break;
				case TextAlignmentOptions.CaplineRight:
					alignLTR = TextAlignmentOptions.CaplineLeft;
					break;
				case TextAlignmentOptions.TopLeft:
					alignLTR = TextAlignmentOptions.TopRight;
					break;
				case TextAlignmentOptions.Left:
					alignLTR = TextAlignmentOptions.Right;
					break;
				case TextAlignmentOptions.BottomLeft:
					alignLTR = TextAlignmentOptions.BottomRight;
					break;
				case TextAlignmentOptions.BaselineLeft:
					alignLTR = TextAlignmentOptions.BaselineRight;
					break;
				case TextAlignmentOptions.MidlineLeft:
					alignLTR = TextAlignmentOptions.MidlineRight;
					break;
				case TextAlignmentOptions.CaplineLeft:
					alignLTR = TextAlignmentOptions.CaplineRight;
					break;
				}
			}
			else
			{
				switch (alignment)
				{
				case TextAlignmentOptions.TopRight:
					alignRTL = TextAlignmentOptions.TopLeft;
					break;
				case TextAlignmentOptions.Right:
					alignRTL = TextAlignmentOptions.Left;
					break;
				case TextAlignmentOptions.BottomRight:
					alignRTL = TextAlignmentOptions.BottomLeft;
					break;
				case TextAlignmentOptions.BaselineRight:
					alignRTL = TextAlignmentOptions.BaselineLeft;
					break;
				case TextAlignmentOptions.MidlineRight:
					alignRTL = TextAlignmentOptions.MidlineLeft;
					break;
				case TextAlignmentOptions.CaplineRight:
					alignRTL = TextAlignmentOptions.CaplineLeft;
					break;
				case TextAlignmentOptions.TopLeft:
					alignRTL = TextAlignmentOptions.TopRight;
					break;
				case TextAlignmentOptions.Left:
					alignRTL = TextAlignmentOptions.Right;
					break;
				case TextAlignmentOptions.BottomLeft:
					alignRTL = TextAlignmentOptions.BottomRight;
					break;
				case TextAlignmentOptions.BaselineLeft:
					alignRTL = TextAlignmentOptions.BaselineRight;
					break;
				case TextAlignmentOptions.MidlineLeft:
					alignRTL = TextAlignmentOptions.MidlineRight;
					break;
				case TextAlignmentOptions.CaplineLeft:
					alignRTL = TextAlignmentOptions.CaplineRight;
					break;
				}
			}
		}

		internal static void SetFont(TMP_Text label, TMP_FontAsset newFont)
		{
			if (label.font != newFont)
			{
				label.font = newFont;
			}
			if (label.linkedTextComponent != null)
			{
				SetFont(label.linkedTextComponent, newFont);
			}
		}

		internal static void SetMaterial(TMP_Text label, Material newMat)
		{
			if (label.fontSharedMaterial != newMat)
			{
				label.fontSharedMaterial = newMat;
			}
			if (label.linkedTextComponent != null)
			{
				SetMaterial(label.linkedTextComponent, newMat);
			}
		}
	}
	public class LocalizeTarget_TextMeshPro_UGUI : LocalizeTarget<TextMeshProUGUI>
	{
		public TextAlignmentOptions mAlignment_RTL = TextAlignmentOptions.Right;

		public TextAlignmentOptions mAlignment_LTR = TextAlignmentOptions.Left;

		public bool mAlignmentWasRTL;

		public bool mInitializeAlignment = true;

		static LocalizeTarget_TextMeshPro_UGUI()
		{
			AutoRegister();
		}

		[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
		private static void AutoRegister()
		{
			LocalizationManager.RegisterTarget(new LocalizeTargetDesc_Type<TextMeshProUGUI, LocalizeTarget_TextMeshPro_UGUI>
			{
				Name = "TextMeshPro UGUI",
				Priority = 100
			});
		}

		public override eTermType GetPrimaryTermType(Localize cmp)
		{
			return eTermType.Text;
		}

		public override eTermType GetSecondaryTermType(Localize cmp)
		{
			return eTermType.TextMeshPFont;
		}

		public override bool CanUseSecondaryTerm()
		{
			return true;
		}

		public override bool AllowMainTermToBeRTL()
		{
			return true;
		}

		public override bool AllowSecondTermToBeRTL()
		{
			return false;
		}

		public override void GetFinalTerms(Localize cmp, string Main, string Secondary, out string primaryTerm, out string secondaryTerm)
		{
			primaryTerm = (mTarget ? mTarget.text : null);
			secondaryTerm = ((mTarget.font != null) ? mTarget.font.name : string.Empty);
		}

		public override void DoLocalize(Localize cmp, string mainTranslation, string secondaryTranslation)
		{
			TMP_FontAsset secondaryTranslatedObj = cmp.GetSecondaryTranslatedObj<TMP_FontAsset>(ref mainTranslation, ref secondaryTranslation);
			if (secondaryTranslatedObj != null)
			{
				LocalizeTarget_TextMeshPro_Label.SetFont(mTarget, secondaryTranslatedObj);
			}
			else
			{
				Material secondaryTranslatedObj2 = cmp.GetSecondaryTranslatedObj<Material>(ref mainTranslation, ref secondaryTranslation);
				if (secondaryTranslatedObj2 != null && mTarget.fontMaterial != secondaryTranslatedObj2)
				{
					if (!secondaryTranslatedObj2.name.StartsWith(mTarget.font.name, StringComparison.Ordinal))
					{
						secondaryTranslatedObj = LocalizeTarget_TextMeshPro_Label.GetTMPFontFromMaterial(cmp, secondaryTranslation.EndsWith(secondaryTranslatedObj2.name, StringComparison.Ordinal) ? secondaryTranslation : secondaryTranslatedObj2.name);
						if (secondaryTranslatedObj != null)
						{
							LocalizeTarget_TextMeshPro_Label.SetFont(mTarget, secondaryTranslatedObj);
						}
					}
					LocalizeTarget_TextMeshPro_Label.SetMaterial(mTarget, secondaryTranslatedObj2);
				}
			}
			if (mInitializeAlignment)
			{
				mInitializeAlignment = false;
				mAlignmentWasRTL = LocalizationManager.IsRight2Left;
				LocalizeTarget_TextMeshPro_Label.InitAlignment_TMPro(mAlignmentWasRTL, mTarget.alignment, out mAlignment_LTR, out mAlignment_RTL);
			}
			else
			{
				LocalizeTarget_TextMeshPro_Label.InitAlignment_TMPro(mAlignmentWasRTL, mTarget.alignment, out var alignLTR, out var alignRTL);
				if ((mAlignmentWasRTL && mAlignment_RTL != alignRTL) || (!mAlignmentWasRTL && mAlignment_LTR != alignLTR))
				{
					mAlignment_LTR = alignLTR;
					mAlignment_RTL = alignRTL;
				}
				mAlignmentWasRTL = LocalizationManager.IsRight2Left;
			}
			if (mainTranslation == null || !(mTarget.text != mainTranslation))
			{
				return;
			}
			if (mainTranslation != null && cmp.CorrectAlignmentForRTL)
			{
				mTarget.alignment = (LocalizationManager.IsRight2Left ? mAlignment_RTL : mAlignment_LTR);
				mTarget.isRightToLeftText = LocalizationManager.IsRight2Left;
				if (LocalizationManager.IsRight2Left)
				{
					mainTranslation = I2Utils.ReverseText(mainTranslation);
				}
			}
			mTarget.text = mainTranslation;
		}
	}
	public class LocalizeTarget_UnityStandard_AudioSource : LocalizeTarget<AudioSource>
	{
		static LocalizeTarget_UnityStandard_AudioSource()
		{
			AutoRegister();
		}

		[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
		private static void AutoRegister()
		{
			LocalizationManager.RegisterTarget(new LocalizeTargetDesc_Type<AudioSource, LocalizeTarget_UnityStandard_AudioSource>
			{
				Name = "AudioSource",
				Priority = 100
			});
		}

		public override eTermType GetPrimaryTermType(Localize cmp)
		{
			return eTermType.AudioClip;
		}

		public override eTermType GetSecondaryTermType(Localize cmp)
		{
			return eTermType.Text;
		}

		public override bool CanUseSecondaryTerm()
		{
			return false;
		}

		public override bool AllowMainTermToBeRTL()
		{
			return false;
		}

		public override bool AllowSecondTermToBeRTL()
		{
			return false;
		}

		public override void GetFinalTerms(Localize cmp, string Main, string Secondary, out string primaryTerm, out string secondaryTerm)
		{
			primaryTerm = (mTarget.clip ? mTarget.clip.name : string.Empty);
			secondaryTerm = null;
		}

		public override void DoLocalize(Localize cmp, string mainTranslation, string secondaryTranslation)
		{
			bool num = (mTarget.isPlaying || mTarget.loop) && UnityEngine.Application.isPlaying;
			AudioClip clip = mTarget.clip;
			AudioClip audioClip = cmp.FindTranslatedObject<AudioClip>(mainTranslation);
			if (clip != audioClip)
			{
				mTarget.clip = audioClip;
			}
			if (num && (bool)mTarget.clip)
			{
				mTarget.Play();
			}
		}
	}
	public class LocalizeTargetDesc_Child : LocalizeTargetDesc<LocalizeTarget_UnityStandard_Child>
	{
		public override bool CanLocalize(Localize cmp)
		{
			return cmp.transform.childCount > 1;
		}
	}
	public class LocalizeTarget_UnityStandard_Child : LocalizeTarget<GameObject>
	{
		static LocalizeTarget_UnityStandard_Child()
		{
			AutoRegister();
		}

		[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
		private static void AutoRegister()
		{
			LocalizationManager.RegisterTarget(new LocalizeTargetDesc_Child
			{
				Name = "Child",
				Priority = 200
			});
		}

		public override bool IsValid(Localize cmp)
		{
			return cmp.transform.childCount > 1;
		}

		public override eTermType GetPrimaryTermType(Localize cmp)
		{
			return eTermType.GameObject;
		}

		public override eTermType GetSecondaryTermType(Localize cmp)
		{
			return eTermType.Text;
		}

		public override bool CanUseSecondaryTerm()
		{
			return false;
		}

		public override bool AllowMainTermToBeRTL()
		{
			return false;
		}

		public override bool AllowSecondTermToBeRTL()
		{
			return false;
		}

		public override void GetFinalTerms(Localize cmp, string Main, string Secondary, out string primaryTerm, out string secondaryTerm)
		{
			primaryTerm = cmp.name;
			secondaryTerm = null;
		}

		public override void DoLocalize(Localize cmp, string mainTranslation, string secondaryTranslation)
		{
			if (!string.IsNullOrEmpty(mainTranslation))
			{
				Transform transform = cmp.transform;
				string text = mainTranslation;
				int num = mainTranslation.LastIndexOfAny(LanguageSourceData.CategorySeparators);
				if (num >= 0)
				{
					text = text.Substring(num + 1);
				}
				for (int i = 0; i < transform.childCount; i++)
				{
					Transform child = transform.GetChild(i);
					child.gameObject.SetActive(child.name == text);
				}
			}
		}
	}
	public class LocalizeTarget_UnityStandard_MeshRenderer : LocalizeTarget<MeshRenderer>
	{
		static LocalizeTarget_UnityStandard_MeshRenderer()
		{
			AutoRegister();
		}

		[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
		private static void AutoRegister()
		{
			LocalizationManager.RegisterTarget(new LocalizeTargetDesc_Type<MeshRenderer, LocalizeTarget_UnityStandard_MeshRenderer>
			{
				Name = "MeshRenderer",
				Priority = 800
			});
		}

		public override eTermType GetPrimaryTermType(Localize cmp)
		{
			return eTermType.Mesh;
		}

		public override eTermType GetSecondaryTermType(Localize cmp)
		{
			return eTermType.Material;
		}

		public override bool CanUseSecondaryTerm()
		{
			return true;
		}

		public override bool AllowMainTermToBeRTL()
		{
			return false;
		}

		public override bool AllowSecondTermToBeRTL()
		{
			return false;
		}

		public override void GetFinalTerms(Localize cmp, string Main, string Secondary, out string primaryTerm, out string secondaryTerm)
		{
			if (mTarget == null)
			{
				primaryTerm = (secondaryTerm = null);
			}
			else
			{
				MeshFilter component = mTarget.GetComponent<MeshFilter>();
				if (component == null || component.sharedMesh == null)
				{
					primaryTerm = null;
				}
				else
				{
					primaryTerm = component.sharedMesh.name;
				}
			}
			if (mTarget == null || mTarget.sharedMaterial == null)
			{
				secondaryTerm = null;
			}
			else
			{
				secondaryTerm = mTarget.sharedMaterial.name;
			}
		}

		public override void DoLocalize(Localize cmp, string mainTranslation, string secondaryTranslation)
		{
			Material secondaryTranslatedObj = cmp.GetSecondaryTranslatedObj<Material>(ref mainTranslation, ref secondaryTranslation);
			if (secondaryTranslatedObj != null && mTarget.sharedMaterial != secondaryTranslatedObj)
			{
				mTarget.material = secondaryTranslatedObj;
			}
			Mesh mesh = cmp.FindTranslatedObject<Mesh>(mainTranslation);
			MeshFilter component = mTarget.GetComponent<MeshFilter>();
			if (mesh != null && component.sharedMesh != mesh)
			{
				component.mesh = mesh;
			}
		}
	}
	public class LocalizeTargetDesc_Prefab : LocalizeTargetDesc<LocalizeTarget_UnityStandard_Prefab>
	{
		public override bool CanLocalize(Localize cmp)
		{
			return true;
		}
	}
	public class LocalizeTarget_UnityStandard_Prefab : LocalizeTarget<GameObject>
	{
		static LocalizeTarget_UnityStandard_Prefab()
		{
			AutoRegister();
		}

		[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
		private static void AutoRegister()
		{
			LocalizationManager.RegisterTarget(new LocalizeTargetDesc_Prefab
			{
				Name = "Prefab",
				Priority = 250
			});
		}

		public override bool IsValid(Localize cmp)
		{
			return true;
		}

		public override eTermType GetPrimaryTermType(Localize cmp)
		{
			return eTermType.GameObject;
		}

		public override eTermType GetSecondaryTermType(Localize cmp)
		{
			return eTermType.Text;
		}

		public override bool CanUseSecondaryTerm()
		{
			return false;
		}

		public override bool AllowMainTermToBeRTL()
		{
			return false;
		}

		public override bool AllowSecondTermToBeRTL()
		{
			return false;
		}

		public override void GetFinalTerms(Localize cmp, string Main, string Secondary, out string primaryTerm, out string secondaryTerm)
		{
			primaryTerm = cmp.name;
			secondaryTerm = null;
		}

		public override void DoLocalize(Localize cmp, string mainTranslation, string secondaryTranslation)
		{
			if (string.IsNullOrEmpty(mainTranslation) || ((bool)mTarget && mTarget.name == mainTranslation))
			{
				return;
			}
			Transform transform = cmp.transform;
			string text = mainTranslation;
			int num = mainTranslation.LastIndexOfAny(LanguageSourceData.CategorySeparators);
			if (num >= 0)
			{
				text = text.Substring(num + 1);
			}
			Transform transform2 = InstantiateNewPrefab(cmp, mainTranslation);
			if (transform2 == null)
			{
				return;
			}
			transform2.name = text;
			for (int num2 = transform.childCount - 1; num2 >= 0; num2--)
			{
				Transform child = transform.GetChild(num2);
				if (child != transform2)
				{
					UnityEngine.Object.Destroy(child.gameObject);
				}
			}
		}

		private Transform InstantiateNewPrefab(Localize cmp, string mainTranslation)
		{
			GameObject gameObject = cmp.FindTranslatedObject<GameObject>(mainTranslation);
			if (gameObject == null)
			{
				return null;
			}
			GameObject gameObject2 = mTarget;
			mTarget = UnityEngine.Object.Instantiate(gameObject);
			if (mTarget == null)
			{
				return null;
			}
			Transform transform = cmp.transform;
			Transform transform2 = mTarget.transform;
			transform2.SetParent(transform);
			Transform transform3 = (gameObject2 ? gameObject2.transform : transform);
			transform2.rotation = transform3.rotation;
			transform2.position = transform3.position;
			return transform2;
		}
	}
	public class LocalizeTarget_UnityStandard_SpriteRenderer : LocalizeTarget<SpriteRenderer>
	{
		static LocalizeTarget_UnityStandard_SpriteRenderer()
		{
			AutoRegister();
		}

		[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
		private static void AutoRegister()
		{
			LocalizationManager.RegisterTarget(new LocalizeTargetDesc_Type<SpriteRenderer, LocalizeTarget_UnityStandard_SpriteRenderer>
			{
				Name = "SpriteRenderer",
				Priority = 100
			});
		}

		public override eTermType GetPrimaryTermType(Localize cmp)
		{
			return eTermType.Sprite;
		}

		public override eTermType GetSecondaryTermType(Localize cmp)
		{
			return eTermType.Text;
		}

		public override bool CanUseSecondaryTerm()
		{
			return false;
		}

		public override bool AllowMainTermToBeRTL()
		{
			return false;
		}

		public override bool AllowSecondTermToBeRTL()
		{
			return false;
		}

		public override void GetFinalTerms(Localize cmp, string Main, string Secondary, out string primaryTerm, out string secondaryTerm)
		{
			primaryTerm = ((mTarget.sprite != null) ? mTarget.sprite.name : string.Empty);
			secondaryTerm = null;
		}

		public override void DoLocalize(Localize cmp, string mainTranslation, string secondaryTranslation)
		{
			Sprite sprite = mTarget.sprite;
			if (sprite == null || sprite.name != mainTranslation)
			{
				mTarget.sprite = cmp.FindTranslatedObject<Sprite>(mainTranslation);
			}
		}
	}
	public class LocalizeTarget_UnityStandard_TextMesh : LocalizeTarget<TextMesh>
	{
		private TextAlignment mAlignment_RTL = TextAlignment.Right;

		private TextAlignment mAlignment_LTR;

		private bool mAlignmentWasRTL;

		private bool mInitializeAlignment = true;

		static LocalizeTarget_UnityStandard_TextMesh()
		{
			AutoRegister();
		}

		[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
		private static void AutoRegister()
		{
			LocalizationManager.RegisterTarget(new LocalizeTargetDesc_Type<TextMesh, LocalizeTarget_UnityStandard_TextMesh>
			{
				Name = "TextMesh",
				Priority = 100
			});
		}

		public override eTermType GetPrimaryTermType(Localize cmp)
		{
			return eTermType.Text;
		}

		public override eTermType GetSecondaryTermType(Localize cmp)
		{
			return eTermType.Font;
		}

		public override bool CanUseSecondaryTerm()
		{
			return true;
		}

		public override bool AllowMainTermToBeRTL()
		{
			return true;
		}

		public override bool AllowSecondTermToBeRTL()
		{
			return false;
		}

		public override void GetFinalTerms(Localize cmp, string Main, string Secondary, out string primaryTerm, out string secondaryTerm)
		{
			primaryTerm = (mTarget ? mTarget.text : null);
			secondaryTerm = ((string.IsNullOrEmpty(Secondary) && mTarget.font != null) ? mTarget.font.name : null);
		}

		public override void DoLocalize(Localize cmp, string mainTranslation, string secondaryTranslation)
		{
			Font secondaryTranslatedObj = cmp.GetSecondaryTranslatedObj<Font>(ref mainTranslation, ref secondaryTranslation);
			if (secondaryTranslatedObj != null && mTarget.font != secondaryTranslatedObj)
			{
				mTarget.font = secondaryTranslatedObj;
			}
			if (mInitializeAlignment)
			{
				mInitializeAlignment = false;
				mAlignment_LTR = (mAlignment_RTL = mTarget.alignment);
				if (LocalizationManager.IsRight2Left && mAlignment_RTL == TextAlignment.Right)
				{
					mAlignment_LTR = TextAlignment.Left;
				}
				if (!LocalizationManager.IsRight2Left && mAlignment_LTR == TextAlignment.Left)
				{
					mAlignment_RTL = TextAlignment.Right;
				}
			}
			if (mainTranslation != null && mTarget.text != mainTranslation)
			{
				if (cmp.CorrectAlignmentForRTL && mTarget.alignment != TextAlignment.Center)
				{
					mTarget.alignment = (LocalizationManager.IsRight2Left ? mAlignment_RTL : mAlignment_LTR);
				}
				mTarget.font.RequestCharactersInTexture(mainTranslation);
				mTarget.text = mainTranslation;
			}
		}
	}
	public class LocalizeTarget_UnityUI_Image : LocalizeTarget<Image>
	{
		static LocalizeTarget_UnityUI_Image()
		{
			AutoRegister();
		}

		[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
		private static void AutoRegister()
		{
			LocalizationManager.RegisterTarget(new LocalizeTargetDesc_Type<Image, LocalizeTarget_UnityUI_Image>
			{
				Name = "Image",
				Priority = 100
			});
		}

		public override bool CanUseSecondaryTerm()
		{
			return false;
		}

		public override bool AllowMainTermToBeRTL()
		{
			return false;
		}

		public override bool AllowSecondTermToBeRTL()
		{
			return false;
		}

		public override eTermType GetPrimaryTermType(Localize cmp)
		{
			if (!(mTarget.sprite == null))
			{
				return eTermType.Sprite;
			}
			return eTermType.Texture;
		}

		public override eTermType GetSecondaryTermType(Localize cmp)
		{
			return eTermType.Text;
		}

		public override void GetFinalTerms(Localize cmp, string Main, string Secondary, out string primaryTerm, out string secondaryTerm)
		{
			primaryTerm = (mTarget.mainTexture ? mTarget.mainTexture.name : "");
			if (mTarget.sprite != null && mTarget.sprite.name != primaryTerm)
			{
				primaryTerm = primaryTerm + "." + mTarget.sprite.name;
			}
			secondaryTerm = null;
		}

		public override void DoLocalize(Localize cmp, string mainTranslation, string secondaryTranslation)
		{
			Sprite sprite = mTarget.sprite;
			if (sprite == null || sprite.name != mainTranslation)
			{
				mTarget.sprite = cmp.FindTranslatedObject<Sprite>(mainTranslation);
			}
		}
	}
	public class LocalizeTarget_UnityUI_RawImage : LocalizeTarget<RawImage>
	{
		static LocalizeTarget_UnityUI_RawImage()
		{
			AutoRegister();
		}

		[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
		private static void AutoRegister()
		{
			LocalizationManager.RegisterTarget(new LocalizeTargetDesc_Type<RawImage, LocalizeTarget_UnityUI_RawImage>
			{
				Name = "RawImage",
				Priority = 100
			});
		}

		public override eTermType GetPrimaryTermType(Localize cmp)
		{
			return eTermType.Texture;
		}

		public override eTermType GetSecondaryTermType(Localize cmp)
		{
			return eTermType.Text;
		}

		public override bool CanUseSecondaryTerm()
		{
			return false;
		}

		public override bool AllowMainTermToBeRTL()
		{
			return false;
		}

		public override bool AllowSecondTermToBeRTL()
		{
			return false;
		}

		public override void GetFinalTerms(Localize cmp, string Main, string Secondary, out string primaryTerm, out string secondaryTerm)
		{
			primaryTerm = (mTarget.mainTexture ? mTarget.mainTexture.name : "");
			secondaryTerm = null;
		}

		public override void DoLocalize(Localize cmp, string mainTranslation, string secondaryTranslation)
		{
			Texture texture = mTarget.texture;
			if (texture == null || texture.name != mainTranslation)
			{
				mTarget.texture = cmp.FindTranslatedObject<Texture>(mainTranslation);
			}
		}
	}
	public class LocalizeTarget_UnityUI_Text : LocalizeTarget<Text>
	{
		private TextAnchor mAlignment_RTL = TextAnchor.UpperRight;

		private TextAnchor mAlignment_LTR;

		private bool mAlignmentWasRTL;

		private bool mInitializeAlignment = true;

		static LocalizeTarget_UnityUI_Text()
		{
			AutoRegister();
		}

		[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
		private static void AutoRegister()
		{
			LocalizationManager.RegisterTarget(new LocalizeTargetDesc_Type<Text, LocalizeTarget_UnityUI_Text>
			{
				Name = "Text",
				Priority = 100
			});
		}

		public override eTermType GetPrimaryTermType(Localize cmp)
		{
			return eTermType.Text;
		}

		public override eTermType GetSecondaryTermType(Localize cmp)
		{
			return eTermType.Font;
		}

		public override bool CanUseSecondaryTerm()
		{
			return true;
		}

		public override bool AllowMainTermToBeRTL()
		{
			return true;
		}

		public override bool AllowSecondTermToBeRTL()
		{
			return false;
		}

		public override void GetFinalTerms(Localize cmp, string Main, string Secondary, out string primaryTerm, out string secondaryTerm)
		{
			primaryTerm = (mTarget ? mTarget.text : null);
			secondaryTerm = ((mTarget.font != null) ? mTarget.font.name : string.Empty);
		}

		public override void DoLocalize(Localize cmp, string mainTranslation, string secondaryTranslation)
		{
			Font secondaryTranslatedObj = cmp.GetSecondaryTranslatedObj<Font>(ref mainTranslation, ref secondaryTranslation);
			if (secondaryTranslatedObj != null && secondaryTranslatedObj != mTarget.font)
			{
				mTarget.font = secondaryTranslatedObj;
			}
			if (mInitializeAlignment)
			{
				mInitializeAlignment = false;
				mAlignmentWasRTL = LocalizationManager.IsRight2Left;
				InitAlignment(mAlignmentWasRTL, mTarget.alignment, out mAlignment_LTR, out mAlignment_RTL);
			}
			else
			{
				InitAlignment(mAlignmentWasRTL, mTarget.alignment, out var alignLTR, out var alignRTL);
				if ((mAlignmentWasRTL && mAlignment_RTL != alignRTL) || (!mAlignmentWasRTL && mAlignment_LTR != alignLTR))
				{
					mAlignment_LTR = alignLTR;
					mAlignment_RTL = alignRTL;
				}
				mAlignmentWasRTL = LocalizationManager.IsRight2Left;
			}
			if (mainTranslation != null && mTarget.text != mainTranslation)
			{
				if (cmp.CorrectAlignmentForRTL)
				{
					mTarget.alignment = (LocalizationManager.IsRight2Left ? mAlignment_RTL : mAlignment_LTR);
				}
				mTarget.text = mainTranslation;
				mTarget.SetVerticesDirty();
			}
		}

		private void InitAlignment(bool isRTL, TextAnchor alignment, out TextAnchor alignLTR, out TextAnchor alignRTL)
		{
			alignLTR = (alignRTL = alignment);
			if (isRTL)
			{
				switch (alignment)
				{
				case TextAnchor.UpperRight:
					alignLTR = TextAnchor.UpperLeft;
					break;
				case TextAnchor.MiddleRight:
					alignLTR = TextAnchor.MiddleLeft;
					break;
				case TextAnchor.LowerRight:
					alignLTR = TextAnchor.LowerLeft;
					break;
				case TextAnchor.UpperLeft:
					alignLTR = TextAnchor.UpperRight;
					break;
				case TextAnchor.MiddleLeft:
					alignLTR = TextAnchor.MiddleRight;
					break;
				case TextAnchor.LowerLeft:
					alignLTR = TextAnchor.LowerRight;
					break;
				case TextAnchor.UpperCenter:
				case TextAnchor.MiddleCenter:
				case TextAnchor.LowerCenter:
					break;
				}
			}
			else
			{
				switch (alignment)
				{
				case TextAnchor.UpperRight:
					alignRTL = TextAnchor.UpperLeft;
					break;
				case TextAnchor.MiddleRight:
					alignRTL = TextAnchor.MiddleLeft;
					break;
				case TextAnchor.LowerRight:
					alignRTL = TextAnchor.LowerLeft;
					break;
				case TextAnchor.UpperLeft:
					alignRTL = TextAnchor.UpperRight;
					break;
				case TextAnchor.MiddleLeft:
					alignRTL = TextAnchor.MiddleRight;
					break;
				case TextAnchor.LowerLeft:
					alignRTL = TextAnchor.LowerRight;
					break;
				case TextAnchor.UpperCenter:
				case TextAnchor.MiddleCenter:
				case TextAnchor.LowerCenter:
					break;
				}
			}
		}
	}
	public enum eTermType
	{
		Text,
		Font,
		Texture,
		AudioClip,
		GameObject,
		Sprite,
		Material,
		Child,
		Mesh,
		TextMeshPFont,
		Object
	}
	public enum TranslationFlag : byte
	{
		Normal = 1,
		AutoTranslated
	}
	[Serializable]
	public class TermData
	{
		public string Term = string.Empty;

		public eTermType TermType;

		[NonSerialized]
		public string Description;

		public string[] Languages = new string[0];

		public byte[] Flags = new byte[0];

		[SerializeField]
		private string[] Languages_Touch;

		public string GetTranslation(int idx, string specialization = null, bool editMode = false)
		{
			string text = Languages[idx];
			if (text != null)
			{
				text = SpecializationManager.GetSpecializedText(text, specialization);
				if (!editMode)
				{
					text = text.Replace("[i2nt]", "").Replace("[/i2nt]", "");
				}
			}
			return text;
		}

		public void SetTranslation(int idx, string translation, string specialization = null)
		{
			Languages[idx] = SpecializationManager.SetSpecializedText(Languages[idx], translation, specialization);
		}

		public void RemoveSpecialization(string specialization)
		{
			for (int i = 0; i < Languages.Length; i++)
			{
				RemoveSpecialization(i, specialization);
			}
		}

		public void RemoveSpecialization(int idx, string specialization)
		{
			string text = Languages[idx];
			if (!(specialization == "Any") && text.Contains("[i2s_" + specialization + "]"))
			{
				Dictionary<string, string> specializations = SpecializationManager.GetSpecializations(text);
				specializations.Remove(specialization);
				Languages[idx] = SpecializationManager.SetSpecializedText(specializations);
			}
		}

		public bool IsAutoTranslated(int idx, bool IsTouch)
		{
			return (Flags[idx] & 2) > 0;
		}

		public void Validate()
		{
			int num = Mathf.Max(Languages.Length, Flags.Length);
			if (Languages.Length != num)
			{
				Array.Resize(ref Languages, num);
			}
			if (Flags.Length != num)
			{
				Array.Resize(ref Flags, num);
			}
			if (Languages_Touch == null)
			{
				return;
			}
			for (int i = 0; i < Mathf.Min(Languages_Touch.Length, num); i++)
			{
				if (string.IsNullOrEmpty(Languages[i]) && !string.IsNullOrEmpty(Languages_Touch[i]))
				{
					Languages[i] = Languages_Touch[i];
					Languages_Touch[i] = null;
				}
			}
			Languages_Touch = null;
		}

		public bool IsTerm(string name, bool allowCategoryMistmatch)
		{
			if (!allowCategoryMistmatch)
			{
				return name == Term;
			}
			return name == LanguageSourceData.GetKeyFromFullTerm(Term);
		}

		public bool HasSpecializations()
		{
			for (int i = 0; i < Languages.Length; i++)
			{
				if (!string.IsNullOrEmpty(Languages[i]) && Languages[i].Contains("[i2s_"))
				{
					return true;
				}
			}
			return false;
		}

		public List<string> GetAllSpecializations()
		{
			List<string> list = new List<string>();
			for (int i = 0; i < Languages.Length; i++)
			{
				SpecializationManager.AppendSpecializations(Languages[i], list);
			}
			return list;
		}
	}
	public class TermsPopup : PropertyAttribute
	{
		public string Filter { get; private set; }

		public TermsPopup(string filter = "")
		{
			Filter = filter;
		}
	}
	public class AutoChangeCultureInfo : MonoBehaviour
	{
		public void Start()
		{
			LocalizationManager.EnableChangingCultureInfo(bEnable: true);
		}
	}
	public class CoroutineManager : MonoBehaviour
	{
		private static CoroutineManager mInstance;

		private static CoroutineManager pInstance
		{
			get
			{
				if (mInstance == null)
				{
					GameObject gameObject = new GameObject("_Coroutiner");
					gameObject.hideFlags = HideFlags.HideAndDontSave;
					mInstance = gameObject.AddComponent<CoroutineManager>();
					if (UnityEngine.Application.isPlaying)
					{
						UnityEngine.Object.DontDestroyOnLoad(gameObject);
					}
				}
				return mInstance;
			}
		}

		private void Awake()
		{
			if (UnityEngine.Application.isPlaying)
			{
				UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
			}
		}

		public static Coroutine Start(IEnumerator coroutine)
		{
			return pInstance.StartCoroutine(coroutine);
		}
	}
	[AddComponentMenu("I2/Localization/I2 Localize Callback")]
	public class CustomLocalizeCallback : MonoBehaviour
	{
		public UnityEvent _OnLocalize = new UnityEvent();

		public void OnEnable()
		{
			LocalizationManager.OnLocalizeEvent -= OnLocalize;
			LocalizationManager.OnLocalizeEvent += OnLocalize;
		}

		public void OnDisable()
		{
			LocalizationManager.OnLocalizeEvent -= OnLocalize;
		}

		public void OnLocalize()
		{
			_OnLocalize.Invoke();
		}
	}
	public class HindiFixer
	{
		internal static string Fix(string text)
		{
			char[] array = text.ToCharArray();
			bool flag = false;
			for (int i = 0; i < array.Length; i++)
			{
				if (array[i] == '\u093f' && !char.IsWhiteSpace(array[i - 1]) && array[i - 1] != 0)
				{
					array[i] = array[i - 1];
					array[i - 1] = '\u093f';
					flag = true;
				}
				if (i != array.Length - 1)
				{
					if (array[i] == 'इ' && array[i + 1] == '\u093c')
					{
						array[i] = 'ऌ';
						array[i + 1] = '\0';
						flag = true;
					}
					if (array[i] == '\u0943' && array[i + 1] == '\u093c')
					{
						array[i] = '\u0944';
						array[i + 1] = '\0';
						flag = true;
					}
					if (array[i] == '\u0901' && array[i + 1] == '\u093c')
					{
						array[i] = 'ॐ';
						array[i + 1] = '\0';
						flag = true;
					}
					if (array[i] == 'ऋ' && array[i + 1] == '\u093c')
					{
						array[i] = 'ॠ';
						array[i + 1] = '\0';
						flag = true;
					}
					if (array[i] == 'ई' && array[i + 1] == '\u093c')
					{
						array[i] = 'ॡ';
						array[i + 1] = '\0';
						flag = true;
					}
					if (array[i] == '\u093f' && array[i + 1] == '\u093c')
					{
						array[i] = '\u0962';
						array[i + 1] = '\0';
						flag = true;
					}
					if (array[i] == '\u0940' && array[i + 1] == '\u093c')
					{
						array[i] = '\u0963';
						array[i + 1] = '\0';
						flag = true;
					}
					if (array[i] == '।' && array[i + 1] == '\u093c')
					{
						array[i] = 'ऽ';
						array[i + 1] = '\0';
						flag = true;
					}
				}
			}
			if (!flag)
			{
				return text;
			}
			string text2 = new string(array.Where((char x) => x != '\0').ToArray());
			if (text2 == text)
			{
				return text2;
			}
			text = text2;
			return text;
		}
	}
	public static class I2Utils
	{
		public const string ValidChars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_";

		public const string NumberChars = "0123456789";

		public const string ValidNameSymbols = ".-_$#@*()[]{}+:?!&',^=<>~`";

		public static string ReverseText(string source)
		{
			int length = source.Length;
			char[] array = new char[length];
			for (int i = 0; i < length; i++)
			{
				array[length - 1 - i] = source[i];
			}
			return new string(array);
		}

		public static string RemoveNonASCII(string text, bool allowCategory = false)
		{
			if (string.IsNullOrEmpty(text))
			{
				return text;
			}
			int num = 0;
			char[] array = new char[text.Length];
			bool flag = false;
			char[] array2 = text.Trim().ToCharArray();
			foreach (char c in array2)
			{
				char c2 = ' ';
				if ((allowCategory && (c == '\\' || c == '"' || c == '/')) || char.IsLetterOrDigit(c) || ".-_$#@*()[]{}+:?!&',^=<>~`".IndexOf(c) >= 0)
				{
					c2 = c;
				}
				if (char.IsWhiteSpace(c2))
				{
					if (!flag)
					{
						if (num > 0)
						{
							array[num++] = ' ';
						}
						flag = true;
					}
				}
				else
				{
					flag = false;
					array[num++] = c2;
				}
			}
			return new string(array, 0, num);
		}

		public static string GetValidTermName(string text, bool allowCategory = false)
		{
			if (text == null)
			{
				return null;
			}
			text = RemoveTags(text);
			return RemoveNonASCII(text, allowCategory);
		}

		public static string SplitLine(string line, int maxCharacters)
		{
			if (maxCharacters <= 0 || line.Length < maxCharacters)
			{
				return line;
			}
			char[] array = line.ToCharArray();
			bool flag = true;
			bool flag2 = false;
			int i = 0;
			int num = 0;
			for (; i < array.Length; i++)
			{
				if (flag)
				{
					num++;
					if (array[i] == '\n')
					{
						num = 0;
					}
					if (num >= maxCharacters && char.IsWhiteSpace(array[i]))
					{
						array[i] = '\n';
						flag = false;
						flag2 = false;
					}
				}
				else if (!char.IsWhiteSpace(array[i]))
				{
					flag = true;
					num = 0;
				}
				else if (array[i] != '\n')
				{
					array[i] = '\0';
				}
				else
				{
					if (!flag2)
					{
						array[i] = '\0';
					}
					flag2 = true;
				}
			}
			return new string(array.Where((char c) => c != '\0').ToArray());
		}

		public static bool FindNextTag(string line, int iStart, out int tagStart, out int tagEnd)
		{
			tagStart = -1;
			tagEnd = -1;
			int length = line.Length;
			tagStart = iStart;
			while (tagStart < length && line[tagStart] != '[' && line[tagStart] != '(' && line[tagStart] != '{' && line[tagStart] != '<')
			{
				tagStart++;
			}
			if (tagStart == length)
			{
				return false;
			}
			bool flag = false;
			for (tagEnd = tagStart + 1; tagEnd < length; tagEnd++)
			{
				char c = line[tagEnd];
				if (c == ']' || c == ')' || c == '}' || c == '>')
				{
					if (flag)
					{
						return FindNextTag(line, tagEnd + 1, out tagStart, out tagEnd);
					}
					return true;
				}
				if (c > 'ÿ')
				{
					flag = true;
				}
			}
			return false;
		}

		public static string RemoveTags(string text)
		{
			return Regex.Replace(text, "\\{\\[(.*?)]}|\\[(.*?)]|\\<(.*?)>", "");
		}

		public static bool RemoveResourcesPath(ref string sPath)
		{
			int num = sPath.IndexOf("\\Resources\\");
			int num2 = sPath.IndexOf("\\Resources/");
			int num3 = sPath.IndexOf("/Resources\\");
			int num4 = sPath.IndexOf("/Resources/");
			int num5 = Mathf.Max(num, num2, num3, num4);
			bool result = false;
			if (num5 >= 0)
			{
				sPath = sPath.Substring(num5 + 11);
				result = true;
			}
			else
			{
				num5 = sPath.LastIndexOfAny(LanguageSourceData.CategorySeparators);
				if (num5 > 0)
				{
					sPath = sPath.Substring(num5 + 1);
				}
			}
			string extension = Path.GetExtension(sPath);
			if (!string.IsNullOrEmpty(extension))
			{
				sPath = sPath.Substring(0, sPath.Length - extension.Length);
			}
			return result;
		}

		public static bool IsPlaying()
		{
			if (UnityEngine.Application.isPlaying)
			{
				return true;
			}
			return false;
		}

		public static string GetPath(this Transform tr)
		{
			Transform parent = tr.parent;
			if (tr == null)
			{
				return tr.name;
			}
			return parent.GetPath() + "/" + tr.name;
		}

		public static Transform FindObject(string objectPath)
		{
			return FindObject(SceneManager.GetActiveScene(), objectPath);
		}

		public static Transform FindObject(Scene scene, string objectPath)
		{
			GameObject[] rootGameObjects = scene.GetRootGameObjects();
			for (int i = 0; i < rootGameObjects.Length; i++)
			{
				Transform transform = rootGameObjects[i].transform;
				if (transform.name == objectPath)
				{
					return transform;
				}
				if (objectPath.StartsWith(transform.name + "/"))
				{
					return FindObject(transform, objectPath.Substring(transform.name.Length + 1));
				}
			}
			return null;
		}

		public static Transform FindObject(Transform root, string objectPath)
		{
			for (int i = 0; i < root.childCount; i++)
			{
				Transform child = root.GetChild(i);
				if (child.name == objectPath)
				{
					return child;
				}
				if (objectPath.StartsWith(child.name + "/"))
				{
					return FindObject(child, objectPath.Substring(child.name.Length + 1));
				}
			}
			return null;
		}

		public static H FindInParents<H>(Transform tr) where H : Component
		{
			if (!tr)
			{
				return null;
			}
			H component = tr.GetComponent<H>();
			while (!component && (bool)tr)
			{
				component = tr.GetComponent<H>();
				tr = tr.parent;
			}
			return component;
		}

		public static string GetCaptureMatch(Match match)
		{
			for (int num = match.Groups.Count - 1; num >= 0; num--)
			{
				if (match.Groups[num].Success)
				{
					return match.Groups[num].ToString();
				}
			}
			return match.ToString();
		}

		public static void SendWebRequest(UnityWebRequest www)
		{
			www.SendWebRequest();
		}
	}
	public interface ILocalizationParamsManager
	{
		string GetParameterValue(string Param);
	}
	public class LocalizationParamsManager : MonoBehaviour, ILocalizationParamsManager
	{
		[Serializable]
		public struct ParamValue
		{
			public string Name;

			public string Value;
		}

		[SerializeField]
		public List<ParamValue> _Params = new List<ParamValue>();

		public bool _IsGlobalManager;

		public string GetParameterValue(string ParamName)
		{
			if (_Params != null)
			{
				int i = 0;
				for (int count = _Params.Count; i < count; i++)
				{
					if (_Params[i].Name == ParamName)
					{
						return _Params[i].Value;
					}
				}
			}
			return null;
		}

		public void SetParameterValue(string ParamName, string ParamValue, bool localize = true)
		{
			bool flag = false;
			int i = 0;
			for (int count = _Params.Count; i < count; i++)
			{
				if (_Params[i].Name == ParamName)
				{
					ParamValue value = _Params[i];
					value.Value = ParamValue;
					_Params[i] = value;
					flag = true;
					break;
				}
			}
			if (!flag)
			{
				_Params.Add(new ParamValue
				{
					Name = ParamName,
					Value = ParamValue
				});
			}
			if (localize)
			{
				OnLocalize();
			}
		}

		public void OnLocalize()
		{
			Localize component = GetComponent<Localize>();
			if (component != null)
			{
				component.OnLocalize(Force: true);
			}
		}

		public virtual void OnEnable()
		{
			if (_IsGlobalManager)
			{
				DoAutoRegister();
			}
		}

		public void DoAutoRegister()
		{
			if (!LocalizationManager.ParamManagers.Contains(this))
			{
				LocalizationManager.ParamManagers.Add(this);
				LocalizationManager.LocalizeAll(Force: true);
			}
		}

		public void OnDisable()
		{
			LocalizationManager.ParamManagers.Remove(this);
		}
	}
	[Serializable]
	public struct LocalizedString
	{
		public string mTerm;

		public bool mRTL_IgnoreArabicFix;

		public int mRTL_MaxLineLength;

		public bool mRTL_ConvertNumbers;

		public bool m_DontLocalizeParameters;

		public static implicit operator string(LocalizedString s)
		{
			return s.ToString();
		}

		public static implicit operator LocalizedString(string term)
		{
			LocalizedString result = default(LocalizedString);
			result.mTerm = term;
			return result;
		}

		public LocalizedString(LocalizedString str)
		{
			mTerm = str.mTerm;
			mRTL_IgnoreArabicFix = str.mRTL_IgnoreArabicFix;
			mRTL_MaxLineLength = str.mRTL_MaxLineLength;
			mRTL_ConvertNumbers = str.mRTL_ConvertNumbers;
			m_DontLocalizeParameters = str.m_DontLocalizeParameters;
		}

		public override string ToString()
		{
			string translation = LocalizationManager.GetTranslation(mTerm, !mRTL_IgnoreArabicFix, mRTL_MaxLineLength, !mRTL_ConvertNumbers, applyParameters: true);
			LocalizationManager.ApplyLocalizationParams(ref translation, !m_DontLocalizeParameters);
			return translation;
		}
	}
	public class RTLFixer
	{
		public static string Fix(string str)
		{
			return Fix(str, showTashkeel: false, useHinduNumbers: true);
		}

		public static string Fix(string str, bool rtl)
		{
			if (rtl)
			{
				return Fix(str);
			}
			string[] array = str.Split(' ');
			string text = "";
			string text2 = "";
			string[] array2 = array;
			foreach (string text3 in array2)
			{
				if (char.IsLower(text3.ToLower()[text3.Length / 2]))
				{
					text = text + Fix(text2) + text3 + " ";
					text2 = "";
				}
				else
				{
					text2 = text2 + text3 + " ";
				}
			}
			if (text2 != "")
			{
				text += Fix(text2);
			}
			return text;
		}

		public static string Fix(string str, bool showTashkeel, bool useHinduNumbers)
		{
			string text = HindiFixer.Fix(str);
			if (text != str)
			{
				return text;
			}
			RTLFixerTool.showTashkeel = showTashkeel;
			RTLFixerTool.useHinduNumbers = useHinduNumbers;
			if (str.Contains("\n"))
			{
				str = str.Replace("\n", Environment.NewLine);
			}
			if (str.Contains(Environment.NewLine))
			{
				string[] separator = new string[1] { Environment.NewLine };
				string[] array = str.Split(separator, StringSplitOptions.None);
				if (array.Length == 0)
				{
					return RTLFixerTool.FixLine(str);
				}
				if (array.Length == 1)
				{
					return RTLFixerTool.FixLine(str);
				}
				string text2 = RTLFixerTool.FixLine(array[0]);
				int i = 1;
				if (array.Length > 1)
				{
					for (; i < array.Length; i++)
					{
						text2 = text2 + Environment.NewLine + RTLFixerTool.FixLine(array[i]);
					}
				}
				return text2;
			}
			return RTLFixerTool.FixLine(str);
		}
	}
	internal enum IsolatedArabicLetters
	{
		Hamza = 65152,
		Alef = 65165,
		AlefHamza = 65155,
		WawHamza = 65157,
		AlefMaksoor = 65159,
		AlefMaksora = 64508,
		HamzaNabera = 65161,
		Ba = 65167,
		Ta = 65173,
		Tha2 = 65177,
		Jeem = 65181,
		H7aa = 65185,
		Khaa2 = 65189,
		Dal = 65193,
		Thal = 65195,
		Ra2 = 65197,
		Zeen = 65199,
		Seen = 65201,
		Sheen = 65205,
		S9a = 65209,
		Dha = 65213,
		T6a = 65217,
		T6ha = 65221,
		Ain = 65225,
		Gain = 65229,
		Fa = 65233,
		Gaf = 65237,
		Kaf = 65241,
		Lam = 65245,
		Meem = 65249,
		Noon = 65253,
		Ha = 65257,
		Waw = 65261,
		Ya = 65265,
		AlefMad = 65153,
		TaMarboota = 65171,
		PersianPe = 64342,
		PersianChe = 64378,
		PersianZe = 64394,
		PersianGaf = 64402,
		PersianGaf2 = 64398
	}
	internal enum GeneralArabicLetters
	{
		Hamza = 1569,
		Alef = 1575,
		AlefHamza = 1571,
		WawHamza = 1572,
		AlefMaksoor = 1573,
		AlefMagsora = 1609,
		HamzaNabera = 1574,
		Ba = 1576,
		Ta = 1578,
		Tha2 = 1579,
		Jeem = 1580,
		H7aa = 1581,
		Khaa2 = 1582,
		Dal = 1583,
		Thal = 1584,
		Ra2 = 1585,
		Zeen = 1586,
		Seen = 1587,
		Sheen = 1588,
		S9a = 1589,
		Dha = 1590,
		T6a = 1591,
		T6ha = 1592,
		Ain = 1593,
		Gain = 1594,
		Fa = 1601,
		Gaf = 1602,
		Kaf = 1603,
		Lam = 1604,
		Meem = 1605,
		Noon = 1606,
		Ha = 1607,
		Waw = 1608,
		Ya = 1610,
		AlefMad = 1570,
		TaMarboota = 1577,
		PersianPe = 1662,
		PersianChe = 1670,
		PersianZe = 1688,
		PersianGaf = 1711,
		PersianGaf2 = 1705
	}
	internal class ArabicMapping
	{
		public int from;

		public int to;

		public ArabicMapping(int from, int to)
		{
			this.from = from;
			this.to = to;
		}
	}
	internal class ArabicTable
	{
		private static List<ArabicMapping> mapList;

		private static ArabicTable arabicMapper;

		internal static ArabicTable ArabicMapper
		{
			get
			{
				if (arabicMapper == null)
				{
					arabicMapper = new ArabicTable();
				}
				return arabicMapper;
			}
		}

		private ArabicTable()
		{
			mapList = new List<ArabicMapping>();
			mapList.Add(new ArabicMapping(1569, 65152));
			mapList.Add(new ArabicMapping(1575, 65165));
			mapList.Add(new ArabicMapping(1571, 65155));
			mapList.Add(new ArabicMapping(1572, 65157));
			mapList.Add(new ArabicMapping(1573, 65159));
			mapList.Add(new ArabicMapping(1609, 64508));
			mapList.Add(new ArabicMapping(1574, 65161));
			mapList.Add(new ArabicMapping(1576, 65167));
			mapList.Add(new ArabicMapping(1578, 65173));
			mapList.Add(new ArabicMapping(1579, 65177));
			mapList.Add(new ArabicMapping(1580, 65181));
			mapList.Add(new ArabicMapping(1581, 65185));
			mapList.Add(new ArabicMapping(1582, 65189));
			mapList.Add(new ArabicMapping(1583, 65193));
			mapList.Add(new ArabicMapping(1584, 65195));
			mapList.Add(new ArabicMapping(1585, 65197));
			mapList.Add(new ArabicMapping(1586, 65199));
			mapList.Add(new ArabicMapping(1587, 65201));
			mapList.Add(new ArabicMapping(1588, 65205));
			mapList.Add(new ArabicMapping(1589, 65209));
			mapList.Add(new ArabicMapping(1590, 65213));
			mapList.Add(new ArabicMapping(1591, 65217));
			mapList.Add(new ArabicMapping(1592, 65221));
			mapList.Add(new ArabicMapping(1593, 65225));
			mapList.Add(new ArabicMapping(1594, 65229));
			mapList.Add(new ArabicMapping(1601, 65233));
			mapList.Add(new ArabicMapping(1602, 65237));
			mapList.Add(new ArabicMapping(1603, 65241));
			mapList.Add(new ArabicMapping(1604, 65245));
			mapList.Add(new ArabicMapping(1605, 65249));
			mapList.Add(new ArabicMapping(1606, 65253));
			mapList.Add(new ArabicMapping(1607, 65257));
			mapList.Add(new ArabicMapping(1608, 65261));
			mapList.Add(new ArabicMapping(1610, 65265));
			mapList.Add(new ArabicMapping(1570, 65153));
			mapList.Add(new ArabicMapping(1577, 65171));
			mapList.Add(new ArabicMapping(1662, 64342));
			mapList.Add(new ArabicMapping(1670, 64378));
			mapList.Add(new ArabicMapping(1688, 64394));
			mapList.Add(new ArabicMapping(1711, 64402));
			mapList.Add(new ArabicMapping(1705, 64398));
		}

		internal int Convert(int toBeConverted)
		{
			foreach (ArabicMapping map in mapList)
			{
				if (map.from == toBeConverted)
				{
					return map.to;
				}
			}
			return toBeConverted;
		}
	}
	internal class TashkeelLocation
	{
		public char tashkeel;

		public int position;

		public TashkeelLocation(char tashkeel, int position)
		{
			this.tashkeel = tashkeel;
			this.position = position;
		}
	}
	internal class RTLFixerTool
	{
		internal static bool showTashkeel = true;

		internal static bool useHinduNumbers = false;

		internal static string RemoveTashkeel(string str, out List<TashkeelLocation> tashkeelLocation)
		{
			tashkeelLocation = new List<TashkeelLocation>();
			char[] array = str.ToCharArray();
			int num = 0;
			for (int i = 0; i < array.Length; i++)
			{
				if (array[i] == '\u064b')
				{
					tashkeelLocation.Add(new TashkeelLocation('\u064b', i));
					num++;
				}
				else if (array[i] == '\u064c')
				{
					tashkeelLocation.Add(new TashkeelLocation('\u064c', i));
					num++;
				}
				else if (array[i] == '\u064d')
				{
					tashkeelLocation.Add(new TashkeelLocation('\u064d', i));
					num++;
				}
				else if (array[i] == '\u064e')
				{
					if (num > 0 && tashkeelLocation[num - 1].tashkeel == '\u0651')
					{
						tashkeelLocation[num - 1].tashkeel = 'ﱠ';
						continue;
					}
					tashkeelLocation.Add(new TashkeelLocation('\u064e', i));
					num++;
				}
				else if (array[i] == '\u064f')
				{
					if (num > 0 && tashkeelLocation[num - 1].tashkeel == '\u0651')
					{
						tashkeelLocation[num - 1].tashkeel = 'ﱡ';
						continue;
					}
					tashkeelLocation.Add(new TashkeelLocation('\u064f', i));
					num++;
				}
				else if (array[i] == '\u0650')
				{
					if (num > 0 && tashkeelLocation[num - 1].tashkeel == '\u0651')
					{
						tashkeelLocation[num - 1].tashkeel = 'ﱢ';
						continue;
					}
					tashkeelLocation.Add(new TashkeelLocation('\u0650', i));
					num++;
				}
				else if (array[i] == '\u0651')
				{
					if (num > 0)
					{
						if (tashkeelLocation[num - 1].tashkeel == '\u064e')
						{
							tashkeelLocation[num - 1].tashkeel = 'ﱠ';
							continue;
						}
						if (tashkeelLocation[num - 1].tashkeel == '\u064f')
						{
							tashkeelLocation[num - 1].tashkeel = 'ﱡ';
							continue;
						}
						if (tashkeelLocation[num - 1].tashkeel == '\u0650')
						{
							tashkeelLocation[num - 1].tashkeel = 'ﱢ';
							continue;
						}
					}
					tashkeelLocation.Add(new TashkeelLocation('\u0651', i));
					num++;
				}
				else if (array[i] == '\u0652')
				{
					tashkeelLocation.Add(new TashkeelLocation('\u0652', i));
					num++;
				}
				else if (array[i] == '\u0653')
				{
					tashkeelLocation.Add(new TashkeelLocation('\u0653', i));
					num++;
				}
			}
			string[] array2 = str.Split('\u064b', '\u064c', '\u064d', '\u064e', '\u064f', '\u0650', '\u0651', '\u0652', '\u0653', 'ﱠ', 'ﱡ', 'ﱢ');
			str = "";
			string[] array3 = array2;
			foreach (string text in array3)
			{
				str += text;
			}
			return str;
		}

		internal static char[] ReturnTashkeel(char[] letters, List<TashkeelLocation> tashkeelLocation)
		{
			char[] array = new char[letters.Length + tashkeelLocation.Count];
			int num = 0;
			for (int i = 0; i < letters.Length; i++)
			{
				array[num] = letters[i];
				num++;
				foreach (TashkeelLocation item in tashkeelLocation)
				{
					if (item.position == num)
					{
						array[num] = item.tashkeel;
						num++;
					}
				}
			}
			return array;
		}

		internal static string FixLine(string str)
		{
			string text = "";
			List<TashkeelLocation> tashkeelLocation;
			string text2 = RemoveTashkeel(str, out tashkeelLocation);
			char[] array = text2.ToCharArray();
			char[] array2 = text2.ToCharArray();
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = (char)ArabicTable.ArabicMapper.Convert(array[i]);
			}
			for (int j = 0; j < array.Length; j++)
			{
				bool flag = false;
				if (array[j] == 'ﻝ' && j < array.Length - 1)
				{
					if (array[j + 1] == 'ﺇ')
					{
						array[j] = 'ﻷ';
						array2[j + 1] = '\uffff';
						flag = true;
					}
					else if (array[j + 1] == 'ﺍ')
					{
						array[j] = 'ﻹ';
						array2[j + 1] = '\uffff';
						flag = true;
					}
					else if (array[j + 1] == 'ﺃ')
					{
						array[j] = 'ﻵ';
						array2[j + 1] = '\uffff';
						flag = true;
					}
					else if (array[j + 1] == 'ﺁ')
					{
						array[j] = 'ﻳ';
						array2[j + 1] = '\uffff';
						flag = true;
					}
				}
				if (!IsIgnoredCharacter(array[j]))
				{
					if (IsMiddleLetter(array, j))
					{
						array2[j] = (char)(array[j] + 3);
					}
					else if (IsFinishingLetter(array, j))
					{
						array2[j] = (char)(array[j] + 1);
					}
					else if (IsLeadingLetter(array, j))
					{
						array2[j] = (char)(array[j] + 2);
					}
				}
				text = text + Convert.ToString(array[j], 16) + " ";
				if (flag)
				{
					j++;
				}
				if (useHinduNumbers)
				{
					if (array[j] == '0')
					{
						array2[j] = '٠';
					}
					else if (array[j] == '1')
					{
						array2[j] = '١';
					}
					else if (array[j] == '2')
					{
						array2[j] = '٢';
					}
					else if (array[j] == '3')
					{
						array2[j] = '٣';
					}
					else if (array[j] == '4')
					{
						array2[j] = '٤';
					}
					else if (array[j] == '5')
					{
						array2[j] = '٥';
					}
					else if (array[j] == '6')
					{
						array2[j] = '٦';
					}
					else if (array[j] == '7')
					{
						array2[j] = '٧';
					}
					else if (array[j] == '8')
					{
						array2[j] = '٨';
					}
					else if (array[j] == '9')
					{
						array2[j] = '٩';
					}
				}
			}
			if (showTashkeel)
			{
				array2 = ReturnTashkeel(array2, tashkeelLocation);
			}
			List<char> list = new List<char>();
			List<char> list2 = new List<char>();
			for (int num = array2.Length - 1; num >= 0; num--)
			{
				if (char.IsPunctuation(array2[num]) && num > 0 && num < array2.Length - 1 && (char.IsPunctuation(array2[num - 1]) || char.IsPunctuation(array2[num + 1])))
				{
					if (array2[num] == '(')
					{
						list.Add(')');
					}
					else if (array2[num] == ')')
					{
						list.Add('(');
					}
					else if (array2[num] == '<')
					{
						list.Add('>');
					}
					else if (array2[num] == '>')
					{
						list.Add('<');
					}
					else if (array2[num] == '[')
					{
						list.Add(']');
					}
					else if (array2[num] == ']')
					{
						list.Add('[');
					}
					else if (array2[num] != '\uffff')
					{
						list.Add(array2[num]);
					}
				}
				else if (array2[num] == ' ' && num > 0 && num < array2.Length - 1 && (char.IsLower(array2[num - 1]) || char.IsUpper(array2[num - 1]) || char.IsNumber(array2[num - 1])) && (char.IsLower(array2[num + 1]) || char.IsUpper(array2[num + 1]) || char.IsNumber(array2[num + 1])))
				{
					list2.Add(array2[num]);
				}
				else if (char.IsNumber(array2[num]) || char.IsLower(array2[num]) || char.IsUpper(array2[num]) || char.IsSymbol(array2[num]) || char.IsPunctuation(array2[num]))
				{
					if (array2[num] == '(')
					{
						list2.Add(')');
					}
					else if (array2[num] == ')')
					{
						list2.Add('(');
					}
					else if (array2[num] == '<')
					{
						list2.Add('>');
					}
					else if (array2[num] == '>')
					{
						list2.Add('<');
					}
					else if (array2[num] == '[')
					{
						list.Add(']');
					}
					else if (array2[num] == ']')
					{
						list.Add('[');
					}
					else
					{
						list2.Add(array2[num]);
					}
				}
				else if ((array2[num] >= '\ud800' && array2[num] <= '\udbff') || (array2[num] >= '\udc00' && array2[num] <= '\udfff'))
				{
					list2.Add(array2[num]);
				}
				else
				{
					if (list2.Count > 0)
					{
						for (int k = 0; k < list2.Count; k++)
						{
							list.Add(list2[list2.Count - 1 - k]);
						}
						list2.Clear();
					}
					if (array2[num] != '\uffff')
					{
						list.Add(array2[num]);
					}
				}
			}
			if (list2.Count > 0)
			{
				for (int l = 0; l < list2.Count; l++)
				{
					list.Add(list2[list2.Count - 1 - l]);
				}
				list2.Clear();
			}
			array2 = new char[list.Count];
			for (int m = 0; m < array2.Length; m++)
			{
				array2[m] = list[m];
			}
			str = new string(array2);
			return str;
		}

		internal static bool IsIgnoredCharacter(char ch)
		{
			bool num = char.IsPunctuation(ch);
			bool flag = char.IsNumber(ch);
			bool flag2 = char.IsLower(ch);
			bool flag3 = char.IsUpper(ch);
			bool flag4 = char.IsSymbol(ch);
			bool flag5 = ch == 'ﭖ' || ch == 'ﭺ' || ch == 'ﮊ' || ch == 'ﮒ' || ch == 'ﮎ';
			bool flag6 = (ch <= '\ufeff' && ch >= 'ﹰ') || flag5 || ch == 'ﯼ';
			if (!(num || flag || flag2 || flag3 || flag4) && flag6 && ch != 'a' && ch != '>' && ch != '<')
			{
				return ch == '؛';
			}
			return true;
		}

		internal static bool IsLeadingLetter(char[] letters, int index)
		{
			bool num = index == 0 || letters[index - 1] == ' ' || letters[index - 1] == '*' || letters[index - 1] == 'A' || char.IsPunctuation(letters[index - 1]) || letters[index - 1] == '>' || letters[index - 1] == '<' || letters[index - 1] == 'ﺍ' || letters[index - 1] == 'ﺩ' || letters[index - 1] == 'ﺫ' || letters[index - 1] == 'ﺭ' || letters[index - 1] == 'ﺯ' || letters[index - 1] == 'ﮊ' || letters[index - 1] == 'ﻭ' || letters[index - 1] == 'ﺁ' || letters[index - 1] == 'ﺃ' || letters[index - 1] == 'ﺇ' || letters[index - 1] == 'ﺅ';
			bool flag = letters[index] != ' ' && letters[index] != 'ﺩ' && letters[index] != 'ﺫ' && letters[index] != 'ﺭ' && letters[index] != 'ﺯ' && letters[index] != 'ﮊ' && letters[index] != 'ﺍ' && letters[index] != 'ﺃ' && letters[index] != 'ﺇ' && letters[index] != 'ﺁ' && letters[index] != 'ﺅ' && letters[index] != 'ﻭ' && letters[index] != 'ﺀ';
			bool flag2 = index < letters.Length - 1 && letters[index + 1] != ' ' && !char.IsPunctuation(letters[index + 1]) && !char.IsNumber(letters[index + 1]) && !char.IsSymbol(letters[index + 1]) && !char.IsLower(letters[index + 1]) && !char.IsUpper(letters[index + 1]) && letters[index + 1] != 'ﺀ';
			if (num && flag && flag2)
			{
				return true;
			}
			return false;
		}

		internal static bool IsFinishingLetter(char[] letters, int index)
		{
			bool num = index != 0 && letters[index - 1] != ' ' && letters[index - 1] != 'ﺩ' && letters[index - 1] != 'ﺫ' && letters[index - 1] != 'ﺭ' && letters[index - 1] != 'ﺯ' && letters[index - 1] != 'ﮊ' && letters[index - 1] != 'ﻭ' && letters[index - 1] != 'ﺍ' && letters[index - 1] != 'ﺁ' && letters[index - 1] != 'ﺃ' && letters[index - 1] != 'ﺇ' && letters[index - 1] != 'ﺅ' && letters[index - 1] != 'ﺀ' && !char.IsPunctuation(letters[index - 1]) && letters[index - 1] != '>' && letters[index - 1] != '<';
			bool flag = letters[index] != ' ' && letters[index] != 'ﺀ';
			if (num && flag)
			{
				return true;
			}
			return false;
		}

		internal static bool IsMiddleLetter(char[] letters, int index)
		{
			bool flag = index != 0 && letters[index] != 'ﺍ' && letters[index] != 'ﺩ' && letters[index] != 'ﺫ' && letters[index] != 'ﺭ' && letters[index] != 'ﺯ' && letters[index] != 'ﮊ' && letters[index] != 'ﻭ' && letters[index] != 'ﺁ' && letters[index] != 'ﺃ' && letters[index] != 'ﺇ' && letters[index] != 'ﺅ' && letters[index] != 'ﺀ';
			bool flag2 = index != 0 && letters[index - 1] != 'ﺍ' && letters[index - 1] != 'ﺩ' && letters[index - 1] != 'ﺫ' && letters[index - 1] != 'ﺭ' && letters[index - 1] != 'ﺯ' && letters[index - 1] != 'ﮊ' && letters[index - 1] != 'ﻭ' && letters[index - 1] != 'ﺁ' && letters[index - 1] != 'ﺃ' && letters[index - 1] != 'ﺇ' && letters[index - 1] != 'ﺅ' && letters[index - 1] != 'ﺀ' && !char.IsPunctuation(letters[index - 1]) && letters[index - 1] != '>' && letters[index - 1] != '<' && letters[index - 1] != ' ' && letters[index - 1] != '*';
			if (index < letters.Length - 1 && letters[index + 1] != ' ' && letters[index + 1] != '\r' && letters[index + 1] != 'ﺀ' && !char.IsNumber(letters[index + 1]) && !char.IsSymbol(letters[index + 1]) && !char.IsPunctuation(letters[index + 1]) && flag2 && flag)
			{
				try
				{
					if (char.IsPunctuation(letters[index + 1]))
					{
						return false;
					}
					return true;
				}
				catch
				{
					return false;
				}
			}
			return false;
		}
	}
	public class RegisterGlobalParameters : MonoBehaviour, ILocalizationParamsManager
	{
		public virtual void OnEnable()
		{
			if (!LocalizationManager.ParamManagers.Contains(this))
			{
				LocalizationManager.ParamManagers.Add(this);
				LocalizationManager.LocalizeAll(Force: true);
			}
		}

		public virtual void OnDisable()
		{
			LocalizationManager.ParamManagers.Remove(this);
		}

		public virtual string GetParameterValue(string ParamName)
		{
			return null;
		}
	}
	public interface IResourceManager_Bundles
	{
		UnityEngine.Object LoadFromBundle(string path, Type assetType);
	}
	public class ResourceManager : MonoBehaviour
	{
		private static ResourceManager mInstance;

		public List<IResourceManager_Bundles> mBundleManagers = new List<IResourceManager_Bundles>();

		public UnityEngine.Object[] Assets;

		private readonly Dictionary<string, UnityEngine.Object> mResourcesCache = new Dictionary<string, UnityEngine.Object>(StringComparer.Ordinal);

		public static ResourceManager pInstance
		{
			get
			{
				bool flag = mInstance == null;
				if (mInstance == null)
				{
					mInstance = (ResourceManager)UnityEngine.Object.FindObjectOfType(typeof(ResourceManager));
				}
				if (mInstance == null)
				{
					GameObject obj = new GameObject("I2ResourceManager", typeof(ResourceManager));
					obj.hideFlags |= HideFlags.HideAndDontSave;
					mInstance = obj.GetComponent<ResourceManager>();
					SceneManager.sceneLoaded += MyOnLevelWasLoaded;
				}
				if (flag && UnityEngine.Application.isPlaying)
				{
					UnityEngine.Object.DontDestroyOnLoad(mInstance.gameObject);
				}
				return mInstance;
			}
		}

		public static void MyOnLevelWasLoaded(Scene scene, LoadSceneMode mode)
		{
			pInstance.CleanResourceCache();
			LocalizationManager.UpdateSources();
		}

		public T GetAsset<T>(string Name) where T : UnityEngine.Object
		{
			T val = FindAsset(Name) as T;
			if (val != null)
			{
				return val;
			}
			return LoadFromResources<T>(Name);
		}

		private UnityEngine.Object FindAsset(string Name)
		{
			if (Assets != null)
			{
				int i = 0;
				for (int num = Assets.Length; i < num; i++)
				{
					if (Assets[i] != null && Assets[i].name == Name)
					{
						return Assets[i];
					}
				}
			}
			return null;
		}

		public bool HasAsset(UnityEngine.Object Obj)
		{
			if (Assets == null)
			{
				return false;
			}
			return Array.IndexOf(Assets, Obj) >= 0;
		}

		public T LoadFromResources<T>(string Path) where T : UnityEngine.Object
		{
			try
			{
				if (string.IsNullOrEmpty(Path))
				{
					return null;
				}
				if (mResourcesCache.TryGetValue(Path, out var value) && value != null)
				{
					return value as T;
				}
				T val = null;
				if (Path.EndsWith("]", StringComparison.OrdinalIgnoreCase))
				{
					int num = Path.LastIndexOf("[", StringComparison.OrdinalIgnoreCase);
					int length = Path.Length - num - 2;
					string value2 = Path.Substring(num + 1, length);
					Path = Path.Substring(0, num);
					T[] array = Resources.LoadAll<T>(Path);
					int i = 0;
					for (int num2 = array.Length; i < num2; i++)
					{
						if (array[i].name.Equals(value2))
						{
							val = array[i];
							break;
						}
					}
				}
				else
				{
					val = Resources.Load(Path, typeof(T)) as T;
				}
				if (val == null)
				{
					val = LoadFromBundle<T>(Path);
				}
				if (val != null)
				{
					mResourcesCache[Path] = val;
				}
				return val;
			}
			catch (Exception ex)
			{
				UnityEngine.Debug.LogErrorFormat("Unable to load {0} '{1}'\nERROR: {2}", typeof(T), Path, ex.ToString());
				return null;
			}
		}

		public T LoadFromBundle<T>(string path) where T : UnityEngine.Object
		{
			int i = 0;
			for (int count = mBundleManagers.Count; i < count; i++)
			{
				if (mBundleManagers[i] != null)
				{
					T val = mBundleManagers[i].LoadFromBundle(path, typeof(T)) as T;
					if (val != null)
					{
						return val;
					}
				}
			}
			return null;
		}

		public void CleanResourceCache()
		{
			mResourcesCache.Clear();
			Resources.UnloadUnusedAssets();
			CancelInvoke();
		}
	}
	[AddComponentMenu("I2/Localization/SetLanguage Button")]
	public class SetLanguage : MonoBehaviour
	{
		public string _Language;

		private void OnClick()
		{
			ApplyLanguage();
		}

		public void ApplyLanguage()
		{
			if (LocalizationManager.HasLanguage(_Language))
			{
				LocalizationManager.CurrentLanguage = _Language;
			}
		}
	}
	[AddComponentMenu("I2/Localization/SetLanguage Dropdown")]
	public class SetLanguageDropdown : MonoBehaviour
	{
		private void OnEnable()
		{
			Dropdown component = GetComponent<Dropdown>();
			if (!(component == null))
			{
				string currentLanguage = LocalizationManager.CurrentLanguage;
				if (LocalizationManager.Sources.Count == 0)
				{
					LocalizationManager.UpdateSources();
				}
				List<string> allLanguages = LocalizationManager.GetAllLanguages();
				component.ClearOptions();
				component.AddOptions(allLanguages);
				component.value = allLanguages.IndexOf(currentLanguage);
				component.onValueChanged.RemoveListener(OnValueChanged);
				component.onValueChanged.AddListener(OnValueChanged);
			}
		}

		private void OnValueChanged(int index)
		{
			Dropdown component = GetComponent<Dropdown>();
			if (index < 0)
			{
				index = 0;
				component.value = index;
			}
			LocalizationManager.CurrentLanguage = component.options[index].text;
		}
	}
	public class StringObfucator
	{
		public static char[] StringObfuscatorPassword = "ÝúbUu\u00b8CÁÂ§*4PÚ©-á©¾@T6Dl±ÒWâuzÅm4GÐóØ$=Íg,¥Që®iKEßr¡×60Ít4öÃ~^«y:Èd1<QÛÝúbUu\u00b8CÁÂ§*4PÚ©-á©¾@T6Dl±ÒWâuzÅm4GÐóØ$=Íg,¥Që®iKEßr¡×60Ít4öÃ~^«y:Èd".ToCharArray();

		public static string Encode(string NormalString)
		{
			try
			{
				return ToBase64(XoREncode(NormalString));
			}
			catch (Exception)
			{
				return null;
			}
		}

		public static string Decode(string ObfucatedString)
		{
			try
			{
				return XoREncode(FromBase64(ObfucatedString));
			}
			catch (Exception)
			{
				return null;
			}
		}

		private static string ToBase64(string regularString)
		{
			return Convert.ToBase64String(Encoding.UTF8.GetBytes(regularString));
		}

		private static string FromBase64(string base64string)
		{
			byte[] array = Convert.FromBase64String(base64string);
			return Encoding.UTF8.GetString(array, 0, array.Length);
		}

		private static string XoREncode(string NormalString)
		{
			try
			{
				char[] stringObfuscatorPassword = StringObfuscatorPassword;
				char[] array = NormalString.ToCharArray();
				int num = stringObfuscatorPassword.Length;
				int i = 0;
				for (int num2 = array.Length; i < num2; i++)
				{
					array[i] = (char)(array[i] ^ stringObfuscatorPassword[i % num] ^ (byte)((i % 2 == 0) ? (i * 23) : (-i * 51)));
				}
				return new string(array);
			}
			catch (Exception)
			{
				return null;
			}
		}
	}
}
namespace I2.Loc.SimpleJSON
{
	public enum JSONBinaryTag
	{
		Array = 1,
		Class,
		Value,
		IntValue,
		DoubleValue,
		BoolValue,
		FloatValue
	}
	public class JSONNode
	{
		public virtual JSONNode this[int aIndex]
		{
			get
			{
				return null;
			}
			set
			{
			}
		}

		public virtual JSONNode this[string aKey]
		{
			get
			{
				return null;
			}
			set
			{
			}
		}

		public virtual string Value
		{
			get
			{
				return "";
			}
			set
			{
			}
		}

		public virtual int Count => 0;

		public virtual IEnumerable<JSONNode> Childs
		{
			get
			{
				yield break;
			}
		}

		public IEnumerable<JSONNode> DeepChilds
		{
			get
			{
				foreach (JSONNode child in Childs)
				{
					foreach (JSONNode deepChild in child.DeepChilds)
					{
						yield return deepChild;
					}
				}
			}
		}

		public virtual int AsInt
		{
			get
			{
				int result = 0;
				if (int.TryParse(Value, out result))
				{
					return result;
				}
				return 0;
			}
			set
			{
				Value = value.ToString();
			}
		}

		public virtual float AsFloat
		{
			get
			{
				float result = 0f;
				if (float.TryParse(Value, out result))
				{
					return result;
				}
				return 0f;
			}
			set
			{
				Value = value.ToString();
			}
		}

		public virtual double AsDouble
		{
			get
			{
				double result = 0.0;
				if (double.TryParse(Value, out result))
				{
					return result;
				}
				return 0.0;
			}
			set
			{
				Value = value.ToString();
			}
		}

		public virtual bool AsBool
		{
			get
			{
				bool result = false;
				if (bool.TryParse(Value, out result))
				{
					return result;
				}
				return !string.IsNullOrEmpty(Value);
			}
			set
			{
				Value = (value ? "true" : "false");
			}
		}

		public virtual JSONArray AsArray => this as JSONArray;

		public virtual JSONClass AsObject => this as JSONClass;

		public virtual void Add(string aKey, JSONNode aItem)
		{
		}

		public virtual void Add(JSONNode aItem)
		{
			Add("", aItem);
		}

		public virtual JSONNode Remove(string aKey)
		{
			return null;
		}

		public virtual JSONNode Remove(int aIndex)
		{
			return null;
		}

		public virtual JSONNode Remove(JSONNode aNode)
		{
			return aNode;
		}

		public override string ToString()
		{
			return "JSONNode";
		}

		public virtual string ToString(string aPrefix)
		{
			return "JSONNode";
		}

		public static implicit operator JSONNode(string s)
		{
			return new JSONData(s);
		}

		public static implicit operator string(JSONNode d)
		{
			if (!(d == null))
			{
				return d.Value;
			}
			return null;
		}

		public static bool operator ==(JSONNode a, object b)
		{
			if (b == null && a is JSONLazyCreator)
			{
				return true;
			}
			return (object)a == b;
		}

		public static bool operator !=(JSONNode a, object b)
		{
			return !(a == b);
		}

		public override bool Equals(object obj)
		{
			return (object)this == obj;
		}

		public override int GetHashCode()
		{
			return base.GetHashCode();
		}

		internal static string Escape(string aText)
		{
			string text = "";
			for (int i = 0; i < aText.Length; i++)
			{
				char c = aText[i];
				text = c switch
				{
					'\\' => text + "\\\\", 
					'"' => text + "\\\"", 
					'\n' => text + "\\n", 
					'\r' => text + "\\r", 
					'\t' => text + "\\t", 
					'\b' => text + "\\b", 
					'\f' => text + "\\f", 
					_ => text + c, 
				};
			}
			return text;
		}

		public static JSONNode Parse(string aJSON)
		{
			Stack<JSONNode> stack = new Stack<JSONNode>();
			JSONNode jSONNode = null;
			int i = 0;
			string text = "";
			string text2 = "";
			bool flag = false;
			for (; i < aJSON.Length; i++)
			{
				switch (aJSON[i])
				{
				case '{':
					if (flag)
					{
						text += aJSON[i];
						break;
					}
					stack.Push(new JSONClass());
					if (jSONNode != null)
					{
						text2 = text2.Trim();
						if (jSONNode is JSONArray)
						{
							jSONNode.Add(stack.Peek());
						}
						else if (text2 != "")
						{
							jSONNode.Add(text2, stack.Peek());
						}
					}
					text2 = "";
					text = "";
					jSONNode = stack.Peek();
					break;
				case '[':
					if (flag)
					{
						text += aJSON[i];
						break;
					}
					stack.Push(new JSONArray());
					if (jSONNode != null)
					{
						text2 = text2.Trim();
						if (jSONNode is JSONArray)
						{
							jSONNode.Add(stack.Peek());
						}
						else if (text2 != "")
						{
							jSONNode.Add(text2, stack.Peek());
						}
					}
					text2 = "";
					text = "";
					jSONNode = stack.Peek();
					break;
				case ']':
				case '}':
					if (flag)
					{
						text += aJSON[i];
						break;
					}
					if (stack.Count == 0)
					{
						throw new Exception("JSON Parse: Too many closing brackets");
					}
					stack.Pop();
					if (text != "")
					{
						text2 = text2.Trim();
						if (jSONNode is JSONArray)
						{
							jSONNode.Add(text);
						}
						else if (text2 != "")
						{
							jSONNode.Add(text2, text);
						}
					}
					text2 = "";
					text = "";
					if (stack.Count > 0)
					{
						jSONNode = stack.Peek();
					}
					break;
				case ':':
					if (flag)
					{
						text += aJSON[i];
						break;
					}
					text2 = text;
					text = "";
					break;
				case '"':
					flag = !flag;
					break;
				case ',':
					if (flag)
					{
						text += aJSON[i];
						break;
					}
					if (text != "")
					{
						if (jSONNode is JSONArray)
						{
							jSONNode.Add(text);
						}
						else if (text2 != "")
						{
							jSONNode.Add(text2, text);
						}
					}
					text2 = "";
					text = "";
					break;
				case '\t':
				case ' ':
					if (flag)
					{
						text += aJSON[i];
					}
					break;
				case '\\':
					i++;
					if (flag)
					{
						char c = aJSON[i];
						switch (c)
						{
						case 't':
							text += "\t";
							break;
						case 'r':
							text += "\r";
							break;
						case 'n':
							text += "\n";
							break;
						case 'b':
							text += "\b";
							break;
						case 'f':
							text += "\f";
							break;
						case 'u':
						{
							string s = aJSON.Substring(i + 1, 4);
							text += (char)int.Parse(s, NumberStyles.AllowHexSpecifier);
							i += 4;
							break;
						}
						default:
							text += c;
							break;
						}
					}
					break;
				default:
					text += aJSON[i];
					break;
				case '\n':
				case '\r':
					break;
				}
			}
			if (flag)
			{
				throw new Exception("JSON Parse: Quotation marks seems to be messed up.");
			}
			return jSONNode;
		}

		public virtual void Serialize(BinaryWriter aWriter)
		{
		}

		public void SaveToStream(Stream aData)
		{
			BinaryWriter aWriter = new BinaryWriter(aData);
			Serialize(aWriter);
		}

		public void SaveToCompressedStream(Stream aData)
		{
			throw new Exception("Can't use compressed functions. You need include the SharpZipLib and uncomment the define at the top of SimpleJSON");
		}

		public void SaveToCompressedFile(string aFileName)
		{
			throw new Exception("Can't use compressed functions. You need include the SharpZipLib and uncomment the define at the top of SimpleJSON");
		}

		public string SaveToCompressedBase64()
		{
			throw new Exception("Can't use compressed functions. You need include the SharpZipLib and uncomment the define at the top of SimpleJSON");
		}

		public void SaveToFile(string aFileName)
		{
			Directory.CreateDirectory(new FileInfo(aFileName).Directory.FullName);
			using FileStream aData = File.OpenWrite(aFileName);
			SaveToStream(aData);
		}

		public string SaveToBase64()
		{
			using MemoryStream memoryStream = new MemoryStream();
			SaveToStream(memoryStream);
			memoryStream.Position = 0L;
			return Convert.ToBase64String(memoryStream.ToArray());
		}

		public static JSONNode Deserialize(BinaryReader aReader)
		{
			JSONBinaryTag jSONBinaryTag = (JSONBinaryTag)aReader.ReadByte();
			switch (jSONBinaryTag)
			{
			case JSONBinaryTag.Array:
			{
				int num2 = aReader.ReadInt32();
				JSONArray jSONArray = new JSONArray();
				for (int j = 0; j < num2; j++)
				{
					jSONArray.Add(Deserialize(aReader));
				}
				return jSONArray;
			}
			case JSONBinaryTag.Class:
			{
				int num = aReader.ReadInt32();
				JSONClass jSONClass = new JSONClass();
				for (int i = 0; i < num; i++)
				{
					string aKey = aReader.ReadString();
					JSONNode aItem = Deserialize(aReader);
					jSONClass.Add(aKey, aItem);
				}
				return jSONClass;
			}
			case JSONBinaryTag.Value:
				return new JSONData(aReader.ReadString());
			case JSONBinaryTag.IntValue:
				return new JSONData(aReader.ReadInt32());
			case JSONBinaryTag.DoubleValue:
				return new JSONData(aReader.ReadDouble());
			case JSONBinaryTag.BoolValue:
				return new JSONData(aReader.ReadBoolean());
			case JSONBinaryTag.FloatValue:
				return new JSONData(aReader.ReadSingle());
			default:
				throw new Exception("Error deserializing JSON. Unknown tag: " + jSONBinaryTag);
			}
		}

		public static JSONNode LoadFromCompressedFile(string aFileName)
		{
			throw new Exception("Can't use compressed functions. You need include the SharpZipLib and uncomment the define at the top of SimpleJSON");
		}

		public static JSONNode LoadFromCompressedStream(Stream aData)
		{
			throw new Exception("Can't use compressed functions. You need include the SharpZipLib and uncomment the define at the top of SimpleJSON");
		}

		public static JSONNode LoadFromCompressedBase64(string aBase64)
		{
			throw new Exception("Can't use compressed functions. You need include the SharpZipLib and uncomment the define at the top of SimpleJSON");
		}

		public static JSONNode LoadFromStream(Stream aData)
		{
			using BinaryReader aReader = new BinaryReader(aData);
			return Deserialize(aReader);
		}

		public static JSONNode LoadFromFile(string aFileName)
		{
			using FileStream aData = File.OpenRead(aFileName);
			return LoadFromStream(aData);
		}

		public static JSONNode LoadFromBase64(string aBase64)
		{
			return LoadFromStream(new MemoryStream(Convert.FromBase64String(aBase64))
			{
				Position = 0L
			});
		}
	}
	public class JSONArray : JSONNode, IEnumerable
	{
		private List<JSONNode> m_List = new List<JSONNode>();

		public override JSONNode this[int aIndex]
		{
			get
			{
				if (aIndex < 0 || aIndex >= m_List.Count)
				{
					return new JSONLazyCreator(this);
				}
				return m_List[aIndex];
			}
			set
			{
				if (aIndex < 0 || aIndex >= m_List.Count)
				{
					m_List.Add(value);
				}
				else
				{
					m_List[aIndex] = value;
				}
			}
		}

		public override JSONNode this[string aKey]
		{
			get
			{
				return new JSONLazyCreator(this);
			}
			set
			{
				m_List.Add(value);
			}
		}

		public override int Count => m_List.Count;

		public override IEnumerable<JSONNode> Childs
		{
			get
			{
				foreach (JSONNode item in m_List)
				{
					yield return item;
				}
			}
		}

		public override void Add(string aKey, JSONNode aItem)
		{
			m_List.Add(aItem);
		}

		public override JSONNode Remove(int aIndex)
		{
			if (aIndex < 0 || aIndex >= m_List.Count)
			{
				return null;
			}
			JSONNode result = m_List[aIndex];
			m_List.RemoveAt(aIndex);
			return result;
		}

		public override JSONNode Remove(JSONNode aNode)
		{
			m_List.Remove(aNode);
			return aNode;
		}

		public IEnumerator GetEnumerator()
		{
			foreach (JSONNode item in m_List)
			{
				yield return item;
			}
		}

		public override string ToString()
		{
			string text = "[ ";
			foreach (JSONNode item in m_List)
			{
				if (text.Length > 2)
				{
					text += ", ";
				}
				text += item.ToString();
			}
			return text + " ]";
		}

		public override string ToString(string aPrefix)
		{
			string text = "[ ";
			foreach (JSONNode item in m_List)
			{
				if (text.Length > 3)
				{
					text += ", ";
				}
				text = text + "\n" + aPrefix + "   ";
				text += item.ToString(aPrefix + "   ");
			}
			return text + "\n" + aPrefix + "]";
		}

		public override void Serialize(BinaryWriter aWriter)
		{
			aWriter.Write((byte)1);
			aWriter.Write(m_List.Count);
			for (int i = 0; i < m_List.Count; i++)
			{
				m_List[i].Serialize(aWriter);
			}
		}
	}
	public class JSONClass : JSONNode, IEnumerable
	{
		private Dictionary<string, JSONNode> m_Dict = new Dictionary<string, JSONNode>(StringComparer.Ordinal);

		public override JSONNode this[string aKey]
		{
			get
			{
				if (m_Dict.ContainsKey(aKey))
				{
					return m_Dict[aKey];
				}
				return new JSONLazyCreator(this, aKey);
			}
			set
			{
				if (m_Dict.ContainsKey(aKey))
				{
					m_Dict[aKey] = value;
				}
				else
				{
					m_Dict.Add(aKey, value);
				}
			}
		}

		public override JSONNode this[int aIndex]
		{
			get
			{
				if (aIndex < 0 || aIndex >= m_Dict.Count)
				{
					return null;
				}
				return m_Dict.ElementAt(aIndex).Value;
			}
			set
			{
				if (aIndex >= 0 && aIndex < m_Dict.Count)
				{
					string key = m_Dict.ElementAt(aIndex).Key;
					m_Dict[key] = value;
				}
			}
		}

		public override int Count => m_Dict.Count;

		public override IEnumerable<JSONNode> Childs
		{
			get
			{
				foreach (KeyValuePair<string, JSONNode> item in m_Dict)
				{
					yield return item.Value;
				}
			}
		}

		public override void Add(string aKey, JSONNode aItem)
		{
			if (!string.IsNullOrEmpty(aKey))
			{
				if (m_Dict.ContainsKey(aKey))
				{
					m_Dict[aKey] = aItem;
				}
				else
				{
					m_Dict.Add(aKey, aItem);
				}
			}
			else
			{
				m_Dict.Add(Guid.NewGuid().ToString(), aItem);
			}
		}

		public override JSONNode Remove(string aKey)
		{
			if (!m_Dict.ContainsKey(aKey))
			{
				return null;
			}
			JSONNode result = m_Dict[aKey];
			m_Dict.Remove(aKey);
			return result;
		}

		public override JSONNode Remove(int aIndex)
		{
			if (aIndex < 0 || aIndex >= m_Dict.Count)
			{
				return null;
			}
			KeyValuePair<string, JSONNode> keyValuePair = m_Dict.ElementAt(aIndex);
			m_Dict.Remove(keyValuePair.Key);
			return keyValuePair.Value;
		}

		public override JSONNode Remove(JSONNode aNode)
		{
			try
			{
				KeyValuePair<string, JSONNode> keyValuePair = m_Dict.Where((KeyValuePair<string, JSONNode> k) => k.Value == aNode).First();
				m_Dict.Remove(keyValuePair.Key);
				return aNode;
			}
			catch
			{
				return null;
			}
		}

		public IEnumerator GetEnumerator()
		{
			foreach (KeyValuePair<string, JSONNode> item in m_Dict)
			{
				yield return item;
			}
		}

		public override string ToString()
		{
			string text = "{";
			foreach (KeyValuePair<string, JSONNode> item in m_Dict)
			{
				if (text.Length > 2)
				{
					text += ", ";
				}
				text = text + "\"" + JSONNode.Escape(item.Key) + "\":" + item.Value.ToString();
			}
			return text + "}";
		}

		public override string ToString(string aPrefix)
		{
			string text = "{ ";
			foreach (KeyValuePair<string, JSONNode> item in m_Dict)
			{
				if (text.Length > 3)
				{
					text += ", ";
				}
				text = text + "\n" + aPrefix + "   ";
				text = text + "\"" + JSONNode.Escape(item.Key) + "\" : " + item.Value.ToString(aPrefix + "   ");
			}
			return text + "\n" + aPrefix + "}";
		}

		public override void Serialize(BinaryWriter aWriter)
		{
			aWriter.Write((byte)2);
			aWriter.Write(m_Dict.Count);
			foreach (string key in m_Dict.Keys)
			{
				aWriter.Write(key);
				m_Dict[key].Serialize(aWriter);
			}
		}
	}
	public class JSONData : JSONNode
	{
		private string m_Data;

		public override string Value
		{
			get
			{
				return m_Data;
			}
			set
			{
				m_Data = value;
			}
		}

		public JSONData(string aData)
		{
			m_Data = aData;
		}

		public JSONData(float aData)
		{
			AsFloat = aData;
		}

		public JSONData(double aData)
		{
			AsDouble = aData;
		}

		public JSONData(bool aData)
		{
			AsBool = aData;
		}

		public JSONData(int aData)
		{
			AsInt = aData;
		}

		public override string ToString()
		{
			return "\"" + JSONNode.Escape(m_Data) + "\"";
		}

		public override string ToString(string aPrefix)
		{
			return "\"" + JSONNode.Escape(m_Data) + "\"";
		}

		public override void Serialize(BinaryWriter aWriter)
		{
			JSONData jSONData = new JSONData("");
			jSONData.AsInt = AsInt;
			if (jSONData.m_Data == m_Data)
			{
				aWriter.Write((byte)4);
				aWriter.Write(AsInt);
				return;
			}
			jSONData.AsFloat = AsFloat;
			if (jSONData.m_Data == m_Data)
			{
				aWriter.Write((byte)7);
				aWriter.Write(AsFloat);
				return;
			}
			jSONData.AsDouble = AsDouble;
			if (jSONData.m_Data == m_Data)
			{
				aWriter.Write((byte)5);
				aWriter.Write(AsDouble);
				return;
			}
			jSONData.AsBool = AsBool;
			if (jSONData.m_Data == m_Data)
			{
				aWriter.Write((byte)6);
				aWriter.Write(AsBool);
			}
			else
			{
				aWriter.Write((byte)3);
				aWriter.Write(m_Data);
			}
		}
	}
	internal class JSONLazyCreator : JSONNode
	{
		private JSONNode m_Node;

		private string m_Key;

		public override JSONNode this[int aIndex]
		{
			get
			{
				return new JSONLazyCreator(this);
			}
			set
			{
				JSONArray jSONArray = new JSONArray();
				jSONArray.Add(value);
				Set(jSONArray);
			}
		}

		public override JSONNode this[string aKey]
		{
			get
			{
				return new JSONLazyCreator(this, aKey);
			}
			set
			{
				JSONClass jSONClass = new JSONClass();
				jSONClass.Add(aKey, value);
				Set(jSONClass);
			}
		}

		public override int AsInt
		{
			get
			{
				JSONData aVal = new JSONData(0);
				Set(aVal);
				return 0;
			}
			set
			{
				JSONData aVal = new JSONData(value);
				Set(aVal);
			}
		}

		public override float AsFloat
		{
			get
			{
				JSONData aVal = new JSONData(0f);
				Set(aVal);
				return 0f;
			}
			set
			{
				JSONData aVal = new JSONData(value);
				Set(aVal);
			}
		}

		public override double AsDouble
		{
			get
			{
				JSONData aVal = new JSONData(0.0);
				Set(aVal);
				return 0.0;
			}
			set
			{
				JSONData aVal = new JSONData(value);
				Set(aVal);
			}
		}

		public override bool AsBool
		{
			get
			{
				JSONData aVal = new JSONData(aData: false);
				Set(aVal);
				return false;
			}
			set
			{
				JSONData aVal = new JSONData(value);
				Set(aVal);
			}
		}

		public override JSONArray AsArray
		{
			get
			{
				JSONArray jSONArray = new JSONArray();
				Set(jSONArray);
				return jSONArray;
			}
		}

		public override JSONClass AsObject
		{
			get
			{
				JSONClass jSONClass = new JSONClass();
				Set(jSONClass);
				return jSONClass;
			}
		}

		public JSONLazyCreator(JSONNode aNode)
		{
			m_Node = aNode;
			m_Key = null;
		}

		public JSONLazyCreator(JSONNode aNode, string aKey)
		{
			m_Node = aNode;
			m_Key = aKey;
		}

		private void Set(JSONNode aVal)
		{
			if (m_Key == null)
			{
				m_Node.Add(aVal);
			}
			else
			{
				m_Node.Add(m_Key, aVal);
			}
			m_Node = null;
		}

		public override void Add(JSONNode aItem)
		{
			JSONArray jSONArray = new JSONArray();
			jSONArray.Add(aItem);
			Set(jSONArray);
		}

		public override void Add(string aKey, JSONNode aItem)
		{
			JSONClass jSONClass = new JSONClass();
			jSONClass.Add(aKey, aItem);
			Set(jSONClass);
		}

		public static bool operator ==(JSONLazyCreator a, object b)
		{
			if (b == null)
			{
				return true;
			}
			return (object)a == b;
		}

		public static bool operator !=(JSONLazyCreator a, object b)
		{
			return !(a == b);
		}

		public override bool Equals(object obj)
		{
			if (obj == null)
			{
				return true;
			}
			return (object)this == obj;
		}

		public override int GetHashCode()
		{
			return base.GetHashCode();
		}

		public override string ToString()
		{
			return "";
		}

		public override string ToString(string aPrefix)
		{
			return "";
		}
	}
	public static class JSON
	{
		public static JSONNode Parse(string aJSON)
		{
			return JSONNode.Parse(aJSON);
		}
	}
}
namespace RogoDigital
{
	[AddComponentMenu("Rogo Digital/Eye Controller")]
	public class EyeController : BlendSystemUser
	{
		public enum ControlMode
		{
			Classic,
			PoseBased
		}

		public enum Axis
		{
			X_Positive,
			X_Negative,
			Y_Positive,
			Y_Negative,
			Z_Positive,
			Z_Negative
		}

		public class BoneShapeInfo
		{
			private Transform bone;

			private Vector3 m_storedPosition;

			private Quaternion m_storedRotation;

			public Vector3 targetPosition;

			public Quaternion targetRotation;

			public Vector3 storedPosition
			{
				get
				{
					return m_storedPosition;
				}
				set
				{
					m_storedPosition = value;
					bone.localPosition = value;
				}
			}

			public Quaternion storedRotation
			{
				get
				{
					return m_storedRotation;
				}
				set
				{
					m_storedRotation = value;
					bone.localRotation = value;
				}
			}

			public BoneShapeInfo(BoneShape boneShape)
			{
				bone = boneShape.bone;
				m_storedPosition = boneShape.neutralPosition;
				m_storedRotation = Quaternion.Euler(boneShape.neutralRotation);
			}
		}

		public bool blinkingEnabled;

		public ControlMode blinkingControlMode;

		public RogoDigital.Lipsync.Shape blinkingShape;

		[FormerlySerializedAs("leftEyeBlinkBlendshape")]
		public int leftEyeBlinkBlendable;

		[FormerlySerializedAs("rightEyeBlinkBlendshape")]
		public int rightEyeBlinkBlendable = 1;

		public float minimumBlinkGap = 1f;

		public float maximumBlinkGap = 4f;

		[FormerlySerializedAs("blinkSpeed")]
		public float blinkDuration = 0.14f;

		public bool randomLookingEnabled;

		public ControlMode lookingControlMode;

		public RogoDigital.Lipsync.Shape lookingUpShape;

		public RogoDigital.Lipsync.Shape lookingDownShape;

		public RogoDigital.Lipsync.Shape lookingLeftShape;

		public RogoDigital.Lipsync.Shape lookingRightShape;

		[SerializeField]
		[FormerlySerializedAs("leftEyeLookAtBone")]
		private Transform _leftEyeLookAtBone;

		[SerializeField]
		[FormerlySerializedAs("rightEyeLookAtBone")]
		private Transform _rightEyeLookAtBone;

		public Vector2 eyeRotationRangeX = new Vector2(-6.5f, 6.5f);

		public Vector2 eyeRotationRangeY = new Vector2(-17.2f, 17.2f);

		public Vector3 eyeLookOffset;

		public Axis eyeForwardAxis = Axis.Z_Positive;

		public float eyeTurnSpeed = 18f;

		public float minimumChangeDirectionGap = 2f;

		public float maximumChangeDirectionGap = 10f;

		public bool targetEnabled;

		public bool autoTarget;

		public string autoTargetTag = "EyeControllerTarget";

		public float autoTargetDistance = 10f;

		public Transform viewTarget;

		public float targetWeight = 1f;

		public bool boneUpdateAnimation;

		private float blinkTimer;

		private bool blinking;

		private bool _keepEyesClosed;

		private bool _asyncBlending;

		private Transform leftEyeDummy;

		private Transform rightEyeDummy;

		private Quaternion leftRotation;

		private Quaternion rightRotation;

		private Vector3[] axisOffsets = new Vector3[6]
		{
			new Vector3(0f, -90f, 0f),
			new Vector3(0f, 90f, 0f),
			new Vector3(90f, 0f, 0f),
			new Vector3(-90f, 0f, 0f),
			new Vector3(0f, 0f, 0f),
			new Vector3(0f, 180f, 0f)
		};

		private float lookTimer;

		private Quaternion randomAngle;

		private Vector2 randomBlend;

		private Transform target;

		private Quaternion leftTargetAngle;

		private Quaternion rightTargetAngle;

		private Transform[] markedTargets;

		private Dictionary<Transform, BoneShapeInfo> boneShapes;

		public bool keepEyesClosed
		{
			get
			{
				return _keepEyesClosed;
			}
			set
			{
				if (value)
				{
					if (_keepEyesClosed != value)
					{
						StartCoroutine(CloseEyes());
					}
				}
				else if (_keepEyesClosed != value)
				{
					StartCoroutine(OpenEyes());
				}
				_keepEyesClosed = value;
			}
		}

		public Transform LeftEyeLookAtBone
		{
			get
			{
				return _leftEyeLookAtBone;
			}
			set
			{
				if (!(_leftEyeLookAtBone == value))
				{
					_leftEyeLookAtBone = value;
					if (UnityEngine.Application.isPlaying)
					{
						FixDummyHierarchy();
					}
				}
			}
		}

		public Transform RightEyeLookAtBone
		{
			get
			{
				return _rightEyeLookAtBone;
			}
			set
			{
				if (!(_rightEyeLookAtBone == value))
				{
					_rightEyeLookAtBone = value;
					if (UnityEngine.Application.isPlaying)
					{
						FixDummyHierarchy();
					}
				}
			}
		}

		private void Start()
		{
			randomAngle = Quaternion.identity;
			leftTargetAngle = Quaternion.identity;
			rightTargetAngle = Quaternion.identity;
			if (LeftEyeLookAtBone != null && RightEyeLookAtBone != null)
			{
				leftRotation = LeftEyeLookAtBone.rotation;
				rightRotation = RightEyeLookAtBone.rotation;
			}
			if (targetEnabled && autoTarget)
			{
				FindTargets();
			}
			leftEyeDummy = new GameObject("Left Eye Dummy").transform;
			rightEyeDummy = new GameObject("Right Eye Dummy").transform;
			leftEyeDummy.gameObject.hideFlags = HideFlags.DontSave;
			rightEyeDummy.gameObject.hideFlags = HideFlags.DontSave;
			FixDummyHierarchy();
			boneShapes = new Dictionary<Transform, BoneShapeInfo>();
			if (blinkingControlMode == ControlMode.PoseBased)
			{
				foreach (BoneShape bone in blinkingShape.bones)
				{
					if (!boneShapes.ContainsKey(bone.bone))
					{
						boneShapes.Add(bone.bone, new BoneShapeInfo(bone));
					}
				}
			}
			if (lookingControlMode != ControlMode.PoseBased)
			{
				return;
			}
			foreach (BoneShape bone2 in lookingUpShape.bones)
			{
				if (!boneShapes.ContainsKey(bone2.bone))
				{
					boneShapes.Add(bone2.bone, new BoneShapeInfo(bone2));
				}
			}
			foreach (BoneShape bone3 in lookingDownShape.bones)
			{
				if (!boneShapes.ContainsKey(bone3.bone))
				{
					boneShapes.Add(bone3.bone, new BoneShapeInfo(bone3));
				}
			}
			foreach (BoneShape bone4 in lookingLeftShape.bones)
			{
				if (!boneShapes.ContainsKey(bone4.bone))
				{
					boneShapes.Add(bone4.bone, new BoneShapeInfo(bone4));
				}
			}
			foreach (BoneShape bone5 in lookingRightShape.bones)
			{
				if (!boneShapes.ContainsKey(bone5.bone))
				{
					boneShapes.Add(bone5.bone, new BoneShapeInfo(bone5));
				}
			}
		}

		private void LateUpdate()
		{
			if (!leftEyeDummy || !rightEyeDummy)
			{
				FixDummyHierarchy();
			}
			if (blinkingEnabled && blendSystem != null && !keepEyesClosed && !_asyncBlending && blendSystem.isReady)
			{
				if (blinking)
				{
					float num = blinkDuration / 2f;
					if (blinkTimer < num)
					{
						if (blinkingControlMode == ControlMode.Classic)
						{
							blendSystem.SetBlendableValue(leftEyeBlinkBlendable, Mathf.Lerp(0f, 100f, blinkTimer / num));
							blendSystem.SetBlendableValue(rightEyeBlinkBlendable, Mathf.Lerp(0f, 100f, blinkTimer / num));
						}
						else if (blinkingControlMode == ControlMode.PoseBased)
						{
							for (int i = 0; i < blinkingShape.blendShapes.Count; i++)
							{
								blendSystem.SetBlendableValue(blinkingShape.blendShapes[i], Mathf.Lerp(0f, blinkingShape.weights[i], blinkTimer / num));
							}
							for (int j = 0; j < blinkingShape.bones.Count; j++)
							{
								if (boneUpdateAnimation)
								{
									Vector3 vector = Vector3.Lerp(boneShapes[blinkingShape.bones[j].bone].storedPosition, blinkingShape.bones[j].endPosition, blinkTimer / num) - blinkingShape.bones[j].neutralPosition;
									Vector3 vector2 = Vector3.Lerp(boneShapes[blinkingShape.bones[j].bone].storedRotation.eulerAngles, blinkingShape.bones[j].endRotation, blinkTimer / num) - blinkingShape.bones[j].neutralRotation;
									if (!blinkingShape.bones[j].lockPosition)
									{
										blinkingShape.bones[j].bone.localPosition += vector;
									}
									if (!blinkingShape.bones[j].lockRotation)
									{
										blinkingShape.bones[j].bone.localEulerAngles += vector2;
									}
								}
								else
								{
									if (!blinkingShape.bones[j].lockPosition)
									{
										blinkingShape.bones[j].bone.localPosition = Vector3.Lerp(boneShapes[blinkingShape.bones[j].bone].storedPosition, blinkingShape.bones[j].endPosition, blinkTimer / num);
									}
									if (!blinkingShape.bones[j].lockRotation)
									{
										blinkingShape.bones[j].bone.localEulerAngles = Vector3.Lerp(boneShapes[blinkingShape.bones[j].bone].storedRotation.eulerAngles, blinkingShape.bones[j].endRotation, blinkTimer / num);
									}
								}
							}
						}
					}
					else
					{
						if (blinkingControlMode == ControlMode.Classic)
						{
							blendSystem.SetBlendableValue(leftEyeBlinkBlendable, Mathf.Lerp(100f, 0f, (blinkTimer - num) / num));
							blendSystem.SetBlendableValue(rightEyeBlinkBlendable, Mathf.Lerp(100f, 0f, (blinkTimer - num) / num));
						}
						else if (blinkingControlMode == ControlMode.PoseBased)
						{
							for (int k = 0; k < blinkingShape.blendShapes.Count; k++)
							{
								blendSystem.SetBlendableValue(blinkingShape.blendShapes[k], Mathf.Lerp(blinkingShape.weights[k], 0f, (blinkTimer - num) / num));
							}
							for (int l = 0; l < blinkingShape.bones.Count; l++)
							{
								if (boneUpdateAnimation)
								{
									Vector3 vector3 = Vector3.Lerp(blinkingShape.bones[l].endPosition, boneShapes[blinkingShape.bones[l].bone].storedPosition, (blinkTimer - num) / num) - blinkingShape.bones[l].neutralPosition;
									Vector3 vector4 = Vector3.Lerp(blinkingShape.bones[l].endRotation, boneShapes[blinkingShape.bones[l].bone].storedRotation.eulerAngles, (blinkTimer - num) / num) - blinkingShape.bones[l].neutralRotation;
									if (!blinkingShape.bones[l].lockPosition)
									{
										blinkingShape.bones[l].bone.localPosition += vector3;
									}
									if (!blinkingShape.bones[l].lockRotation)
									{
										blinkingShape.bones[l].bone.localEulerAngles += vector4;
									}
								}
								else
								{
									if (!blinkingShape.bones[l].lockPosition)
									{
										blinkingShape.bones[l].bone.localPosition = Vector3.Lerp(blinkingShape.bones[l].endPosition, boneShapes[blinkingShape.bones[l].bone].storedPosition, (blinkTimer - num) / num);
									}
									if (!blinkingShape.bones[l].lockRotation)
									{
										blinkingShape.bones[l].bone.localEulerAngles = Vector3.Lerp(blinkingShape.bones[l].endRotation, boneShapes[blinkingShape.bones[l].bone].storedRotation.eulerAngles, (blinkTimer - num) / num);
									}
								}
							}
						}
						if (blinkTimer > blinkDuration)
						{
							blinking = false;
							blinkTimer = UnityEngine.Random.Range(minimumBlinkGap, maximumBlinkGap);
						}
					}
					blinkTimer += Time.deltaTime;
				}
				else if (blinkTimer <= 0f)
				{
					blinking = true;
					blinkTimer = 0f;
				}
				else
				{
					blinkTimer -= Time.deltaTime;
				}
			}
			if (targetEnabled && lookingControlMode != ControlMode.PoseBased && leftEyeDummy != null && rightEyeDummy != null)
			{
				if (autoTarget)
				{
					try
					{
						float num2 = autoTargetDistance;
						target = null;
						for (int m = 0; m < markedTargets.Length; m++)
						{
							if (Vector3.Distance(base.transform.position, markedTargets[m].position) < num2)
							{
								num2 = Vector3.Distance(base.transform.position, markedTargets[m].position);
								target = markedTargets[m];
							}
						}
					}
					catch (NullReferenceException)
					{
						FindTargets();
					}
				}
				else
				{
					target = viewTarget;
				}
				if (target != null)
				{
					Vector3 vector5 = leftEyeDummy.parent.InverseTransformEulerAngle(Quaternion.LookRotation(target.position - leftEyeDummy.position).eulerAngles).ToNegativeEuler();
					Vector3 vector6 = rightEyeDummy.parent.InverseTransformEulerAngle(Quaternion.LookRotation(target.position - rightEyeDummy.position).eulerAngles).ToNegativeEuler();
					vector5 = new Vector3(Mathf.Clamp(vector5.x, eyeRotationRangeX.x, eyeRotationRangeX.y), Mathf.Clamp(vector5.y, eyeRotationRangeY.x, eyeRotationRangeY.y), 0f) + eyeLookOffset;
					vector6 = new Vector3(Mathf.Clamp(vector6.x, eyeRotationRangeX.x, eyeRotationRangeX.y), Mathf.Clamp(vector6.y, eyeRotationRangeY.x, eyeRotationRangeY.y), 0f) + eyeLookOffset;
					leftTargetAngle = Quaternion.Euler(leftEyeDummy.parent.TransformEulerAngle(vector5));
					rightTargetAngle = Quaternion.Euler(rightEyeDummy.parent.TransformEulerAngle(vector6));
				}
			}
			else
			{
				targetWeight = 0f;
			}
			if (randomLookingEnabled && ((leftEyeDummy != null && rightEyeDummy != null && lookingControlMode == ControlMode.Classic) || lookingControlMode == ControlMode.PoseBased))
			{
				if (lookTimer <= 0f)
				{
					lookTimer = UnityEngine.Random.Range(minimumChangeDirectionGap, maximumChangeDirectionGap);
					if (lookingControlMode == ControlMode.Classic)
					{
						randomAngle = Quaternion.Euler(UnityEngine.Random.Range(eyeRotationRangeX.x, eyeRotationRangeX.y), UnityEngine.Random.Range(eyeRotationRangeY.x, eyeRotationRangeY.y), 0f) * Quaternion.Euler(eyeLookOffset);
					}
					else if (lookingControlMode == ControlMode.PoseBased)
					{
						randomBlend = new Vector2(UnityEngine.Random.Range(-1f, 1f), UnityEngine.Random.Range(-1f, 1f));
					}
				}
				else
				{
					lookTimer -= Time.deltaTime;
				}
			}
			if ((!(leftEyeDummy != null) || !(rightEyeDummy != null) || (!randomLookingEnabled && !targetEnabled)) && lookingControlMode != ControlMode.PoseBased)
			{
				return;
			}
			if (lookingControlMode == ControlMode.Classic)
			{
				leftEyeDummy.rotation = leftRotation;
				rightEyeDummy.rotation = rightRotation;
				Quaternion b = Quaternion.Lerp(leftEyeDummy.parent.rotation * randomAngle, leftTargetAngle, targetWeight);
				Quaternion b2 = Quaternion.Lerp(rightEyeDummy.parent.rotation * randomAngle, rightTargetAngle, targetWeight);
				leftEyeDummy.rotation = Quaternion.Lerp(leftEyeDummy.rotation, b, Time.deltaTime * eyeTurnSpeed);
				rightEyeDummy.rotation = Quaternion.Lerp(rightEyeDummy.rotation, b2, Time.deltaTime * eyeTurnSpeed);
				Transform leftEyeLookAtBone = LeftEyeLookAtBone;
				Vector3 localPosition = (RightEyeLookAtBone.localPosition = Vector3.zero);
				leftEyeLookAtBone.localPosition = localPosition;
				LeftEyeLookAtBone.localEulerAngles = axisOffsets[(int)eyeForwardAxis];
				RightEyeLookAtBone.localEulerAngles = axisOffsets[(int)eyeForwardAxis];
				leftRotation = leftEyeDummy.rotation;
				rightRotation = rightEyeDummy.rotation;
			}
			else
			{
				if (lookingControlMode != ControlMode.PoseBased)
				{
					return;
				}
				if (randomBlend.y >= 0f)
				{
					for (int n = 0; n < lookingUpShape.blendShapes.Count; n++)
					{
						if (blinkingControlMode == ControlMode.PoseBased)
						{
							if (!blinkingShape.blendShapes.Contains(lookingUpShape.blendShapes[n]) || (!blinking && !keepEyesClosed))
							{
								blendSystem.SetBlendableValue(lookingUpShape.blendShapes[n], Mathf.Lerp(blendSystem.GetBlendableValue(lookingUpShape.blendShapes[n]), Mathf.Lerp(0f, lookingUpShape.weights[n], randomBlend.y), Time.deltaTime * eyeTurnSpeed));
							}
						}
						else if ((leftEyeBlinkBlendable != lookingUpShape.blendShapes[n] && rightEyeBlinkBlendable != lookingUpShape.blendShapes[n]) || (!blinking && !keepEyesClosed))
						{
							blendSystem.SetBlendableValue(lookingUpShape.blendShapes[n], Mathf.Lerp(blendSystem.GetBlendableValue(lookingUpShape.blendShapes[n]), Mathf.Lerp(0f, lookingUpShape.weights[n], randomBlend.y), Time.deltaTime * eyeTurnSpeed));
						}
					}
					for (int num3 = 0; num3 < lookingUpShape.bones.Count; num3++)
					{
						if (blinkingControlMode == ControlMode.PoseBased && blinkingShape.HasBone(lookingUpShape.bones[num3].bone) && (blinking || keepEyesClosed))
						{
							continue;
						}
						Vector3 vector7 = Vector3.Lerp(lookingUpShape.bones[num3].neutralPosition, lookingUpShape.bones[num3].endPosition, randomBlend.y);
						Vector3 vector8 = Vector3LerpAngle(lookingUpShape.bones[num3].neutralRotation, lookingUpShape.bones[num3].endRotation, randomBlend.y);
						if (boneUpdateAnimation)
						{
							if (!lookingUpShape.bones[num3].lockPosition)
							{
								boneShapes[lookingUpShape.bones[num3].bone].targetPosition = lookingUpShape.bones[num3].bone.localPosition + (vector7 - lookingUpShape.bones[num3].neutralPosition);
							}
							if (!lookingUpShape.bones[num3].lockRotation)
							{
								boneShapes[lookingUpShape.bones[num3].bone].targetRotation = Quaternion.Euler(lookingUpShape.bones[num3].bone.localEulerAngles + (vector8 - lookingUpShape.bones[num3].neutralRotation));
							}
						}
						else
						{
							if (!lookingUpShape.bones[num3].lockPosition)
							{
								boneShapes[lookingUpShape.bones[num3].bone].targetPosition = vector7;
							}
							if (!lookingUpShape.bones[num3].lockRotation)
							{
								boneShapes[lookingUpShape.bones[num3].bone].targetRotation = Quaternion.Euler(vector8);
							}
						}
						if (!lookingUpShape.bones[num3].lockPosition)
						{
							boneShapes[lookingUpShape.bones[num3].bone].storedPosition = Vector3.Lerp(boneShapes[lookingUpShape.bones[num3].bone].storedPosition, boneShapes[lookingUpShape.bones[num3].bone].targetPosition, Time.deltaTime * eyeTurnSpeed);
						}
						if (!lookingUpShape.bones[num3].lockRotation)
						{
							boneShapes[lookingUpShape.bones[num3].bone].storedRotation = Quaternion.Lerp(boneShapes[lookingUpShape.bones[num3].bone].storedRotation, boneShapes[lookingUpShape.bones[num3].bone].targetRotation, Time.deltaTime * eyeTurnSpeed);
						}
					}
				}
				else
				{
					for (int num4 = 0; num4 < lookingDownShape.blendShapes.Count; num4++)
					{
						if (blinkingControlMode == ControlMode.PoseBased)
						{
							if (!blinkingShape.blendShapes.Contains(lookingDownShape.blendShapes[num4]) || (!blinking && !keepEyesClosed))
							{
								blendSystem.SetBlendableValue(lookingDownShape.blendShapes[num4], Mathf.Lerp(blendSystem.GetBlendableValue(lookingDownShape.blendShapes[num4]), Mathf.Lerp(0f, lookingDownShape.weights[num4], 0f - randomBlend.y), Time.deltaTime * eyeTurnSpeed));
							}
						}
						else if ((leftEyeBlinkBlendable != lookingDownShape.blendShapes[num4] && rightEyeBlinkBlendable != lookingDownShape.blendShapes[num4]) || (!blinking && !keepEyesClosed))
						{
							blendSystem.SetBlendableValue(lookingDownShape.blendShapes[num4], Mathf.Lerp(blendSystem.GetBlendableValue(lookingDownShape.blendShapes[num4]), Mathf.Lerp(0f, lookingDownShape.weights[num4], 0f - randomBlend.y), Time.deltaTime * eyeTurnSpeed));
						}
					}
					for (int num5 = 0; num5 < lookingDownShape.bones.Count; num5++)
					{
						if (blinkingControlMode == ControlMode.PoseBased && blinkingShape.HasBone(lookingDownShape.bones[num5].bone) && (blinking || keepEyesClosed))
						{
							continue;
						}
						Vector3 vector9 = Vector3.Lerp(lookingDownShape.bones[num5].neutralPosition, lookingDownShape.bones[num5].endPosition, 0f - randomBlend.y);
						Vector3 vector10 = Vector3LerpAngle(lookingDownShape.bones[num5].neutralRotation, lookingDownShape.bones[num5].endRotation, 0f - randomBlend.y);
						if (boneUpdateAnimation)
						{
							if (!lookingDownShape.bones[num5].lockPosition)
							{
								boneShapes[lookingDownShape.bones[num5].bone].targetPosition = lookingDownShape.bones[num5].bone.localPosition + (vector9 - lookingDownShape.bones[num5].neutralPosition);
							}
							if (!lookingDownShape.bones[num5].lockRotation)
							{
								boneShapes[lookingDownShape.bones[num5].bone].targetRotation = Quaternion.Euler(lookingDownShape.bones[num5].bone.localEulerAngles + (vector10 - lookingDownShape.bones[num5].neutralRotation));
							}
						}
						else
						{
							if (!lookingDownShape.bones[num5].lockPosition)
							{
								boneShapes[lookingDownShape.bones[num5].bone].targetPosition = vector9;
							}
							if (!lookingDownShape.bones[num5].lockRotation)
							{
								boneShapes[lookingDownShape.bones[num5].bone].targetRotation = Quaternion.Euler(vector10);
							}
						}
						if (!lookingDownShape.bones[num5].lockPosition)
						{
							boneShapes[lookingDownShape.bones[num5].bone].storedPosition = Vector3.Lerp(boneShapes[lookingDownShape.bones[num5].bone].storedPosition, boneShapes[lookingDownShape.bones[num5].bone].targetPosition, Time.deltaTime * eyeTurnSpeed);
						}
						if (!lookingDownShape.bones[num5].lockRotation)
						{
							boneShapes[lookingDownShape.bones[num5].bone].storedRotation = Quaternion.Lerp(boneShapes[lookingDownShape.bones[num5].bone].storedRotation, boneShapes[lookingDownShape.bones[num5].bone].targetRotation, Time.deltaTime * eyeTurnSpeed);
						}
					}
				}
				if (randomBlend.x >= 0f)
				{
					for (int num6 = 0; num6 < lookingRightShape.blendShapes.Count; num6++)
					{
						if (blinkingControlMode == ControlMode.PoseBased)
						{
							if (!blinkingShape.blendShapes.Contains(lookingRightShape.blendShapes[num6]) || (!blinking && !keepEyesClosed))
							{
								blendSystem.SetBlendableValue(lookingRightShape.blendShapes[num6], Mathf.Lerp(blendSystem.GetBlendableValue(lookingRightShape.blendShapes[num6]), Mathf.Lerp(0f, lookingRightShape.weights[num6], randomBlend.x), Time.deltaTime * eyeTurnSpeed));
							}
						}
						else if ((leftEyeBlinkBlendable != lookingRightShape.blendShapes[num6] && rightEyeBlinkBlendable != lookingRightShape.blendShapes[num6]) || (!blinking && !keepEyesClosed))
						{
							blendSystem.SetBlendableValue(lookingRightShape.blendShapes[num6], Mathf.Lerp(blendSystem.GetBlendableValue(lookingRightShape.blendShapes[num6]), Mathf.Lerp(0f, lookingRightShape.weights[num6], randomBlend.x), Time.deltaTime * eyeTurnSpeed));
						}
					}
					for (int num7 = 0; num7 < lookingRightShape.bones.Count; num7++)
					{
						if (blinkingControlMode != ControlMode.PoseBased || !blinkingShape.HasBone(lookingRightShape.bones[num7].bone) || (!blinking && !keepEyesClosed))
						{
							Vector3 vector11 = Vector3.Lerp(lookingRightShape.bones[num7].neutralPosition, lookingRightShape.bones[num7].endPosition, randomBlend.x) - lookingRightShape.bones[num7].neutralPosition;
							Vector3 vector12 = Vector3LerpAngle(lookingRightShape.bones[num7].neutralRotation, lookingRightShape.bones[num7].endRotation, randomBlend.x) - lookingRightShape.bones[num7].neutralRotation;
							if (!lookingRightShape.bones[num7].lockPosition)
							{
								boneShapes[lookingRightShape.bones[num7].bone].targetPosition = lookingRightShape.bones[num7].bone.localPosition + vector11;
							}
							if (!lookingRightShape.bones[num7].lockRotation)
							{
								boneShapes[lookingRightShape.bones[num7].bone].targetRotation = Quaternion.Euler(lookingRightShape.bones[num7].bone.localEulerAngles + vector12);
							}
							if (!lookingRightShape.bones[num7].lockPosition)
							{
								boneShapes[lookingRightShape.bones[num7].bone].storedPosition = Vector3.Lerp(boneShapes[lookingRightShape.bones[num7].bone].storedPosition, boneShapes[lookingRightShape.bones[num7].bone].targetPosition, Time.deltaTime * eyeTurnSpeed);
							}
							if (!lookingRightShape.bones[num7].lockRotation)
							{
								boneShapes[lookingRightShape.bones[num7].bone].storedRotation = Quaternion.Lerp(boneShapes[lookingRightShape.bones[num7].bone].storedRotation, boneShapes[lookingRightShape.bones[num7].bone].targetRotation, Time.deltaTime * eyeTurnSpeed);
							}
						}
					}
					return;
				}
				for (int num8 = 0; num8 < lookingLeftShape.blendShapes.Count; num8++)
				{
					if (blinkingControlMode == ControlMode.PoseBased)
					{
						if (!blinkingShape.blendShapes.Contains(lookingLeftShape.blendShapes[num8]) || (!blinking && !keepEyesClosed))
						{
							blendSystem.SetBlendableValue(lookingLeftShape.blendShapes[num8], Mathf.Lerp(blendSystem.GetBlendableValue(lookingRightShape.blendShapes[num8]), Mathf.Lerp(0f, lookingLeftShape.weights[num8], 0f - randomBlend.x), Time.deltaTime * eyeTurnSpeed));
						}
					}
					else if ((leftEyeBlinkBlendable != lookingLeftShape.blendShapes[num8] && rightEyeBlinkBlendable != lookingLeftShape.blendShapes[num8]) || (!blinking && !keepEyesClosed))
					{
						blendSystem.SetBlendableValue(lookingLeftShape.blendShapes[num8], Mathf.Lerp(blendSystem.GetBlendableValue(lookingRightShape.blendShapes[num8]), Mathf.Lerp(0f, lookingLeftShape.weights[num8], 0f - randomBlend.x), Time.deltaTime * eyeTurnSpeed));
					}
				}
				for (int num9 = 0; num9 < lookingLeftShape.bones.Count; num9++)
				{
					if (blinkingControlMode != ControlMode.PoseBased || !blinkingShape.HasBone(lookingLeftShape.bones[num9].bone) || (!blinking && !keepEyesClosed))
					{
						Vector3 vector13 = Vector3.Lerp(lookingLeftShape.bones[num9].neutralPosition, lookingLeftShape.bones[num9].endPosition, 0f - randomBlend.x) - lookingLeftShape.bones[num9].neutralPosition;
						Vector3 vector14 = Vector3LerpAngle(lookingLeftShape.bones[num9].neutralRotation, lookingLeftShape.bones[num9].endRotation, 0f - randomBlend.x) - lookingLeftShape.bones[num9].neutralRotation;
						if (!lookingLeftShape.bones[num9].lockPosition)
						{
							boneShapes[lookingLeftShape.bones[num9].bone].targetPosition = lookingLeftShape.bones[num9].bone.localPosition + vector13;
						}
						if (!lookingLeftShape.bones[num9].lockRotation)
						{
							boneShapes[lookingLeftShape.bones[num9].bone].targetRotation = Quaternion.Euler(lookingLeftShape.bones[num9].bone.localEulerAngles + vector14);
						}
						if (!lookingLeftShape.bones[num9].lockPosition)
						{
							boneShapes[lookingLeftShape.bones[num9].bone].storedPosition = Vector3.Lerp(boneShapes[lookingLeftShape.bones[num9].bone].storedPosition, boneShapes[lookingLeftShape.bones[num9].bone].targetPosition, Time.deltaTime * eyeTurnSpeed);
						}
						if (!lookingLeftShape.bones[num9].lockRotation)
						{
							boneShapes[lookingLeftShape.bones[num9].bone].storedRotation = Quaternion.Lerp(boneShapes[lookingLeftShape.bones[num9].bone].storedRotation, boneShapes[lookingLeftShape.bones[num9].bone].targetRotation, Time.deltaTime * eyeTurnSpeed);
						}
					}
				}
			}
		}

		private IEnumerator CloseEyes()
		{
			bool end = false;
			blinkTimer = 0f;
			_asyncBlending = true;
			while (!end)
			{
				if (blinkingControlMode == ControlMode.Classic)
				{
					blendSystem.SetBlendableValue(leftEyeBlinkBlendable, Mathf.Lerp(0f, 100f, blinkTimer / blinkDuration));
					blendSystem.SetBlendableValue(rightEyeBlinkBlendable, Mathf.Lerp(0f, 100f, blinkTimer / blinkDuration));
				}
				else
				{
					for (int i = 0; i < blinkingShape.blendShapes.Count; i++)
					{
						blendSystem.SetBlendableValue(blinkingShape.blendShapes[i], Mathf.Lerp(0f, 100f, blinkTimer / blinkDuration));
					}
					for (int j = 0; j < blinkingShape.bones.Count; j++)
					{
						if (boneUpdateAnimation)
						{
							Vector3 vector = Vector3.Lerp(blinkingShape.bones[j].neutralPosition, blinkingShape.bones[j].endPosition, blinkTimer / blinkDuration) - blinkingShape.bones[j].neutralPosition;
							Vector3 vector2 = Vector3.Lerp(blinkingShape.bones[j].neutralRotation, blinkingShape.bones[j].endRotation, blinkTimer / blinkDuration) - blinkingShape.bones[j].neutralRotation;
							if (!blinkingShape.bones[j].lockPosition)
							{
								blinkingShape.bones[j].bone.localPosition += vector;
							}
							if (!blinkingShape.bones[j].lockRotation)
							{
								blinkingShape.bones[j].bone.localEulerAngles += vector2;
							}
						}
						else
						{
							if (!blinkingShape.bones[j].lockPosition)
							{
								blinkingShape.bones[j].bone.localPosition = Vector3.Lerp(blinkingShape.bones[j].neutralPosition, blinkingShape.bones[j].endPosition, blinkTimer / blinkDuration);
							}
							if (!blinkingShape.bones[j].lockRotation)
							{
								blinkingShape.bones[j].bone.localEulerAngles = Vector3.Lerp(blinkingShape.bones[j].neutralRotation, blinkingShape.bones[j].endRotation, blinkTimer / blinkDuration);
							}
						}
					}
				}
				if (blinkTimer > blinkDuration)
				{
					end = true;
					_asyncBlending = false;
				}
				blinkTimer += Time.deltaTime;
				yield return null;
			}
		}

		private IEnumerator OpenEyes()
		{
			bool end = false;
			blinkTimer = 0f;
			_asyncBlending = true;
			while (!end)
			{
				if (blinkingControlMode == ControlMode.Classic)
				{
					blendSystem.SetBlendableValue(leftEyeBlinkBlendable, Mathf.Lerp(100f, 0f, blinkTimer / blinkDuration));
					blendSystem.SetBlendableValue(rightEyeBlinkBlendable, Mathf.Lerp(100f, 0f, blinkTimer / blinkDuration));
				}
				else
				{
					for (int i = 0; i < blinkingShape.blendShapes.Count; i++)
					{
						blendSystem.SetBlendableValue(blinkingShape.blendShapes[i], Mathf.Lerp(100f, 0f, blinkTimer / blinkDuration));
					}
					for (int j = 0; j < blinkingShape.bones.Count; j++)
					{
						if (boneUpdateAnimation)
						{
							Vector3 vector = Vector3.Lerp(blinkingShape.bones[j].endPosition, blinkingShape.bones[j].neutralPosition, blinkTimer / blinkDuration) - blinkingShape.bones[j].neutralPosition;
							Vector3 vector2 = Vector3.Lerp(blinkingShape.bones[j].endRotation, blinkingShape.bones[j].neutralRotation, blinkTimer / blinkDuration) - blinkingShape.bones[j].neutralRotation;
							if (!blinkingShape.bones[j].lockPosition)
							{
								blinkingShape.bones[j].bone.localPosition += vector;
							}
							if (!blinkingShape.bones[j].lockRotation)
							{
								blinkingShape.bones[j].bone.localEulerAngles += vector2;
							}
						}
						else
						{
							if (!blinkingShape.bones[j].lockPosition)
							{
								blinkingShape.bones[j].bone.localPosition = Vector3.Lerp(blinkingShape.bones[j].endPosition, blinkingShape.bones[j].neutralPosition, blinkTimer / blinkDuration);
							}
							if (!blinkingShape.bones[j].lockRotation)
							{
								blinkingShape.bones[j].bone.localEulerAngles = Vector3.Lerp(blinkingShape.bones[j].endRotation, blinkingShape.bones[j].neutralRotation, blinkTimer / blinkDuration);
							}
						}
					}
				}
				if (blinkTimer > blinkDuration)
				{
					end = true;
					_asyncBlending = false;
				}
				blinkTimer += Time.deltaTime;
				yield return null;
			}
		}

		private void FixDummyHierarchy()
		{
			if (LeftEyeLookAtBone == null || RightEyeLookAtBone == null)
			{
				return;
			}
			if (!leftEyeDummy || !rightEyeDummy)
			{
				leftEyeDummy = new GameObject("Left Eye Dummy").transform;
				leftEyeDummy.gameObject.hideFlags = HideFlags.DontSave;
			}
			if (!rightEyeDummy)
			{
				rightEyeDummy = new GameObject("Right Eye Dummy").transform;
				rightEyeDummy.gameObject.hideFlags = HideFlags.DontSave;
			}
			if (leftEyeDummy.childCount > 0)
			{
				for (int i = 0; i < leftEyeDummy.childCount; i++)
				{
					leftEyeDummy.GetChild(i).SetParent(leftEyeDummy.parent, worldPositionStays: true);
				}
			}
			if (rightEyeDummy.childCount > 0)
			{
				for (int j = 0; j < rightEyeDummy.childCount; j++)
				{
					rightEyeDummy.GetChild(j).SetParent(rightEyeDummy.parent, worldPositionStays: true);
				}
			}
			leftEyeDummy.SetParent(LeftEyeLookAtBone.parent, worldPositionStays: false);
			rightEyeDummy.SetParent(RightEyeLookAtBone.parent, worldPositionStays: false);
			leftEyeDummy.position = LeftEyeLookAtBone.position;
			leftEyeDummy.rotation = LeftEyeLookAtBone.rotation;
			rightEyeDummy.position = RightEyeLookAtBone.position;
			rightEyeDummy.rotation = RightEyeLookAtBone.rotation;
			LeftEyeLookAtBone.SetParent(leftEyeDummy, worldPositionStays: true);
			RightEyeLookAtBone.SetParent(rightEyeDummy, worldPositionStays: true);
		}

		public void FindTargets()
		{
			GameObject[] array = GameObject.FindGameObjectsWithTag(autoTargetTag);
			markedTargets = new Transform[array.Length];
			for (int i = 0; i < markedTargets.Length; i++)
			{
				markedTargets[i] = array[i].transform;
			}
		}

		public static Vector3 Vector3LerpAngle(Vector3 a, Vector3 b, float t)
		{
			return new Vector3(Mathf.LerpAngle(a.x, b.x, t), Mathf.LerpAngle(a.y, b.y, t), Mathf.LerpAngle(a.z, b.z, t));
		}

		public void SetLookAtAmount(float amount)
		{
			targetWeight = amount;
		}
	}
}
namespace RogoDigital.Lipsync
{
	[RequireComponent(typeof(BlendshapeManager))]
	public class AdvancedBlendshapeBlendSystem : BlendSystem
	{
		[SerializeField]
		private BlendshapeManager manager;

		public override void OnEnable()
		{
			blendableDisplayName = "Blend Shape";
			blendableDisplayNamePlural = "Blend Shapes";
			noBlendablesMessage = "Your chosen Skinned Mesh Renderer has no Blend Shapes defined.";
			notReadyMessage = "Skinned Mesh Renderer not set. The Blend Shape BlendSystem requires at least one Skinned Mesh Renderer.";
			if (manager == null)
			{
				if (base.gameObject.GetComponents<BlendshapeManager>().Length > 1)
				{
					manager = base.gameObject.AddComponent<BlendshapeManager>();
				}
				else
				{
					manager = base.gameObject.GetComponent<BlendshapeManager>();
				}
				manager.blendSystem = this;
			}
			else if (manager.blendSystem == null)
			{
				manager.blendSystem = this;
			}
			isReady = true;
			base.OnEnable();
		}

		public override string[] GetBlendables()
		{
			if (!isReady)
			{
				return null;
			}
			bool flag = false;
			string[] array = new string[manager.blendShapes.Length];
			if (base.blendableCount == 0)
			{
				flag = true;
			}
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = manager.blendShapes[i].name + " (" + i + ")";
				float currentValue = 0f;
				if (manager.blendShapes[i].mappings.Length != 0)
				{
					currentValue = manager.blendShapes[i].mappings[0].skinnedMeshRenderer.GetBlendShapeWeight(manager.blendShapes[i].mappings[0].blendShapeIndex);
				}
				if (flag)
				{
					AddBlendable(i, currentValue);
				}
			}
			return array;
		}

		public override void SetBlendableValue(int blendable, float value)
		{
			if (isReady && blendable < manager.blendShapes.Length && manager.blendShapes[blendable].mappings != null)
			{
				for (int i = 0; i < manager.blendShapes[blendable].mappings.Length; i++)
				{
					SetInternalValue(blendable, value);
					manager.blendShapes[blendable].mappings[i].skinnedMeshRenderer.SetBlendShapeWeight(manager.blendShapes[blendable].mappings[i].blendShapeIndex, value);
				}
			}
		}
	}
	public class BlendshapeBlendSystem : BlendSystem
	{
		public SkinnedMeshRenderer characterMesh;

		public SkinnedMeshRenderer[] optionalOtherMeshes;

		private bool wireframeVisible = true;

		public override void OnEnable()
		{
			blendableDisplayName = "Blend Shape";
			blendableDisplayNamePlural = "Blend Shapes";
			noBlendablesMessage = "Your chosen Skinned Mesh Renderer has no Blend Shapes defined.";
			notReadyMessage = "Skinned Mesh Renderer not set. The Blend Shape BlendSystem requires at least one Skinned Mesh Renderer.";
			base.OnEnable();
		}

		public override void SetBlendableValue(int blendable, float value)
		{
			if (!isReady || characterMesh == null)
			{
				return;
			}
			characterMesh.SetBlendShapeWeight(blendable, value);
			SetInternalValue(blendable, value);
			SkinnedMeshRenderer[] array = optionalOtherMeshes;
			foreach (SkinnedMeshRenderer skinnedMeshRenderer in array)
			{
				if (blendable < skinnedMeshRenderer.sharedMesh.blendShapeCount)
				{
					skinnedMeshRenderer.SetBlendShapeWeight(blendable, value);
				}
			}
		}

		public override string[] GetBlendables()
		{
			if (!isReady || characterMesh == null)
			{
				return null;
			}
			bool flag = false;
			string[] array = new string[characterMesh.sharedMesh.blendShapeCount];
			if (base.blendableCount == 0)
			{
				flag = true;
			}
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = characterMesh.sharedMesh.GetBlendShapeName(i) + " (" + i + ")";
				if (flag)
				{
					AddBlendable(i, characterMesh.GetBlendShapeWeight(i));
				}
			}
			return array;
		}

		public override void OnVariableChanged()
		{
			if (characterMesh != null)
			{
				isReady = true;
			}
			else
			{
				isReady = false;
			}
		}

		[BlendSystemButton("Toggle Wireframe")]
		public void ToggleWireframe()
		{
			if (characterMesh != null)
			{
				wireframeVisible = !wireframeVisible;
			}
		}
	}
	[Serializable]
	public class BlendshapeManager : MonoBehaviour
	{
		[Serializable]
		public struct AdvancedBlendShape
		{
			public string name;

			public BlendShapeMapping[] mappings;
		}

		[Serializable]
		public struct BlendShapeMapping
		{
			public SkinnedMeshRenderer skinnedMeshRenderer;

			public int blendShapeIndex;
		}

		[Space]
		public AdvancedBlendShape[] blendShapes = new AdvancedBlendShape[0];

		[HideInInspector]
		public AdvancedBlendshapeBlendSystem blendSystem;
	}
	[RequireComponent(typeof(SpriteManager))]
	public class SpriteBlendSystem : BlendSystem
	{
		[SerializeField]
		private SpriteManager manager;

		public override void OnEnable()
		{
			blendableDisplayName = "Sprite";
			blendableDisplayNamePlural = "Sprites";
			noBlendablesMessage = "No Sprites or Layers available. Add Sprites and Layers to the attached SpriteManager to use them.";
			notReadyMessage = "No renderers set up";
			if (manager == null)
			{
				if (base.gameObject.GetComponents<SpriteBlendSystem>().Length > 1)
				{
					manager = base.gameObject.AddComponent<SpriteManager>();
				}
				else
				{
					manager = base.gameObject.GetComponent<SpriteManager>();
				}
				manager.blendSystem = this;
			}
			else if (manager.blendSystem == null)
			{
				manager.blendSystem = this;
			}
			base.OnEnable();
		}

		public override void SetBlendableValue(int blendable, float value)
		{
			if (!isReady || manager.groups.Count == 0 || manager.availableSprites.Count == 0)
			{
				return;
			}
			int num = Mathf.FloorToInt(blendable / manager.availableSprites.Count);
			SpriteRenderer spriteRenderer = manager.groups[num].spriteRenderer;
			if (spriteRenderer == null)
			{
				return;
			}
			SetInternalValue(blendable, value);
			int index = 0;
			float num2 = 0f;
			for (int i = num * manager.availableSprites.Count; i < (num + 1) * manager.availableSprites.Count; i++)
			{
				float blendableValue = GetBlendableValue(i);
				if (blendableValue > num2)
				{
					num2 = blendableValue;
					index = i % manager.availableSprites.Count;
				}
			}
			if (num2 == 0f)
			{
				spriteRenderer.sprite = manager.groups[num].defaultSprite;
			}
			else if (spriteRenderer != null)
			{
				spriteRenderer.sprite = manager.availableSprites[index];
			}
		}

		public override string[] GetBlendables()
		{
			if (!isReady)
			{
				return null;
			}
			ClearBlendables();
			List<string> list = new List<string>();
			if (manager == null)
			{
				manager = GetComponent<SpriteManager>();
			}
			for (int i = 0; i < manager.groups.Count; i++)
			{
				if (manager.groups[i] == null)
				{
					continue;
				}
				for (int j = 0; j < manager.availableSprites.Count; j++)
				{
					if (manager.availableSprites[j] != null)
					{
						list.Add(manager.groups[i].groupName + "/" + manager.availableSprites[j].name + "(" + (i * manager.availableSprites.Count + j) + ")");
						AddBlendable(i, 0f);
					}
				}
			}
			return list.ToArray();
		}

		public override void OnVariableChanged()
		{
			isReady = true;
		}

		[BlendSystemButton("Show Help")]
		public void ShowHelp()
		{
			UnityEngine.Application.OpenURL("http://updates.rogodigital.com/AssetStore/LipSync/spriteblendsystem.pdf");
		}
	}
	[Serializable]
	public class SpriteManager : MonoBehaviour
	{
		[Serializable]
		public class SpriteGroup
		{
			[SerializeField]
			public string groupName;

			[SerializeField]
			public SpriteRenderer spriteRenderer;

			[SerializeField]
			public Sprite defaultSprite;

			public SpriteGroup(string groupName)
			{
				this.groupName = groupName;
			}
		}

		[SerializeField]
		public List<Sprite> availableSprites = new List<Sprite>();

		[SerializeField]
		public List<SpriteGroup> groups = new List<SpriteGroup>();

		public SpriteBlendSystem blendSystem;
	}
	[RequireComponent(typeof(TextureOffsetManager))]
	public class TextureOffsetBlendSystem : BlendSystem
	{
		[SerializeField]
		private TextureOffsetManager manager;

		private Dictionary<int, int> groupLookup;

		private Dictionary<string, int> reverseGroupLookup;

		public override void OnEnable()
		{
			blendableDisplayName = "Texture Setting";
			blendableDisplayNamePlural = "Texture Settings";
			noBlendablesMessage = "No Texture Settings available. Add Texture Settings to the attached Texture Offset Manager to use them.";
			notReadyMessage = "No renderers set up";
			if (manager == null)
			{
				if (base.gameObject.GetComponents<TextureOffsetBlendSystem>().Length > 1)
				{
					manager = base.gameObject.AddComponent<TextureOffsetManager>();
				}
				else
				{
					manager = base.gameObject.GetComponent<TextureOffsetManager>();
				}
				manager.blendSystem = this;
			}
			else if (manager.blendSystem == null)
			{
				manager.blendSystem = this;
			}
			CacheGroups();
			base.OnEnable();
		}

		private void CacheGroups()
		{
			groupLookup = new Dictionary<int, int>();
			reverseGroupLookup = new Dictionary<string, int>();
			int num = 0;
			for (int i = 0; i < manager.materialGroups.Length; i++)
			{
				for (int j = 0; j < manager.materialGroups[i].textureSettings.Length; j++)
				{
					groupLookup.Add(num, i);
					reverseGroupLookup.Add(i.ToString() + j, num);
					UnityEngine.Debug.LogFormat("Cached {0} at index {1} as being in group {2} with a sub-index of {3}", manager.materialGroups[i].textureSettings[j].displayName, num, i, j);
					num++;
				}
			}
		}

		public override void SetBlendableValue(int blendable, float value)
		{
			if (!isReady || manager.materialGroups.Length == 0)
			{
				return;
			}
			if (base.blendableCount != groupLookup.Count)
			{
				CacheGroups();
			}
			int num = groupLookup[blendable];
			TextureOffsetManager.MaterialTextureGroup materialTextureGroup = manager.materialGroups[num];
			if (materialTextureGroup == null)
			{
				return;
			}
			SetInternalValue(blendable, value);
			int num2 = 0;
			float num3 = 0f;
			for (int i = 0; i < materialTextureGroup.textureSettings.Length; i++)
			{
				float blendableValue = GetBlendableValue(reverseGroupLookup[num.ToString() + i]);
				if (blendableValue > num3)
				{
					num3 = blendableValue;
					num2 = i;
				}
			}
			if (!materialTextureGroup.material)
			{
				return;
			}
			if (num3 == 0f)
			{
				if ((bool)materialTextureGroup.defaultTexture)
				{
					materialTextureGroup.material.SetTexture(materialTextureGroup.texturePropertyName, materialTextureGroup.defaultTexture);
					materialTextureGroup.material.SetTextureOffset(materialTextureGroup.texturePropertyName, materialTextureGroup.defaultTextureOffset);
					materialTextureGroup.material.SetTextureScale(materialTextureGroup.texturePropertyName, materialTextureGroup.defaultTextureScale);
				}
			}
			else if (materialTextureGroup != null && (bool)materialTextureGroup.textureSettings[num2].texture)
			{
				materialTextureGroup.material.SetTexture(materialTextureGroup.texturePropertyName, materialTextureGroup.textureSettings[num2].texture);
				materialTextureGroup.material.SetTextureOffset(materialTextureGroup.texturePropertyName, materialTextureGroup.textureSettings[num2].textureOffset);
				materialTextureGroup.material.SetTextureScale(materialTextureGroup.texturePropertyName, materialTextureGroup.textureSettings[num2].textureScale);
			}
		}

		public override string[] GetBlendables()
		{
			if (!isReady)
			{
				return null;
			}
			ClearBlendables();
			List<string> list = new List<string>();
			if (manager == null)
			{
				manager = GetComponent<TextureOffsetManager>();
			}
			int num = 0;
			for (int i = 0; i < manager.materialGroups.Length; i++)
			{
				if (manager.materialGroups[i] == null)
				{
					continue;
				}
				for (int j = 0; j < manager.materialGroups[i].textureSettings.Length; j++)
				{
					if (manager.materialGroups[i].textureSettings[j] != null)
					{
						list.Add(manager.materialGroups[i].displayName + "/" + manager.materialGroups[i].textureSettings[j].displayName + " (" + num + ")");
						AddBlendable(i, 0f);
						num++;
					}
				}
			}
			return list.ToArray();
		}

		public override void OnVariableChanged()
		{
			isReady = true;
		}
	}
	[Serializable]
	public class TextureOffsetManager : MonoBehaviour
	{
		[Serializable]
		public class MaterialTextureGroup
		{
			[SerializeField]
			public string displayName;

			[Space]
			[SerializeField]
			public Material material;

			[SerializeField]
			public string texturePropertyName;

			[Space]
			[SerializeField]
			public Texture2D defaultTexture;

			[SerializeField]
			public Vector2 defaultTextureOffset;

			[SerializeField]
			public Vector2 defaultTextureScale = Vector2.one;

			[Space]
			[SerializeField]
			public TextureSetting[] textureSettings;
		}

		[Serializable]
		public class TextureSetting
		{
			[SerializeField]
			public string displayName;

			[Space]
			[SerializeField]
			public Texture2D texture;

			[SerializeField]
			public Vector2 textureOffset;

			[SerializeField]
			public Vector2 textureScale = Vector2.one;
		}

		[SerializeField]
		public MaterialTextureGroup[] materialGroups = new MaterialTextureGroup[0];

		[HideInInspector]
		public TextureOffsetBlendSystem blendSystem;
	}
	[ExecuteInEditMode]
	public class BlendSystem : MonoBehaviour
	{
		public delegate void BlendSystemGenericDelegate();

		[NonSerialized]
		public string blendableDisplayName = "Blendable";

		[NonSerialized]
		public string blendableDisplayNamePlural = "Blendables";

		[NonSerialized]
		public string noBlendablesMessage = "No Blendables found.";

		[NonSerialized]
		public string notReadyMessage = "Setup incomplete.";

		[NonSerialized]
		public float blendRangeLow;

		[NonSerialized]
		public float blendRangeHigh = 100f;

		[NonSerialized]
		public bool allowResyncing;

		public bool isReady;

		public BlendSystemUser[] users = new BlendSystemUser[0];

		public BlendSystemGenericDelegate onBlendablesChanged;

		[SerializeField]
		[HideInInspector]
		private List<Blendable> _blendables;

		public int blendableCount
		{
			get
			{
				if (_blendables == null)
				{
					_blendables = new List<Blendable>();
				}
				return _blendables.Count;
			}
		}

		public virtual void OnEnable()
		{
			base.hideFlags = HideFlags.HideInInspector;
			OnVariableChanged();
			GetBlendables();
		}

		public void Register(BlendSystemUser user)
		{
			List<BlendSystemUser> list = new List<BlendSystemUser>();
			for (int i = 0; i < users.Length; i++)
			{
				list.Add(users[i]);
			}
			if (list.Contains(user))
			{
				UnityEngine.Debug.LogError("Could not register " + user.GetType().Name + " component to " + GetType().Name + ". BlendSystemUser is already registered.");
			}
			else
			{
				list.Add(user);
				user.blendSystem = this;
			}
			users = list.ToArray();
		}

		public void Unregister(BlendSystemUser user)
		{
			List<BlendSystemUser> list = new List<BlendSystemUser>();
			for (int i = 0; i < users.Length; i++)
			{
				list.Add(users[i]);
			}
			if (list.Contains(user))
			{
				if (user != null)
				{
					user.blendSystem = null;
				}
				list.Remove(user);
			}
			users = list.ToArray();
			if (users.Length == 0)
			{
				OnBlendSystemRemoved();
				if (UnityEngine.Application.isPlaying)
				{
					UnityEngine.Object.Destroy(this);
				}
				else
				{
					UnityEngine.Object.DestroyImmediate(this);
				}
			}
		}

		public virtual void SetBlendableValue(int blendable, float value)
		{
		}

		public float GetBlendableValue(int blendable)
		{
			if (_blendables == null)
			{
				_blendables = new List<Blendable>();
			}
			return _blendables[blendable].currentWeight;
		}

		public virtual void OnVariableChanged()
		{
		}

		public virtual void OnBlendSystemAdded()
		{
		}

		public virtual void OnBlendSystemRemoved()
		{
		}

		public virtual string[] GetBlendables()
		{
			return null;
		}

		public virtual void OnBlendableAddedToPose(int blendable)
		{
		}

		public virtual void OnBlendableRemovedFromPose(int blendable)
		{
		}

		public void AddBlendable(int blendable, float currentValue)
		{
			if (_blendables == null)
			{
				_blendables = new List<Blendable>();
			}
			_blendables.Insert(blendable, new Blendable(blendable, currentValue));
		}

		public void ClearBlendables()
		{
			_blendables = new List<Blendable>();
		}

		public void SetInternalValue(int blendable, float value)
		{
			if (_blendables == null)
			{
				_blendables = new List<Blendable>();
				GetBlendables();
			}
			if (blendable >= _blendables.Count)
			{
				GetBlendables();
			}
			_blendables[blendable].currentWeight = value;
		}
	}
	[AttributeUsage(AttributeTargets.Method, AllowMultiple = false)]
	public class BlendSystemButton : Attribute
	{
		public struct Reference
		{
			public string displayName;

			public MethodInfo method;

			public Reference(string displayName, MethodInfo method)
			{
				this.displayName = displayName;
				this.method = method;
			}
		}

		public string displayName;

		public BlendSystemButton(string displayName)
		{
			this.displayName = displayName;
		}
	}
	public class BlendSystemUser : MonoBehaviour
	{
		public BlendSystem blendSystem;

		protected void OnDestroy()
		{
			blendSystem.Unregister(this);
		}

		protected void CleanUpBlendSystems()
		{
			BlendSystem[] components = GetComponents<BlendSystem>();
			for (int i = 0; i < components.Length; i++)
			{
				if (components[i].users == null)
				{
					continue;
				}
				for (int j = 0; j < components[i].users.Length; j++)
				{
					if (components[i].users[j] == this)
					{
						components[i].Unregister(this);
					}
				}
			}
		}
	}
	[Serializable]
	public class Blendable
	{
		public int number;

		public float currentWeight;

		public Blendable(int number, float currentWeight)
		{
			this.number = number;
			this.currentWeight = currentWeight;
		}
	}
	[Obsolete("BlendshapePresets have been deprecated in favour of the new LipSyncPreset class in LipSync Pro 1.0.")]
	public class BlendshapePreset : ScriptableObject
	{
		[SerializeField]
		public List<PhonemeShape> phonemeShapes;

		[SerializeField]
		public List<EmotionShape> emotionShapes;
	}
	[Serializable]
	public class BoneShape
	{
		[SerializeField]
		public Transform bone;

		[SerializeField]
		public Vector3 endPosition;

		[SerializeField]
		public Vector3 endRotation;

		[SerializeField]
		public Vector3 endScale = Vector3.one;

		[SerializeField]
		public bool lockPosition;

		[SerializeField]
		public bool lockRotation;

		public Vector3 neutralPosition;

		public Vector3 neutralRotation;

		public Vector3 neutralScale = Vector3.one;

		public void SetNeutral()
		{
			if (bone != null)
			{
				neutralPosition = bone.localPosition;
				neutralRotation = bone.localEulerAngles;
				neutralScale = bone.localScale;
			}
		}

		public BoneShape(Transform bone, Vector3 endPosition, Vector3 endRotation, Vector3 endScale)
		{
			this.bone = bone;
			this.endPosition = endPosition;
			this.endRotation = endRotation;
			this.endScale = endScale;
		}

		public BoneShape(Transform bone, Vector3 endPosition, Vector3 endRotation)
		{
			this.bone = bone;
			this.endPosition = endPosition;
			this.endRotation = endRotation;
			endScale = bone.localScale;
		}

		public BoneShape()
		{
		}
	}
	[Serializable]
	public class EmotionMarker
	{
		[SerializeField]
		public string emotion;

		[SerializeField]
		public bool isMixer;

		[SerializeField]
		public EmotionMixer mixer;

		[SerializeField]
		public float startTime;

		[SerializeField]
		public float endTime;

		[SerializeField]
		public float blendInTime;

		[SerializeField]
		public float blendOutTime;

		[SerializeField]
		public bool blendToMarker;

		[SerializeField]
		public bool blendFromMarker;

		[SerializeField]
		public bool customBlendIn;

		[SerializeField]
		public bool customBlendOut;

		[SerializeField]
		public float intensity = 1f;

		[SerializeField]
		public bool continuousVariation;

		[SerializeField]
		public float variationFrequency = 0.5f;

		[SerializeField]
		public float intensityVariation = 0.35f;

		[SerializeField]
		public float blendableVariation = 0.1f;

		[SerializeField]
		public float bonePositionVariation = 0.1f;

		[SerializeField]
		public float boneRotationVariation = 0.1f;

		public bool invalid;

		public EmotionMarker(string emotion, float startTime, float endTime, float blendInTime, float blendOutTime, bool blendToMarker, bool blendFromMarker, bool customBlendIn, bool customBlendOut)
		{
			this.emotion = emotion;
			this.startTime = startTime;
			this.endTime = endTime;
			this.blendInTime = blendInTime;
			this.blendOutTime = blendOutTime;
			this.blendToMarker = blendToMarker;
			this.blendFromMarker = blendFromMarker;
			this.customBlendIn = customBlendIn;
			this.customBlendOut = customBlendOut;
		}

		public EmotionMarker(EmotionMixer mixer, float startTime, float endTime, float blendInTime, float blendOutTime, bool blendToMarker, bool blendFromMarker, bool customBlendIn, bool customBlendOut)
		{
			isMixer = true;
			this.mixer = mixer;
			this.startTime = startTime;
			this.endTime = endTime;
			this.blendInTime = blendInTime;
			this.blendOutTime = blendOutTime;
			this.blendToMarker = blendToMarker;
			this.blendFromMarker = blendFromMarker;
			this.customBlendIn = customBlendIn;
			this.customBlendOut = customBlendOut;
		}

		public EmotionMarker(string emotion, float startTime, float endTime, float blendInTime, float blendOutTime, bool blendToMarker, bool blendFromMarker, bool customBlendIn, bool customBlendOut, float intensity)
		{
			this.emotion = emotion;
			this.startTime = startTime;
			this.endTime = endTime;
			this.blendInTime = blendInTime;
			this.blendOutTime = blendOutTime;
			this.blendToMarker = blendToMarker;
			this.blendFromMarker = blendFromMarker;
			this.customBlendIn = customBlendIn;
			this.customBlendOut = customBlendOut;
			this.intensity = intensity;
		}

		public EmotionMarker CreateCopy()
		{
			return new EmotionMarker(emotion, startTime, endTime, blendInTime, blendOutTime, blendToMarker, blendFromMarker, customBlendIn, customBlendOut, intensity)
			{
				isMixer = isMixer,
				mixer = mixer,
				blendableVariation = blendableVariation,
				bonePositionVariation = bonePositionVariation,
				boneRotationVariation = boneRotationVariation,
				intensityVariation = intensityVariation,
				continuousVariation = continuousVariation
			};
		}
	}
	[Serializable]
	public class EmotionMixer
	{
		[Serializable]
		public struct EmotionComponent
		{
			public string emotion;

			public float weight;

			public EmotionComponent(string emotion, float weight)
			{
				this.emotion = emotion;
				this.weight = weight;
			}
		}

		public enum MixingMode
		{
			Normal,
			Additive
		}

		[SerializeField]
		public List<EmotionComponent> emotions;

		[SerializeField]
		public MixingMode mixingMode;

		public Color displayColor;

		public EmotionMixer()
		{
			emotions = new List<EmotionComponent>();
			displayColor = new Color(0f, 0f, 0f);
		}

		public EmotionShape GetShape(LipSync character)
		{
			EmotionShape emotionShape = new EmotionShape("Mixed");
			if (!character)
			{
				return emotionShape;
			}
			if (!character.blendSystem)
			{
				return emotionShape;
			}
			Dictionary<string, EmotionShape> dictionary = new Dictionary<string, EmotionShape>();
			foreach (EmotionShape emotion in character.emotions)
			{
				dictionary.Add(emotion.emotion, emotion);
			}
			for (int i = 0; i < emotions.Count; i++)
			{
				if (!dictionary.ContainsKey(emotions[i].emotion))
				{
					continue;
				}
				EmotionShape emotionShape2 = dictionary[emotions[i].emotion];
				for (int j = 0; j < emotionShape2.blendShapes.Count; j++)
				{
					if (emotionShape.blendShapes.Contains(emotionShape2.blendShapes[j]))
					{
						Mathf.Clamp(emotionShape.weights[emotionShape.blendShapes.IndexOf(emotionShape2.blendShapes[j])] += emotionShape2.weights[j] * emotions[i].weight, character.blendSystem.blendRangeLow, character.blendSystem.blendRangeHigh);
						continue;
					}
					emotionShape.blendShapes.Add(emotionShape2.blendShapes[j]);
					emotionShape.weights.Add(emotionShape2.weights[j] * emotions[i].weight);
				}
				for (int k = 0; k < emotionShape2.bones.Count; k++)
				{
					BoneShape boneShape = emotionShape2.bones[k];
					if (emotionShape.HasBone(boneShape.bone))
					{
						emotionShape.bones[emotionShape.IndexOfBone(boneShape.bone)].endPosition += boneShape.endPosition * emotions[i].weight;
						emotionShape.bones[emotionShape.IndexOfBone(boneShape.bone)].endRotation += boneShape.endRotation * emotions[i].weight;
					}
					else
					{
						emotionShape.bones.Add(new BoneShape(boneShape.bone, boneShape.endPosition * emotions[i].weight, boneShape.endRotation * emotions[i].weight));
					}
				}
			}
			return emotionShape;
		}

		public void SetWeight(int index, float weight)
		{
			SetWeight(index, weight, bypassMinChecks: false);
		}

		public void SetWeight(int index, float weight, bool bypassMinChecks)
		{
			if (mixingMode == MixingMode.Additive)
			{
				emotions[index] = new EmotionComponent(emotions[index].emotion, weight);
				return;
			}
			if (!bypassMinChecks)
			{
				weight = Mathf.Clamp(weight, 0.01f, 1f);
			}
			float num = 0f;
			float[] array = new float[emotions.Count];
			if (emotions.Count == 1)
			{
				emotions[index] = new EmotionComponent(emotions[index].emotion, 1f);
				return;
			}
			for (int i = 0; i < emotions.Count; i++)
			{
				array[i] = emotions[i].weight;
				if (i != index)
				{
					num += emotions[i].weight;
				}
			}
			emotions[index] = new EmotionComponent(emotions[index].emotion, weight);
			float num2 = num - (weight - array[index]);
			for (int j = 0; j < emotions.Count; j++)
			{
				if (j == index)
				{
					continue;
				}
				float num3 = num2 * (emotions[j].weight / num);
				if (num3 > 0.02f || bypassMinChecks)
				{
					emotions[j] = new EmotionComponent(emotions[j].emotion, num3);
					continue;
				}
				for (int k = 0; k < emotions.Count; k++)
				{
					emotions[k] = new EmotionComponent(emotions[k].emotion, array[k]);
				}
				break;
			}
		}
	}
	[Serializable]
	public class EmotionShape : Shape
	{
		[SerializeField]
		public string emotion;

		public EmotionShape(string eEmotion)
		{
			emotion = eEmotion;
			blendShapes = new List<int>();
			weights = new List<float>();
			bones = new List<BoneShape>();
		}
	}
	[Serializable]
	public class GestureMarker
	{
		[SerializeField]
		public string gesture;

		[SerializeField]
		public float time;

		public GestureMarker(string gesture, float time)
		{
			this.gesture = gesture;
			this.time = time;
		}

		public GestureMarker CreateCopy()
		{
			return new GestureMarker(gesture, time);
		}
	}
	[Serializable]
	public class LipSyncData : ScriptableObject
	{
		public AudioClip clip;

		public PhonemeMarker[] phonemeData;

		public EmotionMarker[] emotionData;

		public GestureMarker[] gestureData;

		public float version;

		public float length;

		public string transcript;

		public AnimationCurve[] phonemePoseCurves = new AnimationCurve[0];

		public AnimationCurve[] emotionPoseCurves = new AnimationCurve[0];

		public int targetComponentID;

		public bool isPreprocessed;

		public List<int> indexBlendables;

		public List<AnimationCurve> animCurves;

		public List<Transform> bones;

		public List<TransformAnimationCurve> boneCurves;

		public List<Vector3> boneNeutralPositions;

		public List<Vector3> boneNeutralScales;

		public List<Quaternion> boneNeutralRotations;

		public void GenerateCurves(int phonemeCount, int emotionCount)
		{
			phonemePoseCurves = new AnimationCurve[phonemeCount];
			emotionPoseCurves = new AnimationCurve[emotionCount];
			for (int i = 0; i < phonemePoseCurves.Length; i++)
			{
				phonemePoseCurves[i] = new AnimationCurve(new Keyframe(0f, 0f), new Keyframe(1f, 0f));
			}
			for (int j = 0; j < emotionPoseCurves.Length; j++)
			{
				emotionPoseCurves[j] = new AnimationCurve(new Keyframe(0f, 0f), new Keyframe(1f, 0f));
			}
			for (int k = 0; k < phonemeData.Length; k++)
			{
				for (int l = 0; l < phonemePoseCurves.Length; l++)
				{
					if (l != phonemeData[k].phonemeNumber)
					{
						phonemePoseCurves[l].AddKey(phonemeData[k].time, 0f);
					}
				}
				phonemePoseCurves[phonemeData[k].phonemeNumber].AddKey(phonemeData[k].time, phonemeData[k].intensity);
			}
			for (int m = 0; m < emotionData.Length; m++)
			{
			}
		}

		public static explicit operator LipSyncData(TemporaryLipSyncData data)
		{
			LipSyncData lipSyncData = ScriptableObject.CreateInstance<LipSyncData>();
			lipSyncData.phonemeData = new PhonemeMarker[data.phonemeData.Count];
			lipSyncData.emotionData = new EmotionMarker[data.emotionData.Count];
			lipSyncData.gestureData = new GestureMarker[data.gestureData.Count];
			for (int i = 0; i < data.phonemeData.Count; i++)
			{
				lipSyncData.phonemeData[i] = data.phonemeData[i].CreateCopy();
			}
			for (int j = 0; j < data.emotionData.Count; j++)
			{
				lipSyncData.emotionData[j] = data.emotionData[j].CreateCopy();
			}
			for (int k = 0; k < data.gestureData.Count; k++)
			{
				lipSyncData.gestureData[k] = data.gestureData[k].CreateCopy();
			}
			lipSyncData.clip = data.clip;
			lipSyncData.version = data.version;
			lipSyncData.length = data.length;
			lipSyncData.transcript = data.transcript;
			return lipSyncData;
		}
	}
	public static class LipSyncExtensions
	{
		public static Transform FindDeepChild(this Transform aParent, string aName)
		{
			Transform transform = aParent.Find(aName);
			if (transform != null)
			{
				return transform;
			}
			foreach (Transform item in aParent)
			{
				transform = item.FindDeepChild(aName);
				if (transform != null)
				{
					return transform;
				}
			}
			return null;
		}

		public static Vector3 InverseTransformEulerAngle(this Transform transform, Vector3 eulerAngle)
		{
			return (eulerAngle - transform.eulerAngles).ToPositiveEuler();
		}

		public static Vector3 TransformEulerAngle(this Transform transform, Vector3 eulerAngle)
		{
			return ClampRange(eulerAngle + transform.eulerAngles);
		}

		public static Vector3 ToPositiveEuler(this Vector3 eulerAngle)
		{
			float num = eulerAngle.x;
			float num2 = eulerAngle.y;
			float num3 = eulerAngle.z;
			if (num < 0f)
			{
				num = 360f + num;
			}
			if (num2 < 0f)
			{
				num2 = 360f + num2;
			}
			if (num3 < 0f)
			{
				num3 = 360f + num3;
			}
			return new Vector3(num, num2, num3);
		}

		public static Vector3 ToNegativeEuler(this Vector3 eulerAngle)
		{
			float num = eulerAngle.x;
			float num2 = eulerAngle.y;
			float num3 = eulerAngle.z;
			if (num > 180f)
			{
				num -= 360f;
			}
			if (num2 > 180f)
			{
				num2 -= 360f;
			}
			if (num3 > 180f)
			{
				num3 -= 360f;
			}
			return new Vector3(num, num2, num3);
		}

		private static Vector3 ClampRange(Vector3 eulerAngle)
		{
			float num = eulerAngle.x;
			float num2 = eulerAngle.y;
			float num3 = eulerAngle.z;
			if (num > 360f)
			{
				num -= 360f;
			}
			if (num2 > 360f)
			{
				num2 -= 360f;
			}
			if (num3 > 360f)
			{
				num3 -= 360f;
			}
			return new Vector3(num, num2, num3).ToPositiveEuler();
		}

		public static EmotionMarker PreviousMarker(this List<EmotionMarker> list, EmotionMarker current)
		{
			int num = list.IndexOf(current) - 1;
			if (num >= 0)
			{
				return list[num];
			}
			return null;
		}

		public static EmotionMarker NextMarker(this List<EmotionMarker> list, EmotionMarker current)
		{
			int num = list.IndexOf(current) + 1;
			if (num < list.Count)
			{
				return list[num];
			}
			return null;
		}
	}
	public class LipSyncPreset : ScriptableObject
	{
		[Serializable]
		public struct PhonemeShapeInfo
		{
			[SerializeField]
			public string phonemeName;

			[SerializeField]
			[Obsolete("Please use PhonemeShapeInfo.phonemeName")]
			public Phoneme phoneme;

			[SerializeField]
			public BlendableInfo[] blendables;

			[SerializeField]
			public BoneInfo[] bones;
		}

		[Serializable]
		public struct EmotionShapeInfo
		{
			[SerializeField]
			public string emotion;

			[SerializeField]
			public BlendableInfo[] blendables;

			[SerializeField]
			public BoneInfo[] bones;
		}

		[Serializable]
		public struct BlendableInfo
		{
			[SerializeField]
			public int blendableNumber;

			[SerializeField]
			public string blendableName;

			[SerializeField]
			public float weight;
		}

		[Serializable]
		public struct BoneInfo
		{
			[SerializeField]
			public string path;

			[SerializeField]
			public string name;

			[SerializeField]
			public Vector3 localPosition;

			[SerializeField]
			public Vector3 localRotation;

			[SerializeField]
			public bool lockPosition;

			[SerializeField]
			public bool lockRotation;
		}

		public bool isRelative;

		[SerializeField]
		public PhonemeShapeInfo[] phonemeShapes;

		[SerializeField]
		public EmotionShapeInfo[] emotionShapes;

		public int FindBlendable(BlendableInfo blendable, BlendSystem blendSystem)
		{
			if (!string.IsNullOrEmpty(blendable.blendableName))
			{
				string text = blendable.blendableName;
				if (text.Contains("(" + blendable.blendableNumber + ")"))
				{
					string[] array = text.Split(new string[1] { "(" + blendable.blendableNumber + ")" }, StringSplitOptions.RemoveEmptyEntries);
					if (array.Length != 0)
					{
						text = array[0];
					}
				}
				string[] blendables = blendSystem.GetBlendables();
				for (int i = 0; i < blendables.Length; i++)
				{
					string text2 = blendables[i];
					if (text2.Contains("(" + i + ")"))
					{
						string[] array2 = text2.Split(new string[1] { "(" + i + ")" }, StringSplitOptions.RemoveEmptyEntries);
						if (array2.Length != 0)
						{
							text2 = array2[0];
						}
					}
					if (text2 == text)
					{
						return i;
					}
				}
			}
			if (blendable.blendableNumber < blendSystem.blendableCount)
			{
				if (!string.IsNullOrEmpty(blendable.blendableName) && blendable.blendableName != blendSystem.GetBlendables()[blendable.blendableNumber])
				{
					UnityEngine.Debug.LogWarning("[LipSync] Blendable " + blendable.blendableName + " used in the '" + base.name + "' preset couldn't be matched based on name, and the blendable at the same index in the " + blendSystem.GetType().Name + " has a different name. This may not be the shape you were expecting.");
				}
				return blendable.blendableNumber;
			}
			return -1;
		}

		public Transform FindBone(BoneInfo bone, Transform searchRoot)
		{
			Transform transform = searchRoot.Find(bone.path + bone.name);
			if (transform != null)
			{
				return transform;
			}
			return searchRoot.FindDeepChild(bone.name);
		}

		public void CreateFromShapes(PhonemeShape[] phonemes, EmotionShape[] emotions, BlendSystem blendSystem, bool relative)
		{
			isRelative = relative;
			phonemeShapes = new PhonemeShapeInfo[phonemes.Length];
			emotionShapes = new EmotionShapeInfo[emotions.Length];
			for (int i = 0; i < phonemeShapes.Length; i++)
			{
				phonemeShapes[i] = default(PhonemeShapeInfo);
				phonemeShapes[i].phonemeName = phonemes[i].phonemeName;
				phonemeShapes[i].blendables = new BlendableInfo[phonemes[i].blendShapes.Count];
				for (int j = 0; j < phonemeShapes[i].blendables.Length; j++)
				{
					phonemeShapes[i].blendables[j].blendableNumber = phonemes[i].blendShapes[j];
					phonemeShapes[i].blendables[j].weight = phonemes[i].weights[j];
					if (blendSystem != null)
					{
						phonemeShapes[i].blendables[j].blendableName = blendSystem.GetBlendables()[phonemes[i].blendShapes[j]];
					}
				}
				phonemeShapes[i].bones = new BoneInfo[phonemes[i].bones.Count];
				for (int k = 0; k < phonemeShapes[i].bones.Length; k++)
				{
					phonemeShapes[i].bones[k].name = phonemes[i].bones[k].bone.name;
					phonemeShapes[i].bones[k].lockPosition = phonemes[i].bones[k].lockPosition;
					phonemeShapes[i].bones[k].lockRotation = phonemes[i].bones[k].lockRotation;
					if (relative)
					{
						phonemeShapes[i].bones[k].localPosition = phonemes[i].bones[k].neutralPosition - phonemes[i].bones[k].endPosition;
						phonemeShapes[i].bones[k].localRotation = phonemes[i].bones[k].neutralRotation - phonemes[i].bones[k].endRotation;
					}
					else
					{
						phonemeShapes[i].bones[k].localPosition = phonemes[i].bones[k].endPosition;
						phonemeShapes[i].bones[k].localRotation = phonemes[i].bones[k].endRotation;
					}
				}
			}
			for (int l = 0; l < emotionShapes.Length; l++)
			{
				emotionShapes[l] = default(EmotionShapeInfo);
				emotionShapes[l].emotion = emotions[l].emotion;
				emotionShapes[l].blendables = new BlendableInfo[emotions[l].blendShapes.Count];
				for (int m = 0; m < emotionShapes[l].blendables.Length; m++)
				{
					emotionShapes[l].blendables[m].blendableNumber = emotions[l].blendShapes[m];
					emotionShapes[l].blendables[m].weight = emotions[l].weights[m];
					if (blendSystem != null)
					{
						emotionShapes[l].blendables[m].blendableName = blendSystem.GetBlendables()[emotions[l].blendShapes[m]];
					}
				}
				emotionShapes[l].bones = new BoneInfo[emotions[l].bones.Count];
				for (int n = 0; n < emotionShapes[l].bones.Length; n++)
				{
					emotionShapes[l].bones[n].name = emotions[l].bones[n].bone.name;
					emotionShapes[l].bones[n].lockPosition = emotions[l].bones[n].lockPosition;
					emotionShapes[l].bones[n].lockRotation = emotions[l].bones[n].lockRotation;
					if (relative)
					{
						emotionShapes[l].bones[n].localPosition = emotions[l].bones[n].neutralPosition - phonemes[l].bones[n].endPosition;
						emotionShapes[l].bones[n].localRotation = emotions[l].bones[n].neutralRotation - phonemes[l].bones[n].endRotation;
					}
					else
					{
						emotionShapes[l].bones[n].localPosition = emotions[l].bones[n].endPosition;
						emotionShapes[l].bones[n].localRotation = emotions[l].bones[n].endRotation;
					}
				}
			}
		}
	}
	public class LipSyncProject : ScriptableObject
	{
		[SerializeField]
		public string[] emotions;

		[SerializeField]
		public Color[] emotionColors;

		[SerializeField]
		public List<string> gestures = new List<string>();

		[SerializeField]
		public PhonemeSet phonemeSet;
	}
	[Serializable]
	public class PhonemeMarker
	{
		[SerializeField]
		[Obsolete("Use PhonemeMarker.phonemeNumber instead.")]
		public Phoneme phoneme;

		[SerializeField]
		public int phonemeNumber;

		[SerializeField]
		public float time;

		[SerializeField]
		public float intensity = 1f;

		[SerializeField]
		public bool sustain;

		[SerializeField]
		public bool useRandomness;

		[SerializeField]
		public float intensityRandomness = 0.1f;

		[SerializeField]
		public float blendableRandomness = 0.3f;

		[SerializeField]
		public float bonePositionRandomness = 0.3f;

		[SerializeField]
		public float boneRotationRandomness = 0.3f;

		public PhonemeMarker(int phonemeNumber, float time, float intensity, bool sustain)
		{
			this.phonemeNumber = phonemeNumber;
			this.time = time;
			this.intensity = intensity;
			this.sustain = sustain;
		}

		public PhonemeMarker(int phonemeNumber, float time)
		{
			this.phonemeNumber = phonemeNumber;
			this.time = time;
		}

		[Obsolete("Use int constructors instead.")]
		public PhonemeMarker(Phoneme phoneme, float time, float intensity, bool sustain)
		{
			this.phoneme = phoneme;
			this.time = time;
			this.intensity = intensity;
			this.sustain = sustain;
		}

		[Obsolete("Use int constructors instead.")]
		public PhonemeMarker(Phoneme phoneme, float time)
		{
			this.phoneme = phoneme;
			this.time = time;
		}

		public PhonemeMarker CreateCopy()
		{
			return new PhonemeMarker(phonemeNumber, time, intensity, sustain)
			{
				blendableRandomness = blendableRandomness,
				bonePositionRandomness = bonePositionRandomness,
				boneRotationRandomness = boneRotationRandomness,
				intensityRandomness = intensityRandomness,
				useRandomness = useRandomness
			};
		}
	}
	[Serializable]
	[CreateAssetMenu(fileName = "New Phoneme Set", menuName = "LipSync Pro/Phoneme Set")]
	public class PhonemeSet : ScriptableObject
	{
		[Serializable]
		public class PhonemeCollection
		{
			public List<string> phonemeNames;

			public int Length => phonemeNames.Count;

			public Phoneme this[int index] => new Phoneme(phonemeNames[index], index, Mathf.RoundToInt(Mathf.Pow(2f, index)));

			public PhonemeCollection()
			{
				phonemeNames = new List<string>();
			}
		}

		public struct Phoneme
		{
			public bool visuallyImportant;

			public string name { get; private set; }

			public int number { get; private set; }

			public int flag { get; private set; }

			public Phoneme(string name, int number, int flag)
			{
				this = default(Phoneme);
				this.name = name;
				this.number = number;
				this.flag = flag;
			}
		}

		[SerializeField]
		public string scriptingName;

		[SerializeField]
		public PhonemeCollection phonemes = new PhonemeCollection();

		[SerializeField]
		public Texture2D[] guideImages;
	}
	[Serializable]
	public class PhonemeShape : Shape
	{
		[SerializeField]
		public string phonemeName;

		[SerializeField]
		[Obsolete("Use phonemeName instead.")]
		public Phoneme phoneme;

		public PhonemeShape(string phonemeName)
		{
			this.phonemeName = phonemeName;
			blendShapes = new List<int>();
			weights = new List<float>();
			bones = new List<BoneShape>();
		}

		[Obsolete("Use the new string constructor instead.")]
		public PhonemeShape(Phoneme ePhoneme)
		{
			phoneme = ePhoneme;
			blendShapes = new List<int>();
			weights = new List<float>();
			bones = new List<BoneShape>();
		}
	}
	[Serializable]
	public class Shape
	{
		[SerializeField]
		public List<int> blendShapes = new List<int>();

		[SerializeField]
		public List<string> blendableNames = new List<string>();

		[SerializeField]
		public List<float> weights = new List<float>();

		[SerializeField]
		public List<BoneShape> bones = new List<BoneShape>();

		[SerializeField]
		public bool verified = true;

		public bool HasBone(Transform bone)
		{
			for (int i = 0; i < bones.Count; i++)
			{
				if (bones[i].bone == bone)
				{
					return true;
				}
			}
			return false;
		}

		public int IndexOfBone(Transform bone)
		{
			for (int i = 0; i < bones.Count; i++)
			{
				if (bones[i].bone == bone)
				{
					return i;
				}
			}
			return -1;
		}
	}
	public class TemporaryLipSyncData : ScriptableObject
	{
		public AudioClip clip;

		public List<PhonemeMarker> phonemeData;

		public List<EmotionMarker> emotionData;

		public List<GestureMarker> gestureData;

		public float version;

		public float length = 10f;

		public string transcript = "";

		private void OnEnable()
		{
			base.hideFlags = HideFlags.DontSaveInEditor | HideFlags.DontSaveInBuild;
		}

		public static explicit operator TemporaryLipSyncData(LipSyncData data)
		{
			TemporaryLipSyncData temporaryLipSyncData = ScriptableObject.CreateInstance<TemporaryLipSyncData>();
			temporaryLipSyncData.phonemeData = new List<PhonemeMarker>();
			temporaryLipSyncData.emotionData = new List<EmotionMarker>();
			temporaryLipSyncData.gestureData = new List<GestureMarker>();
			for (int i = 0; i < data.phonemeData.Length; i++)
			{
				temporaryLipSyncData.phonemeData.Add(data.phonemeData[i].CreateCopy());
			}
			for (int j = 0; j < data.emotionData.Length; j++)
			{
				temporaryLipSyncData.emotionData.Add(data.emotionData[j].CreateCopy());
			}
			for (int k = 0; k < data.gestureData.Length; k++)
			{
				temporaryLipSyncData.gestureData.Add(data.gestureData[k].CreateCopy());
			}
			temporaryLipSyncData.clip = data.clip;
			temporaryLipSyncData.version = data.version;
			temporaryLipSyncData.length = data.length;
			temporaryLipSyncData.transcript = data.transcript;
			return temporaryLipSyncData;
		}
	}
	[Serializable]
	public class TransformAnimationCurve
	{
		public struct TransformKeyframe
		{
			public float time;

			public Quaternion rotation;

			public Vector3 position;

			public Vector3 scale;

			public float inTangent;

			public float outTangent;

			public TransformKeyframe(float time, Vector3 position, Quaternion rotation, Vector3 scale, float inTangent, float outTangent)
			{
				this.time = time;
				this.position = position;
				this.rotation = rotation;
				this.scale = scale;
				this.inTangent = inTangent;
				this.outTangent = outTangent;
			}
		}

		private AnimationCurve _posX;

		private AnimationCurve _posY;

		private AnimationCurve _posZ;

		private AnimationCurve _rotX;

		private AnimationCurve _rotY;

		private AnimationCurve _rotZ;

		private AnimationCurve _rotW;

		private AnimationCurve _scaleX;

		private AnimationCurve _scaleY;

		private AnimationCurve _scaleZ;

		public TransformKeyframe[] keys
		{
			get
			{
				List<TransformKeyframe> list = new List<TransformKeyframe>();
				Keyframe[] array = _posX.keys;
				Keyframe[] array2 = _posY.keys;
				Keyframe[] array3 = _posZ.keys;
				Keyframe[] array4 = _rotX.keys;
				Keyframe[] array5 = _rotY.keys;
				Keyframe[] array6 = _rotZ.keys;
				Keyframe[] array7 = _rotW.keys;
				Keyframe[] array8 = _scaleX.keys;
				Keyframe[] array9 = _scaleY.keys;
				Keyframe[] array10 = _scaleZ.keys;
				for (int i = 0; i < _posX.length; i++)
				{
					list.Add(new TransformKeyframe(array[i].time, new Vector3(array[i].value, array2[i].value, array3[i].value), new Quaternion(array4[i].value, array5[i].value, array6[i].value, array7[i].value), new Vector3(array8[i].value, array9[i].value, array10[i].value), array[i].inTangent, array[i].outTangent));
				}
				return list.ToArray();
			}
		}

		public int length => _posX.length;

		public WrapMode postWrapMode
		{
			get
			{
				return _posX.postWrapMode;
			}
			set
			{
				_posX.postWrapMode = value;
				_posY.postWrapMode = value;
				_posZ.postWrapMode = value;
				_rotX.postWrapMode = value;
				_rotY.postWrapMode = value;
				_rotZ.postWrapMode = value;
				_rotW.postWrapMode = value;
				_scaleX.postWrapMode = value;
				_scaleY.postWrapMode = value;
				_scaleZ.postWrapMode = value;
			}
		}

		public WrapMode preWrapMode
		{
			get
			{
				return _posX.preWrapMode;
			}
			set
			{
				_posX.preWrapMode = value;
				_posY.preWrapMode = value;
				_posZ.preWrapMode = value;
				_rotX.preWrapMode = value;
				_rotY.preWrapMode = value;
				_rotZ.preWrapMode = value;
				_rotW.preWrapMode = value;
				_scaleX.preWrapMode = value;
				_scaleY.preWrapMode = value;
				_scaleZ.preWrapMode = value;
			}
		}

		public int AddKey(float time, Vector3 position, Quaternion rotation, Vector3 scale, float inTangent, float outTangent)
		{
			int result = _posX.AddKey(new Keyframe(time, position.x, inTangent, outTangent));
			_posY.AddKey(new Keyframe(time, position.y, inTangent, outTangent));
			_posZ.AddKey(new Keyframe(time, position.z, inTangent, outTangent));
			Quaternion quaternion = Quaternion.Euler(CentreAngles(rotation.eulerAngles));
			_rotX.AddKey(new Keyframe(time, quaternion.x, inTangent, outTangent));
			_rotY.AddKey(new Keyframe(time, quaternion.y, inTangent, outTangent));
			_rotZ.AddKey(new Keyframe(time, quaternion.z, inTangent, outTangent));
			_rotW.AddKey(new Keyframe(time, quaternion.w, inTangent, outTangent));
			_scaleX.AddKey(new Keyframe(time, scale.x, inTangent, outTangent));
			_scaleY.AddKey(new Keyframe(time, scale.y, inTangent, outTangent));
			_scaleZ.AddKey(new Keyframe(time, scale.z, inTangent, outTangent));
			return result;
		}

		public int AddKey(float time, Vector3 position, Quaternion rotation, float inTangent, float outTangent)
		{
			int result = _posX.AddKey(new Keyframe(time, position.x, inTangent, outTangent));
			_posY.AddKey(new Keyframe(time, position.y, inTangent, outTangent));
			_posZ.AddKey(new Keyframe(time, position.z, inTangent, outTangent));
			Quaternion quaternion = Quaternion.Euler(CentreAngles(rotation.eulerAngles));
			_rotX.AddKey(new Keyframe(time, quaternion.x, inTangent, outTangent));
			_rotY.AddKey(new Keyframe(time, quaternion.y, inTangent, outTangent));
			_rotZ.AddKey(new Keyframe(time, quaternion.z, inTangent, outTangent));
			_rotW.AddKey(new Keyframe(time, quaternion.w, inTangent, outTangent));
			return result;
		}

		public int AddKey(float time, Quaternion rotation, float inTangent, float outTangent)
		{
			Quaternion quaternion = Quaternion.Euler(CentreAngles(rotation.eulerAngles));
			int result = _rotX.AddKey(new Keyframe(time, quaternion.x, inTangent, outTangent));
			_rotY.AddKey(new Keyframe(time, quaternion.y, inTangent, outTangent));
			_rotZ.AddKey(new Keyframe(time, quaternion.z, inTangent, outTangent));
			_rotW.AddKey(new Keyframe(time, quaternion.w, inTangent, outTangent));
			return result;
		}

		public int AddKey(float time, Vector3 position, float inTangent, float outTangent)
		{
			int result = _posX.AddKey(new Keyframe(time, position.x, inTangent, outTangent));
			_posY.AddKey(new Keyframe(time, position.y, inTangent, outTangent));
			_posZ.AddKey(new Keyframe(time, position.z, inTangent, outTangent));
			return result;
		}

		public int AddKey(float time, Vector3 position, Quaternion rotation, Vector3 scale)
		{
			int result = _posX.AddKey(time, position.x);
			_posY.AddKey(time, position.y);
			_posZ.AddKey(time, position.z);
			Quaternion quaternion = Quaternion.Euler(CentreAngles(rotation.eulerAngles));
			_rotX.AddKey(time, quaternion.x);
			_rotY.AddKey(time, quaternion.y);
			_rotZ.AddKey(time, quaternion.z);
			_rotW.AddKey(time, quaternion.w);
			_scaleX.AddKey(time, scale.x);
			_scaleY.AddKey(time, scale.y);
			_scaleZ.AddKey(time, scale.z);
			return result;
		}

		public int AddKey(float time, Vector3 position, Quaternion rotation)
		{
			int result = _posX.AddKey(time, position.x);
			_posY.AddKey(time, position.y);
			_posZ.AddKey(time, position.z);
			Quaternion quaternion = Quaternion.Euler(CentreAngles(rotation.eulerAngles));
			_rotX.AddKey(time, quaternion.x);
			_rotY.AddKey(time, quaternion.y);
			_rotZ.AddKey(time, quaternion.z);
			_rotW.AddKey(time, quaternion.w);
			return result;
		}

		public int AddKey(float time, Quaternion rotation)
		{
			Quaternion quaternion = Quaternion.Euler(CentreAngles(rotation.eulerAngles));
			int result = _rotX.AddKey(time, quaternion.x);
			_rotY.AddKey(time, quaternion.y);
			_rotZ.AddKey(time, quaternion.z);
			_rotW.AddKey(time, quaternion.w);
			return result;
		}

		public int AddKey(float time, Vector3 position)
		{
			int result = _posX.AddKey(time, position.x);
			_posY.AddKey(time, position.y);
			_posZ.AddKey(time, position.z);
			return result;
		}

		public int AddKey(TransformKeyframe keyframe)
		{
			int result = _posX.AddKey(new Keyframe(keyframe.time, keyframe.position.x, keyframe.inTangent, keyframe.outTangent));
			_posY.AddKey(new Keyframe(keyframe.time, keyframe.position.y, keyframe.inTangent, keyframe.outTangent));
			_posZ.AddKey(new Keyframe(keyframe.time, keyframe.position.z, keyframe.inTangent, keyframe.outTangent));
			Quaternion quaternion = Quaternion.Euler(CentreAngles(keyframe.rotation.eulerAngles));
			_rotX.AddKey(new Keyframe(keyframe.time, quaternion.x, keyframe.inTangent, keyframe.outTangent));
			_rotY.AddKey(new Keyframe(keyframe.time, quaternion.y, keyframe.inTangent, keyframe.outTangent));
			_rotZ.AddKey(new Keyframe(keyframe.time, quaternion.z, keyframe.inTangent, keyframe.outTangent));
			_rotW.AddKey(new Keyframe(keyframe.time, quaternion.w, keyframe.inTangent, keyframe.outTangent));
			return result;
		}

		public Vector3 EvaluateScale(float time)
		{
			float x = _scaleX.Evaluate(time);
			float y = _scaleY.Evaluate(time);
			float z = _scaleZ.Evaluate(time);
			return new Vector3(x, y, z);
		}

		public Vector3 EvaluatePosition(float time)
		{
			float x = _posX.Evaluate(time);
			float y = _posY.Evaluate(time);
			float z = _posZ.Evaluate(time);
			return new Vector3(x, y, z);
		}

		public Quaternion EvaluateRotation(float time)
		{
			float x = _rotX.Evaluate(time);
			float y = _rotY.Evaluate(time);
			float z = _rotZ.Evaluate(time);
			float w = _rotW.Evaluate(time);
			return new Quaternion(x, y, z, w);
		}

		public TransformAnimationCurve()
		{
			_posX = new AnimationCurve();
			_posY = new AnimationCurve();
			_posZ = new AnimationCurve();
			_scaleX = new AnimationCurve();
			_scaleY = new AnimationCurve();
			_scaleZ = new AnimationCurve();
			_rotX = new AnimationCurve();
			_rotY = new AnimationCurve();
			_rotZ = new AnimationCurve();
			_rotW = new AnimationCurve();
		}

		private Vector3 CentreAngles(Vector3 euler)
		{
			return euler.ToNegativeEuler();
		}

		public void FixQuaternionContinuity()
		{
			Keyframe[] array = _rotX.keys;
			Keyframe[] array2 = _rotY.keys;
			Keyframe[] array3 = _rotZ.keys;
			Keyframe[] array4 = _rotW.keys;
			if (array.Length == 0)
			{
				return;
			}
			Quaternion b = new Quaternion(array[0].value, array2[0].value, array3[0].value, array4[0].value);
			for (int i = 0; i < array.Length; i++)
			{
				Quaternion quaternion = new Quaternion(array[i].value, array2[i].value, array3[i].value, array4[i].value);
				if (Quaternion.Dot(quaternion, b) < 0f)
				{
					quaternion = Quaternion.Inverse(quaternion);
				}
				array[i].value = quaternion.x;
				array2[i].value = quaternion.y;
				array3[i].value = quaternion.z;
				array4[i].value = quaternion.w;
				b = quaternion;
			}
			_rotX.keys = array;
			_rotY.keys = array2;
			_rotZ.keys = array3;
			_rotW.keys = array4;
		}
	}
	[AddComponentMenu("Rogo Digital/LipSync Pro")]
	[DisallowMultipleComponent]
	[HelpURL("https://lipsync.rogodigital.com/documentation/lipsync.php")]
	public class LipSync : BlendSystemUser
	{
		public delegate void ResetDelegate();

		public enum AnimationTimingMode
		{
			AudioPlayback,
			CustomTimer,
			FixedFrameRate
		}

		public enum CurveGenerationMode
		{
			Tight,
			Loose
		}

		public AudioSource audioSource;

		public bool useBones;

		public bool boneUpdateAnimation;

		[SerializeField]
		public List<PhonemeShape> phonemes = new List<PhonemeShape>();

		[SerializeField]
		public List<EmotionShape> emotions = new List<EmotionShape>();

		public bool playOnAwake;

		public bool loop;

		public LipSyncData defaultClip;

		public float defaultDelay;

		public bool scaleAudioSpeed = true;

		[SerializeField]
		private AnimationTimingMode m_animationTimingMode;

		public int frameRate = 30;

		public float restTime = 0.2f;

		public float restHoldTime = 0.4f;

		public CurveGenerationMode phonemeCurveGenerationMode = CurveGenerationMode.Loose;

		public CurveGenerationMode emotionCurveGenerationMode;

		public bool keepEmotionWhenFinished;

		public bool setNeutralBonePosesOnStart;

		public Animator gesturesAnimator;

		public int gesturesLayer;

		public List<GestureInstance> gestures;

		public UnityEvent onFinishedPlaying;

		private AudioClip audioClip;

		private bool ready;

		private Dictionary<string, EmotionShape> emotionCache;

		private int currentFileID;

		private LipSyncData lastClip;

		private float emotionBlendTime;

		private float emotionTimer;

		private bool changingEmotion;

		private int customEmotion = -1;

		private float customTimer;

		private bool isDelaying;

		private List<PhonemeMarker> phonemeMarkers;

		private List<EmotionMarker> emotionMarkers;

		private List<GestureMarker> gestureMarkers;

		private float fileLength;

		private int nextGesture;

		private List<int> indexBlendables;

		private List<AnimationCurve> animCurves;

		private List<Transform> bones;

		private List<TransformAnimationCurve> boneCurves;

		private List<Vector3> boneNeutralPositions;

		private List<Vector3> boneNeutralScales;

		private List<Quaternion> boneNeutralRotations;

		public ResetDelegate reset;

		public float lastUsedVersion;

		public AnimationTimingMode animationTimingMode
		{
			get
			{
				return m_animationTimingMode;
			}
			set
			{
				m_animationTimingMode = value;
			}
		}

		public bool IsPlaying { get; private set; }

		public bool IsPaused { get; private set; }

		public bool IsStopping { get; private set; }

		public float CurrentTime
		{
			get
			{
				if (!IsPlaying)
				{
					return 0f;
				}
				if (animationTimingMode == AnimationTimingMode.AudioPlayback)
				{
					return audioSource.time;
				}
				return customTimer;
			}
		}

		private void Reset()
		{
			CleanUpBlendSystems();
			if (reset != null)
			{
				reset();
			}
		}

		private void Awake()
		{
			if (audioSource == null)
			{
				audioSource = GetComponent<AudioSource>();
			}
			if (audioSource == null)
			{
				UnityEngine.Debug.LogError("[LipSync - " + base.gameObject.name + "] No AudioSource specified or found.");
				return;
			}
			if (blendSystem == null)
			{
				UnityEngine.Debug.LogError("[LipSync - " + base.gameObject.name + "] No BlendSystem set.");
				return;
			}
			if (!blendSystem.isReady)
			{
				UnityEngine.Debug.LogError("[LipSync - " + base.gameObject.name + "] BlendSystem is not set up.");
				return;
			}
			ready = true;
			if (restTime < 0.1f)
			{
				UnityEngine.Debug.LogWarning("[LipSync - " + base.gameObject.name + "] Rest Time and/or Hold Time are lower than recommended and may cause animation errors. From LipSync 0.6, Rest Time is recommended to be 0.2 and Hold Time is recommended to be 0.1");
			}
			emotionCache = new Dictionary<string, EmotionShape>();
			foreach (EmotionShape emotion in emotions)
			{
				if (emotionCache.ContainsKey(emotion.emotion))
				{
					UnityEngine.Debug.LogWarning("[LipSync - " + base.gameObject.name + "] Project Settings contains more than 1 emotion called \"" + emotion.emotion + "\". Duplicates will be ignored.");
					continue;
				}
				if (setNeutralBonePosesOnStart)
				{
					foreach (BoneShape bone in emotion.bones)
					{
						bone.SetNeutral();
					}
				}
				emotionCache.Add(emotion.emotion, emotion);
			}
			if (gesturesAnimator != null)
			{
				foreach (GestureInstance gesture in gestures)
				{
					if (!gesture.IsValid(gesturesAnimator))
					{
						UnityEngine.Debug.LogWarning("[LipSync - " + base.gameObject.name + "] Animator does not contain a trigger called '" + gesture.triggerName + "'. This Gesture will be ignored.");
					}
				}
			}
			if (playOnAwake && defaultClip != null)
			{
				Play(defaultClip, defaultDelay);
			}
		}

		private void LateUpdate()
		{
			if ((!IsPlaying || IsPaused) && !changingEmotion && !IsStopping)
			{
				return;
			}
			if (scaleAudioSpeed && !changingEmotion)
			{
				audioSource.pitch = Time.timeScale;
			}
			if (isDelaying)
			{
				customTimer -= Time.deltaTime;
				if (customTimer <= 0f)
				{
					isDelaying = false;
				}
				return;
			}
			float num = 0f;
			if (IsPlaying || IsStopping)
			{
				if (animationTimingMode == AnimationTimingMode.AudioPlayback && audioClip != null && IsPlaying)
				{
					num = audioSource.time / audioClip.length;
				}
				else if (animationTimingMode == AnimationTimingMode.CustomTimer || (animationTimingMode == AnimationTimingMode.AudioPlayback && audioClip == null) || IsStopping)
				{
					customTimer += Time.deltaTime;
					num = customTimer / (IsStopping ? restHoldTime : fileLength);
				}
				else if (animationTimingMode == AnimationTimingMode.FixedFrameRate)
				{
					customTimer += 1f / (float)frameRate;
					num = customTimer / fileLength;
				}
				if (gestures.Count > 0 && nextGesture < gestureMarkers.Count && gesturesAnimator != null && !IsStopping && num >= gestureMarkers[nextGesture].time)
				{
					if (GetGesture(gestureMarkers[nextGesture].gesture) != null)
					{
						gesturesAnimator.SetTrigger(GetGesture(gestureMarkers[nextGesture].gesture).triggerName);
					}
					nextGesture++;
				}
			}
			else
			{
				emotionTimer += Time.deltaTime;
				num = emotionTimer / emotionBlendTime;
			}
			for (int i = 0; i < animCurves.Count; i++)
			{
				blendSystem.SetBlendableValue(indexBlendables[i], animCurves[i].Evaluate(num));
			}
			if (useBones && boneCurves != null)
			{
				for (int j = 0; j < boneCurves.Count; j++)
				{
					if (!boneUpdateAnimation)
					{
						bones[j].localPosition = boneCurves[j].EvaluatePosition(num);
						bones[j].localRotation = boneCurves[j].EvaluateRotation(num);
						bones[j].localScale = boneCurves[j].EvaluateScale(num);
						continue;
					}
					Vector3 vector = boneCurves[j].EvaluatePosition(num) - boneNeutralPositions[j];
					Vector3 vector2 = boneCurves[j].EvaluateRotation(num).eulerAngles - boneNeutralRotations[j].eulerAngles;
					Vector3 vector3 = boneCurves[j].EvaluateScale(num) - boneNeutralScales[j];
					bones[j].localPosition += vector;
					bones[j].localEulerAngles += vector2;
					bones[j].localScale += vector3;
				}
			}
			if (changingEmotion && num > 1f)
			{
				changingEmotion = false;
			}
			if (num >= 0.98f && !changingEmotion)
			{
				if (IsStopping)
				{
					IsStopping = false;
				}
				else if (loop)
				{
					Stop(stopAudio: false);
					Play(lastClip);
				}
				else
				{
					Stop(stopAudio: false);
				}
			}
		}

		public void SetEmotion(string emotion, float blendTime)
		{
			if (IsPlaying || !ready || !base.enabled)
			{
				return;
			}
			EmotionShape emotionShape = null;
			if (emotion == "")
			{
				emotionShape = new EmotionShape("temp");
			}
			else
			{
				if (emotions.IndexOf(emotionCache[emotion]) == customEmotion)
				{
					return;
				}
				emotionShape = emotionCache[emotion];
			}
			animCurves = new List<AnimationCurve>();
			indexBlendables = new List<int>();
			if (useBones)
			{
				boneCurves = new List<TransformAnimationCurve>();
				bones = new List<Transform>();
			}
			for (int i = 0; i < emotionShape.blendShapes.Count; i++)
			{
				indexBlendables.Add(emotionShape.blendShapes[i]);
				animCurves.Add(new AnimationCurve());
			}
			if (useBones)
			{
				for (int j = 0; j < emotionShape.bones.Count; j++)
				{
					bones.Add(emotionShape.bones[j].bone);
					boneCurves.Add(new TransformAnimationCurve());
				}
			}
			if (customEmotion > -1)
			{
				for (int k = 0; k < emotions[customEmotion].blendShapes.Count; k++)
				{
					if (!indexBlendables.Contains(emotions[customEmotion].blendShapes[k]))
					{
						indexBlendables.Add(emotions[customEmotion].blendShapes[k]);
						animCurves.Add(new AnimationCurve());
					}
				}
				if (useBones)
				{
					for (int l = 0; l < emotions[customEmotion].bones.Count; l++)
					{
						if (!bones.Contains(emotions[customEmotion].bones[l].bone))
						{
							bones.Add(emotions[customEmotion].bones[l].bone);
							boneCurves.Add(new TransformAnimationCurve());
						}
					}
				}
			}
			if (customEmotion > -1)
			{
				for (int m = 0; m < emotions[customEmotion].blendShapes.Count; m++)
				{
					int index = indexBlendables.IndexOf(emotions[customEmotion].blendShapes[m]);
					animCurves[index].AddKey(new Keyframe(0f, blendSystem.GetBlendableValue(emotions[customEmotion].blendShapes[m]), 90f, 0f));
				}
				for (int n = 0; n < animCurves.Count; n++)
				{
					if (animCurves[n].keys.Length != 0)
					{
						if (emotionShape.blendShapes.Contains(indexBlendables[n]))
						{
							animCurves[n].AddKey(new Keyframe(1f, emotionShape.weights[emotionShape.blendShapes.IndexOf(indexBlendables[n])], 0f, 90f));
						}
						else
						{
							animCurves[n].AddKey(new Keyframe(1f, 0f, 0f, 90f));
						}
					}
					else
					{
						animCurves[n].AddKey(new Keyframe(0f, blendSystem.GetBlendableValue(indexBlendables[n]), 90f, 0f));
						int index2 = emotionShape.blendShapes.IndexOf(indexBlendables[n]);
						animCurves[n].AddKey(new Keyframe(1f, emotionShape.weights[index2], 0f, 90f));
					}
				}
				if (useBones && boneCurves != null)
				{
					for (int num = 0; num < emotions[customEmotion].bones.Count; num++)
					{
						int index3 = bones.IndexOf(emotions[customEmotion].bones[num].bone);
						boneCurves[index3].AddKey(0f, emotions[customEmotion].bones[num].bone.localPosition, emotions[customEmotion].bones[num].bone.localRotation, emotions[customEmotion].bones[num].bone.localScale, 90f, 0f);
					}
					for (int num2 = 0; num2 < boneCurves.Count; num2++)
					{
						if (boneCurves[num2].length > 0)
						{
							if (emotionShape.HasBone(bones[num2]))
							{
								boneCurves[num2].AddKey(1f, emotionShape.bones[emotionShape.IndexOfBone(bones[num2])].endPosition, Quaternion.Euler(emotionShape.bones[emotionShape.IndexOfBone(bones[num2])].endRotation), emotionShape.bones[emotionShape.IndexOfBone(bones[num2])].endScale, 0f, 90f);
							}
							else
							{
								boneCurves[num2].AddKey(1f, emotions[customEmotion].bones[emotions[customEmotion].IndexOfBone(bones[num2])].neutralPosition, Quaternion.Euler(emotions[customEmotion].bones[emotions[customEmotion].IndexOfBone(bones[num2])].neutralRotation), emotions[customEmotion].bones[emotions[customEmotion].IndexOfBone(bones[num2])].neutralScale, 0f, 90f);
							}
						}
						else
						{
							boneCurves[num2].AddKey(0f, bones[num2].localPosition, bones[num2].localRotation, bones[num2].localScale, 90f, 0f);
							int index4 = emotionShape.IndexOfBone(bones[num2]);
							boneCurves[num2].AddKey(1f, emotionShape.bones[index4].endPosition, Quaternion.Euler(emotionShape.bones[index4].endRotation), emotionShape.bones[index4].endScale, 0f, 90f);
						}
					}
				}
			}
			else
			{
				for (int num3 = 0; num3 < animCurves.Count; num3++)
				{
					animCurves[num3].AddKey(new Keyframe(0f, blendSystem.GetBlendableValue(indexBlendables[num3]), 90f, 0f));
					animCurves[num3].AddKey(new Keyframe(1f, emotionShape.weights[num3], 0f, 90f));
				}
				if (useBones && boneCurves != null)
				{
					for (int num4 = 0; num4 < boneCurves.Count; num4++)
					{
						boneCurves[num4].AddKey(0f, bones[num4].localPosition, bones[num4].localRotation, bones[num4].localScale, 90f, 0f);
						boneCurves[num4].AddKey(1f, emotionShape.bones[num4].endPosition, Quaternion.Euler(emotionShape.bones[num4].endRotation), emotionShape.bones[num4].endScale, 0f, 90f);
					}
				}
			}
			foreach (TransformAnimationCurve boneCurf in boneCurves)
			{
				boneCurf.FixQuaternionContinuity();
			}
			emotionTimer = 0f;
			emotionBlendTime = blendTime;
			customEmotion = emotions.IndexOf(emotionShape);
			changingEmotion = true;
		}

		public void ResetEmotion(float blendTime)
		{
			SetEmotion("", blendTime);
		}

		private void PlayPP(LipSyncData data, float delay, float time)
		{
			if (data.targetComponentID != GetInstanceID())
			{
				UnityEngine.Debug.LogWarning("Playing pre-processed clip on a different character. The animation may look incorrect or not play at all. You can remove the pre-processed data by selecting the clip in the Project window.");
			}
			phonemeMarkers = new List<PhonemeMarker>(data.phonemeData);
			emotionMarkers = new List<EmotionMarker>(data.emotionData);
			gestureMarkers = new List<GestureMarker>(data.gestureData);
			gestureMarkers.Sort(SortTime);
			lastClip = data;
			currentFileID = data.GetInstanceID();
			audioClip = data.clip;
			fileLength = data.length;
			if ((bool)audioSource)
			{
				audioSource.clip = audioClip;
			}
			animCurves = new List<AnimationCurve>(data.animCurves);
			indexBlendables = data.indexBlendables;
			bones = data.bones;
			boneCurves = new List<TransformAnimationCurve>(data.boneCurves);
			boneNeutralPositions = data.boneNeutralPositions;
			boneNeutralRotations = data.boneNeutralRotations;
			boneNeutralScales = data.boneNeutralScales;
			if (gesturesAnimator != null && gestures != null)
			{
				if (gestures.Count > 0)
				{
					gesturesAnimator.SetLayerWeight(gesturesLayer, 1f);
				}
			}
			else if (data.gestureData.Length != 0)
			{
				UnityEngine.Debug.Log("[LipSync - " + base.gameObject.name + "] Animator or Gestures are not set up. Gestures from this clip won't be played.");
			}
			IsPlaying = true;
			IsPaused = false;
			nextGesture = 0;
			IsStopping = false;
			if ((bool)audioClip && delay > 0f)
			{
				isDelaying = true;
				customTimer = time + delay;
			}
			else
			{
				isDelaying = false;
				customTimer = time;
			}
			if ((bool)audioClip && (bool)audioSource)
			{
				audioSource.PlayDelayed(time + delay);
			}
		}

		public void Play(LipSyncData dataFile, float delay)
		{
			if (!ready || !base.enabled)
			{
				return;
			}
			if (dataFile.isPreprocessed)
			{
				PlayPP(dataFile, delay, 0f);
				return;
			}
			bool flag = true;
			if (dataFile.GetInstanceID() != currentFileID || customEmotion > -1)
			{
				flag = LoadData(dataFile);
			}
			if (!flag)
			{
				return;
			}
			ProcessData();
			if (gesturesAnimator != null && gestures != null)
			{
				if (gestures.Count > 0)
				{
					gesturesAnimator.SetLayerWeight(gesturesLayer, 1f);
				}
			}
			else if (dataFile.gestureData.Length != 0)
			{
				UnityEngine.Debug.Log("[LipSync - " + base.gameObject.name + "] Animator or Gestures are not set up. Gestures from this clip won't be played.");
			}
			IsPlaying = true;
			IsPaused = false;
			nextGesture = 0;
			IsStopping = false;
			if ((bool)audioClip && delay > 0f)
			{
				isDelaying = true;
				customTimer = delay;
			}
			else
			{
				isDelaying = false;
				customTimer = 0f;
			}
			if ((bool)audioClip && (bool)audioSource)
			{
				audioSource.PlayDelayed(delay);
			}
		}

		public void Play(LipSyncData dataFile)
		{
			Play(dataFile, 0f);
		}

		public void Play(TextAsset xmlFile, AudioClip clip, float delay)
		{
			if (ready && base.enabled)
			{
				LoadXML(xmlFile, clip);
				if (gesturesAnimator != null)
				{
					gesturesAnimator.SetLayerWeight(gesturesLayer, 1f);
				}
				IsPlaying = true;
				IsPaused = false;
				nextGesture = 0;
				IsStopping = false;
				ProcessData();
				if ((bool)audioClip && delay > 0f)
				{
					isDelaying = true;
					customTimer = delay;
				}
				else
				{
					isDelaying = false;
					customTimer = 0f;
				}
				audioSource.PlayDelayed(delay);
			}
		}

		public void Play(TextAsset xmlFile, AudioClip clip)
		{
			Play(xmlFile, clip, 0f);
		}

		public void PlayFromTime(LipSyncData dataFile, float delay, float time)
		{
			if (!ready || !base.enabled)
			{
				return;
			}
			if (dataFile.isPreprocessed)
			{
				PlayPP(dataFile, delay, time);
				return;
			}
			bool flag = true;
			if (dataFile.GetInstanceID() != currentFileID || customEmotion > -1)
			{
				flag = LoadData(dataFile);
			}
			if (!flag)
			{
				return;
			}
			if (time >= fileLength)
			{
				UnityEngine.Debug.LogError("[LipSync - " + base.gameObject.name + "] Couldn't play animation. Time parameter is greater than clip length.");
				return;
			}
			ProcessData();
			if (gesturesAnimator != null)
			{
				gesturesAnimator.SetLayerWeight(gesturesLayer, 1f);
			}
			IsPlaying = true;
			IsPaused = false;
			isDelaying = false;
			customTimer = 0f;
			nextGesture = 0;
			IsStopping = false;
			audioSource.Play();
			audioSource.time = time + delay;
		}

		public void PlayFromTime(LipSyncData dataFile, float time)
		{
			PlayFromTime(dataFile, 0f, time);
		}

		public void PlayFromTime(TextAsset xmlFile, AudioClip clip, float delay, float time)
		{
			if (!ready || !base.enabled)
			{
				return;
			}
			LoadXML(xmlFile, clip);
			if (time >= fileLength)
			{
				UnityEngine.Debug.LogError("[LipSync - " + base.gameObject.name + "] Couldn't play animation. Time parameter is greater than clip length.");
				return;
			}
			if (gesturesAnimator != null)
			{
				gesturesAnimator.SetLayerWeight(gesturesLayer, 1f);
			}
			IsPlaying = true;
			IsPaused = false;
			isDelaying = false;
			customTimer = 0f;
			nextGesture = 0;
			IsStopping = false;
			ProcessData();
			audioSource.Play();
			audioSource.time = time + delay;
		}

		public void PlayFromTime(TextAsset xmlFile, AudioClip clip, float time)
		{
			PlayFromTime(xmlFile, clip, 0f, time);
		}

		public void Pause()
		{
			if (IsPlaying && !IsPaused && base.enabled)
			{
				IsPaused = true;
				audioSource.Pause();
			}
		}

		public void Resume()
		{
			if (IsPlaying && IsPaused && base.enabled)
			{
				IsPaused = false;
				audioSource.UnPause();
			}
		}

		public void Stop(bool stopAudio)
		{
			if (!IsPlaying || !base.enabled)
			{
				return;
			}
			IsPlaying = false;
			IsPaused = false;
			isDelaying = false;
			IsStopping = true;
			customTimer = 0f;
			for (int i = 0; i < animCurves.Count; i++)
			{
				float value = animCurves[i].Evaluate(1f);
				float blendableValue = blendSystem.GetBlendableValue(indexBlendables[i]);
				animCurves[i] = new AnimationCurve(new Keyframe(0f, blendableValue), new Keyframe(1f, value));
			}
			if (useBones)
			{
				for (int j = 0; j < boneCurves.Count; j++)
				{
					Vector3 position = boneCurves[j].EvaluatePosition(1f);
					Vector3 scale = boneCurves[j].EvaluateScale(1f);
					Quaternion rotation = boneCurves[j].EvaluateRotation(1f);
					Vector3 localPosition = bones[j].localPosition;
					Vector3 localScale = bones[j].localScale;
					Quaternion localRotation = bones[j].localRotation;
					boneCurves[j] = new TransformAnimationCurve();
					boneCurves[j].AddKey(0f, localPosition, localRotation, localScale, 0f, 0f);
					boneCurves[j].AddKey(1f, position, rotation, scale, 0f, 0f);
				}
			}
			if (stopAudio)
			{
				audioSource.Stop();
			}
			onFinishedPlaying.Invoke();
		}

		public void PreviewAtTime(float time)
		{
			if (IsPlaying || !base.enabled || animCurves == null)
			{
				return;
			}
			if (indexBlendables == null || animCurves == null)
			{
				if (phonemeMarkers == null || emotionMarkers == null)
				{
					return;
				}
				ProcessData();
			}
			else if (indexBlendables.Count != animCurves.Count)
			{
				if (phonemeMarkers == null || emotionMarkers == null)
				{
					return;
				}
				ProcessData();
			}
			for (int i = 0; i < animCurves.Count; i++)
			{
				blendSystem.SetBlendableValue(indexBlendables[i], animCurves[i].Evaluate(time));
			}
			if (!useBones || boneCurves == null)
			{
				return;
			}
			for (int j = 0; j < boneCurves.Count; j++)
			{
				if (bones[j] != null)
				{
					bones[j].localPosition = boneCurves[j].EvaluatePosition(time);
				}
				if (bones[j] != null)
				{
					bones[j].localRotation = boneCurves[j].EvaluateRotation(time);
				}
			}
		}

		public void DisplayEmotionPose(int emotion, float intensity)
		{
			if (useBones)
			{
				foreach (BoneShape bone in emotions[emotion].bones)
				{
					if (bone.bone != null)
					{
						bone.bone.localPosition = Vector3.Lerp(bone.neutralPosition, bone.endPosition, intensity);
						bone.bone.localEulerAngles = Quaternion.Slerp(Quaternion.Euler(bone.neutralRotation), Quaternion.Euler(bone.endRotation), intensity).eulerAngles;
						bone.bone.localScale = Vector3.Lerp(bone.neutralScale, bone.endScale, intensity);
					}
				}
			}
			for (int i = 0; i < emotions[emotion].blendShapes.Count; i++)
			{
				blendSystem.SetBlendableValue(emotions[emotion].blendShapes[i], emotions[emotion].weights[i] * intensity);
			}
		}

		public void ResetDisplayedEmotions()
		{
			foreach (EmotionShape emotion in emotions)
			{
				if (useBones)
				{
					foreach (BoneShape bone in emotion.bones)
					{
						if (bone.bone != null)
						{
							bone.bone.localPosition = bone.neutralPosition;
							bone.bone.localEulerAngles = bone.neutralRotation;
							bone.bone.localScale = bone.neutralScale;
						}
					}
				}
				foreach (int blendShape in emotion.blendShapes)
				{
					blendSystem.SetBlendableValue(blendShape, 0f);
				}
			}
		}

		public void PreviewAudioAtTime(float time, float length)
		{
			if (!IsPlaying && (bool)audioSource && !audioSource.isPlaying)
			{
				audioSource.PlayOneShot(audioClip);
				if (time <= 1f)
				{
					audioSource.time = time * audioClip.length;
				}
				StartCoroutine(StopAudioSource(length));
			}
		}

		public void TempLoad(List<PhonemeMarker> pData, List<EmotionMarker> eData, AudioClip clip, float duration)
		{
			TempLoad(pData.ToArray(), eData.ToArray(), clip, duration);
		}

		public void TempLoad(PhonemeMarker[] pData, EmotionMarker[] eData, AudioClip clip, float duration)
		{
			if (!base.enabled)
			{
				return;
			}
			if (emotionCache == null)
			{
				emotionCache = new Dictionary<string, EmotionShape>();
				foreach (EmotionShape emotion in emotions)
				{
					emotionCache.Add(emotion.emotion, emotion);
				}
			}
			phonemeMarkers = new List<PhonemeMarker>();
			emotionMarkers = new List<EmotionMarker>();
			foreach (PhonemeMarker item in pData)
			{
				phonemeMarkers.Add(item);
			}
			foreach (EmotionMarker item2 in eData)
			{
				emotionMarkers.Add(item2);
			}
			phonemeMarkers.Sort(SortTime);
			audioClip = clip;
			fileLength = duration;
		}

		public void ProcessData(bool emotionOnly = false)
		{
			if (base.enabled)
			{
				boneNeutralPositions = null;
				boneNeutralRotations = null;
				boneNeutralScales = null;
				List<Transform> list = null;
				List<TransformAnimationCurve> list2 = null;
				List<Transform> list3 = null;
				List<TransformAnimationCurve> list4 = null;
				List<int> list5 = new List<int>();
				List<AnimationCurve> list6 = new List<AnimationCurve>();
				List<int> list7 = new List<int>();
				List<AnimationCurve> list8 = new List<AnimationCurve>();
				Dictionary<int, float> dictionary = new Dictionary<int, float>();
				PhonemeShape phonemeShape = null;
				for (int i = 0; i < phonemes.Count; i++)
				{
					if (phonemes[i].phonemeName.ToLowerInvariant() == "rest")
					{
						phonemeShape = phonemes[i];
					}
				}
				indexBlendables = new List<int>();
				animCurves = new List<AnimationCurve>();
				phonemeMarkers.Sort(SortTime);
				if (useBones)
				{
					boneNeutralPositions = new List<Vector3>();
					boneNeutralRotations = new List<Quaternion>();
					boneNeutralScales = new List<Vector3>();
					bones = new List<Transform>();
					boneCurves = new List<TransformAnimationCurve>();
					list3 = new List<Transform>();
					list4 = new List<TransformAnimationCurve>();
					list = new List<Transform>();
					list2 = new List<TransformAnimationCurve>();
				}
				List<Shape> list9 = new List<Shape>();
				if (!emotionOnly)
				{
					foreach (PhonemeMarker phonemeMarker2 in phonemeMarkers)
					{
						if (list9.Count == phonemes.Count)
						{
							break;
						}
						if (list9.Contains(phonemes[phonemeMarker2.phonemeNumber]))
						{
							continue;
						}
						list9.Add(phonemes[phonemeMarker2.phonemeNumber]);
						foreach (int blendShape in phonemes[phonemeMarker2.phonemeNumber].blendShapes)
						{
							if (!list7.Contains(blendShape))
							{
								AnimationCurve animationCurve = new AnimationCurve();
								animationCurve.postWrapMode = WrapMode.Once;
								list8.Add(animationCurve);
								list7.Add(blendShape);
							}
							if (!indexBlendables.Contains(blendShape))
							{
								AnimationCurve animationCurve2 = new AnimationCurve();
								animationCurve2.postWrapMode = WrapMode.Once;
								animCurves.Add(animationCurve2);
								indexBlendables.Add(blendShape);
							}
							if (!dictionary.ContainsKey(blendShape))
							{
								dictionary.Add(blendShape, 0f);
							}
						}
						if (!useBones || boneCurves == null)
						{
							continue;
						}
						foreach (BoneShape bone in phonemes[phonemeMarker2.phonemeNumber].bones)
						{
							if (!list3.Contains(bone.bone))
							{
								TransformAnimationCurve transformAnimationCurve = new TransformAnimationCurve();
								transformAnimationCurve.postWrapMode = WrapMode.Once;
								list4.Add(transformAnimationCurve);
								list3.Add(bone.bone);
							}
							if (!bones.Contains(bone.bone))
							{
								TransformAnimationCurve transformAnimationCurve2 = new TransformAnimationCurve();
								transformAnimationCurve2.postWrapMode = WrapMode.Once;
								boneCurves.Add(transformAnimationCurve2);
								bones.Add(bone.bone);
								boneNeutralPositions.Add(bone.neutralPosition);
								boneNeutralRotations.Add(Quaternion.Euler(bone.neutralRotation.ToNegativeEuler()));
								boneNeutralScales.Add(bone.neutralScale);
							}
						}
					}
				}
				foreach (EmotionMarker emotionMarker7 in emotionMarkers)
				{
					if (emotionMarker7.isMixer)
					{
						for (int j = 0; j < emotionMarker7.mixer.emotions.Count; j++)
						{
							if (list9.Contains(emotionCache[emotionMarker7.mixer.emotions[j].emotion]) || !emotionCache.ContainsKey(emotionMarker7.mixer.emotions[j].emotion))
							{
								continue;
							}
							list9.Add(emotionCache[emotionMarker7.mixer.emotions[j].emotion]);
							foreach (int blendShape2 in emotionCache[emotionMarker7.mixer.emotions[j].emotion].blendShapes)
							{
								if (!list5.Contains(blendShape2))
								{
									AnimationCurve animationCurve3 = new AnimationCurve();
									animationCurve3.postWrapMode = WrapMode.Once;
									list6.Add(animationCurve3);
									list5.Add(blendShape2);
								}
								if (!indexBlendables.Contains(blendShape2))
								{
									AnimationCurve animationCurve4 = new AnimationCurve();
									animationCurve4.postWrapMode = WrapMode.Once;
									animCurves.Add(animationCurve4);
									indexBlendables.Add(blendShape2);
								}
								if (!dictionary.ContainsKey(blendShape2))
								{
									dictionary.Add(blendShape2, 0f);
								}
							}
							if (!useBones || boneCurves == null)
							{
								continue;
							}
							foreach (BoneShape bone2 in emotionCache[emotionMarker7.mixer.emotions[j].emotion].bones)
							{
								if (!list.Contains(bone2.bone))
								{
									TransformAnimationCurve transformAnimationCurve3 = new TransformAnimationCurve();
									transformAnimationCurve3.postWrapMode = WrapMode.Once;
									list2.Add(transformAnimationCurve3);
									list.Add(bone2.bone);
								}
								if (!bones.Contains(bone2.bone))
								{
									TransformAnimationCurve transformAnimationCurve4 = new TransformAnimationCurve();
									transformAnimationCurve4.postWrapMode = WrapMode.Once;
									boneCurves.Add(transformAnimationCurve4);
									bones.Add(bone2.bone);
									boneNeutralPositions.Add(bone2.neutralPosition);
									boneNeutralRotations.Add(Quaternion.Euler(bone2.neutralRotation.ToNegativeEuler()));
									boneNeutralScales.Add(bone2.neutralScale);
								}
							}
						}
						continue;
					}
					if (emotionCache.ContainsKey(emotionMarker7.emotion))
					{
						if (!emotionCache.ContainsKey(emotionMarker7.emotion) || list9.Contains(emotionCache[emotionMarker7.emotion]))
						{
							continue;
						}
						list9.Add(emotionCache[emotionMarker7.emotion]);
						foreach (int blendShape3 in emotionCache[emotionMarker7.emotion].blendShapes)
						{
							if (!list5.Contains(blendShape3))
							{
								AnimationCurve animationCurve5 = new AnimationCurve();
								animationCurve5.postWrapMode = WrapMode.Once;
								list6.Add(animationCurve5);
								list5.Add(blendShape3);
							}
							if (!indexBlendables.Contains(blendShape3))
							{
								AnimationCurve animationCurve6 = new AnimationCurve();
								animationCurve6.postWrapMode = WrapMode.Once;
								animCurves.Add(animationCurve6);
								indexBlendables.Add(blendShape3);
							}
							if (!dictionary.ContainsKey(blendShape3))
							{
								dictionary.Add(blendShape3, 0f);
							}
						}
						if (!useBones || boneCurves == null)
						{
							continue;
						}
						foreach (BoneShape bone3 in emotionCache[emotionMarker7.emotion].bones)
						{
							if (!list.Contains(bone3.bone))
							{
								TransformAnimationCurve transformAnimationCurve5 = new TransformAnimationCurve();
								transformAnimationCurve5.postWrapMode = WrapMode.Once;
								list2.Add(transformAnimationCurve5);
								list.Add(bone3.bone);
							}
							if (!bones.Contains(bone3.bone))
							{
								TransformAnimationCurve transformAnimationCurve6 = new TransformAnimationCurve();
								transformAnimationCurve6.postWrapMode = WrapMode.Once;
								boneCurves.Add(transformAnimationCurve6);
								bones.Add(bone3.bone);
								boneNeutralPositions.Add(bone3.neutralPosition);
								boneNeutralRotations.Add(Quaternion.Euler(bone3.neutralRotation.ToNegativeEuler()));
								boneNeutralScales.Add(bone3.neutralScale);
							}
						}
						continue;
					}
					emotionMarkers.Remove(emotionMarker7);
					break;
				}
				if (!emotionOnly)
				{
					if (customEmotion > -1 && !list9.Contains(emotions[customEmotion]))
					{
						list9.Add(emotions[customEmotion]);
						foreach (int blendShape4 in emotions[customEmotion].blendShapes)
						{
							if (!list5.Contains(blendShape4))
							{
								AnimationCurve animationCurve7 = new AnimationCurve();
								animationCurve7.postWrapMode = WrapMode.Once;
								list6.Add(animationCurve7);
								list5.Add(blendShape4);
							}
							if (!indexBlendables.Contains(blendShape4))
							{
								AnimationCurve animationCurve8 = new AnimationCurve();
								animationCurve8.postWrapMode = WrapMode.Once;
								animCurves.Add(animationCurve8);
								indexBlendables.Add(blendShape4);
							}
							if (!dictionary.ContainsKey(blendShape4))
							{
								dictionary.Add(blendShape4, 0f);
							}
						}
						if (useBones && boneCurves != null)
						{
							foreach (BoneShape bone4 in emotions[customEmotion].bones)
							{
								if (!list.Contains(bone4.bone))
								{
									TransformAnimationCurve transformAnimationCurve7 = new TransformAnimationCurve();
									transformAnimationCurve7.postWrapMode = WrapMode.Once;
									list2.Add(transformAnimationCurve7);
									list.Add(bone4.bone);
								}
								if (!bones.Contains(bone4.bone))
								{
									TransformAnimationCurve transformAnimationCurve8 = new TransformAnimationCurve();
									transformAnimationCurve8.postWrapMode = WrapMode.Once;
									boneCurves.Add(transformAnimationCurve8);
									bones.Add(bone4.bone);
									boneNeutralPositions.Add(bone4.neutralPosition);
									boneNeutralRotations.Add(Quaternion.Euler(bone4.neutralRotation.ToNegativeEuler()));
									boneNeutralScales.Add(bone4.neutralScale);
								}
							}
						}
					}
					if (phonemeShape != null)
					{
						foreach (int blendShape5 in phonemeShape.blendShapes)
						{
							if (!list7.Contains(blendShape5))
							{
								AnimationCurve animationCurve9 = new AnimationCurve();
								animationCurve9.postWrapMode = WrapMode.Once;
								list8.Add(animationCurve9);
								list7.Add(blendShape5);
							}
							if (!indexBlendables.Contains(blendShape5))
							{
								AnimationCurve animationCurve10 = new AnimationCurve();
								animationCurve10.postWrapMode = WrapMode.Once;
								animCurves.Add(animationCurve10);
								indexBlendables.Add(blendShape5);
							}
							if (!dictionary.ContainsKey(blendShape5))
							{
								dictionary.Add(blendShape5, 0f);
							}
						}
						if (useBones && boneCurves != null)
						{
							foreach (BoneShape bone5 in phonemeShape.bones)
							{
								if (!list3.Contains(bone5.bone))
								{
									TransformAnimationCurve transformAnimationCurve9 = new TransformAnimationCurve();
									transformAnimationCurve9.postWrapMode = WrapMode.Once;
									list4.Add(transformAnimationCurve9);
									list3.Add(bone5.bone);
								}
								if (!bones.Contains(bone5.bone))
								{
									TransformAnimationCurve transformAnimationCurve10 = new TransformAnimationCurve();
									transformAnimationCurve10.postWrapMode = WrapMode.Once;
									boneCurves.Add(transformAnimationCurve10);
									bones.Add(bone5.bone);
									boneNeutralPositions.Add(bone5.neutralPosition);
									boneNeutralRotations.Add(Quaternion.Euler(bone5.neutralRotation.ToNegativeEuler()));
									boneNeutralScales.Add(bone5.neutralScale);
								}
							}
						}
					}
					for (int k = 0; k < indexBlendables.Count; k++)
					{
						if (phonemeShape != null)
						{
							if (phonemeShape.blendShapes.Contains(indexBlendables[k]))
							{
								dictionary[indexBlendables[k]] = phonemeShape.weights[phonemeShape.blendShapes.IndexOf(indexBlendables[k])];
							}
							else
							{
								dictionary[indexBlendables[k]] = 0f;
							}
						}
						else
						{
							dictionary[indexBlendables[k]] = 0f;
						}
					}
					if (useBones && boneCurves != null)
					{
						for (int l = 0; l < bones.Count; l++)
						{
							if (phonemeShape != null && phonemeShape.HasBone(bones[l]))
							{
								boneNeutralPositions[l] = phonemeShape.bones[phonemeShape.IndexOfBone(bones[l])].endPosition;
								boneNeutralRotations[l] = Quaternion.Euler(phonemeShape.bones[phonemeShape.IndexOfBone(bones[l])].endRotation);
								boneNeutralScales[l] = phonemeShape.bones[phonemeShape.IndexOfBone(bones[l])].endScale;
							}
						}
					}
					for (int m = 0; m < list8.Count; m++)
					{
						if (customEmotion == -1)
						{
							list8[m].AddKey(0f, dictionary[list7[m]]);
						}
						if (!keepEmotionWhenFinished)
						{
							list8[m].AddKey(1f, dictionary[list7[m]]);
						}
					}
					for (int n = 0; n < list6.Count; n++)
					{
						if (customEmotion > -1)
						{
							if (emotions[customEmotion].blendShapes.Contains(list5[n]))
							{
								list6[n].AddKey(0f, emotions[customEmotion].weights[emotions[customEmotion].blendShapes.IndexOf(list5[n])]);
							}
							else
							{
								list6[n].AddKey(0f, dictionary[list5[n]]);
							}
						}
						else
						{
							list6[n].AddKey(0f, dictionary[list5[n]]);
						}
						if (!keepEmotionWhenFinished)
						{
							list6[n].AddKey(1f, dictionary[list5[n]]);
						}
						else if (customEmotion > -1 && emotions[customEmotion].blendShapes.Contains(list5[n]))
						{
							list6[n].AddKey(1f, emotions[customEmotion].weights[emotions[customEmotion].blendShapes.IndexOf(list5[n])]);
						}
					}
					if (useBones && boneCurves != null)
					{
						for (int num = 0; num < list4.Count; num++)
						{
							if (customEmotion == -1)
							{
								list4[num].AddKey(0f, boneNeutralPositions[bones.IndexOf(list3[num])], boneNeutralRotations[bones.IndexOf(list3[num])], boneNeutralScales[bones.IndexOf(list3[num])], 0f, 0f);
							}
							if (!keepEmotionWhenFinished)
							{
								list4[num].AddKey(1f, boneNeutralPositions[bones.IndexOf(list3[num])], boneNeutralRotations[bones.IndexOf(list3[num])], boneNeutralScales[bones.IndexOf(list3[num])], 0f, 0f);
							}
						}
						for (int num2 = 0; num2 < list2.Count; num2++)
						{
							if (customEmotion > -1)
							{
								if (emotions[customEmotion].HasBone(list[num2]))
								{
									list2[num2].AddKey(0f, emotions[customEmotion].bones[emotions[customEmotion].IndexOfBone(list[num2])].endPosition, Quaternion.Euler(emotions[customEmotion].bones[emotions[customEmotion].IndexOfBone(list[num2])].endRotation), emotions[customEmotion].bones[emotions[customEmotion].IndexOfBone(list[num2])].endScale, 0f, 0f);
								}
								else
								{
									list2[num2].AddKey(0f, boneNeutralPositions[bones.IndexOf(list[num2])], boneNeutralRotations[bones.IndexOf(list[num2])], boneNeutralScales[bones.IndexOf(list[num2])], 0f, 0f);
								}
							}
							else
							{
								list2[num2].AddKey(0f, boneNeutralPositions[bones.IndexOf(list[num2])], boneNeutralRotations[bones.IndexOf(list[num2])], boneNeutralScales[bones.IndexOf(list[num2])], 0f, 0f);
							}
							if (!keepEmotionWhenFinished)
							{
								list2[num2].AddKey(1f, boneNeutralPositions[bones.IndexOf(list[num2])], boneNeutralRotations[bones.IndexOf(list[num2])], boneNeutralScales[bones.IndexOf(list[num2])], 0f, 0f);
							}
							else if (customEmotion > -1 && emotions[customEmotion].HasBone(list[num2]))
							{
								list2[num2].AddKey(1f, emotions[customEmotion].bones[emotions[customEmotion].IndexOfBone(list[num2])].endPosition, Quaternion.Euler(emotions[customEmotion].bones[emotions[customEmotion].IndexOfBone(list[num2])].endRotation), emotions[customEmotion].bones[emotions[customEmotion].IndexOfBone(list[num2])].endScale, 0f, 0f);
							}
						}
					}
				}
				foreach (EmotionMarker emotionMarker8 in emotionMarkers)
				{
					EmotionShape emotionShape = null;
					int num3 = (emotionMarker8.continuousVariation ? Mathf.Clamp(Mathf.FloorToInt((emotionMarker8.endTime - emotionMarker8.startTime - (emotionMarker8.blendInTime - emotionMarker8.blendOutTime)) * fileLength / emotionMarker8.variationFrequency), 2, 128) : 2);
					float[] array = new float[num3];
					float[] array2 = new float[num3];
					float[] array3 = new float[num3];
					float[] array4 = new float[num3];
					for (int num4 = 0; num4 < num3; num4++)
					{
						if (emotionMarker8.continuousVariation)
						{
							array[num4] = UnityEngine.Random.Range(1f - emotionMarker8.intensityVariation / 2f, 1f + emotionMarker8.intensityVariation / 2f);
							continue;
						}
						array[num4] = 1f;
						array2[num4] = 1f;
						array3[num4] = 1f;
						array4[num4] = 1f;
					}
					emotionShape = ((!emotionMarker8.isMixer) ? emotionCache[emotionMarker8.emotion] : emotionMarker8.mixer.GetShape(this));
					for (int num5 = 0; num5 < list6.Count; num5++)
					{
						if (emotionShape.blendShapes.Contains(list5[num5]))
						{
							int index = emotionShape.blendShapes.IndexOf(list5[num5]);
							float value = dictionary[list5[num5]];
							float value2 = dictionary[list5[num5]];
							if (emotionMarker8.continuousVariation)
							{
								for (int num6 = 0; num6 < num3; num6++)
								{
									array2[num6] = UnityEngine.Random.Range(1f - emotionMarker8.blendableVariation / 2f, 1f + emotionMarker8.blendableVariation / 2f);
								}
							}
							if (emotionMarker8.blendFromMarker)
							{
								EmotionMarker emotionMarker = emotionMarkers[emotionMarkers.IndexOf(emotionMarker8) - 1];
								EmotionShape emotionShape2 = null;
								emotionShape2 = ((!emotionMarker.isMixer) ? emotionCache[emotionMarker.emotion] : emotionMarker.mixer.GetShape(this));
								if (emotionShape2.blendShapes.Contains(list5[num5]))
								{
									value = emotionShape2.weights[emotionShape2.blendShapes.IndexOf(list5[num5])] * emotionMarker.intensity;
								}
							}
							if (emotionMarker8.blendToMarker)
							{
								EmotionMarker emotionMarker2 = emotionMarkers[emotionMarkers.IndexOf(emotionMarker8) + 1];
								EmotionShape emotionShape3 = null;
								emotionShape3 = ((!emotionMarker2.isMixer) ? emotionCache[emotionMarker2.emotion] : emotionMarker2.mixer.GetShape(this));
								if (emotionShape3.blendShapes.Contains(list5[num5]))
								{
									value2 = emotionShape3.weights[emotionShape3.blendShapes.IndexOf(list5[num5])] * emotionMarker2.intensity;
								}
							}
							if (emotionCurveGenerationMode == CurveGenerationMode.Tight)
							{
								list6[num5].AddKey(new Keyframe(emotionMarker8.startTime, value, 0f, 0f));
								for (int num7 = 0; num7 < num3; num7++)
								{
									float time = Mathf.Lerp(emotionMarker8.startTime + emotionMarker8.blendInTime, emotionMarker8.endTime + emotionMarker8.blendOutTime, (float)num7 / (float)(num3 - 1));
									list6[num5].AddKey(new Keyframe(time, emotionShape.weights[index] * emotionMarker8.intensity * array[num7] * array2[num7], 0f, 0f));
								}
								list6[num5].AddKey(new Keyframe(emotionMarker8.endTime, value2, 0f, 0f));
							}
							else if (emotionCurveGenerationMode == CurveGenerationMode.Loose)
							{
								list6[num5].AddKey(emotionMarker8.startTime, value);
								for (int num8 = 0; num8 < num3; num8++)
								{
									float time2 = Mathf.Lerp(emotionMarker8.startTime + emotionMarker8.blendInTime, emotionMarker8.endTime + emotionMarker8.blendOutTime, (float)num8 / (float)(num3 - 1));
									list6[num5].AddKey(time2, emotionShape.weights[index] * emotionMarker8.intensity * array[num8] * array2[num8]);
								}
								list6[num5].AddKey(emotionMarker8.endTime, value2);
							}
							continue;
						}
						if (emotionCurveGenerationMode == CurveGenerationMode.Tight)
						{
							list6[num5].AddKey(new Keyframe(emotionMarker8.startTime + emotionMarker8.blendInTime, 0f, 0f, 0f));
							list6[num5].AddKey(new Keyframe(emotionMarker8.endTime + emotionMarker8.blendOutTime, 0f, 0f, 0f));
						}
						else if (emotionCurveGenerationMode == CurveGenerationMode.Loose)
						{
							list6[num5].AddKey(emotionMarker8.startTime + emotionMarker8.blendInTime, 0f);
							list6[num5].AddKey(emotionMarker8.endTime + emotionMarker8.blendOutTime, 0f);
						}
						if (!emotionMarker8.blendToMarker)
						{
							continue;
						}
						EmotionMarker emotionMarker3 = emotionMarkers[emotionMarkers.IndexOf(emotionMarker8) + 1];
						EmotionShape emotionShape4 = null;
						emotionShape4 = ((!emotionMarker3.isMixer) ? emotionCache[emotionMarker3.emotion] : emotionMarker3.mixer.GetShape(this));
						if (emotionShape4.blendShapes.Contains(list5[num5]))
						{
							if (emotionCurveGenerationMode == CurveGenerationMode.Tight)
							{
								list6[num5].AddKey(new Keyframe(emotionMarker8.endTime, emotionShape4.weights[emotionShape4.blendShapes.IndexOf(list5[num5])] * emotionMarker3.intensity, 0f, 0f));
							}
							else if (emotionCurveGenerationMode == CurveGenerationMode.Loose)
							{
								list6[num5].AddKey(emotionMarker8.endTime, emotionShape4.weights[emotionShape4.blendShapes.IndexOf(list5[num5])] * emotionMarker3.intensity);
							}
						}
					}
					if (!useBones || boneCurves == null)
					{
						continue;
					}
					for (int num9 = 0; num9 < list2.Count; num9++)
					{
						if (emotionShape.HasBone(list[num9]))
						{
							int index2 = emotionShape.IndexOfBone(list[num9]);
							if (emotionMarker8.continuousVariation)
							{
								for (int num10 = 0; num10 < num3; num10++)
								{
									array3[num10] = UnityEngine.Random.Range(1f - emotionMarker8.bonePositionVariation / 2f, 1f + emotionMarker8.bonePositionVariation / 2f);
									array4[num10] = UnityEngine.Random.Range(1f - emotionMarker8.boneRotationVariation / 2f, 1f + emotionMarker8.boneRotationVariation / 2f);
								}
							}
							Vector3 vector = emotionShape.bones[index2].neutralPosition;
							Quaternion quaternion = Quaternion.Euler(emotionShape.bones[index2].neutralRotation);
							Vector3 vector2 = emotionShape.bones[index2].neutralScale;
							Vector3 vector3 = emotionShape.bones[index2].neutralPosition;
							Quaternion quaternion2 = Quaternion.Euler(emotionShape.bones[index2].neutralRotation);
							Vector3 vector4 = emotionShape.bones[index2].neutralScale;
							if (emotionMarker8.blendFromMarker)
							{
								EmotionMarker emotionMarker4 = emotionMarkers[emotionMarkers.IndexOf(emotionMarker8) - 1];
								EmotionShape emotionShape5 = null;
								emotionShape5 = ((!emotionMarker4.isMixer) ? emotionCache[emotionMarker4.emotion] : emotionMarker4.mixer.GetShape(this));
								if (emotionShape5.HasBone(list[num9]))
								{
									vector = Vector3.Lerp(vector, emotionShape5.bones[emotionShape5.IndexOfBone(list[num9])].endPosition, emotionMarker4.intensity);
									quaternion = Quaternion.Slerp(quaternion, Quaternion.Euler(emotionShape5.bones[emotionShape5.IndexOfBone(list[num9])].endRotation), emotionMarker4.intensity);
									vector2 = Vector3.Lerp(vector2, emotionShape5.bones[emotionShape5.IndexOfBone(list[num9])].endScale, emotionMarker4.intensity);
								}
							}
							if (emotionMarker8.blendToMarker)
							{
								EmotionMarker emotionMarker5 = emotionMarkers[emotionMarkers.IndexOf(emotionMarker8) + 1];
								EmotionShape emotionShape6 = null;
								emotionShape6 = ((!emotionMarker5.isMixer) ? emotionCache[emotionMarker5.emotion] : emotionMarker5.mixer.GetShape(this));
								if (emotionShape6.HasBone(list[num9]))
								{
									vector3 = Vector3.Lerp(vector3, emotionShape6.bones[emotionShape6.IndexOfBone(list[num9])].endPosition, emotionMarker5.intensity);
									quaternion2 = Quaternion.Slerp(quaternion2, Quaternion.Euler(emotionShape6.bones[emotionShape6.IndexOfBone(list[num9])].endRotation), emotionMarker5.intensity);
									vector4 = Vector3.Lerp(vector4, emotionShape6.bones[emotionShape6.IndexOfBone(list[num9])].endScale, emotionMarker5.intensity);
								}
							}
							list2[num9].AddKey(emotionMarker8.startTime, vector, quaternion, vector2, 0f, 0f);
							for (int num11 = 0; num11 < num3; num11++)
							{
								float time3 = Mathf.Lerp(emotionMarker8.startTime + emotionMarker8.blendInTime, emotionMarker8.endTime + emotionMarker8.blendOutTime, (float)num11 / (float)(num3 - 1));
								list2[num9].AddKey(time3, Vector3.Lerp(emotionShape.bones[index2].neutralPosition, emotionShape.bones[index2].endPosition * array3[num11], emotionMarker8.intensity * array[num11]), Quaternion.Slerp(Quaternion.Euler(emotionShape.bones[index2].neutralRotation), Quaternion.Euler(emotionShape.bones[index2].endRotation * array4[num11]), emotionMarker8.intensity * array[num11]), Vector3.Lerp(emotionShape.bones[index2].neutralScale, emotionShape.bones[index2].endScale, emotionMarker8.intensity * array[num11]), 0f, 0f);
							}
							list2[num9].AddKey(emotionMarker8.endTime, vector3, quaternion2, vector4, 0f, 0f);
							continue;
						}
						list2[num9].AddKey(emotionMarker8.startTime + emotionMarker8.blendInTime, boneNeutralPositions[bones.IndexOf(list[num9])], boneNeutralRotations[bones.IndexOf(list[num9])], boneNeutralScales[bones.IndexOf(list[num9])], 0f, 0f);
						list2[num9].AddKey(emotionMarker8.endTime + emotionMarker8.blendOutTime, boneNeutralPositions[bones.IndexOf(list[num9])], boneNeutralRotations[bones.IndexOf(list[num9])], boneNeutralScales[bones.IndexOf(list[num9])], 0f, 0f);
						if (emotionMarker8.blendToMarker)
						{
							EmotionMarker emotionMarker6 = emotionMarkers[emotionMarkers.IndexOf(emotionMarker8) + 1];
							EmotionShape emotionShape7 = null;
							emotionShape7 = ((!emotionMarker6.isMixer) ? emotionCache[emotionMarker6.emotion] : emotionMarker6.mixer.GetShape(this));
							if (emotionShape7.HasBone(list[num9]))
							{
								BoneShape boneShape = emotionShape7.bones[emotionShape7.IndexOfBone(list[num9])];
								list2[num9].AddKey(emotionMarker8.endTime, Vector3.Lerp(boneShape.neutralPosition, boneShape.endPosition, emotionMarker6.intensity), Quaternion.Slerp(Quaternion.Euler(boneShape.neutralRotation), Quaternion.Euler(boneShape.endRotation), emotionMarker6.intensity), Vector3.Lerp(boneShape.neutralScale, boneShape.endScale, emotionMarker6.intensity), 0f, 0f);
							}
						}
					}
				}
				if (!emotionOnly)
				{
					for (int num12 = 0; num12 < phonemeMarkers.Count; num12++)
					{
						PhonemeMarker phonemeMarker = phonemeMarkers[num12];
						PhonemeShape phonemeShape2 = phonemes[phonemeMarker.phonemeNumber];
						float num13 = 1f;
						float num14 = 1f;
						float num15 = 1f;
						float num16 = 1f;
						if (phonemeMarker.useRandomness)
						{
							num13 = UnityEngine.Random.Range(1f - phonemeMarker.intensityRandomness / 2f, 1f + phonemeMarker.intensityRandomness / 2f);
						}
						bool flag = false;
						if (!phonemeMarker.sustain)
						{
							if (num12 + 1 < phonemeMarkers.Count)
							{
								if (phonemeMarkers[num12 + 1].time > phonemeMarker.time + restTime / fileLength + restHoldTime / fileLength)
								{
									flag = true;
								}
							}
							else
							{
								flag = true;
							}
						}
						for (int num17 = 0; num17 < list8.Count; num17++)
						{
							if (phonemeShape2.blendShapes.Contains(list7[num17]))
							{
								int index3 = phonemeShape2.blendShapes.IndexOf(list7[num17]);
								if (phonemeMarker.useRandomness)
								{
									num14 = UnityEngine.Random.Range(1f - phonemeMarker.blendableRandomness / 2f, 1f + phonemeMarker.blendableRandomness / 2f);
								}
								if (phonemeCurveGenerationMode == CurveGenerationMode.Tight)
								{
									list8[num17].AddKey(new Keyframe(phonemeMarker.time, phonemeShape2.weights[index3] * phonemeMarker.intensity * num13 * num14, 0f, 0f));
									if (num12 == 0)
									{
										list8[num17].AddKey(new Keyframe(phonemeMarkers[num12].time - restHoldTime / fileLength, dictionary[list7[num17]], 0f, 0f));
									}
									if (flag)
									{
										list8[num17].AddKey(new Keyframe(phonemeMarker.time + restHoldTime / fileLength, phonemeShape2.weights[index3] * phonemeMarker.intensity * num13 * num14, 0f, 0f));
										list8[num17].AddKey(new Keyframe(phonemeMarker.time + restHoldTime / fileLength * 2f, dictionary[list7[num17]], 0f, 0f));
										if (num12 + 1 < phonemeMarkers.Count)
										{
											list8[num17].AddKey(new Keyframe(phonemeMarkers[num12 + 1].time - restHoldTime / fileLength, dictionary[list7[num17]], 0f, 0f));
										}
									}
								}
								else
								{
									if (phonemeCurveGenerationMode != CurveGenerationMode.Loose)
									{
										continue;
									}
									list8[num17].AddKey(phonemeMarker.time, phonemeShape2.weights[index3] * phonemeMarker.intensity);
									if (num12 == 0)
									{
										list8[num17].AddKey(phonemeMarkers[num12].time - restHoldTime / fileLength, dictionary[list7[num17]]);
									}
									if (flag)
									{
										list8[num17].AddKey(phonemeMarker.time + restHoldTime / fileLength, phonemeShape2.weights[index3] * phonemeMarker.intensity * num13 * num14);
										list8[num17].AddKey(phonemeMarker.time + restHoldTime / fileLength * 2f, dictionary[list7[num17]]);
										if (num12 + 1 < phonemeMarkers.Count)
										{
											list8[num17].AddKey(phonemeMarkers[num12 + 1].time - restHoldTime / fileLength, dictionary[list7[num17]]);
										}
									}
								}
								continue;
							}
							if (phonemeCurveGenerationMode == CurveGenerationMode.Tight)
							{
								list8[num17].AddKey(new Keyframe(phonemeMarker.time, dictionary[list7[num17]], 0f, 0f));
							}
							else if (phonemeCurveGenerationMode == CurveGenerationMode.Loose)
							{
								list8[num17].AddKey(phonemeMarker.time, dictionary[list7[num17]]);
							}
							if (flag && num12 + 1 < phonemeMarkers.Count)
							{
								if (phonemeCurveGenerationMode == CurveGenerationMode.Tight)
								{
									list8[num17].AddKey(new Keyframe(phonemeMarkers[num12 + 1].time - restHoldTime / fileLength, dictionary[list7[num17]], 0f, 0f));
								}
								else if (phonemeCurveGenerationMode == CurveGenerationMode.Loose)
								{
									list8[num17].AddKey(phonemeMarkers[num12 + 1].time - restHoldTime / fileLength, dictionary[list7[num17]]);
								}
							}
						}
						if (!useBones || boneCurves == null)
						{
							continue;
						}
						for (int num18 = 0; num18 < list4.Count; num18++)
						{
							if (phonemeShape2.HasBone(bones[num18]))
							{
								int index4 = phonemeShape2.IndexOfBone(bones[num18]);
								if (phonemeMarker.useRandomness)
								{
									num15 = UnityEngine.Random.Range(1f - phonemeMarker.bonePositionRandomness / 2f, 1f + phonemeMarker.bonePositionRandomness / 2f);
									num16 = UnityEngine.Random.Range(1f - phonemeMarker.boneRotationRandomness / 2f, 1f + phonemeMarker.boneRotationRandomness / 2f);
								}
								list4[num18].AddKey(phonemeMarker.time, Vector3.Lerp(phonemeShape2.bones[index4].neutralPosition, phonemeShape2.bones[index4].endPosition * num15, phonemeMarker.intensity * num13), Quaternion.Slerp(Quaternion.Euler(phonemeShape2.bones[index4].neutralRotation), Quaternion.Euler(phonemeShape2.bones[index4].endRotation * num16), phonemeMarker.intensity), Vector3.Lerp(phonemeShape2.bones[index4].neutralScale, phonemeShape2.bones[index4].endScale, phonemeMarker.intensity * num13), 0f, 0f);
								if (num12 == 0)
								{
									list4[num18].AddKey(phonemeMarkers[num12].time - restHoldTime / fileLength, boneNeutralPositions[num18], boneNeutralRotations[num18], boneNeutralScales[num18], 0f, 0f);
								}
								if (flag)
								{
									list4[num18].AddKey(phonemeMarker.time + restHoldTime / fileLength, boneNeutralPositions[num18], boneNeutralRotations[num18], boneNeutralScales[num18], 0f, 0f);
									if (num12 + 1 < phonemeMarkers.Count)
									{
										list4[num18].AddKey(phonemeMarkers[num12 + 1].time - restHoldTime / fileLength, boneNeutralPositions[num18], boneNeutralRotations[num18], boneNeutralScales[num18], 0f, 0f);
									}
								}
							}
							else
							{
								list4[num18].AddKey(phonemeMarker.time, boneNeutralPositions[num18], boneNeutralRotations[num18], boneNeutralScales[num18], 0f, 0f);
								if (flag && num12 + 1 < phonemeMarkers.Count)
								{
									list4[num18].AddKey(phonemeMarkers[num12 + 1].time - restHoldTime / fileLength, boneNeutralPositions[num18], boneNeutralRotations[num18], boneNeutralScales[num18], 0f, 0f);
								}
							}
						}
					}
				}
				for (int num19 = 0; num19 < animCurves.Count; num19++)
				{
					if (list7.Contains(indexBlendables[num19]) && list5.Contains(indexBlendables[num19]))
					{
						int index5 = list7.IndexOf(indexBlendables[num19]);
						int index6 = list5.IndexOf(indexBlendables[num19]);
						for (int num20 = 0; num20 < list8[index5].keys.Length; num20++)
						{
							Keyframe key = list8[index5].keys[num20];
							animCurves[num19].AddKey(key);
						}
						for (int num21 = 0; num21 < list6[index6].keys.Length; num21++)
						{
							Keyframe key2 = list6[index6].keys[num21];
							animCurves[num19].AddKey(key2);
						}
					}
					else if (list7.Contains(indexBlendables[num19]))
					{
						int index7 = list7.IndexOf(indexBlendables[num19]);
						for (int num22 = 0; num22 < list8[index7].keys.Length; num22++)
						{
							Keyframe key3 = list8[index7].keys[num22];
							animCurves[num19].AddKey(key3);
						}
					}
					else
					{
						int index8 = list5.IndexOf(indexBlendables[num19]);
						for (int num23 = 0; num23 < list6[index8].keys.Length; num23++)
						{
							Keyframe key4 = list6[index8].keys[num23];
							animCurves[num19].AddKey(key4);
						}
					}
				}
				if (useBones && boneCurves != null)
				{
					for (int num24 = 0; num24 < boneCurves.Count; num24++)
					{
						if (list3.Contains(bones[num24]) && list.Contains(bones[num24]))
						{
							int index9 = list3.IndexOf(bones[num24]);
							int index10 = list.IndexOf(bones[num24]);
							TransformAnimationCurve.TransformKeyframe[] keys = list4[index9].keys;
							for (int num25 = 0; num25 < keys.Length; num25++)
							{
								TransformAnimationCurve.TransformKeyframe transformKeyframe = keys[num25];
								boneCurves[num24].AddKey(transformKeyframe.time, transformKeyframe.position, transformKeyframe.rotation, transformKeyframe.scale, 0f, 0f);
							}
							keys = list2[index10].keys;
							for (int num25 = 0; num25 < keys.Length; num25++)
							{
								TransformAnimationCurve.TransformKeyframe transformKeyframe2 = keys[num25];
								boneCurves[num24].AddKey(transformKeyframe2.time, transformKeyframe2.position, transformKeyframe2.rotation, transformKeyframe2.scale, 0f, 0f);
							}
						}
						else if (list3.Contains(bones[num24]))
						{
							int index11 = list3.IndexOf(bones[num24]);
							TransformAnimationCurve.TransformKeyframe[] keys = list4[index11].keys;
							for (int num25 = 0; num25 < keys.Length; num25++)
							{
								TransformAnimationCurve.TransformKeyframe transformKeyframe3 = keys[num25];
								boneCurves[num24].AddKey(transformKeyframe3.time, transformKeyframe3.position, transformKeyframe3.rotation, transformKeyframe3.scale, 0f, 0f);
							}
						}
						else
						{
							int index12 = list.IndexOf(bones[num24]);
							TransformAnimationCurve.TransformKeyframe[] keys = list2[index12].keys;
							for (int num25 = 0; num25 < keys.Length; num25++)
							{
								TransformAnimationCurve.TransformKeyframe transformKeyframe4 = keys[num25];
								boneCurves[num24].AddKey(transformKeyframe4.time, transformKeyframe4.position, transformKeyframe4.rotation, transformKeyframe4.scale, 0f, 0f);
							}
						}
					}
					foreach (TransformAnimationCurve boneCurf in boneCurves)
					{
						boneCurf.FixQuaternionContinuity();
					}
				}
			}
			if (!emotionOnly && customEmotion > -1)
			{
				ClearDataCache();
				customEmotion = -1;
			}
		}

		public void GetCurveDataOut(out List<int> indexBlendables, out List<AnimationCurve> animCurves, out List<Transform> bones, out List<TransformAnimationCurve> boneCurves, out List<Vector3> boneNeutralPositions, out List<Quaternion> boneNeutralRotations, out List<Vector3> boneNeutralScales)
		{
			indexBlendables = this.indexBlendables;
			animCurves = this.animCurves;
			bones = this.bones;
			boneCurves = this.boneCurves;
			boneNeutralPositions = this.boneNeutralPositions;
			boneNeutralRotations = this.boneNeutralRotations;
			boneNeutralScales = this.boneNeutralScales;
		}

		public void ClearDataCache()
		{
			currentFileID = 0;
		}

		private EmotionMixer GetTransitionMixer(string oldEmotion, string newEmotion, float t)
		{
			return new EmotionMixer
			{
				mixingMode = EmotionMixer.MixingMode.Additive,
				emotions = 
				{
					new EmotionMixer.EmotionComponent(oldEmotion, 1f - t),
					new EmotionMixer.EmotionComponent(newEmotion, t)
				}
			};
		}

		private void FixEmotionBlends(ref List<EmotionMarker> data)
		{
			EmotionMarker[] data2 = data.ToArray();
			FixEmotionBlends(ref data2);
			data.Clear();
			EmotionMarker[] array = data2;
			foreach (EmotionMarker item in array)
			{
				data.Add(item);
			}
		}

		private void FixEmotionBlends(ref EmotionMarker[] data)
		{
			EmotionMarker[] array = data;
			foreach (EmotionMarker emotionMarker in array)
			{
				emotionMarker.blendFromMarker = false;
				emotionMarker.blendToMarker = false;
				if (!emotionMarker.customBlendIn)
				{
					emotionMarker.blendInTime = 0f;
				}
				if (!emotionMarker.customBlendOut)
				{
					emotionMarker.blendOutTime = 0f;
				}
				emotionMarker.invalid = false;
			}
			array = data;
			foreach (EmotionMarker emotionMarker2 in array)
			{
				EmotionMarker[] array2 = data;
				foreach (EmotionMarker emotionMarker3 in array2)
				{
					if (emotionMarker2 == emotionMarker3)
					{
						continue;
					}
					if (emotionMarker2.startTime > emotionMarker3.startTime && emotionMarker2.startTime < emotionMarker3.endTime)
					{
						if (emotionMarker2.customBlendIn)
						{
							emotionMarker2.customBlendIn = false;
							FixEmotionBlends(ref data);
							return;
						}
						emotionMarker2.blendFromMarker = true;
						if (emotionMarker2.endTime > emotionMarker3.startTime && emotionMarker2.endTime < emotionMarker3.endTime)
						{
							emotionMarker2.invalid = true;
						}
						else
						{
							emotionMarker2.blendInTime = emotionMarker3.endTime - emotionMarker2.startTime;
						}
					}
					if (emotionMarker2.endTime > emotionMarker3.startTime && emotionMarker2.endTime < emotionMarker3.endTime)
					{
						if (emotionMarker2.customBlendOut)
						{
							emotionMarker2.customBlendOut = false;
							FixEmotionBlends(ref data);
							return;
						}
						emotionMarker2.blendToMarker = true;
						if (emotionMarker2.startTime > emotionMarker3.startTime && emotionMarker2.startTime < emotionMarker3.endTime)
						{
							emotionMarker2.invalid = true;
						}
						else
						{
							emotionMarker2.blendOutTime = emotionMarker3.startTime - emotionMarker2.endTime;
						}
					}
				}
			}
		}

		private void LoadXML(TextAsset xmlFile, AudioClip linkedClip)
		{
			XmlDocument xmlDocument = new XmlDocument();
			xmlDocument.LoadXml(xmlFile.text);
			phonemeMarkers = new List<PhonemeMarker>();
			emotionMarkers = new List<EmotionMarker>();
			gestureMarkers = new List<GestureMarker>();
			audioClip = linkedClip;
			audioSource.clip = audioClip;
			if (float.Parse(ReadXML(xmlDocument, "LipSyncData", "version")) < 1.321f)
			{
				UnityEngine.Debug.LogError("Cannot load pre-1.321 XML file. Run the converter from Window/Rogo Digital/LipSync Pro/Update XML files.");
				return;
			}
			try
			{
				fileLength = float.Parse(ReadXML(xmlDocument, "LipSyncData", "length"));
				XmlNode xmlNode = xmlDocument.SelectSingleNode("//LipSyncData//phonemes");
				if (xmlNode != null)
				{
					XmlNodeList childNodes = xmlNode.ChildNodes;
					for (int i = 0; i < childNodes.Count; i++)
					{
						XmlNode xmlNode2 = childNodes[i];
						if (xmlNode2.LocalName == "marker")
						{
							int phonemeNumber = int.Parse(xmlNode2.Attributes["phonemeNumber"].Value);
							float time = float.Parse(xmlNode2.Attributes["time"].Value) / fileLength;
							float intensity = float.Parse(xmlNode2.Attributes["intensity"].Value);
							bool sustain = bool.Parse(xmlNode2.Attributes["sustain"].Value);
							phonemeMarkers.Add(new PhonemeMarker(phonemeNumber, time, intensity, sustain));
						}
					}
				}
				XmlNode xmlNode3 = xmlDocument.SelectSingleNode("//LipSyncData//emotions");
				if (xmlNode3 != null)
				{
					XmlNodeList childNodes2 = xmlNode3.ChildNodes;
					for (int j = 0; j < childNodes2.Count; j++)
					{
						XmlNode xmlNode4 = childNodes2[j];
						if (xmlNode4.LocalName == "marker")
						{
							string value = xmlNode4.Attributes["emotion"].Value;
							float startTime = float.Parse(xmlNode4.Attributes["start"].Value) / fileLength;
							float endTime = float.Parse(xmlNode4.Attributes["end"].Value) / fileLength;
							float blendInTime = float.Parse(xmlNode4.Attributes["blendIn"].Value);
							float blendOutTime = float.Parse(xmlNode4.Attributes["blendOut"].Value);
							bool blendToMarker = bool.Parse(xmlNode4.Attributes["blendToMarker"].Value);
							bool blendFromMarker = bool.Parse(xmlNode4.Attributes["blendFromMarker"].Value);
							bool customBlendIn = bool.Parse(xmlNode4.Attributes["customBlendIn"].Value);
							bool customBlendOut = bool.Parse(xmlNode4.Attributes["customBlendOut"].Value);
							float intensity2 = float.Parse(xmlNode4.Attributes["intensity"].Value);
							emotionMarkers.Add(new EmotionMarker(value, startTime, endTime, blendInTime, blendOutTime, blendToMarker, blendFromMarker, customBlendIn, customBlendOut, intensity2));
						}
					}
				}
				XmlNode xmlNode5 = xmlDocument.SelectSingleNode("//LipSyncData//gestures");
				if (xmlNode5 != null)
				{
					XmlNodeList childNodes3 = xmlNode5.ChildNodes;
					for (int k = 0; k < childNodes3.Count; k++)
					{
						XmlNode xmlNode6 = childNodes3[k];
						if (xmlNode6.LocalName == "marker")
						{
							string value2 = xmlNode6.Attributes["gesture"].Value;
							float time2 = float.Parse(xmlNode6.Attributes["time"].Value) / fileLength;
							gestureMarkers.Add(new GestureMarker(value2, time2));
						}
					}
				}
			}
			catch
			{
				UnityEngine.Debug.LogError("[LipSync - " + base.gameObject.name + "] Malformed XML file. See console for details. \nFor the sake of simplicity, LipSync Pro is unable to handle errors in XML files. The clip editor often can, however. Import this XML file into the clip editor and re-export to fix.");
			}
			phonemeMarkers.Sort(SortTime);
			gestureMarkers.Sort(SortTime);
		}

		private bool LoadData(LipSyncData dataFile)
		{
			if (dataFile.phonemeData.Length != 0 || dataFile.emotionData.Length != 0 || dataFile.gestureData.Length != 0)
			{
				audioClip = dataFile.clip;
				fileLength = dataFile.length;
				bool flag = false;
				if (dataFile.version < 1f)
				{
					flag = true;
					for (int i = 0; i < dataFile.emotionData.Length; i++)
					{
						if (dataFile.emotionData[i].blendFromMarker)
						{
							dataFile.emotionData[i].startTime -= dataFile.emotionData[i].blendInTime;
							dataFile.emotionData[i - 1].endTime += dataFile.emotionData[i].blendInTime;
						}
						else
						{
							dataFile.emotionData[i].customBlendIn = true;
						}
						if (dataFile.emotionData[i].blendToMarker)
						{
							dataFile.emotionData[i + 1].startTime -= dataFile.emotionData[i].blendOutTime;
							dataFile.emotionData[i].endTime += dataFile.emotionData[i].blendOutTime;
						}
						else
						{
							dataFile.emotionData[i].customBlendOut = true;
							dataFile.emotionData[i].blendOutTime = 0f - dataFile.emotionData[i].blendOutTime;
						}
					}
					FixEmotionBlends(ref dataFile.emotionData);
					if (dataFile.length == 0f)
					{
						fileLength = audioClip.length;
					}
				}
				if (dataFile.version < 1.3f)
				{
					flag = true;
					for (int j = 0; j < dataFile.phonemeData.Length; j++)
					{
						dataFile.phonemeData[j].phonemeNumber = (int)dataFile.phonemeData[j].phoneme;
					}
				}
				if (flag)
				{
					UnityEngine.Debug.LogWarning("[LipSync - " + base.gameObject.name + "] Loading data from an old format LipSyncData file. For better performance, open this clip in the Clip Editor and re-save to update.");
				}
				phonemeMarkers = new List<PhonemeMarker>();
				emotionMarkers = new List<EmotionMarker>();
				gestureMarkers = new List<GestureMarker>();
				PhonemeMarker[] phonemeData = dataFile.phonemeData;
				foreach (PhonemeMarker item in phonemeData)
				{
					phonemeMarkers.Add(item);
				}
				EmotionMarker[] emotionData = dataFile.emotionData;
				foreach (EmotionMarker item2 in emotionData)
				{
					emotionMarkers.Add(item2);
				}
				GestureMarker[] gestureData = dataFile.gestureData;
				foreach (GestureMarker item3 in gestureData)
				{
					gestureMarkers.Add(item3);
				}
				emotionMarkers.Sort(EmotionSort);
				phonemeMarkers.Sort(SortTime);
				gestureMarkers.Sort(SortTime);
				audioSource.clip = audioClip;
				currentFileID = dataFile.GetInstanceID();
				lastClip = dataFile;
				return true;
			}
			return false;
		}

		private IEnumerator StopAudioSource(float delay)
		{
			yield return new WaitForSeconds(delay);
			audioSource.Stop();
		}

		private GestureInstance GetGesture(string name)
		{
			for (int i = 0; i < gestures.Count; i++)
			{
				if (gestures[i].gesture == name)
				{
					return gestures[i];
				}
			}
			return null;
		}

		public LipSync()
		{
			lastUsedVersion = 1.51f;
		}

		public static int SortTime(PhonemeMarker a, PhonemeMarker b)
		{
			float time = a.time;
			float time2 = b.time;
			return time.CompareTo(time2);
		}

		public static int SortTime(GestureMarker a, GestureMarker b)
		{
			float time = a.time;
			float time2 = b.time;
			return time.CompareTo(time2);
		}

		private static int EmotionSort(EmotionMarker a, EmotionMarker b)
		{
			return a.startTime.CompareTo(b.startTime);
		}

		public static string ReadXML(XmlDocument xml, string parentElement, string elementName)
		{
			return xml.SelectSingleNode("//" + parentElement + "//" + elementName)?.InnerText;
		}
	}
	public enum Phoneme
	{
		AI,
		E,
		U,
		O,
		CDGKNRSThYZ,
		FV,
		L,
		MBP,
		WQ,
		Rest
	}
}
namespace OculusSampleFramework
{
	public class ColorGrabbable : OVRGrabbable
	{
		public static readonly Color COLOR_GRAB = new Color(1f, 0.5f, 0f, 1f);

		public static readonly Color COLOR_HIGHLIGHT = new Color(1f, 0f, 1f, 1f);

		private Color m_color = Color.black;

		private MeshRenderer[] m_meshRenderers;

		private bool m_highlight;

		public bool Highlight
		{
			get
			{
				return m_highlight;
			}
			set
			{
				m_highlight = value;
				UpdateColor();
			}
		}

		protected void UpdateColor()
		{
			if (base.isGrabbed)
			{
				SetColor(COLOR_GRAB);
			}
			else if (Highlight)
			{
				SetColor(COLOR_HIGHLIGHT);
			}
			else
			{
				SetColor(m_color);
			}
		}

		public override void GrabBegin(OVRGrabber hand, Collider grabPoint)
		{
			base.GrabBegin(hand, grabPoint);
			UpdateColor();
		}

		public override void GrabEnd(Vector3 linearVelocity, Vector3 angularVelocity)
		{
			base.GrabEnd(linearVelocity, angularVelocity);
			UpdateColor();
		}

		private void Awake()
		{
			if (m_grabPoints.Length == 0)
			{
				Collider component = GetComponent<Collider>();
				if (component == null)
				{
					throw new ArgumentException("Grabbables cannot have zero grab points and no collider -- please add a grab point or collider.");
				}
				m_grabPoints = new Collider[1] { component };
				m_meshRenderers = new MeshRenderer[1];
				m_meshRenderers[0] = GetComponent<MeshRenderer>();
			}
			else
			{
				m_meshRenderers = GetComponentsInChildren<MeshRenderer>();
			}
			m_color = new Color(UnityEngine.Random.Range(0.1f, 0.95f), UnityEngine.Random.Range(0.1f, 0.95f), UnityEngine.Random.Range(0.1f, 0.95f), 1f);
			SetColor(m_color);
		}

		private void SetColor(Color color)
		{
			for (int i = 0; i < m_meshRenderers.Length; i++)
			{
				MeshRenderer meshRenderer = m_meshRenderers[i];
				for (int j = 0; j < meshRenderer.materials.Length; j++)
				{
					meshRenderer.materials[j].color = color;
				}
			}
		}
	}
	public class DistanceGrabbable : OVRGrabbable
	{
		public string m_materialColorField;

		private GrabbableCrosshair m_crosshair;

		private GrabManager m_crosshairManager;

		private Renderer m_renderer;

		private MaterialPropertyBlock m_mpb;

		private bool m_inRange;

		private bool m_targeted;

		public bool InRange
		{
			get
			{
				return m_inRange;
			}
			set
			{
				m_inRange = value;
				RefreshCrosshair();
			}
		}

		public bool Targeted
		{
			get
			{
				return m_targeted;
			}
			set
			{
				m_targeted = value;
				RefreshCrosshair();
			}
		}

		protected override void Start()
		{
			base.Start();
			m_crosshair = base.gameObject.GetComponentInChildren<GrabbableCrosshair>();
			m_renderer = base.gameObject.GetComponent<Renderer>();
			m_crosshairManager = UnityEngine.Object.FindObjectOfType<GrabManager>();
			m_mpb = new MaterialPropertyBlock();
			RefreshCrosshair();
			m_renderer.SetPropertyBlock(m_mpb);
		}

		private void RefreshCrosshair()
		{
			if ((bool)m_crosshair)
			{
				if (base.isGrabbed)
				{
					m_crosshair.SetState(GrabbableCrosshair.CrosshairState.Disabled);
				}
				else if (!InRange)
				{
					m_crosshair.SetState(GrabbableCrosshair.CrosshairState.Disabled);
				}
				else
				{
					m_crosshair.SetState((!Targeted) ? GrabbableCrosshair.CrosshairState.Enabled : GrabbableCrosshair.CrosshairState.Targeted);
				}
			}
			if (m_materialColorField != null)
			{
				m_renderer.GetPropertyBlock(m_mpb);
				if (base.isGrabbed || !InRange)
				{
					m_mpb.SetColor(m_materialColorField, m_crosshairManager.OutlineColorOutOfRange);
				}
				else if (Targeted)
				{
					m_mpb.SetColor(m_materialColorField, m_crosshairManager.OutlineColorHighlighted);
				}
				else
				{
					m_mpb.SetColor(m_materialColorField, m_crosshairManager.OutlineColorInRange);
				}
				m_renderer.SetPropertyBlock(m_mpb);
			}
		}
	}
	[RequireComponent(typeof(Rigidbody))]
	public class DistanceGrabber : OVRGrabber
	{
		[SerializeField]
		private float m_spherecastRadius;

		[SerializeField]
		private float m_noSnapThreshhold = 0.05f;

		[SerializeField]
		private bool m_useSpherecast;

		[SerializeField]
		public bool m_preventGrabThroughWalls;

		[SerializeField]
		private float m_objectPullVelocity = 10f;

		private float m_objectPullMaxRotationRate = 360f;

		private bool m_movingObjectToHand;

		[SerializeField]
		private float m_maxGrabDistance;

		[SerializeField]
		private int m_grabObjectsInLayer;

		[SerializeField]
		private int m_obstructionLayer;

		private DistanceGrabber m_otherHand;

		protected DistanceGrabbable m_target;

		protected Collider m_targetCollider;

		public bool UseSpherecast
		{
			get
			{
				return m_useSpherecast;
			}
			set
			{
				m_useSpherecast = value;
				GrabVolumeEnable(!m_useSpherecast);
			}
		}

		protected override void Start()
		{
			base.Start();
			Collider componentInChildren = m_player.GetComponentInChildren<Collider>();
			if (componentInChildren != null)
			{
				m_maxGrabDistance = componentInChildren.bounds.size.z * 0.5f + 3f;
			}
			else
			{
				m_maxGrabDistance = 12f;
			}
			if (m_parentHeldObject)
			{
				UnityEngine.Debug.LogError("m_parentHeldObject incompatible with DistanceGrabber. Setting to false.");
				m_parentHeldObject = false;
			}
			DistanceGrabber[] array = UnityEngine.Object.FindObjectsOfType<DistanceGrabber>();
			for (int i = 0; i < array.Length; i++)
			{
				if (array[i] != this)
				{
					m_otherHand = array[i];
				}
			}
		}

		public override void Update()
		{
			base.Update();
			UnityEngine.Debug.DrawRay(base.transform.position, base.transform.forward, Color.red, 0.1f);
			FindTarget(out var dgOut, out var collOut);
			if (dgOut != m_target)
			{
				if (m_target != null)
				{
					m_target.Targeted = m_otherHand.m_target == m_target;
				}
				m_target = dgOut;
				m_targetCollider = collOut;
				if (m_target != null)
				{
					m_target.Targeted = true;
				}
			}
		}

		protected override void GrabBegin()
		{
			DistanceGrabbable target = m_target;
			Collider targetCollider = m_targetCollider;
			GrabVolumeEnable(enabled: false);
			if (!(target != null))
			{
				return;
			}
			if (target.isGrabbed)
			{
				((DistanceGrabber)target.grabbedBy).OffhandGrabbed(target);
			}
			m_grabbedObj = target;
			m_grabbedObj.GrabBegin(this, targetCollider);
			SetPlayerIgnoreCollision(m_grabbedObj.gameObject, ignore: true);
			m_movingObjectToHand = true;
			m_lastPos = base.transform.position;
			m_lastRot = base.transform.rotation;
			Vector3 vector = targetCollider.ClosestPointOnBounds(m_gripTransform.position);
			if (!m_grabbedObj.snapPosition && !m_grabbedObj.snapOrientation && m_noSnapThreshhold > 0f && (vector - m_gripTransform.position).magnitude < m_noSnapThreshhold)
			{
				Vector3 vector2 = m_grabbedObj.transform.position - base.transform.position;
				m_movingObjectToHand = false;
				vector2 = Quaternion.Inverse(base.transform.rotation) * vector2;
				m_grabbedObjectPosOff = vector2;
				Quaternion grabbedObjectRotOff = Quaternion.Inverse(base.transform.rotation) * m_grabbedObj.transform.rotation;
				m_grabbedObjectRotOff = grabbedObjectRotOff;
				return;
			}
			m_grabbedObjectPosOff = m_gripTransform.localPosition;
			if ((bool)m_grabbedObj.snapOffset)
			{
				Vector3 position = m_grabbedObj.snapOffset.position;
				if (m_controller == OVRInput.Controller.LTouch)
				{
					position.x = 0f - position.x;
				}
				m_grabbedObjectPosOff += position;
			}
			m_grabbedObjectRotOff = m_gripTransform.localRotation;
			if ((bool)m_grabbedObj.snapOffset)
			{
				m_grabbedObjectRotOff = m_grabbedObj.snapOffset.rotation * m_grabbedObjectRotOff;
			}
		}

		protected override void MoveGrabbedObject(Vector3 pos, Quaternion rot, bool forceTeleport = false)
		{
			if (m_grabbedObj == null)
			{
				return;
			}
			Rigidbody grabbedRigidbody = m_grabbedObj.grabbedRigidbody;
			Vector3 vector = pos + rot * m_grabbedObjectPosOff;
			Quaternion quaternion = rot * m_grabbedObjectRotOff;
			if (m_movingObjectToHand)
			{
				float num = m_objectPullVelocity * Time.deltaTime;
				Vector3 vector2 = vector - m_grabbedObj.transform.position;
				if (num * num * 1.1f > vector2.sqrMagnitude)
				{
					m_movingObjectToHand = false;
				}
				else
				{
					vector2.Normalize();
					vector = m_grabbedObj.transform.position + vector2 * num;
					quaternion = Quaternion.RotateTowards(m_grabbedObj.transform.rotation, quaternion, m_objectPullMaxRotationRate * Time.deltaTime);
				}
			}
			grabbedRigidbody.MovePosition(vector);
			grabbedRigidbody.MoveRotation(quaternion);
		}

		private static DistanceGrabbable HitInfoToGrabbable(RaycastHit hitInfo)
		{
			if (hitInfo.collider != null)
			{
				GameObject gameObject = hitInfo.collider.gameObject;
				return gameObject.GetComponent<DistanceGrabbable>() ?? gameObject.GetComponentInParent<DistanceGrabbable>();
			}
			return null;
		}

		protected bool FindTarget(out DistanceGrabbable dgOut, out Collider collOut)
		{
			dgOut = null;
			collOut = null;
			float num = float.MaxValue;
			foreach (OVRGrabbable key in m_grabCandidates.Keys)
			{
				DistanceGrabbable distanceGrabbable = key as DistanceGrabbable;
				bool flag = distanceGrabbable != null && distanceGrabbable.InRange && (!distanceGrabbable.isGrabbed || distanceGrabbable.allowOffhandGrab);
				if (flag && m_grabObjectsInLayer >= 0)
				{
					flag = distanceGrabbable.gameObject.layer == m_grabObjectsInLayer;
				}
				if (!flag)
				{
					continue;
				}
				for (int i = 0; i < distanceGrabbable.grabPoints.Length; i++)
				{
					Collider collider = distanceGrabbable.grabPoints[i];
					Vector3 vector = collider.ClosestPointOnBounds(m_gripTransform.position);
					float sqrMagnitude = (m_gripTransform.position - vector).sqrMagnitude;
					if (!(sqrMagnitude < num))
					{
						continue;
					}
					bool flag2 = true;
					if (m_preventGrabThroughWalls)
					{
						Ray ray = default(Ray);
						ray.direction = distanceGrabbable.transform.position - m_gripTransform.position;
						ray.origin = m_gripTransform.position;
						UnityEngine.Debug.DrawRay(ray.origin, ray.direction, Color.red, 0.1f);
						if (Physics.Raycast(ray, out var hitInfo, m_maxGrabDistance, 1 << m_obstructionLayer, QueryTriggerInteraction.Ignore) && (double)(collider.ClosestPointOnBounds(m_gripTransform.position) - m_gripTransform.position).magnitude > (double)hitInfo.distance * 1.1)
						{
							flag2 = false;
						}
					}
					if (flag2)
					{
						num = sqrMagnitude;
						dgOut = distanceGrabbable;
						collOut = collider;
					}
				}
			}
			if (dgOut == null && m_useSpherecast)
			{
				return FindTargetWithSpherecast(out dgOut, out collOut);
			}
			return dgOut != null;
		}

		protected bool FindTargetWithSpherecast(out DistanceGrabbable dgOut, out Collider collOut)
		{
			dgOut = null;
			collOut = null;
			Ray ray = new Ray(m_gripTransform.position, m_gripTransform.forward);
			int layerMask = ((m_grabObjectsInLayer == -1) ? (-1) : (1 << m_grabObjectsInLayer));
			if (Physics.SphereCast(ray, m_spherecastRadius, out var hitInfo, m_maxGrabDistance, layerMask))
			{
				DistanceGrabbable distanceGrabbable = null;
				Collider collider = null;
				if (hitInfo.collider != null)
				{
					distanceGrabbable = hitInfo.collider.gameObject.GetComponentInParent<DistanceGrabbable>();
					collider = ((distanceGrabbable == null) ? null : hitInfo.collider);
					if ((bool)distanceGrabbable)
					{
						dgOut = distanceGrabbable;
						collOut = collider;
					}
				}
				if (distanceGrabbable != null && m_preventGrabThroughWalls)
				{
					ray.direction = hitInfo.point - m_gripTransform.position;
					dgOut = distanceGrabbable;
					collOut = collider;
					if (Physics.Raycast(ray, out var hitInfo2, m_maxGrabDistance, 1 << m_obstructionLayer, QueryTriggerInteraction.Ignore))
					{
						DistanceGrabbable distanceGrabbable2 = null;
						if (hitInfo.collider != null)
						{
							distanceGrabbable2 = hitInfo2.collider.gameObject.GetComponentInParent<DistanceGrabbable>();
						}
						if (distanceGrabbable2 != distanceGrabbable && hitInfo2.distance < hitInfo.distance)
						{
							dgOut = null;
							collOut = null;
						}
					}
				}
			}
			return dgOut != null;
		}

		protected override void GrabVolumeEnable(bool enabled)
		{
			if (m_useSpherecast)
			{
				enabled = false;
			}
			base.GrabVolumeEnable(enabled);
		}

		protected override void OffhandGrabbed(OVRGrabbable grabbable)
		{
			base.OffhandGrabbed(grabbable);
		}
	}
	public class GrabManager : MonoBehaviour
	{
		private Collider m_grabVolume;

		public Color OutlineColorInRange;

		public Color OutlineColorHighlighted;

		public Color OutlineColorOutOfRange;

		private void OnTriggerEnter(Collider otherCollider)
		{
			DistanceGrabbable componentInChildren = otherCollider.GetComponentInChildren<DistanceGrabbable>();
			if ((bool)componentInChildren)
			{
				componentInChildren.InRange = true;
			}
		}

		private void OnTriggerExit(Collider otherCollider)
		{
			DistanceGrabbable componentInChildren = otherCollider.GetComponentInChildren<DistanceGrabbable>();
			if ((bool)componentInChildren)
			{
				componentInChildren.InRange = false;
			}
		}
	}
	public class GrabbableCrosshair : MonoBehaviour
	{
		public enum CrosshairState
		{
			Disabled,
			Enabled,
			Targeted
		}

		private CrosshairState m_state;

		private Transform m_centerEyeAnchor;

		[SerializeField]
		private GameObject m_targetedCrosshair;

		[SerializeField]
		private GameObject m_enabledCrosshair;

		private void Start()
		{
			m_centerEyeAnchor = GameObject.Find("CenterEyeAnchor").transform;
		}

		public void SetState(CrosshairState cs)
		{
			m_state = cs;
			switch (cs)
			{
			case CrosshairState.Disabled:
				m_targetedCrosshair.SetActive(value: false);
				m_enabledCrosshair.SetActive(value: false);
				break;
			case CrosshairState.Enabled:
				m_targetedCrosshair.SetActive(value: false);
				m_enabledCrosshair.SetActive(value: true);
				break;
			case CrosshairState.Targeted:
				m_targetedCrosshair.SetActive(value: true);
				m_enabledCrosshair.SetActive(value: false);
				break;
			}
		}

		private void Update()
		{
			if (m_state != 0)
			{
				base.transform.LookAt(m_centerEyeAnchor);
			}
		}
	}
	public class PauseOnInputLoss : MonoBehaviour
	{
		private void Start()
		{
			OVRManager.InputFocusAcquired += OnInputFocusAcquired;
			OVRManager.InputFocusLost += OnInputFocusLost;
		}

		private void OnInputFocusLost()
		{
			Time.timeScale = 0f;
		}

		private void OnInputFocusAcquired()
		{
			Time.timeScale = 1f;
		}
	}
	public class BoneCapsuleTriggerLogic : MonoBehaviour
	{
		public InteractableToolTags ToolTags;

		public HashSet<ColliderZone> CollidersTouchingUs = new HashSet<ColliderZone>();

		private List<ColliderZone> _elementsToCleanUp = new List<ColliderZone>();

		private void OnDisable()
		{
			CollidersTouchingUs.Clear();
		}

		private void Update()
		{
			CleanUpDeadColliders();
		}

		private void OnTriggerEnter(Collider other)
		{
			ButtonTriggerZone component = other.GetComponent<ButtonTriggerZone>();
			if (component != null && ((uint)component.ParentInteractable.ValidToolTagsMask & (uint)ToolTags) != 0)
			{
				CollidersTouchingUs.Add(component);
			}
		}

		private void OnTriggerExit(Collider other)
		{
			ButtonTriggerZone component = other.GetComponent<ButtonTriggerZone>();
			if (component != null && ((uint)component.ParentInteractable.ValidToolTagsMask & (uint)ToolTags) != 0)
			{
				CollidersTouchingUs.Remove(component);
			}
		}

		private void CleanUpDeadColliders()
		{
			_elementsToCleanUp.Clear();
			foreach (ColliderZone collidersTouchingU in CollidersTouchingUs)
			{
				if (!collidersTouchingU.Collider.gameObject.activeInHierarchy)
				{
					_elementsToCleanUp.Add(collidersTouchingU);
				}
			}
			foreach (ColliderZone item in _elementsToCleanUp)
			{
				CollidersTouchingUs.Remove(item);
			}
		}
	}
	public class ButtonController : Interactable
	{
		public enum ContactTest
		{
			PerpenTest,
			BackwardsPress
		}

		private const float ENTRY_DOT_THRESHOLD = 0.8f;

		private const float PERP_DOT_THRESHOLD = 0.5f;

		[SerializeField]
		private GameObject _proximityZone;

		[SerializeField]
		private GameObject _contactZone;

		[SerializeField]
		private GameObject _actionZone;

		[SerializeField]
		private ContactTest[] _contactTests;

		[SerializeField]
		private Transform _buttonPlaneCenter;

		[SerializeField]
		private bool _makeSureToolIsOnPositiveSide = true;

		[SerializeField]
		private Vector3 _localButtonDirection = Vector3.down;

		[SerializeField]
		private InteractableToolTags[] _allValidToolsTags = new InteractableToolTags[1] { InteractableToolTags.All };

		private int _toolTagsMask;

		private InteractableState _currentButtonState;

		private Dictionary<InteractableTool, InteractableState> _toolToState = new Dictionary<InteractableTool, InteractableState>();

		public override int ValidToolTagsMask => _toolTagsMask;

		public Vector3 LocalButtonDirection => _localButtonDirection;

		protected override void Awake()
		{
			base.Awake();
			InteractableToolTags[] allValidToolsTags = _allValidToolsTags;
			foreach (InteractableToolTags interactableToolTags in allValidToolsTags)
			{
				_toolTagsMask |= (int)interactableToolTags;
			}
			_proximityZoneCollider = _proximityZone.GetComponent<ColliderZone>();
			_contactZoneCollider = _contactZone.GetComponent<ColliderZone>();
			_actionZoneCollider = _actionZone.GetComponent<ColliderZone>();
		}

		private void FireInteractionEventsOnDepth(InteractableCollisionDepth oldDepth, InteractableTool collidingTool, InteractionType interactionType)
		{
			switch (oldDepth)
			{
			case InteractableCollisionDepth.Action:
				OnActionZoneEvent(new ColliderZoneArgs(base.ActionCollider, Time.frameCount, collidingTool, interactionType));
				break;
			case InteractableCollisionDepth.Contact:
				OnContactZoneEvent(new ColliderZoneArgs(base.ContactCollider, Time.frameCount, collidingTool, interactionType));
				break;
			case InteractableCollisionDepth.Proximity:
				OnProximityZoneEvent(new ColliderZoneArgs(base.ProximityCollider, Time.frameCount, collidingTool, interactionType));
				break;
			}
		}

		public override void UpdateCollisionDepth(InteractableTool interactableTool, InteractableCollisionDepth oldCollisionDepth, InteractableCollisionDepth newCollisionDepth)
		{
			bool isFarFieldTool = interactableTool.IsFarFieldTool;
			if (!isFarFieldTool && _toolToState.Keys.Count > 0 && !_toolToState.ContainsKey(interactableTool))
			{
				return;
			}
			InteractableState currentButtonState = _currentButtonState;
			Vector3 vector = base.transform.TransformDirection(_localButtonDirection);
			bool validContact = IsValidContact(interactableTool, vector) || interactableTool.IsFarFieldTool;
			bool toolIsInProximity = newCollisionDepth >= InteractableCollisionDepth.Proximity;
			bool flag = newCollisionDepth == InteractableCollisionDepth.Contact;
			bool flag2 = newCollisionDepth == InteractableCollisionDepth.Action;
			bool flag3 = oldCollisionDepth != newCollisionDepth;
			if (flag3)
			{
				FireInteractionEventsOnDepth(oldCollisionDepth, interactableTool, InteractionType.Exit);
				FireInteractionEventsOnDepth(newCollisionDepth, interactableTool, InteractionType.Enter);
			}
			else
			{
				FireInteractionEventsOnDepth(newCollisionDepth, interactableTool, InteractionType.Stay);
			}
			InteractableState interactableState = currentButtonState;
			if (interactableTool.IsFarFieldTool)
			{
				interactableState = (flag ? InteractableState.ContactState : (flag2 ? InteractableState.ActionState : InteractableState.Default));
			}
			else
			{
				Plane plane = new Plane(-vector, _buttonPlaneCenter.position);
				bool onPositiveSideOfInteractable = !_makeSureToolIsOnPositiveSide || plane.GetSide(interactableTool.InteractionPosition);
				interactableState = GetUpcomingStateNearField(currentButtonState, newCollisionDepth, flag2, flag, toolIsInProximity, validContact, onPositiveSideOfInteractable);
			}
			if (interactableState != 0)
			{
				_toolToState[interactableTool] = interactableState;
			}
			else
			{
				_toolToState.Remove(interactableTool);
			}
			if (isFarFieldTool)
			{
				foreach (InteractableState value in _toolToState.Values)
				{
					if (interactableState < value)
					{
						interactableState = value;
					}
				}
			}
			if (currentButtonState != interactableState)
			{
				_currentButtonState = interactableState;
				InteractionType interactionType = ((!flag3) ? InteractionType.Stay : ((newCollisionDepth == InteractableCollisionDepth.None) ? InteractionType.Exit : InteractionType.Enter));
				ColliderZone collider = ((_currentButtonState == InteractableState.ProximityState) ? base.ProximityCollider : ((_currentButtonState == InteractableState.ContactState) ? base.ContactCollider : ((_currentButtonState == InteractableState.ActionState) ? base.ActionCollider : null)));
				if (InteractableStateChanged != null)
				{
					InteractableStateChanged.Invoke(new InteractableStateArgs(this, interactableTool, _currentButtonState, currentButtonState, new ColliderZoneArgs(collider, Time.frameCount, interactableTool, interactionType)));
				}
			}
		}

		private InteractableState GetUpcomingStateNearField(InteractableState oldState, InteractableCollisionDepth newCollisionDepth, bool toolIsInActionZone, bool toolIsInContactZone, bool toolIsInProximity, bool validContact, bool onPositiveSideOfInteractable)
		{
			InteractableState result = oldState;
			switch (oldState)
			{
			case InteractableState.ActionState:
				if (!toolIsInActionZone)
				{
					result = ((!toolIsInContactZone) ? (toolIsInProximity ? InteractableState.ProximityState : InteractableState.Default) : InteractableState.ContactState);
				}
				break;
			case InteractableState.ContactState:
				if (newCollisionDepth < InteractableCollisionDepth.Contact)
				{
					result = (toolIsInProximity ? InteractableState.ProximityState : InteractableState.Default);
				}
				else if (toolIsInActionZone && validContact && onPositiveSideOfInteractable)
				{
					result = InteractableState.ActionState;
				}
				break;
			case InteractableState.ProximityState:
				if (newCollisionDepth < InteractableCollisionDepth.Proximity)
				{
					result = InteractableState.Default;
				}
				else if (validContact && onPositiveSideOfInteractable && newCollisionDepth > InteractableCollisionDepth.Proximity)
				{
					result = ((newCollisionDepth == InteractableCollisionDepth.Action) ? InteractableState.ActionState : InteractableState.ContactState);
				}
				break;
			case InteractableState.Default:
				if (validContact && onPositiveSideOfInteractable && newCollisionDepth > InteractableCollisionDepth.Proximity)
				{
					result = ((newCollisionDepth == InteractableCollisionDepth.Action) ? InteractableState.ActionState : InteractableState.ContactState);
				}
				else if (toolIsInProximity)
				{
					result = InteractableState.ProximityState;
				}
				break;
			}
			return result;
		}

		private bool IsValidContact(InteractableTool collidingTool, Vector3 buttonDirection)
		{
			if (_contactTests == null || collidingTool.IsFarFieldTool)
			{
				return true;
			}
			ContactTest[] contactTests = _contactTests;
			for (int i = 0; i < contactTests.Length; i++)
			{
				if (contactTests[i] == ContactTest.BackwardsPress)
				{
					if (!PassEntryTest(collidingTool, buttonDirection))
					{
						return false;
					}
				}
				else if (!PassPerpTest(collidingTool, buttonDirection))
				{
					return false;
				}
			}
			return true;
		}

		private bool PassEntryTest(InteractableTool collidingTool, Vector3 buttonDirection)
		{
			if (Vector3.Dot(collidingTool.Velocity.normalized, buttonDirection) < 0.8f)
			{
				return false;
			}
			return true;
		}

		private bool PassPerpTest(InteractableTool collidingTool, Vector3 buttonDirection)
		{
			Vector3 vector = collidingTool.ToolTransform.right;
			if (collidingTool.IsRightHandedTool)
			{
				vector = -vector;
			}
			if (Vector3.Dot(vector, buttonDirection) < 0.5f)
			{
				return false;
			}
			return true;
		}
	}
	public class ButtonTriggerZone : MonoBehaviour, ColliderZone
	{
		[SerializeField]
		private GameObject _parentInteractableObj;

		public Collider Collider { get; private set; }

		public Interactable ParentInteractable { get; private set; }

		public InteractableCollisionDepth CollisionDepth
		{
			get
			{
				if (ParentInteractable.ProximityCollider != this)
				{
					if (ParentInteractable.ContactCollider != this)
					{
						if (ParentInteractable.ActionCollider != this)
						{
							return InteractableCollisionDepth.None;
						}
						return InteractableCollisionDepth.Action;
					}
					return InteractableCollisionDepth.Contact;
				}
				return InteractableCollisionDepth.Proximity;
			}
		}

		private void Awake()
		{
			Collider = GetComponent<Collider>();
			ParentInteractable = _parentInteractableObj.GetComponent<Interactable>();
		}
	}
	public interface ColliderZone
	{
		Collider Collider { get; }

		Interactable ParentInteractable { get; }

		InteractableCollisionDepth CollisionDepth { get; }
	}
	public class ColliderZoneArgs : EventArgs
	{
		public readonly ColliderZone Collider;

		public readonly float FrameTime;

		public readonly InteractableTool CollidingTool;

		public readonly InteractionType InteractionT;

		public ColliderZoneArgs(ColliderZone collider, float frameTime, InteractableTool collidingTool, InteractionType interactionType)
		{
			Collider = collider;
			FrameTime = frameTime;
			CollidingTool = collidingTool;
			InteractionT = interactionType;
		}
	}
	public enum InteractionType
	{
		Enter,
		Stay,
		Exit
	}
	public class HandsManager : MonoBehaviour
	{
		public enum HandsVisualMode
		{
			Mesh,
			Skeleton,
			Both
		}

		private const string SKELETON_VISUALIZER_NAME = "SkeletonRenderer";

		[SerializeField]
		private GameObject _leftHand;

		[SerializeField]
		private GameObject _rightHand;

		public HandsVisualMode VisualMode;

		private OVRHand[] _hand = new OVRHand[2];

		private OVRSkeleton[] _handSkeleton = new OVRSkeleton[2];

		private OVRSkeletonRenderer[] _handSkeletonRenderer = new OVRSkeletonRenderer[2];

		private OVRMesh[] _handMesh = new OVRMesh[2];

		private OVRMeshRenderer[] _handMeshRenderer = new OVRMeshRenderer[2];

		private SkinnedMeshRenderer _leftMeshRenderer;

		private SkinnedMeshRenderer _rightMeshRenderer;

		private GameObject _leftSkeletonVisual;

		private GameObject _rightSkeletonVisual;

		private float _currentHandAlpha = 1f;

		private int HandAlphaId = Shader.PropertyToID("_HandAlpha");

		public OVRHand RightHand
		{
			get
			{
				return _hand[1];
			}
			private set
			{
				_hand[1] = value;
			}
		}

		public OVRSkeleton RightHandSkeleton
		{
			get
			{
				return _handSkeleton[1];
			}
			private set
			{
				_handSkeleton[1] = value;
			}
		}

		public OVRSkeletonRenderer RightHandSkeletonRenderer
		{
			get
			{
				return _handSkeletonRenderer[1];
			}
			private set
			{
				_handSkeletonRenderer[1] = value;
			}
		}

		public OVRMesh RightHandMesh
		{
			get
			{
				return _handMesh[1];
			}
			private set
			{
				_handMesh[1] = value;
			}
		}

		public OVRMeshRenderer RightHandMeshRenderer
		{
			get
			{
				return _handMeshRenderer[1];
			}
			private set
			{
				_handMeshRenderer[1] = value;
			}
		}

		public OVRHand LeftHand
		{
			get
			{
				return _hand[0];
			}
			private set
			{
				_hand[0] = value;
			}
		}

		public OVRSkeleton LeftHandSkeleton
		{
			get
			{
				return _handSkeleton[0];
			}
			private set
			{
				_handSkeleton[0] = value;
			}
		}

		public OVRSkeletonRenderer LeftHandSkeletonRenderer
		{
			get
			{
				return _handSkeletonRenderer[0];
			}
			private set
			{
				_handSkeletonRenderer[0] = value;
			}
		}

		public OVRMesh LeftHandMesh
		{
			get
			{
				return _handMesh[0];
			}
			private set
			{
				_handMesh[0] = value;
			}
		}

		public OVRMeshRenderer LeftHandMeshRenderer
		{
			get
			{
				return _handMeshRenderer[0];
			}
			private set
			{
				_handMeshRenderer[0] = value;
			}
		}

		public static HandsManager Instance { get; private set; }

		private void Awake()
		{
			if ((bool)Instance && Instance != this)
			{
				UnityEngine.Object.Destroy(this);
				return;
			}
			Instance = this;
			LeftHand = _leftHand.GetComponent<OVRHand>();
			LeftHandSkeleton = _leftHand.GetComponent<OVRSkeleton>();
			LeftHandSkeletonRenderer = _leftHand.GetComponent<OVRSkeletonRenderer>();
			LeftHandMesh = _leftHand.GetComponent<OVRMesh>();
			LeftHandMeshRenderer = _leftHand.GetComponent<OVRMeshRenderer>();
			RightHand = _rightHand.GetComponent<OVRHand>();
			RightHandSkeleton = _rightHand.GetComponent<OVRSkeleton>();
			RightHandSkeletonRenderer = _rightHand.GetComponent<OVRSkeletonRenderer>();
			RightHandMesh = _rightHand.GetComponent<OVRMesh>();
			RightHandMeshRenderer = _rightHand.GetComponent<OVRMeshRenderer>();
			_leftMeshRenderer = LeftHand.GetComponent<SkinnedMeshRenderer>();
			_rightMeshRenderer = RightHand.GetComponent<SkinnedMeshRenderer>();
			StartCoroutine(FindSkeletonVisualGameObjects());
		}

		private void Update()
		{
			switch (VisualMode)
			{
			case HandsVisualMode.Mesh:
			case HandsVisualMode.Skeleton:
				_currentHandAlpha = 1f;
				break;
			case HandsVisualMode.Both:
				_currentHandAlpha = 0.6f;
				break;
			default:
				_currentHandAlpha = 1f;
				break;
			}
			_rightMeshRenderer.sharedMaterial.SetFloat(HandAlphaId, _currentHandAlpha);
			_leftMeshRenderer.sharedMaterial.SetFloat(HandAlphaId, _currentHandAlpha);
		}

		private IEnumerator FindSkeletonVisualGameObjects()
		{
			while (!_leftSkeletonVisual || !_rightSkeletonVisual)
			{
				if (!_leftSkeletonVisual)
				{
					Transform transform = LeftHand.transform.Find("SkeletonRenderer");
					if ((bool)transform)
					{
						_leftSkeletonVisual = transform.gameObject;
					}
				}
				if (!_rightSkeletonVisual)
				{
					Transform transform2 = RightHand.transform.Find("SkeletonRenderer");
					if ((bool)transform2)
					{
						_rightSkeletonVisual = transform2.gameObject;
					}
				}
				yield return null;
			}
			SetToCurrentVisualMode();
		}

		public void SwitchVisualization()
		{
			if ((bool)_leftSkeletonVisual && (bool)_rightSkeletonVisual)
			{
				VisualMode = (HandsVisualMode)((int)(VisualMode + 1) % 3);
				SetToCurrentVisualMode();
			}
		}

		private void SetToCurrentVisualMode()
		{
			switch (VisualMode)
			{
			case HandsVisualMode.Mesh:
				RightHandMeshRenderer.enabled = true;
				_rightMeshRenderer.enabled = true;
				_rightSkeletonVisual.gameObject.SetActive(value: false);
				LeftHandMeshRenderer.enabled = true;
				_leftMeshRenderer.enabled = true;
				_leftSkeletonVisual.gameObject.SetActive(value: false);
				break;
			case HandsVisualMode.Skeleton:
				RightHandMeshRenderer.enabled = false;
				_rightMeshRenderer.enabled = false;
				_rightSkeletonVisual.gameObject.SetActive(value: true);
				LeftHandMeshRenderer.enabled = false;
				_leftMeshRenderer.enabled = false;
				_leftSkeletonVisual.gameObject.SetActive(value: true);
				break;
			case HandsVisualMode.Both:
				RightHandMeshRenderer.enabled = true;
				_rightMeshRenderer.enabled = true;
				_rightSkeletonVisual.gameObject.SetActive(value: true);
				LeftHandMeshRenderer.enabled = true;
				_leftMeshRenderer.enabled = true;
				_leftSkeletonVisual.gameObject.SetActive(value: true);
				break;
			}
		}

		public static List<OVRBoneCapsule> GetCapsulesPerBone(OVRSkeleton skeleton, OVRSkeleton.BoneId boneId)
		{
			List<OVRBoneCapsule> list = new List<OVRBoneCapsule>();
			IList<OVRBoneCapsule> capsules = skeleton.Capsules;
			for (int i = 0; i < capsules.Count; i++)
			{
				if (capsules[i].BoneIndex == (short)boneId)
				{
					list.Add(capsules[i]);
				}
			}
			return list;
		}

		public bool IsInitialized()
		{
			if ((bool)LeftHandSkeleton && LeftHandSkeleton.IsInitialized && (bool)RightHandSkeleton && RightHandSkeleton.IsInitialized && (bool)LeftHandMesh && LeftHandMesh.IsInitialized && (bool)RightHandMesh)
			{
				return RightHandMesh.IsInitialized;
			}
			return false;
		}
	}
	public abstract class Interactable : MonoBehaviour
	{
		[Serializable]
		public class InteractableStateArgsEvent : UnityEvent<InteractableStateArgs>
		{
		}

		protected ColliderZone _proximityZoneCollider;

		protected ColliderZone _contactZoneCollider;

		protected ColliderZone _actionZoneCollider;

		public InteractableStateArgsEvent InteractableStateChanged;

		public ColliderZone ProximityCollider => _proximityZoneCollider;

		public ColliderZone ContactCollider => _contactZoneCollider;

		public ColliderZone ActionCollider => _actionZoneCollider;

		public virtual int ValidToolTagsMask => -1;

		public event Action<ColliderZoneArgs> ProximityZoneEvent;

		public event Action<ColliderZoneArgs> ContactZoneEvent;

		public event Action<ColliderZoneArgs> ActionZoneEvent;

		protected virtual void OnProximityZoneEvent(ColliderZoneArgs args)
		{
			if (this.ProximityZoneEvent != null)
			{
				this.ProximityZoneEvent(args);
			}
		}

		protected virtual void OnContactZoneEvent(ColliderZoneArgs args)
		{
			if (this.ContactZoneEvent != null)
			{
				this.ContactZoneEvent(args);
			}
		}

		protected virtual void OnActionZoneEvent(ColliderZoneArgs args)
		{
			if (this.ActionZoneEvent != null)
			{
				this.ActionZoneEvent(args);
			}
		}

		public abstract void UpdateCollisionDepth(InteractableTool interactableTool, InteractableCollisionDepth oldCollisionDepth, InteractableCollisionDepth newCollisionDepth);

		protected virtual void Awake()
		{
			InteractableRegistry.RegisterInteractable(this);
		}

		protected virtual void OnDestroy()
		{
			InteractableRegistry.UnregisterInteractable(this);
		}
	}
	public enum InteractableCollisionDepth
	{
		None,
		Proximity,
		Contact,
		Action
	}
	public enum InteractableState
	{
		Default,
		ProximityState,
		ContactState,
		ActionState
	}
	public class InteractableStateArgs : EventArgs
	{
		public readonly Interactable Interactable;

		public readonly InteractableTool Tool;

		public readonly InteractableState OldInteractableState;

		public readonly InteractableState NewInteractableState;

		public readonly ColliderZoneArgs ColliderArgs;

		public InteractableStateArgs(Interactable interactable, InteractableTool tool, InteractableState newInteractableState, InteractableState oldState, ColliderZoneArgs colliderArgs)
		{
			Interactable = interactable;
			Tool = tool;
			NewInteractableState = newInteractableState;
			OldInteractableState = oldState;
			ColliderArgs = colliderArgs;
		}
	}
	public class InteractableRegistry : MonoBehaviour
	{
		public static HashSet<Interactable> _interactables = new HashSet<Interactable>();

		public static HashSet<Interactable> Interactables => _interactables;

		public static void RegisterInteractable(Interactable interactable)
		{
			Interactables.Add(interactable);
		}

		public static void UnregisterInteractable(Interactable interactable)
		{
			Interactables.Remove(interactable);
		}
	}
	public class InteractableToolsCreator : MonoBehaviour
	{
		[SerializeField]
		private Transform[] LeftHandTools;

		[SerializeField]
		private Transform[] RightHandTools;

		private void Awake()
		{
			if (LeftHandTools != null && LeftHandTools.Length != 0)
			{
				StartCoroutine(AttachToolsToHands(LeftHandTools, isRightHand: false));
			}
			if (RightHandTools != null && RightHandTools.Length != 0)
			{
				StartCoroutine(AttachToolsToHands(RightHandTools, isRightHand: true));
			}
		}

		private IEnumerator AttachToolsToHands(Transform[] toolObjects, bool isRightHand)
		{
			HandsManager handsManagerObj;
			while (true)
			{
				HandsManager instance;
				handsManagerObj = (instance = HandsManager.Instance);
				if (!(instance == null) && handsManagerObj.IsInitialized())
				{
					break;
				}
				yield return null;
			}
			HashSet<Transform> hashSet = new HashSet<Transform>();
			foreach (Transform transform in toolObjects)
			{
				hashSet.Add(transform.transform);
			}
			foreach (Transform toolObject in hashSet)
			{
				OVRSkeleton handSkeletonToAttachTo = (isRightHand ? handsManagerObj.RightHandSkeleton : handsManagerObj.LeftHandSkeleton);
				while (handSkeletonToAttachTo == null || handSkeletonToAttachTo.Bones == null)
				{
					yield return null;
				}
				AttachToolToHandTransform(toolObject, isRightHand);
			}
		}

		private void AttachToolToHandTransform(Transform tool, bool isRightHanded)
		{
			Transform obj = UnityEngine.Object.Instantiate(tool).transform;
			obj.localPosition = Vector3.zero;
			InteractableTool component = obj.GetComponent<InteractableTool>();
			component.IsRightHandedTool = isRightHanded;
			component.Initialize();
		}
	}
	public class InteractableToolsInputRouter : MonoBehaviour
	{
		private static InteractableToolsInputRouter _instance;

		private bool _leftPinch;

		private bool _rightPinch;

		private HashSet<InteractableTool> _leftHandNearTools = new HashSet<InteractableTool>();

		private HashSet<InteractableTool> _leftHandFarTools = new HashSet<InteractableTool>();

		private HashSet<InteractableTool> _rightHandNearTools = new HashSet<InteractableTool>();

		private HashSet<InteractableTool> _rightHandFarTools = new HashSet<InteractableTool>();

		public static InteractableToolsInputRouter Instance
		{
			get
			{
				if (_instance == null)
				{
					InteractableToolsInputRouter[] array = UnityEngine.Object.FindObjectsOfType<InteractableToolsInputRouter>();
					if (array.Length != 0)
					{
						_instance = array[0];
						for (int i = 1; i < array.Length; i++)
						{
							UnityEngine.Object.Destroy(array[i].gameObject);
						}
					}
				}
				return _instance;
			}
		}

		public void RegisterInteractableTool(InteractableTool interactableTool)
		{
			if (interactableTool.IsRightHandedTool)
			{
				if (interactableTool.IsFarFieldTool)
				{
					_rightHandFarTools.Add(interactableTool);
				}
				else
				{
					_rightHandNearTools.Add(interactableTool);
				}
			}
			else if (interactableTool.IsFarFieldTool)
			{
				_leftHandFarTools.Add(interactableTool);
			}
			else
			{
				_leftHandNearTools.Add(interactableTool);
			}
		}

		public void UnregisterInteractableTool(InteractableTool interactableTool)
		{
			if (interactableTool.IsRightHandedTool)
			{
				if (interactableTool.IsFarFieldTool)
				{
					_rightHandFarTools.Remove(interactableTool);
				}
				else
				{
					_rightHandNearTools.Remove(interactableTool);
				}
			}
			else if (interactableTool.IsFarFieldTool)
			{
				_leftHandFarTools.Remove(interactableTool);
			}
			else
			{
				_leftHandNearTools.Remove(interactableTool);
			}
		}

		private void Update()
		{
			if (HandsManager.Instance.IsInitialized())
			{
				bool flag = HandsManager.Instance.LeftHand.IsTracked && HandsManager.Instance.LeftHand.HandConfidence == OVRHand.TrackingConfidence.High;
				bool flag2 = HandsManager.Instance.RightHand.IsTracked && HandsManager.Instance.RightHand.HandConfidence == OVRHand.TrackingConfidence.High;
				bool isPointerPoseValid = HandsManager.Instance.LeftHand.IsPointerPoseValid;
				bool isPointerPoseValid2 = HandsManager.Instance.RightHand.IsPointerPoseValid;
				bool flag3 = UpdateToolsAndEnableState(_leftHandNearTools, flag);
				UpdateToolsAndEnableState(_leftHandFarTools, !flag3 && flag && isPointerPoseValid);
				bool flag4 = UpdateToolsAndEnableState(_rightHandNearTools, flag2);
				UpdateToolsAndEnableState(_rightHandFarTools, !flag4 && flag2 && isPointerPoseValid2);
			}
		}

		private bool UpdateToolsAndEnableState(HashSet<InteractableTool> tools, bool toolsAreEnabledThisFrame)
		{
			bool result = UpdateTools(tools, !toolsAreEnabledThisFrame);
			ToggleToolsEnableState(tools, toolsAreEnabledThisFrame);
			return result;
		}

		private bool UpdateTools(HashSet<InteractableTool> tools, bool resetCollisionData = false)
		{
			bool flag = false;
			foreach (InteractableTool tool in tools)
			{
				List<InteractableCollisionInfo> nextIntersectingObjects = tool.GetNextIntersectingObjects();
				if (nextIntersectingObjects.Count > 0 && !resetCollisionData)
				{
					if (!flag)
					{
						flag = nextIntersectingObjects.Count > 0;
					}
					tool.UpdateCurrentCollisionsBasedOnDepth();
					if (tool.IsFarFieldTool)
					{
						KeyValuePair<Interactable, InteractableCollisionInfo> firstCurrentCollisionInfo = tool.GetFirstCurrentCollisionInfo();
						if (tool.ToolInputState == ToolInputState.PrimaryInputUp)
						{
							firstCurrentCollisionInfo.Value.InteractableCollider = firstCurrentCollisionInfo.Key.ActionCollider;
							firstCurrentCollisionInfo.Value.CollisionDepth = InteractableCollisionDepth.Action;
						}
						else
						{
							firstCurrentCollisionInfo.Value.InteractableCollider = firstCurrentCollisionInfo.Key.ContactCollider;
							firstCurrentCollisionInfo.Value.CollisionDepth = InteractableCollisionDepth.Contact;
						}
						tool.FocusOnInteractable(firstCurrentCollisionInfo.Key, firstCurrentCollisionInfo.Value.InteractableCollider);
					}
				}
				else
				{
					tool.DeFocus();
					tool.ClearAllCurrentCollisionInfos();
				}
				tool.UpdateLatestCollisionData();
			}
			return flag;
		}

		private void ToggleToolsEnableState(HashSet<InteractableTool> tools, bool enableState)
		{
			foreach (InteractableTool tool in tools)
			{
				if (tool.EnableState != enableState)
				{
					tool.EnableState = enableState;
				}
			}
		}
	}
	public class FingerTipPokeTool : InteractableTool
	{
		private const int NUM_VELOCITY_FRAMES = 10;

		[SerializeField]
		private FingerTipPokeToolView _fingerTipPokeToolView;

		[SerializeField]
		private OVRPlugin.HandFinger _fingerToFollow = OVRPlugin.HandFinger.Index;

		private Vector3[] _velocityFrames;

		private int _currVelocityFrame;

		private bool _sampledMaxFramesAlready;

		private Vector3 _position;

		private BoneCapsuleTriggerLogic[] _boneCapsuleTriggerLogic;

		private float _lastScale = 1f;

		private bool _isInitialized;

		private OVRBoneCapsule _capsuleToTrack;

		public override InteractableToolTags ToolTags => InteractableToolTags.Poke;

		public override ToolInputState ToolInputState => ToolInputState.Inactive;

		public override bool IsFarFieldTool => false;

		public override bool EnableState
		{
			get
			{
				return _fingerTipPokeToolView.gameObject.activeSelf;
			}
			set
			{
				_fingerTipPokeToolView.gameObject.SetActive(value);
			}
		}

		public override void Initialize()
		{
			InteractableToolsInputRouter.Instance.RegisterInteractableTool(this);
			_fingerTipPokeToolView.InteractableTool = this;
			_velocityFrames = new Vector3[10];
			Array.Clear(_velocityFrames, 0, 10);
			StartCoroutine(AttachTriggerLogic());
		}

		private IEnumerator AttachTriggerLogic()
		{
			while (!HandsManager.Instance || !HandsManager.Instance.IsInitialized())
			{
				yield return null;
			}
			OVRSkeleton skeleton = (base.IsRightHandedTool ? HandsManager.Instance.RightHandSkeleton : HandsManager.Instance.LeftHandSkeleton);
			OVRSkeleton.BoneId boneId = _fingerToFollow switch
			{
				OVRPlugin.HandFinger.Thumb => OVRSkeleton.BoneId.Hand_Thumb3, 
				OVRPlugin.HandFinger.Index => OVRSkeleton.BoneId.Hand_Index3, 
				OVRPlugin.HandFinger.Middle => OVRSkeleton.BoneId.Hand_Middle3, 
				OVRPlugin.HandFinger.Ring => OVRSkeleton.BoneId.Hand_Ring3, 
				_ => OVRSkeleton.BoneId.Hand_Pinky3, 
			};
			List<BoneCapsuleTriggerLogic> list = new List<BoneCapsuleTriggerLogic>();
			List<OVRBoneCapsule> capsulesPerBone = HandsManager.GetCapsulesPerBone(skeleton, boneId);
			foreach (OVRBoneCapsule item in capsulesPerBone)
			{
				BoneCapsuleTriggerLogic boneCapsuleTriggerLogic = item.CapsuleRigidbody.gameObject.AddComponent<BoneCapsuleTriggerLogic>();
				item.CapsuleCollider.isTrigger = true;
				boneCapsuleTriggerLogic.ToolTags = ToolTags;
				list.Add(boneCapsuleTriggerLogic);
			}
			_boneCapsuleTriggerLogic = list.ToArray();
			if (capsulesPerBone.Count > 0)
			{
				_capsuleToTrack = capsulesPerBone[0];
			}
			_isInitialized = true;
		}

		private void Update()
		{
			if ((bool)HandsManager.Instance && HandsManager.Instance.IsInitialized() && _isInitialized && _capsuleToTrack != null)
			{
				float handScale = (base.IsRightHandedTool ? HandsManager.Instance.RightHand : HandsManager.Instance.LeftHand).HandScale;
				Transform transform = _capsuleToTrack.CapsuleCollider.transform;
				Vector3 right = transform.right;
				Vector3 vector = transform.position + _capsuleToTrack.CapsuleCollider.height * 0.5f * right;
				Vector3 vector2 = handScale * _fingerTipPokeToolView.SphereRadius * right;
				Vector3 position = vector + vector2;
				base.transform.position = position;
				base.transform.rotation = transform.rotation;
				base.InteractionPosition = vector;
				UpdateAverageVelocity();
				CheckAndUpdateScale();
			}
		}

		private void UpdateAverageVelocity()
		{
			Vector3 position = _position;
			Vector3 position2 = base.transform.position;
			Vector3 vector = (position2 - position) / Time.deltaTime;
			_position = position2;
			_velocityFrames[_currVelocityFrame] = vector;
			_currVelocityFrame = (_currVelocityFrame + 1) % 10;
			base.Velocity = Vector3.zero;
			if (!_sampledMaxFramesAlready && _currVelocityFrame == 9)
			{
				_sampledMaxFramesAlready = true;
			}
			int num = (_sampledMaxFramesAlready ? 10 : (_currVelocityFrame + 1));
			for (int i = 0; i < num; i++)
			{
				base.Velocity += _velocityFrames[i];
			}
			base.Velocity /= (float)num;
		}

		private void CheckAndUpdateScale()
		{
			float num = (base.IsRightHandedTool ? HandsManager.Instance.RightHand.HandScale : HandsManager.Instance.LeftHand.HandScale);
			if (Mathf.Abs(num - _lastScale) > Mathf.Epsilon)
			{
				base.transform.localScale = new Vector3(num, num, num);
				_lastScale = num;
			}
		}

		public override List<InteractableCollisionInfo> GetNextIntersectingObjects()
		{
			_currentIntersectingObjects.Clear();
			BoneCapsuleTriggerLogic[] boneCapsuleTriggerLogic = _boneCapsuleTriggerLogic;
			for (int i = 0; i < boneCapsuleTriggerLogic.Length; i++)
			{
				foreach (ColliderZone collidersTouchingU in boneCapsuleTriggerLogic[i].CollidersTouchingUs)
				{
					_currentIntersectingObjects.Add(new InteractableCollisionInfo(collidersTouchingU, collidersTouchingU.CollisionDepth, this));
				}
			}
			return _currentIntersectingObjects;
		}

		public override void FocusOnInteractable(Interactable focusedInteractable, ColliderZone colliderZone)
		{
		}

		public override void DeFocus()
		{
		}
	}
	public class FingerTipPokeToolView : MonoBehaviour, InteractableToolView
	{
		[SerializeField]
		private MeshRenderer _sphereMeshRenderer;

		public InteractableTool InteractableTool { get; set; }

		public bool EnableState
		{
			get
			{
				return _sphereMeshRenderer.enabled;
			}
			set
			{
				_sphereMeshRenderer.enabled = value;
			}
		}

		public bool ToolActivateState { get; set; }

		public float SphereRadius { get; private set; }

		private void Awake()
		{
			SphereRadius = _sphereMeshRenderer.transform.localScale.z * 0.5f;
		}

		public void SetFocusedInteractable(Interactable interactable)
		{
		}
	}
	[Flags]
	public enum InteractableToolTags
	{
		None = 0,
		Ray = 1,
		Poke = 4,
		All = -1
	}
	public enum ToolInputState
	{
		Inactive,
		PrimaryInputDown,
		PrimaryInputDownStay,
		PrimaryInputUp
	}
	public class InteractableCollisionInfo
	{
		public ColliderZone InteractableCollider;

		public InteractableCollisionDepth CollisionDepth;

		public InteractableTool CollidingTool;

		public InteractableCollisionInfo(ColliderZone collider, InteractableCollisionDepth collisionDepth, InteractableTool collidingTool)
		{
			InteractableCollider = collider;
			CollisionDepth = collisionDepth;
			CollidingTool = collidingTool;
		}
	}
	public abstract class InteractableTool : MonoBehaviour
	{
		protected List<InteractableCollisionInfo> _currentIntersectingObjects = new List<InteractableCollisionInfo>();

		private List<Interactable> _addedInteractables = new List<Interactable>();

		private List<Interactable> _removedInteractables = new List<Interactable>();

		private List<Interactable> _remainingInteractables = new List<Interactable>();

		private Dictionary<Interactable, InteractableCollisionInfo> _currInteractableToCollisionInfos = new Dictionary<Interactable, InteractableCollisionInfo>();

		private Dictionary<Interactable, InteractableCollisionInfo> _prevInteractableToCollisionInfos = new Dictionary<Interactable, InteractableCollisionInfo>();

		public Transform ToolTransform => base.transform;

		public bool IsRightHandedTool { get; set; }

		public abstract InteractableToolTags ToolTags { get; }

		public abstract ToolInputState ToolInputState { get; }

		public abstract bool IsFarFieldTool { get; }

		public Vector3 Velocity { get; protected set; }

		public Vector3 InteractionPosition { get; protected set; }

		public abstract bool EnableState { get; set; }

		public List<InteractableCollisionInfo> GetCurrentIntersectingObjects()
		{
			return _currentIntersectingObjects;
		}

		public abstract List<InteractableCollisionInfo> GetNextIntersectingObjects();

		public abstract void FocusOnInteractable(Interactable focusedInteractable, ColliderZone colliderZone);

		public abstract void DeFocus();

		public abstract void Initialize();

		public KeyValuePair<Interactable, InteractableCollisionInfo> GetFirstCurrentCollisionInfo()
		{
			return _currInteractableToCollisionInfos.First();
		}

		public void ClearAllCurrentCollisionInfos()
		{
			_currInteractableToCollisionInfos.Clear();
		}

		public virtual void UpdateCurrentCollisionsBasedOnDepth()
		{
			_currInteractableToCollisionInfos.Clear();
			foreach (InteractableCollisionInfo currentIntersectingObject in _currentIntersectingObjects)
			{
				Interactable parentInteractable = currentIntersectingObject.InteractableCollider.ParentInteractable;
				InteractableCollisionDepth collisionDepth = currentIntersectingObject.CollisionDepth;
				InteractableCollisionInfo value = null;
				if (!_currInteractableToCollisionInfos.TryGetValue(parentInteractable, out value))
				{
					_currInteractableToCollisionInfos[parentInteractable] = currentIntersectingObject;
				}
				else if (value.CollisionDepth < collisionDepth)
				{
					value.InteractableCollider = currentIntersectingObject.InteractableCollider;
					value.CollisionDepth = collisionDepth;
				}
			}
		}

		public virtual void UpdateLatestCollisionData()
		{
			_addedInteractables.Clear();
			_removedInteractables.Clear();
			_remainingInteractables.Clear();
			foreach (Interactable key in _currInteractableToCollisionInfos.Keys)
			{
				if (!_prevInteractableToCollisionInfos.ContainsKey(key))
				{
					_addedInteractables.Add(key);
				}
				else
				{
					_remainingInteractables.Add(key);
				}
			}
			foreach (Interactable key2 in _prevInteractableToCollisionInfos.Keys)
			{
				if (!_currInteractableToCollisionInfos.ContainsKey(key2))
				{
					_removedInteractables.Add(key2);
				}
			}
			foreach (Interactable removedInteractable in _removedInteractables)
			{
				removedInteractable.UpdateCollisionDepth(this, _prevInteractableToCollisionInfos[removedInteractable].CollisionDepth, InteractableCollisionDepth.None);
			}
			foreach (Interactable addedInteractable in _addedInteractables)
			{
				InteractableCollisionDepth collisionDepth = _currInteractableToCollisionInfos[addedInteractable].CollisionDepth;
				addedInteractable.UpdateCollisionDepth(this, InteractableCollisionDepth.None, collisionDepth);
			}
			foreach (Interactable remainingInteractable in _remainingInteractables)
			{
				InteractableCollisionDepth collisionDepth2 = _currInteractableToCollisionInfos[remainingInteractable].CollisionDepth;
				InteractableCollisionDepth collisionDepth3 = _prevInteractableToCollisionInfos[remainingInteractable].CollisionDepth;
				remainingInteractable.UpdateCollisionDepth(this, collisionDepth3, collisionDepth2);
			}
			_prevInteractableToCollisionInfos = new Dictionary<Interactable, InteractableCollisionInfo>(_currInteractableToCollisionInfos);
		}
	}
	public interface InteractableToolView
	{
		InteractableTool InteractableTool { get; }

		bool EnableState { get; set; }

		bool ToolActivateState { get; set; }

		void SetFocusedInteractable(Interactable interactable);
	}
	public class PinchStateModule
	{
		private enum PinchState
		{
			None,
			PinchDown,
			PinchStay,
			PinchUp
		}

		private const float PINCH_STRENGTH_THRESHOLD = 1f;

		private PinchState _currPinchState;

		private Interactable _firstFocusedInteractable;

		public bool PinchUpAndDownOnFocusedObject
		{
			get
			{
				if (_currPinchState == PinchState.PinchUp)
				{
					return _firstFocusedInteractable != null;
				}
				return false;
			}
		}

		public bool PinchSteadyOnFocusedObject
		{
			get
			{
				if (_currPinchState == PinchState.PinchStay)
				{
					return _firstFocusedInteractable != null;
				}
				return false;
			}
		}

		public bool PinchDownOnFocusedObject
		{
			get
			{
				if (_currPinchState == PinchState.PinchDown)
				{
					return _firstFocusedInteractable != null;
				}
				return false;
			}
		}

		public PinchStateModule()
		{
			_currPinchState = PinchState.None;
			_firstFocusedInteractable = null;
		}

		public void UpdateState(OVRHand hand, Interactable currFocusedInteractable)
		{
			float fingerPinchStrength = hand.GetFingerPinchStrength(OVRHand.HandFinger.Index);
			bool flag = Mathf.Abs(1f - fingerPinchStrength) < Mathf.Epsilon;
			switch (_currPinchState)
			{
			case PinchState.PinchUp:
				if (flag)
				{
					_currPinchState = PinchState.PinchDown;
					if (currFocusedInteractable != _firstFocusedInteractable)
					{
						_firstFocusedInteractable = null;
					}
				}
				else
				{
					_currPinchState = PinchState.None;
					_firstFocusedInteractable = null;
				}
				break;
			case PinchState.PinchStay:
				if (!flag)
				{
					_currPinchState = PinchState.PinchUp;
				}
				if (currFocusedInteractable != _firstFocusedInteractable)
				{
					_firstFocusedInteractable = null;
				}
				break;
			case PinchState.PinchDown:
				_currPinchState = (flag ? PinchState.PinchStay : PinchState.PinchUp);
				if (_firstFocusedInteractable != currFocusedInteractable)
				{
					_firstFocusedInteractable = null;
				}
				break;
			default:
				if (flag)
				{
					_currPinchState = PinchState.PinchDown;
					_firstFocusedInteractable = currFocusedInteractable;
				}
				break;
			}
		}
	}
	public class RayTool : InteractableTool
	{
		private const float MINIMUM_RAY_CAST_DISTANCE = 0.8f;

		private const float COLLIDER_RADIUS = 0.01f;

		private const int NUM_MAX_PRIMARY_HITS = 10;

		private const int NUM_MAX_SECONDARY_HITS = 25;

		private const int NUM_COLLIDERS_TO_TEST = 20;

		[SerializeField]
		private RayToolView _rayToolView;

		[Range(0f, 45f)]
		[SerializeField]
		private float _coneAngleDegrees = 20f;

		[SerializeField]
		private float _farFieldMaxDistance = 5f;

		private PinchStateModule _pinchStateModule = new PinchStateModule();

		private Interactable _focusedInteractable;

		private Collider[] _collidersOverlapped = new Collider[20];

		private Interactable _currInteractableCastedAgainst;

		private float _coneAngleReleaseDegrees;

		private RaycastHit[] _primaryHits = new RaycastHit[10];

		private Collider[] _secondaryOverlapResults = new Collider[25];

		private bool _initialized;

		public override InteractableToolTags ToolTags => InteractableToolTags.Ray;

		public override ToolInputState ToolInputState
		{
			get
			{
				if (_pinchStateModule.PinchDownOnFocusedObject)
				{
					return ToolInputState.PrimaryInputDown;
				}
				if (_pinchStateModule.PinchSteadyOnFocusedObject)
				{
					return ToolInputState.PrimaryInputDownStay;
				}
				if (_pinchStateModule.PinchUpAndDownOnFocusedObject)
				{
					return ToolInputState.PrimaryInputUp;
				}
				return ToolInputState.Inactive;
			}
		}

		public override bool IsFarFieldTool => true;

		public override bool EnableState
		{
			get
			{
				return _rayToolView.EnableState;
			}
			set
			{
				_rayToolView.EnableState = value;
			}
		}

		public override void Initialize()
		{
			InteractableToolsInputRouter.Instance.RegisterInteractableTool(this);
			_rayToolView.InteractableTool = this;
			_coneAngleReleaseDegrees = _coneAngleDegrees * 1.2f;
			_initialized = true;
		}

		private void OnDestroy()
		{
			if (InteractableToolsInputRouter.Instance != null)
			{
				InteractableToolsInputRouter.Instance.UnregisterInteractableTool(this);
			}
		}

		private void Update()
		{
			if ((bool)HandsManager.Instance && HandsManager.Instance.IsInitialized() && _initialized)
			{
				OVRHand oVRHand = (base.IsRightHandedTool ? HandsManager.Instance.RightHand : HandsManager.Instance.LeftHand);
				Transform pointerPose = oVRHand.PointerPose;
				base.transform.position = pointerPose.position;
				base.transform.rotation = pointerPose.rotation;
				Vector3 interactionPosition = base.InteractionPosition;
				Vector3 position = base.transform.position;
				base.Velocity = (position - interactionPosition) / Time.deltaTime;
				base.InteractionPosition = position;
				_pinchStateModule.UpdateState(oVRHand, _focusedInteractable);
				_rayToolView.ToolActivateState = _pinchStateModule.PinchSteadyOnFocusedObject || _pinchStateModule.PinchDownOnFocusedObject;
			}
		}

		private Vector3 GetRayCastOrigin()
		{
			return base.transform.position + 0.8f * base.transform.forward;
		}

		public override List<InteractableCollisionInfo> GetNextIntersectingObjects()
		{
			if (!_initialized)
			{
				return _currentIntersectingObjects;
			}
			if (_currInteractableCastedAgainst != null && HasRayReleasedInteractable(_currInteractableCastedAgainst))
			{
				_currInteractableCastedAgainst = null;
			}
			if (_currInteractableCastedAgainst == null)
			{
				_currentIntersectingObjects.Clear();
				_currInteractableCastedAgainst = FindTargetInteractable();
				if (_currInteractableCastedAgainst != null)
				{
					int num = Physics.OverlapSphereNonAlloc(_currInteractableCastedAgainst.transform.position, 0.01f, _collidersOverlapped);
					for (int i = 0; i < num; i++)
					{
						ColliderZone component = _collidersOverlapped[i].GetComponent<ColliderZone>();
						if (component != null)
						{
							Interactable parentInteractable = component.ParentInteractable;
							if (!(parentInteractable == null) && !(parentInteractable != _currInteractableCastedAgainst))
							{
								InteractableCollisionInfo item = new InteractableCollisionInfo(component, component.CollisionDepth, this);
								_currentIntersectingObjects.Add(item);
							}
						}
					}
					if (_currentIntersectingObjects.Count == 0)
					{
						_currInteractableCastedAgainst = null;
					}
				}
			}
			return _currentIntersectingObjects;
		}

		private bool HasRayReleasedInteractable(Interactable focusedInteractable)
		{
			Vector3 position = base.transform.position;
			Vector3 forward = base.transform.forward;
			float num = Mathf.Cos(_coneAngleReleaseDegrees * ((float)Math.PI / 180f));
			Vector3 lhs = focusedInteractable.transform.position - position;
			lhs.Normalize();
			return Vector3.Dot(lhs, forward) < num;
		}

		private Interactable FindTargetInteractable()
		{
			Vector3 rayCastOrigin = GetRayCastOrigin();
			Vector3 forward = base.transform.forward;
			Interactable interactable = null;
			interactable = FindPrimaryRaycastHit(rayCastOrigin, forward);
			if (interactable == null)
			{
				interactable = FindInteractableViaConeTest(rayCastOrigin, forward);
			}
			return interactable;
		}

		private Interactable FindPrimaryRaycastHit(Vector3 rayOrigin, Vector3 rayDirection)
		{
			Interactable interactable = null;
			int num = Physics.RaycastNonAlloc(new Ray(rayOrigin, rayDirection), _primaryHits, float.PositiveInfinity);
			float num2 = 0f;
			for (int i = 0; i < num; i++)
			{
				RaycastHit raycastHit = _primaryHits[i];
				ColliderZone component = raycastHit.transform.GetComponent<ColliderZone>();
				if (component == null)
				{
					continue;
				}
				Interactable parentInteractable = component.ParentInteractable;
				if (!(parentInteractable == null) && ((uint)parentInteractable.ValidToolTagsMask & (uint)ToolTags) != 0)
				{
					float magnitude = (parentInteractable.transform.position - rayOrigin).magnitude;
					if (interactable == null || magnitude < num2)
					{
						interactable = parentInteractable;
						num2 = magnitude;
					}
				}
			}
			return interactable;
		}

		private Interactable FindInteractableViaConeTest(Vector3 rayOrigin, Vector3 rayDirection)
		{
			Interactable interactable = null;
			float num = 0f;
			float num2 = Mathf.Cos(_coneAngleDegrees * ((float)Math.PI / 180f));
			float num3 = Mathf.Tan((float)Math.PI / 180f * _coneAngleDegrees * 0.5f) * _farFieldMaxDistance;
			int num4 = Physics.OverlapBoxNonAlloc(rayOrigin + rayDirection * _farFieldMaxDistance * 0.5f, new Vector3(num3, num3, _farFieldMaxDistance * 0.5f), _secondaryOverlapResults, base.transform.rotation);
			for (int i = 0; i < num4; i++)
			{
				ColliderZone component = _secondaryOverlapResults[i].GetComponent<ColliderZone>();
				if (component == null)
				{
					continue;
				}
				Interactable parentInteractable = component.ParentInteractable;
				if (!(parentInteractable == null) && ((uint)parentInteractable.ValidToolTagsMask & (uint)ToolTags) != 0)
				{
					Vector3 lhs = parentInteractable.transform.position - rayOrigin;
					float magnitude = lhs.magnitude;
					lhs /= magnitude;
					if (!(Vector3.Dot(lhs, rayDirection) < num2) && (interactable == null || magnitude < num))
					{
						interactable = parentInteractable;
						num = magnitude;
					}
				}
			}
			return interactable;
		}

		public override void FocusOnInteractable(Interactable focusedInteractable, ColliderZone colliderZone)
		{
			_rayToolView.SetFocusedInteractable(focusedInteractable);
			_focusedInteractable = focusedInteractable;
		}

		public override void DeFocus()
		{
			_rayToolView.SetFocusedInteractable(null);
			_focusedInteractable = null;
		}
	}
	public class RayToolView : MonoBehaviour, InteractableToolView
	{
		private const int NUM_RAY_LINE_POSITIONS = 25;

		private const float DEFAULT_RAY_CAST_DISTANCE = 3f;

		[SerializeField]
		private Transform _targetTransform;

		[SerializeField]
		private LineRenderer _lineRenderer;

		private bool _toolActivateState;

		private Transform _focusedTransform;

		private Vector3[] linePositions = new Vector3[25];

		private Gradient _oldColorGradient;

		private Gradient _highLightColorGradient;

		public bool EnableState
		{
			get
			{
				return _lineRenderer.enabled;
			}
			set
			{
				_targetTransform.gameObject.SetActive(value);
				_lineRenderer.enabled = value;
			}
		}

		public bool ToolActivateState
		{
			get
			{
				return _toolActivateState;
			}
			set
			{
				_toolActivateState = value;
				_lineRenderer.colorGradient = (_toolActivateState ? _highLightColorGradient : _oldColorGradient);
			}
		}

		public InteractableTool InteractableTool { get; set; }

		private void Awake()
		{
			_lineRenderer.positionCount = 25;
			_oldColorGradient = _lineRenderer.colorGradient;
			_highLightColorGradient = new Gradient();
			_highLightColorGradient.SetKeys(new GradientColorKey[2]
			{
				new GradientColorKey(new Color(0.9f, 0.9f, 0.9f), 0f),
				new GradientColorKey(new Color(0.9f, 0.9f, 0.9f), 1f)
			}, new GradientAlphaKey[2]
			{
				new GradientAlphaKey(1f, 0f),
				new GradientAlphaKey(1f, 1f)
			});
		}

		public void SetFocusedInteractable(Interactable interactable)
		{
			if (interactable == null)
			{
				_focusedTransform = null;
			}
			else
			{
				_focusedTransform = interactable.transform;
			}
		}

		private void Update()
		{
			Vector3 position = InteractableTool.ToolTransform.position;
			Vector3 forward = InteractableTool.ToolTransform.forward;
			Vector3 vector = ((_focusedTransform != null) ? _focusedTransform.position : (position + forward * 3f));
			float magnitude = (vector - position).magnitude;
			Vector3 p = position;
			Vector3 p2 = position + forward * magnitude * 0.3333333f;
			Vector3 p3 = position + forward * magnitude * (2f / 3f);
			Vector3 p4 = vector;
			for (int i = 0; i < 25; i++)
			{
				linePositions[i] = GetPointOnBezierCurve(p, p2, p3, p4, (float)i / 25f);
			}
			_lineRenderer.SetPositions(linePositions);
			_targetTransform.position = vector;
		}

		public static Vector3 GetPointOnBezierCurve(Vector3 p0, Vector3 p1, Vector3 p2, Vector3 p3, float t)
		{
			t = Mathf.Clamp01(t);
			float num = 1f - t;
			float num2 = num * num;
			float num3 = t * t;
			return num * num2 * p0 + 3f * num2 * t * p1 + 3f * num * num3 * p2 + t * num3 * p3;
		}
	}
	public class DistanceGrabberSample : MonoBehaviour
	{
		private bool useSpherecast;

		private bool allowGrabThroughWalls;

		[SerializeField]
		private DistanceGrabber[] m_grabbers;

		public bool UseSpherecast
		{
			get
			{
				return useSpherecast;
			}
			set
			{
				useSpherecast = value;
				for (int i = 0; i < m_grabbers.Length; i++)
				{
					m_grabbers[i].UseSpherecast = useSpherecast;
				}
			}
		}

		public bool AllowGrabThroughWalls
		{
			get
			{
				return allowGrabThroughWalls;
			}
			set
			{
				allowGrabThroughWalls = value;
				for (int i = 0; i < m_grabbers.Length; i++)
				{
					m_grabbers[i].m_preventGrabThroughWalls = !allowGrabThroughWalls;
				}
			}
		}

		private void Start()
		{
			DebugUIBuilder.instance.AddLabel("Distance Grab Sample");
			DebugUIBuilder.instance.AddToggle("Use Spherecasting", ToggleSphereCasting, useSpherecast);
			DebugUIBuilder.instance.AddToggle("Grab Through Walls", ToggleGrabThroughWalls, allowGrabThroughWalls);
			DebugUIBuilder.instance.Show();
			float displayFrequency = OVRManager.display.displayFrequency;
			if (displayFrequency > 0.1f)
			{
				UnityEngine.Debug.Log("Setting Time.fixedDeltaTime to: " + 1f / displayFrequency);
				Time.fixedDeltaTime = 1f / displayFrequency;
			}
		}

		public void ToggleSphereCasting(Toggle t)
		{
			UseSpherecast = !UseSpherecast;
		}

		public void ToggleGrabThroughWalls(Toggle t)
		{
			AllowGrabThroughWalls = !AllowGrabThroughWalls;
		}
	}
	public class ControllerBoxController : MonoBehaviour
	{
		[SerializeField]
		private TrainLocomotive _locomotive;

		[SerializeField]
		private CowController _cowController;

		private void Awake()
		{
		}

		public void StartStopStateChanged(InteractableStateArgs obj)
		{
			if (obj.NewInteractableState == InteractableState.ActionState)
			{
				_locomotive.StartStopStateChanged();
			}
		}

		public void DecreaseSpeedStateChanged(InteractableStateArgs obj)
		{
			if (obj.NewInteractableState == InteractableState.ActionState)
			{
				_locomotive.DecreaseSpeedStateChanged();
			}
		}

		public void IncreaseSpeedStateChanged(InteractableStateArgs obj)
		{
			if (obj.NewInteractableState == InteractableState.ActionState)
			{
				_locomotive.IncreaseSpeedStateChanged();
			}
		}

		public void SmokeButtonStateChanged(InteractableStateArgs obj)
		{
			if (obj.NewInteractableState == InteractableState.ActionState)
			{
				_locomotive.SmokeButtonStateChanged();
			}
		}

		public void WhistleButtonStateChanged(InteractableStateArgs obj)
		{
			if (obj.NewInteractableState == InteractableState.ActionState)
			{
				_locomotive.WhistleButtonStateChanged();
			}
		}

		public void ReverseButtonStateChanged(InteractableStateArgs obj)
		{
			if (obj.NewInteractableState == InteractableState.ActionState)
			{
				_locomotive.ReverseButtonStateChanged();
			}
		}

		public void SwitchVisualization(InteractableStateArgs obj)
		{
			if (obj.NewInteractableState == InteractableState.ActionState)
			{
				HandsManager.Instance.SwitchVisualization();
			}
		}

		public void GoMoo(InteractableStateArgs obj)
		{
			if (obj.NewInteractableState == InteractableState.ActionState)
			{
				_cowController.GoMooCowGo();
			}
		}
	}
	public class CowController : MonoBehaviour
	{
		[SerializeField]
		private Animation _cowAnimation;

		[SerializeField]
		private AudioSource _mooCowAudioSource;

		private void Start()
		{
		}

		public void PlayMooSound()
		{
			_mooCowAudioSource.timeSamples = 0;
			_mooCowAudioSource.Play();
		}

		public void GoMooCowGo()
		{
			_cowAnimation.Rewind();
			_cowAnimation.Play();
		}
	}
	public class PanelHMDFollower : MonoBehaviour
	{
		private const float TOTAL_DURATION = 3f;

		private const float HMD_MOVEMENT_THRESHOLD = 0.3f;

		[SerializeField]
		private float _maxDistance = 0.3f;

		[SerializeField]
		private float _minDistance = 0.05f;

		[SerializeField]
		private float _minZDistance = 0.05f;

		private OVRCameraRig _cameraRig;

		private Vector3 _panelInitialPosition = Vector3.zero;

		private Coroutine _coroutine;

		private Vector3 _prevPos = Vector3.zero;

		private Vector3 _lastMovedToPos = Vector3.zero;

		private void Awake()
		{
			_cameraRig = UnityEngine.Object.FindObjectOfType<OVRCameraRig>();
			_panelInitialPosition = base.transform.position;
		}

		private void Update()
		{
			Vector3 position = _cameraRig.centerEyeAnchor.position;
			_ = base.transform.position;
			float num = Vector3.Distance(position, _lastMovedToPos);
			float num2 = (_cameraRig.centerEyeAnchor.position - _prevPos).magnitude / Time.deltaTime;
			Vector3 vector = base.transform.position - position;
			float magnitude = vector.magnitude;
			if ((num > _maxDistance || _minZDistance > vector.z || _minDistance > magnitude) && num2 < 0.3f && _coroutine == null && _coroutine == null)
			{
				_coroutine = StartCoroutine(LerpToHMD());
			}
			_prevPos = _cameraRig.centerEyeAnchor.position;
		}

		private Vector3 CalculateIdealAnchorPosition()
		{
			return _cameraRig.centerEyeAnchor.position + _panelInitialPosition;
		}

		private IEnumerator LerpToHMD()
		{
			Vector3 newPanelPosition = CalculateIdealAnchorPosition();
			_lastMovedToPos = _cameraRig.centerEyeAnchor.position;
			float startTime = Time.time;
			float endTime = Time.time + 3f;
			while (Time.time < endTime)
			{
				base.transform.position = Vector3.Lerp(base.transform.position, newPanelPosition, (Time.time - startTime) / 3f);
				yield return null;
			}
			base.transform.position = newPanelPosition;
			_coroutine = null;
		}
	}
	public class SelectionCylinder : MonoBehaviour
	{
		public enum SelectionState
		{
			Off,
			Selected,
			Highlighted
		}

		[SerializeField]
		private MeshRenderer _selectionMeshRenderer;

		private static int _colorId = Shader.PropertyToID("_Color");

		private Material[] _selectionMaterials;

		private Color[] _defaultSelectionColors;

		private Color[] _highlightColors;

		private SelectionState _currSelectionState;

		public SelectionState CurrSelectionState
		{
			get
			{
				return _currSelectionState;
			}
			set
			{
				SelectionState currSelectionState = _currSelectionState;
				_currSelectionState = value;
				if (currSelectionState != _currSelectionState)
				{
					if (_currSelectionState > SelectionState.Off)
					{
						_selectionMeshRenderer.enabled = true;
						AffectSelectionColor((_currSelectionState == SelectionState.Selected) ? _defaultSelectionColors : _highlightColors);
					}
					else
					{
						_selectionMeshRenderer.enabled = false;
					}
				}
			}
		}

		private void Awake()
		{
			_selectionMaterials = _selectionMeshRenderer.materials;
			int num = _selectionMaterials.Length;
			_defaultSelectionColors = new Color[num];
			_highlightColors = new Color[num];
			for (int i = 0; i < num; i++)
			{
				_defaultSelectionColors[i] = _selectionMaterials[i].GetColor(_colorId);
				_highlightColors[i] = new Color(1f, 1f, 1f, _defaultSelectionColors[i].a);
			}
			CurrSelectionState = SelectionState.Off;
		}

		private void OnDestroy()
		{
			if (_selectionMaterials == null)
			{
				return;
			}
			Material[] selectionMaterials = _selectionMaterials;
			foreach (Material material in selectionMaterials)
			{
				if (material != null)
				{
					UnityEngine.Object.Destroy(material);
				}
			}
		}

		private void AffectSelectionColor(Color[] newColors)
		{
			int num = newColors.Length;
			for (int i = 0; i < num; i++)
			{
				_selectionMaterials[i].SetColor(_colorId, newColors[i]);
			}
		}
	}
	public class TrackSegment : MonoBehaviour
	{
		public enum SegmentType
		{
			Straight,
			LeftTurn,
			RightTurn,
			Switch
		}

		[SerializeField]
		private SegmentType _segmentType;

		[SerializeField]
		private MeshFilter _straight;

		[SerializeField]
		private MeshFilter _leftTurn;

		[SerializeField]
		private MeshFilter _rightTurn;

		private float _gridSize = 0.8f;

		private int _subDivCount = 20;

		private const float _originalGridSize = 0.8f;

		private const float _trackWidth = 0.15f;

		private GameObject _mesh;

		private Pose _p1 = new Pose();

		private Pose _p2 = new Pose();

		private Pose _endPose = new Pose();

		public float StartDistance { get; set; }

		public float GridSize
		{
			get
			{
				return _gridSize;
			}
			private set
			{
				_gridSize = value;
			}
		}

		public int SubDivCount
		{
			get
			{
				return _subDivCount;
			}
			set
			{
				_subDivCount = value;
			}
		}

		public SegmentType Type => _segmentType;

		public Pose EndPose
		{
			get
			{
				UpdatePose(SegmentLength, _endPose);
				return _endPose;
			}
		}

		public float Radius => 0.5f * GridSize;

		public float SegmentLength
		{
			get
			{
				switch (Type)
				{
				case SegmentType.Straight:
					return GridSize;
				case SegmentType.LeftTurn:
				case SegmentType.RightTurn:
					return (float)Math.PI / 2f * Radius;
				default:
					return 1f;
				}
			}
		}

		public float setGridSize(float size)
		{
			GridSize = size;
			return GridSize / 0.8f;
		}

		private void Awake()
		{
		}

		public void UpdatePose(float distanceIntoSegment, Pose pose)
		{
			if (Type == SegmentType.Straight)
			{
				pose.Position = base.transform.position + distanceIntoSegment * base.transform.forward;
				pose.Rotation = base.transform.rotation;
			}
			else if (Type == SegmentType.LeftTurn)
			{
				float num = distanceIntoSegment / SegmentLength;
				float num2 = (float)Math.PI / 2f * num;
				Vector3 position = new Vector3(Radius * Mathf.Cos(num2) - Radius, 0f, Radius * Mathf.Sin(num2));
				Quaternion quaternion = Quaternion.Euler(0f, (0f - num2) * 57.29578f, 0f);
				pose.Position = base.transform.TransformPoint(position);
				pose.Rotation = base.transform.rotation * quaternion;
			}
			else if (Type == SegmentType.RightTurn)
			{
				float num3 = (float)Math.PI - (float)Math.PI / 2f * distanceIntoSegment / SegmentLength;
				Vector3 position2 = new Vector3(Radius * Mathf.Cos(num3) + Radius, 0f, Radius * Mathf.Sin(num3));
				Quaternion quaternion2 = Quaternion.Euler(0f, ((float)Math.PI - num3) * 57.29578f, 0f);
				pose.Position = base.transform.TransformPoint(position2);
				pose.Rotation = base.transform.rotation * quaternion2;
			}
			else
			{
				pose.Position = Vector3.zero;
				pose.Rotation = Quaternion.identity;
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			UnityEngine.Object.Destroy(_mesh);
		}

		private void DrawDebugLines()
		{
			for (int i = 1; i < SubDivCount + 1; i++)
			{
				float num = SegmentLength / (float)SubDivCount;
				UpdatePose((float)(i - 1) * num, _p1);
				UpdatePose((float)i * num, _p2);
				float num2 = 0.075f;
				UnityEngine.Debug.DrawLine(_p1.Position + num2 * (_p1.Rotation * Vector3.right), _p2.Position + num2 * (_p2.Rotation * Vector3.right));
				UnityEngine.Debug.DrawLine(_p1.Position - num2 * (_p1.Rotation * Vector3.right), _p2.Position - num2 * (_p2.Rotation * Vector3.right));
			}
			UnityEngine.Debug.DrawLine(base.transform.position - 0.5f * GridSize * base.transform.right, base.transform.position + 0.5f * GridSize * base.transform.right, Color.yellow);
			UnityEngine.Debug.DrawLine(base.transform.position - 0.5f * GridSize * base.transform.right, base.transform.position - 0.5f * GridSize * base.transform.right + GridSize * base.transform.forward, Color.yellow);
			UnityEngine.Debug.DrawLine(base.transform.position + 0.5f * GridSize * base.transform.right, base.transform.position + 0.5f * GridSize * base.transform.right + GridSize * base.transform.forward, Color.yellow);
			UnityEngine.Debug.DrawLine(base.transform.position - 0.5f * GridSize * base.transform.right + GridSize * base.transform.forward, base.transform.position + 0.5f * GridSize * base.transform.right + GridSize * base.transform.forward, Color.yellow);
		}

		public void RegenerateTrackAndMesh()
		{
			if (base.transform.childCount > 0 && !_mesh)
			{
				_mesh = base.transform.GetChild(0).gameObject;
			}
			if ((bool)_mesh)
			{
				UnityEngine.Object.DestroyImmediate(_mesh);
			}
			if (_segmentType == SegmentType.LeftTurn)
			{
				_mesh = UnityEngine.Object.Instantiate(_leftTurn.gameObject);
			}
			else if (_segmentType == SegmentType.RightTurn)
			{
				_mesh = UnityEngine.Object.Instantiate(_rightTurn.gameObject);
			}
			else
			{
				_mesh = UnityEngine.Object.Instantiate(_straight.gameObject);
			}
			_mesh.transform.SetParent(base.transform, worldPositionStays: false);
			_mesh.transform.position += GridSize / 2f * base.transform.forward;
			_mesh.transform.localScale = new Vector3(GridSize / 0.8f, GridSize / 0.8f, GridSize / 0.8f);
		}
	}
	public class TrainButtonVisualController : MonoBehaviour
	{
		private const float LERP_TO_OLD_POS_DURATION = 1f;

		private const float LOCAL_SIZE_HALVED = 0.5f;

		[SerializeField]
		private MeshRenderer _meshRenderer;

		[SerializeField]
		private MeshRenderer _glowRenderer;

		[SerializeField]
		private ButtonController _buttonController;

		[SerializeField]
		private Color _buttonContactColor = new Color(0.51f, 0.78f, 0.92f, 1f);

		[SerializeField]
		private Color _buttonActionColor = new Color(0.24f, 0.72f, 0.98f, 1f);

		[SerializeField]
		private AudioSource _audioSource;

		[SerializeField]
		private AudioClip _actionSoundEffect;

		[SerializeField]
		private Transform _buttonContactTransform;

		[SerializeField]
		private float _contactMaxDisplacementDistance = 0.0141f;

		private Material _buttonMaterial;

		private Color _buttonDefaultColor;

		private int _materialColorId;

		private bool _buttonInContactOrActionStates;

		private Coroutine _lerpToOldPositionCr;

		private Vector3 _oldPosition;

		private void Awake()
		{
			_materialColorId = Shader.PropertyToID("_Color");
			_buttonMaterial = _meshRenderer.material;
			_buttonDefaultColor = _buttonMaterial.GetColor(_materialColorId);
			_oldPosition = base.transform.localPosition;
		}

		private void OnDestroy()
		{
			if (_buttonMaterial != null)
			{
				UnityEngine.Object.Destroy(_buttonMaterial);
			}
		}

		private void OnEnable()
		{
			_buttonController.InteractableStateChanged.AddListener(InteractableStateChanged);
			_buttonController.ContactZoneEvent += ActionOrInContactZoneStayEvent;
			_buttonController.ActionZoneEvent += ActionOrInContactZoneStayEvent;
			_buttonInContactOrActionStates = false;
		}

		private void OnDisable()
		{
			if (_buttonController != null)
			{
				_buttonController.InteractableStateChanged.RemoveListener(InteractableStateChanged);
				_buttonController.ContactZoneEvent -= ActionOrInContactZoneStayEvent;
				_buttonController.ActionZoneEvent -= ActionOrInContactZoneStayEvent;
			}
		}

		private void ActionOrInContactZoneStayEvent(ColliderZoneArgs collisionArgs)
		{
			if (_buttonInContactOrActionStates && !collisionArgs.CollidingTool.IsFarFieldTool)
			{
				Vector3 localScale = _buttonContactTransform.localScale;
				Vector3 interactionPosition = collisionArgs.CollidingTool.InteractionPosition;
				float num = (_buttonContactTransform.InverseTransformPoint(interactionPosition) - 0.5f * Vector3.one).y * localScale.y;
				if (num > 0f - _contactMaxDisplacementDistance && num <= 0f)
				{
					base.transform.localPosition = new Vector3(_oldPosition.x, _oldPosition.y + num, _oldPosition.z);
				}
			}
		}

		private void InteractableStateChanged(InteractableStateArgs obj)
		{
			_buttonInContactOrActionStates = false;
			_glowRenderer.gameObject.SetActive(obj.NewInteractableState > InteractableState.Default);
			switch (obj.NewInteractableState)
			{
			case InteractableState.ContactState:
				StopResetLerping();
				_buttonMaterial.SetColor(_materialColorId, _buttonContactColor);
				_buttonInContactOrActionStates = true;
				break;
			case InteractableState.ProximityState:
				_buttonMaterial.SetColor(_materialColorId, _buttonDefaultColor);
				LerpToOldPosition();
				break;
			case InteractableState.ActionState:
				StopResetLerping();
				_buttonMaterial.SetColor(_materialColorId, _buttonActionColor);
				PlaySound(_actionSoundEffect);
				_buttonInContactOrActionStates = true;
				break;
			default:
				_buttonMaterial.SetColor(_materialColorId, _buttonDefaultColor);
				LerpToOldPosition();
				break;
			}
		}

		private void PlaySound(AudioClip clip)
		{
			_audioSource.timeSamples = 0;
			_audioSource.clip = clip;
			_audioSource.Play();
		}

		private void StopResetLerping()
		{
			if (_lerpToOldPositionCr != null)
			{
				StopCoroutine(_lerpToOldPositionCr);
			}
		}

		private void LerpToOldPosition()
		{
			if (!((base.transform.localPosition - _oldPosition).sqrMagnitude < Mathf.Epsilon))
			{
				StopResetLerping();
				_lerpToOldPositionCr = StartCoroutine(ResetPosition());
			}
		}

		private IEnumerator ResetPosition()
		{
			float startTime = Time.time;
			float endTime = Time.time + 1f;
			while (Time.time < endTime)
			{
				base.transform.localPosition = Vector3.Lerp(base.transform.localPosition, _oldPosition, (Time.time - startTime) / 1f);
				yield return null;
			}
			base.transform.localPosition = _oldPosition;
			_lerpToOldPositionCr = null;
		}
	}
	public class TrainCar : TrainCarBase
	{
		[SerializeField]
		private TrainCarBase _parentLocomotive;

		[SerializeField]
		protected float _distanceBehindParent = 0.1f;

		public float DistanceBehindParentScaled => scale * _distanceBehindParent;

		protected override void Awake()
		{
			base.Awake();
		}

		public override void UpdatePosition()
		{
			base.Distance = _parentLocomotive.Distance - DistanceBehindParentScaled;
			UpdateCarPosition();
			RotateCarWheels();
		}
	}
	public abstract class TrainCarBase : MonoBehaviour
	{
		private static Vector3 OFFSET = new Vector3(0f, 0.0195f, 0f);

		private const float WHEEL_RADIUS = 0.027f;

		private const float TWO_PI = (float)Math.PI * 2f;

		[SerializeField]
		protected Transform _frontWheels;

		[SerializeField]
		protected Transform _rearWheels;

		[SerializeField]
		protected TrainTrack _trainTrack;

		[SerializeField]
		protected Transform[] _individualWheels;

		protected float scale = 1f;

		private Pose _frontPose = new Pose();

		private Pose _rearPose = new Pose();

		public float Distance { get; protected set; }

		public float Scale
		{
			get
			{
				return scale;
			}
			set
			{
				scale = value;
			}
		}

		protected virtual void Awake()
		{
		}

		public void UpdatePose(float distance, TrainCarBase train, Pose pose)
		{
			distance = (train._trainTrack.TrackLength + distance) % train._trainTrack.TrackLength;
			if (distance < 0f)
			{
				distance += train._trainTrack.TrackLength;
			}
			TrackSegment segment = train._trainTrack.GetSegment(distance);
			float distanceIntoSegment = distance - segment.StartDistance;
			segment.UpdatePose(distanceIntoSegment, pose);
		}

		protected void UpdateCarPosition()
		{
			UpdatePose(Distance + _frontWheels.transform.localPosition.z * scale, this, _frontPose);
			UpdatePose(Distance + _rearWheels.transform.localPosition.z * scale, this, _rearPose);
			Vector3 vector = 0.5f * (_frontPose.Position + _rearPose.Position);
			Vector3 forward = _frontPose.Position - _rearPose.Position;
			base.transform.position = vector + OFFSET;
			base.transform.rotation = Quaternion.LookRotation(forward, base.transform.up);
			_frontWheels.transform.rotation = _frontPose.Rotation;
			_rearWheels.transform.rotation = _rearPose.Rotation;
		}

		protected void RotateCarWheels()
		{
			float num = Distance / 0.027f % ((float)Math.PI * 2f);
			Transform[] individualWheels = _individualWheels;
			for (int i = 0; i < individualWheels.Length; i++)
			{
				individualWheels[i].localRotation = Quaternion.AngleAxis(57.29578f * num, Vector3.right);
			}
		}

		public abstract void UpdatePosition();
	}
	public class TrainCrossingController : MonoBehaviour
	{
		[SerializeField]
		private AudioSource _audioSource;

		[SerializeField]
		private AudioClip[] _crossingSounds;

		[SerializeField]
		private MeshRenderer _lightSide1Renderer;

		[SerializeField]
		private MeshRenderer _lightSide2Renderer;

		[SerializeField]
		private SelectionCylinder _selectionCylinder;

		private Material _lightsSide1Mat;

		private Material _lightsSide2Mat;

		private int _colorId = Shader.PropertyToID("_Color");

		private Coroutine _xingAnimationCr;

		private InteractableTool _toolInteractingWithMe;

		private void Awake()
		{
			_lightsSide1Mat = _lightSide1Renderer.material;
			_lightsSide2Mat = _lightSide2Renderer.material;
		}

		private void OnDestroy()
		{
			if (_lightsSide1Mat != null)
			{
				UnityEngine.Object.Destroy(_lightsSide1Mat);
			}
			if (_lightsSide2Mat != null)
			{
				UnityEngine.Object.Destroy(_lightsSide2Mat);
			}
		}

		public void CrossingButtonStateChanged(InteractableStateArgs obj)
		{
			if (obj.NewInteractableState == InteractableState.ActionState)
			{
				ActivateTrainCrossing();
			}
			_toolInteractingWithMe = ((obj.NewInteractableState > InteractableState.Default) ? obj.Tool : null);
		}

		private void Update()
		{
			if (_toolInteractingWithMe == null)
			{
				_selectionCylinder.CurrSelectionState = SelectionCylinder.SelectionState.Off;
			}
			else
			{
				_selectionCylinder.CurrSelectionState = ((_toolInteractingWithMe.ToolInputState != ToolInputState.PrimaryInputDown && _toolInteractingWithMe.ToolInputState != ToolInputState.PrimaryInputDownStay) ? SelectionCylinder.SelectionState.Selected : SelectionCylinder.SelectionState.Highlighted);
			}
		}

		private void ActivateTrainCrossing()
		{
			int num = _crossingSounds.Length - 1;
			AudioClip audioClip = _crossingSounds[(int)(UnityEngine.Random.value * (float)num)];
			_audioSource.clip = audioClip;
			_audioSource.timeSamples = 0;
			_audioSource.Play();
			if (_xingAnimationCr != null)
			{
				StopCoroutine(_xingAnimationCr);
			}
			_xingAnimationCr = StartCoroutine(AnimateCrossing(audioClip.length * 0.75f));
		}

		private IEnumerator AnimateCrossing(float animationLength)
		{
			ToggleLightObjects(enableState: true);
			float animationEndTime = Time.time + animationLength;
			float lightBlinkDuration = animationLength * 0.1f;
			float lightBlinkStartTime = Time.time;
			float lightBlinkEndTime = Time.time + lightBlinkDuration;
			Material lightToBlinkOn = _lightsSide1Mat;
			Material lightToBlinkOff = _lightsSide2Mat;
			Color onColor = new Color(1f, 1f, 1f, 1f);
			Color offColor = new Color(1f, 1f, 1f, 0f);
			while (Time.time < animationEndTime)
			{
				float t = (Time.time - lightBlinkStartTime) / lightBlinkDuration;
				lightToBlinkOn.SetColor(_colorId, Color.Lerp(offColor, onColor, t));
				lightToBlinkOff.SetColor(_colorId, Color.Lerp(onColor, offColor, t));
				if (Time.time > lightBlinkEndTime)
				{
					Material material = lightToBlinkOn;
					lightToBlinkOn = lightToBlinkOff;
					lightToBlinkOff = material;
					lightBlinkStartTime = Time.time;
					lightBlinkEndTime = Time.time + lightBlinkDuration;
				}
				yield return null;
			}
			ToggleLightObjects(enableState: false);
		}

		private void AffectMaterials(Material[] materials, Color newColor)
		{
			for (int i = 0; i < materials.Length; i++)
			{
				materials[i].SetColor(_colorId, newColor);
			}
		}

		private void ToggleLightObjects(bool enableState)
		{
			_lightSide1Renderer.gameObject.SetActive(enableState);
			_lightSide2Renderer.gameObject.SetActive(enableState);
		}
	}
	public class TrainLocomotive : TrainCarBase
	{
		private enum EngineSoundState
		{
			Start,
			AccelerateOrSetProperSpeed,
			Stop
		}

		private const float MIN_SPEED = 0.2f;

		private const float MAX_SPEED = 2.7f;

		private const float SMOKE_SPEED_MULTIPLIER = 8f;

		private const int MAX_PARTICLES_MULTIPLIER = 3;

		[SerializeField]
		[Range(0.2f, 2.7f)]
		protected float _initialSpeed;

		[SerializeField]
		private GameObject _startStopButton;

		[SerializeField]
		private GameObject _decreaseSpeedButton;

		[SerializeField]
		private GameObject _increaseSpeedButton;

		[SerializeField]
		private GameObject _smokeButton;

		[SerializeField]
		private GameObject _whistleButton;

		[SerializeField]
		private GameObject _reverseButton;

		[SerializeField]
		private AudioSource _whistleAudioSource;

		[SerializeField]
		private AudioClip _whistleSound;

		[SerializeField]
		private AudioSource _engineAudioSource;

		[SerializeField]
		private AudioClip[] _accelerationSounds;

		[SerializeField]
		private AudioClip[] _decelerationSounds;

		[SerializeField]
		private AudioClip _startUpSound;

		[SerializeField]
		private AudioSource _smokeStackAudioSource;

		[SerializeField]
		private AudioClip _smokeSound;

		[SerializeField]
		private ParticleSystem _smoke1;

		[SerializeField]
		private ParticleSystem _smoke2;

		[SerializeField]
		private TrainCarBase[] _childCars;

		private bool _isMoving = true;

		private bool _reverse;

		private float _currentSpeed;

		private float _speedDiv;

		private float _standardRateOverTimeMultiplier;

		private int _standardMaxParticles;

		private Coroutine _startStopTrainCr;

		private void Start()
		{
			_standardRateOverTimeMultiplier = _smoke1.emission.rateOverTimeMultiplier;
			_standardMaxParticles = _smoke1.main.maxParticles;
			base.Distance = 0f;
			_speedDiv = 2.5f / (float)_accelerationSounds.Length;
			_currentSpeed = _initialSpeed;
			UpdateCarPosition();
			_smoke1.Stop();
			_startStopTrainCr = StartCoroutine(StartStopTrain(startTrain: true));
		}

		private void Update()
		{
			UpdatePosition();
		}

		public override void UpdatePosition()
		{
			if (_isMoving)
			{
				if (_trainTrack != null)
				{
					UpdateDistance();
					UpdateCarPosition();
					RotateCarWheels();
				}
				TrainCarBase[] childCars = _childCars;
				for (int i = 0; i < childCars.Length; i++)
				{
					childCars[i].UpdatePosition();
				}
			}
		}

		public void StartStopStateChanged()
		{
			if (_startStopTrainCr == null)
			{
				_startStopTrainCr = StartCoroutine(StartStopTrain(!_isMoving));
			}
		}

		private IEnumerator StartStopTrain(bool startTrain)
		{
			float endSpeed = (startTrain ? _initialSpeed : 0f);
			float timePeriodForSpeedChange2;
			if (startTrain)
			{
				_smoke1.Play();
				_isMoving = true;
				ParticleSystem.EmissionModule emission = _smoke1.emission;
				ParticleSystem.MainModule main = _smoke1.main;
				emission.rateOverTimeMultiplier = _standardRateOverTimeMultiplier;
				main.maxParticles = _standardMaxParticles;
				timePeriodForSpeedChange2 = PlayEngineSound(EngineSoundState.Start);
			}
			else
			{
				timePeriodForSpeedChange2 = PlayEngineSound(EngineSoundState.Stop);
			}
			_engineAudioSource.loop = false;
			timePeriodForSpeedChange2 *= 0.9f;
			float startTime = Time.time;
			float endTime = Time.time + timePeriodForSpeedChange2;
			float startSpeed = _currentSpeed;
			while (Time.time < endTime)
			{
				float num = (Time.time - startTime) / timePeriodForSpeedChange2;
				_currentSpeed = startSpeed * (1f - num) + endSpeed * num;
				UpdateSmokeEmissionBasedOnSpeed();
				yield return null;
			}
			_currentSpeed = endSpeed;
			_startStopTrainCr = null;
			_isMoving = startTrain;
			if (!_isMoving)
			{
				_smoke1.Stop();
				yield break;
			}
			_engineAudioSource.loop = true;
			PlayEngineSound(EngineSoundState.AccelerateOrSetProperSpeed);
		}

		private float PlayEngineSound(EngineSoundState engineSoundState)
		{
			AudioClip audioClip = null;
			if (engineSoundState == EngineSoundState.Start)
			{
				audioClip = _startUpSound;
			}
			else
			{
				AudioClip[] obj = ((engineSoundState == EngineSoundState.AccelerateOrSetProperSpeed) ? _accelerationSounds : _decelerationSounds);
				int num = obj.Length;
				int value = (int)Mathf.Round((_currentSpeed - 0.2f) / _speedDiv);
				audioClip = obj[Mathf.Clamp(value, 0, num - 1)];
			}
			if (_engineAudioSource.clip == audioClip && _engineAudioSource.isPlaying && engineSoundState == EngineSoundState.AccelerateOrSetProperSpeed)
			{
				return 0f;
			}
			_engineAudioSource.clip = audioClip;
			_engineAudioSource.timeSamples = 0;
			_engineAudioSource.Play();
			return audioClip.length;
		}

		private void UpdateDistance()
		{
			float num = (_reverse ? (0f - _currentSpeed) : _currentSpeed);
			base.Distance = (base.Distance + num * Time.deltaTime) % _trainTrack.TrackLength;
		}

		public void DecreaseSpeedStateChanged()
		{
			if (_startStopTrainCr == null && _isMoving)
			{
				_currentSpeed = Mathf.Clamp(_currentSpeed - _speedDiv, 0.2f, 2.7f);
				UpdateSmokeEmissionBasedOnSpeed();
				PlayEngineSound(EngineSoundState.AccelerateOrSetProperSpeed);
			}
		}

		public void IncreaseSpeedStateChanged()
		{
			if (_startStopTrainCr == null && _isMoving)
			{
				_currentSpeed = Mathf.Clamp(_currentSpeed + _speedDiv, 0.2f, 2.7f);
				UpdateSmokeEmissionBasedOnSpeed();
				PlayEngineSound(EngineSoundState.AccelerateOrSetProperSpeed);
			}
		}

		private void UpdateSmokeEmissionBasedOnSpeed()
		{
			ParticleSystem.EmissionModule emission = _smoke1.emission;
			emission.rateOverTimeMultiplier = GetCurrentSmokeEmission();
			ParticleSystem.MainModule main = _smoke1.main;
			main.maxParticles = (int)Mathf.Lerp(_standardMaxParticles, _standardMaxParticles * 3, _currentSpeed / 2.5f);
		}

		private float GetCurrentSmokeEmission()
		{
			return Mathf.Lerp(_standardRateOverTimeMultiplier, _standardRateOverTimeMultiplier * 8f, _currentSpeed / 2.5f);
		}

		public void SmokeButtonStateChanged()
		{
			if (_isMoving)
			{
				_smokeStackAudioSource.clip = _smokeSound;
				_smokeStackAudioSource.timeSamples = 0;
				_smokeStackAudioSource.Play();
				_smoke2.time = 0f;
				_smoke2.Play();
			}
		}

		public void WhistleButtonStateChanged()
		{
			if (_whistleSound != null)
			{
				_whistleAudioSource.clip = _whistleSound;
				_whistleAudioSource.timeSamples = 0;
				_whistleAudioSource.Play();
			}
		}

		public void ReverseButtonStateChanged()
		{
			_reverse = !_reverse;
		}
	}
	public class TrainTrack : MonoBehaviour
	{
		[SerializeField]
		private float _gridSize = 0.5f;

		[SerializeField]
		private int _subDivCount = 20;

		[SerializeField]
		private Transform _segmentParent;

		[SerializeField]
		private Transform _trainParent;

		[SerializeField]
		private bool _regnerateTrackMeshOnAwake;

		private float _trainLength = -1f;

		private TrackSegment[] _trackSegments;

		public float TrackLength
		{
			get
			{
				return _trainLength;
			}
			private set
			{
				_trainLength = value;
			}
		}

		private void Awake()
		{
			Regenerate();
		}

		public TrackSegment GetSegment(float distance)
		{
			int childCount = _segmentParent.childCount;
			for (int i = 0; i < childCount; i++)
			{
				TrackSegment trackSegment = _trackSegments[i];
				TrackSegment trackSegment2 = _trackSegments[(i + 1) % childCount];
				if (distance >= trackSegment.StartDistance && (distance < trackSegment2.StartDistance || i == childCount - 1))
				{
					return trackSegment;
				}
			}
			return null;
		}

		public void Regenerate()
		{
			_trackSegments = _segmentParent.GetComponentsInChildren<TrackSegment>();
			TrackLength = 0f;
			int childCount = _segmentParent.childCount;
			TrackSegment trackSegment = null;
			float scale = 0f;
			for (int i = 0; i < childCount; i++)
			{
				TrackSegment trackSegment2 = _trackSegments[i];
				trackSegment2.SubDivCount = _subDivCount;
				scale = trackSegment2.setGridSize(_gridSize);
				if (trackSegment != null)
				{
					Pose endPose = trackSegment.EndPose;
					trackSegment2.transform.position = endPose.Position;
					trackSegment2.transform.rotation = endPose.Rotation;
					trackSegment2.StartDistance = TrackLength;
				}
				if (_regnerateTrackMeshOnAwake)
				{
					trackSegment2.RegenerateTrackAndMesh();
				}
				TrackLength += trackSegment2.SegmentLength;
				trackSegment = trackSegment2;
			}
			SetScale(scale);
		}

		private void SetScale(float ratio)
		{
			_trainParent.localScale = new Vector3(ratio, ratio, ratio);
			TrainCar[] componentsInChildren = _trainParent.GetComponentsInChildren<TrainCar>();
			_trainParent.GetComponentInChildren<TrainLocomotive>().Scale = ratio;
			TrainCar[] array = componentsInChildren;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].Scale = ratio;
			}
		}
	}
	public class Pose
	{
		public Vector3 Position;

		public Quaternion Rotation;

		public Pose()
		{
			Position = Vector3.zero;
			Rotation = Quaternion.identity;
		}

		public Pose(Vector3 position, Quaternion rotation)
		{
			Position = position;
			Rotation = rotation;
		}
	}
	public class WindmillBladesController : MonoBehaviour
	{
		private const float MAX_TIME = 1f;

		[SerializeField]
		private AudioSource _audioSource;

		[SerializeField]
		private AudioClip _windMillRotationSound;

		[SerializeField]
		private AudioClip _windMillStartSound;

		[SerializeField]
		private AudioClip _windMillStopSound;

		private float _currentSpeed;

		private Coroutine _lerpSpeedCoroutine;

		private Coroutine _audioChangeCr;

		private Quaternion _originalRotation;

		private float _rotAngle;

		public bool IsMoving { get; private set; }

		private void Start()
		{
			_originalRotation = base.transform.localRotation;
		}

		private void Update()
		{
			_rotAngle += _currentSpeed * Time.deltaTime;
			if (_rotAngle > 360f)
			{
				_rotAngle = 0f;
			}
			base.transform.localRotation = _originalRotation * Quaternion.AngleAxis(_rotAngle, Vector3.forward);
		}

		public void SetMoveState(bool newMoveState, float goalSpeed)
		{
			IsMoving = newMoveState;
			if (_lerpSpeedCoroutine != null)
			{
				StopCoroutine(_lerpSpeedCoroutine);
			}
			_lerpSpeedCoroutine = StartCoroutine(LerpToSpeed(goalSpeed));
		}

		private IEnumerator LerpToSpeed(float goalSpeed)
		{
			float totalTime = 0f;
			float startSpeed = _currentSpeed;
			if (_audioChangeCr != null)
			{
				StopCoroutine(_audioChangeCr);
			}
			if (IsMoving)
			{
				_audioChangeCr = StartCoroutine(PlaySoundDelayed(_windMillStartSound, _windMillRotationSound, _windMillStartSound.length * 0.95f));
			}
			else
			{
				PlaySound(_windMillStopSound);
			}
			for (float num = Mathf.Abs(_currentSpeed - goalSpeed); num > Mathf.Epsilon; num = Mathf.Abs(_currentSpeed - goalSpeed))
			{
				_currentSpeed = Mathf.Lerp(startSpeed, goalSpeed, totalTime / 1f);
				totalTime += Time.deltaTime;
				yield return null;
			}
			_lerpSpeedCoroutine = null;
		}

		private IEnumerator PlaySoundDelayed(AudioClip initial, AudioClip clip, float timeDelayAfterInitial)
		{
			PlaySound(initial);
			yield return new WaitForSeconds(timeDelayAfterInitial);
			PlaySound(clip, loop: true);
		}

		private void PlaySound(AudioClip clip, bool loop = false)
		{
			_audioSource.loop = loop;
			_audioSource.timeSamples = 0;
			_audioSource.clip = clip;
			_audioSource.Play();
		}
	}
	public class WindmillController : MonoBehaviour
	{
		[SerializeField]
		private GameObject _startStopButton;

		[SerializeField]
		private float _maxSpeed = 10f;

		[SerializeField]
		private SelectionCylinder _selectionCylinder;

		private WindmillBladesController _bladesRotation;

		private InteractableTool _toolInteractingWithMe;

		private void Awake()
		{
			_bladesRotation = GetComponentInChildren<WindmillBladesController>();
			_bladesRotation.SetMoveState(newMoveState: true, _maxSpeed);
		}

		private void OnEnable()
		{
			_startStopButton.GetComponent<Interactable>().InteractableStateChanged.AddListener(StartStopStateChanged);
		}

		private void OnDisable()
		{
			if (_startStopButton != null)
			{
				_startStopButton.GetComponent<Interactable>().InteractableStateChanged.RemoveListener(StartStopStateChanged);
			}
		}

		private void StartStopStateChanged(InteractableStateArgs obj)
		{
			if (obj.NewInteractableState == InteractableState.ActionState)
			{
				if (_bladesRotation.IsMoving)
				{
					_bladesRotation.SetMoveState(newMoveState: false, 0f);
				}
				else
				{
					_bladesRotation.SetMoveState(newMoveState: true, _maxSpeed);
				}
			}
			_toolInteractingWithMe = ((obj.NewInteractableState > InteractableState.Default) ? obj.Tool : null);
		}

		private void Update()
		{
			if (_toolInteractingWithMe == null)
			{
				_selectionCylinder.CurrSelectionState = SelectionCylinder.SelectionState.Off;
			}
			else
			{
				_selectionCylinder.CurrSelectionState = ((_toolInteractingWithMe.ToolInputState != ToolInputState.PrimaryInputDown && _toolInteractingWithMe.ToolInputState != ToolInputState.PrimaryInputDownStay) ? SelectionCylinder.SelectionState.Selected : SelectionCylinder.SelectionState.Highlighted);
			}
		}
	}
	public enum EUiDisplayType
	{
		EUDT_WorldGeoQuad,
		EUDT_OverlayQuad,
		EUDT_None,
		EUDT_MaxDislayTypes
	}
	public class OVROverlaySample : MonoBehaviour
	{
		private bool inMenu;

		private const string ovrOverlayID = "OVROverlayID";

		private const string applicationID = "ApplicationID";

		private const string noneID = "NoneID";

		private Toggle applicationRadioButton;

		private Toggle noneRadioButton;

		[Header("App vs Compositor Comparison Settings")]
		public GameObject mainCamera;

		public GameObject uiCamera;

		public GameObject uiGeoParent;

		public GameObject worldspaceGeoParent;

		public OVROverlay cameraRenderOverlay;

		public OVROverlay renderingLabelOverlay;

		public Texture applicationLabelTexture;

		public Texture compositorLabelTexture;

		[Header("Level Loading Sim Settings")]
		public GameObject prefabForLevelLoadSim;

		public OVROverlay cubemapOverlay;

		public OVROverlay loadingTextQuadOverlay;

		public float distanceFromCamToLoadText;

		public float cubeSpawnRadius;

		public float heightBetweenItems;

		public int numObjectsPerLevel;

		public int numLevels;

		public int numLoopsTrigger = 500000000;

		private List<GameObject> spawnedCubes = new List<GameObject>();

		private void Start()
		{
			DebugUIBuilder.instance.AddLabel("OVROverlay Sample");
			DebugUIBuilder.instance.AddDivider();
			DebugUIBuilder.instance.AddLabel("Level Loading Example");
			DebugUIBuilder.instance.AddButton("Simulate Level Load", TriggerLoad);
			DebugUIBuilder.instance.AddButton("Destroy Cubes", TriggerUnload);
			DebugUIBuilder.instance.AddDivider();
			DebugUIBuilder.instance.AddLabel("OVROverlay vs. Application Render Comparison");
			DebugUIBuilder.instance.AddRadio("OVROverlay", "group", delegate(Toggle t)
			{
				RadioPressed("OVROverlayID", "group", t);
			}).GetComponentInChildren<Toggle>();
			applicationRadioButton = DebugUIBuilder.instance.AddRadio("Application", "group", delegate(Toggle t)
			{
				RadioPressed("ApplicationID", "group", t);
			}).GetComponentInChildren<Toggle>();
			noneRadioButton = DebugUIBuilder.instance.AddRadio("None", "group", delegate(Toggle t)
			{
				RadioPressed("NoneID", "group", t);
			}).GetComponentInChildren<Toggle>();
			DebugUIBuilder.instance.Show();
			CameraAndRenderTargetSetup();
			cameraRenderOverlay.enabled = true;
			cameraRenderOverlay.currentOverlayShape = OVROverlay.OverlayShape.Quad;
			spawnedCubes.Capacity = numObjectsPerLevel * numLevels;
		}

		private void Update()
		{
			if (OVRInput.GetDown(OVRInput.Button.Two) || OVRInput.GetDown(OVRInput.Button.Start))
			{
				if (inMenu)
				{
					DebugUIBuilder.instance.Hide();
				}
				else
				{
					DebugUIBuilder.instance.Show();
				}
				inMenu = !inMenu;
			}
			if (Input.GetKeyDown(KeyCode.A))
			{
				TriggerLoad();
			}
		}

		private void ActivateWorldGeo()
		{
			worldspaceGeoParent.SetActive(value: true);
			uiGeoParent.SetActive(value: false);
			uiCamera.SetActive(value: false);
			cameraRenderOverlay.enabled = false;
			renderingLabelOverlay.enabled = true;
			renderingLabelOverlay.textures[0] = applicationLabelTexture;
			UnityEngine.Debug.Log("Switched to ActivateWorldGeo");
		}

		private void ActivateOVROverlay()
		{
			worldspaceGeoParent.SetActive(value: false);
			uiCamera.SetActive(value: true);
			cameraRenderOverlay.enabled = true;
			uiGeoParent.SetActive(value: true);
			renderingLabelOverlay.enabled = true;
			renderingLabelOverlay.textures[0] = compositorLabelTexture;
			UnityEngine.Debug.Log("Switched to ActivateOVROVerlay");
		}

		private void ActivateNone()
		{
			worldspaceGeoParent.SetActive(value: false);
			uiCamera.SetActive(value: false);
			cameraRenderOverlay.enabled = false;
			uiGeoParent.SetActive(value: false);
			renderingLabelOverlay.enabled = false;
			UnityEngine.Debug.Log("Switched to ActivateNone");
		}

		private void TriggerLoad()
		{
			StartCoroutine(WaitforOVROverlay());
		}

		private IEnumerator WaitforOVROverlay()
		{
			Transform transform = mainCamera.transform;
			Transform obj = loadingTextQuadOverlay.transform;
			Vector3 position = transform.position + transform.forward * distanceFromCamToLoadText;
			position.y = transform.position.y;
			obj.position = position;
			cubemapOverlay.enabled = true;
			loadingTextQuadOverlay.enabled = true;
			noneRadioButton.isOn = true;
			yield return new WaitForSeconds(0.1f);
			ClearObjects();
			SimulateLevelLoad();
			cubemapOverlay.enabled = false;
			loadingTextQuadOverlay.enabled = false;
			yield return null;
		}

		private void TriggerUnload()
		{
			ClearObjects();
			applicationRadioButton.isOn = true;
		}

		private void CameraAndRenderTargetSetup()
		{
			float x = cameraRenderOverlay.transform.localScale.x;
			float y = cameraRenderOverlay.transform.localScale.y;
			float z = cameraRenderOverlay.transform.localScale.z;
			float num = 1440f;
			float num2 = 2560f * 0.5f;
			float num3 = mainCamera.GetComponent<Camera>().fieldOfView / 2f;
			float num4 = 2f * z * Mathf.Tan((float)Math.PI / 180f * num3);
			float num5 = num / num4 * x;
			float num6 = 0f;
			float num7 = num4 * mainCamera.GetComponent<Camera>().aspect;
			num6 = num2 / num7 * x;
			float orthographicSize = y / 2f;
			float aspect = x / y;
			uiCamera.GetComponent<Camera>().orthographicSize = orthographicSize;
			uiCamera.GetComponent<Camera>().aspect = aspect;
			if (uiCamera.GetComponent<Camera>().targetTexture != null)
			{
				uiCamera.GetComponent<Camera>().targetTexture.Release();
			}
			RenderTexture renderTexture = new RenderTexture((int)num6 * 2, (int)num5 * 2, 0, RenderTextureFormat.ARGB32, RenderTextureReadWrite.sRGB);
			UnityEngine.Debug.Log("Created RT of resolution w: " + num6 + " and h: " + num5);
			renderTexture.hideFlags = HideFlags.DontSave;
			renderTexture.useMipMap = true;
			renderTexture.filterMode = FilterMode.Trilinear;
			renderTexture.anisoLevel = 4;
			renderTexture.autoGenerateMips = true;
			uiCamera.GetComponent<Camera>().targetTexture = renderTexture;
			cameraRenderOverlay.textures[0] = renderTexture;
		}

		private void SimulateLevelLoad()
		{
			int num = 0;
			for (int i = 0; i < numLoopsTrigger; i++)
			{
				num++;
			}
			UnityEngine.Debug.Log("Finished " + num + " Loops");
			Vector3 position = mainCamera.transform.position;
			position.y = 0.5f;
			for (int j = 0; j < numLevels; j++)
			{
				for (int k = 0; k < numObjectsPerLevel; k++)
				{
					float f = (float)k * (float)Math.PI * 2f / (float)numObjectsPerLevel;
					float num2 = ((k % 2 == 0) ? 1.5f : 1f);
					Vector3 vector = new Vector3(Mathf.Cos(f), 0f, Mathf.Sin(f)) * cubeSpawnRadius * num2;
					vector.y = (float)j * heightBetweenItems;
					GameObject gameObject = UnityEngine.Object.Instantiate(prefabForLevelLoadSim, vector + position, Quaternion.identity);
					Transform obj = gameObject.transform;
					obj.LookAt(position);
					Vector3 eulerAngles = obj.rotation.eulerAngles;
					eulerAngles.x = 0f;
					obj.rotation = Quaternion.Euler(eulerAngles);
					spawnedCubes.Add(gameObject);
				}
			}
		}

		private void ClearObjects()
		{
			for (int i = 0; i < spawnedCubes.Count; i++)
			{
				UnityEngine.Object.DestroyImmediate(spawnedCubes[i]);
			}
			spawnedCubes.Clear();
			GC.Collect();
		}

		public void RadioPressed(string radioLabel, string group, Toggle t)
		{
			if (string.Compare(radioLabel, "OVROverlayID") == 0)
			{
				ActivateOVROverlay();
			}
			else if (string.Compare(radioLabel, "ApplicationID") == 0)
			{
				ActivateWorldGeo();
			}
			else if (string.Compare(radioLabel, "NoneID") == 0)
			{
				ActivateNone();
			}
		}
	}
}
namespace OVRTouchSample
{
	[RequireComponent(typeof(OVRGrabber))]
	public class Hand : MonoBehaviour
	{
		public const string ANIM_LAYER_NAME_POINT = "Point Layer";

		public const string ANIM_LAYER_NAME_THUMB = "Thumb Layer";

		public const string ANIM_PARAM_NAME_FLEX = "Flex";

		public const string ANIM_PARAM_NAME_POSE = "Pose";

		public const float THRESH_COLLISION_FLEX = 0.9f;

		public const float INPUT_RATE_CHANGE = 20f;

		public const float COLLIDER_SCALE_MIN = 0.01f;

		public const float COLLIDER_SCALE_MAX = 1f;

		public const float COLLIDER_SCALE_PER_SECOND = 1f;

		public const float TRIGGER_DEBOUNCE_TIME = 0.05f;

		public const float THUMB_DEBOUNCE_TIME = 0.15f;

		[SerializeField]
		private OVRInput.Controller m_controller;

		[SerializeField]
		private Animator m_animator;

		[SerializeField]
		private HandPose m_defaultGrabPose;

		private Collider[] m_colliders;

		private bool m_collisionEnabled = true;

		private OVRGrabber m_grabber;

		private List<Renderer> m_showAfterInputFocusAcquired;

		private int m_animLayerIndexThumb = -1;

		private int m_animLayerIndexPoint = -1;

		private int m_animParamIndexFlex = -1;

		private int m_animParamIndexPose = -1;

		private bool m_isPointing;

		private bool m_isGivingThumbsUp;

		private float m_pointBlend;

		private float m_thumbsUpBlend;

		private bool m_restoreOnInputAcquired;

		private float m_collisionScaleCurrent;

		private void Awake()
		{
			m_grabber = GetComponent<OVRGrabber>();
		}

		private void Start()
		{
			m_showAfterInputFocusAcquired = new List<Renderer>();
			m_colliders = (from childCollider in GetComponentsInChildren<Collider>()
				where !childCollider.isTrigger
				select childCollider).ToArray();
			CollisionEnable(enabled: false);
			m_animLayerIndexPoint = m_animator.GetLayerIndex("Point Layer");
			m_animLayerIndexThumb = m_animator.GetLayerIndex("Thumb Layer");
			m_animParamIndexFlex = Animator.StringToHash("Flex");
			m_animParamIndexPose = Animator.StringToHash("Pose");
			OVRManager.InputFocusAcquired += OnInputFocusAcquired;
			OVRManager.InputFocusLost += OnInputFocusLost;
		}

		private void OnDestroy()
		{
			OVRManager.InputFocusAcquired -= OnInputFocusAcquired;
			OVRManager.InputFocusLost -= OnInputFocusLost;
		}

		private void Update()
		{
			UpdateCapTouchStates();
			m_pointBlend = InputValueRateChange(m_isPointing, m_pointBlend);
			m_thumbsUpBlend = InputValueRateChange(m_isGivingThumbsUp, m_thumbsUpBlend);
			float num = OVRInput.Get(OVRInput.Axis1D.PrimaryHandTrigger, m_controller);
			bool flag = m_grabber.grabbedObject == null && num >= 0.9f;
			CollisionEnable(flag);
			UpdateAnimStates();
		}

		private void UpdateCapTouchStates()
		{
			m_isPointing = !OVRInput.Get(OVRInput.NearTouch.PrimaryIndexTrigger, m_controller);
			m_isGivingThumbsUp = !OVRInput.Get(OVRInput.NearTouch.PrimaryThumbButtons, m_controller);
		}

		private void LateUpdate()
		{
			if (m_collisionEnabled && m_collisionScaleCurrent + Mathf.Epsilon < 1f)
			{
				m_collisionScaleCurrent = Mathf.Min(1f, m_collisionScaleCurrent + Time.deltaTime * 1f);
				for (int i = 0; i < m_colliders.Length; i++)
				{
					m_colliders[i].transform.localScale = new Vector3(m_collisionScaleCurrent, m_collisionScaleCurrent, m_collisionScaleCurrent);
				}
			}
		}

		private void OnInputFocusLost()
		{
			if (!base.gameObject.activeInHierarchy)
			{
				return;
			}
			m_showAfterInputFocusAcquired.Clear();
			Renderer[] componentsInChildren = GetComponentsInChildren<Renderer>();
			for (int i = 0; i < componentsInChildren.Length; i++)
			{
				if (componentsInChildren[i].enabled)
				{
					componentsInChildren[i].enabled = false;
					m_showAfterInputFocusAcquired.Add(componentsInChildren[i]);
				}
			}
			CollisionEnable(enabled: false);
			m_restoreOnInputAcquired = true;
		}

		private void OnInputFocusAcquired()
		{
			if (!m_restoreOnInputAcquired)
			{
				return;
			}
			for (int i = 0; i < m_showAfterInputFocusAcquired.Count; i++)
			{
				if ((bool)m_showAfterInputFocusAcquired[i])
				{
					m_showAfterInputFocusAcquired[i].enabled = true;
				}
			}
			m_showAfterInputFocusAcquired.Clear();
			m_restoreOnInputAcquired = false;
		}

		private float InputValueRateChange(bool isDown, float value)
		{
			float num = Time.deltaTime * 20f;
			float num2 = (isDown ? 1f : (-1f));
			return Mathf.Clamp01(value + num * num2);
		}

		private void UpdateAnimStates()
		{
			bool num = m_grabber.grabbedObject != null;
			HandPose handPose = m_defaultGrabPose;
			if (num)
			{
				HandPose component = m_grabber.grabbedObject.GetComponent<HandPose>();
				if (component != null)
				{
					handPose = component;
				}
			}
			HandPoseId poseId = handPose.PoseId;
			m_animator.SetInteger(m_animParamIndexPose, (int)poseId);
			float value = OVRInput.Get(OVRInput.Axis1D.PrimaryHandTrigger, m_controller);
			m_animator.SetFloat(m_animParamIndexFlex, value);
			float weight = ((!num || handPose.AllowPointing) ? m_pointBlend : 0f);
			m_animator.SetLayerWeight(m_animLayerIndexPoint, weight);
			float weight2 = ((!num || handPose.AllowThumbsUp) ? m_thumbsUpBlend : 0f);
			m_animator.SetLayerWeight(m_animLayerIndexThumb, weight2);
			float value2 = OVRInput.Get(OVRInput.Axis1D.PrimaryIndexTrigger, m_controller);
			m_animator.SetFloat("Pinch", value2);
		}

		private void CollisionEnable(bool enabled)
		{
			if (m_collisionEnabled == enabled)
			{
				return;
			}
			m_collisionEnabled = enabled;
			if (enabled)
			{
				m_collisionScaleCurrent = 0.01f;
				for (int i = 0; i < m_colliders.Length; i++)
				{
					Collider obj = m_colliders[i];
					obj.transform.localScale = new Vector3(0.01f, 0.01f, 0.01f);
					obj.enabled = true;
				}
			}
			else
			{
				m_collisionScaleCurrent = 1f;
				for (int j = 0; j < m_colliders.Length; j++)
				{
					Collider obj2 = m_colliders[j];
					obj2.enabled = false;
					obj2.transform.localScale = new Vector3(0.01f, 0.01f, 0.01f);
				}
			}
		}
	}
	public enum HandPoseId
	{
		Default,
		Generic,
		PingPongBall,
		Controller
	}
	public class HandPose : MonoBehaviour
	{
		[SerializeField]
		private bool m_allowPointing;

		[SerializeField]
		private bool m_allowThumbsUp;

		[SerializeField]
		private HandPoseId m_poseId;

		public bool AllowPointing => m_allowPointing;

		public bool AllowThumbsUp => m_allowThumbsUp;

		public HandPoseId PoseId => m_poseId;
	}
	public class TouchController : MonoBehaviour
	{
		[SerializeField]
		private OVRInput.Controller m_controller;

		[SerializeField]
		private Animator m_animator;

		private bool m_restoreOnInputAcquired;

		private void Update()
		{
			m_animator.SetFloat("Button 1", OVRInput.Get(OVRInput.Button.One, m_controller) ? 1f : 0f);
			m_animator.SetFloat("Button 2", OVRInput.Get(OVRInput.Button.Two, m_controller) ? 1f : 0f);
			m_animator.SetFloat("Joy X", OVRInput.Get(OVRInput.Axis2D.PrimaryThumbstick, m_controller).x);
			m_animator.SetFloat("Joy Y", OVRInput.Get(OVRInput.Axis2D.PrimaryThumbstick, m_controller).y);
			m_animator.SetFloat("Grip", OVRInput.Get(OVRInput.Axis1D.PrimaryHandTrigger, m_controller));
			m_animator.SetFloat("Trigger", OVRInput.Get(OVRInput.Axis1D.PrimaryIndexTrigger, m_controller));
			OVRManager.InputFocusAcquired += OnInputFocusAcquired;
			OVRManager.InputFocusLost += OnInputFocusLost;
		}

		private void OnInputFocusLost()
		{
			if (base.gameObject.activeInHierarchy)
			{
				base.gameObject.SetActive(value: false);
				m_restoreOnInputAcquired = true;
			}
		}

		private void OnInputFocusAcquired()
		{
			if (m_restoreOnInputAcquired)
			{
				base.gameObject.SetActive(value: true);
				m_restoreOnInputAcquired = false;
			}
		}
	}
}
namespace Oculus.Spatializer.Propagation
{
	public enum FaceType : uint
	{
		TRIANGLES,
		QUADS
	}
	public enum MaterialProperty : uint
	{
		ABSORPTION,
		TRANSMISSION,
		SCATTERING
	}
	[StructLayout(LayoutKind.Sequential, Pack = 1)]
	public struct MeshGroup
	{
		public UIntPtr indexOffset;

		public UIntPtr faceCount;

		[MarshalAs(UnmanagedType.U4)]
		public FaceType faceType;

		public IntPtr material;
	}
}
namespace Oculus.Avatar
{
	public static class AvatarLogger
	{
		public const string LogAvatar = "[Avatars] - ";

		public const string Tab = "    ";

		[Conditional("ENABLE_AVATAR_LOGS")]
		[Conditional("ENABLE_AVATAR_LOG_BASIC")]
		public static void Log(string logMsg)
		{
			UnityEngine.Debug.Log("[Avatars] - " + logMsg);
		}

		[Conditional("ENABLE_AVATAR_LOGS")]
		[Conditional("ENABLE_AVATAR_LOG_BASIC")]
		public static void Log(string logMsg, UnityEngine.Object context)
		{
			UnityEngine.Debug.Log("[Avatars] - " + logMsg, context);
		}

		[Conditional("ENABLE_AVATAR_LOGS")]
		[Conditional("ENABLE_AVATAR_LOG_WARNING")]
		public static void LogWarning(string logMsg)
		{
			UnityEngine.Debug.LogWarning("[Avatars] - " + logMsg);
		}

		[Conditional("ENABLE_AVATAR_LOGS")]
		[Conditional("ENABLE_AVATAR_LOG_ERROR")]
		public static void LogError(string logMsg)
		{
			UnityEngine.Debug.LogError("[Avatars] - " + logMsg);
		}

		[Conditional("ENABLE_AVATAR_LOGS")]
		[Conditional("ENABLE_AVATAR_LOG_ERROR")]
		public static void LogError(string logMsg, UnityEngine.Object context)
		{
			UnityEngine.Debug.LogError("[Avatars] - " + logMsg, context);
		}
	}
	public class CAPI
	{
		public delegate void LoggingDelegate(IntPtr str);

		public enum Result
		{
			Success = 0,
			Failure = -1000,
			Failure_InvalidParameter = -1001,
			Failure_NotInitialized = -1002,
			Failure_InvalidOperation = -1003,
			Failure_Unsupported = -1004,
			Failure_NotYetImplemented = -1005,
			Failure_OperationFailed = -1006,
			Failure_InsufficientSize = -1007
		}

		private static class OVRP_1_30_0
		{
			public static readonly Version version = new Version(1, 30, 0);

			[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
			public static extern Result ovrp_SendEvent2(string name, string param, string source);
		}

		private const string LibFile = "ovravatarloader";

		private static IntPtr nativeVisemeData = IntPtr.Zero;

		private static IntPtr nativeGazeTargetsData = IntPtr.Zero;

		private static IntPtr nativeAvatarLightsData = IntPtr.Zero;

		private static IntPtr DebugLineCountData = IntPtr.Zero;

		private static float[] scratchBufferFloat = new float[16];

		private static GameObject debugLineGo;

		private static string SDKRuntimePrefix = "[RUNTIME] - ";

		private const string ovrPluginDLL = "OVRPlugin";

		private static Version ovrPluginVersion;

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_InitializeAndroidUnity(string appID);

		public static void Initialize()
		{
			nativeVisemeData = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(ovrAvatarVisemes)));
			nativeGazeTargetsData = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(ovrAvatarGazeTargets)));
			nativeAvatarLightsData = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(ovrAvatarLights)));
			DebugLineCountData = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(uint)));
			debugLineGo = new GameObject();
			debugLineGo.name = "AvatarSDKDebugDrawHelper";
		}

		public static void Shutdown()
		{
			Marshal.FreeHGlobal(nativeVisemeData);
			Marshal.FreeHGlobal(nativeGazeTargetsData);
			Marshal.FreeHGlobal(nativeAvatarLightsData);
			Marshal.FreeHGlobal(DebugLineCountData);
			debugLineGo = null;
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_Shutdown();

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovrAvatarMessage_Pop();

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarMessageType ovrAvatarMessage_GetType(IntPtr msg);

		public static ovrAvatarMessage_AvatarSpecification ovrAvatarMessage_GetAvatarSpecification(IntPtr msg)
		{
			return (ovrAvatarMessage_AvatarSpecification)Marshal.PtrToStructure(ovrAvatarMessage_GetAvatarSpecification_Native(msg), typeof(ovrAvatarMessage_AvatarSpecification));
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarMessage_GetAvatarSpecification")]
		private static extern IntPtr ovrAvatarMessage_GetAvatarSpecification_Native(IntPtr msg);

		public static ovrAvatarMessage_AssetLoaded ovrAvatarMessage_GetAssetLoaded(IntPtr msg)
		{
			return (ovrAvatarMessage_AssetLoaded)Marshal.PtrToStructure(ovrAvatarMessage_GetAssetLoaded_Native(msg), typeof(ovrAvatarMessage_AssetLoaded));
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarMessage_GetAssetLoaded")]
		private static extern IntPtr ovrAvatarMessage_GetAssetLoaded_Native(IntPtr msg);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatarMessage_Free(IntPtr msg);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovrAvatarSpecificationRequest_Create(ulong userID);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatarSpecificationRequest_Destroy(IntPtr specificationRequest);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatarSpecificationRequest_SetCombineMeshes(IntPtr specificationRequest, bool useCombinedMesh);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatarSpecificationRequest_SetLookAndFeelVersion(IntPtr specificationRequest, ovrAvatarLookAndFeelVersion version);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatarSpecificationRequest_SetLevelOfDetail(IntPtr specificationRequest, ovrAvatarAssetLevelOfDetail lod);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_RequestAvatarSpecification(ulong userID);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_RequestAvatarSpecificationFromSpecRequest(IntPtr specificationRequest);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatarSpecificationRequest_SetFallbackLookAndFeelVersion(IntPtr specificationRequest, ovrAvatarLookAndFeelVersion version);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatarSpecificationRequest_SetExpressiveFlag(IntPtr specificationRequest, bool enable);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovrAvatar_Create(IntPtr avatarSpecification, ovrAvatarCapabilities capabilities);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_Destroy(IntPtr avatar);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatarPose_UpdateBody(IntPtr avatar, ovrAvatarTransform headPose);

		public static void ovrAvatarPose_UpdateVoiceVisualization(IntPtr avatar, float[] pcmData)
		{
			ovrAvatarPose_UpdateVoiceVisualization_Native(avatar, (uint)pcmData.Length, pcmData);
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarPose_UpdateVoiceVisualization")]
		private static extern void ovrAvatarPose_UpdateVoiceVisualization_Native(IntPtr avatar, uint pcmDataSize, [In] float[] pcmData);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatarPose_UpdateHands(IntPtr avatar, ovrAvatarHandInputState inputStateLeft, ovrAvatarHandInputState inputStateRight);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatarPose_UpdateHandsWithType(IntPtr avatar, ovrAvatarHandInputState inputStateLeft, ovrAvatarHandInputState inputStateRight, ovrAvatarControllerType type);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatarPose_Finalize(IntPtr avatar, float elapsedSeconds);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_SetLeftControllerVisibility(IntPtr avatar, bool show);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_SetRightControllerVisibility(IntPtr avatar, bool show);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_SetLeftHandVisibility(IntPtr avatar, bool show);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_SetRightHandVisibility(IntPtr avatar, bool show);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovrAvatarComponent_Count(IntPtr avatar);

		public static void ovrAvatarComponent_Get(IntPtr avatar, uint index, bool includeName, ref ovrAvatarComponent component)
		{
			ovrAvatarComponent_Get(ovrAvatarComponent_Get_Native(avatar, index), includeName, ref component);
		}

		public static void ovrAvatarComponent_Get(IntPtr componentPtr, bool includeName, ref ovrAvatarComponent component)
		{
			Marshal.Copy(new IntPtr(componentPtr.ToInt64() + ovrAvatarComponent_Offsets.transform), scratchBufferFloat, 0, 10);
			OvrAvatar.ConvertTransform(scratchBufferFloat, ref component.transform);
			component.renderPartCount = (uint)Marshal.ReadInt32(componentPtr, ovrAvatarComponent_Offsets.renderPartCount);
			component.renderParts = Marshal.ReadIntPtr(componentPtr, ovrAvatarComponent_Offsets.renderParts);
			if (includeName)
			{
				IntPtr ptr = Marshal.ReadIntPtr(componentPtr, ovrAvatarComponent_Offsets.name);
				component.name = Marshal.PtrToStringAnsi(ptr);
			}
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarComponent_Get")]
		public static extern IntPtr ovrAvatarComponent_Get_Native(IntPtr avatar, uint index);

		public static bool ovrAvatarPose_GetBaseComponent(IntPtr avatar, ref ovrAvatarBaseComponent component)
		{
			IntPtr intPtr = ovrAvatarPose_GetBaseComponent_Native(avatar);
			if (intPtr == IntPtr.Zero)
			{
				return false;
			}
			int ofs = Marshal.SizeOf(typeof(ovrAvatarBaseComponent)) - Marshal.SizeOf(typeof(IntPtr));
			component.renderComponent = Marshal.ReadIntPtr(intPtr, ofs);
			return true;
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarPose_GetBaseComponent")]
		private static extern IntPtr ovrAvatarPose_GetBaseComponent_Native(IntPtr avatar);

		public static IntPtr MarshalRenderComponent<T>(IntPtr ptr) where T : struct
		{
			return Marshal.ReadIntPtr(new IntPtr(ptr.ToInt64() + Marshal.OffsetOf(typeof(T), "renderComponent").ToInt64()));
		}

		public static bool ovrAvatarPose_GetBodyComponent(IntPtr avatar, ref ovrAvatarBodyComponent component)
		{
			IntPtr intPtr = ovrAvatarPose_GetBodyComponent_Native(avatar);
			if (intPtr == IntPtr.Zero)
			{
				return false;
			}
			Marshal.Copy(new IntPtr(intPtr.ToInt64() + ovrAvatarBodyComponent_Offsets.leftEyeTransform), scratchBufferFloat, 0, 10);
			OvrAvatar.ConvertTransform(scratchBufferFloat, ref component.leftEyeTransform);
			Marshal.Copy(new IntPtr(intPtr.ToInt64() + ovrAvatarBodyComponent_Offsets.rightEyeTransform), scratchBufferFloat, 0, 10);
			OvrAvatar.ConvertTransform(scratchBufferFloat, ref component.rightEyeTransform);
			Marshal.Copy(new IntPtr(intPtr.ToInt64() + ovrAvatarBodyComponent_Offsets.centerEyeTransform), scratchBufferFloat, 0, 10);
			OvrAvatar.ConvertTransform(scratchBufferFloat, ref component.centerEyeTransform);
			component.renderComponent = MarshalRenderComponent<ovrAvatarBodyComponent>(intPtr);
			return true;
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarPose_GetBodyComponent")]
		private static extern IntPtr ovrAvatarPose_GetBodyComponent_Native(IntPtr avatar);

		public static bool ovrAvatarPose_GetLeftControllerComponent(IntPtr avatar, ref ovrAvatarControllerComponent component)
		{
			IntPtr intPtr = ovrAvatarPose_GetLeftControllerComponent_Native(avatar);
			if (intPtr == IntPtr.Zero)
			{
				return false;
			}
			int ofs = Marshal.SizeOf(typeof(ovrAvatarControllerComponent)) - Marshal.SizeOf(typeof(IntPtr));
			component.renderComponent = Marshal.ReadIntPtr(intPtr, ofs);
			return true;
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarPose_GetLeftControllerComponent")]
		private static extern IntPtr ovrAvatarPose_GetLeftControllerComponent_Native(IntPtr avatar);

		public static bool ovrAvatarPose_GetRightControllerComponent(IntPtr avatar, ref ovrAvatarControllerComponent component)
		{
			IntPtr intPtr = ovrAvatarPose_GetRightControllerComponent_Native(avatar);
			if (intPtr == IntPtr.Zero)
			{
				return false;
			}
			int ofs = Marshal.SizeOf(typeof(ovrAvatarControllerComponent)) - Marshal.SizeOf(typeof(IntPtr));
			component.renderComponent = Marshal.ReadIntPtr(intPtr, ofs);
			return true;
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarPose_GetRightControllerComponent")]
		private static extern IntPtr ovrAvatarPose_GetRightControllerComponent_Native(IntPtr avatar);

		public static bool ovrAvatarPose_GetLeftHandComponent(IntPtr avatar, ref ovrAvatarHandComponent component)
		{
			IntPtr intPtr = ovrAvatarPose_GetLeftHandComponent_Native(avatar);
			if (intPtr == IntPtr.Zero)
			{
				return false;
			}
			int ofs = Marshal.SizeOf(typeof(ovrAvatarHandComponent)) - Marshal.SizeOf(typeof(IntPtr));
			component.renderComponent = Marshal.ReadIntPtr(intPtr, ofs);
			return true;
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarPose_GetLeftHandComponent")]
		private static extern IntPtr ovrAvatarPose_GetLeftHandComponent_Native(IntPtr avatar);

		public static bool ovrAvatarPose_GetRightHandComponent(IntPtr avatar, ref ovrAvatarHandComponent component)
		{
			IntPtr intPtr = ovrAvatarPose_GetRightHandComponent_Native(avatar);
			if (intPtr == IntPtr.Zero)
			{
				return false;
			}
			int ofs = Marshal.SizeOf(typeof(ovrAvatarHandComponent)) - Marshal.SizeOf(typeof(IntPtr));
			component.renderComponent = Marshal.ReadIntPtr(intPtr, ofs);
			return true;
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarPose_GetRightHandComponent")]
		private static extern IntPtr ovrAvatarPose_GetRightHandComponent_Native(IntPtr avatar);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatarAsset_BeginLoading(ulong assetID);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovrAvatarAsset_BeginLoadingLOD(ulong assetId, ovrAvatarAssetLevelOfDetail lod);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarAssetType ovrAvatarAsset_GetType(IntPtr assetHandle);

		public static ovrAvatarMeshAssetData ovrAvatarAsset_GetMeshData(IntPtr assetPtr)
		{
			return (ovrAvatarMeshAssetData)Marshal.PtrToStructure(ovrAvatarAsset_GetMeshData_Native(assetPtr), typeof(ovrAvatarMeshAssetData));
		}

		public static ovrAvatarMeshAssetDataV2 ovrAvatarAsset_GetCombinedMeshData(IntPtr assetPtr)
		{
			return (ovrAvatarMeshAssetDataV2)Marshal.PtrToStructure(ovrAvatarAsset_GetCombinedMeshData_Native(assetPtr), typeof(ovrAvatarMeshAssetDataV2));
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarAsset_GetCombinedMeshData")]
		private static extern IntPtr ovrAvatarAsset_GetCombinedMeshData_Native(IntPtr assetPtr);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarAsset_GetMeshData")]
		private static extern IntPtr ovrAvatarAsset_GetMeshData_Native(IntPtr assetPtr);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovrAvatarAsset_GetMeshBlendShapeCount(IntPtr assetPtr);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovrAvatarAsset_GetMeshBlendShapeName(IntPtr assetPtr, uint index);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovrAvatarAsset_GetSubmeshCount(IntPtr assetPtr);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovrAvatarAsset_GetSubmeshLastIndex(IntPtr assetPtr, uint index);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovrAvatarAsset_GetMeshBlendShapeVertices(IntPtr assetPtr);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovrAvatarAsset_GetAvatar(IntPtr assetHandle);

		public static ulong[] ovrAvatarAsset_GetCombinedMeshIDs(IntPtr assetHandle)
		{
			uint structure = 0u;
			IntPtr intPtr = Marshal.AllocHGlobal(Marshal.SizeOf(structure));
			IntPtr ptr = ovrAvatarAsset_GetCombinedMeshIDs_Native(assetHandle, intPtr);
			structure = (uint)Marshal.PtrToStructure(intPtr, typeof(uint));
			ulong[] array = new ulong[structure];
			for (int i = 0; i < structure; i++)
			{
				array[i] = (ulong)Marshal.ReadInt64(ptr, i * Marshal.SizeOf(typeof(ulong)));
			}
			Marshal.FreeHGlobal(intPtr);
			return array;
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarAsset_GetCombinedMeshIDs")]
		public static extern IntPtr ovrAvatarAsset_GetCombinedMeshIDs_Native(IntPtr assetHandle, IntPtr count);

		public static void ovrAvatar_GetCombinedMeshAlphaData(IntPtr avatar, ref ulong textureID, ref Vector4 offset)
		{
			IntPtr intPtr = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(ulong)));
			IntPtr intPtr2 = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(Vector4)));
			ovrAvatar_GetCombinedMeshAlphaData_Native(avatar, intPtr, intPtr2);
			textureID = (ulong)Marshal.PtrToStructure(intPtr, typeof(ulong));
			offset = (Vector4)Marshal.PtrToStructure(intPtr2, typeof(Vector4));
			Marshal.FreeHGlobal(intPtr);
			Marshal.FreeHGlobal(intPtr2);
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatar_GetCombinedMeshAlphaData")]
		public static extern IntPtr ovrAvatar_GetCombinedMeshAlphaData_Native(IntPtr avatar, IntPtr textureIDPtr, IntPtr offsetPtr);

		public static ovrAvatarTextureAssetData ovrAvatarAsset_GetTextureData(IntPtr assetPtr)
		{
			return (ovrAvatarTextureAssetData)Marshal.PtrToStructure(ovrAvatarAsset_GetTextureData_Native(assetPtr), typeof(ovrAvatarTextureAssetData));
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarAsset_GetTextureData")]
		private static extern IntPtr ovrAvatarAsset_GetTextureData_Native(IntPtr assetPtr);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarAsset_GetMaterialData")]
		private static extern IntPtr ovrAvatarAsset_GetMaterialData_Native(IntPtr assetPtr);

		public static ovrAvatarMaterialState ovrAvatarAsset_GetMaterialState(IntPtr assetPtr)
		{
			return (ovrAvatarMaterialState)Marshal.PtrToStructure(ovrAvatarAsset_GetMaterialData_Native(assetPtr), typeof(ovrAvatarMaterialState));
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarRenderPartType ovrAvatarRenderPart_GetType(IntPtr renderPart);

		public static ovrAvatarRenderPart_SkinnedMeshRender ovrAvatarRenderPart_GetSkinnedMeshRender(IntPtr renderPart)
		{
			return (ovrAvatarRenderPart_SkinnedMeshRender)Marshal.PtrToStructure(ovrAvatarRenderPart_GetSkinnedMeshRender_Native(renderPart), typeof(ovrAvatarRenderPart_SkinnedMeshRender));
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarRenderPart_GetSkinnedMeshRender")]
		private static extern IntPtr ovrAvatarRenderPart_GetSkinnedMeshRender_Native(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarTransform ovrAvatarSkinnedMeshRender_GetTransform(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarTransform ovrAvatarSkinnedMeshRenderPBS_GetTransform(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarTransform ovrAvatarSkinnedMeshRenderPBSV2_GetTransform(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarVisibilityFlags ovrAvatarSkinnedMeshRender_GetVisibilityMask(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovrAvatarSkinnedMeshRender_MaterialStateChanged(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovrAvatarSkinnedMeshRenderPBSV2_MaterialStateChanged(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarVisibilityFlags ovrAvatarSkinnedMeshRenderPBS_GetVisibilityMask(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarVisibilityFlags ovrAvatarSkinnedMeshRenderPBSV2_GetVisibilityMask(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarMaterialState ovrAvatarSkinnedMeshRender_GetMaterialState(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarPBSMaterialState ovrAvatarSkinnedMeshRenderPBSV2_GetPBSMaterialState(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarExpressiveParameters ovrAvatar_GetExpressiveParameters(IntPtr avatar);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovrAvatarSkinnedMeshRender_GetDirtyJoints(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovrAvatarSkinnedMeshRenderPBS_GetDirtyJoints(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovrAvatarSkinnedMeshRenderPBSV2_GetDirtyJoints(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarTransform ovrAvatarSkinnedMeshRender_GetJointTransform(IntPtr renderPart, uint jointIndex);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_SetActionUnitOnsetSpeed(IntPtr avatar, float onsetSpeed);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_SetActionUnitFalloffSpeed(IntPtr avatar, float falloffSpeed);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_SetVisemeMultiplier(IntPtr avatar, float visemeMultiplier);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarTransform ovrAvatarSkinnedMeshRenderPBS_GetJointTransform(IntPtr renderPart, uint jointIndex);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarTransform ovrAvatarSkinnedMeshRenderPBSV2_GetJointTransform(IntPtr renderPart, uint jointIndex);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovrAvatarSkinnedMeshRenderPBS_GetAlbedoTextureAssetID(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovrAvatarSkinnedMeshRenderPBS_GetSurfaceTextureAssetID(IntPtr renderPart);

		public static ovrAvatarRenderPart_SkinnedMeshRenderPBS ovrAvatarRenderPart_GetSkinnedMeshRenderPBS(IntPtr renderPart)
		{
			return (ovrAvatarRenderPart_SkinnedMeshRenderPBS)Marshal.PtrToStructure(ovrAvatarRenderPart_GetSkinnedMeshRenderPBS_Native(renderPart), typeof(ovrAvatarRenderPart_SkinnedMeshRenderPBS));
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarRenderPart_GetSkinnedMeshRenderPBS")]
		private static extern IntPtr ovrAvatarRenderPart_GetSkinnedMeshRenderPBS_Native(IntPtr renderPart);

		public static ovrAvatarRenderPart_SkinnedMeshRenderPBS_V2 ovrAvatarRenderPart_GetSkinnedMeshRenderPBSV2(IntPtr renderPart)
		{
			return (ovrAvatarRenderPart_SkinnedMeshRenderPBS_V2)Marshal.PtrToStructure(ovrAvatarRenderPart_GetSkinnedMeshRenderPBSV2_Native(renderPart), typeof(ovrAvatarRenderPart_SkinnedMeshRenderPBS_V2));
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarRenderPart_GetSkinnedMeshRenderPBSV2")]
		private static extern IntPtr ovrAvatarRenderPart_GetSkinnedMeshRenderPBSV2_Native(IntPtr renderPart);

		public static void ovrAvatarSkinnedMeshRender_GetBlendShapeParams(IntPtr renderPart, ref ovrAvatarBlendShapeParams blendParams)
		{
			IntPtr ptr = ovrAvatarSkinnedMeshRender_GetBlendShapeParams_Native(renderPart);
			blendParams.blendShapeParamCount = (uint)Marshal.ReadInt32(ptr);
			Marshal.Copy(new IntPtr(ptr.ToInt64() + ovrAvatarBlendShapeParams_Offsets.blendShapeParams), blendParams.blendShapeParams, 0, (int)blendParams.blendShapeParamCount);
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarSkinnedMeshRender_GetBlendShapeParams")]
		private static extern IntPtr ovrAvatarSkinnedMeshRender_GetBlendShapeParams_Native(IntPtr renderPart);

		public static ovrAvatarRenderPart_ProjectorRender ovrAvatarRenderPart_GetProjectorRender(IntPtr renderPart)
		{
			return (ovrAvatarRenderPart_ProjectorRender)Marshal.PtrToStructure(ovrAvatarRenderPart_GetProjectorRender_Native(renderPart), typeof(ovrAvatarRenderPart_ProjectorRender));
		}

		public static ovrAvatarPBSMaterialState[] ovrAvatar_GetBodyPBSMaterialStates(IntPtr renderPart)
		{
			IntPtr intPtr = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(uint)));
			IntPtr intPtr2 = ovrAvatar_GetBodyPBSMaterialStates_Native(renderPart, intPtr);
			ovrAvatarPBSMaterialState[] array = new ovrAvatarPBSMaterialState[Marshal.ReadInt32(intPtr)];
			for (int i = 0; i < array.Length; i++)
			{
				IntPtr ptr = new IntPtr(intPtr2.ToInt64() + i * Marshal.SizeOf(typeof(ovrAvatarPBSMaterialState)));
				array[i] = (ovrAvatarPBSMaterialState)Marshal.PtrToStructure(ptr, typeof(ovrAvatarPBSMaterialState));
			}
			Marshal.FreeHGlobal(intPtr);
			return array;
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatar_GetBodyPBSMaterialStates")]
		private static extern IntPtr ovrAvatar_GetBodyPBSMaterialStates_Native(IntPtr avatar, IntPtr count);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarRenderPart_GetProjectorRender")]
		private static extern IntPtr ovrAvatarRenderPart_GetProjectorRender_Native(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovrAvatar_GetReferencedAssetCount(IntPtr avatar);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovrAvatar_GetReferencedAsset(IntPtr avatar, uint index);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_SetLeftHandGesture(IntPtr avatar, ovrAvatarHandGesture gesture);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_SetRightHandGesture(IntPtr avatar, ovrAvatarHandGesture gesture);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_SetLeftHandCustomGesture(IntPtr avatar, uint jointCount, [In] ovrAvatarTransform[] customJointTransforms);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_SetRightHandCustomGesture(IntPtr avatar, uint jointCount, [In] ovrAvatarTransform[] customJointTransforms);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_UpdatePoseFromPacket(IntPtr avatar, IntPtr packet, float secondsFromStart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatarPacket_BeginRecording(IntPtr avatar);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovrAvatarPacket_EndRecording(IntPtr avatar);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovrAvatarPacket_GetSize(IntPtr packet);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern float ovrAvatarPacket_GetDurationSeconds(IntPtr packet);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatarPacket_Free(IntPtr packet);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovrAvatarPacket_Write(IntPtr packet, uint bufferSize, [Out] byte[] buffer);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovrAvatarPacket_Read(uint bufferSize, [In] byte[] buffer);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		private static extern void ovrAvatar_SetInternalForceASTCTextures(bool value);

		public static void ovrAvatar_SetForceASTCTextures(bool value)
		{
			ovrAvatar_SetInternalForceASTCTextures(value);
		}

		public static void ovrAvatar_OverrideExpressiveLogic(IntPtr avatar, ovrAvatarBlendShapeParams blendParams)
		{
			IntPtr intPtr = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(ovrAvatarBlendShapeParams)));
			Marshal.StructureToPtr(blendParams, intPtr, fDeleteOld: false);
			ovrAvatar_OverrideExpressiveLogic_Native(avatar, intPtr);
			Marshal.FreeHGlobal(intPtr);
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatar_OverrideExpressiveLogic")]
		private static extern void ovrAvatar_OverrideExpressiveLogic_Native(IntPtr avatar, IntPtr state);

		public static void ovrAvatar_SetVisemes(IntPtr avatar, ovrAvatarVisemes visemes)
		{
			Marshal.WriteInt32(nativeVisemeData, (int)visemes.visemeParamCount);
			Marshal.Copy(visemes.visemeParams, 0, new IntPtr(nativeVisemeData.ToInt64() + ovrAvatarVisemes_Offsets.visemeParams), (int)visemes.visemeParamCount);
			ovrAvatar_SetVisemes_Native(avatar, nativeVisemeData);
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatar_SetVisemes")]
		private static extern void ovrAvatar_SetVisemes_Native(IntPtr avatar, IntPtr visemes);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_UpdateWorldTransform(IntPtr avatar, ovrAvatarTransform transform);

		public static void ovrAvatar_UpdateGazeTargets(ovrAvatarGazeTargets targets)
		{
			Marshal.WriteInt32(nativeGazeTargetsData, (int)targets.targetCount);
			long targets2 = ovrAvatarGazeTargets_Offsets.targets;
			for (uint num = 0u; num < targets.targetCount; num++)
			{
				long num2 = targets2 + num * Marshal.SizeOf(typeof(ovrAvatarGazeTarget));
				Marshal.WriteInt32(new IntPtr(nativeGazeTargetsData.ToInt64() + num2 + ovrAvatarGazeTarget_Offsets.id), (int)targets.targets[num].id);
				scratchBufferFloat[0] = targets.targets[num].worldPosition.x;
				scratchBufferFloat[1] = targets.targets[num].worldPosition.y;
				scratchBufferFloat[2] = targets.targets[num].worldPosition.z;
				Marshal.Copy(scratchBufferFloat, 0, new IntPtr(nativeGazeTargetsData.ToInt64() + num2 + ovrAvatarGazeTarget_Offsets.worldPosition), 3);
				Marshal.WriteInt32(new IntPtr(nativeGazeTargetsData.ToInt64() + num2 + ovrAvatarGazeTarget_Offsets.type), (int)targets.targets[num].type);
			}
			ovrAvatar_UpdateGazeTargets_Native(nativeGazeTargetsData);
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatar_UpdateGazeTargets")]
		private static extern void ovrAvatar_UpdateGazeTargets_Native(IntPtr targets);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_RemoveGazeTargets(uint targetCount, uint[] ids);

		public static void ovrAvatar_UpdateLights(ovrAvatarLights lights)
		{
			scratchBufferFloat[0] = lights.ambientIntensity;
			Marshal.Copy(scratchBufferFloat, 0, nativeAvatarLightsData, 1);
			Marshal.WriteInt32(new IntPtr(nativeAvatarLightsData.ToInt64() + Marshal.OffsetOf(typeof(ovrAvatarLights), "lightCount").ToInt64()), (int)lights.lightCount);
			long num = Marshal.OffsetOf(typeof(ovrAvatarLights), "lights").ToInt64();
			for (uint num2 = 0u; num2 < lights.lightCount; num2++)
			{
				long num3 = num + num2 * Marshal.SizeOf(typeof(ovrAvatarLight));
				Marshal.WriteInt32(new IntPtr(nativeAvatarLightsData.ToInt64() + num3 + Marshal.OffsetOf(typeof(ovrAvatarLight), "id").ToInt64()), (int)lights.lights[num2].id);
				Marshal.WriteInt32(new IntPtr(nativeAvatarLightsData.ToInt64() + num3 + Marshal.OffsetOf(typeof(ovrAvatarLight), "type").ToInt64()), (int)lights.lights[num2].type);
				scratchBufferFloat[0] = lights.lights[num2].intensity;
				Marshal.Copy(scratchBufferFloat, 0, new IntPtr(nativeAvatarLightsData.ToInt64() + num3 + Marshal.OffsetOf(typeof(ovrAvatarLight), "intensity").ToInt64()), 1);
				scratchBufferFloat[0] = lights.lights[num2].worldDirection.x;
				scratchBufferFloat[1] = lights.lights[num2].worldDirection.y;
				scratchBufferFloat[2] = lights.lights[num2].worldDirection.z;
				Marshal.Copy(scratchBufferFloat, 0, new IntPtr(nativeAvatarLightsData.ToInt64() + num3 + Marshal.OffsetOf(typeof(ovrAvatarLight), "worldDirection").ToInt64()), 3);
				scratchBufferFloat[0] = lights.lights[num2].worldPosition.x;
				scratchBufferFloat[1] = lights.lights[num2].worldPosition.y;
				scratchBufferFloat[2] = lights.lights[num2].worldPosition.z;
				Marshal.Copy(scratchBufferFloat, 0, new IntPtr(nativeAvatarLightsData.ToInt64() + num3 + Marshal.OffsetOf(typeof(ovrAvatarLight), "worldPosition").ToInt64()), 3);
				scratchBufferFloat[0] = lights.lights[num2].range;
				Marshal.Copy(scratchBufferFloat, 0, new IntPtr(nativeAvatarLightsData.ToInt64() + num3 + Marshal.OffsetOf(typeof(ovrAvatarLight), "range").ToInt64()), 1);
				scratchBufferFloat[0] = lights.lights[num2].spotAngleDeg;
				Marshal.Copy(scratchBufferFloat, 0, new IntPtr(nativeAvatarLightsData.ToInt64() + num3 + Marshal.OffsetOf(typeof(ovrAvatarLight), "spotAngleDeg").ToInt64()), 1);
			}
			ovrAvatar_UpdateLights_Native(nativeAvatarLightsData);
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatar_UpdateLights")]
		private static extern void ovrAvatar_UpdateLights_Native(IntPtr lights);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_RemoveLights(uint lightCount, uint[] ids);

		[MonoPInvokeCallback(typeof(LoggingDelegate))]
		public static void LoggingCallback(IntPtr str)
		{
			Marshal.PtrToStringAnsi(str);
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_RegisterLoggingCallback(LoggingDelegate callback);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_SetLoggingLevel(ovrAvatarLogLevel level);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatar_GetDebugTransforms")]
		public static extern IntPtr ovrAvatar_GetDebugTransforms_Native(IntPtr count);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatar_GetDebugLines")]
		public static extern IntPtr ovrAvatar_GetDebugLines_Native(IntPtr count);

		public static void ovrAvatar_DrawDebugLines()
		{
			IntPtr intPtr = ovrAvatar_GetDebugLines_Native(DebugLineCountData);
			int num = Marshal.ReadInt32(DebugLineCountData);
			ovrAvatarDebugLine ovrAvatarDebugLine = default(ovrAvatarDebugLine);
			for (int i = 0; i < num; i++)
			{
				int num2 = i * Marshal.SizeOf(typeof(ovrAvatarDebugLine));
				Marshal.Copy(new IntPtr(intPtr.ToInt64() + num2), scratchBufferFloat, 0, 9);
				ovrAvatarDebugLine.startPoint.x = scratchBufferFloat[0];
				ovrAvatarDebugLine.startPoint.y = scratchBufferFloat[1];
				ovrAvatarDebugLine.startPoint.z = 0f - scratchBufferFloat[2];
				ovrAvatarDebugLine.endPoint.x = scratchBufferFloat[3];
				ovrAvatarDebugLine.endPoint.y = scratchBufferFloat[4];
				ovrAvatarDebugLine.endPoint.z = 0f - scratchBufferFloat[5];
				ovrAvatarDebugLine.color.x = scratchBufferFloat[6];
				ovrAvatarDebugLine.color.y = scratchBufferFloat[7];
				ovrAvatarDebugLine.color.z = scratchBufferFloat[8];
				ovrAvatarDebugLine.context = (ovrAvatarDebugContext)Marshal.ReadInt32(new IntPtr(intPtr.ToInt64() + num2 + Marshal.OffsetOf(typeof(ovrAvatarDebugLine), "context").ToInt64()));
				ovrAvatarDebugLine.text = Marshal.ReadIntPtr(new IntPtr(intPtr.ToInt64() + num2 + Marshal.OffsetOf(typeof(ovrAvatarDebugLine), "text").ToInt64()));
				UnityEngine.Debug.DrawLine(ovrAvatarDebugLine.startPoint, ovrAvatarDebugLine.endPoint, new Color(ovrAvatarDebugLine.color.x, ovrAvatarDebugLine.color.y, ovrAvatarDebugLine.color.z));
			}
			intPtr = ovrAvatar_GetDebugTransforms_Native(DebugLineCountData);
			num = Marshal.ReadInt32(DebugLineCountData);
			ovrAvatarDebugTransform ovrAvatarDebugTransform = default(ovrAvatarDebugTransform);
			for (int j = 0; j < num; j++)
			{
				int num3 = j * Marshal.SizeOf(typeof(ovrAvatarDebugTransform));
				Marshal.Copy(new IntPtr(intPtr.ToInt64() + num3), scratchBufferFloat, 0, 10);
				OvrAvatar.ConvertTransform(scratchBufferFloat, ref ovrAvatarDebugTransform.transform);
				OvrAvatar.ConvertTransform(ovrAvatarDebugTransform.transform, debugLineGo.transform);
				ovrAvatarDebugTransform.context = (ovrAvatarDebugContext)Marshal.ReadInt32(new IntPtr(intPtr.ToInt64() + num3 + Marshal.OffsetOf(typeof(ovrAvatarDebugTransform), "context").ToInt64()));
				ovrAvatarDebugTransform.text = Marshal.ReadIntPtr(new IntPtr(intPtr.ToInt64() + num3 + Marshal.OffsetOf(typeof(ovrAvatarDebugTransform), "text").ToInt64()));
				Vector3 vector = 0.1f * debugLineGo.transform.TransformVector(Vector3.up);
				Vector3 vector2 = 0.1f * debugLineGo.transform.TransformVector(Vector3.right);
				Vector3 vector3 = 0.1f * debugLineGo.transform.TransformVector(Vector3.forward);
				UnityEngine.Debug.DrawLine(debugLineGo.transform.position, debugLineGo.transform.position + vector, Color.green);
				UnityEngine.Debug.DrawLine(debugLineGo.transform.position, debugLineGo.transform.position + vector2, Color.red);
				UnityEngine.Debug.DrawLine(debugLineGo.transform.position, debugLineGo.transform.position + vector3, Color.blue);
			}
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_SetDebugDrawContext(uint context);

		public static bool SendEvent(string name, string param = "", string source = "")
		{
			try
			{
				if (ovrPluginVersion == null)
				{
					string text = ovrp_GetVersion();
					if (!string.IsNullOrEmpty(text))
					{
						ovrPluginVersion = new Version(text.Split('-')[0]);
					}
					else
					{
						ovrPluginVersion = new Version(0, 0, 0);
					}
				}
				if (ovrPluginVersion >= OVRP_1_30_0.version)
				{
					return OVRP_1_30_0.ovrp_SendEvent2(name, param, (source.Length == 0) ? "avatar_sdk" : source) == Result.Success;
				}
				return false;
			}
			catch (Exception)
			{
				return false;
			}
		}

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrp_GetVersion")]
		private static extern IntPtr _ovrp_GetVersion();

		public static string ovrp_GetVersion()
		{
			return Marshal.PtrToStringAnsi(_ovrp_GetVersion());
		}
	}
}
namespace OVR
{
	public class TestScript : MonoBehaviour
	{
		[InspectorNote("Sound Setup", "Press '1' to play testSound1 and '2' to play testSound2")]
		public SoundFXRef testSound1;

		public SoundFXRef testSound2;

		private void Start()
		{
		}

		private void Update()
		{
			if (Input.GetKeyDown(KeyCode.Alpha1))
			{
				testSound1.PlaySoundAt(base.transform.position);
			}
			if (Input.GetKeyDown(KeyCode.Alpha2))
			{
				testSound2.PlaySoundAt(new Vector3(5f, 0f, 0f));
			}
		}
	}
	public class AmbienceEmitter : MonoBehaviour
	{
		public SoundFXRef[] ambientSounds = new SoundFXRef[0];

		public bool autoActivate = true;

		[Tooltip("Automatically play the sound randomly again when checked.  Should be OFF for looping sounds")]
		public bool autoRetrigger = true;

		[MinMax(2f, 4f, 0.1f, 10f)]
		public Vector2 randomRetriggerDelaySecs = new Vector2(2f, 4f);

		[Tooltip("If defined, the sounds will randomly play from these transform positions, otherwise the sound will play from this transform")]
		public Transform[] playPositions = new Transform[0];

		private bool activated;

		private int playingIdx = -1;

		private float nextPlayTime;

		private float fadeTime = 0.25f;

		private int lastPosIdx = -1;

		private void Awake()
		{
			if (autoActivate)
			{
				activated = true;
				nextPlayTime = Time.time + UnityEngine.Random.Range(randomRetriggerDelaySecs.x, randomRetriggerDelaySecs.y);
			}
			Transform[] array = playPositions;
			for (int i = 0; i < array.Length; i++)
			{
				if (array[i] == null)
				{
					UnityEngine.Debug.LogWarning("[AmbienceEmitter] Invalid play positions in " + base.name);
					playPositions = new Transform[0];
					break;
				}
			}
		}

		private void Update()
		{
			if (activated && (playingIdx == -1 || autoRetrigger) && Time.time >= nextPlayTime)
			{
				Play();
				if (!autoRetrigger)
				{
					activated = false;
				}
			}
		}

		public void OnTriggerEnter(Collider col)
		{
			activated = !activated;
		}

		public void Play()
		{
			Transform transform = base.transform;
			if (playPositions.Length != 0)
			{
				int num = UnityEngine.Random.Range(0, playPositions.Length);
				while (playPositions.Length > 1 && num == lastPosIdx)
				{
					num = UnityEngine.Random.Range(0, playPositions.Length);
				}
				transform = playPositions[num];
				lastPosIdx = num;
			}
			playingIdx = ambientSounds[UnityEngine.Random.Range(0, ambientSounds.Length)].PlaySoundAt(transform.position);
			if (playingIdx != -1)
			{
				AudioManager.FadeInSound(playingIdx, fadeTime);
				nextPlayTime = Time.time + UnityEngine.Random.Range(randomRetriggerDelaySecs.x, randomRetriggerDelaySecs.y);
			}
		}

		public void EnableEmitter(bool enable)
		{
			activated = enable;
			if (enable)
			{
				Play();
			}
			else if (playingIdx != -1)
			{
				AudioManager.FadeOutSound(playingIdx, fadeTime);
			}
		}
	}
	public enum PreloadSounds
	{
		Default,
		Preload,
		ManualPreload
	}
	public enum Fade
	{
		In,
		Out
	}
	[Serializable]
	public class SoundGroup
	{
		public string name = string.Empty;

		public SoundFX[] soundList = new SoundFX[0];

		public AudioMixerGroup mixerGroup;

		[Range(0f, 64f)]
		public int maxPlayingSounds;

		public PreloadSounds preloadAudio;

		public float volumeOverride = 1f;

		[HideInInspector]
		public int playingSoundCount;

		public SoundGroup(string name)
		{
			this.name = name;
		}

		public SoundGroup()
		{
			mixerGroup = null;
			maxPlayingSounds = 0;
			preloadAudio = PreloadSounds.Default;
			volumeOverride = 1f;
		}

		public void IncrementPlayCount()
		{
			playingSoundCount = Mathf.Clamp(++playingSoundCount, 0, maxPlayingSounds);
		}

		public void DecrementPlayCount()
		{
			playingSoundCount = Mathf.Clamp(--playingSoundCount, 0, maxPlayingSounds);
		}

		public bool CanPlaySound()
		{
			if (maxPlayingSounds != 0)
			{
				return playingSoundCount < maxPlayingSounds;
			}
			return true;
		}
	}
	public class AudioManager : MonoBehaviour
	{
		public enum Fade
		{
			In,
			Out
		}

		[Tooltip("Make the audio manager persistent across all scene loads")]
		public bool makePersistent = true;

		[Tooltip("Enable the OSP audio plugin features")]
		public bool enableSpatializedAudio = true;

		[Tooltip("Always play spatialized sounds with no reflections (Default)")]
		public bool enableSpatializedFastOverride;

		[Tooltip("The audio mixer asset used for snapshot blends, etc.")]
		public AudioMixer audioMixer;

		[Tooltip("The audio mixer group used for the pooled emitters")]
		public AudioMixerGroup defaultMixerGroup;

		[Tooltip("The audio mixer group used for the reserved pool emitter")]
		public AudioMixerGroup reservedMixerGroup;

		[Tooltip("The audio mixer group used for voice chat")]
		public AudioMixerGroup voiceChatMixerGroup;

		[Tooltip("Log all PlaySound calls to the Unity console")]
		public bool verboseLogging;

		[Tooltip("Maximum sound emitters")]
		public int maxSoundEmitters = 32;

		[Tooltip("Default volume for all sounds modulated by individual sound FX volumes")]
		public float volumeSoundFX = 1f;

		[Tooltip("Sound FX fade time")]
		public float soundFxFadeSecs = 1f;

		public float audioMinFallOffDistance = 1f;

		public float audioMaxFallOffDistance = 25f;

		public SoundGroup[] soundGroupings = new SoundGroup[0];

		private Dictionary<string, SoundFX> soundFXCache;

		private static AudioManager theAudioManager = null;

		private static FastList<string> names = new FastList<string>();

		private static string[] defaultSound = new string[1] { "Default Sound" };

		private static SoundFX nullSound = new SoundFX();

		private static bool hideWarnings = false;

		private float audioMaxFallOffDistanceSqr = 625f;

		private SoundEmitter[] soundEmitters;

		private FastList<SoundEmitter> playingEmitters = new FastList<SoundEmitter>();

		private FastList<SoundEmitter> nextFreeEmitters = new FastList<SoundEmitter>();

		private MixerSnapshot currentSnapshot;

		private static GameObject soundEmitterParent = null;

		private static Transform staticListenerPosition = null;

		private static bool showPlayingEmitterCount = false;

		private static bool forceShowEmitterCount = false;

		private static bool soundEnabled = true;

		private static readonly AnimationCurve defaultReverbZoneMix = new AnimationCurve(new Keyframe(0f, 1f), new Keyframe(1f, 1f));

		public static bool enableSpatialization
		{
			get
			{
				if (!(theAudioManager != null))
				{
					return false;
				}
				return theAudioManager.enableSpatializedAudio;
			}
		}

		public static AudioManager Instance => theAudioManager;

		public static float NearFallOff => theAudioManager.audioMinFallOffDistance;

		public static float FarFallOff => theAudioManager.audioMaxFallOffDistance;

		public static AudioMixerGroup EmitterGroup => theAudioManager.defaultMixerGroup;

		public static AudioMixerGroup ReservedGroup => theAudioManager.reservedMixerGroup;

		public static AudioMixerGroup VoipGroup => theAudioManager.voiceChatMixerGroup;

		public static bool SoundEnabled => soundEnabled;

		private void Awake()
		{
			Init();
		}

		private void OnDestroy()
		{
			if (theAudioManager == this && soundEmitterParent != null)
			{
				UnityEngine.Object.Destroy(soundEmitterParent);
			}
		}

		private void Init()
		{
			if (theAudioManager != null)
			{
				if (UnityEngine.Application.isPlaying && theAudioManager != this)
				{
					base.enabled = false;
				}
				return;
			}
			theAudioManager = this;
			nullSound.name = "Default Sound";
			RebuildSoundFXCache();
			if (UnityEngine.Application.isPlaying)
			{
				InitializeSoundSystem();
				if (makePersistent && base.transform.parent == null)
				{
					UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
				}
			}
		}

		private void Update()
		{
			UpdateFreeEmitters();
		}

		private void RebuildSoundFXCache()
		{
			int num = 0;
			for (int i = 0; i < soundGroupings.Length; i++)
			{
				num += soundGroupings[i].soundList.Length;
			}
			soundFXCache = new Dictionary<string, SoundFX>(num + 1);
			soundFXCache.Add(nullSound.name, nullSound);
			for (int j = 0; j < soundGroupings.Length; j++)
			{
				for (int k = 0; k < soundGroupings[j].soundList.Length; k++)
				{
					if (soundFXCache.ContainsKey(soundGroupings[j].soundList[k].name))
					{
						UnityEngine.Debug.LogError("ERROR: Duplicate Sound FX name in the audio manager: '" + soundGroupings[j].name + "' > '" + soundGroupings[j].soundList[k].name + "'");
					}
					else
					{
						soundGroupings[j].soundList[k].Group = soundGroupings[j];
						soundFXCache.Add(soundGroupings[j].soundList[k].name, soundGroupings[j].soundList[k]);
					}
				}
				soundGroupings[j].playingSoundCount = 0;
			}
		}

		public static SoundFX FindSoundFX(string name, bool rebuildCache = false)
		{
			if (string.IsNullOrEmpty(name))
			{
				return nullSound;
			}
			if (rebuildCache)
			{
				theAudioManager.RebuildSoundFXCache();
			}
			if (!theAudioManager.soundFXCache.ContainsKey(name))
			{
				return nullSound;
			}
			return theAudioManager.soundFXCache[name];
		}

		private static bool FindAudioManager()
		{
			GameObject gameObject = GameObject.Find("AudioManager");
			if (gameObject == null || gameObject.GetComponent<AudioManager>() == null)
			{
				if (!hideWarnings)
				{
					UnityEngine.Debug.LogError("[ERROR] AudioManager object missing from hierarchy!");
					hideWarnings = true;
				}
				return false;
			}
			gameObject.GetComponent<AudioManager>().Init();
			return true;
		}

		public static GameObject GetGameObject()
		{
			if (theAudioManager == null && !FindAudioManager())
			{
				return null;
			}
			return theAudioManager.gameObject;
		}

		public static string NameMinusGroup(string name)
		{
			if (name.IndexOf("/") > -1)
			{
				return name.Substring(name.IndexOf("/") + 1);
			}
			return name;
		}

		public static string[] GetSoundFXNames(string currentValue, out int currentIdx)
		{
			currentIdx = 0;
			names.Clear();
			if (theAudioManager == null && !FindAudioManager())
			{
				return defaultSound;
			}
			names.Add(nullSound.name);
			for (int i = 0; i < theAudioManager.soundGroupings.Length; i++)
			{
				for (int j = 0; j < theAudioManager.soundGroupings[i].soundList.Length; j++)
				{
					if (string.Compare(currentValue, theAudioManager.soundGroupings[i].soundList[j].name, ignoreCase: true) == 0)
					{
						currentIdx = names.Count;
					}
					names.Add(theAudioManager.soundGroupings[i].name + "/" + theAudioManager.soundGroupings[i].soundList[j].name);
				}
			}
			return names.ToArray();
		}

		private static int CalculateMaxEmittersSize()
		{
			return theAudioManager.maxSoundEmitters + 1;
		}

		private static bool ValidateEmitterIndex(int index)
		{
			if (index > -1)
			{
				return index < CalculateMaxEmittersSize();
			}
			return false;
		}

		private void InitializeSoundSystem()
		{
			int bufferLength = 960;
			int numBuffers = 4;
			AudioSettings.GetDSPBufferSize(out bufferLength, out numBuffers);
			if (UnityEngine.Application.isPlaying)
			{
				UnityEngine.Debug.Log("[AudioManager] Audio Sample Rate: " + AudioSettings.outputSampleRate);
				UnityEngine.Debug.Log("[AudioManager] Audio Buffer Length: " + bufferLength + " Size: " + numBuffers);
			}
			AudioListener audioListener = UnityEngine.Object.FindObjectOfType<AudioListener>();
			if (audioListener == null)
			{
				UnityEngine.Debug.LogError("[AudioManager] Missing AudioListener object!  Add one to the scene.");
			}
			else
			{
				staticListenerPosition = audioListener.transform;
			}
			soundEmitters = new SoundEmitter[CalculateMaxEmittersSize()];
			soundEmitterParent = GameObject.Find("__SoundEmitters__");
			if (soundEmitterParent != null)
			{
				UnityEngine.Object.Destroy(soundEmitterParent);
			}
			soundEmitterParent = new GameObject("__SoundEmitters__");
			for (int i = 0; i < CalculateMaxEmittersSize(); i++)
			{
				GameObject gameObject = new GameObject("SoundEmitter_" + i);
				gameObject.transform.parent = soundEmitterParent.transform;
				gameObject.transform.position = Vector3.zero;
				gameObject.hideFlags = HideFlags.DontSaveInEditor;
				soundEmitters[i] = gameObject.AddComponent<SoundEmitter>();
				soundEmitters[i].SetDefaultParent(soundEmitterParent.transform);
				soundEmitters[i].SetChannel(i);
				soundEmitters[i].Stop();
				soundEmitters[i].originalIdx = i;
			}
			ResetFreeEmitters();
			soundEmitterParent.hideFlags = HideFlags.DontSaveInEditor;
			audioMaxFallOffDistanceSqr = audioMaxFallOffDistance * audioMaxFallOffDistance;
		}

		private void UpdateFreeEmitters()
		{
			if (verboseLogging)
			{
				if (Input.GetKeyDown(KeyCode.A))
				{
					forceShowEmitterCount = !forceShowEmitterCount;
				}
				if (forceShowEmitterCount)
				{
					showPlayingEmitterCount = true;
				}
			}
			int num = 0;
			int num2 = 0;
			int num3 = 0;
			int num4 = 0;
			int num5 = 0;
			int num6 = 0;
			int num7 = 0;
			while (num7 < playingEmitters.size)
			{
				if (playingEmitters[num7] == null)
				{
					UnityEngine.Debug.LogError("[AudioManager] ERROR: playingEmitters list had a null emitter! Something nuked a sound emitter!!!");
					playingEmitters.RemoveAtFast(num7);
					return;
				}
				if (!playingEmitters[num7].IsPlaying())
				{
					if (verboseLogging && nextFreeEmitters.Contains(playingEmitters[num7]))
					{
						UnityEngine.Debug.LogError("[AudioManager] ERROR: playing sound emitter already in the free emitters list!");
					}
					playingEmitters[num7].Stop();
					nextFreeEmitters.Add(playingEmitters[num7]);
					playingEmitters.RemoveAtFast(num7);
					continue;
				}
				if (verboseLogging && showPlayingEmitterCount)
				{
					num++;
					switch (playingEmitters[num7].priority)
					{
					case SoundPriority.VeryLow:
						num2++;
						break;
					case SoundPriority.Low:
						num3++;
						break;
					case SoundPriority.Default:
						num4++;
						break;
					case SoundPriority.High:
						num5++;
						break;
					case SoundPriority.VeryHigh:
						num6++;
						break;
					}
				}
				num7++;
			}
			if (verboseLogging && showPlayingEmitterCount)
			{
				UnityEngine.Debug.LogWarning($"[AudioManager] Playing sounds: Total {Fmt(num)} | VeryLow {Fmt(num2)} | Low {Fmt(num3)} | Default {Fmt(num4)} | High {Fmt(num5)} | VeryHigh {Fmt(num6)} | Free {FmtFree(nextFreeEmitters.Count)}");
				showPlayingEmitterCount = false;
			}
		}

		private string Fmt(int count)
		{
			float num = (float)count / (float)theAudioManager.maxSoundEmitters;
			if (num < 0.5f)
			{
				return "<color=green>" + count + "</color>";
			}
			if ((double)num < 0.7)
			{
				return "<color=yellow>" + count + "</color>";
			}
			return "<color=red>" + count + "</color>";
		}

		private string FmtFree(int count)
		{
			float num = (float)count / (float)theAudioManager.maxSoundEmitters;
			if (num < 0.2f)
			{
				return "<color=red>" + count + "</color>";
			}
			if ((double)num < 0.3)
			{
				return "<color=yellow>" + count + "</color>";
			}
			return "<color=green>" + count + "</color>";
		}

		private void OnPreSceneLoad()
		{
			UnityEngine.Debug.Log("[AudioManager] OnPreSceneLoad cleanup");
			for (int i = 0; i < soundEmitters.Length; i++)
			{
				soundEmitters[i].Stop();
				soundEmitters[i].ResetParent(soundEmitterParent.transform);
			}
			ResetFreeEmitters();
		}

		private void ResetFreeEmitters()
		{
			nextFreeEmitters.Clear();
			playingEmitters.Clear();
			for (int i = 1; i < soundEmitters.Length; i++)
			{
				nextFreeEmitters.Add(soundEmitters[i]);
			}
		}

		public static void FadeOutSoundChannel(int channel, float delaySecs, float fadeTime)
		{
			theAudioManager.soundEmitters[channel].FadeOutDelayed(delaySecs, fadeTime);
		}

		public static bool StopSound(int idx, bool fadeOut = true, bool stopReserved = false)
		{
			if (!stopReserved && idx == 0)
			{
				return false;
			}
			if (!fadeOut)
			{
				theAudioManager.soundEmitters[idx].Stop();
			}
			else
			{
				theAudioManager.soundEmitters[idx].FadeOut(theAudioManager.soundFxFadeSecs);
			}
			return true;
		}

		public static void FadeInSound(int idx, float fadeTime, float volume)
		{
			theAudioManager.soundEmitters[idx].FadeIn(fadeTime, volume);
		}

		public static void FadeInSound(int idx, float fadeTime)
		{
			theAudioManager.soundEmitters[idx].FadeIn(fadeTime);
		}

		public static void FadeOutSound(int idx, float fadeTime)
		{
			theAudioManager.soundEmitters[idx].FadeOut(fadeTime);
		}

		public static void StopAllSounds(bool fadeOut, bool stopReserved = false)
		{
			for (int i = 0; i < theAudioManager.soundEmitters.Length; i++)
			{
				StopSound(i, fadeOut, stopReserved);
			}
		}

		public void MuteAllSounds(bool mute, bool muteReserved = false)
		{
			for (int i = 0; i < soundEmitters.Length; i++)
			{
				if (muteReserved || i != 0)
				{
					soundEmitters[i].audioSource.mute = true;
				}
			}
		}

		public void UnMuteAllSounds(bool unmute, bool unmuteReserved = false)
		{
			for (int i = 0; i < soundEmitters.Length; i++)
			{
				if ((unmuteReserved || i != 0) && soundEmitters[i].audioSource.isPlaying)
				{
					soundEmitters[i].audioSource.mute = false;
				}
			}
		}

		public static float GetEmitterEndTime(int idx)
		{
			return theAudioManager.soundEmitters[idx].endPlayTime;
		}

		public static float SetEmitterTime(int idx, float time)
		{
			return theAudioManager.soundEmitters[idx].time = time;
		}

		public static int PlaySound(AudioClip clip, float volume, EmitterChannel src = EmitterChannel.Any, float delay = 0f, float pitchVariance = 1f, bool loop = false)
		{
			if (!SoundEnabled)
			{
				return -1;
			}
			return PlaySoundAt((staticListenerPosition != null) ? staticListenerPosition.position : Vector3.zero, clip, volume, src, delay, pitchVariance, loop);
		}

		private static int FindFreeEmitter(EmitterChannel src, SoundPriority priority)
		{
			SoundEmitter soundEmitter = theAudioManager.soundEmitters[0];
			if (src == EmitterChannel.Any)
			{
				if (theAudioManager.nextFreeEmitters.size > 0)
				{
					soundEmitter = theAudioManager.nextFreeEmitters[0];
					theAudioManager.nextFreeEmitters.RemoveAtFast(0);
				}
				else
				{
					if (priority == SoundPriority.VeryLow)
					{
						return -1;
					}
					soundEmitter = theAudioManager.playingEmitters.Find((SoundEmitter item) => item != null && item.priority < priority);
					if (soundEmitter == null)
					{
						if (priority < SoundPriority.Default)
						{
							if (theAudioManager.verboseLogging)
							{
								UnityEngine.Debug.LogWarning("[AudioManager] skipping sound " + priority);
							}
							return -1;
						}
						soundEmitter = theAudioManager.playingEmitters.Find((SoundEmitter item) => item != null && item.priority <= SoundPriority.Default);
					}
					if (soundEmitter != null)
					{
						if (theAudioManager.verboseLogging)
						{
							UnityEngine.Debug.LogWarning("[AudioManager] cannabalizing " + soundEmitter.originalIdx + " Time: " + Time.time);
						}
						soundEmitter.Stop();
						theAudioManager.playingEmitters.RemoveFast(soundEmitter);
					}
				}
			}
			if (soundEmitter == null)
			{
				UnityEngine.Debug.LogError("[AudioManager] ERROR - absolutely couldn't find a free emitter! Priority = " + priority.ToString() + " TOO MANY PlaySound* calls!");
				showPlayingEmitterCount = true;
				return -1;
			}
			return soundEmitter.originalIdx;
		}

		public static int PlaySound(SoundFX soundFX, EmitterChannel src = EmitterChannel.Any, float delay = 0f)
		{
			if (!SoundEnabled)
			{
				return -1;
			}
			return PlaySoundAt((staticListenerPosition != null) ? staticListenerPosition.position : Vector3.zero, soundFX, src, delay);
		}

		public static int PlaySoundAt(Vector3 position, SoundFX soundFX, EmitterChannel src = EmitterChannel.Any, float delay = 0f, float volumeOverride = 1f, float pitchMultiplier = 1f)
		{
			if (!SoundEnabled)
			{
				return -1;
			}
			AudioClip clip = soundFX.GetClip();
			if (clip == null)
			{
				return -1;
			}
			if (staticListenerPosition != null)
			{
				float sqrMagnitude = (staticListenerPosition.position - position).sqrMagnitude;
				if (sqrMagnitude > theAudioManager.audioMaxFallOffDistanceSqr)
				{
					return -1;
				}
				if (sqrMagnitude > soundFX.MaxFalloffDistSquared)
				{
					return -1;
				}
			}
			if (soundFX.ReachedGroupPlayLimit())
			{
				if (theAudioManager.verboseLogging)
				{
					UnityEngine.Debug.Log("[AudioManager] PlaySoundAt() with " + soundFX.name + " skipped due to group play limit");
				}
				return -1;
			}
			int num = FindFreeEmitter(src, soundFX.priority);
			if (num == -1)
			{
				return -1;
			}
			SoundEmitter soundEmitter = theAudioManager.soundEmitters[num];
			soundEmitter.ResetParent(soundEmitterParent.transform);
			soundEmitter.gameObject.SetActive(value: true);
			AudioSource source = soundEmitter.audioSource;
			ONSPAudioSource osp = soundEmitter.osp;
			source.enabled = true;
			source.volume = Mathf.Clamp01(Mathf.Clamp01(theAudioManager.volumeSoundFX * soundFX.volume) * volumeOverride * soundFX.GroupVolumeOverride);
			source.pitch = soundFX.GetPitch() * pitchMultiplier;
			source.time = 0f;
			source.spatialBlend = 1f;
			source.rolloffMode = soundFX.falloffCurve;
			if (soundFX.falloffCurve == AudioRolloffMode.Custom)
			{
				source.SetCustomCurve(AudioSourceCurveType.CustomRolloff, soundFX.volumeFalloffCurve);
			}
			source.SetCustomCurve(AudioSourceCurveType.ReverbZoneMix, soundFX.reverbZoneMix);
			source.dopplerLevel = 0f;
			source.clip = clip;
			source.spread = soundFX.spread;
			source.loop = soundFX.looping;
			source.mute = false;
			source.minDistance = soundFX.falloffDistance.x;
			source.maxDistance = soundFX.falloffDistance.y;
			source.outputAudioMixerGroup = soundFX.GetMixerGroup(EmitterGroup);
			soundEmitter.endPlayTime = Time.time + clip.length + delay;
			soundEmitter.defaultVolume = source.volume;
			soundEmitter.priority = soundFX.priority;
			soundEmitter.onFinished = null;
			soundEmitter.SetPlayingSoundGroup(soundFX.Group);
			if (src == EmitterChannel.Any)
			{
				theAudioManager.playingEmitters.AddUnique(soundEmitter);
			}
			if (osp != null)
			{
				osp.EnableSpatialization = soundFX.ospProps.enableSpatialization;
				osp.EnableRfl = ((theAudioManager.enableSpatializedFastOverride || soundFX.ospProps.useFastOverride) ? true : false);
				osp.Gain = soundFX.ospProps.gain;
				osp.UseInvSqr = soundFX.ospProps.enableInvSquare;
				osp.Near = soundFX.ospProps.invSquareFalloff.x;
				osp.Far = soundFX.ospProps.invSquareFalloff.y;
				source.spatialBlend = (soundFX.ospProps.enableSpatialization ? 1f : 0.8f);
				osp.SetParameters(ref source);
			}
			source.transform.position = position;
			if (theAudioManager.verboseLogging)
			{
				UnityEngine.Debug.Log("[AudioManager] PlaySoundAt() channel = " + num + " soundFX = " + soundFX.name + " volume = " + soundEmitter.volume + " Delay = " + delay + " time = " + Time.time + "\n");
			}
			if (delay > 0f)
			{
				source.PlayDelayed(delay);
			}
			else
			{
				source.Play();
			}
			return num;
		}

		public static int PlayRandomSoundAt(Vector3 position, AudioClip[] clips, float volume, EmitterChannel src = EmitterChannel.Any, float delay = 0f, float pitch = 1f, bool loop = false)
		{
			if (clips == null || clips.Length == 0)
			{
				return -1;
			}
			int num = UnityEngine.Random.Range(0, clips.Length);
			return PlaySoundAt(position, clips[num], volume, src, delay, pitch, loop);
		}

		public static int PlaySoundAt(Vector3 position, AudioClip clip, float volume = 1f, EmitterChannel src = EmitterChannel.Any, float delay = 0f, float pitch = 1f, bool loop = false)
		{
			if (!SoundEnabled)
			{
				return -1;
			}
			if (clip == null)
			{
				return -1;
			}
			if (staticListenerPosition != null && (staticListenerPosition.position - position).sqrMagnitude > theAudioManager.audioMaxFallOffDistanceSqr)
			{
				return -1;
			}
			int num = FindFreeEmitter(src, SoundPriority.Default);
			if (num == -1)
			{
				return -1;
			}
			SoundEmitter soundEmitter = theAudioManager.soundEmitters[num];
			soundEmitter.ResetParent(soundEmitterParent.transform);
			soundEmitter.gameObject.SetActive(value: true);
			AudioSource audioSource = soundEmitter.audioSource;
			ONSPAudioSource osp = soundEmitter.osp;
			audioSource.enabled = true;
			audioSource.volume = Mathf.Clamp01(theAudioManager.volumeSoundFX * volume);
			audioSource.pitch = pitch;
			audioSource.spatialBlend = 0.8f;
			audioSource.rolloffMode = AudioRolloffMode.Linear;
			audioSource.SetCustomCurve(AudioSourceCurveType.ReverbZoneMix, defaultReverbZoneMix);
			audioSource.dopplerLevel = 0f;
			audioSource.clip = clip;
			audioSource.spread = 0f;
			audioSource.loop = loop;
			audioSource.mute = false;
			audioSource.minDistance = theAudioManager.audioMinFallOffDistance;
			audioSource.maxDistance = theAudioManager.audioMaxFallOffDistance;
			audioSource.outputAudioMixerGroup = EmitterGroup;
			soundEmitter.endPlayTime = Time.time + clip.length + delay;
			soundEmitter.defaultVolume = audioSource.volume;
			soundEmitter.priority = SoundPriority.Default;
			soundEmitter.onFinished = null;
			soundEmitter.SetPlayingSoundGroup(null);
			if (src == EmitterChannel.Any)
			{
				theAudioManager.playingEmitters.AddUnique(soundEmitter);
			}
			if (osp != null)
			{
				osp.EnableSpatialization = false;
			}
			audioSource.transform.position = position;
			if (theAudioManager.verboseLogging)
			{
				UnityEngine.Debug.Log("[AudioManager] PlaySoundAt() channel = " + num + " clip = " + clip.name + " volume = " + soundEmitter.volume + " Delay = " + delay + " time = " + Time.time + "\n");
			}
			if (delay > 0f)
			{
				audioSource.PlayDelayed(delay);
			}
			else
			{
				audioSource.Play();
			}
			return num;
		}

		public static void SetOnFinished(int emitterIdx, Action onFinished)
		{
			if (ValidateEmitterIndex(emitterIdx))
			{
				theAudioManager.soundEmitters[emitterIdx].SetOnFinished(onFinished);
			}
		}

		public static void SetOnFinished(int emitterIdx, Action<object> onFinished, object obj)
		{
			if (ValidateEmitterIndex(emitterIdx))
			{
				theAudioManager.soundEmitters[emitterIdx].SetOnFinished(onFinished, obj);
			}
		}

		public static void AttachSoundToParent(int idx, Transform parent)
		{
			if (theAudioManager.verboseLogging)
			{
				string text = parent.name;
				if (parent.parent != null)
				{
					text = parent.parent.name + "/" + text;
				}
				UnityEngine.Debug.Log("[AudioManager] ATTACHING INDEX " + idx + " to " + text);
			}
			theAudioManager.soundEmitters[idx].ParentTo(parent);
		}

		public static void DetachSoundFromParent(int idx)
		{
			if (theAudioManager.verboseLogging)
			{
				UnityEngine.Debug.Log("[AudioManager] DETACHING INDEX " + idx);
			}
			theAudioManager.soundEmitters[idx].DetachFromParent();
		}

		public static void DetachSoundsFromParent(SoundEmitter[] emitters, bool stopSounds = true)
		{
			if (emitters == null)
			{
				return;
			}
			foreach (SoundEmitter soundEmitter in emitters)
			{
				if (soundEmitter.defaultParent != null)
				{
					if (stopSounds)
					{
						soundEmitter.Stop();
					}
					soundEmitter.DetachFromParent();
					soundEmitter.gameObject.SetActive(value: true);
				}
				else if (stopSounds)
				{
					soundEmitter.Stop();
				}
			}
		}

		public static void SetEmitterMixerGroup(int idx, AudioMixerGroup mixerGroup)
		{
			if (theAudioManager != null && idx > -1)
			{
				theAudioManager.soundEmitters[idx].SetAudioMixer(mixerGroup);
			}
		}

		public static MixerSnapshot GetActiveSnapshot()
		{
			if (!(theAudioManager != null))
			{
				return null;
			}
			return theAudioManager.currentSnapshot;
		}

		public static void SetCurrentSnapshot(MixerSnapshot mixerSnapshot)
		{
			if (theAudioManager != null)
			{
				if (mixerSnapshot != null && mixerSnapshot.snapshot != null)
				{
					mixerSnapshot.snapshot.TransitionTo(mixerSnapshot.transitionTime);
				}
				else
				{
					mixerSnapshot = null;
				}
				theAudioManager.currentSnapshot = mixerSnapshot;
			}
		}

		public static void BlendWithCurrentSnapshot(MixerSnapshot blendSnapshot, float weight, float blendTime = 0f)
		{
			if (!(theAudioManager != null))
			{
				return;
			}
			if (theAudioManager.audioMixer == null)
			{
				UnityEngine.Debug.LogWarning("[AudioManager] can't call BlendWithCurrentSnapshot if the audio mixer is not set!");
				return;
			}
			if (blendTime == 0f)
			{
				blendTime = Time.deltaTime;
			}
			if (theAudioManager.currentSnapshot != null && theAudioManager.currentSnapshot.snapshot != null && blendSnapshot != null && blendSnapshot.snapshot != null)
			{
				weight = Mathf.Clamp01(weight);
				if (weight == 0f)
				{
					theAudioManager.currentSnapshot.snapshot.TransitionTo(blendTime);
					return;
				}
				AudioMixerSnapshot[] snapshots = new AudioMixerSnapshot[2]
				{
					theAudioManager.currentSnapshot.snapshot,
					blendSnapshot.snapshot
				};
				float[] weights = new float[2]
				{
					1f - weight,
					weight
				};
				theAudioManager.audioMixer.TransitionToSnapshots(snapshots, weights, blendTime);
			}
		}
	}
	public enum EmitterChannel
	{
		None = -1,
		Reserved,
		Any
	}
	[Serializable]
	public class MixerSnapshot
	{
		public AudioMixerSnapshot snapshot;

		public float transitionTime = 0.25f;
	}
	public class MinMaxAttribute : PropertyAttribute
	{
		public float minDefaultVal = 1f;

		public float maxDefaultVal = 1f;

		public float min;

		public float max = 1f;

		public MinMaxAttribute(float minDefaultVal, float maxDefaultVal, float min, float max)
		{
			this.minDefaultVal = minDefaultVal;
			this.maxDefaultVal = maxDefaultVal;
			this.min = min;
			this.max = max;
		}
	}
	public class SoundEmitter : MonoBehaviour
	{
		public enum FadeState
		{
			Null,
			FadingIn,
			FadingOut,
			Ducking
		}

		public EmitterChannel channel;

		public bool disableSpatialization;

		private FadeState state;

		[NonSerialized]
		[HideInInspector]
		public AudioSource audioSource;

		[NonSerialized]
		[HideInInspector]
		public SoundPriority priority;

		[NonSerialized]
		[HideInInspector]
		public ONSPAudioSource osp;

		[NonSerialized]
		[HideInInspector]
		public float endPlayTime;

		private Transform lastParentTransform;

		[NonSerialized]
		[HideInInspector]
		public float defaultVolume = 1f;

		[NonSerialized]
		[HideInInspector]
		public Transform defaultParent;

		[NonSerialized]
		[HideInInspector]
		public int originalIdx = -1;

		[NonSerialized]
		[HideInInspector]
		public Action onFinished;

		[NonSerialized]
		[HideInInspector]
		public Action<object> onFinishedObject;

		[NonSerialized]
		[HideInInspector]
		public object onFinishedParam;

		[NonSerialized]
		[HideInInspector]
		public SoundGroup playingSoundGroup;

		public float volume
		{
			get
			{
				return audioSource.volume;
			}
			set
			{
				audioSource.volume = value;
			}
		}

		public float pitch
		{
			get
			{
				return audioSource.pitch;
			}
			set
			{
				audioSource.pitch = value;
			}
		}

		public AudioClip clip
		{
			get
			{
				return audioSource.clip;
			}
			set
			{
				audioSource.clip = value;
			}
		}

		public float time
		{
			get
			{
				return audioSource.time;
			}
			set
			{
				audioSource.time = value;
			}
		}

		public float length
		{
			get
			{
				if (!(audioSource.clip != null))
				{
					return 0f;
				}
				return audioSource.clip.length;
			}
		}

		public bool loop
		{
			get
			{
				return audioSource.loop;
			}
			set
			{
				audioSource.loop = value;
			}
		}

		public bool mute
		{
			get
			{
				return audioSource.mute;
			}
			set
			{
				audioSource.mute = value;
			}
		}

		public AudioVelocityUpdateMode velocityUpdateMode
		{
			get
			{
				return audioSource.velocityUpdateMode;
			}
			set
			{
				audioSource.velocityUpdateMode = value;
			}
		}

		public bool isPlaying => audioSource.isPlaying;

		private void Awake()
		{
			audioSource = GetComponent<AudioSource>();
			if (audioSource == null)
			{
				audioSource = base.gameObject.AddComponent<AudioSource>();
			}
			if (AudioManager.enableSpatialization && !disableSpatialization)
			{
				osp = GetComponent<ONSPAudioSource>();
				if (osp == null)
				{
					osp = base.gameObject.AddComponent<ONSPAudioSource>();
				}
			}
			audioSource.playOnAwake = false;
			audioSource.Stop();
		}

		public void SetPlayingSoundGroup(SoundGroup soundGroup)
		{
			playingSoundGroup = soundGroup;
			soundGroup?.IncrementPlayCount();
		}

		public void SetOnFinished(Action onFinished)
		{
			this.onFinished = onFinished;
		}

		public void SetOnFinished(Action<object> onFinished, object obj)
		{
			onFinishedObject = onFinished;
			onFinishedParam = obj;
		}

		public void SetChannel(int _channel)
		{
			channel = (EmitterChannel)_channel;
		}

		public void SetDefaultParent(Transform parent)
		{
			defaultParent = parent;
		}

		public void SetAudioMixer(AudioMixerGroup _mixer)
		{
			if (audioSource != null)
			{
				audioSource.outputAudioMixerGroup = _mixer;
			}
		}

		public bool IsPlaying()
		{
			if (loop && audioSource.isPlaying)
			{
				return true;
			}
			return endPlayTime > Time.time;
		}

		public void Play()
		{
			state = FadeState.Null;
			endPlayTime = Time.time + length;
			StopAllCoroutines();
			audioSource.Play();
		}

		public void Pause()
		{
			state = FadeState.Null;
			StopAllCoroutines();
			audioSource.Pause();
		}

		public void Stop()
		{
			state = FadeState.Null;
			StopAllCoroutines();
			if (audioSource != null)
			{
				audioSource.Stop();
			}
			if (onFinished != null)
			{
				onFinished();
				onFinished = null;
			}
			if (onFinishedObject != null)
			{
				onFinishedObject(onFinishedParam);
				onFinishedObject = null;
			}
			if (playingSoundGroup != null)
			{
				playingSoundGroup.DecrementPlayCount();
				playingSoundGroup = null;
			}
		}

		private int GetSampleTime()
		{
			return audioSource.clip.samples - audioSource.timeSamples;
		}

		public void ParentTo(Transform parent)
		{
			if (lastParentTransform != null)
			{
				UnityEngine.Debug.LogError("[SoundEmitter] You must detach the sound emitter before parenting to another object!");
				return;
			}
			lastParentTransform = base.transform.parent;
			base.transform.parent = parent;
		}

		public void DetachFromParent()
		{
			if (lastParentTransform == null)
			{
				base.transform.parent = defaultParent;
				return;
			}
			base.transform.parent = lastParentTransform;
			lastParentTransform = null;
		}

		public void ResetParent(Transform parent)
		{
			base.transform.parent = parent;
			lastParentTransform = null;
		}

		public void SyncTo(SoundEmitter other, float fadeTime, float toVolume)
		{
			StartCoroutine(DelayedSyncTo(other, fadeTime, toVolume));
		}

		private IEnumerator DelayedSyncTo(SoundEmitter other, float fadeTime, float toVolume)
		{
			yield return new WaitForEndOfFrame();
			audioSource.time = other.time;
			audioSource.Play();
			FadeTo(fadeTime, toVolume);
		}

		public void FadeTo(float fadeTime, float toVolume)
		{
			if (state != FadeState.FadingOut)
			{
				state = FadeState.Ducking;
				StopAllCoroutines();
				StartCoroutine(FadeSoundChannelTo(fadeTime, toVolume));
			}
		}

		public void FadeIn(float fadeTime, float defaultVolume)
		{
			audioSource.volume = 0f;
			state = FadeState.FadingIn;
			StopAllCoroutines();
			StartCoroutine(FadeSoundChannel(0f, fadeTime, Fade.In, defaultVolume));
		}

		public void FadeIn(float fadeTime)
		{
			audioSource.volume = 0f;
			state = FadeState.FadingIn;
			StopAllCoroutines();
			StartCoroutine(FadeSoundChannel(0f, fadeTime, Fade.In, defaultVolume));
		}

		public void FadeOut(float fadeTime)
		{
			if (audioSource.isPlaying)
			{
				state = FadeState.FadingOut;
				StopAllCoroutines();
				StartCoroutine(FadeSoundChannel(0f, fadeTime, Fade.Out, audioSource.volume));
			}
		}

		public void FadeOutDelayed(float delayedSecs, float fadeTime)
		{
			if (audioSource.isPlaying)
			{
				state = FadeState.FadingOut;
				StopAllCoroutines();
				StartCoroutine(FadeSoundChannel(delayedSecs, fadeTime, Fade.Out, audioSource.volume));
			}
		}

		private IEnumerator FadeSoundChannelTo(float fadeTime, float toVolume)
		{
			float start = audioSource.volume;
			float startTime = Time.realtimeSinceStartup;
			float elapsedTime = 0f;
			while (elapsedTime < fadeTime)
			{
				elapsedTime = Time.realtimeSinceStartup - startTime;
				float t = elapsedTime / fadeTime;
				audioSource.volume = Mathf.Lerp(start, toVolume, t);
				yield return 0;
			}
			state = FadeState.Null;
		}

		private IEnumerator FadeSoundChannel(float delaySecs, float fadeTime, Fade fadeType, float defaultVolume)
		{
			if (delaySecs > 0f)
			{
				yield return new WaitForSeconds(delaySecs);
			}
			float start = ((fadeType == Fade.In) ? 0f : defaultVolume);
			float end = ((fadeType == Fade.In) ? defaultVolume : 0f);
			bool restartPlay = false;
			if (fadeType == Fade.In)
			{
				if (Time.time == 0f)
				{
					restartPlay = true;
				}
				audioSource.volume = 0f;
				audioSource.Play();
			}
			float startTime = Time.realtimeSinceStartup;
			float elapsedTime = 0f;
			while (elapsedTime < fadeTime)
			{
				elapsedTime = Time.realtimeSinceStartup - startTime;
				float t = elapsedTime / fadeTime;
				audioSource.volume = Mathf.Lerp(start, end, t);
				yield return 0;
				if (restartPlay && Time.time > 0f)
				{
					audioSource.Play();
					restartPlay = false;
				}
				if (!audioSource.isPlaying)
				{
					break;
				}
			}
			if (fadeType == Fade.Out)
			{
				Stop();
			}
			state = FadeState.Null;
		}
	}
	public enum SoundFXNext
	{
		Random,
		Sequential
	}
	public enum FreqHint
	{
		None,
		Wide,
		Narrow
	}
	public enum SoundPriority
	{
		VeryLow = -2,
		Low,
		Default,
		High,
		VeryHigh
	}
	[Serializable]
	public class OSPProps
	{
		[Tooltip("Set to true to play the sound FX spatialized with binaural HRTF, default = false")]
		public bool enableSpatialization;

		[Tooltip("Play the sound FX with reflections, default = false")]
		public bool useFastOverride;

		[Tooltip("Boost the gain on the spatialized sound FX, default = 0.0")]
		[Range(0f, 24f)]
		public float gain;

		[Tooltip("Enable Inverse Square attenuation curve, default = false")]
		public bool enableInvSquare;

		[Tooltip("Change the sound from point source (0.0f) to a spherical volume, default = 0.0")]
		[Range(0f, 1000f)]
		public float volumetric;

		[Tooltip("Set the near and far falloff value for the OSP attenuation curve, default = 1.0")]
		[MinMax(1f, 25f, 0f, 250f)]
		public Vector2 invSquareFalloff = new Vector2(1f, 25f);

		public OSPProps()
		{
			enableSpatialization = false;
			useFastOverride = false;
			gain = 0f;
			enableInvSquare = false;
			volumetric = 0f;
			invSquareFalloff = new Vector2(1f, 25f);
		}
	}
	[Serializable]
	public class SoundFX
	{
		[Tooltip("Each sound FX should have a unique name")]
		public string name = string.Empty;

		[Tooltip("Sound diversity playback option when multiple audio clips are defined, default = Random")]
		public SoundFXNext playback;

		[Tooltip("Default volume for this sound FX, default = 1.0")]
		[Range(0f, 1f)]
		public float volume = 1f;

		[Tooltip("Random pitch variance each time a sound FX is played, default = 1.0 (none)")]
		[MinMax(1f, 1f, 0f, 2f)]
		public Vector2 pitchVariance = Vector2.one;

		[Tooltip("Falloff distance for the sound FX, default = 1m min to 25m max")]
		[MinMax(1f, 25f, 0f, 250f)]
		public Vector2 falloffDistance = new Vector2(1f, 25f);

		[Tooltip("Volume falloff curve - sets how the sound FX attenuates over distance, default = Linear")]
		public AudioRolloffMode falloffCurve = AudioRolloffMode.Linear;

		[Tooltip("Defines the custom volume falloff curve")]
		public AnimationCurve volumeFalloffCurve = new AnimationCurve(new Keyframe(0f, 1f), new Keyframe(1f, 1f));

		[Tooltip("The amount by which the signal from the AudioSource will be mixed into the global reverb associated with the Reverb Zones | Valid range is 0.0 - 1.1, default = 1.0")]
		public AnimationCurve reverbZoneMix = new AnimationCurve(new Keyframe(0f, 1f), new Keyframe(1f, 1f));

		[Tooltip("Sets the spread angle (in degrees) of a 3d stereo or multichannel sound in speaker space, default = 0")]
		[Range(0f, 360f)]
		public float spread;

		[Tooltip("The percentage chance that this sound FX will play | 0.0 = none, 1.0 = 100%, default = 1.0")]
		[Range(0f, 1f)]
		public float pctChanceToPlay = 1f;

		[Tooltip("Sets the priority for this sound to play and/or to override a currently playing sound FX, default = Default")]
		public SoundPriority priority;

		[Tooltip("Specifies the default delay when this sound FX is played, default = 0.0 secs")]
		[MinMax(0f, 0f, 0f, 2f)]
		public Vector2 delay = Vector2.zero;

		[Tooltip("Set to true for the sound to loop continuously, default = false")]
		public bool looping;

		public OSPProps ospProps = new OSPProps();

		[Tooltip("List of the audio clips assigned to this sound FX")]
		public AudioClip[] soundClips = new AudioClip[1];

		public bool visibilityToggle;

		[NonSerialized]
		private SoundGroup soundGroup;

		private int lastIdx = -1;

		private int playingIdx = -1;

		public int Length => soundClips.Length;

		public bool IsValid
		{
			get
			{
				if (soundClips.Length != 0)
				{
					return soundClips[0] != null;
				}
				return false;
			}
		}

		public SoundGroup Group
		{
			get
			{
				return soundGroup;
			}
			set
			{
				soundGroup = value;
			}
		}

		public float MaxFalloffDistSquared => falloffDistance.y * falloffDistance.y;

		public float GroupVolumeOverride
		{
			get
			{
				if (soundGroup == null)
				{
					return 1f;
				}
				return soundGroup.volumeOverride;
			}
		}

		public SoundFX()
		{
			playback = SoundFXNext.Random;
			volume = 1f;
			pitchVariance = Vector2.one;
			falloffDistance = new Vector2(1f, 25f);
			falloffCurve = AudioRolloffMode.Linear;
			volumeFalloffCurve = new AnimationCurve(new Keyframe(0f, 1f), new Keyframe(1f, 1f));
			reverbZoneMix = new AnimationCurve(new Keyframe(0f, 1f), new Keyframe(1f, 1f));
			spread = 0f;
			pctChanceToPlay = 1f;
			priority = SoundPriority.Default;
			delay = Vector2.zero;
			looping = false;
			ospProps = new OSPProps();
		}

		public AudioClip GetClip()
		{
			if (soundClips.Length == 0)
			{
				return null;
			}
			if (soundClips.Length == 1)
			{
				return soundClips[0];
			}
			if (playback == SoundFXNext.Random)
			{
				int num;
				for (num = UnityEngine.Random.Range(0, soundClips.Length); num == lastIdx; num = UnityEngine.Random.Range(0, soundClips.Length))
				{
				}
				lastIdx = num;
				return soundClips[num];
			}
			if (++lastIdx >= soundClips.Length)
			{
				lastIdx = 0;
			}
			return soundClips[lastIdx];
		}

		public AudioMixerGroup GetMixerGroup(AudioMixerGroup defaultMixerGroup)
		{
			if (soundGroup != null)
			{
				if (!(soundGroup.mixerGroup != null))
				{
					return defaultMixerGroup;
				}
				return soundGroup.mixerGroup;
			}
			return defaultMixerGroup;
		}

		public bool ReachedGroupPlayLimit()
		{
			if (soundGroup != null)
			{
				return !soundGroup.CanPlaySound();
			}
			return false;
		}

		public float GetClipLength(int idx)
		{
			if (idx == -1 || soundClips.Length == 0 || idx >= soundClips.Length || soundClips[idx] == null)
			{
				return 0f;
			}
			return soundClips[idx].length;
		}

		public float GetPitch()
		{
			return UnityEngine.Random.Range(pitchVariance.x, pitchVariance.y);
		}

		public int PlaySound(float delaySecs = 0f)
		{
			playingIdx = -1;
			if (!IsValid)
			{
				return playingIdx;
			}
			if (pctChanceToPlay > 0.99f || UnityEngine.Random.value < pctChanceToPlay)
			{
				if (delay.y > 0f)
				{
					delaySecs = UnityEngine.Random.Range(delay.x, delay.y);
				}
				playingIdx = AudioManager.PlaySound(this, EmitterChannel.Any, delaySecs);
			}
			return playingIdx;
		}

		public int PlaySoundAt(Vector3 pos, float delaySecs = 0f, float volumeOverride = 1f, float pitchMultiplier = 1f)
		{
			playingIdx = -1;
			if (!IsValid)
			{
				return playingIdx;
			}
			if (pctChanceToPlay > 0.99f || UnityEngine.Random.value < pctChanceToPlay)
			{
				if (delay.y > 0f)
				{
					delaySecs = UnityEngine.Random.Range(delay.x, delay.y);
				}
				playingIdx = AudioManager.PlaySoundAt(pos, this, EmitterChannel.Any, delaySecs, volumeOverride, pitchMultiplier);
			}
			return playingIdx;
		}

		public void SetOnFinished(Action onFinished)
		{
			if (playingIdx > -1)
			{
				AudioManager.SetOnFinished(playingIdx, onFinished);
			}
		}

		public void SetOnFinished(Action<object> onFinished, object obj)
		{
			if (playingIdx > -1)
			{
				AudioManager.SetOnFinished(playingIdx, onFinished, obj);
			}
		}

		public bool StopSound()
		{
			bool result = false;
			if (playingIdx > -1)
			{
				result = AudioManager.StopSound(playingIdx);
				playingIdx = -1;
			}
			return result;
		}

		public void AttachToParent(Transform parent)
		{
			if (playingIdx > -1)
			{
				AudioManager.AttachSoundToParent(playingIdx, parent);
			}
		}

		public void DetachFromParent()
		{
			if (playingIdx > -1)
			{
				AudioManager.DetachSoundFromParent(playingIdx);
			}
		}
	}
	[Serializable]
	public class SoundFXRef
	{
		public string soundFXName = string.Empty;

		private bool initialized;

		private SoundFX soundFXCached;

		public SoundFX soundFX
		{
			get
			{
				if (!initialized)
				{
					Init();
				}
				return soundFXCached;
			}
		}

		public string name
		{
			get
			{
				return soundFXName;
			}
			set
			{
				soundFXName = value;
				Init();
			}
		}

		public int Length => soundFX.Length;

		public bool IsValid => soundFX.IsValid;

		private void Init()
		{
			soundFXCached = AudioManager.FindSoundFX(soundFXName);
			if (soundFXCached == null)
			{
				soundFXCached = AudioManager.FindSoundFX(string.Empty);
			}
			initialized = true;
		}

		public AudioClip GetClip()
		{
			return soundFX.GetClip();
		}

		public float GetClipLength(int idx)
		{
			return soundFX.GetClipLength(idx);
		}

		public int PlaySound(float delaySecs = 0f)
		{
			return soundFX.PlaySound(delaySecs);
		}

		public int PlaySoundAt(Vector3 pos, float delaySecs = 0f, float volume = 1f, float pitchMultiplier = 1f)
		{
			return soundFX.PlaySoundAt(pos, delaySecs, volume, pitchMultiplier);
		}

		public void SetOnFinished(Action onFinished)
		{
			soundFX.SetOnFinished(onFinished);
		}

		public void SetOnFinished(Action<object> onFinished, object obj)
		{
			soundFX.SetOnFinished(onFinished, obj);
		}

		public bool StopSound()
		{
			return soundFX.StopSound();
		}

		public void AttachToParent(Transform parent)
		{
			soundFX.AttachToParent(parent);
		}

		public void DetachFromParent()
		{
			soundFX.DetachFromParent();
		}
	}
}
namespace Dreamteck
{
	public static class ArrayUtility
	{
		public static void Add<T>(ref T[] array, T item)
		{
			T[] array2 = new T[array.Length + 1];
			array.CopyTo(array2, 0);
			array2[array2.Length - 1] = item;
			array = array2;
		}

		public static bool Contains<T>(T[] array, T item)
		{
			for (int i = 0; i < array.Length; i++)
			{
				if (array[i].Equals(item))
				{
					return true;
				}
			}
			return false;
		}

		public static int IndexOf<T>(T[] array, T value)
		{
			for (int i = 0; i < array.Length; i++)
			{
				if (array[i].Equals(value))
				{
					return i;
				}
			}
			return 0;
		}

		public static void Insert<T>(ref T[] array, int index, T item)
		{
			T[] array2 = new T[array.Length + 1];
			for (int i = 0; i < array2.Length; i++)
			{
				if (i < index)
				{
					array2[i] = array[i];
				}
				else if (i > index)
				{
					array2[i] = array[i - 1];
				}
				else
				{
					array2[i] = item;
				}
			}
			array = array2;
		}

		public static void RemoveAt<T>(ref T[] array, int index)
		{
			if (array.Length == 0)
			{
				return;
			}
			T[] array2 = new T[array.Length - 1];
			for (int i = 0; i < array.Length; i++)
			{
				if (i < index)
				{
					array2[i] = array[i];
				}
				else if (i > index)
				{
					array2[i - 1] = array[i];
				}
			}
			array = array2;
		}
	}
	public static class DMath
	{
		public static double Sin(double a)
		{
			return Math.Sin(a);
		}

		public static double Cos(double a)
		{
			return Math.Cos(a);
		}

		public static double Tan(double a)
		{
			return Math.Tan(a);
		}

		public static double Pow(double x, double y)
		{
			return Math.Pow(x, y);
		}

		public static double Log(double a, double newBase)
		{
			return Math.Log(a, newBase);
		}

		public static double Log10(double a)
		{
			return Math.Log10(a);
		}

		public static double Clamp01(double a)
		{
			if (a > 1.0)
			{
				return 1.0;
			}
			if (a < 0.0)
			{
				return 0.0;
			}
			return a;
		}

		public static double Clamp(double a, double min, double max)
		{
			if (a > max)
			{
				return max;
			}
			if (a < min)
			{
				return min;
			}
			return a;
		}

		public static double Lerp(double a, double b, double t)
		{
			t = Clamp01(t);
			return a + (b - a) * t;
		}

		public static double InverseLerp(double a, double b, double t)
		{
			if (a == b)
			{
				return 0.0;
			}
			return Clamp01((t - a) / (b - a));
		}

		public static Vector3 LerpVector3(Vector3 a, Vector3 b, double t)
		{
			t = Clamp01(t);
			Vector3 vector = b - a;
			double num = (double)a.x + (double)vector.x * t;
			double num2 = (double)a.y + (double)vector.y * t;
			double num3 = (double)a.z + (double)vector.z * t;
			return new Vector3((float)num, (float)num2, (float)num3);
		}

		public static double Round(double a)
		{
			return Math.Round(a);
		}

		public static int RoundInt(double a)
		{
			return (int)Math.Round(a);
		}

		public static double Ceil(double a)
		{
			return Math.Ceiling(a);
		}

		public static int CeilInt(double a)
		{
			return (int)Math.Ceiling(a);
		}

		public static double Floor(double a)
		{
			return Math.Floor(a);
		}

		public static int FloorInt(double a)
		{
			return (int)Math.Floor(a);
		}

		public static double Move(double current, double target, double amount)
		{
			if (target > current)
			{
				current += amount;
				if (current > target)
				{
					return target;
				}
			}
			else
			{
				current -= amount;
				if (current < target)
				{
					return target;
				}
			}
			return current;
		}

		public static double Abs(double a)
		{
			if (a < 0.0)
			{
				return a * -1.0;
			}
			return a;
		}
	}
	public static class DuplicateUtility
	{
		public static AnimationCurve DuplicateCurve(AnimationCurve input)
		{
			AnimationCurve animationCurve = new AnimationCurve();
			animationCurve.postWrapMode = input.postWrapMode;
			animationCurve.preWrapMode = input.preWrapMode;
			for (int i = 0; i < input.keys.Length; i++)
			{
				animationCurve.AddKey(input.keys[i]);
			}
			return animationCurve;
		}

		public static Gradient DuplicateGradient(Gradient input)
		{
			return null;
		}
	}
	public static class LinearAlgebraUtility
	{
		public static Vector3 ProjectOnLine(Vector3 fromPoint, Vector3 toPoint, Vector3 project)
		{
			Vector3 vector = Vector3.Project(project - fromPoint, toPoint - fromPoint) + fromPoint;
			Vector3 rhs = toPoint - fromPoint;
			Vector3 lhs = vector - fromPoint;
			if (Vector3.Dot(lhs, rhs) > 0f)
			{
				if (lhs.sqrMagnitude <= rhs.sqrMagnitude)
				{
					return vector;
				}
				return toPoint;
			}
			return fromPoint;
		}

		public static float InverseLerp(Vector3 a, Vector3 b, Vector3 value)
		{
			Vector3 vector = b - a;
			return Vector3.Dot(value - a, vector) / Vector3.Dot(vector, vector);
		}
	}
	public class MeshUtility
	{
		private static Vector3[] tan1 = new Vector3[0];

		private static Vector3[] tan2 = new Vector3[0];

		public static int[] GeneratePlaneTriangles(int x, int z, bool flip, int startTriangleIndex = 0, int startVertex = 0)
		{
			int[] triangles = new int[x * (z - 1) * 6];
			GeneratePlaneTriangles(ref triangles, x, z, flip);
			return triangles;
		}

		public static int[] GeneratePlaneTriangles(ref int[] triangles, int x, int z, bool flip, int startTriangleIndex = 0, int startVertex = 0, bool reallocateArray = false)
		{
			int num = x * (z - 1);
			if (reallocateArray && triangles.Length != num * 6)
			{
				if (startTriangleIndex > 0)
				{
					int[] array = new int[startTriangleIndex + num * 6];
					for (int i = 0; i < startTriangleIndex; i++)
					{
						array[i] = triangles[i];
					}
					triangles = array;
				}
				else
				{
					triangles = new int[num * 6];
				}
			}
			int num2 = x + 1;
			int num3 = startTriangleIndex;
			for (int j = 0; j < num + z - 2; j++)
			{
				if ((float)(j + 1) % (float)num2 == 0f && j != 0)
				{
					j++;
				}
				if (flip)
				{
					triangles[num3++] = j + x + 1 + startVertex;
					triangles[num3++] = j + 1 + startVertex;
					triangles[num3++] = j + startVertex;
					triangles[num3++] = j + x + 1 + startVertex;
					triangles[num3++] = j + x + 2 + startVertex;
					triangles[num3++] = j + 1 + startVertex;
				}
				else
				{
					triangles[num3++] = j + startVertex;
					triangles[num3++] = j + 1 + startVertex;
					triangles[num3++] = j + x + 1 + startVertex;
					triangles[num3++] = j + 1 + startVertex;
					triangles[num3++] = j + x + 2 + startVertex;
					triangles[num3++] = j + x + 1 + startVertex;
				}
			}
			return triangles;
		}

		public static void CalculateTangents(TS_Mesh mesh)
		{
			int num = mesh.triangles.Length / 3;
			if (mesh.tangents.Length != mesh.vertexCount)
			{
				mesh.tangents = new Vector4[mesh.vertexCount];
			}
			if (tan1.Length != mesh.vertexCount)
			{
				tan1 = new Vector3[mesh.vertexCount];
				tan2 = new Vector3[mesh.vertexCount];
			}
			int num2 = 0;
			for (int i = 0; i < num; i++)
			{
				int num3 = mesh.triangles[num2];
				int num4 = mesh.triangles[num2 + 1];
				int num5 = mesh.triangles[num2 + 2];
				float num6 = mesh.vertices[num4].x - mesh.vertices[num3].x;
				float num7 = mesh.vertices[num5].x - mesh.vertices[num3].x;
				float num8 = mesh.vertices[num4].y - mesh.vertices[num3].y;
				float num9 = mesh.vertices[num5].y - mesh.vertices[num3].y;
				float num10 = mesh.vertices[num4].z - mesh.vertices[num3].z;
				float num11 = mesh.vertices[num5].z - mesh.vertices[num3].z;
				float num12 = mesh.uv[num4].x - mesh.uv[num3].x;
				float num13 = mesh.uv[num5].x - mesh.uv[num3].x;
				float num14 = mesh.uv[num4].y - mesh.uv[num3].y;
				float num15 = mesh.uv[num5].y - mesh.uv[num3].y;
				float num16 = num12 * num15 - num13 * num14;
				float num17 = ((num16 == 0f) ? 0f : (1f / num16));
				Vector3 vector = new Vector3((num15 * num6 - num14 * num7) * num17, (num15 * num8 - num14 * num9) * num17, (num15 * num10 - num14 * num11) * num17);
				Vector3 vector2 = new Vector3((num12 * num7 - num13 * num6) * num17, (num12 * num9 - num13 * num8) * num17, (num12 * num11 - num13 * num10) * num17);
				tan1[num3] += vector;
				tan1[num4] += vector;
				tan1[num5] += vector;
				tan2[num3] += vector2;
				tan2[num4] += vector2;
				tan2[num5] += vector2;
				num2 += 3;
			}
			for (int j = 0; j < mesh.vertexCount; j++)
			{
				Vector3 normal = mesh.normals[j];
				Vector3 tangent = tan1[j];
				Vector3.OrthoNormalize(ref normal, ref tangent);
				mesh.tangents[j].x = tangent.x;
				mesh.tangents[j].y = tangent.y;
				mesh.tangents[j].z = tangent.z;
				mesh.tangents[j].w = ((Vector3.Dot(Vector3.Cross(normal, tangent), tan2[j]) < 0f) ? (-1f) : 1f);
			}
		}

		public static void MakeDoublesided(Mesh input)
		{
			Vector3[] vertices = input.vertices;
			Vector3[] normals = input.normals;
			Vector2[] uv = input.uv;
			Color[] colors = input.colors;
			int[] triangles = input.triangles;
			List<int[]> list = new List<int[]>();
			for (int i = 0; i < input.subMeshCount; i++)
			{
				list.Add(input.GetTriangles(i));
			}
			Vector3[] array = new Vector3[vertices.Length * 2];
			Vector3[] array2 = new Vector3[normals.Length * 2];
			Vector2[] array3 = new Vector2[uv.Length * 2];
			Color[] array4 = new Color[colors.Length * 2];
			int[] array5 = new int[triangles.Length * 2];
			List<int[]> list2 = new List<int[]>();
			for (int j = 0; j < list.Count; j++)
			{
				list2.Add(new int[list[j].Length * 2]);
				list[j].CopyTo(list2[j], 0);
			}
			for (int k = 0; k < vertices.Length; k++)
			{
				array[k] = vertices[k];
				array2[k] = normals[k];
				array3[k] = uv[k];
				if (colors.Length > k)
				{
					array4[k] = colors[k];
				}
				array[k + vertices.Length] = vertices[k];
				array2[k + vertices.Length] = -normals[k];
				array3[k + vertices.Length] = uv[k];
				if (colors.Length > k)
				{
					array4[k + vertices.Length] = colors[k];
				}
			}
			for (int l = 0; l < triangles.Length; l += 3)
			{
				int num = triangles[l];
				int num2 = triangles[l + 1];
				int num3 = triangles[l + 2];
				array5[l] = num;
				array5[l + 1] = num2;
				array5[l + 2] = num3;
				array5[l + triangles.Length] = num3 + vertices.Length;
				array5[l + triangles.Length + 1] = num2 + vertices.Length;
				array5[l + triangles.Length + 2] = num + vertices.Length;
			}
			for (int m = 0; m < list.Count; m++)
			{
				for (int n = 0; n < list[m].Length; n += 3)
				{
					int num4 = list[m][n];
					int num5 = list[m][n + 1];
					int num6 = list[m][n + 2];
					list2[m][n] = num4;
					list2[m][n + 1] = num5;
					list2[m][n + 2] = num6;
					list2[m][n + list[m].Length] = num6 + vertices.Length;
					list2[m][n + list[m].Length + 1] = num5 + vertices.Length;
					list2[m][n + list[m].Length + 2] = num4 + vertices.Length;
				}
			}
			input.vertices = array;
			input.normals = array2;
			input.uv = array3;
			input.colors = array4;
			input.triangles = array5;
			for (int num7 = 0; num7 < list2.Count; num7++)
			{
				input.SetTriangles(list2[num7], num7);
			}
		}

		public static void MakeDoublesided(TS_Mesh input)
		{
			Vector3[] vertices = input.vertices;
			Vector3[] normals = input.normals;
			Vector2[] uv = input.uv;
			Color[] colors = input.colors;
			int[] triangles = input.triangles;
			List<int[]> subMeshes = input.subMeshes;
			Vector3[] array = new Vector3[vertices.Length * 2];
			Vector3[] array2 = new Vector3[normals.Length * 2];
			Vector2[] array3 = new Vector2[uv.Length * 2];
			Color[] array4 = new Color[colors.Length * 2];
			int[] array5 = new int[triangles.Length * 2];
			List<int[]> list = new List<int[]>();
			for (int i = 0; i < subMeshes.Count; i++)
			{
				list.Add(new int[subMeshes[i].Length * 2]);
				subMeshes[i].CopyTo(list[i], 0);
			}
			for (int j = 0; j < vertices.Length; j++)
			{
				array[j] = vertices[j];
				array2[j] = normals[j];
				array3[j] = uv[j];
				if (colors.Length > j)
				{
					array4[j] = colors[j];
				}
				array[j + vertices.Length] = vertices[j];
				array2[j + vertices.Length] = -normals[j];
				array3[j + vertices.Length] = uv[j];
				if (colors.Length > j)
				{
					array4[j + vertices.Length] = colors[j];
				}
			}
			for (int k = 0; k < triangles.Length; k += 3)
			{
				int num = triangles[k];
				int num2 = triangles[k + 1];
				int num3 = triangles[k + 2];
				array5[k] = num;
				array5[k + 1] = num2;
				array5[k + 2] = num3;
				array5[k + triangles.Length] = num3 + vertices.Length;
				array5[k + triangles.Length + 1] = num2 + vertices.Length;
				array5[k + triangles.Length + 2] = num + vertices.Length;
			}
			for (int l = 0; l < subMeshes.Count; l++)
			{
				for (int m = 0; m < subMeshes[l].Length; m += 3)
				{
					int num4 = subMeshes[l][m];
					int num5 = subMeshes[l][m + 1];
					int num6 = subMeshes[l][m + 2];
					list[l][m] = num4;
					list[l][m + 1] = num5;
					list[l][m + 2] = num6;
					list[l][m + subMeshes[l].Length] = num6 + vertices.Length;
					list[l][m + subMeshes[l].Length + 1] = num5 + vertices.Length;
					list[l][m + subMeshes[l].Length + 2] = num4 + vertices.Length;
				}
			}
			input.vertices = array;
			input.normals = array2;
			input.uv = array3;
			input.colors = array4;
			input.triangles = array5;
			input.subMeshes = list;
		}

		public static void MakeDoublesidedHalf(TS_Mesh input)
		{
			int num = input.vertices.Length / 2;
			int num2 = input.triangles.Length / 2;
			for (int i = 0; i < num; i++)
			{
				input.vertices[i + num] = input.vertices[i];
				if (input.normals.Length > i)
				{
					input.normals[i + num] = -input.normals[i];
				}
				if (input.tangents.Length > i)
				{
					input.tangents[i + num] = input.tangents[i];
				}
				if (input.uv.Length > i)
				{
					input.uv[i + num] = input.uv[i];
				}
				if (input.uv2.Length > i)
				{
					input.uv2[i + num] = input.uv2[i];
				}
				if (input.uv3.Length > i)
				{
					input.uv3[i + num] = input.uv3[i];
				}
				if (input.uv4.Length > i)
				{
					input.uv4[i + num] = input.uv4[i];
				}
				if (input.colors.Length > i)
				{
					input.colors[i + num] = input.colors[i];
				}
			}
			for (int j = 0; j < num2; j += 3)
			{
				input.triangles[j + num2 + 2] = input.triangles[j] + num;
				input.triangles[j + num2 + 1] = input.triangles[j + 1] + num;
				input.triangles[j + num2] = input.triangles[j + 2] + num;
			}
			for (int k = 0; k < input.subMeshes.Count; k++)
			{
				num2 = input.subMeshes[k].Length / 2;
				for (int l = 0; l < num2; l += 3)
				{
					input.subMeshes[k][l + num2 + 2] = input.subMeshes[k][l] + num;
					input.subMeshes[k][l + num2 + 1] = input.subMeshes[k][l + 1] + num;
					input.subMeshes[k][l + num2] = input.subMeshes[k][l + 2] + num;
				}
			}
		}

		public static void InverseTransformMesh(TS_Mesh input, TS_Transform transform)
		{
			if (input.vertices != null && input.normals != null)
			{
				for (int i = 0; i < input.vertices.Length; i++)
				{
					input.vertices[i] = transform.InverseTransformPoint(input.vertices[i]);
					input.normals[i] = transform.InverseTransformDirection(input.normals[i]);
				}
			}
		}

		public static void TransformMesh(TS_Mesh input, TS_Transform transform)
		{
			if (input.vertices != null && input.normals != null)
			{
				for (int i = 0; i < input.vertices.Length; i++)
				{
					input.vertices[i] = transform.TransformPoint(input.vertices[i]);
					input.normals[i] = transform.TransformDirection(input.normals[i]);
				}
			}
		}

		public static void InverseTransformMesh(TS_Mesh input, Transform transform)
		{
			if (input.vertices != null && input.normals != null)
			{
				for (int i = 0; i < input.vertices.Length; i++)
				{
					input.vertices[i] = transform.InverseTransformPoint(input.vertices[i]);
					input.normals[i] = transform.InverseTransformDirection(input.normals[i]);
				}
			}
		}

		public static void TransformMesh(TS_Mesh input, Transform transform)
		{
			if (input.vertices != null && input.normals != null)
			{
				for (int i = 0; i < input.vertices.Length; i++)
				{
					input.vertices[i] = transform.TransformPoint(input.vertices[i]);
					input.normals[i] = transform.TransformDirection(input.normals[i]);
				}
			}
		}

		public static void InverseTransformMesh(Mesh input, Transform transform)
		{
			Vector3[] vertices = input.vertices;
			Vector3[] vertices2 = input.vertices;
			Matrix4x4 worldToLocalMatrix = transform.worldToLocalMatrix;
			for (int i = 0; i < vertices.Length; i++)
			{
				vertices[i] = worldToLocalMatrix.MultiplyPoint3x4(vertices[i]);
				vertices2[i] = worldToLocalMatrix.MultiplyVector(vertices2[i]);
			}
			input.vertices = vertices;
			input.normals = vertices2;
		}

		public static void TransformMesh(Mesh input, Transform transform)
		{
			Vector3[] vertices = input.vertices;
			Vector3[] vertices2 = input.vertices;
			Matrix4x4 localToWorldMatrix = transform.localToWorldMatrix;
			if (input.vertices != null && input.normals != null)
			{
				for (int i = 0; i < input.vertices.Length; i++)
				{
					vertices[i] = localToWorldMatrix.MultiplyPoint3x4(vertices[i]);
					vertices2[i] = localToWorldMatrix.MultiplyVector(vertices2[i]);
				}
				input.vertices = vertices;
				input.normals = vertices2;
			}
		}

		public static void TransformVertices(Vector3[] vertices, Transform transform)
		{
			for (int i = 0; i < vertices.Length; i++)
			{
				vertices[i] = transform.TransformPoint(vertices[i]);
			}
		}

		public static void InverseTransformVertices(Vector3[] vertices, Transform transform)
		{
			for (int i = 0; i < vertices.Length; i++)
			{
				vertices[i] = transform.InverseTransformPoint(vertices[i]);
			}
		}

		public static void TransformNormals(Vector3[] normals, Transform transform)
		{
			for (int i = 0; i < normals.Length; i++)
			{
				normals[i] = transform.TransformDirection(normals[i]);
			}
		}

		public static void InverseTransformNormals(Vector3[] normals, Transform transform)
		{
			for (int i = 0; i < normals.Length; i++)
			{
				normals[i] = transform.InverseTransformDirection(normals[i]);
			}
		}

		public static string ToOBJString(Mesh mesh, Material[] materials)
		{
			int num = 0;
			if (mesh == null)
			{
				return "####Error####";
			}
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.Append("g " + mesh.name + "\n");
			Vector3[] vertices = mesh.vertices;
			for (int i = 0; i < vertices.Length; i++)
			{
				Vector3 vector = vertices[i];
				num++;
				stringBuilder.Append($"v {0f - vector.x} {vector.y} {vector.z}\n");
			}
			stringBuilder.Append("\n");
			vertices = mesh.normals;
			for (int i = 0; i < vertices.Length; i++)
			{
				Vector3 vector2 = vertices[i];
				stringBuilder.Append($"vn {0f - vector2.x} {vector2.y} {vector2.z}\n");
			}
			stringBuilder.Append("\n");
			Vector2[] uv = mesh.uv;
			for (int i = 0; i < uv.Length; i++)
			{
				Vector3 vector3 = uv[i];
				stringBuilder.Append($"vt {vector3.x} {vector3.y}\n");
			}
			stringBuilder.Append("\n");
			uv = mesh.uv2;
			for (int i = 0; i < uv.Length; i++)
			{
				Vector2 vector4 = uv[i];
				stringBuilder.Append($"vt2 {vector4.x} {vector4.y}\n");
			}
			stringBuilder.Append("\n");
			uv = mesh.uv3;
			for (int i = 0; i < uv.Length; i++)
			{
				Vector2 vector5 = uv[i];
				stringBuilder.Append($"vt2 {vector5.x} {vector5.y}\n");
			}
			stringBuilder.Append("\n");
			Color[] colors = mesh.colors;
			for (int i = 0; i < colors.Length; i++)
			{
				Color color = colors[i];
				stringBuilder.Append($"vc {color.r} {color.g} {color.b} {color.a}\n");
			}
			for (int j = 0; j < mesh.subMeshCount; j++)
			{
				stringBuilder.Append("\n");
				stringBuilder.Append("usemtl ").Append(materials[j].name).Append("\n");
				stringBuilder.Append("usemap ").Append(materials[j].name).Append("\n");
				int[] triangles = mesh.GetTriangles(j);
				for (int k = 0; k < triangles.Length; k += 3)
				{
					stringBuilder.Append(string.Format("f {2}/{2}/{2} {1}/{1}/{1} {0}/{0}/{0}\n", triangles[k] + 1, triangles[k + 1] + 1, triangles[k + 2] + 1));
				}
			}
			return stringBuilder.ToString().Replace(',', '.');
		}

		public static Mesh Copy(Mesh input)
		{
			Mesh mesh = new Mesh();
			mesh.name = input.name;
			mesh.vertices = input.vertices;
			mesh.normals = input.normals;
			mesh.colors = input.colors;
			mesh.uv = input.uv;
			mesh.uv2 = input.uv2;
			mesh.uv3 = input.uv3;
			mesh.uv4 = input.uv4;
			mesh.tangents = input.tangents;
			mesh.boneWeights = input.boneWeights;
			mesh.bindposes = input.bindposes;
			mesh.triangles = input.triangles;
			mesh.subMeshCount = input.subMeshCount;
			for (int i = 0; i < input.subMeshCount; i++)
			{
				mesh.SetTriangles(input.GetTriangles(i), i);
			}
			return mesh;
		}

		public static void Triangulate(Vector2[] points, ref int[] output)
		{
			List<int> list = new List<int>();
			int num = points.Length;
			if (num < 3)
			{
				output = new int[0];
				return;
			}
			int[] array = new int[num];
			if (Area(points, num) > 0f)
			{
				for (int i = 0; i < num; i++)
				{
					array[i] = i;
				}
			}
			else
			{
				for (int j = 0; j < num; j++)
				{
					array[j] = num - 1 - j;
				}
			}
			int num2 = num;
			int num3 = 2 * num2;
			int num4 = 0;
			int num5 = num2 - 1;
			while (num2 > 2)
			{
				if (num3-- <= 0)
				{
					if (output.Length != list.Count)
					{
						output = new int[list.Count];
					}
					list.CopyTo(output, 0);
					return;
				}
				int num6 = num5;
				if (num2 <= num6)
				{
					num6 = 0;
				}
				num5 = num6 + 1;
				if (num2 <= num5)
				{
					num5 = 0;
				}
				int num7 = num5 + 1;
				if (num2 <= num7)
				{
					num7 = 0;
				}
				if (Snip(points, num6, num5, num7, num2, array))
				{
					int item = array[num6];
					int item2 = array[num5];
					int item3 = array[num7];
					list.Add(item3);
					list.Add(item2);
					list.Add(item);
					num4++;
					int num8 = num5;
					for (int k = num5 + 1; k < num2; k++)
					{
						array[num8] = array[k];
						num8++;
					}
					num2--;
					num3 = 2 * num2;
				}
			}
			list.Reverse();
			if (output.Length != list.Count)
			{
				output = new int[list.Count];
			}
			list.CopyTo(output, 0);
		}

		public static void FlipTriangles(ref int[] triangles)
		{
			for (int i = 0; i < triangles.Length; i += 3)
			{
				int num = triangles[i];
				triangles[i] = triangles[i + 2];
				triangles[i + 2] = num;
			}
		}

		public static void FlipFaces(TS_Mesh input)
		{
			for (int i = 0; i < input.subMeshes.Count; i++)
			{
				int[] triangles = input.subMeshes[i];
				FlipTriangles(ref triangles);
			}
			FlipTriangles(ref input.triangles);
			for (int j = 0; j < input.normals.Length; j++)
			{
				input.normals[j] *= -1f;
			}
		}

		public static void BreakMesh(Mesh input, bool keepNormals = true)
		{
			Vector3[] array = new Vector3[input.triangles.Length];
			Vector3[] array2 = new Vector3[array.Length];
			Vector2[] array3 = new Vector2[array.Length];
			Vector4[] array4 = new Vector4[array.Length];
			Color[] array5 = new Color[array.Length];
			BoneWeight[] array6 = new BoneWeight[array.Length];
			Vector3[] vertices = input.vertices;
			Vector2[] uv = input.uv;
			Vector3[] normals = input.normals;
			Vector4[] tangents = input.tangents;
			Color[] array7 = input.colors;
			BoneWeight[] boneWeights = input.boneWeights;
			if (array7.Length != vertices.Length)
			{
				array7 = new Color[vertices.Length];
				for (int i = 0; i < array7.Length; i++)
				{
					array7[i] = Color.white;
				}
			}
			List<int[]> list = new List<int[]>();
			int subMeshCount = input.subMeshCount;
			int num = 0;
			for (int j = 0; j < subMeshCount; j++)
			{
				int[] triangles = input.GetTriangles(j);
				for (int k = 0; k < triangles.Length; k += 3)
				{
					array[num] = vertices[triangles[k]];
					array[num + 1] = vertices[triangles[k + 1]];
					array[num + 2] = vertices[triangles[k + 2]];
					if (normals.Length > triangles[k + 2])
					{
						if (!keepNormals)
						{
							array2[num] = (array2[num + 1] = (array2[num + 2] = (normals[triangles[k]] + normals[triangles[k + 1]] + normals[triangles[k + 2]]).normalized));
						}
						else
						{
							array2[num] = normals[triangles[k]];
							array2[num + 1] = normals[triangles[k + 1]];
							array2[num + 2] = normals[triangles[k + 2]];
						}
					}
					if (array7.Length > triangles[k + 2])
					{
						array5[num] = (array5[num + 1] = (array5[num + 2] = (array7[triangles[k]] + array7[triangles[k + 1]] + array7[triangles[k + 2]]) / 3f));
					}
					if (uv.Length > triangles[k + 2])
					{
						array3[num] = uv[triangles[k]];
						array3[num + 1] = uv[triangles[k + 1]];
						array3[num + 2] = uv[triangles[k + 2]];
					}
					if (tangents.Length > triangles[k + 2])
					{
						array4[num] = tangents[triangles[k]];
						array4[num + 1] = tangents[triangles[k + 1]];
						array4[num + 2] = tangents[triangles[k + 2]];
					}
					if (boneWeights.Length > triangles[k + 2])
					{
						array6[num] = boneWeights[triangles[k]];
						array6[num + 1] = boneWeights[triangles[k + 1]];
						array6[num + 2] = boneWeights[triangles[k + 2]];
					}
					triangles[k] = num;
					triangles[k + 1] = num + 1;
					triangles[k + 2] = num + 2;
					num += 3;
				}
				list.Add(triangles);
			}
			input.vertices = array;
			input.normals = array2;
			input.colors = array5;
			input.uv = array3;
			input.tangents = array4;
			input.subMeshCount = list.Count;
			input.boneWeights = array6;
			for (int l = 0; l < list.Count; l++)
			{
				input.SetTriangles(list[l], l);
			}
		}

		private static float Area(Vector2[] points, int maxCount)
		{
			float num = 0f;
			int num2 = maxCount - 1;
			int num3 = 0;
			while (num3 < maxCount)
			{
				Vector2 vector = points[num2];
				Vector2 vector2 = points[num3];
				num += vector.x * vector2.y - vector2.x * vector.y;
				num2 = num3++;
			}
			return num * 0.5f;
		}

		private static bool Snip(Vector2[] points, int u, int v, int w, int n, int[] V)
		{
			Vector2 a = points[V[u]];
			Vector2 b = points[V[v]];
			Vector2 c = points[V[w]];
			if (Mathf.Epsilon > (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x))
			{
				return false;
			}
			for (int i = 0; i < n; i++)
			{
				if (i != u && i != v && i != w)
				{
					Vector2 p = points[V[i]];
					if (InsideTriangle(a, b, c, p))
					{
						return false;
					}
				}
			}
			return true;
		}

		private static bool InsideTriangle(Vector2 A, Vector2 B, Vector2 C, Vector2 P)
		{
			float num = C.x - B.x;
			float num2 = C.y - B.y;
			float num3 = A.x - C.x;
			float num4 = A.y - C.y;
			float num5 = B.x - A.x;
			float num6 = B.y - A.y;
			float num7 = P.x - A.x;
			float num8 = P.y - A.y;
			float num9 = P.x - B.x;
			float num10 = P.y - B.y;
			float num11 = P.x - C.x;
			float num12 = P.y - C.y;
			float num13 = num * num10 - num2 * num9;
			float num14 = num5 * num8 - num6 * num7;
			float num15 = num3 * num12 - num4 * num11;
			if (num13 >= 0f && num15 >= 0f)
			{
				return num14 >= 0f;
			}
			return false;
		}
	}
	public static class ResourceUtility
	{
		public static string FindFolder(string dir, string folderPattern)
		{
			if (folderPattern.StartsWith("/"))
			{
				folderPattern = folderPattern.Substring(1);
			}
			if (!dir.EndsWith("/"))
			{
				dir += "/";
			}
			if (folderPattern == "")
			{
				return "";
			}
			string[] array = folderPattern.Split('/');
			if (array.Length == 0)
			{
				return "";
			}
			string text = "";
			try
			{
				string[] directories = Directory.GetDirectories(dir);
				foreach (string text2 in directories)
				{
					if (new DirectoryInfo(text2).Name == array[0])
					{
						text = text2;
						string text3 = FindFolder(text2, string.Join("/", array, 1, array.Length - 1));
						if (text3 != "")
						{
							text = text3;
							break;
						}
					}
				}
				if (text == "")
				{
					directories = Directory.GetDirectories(dir);
					for (int i = 0; i < directories.Length; i++)
					{
						text = FindFolder(directories[i], string.Join("/", array));
						if (text != "")
						{
							break;
						}
					}
				}
			}
			catch (Exception ex)
			{
				UnityEngine.Debug.LogError(ex.Message);
				return "";
			}
			return text;
		}

		public static Texture2D LoadTexture(string dreamteckPath, string textureFileName)
		{
			string text = UnityEngine.Application.dataPath + "/Dreamteck/" + dreamteckPath;
			if (!Directory.Exists(text))
			{
				text = FindFolder(UnityEngine.Application.dataPath, "Dreamteck/" + dreamteckPath);
				if (!Directory.Exists(text))
				{
					return null;
				}
			}
			if (!File.Exists(text + "/" + textureFileName))
			{
				return null;
			}
			byte[] data = File.ReadAllBytes(text + "/" + textureFileName);
			Texture2D obj = new Texture2D(1, 1)
			{
				name = textureFileName
			};
			obj.LoadImage(data);
			return obj;
		}

		public static Texture2D LoadTexture(string path)
		{
			if (!File.Exists(path))
			{
				return null;
			}
			byte[] data = File.ReadAllBytes(path);
			Texture2D texture2D = new Texture2D(1, 1);
			FileInfo fileInfo = new FileInfo(path);
			texture2D.name = fileInfo.Name;
			texture2D.LoadImage(data);
			return texture2D;
		}
	}
	public static class SceneUtility
	{
		public static void GetChildrenRecursively(Transform current, ref List<Transform> transformList)
		{
			transformList.Add(current);
			foreach (Transform item in current)
			{
				GetChildrenRecursively(item, ref transformList);
			}
		}
	}
	[Serializable]
	public class TS_Bounds
	{
		public Vector3 center = Vector3.zero;

		public Vector3 extents = Vector3.zero;

		public Vector3 max = Vector3.zero;

		public Vector3 min = Vector3.zero;

		public Vector3 size = Vector3.zero;

		public TS_Bounds()
		{
		}

		public TS_Bounds(Bounds bounds)
		{
			center = bounds.center;
			extents = bounds.extents;
			max = bounds.max;
			min = bounds.min;
			size = bounds.size;
		}

		public TS_Bounds(Vector3 c, Vector3 s)
		{
			center = c;
			size = s;
			extents = s / 2f;
			max = center + extents;
			min = center - extents;
		}

		public TS_Bounds(Vector3 min, Vector3 max, Vector3 center)
		{
			size = new Vector3(max.x - min.x, max.y - min.y, max.z - min.z);
			extents = size / 2f;
			this.min = min;
			this.max = max;
			this.center = center;
		}

		public void CreateFromMinMax(Vector3 min, Vector3 max)
		{
			size.x = max.x - min.x;
			size.y = max.y - min.y;
			size.z = max.z - min.z;
			extents = size / 2f;
			this.min = min;
			this.max = max;
			center = Vector3.Lerp(min, max, 0.5f);
		}

		public bool Contains(Vector3 point)
		{
			if (point.x < min.x || point.x > max.x)
			{
				return false;
			}
			if (point.y < min.y || point.y > max.y)
			{
				return false;
			}
			if (point.z < min.z || point.z > max.z)
			{
				return false;
			}
			return true;
		}
	}
	public class TS_Mesh
	{
		public Vector3[] vertices = new Vector3[0];

		public Vector3[] normals = new Vector3[0];

		public Vector4[] tangents = new Vector4[0];

		public Color[] colors = new Color[0];

		public Vector2[] uv = new Vector2[0];

		public Vector2[] uv2 = new Vector2[0];

		public Vector2[] uv3 = new Vector2[0];

		public Vector2[] uv4 = new Vector2[0];

		public int[] triangles = new int[0];

		public List<int[]> subMeshes = new List<int[]>();

		public TS_Bounds bounds = new TS_Bounds(Vector3.zero, Vector3.zero);

		public volatile bool hasUpdate;

		public int vertexCount
		{
			get
			{
				return vertices.Length;
			}
			set
			{
			}
		}

		public TS_Mesh()
		{
		}

		public TS_Mesh(Mesh mesh)
		{
			CreateFromMesh(mesh);
		}

		public void Clear()
		{
			vertices = new Vector3[0];
			normals = new Vector3[0];
			tangents = new Vector4[0];
			colors = new Color[0];
			uv = new Vector2[0];
			uv2 = new Vector2[0];
			uv3 = new Vector2[0];
			uv4 = new Vector2[0];
			triangles = new int[0];
			subMeshes = new List<int[]>();
			bounds = new TS_Bounds(Vector3.zero, Vector3.zero);
		}

		public void CreateFromMesh(Mesh mesh)
		{
			vertices = mesh.vertices;
			normals = mesh.normals;
			tangents = mesh.tangents;
			colors = mesh.colors;
			uv = mesh.uv;
			uv2 = mesh.uv2;
			uv3 = mesh.uv3;
			uv4 = mesh.uv4;
			triangles = mesh.triangles;
			bounds = new TS_Bounds(mesh.bounds);
			for (int i = 0; i < mesh.subMeshCount; i++)
			{
				subMeshes.Add(mesh.GetTriangles(i));
			}
		}

		public void Combine(List<TS_Mesh> newMeshes, bool overwrite = false)
		{
			int num = 0;
			int num2 = 0;
			int num3 = 0;
			for (int i = 0; i < newMeshes.Count; i++)
			{
				num += newMeshes[i].vertexCount;
				num2 += newMeshes[i].triangles.Length;
				if (newMeshes[i].subMeshes.Count > num3)
				{
					num3 = newMeshes[i].subMeshes.Count;
				}
			}
			int[] array = new int[num3];
			int[] array2 = new int[num3];
			for (int j = 0; j < newMeshes.Count; j++)
			{
				for (int k = 0; k < newMeshes[j].subMeshes.Count; k++)
				{
					array[k] += newMeshes[j].subMeshes[k].Length;
				}
			}
			if (overwrite)
			{
				int num4 = 0;
				int num5 = 0;
				if (vertices.Length != num)
				{
					vertices = new Vector3[num];
				}
				if (normals.Length != num)
				{
					normals = new Vector3[num];
				}
				if (uv.Length != num)
				{
					uv = new Vector2[num];
				}
				if (uv2.Length != num)
				{
					uv2 = new Vector2[num];
				}
				if (uv3.Length != num)
				{
					uv3 = new Vector2[num];
				}
				if (uv4.Length != num)
				{
					uv4 = new Vector2[num];
				}
				if (colors.Length != num)
				{
					colors = new Color[num];
				}
				if (tangents.Length != num)
				{
					tangents = new Vector4[num];
				}
				if (triangles.Length != num2)
				{
					triangles = new int[num2];
				}
				if (subMeshes.Count != num3)
				{
					subMeshes.Clear();
				}
				for (int l = 0; l < newMeshes.Count; l++)
				{
					newMeshes[l].vertices.CopyTo(vertices, num4);
					newMeshes[l].normals.CopyTo(normals, num4);
					newMeshes[l].uv.CopyTo(uv, num4);
					newMeshes[l].uv2.CopyTo(uv2, num4);
					newMeshes[l].uv3.CopyTo(uv3, num4);
					newMeshes[l].uv4.CopyTo(uv4, num4);
					newMeshes[l].colors.CopyTo(colors, num4);
					newMeshes[l].tangents.CopyTo(tangents, num4);
					for (int m = num5; m < num5 + newMeshes[l].triangles.Length; m++)
					{
						triangles[m] = newMeshes[l].triangles[m - num2] + num4;
					}
					num5 += newMeshes[l].triangles.Length;
					for (int n = 0; n < newMeshes[l].subMeshes.Count; n++)
					{
						if (n >= subMeshes.Count)
						{
							subMeshes.Add(new int[array[n]]);
						}
						else if (subMeshes[n].Length != array[n])
						{
							subMeshes[n] = new int[array[n]];
						}
						for (int num6 = array2[n]; num6 < array2[n] + newMeshes[l].subMeshes[n].Length; num6++)
						{
							subMeshes[n][num6] = newMeshes[l].subMeshes[n][num6 - array2[n]] + num4;
						}
						array2[n] += newMeshes[l].subMeshes[n].Length;
					}
					num4 += newMeshes[l].vertexCount;
				}
				return;
			}
			Vector3[] array3 = new Vector3[vertices.Length + num];
			Vector3[] array4 = new Vector3[vertices.Length + num];
			Vector2[] array5 = new Vector2[vertices.Length + num];
			Vector2[] array6 = new Vector2[vertices.Length + num];
			Vector2[] array7 = new Vector2[vertices.Length + num];
			Vector2[] array8 = new Vector2[vertices.Length + num];
			Color[] array9 = new Color[vertices.Length + num];
			Vector4[] array10 = new Vector4[tangents.Length + num];
			int[] array11 = new int[triangles.Length + num2];
			List<int[]> list = new List<int[]>();
			for (int num7 = 0; num7 < array.Length; num7++)
			{
				list.Add(new int[array[num7]]);
				if (num7 < subMeshes.Count)
				{
					array[num7] = subMeshes[num7].Length;
				}
				else
				{
					array[num7] = 0;
				}
			}
			num = vertexCount;
			num2 = triangles.Length;
			vertices.CopyTo(array3, 0);
			normals.CopyTo(array4, 0);
			uv.CopyTo(array5, 0);
			uv2.CopyTo(array6, 0);
			uv3.CopyTo(array7, 0);
			uv4.CopyTo(array8, 0);
			colors.CopyTo(array9, 0);
			tangents.CopyTo(array10, 0);
			triangles.CopyTo(array11, 0);
			for (int num8 = 0; num8 < newMeshes.Count; num8++)
			{
				newMeshes[num8].vertices.CopyTo(array3, num);
				newMeshes[num8].normals.CopyTo(array4, num);
				newMeshes[num8].uv.CopyTo(array5, num);
				newMeshes[num8].uv2.CopyTo(array6, num);
				newMeshes[num8].uv3.CopyTo(array7, num);
				newMeshes[num8].uv4.CopyTo(array8, num);
				newMeshes[num8].colors.CopyTo(array9, num);
				newMeshes[num8].tangents.CopyTo(array10, num);
				for (int num9 = num2; num9 < num2 + newMeshes[num8].triangles.Length; num9++)
				{
					array11[num9] = newMeshes[num8].triangles[num9 - num2] + num;
				}
				for (int num10 = 0; num10 < newMeshes[num8].subMeshes.Count; num10++)
				{
					for (int num11 = array[num10]; num11 < array[num10] + newMeshes[num8].subMeshes[num10].Length; num11++)
					{
						list[num10][num11] = newMeshes[num8].subMeshes[num10][num11 - array[num10]] + num;
					}
					array[num10] += newMeshes[num8].subMeshes[num10].Length;
				}
				num2 += newMeshes[num8].triangles.Length;
				num += newMeshes[num8].vertexCount;
			}
			vertices = array3;
			normals = array4;
			uv = array5;
			uv2 = array6;
			uv3 = array7;
			uv4 = array8;
			colors = array9;
			tangents = array10;
			triangles = array11;
			subMeshes = list;
		}

		public void Combine(TS_Mesh newMesh)
		{
			Vector3[] array = new Vector3[vertices.Length + newMesh.vertices.Length];
			Vector3[] array2 = new Vector3[normals.Length + newMesh.normals.Length];
			Vector2[] array3 = new Vector2[uv.Length + newMesh.uv.Length];
			Vector2[] array4 = new Vector2[uv.Length + newMesh.uv2.Length];
			Vector2[] array5 = new Vector2[uv.Length + newMesh.uv3.Length];
			Vector2[] array6 = new Vector2[uv.Length + newMesh.uv4.Length];
			Color[] array7 = new Color[colors.Length + newMesh.colors.Length];
			Vector4[] array8 = new Vector4[tangents.Length + newMesh.tangents.Length];
			int[] array9 = new int[triangles.Length + newMesh.triangles.Length];
			vertices.CopyTo(array, 0);
			newMesh.vertices.CopyTo(array, vertices.Length);
			normals.CopyTo(array2, 0);
			newMesh.normals.CopyTo(array2, normals.Length);
			uv.CopyTo(array3, 0);
			newMesh.uv.CopyTo(array3, uv.Length);
			uv2.CopyTo(array4, 0);
			newMesh.uv2.CopyTo(array4, uv2.Length);
			uv3.CopyTo(array5, 0);
			newMesh.uv3.CopyTo(array5, uv3.Length);
			uv4.CopyTo(array6, 0);
			newMesh.uv4.CopyTo(array6, uv4.Length);
			colors.CopyTo(array7, 0);
			newMesh.colors.CopyTo(array7, colors.Length);
			tangents.CopyTo(array8, 0);
			newMesh.tangents.CopyTo(array8, tangents.Length);
			for (int i = 0; i < array9.Length; i++)
			{
				if (i < triangles.Length)
				{
					array9[i] = triangles[i];
				}
				else
				{
					array9[i] = newMesh.triangles[i - triangles.Length] + vertices.Length;
				}
			}
			for (int j = 0; j < newMesh.subMeshes.Count; j++)
			{
				if (j >= subMeshes.Count)
				{
					subMeshes.Add(newMesh.subMeshes[j]);
					continue;
				}
				int[] array10 = new int[subMeshes[j].Length + newMesh.subMeshes[j].Length];
				subMeshes[j].CopyTo(array10, 0);
				for (int k = 0; k < newMesh.subMeshes[j].Length; k++)
				{
					array10[subMeshes[j].Length + k] = newMesh.subMeshes[j][k] + vertices.Length;
				}
				subMeshes[j] = array10;
			}
			vertices = array;
			normals = array2;
			uv = array3;
			uv2 = array4;
			uv3 = array5;
			uv4 = array6;
			colors = array7;
			tangents = array8;
			triangles = array9;
		}

		public static TS_Mesh Copy(TS_Mesh input)
		{
			TS_Mesh tS_Mesh = new TS_Mesh();
			tS_Mesh.vertices = new Vector3[input.vertices.Length];
			input.vertices.CopyTo(tS_Mesh.vertices, 0);
			tS_Mesh.normals = new Vector3[input.normals.Length];
			input.normals.CopyTo(tS_Mesh.normals, 0);
			tS_Mesh.uv = new Vector2[input.uv.Length];
			input.uv.CopyTo(tS_Mesh.uv, 0);
			tS_Mesh.uv2 = new Vector2[input.uv2.Length];
			input.uv2.CopyTo(tS_Mesh.uv2, 0);
			tS_Mesh.uv3 = new Vector2[input.uv3.Length];
			input.uv3.CopyTo(tS_Mesh.uv3, 0);
			tS_Mesh.uv4 = new Vector2[input.uv4.Length];
			input.uv4.CopyTo(tS_Mesh.uv4, 0);
			tS_Mesh.colors = new Color[input.colors.Length];
			input.colors.CopyTo(tS_Mesh.colors, 0);
			tS_Mesh.tangents = new Vector4[input.tangents.Length];
			input.tangents.CopyTo(tS_Mesh.tangents, 0);
			tS_Mesh.triangles = new int[input.triangles.Length];
			input.triangles.CopyTo(tS_Mesh.triangles, 0);
			tS_Mesh.subMeshes = new List<int[]>();
			for (int i = 0; i < input.subMeshes.Count; i++)
			{
				tS_Mesh.subMeshes.Add(new int[input.subMeshes[i].Length]);
				input.subMeshes[i].CopyTo(tS_Mesh.subMeshes[i], 0);
			}
			tS_Mesh.bounds = new TS_Bounds(input.bounds.center, input.bounds.size);
			return tS_Mesh;
		}

		public void Absorb(TS_Mesh input)
		{
			if (vertices.Length != input.vertexCount)
			{
				vertices = new Vector3[input.vertexCount];
			}
			if (normals.Length != input.normals.Length)
			{
				normals = new Vector3[input.normals.Length];
			}
			if (colors.Length != input.colors.Length)
			{
				colors = new Color[input.colors.Length];
			}
			if (uv.Length != input.uv.Length)
			{
				uv = new Vector2[input.uv.Length];
			}
			if (uv2.Length != input.uv2.Length)
			{
				uv2 = new Vector2[input.uv2.Length];
			}
			if (uv3.Length != input.uv3.Length)
			{
				uv3 = new Vector2[input.uv3.Length];
			}
			if (uv4.Length != input.uv4.Length)
			{
				uv4 = new Vector2[input.uv4.Length];
			}
			if (tangents.Length != input.tangents.Length)
			{
				tangents = new Vector4[input.tangents.Length];
			}
			if (triangles.Length != input.triangles.Length)
			{
				triangles = new int[input.triangles.Length];
			}
			input.vertices.CopyTo(vertices, 0);
			input.normals.CopyTo(normals, 0);
			input.colors.CopyTo(colors, 0);
			input.uv.CopyTo(uv, 0);
			input.uv2.CopyTo(uv2, 0);
			input.uv3.CopyTo(uv3, 0);
			input.uv4.CopyTo(uv4, 0);
			input.tangents.CopyTo(tangents, 0);
			input.triangles.CopyTo(triangles, 0);
			if (subMeshes.Count == input.subMeshes.Count)
			{
				for (int i = 0; i < subMeshes.Count; i++)
				{
					if (input.subMeshes[i].Length != subMeshes[i].Length)
					{
						subMeshes[i] = new int[input.subMeshes[i].Length];
					}
					input.subMeshes[i].CopyTo(subMeshes[i], 0);
				}
			}
			else
			{
				subMeshes = new List<int[]>();
				for (int j = 0; j < input.subMeshes.Count; j++)
				{
					subMeshes.Add(new int[input.subMeshes[j].Length]);
					input.subMeshes[j].CopyTo(subMeshes[j], 0);
				}
			}
			bounds = new TS_Bounds(input.bounds.center, input.bounds.size);
		}

		public void WriteMesh(ref Mesh input)
		{
			if (input == null)
			{
				input = new Mesh();
			}
			if (vertices != null && vertices.Length > 65000)
			{
				return;
			}
			input.Clear();
			input.vertices = vertices;
			input.normals = normals;
			if (tangents.Length == vertices.Length)
			{
				input.tangents = tangents;
			}
			if (colors.Length == vertices.Length)
			{
				input.colors = colors;
			}
			if (uv.Length == vertices.Length)
			{
				input.uv = uv;
			}
			if (uv2.Length == vertices.Length)
			{
				input.uv2 = uv2;
			}
			if (uv3.Length == vertices.Length)
			{
				input.uv3 = uv3;
			}
			if (uv4.Length == vertices.Length)
			{
				input.uv4 = uv4;
			}
			input.triangles = triangles;
			if (subMeshes.Count > 0)
			{
				input.subMeshCount = subMeshes.Count;
				for (int i = 0; i < subMeshes.Count; i++)
				{
					input.SetTriangles(subMeshes[i], i);
				}
			}
			input.RecalculateBounds();
			hasUpdate = false;
		}
	}
	[Serializable]
	public class TS_Transform
	{
		private bool setPosition;

		private bool setRotation;

		private bool setScale;

		private bool setLocalPosition;

		private bool setLocalRotation;

		[SerializeField]
		[HideInInspector]
		private Transform _transform;

		[SerializeField]
		[HideInInspector]
		private volatile float posX;

		[SerializeField]
		[HideInInspector]
		private volatile float posY;

		[SerializeField]
		[HideInInspector]
		private volatile float posZ;

		[SerializeField]
		[HideInInspector]
		private volatile float scaleX = 1f;

		[SerializeField]
		[HideInInspector]
		private volatile float scaleY = 1f;

		[SerializeField]
		[HideInInspector]
		private volatile float scaleZ = 1f;

		[SerializeField]
		[HideInInspector]
		private volatile float lossyScaleX = 1f;

		[SerializeField]
		[HideInInspector]
		private volatile float lossyScaleY = 1f;

		[SerializeField]
		[HideInInspector]
		private volatile float lossyScaleZ = 1f;

		[SerializeField]
		[HideInInspector]
		private volatile float rotX;

		[SerializeField]
		[HideInInspector]
		private volatile float rotY;

		[SerializeField]
		[HideInInspector]
		private volatile float rotZ;

		[SerializeField]
		[HideInInspector]
		private volatile float rotW;

		[SerializeField]
		[HideInInspector]
		private volatile float lposX;

		[SerializeField]
		[HideInInspector]
		private volatile float lposY;

		[SerializeField]
		[HideInInspector]
		private volatile float lposZ;

		[SerializeField]
		[HideInInspector]
		private volatile float lrotX;

		[SerializeField]
		[HideInInspector]
		private volatile float lrotY;

		[SerializeField]
		[HideInInspector]
		private volatile float lrotZ;

		[SerializeField]
		[HideInInspector]
		private volatile float lrotW;

		public Vector3 position
		{
			get
			{
				return new Vector3(posX, posY, posZ);
			}
			set
			{
				setPosition = true;
				setLocalPosition = false;
				posX = value.x;
				posY = value.y;
				posZ = value.z;
			}
		}

		public Quaternion rotation
		{
			get
			{
				return new Quaternion(rotX, rotY, rotZ, rotW);
			}
			set
			{
				setRotation = true;
				setLocalRotation = false;
				rotX = value.x;
				rotY = value.y;
				rotZ = value.z;
				rotW = value.w;
			}
		}

		public Vector3 scale
		{
			get
			{
				return new Vector3(scaleX, scaleY, scaleZ);
			}
			set
			{
				setScale = true;
				scaleX = value.x;
				scaleY = value.y;
				scaleZ = value.z;
			}
		}

		public Vector3 lossyScale
		{
			get
			{
				return new Vector3(lossyScaleX, lossyScaleY, lossyScaleZ);
			}
			set
			{
				setScale = true;
				lossyScaleX = value.x;
				lossyScaleY = value.y;
				lossyScaleZ = value.z;
			}
		}

		public Vector3 localPosition
		{
			get
			{
				return new Vector3(lposX, lposY, lposZ);
			}
			set
			{
				setLocalPosition = true;
				setPosition = false;
				lposX = value.x;
				lposY = value.y;
				lposZ = value.z;
			}
		}

		public Quaternion localRotation
		{
			get
			{
				return new Quaternion(lrotX, lrotY, lrotZ, lrotW);
			}
			set
			{
				setLocalRotation = true;
				setRotation = false;
				lrotX = value.x;
				lrotY = value.y;
				lrotZ = value.z;
				lrotW = value.w;
			}
		}

		public Transform transform => _transform;

		public TS_Transform(Transform input)
		{
			SetTransform(input);
		}

		public void Update()
		{
			if (!(transform == null))
			{
				if (setPosition)
				{
					_transform.position = position;
				}
				else if (setLocalPosition)
				{
					_transform.localPosition = localPosition;
				}
				else
				{
					position = _transform.position;
					localPosition = _transform.localPosition;
				}
				if (setScale)
				{
					_transform.localScale = scale;
				}
				else
				{
					scale = _transform.localScale;
				}
				lossyScale = _transform.lossyScale;
				if (setRotation)
				{
					_transform.rotation = rotation;
				}
				else if (setLocalRotation)
				{
					_transform.localRotation = localRotation;
				}
				else
				{
					rotation = _transform.rotation;
					localRotation = _transform.localRotation;
				}
				setPosition = (setLocalPosition = (setRotation = (setLocalRotation = (setScale = false))));
			}
		}

		public void SetTransform(Transform input)
		{
			_transform = input;
			setPosition = (setLocalPosition = (setRotation = (setLocalRotation = (setScale = false))));
			Update();
		}

		public bool HasChange()
		{
			if (!HasPositionChange() && !HasRotationChange())
			{
				return HasScaleChange();
			}
			return true;
		}

		public bool HasPositionChange()
		{
			if (posX == _transform.position.x && posY == _transform.position.y)
			{
				return posZ != _transform.position.z;
			}
			return true;
		}

		public bool HasRotationChange()
		{
			if (rotX == _transform.rotation.x && rotY == _transform.rotation.y && rotZ == _transform.rotation.z)
			{
				return rotW != _transform.rotation.w;
			}
			return true;
		}

		public bool HasScaleChange()
		{
			if (lossyScaleX == _transform.lossyScale.x && lossyScaleY == _transform.lossyScale.y)
			{
				return lossyScaleZ != _transform.lossyScale.z;
			}
			return true;
		}

		public Vector3 TransformPoint(Vector3 point)
		{
			Vector3 vector = new Vector3(point.x * lossyScaleX, point.y * lossyScaleY, point.z * lossyScaleZ);
			Vector3 vector2 = rotation * vector;
			return position + vector2;
		}

		public Vector3 TransformDirection(Vector3 direction)
		{
			return TransformPoint(direction) - position;
		}

		public Vector3 InverseTransformPoint(Vector3 point)
		{
			return InverseTransformDirection(point - position);
		}

		public Vector3 InverseTransformDirection(Vector3 direction)
		{
			Vector3 vector = Quaternion.Inverse(rotation) * direction;
			return new Vector3(vector.x / lossyScaleX, vector.y / lossyScaleY, vector.z / lossyScaleZ);
		}

		public T GetComponent<T>()
		{
			return _transform.GetComponent<T>();
		}
	}
	public static class TransformUtility
	{
		public static Vector3 GetPosition(Matrix4x4 m)
		{
			return m.GetColumn(3);
		}

		public static Quaternion GetRotation(Matrix4x4 m)
		{
			return Quaternion.LookRotation(m.GetColumn(2), m.GetColumn(1));
		}

		public static Vector3 GetScale(Matrix4x4 m)
		{
			return new Vector3(m.GetColumn(0).magnitude, m.GetColumn(1).magnitude, m.GetColumn(2).magnitude);
		}

		public static void SetPosition(ref Matrix4x4 m, ref Vector3 p)
		{
			m.SetColumn(3, new Vector4(p.x, p.y, p.z, 1f));
		}

		public static void GetChildCount(Transform parent, ref int count)
		{
			foreach (Transform item in parent)
			{
				count++;
				GetChildCount(item, ref count);
			}
		}

		public static bool IsParent(Transform child, Transform parent)
		{
			Transform transform = child;
			while (transform.parent != null)
			{
				transform = transform.parent;
				if (transform == parent)
				{
					return true;
				}
			}
			return false;
		}
	}
}
namespace Dreamteck.Splines
{
	public class BlankUser : SplineUser
	{
		private void Start()
		{
		}

		protected override void LateRun()
		{
			base.LateRun();
		}

		protected override void Build()
		{
			base.Build();
		}

		protected override void PostBuild()
		{
			base.PostBuild();
		}
	}
	[AddComponentMenu("Dreamteck/Splines/Users/Edge Collider Generator")]
	[RequireComponent(typeof(EdgeCollider2D))]
	public class EdgeColliderGenerator : SplineUser
	{
		[SerializeField]
		[HideInInspector]
		private float _offset;

		[SerializeField]
		[HideInInspector]
		protected EdgeCollider2D edgeCollider;

		[SerializeField]
		[HideInInspector]
		protected Vector2[] vertices = new Vector2[0];

		[HideInInspector]
		public float updateRate = 0.1f;

		protected float lastUpdateTime;

		private bool updateCollider;

		public float offset
		{
			get
			{
				return _offset;
			}
			set
			{
				if (value != _offset)
				{
					_offset = value;
					Rebuild();
				}
			}
		}

		protected override void Awake()
		{
			base.Awake();
			edgeCollider = GetComponent<EdgeCollider2D>();
		}

		protected override void Reset()
		{
			base.Reset();
		}

		protected override void OnEnable()
		{
			base.OnEnable();
		}

		protected override void OnDisable()
		{
			base.OnDisable();
		}

		protected override void OnDestroy()
		{
			base.OnDestroy();
		}

		protected override void LateRun()
		{
			base.LateRun();
			if (updateCollider && edgeCollider != null && Time.time - lastUpdateTime >= updateRate)
			{
				lastUpdateTime = Time.time;
				updateCollider = false;
				edgeCollider.points = vertices;
			}
		}

		protected override void Build()
		{
			base.Build();
			if (base.sampleCount == 0)
			{
				return;
			}
			if (vertices.Length != base.sampleCount)
			{
				vertices = new Vector2[base.sampleCount];
			}
			bool flag = offset != 0f;
			for (int i = 0; i < base.sampleCount; i++)
			{
				GetSample(i, evalResult);
				vertices[i] = evalResult.position;
				if (flag)
				{
					Vector2 vector = new Vector2(0f - evalResult.forward.y, evalResult.forward.x).normalized * evalResult.size;
					vertices[i] += vector * offset;
				}
			}
		}

		protected override void PostBuild()
		{
			base.PostBuild();
			if (!(edgeCollider == null))
			{
				for (int i = 0; i < vertices.Length; i++)
				{
					vertices[i] = base.transform.InverseTransformPoint(vertices[i]);
				}
				if (updateRate == 0f)
				{
					edgeCollider.points = vertices;
				}
				else
				{
					updateCollider = true;
				}
			}
		}
	}
	[AddComponentMenu("Dreamteck/Splines/Users/Length Calculator")]
	public class LengthCalculator : SplineUser
	{
		[Serializable]
		public class LengthEvent
		{
			public enum Type
			{
				Growing,
				Shrinking,
				Both
			}

			public bool enabled = true;

			public float targetLength;

			public UnityEvent onChange = new UnityEvent();

			public Type type = Type.Both;

			public LengthEvent()
			{
			}

			public LengthEvent(Type t)
			{
				type = t;
			}

			public void Check(float fromLength, float toLength)
			{
				if (enabled)
				{
					bool flag = false;
					switch (type)
					{
					case Type.Growing:
						flag = toLength >= targetLength && fromLength < targetLength;
						break;
					case Type.Shrinking:
						flag = toLength <= targetLength && fromLength > targetLength;
						break;
					case Type.Both:
						flag = (toLength >= targetLength && fromLength < targetLength) || (toLength <= targetLength && fromLength > targetLength);
						break;
					}
					if (flag)
					{
						onChange.Invoke();
					}
				}
			}
		}

		[HideInInspector]
		public LengthEvent[] lengthEvents = new LengthEvent[0];

		[HideInInspector]
		public float idealLength = 1f;

		private float _length;

		private float lastLength;

		public float length => _length;

		protected override void Awake()
		{
			base.Awake();
			_length = CalculateLength();
			lastLength = _length;
			for (int i = 0; i < lengthEvents.Length; i++)
			{
				if (lengthEvents[i].targetLength == _length)
				{
					lengthEvents[i].onChange.Invoke();
				}
			}
		}

		protected override void Build()
		{
			base.Build();
			_length = CalculateLength();
			if (lastLength != _length)
			{
				for (int i = 0; i < lengthEvents.Length; i++)
				{
					lengthEvents[i].Check(lastLength, _length);
				}
				lastLength = _length;
			}
		}

		private void AddEvent(LengthEvent lengthEvent)
		{
			LengthEvent[] array = new LengthEvent[lengthEvents.Length + 1];
			lengthEvents.CopyTo(array, 0);
			array[array.Length - 1] = lengthEvent;
			lengthEvents = array;
		}
	}
	public class MeshGenerator : SplineUser
	{
		public enum UVMode
		{
			Clip,
			UniformClip,
			Clamp,
			UniformClamp
		}

		public enum NormalMethod
		{
			Recalculate,
			SplineNormals
		}

		[SerializeField]
		[HideInInspector]
		private bool _baked;

		[SerializeField]
		[HideInInspector]
		private bool _markDynamic = true;

		[SerializeField]
		[HideInInspector]
		private float _size = 1f;

		[SerializeField]
		[HideInInspector]
		private Color _color = Color.white;

		[SerializeField]
		[HideInInspector]
		private Vector3 _offset = Vector3.zero;

		[SerializeField]
		[HideInInspector]
		private NormalMethod _normalMethod = NormalMethod.SplineNormals;

		[SerializeField]
		[HideInInspector]
		private bool _calculateTangents = true;

		[SerializeField]
		[HideInInspector]
		[Range(-360f, 360f)]
		private float _rotation;

		[SerializeField]
		[HideInInspector]
		private bool _flipFaces;

		[SerializeField]
		[HideInInspector]
		private bool _doubleSided;

		[SerializeField]
		[HideInInspector]
		private UVMode _uvMode;

		[SerializeField]
		[HideInInspector]
		private Vector2 _uvScale = Vector2.one;

		[SerializeField]
		[HideInInspector]
		private Vector2 _uvOffset = Vector2.zero;

		[SerializeField]
		[HideInInspector]
		private float _uvRotation;

		[SerializeField]
		[HideInInspector]
		protected MeshCollider meshCollider;

		[SerializeField]
		[HideInInspector]
		protected MeshFilter filter;

		[SerializeField]
		[HideInInspector]
		protected MeshRenderer meshRenderer;

		[SerializeField]
		[HideInInspector]
		protected TS_Mesh tsMesh = new TS_Mesh();

		[SerializeField]
		[HideInInspector]
		protected Mesh mesh;

		[HideInInspector]
		public float colliderUpdateRate = 0.2f;

		protected bool updateCollider;

		protected float lastUpdateTime;

		private float vDist;

		protected static Vector2 uvs = Vector2.zero;

		public float size
		{
			get
			{
				return _size;
			}
			set
			{
				if (value != _size)
				{
					_size = value;
					Rebuild();
				}
				else
				{
					_size = value;
				}
			}
		}

		public Color color
		{
			get
			{
				return _color;
			}
			set
			{
				if (value != _color)
				{
					_color = value;
					Rebuild();
				}
			}
		}

		public Vector3 offset
		{
			get
			{
				return _offset;
			}
			set
			{
				if (value != _offset)
				{
					_offset = value;
					Rebuild();
				}
			}
		}

		public NormalMethod normalMethod
		{
			get
			{
				return _normalMethod;
			}
			set
			{
				if (value != _normalMethod)
				{
					_normalMethod = value;
					Rebuild();
				}
			}
		}

		public bool calculateTangents
		{
			get
			{
				return _calculateTangents;
			}
			set
			{
				if (value != _calculateTangents)
				{
					_calculateTangents = value;
					Rebuild();
				}
			}
		}

		public float rotation
		{
			get
			{
				return _rotation;
			}
			set
			{
				if (value != _rotation)
				{
					_rotation = value;
					Rebuild();
				}
			}
		}

		public bool flipFaces
		{
			get
			{
				return _flipFaces;
			}
			set
			{
				if (value != _flipFaces)
				{
					_flipFaces = value;
					Rebuild();
				}
			}
		}

		public bool doubleSided
		{
			get
			{
				return _doubleSided;
			}
			set
			{
				if (value != _doubleSided)
				{
					_doubleSided = value;
					Rebuild();
				}
			}
		}

		public UVMode uvMode
		{
			get
			{
				return _uvMode;
			}
			set
			{
				if (value != _uvMode)
				{
					_uvMode = value;
					Rebuild();
				}
			}
		}

		public Vector2 uvScale
		{
			get
			{
				return _uvScale;
			}
			set
			{
				if (value != _uvScale)
				{
					_uvScale = value;
					Rebuild();
				}
			}
		}

		public Vector2 uvOffset
		{
			get
			{
				return _uvOffset;
			}
			set
			{
				if (value != _uvOffset)
				{
					_uvOffset = value;
					Rebuild();
				}
			}
		}

		public float uvRotation
		{
			get
			{
				return _uvRotation;
			}
			set
			{
				if (value != _uvRotation)
				{
					_uvRotation = value;
					Rebuild();
				}
			}
		}

		public bool baked => _baked;

		public bool markDynamic
		{
			get
			{
				return _markDynamic;
			}
			set
			{
				if (value != _markDynamic)
				{
					_markDynamic = value;
					if (!_markDynamic)
					{
						UnityEngine.Object.Destroy(mesh);
						mesh = new Mesh();
					}
					RebuildImmediate();
				}
			}
		}

		protected override void Awake()
		{
			if (mesh == null)
			{
				mesh = new Mesh();
			}
			base.Awake();
			filter = GetComponent<MeshFilter>();
			meshRenderer = GetComponent<MeshRenderer>();
			meshCollider = GetComponent<MeshCollider>();
		}

		protected override void Reset()
		{
			base.Reset();
		}

		public void CloneMesh()
		{
			if (tsMesh != null)
			{
				tsMesh = TS_Mesh.Copy(tsMesh);
			}
			else
			{
				tsMesh = new TS_Mesh();
			}
			if (mesh != null)
			{
				mesh = UnityEngine.Object.Instantiate(mesh);
			}
			else
			{
				mesh = new Mesh();
			}
		}

		public override void Rebuild()
		{
			if (!_baked)
			{
				base.Rebuild();
			}
		}

		public override void RebuildImmediate()
		{
			if (!_baked)
			{
				base.RebuildImmediate();
			}
		}

		protected override void OnEnable()
		{
			base.OnEnable();
		}

		protected override void OnDisable()
		{
			base.OnDisable();
		}

		protected override void OnDestroy()
		{
			base.OnDestroy();
			MeshFilter component = GetComponent<MeshFilter>();
			MeshRenderer component2 = GetComponent<MeshRenderer>();
			if (component != null)
			{
				component.hideFlags = HideFlags.None;
			}
			if (component2 != null)
			{
				component2.hideFlags = HideFlags.None;
			}
		}

		public void UpdateCollider()
		{
			meshCollider = GetComponent<MeshCollider>();
			if (meshCollider == null)
			{
				meshCollider = base.gameObject.AddComponent<MeshCollider>();
			}
			meshCollider.sharedMesh = filter.sharedMesh;
		}

		protected override void LateRun()
		{
			if (!_baked)
			{
				base.LateRun();
				if (updateCollider && meshCollider != null && Time.time - lastUpdateTime >= colliderUpdateRate)
				{
					lastUpdateTime = Time.time;
					updateCollider = false;
					meshCollider.sharedMesh = filter.sharedMesh;
				}
			}
		}

		protected override void Build()
		{
			base.Build();
			if (base.sampleCount > 0)
			{
				BuildMesh();
			}
		}

		protected override void PostBuild()
		{
			base.PostBuild();
			WriteMesh();
		}

		protected virtual void BuildMesh()
		{
		}

		protected virtual void WriteMesh()
		{
			MeshUtility.InverseTransformMesh(tsMesh, trs);
			if (_doubleSided)
			{
				MeshUtility.MakeDoublesidedHalf(tsMesh);
			}
			else if (_flipFaces)
			{
				MeshUtility.FlipFaces(tsMesh);
			}
			if (_calculateTangents)
			{
				MeshUtility.CalculateTangents(tsMesh);
			}
			mesh.MarkDynamic();
			tsMesh.WriteMesh(ref mesh);
			if (_normalMethod == NormalMethod.Recalculate)
			{
				mesh.RecalculateNormals();
			}
			if (filter != null)
			{
				filter.sharedMesh = mesh;
			}
			updateCollider = true;
		}

		protected virtual void AllocateMesh(int vertexCount, int trisCount)
		{
			if (_doubleSided)
			{
				vertexCount *= 2;
				trisCount *= 2;
			}
			if (tsMesh.vertexCount != vertexCount)
			{
				tsMesh.vertices = new Vector3[vertexCount];
				tsMesh.normals = new Vector3[vertexCount];
				tsMesh.tangents = new Vector4[vertexCount];
				tsMesh.colors = new Color[vertexCount];
				tsMesh.uv = new Vector2[vertexCount];
			}
			if (tsMesh.triangles.Length != trisCount)
			{
				tsMesh.triangles = new int[trisCount];
			}
		}

		protected void ResetUVDistance()
		{
			vDist = 0f;
			if (uvMode == UVMode.UniformClip)
			{
				vDist = base.spline.CalculateLength(0.0, GetSampleRaw(0).percent);
			}
		}

		protected void AddUVDistance(int sampleIndex)
		{
			if (sampleIndex != 0)
			{
				vDist += Vector3.Distance(GetSampleRaw(sampleIndex).position, GetSampleRaw(sampleIndex - 1).position);
			}
		}

		protected void CalculateUVs(double percent, float u)
		{
			uvs.x = u * _uvScale.x - _uvOffset.x;
			switch (uvMode)
			{
			case UVMode.Clip:
				uvs.y = (float)percent * _uvScale.y - _uvOffset.y;
				break;
			case UVMode.Clamp:
				uvs.y = (float)DMath.InverseLerp(base.clipFrom, base.clipTo, percent) * _uvScale.y - _uvOffset.y;
				break;
			case UVMode.UniformClamp:
				uvs.y = vDist * _uvScale.y / (float)base.span - _uvOffset.y;
				break;
			default:
				uvs.y = vDist * _uvScale.y - _uvOffset.y;
				break;
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Dreamteck/Splines/Node Connector")]
	public class Node : MonoBehaviour
	{
		[Serializable]
		public class Connection
		{
			public bool invertTangents;

			[SerializeField]
			private int _pointIndex;

			[SerializeField]
			private SplineComputer _computer;

			[SerializeField]
			[HideInInspector]
			internal SplinePoint point;

			public SplineComputer spline => _computer;

			public int pointIndex => _pointIndex;

			internal bool isValid
			{
				get
				{
					if (_computer == null)
					{
						return false;
					}
					if (_pointIndex >= _computer.pointCount)
					{
						return false;
					}
					return true;
				}
			}

			internal Connection(SplineComputer comp, int index, SplinePoint inputPoint)
			{
				_pointIndex = index;
				_computer = comp;
				point = inputPoint;
			}
		}

		public enum Type
		{
			Smooth,
			Free
		}

		[HideInInspector]
		public Type type;

		[SerializeField]
		[HideInInspector]
		protected Connection[] connections = new Connection[0];

		[SerializeField]
		[HideInInspector]
		private bool _transformSize = true;

		[SerializeField]
		[HideInInspector]
		private bool _transformNormals = true;

		[SerializeField]
		[HideInInspector]
		private bool _transformTangents = true;

		private Vector3 lastPosition;

		private Vector3 lastScale;

		private Quaternion lastRotation;

		private Transform trs;

		public bool transformNormals
		{
			get
			{
				return _transformNormals;
			}
			set
			{
				if (value != _transformNormals)
				{
					_transformNormals = value;
					UpdatePoints();
				}
			}
		}

		public bool transformSize
		{
			get
			{
				return _transformSize;
			}
			set
			{
				if (value != _transformSize)
				{
					_transformSize = value;
					UpdatePoints();
				}
			}
		}

		public bool transformTangents
		{
			get
			{
				return _transformTangents;
			}
			set
			{
				if (value != _transformTangents)
				{
					_transformTangents = value;
					UpdatePoints();
				}
			}
		}

		private void Awake()
		{
			trs = base.transform;
			SampleTransform();
		}

		private void LateUpdate()
		{
			Run();
		}

		private void Update()
		{
			Run();
		}

		private bool TransformChanged()
		{
			if (!(lastPosition != trs.position) && !(lastRotation != trs.rotation))
			{
				return lastScale != trs.lossyScale;
			}
			return true;
		}

		private void SampleTransform()
		{
			lastPosition = trs.position;
			lastScale = trs.lossyScale;
			lastRotation = trs.rotation;
		}

		private void Run()
		{
			if (TransformChanged())
			{
				UpdateConnectedComputers();
				SampleTransform();
			}
		}

		public SplinePoint GetPoint(int connectionIndex, bool swapTangents)
		{
			SplinePoint result = PointToWorld(connections[connectionIndex].point);
			if (connections[connectionIndex].invertTangents && swapTangents)
			{
				Vector3 tangent = result.tangent;
				result.tangent = result.tangent2;
				result.tangent2 = tangent;
			}
			return result;
		}

		public void SetPoint(int connectionIndex, SplinePoint worldPoint, bool swappedTangents)
		{
			Connection connection = connections[connectionIndex];
			connection.point = PointToLocal(worldPoint);
			if (connection.invertTangents && swappedTangents)
			{
				Vector3 tangent = connection.point.tangent;
				connection.point.tangent = connection.point.tangent2;
				connection.point.tangent2 = tangent;
			}
			if (type != 0)
			{
				return;
			}
			if (connection.point.type == SplinePoint.Type.SmoothFree)
			{
				for (int i = 0; i < connections.Length; i++)
				{
					if (i != connectionIndex)
					{
						Vector3 vector = (connection.point.tangent - connection.point.position).normalized;
						if (vector == Vector3.zero)
						{
							vector = -(connection.point.tangent2 - connection.point.position).normalized;
						}
						float magnitude = (connections[i].point.tangent - connections[i].point.position).magnitude;
						float magnitude2 = (connections[i].point.tangent2 - connections[i].point.position).magnitude;
						connections[i].point = connection.point;
						connections[i].point.tangent = connections[i].point.position + vector * magnitude;
						connections[i].point.tangent2 = connections[i].point.position - vector * magnitude2;
					}
				}
				return;
			}
			for (int j = 0; j < connections.Length; j++)
			{
				if (j != connectionIndex)
				{
					connections[j].point = connection.point;
				}
			}
		}

		private void OnDestroy()
		{
			ClearConnections();
		}

		public void ClearConnections()
		{
			for (int num = connections.Length - 1; num >= 0; num--)
			{
				if (connections[num].spline != null)
				{
					connections[num].spline.DisconnectNode(connections[num].pointIndex);
				}
			}
			connections = new Connection[0];
		}

		public void UpdateConnectedComputers(SplineComputer excludeComputer = null)
		{
			for (int num = connections.Length - 1; num >= 0; num--)
			{
				if (!connections[num].isValid)
				{
					RemoveConnection(num);
				}
				else if (!(connections[num].spline == excludeComputer))
				{
					if (type == Type.Smooth && num != 0)
					{
						SetPoint(num, GetPoint(0, swapTangents: false), swappedTangents: false);
					}
					SplinePoint point = GetPoint(num, swapTangents: true);
					if (!transformNormals)
					{
						point.normal = connections[num].spline.GetPointNormal(connections[num].pointIndex);
					}
					if (!transformTangents)
					{
						point.tangent = connections[num].spline.GetPointTangent(connections[num].pointIndex);
						point.tangent2 = connections[num].spline.GetPointTangent2(connections[num].pointIndex);
					}
					if (!transformSize)
					{
						point.size = connections[num].spline.GetPointSize(connections[num].pointIndex);
					}
					connections[num].spline.SetPoint(connections[num].pointIndex, point);
				}
			}
		}

		public void UpdatePoint(SplineComputer computer, int pointIndex, SplinePoint point, bool updatePosition = true)
		{
			trs.position = point.position;
			for (int i = 0; i < connections.Length; i++)
			{
				if (connections[i].spline == computer && connections[i].pointIndex == pointIndex)
				{
					SetPoint(i, point, swappedTangents: true);
				}
			}
		}

		private void UpdatePoints()
		{
			for (int num = connections.Length - 1; num >= 0; num--)
			{
				if (!connections[num].isValid)
				{
					RemoveConnection(num);
				}
				else
				{
					SplinePoint point = connections[num].spline.GetPoint(connections[num].pointIndex);
					point.SetPosition(base.transform.position);
					SetPoint(num, point, swappedTangents: true);
				}
			}
		}

		protected void RemoveInvalidConnections()
		{
			for (int num = connections.Length - 1; num >= 0; num--)
			{
				if (connections[num] == null || !connections[num].isValid)
				{
					RemoveConnection(num);
				}
			}
		}

		public virtual void AddConnection(SplineComputer computer, int pointIndex)
		{
			RemoveInvalidConnections();
			Node node = computer.GetNode(pointIndex);
			if (node != null)
			{
				UnityEngine.Debug.LogError(computer.name + " is already connected to node " + node.name + " at point " + pointIndex);
				return;
			}
			SplinePoint point = computer.GetPoint(pointIndex);
			point.SetPosition(base.transform.position);
			ArrayUtility.Add(ref connections, new Connection(computer, pointIndex, PointToLocal(point)));
			if (connections.Length == 1)
			{
				SetPoint(connections.Length - 1, point, swappedTangents: true);
			}
			UpdateConnectedComputers();
		}

		protected SplinePoint PointToLocal(SplinePoint worldPoint)
		{
			worldPoint.position = Vector3.zero;
			worldPoint.tangent = base.transform.InverseTransformPoint(worldPoint.tangent);
			worldPoint.tangent2 = base.transform.InverseTransformPoint(worldPoint.tangent2);
			worldPoint.normal = base.transform.InverseTransformDirection(worldPoint.normal);
			worldPoint.size /= (base.transform.localScale.x + base.transform.localScale.y + base.transform.localScale.z) / 3f;
			return worldPoint;
		}

		protected SplinePoint PointToWorld(SplinePoint localPoint)
		{
			localPoint.position = base.transform.position;
			localPoint.tangent = base.transform.TransformPoint(localPoint.tangent);
			localPoint.tangent2 = base.transform.TransformPoint(localPoint.tangent2);
			localPoint.normal = base.transform.TransformDirection(localPoint.normal);
			localPoint.size *= (base.transform.localScale.x + base.transform.localScale.y + base.transform.localScale.z) / 3f;
			return localPoint;
		}

		public virtual void RemoveConnection(SplineComputer computer, int pointIndex)
		{
			int num = -1;
			for (int i = 0; i < connections.Length; i++)
			{
				if (connections[i].pointIndex == pointIndex && connections[i].spline == computer)
				{
					num = i;
					break;
				}
			}
			if (num >= 0)
			{
				RemoveConnection(num);
			}
		}

		private void RemoveConnection(int index)
		{
			Connection[] array = new Connection[connections.Length - 1];
			_ = connections[index].spline;
			_ = connections[index].pointIndex;
			for (int i = 0; i < connections.Length; i++)
			{
				if (i < index)
				{
					array[i] = connections[i];
				}
				else if (i != index)
				{
					array[i - 1] = connections[i];
				}
			}
			connections = array;
		}

		public virtual bool HasConnection(SplineComputer computer, int pointIndex)
		{
			for (int num = connections.Length - 1; num >= 0; num--)
			{
				if (!connections[num].isValid)
				{
					RemoveConnection(num);
				}
				else if (connections[num].spline == computer && connections[num].pointIndex == pointIndex)
				{
					return true;
				}
			}
			return false;
		}

		public Connection[] GetConnections()
		{
			return connections;
		}
	}
	[AddComponentMenu("Dreamteck/Splines/Users/Object Bender")]
	public class ObjectBender : SplineUser
	{
		public enum Axis
		{
			X,
			Y,
			Z
		}

		public enum NormalMode
		{
			Spline,
			Auto,
			Custom
		}

		public enum ForwardMode
		{
			Spline,
			Custom
		}

		[Serializable]
		public class BendProperty
		{
			public bool enabled = true;

			public TS_Transform transform;

			public bool applyRotation = true;

			public bool applyScale = true;

			public bool generateLightmapUVs;

			[SerializeField]
			[HideInInspector]
			private bool _bendMesh = true;

			[SerializeField]
			[HideInInspector]
			private bool _bendSpline = true;

			[SerializeField]
			[HideInInspector]
			private bool _bendCollider = true;

			private float colliderUpdateDue;

			public float colliderUpdateRate = 0.2f;

			private bool updateCollider;

			public Vector3 originalPosition = Vector3.zero;

			public Vector3 originalScale = Vector3.one;

			public Quaternion originalRotation = Quaternion.identity;

			public Quaternion parentRotation = Quaternion.identity;

			public Vector3 positionPercent;

			public Vector3[] vertexPercents = new Vector3[0];

			public Vector3[] normals = new Vector3[0];

			public Vector3[] colliderVertexPercents = new Vector3[0];

			public Vector3[] colliderNormals = new Vector3[0];

			[SerializeField]
			[HideInInspector]
			private Mesh originalMesh;

			[SerializeField]
			[HideInInspector]
			private Mesh originalColliderMesh;

			private Spline _originalSpline;

			[SerializeField]
			[HideInInspector]
			private Mesh destinationMesh;

			[SerializeField]
			[HideInInspector]
			private Mesh destinationColliderMesh;

			public Spline destinationSpline;

			public TS_Mesh _editMesh;

			public TS_Mesh _editColliderMesh;

			public MeshFilter filter;

			public MeshCollider collider;

			public SplineComputer splineComputer;

			public Vector3[] splinePointPercents = new Vector3[0];

			public Vector3[] primaryTangentPercents = new Vector3[0];

			public Vector3[] secondaryTangentPercents = new Vector3[0];

			[SerializeField]
			[HideInInspector]
			private bool parent;

			public bool isValid
			{
				get
				{
					if (transform != null)
					{
						return transform.transform != null;
					}
					return false;
				}
			}

			public bool bendMesh
			{
				get
				{
					return _bendMesh;
				}
				set
				{
					if (value == _bendMesh)
					{
						return;
					}
					_bendMesh = value;
					if (value)
					{
						if (filter != null && filter.sharedMesh != null)
						{
							normals = originalMesh.normals;
							for (int i = 0; i < normals.Length; i++)
							{
								normals[i] = transform.transform.TransformDirection(normals[i]);
							}
						}
					}
					else
					{
						RevertMesh();
					}
				}
			}

			public bool bendCollider
			{
				get
				{
					return _bendCollider;
				}
				set
				{
					if (value == _bendCollider)
					{
						return;
					}
					_bendCollider = value;
					if (value)
					{
						if (collider != null && collider.sharedMesh != null && collider.sharedMesh != originalMesh)
						{
							colliderNormals = originalColliderMesh.normals;
						}
					}
					else
					{
						RevertCollider();
					}
				}
			}

			public bool bendSpline
			{
				get
				{
					return _bendSpline;
				}
				set
				{
					_bendSpline = value;
				}
			}

			public TS_Mesh editMesh
			{
				get
				{
					if (!bendMesh || originalMesh == null)
					{
						_editMesh = null;
					}
					else if (_editMesh == null && originalMesh != null)
					{
						_editMesh = new TS_Mesh(originalMesh);
					}
					return _editMesh;
				}
			}

			public TS_Mesh editColliderMesh
			{
				get
				{
					if (!bendCollider || originalColliderMesh == null)
					{
						_editColliderMesh = null;
					}
					else if (_editColliderMesh == null && originalColliderMesh != null && originalColliderMesh != originalMesh)
					{
						_editColliderMesh = new TS_Mesh(originalColliderMesh);
					}
					return _editColliderMesh;
				}
			}

			public Spline originalSpline
			{
				get
				{
					if (!bendSpline || splineComputer == null)
					{
						_originalSpline = null;
					}
					else if (_originalSpline == null && splineComputer != null)
					{
						_originalSpline = new Spline(splineComputer.type);
						_originalSpline.points = splineComputer.GetPoints();
					}
					return _originalSpline;
				}
			}

			public BendProperty(Transform t, bool isParent = false)
			{
				parent = isParent;
				transform = new TS_Transform(t);
				originalPosition = t.localPosition;
				originalScale = t.localScale;
				originalRotation = t.localRotation;
				parentRotation = t.transform.rotation;
				if (t.transform.parent != null)
				{
					parentRotation = t.transform.parent.rotation;
				}
				filter = t.GetComponent<MeshFilter>();
				collider = t.GetComponent<MeshCollider>();
				if (filter != null && filter.sharedMesh != null)
				{
					originalMesh = filter.sharedMesh;
					normals = originalMesh.normals;
					for (int i = 0; i < normals.Length; i++)
					{
						normals[i] = transform.transform.TransformDirection(normals[i]).normalized;
					}
				}
				if (collider != null && collider.sharedMesh != null)
				{
					originalColliderMesh = collider.sharedMesh;
					colliderNormals = originalColliderMesh.normals;
					for (int j = 0; j < colliderNormals.Length; j++)
					{
						colliderNormals[j] = transform.transform.TransformDirection(colliderNormals[j]);
					}
				}
				if (!parent)
				{
					splineComputer = t.GetComponent<SplineComputer>();
				}
				if (splineComputer != null)
				{
					if (splineComputer.isClosed)
					{
						originalSpline.Close();
					}
					destinationSpline = new Spline(originalSpline.type);
					destinationSpline.points = new SplinePoint[originalSpline.points.Length];
					destinationSpline.points = splineComputer.GetPoints();
					if (splineComputer.isClosed)
					{
						destinationSpline.Close();
					}
				}
			}

			public void Revert()
			{
				if (isValid)
				{
					RevertTransform();
					RevertCollider();
					RevertMesh();
					if (splineComputer != null)
					{
						splineComputer.SetPoints(_originalSpline.points);
					}
				}
			}

			private void RevertMesh()
			{
				if (filter != null)
				{
					filter.sharedMesh = originalMesh;
				}
				destinationMesh = null;
			}

			private void RevertTransform()
			{
				transform.localPosition = originalPosition;
				transform.localRotation = originalRotation;
				transform.Update();
				transform.scale = originalScale;
				transform.Update();
			}

			private void RevertCollider()
			{
				if (collider != null)
				{
					collider.sharedMesh = originalColliderMesh;
				}
				destinationColliderMesh = null;
			}

			public void Apply(bool applyTransform)
			{
				if (!enabled || !isValid)
				{
					return;
				}
				if (applyTransform)
				{
					transform.Update();
				}
				if (editMesh != null && editMesh.hasUpdate)
				{
					ApplyMesh();
				}
				if (bendCollider && collider != null && !updateCollider && ((editColliderMesh == null && editMesh != null) || editColliderMesh != null))
				{
					updateCollider = true;
					if (UnityEngine.Application.isPlaying)
					{
						colliderUpdateDue = Time.time + colliderUpdateRate;
					}
				}
				if (splineComputer != null)
				{
					ApplySpline();
				}
			}

			public void Update()
			{
				if (Time.time >= colliderUpdateDue && updateCollider)
				{
					updateCollider = false;
					ApplyCollider();
				}
			}

			private void ApplyMesh()
			{
				if (!(filter == null))
				{
					MeshUtility.CalculateTangents(editMesh);
					if (destinationMesh == null)
					{
						destinationMesh = new Mesh();
						destinationMesh.name = originalMesh.name;
					}
					editMesh.WriteMesh(ref destinationMesh);
					destinationMesh.RecalculateBounds();
					filter.sharedMesh = destinationMesh;
				}
			}

			private void ApplyCollider()
			{
				if (collider == null)
				{
					return;
				}
				if (originalColliderMesh == originalMesh)
				{
					collider.sharedMesh = filter.sharedMesh;
					return;
				}
				MeshUtility.CalculateTangents(editColliderMesh);
				if (destinationColliderMesh == null)
				{
					destinationColliderMesh = new Mesh();
					destinationColliderMesh.name = originalColliderMesh.name;
				}
				editColliderMesh.WriteMesh(ref destinationColliderMesh);
				destinationColliderMesh.RecalculateBounds();
				collider.sharedMesh = destinationColliderMesh;
			}

			private void ApplySpline()
			{
				if (destinationSpline != null)
				{
					splineComputer.SetPoints(destinationSpline.points);
				}
			}
		}

		[SerializeField]
		[HideInInspector]
		private bool _bend;

		[HideInInspector]
		public BendProperty[] bendProperties = new BendProperty[0];

		[SerializeField]
		[HideInInspector]
		private TS_Bounds bounds;

		[SerializeField]
		[HideInInspector]
		private Axis _axis = Axis.Z;

		[SerializeField]
		[HideInInspector]
		private NormalMode _normalMode = NormalMode.Auto;

		[SerializeField]
		[HideInInspector]
		private ForwardMode _forwardMode;

		[SerializeField]
		[HideInInspector]
		[FormerlySerializedAs("_upVector")]
		private Vector3 _customNormal = Vector3.up;

		[SerializeField]
		[HideInInspector]
		private Vector3 _customForward = Vector3.forward;

		private Matrix4x4 normalMatrix;

		private Quaternion bendRotation = Quaternion.identity;

		public bool bend
		{
			get
			{
				return _bend;
			}
			set
			{
				if (_bend != value)
				{
					_bend = value;
					if (value)
					{
						UpdateReferences();
						Rebuild();
					}
					else
					{
						Revert();
					}
				}
			}
		}

		public Axis axis
		{
			get
			{
				return _axis;
			}
			set
			{
				if (base.spline != null && value != _axis)
				{
					_axis = value;
					UpdateReferences();
					Rebuild();
				}
				else
				{
					_axis = value;
				}
			}
		}

		public NormalMode upMode
		{
			get
			{
				return _normalMode;
			}
			set
			{
				if (base.spline != null && value != _normalMode)
				{
					_normalMode = value;
					Rebuild();
				}
				else
				{
					_normalMode = value;
				}
			}
		}

		public Vector3 customNormal
		{
			get
			{
				return _customNormal;
			}
			set
			{
				if (base.spline != null && value != _customNormal)
				{
					_customNormal = value;
					Rebuild();
				}
				else
				{
					_customNormal = value;
				}
			}
		}

		public ForwardMode forwardMode
		{
			get
			{
				return _forwardMode;
			}
			set
			{
				if (base.spline != null && value != _forwardMode)
				{
					_forwardMode = value;
					Rebuild();
				}
				else
				{
					_forwardMode = value;
				}
			}
		}

		public Vector3 customForward
		{
			get
			{
				return _customForward;
			}
			set
			{
				if (base.spline != null && value != _customForward)
				{
					_customForward = value;
					Rebuild();
				}
				else
				{
					_customForward = value;
				}
			}
		}

		private void GetTransformsRecursively(Transform current, ref List<Transform> transformList)
		{
			transformList.Add(current);
			foreach (Transform item in current)
			{
				GetTransformsRecursively(item, ref transformList);
			}
		}

		private void GetObjects()
		{
			List<Transform> transformList = new List<Transform>();
			GetTransformsRecursively(base.transform, ref transformList);
			BendProperty[] array = new BendProperty[transformList.Count];
			for (int i = 0; i < transformList.Count; i++)
			{
				CreateProperty(ref array[i], transformList[i]);
			}
			bendProperties = array;
		}

		public TS_Bounds GetBounds()
		{
			return new TS_Bounds(bounds.min, bounds.max, bounds.center);
		}

		private void CreateProperty(ref BendProperty property, Transform t)
		{
			property = new BendProperty(t, t == trs);
			for (int i = 0; i < bendProperties.Length; i++)
			{
				if (bendProperties[i].transform.transform == t)
				{
					property.enabled = bendProperties[i].enabled;
					property.applyRotation = bendProperties[i].applyRotation;
					property.applyScale = bendProperties[i].applyScale;
					property.bendMesh = bendProperties[i].bendMesh;
					property.bendCollider = bendProperties[i].bendCollider;
					property.generateLightmapUVs = bendProperties[i].generateLightmapUVs;
					property.colliderUpdateRate = bendProperties[i].colliderUpdateRate;
					break;
				}
			}
			if (t.transform != trs)
			{
				property.originalPosition = trs.InverseTransformPoint(t.position);
				property.originalRotation = Quaternion.Inverse(trs.rotation) * t.rotation;
			}
		}

		private void CalculateBounds()
		{
			if (bounds == null)
			{
				bounds = new TS_Bounds(Vector3.zero, Vector3.zero);
			}
			bounds.min = (bounds.max = Vector3.zero);
			for (int i = 0; i < bendProperties.Length; i++)
			{
				CalculatePropertyBounds(ref bendProperties[i]);
			}
			for (int j = 0; j < bendProperties.Length; j++)
			{
				CalculatePercents(bendProperties[j]);
			}
		}

		private void CalculatePropertyBounds(ref BendProperty property)
		{
			if (property.transform.transform == trs)
			{
				if (0f < bounds.min.x)
				{
					bounds.min.x = 0f;
				}
				if (0f < bounds.min.y)
				{
					bounds.min.y = 0f;
				}
				if (0f < bounds.min.z)
				{
					bounds.min.z = 0f;
				}
				if (0f > bounds.max.x)
				{
					bounds.max.x = 0f;
				}
				if (0f > bounds.max.y)
				{
					bounds.max.y = 0f;
				}
				if (0f > bounds.max.z)
				{
					bounds.max.z = 0f;
				}
			}
			else
			{
				if (property.originalPosition.x < bounds.min.x)
				{
					bounds.min.x = property.originalPosition.x;
				}
				if (property.originalPosition.y < bounds.min.y)
				{
					bounds.min.y = property.originalPosition.y;
				}
				if (property.originalPosition.z < bounds.min.z)
				{
					bounds.min.z = property.originalPosition.z;
				}
				if (property.originalPosition.x > bounds.max.x)
				{
					bounds.max.x = property.originalPosition.x;
				}
				if (property.originalPosition.y > bounds.max.y)
				{
					bounds.max.y = property.originalPosition.y;
				}
				if (property.originalPosition.z > bounds.max.z)
				{
					bounds.max.z = property.originalPosition.z;
				}
			}
			if (property.editMesh != null)
			{
				for (int i = 0; i < property.editMesh.vertices.Length; i++)
				{
					Vector3 position = property.transform.TransformPoint(property.editMesh.vertices[i]);
					position = trs.InverseTransformPoint(position);
					if (position.x < bounds.min.x)
					{
						bounds.min.x = position.x;
					}
					if (position.y < bounds.min.y)
					{
						bounds.min.y = position.y;
					}
					if (position.z < bounds.min.z)
					{
						bounds.min.z = position.z;
					}
					if (position.x > bounds.max.x)
					{
						bounds.max.x = position.x;
					}
					if (position.y > bounds.max.y)
					{
						bounds.max.y = position.y;
					}
					if (position.z > bounds.max.z)
					{
						bounds.max.z = position.z;
					}
				}
			}
			if (property.editColliderMesh != null)
			{
				for (int j = 0; j < property.editColliderMesh.vertices.Length; j++)
				{
					Vector3 position2 = property.transform.TransformPoint(property.editColliderMesh.vertices[j]);
					position2 = trs.InverseTransformPoint(position2);
					if (position2.x < bounds.min.x)
					{
						bounds.min.x = position2.x;
					}
					if (position2.y < bounds.min.y)
					{
						bounds.min.y = position2.y;
					}
					if (position2.z < bounds.min.z)
					{
						bounds.min.z = position2.z;
					}
					if (position2.x > bounds.max.x)
					{
						bounds.max.x = position2.x;
					}
					if (position2.y > bounds.max.y)
					{
						bounds.max.y = position2.y;
					}
					if (position2.z > bounds.max.z)
					{
						bounds.max.z = position2.z;
					}
				}
			}
			if (property.originalSpline != null)
			{
				for (int k = 0; k < property.originalSpline.points.Length; k++)
				{
					Vector3 vector = trs.InverseTransformPoint(property.originalSpline.points[k].position);
					if (vector.x < bounds.min.x)
					{
						bounds.min.x = vector.x;
					}
					if (vector.y < bounds.min.y)
					{
						bounds.min.y = vector.y;
					}
					if (vector.z < bounds.min.z)
					{
						bounds.min.z = vector.z;
					}
					if (vector.x > bounds.max.x)
					{
						bounds.max.x = vector.x;
					}
					if (vector.y > bounds.max.y)
					{
						bounds.max.y = vector.y;
					}
					if (vector.z > bounds.max.z)
					{
						bounds.max.z = vector.z;
					}
				}
			}
			bounds.CreateFromMinMax(bounds.min, bounds.max);
		}

		public void CalculatePercents(BendProperty property)
		{
			if (property.transform.transform != trs)
			{
				property.positionPercent = GetPercentage(trs.InverseTransformPoint(property.transform.position));
			}
			else
			{
				property.positionPercent = GetPercentage(Vector3.zero);
			}
			if (property.editMesh != null)
			{
				if (property.vertexPercents.Length != property.editMesh.vertexCount)
				{
					property.vertexPercents = new Vector3[property.editMesh.vertexCount];
				}
				if (property.editColliderMesh != null && property.colliderVertexPercents.Length != property.editMesh.vertexCount)
				{
					property.colliderVertexPercents = new Vector3[property.editColliderMesh.vertexCount];
				}
				for (int i = 0; i < property.editMesh.vertexCount; i++)
				{
					Vector3 position = property.transform.TransformPoint(property.editMesh.vertices[i]);
					position = trs.InverseTransformPoint(position);
					property.vertexPercents[i] = GetPercentage(position);
				}
				if (property.editColliderMesh != null)
				{
					for (int j = 0; j < property.editColliderMesh.vertexCount; j++)
					{
						Vector3 position2 = property.transform.TransformPoint(property.editColliderMesh.vertices[j]);
						position2 = trs.InverseTransformPoint(position2);
						property.colliderVertexPercents[j] = GetPercentage(position2);
					}
				}
			}
			if (property.splineComputer != null)
			{
				SplinePoint[] points = property.splineComputer.GetPoints();
				property.splinePointPercents = new Vector3[points.Length];
				property.primaryTangentPercents = new Vector3[points.Length];
				property.secondaryTangentPercents = new Vector3[points.Length];
				for (int k = 0; k < points.Length; k++)
				{
					property.splinePointPercents[k] = GetPercentage(trs.InverseTransformPoint(points[k].position));
					property.primaryTangentPercents[k] = GetPercentage(trs.InverseTransformPoint(points[k].tangent));
					property.secondaryTangentPercents[k] = GetPercentage(trs.InverseTransformPoint(points[k].tangent2));
				}
			}
		}

		private void Revert()
		{
			for (int i = 0; i < bendProperties.Length; i++)
			{
				bendProperties[i].Revert();
			}
		}

		public void UpdateReferences()
		{
			trs = base.transform;
			if (_bend)
			{
				for (int i = 0; i < bendProperties.Length; i++)
				{
					bendProperties[i].Revert();
				}
			}
			GetObjects();
			CalculateBounds();
			if (_bend)
			{
				Bend();
				for (int j = 0; j < bendProperties.Length; j++)
				{
					bendProperties[j].Apply(j > 0 || trs != base.spline.transform);
					bendProperties[j].Update();
				}
			}
		}

		private void GetevalResult(Vector3 percentage)
		{
			switch (axis)
			{
			case Axis.X:
				Evaluate(percentage.x, evalResult);
				break;
			case Axis.Y:
				Evaluate(percentage.y, evalResult);
				break;
			case Axis.Z:
				Evaluate(percentage.z, evalResult);
				break;
			}
			switch (_normalMode)
			{
			case NormalMode.Auto:
				evalResult.up = Vector3.Cross(evalResult.forward, evalResult.right);
				break;
			case NormalMode.Custom:
				evalResult.up = _customNormal;
				break;
			}
			if (_forwardMode == ForwardMode.Custom)
			{
				evalResult.forward = customForward;
			}
			ModifySample(evalResult);
			Vector3 right = evalResult.right;
			Quaternion quaternion = Quaternion.identity;
			switch (axis)
			{
			case Axis.Z:
				evalResult.position += right * Mathf.Lerp(bounds.min.x, bounds.max.x, percentage.x) * evalResult.size;
				evalResult.position += evalResult.up * Mathf.Lerp(bounds.min.y, bounds.max.y, percentage.y) * evalResult.size;
				break;
			case Axis.X:
				quaternion = Quaternion.Euler(0f, -90f, 0f);
				evalResult.position += right * Mathf.Lerp(bounds.max.z, bounds.min.z, percentage.z) * evalResult.size;
				evalResult.position += evalResult.up * Mathf.Lerp(bounds.min.y, bounds.max.y, percentage.y) * evalResult.size;
				break;
			case Axis.Y:
				quaternion = Quaternion.Euler(90f, 0f, 0f);
				evalResult.position += right * Mathf.Lerp(bounds.min.x, bounds.max.x, percentage.x) * evalResult.size;
				evalResult.position += evalResult.up * Mathf.Lerp(bounds.min.z, bounds.max.z, percentage.z) * evalResult.size;
				break;
			}
			bendRotation = evalResult.rotation * quaternion;
			normalMatrix = Matrix4x4.TRS(evalResult.position, bendRotation, Vector3.one * evalResult.size).inverse.transpose;
		}

		private Vector3 GetPercentage(Vector3 point)
		{
			point.x = Mathf.InverseLerp(bounds.min.x, bounds.max.x, point.x);
			point.y = Mathf.InverseLerp(bounds.min.y, bounds.max.y, point.y);
			point.z = Mathf.InverseLerp(bounds.min.z, bounds.max.z, point.z);
			return point;
		}

		protected override void Build()
		{
			base.Build();
			if (_bend)
			{
				Bend();
			}
		}

		private void Bend()
		{
			if (base.sampleCount > 1 && bendProperties.Length != 0)
			{
				for (int i = 0; i < bendProperties.Length; i++)
				{
					BendObject(bendProperties[i]);
				}
			}
		}

		public void BendObject(BendProperty p)
		{
			if (!p.enabled)
			{
				return;
			}
			GetevalResult(p.positionPercent);
			p.transform.position = evalResult.position;
			if (p.applyRotation)
			{
				p.transform.rotation = bendRotation * (Quaternion.Inverse(p.parentRotation) * p.originalRotation);
			}
			else
			{
				p.transform.rotation = p.originalRotation;
			}
			if (p.applyScale)
			{
				p.transform.scale = p.originalScale * evalResult.size;
			}
			Matrix4x4 inverse = Matrix4x4.TRS(p.transform.position, p.transform.rotation, p.transform.scale).inverse;
			if (p.editMesh != null)
			{
				BendMesh(p.vertexPercents, p.normals, p.editMesh, inverse);
				p.editMesh.hasUpdate = true;
			}
			if (p._editColliderMesh != null)
			{
				BendMesh(p.colliderVertexPercents, p.colliderNormals, p.editColliderMesh, inverse);
				p.editColliderMesh.hasUpdate = true;
			}
			if (p.originalSpline == null)
			{
				return;
			}
			for (int i = 0; i < p.splinePointPercents.Length; i++)
			{
				SplinePoint splinePoint = p.originalSpline.points[i];
				GetevalResult(p.splinePointPercents[i]);
				splinePoint.position = evalResult.position;
				GetevalResult(p.primaryTangentPercents[i]);
				splinePoint.tangent = evalResult.position;
				GetevalResult(p.secondaryTangentPercents[i]);
				splinePoint.tangent2 = evalResult.position;
				switch (axis)
				{
				case Axis.X:
					splinePoint.normal = Quaternion.LookRotation(evalResult.forward, evalResult.up) * Quaternion.FromToRotation(Vector3.up, evalResult.up) * splinePoint.normal;
					break;
				case Axis.Y:
					splinePoint.normal = Quaternion.LookRotation(evalResult.forward, evalResult.up) * Quaternion.FromToRotation(Vector3.up, evalResult.up) * splinePoint.normal;
					break;
				case Axis.Z:
					splinePoint.normal = Quaternion.LookRotation(evalResult.forward, evalResult.up) * splinePoint.normal;
					break;
				}
				p.destinationSpline.points[i] = splinePoint;
			}
		}

		private void BendMesh(Vector3[] vertexPercents, Vector3[] originalNormals, TS_Mesh mesh, Matrix4x4 worldToLocalMatrix)
		{
			if (mesh.vertexCount != vertexPercents.Length)
			{
				UnityEngine.Debug.LogError("Vertex count mismatch");
				return;
			}
			for (int i = 0; i < mesh.vertexCount; i++)
			{
				Vector3 percentage = vertexPercents[i];
				if (axis == Axis.Y)
				{
					percentage.z = 1f - percentage.z;
				}
				GetevalResult(percentage);
				mesh.vertices[i] = worldToLocalMatrix.MultiplyPoint3x4(evalResult.position);
				mesh.normals[i] = worldToLocalMatrix.MultiplyVector(normalMatrix.MultiplyVector(originalNormals[i]));
			}
		}

		protected override void PostBuild()
		{
			base.PostBuild();
			if (_bend)
			{
				for (int i = 0; i < bendProperties.Length; i++)
				{
					bendProperties[i].Apply(i > 0 || trs != base.spline.transform);
					bendProperties[i].Update();
				}
			}
		}

		protected override void LateRun()
		{
			base.LateRun();
			for (int i = 0; i < bendProperties.Length; i++)
			{
				bendProperties[i].Update();
			}
		}
	}
	[AddComponentMenu("Dreamteck/Splines/Users/Object Controller")]
	public class ObjectController : SplineUser
	{
		[Serializable]
		internal class ObjectControl
		{
			public GameObject gameObject;

			public Vector3 position = Vector3.zero;

			public Quaternion rotation = Quaternion.identity;

			public Vector3 scale = Vector3.one;

			public bool active = true;

			public Vector3 baseScale = Vector3.one;

			public bool isNull => gameObject == null;

			public Transform transform
			{
				get
				{
					if (gameObject == null)
					{
						return null;
					}
					return gameObject.transform;
				}
			}

			public ObjectControl(GameObject input)
			{
				gameObject = input;
				baseScale = gameObject.transform.localScale;
			}

			public void Destroy()
			{
				if (!(gameObject == null))
				{
					UnityEngine.Object.Destroy(gameObject);
				}
			}

			public void DestroyImmediate()
			{
				if (!(gameObject == null))
				{
					UnityEngine.Object.DestroyImmediate(gameObject);
				}
			}

			public void Apply()
			{
				if (!(gameObject == null))
				{
					transform.position = position;
					transform.rotation = rotation;
					transform.localScale = scale;
					gameObject.SetActive(active);
				}
			}
		}

		public enum ObjectMethod
		{
			Instantiate,
			GetChildren
		}

		public enum Positioning
		{
			Stretch,
			Clip
		}

		public enum Iteration
		{
			Ordered,
			Random
		}

		[SerializeField]
		[HideInInspector]
		public GameObject[] objects = new GameObject[0];

		[SerializeField]
		[HideInInspector]
		private float _evaluateOffset;

		[SerializeField]
		[HideInInspector]
		private int _spawnCount;

		[SerializeField]
		[HideInInspector]
		private Positioning _objectPositioning;

		[SerializeField]
		[HideInInspector]
		private Iteration _iteration;

		[SerializeField]
		[HideInInspector]
		private int _randomSeed = 1;

		[SerializeField]
		[HideInInspector]
		private Vector3 _minOffset = Vector3.zero;

		[SerializeField]
		[HideInInspector]
		private Vector3 _maxOffset = Vector3.zero;

		[SerializeField]
		[HideInInspector]
		private bool _offsetUseWorldCoords;

		[SerializeField]
		[HideInInspector]
		private Vector3 _minRotation = Vector3.zero;

		[SerializeField]
		[HideInInspector]
		private Vector3 _maxRotation = Vector3.zero;

		[SerializeField]
		[HideInInspector]
		private bool _uniformScaleLerp = true;

		[SerializeField]
		[HideInInspector]
		private Vector3 _minScaleMultiplier = Vector3.one;

		[SerializeField]
		[HideInInspector]
		private Vector3 _maxScaleMultiplier = Vector3.one;

		[SerializeField]
		[HideInInspector]
		private bool _shellOffset;

		[SerializeField]
		[HideInInspector]
		private bool _applyRotation = true;

		[SerializeField]
		[HideInInspector]
		private bool _rotateByOffset;

		[SerializeField]
		[HideInInspector]
		private bool _applyScale;

		[SerializeField]
		[HideInInspector]
		private ObjectMethod _objectMethod;

		[HideInInspector]
		public bool delayedSpawn;

		[HideInInspector]
		public float spawnDelay = 0.1f;

		[SerializeField]
		[HideInInspector]
		private int lastChildCount;

		[SerializeField]
		[HideInInspector]
		private ObjectControl[] spawned = new ObjectControl[0];

		private System.Random offsetRandomizer;

		private System.Random shellRandomizer;

		private System.Random rotationRandomizer;

		private System.Random scaleRandomizer;

		public ObjectMethod objectMethod
		{
			get
			{
				return _objectMethod;
			}
			set
			{
				if (value != _objectMethod)
				{
					if (value == ObjectMethod.GetChildren)
					{
						_objectMethod = value;
						Spawn();
					}
					else
					{
						_objectMethod = value;
					}
				}
			}
		}

		public int spawnCount
		{
			get
			{
				return _spawnCount;
			}
			set
			{
				if (value == _spawnCount)
				{
					return;
				}
				if (value < 0)
				{
					value = 0;
				}
				if (_objectMethod == ObjectMethod.Instantiate)
				{
					if (value < _spawnCount)
					{
						_spawnCount = value;
						Remove();
					}
					else
					{
						_spawnCount = value;
						Spawn();
					}
				}
				else
				{
					_spawnCount = value;
				}
			}
		}

		public Positioning objectPositioning
		{
			get
			{
				return _objectPositioning;
			}
			set
			{
				if (value != _objectPositioning)
				{
					_objectPositioning = value;
					Rebuild();
				}
			}
		}

		public Iteration iteration
		{
			get
			{
				return _iteration;
			}
			set
			{
				if (value != _iteration)
				{
					_iteration = value;
					Rebuild();
				}
			}
		}

		public int randomSeed
		{
			get
			{
				return _randomSeed;
			}
			set
			{
				if (value != _randomSeed)
				{
					_randomSeed = value;
					Rebuild();
				}
			}
		}

		public Vector3 minOffset
		{
			get
			{
				return _minOffset;
			}
			set
			{
				if (value != _minOffset)
				{
					_minOffset = value;
					Rebuild();
				}
			}
		}

		public Vector3 maxOffset
		{
			get
			{
				return _maxOffset;
			}
			set
			{
				if (value != _maxOffset)
				{
					_maxOffset = value;
					Rebuild();
				}
			}
		}

		public bool offsetUseWorldCoords
		{
			get
			{
				return _offsetUseWorldCoords;
			}
			set
			{
				if (value != _offsetUseWorldCoords)
				{
					_offsetUseWorldCoords = value;
					Rebuild();
				}
			}
		}

		public Vector3 minRotation
		{
			get
			{
				return _minRotation;
			}
			set
			{
				if (value != _minRotation)
				{
					_minRotation = value;
					Rebuild();
				}
			}
		}

		public Vector3 maxRotation
		{
			get
			{
				return _maxRotation;
			}
			set
			{
				if (value != _maxRotation)
				{
					_maxRotation = value;
					Rebuild();
				}
			}
		}

		public Vector3 rotationOffset
		{
			get
			{
				return (_maxRotation + _minRotation) / 2f;
			}
			set
			{
				if (value != _minRotation || value != _maxRotation)
				{
					_minRotation = (_maxRotation = value);
					Rebuild();
				}
			}
		}

		public Vector3 minScaleMultiplier
		{
			get
			{
				return _minScaleMultiplier;
			}
			set
			{
				if (value != _minScaleMultiplier)
				{
					_minScaleMultiplier = value;
					Rebuild();
				}
			}
		}

		public Vector3 maxScaleMultiplier
		{
			get
			{
				return _maxScaleMultiplier;
			}
			set
			{
				if (value != _maxScaleMultiplier)
				{
					_maxScaleMultiplier = value;
					Rebuild();
				}
			}
		}

		public bool uniformScaleLerp
		{
			get
			{
				return _uniformScaleLerp;
			}
			set
			{
				if (value != _uniformScaleLerp)
				{
					_uniformScaleLerp = value;
					Rebuild();
				}
			}
		}

		public bool shellOffset
		{
			get
			{
				return _shellOffset;
			}
			set
			{
				if (value != _shellOffset)
				{
					_shellOffset = value;
					Rebuild();
				}
			}
		}

		public bool applyRotation
		{
			get
			{
				return _applyRotation;
			}
			set
			{
				if (value != _applyRotation)
				{
					_applyRotation = value;
					Rebuild();
				}
			}
		}

		public bool rotateByOffset
		{
			get
			{
				return _rotateByOffset;
			}
			set
			{
				if (value != _rotateByOffset)
				{
					_rotateByOffset = value;
					Rebuild();
				}
			}
		}

		public bool applyScale
		{
			get
			{
				return _applyScale;
			}
			set
			{
				if (value != _applyScale)
				{
					_applyScale = value;
					Rebuild();
				}
			}
		}

		public float evaluateOffset
		{
			get
			{
				return _evaluateOffset;
			}
			set
			{
				if (value != _evaluateOffset)
				{
					_evaluateOffset = value;
					Rebuild();
				}
			}
		}

		public void Clear()
		{
			for (int i = 0; i < spawned.Length; i++)
			{
				if (spawned[i] != null && !(spawned[i].transform == null))
				{
					spawned[i].transform.localScale = spawned[i].baseScale;
					if (_objectMethod == ObjectMethod.GetChildren)
					{
						spawned[i].gameObject.SetActive(value: false);
					}
					else
					{
						spawned[i].Destroy();
					}
				}
			}
			spawned = new ObjectControl[0];
		}

		private void OnValidate()
		{
			if (_spawnCount < 0)
			{
				_spawnCount = 0;
			}
		}

		private void Remove()
		{
			if (_spawnCount >= spawned.Length)
			{
				return;
			}
			int num = spawned.Length - 1;
			while (num >= _spawnCount && num < spawned.Length)
			{
				if (spawned[num] != null)
				{
					spawned[num].transform.localScale = spawned[num].baseScale;
					if (_objectMethod == ObjectMethod.GetChildren)
					{
						spawned[num].gameObject.SetActive(value: false);
					}
					else if (UnityEngine.Application.isEditor)
					{
						spawned[num].DestroyImmediate();
					}
					else
					{
						spawned[num].Destroy();
					}
				}
				num--;
			}
			ObjectControl[] array = new ObjectControl[_spawnCount];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = spawned[i];
			}
			spawned = array;
			Rebuild();
		}

		public void GetAll()
		{
			ObjectControl[] array = new ObjectControl[base.transform.childCount];
			int num = 0;
			foreach (Transform item in base.transform)
			{
				if (array[num] == null)
				{
					array[num++] = new ObjectControl(item.gameObject);
					continue;
				}
				bool flag = false;
				for (int i = 0; i < spawned.Length; i++)
				{
					if (spawned[i].gameObject == item.gameObject)
					{
						array[num++] = spawned[i];
						flag = true;
						break;
					}
				}
				if (!flag)
				{
					array[num++] = new ObjectControl(item.gameObject);
				}
			}
			spawned = array;
		}

		public void Spawn()
		{
			if (_objectMethod == ObjectMethod.Instantiate)
			{
				if (delayedSpawn && UnityEngine.Application.isPlaying)
				{
					StopCoroutine("InstantiateAllWithDelay");
					StartCoroutine(InstantiateAllWithDelay());
				}
				else
				{
					InstantiateAll();
				}
			}
			else
			{
				GetAll();
			}
			Rebuild();
		}

		protected override void LateRun()
		{
			base.LateRun();
			if (_objectMethod == ObjectMethod.GetChildren && lastChildCount != base.transform.childCount)
			{
				Spawn();
				lastChildCount = base.transform.childCount;
			}
		}

		private IEnumerator InstantiateAllWithDelay()
		{
			if (!(base.spline == null) && objects.Length != 0)
			{
				for (int i = spawned.Length; i <= spawnCount; i++)
				{
					InstantiateSingle();
					yield return new WaitForSeconds(spawnDelay);
				}
			}
		}

		private void InstantiateAll()
		{
			if (!(base.spline == null) && objects.Length != 0)
			{
				for (int i = spawned.Length; i < spawnCount; i++)
				{
					InstantiateSingle();
				}
			}
		}

		private void InstantiateSingle()
		{
			if (objects.Length != 0)
			{
				int num = 0;
				num = ((_iteration != 0) ? UnityEngine.Random.Range(0, objects.Length) : (spawned.Length - Mathf.FloorToInt(spawned.Length / objects.Length) * objects.Length));
				if (!(objects[num] == null))
				{
					ObjectControl[] array = new ObjectControl[spawned.Length + 1];
					spawned.CopyTo(array, 0);
					array[array.Length - 1] = new ObjectControl(UnityEngine.Object.Instantiate(objects[num], base.transform.position, base.transform.rotation));
					array[array.Length - 1].transform.parent = base.transform;
					spawned = array;
				}
			}
		}

		protected override void Build()
		{
			base.Build();
			offsetRandomizer = new System.Random(_randomSeed);
			if (_shellOffset)
			{
				shellRandomizer = new System.Random(_randomSeed + 1);
			}
			rotationRandomizer = new System.Random(_randomSeed + 2);
			scaleRandomizer = new System.Random(_randomSeed + 3);
			bool flag = _minScaleMultiplier != _maxScaleMultiplier;
			for (int i = 0; i < spawned.Length; i++)
			{
				if (spawned[i] == null)
				{
					Clear();
					Spawn();
					break;
				}
				float num = 0f;
				if (spawned.Length > 1)
				{
					num = ((!base.spline.isClosed) ? ((float)i / (float)(spawned.Length - 1)) : ((float)i / (float)spawned.Length));
				}
				num += _evaluateOffset;
				if (num > 1f)
				{
					num -= 1f;
				}
				else if (num < 0f)
				{
					num += 1f;
				}
				if (objectPositioning == Positioning.Clip)
				{
					base.spline.Evaluate(num, evalResult);
				}
				else
				{
					Evaluate(num, evalResult);
				}
				ModifySample(evalResult);
				spawned[i].position = evalResult.position;
				if (_applyScale)
				{
					Vector3 scale = spawned[i].baseScale * evalResult.size;
					Vector3 vector = _minScaleMultiplier;
					if (flag)
					{
						if (_uniformScaleLerp)
						{
							vector = Vector3.Lerp(new Vector3(_minScaleMultiplier.x, _minScaleMultiplier.y, _minScaleMultiplier.x), new Vector3(_maxScaleMultiplier.x, _maxScaleMultiplier.y, _maxScaleMultiplier.z), (float)scaleRandomizer.NextDouble());
						}
						else
						{
							vector.x = Mathf.Lerp(_minScaleMultiplier.x, _maxScaleMultiplier.x, (float)scaleRandomizer.NextDouble());
							vector.y = Mathf.Lerp(_minScaleMultiplier.y, _maxScaleMultiplier.y, (float)scaleRandomizer.NextDouble());
							vector.z = Mathf.Lerp(_minScaleMultiplier.z, _maxScaleMultiplier.z, (float)scaleRandomizer.NextDouble());
						}
					}
					scale.x *= vector.x;
					scale.y *= vector.y;
					scale.z *= vector.z;
					spawned[i].scale = scale;
				}
				else
				{
					spawned[i].scale = spawned[i].baseScale;
				}
				Vector3 normalized = Vector3.Cross(evalResult.forward, evalResult.up).normalized;
				Vector3 vector2 = _minOffset;
				if (_minOffset != _maxOffset)
				{
					if (_shellOffset)
					{
						float num2 = _maxOffset.x - _minOffset.x;
						float num3 = _maxOffset.y - _minOffset.y;
						float f = (float)shellRandomizer.NextDouble() * 360f * ((float)Math.PI / 180f);
						vector2 = new Vector2(0.5f * Mathf.Cos(f), 0.5f * Mathf.Sin(f));
						vector2.x *= num2;
						vector2.y *= num3;
					}
					else
					{
						float t = (float)offsetRandomizer.NextDouble();
						vector2.x = Mathf.Lerp(_minOffset.x, _maxOffset.x, t);
						t = (float)offsetRandomizer.NextDouble();
						vector2.y = Mathf.Lerp(_minOffset.y, _maxOffset.y, t);
						t = (float)offsetRandomizer.NextDouble();
						vector2.z = Mathf.Lerp(_minOffset.z, _maxOffset.z, t);
					}
				}
				if (_offsetUseWorldCoords)
				{
					spawned[i].position += vector2;
				}
				else
				{
					spawned[i].position += normalized * vector2.x * evalResult.size + evalResult.up * vector2.y * evalResult.size;
				}
				if (_applyRotation)
				{
					Quaternion quaternion = Quaternion.Euler(Mathf.Lerp(_minRotation.x, _maxRotation.x, (float)rotationRandomizer.NextDouble()), Mathf.Lerp(_minRotation.y, _maxRotation.y, (float)rotationRandomizer.NextDouble()), Mathf.Lerp(_minRotation.z, _maxRotation.z, (float)rotationRandomizer.NextDouble()));
					if (_rotateByOffset)
					{
						spawned[i].rotation = Quaternion.LookRotation(evalResult.forward, spawned[i].position - evalResult.position) * quaternion;
					}
					else
					{
						spawned[i].rotation = evalResult.rotation * quaternion;
					}
				}
				if (_objectPositioning == Positioning.Clip)
				{
					if ((double)num < base.clipFrom || (double)num > base.clipTo)
					{
						spawned[i].active = false;
					}
					else
					{
						spawned[i].active = true;
					}
				}
			}
		}

		protected override void PostBuild()
		{
			base.PostBuild();
			for (int i = 0; i < spawned.Length; i++)
			{
				spawned[i].Apply();
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Dreamteck/Splines/Users/Particle Controller")]
	public class ParticleController : SplineUser
	{
		public enum EmitPoint
		{
			Beginning,
			Ending,
			Random,
			Ordered
		}

		public enum MotionType
		{
			None,
			UseParticleSystem,
			FollowForward,
			FollowBackward,
			ByNormal,
			ByNormalRandomized
		}

		public enum Wrap
		{
			Default,
			Loop
		}

		public class Particle
		{
			internal Vector2 startOffset = Vector2.zero;

			internal Vector2 endOffset = Vector2.zero;

			internal float cycleSpeed;

			internal float startLifetime;

			internal Color startColor = Color.white;

			internal float remainingLifetime;

			internal float lifeTime;

			internal double startPercent;

			internal double GetSplinePercent(Wrap wrap, ParticleSystem.Particle particle)
			{
				switch (wrap)
				{
				case Wrap.Default:
					return DMath.Clamp01(startPercent + (double)((1f - particle.remainingLifetime / particle.startLifetime) * cycleSpeed));
				case Wrap.Loop:
				{
					double num = startPercent + (1.0 - (double)(particle.remainingLifetime / particle.startLifetime)) * (double)cycleSpeed;
					if (num > 1.0)
					{
						num -= (double)Mathf.FloorToInt((float)num);
					}
					return num;
				}
				default:
					return 0.0;
				}
			}
		}

		[HideInInspector]
		public ParticleSystem _particleSystem;

		[HideInInspector]
		public bool volumetric;

		[HideInInspector]
		public bool emitFromShell;

		[HideInInspector]
		public Vector2 scale = Vector2.one;

		[HideInInspector]
		public EmitPoint emitPoint;

		[HideInInspector]
		public MotionType motionType = MotionType.UseParticleSystem;

		[HideInInspector]
		public Wrap wrapMode;

		[HideInInspector]
		public float minCycles = 1f;

		[HideInInspector]
		public float maxCycles = 1f;

		private ParticleSystem.Particle[] particles = new ParticleSystem.Particle[0];

		private Particle[] controllers = new Particle[0];

		private int particleCount;

		private int birthIndex;

		protected override void LateRun()
		{
			if (_particleSystem == null || base.sampleCount == 0)
			{
				return;
			}
			int maxParticles = _particleSystem.main.maxParticles;
			if (particles.Length != maxParticles)
			{
				particles = new ParticleSystem.Particle[maxParticles];
				Particle[] array = new Particle[maxParticles];
				for (int i = 0; i < array.Length && i < controllers.Length; i++)
				{
					array[i] = controllers[i];
				}
				controllers = array;
			}
			particleCount = _particleSystem.GetParticles(particles);
			bool flag = _particleSystem.main.simulationSpace == ParticleSystemSimulationSpace.Local;
			Transform transform = _particleSystem.transform;
			for (int num = particleCount - 1; num >= 0; num--)
			{
				if (flag)
				{
					TransformParticle(ref particles[num], transform);
				}
				if (controllers[num] == null)
				{
					controllers[num] = new Particle();
					OnParticleBorn(num);
					if (flag)
					{
						InverseTransformParticle(ref particles[num], transform);
					}
				}
				else
				{
					float num2 = particles[num].startLifetime - particles[num].remainingLifetime;
					if (num2 <= Time.deltaTime && controllers[num].lifeTime > num2)
					{
						OnParticleBorn(num);
					}
					if (flag)
					{
						InverseTransformParticle(ref particles[num], transform);
					}
				}
			}
			for (int j = 0; j < particleCount; j++)
			{
				if (controllers[j] == null)
				{
					controllers[j] = new Particle();
				}
				if (flag)
				{
					TransformParticle(ref particles[j], transform);
				}
				HandleParticle(j);
				if (flag)
				{
					InverseTransformParticle(ref particles[j], transform);
				}
			}
			_particleSystem.SetParticles(particles, particleCount);
		}

		private void TransformParticle(ref ParticleSystem.Particle particle, Transform trs)
		{
			particle.position = trs.TransformPoint(particle.position);
			particle.velocity = trs.TransformDirection(particle.velocity);
		}

		private void InverseTransformParticle(ref ParticleSystem.Particle particle, Transform trs)
		{
			particle.position = trs.InverseTransformPoint(particle.position);
			particle.velocity = trs.InverseTransformDirection(particle.velocity);
		}

		protected override void Reset()
		{
			base.Reset();
			updateMethod = UpdateMethod.LateUpdate;
			if (_particleSystem == null)
			{
				_particleSystem = GetComponent<ParticleSystem>();
			}
		}

		private void HandleParticle(int index)
		{
			float num = particles[index].remainingLifetime / particles[index].startLifetime;
			if (motionType == MotionType.FollowBackward || motionType == MotionType.FollowForward || motionType == MotionType.None)
			{
				Evaluate(controllers[index].GetSplinePercent(wrapMode, particles[index]), evalResult);
				ModifySample(evalResult);
				particles[index].position = evalResult.position;
				if (volumetric)
				{
					Vector3 vector = -Vector3.Cross(evalResult.forward, evalResult.up);
					Vector2 vector2 = controllers[index].startOffset;
					if (motionType != 0)
					{
						vector2 = Vector2.Lerp(controllers[index].startOffset, controllers[index].endOffset, 1f - num);
					}
					particles[index].position += vector * vector2.x * scale.x * evalResult.size + evalResult.up * vector2.y * scale.y * evalResult.size;
				}
				particles[index].velocity = evalResult.forward;
				particles[index].startColor = controllers[index].startColor * evalResult.color;
			}
			controllers[index].remainingLifetime = particles[index].remainingLifetime;
			controllers[index].lifeTime = particles[index].startLifetime - particles[index].remainingLifetime;
		}

		private void OnParticleDie(int index)
		{
		}

		private void OnParticleBorn(int index)
		{
			birthIndex++;
			double num = 0.0;
			float num2 = Mathf.Lerp(_particleSystem.emission.rateOverTime.constantMin, _particleSystem.emission.rateOverTime.constantMax, 0.5f) * _particleSystem.main.startLifetime.constantMax;
			if ((float)birthIndex > num2)
			{
				birthIndex = 0;
			}
			switch (emitPoint)
			{
			case EmitPoint.Beginning:
				num = 0.0;
				break;
			case EmitPoint.Ending:
				num = 1.0;
				break;
			case EmitPoint.Random:
				num = UnityEngine.Random.Range(0f, 1f);
				break;
			case EmitPoint.Ordered:
				num = ((num2 > 0f) ? ((float)birthIndex / num2) : 0f);
				break;
			}
			Evaluate(num, evalResult);
			ModifySample(evalResult);
			controllers[index].startColor = particles[index].startColor;
			controllers[index].startPercent = num;
			controllers[index].startLifetime = particles[index].startLifetime;
			controllers[index].remainingLifetime = particles[index].remainingLifetime;
			controllers[index].cycleSpeed = UnityEngine.Random.Range(minCycles, maxCycles);
			Vector2 vector = Vector2.zero;
			if (volumetric)
			{
				vector = ((!emitFromShell) ? UnityEngine.Random.insideUnitCircle : ((Vector2)(Quaternion.AngleAxis(UnityEngine.Random.Range(0f, 360f), Vector3.forward) * Vector2.right)));
			}
			controllers[index].startOffset = vector * 0.5f;
			controllers[index].endOffset = UnityEngine.Random.insideUnitCircle * 0.5f;
			Vector3 vector2 = Vector3.Cross(evalResult.forward, evalResult.up);
			particles[index].position = evalResult.position + vector2 * controllers[index].startOffset.x * evalResult.size * scale.x + evalResult.up * controllers[index].startOffset.y * evalResult.size * scale.y;
			float x = _particleSystem.forceOverLifetime.x.constantMax;
			float y = _particleSystem.forceOverLifetime.y.constantMax;
			float z = _particleSystem.forceOverLifetime.z.constantMax;
			if (_particleSystem.forceOverLifetime.randomized)
			{
				x = UnityEngine.Random.Range(_particleSystem.forceOverLifetime.x.constantMin, _particleSystem.forceOverLifetime.x.constantMax);
				y = UnityEngine.Random.Range(_particleSystem.forceOverLifetime.y.constantMin, _particleSystem.forceOverLifetime.y.constantMax);
				z = UnityEngine.Random.Range(_particleSystem.forceOverLifetime.z.constantMin, _particleSystem.forceOverLifetime.z.constantMax);
			}
			float num3 = particles[index].startLifetime - particles[index].remainingLifetime;
			Vector3 vector3 = new Vector3(x, y, z) * 0.5f * (num3 * num3);
			float constantMax = _particleSystem.main.startSpeed.constantMax;
			if (motionType == MotionType.ByNormal)
			{
				particles[index].position += evalResult.up * constantMax * (particles[index].startLifetime - particles[index].remainingLifetime);
				particles[index].position += vector3;
				particles[index].velocity = evalResult.up * constantMax + new Vector3(x, y, z) * num3;
			}
			else if (motionType == MotionType.ByNormalRandomized)
			{
				Vector3 vector4 = Quaternion.AngleAxis(UnityEngine.Random.Range(0f, 360f), evalResult.forward) * evalResult.up;
				particles[index].position += vector4 * constantMax * (particles[index].startLifetime - particles[index].remainingLifetime);
				particles[index].position += vector3;
				particles[index].velocity = vector4 * constantMax + new Vector3(x, y, z) * num3;
			}
			HandleParticle(index);
		}
	}
	[RequireComponent(typeof(MeshFilter))]
	[RequireComponent(typeof(MeshRenderer))]
	[AddComponentMenu("Dreamteck/Splines/Users/Path Generator")]
	public class PathGenerator : MeshGenerator
	{
		[SerializeField]
		[HideInInspector]
		private int _slices = 1;

		[SerializeField]
		[HideInInspector]
		private bool _useShapeCurve;

		[SerializeField]
		[HideInInspector]
		private AnimationCurve _shape;

		[SerializeField]
		[HideInInspector]
		private AnimationCurve _lastShape;

		[SerializeField]
		[HideInInspector]
		private float _shapeExposure = 1f;

		public int slices
		{
			get
			{
				return _slices;
			}
			set
			{
				if (value != _slices)
				{
					if (value < 1)
					{
						value = 1;
					}
					_slices = value;
					Rebuild();
				}
			}
		}

		public bool useShapeCurve
		{
			get
			{
				return _useShapeCurve;
			}
			set
			{
				if (value != _useShapeCurve)
				{
					_useShapeCurve = value;
					if (_useShapeCurve)
					{
						_shape = new AnimationCurve();
						_shape.AddKey(new Keyframe(0f, 0f));
						_shape.AddKey(new Keyframe(1f, 0f));
					}
					else
					{
						_shape = null;
					}
					Rebuild();
				}
			}
		}

		public float shapeExposure
		{
			get
			{
				return _shapeExposure;
			}
			set
			{
				if (base.spline != null && value != _shapeExposure)
				{
					_shapeExposure = value;
					Rebuild();
				}
			}
		}

		public AnimationCurve shape
		{
			get
			{
				return _shape;
			}
			set
			{
				if (_lastShape == null)
				{
					_lastShape = new AnimationCurve();
				}
				bool flag = false;
				if (value.keys.Length != _lastShape.keys.Length)
				{
					flag = true;
				}
				else
				{
					for (int i = 0; i < value.keys.Length; i++)
					{
						if (value.keys[i].inTangent != _lastShape.keys[i].inTangent || value.keys[i].outTangent != _lastShape.keys[i].outTangent || value.keys[i].time != _lastShape.keys[i].time || value.keys[i].value != value.keys[i].value)
						{
							flag = true;
							break;
						}
					}
				}
				if (flag)
				{
					Rebuild();
				}
				_lastShape.keys = new Keyframe[value.keys.Length];
				value.keys.CopyTo(_lastShape.keys, 0);
				_lastShape.preWrapMode = value.preWrapMode;
				_lastShape.postWrapMode = value.postWrapMode;
				_shape = value;
			}
		}

		protected override void Awake()
		{
			base.Awake();
			mesh.name = "path";
		}

		protected override void Reset()
		{
			base.Reset();
		}

		protected override void BuildMesh()
		{
			if (base.sampleCount != 0)
			{
				base.BuildMesh();
				GenerateVertices();
				MeshUtility.GeneratePlaneTriangles(ref tsMesh.triangles, _slices, base.sampleCount, flip: false);
			}
		}

		private void GenerateVertices()
		{
			int vertexCount = (_slices + 1) * base.sampleCount;
			AllocateMesh(vertexCount, _slices * (base.sampleCount - 1) * 6);
			int num = 0;
			ResetUVDistance();
			bool flag = base.offset != Vector3.zero;
			for (int i = 0; i < base.sampleCount; i++)
			{
				GetSample(i, evalResult);
				Vector3 zero = Vector3.zero;
				try
				{
					zero = evalResult.position;
				}
				catch (Exception ex)
				{
					UnityEngine.Debug.Log(ex.Message + " for i = " + i);
					break;
				}
				Vector3 right = evalResult.right;
				if (flag)
				{
					zero += base.offset.x * right + base.offset.y * evalResult.up + base.offset.z * evalResult.forward;
				}
				float num2 = base.size * evalResult.size;
				Vector3 vector = Vector3.zero;
				Quaternion quaternion = Quaternion.AngleAxis(base.rotation, evalResult.forward);
				if (base.uvMode == UVMode.UniformClamp || base.uvMode == UVMode.UniformClip)
				{
					AddUVDistance(i);
				}
				Color color = evalResult.color * base.color;
				for (int j = 0; j < _slices + 1; j++)
				{
					float num3 = (float)j / (float)_slices;
					float num4 = 0f;
					if (_useShapeCurve)
					{
						num4 = _shape.Evaluate(num3);
					}
					tsMesh.vertices[num] = zero + quaternion * right * num2 * 0.5f - quaternion * right * num2 * num3 + quaternion * evalResult.up * num4 * _shapeExposure;
					CalculateUVs(evalResult.percent, 1f - num3);
					tsMesh.uv[num] = Vector2.one * 0.5f + (Vector2)(Quaternion.AngleAxis(base.uvRotation, Vector3.forward) * (Vector2.one * 0.5f - MeshGenerator.uvs));
					if (_slices > 1)
					{
						if (j < _slices)
						{
							float num5 = (float)(j + 1) / (float)_slices;
							num4 = 0f;
							if (_useShapeCurve)
							{
								num4 = _shape.Evaluate(num5);
							}
							Vector3 vector2 = zero + quaternion * right * num2 * 0.5f - quaternion * right * num2 * num5 + quaternion * evalResult.up * num4 * _shapeExposure;
							Vector3 vector3 = -Vector3.Cross(evalResult.forward, vector2 - tsMesh.vertices[num]).normalized;
							if (j > 0)
							{
								Vector3 b = -Vector3.Cross(evalResult.forward, tsMesh.vertices[num] - vector).normalized;
								tsMesh.normals[num] = Vector3.Slerp(vector3, b, 0.5f);
							}
							else
							{
								tsMesh.normals[num] = vector3;
							}
						}
						else
						{
							tsMesh.normals[num] = -Vector3.Cross(evalResult.forward, tsMesh.vertices[num] - vector).normalized;
						}
					}
					else
					{
						tsMesh.normals[num] = evalResult.up;
						if (base.rotation != 0f)
						{
							tsMesh.normals[num] = quaternion * tsMesh.normals[num];
						}
					}
					tsMesh.colors[num] = color;
					vector = tsMesh.vertices[num];
					num++;
				}
			}
		}
	}
	[AddComponentMenu("Dreamteck/Splines/Users/Polygon Collider Generator")]
	[RequireComponent(typeof(PolygonCollider2D))]
	public class PolygonColliderGenerator : SplineUser
	{
		public enum Type
		{
			Path,
			Shape
		}

		[SerializeField]
		[HideInInspector]
		private Type _type;

		[SerializeField]
		[HideInInspector]
		private float _size = 1f;

		[SerializeField]
		[HideInInspector]
		private float _offset;

		[SerializeField]
		[HideInInspector]
		protected PolygonCollider2D polygonCollider;

		[SerializeField]
		[HideInInspector]
		protected Vector2[] vertices = new Vector2[0];

		[HideInInspector]
		public float updateRate = 0.1f;

		protected float lastUpdateTime;

		private bool updateCollider;

		public Type type
		{
			get
			{
				return _type;
			}
			set
			{
				if (value != _type)
				{
					_type = value;
					Rebuild();
				}
			}
		}

		public float size
		{
			get
			{
				return _size;
			}
			set
			{
				if (value != _size)
				{
					_size = value;
					Rebuild();
				}
			}
		}

		public float offset
		{
			get
			{
				return _offset;
			}
			set
			{
				if (value != _offset)
				{
					_offset = value;
					Rebuild();
				}
			}
		}

		protected override void Awake()
		{
			base.Awake();
			polygonCollider = GetComponent<PolygonCollider2D>();
		}

		protected override void Reset()
		{
			base.Reset();
		}

		protected override void OnEnable()
		{
			base.OnEnable();
		}

		protected override void OnDisable()
		{
			base.OnDisable();
		}

		protected override void OnDestroy()
		{
			base.OnDestroy();
		}

		protected override void LateRun()
		{
			base.LateRun();
			if (updateCollider && polygonCollider != null && Time.time - lastUpdateTime >= updateRate)
			{
				lastUpdateTime = Time.time;
				updateCollider = false;
				polygonCollider.SetPath(0, vertices);
			}
		}

		protected override void Build()
		{
			base.Build();
			if (base.sampleCount != 0)
			{
				switch (type)
				{
				case Type.Path:
					GeneratePath();
					break;
				case Type.Shape:
					GenerateShape();
					break;
				}
			}
		}

		protected override void PostBuild()
		{
			base.PostBuild();
			if (!(polygonCollider == null))
			{
				for (int i = 0; i < vertices.Length; i++)
				{
					vertices[i] = base.transform.InverseTransformPoint(vertices[i]);
				}
				if (updateRate == 0f)
				{
					polygonCollider.SetPath(0, vertices);
				}
				else
				{
					updateCollider = true;
				}
			}
		}

		private void GeneratePath()
		{
			int num = base.sampleCount * 2;
			if (vertices.Length != num)
			{
				vertices = new Vector2[num];
			}
			for (int i = 0; i < base.sampleCount; i++)
			{
				GetSample(i, evalResult);
				Vector2 vector = new Vector2(0f - evalResult.forward.y, evalResult.forward.x).normalized * evalResult.size;
				vertices[i] = new Vector2(evalResult.position.x, evalResult.position.y) + vector * size * 0.5f + vector * offset;
				vertices[base.sampleCount + (base.sampleCount - 1) - i] = new Vector2(evalResult.position.x, evalResult.position.y) - vector * size * 0.5f + vector * offset;
			}
		}

		private void GenerateShape()
		{
			if (vertices.Length != base.sampleCount)
			{
				vertices = new Vector2[base.sampleCount];
			}
			for (int i = 0; i < base.sampleCount; i++)
			{
				GetSample(i, evalResult);
				vertices[i] = evalResult.position;
				if (offset != 0f)
				{
					Vector2 vector = new Vector2(0f - evalResult.forward.y, evalResult.forward.x).normalized * evalResult.size;
					vertices[i] += vector * offset;
				}
			}
		}
	}
	[Serializable]
	public class ColorModifier : SplineSampleModifier
	{
		[Serializable]
		public class ColorKey : Key
		{
			public enum BlendMode
			{
				Lerp,
				Multiply,
				Add,
				Subtract
			}

			public Color color = Color.white;

			public BlendMode blendMode;

			public ColorKey(double f, double t, ColorModifier modifier)
				: base(f, t, modifier)
			{
			}

			public Color Blend(Color input, float percent)
			{
				return blendMode switch
				{
					BlendMode.Lerp => Color.Lerp(input, color, blend * percent), 
					BlendMode.Add => input + color * blend * percent, 
					BlendMode.Subtract => input - color * blend * percent, 
					BlendMode.Multiply => Color.Lerp(input, input * color, blend * percent), 
					_ => input, 
				};
			}
		}

		public List<ColorKey> keys = new List<ColorKey>();

		public ColorModifier()
		{
			keys = new List<ColorKey>();
		}

		public override List<Key> GetKeys()
		{
			List<Key> list = new List<Key>();
			for (int i = 0; i < keys.Count; i++)
			{
				list.Add(keys[i]);
			}
			return list;
		}

		public override void SetKeys(List<Key> input)
		{
			keys = new List<ColorKey>();
			for (int i = 0; i < input.Count; i++)
			{
				keys.Add((ColorKey)input[i]);
			}
			base.SetKeys(input);
		}

		public void AddKey(double f, double t)
		{
			keys.Add(new ColorKey(f, t, this));
		}

		public override void Apply(SplineSample result)
		{
			if (keys.Count != 0)
			{
				base.Apply(result);
				for (int i = 0; i < keys.Count; i++)
				{
					result.color = keys[i].Blend(result.color, keys[i].Evaluate(result.percent));
				}
			}
		}
	}
	[Serializable]
	public class MeshScaleModifier : SplineSampleModifier
	{
		[Serializable]
		public class ScaleKey : Key
		{
			public Vector2 scale = Vector2.one;

			public ScaleKey(double f, double t, MeshScaleModifier modifier)
				: base(f, t, modifier)
			{
			}
		}

		public List<ScaleKey> keys = new List<ScaleKey>();

		public MeshScaleModifier()
		{
			keys = new List<ScaleKey>();
		}

		public override List<Key> GetKeys()
		{
			List<Key> list = new List<Key>();
			for (int i = 0; i < keys.Count; i++)
			{
				list.Add(keys[i]);
			}
			return list;
		}

		public override void SetKeys(List<Key> input)
		{
			keys = new List<ScaleKey>();
			for (int i = 0; i < input.Count; i++)
			{
				input[i].modifier = this;
				keys.Add((ScaleKey)input[i]);
			}
		}

		public void AddKey(double f, double t)
		{
			keys.Add(new ScaleKey(f, t, this));
		}

		public override void Apply(SplineSample result)
		{
			if (keys.Count != 0)
			{
				for (int i = 0; i < keys.Count; i++)
				{
					result.size += keys[i].Evaluate(result.percent) * keys[i].scale.magnitude;
				}
			}
		}

		public Vector2 GetScale(SplineSample sample)
		{
			Vector2 one = Vector2.one;
			for (int i = 0; i < keys.Count; i++)
			{
				float t = keys[i].Evaluate(sample.percent);
				Vector2 vector = Vector2.Lerp(Vector2.one, keys[i].scale, t);
				one.x *= vector.x;
				one.y *= vector.y;
			}
			return one;
		}
	}
	[Serializable]
	public class OffsetModifier : SplineSampleModifier
	{
		[Serializable]
		public class OffsetKey : Key
		{
			public Vector2 offset = Vector2.zero;

			public OffsetKey(Vector2 o, double f, double t, OffsetModifier modifier)
				: base(f, t, modifier)
			{
				offset = o;
			}
		}

		public List<OffsetKey> keys = new List<OffsetKey>();

		public OffsetModifier()
		{
			keys = new List<OffsetKey>();
		}

		public override List<Key> GetKeys()
		{
			List<Key> list = new List<Key>();
			for (int i = 0; i < keys.Count; i++)
			{
				list.Add(keys[i]);
			}
			return list;
		}

		public override void SetKeys(List<Key> input)
		{
			keys = new List<OffsetKey>();
			for (int i = 0; i < input.Count; i++)
			{
				keys.Add((OffsetKey)input[i]);
			}
			base.SetKeys(input);
		}

		public void AddKey(Vector2 offset, double f, double t)
		{
			keys.Add(new OffsetKey(offset, f, t, this));
		}

		public override void Apply(SplineSample result)
		{
			if (keys.Count != 0)
			{
				base.Apply(result);
				Vector2 vector = Evaluate(result.percent);
				result.position += result.right * vector.x + result.up * vector.y;
			}
		}

		private Vector2 Evaluate(double time)
		{
			if (keys.Count == 0)
			{
				return Vector2.zero;
			}
			Vector2 zero = Vector2.zero;
			for (int i = 0; i < keys.Count; i++)
			{
				zero += keys[i].offset * keys[i].Evaluate(time);
			}
			return zero * blend;
		}
	}
	[Serializable]
	public class RotationModifier : SplineSampleModifier
	{
		[Serializable]
		public class RotationKey : Key
		{
			public bool useLookTarget;

			public Transform target;

			public Vector3 rotation = Vector3.zero;

			public RotationKey(Vector3 rotation, double f, double t, RotationModifier modifier)
				: base(f, t, modifier)
			{
				this.rotation = rotation;
			}
		}

		public List<RotationKey> keys = new List<RotationKey>();

		public RotationModifier()
		{
			keys = new List<RotationKey>();
		}

		public override List<Key> GetKeys()
		{
			List<Key> list = new List<Key>();
			for (int i = 0; i < keys.Count; i++)
			{
				list.Add(keys[i]);
			}
			return list;
		}

		public override void SetKeys(List<Key> input)
		{
			keys = new List<RotationKey>();
			for (int i = 0; i < input.Count; i++)
			{
				keys.Add((RotationKey)input[i]);
			}
			base.SetKeys(input);
		}

		public void AddKey(Vector3 rotation, double f, double t)
		{
			keys.Add(new RotationKey(rotation, f, t, this));
		}

		public override void Apply(SplineSample result)
		{
			if (keys.Count == 0)
			{
				return;
			}
			base.Apply(result);
			Quaternion quaternion = Quaternion.identity;
			Quaternion quaternion2 = result.rotation;
			for (int i = 0; i < keys.Count; i++)
			{
				if (keys[i].useLookTarget && keys[i].target != null)
				{
					Quaternion b = Quaternion.LookRotation(keys[i].target.position - result.position);
					quaternion2 = Quaternion.Slerp(quaternion2, b, keys[i].Evaluate(result.percent));
				}
				else
				{
					Quaternion quaternion3 = Quaternion.Euler(keys[i].rotation.x, keys[i].rotation.y, keys[i].rotation.z);
					quaternion = Quaternion.Slerp(quaternion, quaternion * quaternion3, keys[i].Evaluate(result.percent));
				}
			}
			Quaternion quaternion4 = quaternion2 * quaternion;
			Vector3 vector = Quaternion.Inverse(result.rotation) * result.up;
			result.forward = quaternion4 * Vector3.forward;
			result.up = quaternion4 * vector;
		}
	}
	[Serializable]
	public class SizeModifier : SplineSampleModifier
	{
		[Serializable]
		public class SizeKey : Key
		{
			public float size;

			public SizeKey(double f, double t, SizeModifier modifier)
				: base(f, t, modifier)
			{
			}
		}

		public List<SizeKey> keys = new List<SizeKey>();

		public SizeModifier()
		{
			keys = new List<SizeKey>();
		}

		public override List<Key> GetKeys()
		{
			List<Key> list = new List<Key>();
			for (int i = 0; i < keys.Count; i++)
			{
				list.Add(keys[i]);
			}
			return list;
		}

		public override void SetKeys(List<Key> input)
		{
			keys = new List<SizeKey>();
			for (int i = 0; i < input.Count; i++)
			{
				input[i].modifier = this;
				keys.Add((SizeKey)input[i]);
			}
		}

		public void AddKey(double f, double t)
		{
			keys.Add(new SizeKey(f, t, this));
		}

		public override void Apply(SplineSample result)
		{
			if (keys.Count != 0)
			{
				base.Apply(result);
				for (int i = 0; i < keys.Count; i++)
				{
					result.size += keys[i].Evaluate(result.percent) * keys[i].size;
				}
			}
		}
	}
	[Serializable]
	public class SplineSampleModifier
	{
		[Serializable]
		public class Key
		{
			[SerializeField]
			private double _featherStart;

			[SerializeField]
			private double _featherEnd;

			[SerializeField]
			private double _centerStart = 0.25;

			[SerializeField]
			private double _centerEnd = 0.75;

			[SerializeField]
			internal SplineSampleModifier modifier;

			public AnimationCurve interpolation;

			public float blend = 1f;

			public double start
			{
				get
				{
					return _featherStart;
				}
				set
				{
					if (value != _featherStart)
					{
						_featherStart = DMath.Clamp01(value);
					}
				}
			}

			public double end
			{
				get
				{
					return _featherEnd;
				}
				set
				{
					if (value != _featherEnd)
					{
						_featherEnd = DMath.Clamp01(value);
					}
				}
			}

			public double centerStart
			{
				get
				{
					return _centerStart;
				}
				set
				{
					if (value != _centerStart)
					{
						_centerStart = DMath.Clamp01(value);
						if (_centerStart > _centerEnd)
						{
							_centerStart = _centerEnd;
						}
					}
				}
			}

			public double centerEnd
			{
				get
				{
					return _centerEnd;
				}
				set
				{
					if (value != _centerEnd)
					{
						_centerEnd = DMath.Clamp01(value);
						if (_centerEnd < _centerStart)
						{
							_centerEnd = _centerStart;
						}
					}
				}
			}

			public double globalCenterStart
			{
				get
				{
					return LocalToGlobalPercent(centerStart);
				}
				set
				{
					centerStart = DMath.Clamp01(GlobalToLocalPercent(value));
				}
			}

			public double globalCenterEnd
			{
				get
				{
					return LocalToGlobalPercent(centerEnd);
				}
				set
				{
					centerEnd = DMath.Clamp01(GlobalToLocalPercent(value));
				}
			}

			public double position
			{
				get
				{
					double num = DMath.Lerp(_centerStart, _centerEnd, 0.5);
					if (start > end)
					{
						double num2 = DMath.Lerp(_featherStart, _featherEnd, num);
						double num3 = 1.0 - _featherStart;
						double num4 = num * (num3 + _featherEnd);
						num2 = _featherStart + num4;
						if (num2 > 1.0)
						{
							num2 -= 1.0;
						}
						return num2;
					}
					return DMath.Lerp(_featherStart, _featherEnd, num);
				}
				set
				{
					double num = value - position;
					start += num;
					end += num;
				}
			}

			internal Key(double f, double t, SplineSampleModifier modifier)
			{
				this.modifier = modifier;
				start = f;
				end = t;
				interpolation = AnimationCurve.Linear(0f, 0f, 1f, 1f);
			}

			private double GlobalToLocalPercent(double t)
			{
				if (_featherStart > _featherEnd)
				{
					if (t > _featherStart)
					{
						return DMath.InverseLerp(_featherStart, _featherStart + (1.0 - _featherStart) + _featherEnd, t);
					}
					if (t < _featherEnd)
					{
						return DMath.InverseLerp(0.0 - (1.0 - _featherStart), _featherEnd, t);
					}
					return 0.0;
				}
				return DMath.InverseLerp(_featherStart, _featherEnd, t);
			}

			private double LocalToGlobalPercent(double t)
			{
				if (_featherStart > _featherEnd)
				{
					t = DMath.Lerp(_featherStart, _featherStart + (1.0 - _featherStart) + _featherEnd, t);
					if (t > 1.0)
					{
						t -= 1.0;
					}
					return t;
				}
				return DMath.Lerp(_featherStart, _featherEnd, t);
			}

			public float Evaluate(double t)
			{
				t = (float)GlobalToLocalPercent(t);
				if (t < _centerStart)
				{
					return interpolation.Evaluate((float)t / (float)_centerStart) * blend;
				}
				if (t > _centerEnd)
				{
					return interpolation.Evaluate(1f - (float)DMath.InverseLerp(_centerEnd, 1.0, t)) * blend;
				}
				return interpolation.Evaluate(1f) * blend;
			}

			public virtual Key Duplicate()
			{
				return new Key(start, end, modifier)
				{
					_centerStart = _centerStart,
					_centerEnd = _centerEnd,
					blend = blend,
					interpolation = DuplicateUtility.DuplicateCurve(interpolation)
				};
			}
		}

		public float blend = 1f;

		public virtual List<Key> GetKeys()
		{
			return new List<Key>();
		}

		public virtual void SetKeys(List<Key> input)
		{
			for (int i = 0; i < input.Count; i++)
			{
				input[i].modifier = this;
			}
		}

		public virtual void Apply(SplineSample result)
		{
		}

		public virtual void Apply(SplineSample source, SplineSample destination)
		{
			destination.CopyFrom(source);
			Apply(destination);
		}
	}
	public delegate void EmptySplineHandler();
	[AddComponentMenu("Dreamteck/Splines/Spline Computer")]
	[ExecuteInEditMode]
	public class SplineComputer : MonoBehaviour
	{
		public enum Space
		{
			World,
			Local
		}

		public enum EvaluateMode
		{
			Cached,
			Calculate
		}

		public enum SampleMode
		{
			Default,
			Uniform,
			Optimized
		}

		public enum UpdateMode
		{
			Update,
			FixedUpdate,
			LateUpdate,
			AllUpdate,
			None
		}

		[Serializable]
		internal class NodeLink
		{
			[SerializeField]
			internal Node node;

			[SerializeField]
			internal int pointIndex;

			internal List<Node.Connection> GetConnections(SplineComputer exclude)
			{
				Node.Connection[] connections = node.GetConnections();
				List<Node.Connection> list = new List<Node.Connection>();
				for (int i = 0; i < connections.Length; i++)
				{
					if (!(connections[i].spline == exclude))
					{
						list.Add(connections[i]);
					}
				}
				return list;
			}
		}

		[HideInInspector]
		public bool multithreaded;

		[HideInInspector]
		public bool rebuildOnAwake;

		[HideInInspector]
		public UpdateMode updateMode;

		[HideInInspector]
		public TriggerGroup[] triggerGroups = new TriggerGroup[0];

		[HideInInspector]
		[SerializeField]
		private Spline spline = new Spline(Spline.Type.CatmullRom);

		[HideInInspector]
		[SerializeField]
		private SplineSample[] _rawSamples = new SplineSample[0];

		[HideInInspector]
		[SerializeField]
		private SplineSample[] _transformedSamples = new SplineSample[0];

		[HideInInspector]
		[SerializeField]
		private SampleCollection sampleCollection = new SampleCollection();

		[HideInInspector]
		[SerializeField]
		private double[] originalSamplePercents = new double[0];

		private bool[] sampleFlter = new bool[0];

		[HideInInspector]
		[SerializeField]
		private int _sampleCount;

		[HideInInspector]
		[SerializeField]
		private bool _is2D;

		[HideInInspector]
		[SerializeField]
		private bool hasSamples;

		[HideInInspector]
		[SerializeField]
		private bool[] pointsDirty = new bool[0];

		[HideInInspector]
		[SerializeField]
		[Range(0.001f, 45f)]
		private float _optimizeAngleThreshold = 0.5f;

		[HideInInspector]
		[SerializeField]
		private Space _space = Space.Local;

		[HideInInspector]
		[SerializeField]
		private SampleMode _sampleMode;

		[HideInInspector]
		[SerializeField]
		private SplineUser[] subscribers = new SplineUser[0];

		[HideInInspector]
		[SerializeField]
		[FormerlySerializedAs("_nodeLinks")]
		private NodeLink[] nodes = new NodeLink[0];

		private bool rebuildPending;

		private bool _trsCheck;

		private Transform _trs;

		private Matrix4x4 transformMatrix;

		private Matrix4x4 inverseTransformMatrix;

		private bool queueResample;

		private bool queueRebuild;

		private Vector3 lastPosition = Vector3.zero;

		private Vector3 lastScale = Vector3.zero;

		private bool uniformScale = true;

		private Quaternion lastRotation = Quaternion.identity;

		public Space space
		{
			get
			{
				return _space;
			}
			set
			{
				if (value == _space)
				{
					return;
				}
				SplinePoint[] points = GetPoints();
				_space = value;
				if (_space == Space.Local)
				{
					_transformedSamples = new SplineSample[_rawSamples.Length];
					for (int i = 0; i < _transformedSamples.Length; i++)
					{
						_transformedSamples[i] = new SplineSample();
					}
				}
				SetPoints(points);
				Rebuild(forceUpdateAll: true);
			}
		}

		public Spline.Type type
		{
			get
			{
				return spline.type;
			}
			set
			{
				if (value != spline.type)
				{
					spline.type = value;
					Rebuild(forceUpdateAll: true);
				}
			}
		}

		public bool linearAverageDirection
		{
			get
			{
				return spline.linearAverageDirection;
			}
			set
			{
				if (value != spline.linearAverageDirection)
				{
					spline.linearAverageDirection = value;
					Rebuild(forceUpdateAll: true);
				}
			}
		}

		public bool is2D
		{
			get
			{
				return _is2D;
			}
			set
			{
				if (value != _is2D)
				{
					_is2D = value;
					SetPoints(GetPoints());
				}
			}
		}

		public int sampleRate
		{
			get
			{
				return spline.sampleRate;
			}
			set
			{
				if (value != spline.sampleRate)
				{
					if (value < 2)
					{
						value = 2;
					}
					spline.sampleRate = value;
					Rebuild(forceUpdateAll: true);
				}
			}
		}

		public float optimizeAngleThreshold
		{
			get
			{
				return _optimizeAngleThreshold;
			}
			set
			{
				if (value != _optimizeAngleThreshold)
				{
					if (value < 0.001f)
					{
						value = 0.001f;
					}
					_optimizeAngleThreshold = value;
					if (_sampleMode == SampleMode.Optimized)
					{
						Rebuild(forceUpdateAll: true);
					}
				}
			}
		}

		public SampleMode sampleMode
		{
			get
			{
				return _sampleMode;
			}
			set
			{
				if (value != _sampleMode)
				{
					_sampleMode = value;
					Rebuild(forceUpdateAll: true);
				}
			}
		}

		public AnimationCurve customValueInterpolation
		{
			get
			{
				return spline.customValueInterpolation;
			}
			set
			{
				spline.customValueInterpolation = value;
				Rebuild();
			}
		}

		public AnimationCurve customNormalInterpolation
		{
			get
			{
				return spline.customNormalInterpolation;
			}
			set
			{
				spline.customNormalInterpolation = value;
				Rebuild();
			}
		}

		public int iterations => spline.iterations;

		public double moveStep => spline.moveStep;

		public bool isClosed => spline.isClosed;

		public int pointCount => spline.points.Length;

		public SplineSample[] samples => sampleCollection.samples;

		public int sampleCount => _sampleCount;

		public SplineSample[] rawSamples => _rawSamples;

		public Vector3 position => lastPosition;

		public Quaternion rotation => lastRotation;

		public Vector3 scale => lastScale;

		public int subscriberCount => subscribers.Length;

		public Transform trs
		{
			get
			{
				if (!_trsCheck)
				{
					_trs = base.transform;
				}
				return _trs;
			}
		}

		private bool useMultithreading => multithreaded;

		public event EmptySplineHandler onRebuild;

		private void Awake()
		{
			if (rebuildOnAwake)
			{
				RebuildImmediate(calculateSamples: true, forceUpdateAll: true);
			}
			ResampleTransform();
		}

		private void FixedUpdate()
		{
			if (updateMode == UpdateMode.FixedUpdate || updateMode == UpdateMode.AllUpdate)
			{
				RunUpdate();
			}
		}

		private void LateUpdate()
		{
			if (updateMode == UpdateMode.LateUpdate || updateMode == UpdateMode.AllUpdate)
			{
				RunUpdate();
			}
		}

		private void Update()
		{
			if (updateMode == UpdateMode.Update || updateMode == UpdateMode.AllUpdate)
			{
				RunUpdate();
			}
		}

		private void RunUpdate()
		{
			bool flag = TransformHasChanged();
			if (flag)
			{
				ResampleTransform();
				if (nodes.Length != 0)
				{
					UpdateConnectedNodes();
				}
			}
			if (useMultithreading && queueRebuild)
			{
				RebuildUsers();
			}
			if (queueResample)
			{
				if (useMultithreading)
				{
					if (!flag)
					{
						SplineThreading.Run(CalculateAndTransformSamples);
					}
					else
					{
						SplineThreading.Run(CalculateSamples);
					}
				}
				else
				{
					CalculateSamples();
					if (!flag)
					{
						TransformSamples();
					}
				}
			}
			if (flag)
			{
				SetPointsDirty();
				if (useMultithreading)
				{
					SplineThreading.Run(TransformSamplesThreaded);
				}
				else
				{
					TransformSamples(forceTransformAll: true);
				}
			}
			if (!useMultithreading && queueRebuild)
			{
				RebuildUsers();
			}
		}

		private void TransformSamplesThreaded()
		{
			TransformSamples(forceTransformAll: true);
		}

		private void CalculateAndTransformSamples()
		{
			CalculateSamples();
			TransformSamples();
		}

		private bool TransformHasChanged()
		{
			if (!(lastPosition != trs.position) && !(lastRotation != trs.rotation))
			{
				return lastScale != trs.lossyScale;
			}
			return true;
		}

		private void OnEnable()
		{
			if (rebuildPending)
			{
				rebuildPending = false;
				Rebuild();
			}
		}

		public void GetSamples(SampleCollection collection)
		{
			collection.samples = sampleCollection.samples;
			collection.optimizedIndices = sampleCollection.optimizedIndices;
			collection.sampleMode = _sampleMode;
		}

		public void ResampleTransform()
		{
			transformMatrix.SetTRS(trs.position, trs.rotation, trs.lossyScale);
			inverseTransformMatrix = transformMatrix.inverse;
			lastPosition = trs.position;
			lastRotation = trs.rotation;
			lastScale = trs.lossyScale;
			uniformScale = lastScale.x == lastScale.y && lastScale.y == lastScale.z;
		}

		public void Subscribe(SplineUser input)
		{
			for (int i = 0; i < subscribers.Length; i++)
			{
				if (subscribers[i] == input)
				{
					return;
				}
			}
			ArrayUtility.Add(ref subscribers, input);
		}

		public void Unsubscribe(SplineUser input)
		{
			for (int i = 0; i < subscribers.Length; i++)
			{
				if (subscribers[i] == input)
				{
					ArrayUtility.RemoveAt(ref subscribers, i);
					break;
				}
			}
		}

		public bool IsSubscribed(SplineUser user)
		{
			for (int i = 0; i < subscribers.Length; i++)
			{
				if (subscribers[i] == user)
				{
					return true;
				}
			}
			return false;
		}

		public SplineUser[] GetSubscribers()
		{
			SplineUser[] array = new SplineUser[subscribers.Length];
			subscribers.CopyTo(array, 0);
			return array;
		}

		public SplinePoint[] GetPoints(Space getSpace = Space.World)
		{
			SplinePoint[] array = new SplinePoint[spline.points.Length];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = spline.points[i];
				if (_space == Space.Local && getSpace == Space.World)
				{
					array[i].position = TransformPoint(array[i].position);
					array[i].tangent = TransformPoint(array[i].tangent);
					array[i].tangent2 = TransformPoint(array[i].tangent2);
					array[i].normal = TransformDirection(array[i].normal);
				}
			}
			return array;
		}

		public SplinePoint GetPoint(int index, Space getSpace = Space.World)
		{
			if (index < 0 || index >= spline.points.Length)
			{
				return default(SplinePoint);
			}
			if (_space == Space.Local && getSpace == Space.World)
			{
				SplinePoint result = spline.points[index];
				result.position = TransformPoint(result.position);
				result.tangent = TransformPoint(result.tangent);
				result.tangent2 = TransformPoint(result.tangent2);
				result.normal = TransformDirection(result.normal);
				return result;
			}
			return spline.points[index];
		}

		public Vector3 GetPointPosition(int index, Space getSpace = Space.World)
		{
			if (_space == Space.Local && getSpace == Space.World)
			{
				return TransformPoint(spline.points[index].position);
			}
			return spline.points[index].position;
		}

		public Vector3 GetPointNormal(int index, Space getSpace = Space.World)
		{
			if (_space == Space.Local && getSpace == Space.World)
			{
				return TransformDirection(spline.points[index].normal).normalized;
			}
			return spline.points[index].normal;
		}

		public Vector3 GetPointTangent(int index, Space getSpace = Space.World)
		{
			if (_space == Space.Local && getSpace == Space.World)
			{
				return TransformPoint(spline.points[index].tangent);
			}
			return spline.points[index].tangent;
		}

		public Vector3 GetPointTangent2(int index, Space getSpace = Space.World)
		{
			if (_space == Space.Local && getSpace == Space.World)
			{
				return TransformPoint(spline.points[index].tangent2);
			}
			return spline.points[index].tangent2;
		}

		public float GetPointSize(int index, Space getSpace = Space.World)
		{
			return spline.points[index].size;
		}

		public Color GetPointColor(int index, Space getSpace = Space.World)
		{
			return spline.points[index].color;
		}

		private void Make2D(ref SplinePoint point)
		{
			point.normal = Vector3.back;
			point.position.z = 0f;
			point.tangent.z = 0f;
			point.tangent2.z = 0f;
		}

		public void SetPoints(SplinePoint[] points, Space setSpace = Space.World)
		{
			bool flag = false;
			if (points.Length != spline.points.Length)
			{
				flag = true;
				if (points.Length < 4)
				{
					Break();
				}
				spline.points = new SplinePoint[points.Length];
				SetPointsDirty();
			}
			for (int i = 0; i < points.Length; i++)
			{
				SplinePoint point = points[i];
				if (_space == Space.Local && setSpace == Space.World)
				{
					point.position = InverseTransformPoint(points[i].position);
					point.tangent = InverseTransformPoint(points[i].tangent);
					point.tangent2 = InverseTransformPoint(points[i].tangent2);
					point.normal = InverseTransformDirection(points[i].normal);
				}
				if (_is2D)
				{
					Make2D(ref point);
				}
				if (SplinePoint.AreDifferent(ref point, ref spline.points[i]))
				{
					SetDirty(i);
					flag = true;
				}
				spline.points[i] = point;
			}
			if (isClosed)
			{
				spline.points[spline.points.Length - 1] = spline.points[0];
			}
			if (flag)
			{
				Rebuild();
				UpdateConnectedNodes(points);
			}
		}

		public void SetPointPosition(int index, Vector3 pos, Space setSpace = Space.World)
		{
			if (index >= 0)
			{
				if (index >= spline.points.Length)
				{
					AppendPoints(index + 1 - spline.points.Length);
				}
				Vector3 vector = pos;
				if (_space == Space.Local && setSpace == Space.World)
				{
					vector = InverseTransformPoint(pos);
				}
				if (vector != spline.points[index].position)
				{
					SetDirty(index);
					spline.points[index].position = vector;
					Rebuild();
					SetNodeForPoint(index, GetPoint(index));
				}
			}
		}

		public void SetPointTangents(int index, Vector3 tan1, Vector3 tan2, Space setSpace = Space.World)
		{
			if (index >= 0)
			{
				if (index >= spline.points.Length)
				{
					AppendPoints(index + 1 - spline.points.Length);
				}
				Vector3 vector = tan1;
				Vector3 vector2 = tan2;
				if (_space == Space.Local && setSpace == Space.World)
				{
					vector = InverseTransformPoint(tan1);
					vector2 = InverseTransformPoint(tan2);
				}
				bool flag = false;
				if (vector2 != spline.points[index].tangent2)
				{
					flag = true;
					spline.points[index].SetTangent2Position(vector2);
				}
				if (vector != spline.points[index].tangent)
				{
					flag = true;
					spline.points[index].SetTangentPosition(vector);
				}
				if (_is2D)
				{
					Make2D(ref spline.points[index]);
				}
				if (flag)
				{
					SetDirty(index);
					Rebuild();
					SetNodeForPoint(index, GetPoint(index));
				}
			}
		}

		public void SetPointNormal(int index, Vector3 nrm, Space setSpace = Space.World)
		{
			if (index < 0)
			{
				return;
			}
			if (index >= spline.points.Length)
			{
				AppendPoints(index + 1 - spline.points.Length);
			}
			Vector3 vector = nrm;
			if (_space == Space.Local && setSpace == Space.World)
			{
				vector = InverseTransformDirection(nrm);
			}
			if (vector != spline.points[index].normal)
			{
				SetDirty(index);
				spline.points[index].normal = vector;
				if (_is2D)
				{
					Make2D(ref spline.points[index]);
				}
				Rebuild();
				SetNodeForPoint(index, GetPoint(index));
			}
		}

		public void SetPointSize(int index, float size)
		{
			if (index >= 0)
			{
				if (index >= spline.points.Length)
				{
					AppendPoints(index + 1 - spline.points.Length);
				}
				if (size != spline.points[index].size)
				{
					SetDirty(index);
					spline.points[index].size = size;
					Rebuild();
					SetNodeForPoint(index, GetPoint(index));
				}
			}
		}

		public void SetPointColor(int index, Color color)
		{
			if (index >= 0)
			{
				if (index >= spline.points.Length)
				{
					AppendPoints(index + 1 - spline.points.Length);
				}
				if (color != spline.points[index].color)
				{
					SetDirty(index);
					spline.points[index].color = color;
					Rebuild();
					SetNodeForPoint(index, GetPoint(index));
				}
			}
		}

		public void SetPoint(int index, SplinePoint point, Space setSpace = Space.World)
		{
			if (index >= 0)
			{
				if (index >= spline.points.Length)
				{
					AppendPoints(index + 1 - spline.points.Length);
				}
				bool flag = false;
				SplinePoint point2 = point;
				if (_space == Space.Local && setSpace == Space.World)
				{
					point2.position = InverseTransformPoint(point.position);
					point2.tangent = InverseTransformPoint(point.tangent);
					point2.tangent2 = InverseTransformPoint(point.tangent2);
					point2.normal = InverseTransformDirection(point.normal);
				}
				if (_is2D)
				{
					Make2D(ref point2);
				}
				if (SplinePoint.AreDifferent(ref point2, ref spline.points[index]))
				{
					flag = true;
				}
				if (flag)
				{
					SetDirty(index);
					spline.points[index] = point2;
					Rebuild();
					SetNodeForPoint(index, point);
				}
			}
		}

		private void AppendPoints(int count)
		{
			SplinePoint[] array = new SplinePoint[spline.points.Length + count];
			spline.points.CopyTo(array, 0);
			spline.points = array;
			Rebuild(forceUpdateAll: true);
		}

		public double GetPointPercent(int pointIndex)
		{
			double num = DMath.Clamp01((double)pointIndex / (double)(pointCount - 1));
			if (_sampleMode != SampleMode.Uniform)
			{
				return num;
			}
			if (originalSamplePercents.Length <= 1)
			{
				return 0.0;
			}
			for (int num2 = originalSamplePercents.Length - 2; num2 >= 0; num2--)
			{
				if (originalSamplePercents[num2] < num)
				{
					double t = DMath.InverseLerp(originalSamplePercents[num2], originalSamplePercents[num2 + 1], num);
					return DMath.Lerp(sampleCollection.samples[num2].percent, sampleCollection.samples[num2 + 1].percent, t);
				}
			}
			return 0.0;
		}

		public int PercentToPointIndex(double percent, Spline.Direction direction = Spline.Direction.Forward)
		{
			if (_sampleMode == SampleMode.Uniform)
			{
				GetSamplingValues(percent, out var index, out var lerp);
				if (lerp > 0.0)
				{
					lerp = DMath.Lerp(originalSamplePercents[index], originalSamplePercents[index + 1], lerp);
					if (direction == Spline.Direction.Forward)
					{
						return DMath.FloorInt(lerp * (double)(pointCount - 1));
					}
					return DMath.CeilInt(lerp * (double)(pointCount - 1));
				}
				if (direction == Spline.Direction.Forward)
				{
					return DMath.FloorInt(originalSamplePercents[index] * (double)(pointCount - 1));
				}
				return DMath.CeilInt(originalSamplePercents[index] * (double)(pointCount - 1));
			}
			if (direction == Spline.Direction.Forward)
			{
				return DMath.FloorInt(percent * (double)(pointCount - 1));
			}
			return DMath.CeilInt(percent * (double)(pointCount - 1));
		}

		public Vector3 EvaluatePosition(double percent)
		{
			return EvaluatePosition(percent, EvaluateMode.Cached);
		}

		public Vector3 EvaluatePosition(double percent, EvaluateMode mode = EvaluateMode.Cached)
		{
			if (mode == EvaluateMode.Calculate)
			{
				return TransformPoint(spline.EvaluatePosition(percent));
			}
			return sampleCollection.EvaluatePosition(percent);
		}

		public Vector3 EvaluatePosition(int pointIndex, EvaluateMode mode = EvaluateMode.Cached)
		{
			return EvaluatePosition(GetPointPercent(pointIndex), mode);
		}

		public SplineSample Evaluate(double percent)
		{
			return Evaluate(percent, EvaluateMode.Cached);
		}

		public SplineSample Evaluate(double percent, EvaluateMode mode = EvaluateMode.Cached)
		{
			SplineSample result = new SplineSample();
			Evaluate(percent, result, mode);
			return result;
		}

		public SplineSample Evaluate(int pointIndex)
		{
			SplineSample result = new SplineSample();
			Evaluate(pointIndex, result);
			return result;
		}

		public void Evaluate(int pointIndex, SplineSample result)
		{
			Evaluate(GetPointPercent(pointIndex), result);
		}

		public void Evaluate(double percent, SplineSample result)
		{
			Evaluate(percent, result, EvaluateMode.Cached);
		}

		public void Evaluate(double percent, SplineSample result, EvaluateMode mode = EvaluateMode.Cached)
		{
			if (mode == EvaluateMode.Calculate)
			{
				spline.Evaluate(result, percent);
				TransformResult(result);
			}
			else
			{
				sampleCollection.Evaluate(percent, result);
			}
		}

		public void Evaluate(ref SplineSample[] results, double from = 0.0, double to = 1.0)
		{
			sampleCollection.Evaluate(ref results, from, to);
		}

		public void EvaluatePositions(ref Vector3[] positions, double from = 0.0, double to = 1.0)
		{
			sampleCollection.EvaluatePositions(ref positions, from, to);
		}

		public double Travel(double start, float distance, out float moved, Spline.Direction direction = Spline.Direction.Forward)
		{
			return sampleCollection.Travel(start, distance, direction, out moved);
		}

		public double Travel(double start, float distance, Spline.Direction direction = Spline.Direction.Forward)
		{
			float moved;
			return Travel(start, distance, out moved, direction);
		}

		public void Project(SplineSample result, Vector3 position, double from = 0.0, double to = 1.0, EvaluateMode mode = EvaluateMode.Cached, int subdivisions = 4)
		{
			if (mode == EvaluateMode.Calculate)
			{
				position = InverseTransformPoint(position);
				double percent = spline.Project(position, subdivisions, from, to);
				spline.Evaluate(result, percent);
				TransformResult(result);
			}
			else
			{
				sampleCollection.Project(position, pointCount, result, from, to);
			}
		}

		public SplineSample Project(Vector3 point, double from = 0.0, double to = 1.0)
		{
			SplineSample result = new SplineSample();
			Project(result, point, from, to);
			return result;
		}

		public float CalculateLength(double from = 0.0, double to = 1.0)
		{
			if (!hasSamples)
			{
				return 0f;
			}
			return sampleCollection.CalculateLength(from, to);
		}

		private void TransformResult(SplineSample result)
		{
			result.position = TransformPoint(result.position);
			result.forward = TransformDirection(result.forward);
			result.up = TransformDirection(result.up);
			if (!uniformScale)
			{
				result.forward.Normalize();
				result.up.Normalize();
			}
		}

		public void Rebuild(bool forceUpdateAll = false)
		{
			if (forceUpdateAll)
			{
				SetPointsDirty();
			}
			queueResample = true;
			if (updateMode == UpdateMode.None)
			{
				queueResample = false;
			}
		}

		public void RebuildImmediate(bool calculateSamples = true, bool forceUpdateAll = false)
		{
			if (calculateSamples)
			{
				queueResample = true;
				if (forceUpdateAll)
				{
					SetPointsDirty();
				}
			}
			else
			{
				queueResample = false;
			}
			RunUpdate();
		}

		private void RebuildUsers()
		{
			for (int num = subscribers.Length - 1; num >= 0; num--)
			{
				if (subscribers[num] != null)
				{
					if (subscribers[num].spline != this)
					{
						ArrayUtility.RemoveAt(ref subscribers, num);
					}
					else
					{
						subscribers[num].Rebuild();
					}
				}
				else
				{
					ArrayUtility.RemoveAt(ref subscribers, num);
				}
			}
			if (this.onRebuild != null)
			{
				this.onRebuild();
			}
			queueRebuild = false;
		}

		private void UnsetPointsDirty()
		{
			if (pointsDirty.Length != spline.points.Length)
			{
				pointsDirty = new bool[spline.points.Length];
			}
			for (int i = 0; i < pointsDirty.Length; i++)
			{
				pointsDirty[i] = false;
			}
		}

		private void SetPointsDirty()
		{
			if (pointsDirty.Length != spline.points.Length)
			{
				pointsDirty = new bool[spline.points.Length];
			}
			for (int i = 0; i < pointsDirty.Length; i++)
			{
				pointsDirty[i] = true;
			}
		}

		private void SetDirty(int index)
		{
			if (sampleMode == SampleMode.Uniform)
			{
				SetPointsDirty();
				return;
			}
			pointsDirty[index] = true;
			if (index == 0 && isClosed)
			{
				pointsDirty[pointsDirty.Length - 1] = true;
			}
		}

		private void CalculateSamples()
		{
			queueResample = false;
			if (pointCount == 0)
			{
				if (_rawSamples.Length != 0)
				{
					_rawSamples = new SplineSample[0];
					sampleCollection.samples = new SplineSample[0];
				}
				return;
			}
			if (pointCount == 1)
			{
				if (_rawSamples.Length != 1)
				{
					_rawSamples = new SplineSample[1];
					_rawSamples[0] = new SplineSample();
					sampleCollection.samples = new SplineSample[1];
					sampleCollection.samples[0] = new SplineSample();
				}
				Evaluate(0.0, _rawSamples[0]);
				return;
			}
			if (_sampleMode == SampleMode.Uniform)
			{
				spline.EvaluateUniform(ref _rawSamples, ref originalSamplePercents);
			}
			else
			{
				if (originalSamplePercents.Length != 0)
				{
					originalSamplePercents = new double[0];
				}
				if (_rawSamples.Length != spline.iterations)
				{
					_rawSamples = new SplineSample[spline.iterations];
					for (int i = 0; i < _rawSamples.Length; i++)
					{
						_rawSamples[i] = new SplineSample();
					}
				}
				bool flag = true;
				if (type == Spline.Type.Bezier || type == Spline.Type.Linear)
				{
					flag = false;
				}
				for (int j = 0; j < _rawSamples.Length; j++)
				{
					double num = (double)j / (double)(_rawSamples.Length - 1);
					if (flag ? IsDirtyHermite(num) : IsDirtyBezier(num))
					{
						spline.Evaluate(_rawSamples[j], num);
					}
				}
			}
			if (isClosed)
			{
				_rawSamples[_rawSamples.Length - 1].CopyFrom(_rawSamples[0]);
				_rawSamples[_rawSamples.Length - 1].percent = 1.0;
			}
		}

		private void TransformSamples(bool forceTransformAll = false)
		{
			if (_transformedSamples.Length != _rawSamples.Length)
			{
				_transformedSamples = new SplineSample[_rawSamples.Length];
				for (int i = 0; i < _transformedSamples.Length; i++)
				{
					_transformedSamples[i] = new SplineSample(_rawSamples[i]);
				}
			}
			bool flag = true;
			if (type == Spline.Type.Bezier || type == Spline.Type.Linear)
			{
				flag = false;
			}
			if (space == Space.Local)
			{
				for (int j = 0; j < _rawSamples.Length; j++)
				{
					if (!((!forceTransformAll && flag) ? (!IsDirtyHermite(_rawSamples[j].percent)) : (!IsDirtyBezier(_rawSamples[j].percent))))
					{
						_transformedSamples[j].CopyFrom(_rawSamples[j]);
						TransformResult(_transformedSamples[j]);
					}
				}
			}
			else
			{
				_transformedSamples = _rawSamples;
			}
			if (_sampleMode == SampleMode.Optimized)
			{
				OptimizeSamples();
			}
			else
			{
				sampleCollection.samples = _transformedSamples;
				if (sampleFlter.Length != 0)
				{
					sampleFlter = new bool[0];
				}
				_sampleCount = sampleCollection.Count;
			}
			if (_sampleMode == SampleMode.Optimized)
			{
				if (sampleCollection.optimizedIndices.Length != _rawSamples.Length)
				{
					sampleCollection.optimizedIndices = new int[_rawSamples.Length];
				}
				sampleCollection.optimizedIndices[0] = 0;
				sampleCollection.optimizedIndices[sampleCollection.optimizedIndices.Length - 1] = sampleCollection.Count - 1;
				for (int k = 1; k < _rawSamples.Length - 1; k++)
				{
					sampleCollection.optimizedIndices[k] = 0;
					double num = (double)k / (double)(_rawSamples.Length - 1);
					for (int l = 0; l < sampleCollection.Count && !(sampleCollection.samples[l].percent > num); l++)
					{
						sampleCollection.optimizedIndices[k] = l;
					}
				}
				if (sampleCollection.optimizedIndices.Length > 1)
				{
					sampleCollection.optimizedIndices[sampleCollection.optimizedIndices.Length - 1] = sampleCollection.Count - 1;
				}
			}
			else if (sampleCollection.Count > 0)
			{
				sampleCollection.optimizedIndices = new int[0];
			}
			sampleCollection.sampleMode = _sampleMode;
			queueRebuild = true;
			hasSamples = _sampleCount > 0;
			UnsetPointsDirty();
		}

		private void OptimizeSamples()
		{
			if (_transformedSamples.Length <= 1)
			{
				return;
			}
			if (sampleFlter.Length != _rawSamples.Length)
			{
				sampleFlter = new bool[_rawSamples.Length];
			}
			_sampleCount = 2;
			Vector3 forward = _transformedSamples[0].forward;
			sampleFlter[0] = true;
			sampleFlter[sampleFlter.Length - 1] = true;
			for (int i = 1; i < _transformedSamples.Length - 1; i++)
			{
				if (Vector3.Angle(forward, _transformedSamples[i].forward) >= _optimizeAngleThreshold)
				{
					sampleFlter[i] = true;
					_sampleCount++;
					forward = _transformedSamples[i].forward;
				}
				else
				{
					sampleFlter[i] = false;
				}
			}
			if (sampleCollection.Count != _sampleCount || sampleCollection.samples == _transformedSamples)
			{
				sampleCollection.samples = new SplineSample[_sampleCount];
				for (int j = 0; j < sampleCollection.Count; j++)
				{
					sampleCollection.samples[j] = new SplineSample();
				}
			}
			int num = 0;
			for (int k = 0; k < _transformedSamples.Length; k++)
			{
				if (sampleFlter[k])
				{
					sampleCollection.samples[num].CopyFrom(_transformedSamples[k]);
					num++;
				}
			}
		}

		private bool IsDirtyBezier(double samplePercent)
		{
			float num = (float)samplePercent * (float)(pointCount - 1);
			int num2 = Mathf.FloorToInt(num);
			if (pointsDirty[num2])
			{
				return true;
			}
			int num3 = num2 + 1;
			if (num3 > pointCount - 1)
			{
				num3 = ((!isClosed) ? (pointCount - 1) : 0);
			}
			if (pointsDirty[num3])
			{
				return true;
			}
			int num4 = num2 - 1;
			if (num4 < 0)
			{
				num4 = (isClosed ? (pointCount - 1) : 0);
			}
			if (pointsDirty[num4] && Mathf.Approximately(num, num2))
			{
				return true;
			}
			return false;
		}

		private bool IsDirtyHermite(double samplePercent)
		{
			float num = (float)samplePercent * (float)(pointCount - 1);
			int num2 = Mathf.FloorToInt(num);
			if (pointsDirty[num2])
			{
				return true;
			}
			int num3 = num2 + 1;
			if (num3 > pointCount - 1)
			{
				num3 = ((!isClosed) ? (pointCount - 1) : 0);
			}
			int num4 = num3 + 1;
			if (num4 > pointCount - 1)
			{
				num4 = (isClosed ? 1 : (pointCount - 1));
			}
			if (pointsDirty[num3] || pointsDirty[num4])
			{
				return true;
			}
			int num5 = num2 - 1;
			if (num5 < 0)
			{
				num5 = (isClosed ? (pointCount - 2) : 0);
			}
			int num6 = num5 - 1;
			if (num6 < 0)
			{
				num6 = (isClosed ? (pointCount - 2) : 0);
			}
			if (pointsDirty[num5])
			{
				return true;
			}
			if (pointsDirty[num6] && Mathf.Approximately(num, num2))
			{
				return true;
			}
			return false;
		}

		public void Break()
		{
			Break(0);
		}

		public void Break(int at)
		{
			if (spline.isClosed)
			{
				spline.Break(at);
				if (at != 0)
				{
					SetPointsDirty();
				}
				else
				{
					SetDirty(0);
					SetDirty(pointCount - 1);
				}
				Rebuild();
			}
		}

		public void Close()
		{
			if (!spline.isClosed)
			{
				spline.Close();
				SetDirty(0);
				SetDirty(pointCount - 1);
				Rebuild();
			}
		}

		public void CatToBezierTangents()
		{
			spline.CatToBezierTangents();
			SetPoints(spline.points, Space.Local);
		}

		public bool Raycast(out RaycastHit hit, out double hitPercent, LayerMask layerMask, double resolution = 1.0, double from = 0.0, double to = 1.0, QueryTriggerInteraction hitTriggers = QueryTriggerInteraction.UseGlobal)
		{
			resolution = DMath.Clamp01(resolution);
			Spline.FormatFromTo(ref from, ref to, preventInvert: false);
			double num = from;
			Vector3 vector = EvaluatePosition(num);
			hitPercent = 0.0;
			do
			{
				double a = num;
				num = DMath.Move(num, to, moveStep / resolution);
				Vector3 vector2 = EvaluatePosition(num);
				if (Physics.Linecast(vector, vector2, out hit, layerMask, hitTriggers))
				{
					double t = (hit.point - vector).sqrMagnitude / (vector2 - vector).sqrMagnitude;
					hitPercent = DMath.Lerp(a, num, t);
					return true;
				}
				vector = vector2;
			}
			while (num != to);
			return false;
		}

		public bool RaycastAll(out RaycastHit[] hits, out double[] hitPercents, LayerMask layerMask, double resolution = 1.0, double from = 0.0, double to = 1.0, QueryTriggerInteraction hitTriggers = QueryTriggerInteraction.UseGlobal)
		{
			resolution = DMath.Clamp01(resolution);
			Spline.FormatFromTo(ref from, ref to, preventInvert: false);
			double num = from;
			Vector3 vector = EvaluatePosition(num);
			List<RaycastHit> list = new List<RaycastHit>();
			List<double> list2 = new List<double>();
			bool result = false;
			do
			{
				double a = num;
				num = DMath.Move(num, to, moveStep / resolution);
				Vector3 vector2 = EvaluatePosition(num);
				RaycastHit[] array = Physics.RaycastAll(vector, vector2 - vector, Vector3.Distance(vector, vector2), layerMask, hitTriggers);
				for (int i = 0; i < array.Length; i++)
				{
					result = true;
					double t = (array[i].point - vector).sqrMagnitude / (vector2 - vector).sqrMagnitude;
					list2.Add(DMath.Lerp(a, num, t));
					list.Add(array[i]);
				}
				vector = vector2;
			}
			while (num != to);
			hits = list.ToArray();
			hitPercents = list2.ToArray();
			return result;
		}

		public void CheckTriggers(double start, double end, SplineUser user = null)
		{
			for (int i = 0; i < triggerGroups.Length; i++)
			{
				triggerGroups[i].Check(start, end);
			}
		}

		public void CheckTriggers(int group, double start, double end)
		{
			if (group < 0 || group >= triggerGroups.Length)
			{
				UnityEngine.Debug.LogError("Trigger group " + group + " does not exist");
			}
			else
			{
				triggerGroups[group].Check(start, end);
			}
		}

		public void ResetTriggers()
		{
			for (int i = 0; i < triggerGroups.Length; i++)
			{
				triggerGroups[i].Reset();
			}
		}

		public void ResetTriggers(int group)
		{
			if (group < 0 || group >= triggerGroups.Length)
			{
				UnityEngine.Debug.LogError("Trigger group " + group + " does not exist");
				return;
			}
			for (int i = 0; i < triggerGroups[group].triggers.Length; i++)
			{
				triggerGroups[group].triggers[i].Reset();
			}
		}

		public List<Node.Connection> GetJunctions(int pointIndex)
		{
			for (int i = 0; i < nodes.Length; i++)
			{
				if (nodes[i].pointIndex == pointIndex)
				{
					return nodes[i].GetConnections(this);
				}
			}
			return new List<Node.Connection>();
		}

		public Dictionary<int, List<Node.Connection>> GetJunctions(double start = 0.0, double end = 1.0)
		{
			sampleCollection.GetSamplingValues(start, out var _, out var _);
			Dictionary<int, List<Node.Connection>> dictionary = new Dictionary<int, List<Node.Connection>>();
			float num = (float)(pointCount - 1) * (float)start;
			float num2 = (float)(pointCount - 1) * (float)end;
			for (int i = 0; i < nodes.Length; i++)
			{
				bool flag = false;
				if (end > start && (float)nodes[i].pointIndex > num && (float)nodes[i].pointIndex < num2)
				{
					flag = true;
				}
				else if ((float)nodes[i].pointIndex < num && (float)nodes[i].pointIndex > num2)
				{
					flag = true;
				}
				if (!flag && Mathf.Abs(num - (float)nodes[i].pointIndex) <= 0.0001f)
				{
					flag = true;
				}
				if (!flag && Mathf.Abs(num2 - (float)nodes[i].pointIndex) <= 0.0001f)
				{
					flag = true;
				}
				if (flag)
				{
					dictionary.Add(nodes[i].pointIndex, nodes[i].GetConnections(this));
				}
			}
			return dictionary;
		}

		public void ConnectNode(Node node, int pointIndex)
		{
			if (node == null)
			{
				UnityEngine.Debug.LogError("Missing Node");
				return;
			}
			if (pointIndex < 0 || pointIndex >= spline.points.Length)
			{
				UnityEngine.Debug.Log("Invalid point index " + pointIndex);
				return;
			}
			for (int i = 0; i < nodes.Length; i++)
			{
				if (nodes[i].node == null || (nodes[i].pointIndex != pointIndex && !(nodes[i].node == node)))
				{
					continue;
				}
				Node.Connection[] connections = nodes[i].node.GetConnections();
				for (int j = 0; j < connections.Length; j++)
				{
					if (connections[j].spline == this)
					{
						UnityEngine.Debug.LogError("Node " + node.name + " is already connected to spline " + base.name + " at point " + nodes[i].pointIndex);
						return;
					}
				}
				AddNodeLink(node, pointIndex);
				return;
			}
			node.AddConnection(this, pointIndex);
			AddNodeLink(node, pointIndex);
		}

		public void DisconnectNode(int pointIndex)
		{
			for (int i = 0; i < nodes.Length; i++)
			{
				if (nodes[i].pointIndex == pointIndex)
				{
					nodes[i].node.RemoveConnection(this, pointIndex);
					ArrayUtility.RemoveAt(ref nodes, i);
					break;
				}
			}
		}

		private void AddNodeLink(Node node, int pointIndex)
		{
			NodeLink nodeLink = new NodeLink();
			nodeLink.node = node;
			nodeLink.pointIndex = pointIndex;
			ArrayUtility.Add(ref nodes, nodeLink);
			UpdateConnectedNodes();
		}

		public Dictionary<int, Node> GetNodes(double start = 0.0, double end = 1.0)
		{
			sampleCollection.GetSamplingValues(start, out var _, out var _);
			Dictionary<int, Node> dictionary = new Dictionary<int, Node>();
			float num = (float)(pointCount - 1) * (float)start;
			float num2 = (float)(pointCount - 1) * (float)end;
			for (int i = 0; i < nodes.Length; i++)
			{
				bool flag = false;
				if (end > start && (float)nodes[i].pointIndex > num && (float)nodes[i].pointIndex < num2)
				{
					flag = true;
				}
				else if ((float)nodes[i].pointIndex < num && (float)nodes[i].pointIndex > num2)
				{
					flag = true;
				}
				if (!flag && Mathf.Abs(num - (float)nodes[i].pointIndex) <= 0.0001f)
				{
					flag = true;
				}
				if (!flag && Mathf.Abs(num2 - (float)nodes[i].pointIndex) <= 0.0001f)
				{
					flag = true;
				}
				if (flag)
				{
					dictionary.Add(nodes[i].pointIndex, nodes[i].node);
				}
			}
			return dictionary;
		}

		public Node GetNode(int pointIndex)
		{
			if (pointIndex < 0 || pointIndex >= pointCount)
			{
				return null;
			}
			for (int i = 0; i < nodes.Length; i++)
			{
				if (nodes[i].pointIndex == pointIndex)
				{
					return nodes[i].node;
				}
			}
			return null;
		}

		public void TransferNode(int pointIndex, int newPointIndex)
		{
			if (newPointIndex < 0 || newPointIndex >= pointCount)
			{
				UnityEngine.Debug.LogError("Invalid new point index " + newPointIndex);
				return;
			}
			if (GetNode(newPointIndex) != null)
			{
				UnityEngine.Debug.LogError("Cannot move node to point " + newPointIndex + ". Point already connected to a node");
				return;
			}
			Node node = GetNode(pointIndex);
			if (node == null)
			{
				UnityEngine.Debug.LogError("No node connected to point " + pointIndex);
				return;
			}
			DisconnectNode(pointIndex);
			ConnectNode(node, newPointIndex);
		}

		public void ShiftNodes(int startIndex, int endIndex, int shift)
		{
			if (startIndex < endIndex)
			{
				for (int num = endIndex; num >= startIndex; num--)
				{
					if (GetNode(num) != null)
					{
						TransferNode(num, num + shift);
					}
				}
				return;
			}
			for (int num2 = startIndex; num2 >= endIndex; num2--)
			{
				if (GetNode(num2) != null)
				{
					TransferNode(num2, num2 + shift);
				}
			}
		}

		public void GetConnectedComputers(List<SplineComputer> computers, List<int> connectionIndices, List<int> connectedIndices, double percent, Spline.Direction direction, bool includeEqual)
		{
			if (computers == null)
			{
				computers = new List<SplineComputer>();
			}
			if (connectionIndices == null)
			{
				connectionIndices = new List<int>();
			}
			if (connectedIndices == null)
			{
				connectionIndices = new List<int>();
			}
			computers.Clear();
			connectionIndices.Clear();
			connectedIndices.Clear();
			int num = Mathf.FloorToInt((float)(pointCount - 1) * (float)percent);
			for (int i = 0; i < nodes.Length; i++)
			{
				bool flag = false;
				if (includeEqual)
				{
					flag = ((direction != Spline.Direction.Forward) ? (nodes[i].pointIndex <= num) : (nodes[i].pointIndex >= num));
				}
				if (!flag)
				{
					continue;
				}
				Node.Connection[] connections = nodes[i].node.GetConnections();
				for (int j = 0; j < connections.Length; j++)
				{
					if (connections[j].spline != this)
					{
						computers.Add(connections[j].spline);
						connectionIndices.Add(nodes[i].pointIndex);
						connectedIndices.Add(connections[j].pointIndex);
					}
				}
			}
		}

		public List<SplineComputer> GetConnectedComputers()
		{
			List<SplineComputer> computers = new List<SplineComputer>();
			computers.Add(this);
			if (nodes.Length == 0)
			{
				return computers;
			}
			GetConnectedComputers(ref computers);
			return computers;
		}

		public void GetSamplingValues(double percent, out int index, out double lerp)
		{
			sampleCollection.GetSamplingValues(percent, out index, out lerp);
		}

		private void GetConnectedComputers(ref List<SplineComputer> computers)
		{
			SplineComputer splineComputer = computers[computers.Count - 1];
			if (splineComputer == null)
			{
				return;
			}
			for (int i = 0; i < splineComputer.nodes.Length; i++)
			{
				if (splineComputer.nodes[i].node == null)
				{
					continue;
				}
				Node.Connection[] connections = splineComputer.nodes[i].node.GetConnections();
				for (int j = 0; j < connections.Length; j++)
				{
					bool flag = false;
					if (connections[j].spline == this)
					{
						continue;
					}
					for (int k = 0; k < computers.Count; k++)
					{
						if (computers[k] == connections[j].spline)
						{
							flag = true;
							break;
						}
					}
					if (!flag)
					{
						computers.Add(connections[j].spline);
						GetConnectedComputers(ref computers);
					}
				}
			}
		}

		private void RemoveNodeLinkAt(int index)
		{
			NodeLink[] array = new NodeLink[nodes.Length - 1];
			for (int i = 0; i < nodes.Length; i++)
			{
				if (i != index)
				{
					if (i < index)
					{
						array[i] = nodes[i];
					}
					else
					{
						array[i - 1] = nodes[i];
					}
				}
			}
			nodes = array;
		}

		private void SetNodeForPoint(int index, SplinePoint worldPoint)
		{
			for (int i = 0; i < nodes.Length; i++)
			{
				if (nodes[i].pointIndex == index)
				{
					nodes[i].node.UpdatePoint(this, nodes[i].pointIndex, worldPoint);
					break;
				}
			}
		}

		private void UpdateConnectedNodes(SplinePoint[] worldPoints)
		{
			for (int i = 0; i < nodes.Length; i++)
			{
				if (nodes[i].node == null)
				{
					RemoveNodeLinkAt(i);
					i--;
					Rebuild();
					continue;
				}
				bool flag = false;
				Node.Connection[] connections = nodes[i].node.GetConnections();
				for (int j = 0; j < connections.Length; j++)
				{
					if (connections[j].spline == this)
					{
						flag = true;
						break;
					}
				}
				if (!flag)
				{
					RemoveNodeLinkAt(i);
					i--;
					Rebuild();
				}
				else
				{
					nodes[i].node.UpdatePoint(this, nodes[i].pointIndex, worldPoints[nodes[i].pointIndex]);
					nodes[i].node.UpdateConnectedComputers(this);
				}
			}
		}

		private void UpdateConnectedNodes()
		{
			for (int i = 0; i < nodes.Length; i++)
			{
				if (nodes[i].node == null)
				{
					RemoveNodeLinkAt(i);
					Rebuild();
					i--;
					continue;
				}
				bool flag = false;
				Node.Connection[] connections = nodes[i].node.GetConnections();
				for (int j = 0; j < connections.Length; j++)
				{
					if (connections[j].spline == this && connections[j].pointIndex == nodes[i].pointIndex)
					{
						flag = true;
						break;
					}
				}
				if (flag)
				{
					nodes[i].node.UpdatePoint(this, nodes[i].pointIndex, GetPoint(nodes[i].pointIndex));
					nodes[i].node.UpdateConnectedComputers(this);
				}
				else
				{
					RemoveNodeLinkAt(i);
					Rebuild();
					i--;
				}
			}
		}

		public Vector3 TransformPoint(Vector3 point)
		{
			return transformMatrix.MultiplyPoint3x4(point);
		}

		public Vector3 InverseTransformPoint(Vector3 point)
		{
			return inverseTransformMatrix.MultiplyPoint3x4(point);
		}

		public Vector3 TransformDirection(Vector3 direction)
		{
			return transformMatrix.MultiplyVector(direction);
		}

		public Vector3 InverseTransformDirection(Vector3 direction)
		{
			return inverseTransformMatrix.MultiplyVector(direction);
		}
	}
	public delegate void SplineReachHandler();
	[AddComponentMenu("Dreamteck/Splines/Users/Spline Follower")]
	public class SplineFollower : SplineTracer
	{
		public enum FollowMode
		{
			Uniform,
			Time
		}

		public enum Wrap
		{
			Default,
			Loop,
			PingPong
		}

		[HideInInspector]
		public Wrap wrapMode;

		[HideInInspector]
		public FollowMode followMode;

		[HideInInspector]
		public bool autoStartPosition;

		[HideInInspector]
		public bool follow = true;

		[SerializeField]
		[HideInInspector]
		private float _followSpeed = 1f;

		[SerializeField]
		[HideInInspector]
		private float _followDuration = 1f;

		[SerializeField]
		[HideInInspector]
		[Range(0f, 1f)]
		private double _startPosition;

		private double lastClippedPercent = -1.0;

		private bool followStarted;

		public float followSpeed
		{
			get
			{
				return _followSpeed;
			}
			set
			{
				if (_followSpeed != value)
				{
					if (value < 0f)
					{
						value = 0f;
					}
					_followSpeed = value;
				}
			}
		}

		public double startPosition
		{
			get
			{
				return _startPosition;
			}
			set
			{
				if (value != _startPosition)
				{
					_startPosition = DMath.Clamp01(value);
					if (!followStarted)
					{
						SetPercent(_startPosition);
					}
				}
			}
		}

		public float followDuration
		{
			get
			{
				return _followDuration;
			}
			set
			{
				if (_followDuration != value)
				{
					if (value < 0f)
					{
						value = 0f;
					}
					_followDuration = value;
				}
			}
		}

		public event SplineReachHandler onEndReached;

		public event SplineReachHandler onBeginningReached;

		protected override void Start()
		{
			base.Start();
			if (follow && autoStartPosition)
			{
				SetPercent(base.spline.Project(GetTransform().position).percent);
			}
		}

		protected override void LateRun()
		{
			base.LateRun();
			if (follow)
			{
				Follow();
			}
		}

		protected override void PostBuild()
		{
			base.PostBuild();
			if (base.sampleCount != 0)
			{
				Evaluate(_result.percent, _result);
				if (follow && !autoStartPosition)
				{
					ApplyMotion();
				}
			}
		}

		private void Follow()
		{
			if (!followStarted)
			{
				if (autoStartPosition)
				{
					Project(GetTransform().position, evalResult);
					SetPercent(evalResult.percent);
				}
				else
				{
					SetPercent(_startPosition);
				}
			}
			followStarted = true;
			switch (followMode)
			{
			case FollowMode.Uniform:
				Move(Time.deltaTime * _followSpeed);
				break;
			case FollowMode.Time:
				if ((double)_followDuration == 0.0)
				{
					Move(0.0);
				}
				else
				{
					Move((double)Time.deltaTime / (double)_followDuration);
				}
				break;
			}
		}

		public void Restart(double startPosition = 0.0)
		{
			followStarted = false;
			SetPercent(startPosition);
		}

		public override void SetPercent(double percent, bool checkTriggers = false, bool handleJuncitons = false)
		{
			base.SetPercent(percent, checkTriggers, handleJuncitons);
			lastClippedPercent = percent;
		}

		public override void SetDistance(float distance, bool checkTriggers = false, bool handleJuncitons = false)
		{
			base.SetDistance(distance, checkTriggers, handleJuncitons);
			lastClippedPercent = ClipPercent(_result.percent);
			if (base.samplesAreLooped && base.clipFrom == base.clipTo && distance > 0f && lastClippedPercent == 0.0)
			{
				lastClippedPercent = 1.0;
			}
		}

		public void Move(double percent)
		{
			if (percent == 0.0)
			{
				return;
			}
			if (base.sampleCount <= 1)
			{
				if (base.sampleCount == 1)
				{
					_result.CopyFrom(GetSampleRaw(0));
					ApplyMotion();
				}
				return;
			}
			Evaluate(_result.percent, _result);
			double num = _result.percent;
			if (wrapMode == Wrap.Default && lastClippedPercent >= 1.0 && num == 0.0)
			{
				num = 1.0;
			}
			double num2 = num + ((_direction == Spline.Direction.Forward) ? percent : (0.0 - percent));
			bool flag = false;
			bool flag2 = false;
			lastClippedPercent = num2;
			if (_direction == Spline.Direction.Forward && num2 >= 1.0)
			{
				if (this.onEndReached != null && num < 1.0)
				{
					flag = true;
				}
				switch (wrapMode)
				{
				case Wrap.Default:
					num2 = 1.0;
					break;
				case Wrap.Loop:
					CheckTriggers(num, 1.0);
					CheckNodes(num, 1.0);
					while (num2 > 1.0)
					{
						num2 -= 1.0;
					}
					num = 0.0;
					break;
				case Wrap.PingPong:
					num2 = DMath.Clamp01(1.0 - (num2 - 1.0));
					num = 1.0;
					_direction = Spline.Direction.Backward;
					break;
				}
			}
			else if (_direction == Spline.Direction.Backward && num2 <= 0.0)
			{
				if (this.onBeginningReached != null && num > 0.0)
				{
					flag2 = true;
				}
				switch (wrapMode)
				{
				case Wrap.Default:
					num2 = 0.0;
					break;
				case Wrap.Loop:
					CheckTriggers(num, 0.0);
					CheckNodes(num, 0.0);
					for (; num2 < 0.0; num2 += 1.0)
					{
					}
					num = 1.0;
					break;
				case Wrap.PingPong:
					num2 = DMath.Clamp01(0.0 - num2);
					num = 0.0;
					_direction = Spline.Direction.Forward;
					break;
				}
			}
			CheckTriggers(num, num2);
			CheckNodes(num, num2);
			Evaluate(num2, _result);
			ApplyMotion();
			if (flag)
			{
				this.onEndReached();
			}
			else if (flag2)
			{
				this.onBeginningReached();
			}
			InvokeTriggers();
			InvokeNodes();
		}

		public void Move(float distance)
		{
			bool flag = false;
			bool flag2 = false;
			float moved = 0f;
			double percent = _result.percent;
			_result.percent = Travel(_result.percent, distance, _direction, out moved);
			if (percent != _result.percent)
			{
				CheckTriggers(percent, _result.percent);
				CheckNodes(percent, _result.percent);
			}
			if (moved < distance)
			{
				if (base.direction == Spline.Direction.Forward)
				{
					if (_result.percent >= 1.0)
					{
						switch (wrapMode)
						{
						case Wrap.Loop:
							_result.percent = Travel(0.0, distance - moved, _direction, out moved);
							CheckTriggers(0.0, _result.percent);
							CheckNodes(0.0, _result.percent);
							break;
						case Wrap.PingPong:
							_direction = Spline.Direction.Backward;
							_result.percent = Travel(1.0, distance - moved, _direction, out moved);
							CheckTriggers(1.0, _result.percent);
							CheckNodes(1.0, _result.percent);
							break;
						}
						if (percent < _result.percent)
						{
							flag = true;
						}
					}
				}
				else if (_result.percent <= 0.0)
				{
					switch (wrapMode)
					{
					case Wrap.Loop:
						_result.percent = Travel(1.0, distance - moved, _direction, out moved);
						CheckTriggers(1.0, _result.percent);
						CheckNodes(1.0, _result.percent);
						break;
					case Wrap.PingPong:
						_direction = Spline.Direction.Forward;
						_result.percent = Travel(0.0, distance - moved, _direction, out moved);
						CheckTriggers(0.0, _result.percent);
						CheckNodes(0.0, _result.percent);
						break;
					}
					if (percent > _result.percent)
					{
						flag2 = true;
					}
				}
			}
			Evaluate(_result.percent, _result);
			ApplyMotion();
			if (flag && this.onEndReached != null)
			{
				this.onEndReached();
			}
			else if (flag2 && this.onBeginningReached != null)
			{
				this.onBeginningReached();
			}
			InvokeTriggers();
			InvokeNodes();
		}
	}
	[RequireComponent(typeof(MeshFilter))]
	[RequireComponent(typeof(MeshRenderer))]
	[AddComponentMenu("Dreamteck/Splines/Users/Spline Mesh")]
	public class SplineMesh : MeshGenerator
	{
		[Serializable]
		public class Channel
		{
			public delegate float FloatHandler(double percent);

			public delegate Vector2 Vector2Handler(double percent);

			public delegate Vector3 Vector3Handler(double percent);

			public delegate Quaternion QuaternionHandler(double percent);

			public enum Type
			{
				Extrude,
				Place
			}

			public enum UVOverride
			{
				None,
				ClampU,
				ClampV,
				UniformU,
				UniformV
			}

			[Serializable]
			public class MeshDefinition
			{
				public enum MirrorMethod
				{
					None,
					X,
					Y,
					Z
				}

				[Serializable]
				public class Submesh
				{
					public int[] triangles = new int[0];

					public Submesh()
					{
					}

					public Submesh(int[] input)
					{
						triangles = new int[input.Length];
						input.CopyTo(triangles, 0);
					}
				}

				[Serializable]
				public class VertexGroup
				{
					public float value;

					public double percent;

					public int[] ids;

					public VertexGroup(float val, double perc, int[] vertIds)
					{
						percent = perc;
						value = val;
						ids = vertIds;
					}

					public void AddId(int id)
					{
						int[] array = new int[ids.Length + 1];
						ids.CopyTo(array, 0);
						array[array.Length - 1] = id;
						ids = array;
					}
				}

				[SerializeField]
				[HideInInspector]
				internal Vector3[] vertices = new Vector3[0];

				[SerializeField]
				[HideInInspector]
				internal Vector3[] normals = new Vector3[0];

				[SerializeField]
				[HideInInspector]
				internal Vector4[] tangents = new Vector4[0];

				[SerializeField]
				[HideInInspector]
				internal Color[] colors = new Color[0];

				[SerializeField]
				[HideInInspector]
				internal Vector2[] uv = new Vector2[0];

				[SerializeField]
				[HideInInspector]
				internal Vector2[] uv2 = new Vector2[0];

				[SerializeField]
				[HideInInspector]
				internal Vector2[] uv3 = new Vector2[0];

				[SerializeField]
				[HideInInspector]
				internal Vector2[] uv4 = new Vector2[0];

				[SerializeField]
				[HideInInspector]
				internal int[] triangles = new int[0];

				[SerializeField]
				[HideInInspector]
				internal List<Submesh> subMeshes = new List<Submesh>();

				[SerializeField]
				[HideInInspector]
				internal TS_Bounds bounds = new TS_Bounds(Vector3.zero, Vector3.zero);

				[SerializeField]
				[HideInInspector]
				internal List<VertexGroup> vertexGroups = new List<VertexGroup>();

				[SerializeField]
				[HideInInspector]
				private Mesh _mesh;

				[SerializeField]
				[HideInInspector]
				private Vector3 _rotation = Vector3.zero;

				[SerializeField]
				[HideInInspector]
				private Vector3 _offset = Vector3.zero;

				[SerializeField]
				[HideInInspector]
				private Vector3 _scale = Vector3.one;

				[SerializeField]
				[HideInInspector]
				private Vector2 _uvScale = Vector2.one;

				[SerializeField]
				[HideInInspector]
				private Vector2 _uvOffset = Vector2.zero;

				[SerializeField]
				[HideInInspector]
				private float _uvRotation;

				[SerializeField]
				[HideInInspector]
				private MirrorMethod _mirror;

				[SerializeField]
				[HideInInspector]
				private float _vertexGroupingMargin;

				[SerializeField]
				[HideInInspector]
				private bool _removeInnerFaces;

				[SerializeField]
				[HideInInspector]
				private bool _flipFaces;

				[SerializeField]
				[HideInInspector]
				private bool _doubleSided;

				public Mesh mesh
				{
					get
					{
						return _mesh;
					}
					set
					{
						if (_mesh != value)
						{
							_mesh = value;
							Refresh();
						}
					}
				}

				public Vector3 rotation
				{
					get
					{
						return _rotation;
					}
					set
					{
						if (rotation != value)
						{
							_rotation = value;
							Refresh();
						}
					}
				}

				public Vector3 offset
				{
					get
					{
						return _offset;
					}
					set
					{
						if (_offset != value)
						{
							_offset = value;
							Refresh();
						}
					}
				}

				public Vector3 scale
				{
					get
					{
						return _scale;
					}
					set
					{
						if (_scale != value)
						{
							_scale = value;
							Refresh();
						}
					}
				}

				public Vector2 uvScale
				{
					get
					{
						return _uvScale;
					}
					set
					{
						if (_uvScale != value)
						{
							_uvScale = value;
							Refresh();
						}
					}
				}

				public Vector2 uvOffset
				{
					get
					{
						return _uvOffset;
					}
					set
					{
						if (_uvOffset != value)
						{
							_uvOffset = value;
							Refresh();
						}
					}
				}

				public float uvRotation
				{
					get
					{
						return _uvRotation;
					}
					set
					{
						if (_uvRotation != value)
						{
							_uvRotation = value;
							Refresh();
						}
					}
				}

				public float vertexGroupingMargin
				{
					get
					{
						return _vertexGroupingMargin;
					}
					set
					{
						if (_vertexGroupingMargin != value)
						{
							_vertexGroupingMargin = value;
							Refresh();
						}
					}
				}

				public MirrorMethod mirror
				{
					get
					{
						return _mirror;
					}
					set
					{
						if (_mirror != value)
						{
							_mirror = value;
							Refresh();
						}
					}
				}

				public bool removeInnerFaces
				{
					get
					{
						return _removeInnerFaces;
					}
					set
					{
						if (_removeInnerFaces != value)
						{
							_removeInnerFaces = value;
							Refresh();
						}
					}
				}

				public bool flipFaces
				{
					get
					{
						return _flipFaces;
					}
					set
					{
						if (_flipFaces != value)
						{
							_flipFaces = value;
							Refresh();
						}
					}
				}

				public bool doubleSided
				{
					get
					{
						return _doubleSided;
					}
					set
					{
						if (_doubleSided != value)
						{
							_doubleSided = value;
							Refresh();
						}
					}
				}

				internal MeshDefinition Copy()
				{
					MeshDefinition meshDefinition = new MeshDefinition(_mesh);
					meshDefinition.vertices = new Vector3[vertices.Length];
					meshDefinition.normals = new Vector3[normals.Length];
					meshDefinition.colors = new Color[colors.Length];
					meshDefinition.tangents = new Vector4[tangents.Length];
					meshDefinition.uv = new Vector2[uv.Length];
					meshDefinition.uv2 = new Vector2[uv2.Length];
					meshDefinition.uv3 = new Vector2[uv3.Length];
					meshDefinition.uv4 = new Vector2[uv4.Length];
					meshDefinition.triangles = new int[triangles.Length];
					vertices.CopyTo(meshDefinition.vertices, 0);
					normals.CopyTo(meshDefinition.normals, 0);
					colors.CopyTo(meshDefinition.colors, 0);
					tangents.CopyTo(meshDefinition.tangents, 0);
					uv.CopyTo(meshDefinition.uv, 0);
					uv2.CopyTo(meshDefinition.uv2, 0);
					uv3.CopyTo(meshDefinition.uv3, 0);
					uv4.CopyTo(meshDefinition.uv4, 0);
					triangles.CopyTo(meshDefinition.triangles, 0);
					meshDefinition.bounds = new TS_Bounds(bounds.min, bounds.max);
					meshDefinition.subMeshes = new List<Submesh>();
					for (int i = 0; i < subMeshes.Count; i++)
					{
						meshDefinition.subMeshes.Add(new Submesh(new int[subMeshes[i].triangles.Length]));
						subMeshes[i].triangles.CopyTo(meshDefinition.subMeshes[meshDefinition.subMeshes.Count - 1].triangles, 0);
					}
					meshDefinition._mirror = _mirror;
					meshDefinition._offset = _offset;
					meshDefinition._rotation = _rotation;
					meshDefinition._scale = _scale;
					meshDefinition._uvOffset = _uvOffset;
					meshDefinition._uvScale = _uvScale;
					meshDefinition._uvRotation = _uvRotation;
					meshDefinition._flipFaces = _flipFaces;
					meshDefinition._doubleSided = _doubleSided;
					return meshDefinition;
				}

				public MeshDefinition(Mesh input)
				{
					_mesh = input;
					Refresh();
				}

				public void Refresh()
				{
					if (_mesh == null)
					{
						vertices = new Vector3[0];
						normals = new Vector3[0];
						colors = new Color[0];
						uv = new Vector2[0];
						uv2 = new Vector2[0];
						uv3 = new Vector2[0];
						uv4 = new Vector2[0];
						tangents = new Vector4[0];
						triangles = new int[0];
						subMeshes = new List<Submesh>();
						vertexGroups = new List<VertexGroup>();
						return;
					}
					if (vertices.Length != _mesh.vertexCount)
					{
						vertices = new Vector3[_mesh.vertexCount];
					}
					if (normals.Length != _mesh.normals.Length)
					{
						normals = new Vector3[_mesh.normals.Length];
					}
					if (colors.Length != _mesh.colors.Length)
					{
						colors = new Color[_mesh.colors.Length];
					}
					if (uv.Length != _mesh.uv.Length)
					{
						uv = new Vector2[_mesh.uv.Length];
					}
					if (uv2.Length != _mesh.uv2.Length)
					{
						uv2 = new Vector2[_mesh.uv2.Length];
					}
					if (uv3.Length != _mesh.uv3.Length)
					{
						uv3 = new Vector2[_mesh.uv3.Length];
					}
					if (uv4.Length != _mesh.uv4.Length)
					{
						uv4 = new Vector2[_mesh.uv4.Length];
					}
					if (tangents.Length != _mesh.tangents.Length)
					{
						tangents = new Vector4[_mesh.tangents.Length];
					}
					if (triangles.Length != _mesh.triangles.Length)
					{
						triangles = new int[_mesh.triangles.Length];
					}
					vertices = _mesh.vertices;
					normals = _mesh.normals;
					colors = _mesh.colors;
					uv = _mesh.uv;
					uv2 = _mesh.uv2;
					uv3 = _mesh.uv3;
					uv4 = _mesh.uv4;
					tangents = _mesh.tangents;
					triangles = _mesh.triangles;
					colors = _mesh.colors;
					while (subMeshes.Count > _mesh.subMeshCount)
					{
						subMeshes.RemoveAt(0);
					}
					while (subMeshes.Count < _mesh.subMeshCount)
					{
						subMeshes.Add(new Submesh(new int[0]));
					}
					for (int i = 0; i < subMeshes.Count; i++)
					{
						subMeshes[i].triangles = _mesh.GetTriangles(i);
					}
					if (colors.Length != vertices.Length)
					{
						colors = new Color[vertices.Length];
						for (int j = 0; j < colors.Length; j++)
						{
							colors[j] = Color.white;
						}
					}
					Mirror();
					if (_doubleSided)
					{
						DoubleSided();
					}
					else if (_flipFaces)
					{
						FlipFaces();
					}
					TransformVertices();
					CalculateBounds();
					if (_removeInnerFaces)
					{
						RemoveInnerFaces();
					}
					GroupVertices();
				}

				private void RemoveInnerFaces()
				{
					float num = float.MaxValue;
					float num2 = 0f;
					for (int i = 0; i < vertices.Length; i++)
					{
						if (vertices[i].z < num)
						{
							num = vertices[i].z;
						}
						if (vertices[i].z > num2)
						{
							num2 = vertices[i].z;
						}
					}
					for (int j = 0; j < subMeshes.Count; j++)
					{
						List<int> list = new List<int>();
						for (int k = 0; k < subMeshes[j].triangles.Length; k += 3)
						{
							bool flag = true;
							bool flag2 = true;
							for (int l = k; l < k + 3; l++)
							{
								int num3 = subMeshes[j].triangles[l];
								if (!Mathf.Approximately(vertices[num3].z, num2))
								{
									flag = false;
								}
								if (!Mathf.Approximately(vertices[num3].z, num))
								{
									flag2 = false;
								}
							}
							if (!flag && !flag2)
							{
								list.Add(subMeshes[j].triangles[k]);
								list.Add(subMeshes[j].triangles[k + 1]);
								list.Add(subMeshes[j].triangles[k + 2]);
							}
						}
						subMeshes[j].triangles = list.ToArray();
					}
				}

				private void FlipFaces()
				{
					TS_Mesh tS_Mesh = new TS_Mesh();
					tS_Mesh.normals = normals;
					tS_Mesh.tangents = tangents;
					tS_Mesh.triangles = triangles;
					for (int i = 0; i < subMeshes.Count; i++)
					{
						tS_Mesh.subMeshes.Add(subMeshes[i].triangles);
					}
					MeshUtility.FlipFaces(tS_Mesh);
				}

				private void DoubleSided()
				{
					TS_Mesh tS_Mesh = new TS_Mesh();
					tS_Mesh.vertices = vertices;
					tS_Mesh.normals = normals;
					tS_Mesh.tangents = tangents;
					tS_Mesh.colors = colors;
					tS_Mesh.uv = uv;
					tS_Mesh.uv2 = uv2;
					tS_Mesh.uv3 = uv3;
					tS_Mesh.uv4 = uv4;
					tS_Mesh.triangles = triangles;
					for (int i = 0; i < subMeshes.Count; i++)
					{
						tS_Mesh.subMeshes.Add(subMeshes[i].triangles);
					}
					MeshUtility.MakeDoublesided(tS_Mesh);
					vertices = tS_Mesh.vertices;
					normals = tS_Mesh.normals;
					tangents = tS_Mesh.tangents;
					colors = tS_Mesh.colors;
					uv = tS_Mesh.uv;
					uv2 = tS_Mesh.uv2;
					uv3 = tS_Mesh.uv3;
					uv4 = tS_Mesh.uv4;
					triangles = tS_Mesh.triangles;
					for (int j = 0; j < subMeshes.Count; j++)
					{
						subMeshes[j].triangles = tS_Mesh.subMeshes[j];
					}
				}

				public void Write(TS_Mesh target, int forceMaterialId = -1)
				{
					if (target.vertices.Length != vertices.Length)
					{
						target.vertices = new Vector3[vertices.Length];
					}
					if (target.normals.Length != normals.Length)
					{
						target.normals = new Vector3[normals.Length];
					}
					if (target.colors.Length != colors.Length)
					{
						target.colors = new Color[colors.Length];
					}
					if (target.uv.Length != uv.Length)
					{
						target.uv = new Vector2[uv.Length];
					}
					if (target.uv2.Length != uv2.Length)
					{
						target.uv2 = new Vector2[uv2.Length];
					}
					if (target.uv3.Length != uv3.Length)
					{
						target.uv3 = new Vector2[uv3.Length];
					}
					if (target.uv4.Length != uv4.Length)
					{
						target.uv4 = new Vector2[uv4.Length];
					}
					if (target.tangents.Length != tangents.Length)
					{
						target.tangents = new Vector4[tangents.Length];
					}
					if (target.triangles.Length != triangles.Length)
					{
						target.triangles = new int[triangles.Length];
					}
					vertices.CopyTo(target.vertices, 0);
					normals.CopyTo(target.normals, 0);
					colors.CopyTo(target.colors, 0);
					uv.CopyTo(target.uv, 0);
					uv2.CopyTo(target.uv2, 0);
					uv3.CopyTo(target.uv3, 0);
					uv4.CopyTo(target.uv4, 0);
					tangents.CopyTo(target.tangents, 0);
					triangles.CopyTo(target.triangles, 0);
					if (target.subMeshes == null)
					{
						target.subMeshes = new List<int[]>();
					}
					if (forceMaterialId >= 0)
					{
						while (target.subMeshes.Count > forceMaterialId + 1)
						{
							target.subMeshes.RemoveAt(0);
						}
						while (target.subMeshes.Count < forceMaterialId + 1)
						{
							target.subMeshes.Add(new int[0]);
						}
						for (int i = 0; i < target.subMeshes.Count; i++)
						{
							if (i != forceMaterialId)
							{
								if (target.subMeshes[i].Length != 0)
								{
									target.subMeshes[i] = new int[0];
								}
								continue;
							}
							if (target.subMeshes[i].Length != triangles.Length)
							{
								target.subMeshes[i] = new int[triangles.Length];
							}
							triangles.CopyTo(target.subMeshes[i], 0);
						}
						return;
					}
					while (target.subMeshes.Count > subMeshes.Count)
					{
						target.subMeshes.RemoveAt(0);
					}
					while (target.subMeshes.Count < subMeshes.Count)
					{
						target.subMeshes.Add(new int[0]);
					}
					for (int j = 0; j < subMeshes.Count; j++)
					{
						if (subMeshes[j].triangles.Length != target.subMeshes[j].Length)
						{
							target.subMeshes[j] = new int[subMeshes[j].triangles.Length];
						}
						subMeshes[j].triangles.CopyTo(target.subMeshes[j], 0);
					}
				}

				private void CalculateBounds()
				{
					Vector3 zero = Vector3.zero;
					Vector3 zero2 = Vector3.zero;
					for (int i = 0; i < vertices.Length; i++)
					{
						if (vertices[i].x < zero.x)
						{
							zero.x = vertices[i].x;
						}
						else if (vertices[i].x > zero2.x)
						{
							zero2.x = vertices[i].x;
						}
						if (vertices[i].y < zero.y)
						{
							zero.y = vertices[i].y;
						}
						else if (vertices[i].y > zero2.y)
						{
							zero2.y = vertices[i].y;
						}
						if (vertices[i].z < zero.z)
						{
							zero.z = vertices[i].z;
						}
						else if (vertices[i].z > zero2.z)
						{
							zero2.z = vertices[i].z;
						}
					}
					bounds.CreateFromMinMax(zero, zero2);
				}

				private void Mirror()
				{
					if (_mirror == MirrorMethod.None)
					{
						return;
					}
					switch (_mirror)
					{
					case MirrorMethod.X:
					{
						for (int j = 0; j < vertices.Length; j++)
						{
							vertices[j].x *= -1f;
							normals[j].x = 0f - normals[j].x;
						}
						break;
					}
					case MirrorMethod.Y:
					{
						for (int k = 0; k < vertices.Length; k++)
						{
							vertices[k].y *= -1f;
							normals[k].y = 0f - normals[k].y;
						}
						break;
					}
					case MirrorMethod.Z:
					{
						for (int i = 0; i < vertices.Length; i++)
						{
							vertices[i].z *= -1f;
							normals[i].z = 0f - normals[i].z;
						}
						break;
					}
					}
					for (int l = 0; l < triangles.Length; l += 3)
					{
						int num = triangles[l];
						triangles[l] = triangles[l + 2];
						triangles[l + 2] = num;
					}
					for (int m = 0; m < subMeshes.Count; m++)
					{
						for (int n = 0; n < subMeshes[m].triangles.Length; n += 3)
						{
							int num2 = subMeshes[m].triangles[n];
							subMeshes[m].triangles[n] = subMeshes[m].triangles[n + 2];
							subMeshes[m].triangles[n + 2] = num2;
						}
					}
					CalculateTangents();
				}

				private void TransformVertices()
				{
					Matrix4x4 matrix4x = default(Matrix4x4);
					matrix4x.SetTRS(_offset, Quaternion.Euler(_rotation), _scale);
					Matrix4x4 transpose = matrix4x.inverse.transpose;
					for (int i = 0; i < vertices.Length; i++)
					{
						vertices[i] = matrix4x.MultiplyPoint3x4(vertices[i]);
						normals[i] = transpose.MultiplyVector(normals[i]).normalized;
					}
					for (int j = 0; j < tangents.Length; j++)
					{
						tangents[j] = transpose.MultiplyVector(tangents[j]);
					}
					for (int k = 0; k < uv.Length; k++)
					{
						uv[k].x *= _uvScale.x;
						uv[k].y *= _uvScale.y;
						uv[k] += _uvOffset;
						uv[k] = Quaternion.AngleAxis(uvRotation, Vector3.forward) * uv[k];
					}
				}

				private void GroupVertices()
				{
					vertexGroups = new List<VertexGroup>();
					for (int i = 0; i < vertices.Length; i++)
					{
						float z = vertices[i].z;
						double perc = DMath.Clamp01(DMath.InverseLerp(bounds.min.z, bounds.max.z, z));
						int num = FindInsertIndex(vertices[i], z);
						if (num >= vertexGroups.Count)
						{
							vertexGroups.Add(new VertexGroup(z, perc, new int[1] { i }));
							continue;
						}
						float num2 = Mathf.Abs(vertexGroups[num].value - z);
						if (num2 < vertexGroupingMargin || Mathf.Approximately(num2, vertexGroupingMargin))
						{
							vertexGroups[num].AddId(i);
						}
						else if (vertexGroups[num].value < z)
						{
							vertexGroups.Insert(num, new VertexGroup(z, perc, new int[1] { i }));
						}
						else if (num < vertexGroups.Count - 1)
						{
							vertexGroups.Insert(num + 1, new VertexGroup(z, perc, new int[1] { i }));
						}
						else
						{
							vertexGroups.Add(new VertexGroup(z, perc, new int[1] { i }));
						}
					}
				}

				private int FindInsertIndex(Vector3 pos, float value)
				{
					int num = 0;
					int num2 = vertexGroups.Count - 1;
					while (num <= num2)
					{
						int num3 = num + (num2 - num) / 2;
						if (vertexGroups[num3].value == value)
						{
							return num3;
						}
						if (vertexGroups[num3].value < value)
						{
							num2 = num3 - 1;
						}
						else
						{
							num = num3 + 1;
						}
					}
					return num;
				}

				private void CalculateTangents()
				{
					if (vertices.Length == 0)
					{
						tangents = new Vector4[0];
						return;
					}
					tangents = new Vector4[vertices.Length];
					Vector3[] array = new Vector3[vertices.Length];
					Vector3[] array2 = new Vector3[vertices.Length];
					for (int i = 0; i < subMeshes.Count; i++)
					{
						for (int j = 0; j < subMeshes[i].triangles.Length; j += 3)
						{
							int num = subMeshes[i].triangles[j];
							int num2 = subMeshes[i].triangles[j + 1];
							int num3 = subMeshes[i].triangles[j + 2];
							float num4 = vertices[num2].x - vertices[num].x;
							float num5 = vertices[num3].x - vertices[num].x;
							float num6 = vertices[num2].y - vertices[num].y;
							float num7 = vertices[num3].y - vertices[num].y;
							float num8 = vertices[num2].z - vertices[num].z;
							float num9 = vertices[num3].z - vertices[num].z;
							float num10 = uv[num2].x - uv[num].x;
							float num11 = uv[num3].x - uv[num].x;
							float num12 = uv[num2].y - uv[num].y;
							float num13 = uv[num3].y - uv[num].y;
							float num14 = num10 * num13 - num11 * num12;
							float num15 = ((num14 == 0f) ? 0f : (1f / num14));
							Vector3 vector = new Vector3((num13 * num4 - num12 * num5) * num15, (num13 * num6 - num12 * num7) * num15, (num13 * num8 - num12 * num9) * num15);
							Vector3 vector2 = new Vector3((num10 * num5 - num11 * num4) * num15, (num10 * num7 - num11 * num6) * num15, (num10 * num9 - num11 * num8) * num15);
							array[num] += vector;
							array[num2] += vector;
							array[num3] += vector;
							array2[num] += vector2;
							array2[num2] += vector2;
							array2[num3] += vector2;
						}
					}
					for (int k = 0; k < vertices.Length; k++)
					{
						Vector3 normal = normals[k];
						Vector3 tangent = array[k];
						Vector3.OrthoNormalize(ref normal, ref tangent);
						tangents[k].x = tangent.x;
						tangents[k].y = tangent.y;
						tangents[k].z = tangent.z;
						tangents[k].w = ((Vector3.Dot(Vector3.Cross(normal, tangent), array2[k]) < 0f) ? (-1f) : 1f);
					}
				}
			}

			public string name = "Channel";

			private System.Random iterationRandom;

			[SerializeField]
			[HideInInspector]
			private int _iterationSeed;

			[SerializeField]
			[HideInInspector]
			private int _offsetSeed;

			private System.Random offsetRandom;

			private Vector2Handler _offsetHandler;

			[SerializeField]
			[HideInInspector]
			private int _rotationSeed;

			private System.Random rotationRandom;

			private QuaternionHandler _placeRotationHandler;

			private FloatHandler _extrudeRotationHandler;

			[SerializeField]
			[HideInInspector]
			private int _scaleSeed;

			private System.Random scaleRandom;

			private Vector3Handler _scaleHandler;

			[SerializeField]
			internal SplineMesh owner;

			[SerializeField]
			[HideInInspector]
			private List<MeshDefinition> meshes = new List<MeshDefinition>();

			[SerializeField]
			[HideInInspector]
			private double _clipFrom;

			[SerializeField]
			[HideInInspector]
			private double _clipTo = 1.0;

			[SerializeField]
			[HideInInspector]
			private bool _randomOrder;

			[SerializeField]
			[HideInInspector]
			private UVOverride _overrideUVs;

			[SerializeField]
			[HideInInspector]
			private Vector2 _uvScale = Vector2.one;

			[SerializeField]
			[HideInInspector]
			private Vector2 _uvOffset = Vector2.zero;

			[SerializeField]
			[HideInInspector]
			private bool _overrideNormal;

			[SerializeField]
			[HideInInspector]
			private Vector3 _customNormal = Vector3.up;

			[SerializeField]
			[HideInInspector]
			private Type _type;

			[SerializeField]
			[HideInInspector]
			private int _count = 1;

			[SerializeField]
			[HideInInspector]
			private bool _autoCount;

			[SerializeField]
			[HideInInspector]
			private double _spacing;

			[SerializeField]
			[HideInInspector]
			private bool _randomRotation;

			[SerializeField]
			[HideInInspector]
			private Vector3 _minRotation = Vector3.zero;

			[SerializeField]
			[HideInInspector]
			private Vector3 _maxRotation = Vector3.zero;

			[SerializeField]
			[HideInInspector]
			private bool _randomOffset;

			[SerializeField]
			[HideInInspector]
			private Vector2 _minOffset = Vector2.one;

			[SerializeField]
			[HideInInspector]
			private Vector2 _maxOffset = Vector2.one;

			[SerializeField]
			[HideInInspector]
			private bool _randomScale;

			[SerializeField]
			[HideInInspector]
			private bool _uniformRandomScale;

			[SerializeField]
			[HideInInspector]
			private Vector3 _minScale = Vector3.one;

			[SerializeField]
			[HideInInspector]
			private Vector3 _maxScale = Vector3.one;

			private int iterator;

			[SerializeField]
			[HideInInspector]
			private bool _overrideMaterialID;

			[SerializeField]
			[HideInInspector]
			private int _targetMaterialID;

			[SerializeField]
			[HideInInspector]
			protected MeshScaleModifier _scaleModifier = new MeshScaleModifier();

			public double clipFrom
			{
				get
				{
					return _clipFrom;
				}
				set
				{
					if (value != _clipFrom)
					{
						_clipFrom = value;
						Rebuild();
					}
				}
			}

			public double clipTo
			{
				get
				{
					return _clipTo;
				}
				set
				{
					if (value != _clipTo)
					{
						_clipTo = value;
						Rebuild();
					}
				}
			}

			public bool randomOffset
			{
				get
				{
					return _randomOffset;
				}
				set
				{
					if (value != _randomOffset)
					{
						_randomOffset = value;
						Rebuild();
					}
				}
			}

			public Vector2Handler offsetHandler
			{
				get
				{
					return _offsetHandler;
				}
				set
				{
					if (value != _offsetHandler)
					{
						_offsetHandler = value;
						Rebuild();
					}
				}
			}

			public bool overrideMaterialID
			{
				get
				{
					return _overrideMaterialID;
				}
				set
				{
					if (value != _overrideMaterialID)
					{
						_overrideMaterialID = value;
						Rebuild();
					}
				}
			}

			public int targetMaterialID
			{
				get
				{
					return _targetMaterialID;
				}
				set
				{
					if (value != _targetMaterialID)
					{
						_targetMaterialID = value;
						Rebuild();
					}
				}
			}

			public bool randomRotation
			{
				get
				{
					return _randomRotation;
				}
				set
				{
					if (value != _randomRotation)
					{
						_randomRotation = value;
						Rebuild();
					}
				}
			}

			public QuaternionHandler placeRotationHandler
			{
				get
				{
					return _placeRotationHandler;
				}
				set
				{
					if (value != _placeRotationHandler)
					{
						_placeRotationHandler = value;
						Rebuild();
					}
				}
			}

			public FloatHandler extrudeRotationHandler
			{
				get
				{
					return _extrudeRotationHandler;
				}
				set
				{
					if (value != _extrudeRotationHandler)
					{
						_extrudeRotationHandler = value;
						Rebuild();
					}
				}
			}

			public bool randomScale
			{
				get
				{
					return _randomScale;
				}
				set
				{
					if (value != _randomScale)
					{
						_randomScale = value;
						Rebuild();
					}
				}
			}

			public Vector3Handler scaleHandler
			{
				get
				{
					return _scaleHandler;
				}
				set
				{
					if (value != _scaleHandler)
					{
						_scaleHandler = value;
						Rebuild();
					}
				}
			}

			public bool uniformRandomScale
			{
				get
				{
					return _uniformRandomScale;
				}
				set
				{
					if (value != _uniformRandomScale)
					{
						_uniformRandomScale = value;
						Rebuild();
					}
				}
			}

			public int offsetSeed
			{
				get
				{
					return _offsetSeed;
				}
				set
				{
					if (value != _offsetSeed)
					{
						_offsetSeed = value;
						Rebuild();
					}
				}
			}

			public int rotationSeed
			{
				get
				{
					return _rotationSeed;
				}
				set
				{
					if (value != _rotationSeed)
					{
						_rotationSeed = value;
						Rebuild();
					}
				}
			}

			public int scaleSeed
			{
				get
				{
					return _scaleSeed;
				}
				set
				{
					if (value != _scaleSeed)
					{
						_scaleSeed = value;
						Rebuild();
					}
				}
			}

			public double spacing
			{
				get
				{
					return _spacing;
				}
				set
				{
					if (value != _spacing)
					{
						_spacing = value;
						Rebuild();
					}
				}
			}

			public Vector2 minOffset
			{
				get
				{
					return _minOffset;
				}
				set
				{
					if (value != _minOffset)
					{
						_minOffset = value;
						Rebuild();
					}
				}
			}

			public Vector2 maxOffset
			{
				get
				{
					return _maxOffset;
				}
				set
				{
					if (value != _maxOffset)
					{
						_maxOffset = value;
						Rebuild();
					}
				}
			}

			public Vector3 minRotation
			{
				get
				{
					return _minRotation;
				}
				set
				{
					if (value != _minRotation)
					{
						_minRotation = value;
						Rebuild();
					}
				}
			}

			public Vector3 maxRotation
			{
				get
				{
					return _maxRotation;
				}
				set
				{
					if (value != _maxRotation)
					{
						_maxRotation = value;
						Rebuild();
					}
				}
			}

			public Vector3 minScale
			{
				get
				{
					return _minScale;
				}
				set
				{
					if (value != _minScale)
					{
						_minScale = value;
						Rebuild();
					}
				}
			}

			public Vector3 maxScale
			{
				get
				{
					return _maxScale;
				}
				set
				{
					if (value != _maxScale)
					{
						_maxScale = value;
						Rebuild();
					}
				}
			}

			public Type type
			{
				get
				{
					return _type;
				}
				set
				{
					if (value != _type)
					{
						_type = value;
						Rebuild();
					}
				}
			}

			public bool randomOrder
			{
				get
				{
					return _randomOrder;
				}
				set
				{
					if (value != _randomOrder)
					{
						_randomOrder = value;
						Rebuild();
					}
				}
			}

			public int randomSeed
			{
				get
				{
					return _iterationSeed;
				}
				set
				{
					if (value != _iterationSeed)
					{
						_iterationSeed = value;
						if (_randomOrder)
						{
							Rebuild();
						}
					}
				}
			}

			public int count
			{
				get
				{
					return _count;
				}
				set
				{
					if (value != _count)
					{
						_count = value;
						if (_count < 1)
						{
							_count = 1;
						}
						Rebuild();
					}
				}
			}

			public bool autoCount
			{
				get
				{
					return _autoCount;
				}
				set
				{
					if (value != _autoCount)
					{
						_autoCount = value;
						Rebuild();
					}
				}
			}

			public UVOverride overrideUVs
			{
				get
				{
					return _overrideUVs;
				}
				set
				{
					if (value != _overrideUVs)
					{
						_overrideUVs = value;
						Rebuild();
					}
				}
			}

			public Vector2 uvOffset
			{
				get
				{
					return _uvOffset;
				}
				set
				{
					if (value != _uvOffset)
					{
						_uvOffset = value;
						Rebuild();
					}
				}
			}

			public Vector2 uvScale
			{
				get
				{
					return _uvScale;
				}
				set
				{
					if (value != _uvScale)
					{
						_uvScale = value;
						Rebuild();
					}
				}
			}

			public bool overrideNormal
			{
				get
				{
					return _overrideNormal;
				}
				set
				{
					if (value != _overrideNormal)
					{
						_overrideNormal = value;
						Rebuild();
					}
				}
			}

			public Vector3 customNormal
			{
				get
				{
					return _customNormal;
				}
				set
				{
					if (value != _customNormal)
					{
						_customNormal = value;
						Rebuild();
					}
				}
			}

			public MeshScaleModifier scaleModifier => _scaleModifier;

			public Channel(string n, SplineMesh parent)
			{
				name = n;
				owner = parent;
				Init();
			}

			public Channel(string n, Mesh inputMesh, SplineMesh parent)
			{
				name = n;
				owner = parent;
				meshes.Add(new MeshDefinition(inputMesh));
				Init();
				Rebuild();
			}

			private void Init()
			{
				_minScale = (_maxScale = Vector3.one);
				_minOffset = (_maxOffset = Vector3.zero);
				_minRotation = (_maxRotation = Vector3.zero);
			}

			public void CopyTo(Channel target)
			{
				target.meshes.Clear();
				for (int i = 0; i < meshes.Count; i++)
				{
					target.meshes.Add(meshes[i].Copy());
				}
				target._clipFrom = _clipFrom;
				target._clipTo = _clipTo;
				target._customNormal = _customNormal;
				target._iterationSeed = _iterationSeed;
				target._minOffset = _minOffset;
				target._minRotation = _minRotation;
				target._minScale = _minScale;
				target._maxOffset = _maxOffset;
				target._maxRotation = _maxRotation;
				target._maxScale = _maxScale;
				target._randomOffset = _randomOffset;
				target._randomRotation = _randomRotation;
				target._randomScale = _randomScale;
				target._offsetSeed = _offsetSeed;
				target._offsetHandler = _offsetHandler;
				target._rotationSeed = _rotationSeed;
				target._placeRotationHandler = _placeRotationHandler;
				target._extrudeRotationHandler = _extrudeRotationHandler;
				target._scaleSeed = _scaleSeed;
				target._scaleHandler = _scaleHandler;
				target._iterationSeed = _iterationSeed;
				target._count = _count;
				target._spacing = _spacing;
				target._overrideUVs = _overrideUVs;
				target._type = _type;
				target._overrideMaterialID = _overrideMaterialID;
				target._targetMaterialID = _targetMaterialID;
				target._overrideNormal = _overrideNormal;
			}

			public int GetMeshCount()
			{
				return meshes.Count;
			}

			public void SwapMeshes(int a, int b)
			{
				if (a >= 0 && a < meshes.Count && b >= 0 && b < meshes.Count)
				{
					MeshDefinition value = meshes[b];
					meshes[b] = meshes[a];
					meshes[a] = value;
					Rebuild();
				}
			}

			public void DuplicateMesh(int index)
			{
				if (index >= 0 && index < meshes.Count)
				{
					meshes.Add(meshes[index].Copy());
					Rebuild();
				}
			}

			public MeshDefinition GetMesh(int index)
			{
				return meshes[index];
			}

			public void AddMesh(Mesh input)
			{
				meshes.Add(new MeshDefinition(input));
				Rebuild();
			}

			public void RemoveMesh(int index)
			{
				meshes.RemoveAt(index);
				Rebuild();
			}

			public void ResetIteration()
			{
				if (_randomOrder)
				{
					iterationRandom = new System.Random(_iterationSeed);
				}
				if (_randomOffset)
				{
					offsetRandom = new System.Random(_offsetSeed);
				}
				if (_randomRotation)
				{
					rotationRandom = new System.Random(_rotationSeed);
				}
				if (_randomScale)
				{
					scaleRandom = new System.Random(_scaleSeed);
				}
				iterator = 0;
			}

			public Vector2 NextOffset(double percent)
			{
				if (_offsetHandler != null)
				{
					return _offsetHandler(percent);
				}
				if (_randomOffset)
				{
					return new Vector2(Mathf.Lerp(_minOffset.x, _maxOffset.x, (float)offsetRandom.NextDouble()), Mathf.Lerp(_minOffset.y, _maxOffset.y, (float)offsetRandom.NextDouble()));
				}
				return _minOffset;
			}

			public Quaternion NextPlaceRotation(double percent)
			{
				if (_placeRotationHandler != null)
				{
					return _placeRotationHandler(percent);
				}
				if (_randomRotation)
				{
					return Quaternion.Euler(new Vector3(Mathf.Lerp(_minRotation.x, _maxRotation.x, (float)rotationRandom.NextDouble()), Mathf.Lerp(_minRotation.y, _maxRotation.y, (float)rotationRandom.NextDouble()), Mathf.Lerp(_minRotation.z, _maxRotation.z, (float)rotationRandom.NextDouble())));
				}
				return Quaternion.Euler(_minRotation);
			}

			public float NextExtrudeRotation(double percent)
			{
				if (_extrudeRotationHandler != null)
				{
					return _extrudeRotationHandler(percent);
				}
				if (_randomRotation)
				{
					return Mathf.Lerp(_minRotation.z, _maxRotation.z, (float)rotationRandom.NextDouble());
				}
				return _minRotation.z;
			}

			public Vector3 NextExtrudeScale(double percent)
			{
				if (_scaleHandler != null)
				{
					return _scaleHandler(percent);
				}
				if (_randomScale)
				{
					if (_uniformRandomScale)
					{
						return Vector3.Lerp(new Vector3(_minScale.x, _minScale.y, 1f), new Vector3(_maxScale.x, _maxScale.y, 1f), (float)scaleRandom.NextDouble());
					}
					return new Vector3(Mathf.Lerp(_minScale.x, _maxScale.x, (float)scaleRandom.NextDouble()), Mathf.Lerp(_minScale.y, _maxScale.y, (float)scaleRandom.NextDouble()), 1f);
				}
				return new Vector3(_minScale.x, _minScale.y, 1f);
			}

			public Vector3 NextPlaceScale()
			{
				if (_randomScale)
				{
					if (_uniformRandomScale)
					{
						return Vector3.Lerp(_minScale, _maxScale, (float)scaleRandom.NextDouble());
					}
					return new Vector3(Mathf.Lerp(_minScale.x, _maxScale.x, (float)scaleRandom.NextDouble()), Mathf.Lerp(_minScale.y, _maxScale.y, (float)scaleRandom.NextDouble()), Mathf.Lerp(_minScale.z, _maxScale.z, (float)scaleRandom.NextDouble()));
				}
				return _minScale;
			}

			public MeshDefinition NextMesh()
			{
				if (_randomOrder)
				{
					return meshes[iterationRandom.Next(meshes.Count)];
				}
				if (iterator >= meshes.Count)
				{
					iterator = 0;
				}
				return meshes[iterator++];
			}

			internal void Rebuild()
			{
				if (owner != null)
				{
					owner.Rebuild();
				}
			}

			private void Refresh()
			{
				for (int i = 0; i < meshes.Count; i++)
				{
					meshes[i].Refresh();
				}
				Rebuild();
			}
		}

		[SerializeField]
		[HideInInspector]
		private List<Channel> channels = new List<Channel>();

		private bool useLastResult;

		private List<TS_Mesh> combineMeshes = new List<TS_Mesh>();

		private int meshCount;

		private Matrix4x4 vertexMatrix;

		private Matrix4x4 normalMatrix;

		private SplineSample lastResult = new SplineSample();

		private SplineSample modifiedResult = new SplineSample();

		protected override void Awake()
		{
			base.Awake();
			mesh.name = "Extruded Mesh";
		}

		protected override void Reset()
		{
			base.Reset();
			AddChannel("Channel 1");
		}

		public void RemoveChannel(int index)
		{
			channels.RemoveAt(index);
			Rebuild();
		}

		public void SwapChannels(int a, int b)
		{
			if (a >= 0 && a < channels.Count && b >= 0 && b < channels.Count)
			{
				Channel value = channels[b];
				channels[b] = channels[a];
				channels[a] = value;
				Rebuild();
			}
		}

		public Channel AddChannel(Mesh inputMesh, string name)
		{
			Channel channel = new Channel(name, inputMesh, this);
			channels.Add(channel);
			return channel;
		}

		public Channel AddChannel(string name)
		{
			Channel channel = new Channel(name, this);
			channels.Add(channel);
			return channel;
		}

		public int GetChannelCount()
		{
			return channels.Count;
		}

		public Channel GetChannel(int index)
		{
			return channels[index];
		}

		protected override void BuildMesh()
		{
			if (base.sampleCount != 0)
			{
				base.BuildMesh();
				Generate();
			}
		}

		private void Generate()
		{
			meshCount = 0;
			for (int i = 0; i < channels.Count; i++)
			{
				if (channels[i].GetMeshCount() != 0)
				{
					meshCount += channels[i].count;
				}
			}
			if (meshCount == 0)
			{
				tsMesh.Clear();
				return;
			}
			if (combineMeshes.Count < meshCount)
			{
				combineMeshes.AddRange(new TS_Mesh[meshCount - combineMeshes.Count]);
			}
			else if (combineMeshes.Count > meshCount)
			{
				combineMeshes.RemoveRange(combineMeshes.Count - 1 - (combineMeshes.Count - meshCount), combineMeshes.Count - meshCount);
			}
			int num = 0;
			for (int j = 0; j < channels.Count; j++)
			{
				if (channels[j].GetMeshCount() == 0)
				{
					continue;
				}
				if (channels[j].autoCount)
				{
					float num2 = 0f;
					for (int k = 0; k < channels[j].GetMeshCount(); k++)
					{
						num2 += channels[j].GetMesh(k).bounds.size.z;
					}
					if (channels[j].GetMeshCount() > 1)
					{
						num2 /= (float)channels[j].GetMeshCount();
					}
					if (num2 > 0f)
					{
						float num3 = CalculateLength(channels[j].clipFrom, channels[j].clipTo);
						channels[j].count = Mathf.RoundToInt(num3 / num2);
						if (channels[j].count < 1)
						{
							channels[j].count = 1;
						}
					}
				}
				channels[j].ResetIteration();
				useLastResult = false;
				double num4 = 1.0 / (double)channels[j].count;
				double num5 = num4 * channels[j].spacing * 0.5;
				switch (channels[j].type)
				{
				case Channel.Type.Extrude:
				{
					for (int m = 0; m < channels[j].count; m++)
					{
						double from = DMath.Lerp(channels[j].clipFrom, channels[j].clipTo, (double)m * num4 + num5);
						double to = DMath.Lerp(channels[j].clipFrom, channels[j].clipTo, (double)m * num4 + num4 - num5);
						if (combineMeshes[num] == null)
						{
							combineMeshes[num] = new TS_Mesh();
						}
						Stretch(channels[j], combineMeshes[num], from, to);
						num++;
					}
					if (num5 == 0.0)
					{
						useLastResult = true;
					}
					break;
				}
				case Channel.Type.Place:
				{
					for (int l = 0; l < channels[j].count; l++)
					{
						if (combineMeshes[num] == null)
						{
							combineMeshes[num] = new TS_Mesh();
						}
						Place(channels[j], combineMeshes[num], DMath.Lerp(channels[j].clipFrom, channels[j].clipTo, (double)l / (double)Mathf.Max(channels[j].count - 1, 1)));
						num++;
					}
					break;
				}
				}
			}
			if (tsMesh == null)
			{
				tsMesh = new TS_Mesh();
			}
			else
			{
				tsMesh.Clear();
			}
			tsMesh.Combine(combineMeshes);
		}

		private void Place(Channel channel, TS_Mesh target, double percent)
		{
			Channel.MeshDefinition meshDefinition = channel.NextMesh();
			if (target == null)
			{
				target = new TS_Mesh();
			}
			meshDefinition.Write(target, channel.overrideMaterialID ? channel.targetMaterialID : (-1));
			Vector2 vector = channel.NextOffset(percent);
			Evaluate(percent, evalResult);
			ModifySample(evalResult);
			Vector3 up = evalResult.up;
			Vector3 right = evalResult.right;
			Vector3 forward = evalResult.forward;
			if (channel.overrideNormal)
			{
				evalResult.forward = Vector3.Cross(evalResult.right, channel.customNormal);
				evalResult.up = channel.customNormal;
			}
			_ = Quaternion.identity;
			vertexMatrix.SetTRS(evalResult.position + right * (base.offset.x + vector.x) * evalResult.size + up * (base.offset.y + vector.y) * evalResult.size + forward * base.offset.z, evalResult.rotation * channel.NextPlaceRotation(percent) * Quaternion.AngleAxis(base.rotation, Vector3.forward), channel.NextPlaceScale() * evalResult.size);
			normalMatrix = vertexMatrix.inverse.transpose;
			for (int i = 0; i < target.vertexCount; i++)
			{
				target.vertices[i] = vertexMatrix.MultiplyPoint3x4(meshDefinition.vertices[i]);
				target.normals[i] = normalMatrix.MultiplyVector(meshDefinition.normals[i]);
			}
			for (int j = 0; j < Mathf.Min(target.colors.Length, meshDefinition.colors.Length); j++)
			{
				target.colors[j] = meshDefinition.colors[j] * evalResult.color;
			}
		}

		private void Stretch(Channel channel, TS_Mesh target, double from, double to)
		{
			Channel.MeshDefinition meshDefinition = channel.NextMesh();
			if (target == null)
			{
				target = new TS_Mesh();
			}
			meshDefinition.Write(target, channel.overrideMaterialID ? channel.targetMaterialID : (-1));
			Vector2 zero = Vector2.zero;
			Vector3 zero2 = Vector3.zero;
			for (int i = 0; i < meshDefinition.vertexGroups.Count; i++)
			{
				if (useLastResult && i == meshDefinition.vertexGroups.Count)
				{
					evalResult = lastResult;
				}
				else
				{
					Evaluate(DMath.Lerp(from, to, meshDefinition.vertexGroups[i].percent), evalResult);
				}
				ModifySample(evalResult, modifiedResult);
				Vector3 up = modifiedResult.up;
				Vector3 right = modifiedResult.right;
				Vector3 forward = modifiedResult.forward;
				if (channel.overrideNormal)
				{
					modifiedResult.forward = Vector3.Cross(modifiedResult.right, channel.customNormal);
					modifiedResult.up = channel.customNormal;
				}
				Vector2 vector = channel.NextOffset(modifiedResult.percent);
				Vector3 vector2 = channel.NextExtrudeScale(modifiedResult.percent);
				Vector2 scale = channel.scaleModifier.GetScale(modifiedResult);
				vector2.x *= scale.x;
				vector2.y *= scale.y;
				float num = channel.NextExtrudeRotation(modifiedResult.percent);
				vertexMatrix.SetTRS(modifiedResult.position + right * (base.offset.x + vector.x) * modifiedResult.size + up * (base.offset.y + vector.y) * modifiedResult.size + forward * base.offset.z, modifiedResult.rotation * Quaternion.AngleAxis(base.rotation + num, Vector3.forward), vector2 * modifiedResult.size);
				normalMatrix = vertexMatrix.inverse.transpose;
				if (i == 0)
				{
					lastResult.CopyFrom(evalResult);
				}
				for (int j = 0; j < meshDefinition.vertexGroups[i].ids.Length; j++)
				{
					int num2 = meshDefinition.vertexGroups[i].ids[j];
					zero2 = meshDefinition.vertices[num2];
					zero2.z = 0f;
					target.vertices[num2] = vertexMatrix.MultiplyPoint3x4(zero2);
					zero2 = meshDefinition.normals[num2];
					target.normals[num2] = normalMatrix.MultiplyVector(zero2);
					target.colors[num2] = target.colors[num2] * modifiedResult.color;
					if (target.uv.Length > num2)
					{
						zero = target.uv[num2];
						switch (channel.overrideUVs)
						{
						case Channel.UVOverride.ClampU:
							zero.x = (float)modifiedResult.percent;
							break;
						case Channel.UVOverride.ClampV:
							zero.y = (float)modifiedResult.percent;
							break;
						case Channel.UVOverride.UniformU:
							zero.x = CalculateLength(0.0, ClipPercent(modifiedResult.percent));
							break;
						case Channel.UVOverride.UniformV:
							zero.y = CalculateLength(0.0, ClipPercent(modifiedResult.percent));
							break;
						}
						target.uv[num2] = new Vector2(zero.x * base.uvScale.x * channel.uvScale.x, zero.y * base.uvScale.y * channel.uvScale.y);
						target.uv[num2] += base.uvOffset + channel.uvOffset;
					}
				}
			}
		}
	}
	[AddComponentMenu("Dreamteck/Splines/Morph")]
	public class SplineMorph : MonoBehaviour
	{
		public enum CycleMode
		{
			Default,
			Loop,
			PingPong
		}

		public enum UpdateMode
		{
			Update,
			FixedUpdate,
			LateUpdate
		}

		[Serializable]
		public class Channel
		{
			public enum Interpolation
			{
				Linear,
				Spherical
			}

			[SerializeField]
			internal SplinePoint[] points = new SplinePoint[0];

			[SerializeField]
			internal float percent = 1f;

			public string name = "";

			public AnimationCurve curve;

			public Interpolation interpolation;
		}

		[HideInInspector]
		public SplineComputer.Space space = SplineComputer.Space.Local;

		[HideInInspector]
		public bool cycle;

		[HideInInspector]
		public CycleMode cycleMode;

		[HideInInspector]
		public UpdateMode cycleUpdateMode;

		[HideInInspector]
		public float cycleDuration = 1f;

		[SerializeField]
		[HideInInspector]
		private SplineComputer _spline;

		private SplinePoint[] points = new SplinePoint[0];

		private float cycleValue;

		private short cycleDirection = 1;

		[HideInInspector]
		[SerializeField]
		[FormerlySerializedAs("morphStates")]
		private Channel[] channels = new Channel[0];

		public SplineComputer spline
		{
			get
			{
				return _spline;
			}
			set
			{
				if (UnityEngine.Application.isPlaying && channels.Length != 0 && value.pointCount != channels[0].points.Length)
				{
					value.SetPoints(channels[0].points, space);
				}
				_spline = value;
			}
		}

		private void Reset()
		{
			spline = GetComponent<SplineComputer>();
		}

		private void Update()
		{
			if (cycleUpdateMode == UpdateMode.Update)
			{
				RunUpdate();
			}
		}

		private void FixedUpdate()
		{
			if (cycleUpdateMode == UpdateMode.FixedUpdate)
			{
				RunUpdate();
			}
		}

		private void LateUpdate()
		{
			if (cycleUpdateMode == UpdateMode.LateUpdate)
			{
				RunUpdate();
			}
		}

		private void RunUpdate()
		{
			if (!cycle)
			{
				return;
			}
			if (cycleMode != CycleMode.PingPong)
			{
				cycleDirection = 1;
			}
			cycleValue += Time.deltaTime / cycleDuration * (float)cycleDirection;
			switch (cycleMode)
			{
			case CycleMode.Default:
				if (cycleValue > 1f)
				{
					cycleValue = 1f;
				}
				break;
			case CycleMode.Loop:
				if (cycleValue > 1f)
				{
					cycleValue -= Mathf.Floor(cycleValue);
				}
				break;
			case CycleMode.PingPong:
				if (cycleValue > 1f)
				{
					cycleValue = 1f - (cycleValue - Mathf.Floor(cycleValue));
					cycleDirection = -1;
				}
				else if (cycleValue < 0f)
				{
					cycleValue = 0f - cycleValue - Mathf.Floor(0f - cycleValue);
					cycleDirection = 1;
				}
				break;
			}
			SetWeight(cycleValue, cycleMode == CycleMode.Loop);
		}

		public void SetCycle(float value)
		{
			cycleValue = Mathf.Clamp01(value);
		}

		public void SetWeight(int index, float weight)
		{
			channels[index].percent = Mathf.Clamp01(weight);
			UpdateMorph();
		}

		public void SetWeight(string name, float weight)
		{
			int channelIndex = GetChannelIndex(name);
			channels[channelIndex].percent = Mathf.Clamp01(weight);
			UpdateMorph();
		}

		public void SetWeight(float percent, bool loop = false)
		{
			float num = percent * (float)(loop ? channels.Length : (channels.Length - 1));
			for (int i = 0; i < channels.Length; i++)
			{
				if (Mathf.Abs((float)i - num) > 1f)
				{
					SetWeight(i, 0f);
				}
				else if (num <= (float)i)
				{
					SetWeight(i, 1f - ((float)i - num));
				}
				else
				{
					SetWeight(i, 1f - (num - (float)i));
				}
			}
			if (loop && num >= (float)(channels.Length - 1))
			{
				SetWeight(0, num - (float)(channels.Length - 1));
			}
		}

		public void CaptureSnapshot(string name)
		{
			CaptureSnapshot(GetChannelIndex(name));
		}

		public void CaptureSnapshot(int index)
		{
			if (!(_spline == null))
			{
				if (channels.Length != 0 && _spline.pointCount != channels[0].points.Length && index != 0)
				{
					UnityEngine.Debug.LogError("Point count must be the same as " + _spline.pointCount);
					return;
				}
				channels[index].points = _spline.GetPoints(space);
				UpdateMorph();
			}
		}

		public void Clear()
		{
			channels = new Channel[0];
		}

		public SplinePoint[] GetSnapshot(int index)
		{
			return channels[index].points;
		}

		public SplinePoint[] GetSnapshot(string name)
		{
			int channelIndex = GetChannelIndex(name);
			return channels[channelIndex].points;
		}

		public float GetWeight(int index)
		{
			return channels[index].percent;
		}

		public float GetWeight(string name)
		{
			int channelIndex = GetChannelIndex(name);
			return channels[channelIndex].percent;
		}

		public void AddChannel(string name)
		{
			if (!(_spline == null))
			{
				if (channels.Length != 0 && _spline.pointCount != channels[0].points.Length)
				{
					UnityEngine.Debug.LogError("Point count must be the same as " + channels[0].points.Length);
					return;
				}
				Channel channel = new Channel();
				channel.points = _spline.GetPoints(space);
				channel.name = name;
				channel.curve = new AnimationCurve();
				channel.curve.AddKey(new Keyframe(0f, 0f, 0f, 1f));
				channel.curve.AddKey(new Keyframe(1f, 1f, 1f, 0f));
				ArrayUtility.Add(ref channels, channel);
				UpdateMorph();
			}
		}

		public void RemoveChannel(string name)
		{
			int channelIndex = GetChannelIndex(name);
			RemoveChannel(channelIndex);
		}

		public void RemoveChannel(int index)
		{
			if (index < 0 || index >= channels.Length)
			{
				return;
			}
			Channel[] array = new Channel[channels.Length - 1];
			for (int i = 0; i < channels.Length; i++)
			{
				if (i != index)
				{
					if (i < index)
					{
						array[i] = channels[i];
					}
					else if (i >= index)
					{
						array[i - 1] = channels[i];
					}
				}
			}
			channels = array;
			UpdateMorph();
		}

		private int GetChannelIndex(string name)
		{
			for (int i = 0; i < channels.Length; i++)
			{
				if (channels[i].name == name)
				{
					return i;
				}
			}
			UnityEngine.Debug.Log("Channel not found " + name);
			return 0;
		}

		public int GetChannelCount()
		{
			if (channels == null)
			{
				return 0;
			}
			return channels.Length;
		}

		public Channel GetChannel(int index)
		{
			return channels[index];
		}

		public Channel GetChannel(string name)
		{
			return channels[GetChannelIndex(name)];
		}

		public void UpdateMorph()
		{
			if (_spline == null || channels.Length == 0)
			{
				return;
			}
			if (points.Length != channels[0].points.Length)
			{
				points = new SplinePoint[channels[0].points.Length];
			}
			for (int i = 0; i < channels.Length; i++)
			{
				for (int j = 0; j < points.Length; j++)
				{
					if (i == 0)
					{
						points[j] = channels[0].points[j];
						continue;
					}
					float num = channels[i].curve.Evaluate(channels[i].percent);
					if (channels[i].interpolation == Channel.Interpolation.Linear)
					{
						points[j].position += (channels[i].points[j].position - channels[0].points[j].position) * num;
						points[j].tangent += (channels[i].points[j].tangent - channels[0].points[j].tangent) * num;
						points[j].tangent2 += (channels[i].points[j].tangent2 - channels[0].points[j].tangent2) * num;
						points[j].normal += (channels[i].points[j].normal - channels[0].points[j].normal) * num;
					}
					else
					{
						points[j].position = Vector3.Slerp(points[j].position, points[j].position + (channels[i].points[j].position - channels[0].points[j].position), num);
						points[j].tangent = Vector3.Slerp(points[j].tangent, points[j].tangent + (channels[i].points[j].tangent - channels[0].points[j].tangent), num);
						points[j].tangent2 = Vector3.Slerp(points[j].tangent2, points[j].tangent2 + (channels[i].points[j].tangent2 - channels[0].points[j].tangent2), num);
						points[j].normal = Vector3.Slerp(points[j].normal, points[j].normal + (channels[i].points[j].normal - channels[0].points[j].normal), num);
					}
					points[j].color += (channels[i].points[j].color - channels[0].points[j].color) * num;
					points[j].size += (channels[i].points[j].size - channels[0].points[j].size) * num;
					if (points[j].type == SplinePoint.Type.SmoothMirrored)
					{
						points[j].type = channels[i].points[j].type;
					}
					else if (points[j].type == SplinePoint.Type.SmoothFree && channels[i].points[j].type == SplinePoint.Type.Broken)
					{
						points[j].type = SplinePoint.Type.Broken;
					}
				}
			}
			for (int k = 0; k < points.Length; k++)
			{
				points[k].normal.Normalize();
			}
			_spline.SetPoints(points, space);
		}
	}
	[AddComponentMenu("Dreamteck/Splines/Users/Spline Positioner")]
	public class SplinePositioner : SplineTracer
	{
		public enum Mode
		{
			Percent,
			Distance
		}

		[SerializeField]
		[HideInInspector]
		private GameObject _targetObject;

		[SerializeField]
		[HideInInspector]
		private double _position;

		[SerializeField]
		[HideInInspector]
		private float animPosition;

		[SerializeField]
		[HideInInspector]
		private Mode _mode;

		public GameObject targetObject
		{
			get
			{
				if (_targetObject == null)
				{
					return base.gameObject;
				}
				return _targetObject;
			}
			set
			{
				if (value != _targetObject)
				{
					_targetObject = value;
					RefreshTargets();
					Rebuild();
				}
			}
		}

		public double position
		{
			get
			{
				return _position;
			}
			set
			{
				if (value != _position)
				{
					animPosition = (float)value;
					_position = value;
					if (mode == Mode.Distance)
					{
						SetDistance((float)_position, checkTriggers: true);
					}
					else
					{
						SetPercent(_position, checkTriggers: true);
					}
				}
			}
		}

		public Mode mode
		{
			get
			{
				return _mode;
			}
			set
			{
				if (value != _mode)
				{
					_mode = value;
					Rebuild();
				}
			}
		}

		protected override void OnDidApplyAnimationProperties()
		{
			if ((double)animPosition != _position)
			{
				position = animPosition;
			}
			base.OnDidApplyAnimationProperties();
		}

		protected override Transform GetTransform()
		{
			return targetObject.transform;
		}

		protected override Rigidbody GetRigidbody()
		{
			return targetObject.GetComponent<Rigidbody>();
		}

		protected override Rigidbody2D GetRigidbody2D()
		{
			return targetObject.GetComponent<Rigidbody2D>();
		}

		protected override void PostBuild()
		{
			base.PostBuild();
			if (mode == Mode.Distance)
			{
				SetDistance((float)_position, checkTriggers: true);
			}
			else
			{
				SetPercent(_position, checkTriggers: true);
			}
		}

		public override void SetPercent(double percent, bool checkTriggers = false, bool handleJuncitons = false)
		{
			base.SetPercent(percent, checkTriggers, handleJuncitons);
			_position = percent;
		}

		public override void SetDistance(float distance, bool checkTriggers = false, bool handleJuncitons = false)
		{
			base.SetDistance(distance, checkTriggers, handleJuncitons);
			_position = distance;
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Dreamteck/Splines/Users/Spline Projector")]
	public class SplineProjector : SplineTracer
	{
		public enum Mode
		{
			Accurate,
			Cached
		}

		[SerializeField]
		[HideInInspector]
		private Mode _mode = Mode.Cached;

		[SerializeField]
		[HideInInspector]
		private bool _autoProject = true;

		[SerializeField]
		[HideInInspector]
		[Range(3f, 8f)]
		private int _subdivide = 4;

		[SerializeField]
		[HideInInspector]
		private Transform _projectTarget;

		[SerializeField]
		[HideInInspector]
		private Transform applyTarget;

		[SerializeField]
		[HideInInspector]
		private GameObject _targetObject;

		[SerializeField]
		[HideInInspector]
		public Vector2 _offset;

		[SerializeField]
		[HideInInspector]
		public Vector3 _rotationOffset = Vector3.zero;

		[SerializeField]
		[HideInInspector]
		private Vector3 lastPosition = Vector3.zero;

		public Mode mode
		{
			get
			{
				return _mode;
			}
			set
			{
				if (value != _mode)
				{
					_mode = value;
					Rebuild();
				}
			}
		}

		public bool autoProject
		{
			get
			{
				return _autoProject;
			}
			set
			{
				if (value != _autoProject)
				{
					_autoProject = value;
					if (_autoProject)
					{
						Rebuild();
					}
				}
			}
		}

		public int subdivide
		{
			get
			{
				return _subdivide;
			}
			set
			{
				if (value != _subdivide)
				{
					_subdivide = value;
					if (_mode == Mode.Accurate)
					{
						Rebuild();
					}
				}
			}
		}

		public Transform projectTarget
		{
			get
			{
				if (_projectTarget == null)
				{
					return base.transform;
				}
				return _projectTarget;
			}
			set
			{
				if (value != _projectTarget)
				{
					_projectTarget = value;
					Rebuild();
				}
			}
		}

		public GameObject targetObject
		{
			get
			{
				if (_targetObject == null && applyTarget != null)
				{
					_targetObject = applyTarget.gameObject;
					applyTarget = null;
					return _targetObject;
				}
				return _targetObject;
			}
			set
			{
				if (value != _targetObject)
				{
					_targetObject = value;
					RefreshTargets();
					Rebuild();
				}
			}
		}

		public event SplineReachHandler onEndReached;

		public event SplineReachHandler onBeginningReached;

		protected override void Reset()
		{
			base.Reset();
			_projectTarget = base.transform;
		}

		protected override Transform GetTransform()
		{
			if (targetObject == null)
			{
				return null;
			}
			return targetObject.transform;
		}

		protected override Rigidbody GetRigidbody()
		{
			if (targetObject == null)
			{
				return null;
			}
			return targetObject.GetComponent<Rigidbody>();
		}

		protected override Rigidbody2D GetRigidbody2D()
		{
			if (targetObject == null)
			{
				return null;
			}
			return targetObject.GetComponent<Rigidbody2D>();
		}

		protected override void LateRun()
		{
			base.LateRun();
			if (autoProject && (bool)projectTarget && lastPosition != projectTarget.position)
			{
				lastPosition = projectTarget.position;
				CalculateProjection();
			}
		}

		protected override void PostBuild()
		{
			base.PostBuild();
			CalculateProjection();
		}

		protected override void OnSplineChanged()
		{
			if (base.spline != null)
			{
				if (_mode == Mode.Accurate)
				{
					base.spline.Project(_result, _projectTarget.position, base.clipFrom, base.clipTo, SplineComputer.EvaluateMode.Calculate, subdivide);
				}
				else
				{
					base.spline.Project(_result, _projectTarget.position, base.clipFrom, base.clipTo);
				}
				_result.percent = ClipPercent(_result.percent);
			}
		}

		private void Project()
		{
			if (_mode == Mode.Accurate && base.spline != null)
			{
				base.spline.Project(_result, _projectTarget.position, base.clipFrom, base.clipTo, SplineComputer.EvaluateMode.Calculate, subdivide);
				_result.percent = ClipPercent(_result.percent);
			}
			else
			{
				Project(_projectTarget.position, _result);
			}
		}

		public void CalculateProjection()
		{
			if (_projectTarget == null)
			{
				return;
			}
			double num = _result.percent;
			Project();
			if (this.onBeginningReached != null && _result.percent <= base.clipFrom)
			{
				if (!Mathf.Approximately((float)num, (float)_result.percent))
				{
					this.onBeginningReached();
					if (base.samplesAreLooped)
					{
						CheckTriggers(num, 0.0);
						CheckNodes(num, 0.0);
						num = 1.0;
					}
				}
			}
			else if (this.onEndReached != null && _result.percent >= base.clipTo && !Mathf.Approximately((float)num, (float)_result.percent))
			{
				this.onEndReached();
				if (base.samplesAreLooped)
				{
					CheckTriggers(num, 1.0);
					CheckNodes(num, 1.0);
					num = 0.0;
				}
			}
			CheckTriggers(num, _result.percent);
			CheckNodes(num, _result.percent);
			if (targetObject != null)
			{
				ApplyMotion();
			}
			InvokeTriggers();
			InvokeNodes();
			lastPosition = projectTarget.position;
		}
	}
	[RequireComponent(typeof(MeshFilter))]
	[RequireComponent(typeof(MeshRenderer))]
	[AddComponentMenu("Dreamteck/Splines/Users/Spline Renderer")]
	[ExecuteInEditMode]
	public class SplineRenderer : MeshGenerator
	{
		[HideInInspector]
		public bool autoOrient = true;

		[HideInInspector]
		public int updateFrameInterval;

		private int currentFrame;

		[SerializeField]
		[HideInInspector]
		private int _slices = 1;

		[SerializeField]
		[HideInInspector]
		private Vector3 vertexDirection = Vector3.up;

		private bool orthographic;

		private bool init;

		public int slices
		{
			get
			{
				return _slices;
			}
			set
			{
				if (value != _slices)
				{
					if (value < 1)
					{
						value = 1;
					}
					_slices = value;
					Rebuild();
				}
			}
		}

		protected override void Awake()
		{
			base.Awake();
			mesh.name = "spline";
		}

		private void Start()
		{
			if (Camera.current != null)
			{
				orthographic = Camera.current.orthographic;
			}
		}

		protected override void LateRun()
		{
			if (updateFrameInterval > 0)
			{
				currentFrame++;
				if (currentFrame > updateFrameInterval)
				{
					currentFrame = 0;
				}
			}
		}

		protected override void BuildMesh()
		{
			base.BuildMesh();
			GenerateVertices(vertexDirection, orthographic);
			MeshUtility.GeneratePlaneTriangles(ref tsMesh.triangles, _slices, base.sampleCount, flip: false);
		}

		public void RenderWithCamera(Camera cam)
		{
			if (base.sampleCount == 0)
			{
				return;
			}
			orthographic = true;
			if (cam != null)
			{
				if (cam.orthographic)
				{
					vertexDirection = -cam.transform.forward;
				}
				else
				{
					vertexDirection = cam.transform.position;
				}
				orthographic = cam.orthographic;
			}
			BuildMesh();
			WriteMesh();
		}

		private void OnWillRenderObject()
		{
			if (autoOrient && (updateFrameInterval <= 0 || currentFrame == 0))
			{
				if (!UnityEngine.Application.isPlaying && !init)
				{
					Awake();
					init = true;
				}
				RenderWithCamera(Camera.current);
			}
		}

		public void GenerateVertices(Vector3 vertexDirection, bool orthoGraphic)
		{
			AllocateMesh((_slices + 1) * base.sampleCount, _slices * (base.sampleCount - 1) * 6);
			int num = 0;
			ResetUVDistance();
			bool flag = base.offset != Vector3.zero;
			for (int i = 0; i < base.sampleCount; i++)
			{
				GetSample(i, evalResult);
				Vector3 position = evalResult.position;
				if (flag)
				{
					position += base.offset.x * -Vector3.Cross(evalResult.forward, evalResult.up) + base.offset.y * evalResult.up + base.offset.z * evalResult.forward;
				}
				Vector3 vector = ((!orthoGraphic) ? (vertexDirection - position).normalized : vertexDirection);
				Vector3 normalized = Vector3.Cross(evalResult.forward, vector).normalized;
				if (base.uvMode == UVMode.UniformClamp || base.uvMode == UVMode.UniformClip)
				{
					AddUVDistance(i);
				}
				Color color = evalResult.color * base.color;
				for (int j = 0; j < _slices + 1; j++)
				{
					float num2 = (float)j / (float)_slices;
					tsMesh.vertices[num] = position - normalized * evalResult.size * 0.5f * base.size + normalized * evalResult.size * num2 * base.size;
					CalculateUVs(evalResult.percent, num2);
					tsMesh.uv[num] = Vector2.one * 0.5f + (Vector2)(Quaternion.AngleAxis(base.uvRotation, Vector3.forward) * (Vector2.one * 0.5f - MeshGenerator.uvs));
					tsMesh.normals[num] = vector;
					tsMesh.colors[num] = color;
					num++;
				}
			}
		}
	}
	public class SplineTracer : SplineUser
	{
		public class NodeConnection
		{
			public Node node;

			public int point;

			public NodeConnection(Node node, int point)
			{
				this.node = node;
				this.point = point;
			}
		}

		public enum PhysicsMode
		{
			Transform,
			Rigidbody,
			Rigidbody2D
		}

		public delegate void JunctionHandler(List<NodeConnection> passed);

		private SplineTrigger[] triggerInvokeQueue = new SplineTrigger[0];

		private List<NodeConnection> nodeConnectionQueue = new List<NodeConnection>();

		private int addTriggerIndex;

		[HideInInspector]
		public bool applyDirectionRotation = true;

		[HideInInspector]
		public bool useTriggers;

		[HideInInspector]
		public int triggerGroup;

		[SerializeField]
		[HideInInspector]
		protected Spline.Direction _direction = Spline.Direction.Forward;

		[SerializeField]
		[HideInInspector]
		protected PhysicsMode _physicsMode;

		[SerializeField]
		[HideInInspector]
		protected TransformModule _motion;

		[SerializeField]
		[HideInInspector]
		protected Rigidbody targetRigidbody;

		[SerializeField]
		[HideInInspector]
		protected Rigidbody2D targetRigidbody2D;

		[SerializeField]
		[HideInInspector]
		protected Transform targetTransform;

		[SerializeField]
		[HideInInspector]
		protected SplineSample _result = new SplineSample();

		[SerializeField]
		[HideInInspector]
		protected SplineSample _finalResult = new SplineSample();

		private bool setPercentOnRebuild;

		private double targetPercentOnRebuild;

		private const double MIN_DELTA = 1E-06;

		public PhysicsMode physicsMode
		{
			get
			{
				return _physicsMode;
			}
			set
			{
				_physicsMode = value;
				RefreshTargets();
			}
		}

		public TransformModule motion
		{
			get
			{
				if (_motion == null)
				{
					_motion = new TransformModule();
				}
				return _motion;
			}
		}

		public SplineSample result => _result;

		public SplineSample modifiedResult => _finalResult;

		public Spline.Direction direction
		{
			get
			{
				return _direction;
			}
			set
			{
				if (value != _direction)
				{
					_direction = value;
					ApplyMotion();
				}
			}
		}

		public event JunctionHandler onNode;

		public event EmptySplineHandler onMotionApplied;

		protected virtual void Start()
		{
			RefreshTargets();
		}

		public virtual void SetPercent(double percent, bool checkTriggers = false, bool handleJunctions = false)
		{
			if (base.sampleCount != 0)
			{
				double percent2 = _result.percent;
				Evaluate(percent, _result);
				ApplyMotion();
				if (checkTriggers)
				{
					CheckTriggers(percent2, percent);
					InvokeTriggers();
				}
				if (handleJunctions)
				{
					CheckNodes(percent2, percent);
				}
			}
		}

		public virtual void SetDistance(float distance, bool checkTriggers = false, bool handleJunctions = false)
		{
			if (base.sampleCount != 0)
			{
				double percent = _result.percent;
				Evaluate(Travel(0.0, distance), _result);
				ApplyMotion();
				if (checkTriggers)
				{
					CheckTriggers(percent, _result.percent);
					InvokeTriggers();
				}
				if (handleJunctions)
				{
					CheckNodes(percent, _result.percent);
				}
			}
		}

		protected override void PostBuild()
		{
			if (setPercentOnRebuild)
			{
				SetPercent(targetPercentOnRebuild);
				setPercentOnRebuild = false;
			}
		}

		protected virtual Rigidbody GetRigidbody()
		{
			return GetComponent<Rigidbody>();
		}

		protected virtual Rigidbody2D GetRigidbody2D()
		{
			return GetComponent<Rigidbody2D>();
		}

		protected virtual Transform GetTransform()
		{
			return base.transform;
		}

		protected void ApplyMotion()
		{
			ModifySample(_result, _finalResult);
			motion.targetUser = this;
			motion.splineResult = _finalResult;
			if (applyDirectionRotation)
			{
				motion.direction = _direction;
			}
			else
			{
				motion.direction = Spline.Direction.Forward;
			}
			switch (_physicsMode)
			{
			case PhysicsMode.Transform:
				if (targetTransform == null)
				{
					RefreshTargets();
				}
				if (!(targetTransform == null))
				{
					motion.ApplyTransform(targetTransform);
					if (this.onMotionApplied != null)
					{
						this.onMotionApplied();
					}
				}
				break;
			case PhysicsMode.Rigidbody:
				if (targetRigidbody == null)
				{
					RefreshTargets();
					if (targetRigidbody == null)
					{
						throw new MissingComponentException("There is no Rigidbody attached to " + base.name + " but the Physics mode is set to use one.");
					}
				}
				motion.ApplyRigidbody(targetRigidbody);
				if (this.onMotionApplied != null)
				{
					this.onMotionApplied();
				}
				break;
			case PhysicsMode.Rigidbody2D:
				if (targetRigidbody2D == null)
				{
					RefreshTargets();
					if (targetRigidbody2D == null)
					{
						throw new MissingComponentException("There is no Rigidbody2D attached to " + base.name + " but the Physics mode is set to use one.");
					}
				}
				motion.ApplyRigidbody2D(targetRigidbody2D);
				if (this.onMotionApplied != null)
				{
					this.onMotionApplied();
				}
				break;
			}
		}

		protected void CheckNodes(double from, double to)
		{
			if (this.onNode == null || from == to)
			{
				return;
			}
			UnclipPercent(ref from);
			UnclipPercent(ref to);
			Spline.FormatFromTo(ref from, ref to);
			int num = base.spline.PercentToPointIndex(from, _direction);
			int num2 = base.spline.PercentToPointIndex(to, _direction);
			if (num != num2)
			{
				if (_direction == Spline.Direction.Forward)
				{
					for (int i = num + 1; i <= num2; i++)
					{
						NodeConnection junction = GetJunction(i);
						if (junction != null)
						{
							nodeConnectionQueue.Add(junction);
						}
					}
					return;
				}
				for (int num3 = num2 - 1; num3 >= num; num3--)
				{
					NodeConnection junction2 = GetJunction(num3);
					if (junction2 != null)
					{
						nodeConnectionQueue.Add(junction2);
					}
				}
			}
			else if (from < 1E-06 && to > from)
			{
				NodeConnection junction3 = GetJunction(0);
				if (junction3 != null)
				{
					nodeConnectionQueue.Add(junction3);
				}
			}
			else if (to > 0.999999 && from < to)
			{
				NodeConnection junction4 = GetJunction(base.spline.pointCount - 1);
				if (junction4 != null)
				{
					nodeConnectionQueue.Add(junction4);
				}
			}
		}

		protected void InvokeNodes()
		{
			if (nodeConnectionQueue.Count > 0)
			{
				this.onNode(nodeConnectionQueue);
				nodeConnectionQueue.Clear();
			}
		}

		protected void CheckTriggers(double from, double to)
		{
			if (!useTriggers || from == to)
			{
				return;
			}
			UnclipPercent(ref from);
			UnclipPercent(ref to);
			if (triggerGroup < 0 || triggerGroup >= base.spline.triggerGroups.Length)
			{
				return;
			}
			for (int i = 0; i < base.spline.triggerGroups[triggerGroup].triggers.Length; i++)
			{
				if (base.spline.triggerGroups[triggerGroup].triggers[i] != null && base.spline.triggerGroups[triggerGroup].triggers[i].Check(from, to))
				{
					AddTriggerToQueue(base.spline.triggerGroups[triggerGroup].triggers[i]);
				}
			}
		}

		private NodeConnection GetJunction(int pointIndex)
		{
			Node node = base.spline.GetNode(pointIndex);
			if (node == null)
			{
				return null;
			}
			return new NodeConnection(node, pointIndex);
		}

		protected void InvokeTriggers()
		{
			for (int i = 0; i < addTriggerIndex; i++)
			{
				if (triggerInvokeQueue[i] != null)
				{
					triggerInvokeQueue[i].Invoke(this);
				}
			}
			addTriggerIndex = 0;
		}

		protected void RefreshTargets()
		{
			switch (_physicsMode)
			{
			case PhysicsMode.Transform:
				targetTransform = GetTransform();
				break;
			case PhysicsMode.Rigidbody:
				targetRigidbody = GetRigidbody();
				break;
			case PhysicsMode.Rigidbody2D:
				targetRigidbody2D = GetRigidbody2D();
				break;
			}
		}

		private void AddTriggerToQueue(SplineTrigger trigger)
		{
			if (addTriggerIndex >= triggerInvokeQueue.Length)
			{
				SplineTrigger[] array = new SplineTrigger[triggerInvokeQueue.Length + base.spline.triggerGroups[triggerGroup].triggers.Length];
				triggerInvokeQueue.CopyTo(array, 0);
				triggerInvokeQueue = array;
			}
			triggerInvokeQueue[addTriggerIndex] = trigger;
			addTriggerIndex++;
		}
	}
	[ExecuteInEditMode]
	public class SplineUser : MonoBehaviour
	{
		public enum UpdateMethod
		{
			Update,
			FixedUpdate,
			LateUpdate
		}

		[HideInInspector]
		public UpdateMethod updateMethod;

		[SerializeField]
		[HideInInspector]
		[FormerlySerializedAs("_computer")]
		private SplineComputer _spline;

		[SerializeField]
		[HideInInspector]
		private bool _autoUpdate = true;

		[SerializeField]
		[HideInInspector]
		protected RotationModifier _rotationModifier = new RotationModifier();

		[SerializeField]
		[HideInInspector]
		protected OffsetModifier _offsetModifier = new OffsetModifier();

		[SerializeField]
		[HideInInspector]
		protected ColorModifier _colorModifier = new ColorModifier();

		[SerializeField]
		[HideInInspector]
		protected SizeModifier _sizeModifier = new SizeModifier();

		[SerializeField]
		[HideInInspector]
		private SampleCollection sampleCollection = new SampleCollection();

		[SerializeField]
		[HideInInspector]
		private SplineSample clipFromSample = new SplineSample();

		[SerializeField]
		[HideInInspector]
		private SplineSample clipToSample = new SplineSample();

		[SerializeField]
		[HideInInspector]
		private float animClipFrom;

		[SerializeField]
		[HideInInspector]
		private float animClipTo = 1f;

		private bool rebuild;

		private bool getSamples;

		private bool postBuild;

		protected Transform trs;

		[SerializeField]
		[HideInInspector]
		private int _sampleCount;

		[SerializeField]
		[HideInInspector]
		private int startSampleIndex;

		protected SplineSample evalResult = new SplineSample();

		[HideInInspector]
		public volatile bool multithreaded;

		[HideInInspector]
		public bool buildOnAwake;

		[HideInInspector]
		public bool buildOnEnable;

		public SplineComputer spline
		{
			get
			{
				return _spline;
			}
			set
			{
				if (value != _spline)
				{
					if (_spline != null)
					{
						_spline.Unsubscribe(this);
					}
					_spline = value;
					if (_spline != null)
					{
						_spline.Subscribe(this);
						Rebuild();
					}
					OnSplineChanged();
				}
			}
		}

		public double clipFrom
		{
			get
			{
				return sampleCollection.clipFrom;
			}
			set
			{
				if (value != sampleCollection.clipFrom)
				{
					animClipFrom = (float)sampleCollection.clipFrom;
					sampleCollection.clipFrom = DMath.Clamp01(value);
					if (sampleCollection.clipFrom > sampleCollection.clipTo && !_spline.isClosed)
					{
						sampleCollection.clipTo = sampleCollection.clipFrom;
					}
					getSamples = true;
					Rebuild();
				}
			}
		}

		public double clipTo
		{
			get
			{
				return sampleCollection.clipTo;
			}
			set
			{
				if (value != sampleCollection.clipTo)
				{
					animClipTo = (float)sampleCollection.clipTo;
					sampleCollection.clipTo = DMath.Clamp01(value);
					if (sampleCollection.clipTo < sampleCollection.clipFrom && !_spline.isClosed)
					{
						sampleCollection.clipFrom = sampleCollection.clipTo;
					}
					getSamples = true;
					Rebuild();
				}
			}
		}

		public bool autoUpdate
		{
			get
			{
				return _autoUpdate;
			}
			set
			{
				if (value != _autoUpdate)
				{
					_autoUpdate = value;
					if (value)
					{
						Rebuild();
					}
				}
			}
		}

		public bool loopSamples
		{
			get
			{
				return sampleCollection.loopSamples;
			}
			set
			{
				if (value != sampleCollection.loopSamples)
				{
					sampleCollection.loopSamples = value;
					if (!sampleCollection.loopSamples && sampleCollection.clipTo < sampleCollection.clipFrom)
					{
						double num = sampleCollection.clipTo;
						sampleCollection.clipTo = sampleCollection.clipFrom;
						sampleCollection.clipFrom = num;
					}
					Rebuild();
				}
			}
		}

		public double span
		{
			get
			{
				if (samplesAreLooped)
				{
					return 1.0 - sampleCollection.clipFrom + sampleCollection.clipTo;
				}
				return sampleCollection.clipTo - sampleCollection.clipFrom;
			}
		}

		public bool samplesAreLooped => sampleCollection.samplesAreLooped;

		public RotationModifier rotationModifier => _rotationModifier;

		public OffsetModifier offsetModifier => _offsetModifier;

		public ColorModifier colorModifier => _colorModifier;

		public SizeModifier sizeModifier => _sizeModifier;

		public int sampleCount => _sampleCount;

		protected virtual void Awake()
		{
			trs = base.transform;
			if (spline == null)
			{
				spline = GetComponent<SplineComputer>();
			}
			else if (!spline.IsSubscribed(this))
			{
				spline.Subscribe(this);
			}
			if (buildOnAwake)
			{
				RebuildImmediate();
			}
		}

		protected virtual void Reset()
		{
		}

		protected virtual void OnEnable()
		{
			if (spline != null)
			{
				spline.Subscribe(this);
			}
			if (buildOnEnable)
			{
				RebuildImmediate();
			}
		}

		protected virtual void OnDisable()
		{
			if (spline != null)
			{
				spline.Unsubscribe(this);
			}
		}

		protected virtual void OnDestroy()
		{
		}

		protected virtual void OnDidApplyAnimationProperties()
		{
			bool flag = false;
			if (sampleCollection.clipFrom != (double)animClipFrom || sampleCollection.clipTo != (double)animClipTo)
			{
				flag = true;
			}
			sampleCollection.clipFrom = animClipFrom;
			sampleCollection.clipTo = animClipTo;
			Rebuild();
			if (flag)
			{
				GetSamples();
			}
		}

		public SplineSample GetSampleRaw(int index)
		{
			if (index >= _sampleCount)
			{
				index = _sampleCount - 1;
			}
			if (sampleCollection.samplesAreLooped)
			{
				sampleCollection.GetSamplingValues(clipFrom, out var sampleIndex, out var lerp);
				sampleCollection.GetSamplingValues(clipTo, out var sampleIndex2, out lerp);
				if (index == 0)
				{
					return clipFromSample;
				}
				int num = sampleIndex2;
				if (lerp > 0.0)
				{
					num++;
				}
				if (index == _sampleCount - 1)
				{
					return clipToSample;
				}
				int num2 = sampleIndex + index;
				if (num2 >= sampleCollection.Count)
				{
					num2 -= sampleCollection.Count;
				}
				return sampleCollection.samples[num2];
			}
			if (index == 0)
			{
				return clipFromSample;
			}
			if (index == _sampleCount - 1)
			{
				return clipToSample;
			}
			return sampleCollection.samples[startSampleIndex + index];
		}

		public void GetSample(int index, SplineSample target)
		{
			ModifySample(GetSampleRaw(index), target);
		}

		public virtual void Rebuild()
		{
			if (autoUpdate)
			{
				rebuild = (getSamples = true);
			}
		}

		public virtual void RebuildImmediate()
		{
			try
			{
				GetSamples();
				Build();
				PostBuild();
			}
			catch (Exception ex)
			{
				UnityEngine.Debug.Log(ex.Message);
			}
			rebuild = false;
			getSamples = false;
		}

		private void Update()
		{
			if (updateMethod == UpdateMethod.Update)
			{
				Run();
				RunUpdate();
				LateRun();
			}
		}

		private void LateUpdate()
		{
			if (updateMethod == UpdateMethod.LateUpdate)
			{
				Run();
				RunUpdate();
				LateRun();
			}
		}

		private void FixedUpdate()
		{
			if (updateMethod == UpdateMethod.FixedUpdate)
			{
				Run();
				RunUpdate();
				LateRun();
			}
		}

		private void RunUpdate()
		{
			if (rebuild)
			{
				if (multithreaded)
				{
					if (getSamples)
					{
						SplineThreading.Run(ResampleAndBuildThreaded);
					}
					else
					{
						SplineThreading.Run(BuildThreaded);
					}
				}
				else
				{
					if (getSamples || spline.sampleMode == SplineComputer.SampleMode.Optimized)
					{
						GetSamples();
					}
					Build();
					postBuild = true;
				}
				rebuild = false;
			}
			if (postBuild)
			{
				PostBuild();
				postBuild = false;
			}
		}

		private void BuildThreaded()
		{
			Build();
			postBuild = true;
		}

		private void ResampleAndBuildThreaded()
		{
			GetSamples();
			Build();
			postBuild = true;
		}

		protected virtual void Run()
		{
		}

		protected virtual void LateRun()
		{
		}

		protected virtual void Build()
		{
		}

		protected virtual void PostBuild()
		{
		}

		protected virtual void OnSplineChanged()
		{
		}

		public void ModifySample(SplineSample source, SplineSample destination)
		{
			destination.CopyFrom(source);
			ModifySample(destination);
		}

		public void ModifySample(SplineSample sample)
		{
			offsetModifier.Apply(sample);
			_rotationModifier.Apply(sample);
			_colorModifier.Apply(sample);
			_sizeModifier.Apply(sample);
		}

		public void SetClipRange(double from, double to)
		{
			if (!_spline.isClosed && to < from)
			{
				to = from;
			}
			sampleCollection.clipFrom = DMath.Clamp01(from);
			sampleCollection.clipTo = DMath.Clamp01(to);
			GetSamples();
			Rebuild();
		}

		private void GetSamples()
		{
			if (!(spline == null))
			{
				getSamples = false;
				spline.GetSamples(sampleCollection);
				sampleCollection.Evaluate(0.0, clipFromSample);
				sampleCollection.Evaluate(1.0, clipToSample);
				_sampleCount = sampleCollection.GetClippedSampleCount(out var _, out var _);
				sampleCollection.GetSamplingValues(sampleCollection.clipFrom, out startSampleIndex, out var _);
			}
		}

		public double ClipPercent(double percent)
		{
			ClipPercent(ref percent);
			return percent;
		}

		public void ClipPercent(ref double percent)
		{
			sampleCollection.ClipPercent(ref percent);
		}

		public double UnclipPercent(double percent)
		{
			UnclipPercent(ref percent);
			return percent;
		}

		public void UnclipPercent(ref double percent)
		{
			sampleCollection.UnclipPercent(ref percent);
		}

		private int GetSampleIndex(double percent)
		{
			return DMath.FloorInt(percent * (double)(sampleCollection.Count - 1));
		}

		public Vector3 EvaluatePosition(double percent)
		{
			return sampleCollection.EvaluatePosition(percent);
		}

		public void Evaluate(double percent, SplineSample result)
		{
			sampleCollection.Evaluate(percent, result);
			result.percent = DMath.Clamp01(percent);
		}

		public SplineSample Evaluate(double percent)
		{
			SplineSample splineSample = new SplineSample();
			Evaluate(percent, splineSample);
			splineSample.percent = DMath.Clamp01(percent);
			return splineSample;
		}

		public void Evaluate(ref SplineSample[] results, double from = 0.0, double to = 1.0)
		{
			sampleCollection.Evaluate(ref results, from, to);
			for (int i = 0; i < results.Length; i++)
			{
				ClipPercent(ref results[i].percent);
			}
		}

		public void EvaluatePositions(ref Vector3[] positions, double from = 0.0, double to = 1.0)
		{
			sampleCollection.EvaluatePositions(ref positions, from, to);
		}

		public double Travel(double start, float distance, Spline.Direction direction, out float moved)
		{
			moved = 0f;
			if (direction == Spline.Direction.Forward && start >= 1.0)
			{
				return 1.0;
			}
			if (direction == Spline.Direction.Backward && start <= 0.0)
			{
				return 0.0;
			}
			if (distance == 0f)
			{
				return DMath.Clamp01(start);
			}
			double percent = sampleCollection.Travel(start, distance, direction, out moved);
			return ClipPercent(percent);
		}

		public double Travel(double start, float distance, Spline.Direction direction = Spline.Direction.Forward)
		{
			float moved;
			return Travel(start, distance, direction, out moved);
		}

		public virtual void Project(Vector3 position, SplineSample result, double from = 0.0, double to = 1.0)
		{
			if (!(_spline == null))
			{
				sampleCollection.Project(position, _spline.pointCount, result, from, to);
				ClipPercent(ref result.percent);
			}
		}

		public float CalculateLength(double from = 0.0, double to = 1.0)
		{
			return sampleCollection.CalculateLength(from, to);
		}
	}
	[RequireComponent(typeof(MeshFilter))]
	[RequireComponent(typeof(MeshRenderer))]
	[AddComponentMenu("Dreamteck/Splines/Users/Surface Generator")]
	public class SurfaceGenerator : MeshGenerator
	{
		[SerializeField]
		[HideInInspector]
		private float _expand;

		[SerializeField]
		[HideInInspector]
		private float _extrude;

		[SerializeField]
		[HideInInspector]
		private Vector2 _sideUvScale = Vector2.one;

		[SerializeField]
		[HideInInspector]
		private Vector2 _sideUvOffset = Vector2.zero;

		[SerializeField]
		[HideInInspector]
		private SplineComputer _extrudeSpline;

		[SerializeField]
		[HideInInspector]
		private SplineSample[] extrudeResults = new SplineSample[0];

		[SerializeField]
		[HideInInspector]
		private Vector3[] identityVertices = new Vector3[0];

		[SerializeField]
		[HideInInspector]
		private Vector3[] identityNormals = new Vector3[0];

		[SerializeField]
		[HideInInspector]
		private Vector2[] projectedVerts = new Vector2[0];

		[SerializeField]
		[HideInInspector]
		private int[] surfaceTris = new int[0];

		[SerializeField]
		[HideInInspector]
		private int[] wallTris = new int[0];

		[SerializeField]
		[HideInInspector]
		private double _extrudeFrom;

		[SerializeField]
		[HideInInspector]
		private double _extrudeTo = 1.0;

		[SerializeField]
		[HideInInspector]
		private bool _uniformUvs;

		public float expand
		{
			get
			{
				return _expand;
			}
			set
			{
				if (value != _expand)
				{
					_expand = value;
					Rebuild();
				}
			}
		}

		public float extrude
		{
			get
			{
				return _extrude;
			}
			set
			{
				if (value != _extrude)
				{
					_extrude = value;
					Rebuild();
				}
			}
		}

		public double extrudeClipFrom
		{
			get
			{
				return _extrudeFrom;
			}
			set
			{
				if (value != _extrudeFrom)
				{
					_extrudeFrom = value;
					Rebuild();
				}
			}
		}

		public double extrudeClipTo
		{
			get
			{
				return _extrudeTo;
			}
			set
			{
				if (value != _extrudeTo)
				{
					_extrudeTo = value;
					Rebuild();
				}
			}
		}

		public Vector2 sideUvScale
		{
			get
			{
				return _sideUvScale;
			}
			set
			{
				if (value != _sideUvScale)
				{
					_sideUvScale = value;
					Rebuild();
				}
				else
				{
					_sideUvScale = value;
				}
			}
		}

		public Vector2 sideUvOffset
		{
			get
			{
				return _sideUvOffset;
			}
			set
			{
				if (value != _sideUvOffset)
				{
					_sideUvOffset = value;
					Rebuild();
				}
				else
				{
					_sideUvOffset = value;
				}
			}
		}

		public SplineComputer extrudeSpline
		{
			get
			{
				return _extrudeSpline;
			}
			set
			{
				if (value != _extrudeSpline)
				{
					if (_extrudeSpline != null)
					{
						_extrudeSpline.Unsubscribe(this);
					}
					_extrudeSpline = value;
					if (value != null)
					{
						_extrudeSpline.Subscribe(this);
					}
					Rebuild();
				}
			}
		}

		public bool uniformUvs
		{
			get
			{
				return _uniformUvs;
			}
			set
			{
				if (value != _uniformUvs)
				{
					_uniformUvs = value;
					Rebuild();
				}
			}
		}

		protected override void Awake()
		{
			base.Awake();
			mesh.name = "surface";
		}

		protected override void BuildMesh()
		{
			if (base.spline.pointCount != 0)
			{
				base.BuildMesh();
				Generate();
			}
		}

		public void Generate()
		{
			int num = base.sampleCount;
			if (base.spline.isClosed)
			{
				num--;
			}
			int num2 = num;
			if ((bool)_extrudeSpline)
			{
				_extrudeSpline.Evaluate(ref extrudeResults, _extrudeFrom, _extrudeTo);
			}
			bool flag = (bool)_extrudeSpline && extrudeResults.Length != 0;
			bool flag2 = !flag && _extrude != 0f;
			if (flag)
			{
				num2 *= 2;
				num2 += base.sampleCount * extrudeResults.Length;
			}
			else if (flag2)
			{
				num2 *= 4;
				num2 += 2;
			}
			GetProjectedVertices(num, out var center, out var normal);
			bool flag3 = IsClockwise(projectedVerts);
			bool flag4 = false;
			bool flag5 = false;
			if (!flag3)
			{
				flag5 = !flag5;
			}
			if (flag2 && _extrude < 0f)
			{
				flag4 = !flag4;
				flag5 = !flag5;
			}
			GenerateSurfaceTris(flag4);
			int num3 = surfaceTris.Length;
			if (flag2)
			{
				num3 *= 2;
				num3 += 2 * base.sampleCount * 2 * 3;
			}
			else
			{
				num3 *= 2;
				num3 += extrudeResults.Length * base.sampleCount * 2 * 3;
			}
			AllocateMesh(num2, num3);
			Vector3 vector = trs.right * base.offset.x + trs.up * base.offset.y + trs.forward * base.offset.z;
			for (int i = 0; i < num; i++)
			{
				GetSample(i, evalResult);
				tsMesh.vertices[i] = evalResult.position + vector;
				tsMesh.normals[i] = evalResult.up;
				tsMesh.colors[i] = evalResult.color * base.color;
			}
			Vector2 vector2 = projectedVerts[0];
			Vector2 vector3 = projectedVerts[0];
			for (int j = 1; j < projectedVerts.Length; j++)
			{
				if (vector2.x < projectedVerts[j].x)
				{
					vector2.x = projectedVerts[j].x;
				}
				if (vector2.y < projectedVerts[j].y)
				{
					vector2.y = projectedVerts[j].y;
				}
				if (vector3.x > projectedVerts[j].x)
				{
					vector3.x = projectedVerts[j].x;
				}
				if (vector3.y > projectedVerts[j].y)
				{
					vector3.y = projectedVerts[j].y;
				}
			}
			for (int k = 0; k < projectedVerts.Length; k++)
			{
				tsMesh.uv[k].x = Mathf.InverseLerp(vector3.x, vector2.x, projectedVerts[k].x) * base.uvScale.x - base.uvScale.x * 0.5f + base.uvOffset.x + 0.5f;
				tsMesh.uv[k].y = Mathf.InverseLerp(vector2.y, vector3.y, projectedVerts[k].y) * base.uvScale.y - base.uvScale.y * 0.5f + base.uvOffset.y + 0.5f;
			}
			if (flag4)
			{
				for (int l = 0; l < num; l++)
				{
					tsMesh.normals[l] *= -1f;
				}
			}
			if (_expand != 0f)
			{
				for (int m = 0; m < num; m++)
				{
					GetSample(m, evalResult);
					tsMesh.vertices[m] += (flag3 ? (-evalResult.right) : evalResult.right) * _expand;
				}
			}
			if (flag)
			{
				GetIdentityVerts(center, normal, flag3);
				for (int n = 0; n < num; n++)
				{
					tsMesh.vertices[n + num] = extrudeResults[0].position + extrudeResults[0].rotation * identityVertices[n] + vector;
					tsMesh.normals[n + num] = -extrudeResults[0].forward;
					tsMesh.colors[n + num] = tsMesh.colors[n] * extrudeResults[0].color;
					tsMesh.uv[n + num] = new Vector2(1f - tsMesh.uv[n].x, tsMesh.uv[n].y);
					tsMesh.vertices[n] = extrudeResults[extrudeResults.Length - 1].position + extrudeResults[extrudeResults.Length - 1].rotation * identityVertices[n] + vector;
					tsMesh.normals[n] = extrudeResults[extrudeResults.Length - 1].forward;
					tsMesh.colors[n] *= extrudeResults[extrudeResults.Length - 1].color;
				}
				float num4 = 0f;
				for (int num5 = 0; num5 < extrudeResults.Length; num5++)
				{
					if (_uniformUvs && num5 > 0)
					{
						num4 += Vector3.Distance(extrudeResults[num5].position, extrudeResults[num5 - 1].position);
					}
					int num6 = num * 2 + num5 * base.sampleCount;
					for (int num7 = 0; num7 < identityVertices.Length; num7++)
					{
						tsMesh.vertices[num6 + num7] = extrudeResults[num5].position + extrudeResults[num5].rotation * identityVertices[num7] + vector;
						tsMesh.normals[num6 + num7] = extrudeResults[num5].rotation * identityNormals[num7];
						if (_uniformUvs)
						{
							tsMesh.uv[num6 + num7] = new Vector2((float)num7 / (float)(identityVertices.Length - 1) * _sideUvScale.x + _sideUvOffset.x, num4 * _sideUvScale.y + _sideUvOffset.y);
						}
						else
						{
							tsMesh.uv[num6 + num7] = new Vector2((float)num7 / (float)(identityVertices.Length - 1) * _sideUvScale.x + _sideUvOffset.x, (float)num5 / (float)(extrudeResults.Length - 1) * _sideUvScale.y + _sideUvOffset.y);
						}
						if (flag3)
						{
							tsMesh.uv[num6 + num7].x = 1f - tsMesh.uv[num6 + num7].x;
						}
					}
				}
				int trisOffset = WriteTris(ref surfaceTris, ref tsMesh.triangles, 0, 0, flip: false);
				trisOffset = WriteTris(ref surfaceTris, ref tsMesh.triangles, num, trisOffset, flip: true);
				MeshUtility.GeneratePlaneTriangles(ref wallTris, base.sampleCount - 1, extrudeResults.Length, flag5, 0, 0, reallocateArray: true);
				WriteTris(ref wallTris, ref tsMesh.triangles, num * 2, trisOffset, flip: false);
			}
			else if (flag2)
			{
				for (int num8 = 0; num8 < num; num8++)
				{
					tsMesh.vertices[num8 + num] = tsMesh.vertices[num8];
					tsMesh.normals[num8 + num] = -tsMesh.normals[num8];
					tsMesh.colors[num8 + num] = tsMesh.colors[num8];
					tsMesh.uv[num8 + num] = new Vector2(1f - tsMesh.uv[num8].x, tsMesh.uv[num8].y);
					tsMesh.vertices[num8] += normal * _extrude;
				}
				for (int num9 = 0; num9 < num + 1; num9++)
				{
					int num10 = num9;
					if (num9 >= num)
					{
						num10 = num9 - num;
					}
					GetSample(num10, evalResult);
					tsMesh.vertices[num9 + num * 2] = tsMesh.vertices[num10] - normal * _extrude;
					tsMesh.normals[num9 + num * 2] = (flag3 ? (-evalResult.right) : evalResult.right);
					tsMesh.colors[num9 + num * 2] = tsMesh.colors[num10];
					tsMesh.uv[num9 + num * 2] = new Vector2((float)num9 / (float)(num - 1) * _sideUvScale.x + _sideUvOffset.x, 0f + _sideUvOffset.y);
					if (flag3)
					{
						tsMesh.uv[num9 + num * 2].x = 1f - tsMesh.uv[num9 + num * 2].x;
					}
					int num11 = num9 + num * 3 + 1;
					tsMesh.vertices[num11] = tsMesh.vertices[num10];
					tsMesh.normals[num11] = tsMesh.normals[num9 + num * 2];
					tsMesh.colors[num11] = tsMesh.colors[num10];
					if (_uniformUvs)
					{
						tsMesh.uv[num11] = new Vector2((float)num9 / (float)num * _sideUvScale.x + _sideUvOffset.x, _extrude * _sideUvScale.y + _sideUvOffset.y);
					}
					else
					{
						tsMesh.uv[num11] = new Vector2((float)num9 / (float)num * _sideUvScale.x + _sideUvOffset.x, 1f * _sideUvScale.y + _sideUvOffset.y);
					}
					if (flag3)
					{
						tsMesh.uv[num11].x = 1f - tsMesh.uv[num11].x;
					}
				}
				int trisOffset2 = WriteTris(ref surfaceTris, ref tsMesh.triangles, 0, 0, flip: false);
				trisOffset2 = WriteTris(ref surfaceTris, ref tsMesh.triangles, num, trisOffset2, flip: true);
				MeshUtility.GeneratePlaneTriangles(ref wallTris, base.sampleCount - 1, 2, flag5, 0, 0, reallocateArray: true);
				WriteTris(ref wallTris, ref tsMesh.triangles, num * 2, trisOffset2, flip: false);
			}
			else
			{
				WriteTris(ref surfaceTris, ref tsMesh.triangles, 0, 0, flip: false);
			}
		}

		private void GenerateSurfaceTris(bool flip)
		{
			MeshUtility.Triangulate(projectedVerts, ref surfaceTris);
			if (flip)
			{
				MeshUtility.FlipTriangles(ref surfaceTris);
			}
		}

		private int WriteTris(ref int[] tris, ref int[] target, int vertexOffset, int trisOffset, bool flip)
		{
			for (int i = trisOffset; i < trisOffset + tris.Length; i += 3)
			{
				if (flip)
				{
					target[i] = tris[i + 2 - trisOffset] + vertexOffset;
					target[i + 1] = tris[i + 1 - trisOffset] + vertexOffset;
					target[i + 2] = tris[i - trisOffset] + vertexOffset;
				}
				else
				{
					target[i] = tris[i - trisOffset] + vertexOffset;
					target[i + 1] = tris[i + 1 - trisOffset] + vertexOffset;
					target[i + 2] = tris[i + 2 - trisOffset] + vertexOffset;
				}
			}
			return trisOffset + tris.Length;
		}

		private bool IsClockwise(Vector2[] points2D)
		{
			float num = 0f;
			for (int i = 1; i < points2D.Length; i++)
			{
				Vector2 vector = points2D[i];
				Vector2 vector2 = points2D[(i + 1) % points2D.Length];
				num += (vector2.x - vector.x) * (vector2.y + vector.y);
			}
			num += (points2D[0].x - points2D[points2D.Length - 1].x) * (points2D[0].y + points2D[points2D.Length - 1].y);
			return num <= 0f;
		}

		private void GetIdentityVerts(Vector3 center, Vector3 normal, bool clockwise)
		{
			Quaternion quaternion = Quaternion.Inverse(Quaternion.LookRotation(normal));
			if (identityVertices.Length != base.sampleCount)
			{
				identityVertices = new Vector3[base.sampleCount];
				identityNormals = new Vector3[base.sampleCount];
			}
			for (int i = 0; i < base.sampleCount; i++)
			{
				identityVertices[i] = quaternion * (GetSampleRaw(i).position - center + (clockwise ? (-GetSampleRaw(i).right) : GetSampleRaw(i).right) * _expand);
				identityNormals[i] = quaternion * (clockwise ? (-GetSampleRaw(i).right) : GetSampleRaw(i).right);
			}
		}

		private void GetProjectedVertices(int count, out Vector3 center, out Vector3 normal)
		{
			center = Vector3.zero;
			normal = Vector3.zero;
			Vector3 vector = trs.right * base.offset.x + trs.up * base.offset.y + trs.forward * base.offset.z;
			for (int i = 0; i < count; i++)
			{
				center += GetSampleRaw(i).position + vector;
				normal += GetSampleRaw(i).up;
			}
			normal.Normalize();
			center /= (float)count;
			Quaternion quaternion = Quaternion.LookRotation(normal, Vector3.up);
			Vector3 vector2 = quaternion * Vector3.up;
			Vector3 vector3 = quaternion * Vector3.right;
			if (projectedVerts.Length != count)
			{
				projectedVerts = new Vector2[count];
			}
			for (int j = 0; j < count; j++)
			{
				Vector3 vector4 = GetSampleRaw(j).position + vector - center;
				float num = Vector3.Project(vector4, vector3).magnitude;
				if (Vector3.Dot(vector4, vector3) < 0f)
				{
					num *= -1f;
				}
				float num2 = Vector3.Project(vector4, vector2).magnitude;
				if (Vector3.Dot(vector4, vector2) < 0f)
				{
					num2 *= -1f;
				}
				projectedVerts[j].x = num;
				projectedVerts[j].y = num2;
			}
		}
	}
	[RequireComponent(typeof(MeshFilter))]
	[RequireComponent(typeof(MeshRenderer))]
	[AddComponentMenu("Dreamteck/Splines/Users/Tube Generator")]
	public class TubeGenerator : MeshGenerator
	{
		public enum CapMethod
		{
			None,
			Flat,
			Round
		}

		[SerializeField]
		[HideInInspector]
		private int _sides = 12;

		[SerializeField]
		[HideInInspector]
		private int _roundCapLatitude = 6;

		[SerializeField]
		[HideInInspector]
		private CapMethod _capMode;

		[SerializeField]
		[HideInInspector]
		[Range(0f, 360f)]
		private float _revolve = 360f;

		[SerializeField]
		[HideInInspector]
		private float _capUVScale = 1f;

		private int bodyVertexCount;

		private int bodyTrisCount;

		private int capVertexCount;

		private int capTrisCount;

		public int sides
		{
			get
			{
				return _sides;
			}
			set
			{
				if (value != _sides)
				{
					if (value < 3)
					{
						value = 3;
					}
					_sides = value;
					Rebuild();
				}
			}
		}

		public CapMethod capMode
		{
			get
			{
				return _capMode;
			}
			set
			{
				if (value != _capMode)
				{
					_capMode = value;
					Rebuild();
				}
			}
		}

		public int roundCapLatitude
		{
			get
			{
				return _roundCapLatitude;
			}
			set
			{
				if (value < 1)
				{
					value = 1;
				}
				if (value != _roundCapLatitude)
				{
					_roundCapLatitude = value;
					if (_capMode == CapMethod.Round)
					{
						Rebuild();
					}
				}
			}
		}

		public float revolve
		{
			get
			{
				return _revolve;
			}
			set
			{
				if (value != _revolve)
				{
					_revolve = value;
					Rebuild();
				}
			}
		}

		public float capUVScale
		{
			get
			{
				return _capUVScale;
			}
			set
			{
				if (value != _capUVScale)
				{
					_capUVScale = value;
					Rebuild();
				}
			}
		}

		private bool useCap
		{
			get
			{
				bool flag = _capMode != CapMethod.None;
				if (base.spline != null)
				{
					if (flag)
					{
						if (base.spline.isClosed)
						{
							return base.span < 1.0;
						}
						return true;
					}
					return false;
				}
				return flag;
			}
		}

		protected override void Reset()
		{
			base.Reset();
		}

		protected override void Awake()
		{
			base.Awake();
			mesh.name = "tube";
		}

		protected override void BuildMesh()
		{
			if (_sides > 2)
			{
				base.BuildMesh();
				bodyVertexCount = (_sides + 1) * base.sampleCount;
				CapMethod capMethod = _capMode;
				if (!useCap)
				{
					capMethod = CapMethod.None;
				}
				switch (capMethod)
				{
				case CapMethod.Flat:
					capVertexCount = _sides + 1;
					break;
				case CapMethod.Round:
					capVertexCount = _roundCapLatitude * (sides + 1);
					break;
				default:
					capVertexCount = 0;
					break;
				}
				int vertexCount = bodyVertexCount + capVertexCount * 2;
				bodyTrisCount = _sides * (base.sampleCount - 1) * 2 * 3;
				switch (capMethod)
				{
				case CapMethod.Flat:
					capTrisCount = (_sides - 1) * 3 * 2;
					break;
				case CapMethod.Round:
					capTrisCount = _sides * _roundCapLatitude * 6;
					break;
				default:
					capTrisCount = 0;
					break;
				}
				AllocateMesh(vertexCount, bodyTrisCount + capTrisCount * 2);
				Generate();
				switch (capMethod)
				{
				case CapMethod.Flat:
					GenerateFlatCaps();
					break;
				case CapMethod.Round:
					GenerateRoundCaps();
					break;
				}
			}
		}

		private void Generate()
		{
			int num = 0;
			ResetUVDistance();
			bool flag = base.offset != Vector3.zero;
			for (int i = 0; i < base.sampleCount; i++)
			{
				GetSample(i, evalResult);
				Vector3 position = evalResult.position;
				Vector3 right = evalResult.right;
				if (flag)
				{
					position += base.offset.x * right + base.offset.y * evalResult.up + base.offset.z * evalResult.forward;
				}
				if (base.uvMode == UVMode.UniformClamp || base.uvMode == UVMode.UniformClip)
				{
					AddUVDistance(i);
				}
				Color color = evalResult.color * base.color;
				for (int j = 0; j < _sides + 1; j++)
				{
					float num2 = (float)j / (float)_sides;
					Quaternion quaternion = Quaternion.AngleAxis(_revolve * num2 + base.rotation + 180f, evalResult.forward);
					tsMesh.vertices[num] = position + quaternion * right * base.size * evalResult.size * 0.5f;
					CalculateUVs(evalResult.percent, num2);
					tsMesh.uv[num] = Vector2.one * 0.5f + (Vector2)(Quaternion.AngleAxis(base.uvRotation, Vector3.forward) * (Vector2.one * 0.5f - MeshGenerator.uvs));
					tsMesh.normals[num] = Vector3.Normalize(tsMesh.vertices[num] - position);
					tsMesh.colors[num] = color;
					num++;
				}
			}
			MeshUtility.GeneratePlaneTriangles(ref tsMesh.triangles, _sides, base.sampleCount, flip: false);
		}

		private void GenerateFlatCaps()
		{
			GetSample(0, evalResult);
			for (int i = 0; i < _sides + 1; i++)
			{
				int num = bodyVertexCount + i;
				tsMesh.vertices[num] = tsMesh.vertices[i];
				tsMesh.normals[num] = -evalResult.forward;
				tsMesh.colors[num] = tsMesh.colors[i];
				tsMesh.uv[num] = Quaternion.AngleAxis(_revolve * ((float)i / (float)(_sides - 1)), Vector3.forward) * Vector2.right * 0.5f * capUVScale + Vector3.right * 0.5f + Vector3.up * 0.5f;
			}
			GetSample(base.sampleCount - 1, evalResult);
			for (int j = 0; j < _sides + 1; j++)
			{
				int num2 = bodyVertexCount + (_sides + 1) + j;
				int num3 = bodyVertexCount - (_sides + 1) + j;
				tsMesh.vertices[num2] = tsMesh.vertices[num3];
				tsMesh.normals[num2] = GetSampleRaw(base.sampleCount - 1).forward;
				tsMesh.colors[num2] = tsMesh.colors[num3];
				tsMesh.uv[num2] = Quaternion.AngleAxis(_revolve * ((float)num3 / (float)(_sides - 1)), Vector3.forward) * Vector2.right * 0.5f * capUVScale + Vector3.right * 0.5f + Vector3.up * 0.5f;
			}
			int num4 = bodyTrisCount;
			int num5 = ((_revolve == 360f) ? (_sides - 1) : _sides);
			for (int k = 0; k < num5 - 1; k++)
			{
				tsMesh.triangles[num4++] = k + bodyVertexCount + 2;
				tsMesh.triangles[num4++] = k + bodyVertexCount + 1;
				tsMesh.triangles[num4++] = bodyVertexCount;
			}
			for (int l = 0; l < num5 - 1; l++)
			{
				tsMesh.triangles[num4++] = bodyVertexCount + (_sides + 1);
				tsMesh.triangles[num4++] = l + 1 + bodyVertexCount + (_sides + 1);
				tsMesh.triangles[num4++] = l + 2 + bodyVertexCount + (_sides + 1);
			}
		}

		private void GenerateRoundCaps()
		{
			GetSample(0, evalResult);
			Vector3 position = evalResult.position;
			bool flag = base.offset != Vector3.zero;
			if (flag)
			{
				position += base.offset.x * evalResult.right + base.offset.y * evalResult.up + base.offset.z * evalResult.forward;
			}
			Quaternion quaternion = Quaternion.LookRotation(-evalResult.forward, evalResult.up);
			float num = 0f;
			float num2 = 0f;
			switch (base.uvMode)
			{
			case UVMode.Clip:
				num = (float)evalResult.percent;
				num2 = base.size * 0.5f / base.spline.CalculateLength();
				break;
			case UVMode.UniformClip:
				num = base.spline.CalculateLength(0.0, evalResult.percent);
				num2 = base.size * 0.5f;
				break;
			case UVMode.UniformClamp:
				num = 0f;
				num2 = base.size * 0.5f / (float)base.span;
				break;
			case UVMode.Clamp:
				num2 = base.size * 0.5f / base.spline.CalculateLength(base.clipFrom, base.clipTo);
				break;
			}
			Color color = evalResult.color * base.color;
			for (int i = 1; i < _roundCapLatitude + 1; i++)
			{
				float num3 = (float)i / (float)_roundCapLatitude;
				float angle = 90f * num3;
				for (int j = 0; j <= sides; j++)
				{
					float num4 = (float)j / (float)sides;
					int num5 = bodyVertexCount + j + (i - 1) * (sides + 1);
					Quaternion quaternion2 = Quaternion.AngleAxis(_revolve * num4 + base.rotation + 180f, -Vector3.forward) * Quaternion.AngleAxis(angle, Vector3.up);
					tsMesh.vertices[num5] = position + quaternion * quaternion2 * -Vector3.right * base.size * 0.5f * evalResult.size;
					tsMesh.colors[num5] = color;
					tsMesh.normals[num5] = (tsMesh.vertices[num5] - position).normalized;
					tsMesh.uv[num5] = new Vector2(num4 * base.uvScale.x, (num - num2 * num3) * base.uvScale.y) - base.uvOffset;
				}
			}
			int num6 = bodyTrisCount;
			for (int k = -1; k < _roundCapLatitude - 1; k++)
			{
				for (int l = 0; l < sides; l++)
				{
					int num7 = bodyVertexCount + l + k * (sides + 1);
					int num8 = num7 + (sides + 1);
					if (k == -1)
					{
						num7 = l;
						num8 = bodyVertexCount + l;
					}
					tsMesh.triangles[num6++] = num8 + 1;
					tsMesh.triangles[num6++] = num7 + 1;
					tsMesh.triangles[num6++] = num7;
					tsMesh.triangles[num6++] = num8;
					tsMesh.triangles[num6++] = num8 + 1;
					tsMesh.triangles[num6++] = num7;
				}
			}
			GetSample(base.sampleCount - 1, evalResult);
			position = evalResult.position;
			if (flag)
			{
				position += base.offset.x * evalResult.right + base.offset.y * evalResult.up + base.offset.z * evalResult.forward;
			}
			quaternion = Quaternion.LookRotation(evalResult.forward, evalResult.up);
			switch (base.uvMode)
			{
			case UVMode.Clip:
				num = (float)evalResult.percent;
				break;
			case UVMode.UniformClip:
				num = base.spline.CalculateLength(0.0, evalResult.percent);
				break;
			case UVMode.Clamp:
				num = 1f;
				break;
			case UVMode.UniformClamp:
				num = base.spline.CalculateLength();
				break;
			}
			color = evalResult.color * base.color;
			for (int m = 1; m < _roundCapLatitude + 1; m++)
			{
				float num9 = (float)m / (float)_roundCapLatitude;
				float angle2 = 90f * num9;
				for (int n = 0; n <= sides; n++)
				{
					float num10 = (float)n / (float)sides;
					int num11 = bodyVertexCount + capVertexCount + n + (m - 1) * (sides + 1);
					Quaternion quaternion3 = Quaternion.AngleAxis(_revolve * num10 + base.rotation + 180f, Vector3.forward) * Quaternion.AngleAxis(angle2, -Vector3.up);
					tsMesh.vertices[num11] = position + quaternion * quaternion3 * Vector3.right * base.size * 0.5f * evalResult.size;
					tsMesh.normals[num11] = (tsMesh.vertices[num11] - position).normalized;
					tsMesh.colors[num11] = color;
					tsMesh.uv[num11] = new Vector2(num10 * base.uvScale.x, (num + num2 * num9) * base.uvScale.y) - base.uvOffset;
				}
			}
			for (int num12 = -1; num12 < _roundCapLatitude - 1; num12++)
			{
				for (int num13 = 0; num13 < sides; num13++)
				{
					int num14 = bodyVertexCount + capVertexCount + num13 + num12 * (sides + 1);
					int num15 = num14 + (sides + 1);
					if (num12 == -1)
					{
						num14 = bodyVertexCount - (_sides + 1) + num13;
						num15 = bodyVertexCount + capVertexCount + num13;
					}
					tsMesh.triangles[num6++] = num14 + 1;
					tsMesh.triangles[num6++] = num15 + 1;
					tsMesh.triangles[num6++] = num15;
					tsMesh.triangles[num6++] = num15;
					tsMesh.triangles[num6++] = num14;
					tsMesh.triangles[num6++] = num14 + 1;
				}
			}
		}
	}
	[RequireComponent(typeof(MeshFilter))]
	[RequireComponent(typeof(MeshRenderer))]
	[AddComponentMenu("Dreamteck/Splines/Users/Waveform Generator")]
	public class WaveformGenerator : MeshGenerator
	{
		public enum Axis
		{
			X,
			Y,
			Z
		}

		public enum Space
		{
			World,
			Local
		}

		public enum UVWrapMode
		{
			Clamp,
			UniformX,
			UniformY,
			Uniform
		}

		[SerializeField]
		[HideInInspector]
		private Axis _axis = Axis.Y;

		[SerializeField]
		[HideInInspector]
		private bool _symmetry;

		[SerializeField]
		[HideInInspector]
		private UVWrapMode _uvWrapMode;

		[SerializeField]
		[HideInInspector]
		private int _slices = 1;

		public Axis axis
		{
			get
			{
				return _axis;
			}
			set
			{
				if (value != _axis)
				{
					_axis = value;
					Rebuild();
				}
			}
		}

		public bool symmetry
		{
			get
			{
				return _symmetry;
			}
			set
			{
				if (value != _symmetry)
				{
					_symmetry = value;
					Rebuild();
				}
			}
		}

		public UVWrapMode uvWrapMode
		{
			get
			{
				return _uvWrapMode;
			}
			set
			{
				if (value != _uvWrapMode)
				{
					_uvWrapMode = value;
					Rebuild();
				}
			}
		}

		public int slices
		{
			get
			{
				return _slices;
			}
			set
			{
				if (value != _slices)
				{
					if (value < 1)
					{
						value = 1;
					}
					_slices = value;
					Rebuild();
				}
			}
		}

		protected override void Awake()
		{
			base.Awake();
			mesh.name = "waveform";
		}

		protected override void BuildMesh()
		{
			base.BuildMesh();
			Generate();
		}

		protected override void Build()
		{
			base.Build();
		}

		protected override void LateRun()
		{
			base.LateRun();
		}

		private void Generate()
		{
			int vertexCount = base.sampleCount * (_slices + 1);
			AllocateMesh(vertexCount, _slices * (base.sampleCount - 1) * 6);
			int num = 0;
			float num2 = 0f;
			float num3 = 0f;
			_ = base.spline.position;
			Vector3 vector = base.spline.TransformDirection(Vector3.right);
			switch (_axis)
			{
			case Axis.Y:
				vector = base.spline.TransformDirection(Vector3.up);
				break;
			case Axis.Z:
				vector = base.spline.TransformDirection(Vector3.forward);
				break;
			}
			for (int i = 0; i < base.sampleCount; i++)
			{
				Vector3 position = GetSampleRaw(i).position;
				Vector3 vector2 = base.spline.InverseTransformPoint(position);
				Vector3 point = vector2;
				Vector3 forward = GetSampleRaw(i).forward;
				Vector3 up = GetSampleRaw(i).up;
				float num4 = 1f;
				if ((_uvWrapMode == UVWrapMode.UniformX || _uvWrapMode == UVWrapMode.Uniform) && i > 0)
				{
					num3 += Vector3.Distance(GetSampleRaw(i).position, GetSampleRaw(i - 1).position);
				}
				switch (_axis)
				{
				case Axis.X:
					point.x = (_symmetry ? (0f - vector2.x) : 0f);
					num4 = base.uvScale.y * Mathf.Abs(vector2.x);
					num2 += vector2.x;
					break;
				case Axis.Y:
					point.y = (_symmetry ? (0f - vector2.y) : 0f);
					num4 = base.uvScale.y * Mathf.Abs(vector2.y);
					num2 += vector2.y;
					break;
				case Axis.Z:
					point.z = (_symmetry ? (0f - vector2.z) : 0f);
					num4 = base.uvScale.y * Mathf.Abs(vector2.z);
					num2 += vector2.z;
					break;
				}
				point = base.spline.TransformPoint(point);
				Vector3 normalized = Vector3.Cross(vector, forward).normalized;
				Vector3 vector3 = Vector3.Cross(up, forward);
				for (int j = 0; j < _slices + 1; j++)
				{
					float num5 = (float)j / (float)_slices;
					tsMesh.vertices[num] = Vector3.Lerp(point, position, num5) + vector * base.offset.y + vector3 * base.offset.x;
					tsMesh.normals[num] = normalized;
					switch (_uvWrapMode)
					{
					case UVWrapMode.Clamp:
						tsMesh.uv[num] = new Vector2((float)GetSampleRaw(i).percent * base.uvScale.x + base.uvOffset.x, num5 * base.uvScale.y + base.uvOffset.y);
						break;
					case UVWrapMode.UniformX:
						tsMesh.uv[num] = new Vector2(num3 * base.uvScale.x + base.uvOffset.x, num5 * base.uvScale.y + base.uvOffset.y);
						break;
					case UVWrapMode.UniformY:
						tsMesh.uv[num] = new Vector2((float)GetSampleRaw(i).percent * base.uvScale.x + base.uvOffset.x, num4 * num5 * base.uvScale.y + base.uvOffset.y);
						break;
					case UVWrapMode.Uniform:
						tsMesh.uv[num] = new Vector2(num3 * base.uvScale.x + base.uvOffset.x, num4 * num5 * base.uvScale.y + base.uvOffset.y);
						break;
					}
					tsMesh.colors[num] = GetSampleRaw(i).color * base.color;
					num++;
				}
			}
			if (base.sampleCount > 0)
			{
				num2 /= (float)base.sampleCount;
			}
			MeshUtility.GeneratePlaneTriangles(ref tsMesh.triangles, _slices, base.sampleCount, num2 < 0f);
		}
	}
	[Serializable]
	public class ObjectSequence<T>
	{
		public enum Iteration
		{
			Ordered,
			Random
		}

		public T startObject;

		public T endObject;

		public T[] objects;

		public Iteration iteration;

		[SerializeField]
		[HideInInspector]
		private int _randomSeed = 1;

		[SerializeField]
		[HideInInspector]
		private int index;

		[SerializeField]
		[HideInInspector]
		private System.Random randomizer;

		public int randomSeed
		{
			get
			{
				return _randomSeed;
			}
			set
			{
				if (value != _randomSeed)
				{
					_randomSeed = value;
					randomizer = new System.Random(_randomSeed);
				}
			}
		}

		public ObjectSequence()
		{
			randomizer = new System.Random(_randomSeed);
		}

		public T GetFirst()
		{
			if (startObject != null)
			{
				return startObject;
			}
			return Next();
		}

		public T GetLast()
		{
			if (endObject != null)
			{
				return endObject;
			}
			return Next();
		}

		public T Next()
		{
			if (iteration == Iteration.Ordered)
			{
				if (index >= objects.Length)
				{
					index = 0;
				}
				return objects[index++];
			}
			int num = randomizer.Next(objects.Length - 1);
			return objects[num];
		}
	}
	[Serializable]
	public class SampleCollection
	{
		[HideInInspector]
		public SplineSample[] samples = new SplineSample[0];

		public int[] optimizedIndices = new int[0];

		public SplineComputer.SampleMode sampleMode;

		public double clipFrom;

		public double clipTo = 1.0;

		public bool loopSamples;

		public int Count => samples.Length;

		private bool hasSamples => Count > 0;

		public bool samplesAreLooped
		{
			get
			{
				if (loopSamples)
				{
					return clipFrom >= clipTo;
				}
				return false;
			}
		}

		public double span
		{
			get
			{
				if (samplesAreLooped)
				{
					return 1.0 - clipFrom + clipTo;
				}
				return clipTo - clipFrom;
			}
		}

		public SampleCollection()
		{
		}

		public SampleCollection(SampleCollection input)
		{
			samples = input.samples;
			optimizedIndices = input.optimizedIndices;
			sampleMode = input.sampleMode;
			clipFrom = input.clipFrom;
			clipTo = input.clipTo;
		}

		public int GetClippedSampleCount(out int startIndex, out int endIndex)
		{
			startIndex = (endIndex = 0);
			if (sampleMode == SplineComputer.SampleMode.Default)
			{
				startIndex = DMath.FloorInt((double)(Count - 1) * clipFrom);
				endIndex = DMath.CeilInt((double)(Count - 1) * clipTo);
			}
			else
			{
				double lerp = 0.0;
				double lerp2 = 0.0;
				GetSamplingValues(clipFrom, out startIndex, out lerp);
				GetSamplingValues(clipTo, out endIndex, out lerp2);
				if (lerp2 > 0.0 && endIndex < Count - 1)
				{
					endIndex++;
				}
			}
			if (samplesAreLooped)
			{
				int num = endIndex + 1;
				int num2 = Count - startIndex;
				return num + num2;
			}
			return endIndex - startIndex + 1;
		}

		public double ClipPercent(double percent)
		{
			ClipPercent(ref percent);
			return percent;
		}

		public void ClipPercent(ref double percent)
		{
			if (Count == 0)
			{
				percent = 0.0;
			}
			else if (samplesAreLooped)
			{
				if (percent >= clipFrom && percent <= 1.0)
				{
					percent = DMath.InverseLerp(clipFrom, clipFrom + span, percent);
				}
				else if (percent <= clipTo)
				{
					percent = DMath.InverseLerp(clipTo - span, clipTo, percent);
				}
				else if (DMath.InverseLerp(clipTo, clipFrom, percent) < 0.5)
				{
					percent = 1.0;
				}
				else
				{
					percent = 0.0;
				}
			}
			else
			{
				percent = DMath.InverseLerp(clipFrom, clipTo, percent);
			}
		}

		public double UnclipPercent(double percent)
		{
			UnclipPercent(ref percent);
			return percent;
		}

		public void UnclipPercent(ref double percent)
		{
			if (percent == 0.0)
			{
				percent = clipFrom;
				return;
			}
			if (percent == 1.0)
			{
				percent = clipTo;
				return;
			}
			if (samplesAreLooped)
			{
				double num = (1.0 - clipFrom) / span;
				if (num == 0.0)
				{
					percent = 0.0;
					return;
				}
				if (percent < num)
				{
					percent = DMath.Lerp(clipFrom, 1.0, percent / num);
				}
				else
				{
					if (clipTo == 0.0)
					{
						percent = 0.0;
						return;
					}
					percent = DMath.Lerp(0.0, clipTo, (percent - num) / (clipTo / span));
				}
			}
			else
			{
				percent = DMath.Lerp(clipFrom, clipTo, percent);
			}
			percent = DMath.Clamp01(percent);
		}

		public void GetSamplingValues(double percent, out int sampleIndex, out double lerp)
		{
			lerp = 0.0;
			if (sampleMode == SplineComputer.SampleMode.Optimized)
			{
				double num = percent * (double)(optimizedIndices.Length - 1);
				int num2 = DMath.FloorInt(num);
				sampleIndex = optimizedIndices[num2];
				double t = 0.0;
				if (num2 < optimizedIndices.Length - 1)
				{
					double t2 = num - (double)num2;
					double a = (double)num2 / (double)(optimizedIndices.Length - 1);
					double b = (double)(num2 + 1) / (double)(optimizedIndices.Length - 1);
					t = DMath.Lerp(a, b, t2);
				}
				if (sampleIndex < Count - 1)
				{
					lerp = DMath.InverseLerp(samples[sampleIndex].percent, samples[sampleIndex + 1].percent, t);
				}
			}
			else
			{
				sampleIndex = DMath.FloorInt(percent * (double)(Count - 1));
				lerp = (double)(Count - 1) * percent - (double)sampleIndex;
			}
		}

		public Vector3 EvaluatePosition(double percent)
		{
			if (!hasSamples)
			{
				return Vector3.zero;
			}
			UnclipPercent(ref percent);
			GetSamplingValues(percent, out var sampleIndex, out var lerp);
			if (lerp > 0.0)
			{
				return Vector3.Lerp(samples[sampleIndex].position, samples[sampleIndex + 1].position, (float)lerp);
			}
			return samples[sampleIndex].position;
		}

		public SplineSample Evaluate(double percent)
		{
			SplineSample result = new SplineSample();
			Evaluate(percent, result);
			return result;
		}

		public void Evaluate(double percent, SplineSample result)
		{
			if (!hasSamples)
			{
				result = new SplineSample();
				return;
			}
			UnclipPercent(ref percent);
			GetSamplingValues(percent, out var sampleIndex, out var lerp);
			if (lerp > 0.0)
			{
				SplineSample.Lerp(samples[sampleIndex], samples[sampleIndex + 1], lerp, result);
			}
			else
			{
				result.CopyFrom(samples[sampleIndex]);
			}
		}

		public void Evaluate(ref SplineSample[] results, double from = 0.0, double to = 1.0)
		{
			if (!hasSamples)
			{
				results = new SplineSample[0];
				return;
			}
			Spline.FormatFromTo(ref from, ref to);
			GetSamplingValues(from, out var sampleIndex, out var lerp);
			GetSamplingValues(to, out var sampleIndex2, out lerp);
			if (lerp > 0.0 && sampleIndex2 < Count - 1)
			{
				sampleIndex2++;
			}
			int num = sampleIndex2 - sampleIndex + 1;
			if (results == null)
			{
				results = new SplineSample[num];
			}
			else if (results.Length != num)
			{
				results = new SplineSample[num];
			}
			results[0] = Evaluate(from);
			results[results.Length - 1] = Evaluate(to);
			for (int i = 1; i < results.Length - 1; i++)
			{
				results[i] = samples[i + sampleIndex];
			}
		}

		public void EvaluatePositions(ref Vector3[] positions, double from = 0.0, double to = 1.0)
		{
			if (!hasSamples)
			{
				positions = new Vector3[0];
				return;
			}
			Spline.FormatFromTo(ref from, ref to);
			GetSamplingValues(from, out var sampleIndex, out var lerp);
			GetSamplingValues(to, out var sampleIndex2, out lerp);
			if (lerp > 0.0 && sampleIndex2 < Count - 1)
			{
				sampleIndex2++;
			}
			int num = sampleIndex2 - sampleIndex + 1;
			if (positions == null)
			{
				positions = new Vector3[num];
			}
			else if (positions.Length != num)
			{
				positions = new Vector3[num];
			}
			positions[0] = EvaluatePosition(from);
			positions[positions.Length - 1] = EvaluatePosition(to);
			for (int i = 1; i < positions.Length - 1; i++)
			{
				positions[i] = samples[i + sampleIndex].position;
			}
		}

		public double Travel(double start, float distance, Spline.Direction direction, out float moved)
		{
			moved = 0f;
			if (!hasSamples)
			{
				return 0.0;
			}
			if (direction == Spline.Direction.Forward && start >= 1.0)
			{
				return clipTo;
			}
			if (direction == Spline.Direction.Backward && start <= 0.0)
			{
				return clipFrom;
			}
			double num = UnclipPercent(DMath.Clamp01(start));
			if (distance == 0f)
			{
				return num;
			}
			Vector3 b = EvaluatePosition(start);
			GetSamplingValues(num, out var sampleIndex, out var lerp);
			if (direction == Spline.Direction.Forward && lerp > 0.0)
			{
				sampleIndex++;
			}
			float num2 = 0f;
			int sampleIndex2 = 0;
			int sampleIndex3 = Count - 1;
			if (samplesAreLooped)
			{
				GetSamplingValues(clipFrom, out sampleIndex2, out lerp);
				GetSamplingValues(clipTo, out sampleIndex3, out lerp);
				if (lerp > 0.0)
				{
					sampleIndex3++;
				}
			}
			while (moved < distance)
			{
				num2 = Vector3.Distance(samples[sampleIndex].position, b);
				moved += num2;
				if (moved >= distance)
				{
					break;
				}
				b = samples[sampleIndex].position;
				num = samples[sampleIndex].percent;
				if (direction == Spline.Direction.Forward)
				{
					if (sampleIndex == Count - 1)
					{
						if (!samplesAreLooped)
						{
							break;
						}
						b = samples[0].position;
						num = samples[0].percent;
						sampleIndex = 1;
					}
					if (samplesAreLooped && sampleIndex == sampleIndex3)
					{
						break;
					}
					sampleIndex++;
					continue;
				}
				if (sampleIndex == 0)
				{
					if (!samplesAreLooped)
					{
						break;
					}
					b = samples[Count - 1].position;
					num = samples[Count - 1].percent;
					sampleIndex = Count - 2;
				}
				if (samplesAreLooped && sampleIndex == sampleIndex2)
				{
					break;
				}
				sampleIndex--;
			}
			float num3 = 0f;
			if (moved > distance)
			{
				num3 = moved - distance;
			}
			double result = DMath.Lerp(num, samples[sampleIndex].percent, 1f - num3 / num2);
			moved -= num3;
			return result;
		}

		public double Travel(double start, float distance, Spline.Direction direction = Spline.Direction.Forward)
		{
			float moved;
			return Travel(start, distance, direction, out moved);
		}

		public void Project(Vector3 position, int controlPointCount, SplineSample result, double from = 0.0, double to = 1.0)
		{
			if (!hasSamples)
			{
				return;
			}
			if (Count == 1)
			{
				if (result == null)
				{
					result = new SplineSample(samples[0]);
				}
				else
				{
					result.CopyFrom(samples[0]);
				}
				return;
			}
			Spline.FormatFromTo(ref from, ref to);
			int num = (controlPointCount - 1) * 6;
			int num2 = Count / num;
			if (num2 < 1)
			{
				num2 = 1;
			}
			float num3 = (position - samples[0].position).sqrMagnitude;
			int sampleIndex = 0;
			int sampleIndex2 = Count - 1;
			double lerp;
			if (from != 0.0)
			{
				GetSamplingValues(from, out sampleIndex, out lerp);
			}
			if (to != 1.0)
			{
				GetSamplingValues(to, out sampleIndex2, out lerp);
				if (lerp > 0.0 && sampleIndex2 < Count - 1)
				{
					sampleIndex2++;
				}
			}
			int num4 = sampleIndex;
			int num5 = sampleIndex2;
			for (int i = sampleIndex; i <= sampleIndex2; i += num2)
			{
				if (i > sampleIndex2)
				{
					i = sampleIndex2;
				}
				float sqrMagnitude = (position - samples[i].position).sqrMagnitude;
				if (sqrMagnitude < num3)
				{
					num3 = sqrMagnitude;
					num4 = Mathf.Max(i - num2, 0);
					num5 = Mathf.Min(i + num2, Count - 1);
				}
				if (i == sampleIndex2)
				{
					break;
				}
			}
			num3 = (position - samples[num4].position).sqrMagnitude;
			int num6 = num4;
			for (int j = num4 + 1; j <= num5; j++)
			{
				float sqrMagnitude2 = (position - samples[j].position).sqrMagnitude;
				if (sqrMagnitude2 < num3)
				{
					num3 = sqrMagnitude2;
					num6 = j;
				}
			}
			int num7 = num6 - 1;
			if (num7 < 0)
			{
				num7 = 0;
			}
			int num8 = num6 + 1;
			if (num8 > Count - 1)
			{
				num8 = Count - 1;
			}
			Vector3 vector = LinearAlgebraUtility.ProjectOnLine(samples[num7].position, samples[num6].position, position);
			Vector3 vector2 = LinearAlgebraUtility.ProjectOnLine(samples[num6].position, samples[num8].position, position);
			float magnitude = (samples[num6].position - samples[num7].position).magnitude;
			float magnitude2 = (samples[num6].position - samples[num8].position).magnitude;
			float magnitude3 = (vector - samples[num7].position).magnitude;
			float magnitude4 = (vector2 - samples[num8].position).magnitude;
			if (num7 < num6 && num6 < num8)
			{
				if ((position - vector).sqrMagnitude < (position - vector2).sqrMagnitude)
				{
					SplineSample.Lerp(samples[num7], samples[num6], magnitude3 / magnitude, result);
					if (sampleMode == SplineComputer.SampleMode.Uniform)
					{
						result.percent = DMath.Lerp(GetSamplePercent(num7), GetSamplePercent(num6), magnitude3 / magnitude);
					}
				}
				else
				{
					SplineSample.Lerp(samples[num8], samples[num6], magnitude4 / magnitude2, result);
					if (sampleMode == SplineComputer.SampleMode.Uniform)
					{
						result.percent = DMath.Lerp(GetSamplePercent(num8), GetSamplePercent(num6), magnitude4 / magnitude2);
					}
				}
			}
			else if (num7 < num6)
			{
				SplineSample.Lerp(samples[num7], samples[num6], magnitude3 / magnitude, result);
				if (sampleMode == SplineComputer.SampleMode.Uniform)
				{
					result.percent = DMath.Lerp(GetSamplePercent(num7), GetSamplePercent(num6), magnitude3 / magnitude);
				}
			}
			else
			{
				SplineSample.Lerp(samples[num8], samples[num6], magnitude4 / magnitude2, result);
				if (sampleMode == SplineComputer.SampleMode.Uniform)
				{
					result.percent = DMath.Lerp(GetSamplePercent(num8), GetSamplePercent(num6), magnitude4 / magnitude2);
				}
			}
			if (Count <= 1 || from != 0.0 || to != 1.0 || !(result.percent < samples[1].percent))
			{
				return;
			}
			Vector3 vector3 = LinearAlgebraUtility.ProjectOnLine(samples[Count - 1].position, samples[Count - 2].position, position);
			if ((position - vector3).sqrMagnitude < (position - result.position).sqrMagnitude)
			{
				double t = LinearAlgebraUtility.InverseLerp(samples[Count - 1].position, samples[Count - 2].position, vector3);
				SplineSample.Lerp(samples[Count - 1], samples[Count - 2], t, result);
				if (sampleMode == SplineComputer.SampleMode.Uniform)
				{
					result.percent = DMath.Lerp(GetSamplePercent(Count - 1), GetSamplePercent(Count - 2), t);
				}
			}
		}

		private double GetSamplePercent(int sampleIndex)
		{
			if (sampleMode == SplineComputer.SampleMode.Optimized)
			{
				return samples[optimizedIndices[sampleIndex]].percent;
			}
			return (double)sampleIndex / (double)(Count - 1);
		}

		public float CalculateLength(double from = 0.0, double to = 1.0)
		{
			if (!hasSamples)
			{
				return 0f;
			}
			Spline.FormatFromTo(ref from, ref to);
			float num = 0f;
			Vector3 b = EvaluatePosition(from);
			GetSamplingValues(from, out var sampleIndex, out var lerp);
			GetSamplingValues(to, out var sampleIndex2, out lerp);
			if (lerp > 0.0 && sampleIndex2 < Count - 1)
			{
				sampleIndex2++;
			}
			for (int i = sampleIndex + 1; i < sampleIndex2; i++)
			{
				num += Vector3.Distance(samples[i].position, b);
				b = samples[i].position;
			}
			return num + Vector3.Distance(EvaluatePosition(to), b);
		}
	}
	[Serializable]
	public class Spline
	{
		public enum Direction
		{
			Forward = 1,
			Backward = -1
		}

		public enum Type
		{
			CatmullRom,
			BSpline,
			Bezier,
			Linear
		}

		public SplinePoint[] points = new SplinePoint[0];

		[SerializeField]
		private bool closed;

		public Type type = Type.Bezier;

		public bool linearAverageDirection = true;

		public AnimationCurve customValueInterpolation;

		public AnimationCurve customNormalInterpolation;

		public int sampleRate = 10;

		private static Vector3[] catPoints = new Vector3[4];

		public bool isClosed
		{
			get
			{
				if (closed)
				{
					return points.Length >= 4;
				}
				return false;
			}
			set
			{
			}
		}

		public double moveStep
		{
			get
			{
				if (type == Type.Linear)
				{
					return 1f / (float)(points.Length - 1);
				}
				return 1f / (float)(iterations - 1);
			}
			set
			{
			}
		}

		public int iterations
		{
			get
			{
				if (type == Type.Linear)
				{
					return points.Length;
				}
				return sampleRate * (points.Length - 1) - (points.Length - 1) + 1;
			}
		}

		public Spline(Type type)
		{
			this.type = type;
			points = new SplinePoint[0];
		}

		public Spline(Type type, int sampleRate)
		{
			this.type = type;
			this.sampleRate = sampleRate;
			points = new SplinePoint[0];
		}

		public float CalculateLength(double from = 0.0, double to = 1.0, double resolution = 1.0)
		{
			if (points.Length == 0)
			{
				return 0f;
			}
			resolution = DMath.Clamp01(resolution);
			if (resolution == 0.0)
			{
				return 0f;
			}
			from = DMath.Clamp01(from);
			to = DMath.Clamp01(to);
			if (to < from)
			{
				to = from;
			}
			double num = from;
			Vector3 vector = EvaluatePosition(num);
			float num2 = 0f;
			do
			{
				num = DMath.Move(num, to, moveStep / resolution);
				Vector3 vector2 = EvaluatePosition(num);
				num2 += (vector2 - vector).magnitude;
				vector = vector2;
			}
			while (num != to);
			return num2;
		}

		public double Project(Vector3 position, int subdivide = 4, double from = 0.0, double to = 1.0)
		{
			if (points.Length == 0)
			{
				return 0.0;
			}
			if (closed && from == 0.0 && to == 1.0)
			{
				double closestPoint = GetClosestPoint(subdivide, position, from, to, Mathf.RoundToInt(Mathf.Max(iterations / points.Length, 10)) * 5);
				if (closestPoint < moveStep)
				{
					double closestPoint2 = GetClosestPoint(subdivide, position, 0.5, to, Mathf.RoundToInt(Mathf.Max(iterations / points.Length, 10)) * 5);
					if (Vector3.Distance(position, EvaluatePosition(closestPoint2)) < Vector3.Distance(position, EvaluatePosition(closestPoint)))
					{
						return closestPoint2;
					}
				}
				return closestPoint;
			}
			return GetClosestPoint(subdivide, position, from, to, Mathf.RoundToInt(Mathf.Max(iterations / points.Length, 10)) * 5);
		}

		public bool Raycast(out RaycastHit hit, out double hitPercent, LayerMask layerMask, double resolution = 1.0, double from = 0.0, double to = 1.0, QueryTriggerInteraction hitTriggers = QueryTriggerInteraction.UseGlobal)
		{
			resolution = DMath.Clamp01(resolution);
			from = DMath.Clamp01(from);
			to = DMath.Clamp01(to);
			double num = from;
			Vector3 vector = EvaluatePosition(num);
			hitPercent = 0.0;
			if (resolution == 0.0)
			{
				hit = default(RaycastHit);
				hitPercent = 0.0;
				return false;
			}
			do
			{
				double a = num;
				num = DMath.Move(num, to, moveStep / resolution);
				Vector3 vector2 = EvaluatePosition(num);
				if (Physics.Linecast(vector, vector2, out hit, layerMask, hitTriggers))
				{
					double t = (hit.point - vector).sqrMagnitude / (vector2 - vector).sqrMagnitude;
					hitPercent = DMath.Lerp(a, num, t);
					return true;
				}
				vector = vector2;
			}
			while (num != to);
			return false;
		}

		public bool RaycastAll(out RaycastHit[] hits, out double[] hitPercents, LayerMask layerMask, double resolution = 1.0, double from = 0.0, double to = 1.0, QueryTriggerInteraction hitTriggers = QueryTriggerInteraction.UseGlobal)
		{
			resolution = DMath.Clamp01(resolution);
			from = DMath.Clamp01(from);
			to = DMath.Clamp01(to);
			double num = from;
			Vector3 vector = EvaluatePosition(num);
			List<RaycastHit> list = new List<RaycastHit>();
			List<double> list2 = new List<double>();
			if (resolution == 0.0)
			{
				hits = new RaycastHit[0];
				hitPercents = new double[0];
				return false;
			}
			bool result = false;
			do
			{
				double a = num;
				num = DMath.Move(num, to, moveStep / resolution);
				Vector3 vector2 = EvaluatePosition(num);
				RaycastHit[] array = Physics.RaycastAll(vector, vector2 - vector, Vector3.Distance(vector, vector2), layerMask, hitTriggers);
				for (int i = 0; i < array.Length; i++)
				{
					result = true;
					double t = (array[i].point - vector).sqrMagnitude / (vector2 - vector).sqrMagnitude;
					list2.Add(DMath.Lerp(a, num, t));
					list.Add(array[i]);
				}
				vector = vector2;
			}
			while (num != to);
			hits = list.ToArray();
			hitPercents = list2.ToArray();
			return result;
		}

		public double GetPointPercent(int pointIndex)
		{
			return DMath.Clamp01((double)pointIndex / (double)(points.Length - 1));
		}

		public Vector3 EvaluatePosition(double percent)
		{
			if (points.Length == 0)
			{
				return Vector3.zero;
			}
			Vector3 point = default(Vector3);
			EvaluatePosition(ref point, percent);
			return point;
		}

		public SplineSample Evaluate(double percent)
		{
			SplineSample result = new SplineSample();
			Evaluate(result, percent);
			return result;
		}

		public SplineSample Evaluate(int pointIndex)
		{
			SplineSample result = new SplineSample();
			Evaluate(result, GetPointPercent(pointIndex));
			return result;
		}

		public void Evaluate(SplineSample result, int pointIndex)
		{
			Evaluate(result, GetPointPercent(pointIndex));
		}

		public void Evaluate(SplineSample result, double percent)
		{
			if (points.Length == 0)
			{
				result = new SplineSample();
				return;
			}
			percent = DMath.Clamp01(percent);
			if (closed && points.Length <= 2)
			{
				closed = false;
			}
			if (points.Length == 1)
			{
				result.position = points[0].position;
				result.up = points[0].normal;
				result.forward = Vector3.forward;
				result.size = points[0].size;
				result.color = points[0].color;
				result.percent = percent;
				return;
			}
			double num = (double)(points.Length - 1) * percent;
			int num2 = Mathf.Clamp(DMath.FloorInt(num), 0, points.Length - 2);
			double num3 = num - (double)num2;
			Vector3 position = EvaluatePosition(percent);
			result.position = position;
			result.percent = percent;
			if (num2 <= points.Length - 2)
			{
				SplinePoint splinePoint = points[num2 + 1];
				if (num2 == points.Length - 2 && closed)
				{
					splinePoint = points[0];
				}
				float num4 = (float)num3;
				if (customValueInterpolation != null && customValueInterpolation.length > 0)
				{
					num4 = customValueInterpolation.Evaluate(num4);
				}
				float num5 = (float)num3;
				if (customNormalInterpolation != null && customNormalInterpolation.length > 0)
				{
					num5 = customNormalInterpolation.Evaluate(num5);
				}
				result.size = Mathf.Lerp(points[num2].size, splinePoint.size, num4);
				result.color = Color.Lerp(points[num2].color, splinePoint.color, num4);
				result.up = Vector3.Slerp(points[num2].normal, splinePoint.normal, num5);
			}
			else if (closed)
			{
				result.size = points[0].size;
				result.color = points[0].color;
				result.up = points[0].normal;
			}
			else
			{
				result.size = points[num2].size;
				result.color = points[num2].color;
				result.up = points[num2].normal;
			}
			if (type == Type.BSpline)
			{
				double num6 = 1.0 / (double)(iterations - 1);
				if (percent <= 1.0 - num6 && percent >= num6)
				{
					result.forward = EvaluatePosition(percent + num6) - EvaluatePosition(percent - num6);
				}
				else
				{
					Vector3 zero = Vector3.zero;
					Vector3 zero2 = Vector3.zero;
					if (closed)
					{
						zero = ((!(percent < num6)) ? EvaluatePosition(percent - num6) : EvaluatePosition(1.0 - (num6 - percent)));
						zero2 = ((!(percent > 1.0 - num6)) ? EvaluatePosition(percent + num6) : EvaluatePosition(num6 - (1.0 - percent)));
						result.forward = zero2 - zero;
					}
					else
					{
						zero = result.position - EvaluatePosition(percent - num6);
						zero2 = EvaluatePosition(percent + num6) - result.position;
						result.forward = Vector3.Slerp(zero2, zero, zero.magnitude / zero2.magnitude);
					}
				}
			}
			else
			{
				EvaluateTangent(ref result.forward, percent);
			}
			result.forward.Normalize();
		}

		public void Evaluate(ref SplineSample[] samples, double from = 0.0, double to = 1.0)
		{
			if (points.Length == 0)
			{
				samples = new SplineSample[0];
				return;
			}
			from = DMath.Clamp01(from);
			to = DMath.Clamp(to, from, 1.0);
			double a = from * (double)(iterations - 1);
			int num = DMath.CeilInt(to * (double)(iterations - 1)) - DMath.FloorInt(a) + 1;
			if (samples == null)
			{
				samples = new SplineSample[num];
			}
			else if (samples.Length != num)
			{
				samples = new SplineSample[num];
			}
			double num2 = from;
			double amount = moveStep;
			int num3 = 0;
			while (true)
			{
				samples[num3] = Evaluate(num2);
				num3++;
				if (num3 < samples.Length)
				{
					num2 = DMath.Move(num2, to, amount);
					continue;
				}
				break;
			}
		}

		public void EvaluateUniform(ref SplineSample[] samples, ref double[] originalSamplePercents, double from = 0.0, double to = 1.0)
		{
			if (points.Length == 0)
			{
				samples = new SplineSample[0];
				return;
			}
			from = DMath.Clamp01(from);
			to = DMath.Clamp(to, from, 1.0);
			double a = from * (double)(iterations - 1);
			int num = DMath.CeilInt(to * (double)(iterations - 1)) - DMath.FloorInt(a) + 1;
			if (samples == null || samples.Length != num)
			{
				samples = new SplineSample[num];
			}
			if (originalSamplePercents == null || originalSamplePercents.Length != num)
			{
				originalSamplePercents = new double[num];
			}
			for (int i = 0; i < samples.Length; i++)
			{
				if (samples[i] == null)
				{
					samples[i] = new SplineSample();
				}
			}
			float distance = CalculateLength(from, to) / (float)(iterations - 1);
			Evaluate(samples[0], from);
			samples[0].percent = (originalSamplePercents[0] = from);
			double num2 = from;
			float moved = 0f;
			for (int j = 1; j < samples.Length - 1; j++)
			{
				Evaluate(samples[j], Travel(num2, distance, out moved, Direction.Forward));
				num2 = samples[j].percent;
				originalSamplePercents[j] = num2;
				samples[j].percent = DMath.Lerp(from, to, (double)j / (double)(samples.Length - 1));
			}
			Evaluate(samples[samples.Length - 1], to);
			samples[samples.Length - 1].percent = (originalSamplePercents[originalSamplePercents.Length - 1] = to);
		}

		public void EvaluatePositions(ref Vector3[] positions, double from = 0.0, double to = 1.0)
		{
			if (points.Length == 0)
			{
				positions = new Vector3[0];
				return;
			}
			from = DMath.Clamp01(from);
			to = DMath.Clamp(to, from, 1.0);
			double a = from * (double)(iterations - 1);
			int num = DMath.CeilInt(to * (double)(iterations - 1)) - DMath.FloorInt(a) + 1;
			if (positions.Length != num)
			{
				positions = new Vector3[num];
			}
			double num2 = from;
			double amount = moveStep;
			int num3 = 0;
			while (true)
			{
				positions[num3] = EvaluatePosition(num2);
				num3++;
				if (num3 < positions.Length)
				{
					num2 = DMath.Move(num2, to, amount);
					continue;
				}
				break;
			}
		}

		public double Travel(double start, float distance, out float moved, Direction direction)
		{
			moved = 0f;
			if (points.Length <= 1)
			{
				return 0.0;
			}
			if (direction == Direction.Forward && start >= 1.0)
			{
				return 1.0;
			}
			if (direction == Direction.Backward && start <= 0.0)
			{
				return 0.0;
			}
			if (distance == 0f)
			{
				return DMath.Clamp01(start);
			}
			Vector3 point = Vector3.zero;
			EvaluatePosition(ref point, start);
			Vector3 b = point;
			double a = start;
			int num = iterations - 1;
			int num2 = ((direction == Direction.Forward) ? DMath.CeilInt(start * (double)num) : DMath.FloorInt(start * (double)num));
			float num3 = 0f;
			double num4 = start;
			while (true)
			{
				num4 = (double)num2 / (double)num;
				point = EvaluatePosition(num4);
				num3 = Vector3.Distance(point, b);
				b = point;
				moved += num3;
				if (moved >= distance)
				{
					break;
				}
				a = num4;
				if (direction == Direction.Forward)
				{
					if (num2 == num)
					{
						break;
					}
					num2++;
				}
				else
				{
					if (num2 == 0)
					{
						break;
					}
					num2--;
				}
			}
			return DMath.Lerp(a, num4, 1f - (moved - distance) / num3);
		}

		public double Travel(double start, float distance, Direction direction = Direction.Forward)
		{
			float moved;
			return Travel(start, distance, out moved, direction);
		}

		public void EvaluatePosition(ref Vector3 point, double percent)
		{
			percent = DMath.Clamp01(percent);
			double num = (double)(points.Length - 1) * percent;
			int num2 = DMath.FloorInt(num);
			if (type == Type.Bezier)
			{
				num2 = Mathf.Clamp(num2, 0, Mathf.Max(points.Length - 2, 0));
			}
			GetPoint(ref point, num - (double)num2, num2);
		}

		public void EvaluateTangent(ref Vector3 tangent, double percent)
		{
			percent = DMath.Clamp01(percent);
			double num = (double)(points.Length - 1) * percent;
			int num2 = DMath.FloorInt(num);
			if (type == Type.Bezier)
			{
				num2 = Mathf.Clamp(num2, 0, Mathf.Max(points.Length - 2, 0));
			}
			GetTangent(ref tangent, num - (double)num2, num2);
		}

		private double GetClosestPoint(int iterations, Vector3 point, double start, double end, int slices)
		{
			if (iterations <= 0)
			{
				float sqrMagnitude = (point - EvaluatePosition(start)).sqrMagnitude;
				float sqrMagnitude2 = (point - EvaluatePosition(end)).sqrMagnitude;
				if (sqrMagnitude < sqrMagnitude2)
				{
					return start;
				}
				if (sqrMagnitude2 < sqrMagnitude)
				{
					return end;
				}
				return (start + end) / 2.0;
			}
			double num = 0.0;
			float num2 = float.PositiveInfinity;
			double num3 = (end - start) / (double)slices;
			double num4 = start;
			Vector3 point2 = Vector3.zero;
			while (true)
			{
				EvaluatePosition(ref point2, num4);
				float sqrMagnitude3 = (point - point2).sqrMagnitude;
				if (sqrMagnitude3 < num2)
				{
					num2 = sqrMagnitude3;
					num = num4;
				}
				if (num4 == end)
				{
					break;
				}
				num4 = DMath.Move(num4, end, num3);
			}
			double num5 = num - num3;
			if (num5 < start)
			{
				num5 = start;
			}
			double num6 = num + num3;
			if (num6 > end)
			{
				num6 = end;
			}
			return GetClosestPoint(--iterations, point, num5, num6, slices);
		}

		public void Break()
		{
			Break(0);
		}

		public void Break(int at)
		{
			if (closed && at < points.Length)
			{
				SplinePoint[] array = new SplinePoint[at];
				for (int i = 0; i < array.Length; i++)
				{
					array[i] = points[i];
				}
				for (int j = at; j < points.Length - 1; j++)
				{
					points[j - at] = points[j];
				}
				for (int k = 0; k < array.Length; k++)
				{
					points[points.Length - at + k - 1] = array[k];
				}
				points[points.Length - 1] = points[0];
				closed = false;
			}
		}

		public void Close()
		{
			if (points.Length < 4)
			{
				UnityEngine.Debug.LogError("Points need to be at least 4 to close the spline");
			}
			else
			{
				closed = true;
			}
		}

		public void CatToBezierTangents()
		{
			switch (type)
			{
			case Type.Linear:
			{
				for (int j = 0; j < points.Length; j++)
				{
					points[j].type = SplinePoint.Type.Broken;
					points[j].SetTangentPosition(points[j].position);
					points[j].SetTangent2Position(points[j].position);
				}
				break;
			}
			case Type.CatmullRom:
			{
				for (int i = 0; i < points.Length; i++)
				{
					GetCatPoints(i);
					points[i].type = SplinePoint.Type.SmoothMirrored;
					if (i == 0)
					{
						Vector3 vector = catPoints[1] - catPoints[2];
						if (closed)
						{
							vector = points[points.Length - 2].position - points[i + 1].position;
							points[i].SetTangentPosition(points[i].position + vector / 6f);
						}
						else
						{
							points[i].SetTangentPosition(points[i].position + vector / 3f);
						}
					}
					else if (i == points.Length - 1)
					{
						Vector3 vector2 = catPoints[2] - catPoints[3];
						points[i].SetTangentPosition(points[i].position + vector2 / 3f);
					}
					else
					{
						Vector3 vector3 = catPoints[0] - catPoints[2];
						points[i].SetTangentPosition(points[i].position + vector3 / 6f);
					}
				}
				break;
			}
			}
			type = Type.Bezier;
		}

		private void GetPoint(ref Vector3 point, double percent, int pointIndex)
		{
			if (closed && points.Length > 3)
			{
				if (pointIndex == points.Length - 2)
				{
					points[0].SetTangentPosition(points[points.Length - 1].tangent);
					points[points.Length - 1] = points[0];
				}
			}
			else
			{
				closed = false;
			}
			switch (type)
			{
			case Type.CatmullRom:
				CatmullRomGetPoint(ref point, percent, pointIndex);
				break;
			case Type.Bezier:
				BezierGetPoint(ref point, percent, pointIndex);
				break;
			case Type.BSpline:
				BSPGetPoint(ref point, percent, pointIndex);
				break;
			case Type.Linear:
				LinearGetPoint(ref point, percent, pointIndex);
				break;
			}
		}

		private void GetTangent(ref Vector3 tangent, double percent, int pointIndex)
		{
			switch (type)
			{
			case Type.CatmullRom:
				GetCatmullRomTangent(ref tangent, percent, pointIndex);
				break;
			case Type.Bezier:
				BezierGetTangent(ref tangent, percent, pointIndex);
				break;
			case Type.Linear:
				LinearGetTangent(ref tangent, percent, pointIndex);
				break;
			case Type.BSpline:
				break;
			}
		}

		private void LinearGetPoint(ref Vector3 point, double t, int i)
		{
			if (points.Length == 0)
			{
				point = Vector3.zero;
			}
			else if (i < points.Length - 1)
			{
				t = DMath.Clamp01(t);
				i = Mathf.Clamp(i, 0, points.Length - 2);
				point = Vector3.Lerp(points[i].position, points[i + 1].position, (float)t);
			}
			else
			{
				point = points[i].position;
			}
		}

		private void LinearGetTangent(ref Vector3 tangent, double t, int i)
		{
			if (points.Length == 0)
			{
				tangent = Vector3.forward;
				return;
			}
			GetCatPoints(i);
			if (linearAverageDirection)
			{
				tangent = Vector3.Slerp(catPoints[1] - catPoints[0], catPoints[2] - catPoints[1], 0.5f);
			}
			else
			{
				tangent = catPoints[2] - catPoints[1];
			}
		}

		private void BSPGetPoint(ref Vector3 point, double time, int i)
		{
			if (points.Length != 0)
			{
				point = points[0].position;
			}
			if (points.Length > 1)
			{
				float num = (float)DMath.Clamp01(time);
				GetCatPoints(i);
				point = ((-catPoints[0] + catPoints[2]) / 2f + num * ((catPoints[0] - 2f * catPoints[1] + catPoints[2]) / 2f + num * (-catPoints[0] + 3f * catPoints[1] - 3f * catPoints[2] + catPoints[3]) / 6f)) * num + (catPoints[0] + 4f * catPoints[1] + catPoints[2]) / 6f;
			}
		}

		private void BezierGetPoint(ref Vector3 point, double t, int i)
		{
			if (points.Length != 0)
			{
				point = points[0].position;
				if (points.Length != 1 && i < points.Length - 1)
				{
					t = DMath.Clamp01(t);
					i = Mathf.Clamp(i, 0, points.Length - 2);
					float num = (float)t;
					float num2 = 1f - num;
					point = num2 * num2 * num2 * points[i].position + 3f * num2 * num2 * num * points[i].tangent2 + 3f * num2 * num * num * points[i + 1].tangent + num * num * num * points[i + 1].position;
				}
			}
		}

		private void BezierGetTangent(ref Vector3 tangent, double t, int i)
		{
			if (points.Length != 0)
			{
				tangent = points[0].tangent2;
				if (points.Length != 1 && i < points.Length - 1)
				{
					t = DMath.Clamp01(t);
					i = Mathf.Clamp(i, 0, points.Length - 2);
					float num = (float)t;
					float num2 = 1f - num;
					tangent = -3f * num2 * num2 * points[i].position + 3f * num2 * num2 * points[i].tangent2 - 6f * num * num2 * points[i].tangent2 - 3f * num * num * points[i + 1].tangent + 6f * num * num2 * points[i + 1].tangent + 3f * num * num * points[i + 1].position;
				}
			}
		}

		private void CatmullRomGetPoint(ref Vector3 point, double t, int i)
		{
			float num = (float)t;
			float num2 = num * num;
			float num3 = num2 * num;
			if (points.Length != 0)
			{
				point = points[0].position;
			}
			if (i < points.Length && points.Length > 1)
			{
				GetCatPoints(i);
				point = 0.5f * (2f * catPoints[1] + (-catPoints[0] + catPoints[2]) * num + (2f * catPoints[0] - 5f * catPoints[1] + 4f * catPoints[2] - catPoints[3]) * num2 + (-catPoints[0] + 3f * catPoints[1] - 3f * catPoints[2] + catPoints[3]) * num3);
			}
		}

		private void GetCatmullRomTangent(ref Vector3 direction, double t, int i)
		{
			float num = (float)t;
			float num2 = num * num;
			if (points.Length != 0)
			{
				direction = Vector3.forward;
			}
			if (i < points.Length && points.Length > 1)
			{
				GetCatPoints(i);
				direction = (6f * num2 - 6f * num) * catPoints[1] + (3f * num2 - 4f * num + 1f) * (catPoints[2] - catPoints[0]) * 0.5f + (-6f * num2 + 6f * num) * catPoints[2] + (3f * num2 - 2f * num) * (catPoints[3] - catPoints[1]) * 0.5f;
			}
		}

		private void GetCatPoints(int i)
		{
			if (i > 0)
			{
				catPoints[0] = points[i - 1].position;
			}
			else if (closed && points.Length - 2 > i)
			{
				catPoints[0] = points[points.Length - 2].position;
			}
			else if (i + 1 < points.Length)
			{
				catPoints[0] = points[i].position + (points[i].position - points[i + 1].position);
			}
			else
			{
				catPoints[0] = points[i].position;
			}
			catPoints[1] = points[i].position;
			if (i + 1 < points.Length)
			{
				catPoints[2] = points[i + 1].position;
			}
			else if (closed && i + 2 - points.Length != i)
			{
				catPoints[2] = points[i + 2 - points.Length].position;
			}
			else
			{
				catPoints[2] = catPoints[1] + (catPoints[1] - catPoints[0]);
			}
			if (i + 2 < points.Length)
			{
				catPoints[3] = points[i + 2].position;
			}
			else if (closed && i + 3 - points.Length != i)
			{
				catPoints[3] = points[i + 3 - points.Length].position;
			}
			else
			{
				catPoints[3] = catPoints[2] + (catPoints[2] - catPoints[1]);
			}
		}

		public static void FormatFromTo(ref double from, ref double to, bool preventInvert = true)
		{
			from = DMath.Clamp01(from);
			to = DMath.Clamp01(to);
			if (preventInvert && from > to)
			{
				double num = from;
				from = to;
				to = num;
			}
			else
			{
				to = DMath.Clamp(to, 0.0, 1.0);
			}
		}
	}
	[Serializable]
	public struct SplinePoint
	{
		public enum Type
		{
			SmoothMirrored,
			Broken,
			SmoothFree
		}

		[FormerlySerializedAs("type")]
		[SerializeField]
		[HideInInspector]
		private Type _type;

		public Vector3 position;

		public Color color;

		public Vector3 normal;

		public float size;

		public Vector3 tangent;

		public Vector3 tangent2;

		public Type type
		{
			get
			{
				return _type;
			}
			set
			{
				_type = value;
				if (value == Type.SmoothMirrored)
				{
					SmoothMirrorTangent2();
				}
			}
		}

		public static SplinePoint Lerp(SplinePoint a, SplinePoint b, float t)
		{
			SplinePoint result = a;
			if (a.type == Type.Broken || b.type == Type.Broken)
			{
				result.type = Type.Broken;
			}
			else if (a.type == Type.SmoothFree || b.type == Type.SmoothFree)
			{
				result.type = Type.SmoothFree;
			}
			else
			{
				result.type = Type.SmoothMirrored;
			}
			result.position = Vector3.Lerp(a.position, b.position, t);
			GetInterpolatedTangents(a, b, t, out result.tangent, out result.tangent2);
			result.color = Color.Lerp(a.color, b.color, t);
			result.size = Mathf.Lerp(a.size, b.size, t);
			result.normal = Vector3.Slerp(a.normal, b.normal, t);
			return result;
		}

		private static void GetInterpolatedTangents(SplinePoint a, SplinePoint b, float t, out Vector3 t1, out Vector3 t2)
		{
			Vector3 vector = (1f - t) * a.position + t * a.tangent2;
			Vector3 vector2 = (1f - t) * a.tangent2 + t * b.tangent;
			Vector3 vector3 = (1f - t) * b.tangent + t * b.position;
			Vector3 vector4 = (1f - t) * vector + t * vector2;
			Vector3 vector5 = (1f - t) * vector2 + t * vector3;
			t1 = vector4;
			t2 = vector5;
		}

		public static bool AreDifferent(ref SplinePoint a, ref SplinePoint b)
		{
			if (a.position != b.position)
			{
				return true;
			}
			if (a.tangent != b.tangent)
			{
				return true;
			}
			if (a.tangent2 != b.tangent2)
			{
				return true;
			}
			if (a.normal != b.normal)
			{
				return true;
			}
			if (a.color != b.color)
			{
				return true;
			}
			if (a.size != b.size)
			{
				return true;
			}
			if (a.type != b.type)
			{
				return true;
			}
			return false;
		}

		public void SetPosition(Vector3 pos)
		{
			tangent -= position - pos;
			tangent2 -= position - pos;
			position = pos;
		}

		public void SetTangentPosition(Vector3 pos)
		{
			tangent = pos;
			switch (_type)
			{
			case Type.SmoothMirrored:
				SmoothMirrorTangent2();
				break;
			case Type.SmoothFree:
				SmoothFreeTangent2();
				break;
			}
		}

		public void SetTangent2Position(Vector3 pos)
		{
			tangent2 = pos;
			switch (_type)
			{
			case Type.SmoothMirrored:
				SmoothMirrorTangent();
				break;
			case Type.SmoothFree:
				SmoothFreeTangent();
				break;
			}
		}

		public SplinePoint(Vector3 p)
		{
			position = p;
			tangent = p;
			tangent2 = p;
			color = Color.white;
			normal = Vector3.up;
			size = 1f;
			_type = Type.SmoothMirrored;
			SmoothMirrorTangent2();
		}

		public SplinePoint(Vector3 p, Vector3 t)
		{
			position = p;
			tangent = t;
			tangent2 = p + (p - t);
			color = Color.white;
			normal = Vector3.up;
			size = 1f;
			_type = Type.SmoothMirrored;
			SmoothMirrorTangent2();
		}

		public SplinePoint(Vector3 pos, Vector3 tan, Vector3 nor, float s, Color col)
		{
			position = pos;
			tangent = tan;
			tangent2 = pos + (pos - tan);
			normal = nor;
			size = s;
			color = col;
			_type = Type.SmoothMirrored;
			SmoothMirrorTangent2();
		}

		public SplinePoint(Vector3 pos, Vector3 tan, Vector3 tan2, Vector3 nor, float s, Color col)
		{
			position = pos;
			tangent = tan;
			tangent2 = tan2;
			normal = nor;
			size = s;
			color = col;
			_type = Type.Broken;
			switch (_type)
			{
			case Type.SmoothMirrored:
				SmoothMirrorTangent2();
				break;
			case Type.SmoothFree:
				SmoothFreeTangent2();
				break;
			}
		}

		public SplinePoint(SplinePoint source)
		{
			position = source.position;
			tangent = source.tangent;
			tangent2 = source.tangent2;
			color = source.color;
			normal = source.normal;
			size = source.size;
			_type = source.type;
			switch (_type)
			{
			case Type.SmoothMirrored:
				SmoothMirrorTangent2();
				break;
			case Type.SmoothFree:
				SmoothFreeTangent2();
				break;
			}
		}

		private void SmoothMirrorTangent2()
		{
			tangent2 = position + (position - tangent);
		}

		private void SmoothMirrorTangent()
		{
			tangent = position + (position - tangent2);
		}

		private void SmoothFreeTangent2()
		{
			tangent2 = position + (position - tangent).normalized * (tangent2 - position).magnitude;
		}

		private void SmoothFreeTangent()
		{
			tangent = position + (position - tangent2).normalized * (tangent - position).magnitude;
		}
	}
	[Serializable]
	public class SplineSample
	{
		public Vector3 position = Vector3.zero;

		public Vector3 up = Vector3.up;

		public Vector3 forward = Vector3.forward;

		public Color color = Color.white;

		public float size = 1f;

		public double percent;

		public Quaternion rotation
		{
			get
			{
				if (up == forward)
				{
					if (up == Vector3.up)
					{
						return Quaternion.LookRotation(Vector3.up, Vector3.back);
					}
					return Quaternion.LookRotation(forward, Vector3.up);
				}
				return Quaternion.LookRotation(forward, up);
			}
		}

		public Vector3 right
		{
			get
			{
				if (up == forward)
				{
					if (up == Vector3.up)
					{
						return Vector3.right;
					}
					return Vector3.Cross(Vector3.up, forward).normalized;
				}
				return Vector3.Cross(up, forward).normalized;
			}
		}

		public static SplineSample Lerp(SplineSample a, SplineSample b, float t)
		{
			SplineSample splineSample = new SplineSample();
			Lerp(a, b, t, splineSample);
			return splineSample;
		}

		public static SplineSample Lerp(SplineSample a, SplineSample b, double t)
		{
			SplineSample splineSample = new SplineSample();
			Lerp(a, b, t, splineSample);
			return splineSample;
		}

		public static void Lerp(SplineSample a, SplineSample b, double t, SplineSample target)
		{
			float t2 = (float)t;
			target.position = DMath.LerpVector3(a.position, b.position, t);
			target.forward = Vector3.Slerp(a.forward, b.forward, t2);
			target.up = Vector3.Slerp(a.up, b.up, t2);
			target.color = Color.Lerp(a.color, b.color, t2);
			target.size = Mathf.Lerp(a.size, b.size, t2);
			target.percent = DMath.Lerp(a.percent, b.percent, t);
		}

		public static void Lerp(SplineSample a, SplineSample b, float t, SplineSample target)
		{
			target.position = DMath.LerpVector3(a.position, b.position, t);
			target.forward = Vector3.Slerp(a.forward, b.forward, t);
			target.up = Vector3.Slerp(a.up, b.up, t);
			target.color = Color.Lerp(a.color, b.color, t);
			target.size = Mathf.Lerp(a.size, b.size, t);
			target.percent = DMath.Lerp(a.percent, b.percent, t);
		}

		public void Lerp(SplineSample b, double t)
		{
			Lerp(this, b, t, this);
		}

		public void Lerp(SplineSample b, float t)
		{
			Lerp(this, b, t, this);
		}

		public void CopyFrom(SplineSample input)
		{
			position = input.position;
			forward = input.forward;
			up = input.up;
			color = input.color;
			size = input.size;
			percent = input.percent;
		}

		public SplineSample()
		{
		}

		public SplineSample(Vector3 position, Vector3 normal, Vector3 direction, Color color, float size, double percent)
		{
			this.position = position;
			up = normal;
			forward = direction;
			this.color = color;
			this.size = size;
			this.percent = percent;
		}

		public SplineSample(SplineSample input)
		{
			position = input.position;
			up = input.up;
			forward = input.forward;
			color = input.color;
			size = input.size;
			percent = input.percent;
		}
	}
	public static class SplineThreading
	{
		public delegate void EmptyHandler();

		internal class ThreadDef
		{
			internal class Worker
			{
				internal bool computing;

				internal Queue<EmptyHandler> instructions = new Queue<EmptyHandler>();
			}

			internal delegate void BoolHandler(bool flag);

			private ParameterizedThreadStart start;

			internal Thread thread;

			private Worker worker = new Worker();

			internal bool isAlive
			{
				get
				{
					if (thread != null)
					{
						return thread.IsAlive;
					}
					return false;
				}
			}

			internal bool computing => worker.computing;

			internal ThreadDef()
			{
				start = RunThread;
			}

			internal void Queue(EmptyHandler handler)
			{
				worker.instructions.Enqueue(handler);
			}

			internal void Interrupt()
			{
				thread.Interrupt();
			}

			internal void Restart()
			{
				thread = new Thread(start);
				thread.Start(worker);
				UnityEngine.Debug.Log("Starting Thread");
			}

			internal void Abort()
			{
				if (isAlive)
				{
					thread.Abort();
				}
				UnityEngine.Debug.Log("Stopping Thread");
			}
		}

		internal static ThreadDef[] threads;

		internal static readonly object locker;

		public static int threadCount
		{
			get
			{
				return threads.Length;
			}
			set
			{
				if (value > threads.Length)
				{
					while (threads.Length < value)
					{
						ThreadDef threadDef = new ThreadDef();
						threadDef.Restart();
						ArrayUtility.Add(ref threads, threadDef);
					}
				}
			}
		}

		static SplineThreading()
		{
			threads = new ThreadDef[2];
			locker = new object();
			for (int i = 0; i < threads.Length; i++)
			{
				threads[i] = new ThreadDef();
			}
		}

		private static void Quitting()
		{
			Stop();
		}

		private static void RunThread(object o)
		{
			ThreadDef.Worker worker = (ThreadDef.Worker)o;
			while (true)
			{
				try
				{
					worker.computing = false;
					Thread.Sleep(-1);
				}
				catch (ThreadInterruptedException)
				{
					worker.computing = true;
					lock (locker)
					{
						while (worker.instructions.Count > 0)
						{
							worker.instructions.Dequeue()?.Invoke();
						}
					}
				}
				catch (Exception ex2)
				{
					if (ex2.Message != "")
					{
						UnityEngine.Debug.Log("THREAD EXCEPTION " + ex2.Message);
					}
					break;
				}
			}
			UnityEngine.Debug.Log("Thread stopped");
			worker.computing = false;
		}

		public static void Run(EmptyHandler handler)
		{
			for (int i = 0; i < threads.Length; i++)
			{
				if (!threads[i].isAlive)
				{
					threads[i].Restart();
				}
				if (!threads[i].computing || i == threads.Length - 1)
				{
					threads[i].Queue(handler);
					if (!threads[i].computing)
					{
						threads[i].Interrupt();
					}
					break;
				}
			}
		}

		public static void PrewarmThreads()
		{
			for (int i = 0; i < threads.Length; i++)
			{
				if (!threads[i].isAlive)
				{
					threads[i].Restart();
				}
			}
		}

		public static void Stop()
		{
			for (int i = 0; i < threads.Length; i++)
			{
				threads[i].Abort();
			}
		}
	}
	[Serializable]
	public class TriggerGroup
	{
		public bool enabled = true;

		public string name = "";

		public Color color = Color.white;

		public SplineTrigger[] triggers = new SplineTrigger[0];

		public void Check(double start, double end, SplineUser user = null)
		{
			for (int i = 0; i < triggers.Length; i++)
			{
				if (triggers[i] != null && triggers[i].Check(start, end))
				{
					triggers[i].Invoke(user);
				}
			}
		}

		public void Reset()
		{
			for (int i = 0; i < triggers.Length; i++)
			{
				triggers[i].Reset();
			}
		}
	}
	[Serializable]
	public class SplineTrigger
	{
		public enum Type
		{
			Double,
			Forward,
			Backward
		}

		public string name = "Trigger";

		[SerializeField]
		public Type type;

		public bool workOnce;

		private bool worked;

		[Range(0f, 1f)]
		public double position = 0.5;

		[SerializeField]
		public bool enabled = true;

		[SerializeField]
		public Color color = Color.white;

		[SerializeField]
		[HideInInspector]
		public UnityEvent onCross = new UnityEvent();

		public event Action<SplineUser> onUserCross;

		public SplineTrigger(Type t)
		{
			type = t;
			enabled = true;
			onCross = new UnityEvent();
		}

		public void AddListener(UnityAction action)
		{
			onCross.AddListener(action);
		}

		public void Reset()
		{
			worked = false;
		}

		public bool Check(double previousPercent, double currentPercent)
		{
			if (!enabled)
			{
				return false;
			}
			if (workOnce && worked)
			{
				return false;
			}
			bool flag = false;
			switch (type)
			{
			case Type.Double:
				flag = (previousPercent <= position && currentPercent >= position) || (currentPercent <= position && previousPercent >= position);
				break;
			case Type.Forward:
				flag = previousPercent <= position && currentPercent >= position;
				break;
			case Type.Backward:
				flag = currentPercent <= position && previousPercent >= position;
				break;
			}
			if (flag)
			{
				worked = true;
			}
			return flag;
		}

		public void Invoke(SplineUser user = null)
		{
			onCross.Invoke();
			if ((bool)user && this.onUserCross != null)
			{
				this.onUserCross(user);
			}
		}
	}
	[Serializable]
	public class TransformModule
	{
		public enum VelocityHandleMode
		{
			Zero,
			Preserve,
			Align,
			AlignRealistic
		}

		[SerializeField]
		[HideInInspector]
		[FormerlySerializedAs("offset")]
		private Vector2 _offset;

		[SerializeField]
		[HideInInspector]
		[FormerlySerializedAs("rotationOffset")]
		private Vector3 _rotationOffset = Vector3.zero;

		[SerializeField]
		[HideInInspector]
		[FormerlySerializedAs("baseScale")]
		private Vector3 _baseScale = Vector3.one;

		public VelocityHandleMode velocityHandleMode;

		private SplineSample _splineResult;

		public bool applyPositionX = true;

		public bool applyPositionY = true;

		public bool applyPositionZ = true;

		public Spline.Direction direction = Spline.Direction.Forward;

		public bool applyRotationX = true;

		public bool applyRotationY = true;

		public bool applyRotationZ = true;

		public bool applyScaleX;

		public bool applyScaleY;

		public bool applyScaleZ;

		[HideInInspector]
		public SplineUser targetUser;

		private static Vector3 position = Vector3.zero;

		private static Quaternion rotation = Quaternion.identity;

		public Vector2 offset
		{
			get
			{
				return _offset;
			}
			set
			{
				if (value != _offset)
				{
					_offset = value;
					if (targetUser != null)
					{
						targetUser.Rebuild();
					}
				}
			}
		}

		public Vector3 rotationOffset
		{
			get
			{
				return _rotationOffset;
			}
			set
			{
				if (value != _rotationOffset)
				{
					_rotationOffset = value;
					if (targetUser != null)
					{
						targetUser.Rebuild();
					}
				}
			}
		}

		public Vector3 baseScale
		{
			get
			{
				return _baseScale;
			}
			set
			{
				if (value != _baseScale)
				{
					_baseScale = value;
					if (targetUser != null)
					{
						targetUser.Rebuild();
					}
				}
			}
		}

		public SplineSample splineResult
		{
			get
			{
				if (_splineResult == null)
				{
					_splineResult = new SplineSample();
				}
				return _splineResult;
			}
			set
			{
				if (_splineResult == null)
				{
					_splineResult = new SplineSample(value);
				}
				else
				{
					_splineResult.CopyFrom(value);
				}
			}
		}

		public bool applyPosition
		{
			get
			{
				if (!applyPositionX && !applyPositionY)
				{
					return applyPositionZ;
				}
				return true;
			}
			set
			{
				applyPositionX = (applyPositionY = (applyPositionZ = value));
			}
		}

		public bool applyRotation
		{
			get
			{
				if (!applyRotationX && !applyRotationY)
				{
					return applyRotationZ;
				}
				return true;
			}
			set
			{
				applyRotationX = (applyRotationY = (applyRotationZ = value));
			}
		}

		public bool applyScale
		{
			get
			{
				if (!applyScaleX && !applyScaleY)
				{
					return applyScaleZ;
				}
				return true;
			}
			set
			{
				applyScaleX = (applyScaleY = (applyScaleZ = value));
			}
		}

		public void ApplyTransform(Transform input)
		{
			input.position = GetPosition(input.position);
			input.rotation = GetRotation(input.rotation);
			input.localScale = GetScale(input.localScale);
		}

		public void ApplyRigidbody(Rigidbody input)
		{
			input.transform.localScale = GetScale(input.transform.localScale);
			input.MovePosition(GetPosition(input.position));
			input.velocity = HandleVelocity(input.velocity);
			Vector3 velocity = input.velocity;
			input.velocity = velocity;
			input.MoveRotation(GetRotation(input.rotation));
			velocity = input.angularVelocity;
			if (applyRotationX)
			{
				velocity.x = 0f;
			}
			if (applyRotationY)
			{
				velocity.y = 0f;
			}
			if (applyRotationZ)
			{
				velocity.z = 0f;
			}
			input.angularVelocity = velocity;
		}

		public void ApplyRigidbody2D(Rigidbody2D input)
		{
			input.transform.localScale = GetScale(input.transform.localScale);
			input.position = GetPosition(input.position);
			input.velocity = HandleVelocity(input.velocity);
			input.rotation = 0f - GetRotation(Quaternion.Euler(0f, 0f, input.rotation)).eulerAngles.z;
			if (applyRotationX)
			{
				input.angularVelocity = 0f;
			}
		}

		private Vector3 HandleVelocity(Vector3 velocity)
		{
			Vector3 vector = Vector3.zero;
			Vector3 right = Vector3.right;
			switch (velocityHandleMode)
			{
			case VelocityHandleMode.Preserve:
				vector = velocity;
				break;
			case VelocityHandleMode.Align:
				right = _splineResult.forward;
				if (Vector3.Dot(velocity, right) < 0f)
				{
					right *= -1f;
				}
				vector = right * velocity.magnitude;
				break;
			case VelocityHandleMode.AlignRealistic:
				right = _splineResult.forward;
				if (Vector3.Dot(velocity, right) < 0f)
				{
					right *= -1f;
				}
				vector = right * velocity.magnitude * Vector3.Dot(velocity.normalized, right);
				break;
			}
			if (applyPositionX)
			{
				velocity.x = vector.x;
			}
			if (applyPositionY)
			{
				velocity.y = vector.y;
			}
			if (applyPositionZ)
			{
				velocity.z = vector.z;
			}
			return velocity;
		}

		private Vector3 GetPosition(Vector3 inputPosition)
		{
			position = _splineResult.position;
			Vector2 vector = _offset;
			if (vector != Vector2.zero)
			{
				position += _splineResult.right * vector.x * _splineResult.size + _splineResult.up * vector.y * _splineResult.size;
			}
			if (applyPositionX)
			{
				inputPosition.x = position.x;
			}
			if (applyPositionY)
			{
				inputPosition.y = position.y;
			}
			if (applyPositionZ)
			{
				inputPosition.z = position.z;
			}
			return inputPosition;
		}

		private Quaternion GetRotation(Quaternion inputRotation)
		{
			rotation = Quaternion.LookRotation(_splineResult.forward * ((direction == Spline.Direction.Forward) ? 1f : (-1f)), _splineResult.up);
			if (_rotationOffset != Vector3.zero)
			{
				rotation *= Quaternion.Euler(_rotationOffset);
			}
			if (!applyRotationX || !applyRotationY)
			{
				Vector3 eulerAngles = rotation.eulerAngles;
				if (!applyRotationX)
				{
					eulerAngles.x = inputRotation.eulerAngles.x;
				}
				if (!applyRotationY)
				{
					eulerAngles.y = inputRotation.eulerAngles.y;
				}
				if (!applyRotationZ)
				{
					eulerAngles.z = inputRotation.eulerAngles.z;
				}
				inputRotation.eulerAngles = eulerAngles;
			}
			else
			{
				inputRotation = rotation;
			}
			return inputRotation;
		}

		private Vector3 GetScale(Vector3 inputScale)
		{
			if (applyScaleX)
			{
				inputScale.x = _baseScale.x * _splineResult.size;
			}
			if (applyScaleY)
			{
				inputScale.y = _baseScale.y * _splineResult.size;
			}
			if (applyScaleZ)
			{
				inputScale.z = _baseScale.z * _splineResult.size;
			}
			return inputScale;
		}
	}
}
namespace Dreamteck.Splines.Primitives
{
	public class Capsule : SplinePrimitive
	{
		public float radius = 1f;

		public float height = 2f;

		public override Spline.Type GetSplineType()
		{
			return Spline.Type.Bezier;
		}

		protected override void Generate()
		{
			base.Generate();
			closed = true;
			CreatePoints(7, SplinePoint.Type.SmoothMirrored);
			points[0].position = Vector3.right / 2f * radius + Vector3.forward * height * 0.5f;
			points[0].SetTangentPosition(points[0].position + Vector3.back * 2f * (Mathf.Sqrt(2f) - 1f) / 3f * radius);
			points[1].position = Vector3.forward / 2f * radius + Vector3.forward * height * 0.5f;
			points[1].SetTangentPosition(points[1].position + Vector3.right * 2f * (Mathf.Sqrt(2f) - 1f) / 3f * radius);
			points[2].position = Vector3.left / 2f * radius + Vector3.forward * height * 0.5f;
			points[2].SetTangentPosition(points[2].position + Vector3.forward * 2f * (Mathf.Sqrt(2f) - 1f) / 3f * radius);
			points[3].position = Vector3.left / 2f * radius + Vector3.back * height * 0.5f;
			points[3].SetTangentPosition(points[3].position + Vector3.forward * 2f * (Mathf.Sqrt(2f) - 1f) / 3f * radius);
			points[4].position = Vector3.back / 2f * radius + Vector3.back * height * 0.5f;
			points[4].SetTangentPosition(points[4].position + Vector3.left * 2f * (Mathf.Sqrt(2f) - 1f) / 3f * radius);
			points[5].position = Vector3.right / 2f * radius + Vector3.back * height * 0.5f;
			points[5].SetTangentPosition(points[5].position + Vector3.back * 2f * (Mathf.Sqrt(2f) - 1f) / 3f * radius);
			points[6] = points[0];
		}
	}
	public class Ellipse : SplinePrimitive
	{
		public float xRadius = 1f;

		public float yRadius = 1f;

		public override Spline.Type GetSplineType()
		{
			return Spline.Type.Bezier;
		}

		protected override void Generate()
		{
			base.Generate();
			closed = true;
			CreatePoints(5, SplinePoint.Type.SmoothMirrored);
			points[0].position = Vector3.forward * yRadius;
			points[0].SetTangentPosition(points[0].position + Vector3.right * 2f * (Mathf.Sqrt(2f) - 1f) / 1.5f * xRadius);
			points[1].position = Vector3.left * xRadius;
			points[1].SetTangentPosition(points[1].position + Vector3.forward * 2f * (Mathf.Sqrt(2f) - 1f) / 1.5f * yRadius);
			points[2].position = Vector3.back * yRadius;
			points[2].SetTangentPosition(points[2].position + Vector3.left * 2f * (Mathf.Sqrt(2f) - 1f) / 1.5f * xRadius);
			points[3].position = Vector3.right * xRadius;
			points[3].SetTangentPosition(points[3].position + Vector3.back * 2f * (Mathf.Sqrt(2f) - 1f) / 1.5f * yRadius);
			points[4] = points[0];
		}
	}
	public class Line : SplinePrimitive
	{
		public bool mirror = true;

		public float length = 1f;

		public int segments = 1;

		public override Spline.Type GetSplineType()
		{
			return Spline.Type.Linear;
		}

		protected override void Generate()
		{
			base.Generate();
			closed = false;
			CreatePoints(segments + 1, SplinePoint.Type.SmoothMirrored);
			Vector3 vector = Vector3.zero;
			if (mirror)
			{
				vector = -Vector3.forward * length * 0.5f;
			}
			for (int i = 0; i < points.Length; i++)
			{
				points[i].position = vector + Vector3.forward * length * ((float)i / (float)(points.Length - 1));
			}
		}
	}
	public class Ngon : SplinePrimitive
	{
		public float radius = 1f;

		public int sides = 3;

		public override Spline.Type GetSplineType()
		{
			return Spline.Type.Linear;
		}

		protected override void Generate()
		{
			base.Generate();
			closed = true;
			CreatePoints(sides + 1, SplinePoint.Type.SmoothMirrored);
			for (int i = 0; i < sides; i++)
			{
				float num = (float)i / (float)sides;
				Vector3 position = Quaternion.AngleAxis(360f * num, Vector3.up) * Vector3.forward * radius;
				points[i].SetPosition(position);
			}
			points[points.Length - 1] = points[0];
		}
	}
	public class Rectangle : SplinePrimitive
	{
		public Vector2 size = Vector2.one;

		public override Spline.Type GetSplineType()
		{
			return Spline.Type.Linear;
		}

		protected override void Generate()
		{
			base.Generate();
			closed = true;
			CreatePoints(5, SplinePoint.Type.SmoothMirrored);
			points[0].position = (points[0].tangent = Vector3.forward / 2f * size.y + Vector3.left / 2f * size.x);
			points[1].position = (points[1].tangent = Vector3.forward / 2f * size.y + Vector3.right / 2f * size.x);
			points[2].position = (points[2].tangent = Vector3.back / 2f * size.y + Vector3.right / 2f * size.x);
			points[3].position = (points[3].tangent = Vector3.back / 2f * size.y + Vector3.left / 2f * size.x);
			points[4] = points[0];
		}
	}
	public class RoundedRectangle : SplinePrimitive
	{
		public Vector2 size = Vector2.one;

		public float xRadius = 0.25f;

		public float yRadius = 0.25f;

		public override Spline.Type GetSplineType()
		{
			return Spline.Type.Bezier;
		}

		protected override void Generate()
		{
			base.Generate();
			closed = true;
			CreatePoints(9, SplinePoint.Type.Broken);
			Vector2 vector = size - new Vector2(xRadius, yRadius) * 2f;
			points[0].SetPosition(Vector3.forward / 2f * vector.y + Vector3.left / 2f * size.x);
			points[1].SetPosition(Vector3.forward / 2f * size.y + Vector3.left / 2f * vector.x);
			points[2].SetPosition(Vector3.forward / 2f * size.y + Vector3.right / 2f * vector.x);
			points[3].SetPosition(Vector3.forward / 2f * vector.y + Vector3.right / 2f * size.x);
			points[4].SetPosition(Vector3.back / 2f * vector.y + Vector3.right / 2f * size.x);
			points[5].SetPosition(Vector3.back / 2f * size.y + Vector3.right / 2f * vector.x);
			points[6].SetPosition(Vector3.back / 2f * size.y + Vector3.left / 2f * vector.x);
			points[7].SetPosition(Vector3.back / 2f * vector.y + Vector3.left / 2f * size.x);
			float num = 2f * (Mathf.Sqrt(2f) - 1f) / 3f * xRadius * 2f;
			float num2 = 2f * (Mathf.Sqrt(2f) - 1f) / 3f * yRadius * 2f;
			points[0].SetTangent2Position(points[0].position + Vector3.forward * num2);
			points[1].SetTangentPosition(points[1].position + Vector3.left * num);
			points[2].SetTangent2Position(points[2].position + Vector3.right * num);
			points[3].SetTangentPosition(points[3].position + Vector3.forward * num2);
			points[4].SetTangent2Position(points[4].position + Vector3.back * num2);
			points[5].SetTangentPosition(points[5].position + Vector3.right * num);
			points[6].SetTangent2Position(points[6].position + Vector3.left * num);
			points[7].SetTangentPosition(points[7].position + Vector3.back * num2);
			points[8] = points[0];
		}
	}
	public class Spiral : SplinePrimitive
	{
		public float startRadius = 1f;

		public float endRadius = 1f;

		public float stretch = 1f;

		public int iterations = 3;

		public bool clockwise = true;

		public AnimationCurve curve = new AnimationCurve();

		public override Spline.Type GetSplineType()
		{
			return Spline.Type.Bezier;
		}

		protected override void Generate()
		{
			base.Generate();
			closed = false;
			CreatePoints(iterations * 4 + 1, SplinePoint.Type.SmoothMirrored);
			float num = Mathf.Abs(endRadius - startRadius) / Mathf.Max(Mathf.Abs(endRadius), Mathf.Abs(startRadius));
			float num2 = 1f;
			if (endRadius > startRadius)
			{
				num2 = -1f;
			}
			float num3 = 0f;
			float num4 = 0f;
			float num5 = (clockwise ? 1f : (-1f));
			for (int i = 0; i <= iterations * 4; i++)
			{
				float num6 = curve.Evaluate((float)i / (float)(iterations * 4));
				float num7 = Mathf.Lerp(startRadius, endRadius, num6);
				Quaternion quaternion = Quaternion.AngleAxis(num3, Vector3.up);
				points[i].position = quaternion * Vector3.forward / 2f * num7 + Vector3.up * num4;
				Quaternion identity = Quaternion.identity;
				identity = ((!(num2 > 0f)) ? Quaternion.AngleAxis(Mathf.Lerp(0f, -14.4f * num5, (1f - num6) * num), Vector3.up) : Quaternion.AngleAxis(Mathf.Lerp(0f, 14.4f * num5, num * num6), Vector3.up));
				if (clockwise)
				{
					points[i].tangent = points[i].position - (identity * quaternion * Vector3.right * num7 + Vector3.up * stretch / 4f) * 2f * (Mathf.Sqrt(2f) - 1f) / 3f;
				}
				else
				{
					points[i].tangent = points[i].position + (identity * quaternion * Vector3.right * num7 - Vector3.up * stretch / 4f) * 2f * (Mathf.Sqrt(2f) - 1f) / 3f;
				}
				points[i].tangent2 = points[i].position - (points[i].tangent - points[i].position);
				num4 += stretch / 4f;
				num3 += 90f * num5;
			}
		}
	}
	public class SplinePrimitive
	{
		protected bool closed;

		protected SplinePoint[] points = new SplinePoint[0];

		public Vector3 offset = Vector3.zero;

		public Vector3 rotation = Vector3.zero;

		public bool is2D;

		public virtual void Calculate()
		{
			Generate();
			ApplyOffset();
		}

		protected virtual void Generate()
		{
		}

		public Spline CreateSpline()
		{
			Generate();
			ApplyOffset();
			Spline spline = new Spline(GetSplineType());
			spline.points = points;
			if (closed)
			{
				spline.Close();
			}
			return spline;
		}

		public void UpdateSpline(Spline spline)
		{
			Generate();
			ApplyOffset();
			spline.type = GetSplineType();
			spline.points = points;
			if (closed)
			{
				spline.Close();
			}
			else if (spline.isClosed)
			{
				spline.Break();
			}
		}

		public SplineComputer CreateSplineComputer(string name, Vector3 position, Quaternion rotation)
		{
			Generate();
			ApplyOffset();
			SplineComputer splineComputer = new GameObject(name).AddComponent<SplineComputer>();
			splineComputer.SetPoints(points, SplineComputer.Space.Local);
			if (closed)
			{
				splineComputer.Close();
			}
			splineComputer.transform.position = position;
			splineComputer.transform.rotation = rotation;
			return splineComputer;
		}

		public void UpdateSplineComputer(SplineComputer comp)
		{
			Generate();
			ApplyOffset();
			comp.type = GetSplineType();
			comp.SetPoints(points, SplineComputer.Space.Local);
			if (closed)
			{
				comp.Close();
			}
			else if (comp.isClosed)
			{
				comp.Break();
			}
		}

		public SplinePoint[] GetPoints()
		{
			return points;
		}

		public virtual Spline.Type GetSplineType()
		{
			return Spline.Type.CatmullRom;
		}

		public bool GetIsClosed()
		{
			return closed;
		}

		private void ApplyOffset()
		{
			Quaternion quaternion = Quaternion.Euler(rotation);
			if (is2D)
			{
				quaternion = Quaternion.AngleAxis(0f - rotation.z, Vector3.forward) * Quaternion.AngleAxis(90f, Vector3.right);
			}
			for (int i = 0; i < points.Length; i++)
			{
				points[i].position = quaternion * points[i].position;
				points[i].tangent = quaternion * points[i].tangent;
				points[i].tangent2 = quaternion * points[i].tangent2;
				points[i].normal = quaternion * points[i].normal;
			}
			for (int j = 0; j < points.Length; j++)
			{
				points[j].SetPosition(points[j].position + offset);
			}
		}

		protected void CreatePoints(int count, SplinePoint.Type type)
		{
			if (points.Length != count)
			{
				points = new SplinePoint[count];
			}
			for (int i = 0; i < points.Length; i++)
			{
				points[i].type = type;
				points[i].normal = Vector3.up;
				points[i].color = Color.white;
				points[i].size = 1f;
			}
		}
	}
	public class Star : SplinePrimitive
	{
		public float radius = 1f;

		public float depth = 0.5f;

		public int sides = 5;

		public override Spline.Type GetSplineType()
		{
			return Spline.Type.Linear;
		}

		protected override void Generate()
		{
			base.Generate();
			closed = true;
			CreatePoints(sides * 2 + 1, SplinePoint.Type.SmoothMirrored);
			float num = radius * depth;
			for (int i = 0; i < sides * 2; i++)
			{
				float num2 = (float)i / (float)(sides * 2);
				Vector3 position = Quaternion.AngleAxis(180f + 360f * num2, Vector3.up) * Vector3.forward * (((float)i % 2f == 0f) ? radius : num);
				points[i].SetPosition(position);
			}
			points[points.Length - 1] = points[0];
		}
	}
}
namespace Dreamteck.Splines.IO
{
	public class CSV : SplineParser
	{
		public enum ColumnType
		{
			Position,
			Tangent,
			Tangent2,
			Normal,
			Size,
			Color
		}

		public List<ColumnType> columns = new List<ColumnType>();

		public CSV(SplineComputer computer)
		{
			Spline spline = new Spline(computer.type, computer.sampleRate)
			{
				points = computer.GetPoints()
			};
			if (spline.type != Spline.Type.Bezier && spline.type != Spline.Type.Linear)
			{
				spline.CatToBezierTangents();
			}
			if (computer.isClosed)
			{
				spline.Close();
			}
			buffer = new SplineDefinition(computer.name, spline);
			fileName = computer.name;
			columns.Add(ColumnType.Position);
			columns.Add(ColumnType.Tangent);
			columns.Add(ColumnType.Tangent2);
		}

		public CSV(string filePath, List<ColumnType> customColumns = null)
		{
			if (!File.Exists(filePath))
			{
				return;
			}
			string text = Path.GetExtension(filePath).ToLower();
			fileName = Path.GetFileNameWithoutExtension(filePath);
			if (text != ".csv")
			{
				UnityEngine.Debug.LogError("CSV Parsing ERROR: Wrong format. Please use SVG or XML");
				return;
			}
			string[] lines = File.ReadAllLines(filePath);
			if (customColumns == null)
			{
				columns.Add(ColumnType.Position);
				columns.Add(ColumnType.Tangent);
				columns.Add(ColumnType.Tangent2);
				columns.Add(ColumnType.Normal);
				columns.Add(ColumnType.Size);
				columns.Add(ColumnType.Color);
			}
			else
			{
				columns = new List<ColumnType>(customColumns);
			}
			buffer = new SplineDefinition(fileName, Spline.Type.CatmullRom);
			Read(lines);
		}

		private void Read(string[] lines)
		{
			int num = 0;
			using (List<ColumnType>.Enumerator enumerator = columns.GetEnumerator())
			{
				while (enumerator.MoveNext())
				{
					switch (enumerator.Current)
					{
					case ColumnType.Position:
						num += 3;
						break;
					case ColumnType.Tangent:
						num += 3;
						break;
					case ColumnType.Tangent2:
						num += 3;
						break;
					case ColumnType.Normal:
						num += 3;
						break;
					case ColumnType.Size:
						num++;
						break;
					case ColumnType.Color:
						num += 4;
						break;
					}
				}
			}
			for (int i = 1; i < lines.Length; i++)
			{
				lines[i] = Regex.Replace(lines[i], "\\s+", "");
				string[] array = lines[i].Split(',');
				if (array.Length != num)
				{
					UnityEngine.Debug.LogError("Unexpected element count on row " + i + ". Expected " + num + " found " + array.Length + " Please make sure that all values exist and the column order is correct.");
					continue;
				}
				float[] array2 = new float[array.Length];
				for (int j = 0; j < array.Length; j++)
				{
					float.TryParse(array[j], out array2[j]);
				}
				int num2 = 0;
				using (List<ColumnType>.Enumerator enumerator = columns.GetEnumerator())
				{
					while (enumerator.MoveNext())
					{
						switch (enumerator.Current)
						{
						case ColumnType.Position:
							buffer.position = new Vector3(array2[num2++], array2[num2++], array2[num2++]);
							break;
						case ColumnType.Tangent:
							buffer.tangent = new Vector3(array2[num2++], array2[num2++], array2[num2++]);
							break;
						case ColumnType.Tangent2:
							buffer.tangent2 = new Vector3(array2[num2++], array2[num2++], array2[num2++]);
							break;
						case ColumnType.Normal:
							buffer.normal = new Vector3(array2[num2++], array2[num2++], array2[num2++]);
							break;
						case ColumnType.Size:
							buffer.size = array2[num2++];
							break;
						case ColumnType.Color:
							buffer.color = new Color(array2[num2++], array2[num2++], array2[num2++], array2[num2++]);
							break;
						}
					}
				}
				buffer.CreateSmooth();
			}
		}

		public SplineComputer CreateSplineComputer(Vector3 position, Quaternion rotation)
		{
			return buffer.CreateSplineComputer(position, rotation);
		}

		public Spline CreateSpline()
		{
			return buffer.CreateSpline();
		}

		public void FlatX()
		{
			for (int i = 0; i < buffer.pointCount; i++)
			{
				SplinePoint value = buffer.points[i];
				value.position.x = 0f;
				value.tangent.x = 0f;
				value.tangent2.x = 0f;
				value.normal = Vector3.right;
				buffer.points[i] = value;
			}
		}

		public void FlatY()
		{
			for (int i = 0; i < buffer.pointCount; i++)
			{
				SplinePoint value = buffer.points[i];
				value.position.y = 0f;
				value.tangent.y = 0f;
				value.tangent2.y = 0f;
				value.normal = Vector3.up;
				buffer.points[i] = value;
			}
		}

		public void FlatZ()
		{
			for (int i = 0; i < buffer.pointCount; i++)
			{
				SplinePoint value = buffer.points[i];
				value.position.z = 0f;
				value.tangent.z = 0f;
				value.tangent2.z = 0f;
				value.normal = Vector3.back;
				buffer.points[i] = value;
			}
		}

		private void AddTitle(ref string[] content, string title)
		{
			if (!string.IsNullOrEmpty(content[0]))
			{
				content[0] += ",";
			}
			content[0] += title;
		}

		private void AddVector3Title(ref string[] content, string prefix)
		{
			AddTitle(ref content, prefix + "X," + prefix + "Y," + prefix + "Z");
		}

		private void AddColorTitle(ref string[] content, string prefix)
		{
			AddTitle(ref content, prefix + "R," + prefix + "G," + prefix + "B" + prefix + "A");
		}

		private void AddVector3(ref string[] content, int index, Vector3 vector)
		{
			AddFloat(ref content, index, vector.x);
			AddFloat(ref content, index, vector.y);
			AddFloat(ref content, index, vector.z);
		}

		private void AddColor(ref string[] content, int index, Color color)
		{
			AddFloat(ref content, index, color.r);
			AddFloat(ref content, index, color.g);
			AddFloat(ref content, index, color.b);
			AddFloat(ref content, index, color.a);
		}

		private void AddFloat(ref string[] content, int index, float value)
		{
			if (!string.IsNullOrEmpty(content[index]))
			{
				content[index] += ",";
			}
			content[index] += value;
		}

		public void Write(string filePath)
		{
			if (!Directory.Exists(Path.GetDirectoryName(filePath)))
			{
				throw new DirectoryNotFoundException("The file is being saved to a non-existing directory.");
			}
			List<SplinePoint> points = buffer.points;
			string[] content = new string[points.Count + 1];
			using (List<ColumnType>.Enumerator enumerator = columns.GetEnumerator())
			{
				while (enumerator.MoveNext())
				{
					switch (enumerator.Current)
					{
					case ColumnType.Position:
						AddVector3Title(ref content, "Position");
						break;
					case ColumnType.Tangent:
						AddVector3Title(ref content, "Tangent");
						break;
					case ColumnType.Tangent2:
						AddVector3Title(ref content, "Tangent2");
						break;
					case ColumnType.Normal:
						AddVector3Title(ref content, "Normal");
						break;
					case ColumnType.Size:
						AddTitle(ref content, "Size");
						break;
					case ColumnType.Color:
						AddColorTitle(ref content, "Color");
						break;
					}
				}
			}
			foreach (ColumnType column in columns)
			{
				for (int i = 1; i <= points.Count; i++)
				{
					int index = i - 1;
					switch (column)
					{
					case ColumnType.Position:
						AddVector3(ref content, i, points[index].position);
						break;
					case ColumnType.Tangent:
						AddVector3(ref content, i, points[index].tangent);
						break;
					case ColumnType.Tangent2:
						AddVector3(ref content, i, points[index].tangent2);
						break;
					case ColumnType.Normal:
						AddVector3(ref content, i, points[index].normal);
						break;
					case ColumnType.Size:
						AddFloat(ref content, i, points[index].size);
						break;
					case ColumnType.Color:
						AddColor(ref content, i, points[index].color);
						break;
					}
				}
			}
			File.WriteAllLines(filePath, content);
		}
	}
	public class SVG : SplineParser
	{
		public enum Axis
		{
			X,
			Y,
			Z
		}

		internal class PathSegment
		{
			internal enum Type
			{
				Cubic,
				CubicShort,
				Quadratic,
				QuadraticShort
			}

			internal Vector3 startTangent = Vector3.zero;

			internal Vector3 endTangent = Vector3.zero;

			internal Vector3 endPoint = Vector3.zero;

			internal PathSegment(Vector2 s, Vector2 e, Vector2 c)
			{
				startTangent = s;
				endTangent = e;
				endPoint = c;
			}

			internal PathSegment()
			{
			}
		}

		public enum Element
		{
			All,
			Path,
			Polygon,
			Ellipse,
			Rectangle,
			Line
		}

		private List<SplineDefinition> paths = new List<SplineDefinition>();

		private List<SplineDefinition> polygons = new List<SplineDefinition>();

		private List<SplineDefinition> ellipses = new List<SplineDefinition>();

		private List<SplineDefinition> rectangles = new List<SplineDefinition>();

		private List<SplineDefinition> lines = new List<SplineDefinition>();

		private List<Transformation> transformBuffer = new List<Transformation>();

		public SVG(string filePath)
		{
			if (!File.Exists(filePath))
			{
				return;
			}
			string text = Path.GetExtension(filePath).ToLower();
			fileName = Path.GetFileNameWithoutExtension(filePath);
			if (text != ".svg" && text != ".xml")
			{
				UnityEngine.Debug.LogError("SVG Parsing ERROR: Wrong format. Please use SVG or XML");
				return;
			}
			XmlDocument xmlDocument = new XmlDocument
			{
				XmlResolver = null
			};
			try
			{
				xmlDocument.Load(filePath);
			}
			catch (XmlException ex)
			{
				UnityEngine.Debug.LogError(ex.Message);
				return;
			}
			Read(xmlDocument);
		}

		public SVG(List<SplineComputer> computers)
		{
			paths = new List<SplineDefinition>(computers.Count);
			for (int i = 0; i < computers.Count; i++)
			{
				if (!(computers[i] == null))
				{
					Spline spline = new Spline(computers[i].type, computers[i].sampleRate)
					{
						points = computers[i].GetPoints()
					};
					if (spline.type != Spline.Type.Bezier && spline.type != Spline.Type.Linear)
					{
						spline.CatToBezierTangents();
					}
					if (computers[i].isClosed)
					{
						spline.Close();
					}
					paths.Add(new SplineDefinition(computers[i].name, spline));
				}
			}
		}

		public void Write(string filePath, Axis ax = Axis.Z)
		{
			XmlDocument xmlDocument = new XmlDocument();
			XmlElement xmlElement = xmlDocument.CreateElement("svg");
			foreach (SplineDefinition path in paths)
			{
				string text = "path";
				string text2 = "d";
				if (path.type == Spline.Type.Linear)
				{
					text2 = "points";
					text = ((!path.closed) ? "polyline" : "polygon");
				}
				XmlElement xmlElement2 = xmlDocument.CreateElement(text);
				XmlAttribute xmlAttribute = xmlDocument.CreateAttribute("id");
				xmlAttribute.Value = path.name;
				xmlElement2.Attributes.Append(xmlAttribute);
				xmlAttribute = xmlDocument.CreateAttribute(text2);
				if (path.type == Spline.Type.Linear)
				{
					xmlAttribute.Value = EncodePolygon(path, ax);
				}
				else
				{
					xmlAttribute.Value = EncodePath(path, ax);
				}
				xmlElement2.Attributes.Append(xmlAttribute);
				xmlAttribute = xmlDocument.CreateAttribute("stroke");
				xmlAttribute.Value = "black";
				xmlElement2.Attributes.Append(xmlAttribute);
				xmlAttribute = xmlDocument.CreateAttribute("stroke-width");
				xmlAttribute.Value = "3";
				xmlElement2.Attributes.Append(xmlAttribute);
				xmlAttribute = xmlDocument.CreateAttribute("fill");
				xmlAttribute.Value = "none";
				xmlElement2.Attributes.Append(xmlAttribute);
				xmlElement.AppendChild(xmlElement2);
			}
			XmlAttribute xmlAttribute2 = xmlDocument.CreateAttribute("version");
			xmlAttribute2.Value = "1.1";
			xmlElement.Attributes.Append(xmlAttribute2);
			xmlAttribute2 = xmlDocument.CreateAttribute("xmlns");
			xmlAttribute2.Value = "http://www.w3.org/2000/svg";
			xmlElement.Attributes.Append(xmlAttribute2);
			xmlDocument.AppendChild(xmlElement);
			xmlDocument.Save(filePath);
		}

		private Vector2 MapPoint(Vector3 original, Axis ax)
		{
			return ax switch
			{
				Axis.X => new Vector2(original.z, 0f - original.y), 
				Axis.Y => new Vector2(original.x, 0f - original.z), 
				Axis.Z => new Vector2(original.x, 0f - original.y), 
				_ => original, 
			};
		}

		private void Read(XmlDocument doc)
		{
			transformBuffer.Clear();
			Traverse(doc.ChildNodes);
		}

		private void Traverse(XmlNodeList nodes)
		{
			foreach (XmlNode node in nodes)
			{
				int num = 0;
				switch (node.Name)
				{
				case "g":
					num = ParseTransformation(node);
					break;
				case "path":
					num = ReadPath(node);
					break;
				case "polygon":
					num = ReadPolygon(node, closed: true);
					break;
				case "polyline":
					num = ReadPolygon(node, closed: false);
					break;
				case "ellipse":
					num = ReadEllipse(node);
					break;
				case "circle":
					num = ReadEllipse(node);
					break;
				case "line":
					num = ReadLine(node);
					break;
				case "rect":
					num = ReadRectangle(node);
					break;
				}
				Traverse(node.ChildNodes);
				if (num > 0)
				{
					transformBuffer.RemoveRange(transformBuffer.Count - num, num);
				}
			}
		}

		public List<SplineComputer> CreateSplineComputers(Vector3 position, Quaternion rotation, Element elements = Element.All)
		{
			List<SplineComputer> list = new List<SplineComputer>();
			if (elements == Element.All || elements == Element.Path)
			{
				foreach (SplineDefinition path in paths)
				{
					list.Add(path.CreateSplineComputer(position, rotation));
				}
			}
			if (elements == Element.All || elements == Element.Polygon)
			{
				foreach (SplineDefinition polygon in polygons)
				{
					list.Add(polygon.CreateSplineComputer(position, rotation));
				}
			}
			if (elements == Element.All || elements == Element.Ellipse)
			{
				foreach (SplineDefinition ellipsis in ellipses)
				{
					list.Add(ellipsis.CreateSplineComputer(position, rotation));
				}
			}
			if (elements == Element.All || elements == Element.Rectangle)
			{
				foreach (SplineDefinition rectangle in rectangles)
				{
					list.Add(rectangle.CreateSplineComputer(position, rotation));
				}
			}
			if (elements == Element.All || elements == Element.Line)
			{
				foreach (SplineDefinition line in lines)
				{
					list.Add(line.CreateSplineComputer(position, rotation));
				}
			}
			return list;
		}

		public List<Spline> CreateSplines(Element elements = Element.All)
		{
			List<Spline> list = new List<Spline>();
			if (elements == Element.All || elements == Element.Path)
			{
				foreach (SplineDefinition path in paths)
				{
					list.Add(path.CreateSpline());
				}
			}
			if (elements == Element.All || elements == Element.Polygon)
			{
				foreach (SplineDefinition polygon in polygons)
				{
					list.Add(polygon.CreateSpline());
				}
			}
			if (elements == Element.All || elements == Element.Ellipse)
			{
				foreach (SplineDefinition ellipsis in ellipses)
				{
					list.Add(ellipsis.CreateSpline());
				}
			}
			if (elements == Element.All || elements == Element.Rectangle)
			{
				foreach (SplineDefinition rectangle in rectangles)
				{
					list.Add(rectangle.CreateSpline());
				}
			}
			if (elements == Element.All || elements == Element.Line)
			{
				foreach (SplineDefinition line in lines)
				{
					list.Add(line.CreateSpline());
				}
			}
			return list;
		}

		private int ReadRectangle(XmlNode rectNode)
		{
			float result = 0f;
			float result2 = 0f;
			float result3 = 0f;
			float result4 = 0f;
			float result5 = -1f;
			float result6 = -1f;
			string attributeContent = GetAttributeContent(rectNode, "x");
			if (attributeContent == "ERROR")
			{
				return 0;
			}
			float.TryParse(attributeContent, out result);
			attributeContent = GetAttributeContent(rectNode, "y");
			if (attributeContent == "ERROR")
			{
				return 0;
			}
			float.TryParse(attributeContent, out result2);
			attributeContent = GetAttributeContent(rectNode, "width");
			if (attributeContent == "ERROR")
			{
				return 0;
			}
			float.TryParse(attributeContent, out result3);
			attributeContent = GetAttributeContent(rectNode, "height");
			if (attributeContent == "ERROR")
			{
				return 0;
			}
			float.TryParse(attributeContent, out result4);
			attributeContent = GetAttributeContent(rectNode, "rx");
			if (attributeContent != "ERROR")
			{
				float.TryParse(attributeContent, out result5);
			}
			attributeContent = GetAttributeContent(rectNode, "ry");
			if (attributeContent != "ERROR")
			{
				float.TryParse(attributeContent, out result6);
			}
			else
			{
				result6 = result5;
			}
			string text = GetAttributeContent(rectNode, "id");
			if (result5 == -1f && result6 == -1f)
			{
				Rectangle rectangle = new Rectangle();
				rectangle.offset = new Vector2(result + result3 / 2f, 0f - result2 - result4 / 2f);
				rectangle.size = new Vector2(result3, result4);
				if (text == "ERROR")
				{
					text = fileName + "_rectangle" + (rectangles.Count + 1);
				}
				buffer = new SplineDefinition(text, rectangle.CreateSpline());
			}
			else
			{
				RoundedRectangle roundedRectangle = new RoundedRectangle();
				roundedRectangle.offset = new Vector2(result + result3 / 2f, 0f - result2 - result4 / 2f);
				roundedRectangle.size = new Vector2(result3, result4);
				roundedRectangle.xRadius = result5;
				roundedRectangle.yRadius = result6;
				if (text == "ERROR")
				{
					text = fileName + "_roundedRectangle" + (rectangles.Count + 1);
				}
				buffer = new SplineDefinition(text, roundedRectangle.CreateSpline());
			}
			int result7 = ParseTransformation(rectNode);
			WriteBufferTo(rectangles);
			return result7;
		}

		private int ReadLine(XmlNode lineNode)
		{
			float result = 0f;
			float result2 = 0f;
			float result3 = 0f;
			float result4 = 0f;
			string attributeContent = GetAttributeContent(lineNode, "x1");
			if (attributeContent == "ERROR")
			{
				return 0;
			}
			float.TryParse(attributeContent, out result);
			attributeContent = GetAttributeContent(lineNode, "y1");
			if (attributeContent == "ERROR")
			{
				return 0;
			}
			float.TryParse(attributeContent, out result2);
			attributeContent = GetAttributeContent(lineNode, "x2");
			if (attributeContent == "ERROR")
			{
				return 0;
			}
			float.TryParse(attributeContent, out result3);
			attributeContent = GetAttributeContent(lineNode, "y2");
			if (attributeContent == "ERROR")
			{
				return 0;
			}
			float.TryParse(attributeContent, out result4);
			string text = GetAttributeContent(lineNode, "id");
			if (text == "ERROR")
			{
				text = fileName + "_line" + (ellipses.Count + 1);
			}
			buffer = new SplineDefinition(text, Spline.Type.Linear);
			buffer.position = new Vector2(result, 0f - result2);
			buffer.CreateLinear();
			buffer.position = new Vector2(result3, 0f - result4);
			buffer.CreateLinear();
			int result5 = ParseTransformation(lineNode);
			WriteBufferTo(lines);
			return result5;
		}

		private int ReadEllipse(XmlNode ellipseNode)
		{
			float result = 0f;
			float result2 = 0f;
			float result3 = 0f;
			float result4 = 0f;
			string attributeContent = GetAttributeContent(ellipseNode, "cx");
			if (attributeContent == "ERROR")
			{
				return 0;
			}
			float.TryParse(attributeContent, out result);
			attributeContent = GetAttributeContent(ellipseNode, "cy");
			if (attributeContent == "ERROR")
			{
				return 0;
			}
			float.TryParse(attributeContent, out result2);
			attributeContent = GetAttributeContent(ellipseNode, "r");
			string text = "circle";
			if (attributeContent == "ERROR")
			{
				text = "ellipse";
				attributeContent = GetAttributeContent(ellipseNode, "rx");
				if (attributeContent == "ERROR")
				{
					return 0;
				}
				float.TryParse(attributeContent, out result3);
				attributeContent = GetAttributeContent(ellipseNode, "ry");
				if (attributeContent == "ERROR")
				{
					return 0;
				}
			}
			else
			{
				float.TryParse(attributeContent, out result3);
				result4 = result3;
			}
			float.TryParse(attributeContent, out result4);
			Ellipse ellipse = new Ellipse();
			ellipse.offset = new Vector2(result, 0f - result2);
			ellipse.xRadius = result3;
			ellipse.yRadius = result4;
			string text2 = GetAttributeContent(ellipseNode, "id");
			if (text2 == "ERROR")
			{
				text2 = fileName + "_" + text + (ellipses.Count + 1);
			}
			buffer = new SplineDefinition(text2, ellipse.CreateSpline());
			int result5 = ParseTransformation(ellipseNode);
			WriteBufferTo(ellipses);
			return result5;
		}

		private int ReadPolygon(XmlNode polyNode, bool closed)
		{
			string attributeContent = GetAttributeContent(polyNode, "points");
			if (attributeContent == "ERROR")
			{
				return 0;
			}
			List<float> list = ParseFloatArray(attributeContent);
			if (list.Count % 2 != 0)
			{
				UnityEngine.Debug.LogWarning("There is an error with one of the polygon shapes.");
				return 0;
			}
			string text = GetAttributeContent(polyNode, "id");
			if (text == "ERROR")
			{
				text = fileName + (closed ? "_polygon " : "_polyline") + (polygons.Count + 1);
			}
			buffer = new SplineDefinition(text, Spline.Type.Linear);
			int num = list.Count / 2;
			for (int i = 0; i < num; i++)
			{
				buffer.position = new Vector2(list[2 * i], 0f - list[1 + 2 * i]);
				buffer.CreateLinear();
			}
			if (closed)
			{
				buffer.CreateClosingPoint();
				buffer.closed = true;
			}
			int result = ParseTransformation(polyNode);
			WriteBufferTo(polygons);
			return result;
		}

		private int ParseTransformation(XmlNode node)
		{
			string attributeContent = GetAttributeContent(node, "transform");
			if (attributeContent == "ERROR")
			{
				return 0;
			}
			List<Transformation> list = ParseTransformations(attributeContent);
			transformBuffer.AddRange(list);
			return list.Count;
		}

		private List<Transformation> ParseTransformations(string transformContent)
		{
			List<Transformation> list = new List<Transformation>();
			foreach (Match item in Regex.Matches(transformContent.ToLower(), "(?<function>translate|rotate|scale|skewx|skewy|matrix)\\s*\\((\\s*(?<param>-?\\s*\\d+(\\.\\d+)?)\\s*\\,*\\s*)+\\)"))
			{
				if (!item.Groups["function"].Success)
				{
					continue;
				}
				CaptureCollection captures = item.Groups["param"].Captures;
				switch (item.Groups["function"].Value)
				{
				case "translate":
					if (captures.Count >= 2)
					{
						list.Add(new Translate(new Vector2(float.Parse(captures[0].Value), float.Parse(captures[1].Value))));
					}
					break;
				case "rotate":
					if (captures.Count >= 1)
					{
						list.Add(new Rotate(float.Parse(captures[0].Value)));
					}
					break;
				case "scale":
					if (captures.Count >= 2)
					{
						list.Add(new Scale(new Vector2(float.Parse(captures[0].Value), float.Parse(captures[1].Value))));
					}
					break;
				case "skewx":
					if (captures.Count >= 1)
					{
						list.Add(new SkewX(float.Parse(captures[0].Value)));
					}
					break;
				case "skewy":
					if (captures.Count >= 1)
					{
						list.Add(new SkewY(float.Parse(captures[0].Value)));
					}
					break;
				case "matrix":
					if (captures.Count >= 6)
					{
						list.Add(new MatrixTransform(float.Parse(captures[0].Value), float.Parse(captures[1].Value), float.Parse(captures[2].Value), float.Parse(captures[3].Value), float.Parse(captures[4].Value), float.Parse(captures[5].Value)));
					}
					break;
				}
			}
			return list;
		}

		private int ReadPath(XmlNode pathNode)
		{
			string attributeContent = GetAttributeContent(pathNode, "d");
			if (attributeContent == "ERROR")
			{
				return 0;
			}
			string text = GetAttributeContent(pathNode, "id");
			if (text == "ERROR")
			{
				text = fileName + "_path " + (paths.Count + 1);
			}
			foreach (string item in from t in Regex.Split(attributeContent, "(?=[A-Za-z])")
				where !string.IsNullOrEmpty(t)
				select t)
			{
				switch (item.Substring(0, 1).Single())
				{
				case 'M':
					PathStart(text, item, relative: false);
					break;
				case 'm':
					PathStart(text, item, relative: true);
					break;
				case 'Z':
					PathClose();
					break;
				case 'z':
					PathClose();
					break;
				case 'L':
					PathLineTo(item, relative: false);
					break;
				case 'l':
					PathLineTo(item, relative: true);
					break;
				case 'H':
					PathHorizontalLineTo(item, relative: false);
					break;
				case 'h':
					PathHorizontalLineTo(item, relative: true);
					break;
				case 'V':
					PathVerticalLineTo(item, relative: false);
					break;
				case 'v':
					PathVerticalLineTo(item, relative: true);
					break;
				case 'C':
					PathCurveTo(item, PathSegment.Type.Cubic, relative: false);
					break;
				case 'c':
					PathCurveTo(item, PathSegment.Type.Cubic, relative: true);
					break;
				case 'S':
					PathCurveTo(item, PathSegment.Type.CubicShort, relative: false);
					break;
				case 's':
					PathCurveTo(item, PathSegment.Type.CubicShort, relative: true);
					break;
				case 'Q':
					PathCurveTo(item, PathSegment.Type.Quadratic, relative: false);
					break;
				case 'q':
					PathCurveTo(item, PathSegment.Type.Quadratic, relative: true);
					break;
				case 'T':
					PathCurveTo(item, PathSegment.Type.QuadraticShort, relative: false);
					break;
				case 't':
					PathCurveTo(item, PathSegment.Type.QuadraticShort, relative: true);
					break;
				}
			}
			int result = ParseTransformation(pathNode);
			if (buffer != null)
			{
				WriteBufferTo(paths);
			}
			return result;
		}

		private void PathStart(string name, string coords, bool relative)
		{
			if (buffer != null)
			{
				WriteBufferTo(paths);
			}
			buffer = new SplineDefinition(name, Spline.Type.Bezier);
			Vector2[] array = ParseVector2(coords);
			foreach (Vector3 vector in array)
			{
				if (relative)
				{
					buffer.position += vector;
				}
				else
				{
					buffer.position = vector;
				}
				buffer.CreateLinear();
			}
		}

		private void PathClose()
		{
			buffer.closed = true;
		}

		private void PathLineTo(string coords, bool relative)
		{
			Vector2[] array = ParseVector2(coords);
			foreach (Vector3 vector in array)
			{
				if (relative)
				{
					buffer.position += vector;
				}
				else
				{
					buffer.position = vector;
				}
				buffer.CreateLinear();
			}
		}

		private void PathHorizontalLineTo(string coords, bool relative)
		{
			float[] array = ParseFloat(coords);
			foreach (float num in array)
			{
				if (relative)
				{
					buffer.position.x += num;
				}
				else
				{
					buffer.position.x = num;
				}
				buffer.CreateLinear();
			}
		}

		private void PathVerticalLineTo(string coords, bool relative)
		{
			float[] array = ParseFloat(coords);
			foreach (float num in array)
			{
				if (relative)
				{
					buffer.position.y -= num;
				}
				else
				{
					buffer.position.y = 0f - num;
				}
				buffer.CreateLinear();
			}
		}

		private void PathCurveTo(string coords, PathSegment.Type type, bool relative)
		{
			PathSegment[] array = ParsePathSegment(coords, type);
			for (int i = 0; i < array.Length; i++)
			{
				SplinePoint lastPoint = buffer.GetLastPoint();
				lastPoint.type = SplinePoint.Type.Broken;
				Vector3 position = lastPoint.position;
				Vector3 endPoint = array[i].endPoint;
				Vector3 vector = array[i].startTangent;
				Vector3 vector2 = array[i].endTangent;
				switch (type)
				{
				case PathSegment.Type.CubicShort:
					vector = position - lastPoint.tangent;
					break;
				case PathSegment.Type.Quadratic:
					buffer.tangent = array[i].startTangent;
					vector = position + 2f / 3f * (buffer.tangent - position);
					vector2 = endPoint + 2f / 3f * (buffer.tangent - endPoint);
					break;
				case PathSegment.Type.QuadraticShort:
				{
					Vector3 vector3 = position + (position - buffer.tangent);
					vector = position + 2f / 3f * (vector3 - position);
					vector2 = endPoint + 2f / 3f * (vector3 - endPoint);
					break;
				}
				}
				if (type == PathSegment.Type.CubicShort || type == PathSegment.Type.QuadraticShort)
				{
					lastPoint.type = SplinePoint.Type.SmoothMirrored;
				}
				else if (relative)
				{
					lastPoint.SetTangent2Position(position + vector);
				}
				else
				{
					lastPoint.SetTangent2Position(vector);
				}
				buffer.SetLastPoint(lastPoint);
				if (relative)
				{
					buffer.position += endPoint;
					buffer.tangent = position + vector2;
				}
				else
				{
					buffer.position = endPoint;
					buffer.tangent = vector2;
				}
				buffer.CreateBroken();
			}
		}

		private void WriteBufferTo(List<SplineDefinition> list)
		{
			buffer.Transform(transformBuffer);
			list.Add(buffer);
			buffer = null;
		}

		private PathSegment[] ParsePathSegment(string coord, PathSegment.Type type)
		{
			List<float> list = ParseFloatArray(coord.Substring(1));
			int num = 0;
			switch (type)
			{
			case PathSegment.Type.Cubic:
				num = list.Count / 6;
				break;
			case PathSegment.Type.Quadratic:
				num = list.Count / 4;
				break;
			case PathSegment.Type.CubicShort:
				num = list.Count / 4;
				break;
			case PathSegment.Type.QuadraticShort:
				num = list.Count / 2;
				break;
			}
			if (num == 0)
			{
				UnityEngine.Debug.Log("Error in " + coord + " " + type);
				return new PathSegment[1]
				{
					new PathSegment()
				};
			}
			PathSegment[] array = new PathSegment[num];
			for (int i = 0; i < num; i++)
			{
				switch (type)
				{
				case PathSegment.Type.Cubic:
					array[i] = new PathSegment(new Vector2(list[6 * i], 0f - list[1 + 6 * i]), new Vector2(list[2 + 6 * i], 0f - list[3 + 6 * i]), new Vector2(list[4 + 6 * i], 0f - list[5 + 6 * i]));
					break;
				case PathSegment.Type.Quadratic:
					array[i] = new PathSegment(new Vector2(list[4 * i], 0f - list[1 + 4 * i]), Vector2.zero, new Vector2(list[2 + 4 * i], 0f - list[3 + 4 * i]));
					break;
				case PathSegment.Type.CubicShort:
					array[i] = new PathSegment(Vector2.zero, new Vector2(list[4 * i], 0f - list[1 + 4 * i]), new Vector2(list[2 + 4 * i], 0f - list[3 + 4 * i]));
					break;
				case PathSegment.Type.QuadraticShort:
					array[i] = new PathSegment(Vector2.zero, Vector2.zero, new Vector2(list[4 * i], 0f - list[1 + 4 * i]));
					break;
				}
			}
			return array;
		}

		private string EncodePath(SplineDefinition definition, Axis ax)
		{
			string text = "M";
			for (int i = 0; i < definition.pointCount; i++)
			{
				SplinePoint splinePoint = definition.points[i];
				Vector3 vector = MapPoint(splinePoint.tangent, ax);
				Vector3 vector2 = MapPoint(splinePoint.position, ax);
				if (i == 0)
				{
					text = text + vector2.x + "," + vector2.y;
					continue;
				}
				Vector3 vector3 = MapPoint(definition.points[i - 1].tangent2, ax);
				text = text + "C" + vector3.x + "," + vector3.y + "," + vector.x + "," + vector.y + "," + vector2.x + "," + vector2.y;
			}
			if (definition.closed)
			{
				text += "z";
			}
			return text;
		}

		private string EncodePolygon(SplineDefinition definition, Axis ax)
		{
			string text = "";
			for (int i = 0; i < definition.pointCount; i++)
			{
				Vector3 vector = MapPoint(definition.points[i].position, ax);
				if (text != "")
				{
					text += ",";
				}
				text = text + vector.x + "," + vector.y;
			}
			return text;
		}

		private string GetAttributeContent(XmlNode node, string attributeName)
		{
			for (int i = 0; i < node.Attributes.Count; i++)
			{
				if (node.Attributes[i].Name == attributeName)
				{
					return node.Attributes[i].InnerText;
				}
			}
			return "ERROR";
		}
	}
	public class SplineParser
	{
		internal class Transformation
		{
			protected static Matrix4x4 matrix;

			internal static void ResetMatrix()
			{
				matrix.SetTRS(Vector3.zero, Quaternion.identity, Vector3.one);
			}

			internal virtual void Push()
			{
			}

			internal static void Apply(SplinePoint[] points)
			{
				for (int i = 0; i < points.Length; i++)
				{
					SplinePoint splinePoint = points[i];
					splinePoint.position = matrix.MultiplyPoint(splinePoint.position);
					splinePoint.tangent = matrix.MultiplyPoint(splinePoint.tangent);
					splinePoint.tangent2 = matrix.MultiplyPoint(splinePoint.tangent2);
					points[i] = splinePoint;
				}
			}
		}

		internal class Translate : Transformation
		{
			private Vector2 offset = Vector2.zero;

			public Translate(Vector2 o)
			{
				offset = o;
			}

			internal override void Push()
			{
				Matrix4x4 matrix4x = default(Matrix4x4);
				matrix4x.SetTRS(new Vector2(offset.x, 0f - offset.y), Quaternion.identity, Vector3.one);
				Transformation.matrix *= matrix4x;
			}
		}

		internal class Rotate : Transformation
		{
			private float angle;

			public Rotate(float a)
			{
				angle = a;
			}

			internal override void Push()
			{
				Matrix4x4 matrix4x = default(Matrix4x4);
				matrix4x.SetTRS(Vector3.zero, Quaternion.AngleAxis(angle, Vector3.back), Vector3.one);
				Transformation.matrix *= matrix4x;
			}
		}

		internal class Scale : Transformation
		{
			private Vector2 multiplier = Vector2.one;

			public Scale(Vector2 s)
			{
				multiplier = s;
			}

			internal override void Push()
			{
				Matrix4x4 matrix4x = default(Matrix4x4);
				matrix4x.SetTRS(Vector3.zero, Quaternion.identity, multiplier);
				Transformation.matrix *= matrix4x;
			}
		}

		internal class SkewX : Transformation
		{
			private float amount;

			public SkewX(float a)
			{
				amount = a;
			}

			internal override void Push()
			{
				Matrix4x4 matrix4x = default(Matrix4x4);
				matrix4x[0, 0] = 1f;
				matrix4x[1, 1] = 1f;
				matrix4x[2, 2] = 1f;
				matrix4x[3, 3] = 1f;
				matrix4x[0, 1] = Mathf.Tan((0f - amount) * ((float)Math.PI / 180f));
				Transformation.matrix *= matrix4x;
			}
		}

		internal class SkewY : Transformation
		{
			private float amount;

			public SkewY(float a)
			{
				amount = a;
			}

			internal override void Push()
			{
				Matrix4x4 matrix4x = default(Matrix4x4);
				matrix4x[0, 0] = 1f;
				matrix4x[1, 1] = 1f;
				matrix4x[2, 2] = 1f;
				matrix4x[3, 3] = 1f;
				matrix4x[1, 0] = Mathf.Tan((0f - amount) * ((float)Math.PI / 180f));
				Transformation.matrix *= matrix4x;
			}
		}

		internal class MatrixTransform : Transformation
		{
			private Matrix4x4 transformMatrix;

			public MatrixTransform(float a, float b, float c, float d, float e, float f)
			{
				transformMatrix.SetRow(0, new Vector4(a, c, 0f, e));
				transformMatrix.SetRow(1, new Vector4(b, d, 0f, 0f - f));
				transformMatrix.SetRow(2, new Vector4(0f, 0f, 1f, 0f));
				transformMatrix.SetRow(3, new Vector4(0f, 0f, 0f, 1f));
			}

			internal override void Push()
			{
				Transformation.matrix *= transformMatrix;
			}
		}

		internal class SplineDefinition
		{
			internal string name = "";

			internal Spline.Type type = Spline.Type.Linear;

			internal List<SplinePoint> points = new List<SplinePoint>();

			internal bool closed;

			internal Vector3 position = Vector3.zero;

			internal Vector3 tangent = Vector3.zero;

			internal Vector3 tangent2 = Vector3.zero;

			internal Vector3 normal = Vector3.back;

			internal float size = 1f;

			internal Color color = Color.white;

			internal int pointCount => points.Count;

			internal SplineDefinition(string n, Spline.Type t)
			{
				name = n;
				type = t;
			}

			internal SplineDefinition(string n, Spline spline)
			{
				name = n;
				type = spline.type;
				closed = spline.isClosed;
				points = new List<SplinePoint>(spline.points);
			}

			internal SplinePoint GetLastPoint()
			{
				if (points.Count == 0)
				{
					return default(SplinePoint);
				}
				return points[points.Count - 1];
			}

			internal void SetLastPoint(SplinePoint point)
			{
				if (points.Count != 0)
				{
					points[points.Count - 1] = point;
				}
			}

			internal void CreateClosingPoint()
			{
				SplinePoint item = new SplinePoint(points[0]);
				points.Add(item);
			}

			internal void CreateSmooth()
			{
				points.Add(new SplinePoint(position, tangent, normal, size, color));
			}

			internal void CreateBroken()
			{
				SplinePoint item = new SplinePoint(new SplinePoint(position, tangent, normal, size, color));
				item.type = SplinePoint.Type.Broken;
				item.SetTangent2Position(item.position);
				item.normal = normal;
				item.color = color;
				item.size = size;
				points.Add(item);
			}

			internal void CreateLinear()
			{
				tangent = position;
				CreateSmooth();
			}

			internal SplineComputer CreateSplineComputer(Vector3 position, Quaternion rotation)
			{
				GameObject gameObject = new GameObject(name);
				gameObject.transform.position = position;
				gameObject.transform.rotation = rotation;
				SplineComputer splineComputer = gameObject.AddComponent<SplineComputer>();
				splineComputer.type = type;
				if (closed && points[0].type == SplinePoint.Type.Broken)
				{
					points[0].SetTangentPosition(GetLastPoint().tangent2);
				}
				splineComputer.SetPoints(points.ToArray(), SplineComputer.Space.Local);
				if (closed)
				{
					splineComputer.Close();
				}
				return splineComputer;
			}

			internal Spline CreateSpline()
			{
				Spline spline = new Spline(type);
				spline.points = points.ToArray();
				if (closed)
				{
					spline.Close();
				}
				return spline;
			}

			internal void Transform(List<Transformation> trs)
			{
				SplinePoint[] array = points.ToArray();
				Transformation.ResetMatrix();
				foreach (Transformation tr in trs)
				{
					tr.Push();
				}
				Transformation.Apply(array);
				for (int i = 0; i < array.Length; i++)
				{
					points[i] = array[i];
				}
				Transformation.Apply(new SplinePoint[1] { default(SplinePoint) });
			}
		}

		protected string fileName = "";

		internal SplineDefinition buffer;

		public string name => fileName;

		internal Vector2[] ParseVector2(string coord)
		{
			List<float> list = ParseFloatArray(coord.Substring(1));
			int num = list.Count / 2;
			if (num == 0)
			{
				UnityEngine.Debug.Log("Error in " + coord);
				return new Vector2[1] { Vector2.zero };
			}
			Vector2[] array = new Vector2[num];
			for (int i = 0; i < num; i++)
			{
				array[i] = new Vector2(list[i * 2], 0f - list[1 + i * 2]);
			}
			return array;
		}

		internal float[] ParseFloat(string coord)
		{
			List<float> list = ParseFloatArray(coord.Substring(1));
			if (list.Count < 1)
			{
				UnityEngine.Debug.Log("Error in " + coord);
				return new float[1];
			}
			return list.ToArray();
		}

		internal List<float> ParseFloatArray(string content)
		{
			string text = "";
			List<float> list = new List<float>();
			for (int i = 0; i < content.Length; i++)
			{
				char c = content[i];
				if ((c == ',' || c == '-' || char.IsWhiteSpace(c)) && !IsWHiteSpace(text))
				{
					float result = 0f;
					float.TryParse(text, out result);
					list.Add(result);
					text = "";
					if (c == '-')
					{
						text = "-";
					}
				}
				else if (!char.IsWhiteSpace(c))
				{
					text += c;
				}
			}
			if (!IsWHiteSpace(text))
			{
				float result2 = 0f;
				float.TryParse(text, out result2);
				list.Add(result2);
			}
			return list;
		}

		public bool IsWHiteSpace(string s)
		{
			for (int i = 0; i < s.Length; i++)
			{
				if (!char.IsWhiteSpace(s[i]))
				{
					return false;
				}
			}
			return true;
		}
	}
}
namespace AmplifyImpostors
{
	public enum LODReplacement
	{
		DoNothing,
		ReplaceCulled,
		ReplaceLast,
		ReplaceAllExceptFirst,
		ReplaceSpecific,
		ReplaceAfterSpecific,
		InsertAfter
	}
	public enum CutMode
	{
		Automatic,
		Manual
	}
	public enum FolderMode
	{
		RelativeToPrefab,
		Global
	}
	public class AmplifyImpostor : MonoBehaviour
	{
		private const string ShaderGUID = "e82933f4c0eb9ba42aab0739f48efe21";

		private const string DilateGUID = "57c23892d43bc9f458360024c5985405";

		private const string PackerGUID = "31bd3cd74692f384a916d9d7ea87710d";

		private const string ShaderOctaGUID = "572f9be5706148142b8da6e9de53acdb";

		[SerializeField]
		private AmplifyImpostorAsset m_data;

		[SerializeField]
		private Transform m_rootTransform;

		[SerializeField]
		private LODGroup m_lodGroup;

		[SerializeField]
		private Renderer[] m_renderers;

		public LODReplacement m_lodReplacement = LODReplacement.ReplaceLast;

		public int m_insertIndex = 1;

		[SerializeField]
		public GameObject m_lastImpostor;

		[SerializeField]
		public string m_folderPath;

		[SerializeField]
		public string m_impostorName = string.Empty;

		[SerializeField]
		public CutMode m_cutMode;

		[NonSerialized]
		private const float StartXRotation = -90f;

		[NonSerialized]
		private const float StartYRotation = 90f;

		[NonSerialized]
		private const int MinAlphaResolution = 256;

		[NonSerialized]
		private RenderTexture[] m_rtGBuffers;

		[NonSerialized]
		private RenderTexture[] m_alphaGBuffers;

		[NonSerialized]
		private RenderTexture m_trueDepth;

		[NonSerialized]
		public Texture2D m_alphaTex;

		[NonSerialized]
		private RenderTexture m_combinedAlphaTexture;

		[NonSerialized]
		private float m_trueFitsize;

		[NonSerialized]
		private float m_depthFitsize;

		[NonSerialized]
		private Bounds m_originalBound;

		public AmplifyImpostorAsset Data
		{
			get
			{
				return m_data;
			}
			set
			{
				m_data = value;
			}
		}

		public Transform RootTransform
		{
			get
			{
				return m_rootTransform;
			}
			set
			{
				m_rootTransform = value;
			}
		}

		public LODGroup LodGroup
		{
			get
			{
				return m_lodGroup;
			}
			set
			{
				m_lodGroup = value;
			}
		}

		public Renderer[] Renderers
		{
			get
			{
				return m_renderers;
			}
			set
			{
				m_renderers = value;
			}
		}

		public RenderTexture CombinedAlphaTexture
		{
			get
			{
				return m_combinedAlphaTexture;
			}
			set
			{
				m_combinedAlphaTexture = value;
			}
		}

		private void GenerateTextures()
		{
			m_rtGBuffers = new RenderTexture[4];
			for (int i = 0; i < m_rtGBuffers.Length - 2; i++)
			{
				m_rtGBuffers[i] = new RenderTexture((int)m_data.TexSize.x, (int)m_data.TexSize.y, 16, RenderTextureFormat.ARGB32);
				m_rtGBuffers[i].Create();
			}
			m_rtGBuffers[2] = new RenderTexture((int)m_data.TexSize.x, (int)m_data.TexSize.y, 16, RenderTextureFormat.ARGBHalf);
			m_rtGBuffers[2].Create();
			m_rtGBuffers[3] = new RenderTexture((int)m_data.TexSize.x, (int)m_data.TexSize.y, 16, RenderTextureFormat.ARGBHalf);
			m_rtGBuffers[3].Create();
			m_trueDepth = new RenderTexture((int)m_data.TexSize.x, (int)m_data.TexSize.y, 16, RenderTextureFormat.Depth);
			m_trueDepth.Create();
		}

		private void GenerateAlphaTextures(bool useMinResolution = false)
		{
			m_alphaGBuffers = new RenderTexture[4];
			int num = (int)m_data.TexSize.x / m_data.HorizontalFrames;
			int num2 = (int)m_data.TexSize.y / m_data.VerticalFrames;
			if (useMinResolution)
			{
				num = Mathf.Max(256, num);
				num2 = Mathf.Max(256, num2);
			}
			for (int i = 0; i < m_alphaGBuffers.Length; i++)
			{
				m_alphaGBuffers[i] = new RenderTexture(num, num2, 16, RenderTextureFormat.ARGBHalf);
				m_alphaGBuffers[i].Create();
			}
			m_combinedAlphaTexture = new RenderTexture(num, num2, 16, RenderTextureFormat.ARGBHalf);
			m_combinedAlphaTexture.Create();
		}

		private void ClearBuffers()
		{
			RenderTexture.active = null;
			RenderTexture[] rtGBuffers = m_rtGBuffers;
			for (int i = 0; i < rtGBuffers.Length; i++)
			{
				rtGBuffers[i].Release();
			}
			m_rtGBuffers = null;
			m_trueDepth.Release();
			m_trueDepth = null;
		}

		private void ClearAlphaBuffers(bool clearCombinedRT = false)
		{
			RenderTexture.active = null;
			RenderTexture[] alphaGBuffers = m_alphaGBuffers;
			for (int i = 0; i < alphaGBuffers.Length; i++)
			{
				alphaGBuffers[i].Release();
			}
			m_alphaGBuffers = null;
			if (clearCombinedRT)
			{
				m_combinedAlphaTexture.Release();
				m_combinedAlphaTexture = null;
			}
		}

		public void ClearCombinedAlphaBuffer()
		{
			RenderTexture.active = null;
			m_combinedAlphaTexture.Release();
			m_combinedAlphaTexture = null;
		}

		public void RenderImpostor(ImpostorType impostorType, bool impostorMaps = true, bool combinedAlphas = false, bool useMinResolution = false)
		{
			if (!impostorMaps && !combinedAlphas)
			{
				return;
			}
			CommandBuffer commandBuffer = new CommandBuffer();
			if (impostorMaps)
			{
				commandBuffer.name = "GBufferCatcher";
				RenderTargetIdentifier[] colors = new RenderTargetIdentifier[4]
				{
					m_rtGBuffers[0],
					m_rtGBuffers[1],
					m_rtGBuffers[2],
					m_rtGBuffers[3]
				};
				commandBuffer.SetRenderTarget(colors, m_trueDepth);
				commandBuffer.ClearRenderTarget(clearDepth: true, clearColor: true, Color.clear, 1f);
			}
			CommandBuffer commandBuffer2 = new CommandBuffer();
			if (combinedAlphas)
			{
				commandBuffer2.name = "DepthAlphaCatcher";
				RenderTargetIdentifier[] array = new RenderTargetIdentifier[4]
				{
					m_alphaGBuffers[0],
					m_alphaGBuffers[1],
					m_alphaGBuffers[2],
					m_alphaGBuffers[3]
				};
				commandBuffer2.SetRenderTarget(array, array[0]);
				commandBuffer2.ClearRenderTarget(clearDepth: true, clearColor: true, Color.clear, 1f);
			}
			int horizontalFrames = m_data.HorizontalFrames;
			int num = m_data.HorizontalFrames;
			if (impostorType == ImpostorType.Spherical)
			{
				num = m_data.HorizontalFrames - 1;
				if (m_data.DecoupleAxisFrames)
				{
					num = m_data.VerticalFrames - 1;
				}
			}
			for (int i = 0; i < horizontalFrames; i++)
			{
				for (int j = 0; j <= num; j++)
				{
					Bounds bounds = default(Bounds);
					Matrix4x4 matrix4x = Matrix4x4.identity;
					switch (impostorType)
					{
					case ImpostorType.Spherical:
					{
						float num2 = 0f;
						if (num > 0)
						{
							num2 = 0f - 180f / (float)num;
						}
						Quaternion quaternion = Quaternion.Euler(num2 * (float)j + 90f, 0f, 0f);
						Quaternion quaternion2 = Quaternion.Euler(0f, 360f / (float)horizontalFrames * (float)i + -90f, 0f);
						matrix4x = Matrix4x4.Rotate(quaternion * quaternion2);
						break;
					}
					case ImpostorType.Octahedron:
					{
						Vector3 vector2 = OctahedronToVector((float)i / ((float)horizontalFrames - 1f) * 2f - 1f, (float)j / ((float)num - 1f) * 2f - 1f);
						matrix4x = Matrix4x4.Rotate(Quaternion.LookRotation(new Vector3(vector2.x * -1f, vector2.z * -1f, vector2.y * -1f), Vector3.up)).inverse;
						break;
					}
					case ImpostorType.HemiOctahedron:
					{
						Vector3 vector = HemiOctahedronToVector((float)i / ((float)horizontalFrames - 1f) * 2f - 1f, (float)j / ((float)num - 1f) * 2f - 1f);
						matrix4x = Matrix4x4.Rotate(Quaternion.LookRotation(new Vector3(vector.x * -1f, vector.z * -1f, vector.y * -1f), Vector3.up)).inverse;
						break;
					}
					}
					for (int k = 0; k < Renderers.Length; k++)
					{
						if (!(Renderers[k] == null))
						{
							if (k == 0)
							{
								bounds = Renderers[k].bounds;
							}
							else
							{
								bounds.Encapsulate(Renderers[k].bounds);
							}
						}
					}
					if (i == 0 && j == 0)
					{
						m_originalBound = bounds;
					}
					bounds = bounds.Transform(matrix4x * m_rootTransform.worldToLocalMatrix);
					Matrix4x4 matrix4x2 = matrix4x.inverse * Matrix4x4.LookAt(bounds.center - new Vector3(0f, 0f, m_depthFitsize * 0.5f), bounds.center, Vector3.up);
					float num3 = m_trueFitsize * 0.5f;
					Matrix4x4 proj = Matrix4x4.Ortho(0f - num3, num3, 0f - num3, num3, 0f, 0f - m_depthFitsize);
					if (impostorMaps)
					{
						commandBuffer.SetViewProjectionMatrices(matrix4x2.inverse, proj);
						commandBuffer.SetViewport(new Rect(m_data.TexSize.x / (float)horizontalFrames * (float)i, m_data.TexSize.y / (float)(num + ((impostorType == ImpostorType.Spherical) ? 1 : 0)) * (float)j, m_data.TexSize.x / (float)m_data.HorizontalFrames, m_data.TexSize.y / (float)m_data.VerticalFrames));
					}
					if (combinedAlphas)
					{
						int num4 = (int)m_data.TexSize.x / m_data.HorizontalFrames;
						int num5 = (int)m_data.TexSize.y / m_data.VerticalFrames;
						if (useMinResolution)
						{
							num4 = Mathf.Max(256, num4);
							num5 = Mathf.Max(256, num5);
						}
						commandBuffer2.SetViewProjectionMatrices(matrix4x2.inverse, proj);
						commandBuffer2.SetViewport(new Rect(0f, 0f, num4, num5));
					}
					for (int l = 0; l < Renderers.Length; l++)
					{
						if (Renderers[l] == null)
						{
							continue;
						}
						Transform transform = Renderers[l].transform;
						Material[] sharedMaterials = Renderers[l].sharedMaterials;
						MeshFilter component = transform.GetComponent<MeshFilter>();
						if (component == null)
						{
							continue;
						}
						for (int m = 0; m < sharedMaterials.Length; m++)
						{
							Mesh sharedMesh = component.sharedMesh;
							Material material = sharedMaterials[m];
							int num6 = material.FindPass("DEFERRED");
							if (num6 == -1)
							{
								num6 = material.FindPass("Deferred");
							}
							if (num6 == -1)
							{
								num6 = 0;
								for (int n = 0; n < material.passCount; n++)
								{
									if (material.GetTag("LightMode", searchFallbacks: true).Equals("Deferred"))
									{
										num6 = n;
										break;
									}
								}
							}
							commandBuffer.EnableShaderKeyword("UNITY_HDR_ON");
							Matrix4x4 matrix = m_rootTransform.worldToLocalMatrix * transform.localToWorldMatrix;
							if (impostorMaps)
							{
								commandBuffer.DrawMesh(sharedMesh, matrix, material, m, num6);
							}
							if (combinedAlphas)
							{
								commandBuffer2.DrawMesh(sharedMesh, matrix, material, m, num6);
							}
						}
					}
					if (impostorMaps)
					{
						Graphics.ExecuteCommandBuffer(commandBuffer);
					}
					if (combinedAlphas)
					{
						Graphics.ExecuteCommandBuffer(commandBuffer2);
					}
				}
			}
			commandBuffer.Release();
			commandBuffer = null;
			commandBuffer2.Release();
			commandBuffer2 = null;
		}

		private Vector3 OctahedronToVector(Vector2 oct)
		{
			Vector3 value = new Vector3(oct.x, oct.y, 1f - Mathf.Abs(oct.x) - Mathf.Abs(oct.y));
			float num = Mathf.Clamp01(0f - value.z);
			value.Set(value.x + ((value.x >= 0f) ? (0f - num) : num), value.y + ((value.y >= 0f) ? (0f - num) : num), value.z);
			return Vector3.Normalize(value);
		}

		private Vector3 OctahedronToVector(float x, float y)
		{
			Vector3 value = new Vector3(x, y, 1f - Mathf.Abs(x) - Mathf.Abs(y));
			float num = Mathf.Clamp01(0f - value.z);
			value.Set(value.x + ((value.x >= 0f) ? (0f - num) : num), value.y + ((value.y >= 0f) ? (0f - num) : num), value.z);
			return Vector3.Normalize(value);
		}

		private Vector3 HemiOctahedronToVector(float x, float y)
		{
			float num = x;
			float num2 = y;
			x = (num + num2) * 0.5f;
			y = (num - num2) * 0.5f;
			return Vector3.Normalize(new Vector3(x, y, 1f - Mathf.Abs(x) - Mathf.Abs(y)));
		}

		public Mesh GenerateMesh(Vector2[] points, Vector3 offset, float width = 1f, float height = 1f, bool invertY = true)
		{
			Vector2[] array = new Vector2[points.Length];
			Vector2[] array2 = new Vector2[points.Length];
			Array.Copy(points, array, points.Length);
			float num = width * 0.5f;
			float num2 = height * 0.5f;
			if (invertY)
			{
				for (int i = 0; i < array.Length; i++)
				{
					array[i] = new Vector2(array[i].x, 1f - array[i].y);
				}
			}
			Array.Copy(array, array2, array.Length);
			for (int j = 0; j < array.Length; j++)
			{
				array[j] = new Vector2(array[j].x * width - num, array[j].y * height - num2);
			}
			Triangulator triangulator = new Triangulator(array);
			int[] triangles = triangulator.Triangulate();
			Vector3[] array3 = new Vector3[triangulator.Points.Count];
			for (int k = 0; k < array3.Length; k++)
			{
				array3[k] = new Vector3(triangulator.Points[k].x, triangulator.Points[k].y, 0f);
			}
			Mesh mesh = new Mesh();
			mesh.vertices = array3;
			mesh.uv = array2;
			mesh.triangles = triangles;
			mesh.RecalculateNormals();
			mesh.bounds = new Bounds(offset, m_originalBound.size);
			return mesh;
		}
	}
	public static class BoundsEx
	{
		public static Bounds Transform(this Bounds bounds, Matrix4x4 matrix)
		{
			Vector3 center = matrix.MultiplyPoint3x4(bounds.center);
			Vector3 extents = bounds.extents;
			Vector3 vector = matrix.MultiplyVector(new Vector3(extents.x, 0f, 0f));
			Vector3 vector2 = matrix.MultiplyVector(new Vector3(0f, extents.y, 0f));
			Vector3 vector3 = matrix.MultiplyVector(new Vector3(0f, 0f, extents.z));
			extents.x = Mathf.Abs(vector.x) + Mathf.Abs(vector2.x) + Mathf.Abs(vector3.x);
			extents.y = Mathf.Abs(vector.y) + Mathf.Abs(vector2.y) + Mathf.Abs(vector3.y);
			extents.z = Mathf.Abs(vector.z) + Mathf.Abs(vector2.z) + Mathf.Abs(vector3.z);
			Bounds result = default(Bounds);
			result.center = center;
			result.extents = extents;
			return result;
		}
	}
	public static class SpriteUtilityEx
	{
		private static Type type;

		public static Type Type
		{
			get
			{
				if (!(type == null))
				{
					return type;
				}
				return type = Type.GetType("UnityEditor.Sprites.SpriteUtility, UnityEditor");
			}
		}

		public static void GenerateOutline(Texture2D texture, Rect rect, float detail, byte alphaTolerance, bool holeDetection, out Vector2[][] paths)
		{
			Vector2[][] array = new Vector2[0][];
			object[] array2 = new object[6] { texture, rect, detail, alphaTolerance, holeDetection, array };
			Type.GetMethod("GenerateOutline", BindingFlags.Static | BindingFlags.NonPublic).Invoke(null, array2);
			paths = (Vector2[][])array2[5];
		}
	}
	public static class Vector2Ex
	{
		public static float Cross(this Vector2 O, Vector2 A, Vector2 B)
		{
			return (A.x - O.x) * (B.y - O.y) - (A.y - O.y) * (B.x - O.x);
		}

		public static float TriangleArea(this Vector2 O, Vector2 A, Vector2 B)
		{
			return Mathf.Abs((A.x - B.x) * (O.y - A.y) - (A.x - O.x) * (B.y - A.y)) * 0.5f;
		}

		public static float TriangleArea(this Vector3 O, Vector3 A, Vector3 B)
		{
			return Mathf.Abs((A.x - B.x) * (O.y - A.y) - (A.x - O.x) * (B.y - A.y)) * 0.5f;
		}

		public static Vector2[] ConvexHull(Vector2[] P)
		{
			if (P.Length > 1)
			{
				int num = P.Length;
				int num2 = 0;
				Vector2[] array = new Vector2[2 * num];
				Comparison<Vector2> comparison = (Vector2 a, Vector2 b) => (a.x == b.x) ? a.y.CompareTo(b.y) : a.x.CompareTo(b.x);
				Array.Sort(P, comparison);
				for (int i = 0; i < num; i++)
				{
					while (num2 >= 2 && P[i].Cross(array[num2 - 2], array[num2 - 1]) <= 0f)
					{
						num2--;
					}
					array[num2++] = P[i];
				}
				int num3 = num - 2;
				int num4 = num2 + 1;
				while (num3 >= 0)
				{
					while (num2 >= num4 && P[num3].Cross(array[num2 - 2], array[num2 - 1]) <= 0f)
					{
						num2--;
					}
					array[num2++] = P[num3];
					num3--;
				}
				if (num2 > 1)
				{
					Array.Resize(ref array, num2 - 1);
				}
				return array;
			}
			if (P.Length <= 1)
			{
				return P;
			}
			return null;
		}

		public static Vector2[] ScaleAlongNormals(Vector2[] P, float scaleAmount)
		{
			Vector2[] array = new Vector2[P.Length];
			for (int i = 0; i < array.Length; i++)
			{
				int num = i - 1;
				int num2 = i + 1;
				if (i == 0)
				{
					num = P.Length - 1;
				}
				if (i == P.Length - 1)
				{
					num2 = 0;
				}
				Vector2 vector = P[i] - P[num];
				Vector2 vector2 = P[i] - P[num2];
				Vector2 normalized = (vector.normalized + vector2.normalized).normalized;
				array[i] = normalized;
			}
			for (int j = 0; j < array.Length; j++)
			{
				P[j] += array[j] * scaleAmount;
			}
			return P;
		}

		private static Vector2 GetIntersectionPointCoordinates(Vector2 A1, Vector2 A2, Vector2 B1, Vector2 B2)
		{
			float num = (B2.x - B1.x) * (A2.y - A1.y) - (B2.y - B1.y) * (A2.x - A1.x);
			if (num == 0f)
			{
				return (Vector2.Lerp(A2, B1, 0.5f) - Vector2.one * 0.5f) * 1000f + Vector2.one * 500f;
			}
			float num2 = ((A1.x - B1.x) * (A2.y - A1.y) - (A1.y - B1.y) * (A2.x - A1.x)) / num;
			return new Vector2(B1.x + (B2.x - B1.x) * num2, B1.y + (B2.y - B1.y) * num2);
		}

		private static float OutsideBounds(Vector2 P)
		{
			P -= Vector2.one * 0.5f;
			float num = Mathf.Clamp01(Mathf.Abs(P.y) - 0.5f);
			return Mathf.Clamp01(Mathf.Abs(P.x) - 0.5f) + num;
		}
	}
	public static class ImpostorBakingTools
	{
		public static readonly string PrefGlobalFolder = "IMPOSTORS_GLOBALFOLDER";

		public static readonly string PrefGlobalRelativeFolder = "IMPOSTORS_GLOBALRELATIVEFOLDER";

		public static readonly string PrefGlobalDefault = "IMPOSTORS_GLOBALDEFAULT";

		public static readonly string PrefGlobalTexImport = "IMPOSTORS_GLOBALTEXIMPORT";

		public static readonly string PrefGlobalCreateLodGroup = "IMPOSTORS_GLOBALCREATELODGROUP ";

		public static readonly string PrefGlobalGBuffer0Name = "IMPOSTORS_GLOBALGBUFFER0SUFFIX";

		public static readonly string PrefGlobalGBuffer1Name = "IMPOSTORS_GLOBALGBUFFER1SUFFIX";

		public static readonly string PrefGlobalGBuffer2Name = "IMPOSTORS_GLOBALGBUFFER2SUFFIX";

		public static readonly string PrefGlobalGBuffer3Name = "IMPOSTORS_GLOBALGBUFFER3SUFFIX";

		public static readonly string PrefGlobalBakingOptions = "IMPOSTORS_GLOBALBakingOptions";

		public static readonly string PrefDataImpType = "IMPOSTORS_DATAIMPTYPE";

		public static readonly string PrefDataTexSizeLocked = "IMPOSTORS_DATATEXSIZEXLOCKED";

		public static readonly string PrefDataTexSizeSelected = "IMPOSTORS_DATATEXSIZEXSELECTED";

		public static readonly string PrefDataTexSizeX = "IMPOSTORS_DATATEXSIZEX";

		public static readonly string PrefDataTexSizeY = "IMPOSTORS_DATATEXSIZEY";

		public static readonly string PrefDataDecoupledFrames = "IMPOSTORS_DATADECOUPLEDFRAMES";

		public static readonly string PrefDataXFrames = "IMPOSTORS_DATAXFRAMES";

		public static readonly string PrefDataYFrames = "IMPOSTORS_DATAYFRAMES";

		public static readonly string PrefDataPixelBleeding = "IMPOSTORS_DATAPIXELBLEEDING";

		public static readonly string PrefDataTolerance = "IMPOSTORS_DATATOLERANCE ";

		public static readonly string PrefDataNormalScale = "IMPOSTORS_DATANORMALSCALE";

		public static readonly string PrefDataMaxVertices = "IMPOSTORS_DATAMAXVERTICES";
	}
	public class Triangulator
	{
		private List<Vector2> m_points = new List<Vector2>();

		public List<Vector2> Points => m_points;

		public Triangulator(Vector2[] points)
		{
			m_points = new List<Vector2>(points);
		}

		public Triangulator(Vector2[] points, bool invertY = true)
		{
			if (invertY)
			{
				m_points = new List<Vector2>();
				for (int i = 0; i < points.Length; i++)
				{
					m_points.Add(new Vector2(points[i].x, 1f - points[i].y));
				}
			}
			else
			{
				m_points = new List<Vector2>(points);
			}
		}

		public int[] Triangulate()
		{
			List<int> list = new List<int>();
			int count = m_points.Count;
			if (count < 3)
			{
				return list.ToArray();
			}
			int[] array = new int[count];
			if (Area() > 0f)
			{
				for (int i = 0; i < count; i++)
				{
					array[i] = i;
				}
			}
			else
			{
				for (int j = 0; j < count; j++)
				{
					array[j] = count - 1 - j;
				}
			}
			int num = count;
			int num2 = 2 * num;
			int num3 = 0;
			int num4 = num - 1;
			while (num > 2)
			{
				if (num2-- <= 0)
				{
					return list.ToArray();
				}
				int num5 = num4;
				if (num <= num5)
				{
					num5 = 0;
				}
				num4 = num5 + 1;
				if (num <= num4)
				{
					num4 = 0;
				}
				int num6 = num4 + 1;
				if (num <= num6)
				{
					num6 = 0;
				}
				if (Snip(num5, num4, num6, num, array))
				{
					int item = array[num5];
					int item2 = array[num4];
					int item3 = array[num6];
					list.Add(item);
					list.Add(item2);
					list.Add(item3);
					num3++;
					int num7 = num4;
					for (int k = num4 + 1; k < num; k++)
					{
						array[num7] = array[k];
						num7++;
					}
					num--;
					num2 = 2 * num;
				}
			}
			list.Reverse();
			return list.ToArray();
		}

		private float Area()
		{
			int count = m_points.Count;
			float num = 0f;
			int index = count - 1;
			int num2 = 0;
			while (num2 < count)
			{
				Vector2 vector = m_points[index];
				Vector2 vector2 = m_points[num2];
				num += vector.x * vector2.y - vector2.x * vector.y;
				index = num2++;
			}
			return num * 0.5f;
		}

		private bool Snip(int u, int v, int w, int n, int[] V)
		{
			Vector2 v2 = m_points[V[u]];
			Vector2 v3 = m_points[V[v]];
			Vector2 v4 = m_points[V[w]];
			if (Mathf.Epsilon > (v3.x - v2.x) * (v4.y - v2.y) - (v3.y - v2.y) * (v4.x - v2.x))
			{
				return false;
			}
			for (int i = 0; i < n; i++)
			{
				if (i != u && i != v && i != w)
				{
					Vector2 pt = m_points[V[i]];
					if (InsideTriangle(pt, v2, v3, v4))
					{
						return false;
					}
				}
			}
			return true;
		}

		private bool InsideTriangle(Vector2 pt, Vector2 v1, Vector2 v2, Vector2 v3)
		{
			bool num = pt.Cross(v1, v2) < 0f;
			bool flag = pt.Cross(v2, v3) < 0f;
			bool flag2 = pt.Cross(v3, v1) < 0f;
			if (num == flag)
			{
				return flag == flag2;
			}
			return false;
		}
	}
	[Serializable]
	public class VersionInfo
	{
		public const byte Major = 0;

		public const byte Minor = 8;

		public const byte Release = 4;

		public static byte Revision;

		public static int FullNumber => 8400 + Revision;

		public static string FullLabel => "Version=" + FullNumber;

		public static string StaticToString()
		{
			return $"{(byte)0}.{(byte)8}.{(byte)4}" + ((Revision > 0) ? ("r" + Revision) : "");
		}
	}
}
