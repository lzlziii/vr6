using System;
using System.CodeDom.Compiler;
using System.Collections;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Net;
using System.Net.Security;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.Serialization;
using System.Security.Cryptography;
using System.Security.Cryptography.X509Certificates;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Xml.Serialization;
using AOT;
using BoundarySystem_Ext;
using DG.Tweening;
using DeerCat;
using DeerCat.SimpleTween;
using DeerCat.TunnelRush;
using Ionic.Crc;
using Ionic.Zlib;
using LitJson;
using MalbersAnimations.Events;
using MalbersAnimations.HAP;
using MalbersAnimations.Scriptables;
using MalbersAnimations.Utilities;
using MalbersAnimations.Weapons;
using Microsoft.Applications.Events.DataModels;
using Oculus.Platform;
using Oculus.Spatializer.Propagation;
using PlayFab;
using PlayFab.AuthenticationModels;
using PlayFab.ClientModels;
using PlayFab.CloudScriptModels;
using PlayFab.DataModels;
using PlayFab.EventsModels;
using PlayFab.GroupsModels;
using PlayFab.Internal;
using PlayFab.Json;
using PlayFab.LocalizationModels;
using PlayFab.MultiplayerModels;
using PlayFab.ProfilesModels;
using PlayFab.Public;
using PlayFab.SharedModels;
using Pvr_UnitySDKAPI;
using Pvr_UnitySDKAPI.Achievement;
using SimpleJSON;
using TMPro;
using UnityEngine;
using UnityEngine.AI;
using UnityEngine.Assertions;
using UnityEngine.Audio;
using UnityEngine.EventSystems;
using UnityEngine.Events;
using UnityEngine.Experimental.Rendering;
using UnityEngine.Networking;
using UnityEngine.Rendering;
using UnityEngine.SceneManagement;
using UnityEngine.UI;
using UnityEngine.XR;
using Valve.VR;
using Viveport;
using Viveport.Core;
using Viveport.Internal;
using WVR_Log;
using Wacki;
using wvr;
using wvr.TypeExtensions;
using wvr.render;
using wvr.render.gl;
using wvr.render.thread;
using wvr.render.utils;

[assembly: CompilationRelaxations(8)]
[assembly: RuntimeCompatibility(WrapNonExceptionThrows = true)]
[assembly: Debuggable(DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints)]
[assembly: AssemblyVersion("0.0.0.0")]
public class csChangeNamePanel : csMainMenuPanelBase
{
	[SerializeField]
	private GameObject body;

	private bool isCaps;

	[HideInInspector]
	public string inputContent = "";

	[SerializeField]
	private Text tempInputText;

	[SerializeField]
	private Text TipsText;

	[SerializeField]
	private List<Text> characterText = new List<Text>();

	public Action doneBtnAction;

	public GameObject LoadingObj;

	public GameObject DoneBtnObj;

	public Text CoinText;

	private const byte VK_CAPSLOCK = 20;

	private const uint KEYEVENTF_EXTENDEDKEY = 1u;

	private const int KEYEVENTF_KEYUP = 2;

	private const int KEYEVENTF_KEYDOWN = 0;

	private int limit;

	public override void StartInit()
	{
		base.StartInit();
		csPlayfab.ChangeNameCallBack = (Action<bool, string>)Delegate.Combine(csPlayfab.ChangeNameCallBack, new Action<bool, string>(ChangeNameCallBack));
		doneBtnAction = ConfirmName;
	}

	private void OnDestroy()
	{
		csPlayfab.ChangeNameCallBack = (Action<bool, string>)Delegate.Remove(csPlayfab.ChangeNameCallBack, new Action<bool, string>(ChangeNameCallBack));
	}

	public override void Show(UnityAction act, string msg = "")
	{
		base.Show(act, msg);
		for (int i = 0; i < characterText.Count; i++)
		{
			characterText[i].text = (isCaps ? characterText[i].text.ToUpper() : characterText[i].text.ToLower());
		}
		inputContent = "";
		tempInputText.text = "";
		limit = 14;
		csLocalizationManager.Instance.CheckTextFontType(TipsText);
		TipsText.text = string.Format(csLocalizationManager.Instance.GetLocalText("ChangeName1"), 2000);
		CoinText.text = csPlayerData.PlayerCoin.ToString();
	}

	private bool isNumOrLetter(string str)
	{
		return new Regex("^[A-Za-z0-9]+$").IsMatch(str);
	}

	public void InputHandle(string value)
	{
		switch (value)
		{
		case "caps":
		{
			isCaps = !isCaps;
			for (int i = 0; i < characterText.Count; i++)
			{
				characterText[i].text = (isCaps ? characterText[i].text.ToUpper() : characterText[i].text.ToLower());
			}
			break;
		}
		case "del":
			if (inputContent.Length > 0)
			{
				inputContent = inputContent.Substring(0, inputContent.Length - 1);
				tempInputText.text = inputContent;
			}
			break;
		case "done":
			doneBtnAction?.Invoke();
			break;
		default:
			if (limit == -1 || (limit != -1 && tempInputText.text.Length < limit))
			{
				inputContent += (isCaps ? value.ToUpper() : value.ToLower());
				tempInputText.text = inputContent;
			}
			break;
		}
	}

	public void ConfirmName()
	{
		if (csPlayerData.PlayerCoin >= 2000)
		{
			if (csPlayerData.HasLogin)
			{
				csGameSettings.IsLoading = true;
				LoadingObj.SetActive(value: true);
				csPlayfab.instance.ChangeNameIngame(inputContent);
			}
			else
			{
				csPlayerData.PlayerCoin -= 2000;
				csPlayerData.PlayerName = inputContent;
				RefreshLeaderboard();
				Cancel();
			}
		}
		else
		{
			csMainMenuCanvas.instance.MsgPanel.SetMsg("", csLocalizationManager.Instance.GetLocalText("PopHint02"));
			csMainMenuCanvas.instance.MsgPanel.ShowHint(delegate
			{
				csMainMenuCanvas.instance.OpenMenu(MainMenuType.PropShop, "CoinShop");
			}, null);
		}
	}

	public void Cancel()
	{
		csMainMenuCanvas.instance.BackToMenu();
		((csMainStartPanel)csMainMenuCanvas.instance.MenuObjDic[MainMenuType.MainMenu]).ShowSetting();
	}

	private void ChangeNameCallBack(bool isSuccess, string error)
	{
		csGameSettings.IsLoading = false;
		LoadingObj.SetActive(value: false);
		UnityEngine.Debug.LogError("ChangeNameCallBack isSuccess= " + isSuccess);
		if (!isSuccess)
		{
			UnityEngine.Debug.LogError("error:" + error);
			csLocalizationManager.Instance.CheckTextFontType(TipsText);
			TipsText.text = csLocalizationManager.Instance.GetLocalText("ChangeName2") + error;
		}
		else
		{
			csPlayerData.PlayerCoin -= 2000;
			RefreshLeaderboard();
			Cancel();
		}
	}

	private void RefreshLeaderboard()
	{
		if (csPlayerData.HasLogin)
		{
			if (((csMainStartPanel)csMainMenuCanvas.instance.MenuObjDic[MainMenuType.MainMenu]).leaderboardPanel.isPlayFab)
			{
				csLeaderboard.instance.GetLeaderboard_Playfab();
			}
			else
			{
				csLeaderboard.instance.TryRefresh();
			}
		}
		else
		{
			csLeaderboard.instance.TryRefresh();
		}
	}
}
public class csVRKey : MonoBehaviour
{
	[SerializeField]
	private string value = "";

	public csChangeNamePanel manager2;

	private Button m_btn;

	private void Start()
	{
		m_btn = base.gameObject.AddComponent<Button>();
		m_btn.onClick.AddListener(OnPointerClick);
	}

	public void OnPointerClick()
	{
		if ((bool)manager2)
		{
			manager2.InputHandle(value);
		}
	}
}
public class PressedBtn : MonoBehaviour, IPointerDownHandler, IEventSystemHandler, IPointerEnterHandler, IPointerExitHandler, IPointerUpHandler
{
	private Button btn;

	private Image[] myIcons;

	private Text[] myTexts;

	private void Start()
	{
		btn = GetComponent<Button>();
		if (base.transform.childCount > 0)
		{
			myIcons = base.transform.GetComponentsInChildren<Image>();
			myTexts = base.transform.GetComponentsInChildren<Text>();
		}
	}

	public void OnPointerDown(PointerEventData eventData)
	{
		if (myIcons != null)
		{
			Image[] array = myIcons;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].color = btn.colors.pressedColor;
			}
		}
		if (myTexts != null)
		{
			Text[] array2 = myTexts;
			for (int i = 0; i < array2.Length; i++)
			{
				array2[i].color = btn.colors.pressedColor;
			}
		}
	}

	public void OnPointerEnter(PointerEventData eventData)
	{
		if (myIcons != null)
		{
			Image[] array = myIcons;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].color = btn.colors.highlightedColor;
			}
		}
		if (myTexts != null)
		{
			Text[] array2 = myTexts;
			for (int i = 0; i < array2.Length; i++)
			{
				array2[i].color = btn.colors.highlightedColor;
			}
		}
	}

	public void OnPointerExit(PointerEventData eventData)
	{
		if (myIcons != null)
		{
			Image[] array = myIcons;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].color = btn.colors.normalColor;
			}
		}
		if (myTexts != null)
		{
			Text[] array2 = myTexts;
			for (int i = 0; i < array2.Length; i++)
			{
				array2[i].color = btn.colors.normalColor;
			}
		}
	}

	public void OnPointerUp(PointerEventData eventData)
	{
		if (myIcons != null)
		{
			Image[] array = myIcons;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].color = btn.colors.highlightedColor;
			}
		}
		if (myTexts != null)
		{
			Text[] array2 = myTexts;
			for (int i = 0; i < array2.Length; i++)
			{
				array2[i].color = btn.colors.highlightedColor;
			}
		}
	}
}
public class SliderValuePass : MonoBehaviour
{
	private Text progress;

	private void Start()
	{
		progress = GetComponent<Text>();
	}

	public void UpdateProgress(float content)
	{
		progress.text = Mathf.Round(content * 100f) + "%";
	}
}
public class NoCollidersBehavior : StateMachineBehaviour
{
	[Header("Deactivate Colliders on Enter")]
	public bool enter = true;

	[Header("Activate Colliders on Exit")]
	public bool exit = true;

	private Collider[] cap;

	public override void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		cap = animator.GetComponentsInChildren<Collider>();
		if (enter)
		{
			Collider[] array = cap;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].enabled = false;
			}
		}
	}

	public override void OnStateExit(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		if (exit)
		{
			Collider[] array = cap;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].enabled = true;
			}
		}
	}
}
public class RootMotionBehaviour : StateMachineBehaviour
{
	public bool OnEnter;

	public bool RootMotionOnEnter;

	[Space]
	public bool OnExit;

	public bool RootMotionOnExit;

	public override void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		if (OnEnter)
		{
			animator.applyRootMotion = RootMotionOnEnter;
		}
	}

	public override void OnStateExit(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		if (OnExit)
		{
			animator.applyRootMotion = RootMotionOnExit;
		}
	}
}
internal interface IMWayPoint
{
	Transform NextTarget { get; }

	float StoppinDistance { get; }
}
public class GizmoVisualizer : MonoBehaviour
{
}
public class LockAxis : MonoBehaviour
{
	public bool LockX = true;

	public bool LockY;

	public bool LockZ;

	private void Update()
	{
		Vector3 position = base.transform.position;
		if (LockX)
		{
			position.x = 0f;
		}
		if (LockY)
		{
			position.y = 0f;
		}
		if (LockZ)
		{
			position.z = 0f;
		}
		base.transform.position = position;
	}
}
public static class MalbersAnimationsExtensions
{
	public static Transform FindGrandChild(this Transform aParent, string aName)
	{
		Transform transform = aParent.Find(aName);
		if (transform != null)
		{
			return transform;
		}
		foreach (Transform item in aParent)
		{
			transform = item.FindGrandChild(aName);
			if (transform != null)
			{
				return transform;
			}
		}
		return null;
	}

	public static Vector3 DeltaPositionFromRotate(this Transform transform, Vector3 point, Vector3 axis, float deltaAngle)
	{
		Vector3 position = transform.position;
		Vector3 vector = position - point;
		vector = Quaternion.AngleAxis(deltaAngle, axis) * vector;
		position = point + vector - position;
		position.y = 0f;
		return position;
	}

	public static void InvokeWithParams(this MonoBehaviour sender, string method, object args)
	{
		Type type = null;
		if (args != null)
		{
			type = args.GetType();
		}
		MethodInfo methodInfo = null;
		methodInfo = ((!(type != null)) ? sender.GetType().GetMethod(method) : sender.GetType().GetMethod(method, new Type[1] { type }));
		if (methodInfo != null)
		{
			if (args != null)
			{
				object[] parameters = new object[1] { args };
				methodInfo.Invoke(sender, parameters);
			}
			else
			{
				methodInfo.Invoke(sender, null);
			}
		}
		else
		{
			PropertyInfo property = sender.GetType().GetProperty(method);
			if (property != null)
			{
				property.SetValue(sender, args, null);
			}
		}
	}

	public static void InvokeDelay(this MonoBehaviour behaviour, string method, object options, YieldInstruction wait)
	{
		behaviour.StartCoroutine(behaviour._invoke(method, wait, options));
	}

	private static IEnumerator _invoke(this MonoBehaviour behaviour, string method, YieldInstruction wait, object options)
	{
		yield return wait;
		behaviour.GetType().GetMethod(method).Invoke(behaviour, new object[1] { options });
		yield return null;
	}

	public static void Invoke(this ScriptableObject sender, string method, object args)
	{
		MethodInfo method2 = sender.GetType().GetMethod(method);
		if (method2 != null)
		{
			if (args != null)
			{
				object[] parameters = new object[1] { args };
				method2.Invoke(sender, parameters);
			}
			else
			{
				method2.Invoke(sender, null);
			}
		}
	}

	public static void SetLayer(this GameObject parent, int layer, bool includeChildren = true)
	{
		parent.layer = layer;
		if (includeChildren)
		{
			Transform[] componentsInChildren = parent.transform.GetComponentsInChildren<Transform>(includeInactive: true);
			for (int i = 0; i < componentsInChildren.Length; i++)
			{
				componentsInChildren[i].gameObject.layer = layer;
			}
		}
	}
}
public class MComparer : MonoBehaviour
{
	public UnityEvent React = new UnityEvent();
}
public interface IInventory
{
}
public class FastList<T>
{
	public delegate int CompareFunc(T left, T right);

	public T[] array;

	public int size;

	public int Count
	{
		get
		{
			return size;
		}
		set
		{
		}
	}

	public T this[int i]
	{
		get
		{
			return array[i];
		}
		set
		{
			array[i] = value;
		}
	}

	public FastList()
	{
	}

	public FastList(int size)
	{
		if (size > 0)
		{
			this.size = 0;
			array = new T[size];
		}
		else
		{
			this.size = 0;
		}
	}

	public void Add(T item)
	{
		if (array == null || size == array.Length)
		{
			Allocate();
		}
		array[size] = item;
		size++;
	}

	public void AddUnique(T item)
	{
		if (array == null || size == array.Length)
		{
			Allocate();
		}
		if (!Contains(item))
		{
			array[size] = item;
			size++;
		}
	}

	public void AddRange(IEnumerable<T> items)
	{
		foreach (T item in items)
		{
			Add(item);
		}
	}

	public void Insert(int index, T item)
	{
		if (array == null || size == array.Length)
		{
			Allocate();
		}
		if (index < size)
		{
			for (int num = size; num > index; num--)
			{
				array[num] = array[num - 1];
			}
			array[index] = item;
			size++;
		}
		else
		{
			Add(item);
		}
	}

	public bool Remove(T item)
	{
		if (array != null)
		{
			for (int i = 0; i < size; i++)
			{
				if (item.Equals(array[i]))
				{
					size--;
					for (int j = i; j < size; j++)
					{
						array[j] = array[j + 1];
					}
					array[size] = default(T);
					return true;
				}
			}
		}
		return false;
	}

	public void RemoveAt(int index)
	{
		if (array != null && size > 0 && index < size)
		{
			size--;
			for (int i = index; i < size; i++)
			{
				array[i] = array[i + 1];
			}
			array[size] = default(T);
		}
	}

	public bool RemoveFast(T item)
	{
		if (array != null)
		{
			for (int i = 0; i < size; i++)
			{
				if (item.Equals(array[i]))
				{
					if (i < size - 1)
					{
						T val = array[size - 1];
						array[size - 1] = default(T);
						array[i] = val;
					}
					else
					{
						array[i] = default(T);
					}
					size--;
					return true;
				}
			}
		}
		return false;
	}

	public void RemoveAtFast(int index)
	{
		if (array != null && index < size && index >= 0)
		{
			if (index == size - 1)
			{
				array[index] = default(T);
			}
			else
			{
				T val = array[size - 1];
				array[index] = val;
				array[size - 1] = default(T);
			}
			size--;
		}
	}

	public bool Contains(T item)
	{
		if (array == null || size <= 0)
		{
			return false;
		}
		for (int i = 0; i < size; i++)
		{
			if (array[i].Equals(item))
			{
				return true;
			}
		}
		return false;
	}

	public int IndexOf(T item)
	{
		if (size <= 0 || array == null)
		{
			return -1;
		}
		for (int i = 0; i < size; i++)
		{
			if (item.Equals(array[i]))
			{
				return i;
			}
		}
		return -1;
	}

	public T Pop()
	{
		if (array != null && size > 0)
		{
			T result = array[size - 1];
			array[size - 1] = default(T);
			size--;
			return result;
		}
		return default(T);
	}

	public T[] ToArray()
	{
		Trim();
		return array;
	}

	public void Sort(CompareFunc comparer)
	{
		int num = 0;
		int num2 = size - 1;
		bool flag = true;
		while (flag)
		{
			flag = false;
			for (int i = num; i < num2; i++)
			{
				if (comparer(array[i], array[i + 1]) > 0)
				{
					T val = array[i];
					array[i] = array[i + 1];
					array[i + 1] = val;
					flag = true;
				}
				else if (!flag)
				{
					num = ((i != 0) ? (i - 1) : 0);
				}
			}
		}
	}

	public void InsertionSort(CompareFunc comparer)
	{
		for (int i = 1; i < size; i++)
		{
			T val = array[i];
			int num = i;
			while (num > 0 && comparer(array[num - 1], val) > 0)
			{
				array[num] = array[num - 1];
				num--;
			}
			array[num] = val;
		}
	}

	public IEnumerator<T> GetEnumerator()
	{
		if (array != null)
		{
			for (int i = 0; i < size; i++)
			{
				yield return array[i];
			}
		}
	}

	public T Find(Predicate<T> match)
	{
		if (match != null && array != null)
		{
			for (int i = 0; i < size; i++)
			{
				if (match(array[i]))
				{
					return array[i];
				}
			}
		}
		return default(T);
	}

	private void Allocate()
	{
		T[] array = ((this.array != null) ? new T[Mathf.Max(this.array.Length << 1, 32)] : new T[32]);
		if (this.array != null && size > 0)
		{
			this.array.CopyTo(array, 0);
		}
		this.array = array;
	}

	private void Trim()
	{
		if (size > 0)
		{
			T[] array = new T[size];
			for (int i = 0; i < size; i++)
			{
				array[i] = this.array[i];
			}
			this.array = array;
		}
		else
		{
			this.array = null;
		}
	}

	public void Clear()
	{
		size = 0;
	}

	public void Release()
	{
		Clear();
		array = null;
	}
}
public class InspectorNoteAttribute : PropertyAttribute
{
	public readonly string header;

	public readonly string message;

	public InspectorNoteAttribute(string header, string message = "")
	{
		this.header = header;
		this.message = message;
	}
}
public class InspectorCommentAttribute : PropertyAttribute
{
	public readonly string message;

	public InspectorCommentAttribute(string message = "")
	{
		this.message = message;
	}
}
[AddComponentMenu("Camera-Control/Mouse Look")]
public class MouseLook : MonoBehaviour
{
	public enum RotationAxes
	{
		MouseXAndY,
		MouseX,
		MouseY
	}

	public RotationAxes axes;

	public float sensitivityX = 15f;

	public float sensitivityY = 15f;

	public float minimumX = -360f;

	public float maximumX = 360f;

	public float minimumY = -60f;

	public float maximumY = 60f;

	private float rotationY;

	private void Update()
	{
		if (axes == RotationAxes.MouseXAndY)
		{
			float y = base.transform.localEulerAngles.y + Input.GetAxis("Mouse X") * sensitivityX;
			rotationY += Input.GetAxis("Mouse Y") * sensitivityY;
			rotationY = Mathf.Clamp(rotationY, minimumY, maximumY);
			base.transform.localEulerAngles = new Vector3(0f - rotationY, y, 0f);
		}
		else if (axes == RotationAxes.MouseX)
		{
			base.transform.Rotate(0f, Input.GetAxis("Mouse X") * sensitivityX, 0f);
		}
		else
		{
			rotationY += Input.GetAxis("Mouse Y") * sensitivityY;
			rotationY = Mathf.Clamp(rotationY, minimumY, maximumY);
			base.transform.localEulerAngles = new Vector3(0f - rotationY, base.transform.localEulerAngles.y, 0f);
		}
	}

	private void Start()
	{
		if ((bool)GetComponent<Rigidbody>())
		{
			GetComponent<Rigidbody>().freezeRotation = true;
		}
	}
}
public struct ReflectionSnapshot
{
	public AudioMixerSnapshot mixerSnapshot;

	public float fadeTime;
}
public class ONSPReflectionZone : MonoBehaviour
{
	public AudioMixerSnapshot mixerSnapshot;

	public float fadeTime;

	private static Stack<ReflectionSnapshot> snapshotList = new Stack<ReflectionSnapshot>();

	private static ReflectionSnapshot currentSnapshot = default(ReflectionSnapshot);

	private void Start()
	{
	}

	private void Update()
	{
	}

	private void OnTriggerEnter(Collider other)
	{
		if (CheckForAudioListener(other.gameObject))
		{
			PushCurrentMixerShapshot();
		}
	}

	private void OnTriggerExit(Collider other)
	{
		if (CheckForAudioListener(other.gameObject))
		{
			PopCurrentMixerSnapshot();
		}
	}

	private bool CheckForAudioListener(GameObject gameObject)
	{
		if (gameObject.GetComponentInChildren<AudioListener>() != null)
		{
			return true;
		}
		return false;
	}

	private void PushCurrentMixerShapshot()
	{
		ReflectionSnapshot item = currentSnapshot;
		snapshotList.Push(item);
		SetReflectionValues();
	}

	private void PopCurrentMixerSnapshot()
	{
		ReflectionSnapshot mss = snapshotList.Pop();
		SetReflectionValues(ref mss);
	}

	private void SetReflectionValues()
	{
		if (mixerSnapshot != null)
		{
			UnityEngine.Debug.Log("Setting off snapshot " + mixerSnapshot.name);
			mixerSnapshot.TransitionTo(fadeTime);
			currentSnapshot.mixerSnapshot = mixerSnapshot;
			currentSnapshot.fadeTime = fadeTime;
		}
		else
		{
			UnityEngine.Debug.Log("Mixer snapshot not set - Please ensure play area has at least one encompassing snapshot.");
		}
	}

	private void SetReflectionValues(ref ReflectionSnapshot mss)
	{
		if (mss.mixerSnapshot != null)
		{
			UnityEngine.Debug.Log("Setting off snapshot " + mss.mixerSnapshot.name);
			mss.mixerSnapshot.TransitionTo(mss.fadeTime);
			currentSnapshot.mixerSnapshot = mss.mixerSnapshot;
			currentSnapshot.fadeTime = mss.fadeTime;
		}
		else
		{
			UnityEngine.Debug.Log("Mixer snapshot not set - Please ensure play area has at least one encompassing snapshot.");
		}
	}
}
public class OculusSpatializerUnity : MonoBehaviour
{
	public delegate void AudioRaycastCallback(Vector3 origin, Vector3 direction, out Vector3 point, out Vector3 normal, IntPtr data);

	public LayerMask layerMask = -1;

	public bool visualizeRoom = true;

	private bool roomVisualizationInitialized;

	public int raysPerSecond = 256;

	public float roomInterpSpeed = 0.9f;

	public float maxWallDistance = 50f;

	public int rayCacheSize = 512;

	public bool dynamicReflectionsEnabled = true;

	private float particleSize = 0.2f;

	private float particleOffset = 0.1f;

	private GameObject room;

	private Renderer[] wallRenderer = new Renderer[6];

	private float[] dims = new float[3] { 1f, 1f, 1f };

	private float[] coefs = new float[6];

	private const int HIT_COUNT = 2048;

	private Vector3[] points = new Vector3[2048];

	private Vector3[] normals = new Vector3[2048];

	private ParticleSystem sys;

	private ParticleSystem.Particle[] particles = new ParticleSystem.Particle[2048];

	private static LayerMask gLayerMask = -1;

	private const string strOSP = "AudioPluginOculusSpatializer";

	private static Vector3 swapHandedness(Vector3 vec)
	{
		return new Vector3(vec.x, vec.y, 0f - vec.z);
	}

	[MonoPInvokeCallback(typeof(AudioRaycastCallback))]
	private static void AudioRaycast(Vector3 origin, Vector3 direction, out Vector3 point, out Vector3 normal, IntPtr data)
	{
		point = Vector3.zero;
		normal = Vector3.zero;
		if (Physics.Raycast(swapHandedness(origin), swapHandedness(direction), out var hitInfo, 1000f, gLayerMask.value))
		{
			point = swapHandedness(hitInfo.point);
			normal = swapHandedness(hitInfo.normal);
		}
	}

	private void Start()
	{
		OSP_Unity_AssignRaycastCallback(AudioRaycast, IntPtr.Zero);
	}

	private void OnDestroy()
	{
		OSP_Unity_AssignRaycastCallback(IntPtr.Zero, IntPtr.Zero);
	}

	private void Update()
	{
		if (dynamicReflectionsEnabled)
		{
			OSP_Unity_AssignRaycastCallback(AudioRaycast, IntPtr.Zero);
		}
		else
		{
			OSP_Unity_AssignRaycastCallback(IntPtr.Zero, IntPtr.Zero);
		}
		OSP_Unity_SetDynamicRoomRaysPerSecond(raysPerSecond);
		OSP_Unity_SetDynamicRoomInterpSpeed(roomInterpSpeed);
		OSP_Unity_SetDynamicRoomMaxWallDistance(maxWallDistance);
		OSP_Unity_SetDynamicRoomRaysRayCacheSize(rayCacheSize);
		gLayerMask = layerMask;
		OSP_Unity_UpdateRoomModel(1f);
		if (!visualizeRoom)
		{
			return;
		}
		if (!roomVisualizationInitialized)
		{
			inititalizeRoomVisualization();
			roomVisualizationInitialized = true;
		}
		OSP_Unity_GetRoomDimensions(dims, coefs, out var position);
		position.z *= -1f;
		Vector3 vector = new Vector3(dims[0], dims[1], dims[2]);
		float sqrMagnitude = vector.sqrMagnitude;
		if (!float.IsNaN(sqrMagnitude) && 0f < sqrMagnitude && sqrMagnitude < 1000000f)
		{
			base.transform.localScale = vector * 0.999f;
		}
		base.transform.position = position;
		OSP_Unity_GetRaycastHits(points, normals, 2048);
		for (int i = 0; i < 2048; i++)
		{
			if (points[i] == Vector3.zero)
			{
				points[i].y = -10000f;
			}
			points[i].z *= -1f;
			normals[i].z *= -1f;
			particles[i].position = points[i] + normals[i] * particleOffset;
			if (normals[i] != Vector3.zero)
			{
				particles[i].rotation3D = Quaternion.LookRotation(normals[i]).eulerAngles;
			}
			particles[i].startSize = particleSize;
			particles[i].startColor = new Color(0.8156863f, 0.14901961f, 58f / 85f, 1f);
		}
		for (int j = 0; j < 6; j++)
		{
			Color value = Color.Lerp(Color.red, Color.green, coefs[j]);
			wallRenderer[j].material.SetColor("_TintColor", value);
		}
		sys.SetParticles(particles, particles.Length);
	}

	private void inititalizeRoomVisualization()
	{
		UnityEngine.Debug.Log("Oculus Audio dynamic room estimation visualization enabled");
		base.transform.position = Vector3.zero;
		GameObject gameObject = new GameObject("DecalManager");
		gameObject.transform.parent = base.transform;
		sys = gameObject.AddComponent<ParticleSystem>();
		ParticleSystem.MainModule main = sys.main;
		main.simulationSpace = ParticleSystemSimulationSpace.World;
		main.loop = false;
		main.playOnAwake = false;
		ParticleSystem.EmissionModule emission = sys.emission;
		emission.enabled = false;
		ParticleSystem.ShapeModule shape = sys.shape;
		shape.enabled = false;
		ParticleSystemRenderer component = sys.GetComponent<ParticleSystemRenderer>();
		component.renderMode = ParticleSystemRenderMode.Mesh;
		component.material.shader = Shader.Find("Particles/Additive");
		Texture2D texture2D = new Texture2D(64, 64);
		for (int i = 0; i < 32; i++)
		{
			for (int j = 0; j < 32; j++)
			{
				float num = 32 - i;
				float num2 = 32 - j;
				float num3 = Mathf.Sqrt(num * num + num2 * num2);
				float num4 = 2f * num3 / 32f;
				float a = ((num3 < 32f) ? Mathf.Clamp01(Mathf.Sin((float)Math.PI * 2f * num4)) : 0f);
				Color color = new Color(1f, 1f, 1f, a);
				texture2D.SetPixel(i, j, color);
				texture2D.SetPixel(64 - i, j, color);
				texture2D.SetPixel(i, 64 - j, color);
				texture2D.SetPixel(64 - i, 64 - j, color);
			}
		}
		texture2D.Apply();
		component.material.mainTexture = texture2D;
		Mesh mesh = new Mesh();
		mesh.name = "ParticleQuad";
		mesh.vertices = new Vector3[4]
		{
			new Vector3(-0.5f, -0.5f, 0f),
			new Vector3(0.5f, -0.5f, 0f),
			new Vector3(0.5f, 0.5f, 0f),
			new Vector3(-0.5f, 0.5f, 0f)
		};
		mesh.uv = new Vector2[4]
		{
			new Vector2(0f, 0f),
			new Vector2(0f, 1f),
			new Vector2(1f, 1f),
			new Vector2(1f, 0f)
		};
		mesh.triangles = new int[6] { 0, 1, 2, 0, 2, 3 };
		mesh.RecalculateNormals();
		component.mesh = mesh;
		sys.Emit(2048);
		room = new GameObject("RoomVisualizer");
		room.transform.parent = base.transform;
		room.transform.localPosition = Vector3.zero;
		Texture2D texture2D2 = new Texture2D(32, 32);
		Color color2 = new Color(0f, 0f, 0f, 0f);
		for (int k = 0; k < 32; k++)
		{
			for (int l = 0; l < 32; l++)
			{
				texture2D2.SetPixel(k, l, color2);
			}
		}
		for (int m = 0; m < 32; m++)
		{
			Color color3 = Color.white * 0.125f;
			texture2D2.SetPixel(8, m, color3);
			texture2D2.SetPixel(m, 8, color3);
			texture2D2.SetPixel(24, m, color3);
			texture2D2.SetPixel(m, 24, color3);
			color3 *= 2f;
			texture2D2.SetPixel(16, m, color3);
			texture2D2.SetPixel(m, 16, color3);
			color3 *= 2f;
			texture2D2.SetPixel(0, m, color3);
			texture2D2.SetPixel(m, 0, color3);
		}
		texture2D2.Apply();
		for (int n = 0; n < 6; n++)
		{
			Mesh mesh2 = new Mesh();
			mesh2.name = "Plane" + n;
			Vector3[] array = new Vector3[4];
			int num5 = n / 2;
			int num6 = ((n % 2 == 0) ? 1 : (-1));
			for (int num7 = 0; num7 < 4; num7++)
			{
				array[num7][num5] = (float)num6 * 0.5f;
				array[num7][(num5 + 1) % 3] = 0.5f * (float)((num7 == 1 || num7 == 2) ? 1 : (-1));
				array[num7][(num5 + 2) % 3] = 0.5f * (float)((num7 == 2 || num7 == 3) ? 1 : (-1));
			}
			mesh2.vertices = array;
			mesh2.uv = new Vector2[4]
			{
				new Vector2(0f, 0f),
				new Vector2(0f, 1f),
				new Vector2(1f, 1f),
				new Vector2(1f, 0f)
			};
			mesh2.triangles = new int[6] { 0, 1, 2, 0, 2, 3 };
			mesh2.RecalculateNormals();
			GameObject obj = new GameObject("Wall_" + n);
			obj.AddComponent<MeshFilter>().mesh = mesh2;
			MeshRenderer meshRenderer = obj.AddComponent<MeshRenderer>();
			wallRenderer[n] = meshRenderer;
			meshRenderer.material.shader = Shader.Find("Particles/Additive");
			meshRenderer.material.mainTexture = texture2D2;
			meshRenderer.material.mainTextureScale = new Vector2(8f, 8f);
			obj.transform.parent = room.transform;
			room.transform.localPosition = Vector3.zero;
		}
	}

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_Unity_AssignRaycastCallback(AudioRaycastCallback callback, IntPtr data);

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_Unity_AssignRaycastCallback(IntPtr callback, IntPtr data);

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_Unity_SetDynamicRoomRaysPerSecond(int RaysPerSecond);

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_Unity_SetDynamicRoomInterpSpeed(float InterpSpeed);

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_Unity_SetDynamicRoomMaxWallDistance(float MaxWallDistance);

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_Unity_SetDynamicRoomRaysRayCacheSize(int RayCacheSize);

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_Unity_UpdateRoomModel(float wetLevel);

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_Unity_GetRoomDimensions(float[] roomDimensions, float[] reflectionsCoefs, out Vector3 position);

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_Unity_GetRaycastHits(Vector3[] points, Vector3[] normals, int length);
}
public class ONSPAmbisonicsNative : MonoBehaviour
{
	public enum ovrAmbisonicsNativeStatus
	{
		Uninitialized = -1,
		NotEnabled,
		Success,
		StreamError,
		ProcessError,
		MaxStatValue
	}

	private AudioSource source;

	private static int numFOAChannels = 4;

	private static int paramAmbiStat = 6;

	private ovrAmbisonicsNativeStatus currentStatus = ovrAmbisonicsNativeStatus.Uninitialized;

	private void OnEnable()
	{
		source = GetComponent<AudioSource>();
		currentStatus = ovrAmbisonicsNativeStatus.Uninitialized;
		if (source == null)
		{
			UnityEngine.Debug.Log("Ambisonic ERROR: AudioSource does not exist.");
			return;
		}
		if (source.spatialize)
		{
			UnityEngine.Debug.Log("Ambisonic WARNING: Turning spatialize field off for Ambisonic sources.");
			source.spatialize = false;
		}
		if (source.clip == null)
		{
			UnityEngine.Debug.Log("Ambisonic ERROR: AudioSource does not contain an audio clip.");
		}
		else if (source.clip.channels != numFOAChannels)
		{
			UnityEngine.Debug.Log("Ambisonic ERROR: AudioSource clip does not have correct number of channels.");
		}
	}

	private void Update()
	{
		if (source == null)
		{
			return;
		}
		float value = 0f;
		source.GetAmbisonicDecoderFloat(paramAmbiStat, out value);
		ovrAmbisonicsNativeStatus ovrAmbisonicsNativeStatus = (ovrAmbisonicsNativeStatus)value;
		if (ovrAmbisonicsNativeStatus != currentStatus)
		{
			switch (ovrAmbisonicsNativeStatus)
			{
			case ovrAmbisonicsNativeStatus.NotEnabled:
				UnityEngine.Debug.Log("Ambisonic Native: Ambisonic not enabled on clip. Check clip field and turn it on");
				break;
			case ovrAmbisonicsNativeStatus.Uninitialized:
				UnityEngine.Debug.Log("Ambisonic Native: Stream uninitialized");
				break;
			case ovrAmbisonicsNativeStatus.Success:
				UnityEngine.Debug.Log("Ambisonic Native: Stream successfully initialized and playing/playable");
				break;
			case ovrAmbisonicsNativeStatus.StreamError:
				UnityEngine.Debug.Log("Ambisonic Native WARNING: Stream error (bad input format?)");
				break;
			case ovrAmbisonicsNativeStatus.ProcessError:
				UnityEngine.Debug.Log("Ambisonic Native WARNING: Stream process error (check default speaker setup)");
				break;
			}
		}
		currentStatus = ovrAmbisonicsNativeStatus;
	}
}
public class ONSPAudioSource : MonoBehaviour
{
	private enum Parameters
	{
		P_GAIN,
		P_USEINVSQR,
		P_NEAR,
		P_FAR,
		P_RADIUS,
		P_DISABLE_RFL,
		P_AMBISTAT,
		P_READONLY_GLOBAL_RFL_ENABLED,
		P_READONLY_NUM_VOICES,
		P_SENDLEVEL,
		P_NUM
	}

	public const string strONSPS = "AudioPluginOculusSpatializer";

	[SerializeField]
	private bool enableSpatialization = true;

	[SerializeField]
	private float gain;

	[SerializeField]
	private bool useInvSqr;

	[SerializeField]
	private float near = 0.25f;

	[SerializeField]
	private float far = 250f;

	[SerializeField]
	private float volumetricRadius;

	[SerializeField]
	private float reverbSend;

	[SerializeField]
	private bool enableRfl;

	private static ONSPAudioSource RoomReflectionGizmoAS;

	public bool EnableSpatialization
	{
		get
		{
			return enableSpatialization;
		}
		set
		{
			enableSpatialization = value;
		}
	}

	public float Gain
	{
		get
		{
			return gain;
		}
		set
		{
			gain = Mathf.Clamp(value, 0f, 24f);
		}
	}

	public bool UseInvSqr
	{
		get
		{
			return useInvSqr;
		}
		set
		{
			useInvSqr = value;
		}
	}

	public float Near
	{
		get
		{
			return near;
		}
		set
		{
			near = Mathf.Clamp(value, 0f, 1000000f);
		}
	}

	public float Far
	{
		get
		{
			return far;
		}
		set
		{
			far = Mathf.Clamp(value, 0f, 1000000f);
		}
	}

	public float VolumetricRadius
	{
		get
		{
			return volumetricRadius;
		}
		set
		{
			volumetricRadius = Mathf.Clamp(value, 0f, 1000f);
		}
	}

	public float ReverbSend
	{
		get
		{
			return reverbSend;
		}
		set
		{
			reverbSend = Mathf.Clamp(value, -60f, 20f);
		}
	}

	public bool EnableRfl
	{
		get
		{
			return enableRfl;
		}
		set
		{
			enableRfl = value;
		}
	}

	[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
	private static void OnBeforeSceneLoadRuntimeMethod()
	{
		OSP_SetGlobalVoiceLimit(ONSPSettings.Instance.voiceLimit);
	}

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern void ONSP_GetGlobalRoomReflectionValues(ref bool reflOn, ref bool reverbOn, ref float width, ref float height, ref float length);

	private void Awake()
	{
		AudioSource source = GetComponent<AudioSource>();
		SetParameters(ref source);
	}

	private void Start()
	{
	}

	private void Update()
	{
		AudioSource source = GetComponent<AudioSource>();
		if (!UnityEngine.Application.isPlaying || AudioListener.pause || !source.isPlaying || !source.isActiveAndEnabled)
		{
			source.spatialize = false;
		}
		else
		{
			SetParameters(ref source);
		}
	}

	public void SetParameters(ref AudioSource source)
	{
		source.spatialize = enableSpatialization;
		source.SetSpatializerFloat(0, gain);
		if (useInvSqr)
		{
			source.SetSpatializerFloat(1, 1f);
		}
		else
		{
			source.SetSpatializerFloat(1, 0f);
		}
		source.SetSpatializerFloat(2, near);
		source.SetSpatializerFloat(3, far);
		source.SetSpatializerFloat(4, volumetricRadius);
		if (enableRfl)
		{
			source.SetSpatializerFloat(5, 0f);
		}
		else
		{
			source.SetSpatializerFloat(5, 1f);
		}
		source.SetSpatializerFloat(9, reverbSend);
	}

	private void OnDrawGizmos()
	{
		if (RoomReflectionGizmoAS == null)
		{
			RoomReflectionGizmoAS = this;
		}
		Color color = default(Color);
		color.r = 1f;
		color.g = 0.5f;
		color.b = 0f;
		color.a = 1f;
		Gizmos.color = color;
		Gizmos.DrawWireSphere(base.transform.position, Near);
		color.a = 0.1f;
		Gizmos.color = color;
		Gizmos.DrawSphere(base.transform.position, Near);
		color.r = 1f;
		color.g = 0f;
		color.b = 0f;
		color.a = 1f;
		Gizmos.color = Color.red;
		Gizmos.DrawWireSphere(base.transform.position, Far);
		color.a = 0.1f;
		Gizmos.color = color;
		Gizmos.DrawSphere(base.transform.position, Far);
		color.r = 1f;
		color.g = 0f;
		color.b = 1f;
		color.a = 1f;
		Gizmos.color = color;
		Gizmos.DrawWireSphere(base.transform.position, VolumetricRadius);
		color.a = 0.1f;
		Gizmos.color = color;
		Gizmos.DrawSphere(base.transform.position, VolumetricRadius);
		if (RoomReflectionGizmoAS == this)
		{
			bool reflOn = false;
			bool reverbOn = false;
			float width = 1f;
			float height = 1f;
			float length = 1f;
			ONSP_GetGlobalRoomReflectionValues(ref reflOn, ref reverbOn, ref width, ref height, ref length);
			if (Camera.main != null && reflOn)
			{
				color = (Gizmos.color = ((!reverbOn) ? Color.cyan : Color.white));
				Gizmos.DrawWireCube(Camera.main.transform.position, new Vector3(width, height, length));
				color.a = 0.1f;
				Gizmos.color = color;
				Gizmos.DrawCube(Camera.main.transform.position, new Vector3(width, height, length));
			}
		}
	}

	private void OnDestroy()
	{
		if (RoomReflectionGizmoAS == this)
		{
			RoomReflectionGizmoAS = null;
		}
	}

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_SetGlobalVoiceLimit(int VoiceLimit);
}
public class ONSPProfiler : MonoBehaviour
{
	public bool profilerEnabled;

	private const int DEFAULT_PORT = 2121;

	public int port = 2121;

	public const string strONSPS = "AudioPluginOculusSpatializer";

	private void Start()
	{
		UnityEngine.Application.runInBackground = true;
	}

	private void Update()
	{
		if (port < 0 || port > 65535)
		{
			port = 2121;
		}
		ONSP_SetProfilerPort(port);
		ONSP_SetProfilerEnabled(profilerEnabled);
	}

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int ONSP_SetProfilerEnabled(bool enabled);

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int ONSP_SetProfilerPort(int port);
}
public class ONSPPropagationGeometry : MonoBehaviour
{
	private struct MeshMaterial
	{
		public MeshFilter meshFilter;

		public ONSPPropagationMaterial[] materials;
	}

	private struct TerrainMaterial
	{
		public Terrain terrain;

		public ONSPPropagationMaterial[] materials;

		public Mesh[] treePrototypeMeshes;
	}

	public static string GeometryAssetDirectory = "AudioGeometry";

	public string filePathRelative = "";

	public bool fileEnabled;

	public bool includeChildMeshes = true;

	private IntPtr geometryHandle = IntPtr.Zero;

	public static int OSPSuccess = 0;

	public const string GEOMETRY_FILE_EXTENSION = "ovramesh";

	private static int terrainDecimation = 4;

	public static string GeometryAssetPath => UnityEngine.Application.streamingAssetsPath + "/" + GeometryAssetDirectory;

	public string filePath => GeometryAssetPath + "/" + filePathRelative;

	private static string GetPath(Transform current)
	{
		if (current.parent == null)
		{
			return current.gameObject.scene.name + "/" + current.name;
		}
		return GetPath(current.parent) + "-" + current.name;
	}

	private void Awake()
	{
		CreatePropagationGeometry();
	}

	private void CreatePropagationGeometry()
	{
		if (ONSPPropagation.Interface.CreateAudioGeometry(out geometryHandle) != OSPSuccess)
		{
			throw new Exception("Unable to create geometry handle");
		}
		if (filePath != null && filePath.Length != 0 && fileEnabled && UnityEngine.Application.isPlaying)
		{
			if (!ReadFile())
			{
				UnityEngine.Debug.LogError("Failed to read file, attempting to regenerate audio geometry");
				UploadGeometry();
			}
		}
		else
		{
			UploadGeometry();
		}
	}

	private void Update()
	{
		if (!(geometryHandle == IntPtr.Zero))
		{
			Matrix4x4 localToWorldMatrix = base.transform.localToWorldMatrix;
			float[] matrix4x = new float[16]
			{
				localToWorldMatrix[0, 0],
				localToWorldMatrix[1, 0],
				0f - localToWorldMatrix[2, 0],
				localToWorldMatrix[3, 0],
				localToWorldMatrix[0, 1],
				localToWorldMatrix[1, 1],
				0f - localToWorldMatrix[2, 1],
				localToWorldMatrix[3, 1],
				localToWorldMatrix[0, 2],
				localToWorldMatrix[1, 2],
				0f - localToWorldMatrix[2, 2],
				localToWorldMatrix[3, 2],
				localToWorldMatrix[0, 3],
				localToWorldMatrix[1, 3],
				0f - localToWorldMatrix[2, 3],
				localToWorldMatrix[3, 3]
			};
			ONSPPropagation.Interface.AudioGeometrySetTransform(geometryHandle, matrix4x);
		}
	}

	private void OnDestroy()
	{
		if (geometryHandle != IntPtr.Zero && ONSPPropagation.Interface.DestroyAudioGeometry(geometryHandle) != OSPSuccess)
		{
			throw new Exception("Unable to destroy geometry");
		}
		geometryHandle = IntPtr.Zero;
	}

	private static void traverseMeshHierarchy(GameObject obj, ONSPPropagationMaterial[] currentMaterials, bool includeChildren, List<MeshMaterial> meshMaterials, List<TerrainMaterial> terrainMaterials, bool ignoreStatic, ref int ignoredMeshCount)
	{
		if (!obj.activeInHierarchy)
		{
			return;
		}
		MeshFilter[] components = obj.GetComponents<MeshFilter>();
		Terrain[] components2 = obj.GetComponents<Terrain>();
		ONSPPropagationMaterial[] components3 = obj.GetComponents<ONSPPropagationMaterial>();
		if (components3 != null && components3.Length != 0)
		{
			int num = components3.Length;
			if (currentMaterials != null)
			{
				num = Math.Max(num, currentMaterials.Length);
			}
			ONSPPropagationMaterial[] array = new ONSPPropagationMaterial[num];
			if (currentMaterials != null)
			{
				for (int i = components3.Length; i < num; i++)
				{
					array[i] = currentMaterials[i];
				}
			}
			currentMaterials = array;
			for (int j = 0; j < components3.Length; j++)
			{
				currentMaterials[j] = components3[j];
			}
		}
		MeshFilter[] array2 = components;
		foreach (MeshFilter meshFilter in array2)
		{
			Mesh sharedMesh = meshFilter.sharedMesh;
			if (!(sharedMesh == null))
			{
				if (ignoreStatic && !sharedMesh.isReadable)
				{
					UnityEngine.Debug.LogWarning("Mesh: " + meshFilter.gameObject.name + " not readable, cannot be static.", meshFilter.gameObject);
					ignoredMeshCount++;
					continue;
				}
				MeshMaterial item = default(MeshMaterial);
				item.meshFilter = meshFilter;
				item.materials = currentMaterials;
				meshMaterials.Add(item);
			}
		}
		Terrain[] array3 = components2;
		foreach (Terrain terrain in array3)
		{
			TerrainMaterial item2 = default(TerrainMaterial);
			item2.terrain = terrain;
			item2.materials = currentMaterials;
			terrainMaterials.Add(item2);
		}
		if (!includeChildren)
		{
			return;
		}
		foreach (Transform item3 in obj.transform)
		{
			if (item3.GetComponent<ONSPPropagationGeometry>() == null)
			{
				traverseMeshHierarchy(item3.gameObject, currentMaterials, includeChildren, meshMaterials, terrainMaterials, ignoreStatic, ref ignoredMeshCount);
			}
		}
	}

	private int uploadMesh(IntPtr geometryHandle, GameObject meshObject, Matrix4x4 worldToLocal)
	{
		int ignoredMeshCount = 0;
		return uploadMesh(geometryHandle, meshObject, worldToLocal, ignoreStatic: false, ref ignoredMeshCount);
	}

	private int uploadMesh(IntPtr geometryHandle, GameObject meshObject, Matrix4x4 worldToLocal, bool ignoreStatic, ref int ignoredMeshCount)
	{
		List<MeshMaterial> list = new List<MeshMaterial>();
		List<TerrainMaterial> list2 = new List<TerrainMaterial>();
		traverseMeshHierarchy(meshObject, null, includeChildMeshes, list, list2, ignoreStatic, ref ignoredMeshCount);
		ONSPPropagationMaterial[] array = new ONSPPropagationMaterial[1] { base.gameObject.AddComponent<ONSPPropagationMaterial>() };
		array[0].SetPreset(ONSPPropagationMaterial.Preset.Foliage);
		int totalVertexCount = 0;
		uint totalIndexCount = 0u;
		int totalFaceCount = 0;
		int totalMaterialCount = 0;
		foreach (MeshMaterial item in list)
		{
			updateCountsForMesh(ref totalVertexCount, ref totalIndexCount, ref totalFaceCount, ref totalMaterialCount, item.meshFilter.sharedMesh);
		}
		for (int i = 0; i < list2.Count; i++)
		{
			TerrainMaterial value = list2[i];
			TerrainData terrainData = value.terrain.terrainData;
			int heightmapWidth = terrainData.heightmapWidth;
			int heightmapHeight = terrainData.heightmapHeight;
			int num = (heightmapWidth - 1) / terrainDecimation + 1;
			int num2 = (heightmapHeight - 1) / terrainDecimation + 1;
			int num3 = num * num2;
			int num4 = (num - 1) * (num2 - 1) * 6;
			totalMaterialCount++;
			totalVertexCount += num3;
			totalIndexCount += (uint)num4;
			totalFaceCount += num4 / 3;
			TreePrototype[] treePrototypes = terrainData.treePrototypes;
			value.treePrototypeMeshes = new Mesh[treePrototypes.Length];
			for (int j = 0; j < treePrototypes.Length; j++)
			{
				MeshFilter[] componentsInChildren = treePrototypes[j].prefab.GetComponentsInChildren<MeshFilter>();
				int num5 = int.MaxValue;
				int num6 = -1;
				for (int k = 0; k < componentsInChildren.Length; k++)
				{
					int vertexCount = componentsInChildren[k].sharedMesh.vertexCount;
					if (vertexCount < num5)
					{
						num5 = vertexCount;
						num6 = k;
					}
				}
				value.treePrototypeMeshes[j] = componentsInChildren[num6].sharedMesh;
			}
			TreeInstance[] treeInstances = terrainData.treeInstances;
			for (int l = 0; l < treeInstances.Length; l++)
			{
				TreeInstance treeInstance = treeInstances[l];
				updateCountsForMesh(ref totalVertexCount, ref totalIndexCount, ref totalFaceCount, ref totalMaterialCount, value.treePrototypeMeshes[treeInstance.prototypeIndex]);
			}
			list2[i] = value;
		}
		List<Vector3> tempVertices = new List<Vector3>();
		List<int> tempIndices = new List<int>();
		MeshGroup[] array2 = new MeshGroup[totalMaterialCount];
		float[] array3 = new float[totalVertexCount * 3];
		int[] array4 = new int[totalIndexCount];
		int vertexOffset = 0;
		int indexOffset = 0;
		int groupOffset = 0;
		foreach (MeshMaterial item2 in list)
		{
			MeshFilter meshFilter = item2.meshFilter;
			Matrix4x4 matrix = worldToLocal * meshFilter.gameObject.transform.localToWorldMatrix;
			uploadMeshFilter(tempVertices, tempIndices, array2, array3, array4, ref vertexOffset, ref indexOffset, ref groupOffset, meshFilter.sharedMesh, item2.materials, matrix);
		}
		foreach (TerrainMaterial item3 in list2)
		{
			TerrainData terrainData2 = item3.terrain.terrainData;
			Matrix4x4 matrix4x = worldToLocal * item3.terrain.gameObject.transform.localToWorldMatrix;
			int heightmapWidth2 = terrainData2.heightmapWidth;
			int heightmapHeight2 = terrainData2.heightmapHeight;
			float[,] heights = terrainData2.GetHeights(0, 0, heightmapWidth2, heightmapHeight2);
			Vector3 size = terrainData2.size;
			size = new Vector3(size.x / (float)(heightmapWidth2 - 1) * (float)terrainDecimation, size.y, size.z / (float)(heightmapHeight2 - 1) * (float)terrainDecimation);
			int num7 = (heightmapWidth2 - 1) / terrainDecimation + 1;
			int num8 = (heightmapHeight2 - 1) / terrainDecimation + 1;
			int num9 = num7 * num8;
			int num10 = (num7 - 1) * (num8 - 1) * 2;
			array2[groupOffset].faceType = FaceType.TRIANGLES;
			array2[groupOffset].faceCount = (UIntPtr)(ulong)num10;
			array2[groupOffset].indexOffset = (UIntPtr)(ulong)indexOffset;
			if (item3.materials != null && item3.materials.Length != 0)
			{
				item3.materials[0].StartInternal();
				array2[groupOffset].material = item3.materials[0].materialHandle;
			}
			else
			{
				array2[groupOffset].material = IntPtr.Zero;
			}
			for (int m = 0; m < num8; m++)
			{
				for (int n = 0; n < num7; n++)
				{
					int num11 = (vertexOffset + m * num7 + n) * 3;
					Vector3 vector = matrix4x.MultiplyPoint3x4(Vector3.Scale(size, new Vector3(m, heights[n * terrainDecimation, m * terrainDecimation], n)));
					array3[num11] = vector.x;
					array3[num11 + 1] = vector.y;
					array3[num11 + 2] = vector.z;
				}
			}
			for (int num12 = 0; num12 < num8 - 1; num12++)
			{
				for (int num13 = 0; num13 < num7 - 1; num13++)
				{
					array4[indexOffset] = vertexOffset + num12 * num7 + num13;
					array4[indexOffset + 1] = vertexOffset + num12 * num7 + num13 + 1;
					array4[indexOffset + 2] = vertexOffset + (num12 + 1) * num7 + num13;
					array4[indexOffset + 3] = vertexOffset + (num12 + 1) * num7 + num13;
					array4[indexOffset + 4] = vertexOffset + num12 * num7 + num13 + 1;
					array4[indexOffset + 5] = vertexOffset + (num12 + 1) * num7 + num13 + 1;
					indexOffset += 6;
				}
			}
			vertexOffset += num9;
			groupOffset++;
			TreeInstance[] treeInstances = terrainData2.treeInstances;
			for (int l = 0; l < treeInstances.Length; l++)
			{
				TreeInstance treeInstance2 = treeInstances[l];
				Vector3 vector2 = Vector3.Scale(treeInstance2.position, terrainData2.size);
				Matrix4x4 localToWorldMatrix = item3.terrain.gameObject.transform.localToWorldMatrix;
				localToWorldMatrix.SetColumn(3, localToWorldMatrix.GetColumn(3) + new Vector4(vector2.x, vector2.y, vector2.z, 0f));
				Matrix4x4 matrix2 = worldToLocal * localToWorldMatrix;
				uploadMeshFilter(tempVertices, tempIndices, array2, array3, array4, ref vertexOffset, ref indexOffset, ref groupOffset, item3.treePrototypeMeshes[treeInstance2.prototypeIndex], array, matrix2);
			}
		}
		return ONSPPropagation.Interface.AudioGeometryUploadMeshArrays(geometryHandle, array3, totalVertexCount, array4, array4.Length, array2, array2.Length);
	}

	private static void uploadMeshFilter(List<Vector3> tempVertices, List<int> tempIndices, MeshGroup[] groups, float[] vertices, int[] indices, ref int vertexOffset, ref int indexOffset, ref int groupOffset, Mesh mesh, ONSPPropagationMaterial[] materials, Matrix4x4 matrix)
	{
		tempVertices.Clear();
		mesh.GetVertices(tempVertices);
		int count = tempVertices.Count;
		for (int i = 0; i < count; i++)
		{
			Vector3 vector = matrix.MultiplyPoint3x4(tempVertices[i]);
			int num = (vertexOffset + i) * 3;
			vertices[num] = vector.x;
			vertices[num + 1] = vector.y;
			vertices[num + 2] = vector.z;
		}
		for (int j = 0; j < mesh.subMeshCount; j++)
		{
			MeshTopology topology = mesh.GetTopology(j);
			if (topology != 0 && topology != MeshTopology.Quads)
			{
				continue;
			}
			tempIndices.Clear();
			mesh.GetIndices(tempIndices, j);
			int count2 = tempIndices.Count;
			for (int k = 0; k < count2; k++)
			{
				indices[indexOffset + k] = tempIndices[k] + vertexOffset;
			}
			switch (topology)
			{
			case MeshTopology.Triangles:
				groups[groupOffset + j].faceType = FaceType.TRIANGLES;
				groups[groupOffset + j].faceCount = (UIntPtr)(ulong)(count2 / 3);
				break;
			case MeshTopology.Quads:
				groups[groupOffset + j].faceType = FaceType.QUADS;
				groups[groupOffset + j].faceCount = (UIntPtr)(ulong)(count2 / 4);
				break;
			}
			groups[groupOffset + j].indexOffset = (UIntPtr)(ulong)indexOffset;
			if (materials != null && materials.Length != 0)
			{
				int num2 = j;
				if (num2 >= materials.Length)
				{
					num2 = materials.Length - 1;
				}
				materials[num2].StartInternal();
				groups[groupOffset + j].material = materials[num2].materialHandle;
			}
			else
			{
				groups[groupOffset + j].material = IntPtr.Zero;
			}
			indexOffset += count2;
		}
		vertexOffset += count;
		groupOffset += mesh.subMeshCount;
	}

	private static void updateCountsForMesh(ref int totalVertexCount, ref uint totalIndexCount, ref int totalFaceCount, ref int totalMaterialCount, Mesh mesh)
	{
		totalMaterialCount += mesh.subMeshCount;
		totalVertexCount += mesh.vertexCount;
		for (int i = 0; i < mesh.subMeshCount; i++)
		{
			MeshTopology topology = mesh.GetTopology(i);
			if (topology == MeshTopology.Triangles || topology == MeshTopology.Quads)
			{
				uint indexCount = mesh.GetIndexCount(i);
				totalIndexCount += indexCount;
				switch (topology)
				{
				case MeshTopology.Triangles:
					totalFaceCount += (int)indexCount / 3;
					break;
				case MeshTopology.Quads:
					totalFaceCount += (int)indexCount / 4;
					break;
				}
			}
		}
	}

	public void UploadGeometry()
	{
		int ignoredMeshCount = 0;
		if (uploadMesh(geometryHandle, base.gameObject, base.gameObject.transform.worldToLocalMatrix, ignoreStatic: true, ref ignoredMeshCount) != OSPSuccess)
		{
			throw new Exception("Unable to upload audio mesh geometry");
		}
		if (ignoredMeshCount != 0)
		{
			UnityEngine.Debug.LogError("Failed to upload meshes, " + ignoredMeshCount + " static meshes ignored. Turn on \"File Enabled\" to process static meshes offline", base.gameObject);
		}
	}

	public bool ReadFile()
	{
		if (filePath == null || filePath.Length == 0)
		{
			UnityEngine.Debug.LogError("Invalid mesh file path");
			return false;
		}
		if (ONSPPropagation.Interface.AudioGeometryReadMeshFile(geometryHandle, filePath) != OSPSuccess)
		{
			UnityEngine.Debug.LogError("Error reading mesh file " + filePath);
			return false;
		}
		return true;
	}

	public bool WriteToObj()
	{
		IntPtr geometry = IntPtr.Zero;
		if (ONSPPropagation.Interface.CreateAudioGeometry(out geometry) != OSPSuccess)
		{
			throw new Exception("Failed to create temp geometry handle");
		}
		if (uploadMesh(geometry, base.gameObject, base.gameObject.transform.worldToLocalMatrix) != OSPSuccess)
		{
			UnityEngine.Debug.LogError("Error uploading mesh " + base.gameObject.name);
			return false;
		}
		if (ONSPPropagation.Interface.AudioGeometryWriteMeshFileObj(geometry, filePath + ".obj") != OSPSuccess)
		{
			UnityEngine.Debug.LogError("Error writing .obj file " + filePath + ".obj");
			return false;
		}
		if (ONSPPropagation.Interface.DestroyAudioGeometry(geometry) != OSPSuccess)
		{
			throw new Exception("Failed to destroy temp geometry handle");
		}
		return true;
	}
}
internal class ONSPPropagation
{
	public enum ovrAudioScalarType : uint
	{
		Int8,
		UInt8,
		Int16,
		UInt16,
		Int32,
		UInt32,
		Int64,
		UInt64,
		Float16,
		Float32,
		Float64
	}

	public class ClientType
	{
		public const uint OVRA_CLIENT_TYPE_NATIVE = 0u;

		public const uint OVRA_CLIENT_TYPE_WWISE_2016 = 1u;

		public const uint OVRA_CLIENT_TYPE_WWISE_2017_1 = 2u;

		public const uint OVRA_CLIENT_TYPE_WWISE_2017_2 = 3u;

		public const uint OVRA_CLIENT_TYPE_WWISE_2018_1 = 4u;

		public const uint OVRA_CLIENT_TYPE_FMOD = 5u;

		public const uint OVRA_CLIENT_TYPE_UNITY = 6u;

		public const uint OVRA_CLIENT_TYPE_UE4 = 7u;

		public const uint OVRA_CLIENT_TYPE_VST = 8u;

		public const uint OVRA_CLIENT_TYPE_AAX = 9u;

		public const uint OVRA_CLIENT_TYPE_TEST = 10u;

		public const uint OVRA_CLIENT_TYPE_OTHER = 11u;

		public const uint OVRA_CLIENT_TYPE_WWISE_UNKNOWN = 12u;

		public const uint OVRA_CLIENT_TYPE_WWISE_2019_1 = 13u;

		public const uint OVRA_CLIENT_TYPE_WWISE_2019_2 = 14u;
	}

	public interface PropagationInterface
	{
		int SetPropagationQuality(float quality);

		int SetPropagationThreadAffinity(ulong cpuMask);

		int CreateAudioGeometry(out IntPtr geometry);

		int DestroyAudioGeometry(IntPtr geometry);

		int AudioGeometryUploadMeshArrays(IntPtr geometry, float[] vertices, int vertexCount, int[] indices, int indexCount, MeshGroup[] groups, int groupCount);

		int AudioGeometrySetTransform(IntPtr geometry, float[] matrix4x4);

		int AudioGeometryGetTransform(IntPtr geometry, out float[] matrix4x4);

		int AudioGeometryWriteMeshFile(IntPtr geometry, string filePath);

		int AudioGeometryReadMeshFile(IntPtr geometry, string filePath);

		int AudioGeometryWriteMeshFileObj(IntPtr geometry, string filePath);

		int AudioMaterialGetFrequency(IntPtr material, MaterialProperty property, float frequency, out float value);

		int CreateAudioMaterial(out IntPtr material);

		int DestroyAudioMaterial(IntPtr material);

		int AudioMaterialSetFrequency(IntPtr material, MaterialProperty property, float frequency, float value);

		int AudioMaterialReset(IntPtr material, MaterialProperty property);
	}

	public class UnityNativeInterface : PropagationInterface
	{
		public const string strOSPS = "AudioPluginOculusSpatializer";

		private IntPtr context_ = IntPtr.Zero;

		private IntPtr context
		{
			get
			{
				if (context_ == IntPtr.Zero)
				{
					ovrAudio_GetPluginContext(out context_, 6u);
				}
				return context_;
			}
		}

		[DllImport("AudioPluginOculusSpatializer")]
		public static extern int ovrAudio_GetPluginContext(out IntPtr context, uint clientType);

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_SetPropagationQuality(IntPtr context, float quality);

		public int SetPropagationQuality(float quality)
		{
			return ovrAudio_SetPropagationQuality(context, quality);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_SetPropagationThreadAffinity(IntPtr context, ulong cpuMask);

		public int SetPropagationThreadAffinity(ulong cpuMask)
		{
			return ovrAudio_SetPropagationThreadAffinity(context, cpuMask);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_CreateAudioGeometry(IntPtr context, out IntPtr geometry);

		public int CreateAudioGeometry(out IntPtr geometry)
		{
			return ovrAudio_CreateAudioGeometry(context, out geometry);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_DestroyAudioGeometry(IntPtr geometry);

		public int DestroyAudioGeometry(IntPtr geometry)
		{
			return ovrAudio_DestroyAudioGeometry(geometry);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_AudioGeometryUploadMeshArrays(IntPtr geometry, float[] vertices, UIntPtr verticesBytesOffset, UIntPtr vertexCount, UIntPtr vertexStride, ovrAudioScalarType vertexType, int[] indices, UIntPtr indicesByteOffset, UIntPtr indexCount, ovrAudioScalarType indexType, MeshGroup[] groups, UIntPtr groupCount);

		public int AudioGeometryUploadMeshArrays(IntPtr geometry, float[] vertices, int vertexCount, int[] indices, int indexCount, MeshGroup[] groups, int groupCount)
		{
			return ovrAudio_AudioGeometryUploadMeshArrays(geometry, vertices, UIntPtr.Zero, (UIntPtr)(ulong)vertexCount, UIntPtr.Zero, ovrAudioScalarType.Float32, indices, UIntPtr.Zero, (UIntPtr)(ulong)indexCount, ovrAudioScalarType.UInt32, groups, (UIntPtr)(ulong)groupCount);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_AudioGeometrySetTransform(IntPtr geometry, float[] matrix4x4);

		public int AudioGeometrySetTransform(IntPtr geometry, float[] matrix4x4)
		{
			return ovrAudio_AudioGeometrySetTransform(geometry, matrix4x4);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_AudioGeometryGetTransform(IntPtr geometry, out float[] matrix4x4);

		public int AudioGeometryGetTransform(IntPtr geometry, out float[] matrix4x4)
		{
			return ovrAudio_AudioGeometryGetTransform(geometry, out matrix4x4);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_AudioGeometryWriteMeshFile(IntPtr geometry, string filePath);

		public int AudioGeometryWriteMeshFile(IntPtr geometry, string filePath)
		{
			return ovrAudio_AudioGeometryWriteMeshFile(geometry, filePath);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_AudioGeometryReadMeshFile(IntPtr geometry, string filePath);

		public int AudioGeometryReadMeshFile(IntPtr geometry, string filePath)
		{
			return ovrAudio_AudioGeometryReadMeshFile(geometry, filePath);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_AudioGeometryWriteMeshFileObj(IntPtr geometry, string filePath);

		public int AudioGeometryWriteMeshFileObj(IntPtr geometry, string filePath)
		{
			return ovrAudio_AudioGeometryWriteMeshFileObj(geometry, filePath);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_CreateAudioMaterial(IntPtr context, out IntPtr material);

		public int CreateAudioMaterial(out IntPtr material)
		{
			return ovrAudio_CreateAudioMaterial(context, out material);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_DestroyAudioMaterial(IntPtr material);

		public int DestroyAudioMaterial(IntPtr material)
		{
			return ovrAudio_DestroyAudioMaterial(material);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_AudioMaterialSetFrequency(IntPtr material, MaterialProperty property, float frequency, float value);

		public int AudioMaterialSetFrequency(IntPtr material, MaterialProperty property, float frequency, float value)
		{
			return ovrAudio_AudioMaterialSetFrequency(material, property, frequency, value);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_AudioMaterialGetFrequency(IntPtr material, MaterialProperty property, float frequency, out float value);

		public int AudioMaterialGetFrequency(IntPtr material, MaterialProperty property, float frequency, out float value)
		{
			return ovrAudio_AudioMaterialGetFrequency(material, property, frequency, out value);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_AudioMaterialReset(IntPtr material, MaterialProperty property);

		public int AudioMaterialReset(IntPtr material, MaterialProperty property)
		{
			return ovrAudio_AudioMaterialReset(material, property);
		}
	}

	public class WwisePluginInterface : PropagationInterface
	{
		public const string strOSPS = "OculusSpatializerWwise";

		private IntPtr context_ = IntPtr.Zero;

		private IntPtr context
		{
			get
			{
				if (context_ == IntPtr.Zero)
				{
					ovrAudio_GetPluginContext(out context_, 12u);
				}
				return context_;
			}
		}

		[DllImport("OculusSpatializerWwise")]
		public static extern int ovrAudio_GetPluginContext(out IntPtr context, uint clientType);

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_SetPropagationQuality(IntPtr context, float quality);

		public int SetPropagationQuality(float quality)
		{
			return ovrAudio_SetPropagationQuality(context, quality);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_SetPropagationThreadAffinity(IntPtr context, ulong cpuMask);

		public int SetPropagationThreadAffinity(ulong cpuMask)
		{
			return ovrAudio_SetPropagationThreadAffinity(context, cpuMask);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_CreateAudioGeometry(IntPtr context, out IntPtr geometry);

		public int CreateAudioGeometry(out IntPtr geometry)
		{
			return ovrAudio_CreateAudioGeometry(context, out geometry);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_DestroyAudioGeometry(IntPtr geometry);

		public int DestroyAudioGeometry(IntPtr geometry)
		{
			return ovrAudio_DestroyAudioGeometry(geometry);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_AudioGeometryUploadMeshArrays(IntPtr geometry, float[] vertices, UIntPtr verticesBytesOffset, UIntPtr vertexCount, UIntPtr vertexStride, ovrAudioScalarType vertexType, int[] indices, UIntPtr indicesByteOffset, UIntPtr indexCount, ovrAudioScalarType indexType, MeshGroup[] groups, UIntPtr groupCount);

		public int AudioGeometryUploadMeshArrays(IntPtr geometry, float[] vertices, int vertexCount, int[] indices, int indexCount, MeshGroup[] groups, int groupCount)
		{
			return ovrAudio_AudioGeometryUploadMeshArrays(geometry, vertices, UIntPtr.Zero, (UIntPtr)(ulong)vertexCount, UIntPtr.Zero, ovrAudioScalarType.Float32, indices, UIntPtr.Zero, (UIntPtr)(ulong)indexCount, ovrAudioScalarType.UInt32, groups, (UIntPtr)(ulong)groupCount);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_AudioGeometrySetTransform(IntPtr geometry, float[] matrix4x4);

		public int AudioGeometrySetTransform(IntPtr geometry, float[] matrix4x4)
		{
			return ovrAudio_AudioGeometrySetTransform(geometry, matrix4x4);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_AudioGeometryGetTransform(IntPtr geometry, out float[] matrix4x4);

		public int AudioGeometryGetTransform(IntPtr geometry, out float[] matrix4x4)
		{
			return ovrAudio_AudioGeometryGetTransform(geometry, out matrix4x4);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_AudioGeometryWriteMeshFile(IntPtr geometry, string filePath);

		public int AudioGeometryWriteMeshFile(IntPtr geometry, string filePath)
		{
			return ovrAudio_AudioGeometryWriteMeshFile(geometry, filePath);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_AudioGeometryReadMeshFile(IntPtr geometry, string filePath);

		public int AudioGeometryReadMeshFile(IntPtr geometry, string filePath)
		{
			return ovrAudio_AudioGeometryReadMeshFile(geometry, filePath);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_AudioGeometryWriteMeshFileObj(IntPtr geometry, string filePath);

		public int AudioGeometryWriteMeshFileObj(IntPtr geometry, string filePath)
		{
			return ovrAudio_AudioGeometryWriteMeshFileObj(geometry, filePath);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_CreateAudioMaterial(IntPtr context, out IntPtr material);

		public int CreateAudioMaterial(out IntPtr material)
		{
			return ovrAudio_CreateAudioMaterial(context, out material);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_DestroyAudioMaterial(IntPtr material);

		public int DestroyAudioMaterial(IntPtr material)
		{
			return ovrAudio_DestroyAudioMaterial(material);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_AudioMaterialSetFrequency(IntPtr material, MaterialProperty property, float frequency, float value);

		public int AudioMaterialSetFrequency(IntPtr material, MaterialProperty property, float frequency, float value)
		{
			return ovrAudio_AudioMaterialSetFrequency(material, property, frequency, value);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_AudioMaterialGetFrequency(IntPtr material, MaterialProperty property, float frequency, out float value);

		public int AudioMaterialGetFrequency(IntPtr material, MaterialProperty property, float frequency, out float value)
		{
			return ovrAudio_AudioMaterialGetFrequency(material, property, frequency, out value);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_AudioMaterialReset(IntPtr material, MaterialProperty property);

		public int AudioMaterialReset(IntPtr material, MaterialProperty property)
		{
			return ovrAudio_AudioMaterialReset(material, property);
		}
	}

	public class FMODPluginInterface : PropagationInterface
	{
		public const string strOSPS = "OculusSpatializerFMOD";

		private IntPtr context_ = IntPtr.Zero;

		private IntPtr context
		{
			get
			{
				if (context_ == IntPtr.Zero)
				{
					ovrAudio_GetPluginContext(out context_, 5u);
				}
				return context_;
			}
		}

		[DllImport("OculusSpatializerFMOD")]
		public static extern int ovrAudio_GetPluginContext(out IntPtr context, uint clientType);

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_SetPropagationQuality(IntPtr context, float quality);

		public int SetPropagationQuality(float quality)
		{
			return ovrAudio_SetPropagationQuality(context, quality);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_SetPropagationThreadAffinity(IntPtr context, ulong cpuMask);

		public int SetPropagationThreadAffinity(ulong cpuMask)
		{
			return ovrAudio_SetPropagationThreadAffinity(context, cpuMask);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_CreateAudioGeometry(IntPtr context, out IntPtr geometry);

		public int CreateAudioGeometry(out IntPtr geometry)
		{
			return ovrAudio_CreateAudioGeometry(context, out geometry);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_DestroyAudioGeometry(IntPtr geometry);

		public int DestroyAudioGeometry(IntPtr geometry)
		{
			return ovrAudio_DestroyAudioGeometry(geometry);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_AudioGeometryUploadMeshArrays(IntPtr geometry, float[] vertices, UIntPtr verticesBytesOffset, UIntPtr vertexCount, UIntPtr vertexStride, ovrAudioScalarType vertexType, int[] indices, UIntPtr indicesByteOffset, UIntPtr indexCount, ovrAudioScalarType indexType, MeshGroup[] groups, UIntPtr groupCount);

		public int AudioGeometryUploadMeshArrays(IntPtr geometry, float[] vertices, int vertexCount, int[] indices, int indexCount, MeshGroup[] groups, int groupCount)
		{
			return ovrAudio_AudioGeometryUploadMeshArrays(geometry, vertices, UIntPtr.Zero, (UIntPtr)(ulong)vertexCount, UIntPtr.Zero, ovrAudioScalarType.Float32, indices, UIntPtr.Zero, (UIntPtr)(ulong)indexCount, ovrAudioScalarType.UInt32, groups, (UIntPtr)(ulong)groupCount);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_AudioGeometrySetTransform(IntPtr geometry, float[] matrix4x4);

		public int AudioGeometrySetTransform(IntPtr geometry, float[] matrix4x4)
		{
			return ovrAudio_AudioGeometrySetTransform(geometry, matrix4x4);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_AudioGeometryGetTransform(IntPtr geometry, out float[] matrix4x4);

		public int AudioGeometryGetTransform(IntPtr geometry, out float[] matrix4x4)
		{
			return ovrAudio_AudioGeometryGetTransform(geometry, out matrix4x4);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_AudioGeometryWriteMeshFile(IntPtr geometry, string filePath);

		public int AudioGeometryWriteMeshFile(IntPtr geometry, string filePath)
		{
			return ovrAudio_AudioGeometryWriteMeshFile(geometry, filePath);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_AudioGeometryReadMeshFile(IntPtr geometry, string filePath);

		public int AudioGeometryReadMeshFile(IntPtr geometry, string filePath)
		{
			return ovrAudio_AudioGeometryReadMeshFile(geometry, filePath);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_AudioGeometryWriteMeshFileObj(IntPtr geometry, string filePath);

		public int AudioGeometryWriteMeshFileObj(IntPtr geometry, string filePath)
		{
			return ovrAudio_AudioGeometryWriteMeshFileObj(geometry, filePath);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_CreateAudioMaterial(IntPtr context, out IntPtr material);

		public int CreateAudioMaterial(out IntPtr material)
		{
			return ovrAudio_CreateAudioMaterial(context, out material);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_DestroyAudioMaterial(IntPtr material);

		public int DestroyAudioMaterial(IntPtr material)
		{
			return ovrAudio_DestroyAudioMaterial(material);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_AudioMaterialSetFrequency(IntPtr material, MaterialProperty property, float frequency, float value);

		public int AudioMaterialSetFrequency(IntPtr material, MaterialProperty property, float frequency, float value)
		{
			return ovrAudio_AudioMaterialSetFrequency(material, property, frequency, value);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_AudioMaterialGetFrequency(IntPtr material, MaterialProperty property, float frequency, out float value);

		public int AudioMaterialGetFrequency(IntPtr material, MaterialProperty property, float frequency, out float value)
		{
			return ovrAudio_AudioMaterialGetFrequency(material, property, frequency, out value);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_AudioMaterialReset(IntPtr material, MaterialProperty property);

		public int AudioMaterialReset(IntPtr material, MaterialProperty property)
		{
			return ovrAudio_AudioMaterialReset(material, property);
		}
	}

	private static PropagationInterface CachedInterface;

	public static PropagationInterface Interface
	{
		get
		{
			if (CachedInterface == null)
			{
				CachedInterface = FindInterface();
			}
			return CachedInterface;
		}
	}

	private static PropagationInterface FindInterface()
	{
		IntPtr context;
		try
		{
			WwisePluginInterface.ovrAudio_GetPluginContext(out context, 12u);
			UnityEngine.Debug.Log("Propagation initialized with Wwise Oculus Spatializer plugin");
			return new WwisePluginInterface();
		}
		catch (DllNotFoundException)
		{
		}
		try
		{
			FMODPluginInterface.ovrAudio_GetPluginContext(out context, 5u);
			UnityEngine.Debug.Log("Propagation initialized with FMOD Oculus Spatializer plugin");
			return new FMODPluginInterface();
		}
		catch (DllNotFoundException)
		{
		}
		UnityEngine.Debug.Log("Propagation initialized with Unity Oculus Spatializer plugin");
		return new UnityNativeInterface();
	}
}
public sealed class ONSPPropagationMaterial : MonoBehaviour
{
	public enum Preset
	{
		Custom,
		AcousticTile,
		Brick,
		BrickPainted,
		Carpet,
		CarpetHeavy,
		CarpetHeavyPadded,
		CeramicTile,
		Concrete,
		ConcreteRough,
		ConcreteBlock,
		ConcreteBlockPainted,
		Curtain,
		Foliage,
		Glass,
		GlassHeavy,
		Grass,
		Gravel,
		GypsumBoard,
		PlasterOnBrick,
		PlasterOnConcreteBlock,
		Soil,
		SoundProof,
		Snow,
		Steel,
		Water,
		WoodThin,
		WoodThick,
		WoodFloor,
		WoodOnConcrete
	}

	[Serializable]
	public sealed class Point
	{
		public float frequency;

		public float data;

		public Point(float frequency = 0f, float data = 0f)
		{
			this.frequency = frequency;
			this.data = data;
		}

		public static implicit operator Point(Vector2 v)
		{
			return new Point(v.x, v.y);
		}

		public static implicit operator Vector2(Point point)
		{
			return new Vector2(point.frequency, point.data);
		}
	}

	[Serializable]
	public sealed class Spectrum
	{
		public int selection = int.MaxValue;

		public List<Point> points = new List<Point>();

		public float this[float f]
		{
			get
			{
				if (points.Count > 0)
				{
					Point point = new Point(float.MinValue);
					Point point2 = new Point(float.MaxValue);
					foreach (Point point3 in points)
					{
						if (point3.frequency < f)
						{
							if (point3.frequency > point.frequency)
							{
								point = point3;
							}
						}
						else if (point3.frequency < point2.frequency)
						{
							point2 = point3;
						}
					}
					if (point.frequency == float.MinValue)
					{
						point.data = points.OrderBy((Point p) => p.frequency).First().data;
					}
					if (point2.frequency == float.MaxValue)
					{
						point2.data = points.OrderBy((Point p) => p.frequency).Last().data;
					}
					return point.data + (f - point.frequency) * (point2.data - point.data) / (point2.frequency - point.frequency);
				}
				return 0f;
			}
		}
	}

	public IntPtr materialHandle = IntPtr.Zero;

	[Tooltip("Absorption")]
	public Spectrum absorption = new Spectrum();

	[Tooltip("Transmission")]
	public Spectrum transmission = new Spectrum();

	[Tooltip("Scattering")]
	public Spectrum scattering = new Spectrum();

	[SerializeField]
	private Preset preset_;

	public Preset preset
	{
		get
		{
			return preset_;
		}
		set
		{
			SetPreset(value);
			preset_ = value;
		}
	}

	private void Start()
	{
		StartInternal();
	}

	public void StartInternal()
	{
		if (!(materialHandle != IntPtr.Zero))
		{
			if (ONSPPropagation.Interface.CreateAudioMaterial(out materialHandle) != ONSPPropagationGeometry.OSPSuccess)
			{
				throw new Exception("Unable to create internal audio material");
			}
			UploadMaterial();
		}
	}

	private void OnDestroy()
	{
		DestroyInternal();
	}

	public void DestroyInternal()
	{
		if (materialHandle != IntPtr.Zero)
		{
			ONSPPropagation.Interface.DestroyAudioMaterial(materialHandle);
			materialHandle = IntPtr.Zero;
		}
	}

	public void UploadMaterial()
	{
		if (materialHandle == IntPtr.Zero)
		{
			return;
		}
		ONSPPropagation.Interface.AudioMaterialReset(materialHandle, MaterialProperty.ABSORPTION);
		foreach (Point point in absorption.points)
		{
			ONSPPropagation.Interface.AudioMaterialSetFrequency(materialHandle, MaterialProperty.ABSORPTION, point.frequency, point.data);
		}
		ONSPPropagation.Interface.AudioMaterialReset(materialHandle, MaterialProperty.TRANSMISSION);
		foreach (Point point2 in transmission.points)
		{
			ONSPPropagation.Interface.AudioMaterialSetFrequency(materialHandle, MaterialProperty.TRANSMISSION, point2.frequency, point2.data);
		}
		ONSPPropagation.Interface.AudioMaterialReset(materialHandle, MaterialProperty.SCATTERING);
		foreach (Point point3 in scattering.points)
		{
			ONSPPropagation.Interface.AudioMaterialSetFrequency(materialHandle, MaterialProperty.SCATTERING, point3.frequency, point3.data);
		}
	}

	public void SetPreset(Preset preset)
	{
		ONSPPropagationMaterial material = this;
		switch (preset)
		{
		case Preset.AcousticTile:
			AcousticTile(ref material);
			break;
		case Preset.Brick:
			Brick(ref material);
			break;
		case Preset.BrickPainted:
			BrickPainted(ref material);
			break;
		case Preset.Carpet:
			Carpet(ref material);
			break;
		case Preset.CarpetHeavy:
			CarpetHeavy(ref material);
			break;
		case Preset.CarpetHeavyPadded:
			CarpetHeavyPadded(ref material);
			break;
		case Preset.CeramicTile:
			CeramicTile(ref material);
			break;
		case Preset.Concrete:
			Concrete(ref material);
			break;
		case Preset.ConcreteRough:
			ConcreteRough(ref material);
			break;
		case Preset.ConcreteBlock:
			ConcreteBlock(ref material);
			break;
		case Preset.ConcreteBlockPainted:
			ConcreteBlockPainted(ref material);
			break;
		case Preset.Curtain:
			Curtain(ref material);
			break;
		case Preset.Foliage:
			Foliage(ref material);
			break;
		case Preset.Glass:
			Glass(ref material);
			break;
		case Preset.GlassHeavy:
			GlassHeavy(ref material);
			break;
		case Preset.Grass:
			Grass(ref material);
			break;
		case Preset.Gravel:
			Gravel(ref material);
			break;
		case Preset.GypsumBoard:
			GypsumBoard(ref material);
			break;
		case Preset.PlasterOnBrick:
			PlasterOnBrick(ref material);
			break;
		case Preset.PlasterOnConcreteBlock:
			PlasterOnConcreteBlock(ref material);
			break;
		case Preset.Soil:
			Soil(ref material);
			break;
		case Preset.SoundProof:
			SoundProof(ref material);
			break;
		case Preset.Snow:
			Snow(ref material);
			break;
		case Preset.Steel:
			Steel(ref material);
			break;
		case Preset.Water:
			Water(ref material);
			break;
		case Preset.WoodThin:
			WoodThin(ref material);
			break;
		case Preset.WoodThick:
			WoodThick(ref material);
			break;
		case Preset.WoodFloor:
			WoodFloor(ref material);
			break;
		case Preset.WoodOnConcrete:
			WoodOnConcrete(ref material);
			break;
		case Preset.Custom:
			break;
		}
	}

	private static void AcousticTile(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.5f),
			new Point(250f, 0.7f),
			new Point(500f, 0.6f),
			new Point(1000f, 0.7f),
			new Point(2000f, 0.7f),
			new Point(4000f, 0.5f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.15f),
			new Point(500f, 0.2f),
			new Point(1000f, 0.2f),
			new Point(2000f, 0.25f),
			new Point(4000f, 0.3f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.05f),
			new Point(250f, 0.04f),
			new Point(500f, 0.03f),
			new Point(1000f, 0.02f),
			new Point(2000f, 0.005f),
			new Point(4000f, 0.002f)
		};
	}

	private static void Brick(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.02f),
			new Point(250f, 0.02f),
			new Point(500f, 0.03f),
			new Point(1000f, 0.04f),
			new Point(2000f, 0.05f),
			new Point(4000f, 0.07f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.2f),
			new Point(250f, 0.25f),
			new Point(500f, 0.3f),
			new Point(1000f, 0.35f),
			new Point(2000f, 0.4f),
			new Point(4000f, 0.45f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.025f),
			new Point(250f, 0.019f),
			new Point(500f, 0.01f),
			new Point(1000f, 0.0045f),
			new Point(2000f, 0.0018f),
			new Point(4000f, 0.00089f)
		};
	}

	private static void BrickPainted(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.01f),
			new Point(250f, 0.01f),
			new Point(500f, 0.02f),
			new Point(1000f, 0.02f),
			new Point(2000f, 0.02f),
			new Point(4000f, 0.03f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.15f),
			new Point(250f, 0.15f),
			new Point(500f, 0.2f),
			new Point(1000f, 0.2f),
			new Point(2000f, 0.2f),
			new Point(4000f, 0.25f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.025f),
			new Point(250f, 0.019f),
			new Point(500f, 0.01f),
			new Point(1000f, 0.0045f),
			new Point(2000f, 0.0018f),
			new Point(4000f, 0.00089f)
		};
	}

	private static void Carpet(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.01f),
			new Point(250f, 0.05f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.2f),
			new Point(2000f, 0.45f),
			new Point(4000f, 0.65f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.1f),
			new Point(500f, 0.15f),
			new Point(1000f, 0.2f),
			new Point(2000f, 0.3f),
			new Point(4000f, 0.45f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.004f),
			new Point(250f, 0.0079f),
			new Point(500f, 0.0056f),
			new Point(1000f, 0.0016f),
			new Point(2000f, 0.0014f),
			new Point(4000f, 0.0005f)
		};
	}

	private static void CarpetHeavy(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.02f),
			new Point(250f, 0.06f),
			new Point(500f, 0.14f),
			new Point(1000f, 0.37f),
			new Point(2000f, 0.48f),
			new Point(4000f, 0.63f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.15f),
			new Point(500f, 0.2f),
			new Point(1000f, 0.25f),
			new Point(2000f, 0.35f),
			new Point(4000f, 0.5f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.004f),
			new Point(250f, 0.0079f),
			new Point(500f, 0.0056f),
			new Point(1000f, 0.0016f),
			new Point(2000f, 0.0014f),
			new Point(4000f, 0.0005f)
		};
	}

	private static void CarpetHeavyPadded(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.08f),
			new Point(250f, 0.24f),
			new Point(500f, 0.57f),
			new Point(1000f, 0.69f),
			new Point(2000f, 0.71f),
			new Point(4000f, 0.73f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.15f),
			new Point(500f, 0.2f),
			new Point(1000f, 0.25f),
			new Point(2000f, 0.35f),
			new Point(4000f, 0.5f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.004f),
			new Point(250f, 0.0079f),
			new Point(500f, 0.0056f),
			new Point(1000f, 0.0016f),
			new Point(2000f, 0.0014f),
			new Point(4000f, 0.0005f)
		};
	}

	private static void CeramicTile(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.01f),
			new Point(250f, 0.01f),
			new Point(500f, 0.01f),
			new Point(1000f, 0.01f),
			new Point(2000f, 0.02f),
			new Point(4000f, 0.02f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.12f),
			new Point(500f, 0.14f),
			new Point(1000f, 0.16f),
			new Point(2000f, 0.18f),
			new Point(4000f, 0.2f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.004f),
			new Point(250f, 0.0079f),
			new Point(500f, 0.0056f),
			new Point(1000f, 0.0016f),
			new Point(2000f, 0.0014f),
			new Point(4000f, 0.0005f)
		};
	}

	private static void Concrete(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.01f),
			new Point(250f, 0.01f),
			new Point(500f, 0.02f),
			new Point(1000f, 0.02f),
			new Point(2000f, 0.02f),
			new Point(4000f, 0.02f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.11f),
			new Point(500f, 0.12f),
			new Point(1000f, 0.13f),
			new Point(2000f, 0.14f),
			new Point(4000f, 0.15f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.004f),
			new Point(250f, 0.0079f),
			new Point(500f, 0.0056f),
			new Point(1000f, 0.0016f),
			new Point(2000f, 0.0014f),
			new Point(4000f, 0.0005f)
		};
	}

	private static void ConcreteRough(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.01f),
			new Point(250f, 0.02f),
			new Point(500f, 0.04f),
			new Point(1000f, 0.06f),
			new Point(2000f, 0.08f),
			new Point(4000f, 0.1f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.12f),
			new Point(500f, 0.15f),
			new Point(1000f, 0.2f),
			new Point(2000f, 0.25f),
			new Point(4000f, 0.3f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.004f),
			new Point(250f, 0.0079f),
			new Point(500f, 0.0056f),
			new Point(1000f, 0.0016f),
			new Point(2000f, 0.0014f),
			new Point(4000f, 0.0005f)
		};
	}

	private static void ConcreteBlock(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.36f),
			new Point(250f, 0.44f),
			new Point(500f, 0.31f),
			new Point(1000f, 0.29f),
			new Point(2000f, 0.39f),
			new Point(4000f, 0.21f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.12f),
			new Point(500f, 0.15f),
			new Point(1000f, 0.2f),
			new Point(2000f, 0.3f),
			new Point(4000f, 0.4f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.02f),
			new Point(250f, 0.01f),
			new Point(500f, 0.0063f),
			new Point(1000f, 0.0035f),
			new Point(2000f, 0.00011f),
			new Point(4000f, 0.00063f)
		};
	}

	private static void ConcreteBlockPainted(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.05f),
			new Point(500f, 0.06f),
			new Point(1000f, 0.07f),
			new Point(2000f, 0.09f),
			new Point(4000f, 0.08f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.11f),
			new Point(500f, 0.13f),
			new Point(1000f, 0.15f),
			new Point(2000f, 0.16f),
			new Point(4000f, 0.2f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.02f),
			new Point(250f, 0.01f),
			new Point(500f, 0.0063f),
			new Point(1000f, 0.0035f),
			new Point(2000f, 0.00011f),
			new Point(4000f, 0.00063f)
		};
	}

	private static void Curtain(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.07f),
			new Point(250f, 0.31f),
			new Point(500f, 0.49f),
			new Point(1000f, 0.75f),
			new Point(2000f, 0.7f),
			new Point(4000f, 0.6f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.15f),
			new Point(500f, 0.2f),
			new Point(1000f, 0.3f),
			new Point(2000f, 0.4f),
			new Point(4000f, 0.5f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.42f),
			new Point(250f, 0.39f),
			new Point(500f, 0.21f),
			new Point(1000f, 0.14f),
			new Point(2000f, 0.079f),
			new Point(4000f, 0.045f)
		};
	}

	private static void Foliage(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.03f),
			new Point(250f, 0.06f),
			new Point(500f, 0.11f),
			new Point(1000f, 0.17f),
			new Point(2000f, 0.27f),
			new Point(4000f, 0.31f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.2f),
			new Point(250f, 0.3f),
			new Point(500f, 0.4f),
			new Point(1000f, 0.5f),
			new Point(2000f, 0.7f),
			new Point(4000f, 0.8f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.9f),
			new Point(250f, 0.9f),
			new Point(500f, 0.9f),
			new Point(1000f, 0.8f),
			new Point(2000f, 0.5f),
			new Point(4000f, 0.3f)
		};
	}

	private static void Glass(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.35f),
			new Point(250f, 0.25f),
			new Point(500f, 0.18f),
			new Point(1000f, 0.12f),
			new Point(2000f, 0.07f),
			new Point(4000f, 0.05f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.05f),
			new Point(250f, 0.05f),
			new Point(500f, 0.05f),
			new Point(1000f, 0.05f),
			new Point(2000f, 0.05f),
			new Point(4000f, 0.05f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.125f),
			new Point(250f, 0.089f),
			new Point(500f, 0.05f),
			new Point(1000f, 0.028f),
			new Point(2000f, 0.022f),
			new Point(4000f, 0.079f)
		};
	}

	private static void GlassHeavy(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.18f),
			new Point(250f, 0.06f),
			new Point(500f, 0.04f),
			new Point(1000f, 0.03f),
			new Point(2000f, 0.02f),
			new Point(4000f, 0.02f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.05f),
			new Point(250f, 0.05f),
			new Point(500f, 0.05f),
			new Point(1000f, 0.05f),
			new Point(2000f, 0.05f),
			new Point(4000f, 0.05f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.056f),
			new Point(250f, 0.039f),
			new Point(500f, 0.028f),
			new Point(1000f, 0.02f),
			new Point(2000f, 0.032f),
			new Point(4000f, 0.014f)
		};
	}

	private static void Grass(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.11f),
			new Point(250f, 0.26f),
			new Point(500f, 0.6f),
			new Point(1000f, 0.69f),
			new Point(2000f, 0.92f),
			new Point(4000f, 0.99f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.3f),
			new Point(250f, 0.3f),
			new Point(500f, 0.4f),
			new Point(1000f, 0.5f),
			new Point(2000f, 0.6f),
			new Point(4000f, 0.7f)
		};
		material.transmission.points = new List<Point>();
	}

	private static void Gravel(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.25f),
			new Point(250f, 0.6f),
			new Point(500f, 0.65f),
			new Point(1000f, 0.7f),
			new Point(2000f, 0.75f),
			new Point(4000f, 0.8f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.2f),
			new Point(250f, 0.3f),
			new Point(500f, 0.4f),
			new Point(1000f, 0.5f),
			new Point(2000f, 0.6f),
			new Point(4000f, 0.7f)
		};
		material.transmission.points = new List<Point>();
	}

	private static void GypsumBoard(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.29f),
			new Point(250f, 0.1f),
			new Point(500f, 0.05f),
			new Point(1000f, 0.04f),
			new Point(2000f, 0.07f),
			new Point(4000f, 0.09f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.11f),
			new Point(500f, 0.12f),
			new Point(1000f, 0.13f),
			new Point(2000f, 0.14f),
			new Point(4000f, 0.15f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.035f),
			new Point(250f, 0.0125f),
			new Point(500f, 0.0056f),
			new Point(1000f, 0.0025f),
			new Point(2000f, 0.0013f),
			new Point(4000f, 0.0032f)
		};
	}

	private static void PlasterOnBrick(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.01f),
			new Point(250f, 0.02f),
			new Point(500f, 0.02f),
			new Point(1000f, 0.03f),
			new Point(2000f, 0.04f),
			new Point(4000f, 0.05f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.2f),
			new Point(250f, 0.25f),
			new Point(500f, 0.3f),
			new Point(1000f, 0.35f),
			new Point(2000f, 0.4f),
			new Point(4000f, 0.45f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.025f),
			new Point(250f, 0.019f),
			new Point(500f, 0.01f),
			new Point(1000f, 0.0045f),
			new Point(2000f, 0.0018f),
			new Point(4000f, 0.00089f)
		};
	}

	private static void PlasterOnConcreteBlock(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.12f),
			new Point(250f, 0.09f),
			new Point(500f, 0.07f),
			new Point(1000f, 0.05f),
			new Point(2000f, 0.05f),
			new Point(4000f, 0.04f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.2f),
			new Point(250f, 0.25f),
			new Point(500f, 0.3f),
			new Point(1000f, 0.35f),
			new Point(2000f, 0.4f),
			new Point(4000f, 0.45f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.02f),
			new Point(250f, 0.01f),
			new Point(500f, 0.0063f),
			new Point(1000f, 0.0035f),
			new Point(2000f, 0.00011f),
			new Point(4000f, 0.00063f)
		};
	}

	private static void Soil(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.15f),
			new Point(250f, 0.25f),
			new Point(500f, 0.4f),
			new Point(1000f, 0.55f),
			new Point(2000f, 0.6f),
			new Point(4000f, 0.6f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.2f),
			new Point(500f, 0.25f),
			new Point(1000f, 0.4f),
			new Point(2000f, 0.55f),
			new Point(4000f, 0.7f)
		};
		material.transmission.points = new List<Point>();
	}

	private static void SoundProof(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(1000f, 1f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(1000f)
		};
		material.transmission.points = new List<Point>();
	}

	private static void Snow(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.45f),
			new Point(250f, 0.75f),
			new Point(500f, 0.9f),
			new Point(1000f, 0.95f),
			new Point(2000f, 0.95f),
			new Point(4000f, 0.95f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.2f),
			new Point(250f, 0.3f),
			new Point(500f, 0.4f),
			new Point(1000f, 0.5f),
			new Point(2000f, 0.6f),
			new Point(4000f, 0.75f)
		};
		material.transmission.points = new List<Point>();
	}

	private static void Steel(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.05f),
			new Point(250f, 0.1f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.1f),
			new Point(2000f, 0.07f),
			new Point(4000f, 0.02f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.1f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.1f),
			new Point(2000f, 0.1f),
			new Point(4000f, 0.1f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.25f),
			new Point(250f, 0.2f),
			new Point(500f, 0.17f),
			new Point(1000f, 0.089f),
			new Point(2000f, 0.089f),
			new Point(4000f, 0.0056f)
		};
	}

	private static void Water(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.01f),
			new Point(250f, 0.01f),
			new Point(500f, 0.01f),
			new Point(1000f, 0.02f),
			new Point(2000f, 0.02f),
			new Point(4000f, 0.03f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.1f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.07f),
			new Point(2000f, 0.05f),
			new Point(4000f, 0.05f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.03f),
			new Point(250f, 0.03f),
			new Point(500f, 0.03f),
			new Point(1000f, 0.02f),
			new Point(2000f, 0.015f),
			new Point(4000f, 0.01f)
		};
	}

	private static void WoodThin(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.42f),
			new Point(250f, 0.21f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.08f),
			new Point(2000f, 0.06f),
			new Point(4000f, 0.06f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.1f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.1f),
			new Point(2000f, 0.1f),
			new Point(4000f, 0.15f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.2f),
			new Point(250f, 0.125f),
			new Point(500f, 0.079f),
			new Point(1000f, 0.1f),
			new Point(2000f, 0.089f),
			new Point(4000f, 0.05f)
		};
	}

	private static void WoodThick(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.19f),
			new Point(250f, 0.14f),
			new Point(500f, 0.09f),
			new Point(1000f, 0.06f),
			new Point(2000f, 0.06f),
			new Point(4000f, 0.05f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.1f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.1f),
			new Point(2000f, 0.1f),
			new Point(4000f, 0.15f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.035f),
			new Point(250f, 0.028f),
			new Point(500f, 0.028f),
			new Point(1000f, 0.028f),
			new Point(2000f, 0.011f),
			new Point(4000f, 0.0071f)
		};
	}

	private static void WoodFloor(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.15f),
			new Point(250f, 0.11f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.07f),
			new Point(2000f, 0.06f),
			new Point(4000f, 0.07f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.1f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.1f),
			new Point(2000f, 0.1f),
			new Point(4000f, 0.15f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.071f),
			new Point(250f, 0.025f),
			new Point(500f, 0.0158f),
			new Point(1000f, 0.0056f),
			new Point(2000f, 0.0035f),
			new Point(4000f, 0.0016f)
		};
	}

	private static void WoodOnConcrete(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.04f),
			new Point(250f, 0.04f),
			new Point(500f, 0.07f),
			new Point(1000f, 0.06f),
			new Point(2000f, 0.06f),
			new Point(4000f, 0.07f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.1f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.1f),
			new Point(2000f, 0.1f),
			new Point(4000f, 0.15f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.004f),
			new Point(250f, 0.0079f),
			new Point(500f, 0.0056f),
			new Point(1000f, 0.0016f),
			new Point(2000f, 0.0014f),
			new Point(4000f, 0.0005f)
		};
	}
}
public class ONSPPropagationSettings : MonoBehaviour
{
	public float quality = 100f;

	private void Update()
	{
		ONSPPropagation.Interface.SetPropagationQuality(quality / 100f);
	}
}
public sealed class ONSPSettings : ScriptableObject
{
	[SerializeField]
	public int voiceLimit = 64;

	private static ONSPSettings instance;

	public static ONSPSettings Instance
	{
		get
		{
			if (instance == null)
			{
				instance = Resources.Load<ONSPSettings>("ONSPSettings");
				if (instance == null)
				{
					instance = ScriptableObject.CreateInstance<ONSPSettings>();
				}
			}
			return instance;
		}
	}
}
public class ONSPVersion : MonoBehaviour
{
	public const string strONSPS = "AudioPluginOculusSpatializer";

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern void ONSP_GetVersion(ref int Major, ref int Minor, ref int Patch);

	private void Awake()
	{
		int Major = 0;
		int Minor = 0;
		int Patch = 0;
		ONSP_GetVersion(ref Major, ref Minor, ref Patch);
		UnityEngine.Debug.Log($"ONSP Version: {Major:F0}.{Minor:F0}.{Patch:F0}");
	}

	private void Start()
	{
	}

	private void Update()
	{
	}
}
public class Pvr_Controller : MonoBehaviour
{
	public enum UserHandNess
	{
		Right,
		Left
	}

	public enum GazeType
	{
		Never,
		DuringMotion,
		Always
	}

	public enum ControllerAxis
	{
		Controller,
		Wrist,
		Elbow,
		Shoulder
	}

	public GameObject controller0;

	public GameObject controller1;

	private static UserHandNess handness;

	public ControllerAxis Axis;

	public GazeType Gazetype;

	[Range(0f, 0.2f)]
	public float ElbowHeight;

	[Range(0f, 0.2f)]
	public float ElbowDepth;

	[Range(0f, 30f)]
	public float PointerTiltAngle = 15f;

	private float mouseX;

	private float mouseY;

	private float mouseZ;

	private Vector3[] inputDirection = new Vector3[2];

	public static Vector3 pointerPosition { get; set; }

	public static Quaternion pointerRotation { get; set; }

	public static Vector3 elbowPosition { get; set; }

	public static Quaternion elbowRotation { get; set; }

	public static Vector3 wristPosition { get; set; }

	public static Quaternion wristRotation { get; set; }

	public static Vector3 shoulderPosition { get; set; }

	public static Quaternion shoulderRotation { get; set; }

	private void Awake()
	{
		Pvr_ControllerManager.PvrServiceStartSuccessEvent += ServiceStartSuccess;
		Pvr_ControllerManager.SetControllerAbilityEvent += CheckControllerState;
		Pvr_ControllerManager.ChangeMainControllerCallBackEvent += MainControllerChanged;
		Pvr_ControllerManager.ChangeHandNessCallBackEvent += HandnessChanged;
	}

	private void Start()
	{
		handness = Controller.UPvr_GetHandNess();
		if (handness == (UserHandNess)(-1))
		{
			handness = UserHandNess.Right;
		}
	}

	private void OnDestroy()
	{
		Pvr_ControllerManager.PvrServiceStartSuccessEvent -= ServiceStartSuccess;
		Pvr_ControllerManager.SetControllerAbilityEvent -= CheckControllerState;
		Pvr_ControllerManager.ChangeMainControllerCallBackEvent -= MainControllerChanged;
		Pvr_ControllerManager.ChangeHandNessCallBackEvent -= HandnessChanged;
	}

	private void MainControllerChanged(string index)
	{
		RefreshHandness();
	}

	private void HandnessChanged(string index)
	{
		RefreshHandness();
	}

	private void ServiceStartSuccess()
	{
		RefreshHandness();
	}

	private void RefreshHandness()
	{
		handness = Controller.UPvr_GetHandNess();
		if (Controller.UPvr_GetMainHandNess() == 1)
		{
			ChangeHandNess();
		}
	}

	private void OnApplicationPause(bool pause)
	{
		if (!pause)
		{
			if (controller0 != null)
			{
				controller0.transform.localScale = Vector3.zero;
			}
			if (controller1 != null)
			{
				controller1.transform.localScale = Vector3.zero;
			}
		}
		Invoke("ShowController", 0.1f * Time.timeScale);
	}

	private void ShowController()
	{
		if (controller0 != null)
		{
			controller0.transform.localScale = Vector3.one;
		}
		if (controller1 != null)
		{
			controller1.transform.localScale = Vector3.one;
		}
	}

	private void CheckControllerState(string data)
	{
		bool num = Convert.ToBoolean(Convert.ToInt16(data.Substring(4, 1)));
		short num2 = Convert.ToInt16(data.Substring(0, 1));
		if (num && num2 == 1)
		{
			RefreshHandness();
		}
	}

	private void Update()
	{
		if (Pvr_UnitySDKManager.SDK.ControllerOnlyrot)
		{
			DoUpdateControler0();
			DoUpdateControler1();
			UpdateControlloerRay();
			return;
		}
		if (Controller.UPvr_GetPreferenceDevice() == 1)
		{
			DoUpdateControler0();
			DoUpdateControler1();
			UpdateControlloerRay();
			return;
		}
		if (controller0 != null)
		{
			controller0.transform.localRotation = Controller.UPvr_GetControllerQUA(0);
			controller0.transform.localPosition = Controller.UPvr_GetControllerPOS(0);
			UpdateControlloerRay(update0: true, update1: false);
		}
		if (controller1 != null)
		{
			controller1.transform.localRotation = Controller.UPvr_GetControllerQUA(1);
			controller1.transform.localPosition = Controller.UPvr_GetControllerPOS(1);
			UpdateControlloerRay(update0: false);
		}
	}

	public static void ChangeHandNess()
	{
		handness = ((handness == UserHandNess.Right) ? UserHandNess.Left : UserHandNess.Right);
	}

	private void DoUpdateControler0()
	{
		SetArmParaToSo((int)handness, (int)Gazetype, ElbowHeight, ElbowDepth, PointerTiltAngle);
		CalcArmModelfromSo(0);
		UpdateControllerDataSO(0);
	}

	private void DoUpdateControler1()
	{
		int hand = ((handness != UserHandNess.Left) ? 1 : 0);
		SetArmParaToSo(hand, (int)Gazetype, ElbowHeight, ElbowDepth, PointerTiltAngle);
		CalcArmModelfromSo(1);
		UpdateControllerDataSO(1);
	}

	private void UpdateControlloerRay(bool update0 = true, bool update1 = true)
	{
		_ = Pvr_ControllerManager.Instance.LengthAdaptiveRay;
	}

	private Quaternion UpdateSimulatedFrameParams()
	{
		if (Input.GetKey(KeyCode.LeftShift))
		{
			mouseX += Input.GetAxis("Mouse X") * 5f;
			if (mouseX <= -180f)
			{
				mouseX += 360f;
			}
			else if (mouseX > 180f)
			{
				mouseX -= 360f;
			}
			mouseY -= Input.GetAxis("Mouse Y") * 2.4f;
			mouseY = Mathf.Clamp(mouseY, -80f, 80f);
		}
		else if (Input.GetKey(KeyCode.RightShift))
		{
			mouseZ += Input.GetAxis("Mouse X") * 5f;
			mouseZ = Mathf.Clamp(mouseZ, -80f, 80f);
		}
		return Quaternion.Euler(mouseY, mouseX, mouseZ);
	}

	private void SetArmParaToSo(int hand, int gazeType, float elbowHeight, float elbowDepth, float pointerTiltAngle)
	{
		Controller.UPvr_SetArmModelParameters(hand, gazeType, elbowHeight, elbowDepth, pointerTiltAngle);
	}

	private void CalcArmModelfromSo(int hand)
	{
		float[] array = new float[4];
		float[] array2 = new float[4];
		float[] array3 = new float[3];
		Quaternion quaternion = default(Quaternion);
		quaternion = Controller.UPvr_GetControllerQUA(hand);
		Vector3 vector = Controller.UPvr_GetAngularVelocity(hand);
		array2[0] = quaternion.x;
		array2[1] = quaternion.y;
		array2[2] = quaternion.z;
		array2[3] = quaternion.w;
		array3[0] = vector.x;
		array3[1] = vector.y;
		array3[2] = vector.z;
		if (Gazetype == GazeType.DuringMotion)
		{
			Vector3 b = Pvr_UnitySDKSensor.Instance.HeadPose.Orientation * Vector3.forward;
			b.y = 0f;
			b.Normalize();
			float t = Mathf.Clamp((vector.magnitude - 0.2f) / 45f, 0f, 0.1f);
			inputDirection[hand] = Vector3.Slerp(inputDirection[hand], b, t);
			if (Controller.UPvr_GetKeyLongPressed(hand, Pvr_KeyCode.HOME))
			{
				inputDirection[hand] = default(Vector3);
			}
			Quaternion quaternion2 = Quaternion.FromToRotation(Vector3.forward, inputDirection[hand]);
			array[0] = quaternion2.x;
			array[1] = quaternion2.y;
			array[2] = quaternion2.z;
			array[3] = quaternion2.w;
		}
		else
		{
			array[0] = Pvr_UnitySDKSensor.Instance.HeadPose.Orientation.x;
			array[1] = Pvr_UnitySDKSensor.Instance.HeadPose.Orientation.y;
			array[2] = Pvr_UnitySDKSensor.Instance.HeadPose.Orientation.z;
			array[3] = Pvr_UnitySDKSensor.Instance.HeadPose.Orientation.w;
		}
		Controller.UPvr_CalcArmModelParameters(array, array2, array3);
	}

	public void UpdateControllerDataSO(int hand)
	{
		float[] array = new float[4];
		float[] array2 = new float[3];
		Vector3 vector;
		Quaternion localRotation;
		switch (Axis)
		{
		case ControllerAxis.Controller:
			Controller.UPvr_GetPointerPose(array, array2);
			pointerPosition = new Vector3(array2[0], array2[1], array2[2]);
			pointerRotation = new Quaternion(array[0], array[1], array[2], array[3]);
			vector = pointerPosition;
			localRotation = pointerRotation;
			break;
		case ControllerAxis.Wrist:
			Controller.UPvr_GetWristPose(array, array2);
			wristPosition = new Vector3(array2[0], array2[1], array2[2]);
			wristRotation = new Quaternion(array[0], array[1], array[2], array[3]);
			vector = wristPosition;
			localRotation = wristRotation;
			break;
		case ControllerAxis.Elbow:
			Controller.UPvr_GetElbowPose(array, array2);
			elbowPosition = new Vector3(array2[0], array2[1], array2[2]);
			elbowRotation = new Quaternion(array[0], array[1], array[2], array[3]);
			vector = elbowPosition;
			localRotation = elbowRotation;
			break;
		case ControllerAxis.Shoulder:
			Controller.UPvr_GetShoulderPose(array, array2);
			shoulderPosition = new Vector3(array2[0], array2[1], array2[2]);
			shoulderRotation = new Quaternion(array[0], array[1], array[2], array[3]);
			vector = shoulderPosition;
			localRotation = shoulderRotation;
			break;
		default:
			throw new Exception("Invalid FromJoint.");
		}
		if (hand == 0)
		{
			if (controller0 != null)
			{
				if (!Pvr_UnitySDKManager.SDK.HmdOnlyrot)
				{
					controller0.transform.localPosition = vector + Pvr_UnitySDKSensor.Instance.HeadPose.Position;
				}
				else if (Pvr_UnitySDKManager.SDK.TrackingOrigin == TrackingOrigin.FloorLevel)
				{
					controller0.transform.localPosition = vector + Pvr_UnitySDKSensor.Instance.HeadPose.Position;
				}
				else
				{
					controller0.transform.localPosition = vector;
				}
				controller0.transform.localRotation = localRotation;
			}
		}
		else if (controller1 != null)
		{
			if (!Pvr_UnitySDKManager.SDK.HmdOnlyrot)
			{
				controller1.transform.localPosition = vector + Pvr_UnitySDKSensor.Instance.HeadPose.Position;
			}
			else if (Pvr_UnitySDKManager.SDK.TrackingOrigin == TrackingOrigin.FloorLevel)
			{
				controller1.transform.localPosition = vector + Pvr_UnitySDKSensor.Instance.HeadPose.Position;
			}
			else
			{
				controller1.transform.localPosition = vector;
			}
			controller1.transform.localRotation = localRotation;
		}
	}
}
public class Pvr_ControllerDemo : MonoBehaviour
{
	public GameObject HeadSetController;

	public GameObject controller0;

	public GameObject controller1;

	public GameObject cube;

	private Ray ray;

	private GameObject currentController;

	private Transform lastHit;

	private Transform currentHit;

	[SerializeField]
	private Material normat;

	[SerializeField]
	private Material gazemat;

	[SerializeField]
	private Material clickmat;

	private bool noClick;

	private GameObject referenceObj;

	public float rayDefaultLength = 4f;

	private bool isHasController;

	private bool headcontrolmode;

	private RaycastHit hit;

	private GameObject rayLine;

	private GameObject dot;

	private Transform dragObj;

	private float disX;

	private float disY;

	private float disZ;

	private void Start()
	{
		ray = default(Ray);
		hit = default(RaycastHit);
		if (Pvr_UnitySDKManager.SDK.isHasController)
		{
			Pvr_ControllerManager.PvrServiceStartSuccessEvent += ServiceStartSuccess;
			Pvr_ControllerManager.SetControllerStateChangedEvent += ControllerStateListener;
			Pvr_ControllerManager.ControllerStatusChangeEvent += CheckControllerStateForGoblin;
			isHasController = true;
		}
		referenceObj = new GameObject("ReferenceObj");
	}

	private void OnDestroy()
	{
		if (isHasController)
		{
			Pvr_ControllerManager.PvrServiceStartSuccessEvent -= ServiceStartSuccess;
			Pvr_ControllerManager.SetControllerStateChangedEvent -= ControllerStateListener;
			Pvr_ControllerManager.ControllerStatusChangeEvent -= CheckControllerStateForGoblin;
		}
	}

	private void Update()
	{
		if (HeadSetController.activeSelf)
		{
			HeadSetController.transform.parent.localRotation = Quaternion.Euler(Pvr_UnitySDKSensor.Instance.HeadPose.Orientation.eulerAngles.x, Pvr_UnitySDKSensor.Instance.HeadPose.Orientation.eulerAngles.y, 0f);
			HeadSetController.transform.parent.localPosition = Pvr_UnitySDKSensor.Instance.HeadPose.Position;
			ray.direction = HeadSetController.transform.position - HeadSetController.transform.parent.parent.Find("Head").position;
			ray.origin = HeadSetController.transform.parent.parent.Find("Head").position;
			if (Physics.Raycast(ray, out hit))
			{
				if (HeadSetController.name == "SightPointer")
				{
					HeadSetController.transform.localScale = new Vector3(0.09f, 0.09f, 0.09f);
				}
				currentHit = hit.transform;
				if (currentHit != null && lastHit != null && currentHit != lastHit && (bool)lastHit.GetComponent<Pvr_UIGraphicRaycaster>() && lastHit.transform.gameObject.activeInHierarchy && lastHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled)
				{
					lastHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled = false;
				}
				if (currentHit != null && lastHit != null && currentHit == lastHit && (bool)currentHit.GetComponent<Pvr_UIGraphicRaycaster>() && !currentHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled)
				{
					currentHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled = true;
				}
				if (1 << hit.transform.gameObject.layer == LayerMask.GetMask("Water") && !noClick)
				{
					hit.transform.GetComponent<Renderer>().material = gazemat;
				}
				lastHit = hit.transform;
				if (Pvr_ControllerManager.Instance.LengthAdaptiveRay)
				{
					HeadSetController.transform.position = hit.point;
					HeadSetController.transform.position -= (hit.point - HeadSetController.transform.parent.parent.Find("Head").position).normalized * 0.02f;
					float num = 0.008f * hit.distance / 4f;
					Mathf.Clamp(num, 0.002f, 0.008f);
					HeadSetController.transform.localScale = new Vector3(num, num, 1f);
				}
			}
			else
			{
				if (HeadSetController.name == "SightPointer")
				{
					HeadSetController.transform.localScale = Vector3.zero;
				}
				if (lastHit != null && 1 << lastHit.transform.gameObject.layer == LayerMask.GetMask("Water"))
				{
					lastHit.transform.GetComponent<Renderer>().material = normat;
				}
				currentHit = null;
				noClick = false;
				if (Pvr_ControllerManager.Instance.LengthAdaptiveRay)
				{
					HeadSetController.transform.position = HeadSetController.transform.parent.parent.Find("Head").position + ray.direction.normalized * (0.5f + rayDefaultLength);
					HeadSetController.transform.localScale = new Vector3(0.008f, 0.008f, 1f);
				}
			}
			if ((Input.GetKeyDown(KeyCode.JoystickButton0) || Input.GetMouseButtonDown(0)) && lastHit != null && 1 << lastHit.transform.gameObject.layer == LayerMask.GetMask("Water") && currentHit != null)
			{
				lastHit.transform.GetComponent<Renderer>().material = clickmat;
				noClick = true;
			}
			return;
		}
		if (currentController != null)
		{
			ray.direction = currentController.transform.forward - currentController.transform.up * 0.25f;
			ray.origin = currentController.transform.Find("start").position;
			if (Physics.Raycast(ray, out hit))
			{
				currentHit = hit.transform;
				if (currentHit != null && lastHit != null && currentHit != lastHit && (bool)lastHit.GetComponent<Pvr_UIGraphicRaycaster>() && lastHit.transform.gameObject.activeInHierarchy && lastHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled)
				{
					lastHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled = false;
				}
				if (currentHit != null && lastHit != null && currentHit == lastHit && (bool)currentHit.GetComponent<Pvr_UIGraphicRaycaster>() && !currentHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled)
				{
					currentHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled = true;
				}
				if (1 << hit.transform.gameObject.layer == LayerMask.GetMask("Water"))
				{
					if (!noClick)
					{
						hit.transform.GetComponent<Renderer>().material = gazemat;
					}
					if (Controller.UPvr_GetKeyDown(0, Pvr_KeyCode.TOUCHPAD) || Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.TOUCHPAD) || Input.GetMouseButtonDown(0))
					{
						referenceObj.transform.position = hit.point;
						disX = hit.transform.position.x - referenceObj.transform.position.x;
						disY = hit.transform.position.y - referenceObj.transform.position.y;
						dragObj = hit.transform;
					}
					if ((Controller.UPvr_GetKey(0, Pvr_KeyCode.TOUCHPAD) || Controller.UPvr_GetKey(1, Pvr_KeyCode.TOUCHPAD) || Input.GetMouseButton(0)) && hit.transform == dragObj.transform)
					{
						referenceObj.transform.position = new Vector3(hit.point.x, hit.point.y, hit.transform.position.z);
						dragObj.position = new Vector3(referenceObj.transform.position.x + disX, referenceObj.transform.position.y + disY, hit.transform.position.z);
					}
				}
				lastHit = hit.transform;
				currentController.transform.Find("dot").position = hit.point;
				if (Pvr_ControllerManager.Instance.LengthAdaptiveRay)
				{
					float num2 = 0.178f * currentController.transform.Find("dot").localPosition.z / 3.3f;
					Mathf.Clamp(num2, 0.05f, 0.178f);
					currentController.transform.Find("dot").localScale = new Vector3(num2, num2, 1f);
				}
			}
			else
			{
				if (lastHit != null && 1 << lastHit.transform.gameObject.layer == LayerMask.GetMask("Water"))
				{
					lastHit.transform.GetComponent<Renderer>().material = normat;
				}
				currentHit = null;
				noClick = false;
				if (Pvr_ControllerManager.Instance.LengthAdaptiveRay)
				{
					currentController.transform.Find("dot").localScale = new Vector3(0.178f, 0.178f, 1f);
				}
			}
		}
		if ((Controller.UPvr_GetKeyDown(0, Pvr_KeyCode.TOUCHPAD) || Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.TOUCHPAD) || Input.GetMouseButtonDown(0)) && lastHit != null && 1 << lastHit.transform.gameObject.layer == LayerMask.GetMask("Water") && currentHit != null)
		{
			lastHit.transform.GetComponent<Renderer>().material = clickmat;
			noClick = true;
		}
	}

	private void ServiceStartSuccess()
	{
		if (Controller.UPvr_GetControllerState(0) == ControllerState.Connected || Controller.UPvr_GetControllerState(1) == ControllerState.Connected)
		{
			HeadSetController.SetActive(value: false);
		}
		else
		{
			HeadSetController.SetActive(value: true);
		}
		if (Controller.UPvr_GetMainHandNess() == 0)
		{
			currentController = controller0;
		}
		if (Controller.UPvr_GetMainHandNess() == 1)
		{
			currentController = controller1;
		}
	}

	private void ControllerStateListener(string data)
	{
		if (Controller.UPvr_GetControllerState(0) == ControllerState.Connected || Controller.UPvr_GetControllerState(1) == ControllerState.Connected)
		{
			HeadSetController.SetActive(value: false);
		}
		else
		{
			HeadSetController.SetActive(value: true);
		}
		if (Controller.UPvr_GetMainHandNess() == 0)
		{
			currentController = controller0;
		}
		if (Controller.UPvr_GetMainHandNess() == 1)
		{
			currentController = controller1;
		}
	}

	private void CheckControllerStateForGoblin(string state)
	{
		HeadSetController.SetActive(Convert.ToInt16(state) != 1);
	}

	public void SwitchControlMode()
	{
	}
}
public class Pvr_ControllerEventsExamples : MonoBehaviour
{
	private void Start()
	{
		if (!(GetComponent<Pvr_UIPointer>() == null))
		{
			GetComponent<Pvr_UIPointer>().UIPointerElementEnter += UIPointerElementEnter;
			GetComponent<Pvr_UIPointer>().UIPointerElementExit += UIPointerElementExit;
			GetComponent<Pvr_UIPointer>().UIPointerElementClick += UIPointerElementClick;
			GetComponent<Pvr_UIPointer>().UIPointerElementDragStart += UIPointerElementDragStart;
			GetComponent<Pvr_UIPointer>().UIPointerElementDragEnd += UIPointerElementDragEnd;
		}
	}

	private void UIPointerElementEnter(object sender, UIPointerEventArgs e)
	{
		PLOG.I("UI Pointer entered" + e.currentTarget.name);
	}

	private void UIPointerElementExit(object sender, UIPointerEventArgs e)
	{
		PLOG.I("UI Pointer exited" + e.currentTarget.name);
	}

	private void UIPointerElementClick(object sender, UIPointerEventArgs e)
	{
		PLOG.I("UI Pointer clicked" + e.currentTarget.name);
	}

	private void UIPointerElementDragStart(object sender, UIPointerEventArgs e)
	{
		PLOG.I("UI Pointer started dragging" + e.currentTarget.name);
	}

	private void UIPointerElementDragEnd(object sender, UIPointerEventArgs e)
	{
		PLOG.I("UI Pointer stopped dragging" + e.currentTarget.name);
	}
}
public class Pvr_ControllerInit : MonoBehaviour
{
	private ControllerVariety Variety;

	private bool isCustomModel;

	[SerializeField]
	private GameObject goblin;

	[SerializeField]
	private GameObject g2;

	[SerializeField]
	private GameObject neo2L;

	[SerializeField]
	private GameObject neo2R;

	[SerializeField]
	private GameObject neo3L;

	[SerializeField]
	private GameObject neo3R;

	[SerializeField]
	private Material standardMat;

	[SerializeField]
	private Material unlitMat;

	private int controllerType = -1;

	[HideInInspector]
	public bool loadModelSuccess;

	private int systemOrUnity;

	private JsonData curControllerData;

	private string modelName = "";

	private string texFormat = "";

	private string prePath = "";

	private string modelFilePath = "/system/media/PvrRes/controller/";

	private const string goblinTexbasePath = "Controller/controller1/controller1";

	private const string g2TexbasePath = "Controller/controller3/controller3";

	private const string neo2TexbasePath = "Controller/controller4/controller4";

	private const string neo3TexbasePath = "Controller/controller5/controller5";

	private void Awake()
	{
		Render.UPvr_GetIntConfig(15, ref systemOrUnity);
		Variety = base.transform.GetComponentInParent<Pvr_ControllerModuleInit>().Variety;
		isCustomModel = base.transform.GetComponentInParent<Pvr_ControllerModuleInit>().IsCustomModel;
		if (!isCustomModel)
		{
			Pvr_ControllerManager.PvrServiceStartSuccessEvent += ServiceStartSuccess;
			Pvr_ControllerManager.SetControllerAbilityEvent += CheckControllerStateOfAbility;
			Pvr_ControllerManager.ControllerStatusChangeEvent += CheckControllerStateForGoblin;
		}
	}

	private void OnDestroy()
	{
		Pvr_ControllerManager.PvrServiceStartSuccessEvent -= ServiceStartSuccess;
		Pvr_ControllerManager.SetControllerAbilityEvent -= CheckControllerStateOfAbility;
		Pvr_ControllerManager.ControllerStatusChangeEvent -= CheckControllerStateForGoblin;
	}

	private void OnApplicationPause(bool pause)
	{
		if (pause)
		{
			DestroyLocalController();
		}
	}

	private void ServiceStartSuccess()
	{
		int num = Controller.UPvr_GetDeviceType();
		if (controllerType != num && num != 0)
		{
			controllerType = num;
		}
		LoadResFromJson();
		if (Pvr_ControllerManager.controllerlink.neoserviceStarted)
		{
			if (Variety == ControllerVariety.Controller0)
			{
				if (Pvr_ControllerManager.controllerlink.controller0Connected)
				{
					StartCoroutine(RefreshController(0));
				}
				else
				{
					DestroyLocalController();
				}
			}
			if (Variety == ControllerVariety.Controller1)
			{
				if (Pvr_ControllerManager.controllerlink.controller1Connected)
				{
					StartCoroutine(RefreshController(1));
				}
				else
				{
					DestroyLocalController();
				}
			}
		}
		if (Pvr_ControllerManager.controllerlink.goblinserviceStarted && Variety == ControllerVariety.Controller0)
		{
			if (Pvr_ControllerManager.controllerlink.controller0Connected)
			{
				StartCoroutine(RefreshController(0));
			}
			else
			{
				DestroyLocalController();
			}
		}
	}

	private void LoadResFromJson()
	{
		string text = Pvr_UnitySDKAPI.System.UPvr_GetObjectOrArray("config.controller", 7);
		if (text != null)
		{
			JsonData jsonData = JsonMapper.ToObject(text);
			if (controllerType >= 0 && jsonData.Count >= controllerType)
			{
				curControllerData = jsonData[controllerType - 1];
				modelFilePath = (string)curControllerData["base_path"];
				modelName = (string)curControllerData["model_name"] + "_sys";
			}
		}
		else
		{
			PLOG.E("PvrLog LoadJsonFromSystem Error");
		}
	}

	private void CheckControllerStateForGoblin(string state)
	{
		int num = Controller.UPvr_GetDeviceType();
		if (Variety != 0)
		{
			return;
		}
		if (Convert.ToInt16(state) == 1)
		{
			if (controllerType != num)
			{
				DestroySysController();
				controllerType = num;
			}
			StartCoroutine(RefreshController(0));
		}
		else
		{
			DestroyLocalController();
		}
	}

	private void CheckControllerStateOfAbility(string data)
	{
		bool num = Convert.ToBoolean(Convert.ToInt16(data.Substring(4, 1)));
		short num2 = Convert.ToInt16(data.Substring(0, 1));
		int num3 = Controller.UPvr_GetDeviceType();
		if (num)
		{
			controllerType = num3;
			switch (num2)
			{
			case 0:
				if (Variety == ControllerVariety.Controller0)
				{
					StartCoroutine(RefreshController(0));
				}
				break;
			case 1:
				if (Variety == ControllerVariety.Controller1)
				{
					StartCoroutine(RefreshController(1));
				}
				break;
			}
			return;
		}
		switch (num2)
		{
		case 0:
			if (Variety == ControllerVariety.Controller0)
			{
				DestroyLocalController();
			}
			break;
		case 1:
			if (Variety == ControllerVariety.Controller1)
			{
				DestroyLocalController();
			}
			break;
		}
	}

	private void DestroyLocalController()
	{
		foreach (Transform item in base.transform)
		{
			UnityEngine.Object.Destroy(item.gameObject);
			loadModelSuccess = false;
		}
	}

	private void DestroySysController()
	{
		foreach (Transform item in base.transform)
		{
			if (item.name == modelName)
			{
				UnityEngine.Object.Destroy(item.gameObject);
				loadModelSuccess = false;
			}
		}
	}

	private IEnumerator RefreshController(int id)
	{
		yield return null;
		yield return null;
		if (Controller.UPvr_GetControllerState(id) != ControllerState.Connected)
		{
			yield break;
		}
		if (systemOrUnity == 0)
		{
			LoadControllerFromPrefab();
			if (!loadModelSuccess)
			{
				LoadControllerFromSystem(id);
			}
		}
		else
		{
			bool flag = false;
			foreach (Transform item in base.transform)
			{
				if (item.name == modelName)
				{
					flag = true;
				}
			}
			if (!flag)
			{
				LoadControllerFromSystem(id);
				if (!loadModelSuccess)
				{
					LoadControllerFromPrefab();
				}
			}
			else
			{
				base.transform.Find(modelName).gameObject.SetActive(value: true);
			}
		}
		Pvr_ToolTips.RefreshTips();
		PLOG.I("PvrLog Controller Refresh Success");
	}

	private void LoadControllerFromPrefab()
	{
		switch (controllerType)
		{
		case 1:
		{
			Pvr_ControllerVisual pvr_ControllerVisual3 = UnityEngine.Object.Instantiate(goblin, base.transform, worldPositionStays: false).AddComponent<Pvr_ControllerVisual>();
			pvr_ControllerVisual3.currentDevice = ControllerDevice.Goblin;
			LoadTexture(pvr_ControllerVisual3, "Controller/controller1/controller1", fromRes: true);
			loadModelSuccess = true;
			break;
		}
		case 3:
		{
			Pvr_ControllerVisual pvr_ControllerVisual2 = UnityEngine.Object.Instantiate(g2, base.transform, worldPositionStays: false).AddComponent<Pvr_ControllerVisual>();
			pvr_ControllerVisual2.currentDevice = ControllerDevice.G2;
			LoadTexture(pvr_ControllerVisual2, "Controller/controller3/controller3", fromRes: true);
			loadModelSuccess = true;
			break;
		}
		case 4:
		{
			Pvr_ControllerVisual pvr_ControllerVisual4 = UnityEngine.Object.Instantiate((Variety == ControllerVariety.Controller0) ? neo2L : neo2R, base.transform, worldPositionStays: false).AddComponent<Pvr_ControllerVisual>();
			pvr_ControllerVisual4.currentDevice = ControllerDevice.Neo2;
			LoadTexture(pvr_ControllerVisual4, "Controller/controller4/controller4", fromRes: true);
			loadModelSuccess = true;
			break;
		}
		case 5:
		{
			Pvr_ControllerVisual pvr_ControllerVisual = UnityEngine.Object.Instantiate((Variety == ControllerVariety.Controller0) ? neo3L : neo3R, base.transform, worldPositionStays: false).AddComponent<Pvr_ControllerVisual>();
			pvr_ControllerVisual.currentDevice = ControllerDevice.Neo3;
			LoadTexture(pvr_ControllerVisual, "Controller/controller5/controller5", fromRes: true);
			loadModelSuccess = true;
			break;
		}
		default:
			loadModelSuccess = false;
			break;
		}
	}

	private void LoadControllerFromSystem(int id)
	{
		string text = controllerType.ToString() + id + ".obj";
		string text2 = modelFilePath + text;
		if (!File.Exists(text2))
		{
			PLOG.I("PvrLog Obj File does not exist==" + text2);
			return;
		}
		GameObject gameObject = new GameObject();
		gameObject.name = modelName;
		gameObject.AddComponent<MeshFilter>().mesh = Pvr_ObjImporter.Instance.ImportFile(text2);
		gameObject.transform.SetParent(base.transform);
		gameObject.transform.localPosition = Vector3.zero;
		gameObject.AddComponent<MeshRenderer>().material = (((int)curControllerData["material_type"] == 0) ? standardMat : unlitMat);
		loadModelSuccess = true;
		Pvr_ControllerVisual pvr_ControllerVisual = gameObject.AddComponent<Pvr_ControllerVisual>();
		switch (controllerType)
		{
		case 1:
			pvr_ControllerVisual.currentDevice = ControllerDevice.Goblin;
			break;
		case 3:
			pvr_ControllerVisual.currentDevice = ControllerDevice.G2;
			break;
		case 4:
			pvr_ControllerVisual.currentDevice = ControllerDevice.Neo2;
			break;
		case 5:
			pvr_ControllerVisual.currentDevice = ControllerDevice.Neo3;
			break;
		default:
			pvr_ControllerVisual.currentDevice = ControllerDevice.NewController;
			break;
		}
		pvr_ControllerVisual.variety = Variety;
		LoadTexture(pvr_ControllerVisual, controllerType.ToString() + id, fromRes: false);
		gameObject.transform.localRotation = Quaternion.Euler(new Vector3(0f, 180f, 0f));
		gameObject.transform.localScale = new Vector3(-0.01f, 0.01f, 0.01f);
	}

	private void LoadTexture(Pvr_ControllerVisual visual, string controllerName, bool fromRes)
	{
		if (fromRes)
		{
			texFormat = "";
			prePath = controllerName;
		}
		else
		{
			texFormat = "." + (string)curControllerData["tex_format"];
			prePath = modelFilePath + controllerName;
		}
		string filepath = prePath + "_idle" + texFormat;
		visual.m_idle = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_app" + texFormat;
		visual.m_app = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_home" + texFormat;
		visual.m_home = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_touch" + texFormat;
		visual.m_touchpad = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_volume_down" + texFormat;
		visual.m_volDn = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_volume_up" + texFormat;
		visual.m_volUp = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_trigger" + texFormat;
		visual.m_trigger = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_a" + texFormat;
		visual.m_a = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_b" + texFormat;
		visual.m_b = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_x" + texFormat;
		visual.m_x = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_y" + texFormat;
		visual.m_y = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_grip" + texFormat;
		visual.m_grip = LoadOneTexture(filepath, fromRes);
	}

	private Texture2D LoadOneTexture(string filepath, bool fromRes)
	{
		if (fromRes)
		{
			return Resources.Load<Texture2D>(filepath);
		}
		int width = (int)curControllerData["tex_width"];
		int height = (int)curControllerData["tex_height"];
		Texture2D texture2D = new Texture2D(width, height);
		texture2D.LoadImage(ReadPNG(filepath));
		return texture2D;
	}

	private byte[] ReadPNG(string path)
	{
		FileStream fileStream = new FileStream(path, FileMode.Open, FileAccess.Read);
		fileStream.Seek(0L, SeekOrigin.Begin);
		byte[] array = new byte[fileStream.Length];
		fileStream.Read(array, 0, (int)fileStream.Length);
		fileStream.Close();
		fileStream.Dispose();
		fileStream = null;
		return array;
	}
}
public class Pvr_ControllerLink
{
	public AndroidJavaClass javaHummingbirdClass;

	public AndroidJavaClass javaPico2ReceiverClass;

	public AndroidJavaClass javaserviceClass;

	public AndroidJavaClass javavractivityclass;

	public AndroidJavaClass javaCVClass;

	public AndroidJavaObject activity;

	public string gameobjname = "";

	public bool picoDevice;

	public string hummingBirdMac;

	public int hummingBirdRSSI;

	public bool goblinserviceStarted;

	public bool neoserviceStarted;

	public bool controller0Connected;

	public bool controller1Connected;

	public int mainHandID;

	public Pvr_Controller.UserHandNess handness;

	public int controllerType;

	public ControllerHand Controller0;

	public ControllerHand Controller1;

	public int platFormType = -1;

	public int trackingmode = -1;

	public int systemProp = -1;

	public int enablehand6dofbyhead = -1;

	public bool switchHomeKey = true;

	private int iPhoneHMDModeEnabled;

	private float[] hbPoseData = new float[4];

	private float[] sensorData = new float[28];

	private int[] keyData = new int[134];

	private int[] neo3TouchValue = new int[15];

	private float[] fixedState = new float[7] { 0f, 0f, 0f, 1f, 0f, 0f, 0f };

	private float[] neoposeData = new float[7] { 0f, 0f, 0f, 1f, 0f, 0f, 0f };

	private int[] goblinKeyArray = new int[47];

	private int[] neoKeyArray = new int[67];

	private int[] neotriggerV = new int[9];

	private float[] velocity = new float[3];

	private float[] angularVelocity = new float[3];

	private float[] acceData = new float[3];

	public Pvr_ControllerLink(string name)
	{
		gameobjname = name;
		hummingBirdMac = "";
		hummingBirdRSSI = 0;
		UnityEngine.Debug.Log("PvrLog Controller GameObject:" + gameobjname);
		StartHummingBirdService();
		Controller0 = new ControllerHand();
		Controller0.Position = new Vector3(0f, Pvr_UnitySDKSensor.Instance.HeadPose.Position.y, 0f) + new Vector3(-0.1f, -0.3f, 0.3f);
		Controller1 = new ControllerHand();
		Controller1.Position = new Vector3(0f, Pvr_UnitySDKSensor.Instance.HeadPose.Position.y, 0f) + new Vector3(0.1f, -0.3f, 0.3f);
	}

	private void StartHummingBirdService()
	{
		try
		{
			AndroidJavaClass androidJavaClass = new AndroidJavaClass("com.unity3d.player.UnityPlayer");
			activity = androidJavaClass.GetStatic<AndroidJavaObject>("currentActivity");
			javaHummingbirdClass = new AndroidJavaClass("com.picovr.picovrlib.hummingbirdclient.HbClientActivity");
			javaCVClass = new AndroidJavaClass("com.picovr.picovrlib.cvcontrollerclient.ControllerClient");
			javavractivityclass = new AndroidJavaClass("com.psmart.vrlib.VrActivity");
			javaserviceClass = new AndroidJavaClass("com.picovr.picovrlib.hummingbirdclient.UnityClient");
			Pvr_UnitySDKAPI.System.Pvr_SetInitActivity(activity.GetRawObject(), javaHummingbirdClass.GetRawClass());
			Render.UPvr_GetIntConfig(4, ref platFormType);
			UnityEngine.Debug.Log("PvrLog platform" + platFormType);
			Render.UPvr_GetIntConfig(5, ref trackingmode);
			UnityEngine.Debug.Log("PvrLog trackingmode" + trackingmode);
			systemProp = GetSysproc();
			UnityEngine.Debug.Log("PvrLog systemProp" + systemProp);
			Render.UPvr_GetIntConfig(7, ref enablehand6dofbyhead);
			UnityEngine.Debug.Log("PvrLog enablehand6dofbyhead" + enablehand6dofbyhead);
			if (trackingmode == 0 || trackingmode == 1 || ((trackingmode == 3 || trackingmode == 5 || trackingmode == 6) && (systemProp == 1 || systemProp == 3)))
			{
				picoDevice = platFormType != 0;
				javaPico2ReceiverClass = new AndroidJavaClass("com.picovr.picovrlib.hummingbirdclient.HbClientReceiver");
				Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaPico2ReceiverClass, "startReceiver", activity, gameobjname);
				Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "setPlatformType", platFormType);
			}
			else
			{
				picoDevice = true;
				SetGameObjectToJar(gameobjname);
			}
			Render.UPvr_GetIntConfig(16, ref iPhoneHMDModeEnabled);
			if (iPhoneHMDModeEnabled == 1)
			{
				BindService();
			}
			else if (IsServiceExisted())
			{
				BindService();
			}
		}
		catch (AndroidJavaException ex)
		{
			PLOG.E("ConnectToAndriod--catch" + ex.Message);
		}
	}

	public bool IsServiceExisted()
	{
		bool result = false;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaserviceClass, "isServiceExisted", activity, trackingmode);
		UnityEngine.Debug.Log("PvrLog ServiceExisted ?" + result);
		return result;
	}

	public void SetGameObjectToJar(string name)
	{
		UnityEngine.Debug.Log("PvrLog SetGameObjectToJar " + name);
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "setGameObjectCallback", name);
	}

	public void BindService()
	{
		UnityEngine.Debug.Log("PvrLog Bind Service");
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaserviceClass, "bindService", activity, trackingmode);
	}

	public void UnBindService()
	{
		UnityEngine.Debug.Log("PvrLog UnBind Service");
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaserviceClass, "unbindService", activity, trackingmode);
	}

	public void StopLark2Receiver()
	{
		UnityEngine.Debug.Log("PvrLog StopLark2Receiver");
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaPico2ReceiverClass, "stopReceiver", activity);
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaPico2ReceiverClass, "stopOnBootReceiver", activity);
	}

	public void StartLark2Receiver()
	{
		UnityEngine.Debug.Log("PvrLog StartLark2Receiver");
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaPico2ReceiverClass, "startReceiver", activity, gameobjname);
	}

	public void StopLark2Service()
	{
		UnityEngine.Debug.Log("PvrLog StopLark2Service");
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaPico2ReceiverClass, "stopReceiver", activity);
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "unbindHbService", activity);
	}

	public void StartLark2Service()
	{
		UnityEngine.Debug.Log("PvrLog StartLark2Service");
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaPico2ReceiverClass, "startReceiver", activity, gameobjname);
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "bindHbService", activity);
	}

	public int getHandness()
	{
		int result = -1;
		if (iPhoneHMDModeEnabled == 0)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javavractivityclass, "getPvrHandness", activity);
		}
		else
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getHbHandednessInSP");
		}
		PLOG.I("PvrLog GetHandness =" + result);
		return result;
	}

	public void setHandness(int hand)
	{
		PLOG.I("PvrLog SetHandness =" + hand);
		if (iPhoneHMDModeEnabled == 1)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "setHbHandednessInSP", hand);
		}
	}

	public void StartScan()
	{
		PLOG.I("PvrLog ScanHBController");
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "scanHbDevice", true);
	}

	public void StopScan()
	{
		PLOG.I("PvrLog StopScanHBController");
		if (iPhoneHMDModeEnabled == 0)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "scanHbDevice", false);
		}
	}

	public int GetSysproc()
	{
		int result = -1;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaserviceClass, "getSysproc");
		PLOG.I("PvrLog GetSysproc" + result);
		return result;
	}

	public void ResetController(int num)
	{
		UnityEngine.Debug.Log("PvrLog ResetController" + num);
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "resetControllerSensorState", num);
		}
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "resetHbSensorState");
		}
	}

	public void ConnectBLE()
	{
		UnityEngine.Debug.Log("PvrLog ConnectHBController" + hummingBirdMac);
		if (hummingBirdMac != "")
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "connectHbController", hummingBirdMac);
		}
	}

	public void DisConnectBLE()
	{
		UnityEngine.Debug.Log("PvrLog DisConnectHBController");
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "disconnectHbController");
	}

	public bool StartUpgrade()
	{
		UnityEngine.Debug.Log("PvrLog StartUpgradeHBController");
		bool result = false;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "startUpgrade");
		return result;
	}

	public void setBinPath(string path, bool isasset)
	{
		UnityEngine.Debug.Log("PvrLog setBinPath" + path + isasset);
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "setBinPath", path, isasset);
	}

	public string GetBLEImageType()
	{
		string result = "";
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getBLEImageType");
		}
		UnityEngine.Debug.Log("PvrLog GetBLEImageType" + result);
		return result;
	}

	public long GetBLEVersion()
	{
		long result = 0L;
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getBLEVersion");
		}
		UnityEngine.Debug.Log("PvrLog GetBLEVersion" + result);
		return result;
	}

	public string GetFileImageType()
	{
		string result = "";
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getFileImageType");
		}
		UnityEngine.Debug.Log("PvrLog GetFileImageType" + result);
		return result;
	}

	public long GetFileVersion()
	{
		long result = 0L;
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getFileVersion");
		}
		UnityEngine.Debug.Log("PvrLog GetFileVersion" + result);
		return result;
	}

	public int GetControllerConnectionState(int num)
	{
		int result = -1;
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaCVClass, "getControllerConnectionState", num);
		}
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getHbConnectionState");
		}
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog GetControllerState:" + num + "state:" + result);
		}
		return result;
	}

	public void RebackToLauncher()
	{
		UnityEngine.Debug.Log("PvrLog RebackToLauncher");
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "startLauncher");
		}
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "startLauncher");
		}
	}

	public void TurnUpVolume()
	{
		UnityEngine.Debug.Log("PvrLog TurnUpVolume");
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "turnUpVolume", activity);
		}
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "turnUpVolume", activity);
		}
	}

	public void TurnDownVolume()
	{
		UnityEngine.Debug.Log("PvrLog TurnDownVolume");
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "turnDownVolume", activity);
		}
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "turnDownVolume", activity);
		}
	}

	public float[] GetHBControllerPoseData()
	{
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref hbPoseData, javaHummingbirdClass, "getHBSensorPose");
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog HBControllerData" + hbPoseData[0] + "," + hbPoseData[1] + "," + hbPoseData[2] + "," + hbPoseData[3]);
		}
		return hbPoseData;
	}

	public float[] GetControllerSensorData()
	{
		if (enablehand6dofbyhead == 1)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref sensorData, javaCVClass, "getControllerDataInfoBySharmem", Pvr_UnitySDKManager.SDK.headData);
		}
		else
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref sensorData, javaCVClass, "getControllerDataInfoBySharmem");
		}
		return sensorData;
	}

	public int[] GetControllerKeyData()
	{
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref keyData, javaCVClass, "getDoubleControllerKeyEventUnityExtBySharmem");
		return keyData;
	}

	public int[] GetNeo3TouchData(int hand)
	{
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref neo3TouchValue, javaCVClass, "getControllerTouchEvent", hand);
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog Neo3Touch hand:" + hand + "-" + neo3TouchValue[0] + neo3TouchValue[1] + neo3TouchValue[2] + neo3TouchValue[3] + neo3TouchValue[4] + "," + neo3TouchValue[5] + neo3TouchValue[6] + neo3TouchValue[7] + neo3TouchValue[8] + neo3TouchValue[9] + "," + neo3TouchValue[10] + neo3TouchValue[11] + neo3TouchValue[12] + neo3TouchValue[13] + neo3TouchValue[14]);
		}
		return neo3TouchValue;
	}

	public int GetNeo3GripValue(int hand)
	{
		int result = 0;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaCVClass, "getControllerGripValue", hand);
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog Neo3GripValue:" + result);
		}
		return result;
	}

	public float[] GetControllerFixedSensorState(int hand)
	{
		if (trackingmode == 2 || trackingmode == 3)
		{
			return fixedState;
		}
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref fixedState, javaCVClass, "getControllerFixedSensorState", hand);
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog GetControllerFixedSensorState " + hand + "Rotation:" + fixedState[0] + "," + fixedState[1] + "," + fixedState[2] + "," + fixedState[3] + "Position:" + fixedState[4] + "," + fixedState[5] + "," + fixedState[6]);
		}
		return fixedState;
	}

	public float[] GetCvControllerPoseData(int hand)
	{
		if (enablehand6dofbyhead == 1)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref neoposeData, javaCVClass, "getControllerSensorState", hand, Pvr_UnitySDKManager.SDK.headData);
		}
		else
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref neoposeData, javaCVClass, "getControllerSensorState", hand);
		}
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog CVControllerData :" + neoposeData[0] + "," + neoposeData[1] + "," + neoposeData[2] + "," + neoposeData[3] + "," + neoposeData[4] + "," + neoposeData[5] + "," + neoposeData[6]);
		}
		return neoposeData;
	}

	public int[] GetHBControllerKeyData()
	{
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref goblinKeyArray, javaHummingbirdClass, "getHBKeyEventUnityExt");
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog HBControllerKey" + goblinKeyArray[0] + goblinKeyArray[1] + goblinKeyArray[2] + goblinKeyArray[3] + goblinKeyArray[4] + "," + goblinKeyArray[5] + goblinKeyArray[6] + goblinKeyArray[7] + goblinKeyArray[8] + goblinKeyArray[9] + "," + goblinKeyArray[10] + goblinKeyArray[11] + goblinKeyArray[12] + goblinKeyArray[13] + goblinKeyArray[14] + "," + goblinKeyArray[15] + goblinKeyArray[16] + goblinKeyArray[17] + goblinKeyArray[18] + goblinKeyArray[19] + "," + goblinKeyArray[20] + goblinKeyArray[21] + goblinKeyArray[22] + goblinKeyArray[23] + goblinKeyArray[24] + "," + goblinKeyArray[25] + goblinKeyArray[26] + goblinKeyArray[27] + goblinKeyArray[28] + goblinKeyArray[29] + "," + goblinKeyArray[30] + goblinKeyArray[31] + goblinKeyArray[32] + goblinKeyArray[33] + goblinKeyArray[34] + "," + goblinKeyArray[35] + goblinKeyArray[36] + goblinKeyArray[37] + goblinKeyArray[38] + goblinKeyArray[39] + "," + goblinKeyArray[40] + goblinKeyArray[41] + goblinKeyArray[42] + goblinKeyArray[43] + goblinKeyArray[44] + "," + goblinKeyArray[45] + goblinKeyArray[46]);
		}
		return goblinKeyArray;
	}

	public int GetHBKeyValue()
	{
		int result = -1;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getTriggerKeyEvent");
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog GoblinControllerTriggerKey:" + result);
		}
		return result;
	}

	public int[] GetCvControllerKeyData(int hand)
	{
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref neoKeyArray, javaCVClass, "getControllerKeyEventUnityExt", hand);
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog CVControllerKey hand:" + hand + "-" + neoKeyArray[0] + neoKeyArray[1] + neoKeyArray[2] + neoKeyArray[3] + neoKeyArray[4] + "," + neoKeyArray[5] + neoKeyArray[6] + neoKeyArray[7] + neoKeyArray[8] + neoKeyArray[9] + "," + neoKeyArray[10] + neoKeyArray[11] + neoKeyArray[12] + neoKeyArray[13] + neoKeyArray[14] + "," + neoKeyArray[15] + neoKeyArray[16] + neoKeyArray[17] + neoKeyArray[18] + neoKeyArray[19] + "," + neoKeyArray[20] + neoKeyArray[21] + neoKeyArray[22] + neoKeyArray[23] + neoKeyArray[24] + "," + neoKeyArray[25] + neoKeyArray[26] + neoKeyArray[27] + neoKeyArray[28] + neoKeyArray[29] + "," + neoKeyArray[30] + neoKeyArray[31] + neoKeyArray[32] + neoKeyArray[33] + neoKeyArray[34] + "," + neoKeyArray[35] + neoKeyArray[36] + neoKeyArray[37] + neoKeyArray[38] + neoKeyArray[39] + "," + neoKeyArray[40] + neoKeyArray[41] + neoKeyArray[42] + neoKeyArray[43] + neoKeyArray[44] + "," + neoKeyArray[45] + neoKeyArray[46] + neoKeyArray[47] + neoKeyArray[48] + neoKeyArray[49] + "," + neoKeyArray[50] + neoKeyArray[51] + neoKeyArray[52] + neoKeyArray[53] + neoKeyArray[54] + "," + neoKeyArray[55] + neoKeyArray[56] + neoKeyArray[57] + neoKeyArray[58] + neoKeyArray[59] + "," + neoKeyArray[60] + neoKeyArray[61] + neoKeyArray[62] + neoKeyArray[63] + neoKeyArray[64] + "," + neoKeyArray[65] + neoKeyArray[66]);
		}
		return neoKeyArray;
	}

	public int GetCVTriggerValue(int hand)
	{
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref neotriggerV, javaCVClass, "getControllerKeyEvent", hand);
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog CVTriggerValue " + neotriggerV[7]);
		}
		return neotriggerV[7];
	}

	public void AutoConnectHbController(int scanTimeMs)
	{
		PLOG.I("PvrLog AutoConnectHbController" + scanTimeMs);
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "autoConnectHbController", scanTimeMs, gameobjname);
	}

	public void StartControllerThread(int headSensorState, int handSensorState)
	{
		if (BoundarySystem.UPvr_IsBoundaryEnable())
		{
			headSensorState = 1;
			handSensorState = 1;
		}
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "startControllerThread", headSensorState, handSensorState);
		UnityEngine.Debug.Log("PvrLog StartControllerThread" + headSensorState + handSensorState);
	}

	public void StopControllerThread(int headSensorState, int handSensorState)
	{
		if (BoundarySystem.UPvr_IsBoundaryEnable())
		{
			headSensorState = 1;
			handSensorState = 1;
		}
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "stopControllerThread", headSensorState, handSensorState);
		UnityEngine.Debug.Log("PvrLog StopControllerThread" + headSensorState + handSensorState);
	}

	public void SetUnityVersionToJar(string version)
	{
		if (trackingmode == 4 || trackingmode == 5 || trackingmode == 6)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "setUnityVersion", version);
		}
		UnityEngine.Debug.Log("PvrLog SetUnityVersionToJar" + version);
	}

	public Vector3 GetVelocity(int num)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref velocity, javaCVClass, "getControllerLinearVelocity", num);
		}
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog Velocity" + velocity[0] + "," + velocity[1] + "," + velocity[2]);
		}
		return new Vector3(velocity[0], velocity[1], 0f - velocity[2]);
	}

	public Vector3 GetAngularVelocity(int num)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref angularVelocity, javaCVClass, "getControllerAngularVelocity", num);
		}
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref angularVelocity, javaHummingbirdClass, "getHbAngularVelocity");
		}
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog Gyro:" + angularVelocity[0] + "," + angularVelocity[1] + "," + angularVelocity[2]);
		}
		return new Vector3(0f, 0f, 0f);
	}

	public Vector3 GetAcceleration(int num)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref acceData, javaCVClass, "getControllerAcceleration", num);
		}
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref acceData, javaHummingbirdClass, "getHbAcceleration");
		}
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog Acce:" + acceData[0] + acceData[1] + acceData[2]);
		}
		return new Vector3(0f, 0f, 0f);
	}

	public string GetConnectedDeviceMac()
	{
		string result = "";
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getConnectedDeviceMac");
		}
		PLOG.I("PvrLog ConnectedDeviceMac:" + result);
		return result;
	}

	public void VibrateNeo2Controller(float strength, int time, int hand)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "vibrateCV2ControllerStrength", strength, time, hand);
		}
		PLOG.I("PvrLog VibrateNeo2Controller:" + strength + time + hand);
	}

	public int GetMainControllerIndex()
	{
		int result = 0;
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaCVClass, "getMainControllerIndex");
		}
		PLOG.I("PvrLog GetMainControllerIndex:" + result);
		return result;
	}

	public void SetMainController(int index)
	{
		PLOG.I("PvrLog SetMainController:" + index);
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "setMainController", index);
		}
	}

	public void ResetHeadSensorForController()
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "resetHeadSensorForController");
		}
		PLOG.I("PvrLog ResetHeadSensorForController:");
	}

	public void GetDeviceVersion(int deviceType)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "getDeviceVersion", deviceType);
		}
		PLOG.I("PvrLog GetDeviceVersion:" + deviceType);
	}

	public void GetControllerSnCode(int controllerSerialNum)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "getControllerSnCode", controllerSerialNum);
		}
		PLOG.I("PvrLog GetControllerSnCode:" + controllerSerialNum);
	}

	public void SetControllerUnbind(int controllerSerialNum)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "setControllerUnbind", controllerSerialNum);
		}
		PLOG.I("PvrLog SetControllerUnbind:" + controllerSerialNum);
	}

	public void SetStationRestart()
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "setStationRestart");
		}
		PLOG.I("PvrLog SetStationRestart");
	}

	public void StartStationOtaUpdate()
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "startStationOtaUpdate");
		}
		PLOG.I("PvrLog StartStationOtaUpdate");
	}

	public void StartControllerOtaUpdate(int mode, int controllerSerialNum)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "startControllerOtaUpdate", mode, controllerSerialNum);
		}
		PLOG.I("PvrLog StartControllerOtaUpdate" + mode + controllerSerialNum);
	}

	public void EnterPairMode(int controllerSerialNum)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "enterPairMode", controllerSerialNum);
		}
		PLOG.I("PvrLog EnterPairMode" + controllerSerialNum);
	}

	public void SetControllerShutdown(int controllerSerialNum)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "setControllerShutdown", controllerSerialNum);
		}
		PLOG.I("PvrLog SetControllerShutdown" + controllerSerialNum);
	}

	public int GetStationPairState()
	{
		int result = -1;
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaCVClass, "getStationPairState");
		}
		PLOG.I("PvrLog StationPairState" + result);
		return result;
	}

	public int GetStationOtaUpdateProgress()
	{
		int result = -1;
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaCVClass, "getStationOtaUpdateProgress");
		}
		PLOG.I("PvrLog StationOtaUpdateProgress" + result);
		return result;
	}

	public int GetControllerOtaUpdateProgress()
	{
		int result = -1;
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaCVClass, "getControllerOtaUpdateProgress");
		}
		PLOG.I("PvrLog ControllerOtaUpdateProgress" + result);
		return result;
	}

	public void GetControllerVersionAndSN(int controllerSerialNum)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "getControllerVersionAndSN", controllerSerialNum);
		}
		PLOG.I("PvrLog GetControllerVersionAndSN" + controllerSerialNum);
	}

	public void GetControllerUniqueID()
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "getControllerUniqueID");
		}
		PLOG.I("PvrLog GetControllerUniqueID");
	}

	public void InterruptStationPairMode()
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "interruptStationPairMode");
		}
		PLOG.I("PvrLog InterruptStationPairMode");
	}

	public int GetControllerAbility(int controllerSerialNum)
	{
		int result = -1;
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaCVClass, "getControllerAbility", controllerSerialNum);
		}
		PLOG.I("PvrLog ControllerAbility:" + result);
		return result;
	}

	public void SwitchHomeKey(bool state)
	{
		PLOG.I("PvrLog SwitchHomeKey:" + state);
		switchHomeKey = state;
	}

	public void SetBootReconnect()
	{
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "setBootReconnect");
		PLOG.I("PvrLog SetBootReconnect");
	}

	public int GetTemperature()
	{
		int result = -1;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getTemperature");
		PLOG.I("PvrLog Temperature:" + result);
		return result;
	}

	public int GetDeviceType()
	{
		int result = -1;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getDeviceType");
		PLOG.I("PvrLog DeviceType:" + result);
		return result;
	}

	public int GetControllerType()
	{
		int result = -1;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getControllerType");
		return result;
	}

	public string GetHummingBird2SN()
	{
		string result = "";
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getHummingBird2SN");
		PLOG.I("PvrLog HummingBird2SN:" + result);
		return result;
	}

	public string GetControllerVersion()
	{
		string result = "";
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getControllerVersion");
		PLOG.I("PvrLog ControllerVersion:" + result);
		return result;
	}

	public bool IsEnbleTrigger()
	{
		bool result = false;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "isEnbleTrigger");
		PLOG.I("PvrLog IsEnbleTrigger:" + result);
		return result;
	}

	public void StartCV2PairingMode(int devicetype)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "startCV2PairingMode", devicetype);
		}
		PLOG.I("PvrLog StartCV2PairingMode:" + devicetype);
	}

	public void StopCV2PairingMode(int devicetype)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "stopCV2PairingMode", devicetype);
		}
		PLOG.I("PvrLog StopCV2PairingMode:" + devicetype);
	}

	public int GetControllerBindingState(int id)
	{
		int result = -1;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaCVClass, "getControllerBindingState", id);
		PLOG.I("PvrLog getControllerBindingState:" + result);
		return result;
	}

	public void setIsEnbleHomeKey(bool state)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "setIsEnbleHomeKey", state);
		}
		PLOG.I("PvrLog setIsEnbleHomeKey:" + state);
	}

	public int getControllerSensorStatus(int id)
	{
		int result = -1;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaCVClass, "getControllerSensorStatus", id);
		PLOG.I("PvrLog getControllerSensorStatus:" + result);
		return result;
	}
}
public class Pvr_ControllerManager : MonoBehaviour
{
	public delegate void PvrServiceStartSuccess();

	public delegate void PvrControllerStateChanged(string data);

	public delegate void ChangeMainControllerCallBack(string index);

	public delegate void ChangeHandNessCallBack(string index);

	public delegate void SetHbServiceBindState();

	public delegate void ControllerThreadStartedCallback();

	public delegate void SetControllerServiceBindState();

	public delegate void ControllerStatusChange(string isconnect);

	public delegate void SetControllerAbility(string data);

	public delegate void SetControllerStateChanged(string data);

	public delegate void SetHbControllerMac(string mac);

	public delegate void ControllerDeviceVersionCallback(string data);

	public delegate void ControllerSnCodeCallback(string data);

	public delegate void ControllerUnbindCallback(string status);

	public delegate void ControllerStationStatusCallback(string status);

	public delegate void ControllerStationBusyCallback(string status);

	public delegate void ControllerOtaStartCodeCallback(string data);

	public delegate void ControllerDeviceVersionAndSNCallback(string data);

	public delegate void ControllerUniqueIDCallback(string data);

	public delegate void ControllerCombinedKeyUnbindCallback(string data);

	private static Pvr_ControllerManager instance;

	public static Pvr_ControllerLink controllerlink;

	private float cTime = 1f;

	private bool stopConnect;

	public Text toast;

	private bool controllerServicestate;

	private float disConnectTime;

	public bool LengthAdaptiveRay;

	private float[] sensorData = new float[28];

	private int[] keyData = new int[134];

	private float[] g2SensorData = new float[4];

	private int[] g2KeyData = new int[47];

	private int keyOffset;

	private int rotControllerMode = 1;

	public static Pvr_ControllerManager Instance
	{
		get
		{
			if (instance == null)
			{
				instance = UnityEngine.Object.FindObjectOfType<Pvr_ControllerManager>();
			}
			if (instance == null)
			{
				GameObject obj = new GameObject("GameObject");
				instance = obj.AddComponent<Pvr_ControllerManager>();
				obj.transform.localPosition = Vector3.zero;
			}
			return instance;
		}
	}

	public static event PvrServiceStartSuccess PvrServiceStartSuccessEvent;

	public static event PvrControllerStateChanged PvrControllerStateChangedEvent;

	public static event ChangeMainControllerCallBack ChangeMainControllerCallBackEvent;

	public static event ChangeHandNessCallBack ChangeHandNessCallBackEvent;

	public static event SetHbServiceBindState SetHbServiceBindStateEvent;

	public static event ControllerThreadStartedCallback ControllerThreadStartedCallbackEvent;

	public static event SetControllerServiceBindState SetControllerServiceBindStateEvent;

	public static event ControllerStatusChange ControllerStatusChangeEvent;

	public static event SetControllerAbility SetControllerAbilityEvent;

	public static event SetControllerStateChanged SetControllerStateChangedEvent;

	public static event SetHbControllerMac SetHbControllerMacEvent;

	public static event ControllerDeviceVersionCallback ControllerDeviceVersionCallbackEvent;

	public static event ControllerSnCodeCallback ControllerSnCodeCallbackEvent;

	public static event ControllerUnbindCallback ControllerUnbindCallbackEvent;

	public static event ControllerStationStatusCallback ControllerStationStatusCallbackEvent;

	public static event ControllerStationBusyCallback ControllerStationBusyCallbackEvent;

	public static event ControllerOtaStartCodeCallback ControllerOtaStartCodeCallbackEvent;

	public static event ControllerDeviceVersionAndSNCallback ControllerDeviceVersionAndSNCallbackEvent;

	public static event ControllerUniqueIDCallback ControllerUniqueIDCallbackEvent;

	public static event ControllerCombinedKeyUnbindCallback ControllerCombinedKeyUnbindCallbackEvent;

	private void Awake()
	{
		if (instance == null)
		{
			instance = this;
		}
		if (instance != this)
		{
			PLOG.E("instance object should be a singleton.");
			return;
		}
		if (controllerlink == null)
		{
			controllerlink = new Pvr_ControllerLink(base.gameObject.name);
			return;
		}
		controllerlink.SetGameObjectToJar(base.gameObject.name);
		BindService();
	}

	private void Start()
	{
		if (controllerlink.trackingmode < 2)
		{
			Invoke("CheckControllerService", 10f);
		}
		Render.UPvr_GetIntConfig(23, ref rotControllerMode);
	}

	private void Update()
	{
		if (controllerlink.neoserviceStarted)
		{
			sensorData = controllerlink.GetControllerSensorData();
			keyData = controllerlink.GetControllerKeyData();
			if (controllerlink.controller0Connected)
			{
				if (Pvr_UnitySDKManager.SDK.ShowVideoSeethrough)
				{
					sensorData[2] = 0f - sensorData[2];
					sensorData[3] = 0f - sensorData[3];
					controllerlink.Controller0.Rotation.Set(sensorData[0], sensorData[1], sensorData[2], sensorData[3]);
					if (rotControllerMode == 0)
					{
						controllerlink.Controller0.Rotation *= Quaternion.Euler(34f, 0f, 0f);
					}
					controllerlink.Controller0.Position.Set(sensorData[4] / 1000f, sensorData[5] / 1000f, (0f - sensorData[6]) / 1000f);
				}
				else
				{
					controllerlink.Controller0.Rotation.Set(sensorData[7], sensorData[8], sensorData[9], sensorData[10]);
					if (rotControllerMode == 0)
					{
						controllerlink.Controller0.Rotation *= Quaternion.Euler(34f, 0f, 0f);
					}
					controllerlink.Controller0.Position.Set(sensorData[11] / 1000f, sensorData[12] / 1000f, (0f - sensorData[13]) / 1000f);
				}
				if (!controllerlink.Controller0.isShowBoundary)
				{
					if (controllerlink.getControllerSensorStatus(0) == 0)
					{
						Sensor.UPvr_SetReinPosition(sensorData[0], sensorData[1], sensorData[2], sensorData[3], sensorData[4], sensorData[5], sensorData[6], 0, valid: false, 0);
					}
					else
					{
						controllerlink.Controller0.isShowBoundary = true;
						Sensor.UPvr_SetReinPosition(sensorData[0], sensorData[1], sensorData[2], sensorData[3], sensorData[4], sensorData[5], sensorData[6], 0, valid: true, Convert.ToInt32(Convert.ToString(keyData[35]) + Convert.ToString(keyData[15]) + "00", 2));
					}
				}
				else
				{
					Sensor.UPvr_SetReinPosition(sensorData[0], sensorData[1], sensorData[2], sensorData[3], sensorData[4], sensorData[5], sensorData[6], 0, valid: true, Convert.ToInt32(Convert.ToString(keyData[35]) + Convert.ToString(keyData[15]) + "00", 2));
				}
				TransformData(controllerlink.Controller0, 0, keyData);
			}
			else
			{
				Sensor.UPvr_SetReinPosition(sensorData[0], sensorData[1], sensorData[2], sensorData[3], sensorData[4], sensorData[5], sensorData[6], 0, valid: false, 0);
			}
			if (controllerlink.controller1Connected)
			{
				if (Pvr_UnitySDKManager.SDK.ShowVideoSeethrough)
				{
					sensorData[16] = 0f - sensorData[16];
					sensorData[17] = 0f - sensorData[17];
					controllerlink.Controller1.Rotation.Set(sensorData[14], sensorData[15], sensorData[16], sensorData[17]);
					if (rotControllerMode == 0)
					{
						controllerlink.Controller1.Rotation *= Quaternion.Euler(34f, 0f, 0f);
					}
					controllerlink.Controller1.Position.Set(sensorData[18] / 1000f, sensorData[19] / 1000f, (0f - sensorData[20]) / 1000f);
				}
				else
				{
					controllerlink.Controller1.Rotation.Set(sensorData[21], sensorData[22], sensorData[23], sensorData[24]);
					if (rotControllerMode == 0)
					{
						controllerlink.Controller1.Rotation *= Quaternion.Euler(34f, 0f, 0f);
					}
					controllerlink.Controller1.Position.Set(sensorData[25] / 1000f, sensorData[26] / 1000f, (0f - sensorData[27]) / 1000f);
				}
				if (!controllerlink.Controller1.isShowBoundary)
				{
					if (controllerlink.getControllerSensorStatus(1) == 0)
					{
						Sensor.UPvr_SetReinPosition(sensorData[14], sensorData[15], sensorData[16], sensorData[17], sensorData[18], sensorData[19], sensorData[20], 1, valid: false, 0);
					}
					else
					{
						controllerlink.Controller1.isShowBoundary = true;
						Sensor.UPvr_SetReinPosition(sensorData[14], sensorData[15], sensorData[16], sensorData[17], sensorData[18], sensorData[19], sensorData[20], 1, valid: true, Convert.ToInt32(Convert.ToString(keyData[102]) + Convert.ToString(keyData[82]) + "00", 2));
					}
				}
				else
				{
					Sensor.UPvr_SetReinPosition(sensorData[14], sensorData[15], sensorData[16], sensorData[17], sensorData[18], sensorData[19], sensorData[20], 1, valid: true, Convert.ToInt32(Convert.ToString(keyData[102]) + Convert.ToString(keyData[82]) + "00", 2));
				}
				TransformData(controllerlink.Controller1, 1, keyData);
			}
			else
			{
				Sensor.UPvr_SetReinPosition(sensorData[14], sensorData[15], sensorData[16], sensorData[17], sensorData[18], sensorData[19], sensorData[20], 1, valid: false, 0);
			}
		}
		if (controllerlink.goblinserviceStarted && controllerlink.controller0Connected)
		{
			g2SensorData = controllerlink.GetHBControllerPoseData();
			controllerlink.Controller0.Rotation.Set(g2SensorData[0], g2SensorData[1], g2SensorData[2], g2SensorData[3]);
			g2KeyData = controllerlink.GetHBControllerKeyData();
			TransformData(controllerlink.Controller0, 0, g2KeyData);
		}
		SetSystemKey();
	}

	private void OnApplicationPause(bool pause)
	{
		int headSensorState = ((!Pvr_UnitySDKManager.SDK.HmdOnlyrot) ? 1 : 0);
		int handSensorState = ((!Pvr_UnitySDKManager.SDK.ControllerOnlyrot) ? 1 : 0);
		if (pause)
		{
			if (controllerlink.neoserviceStarted)
			{
				controllerlink.SetGameObjectToJar("");
				controllerlink.StopControllerThread(headSensorState, handSensorState);
			}
			if (controllerlink.goblinserviceStarted)
			{
				controllerlink.StopLark2Receiver();
			}
			return;
		}
		controllerlink.Controller0 = new ControllerHand();
		controllerlink.Controller1 = new ControllerHand();
		if (controllerlink.neoserviceStarted)
		{
			controllerlink.SetGameObjectToJar(base.gameObject.name);
			controllerlink.SetUnityVersionToJar("2.8.9.12");
			controllerlink.StartControllerThread(headSensorState, handSensorState);
		}
		if (controllerlink.goblinserviceStarted)
		{
			controllerlink.StartLark2Receiver();
			controllerlink.controller0Connected = GetControllerConnectionState(0) == 1;
			controllerlink.controllerType = controllerlink.GetControllerType();
			controllerlink.handness = (Pvr_Controller.UserHandNess)controllerlink.getHandness();
			if (Pvr_ControllerManager.PvrServiceStartSuccessEvent != null)
			{
				Pvr_ControllerManager.PvrServiceStartSuccessEvent();
			}
		}
	}

	private void OnDestroy()
	{
		controllerlink.UnBindService();
		Sensor.UPvr_SetReinPosition(0f, 0f, 0f, 1f, 0f, 0f, 0f, 0, valid: false, 0);
		Sensor.UPvr_SetReinPosition(0f, 0f, 0f, 1f, 0f, 0f, 0f, 1, valid: false, 0);
	}

	private void OnApplicationQuit()
	{
		int headSensorState = ((!Pvr_UnitySDKManager.SDK.HmdOnlyrot) ? 1 : 0);
		int handSensorState = ((!Pvr_UnitySDKManager.SDK.ControllerOnlyrot) ? 1 : 0);
		if (controllerlink.neoserviceStarted)
		{
			controllerlink.SetGameObjectToJar("");
			controllerlink.StopControllerThread(headSensorState, handSensorState);
		}
	}

	public void StopLark2Service()
	{
		if (controllerlink != null)
		{
			controllerlink.StopLark2Service();
		}
	}

	public Vector3 GetAngularVelocity(int num)
	{
		if (controllerlink != null)
		{
			return controllerlink.GetAngularVelocity(num);
		}
		return new Vector3(0f, 0f, 0f);
	}

	public Vector3 GetAcceleration(int num)
	{
		if (controllerlink != null)
		{
			return controllerlink.GetAcceleration(num);
		}
		return new Vector3(0f, 0f, 0f);
	}

	public void BindService()
	{
		if (controllerlink != null)
		{
			controllerlink.BindService();
		}
	}

	public void StartScan()
	{
		if (controllerlink != null)
		{
			controllerlink.StartScan();
		}
	}

	public void StopScan()
	{
		if (controllerlink != null)
		{
			controllerlink.StopScan();
		}
	}

	public void ResetController(int num)
	{
		if (controllerlink != null)
		{
			controllerlink.ResetController(num);
		}
	}

	public static int GetControllerConnectionState(int num)
	{
		return controllerlink.GetControllerConnectionState(num);
	}

	public void ConnectBLE()
	{
		if (controllerlink != null)
		{
			controllerlink.ConnectBLE();
		}
	}

	public void DisConnectBLE()
	{
		if (controllerlink != null)
		{
			controllerlink.DisConnectBLE();
		}
	}

	public void SetBinPath(string path, bool isAsset)
	{
		if (controllerlink != null)
		{
			controllerlink.setBinPath(path, isAsset);
		}
	}

	public void StartUpgrade()
	{
		if (controllerlink != null)
		{
			controllerlink.StartUpgrade();
		}
	}

	public static string GetBLEImageType()
	{
		return controllerlink.GetBLEImageType();
	}

	public static long GetBLEVersion()
	{
		return controllerlink.GetBLEVersion();
	}

	public static string GetFileImageType()
	{
		return controllerlink.GetFileImageType();
	}

	public static long GetFileVersion()
	{
		return controllerlink.GetFileVersion();
	}

	public static void AutoConnectHbController(int scans)
	{
		if (controllerlink != null)
		{
			controllerlink.AutoConnectHbController(scans);
		}
	}

	public static string GetConnectedDeviceMac()
	{
		string result = "";
		if (controllerlink != null)
		{
			result = controllerlink.GetConnectedDeviceMac();
		}
		return result;
	}

	public void setHbControllerMac(string mac)
	{
		PLOG.I("PvrLog HBMacRSSI" + mac);
		controllerlink.hummingBirdMac = mac.Substring(0, 17);
		controllerlink.hummingBirdRSSI = Convert.ToInt16(mac.Remove(0, 18));
		if (Pvr_ControllerManager.SetHbControllerMacEvent != null)
		{
			Pvr_ControllerManager.SetHbControllerMacEvent(mac.Substring(0, 17));
		}
	}

	public int GetControllerRSSI()
	{
		return controllerlink.hummingBirdRSSI;
	}

	public void setHbServiceBindState(string state)
	{
		PLOG.I("PvrLog HBBindCallBack" + state);
		controllerServicestate = true;
		if (Convert.ToInt16(state) == 0)
		{
			Invoke("BindService", 0.5f);
			controllerlink.goblinserviceStarted = false;
		}
		else if (Convert.ToInt16(state) == 1)
		{
			controllerlink.goblinserviceStarted = true;
			controllerlink.controller0Connected = GetControllerConnectionState(0) == 1;
			controllerlink.controllerType = controllerlink.GetControllerType();
			controllerlink.handness = (Pvr_Controller.UserHandNess)controllerlink.getHandness();
			if (Pvr_ControllerManager.SetHbServiceBindStateEvent != null)
			{
				Pvr_ControllerManager.SetHbServiceBindStateEvent();
			}
			if (Pvr_ControllerManager.PvrServiceStartSuccessEvent != null)
			{
				Pvr_ControllerManager.PvrServiceStartSuccessEvent();
			}
		}
	}

	public void setControllerServiceBindState(string state)
	{
		PLOG.I("PvrLog CVBindCallBack" + state);
		if (Convert.ToInt16(state) == 0)
		{
			Invoke("BindService", 0.5f);
			controllerlink.neoserviceStarted = false;
		}
		else if (Convert.ToInt16(state) == 1)
		{
			controllerlink.SetUnityVersionToJar("2.8.9.12");
			controllerlink.neoserviceStarted = true;
			int headSensorState = ((!Pvr_UnitySDKManager.SDK.HmdOnlyrot) ? 1 : 0);
			int handSensorState = ((!Pvr_UnitySDKManager.SDK.ControllerOnlyrot) ? 1 : 0);
			controllerlink.StartControllerThread(headSensorState, handSensorState);
			if (Pvr_ControllerManager.SetControllerServiceBindStateEvent != null)
			{
				Pvr_ControllerManager.SetControllerServiceBindStateEvent();
			}
		}
	}

	public void setHbControllerConnectState(string isconnect)
	{
		PLOG.I("PvrLog HBControllerConnect" + isconnect);
		controllerlink.controller0Connected = Convert.ToInt16(isconnect) == 1;
		if (!controllerlink.controller0Connected)
		{
			controllerlink.Controller0 = new ControllerHand();
		}
		else
		{
			ResetController(0);
			controllerlink.controllerType = controllerlink.GetControllerType();
			controllerlink.handness = (Pvr_Controller.UserHandNess)controllerlink.getHandness();
		}
		stopConnect = false;
		if (Pvr_ControllerManager.ControllerStatusChangeEvent != null)
		{
			Pvr_ControllerManager.ControllerStatusChangeEvent(isconnect);
		}
		if (Pvr_ControllerManager.PvrControllerStateChangedEvent != null)
		{
			Pvr_ControllerManager.PvrControllerStateChangedEvent(isconnect);
		}
	}

	public void setControllerStateChanged(string state)
	{
		PLOG.I("PvrLog CVControllerStateChanged" + state);
		int num = Convert.ToInt16(state.Substring(0, 1));
		if (num == 0)
		{
			controllerlink.controller0Connected = Convert.ToBoolean(Convert.ToInt16(state.Substring(2, 1)));
			if (!controllerlink.controller0Connected)
			{
				controllerlink.Controller0 = new ControllerHand();
				controllerlink.Controller0.Position = new Vector3(0f, Pvr_UnitySDKSensor.Instance.HeadPose.Position.y, 0f) + new Vector3(-0.1f, -0.3f, 0.3f);
			}
		}
		else
		{
			controllerlink.controller1Connected = Convert.ToBoolean(Convert.ToInt16(state.Substring(2, 1)));
			if (!controllerlink.controller1Connected)
			{
				controllerlink.Controller1 = new ControllerHand();
				controllerlink.Controller1.Position = new Vector3(0f, Pvr_UnitySDKSensor.Instance.HeadPose.Position.y, 0f) + new Vector3(0.1f, -0.3f, 0.3f);
			}
		}
		if (Convert.ToBoolean(Convert.ToInt16(state.Substring(2, 1))))
		{
			controllerlink.controllerType = controllerlink.GetControllerType();
			controllerlink.ResetController(num);
		}
		controllerlink.handness = (Pvr_Controller.UserHandNess)controllerlink.getHandness();
		controllerlink.mainHandID = controllerlink.GetMainControllerIndex();
		if (Pvr_ControllerManager.SetControllerStateChangedEvent != null)
		{
			Pvr_ControllerManager.SetControllerStateChangedEvent(state);
		}
		if (Pvr_ControllerManager.PvrControllerStateChangedEvent != null)
		{
			Pvr_ControllerManager.PvrControllerStateChangedEvent(state);
		}
	}

	public void setControllerAbility(string data)
	{
		PLOG.I("PvrLog setControllerAbility" + data);
		if (Pvr_ControllerManager.SetControllerAbilityEvent != null)
		{
			Pvr_ControllerManager.SetControllerAbilityEvent(data);
		}
	}

	public void controllerThreadStartedCallback()
	{
		PLOG.I("PvrLog ThreadStartSuccess");
		GetCVControllerState();
		if (Pvr_ControllerManager.ControllerThreadStartedCallbackEvent != null)
		{
			Pvr_ControllerManager.ControllerThreadStartedCallbackEvent();
		}
		if (Pvr_ControllerManager.PvrServiceStartSuccessEvent != null)
		{
			Pvr_ControllerManager.PvrServiceStartSuccessEvent();
		}
	}

	public void controllerDeviceVersionCallback(string data)
	{
		PLOG.I("PvrLog VersionCallBack" + data);
		if (Pvr_ControllerManager.ControllerDeviceVersionCallbackEvent != null)
		{
			Pvr_ControllerManager.ControllerDeviceVersionCallbackEvent(data);
		}
	}

	public void controllerSnCodeCallback(string data)
	{
		PLOG.I("PvrLog SNCodeCallBack" + data);
		if (Pvr_ControllerManager.ControllerSnCodeCallbackEvent != null)
		{
			Pvr_ControllerManager.ControllerSnCodeCallbackEvent(data);
		}
	}

	public void controllerUnbindCallback(string status)
	{
		PLOG.I("PvrLog ControllerUnBindCallBack" + status);
		if (Pvr_ControllerManager.ControllerUnbindCallbackEvent != null)
		{
			Pvr_ControllerManager.ControllerUnbindCallbackEvent(status);
		}
	}

	public void controllerStationStatusCallback(string status)
	{
		PLOG.I("PvrLog StationStatusCallBack" + status);
		if (Pvr_ControllerManager.ControllerStationStatusCallbackEvent != null)
		{
			Pvr_ControllerManager.ControllerStationStatusCallbackEvent(status);
		}
	}

	public void controllerStationBusyCallback(string status)
	{
		PLOG.I("PvrLog StationBusyCallBack" + status);
		if (Pvr_ControllerManager.ControllerStationBusyCallbackEvent != null)
		{
			Pvr_ControllerManager.ControllerStationBusyCallbackEvent(status);
		}
	}

	public void controllerOTAStartCodeCallback(string data)
	{
		PLOG.I("PvrLog OTAUpdateCallBack" + data);
		if (Pvr_ControllerManager.ControllerOtaStartCodeCallbackEvent != null)
		{
			Pvr_ControllerManager.ControllerOtaStartCodeCallbackEvent(data);
		}
	}

	public void controllerDeviceVersionAndSNCallback(string data)
	{
		PLOG.I("PvrLog DeviceVersionAndSNCallback" + data);
		if (Pvr_ControllerManager.ControllerDeviceVersionAndSNCallbackEvent != null)
		{
			Pvr_ControllerManager.ControllerDeviceVersionAndSNCallbackEvent(data);
		}
	}

	public void controllerUniqueIDCallback(string data)
	{
		PLOG.I("PvrLog controllerUniqueIDCallback" + data);
		if (Pvr_ControllerManager.ControllerUniqueIDCallbackEvent != null)
		{
			Pvr_ControllerManager.ControllerUniqueIDCallbackEvent(data);
		}
	}

	public void controllerCombinedKeyUnbindCallback(string controllerSerialNum)
	{
		if (Pvr_ControllerManager.ControllerCombinedKeyUnbindCallbackEvent != null)
		{
			Pvr_ControllerManager.ControllerCombinedKeyUnbindCallbackEvent(controllerSerialNum);
		}
	}

	public void setupdateFailed()
	{
	}

	public void setupdateSuccess()
	{
	}

	public void setupdateProgress(string progress)
	{
	}

	public void setHbAutoConnectState(string state)
	{
		PLOG.I("PvrLog HBAutoConnectState" + state);
		controllerServicestate = true;
		if (Convert.ToInt16(state) == 0 && GetControllerConnectionState(0) == 0)
		{
			ShowToast(2);
		}
		if (Convert.ToInt16(state) == 2)
		{
			ShowToast(3);
		}
	}

	public void callbackControllerServiceState(string state)
	{
		PLOG.I("PvrLog HBServiceState" + state);
		controllerServicestate = true;
		if (Convert.ToInt16(state) == 0)
		{
			ShowToast(0);
		}
		if (Convert.ToInt16(state) == 1)
		{
			BindService();
		}
		if (Convert.ToInt16(state) == 2)
		{
			ShowToast(1);
		}
	}

	public void changeMainControllerCallback(string index)
	{
		PLOG.I("PvrLog MainControllerCallBack" + index);
		controllerlink.mainHandID = Convert.ToInt16(index);
		if (Pvr_ControllerManager.ChangeMainControllerCallBackEvent != null)
		{
			Pvr_ControllerManager.ChangeMainControllerCallBackEvent(index);
		}
	}

	public void changeHandnessCallback(string index)
	{
		PLOG.I("PvrLog changeHandnessCallback" + index);
		controllerlink.handness = (Pvr_Controller.UserHandNess)Convert.ToInt16(index);
		if (Pvr_ControllerManager.ChangeHandNessCallBackEvent != null)
		{
			Pvr_ControllerManager.ChangeHandNessCallBackEvent(index);
		}
	}

	private void ShowToast(int type)
	{
		if (toast != null)
		{
			switch (type)
			{
			case 0:
				toast.text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("servicetip0");
				Invoke("HideToast", 5f);
				break;
			case 1:
				toast.text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("servicetip1");
				Invoke("HideToast", 5f);
				break;
			case 2:
				toast.text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("servicetip2");
				AutoConnectHbController(6000);
				Invoke("HideToast", 5f);
				break;
			case 3:
				toast.text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("servicetip3");
				AutoConnectHbController(6000);
				Invoke("HideToast", 5f);
				break;
			case 4:
				toast.text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("servicetip4");
				Invoke("HideToast", 10f);
				break;
			}
		}
	}

	private void HideToast()
	{
		if (toast != null)
		{
			toast.text = "";
		}
	}

	private void CheckControllerService()
	{
		if (!controllerServicestate)
		{
			ShowToast(4);
		}
	}

	private void GetCVControllerState()
	{
		int controllerConnectionState = GetControllerConnectionState(0);
		int controllerConnectionState2 = GetControllerConnectionState(1);
		PLOG.I("PvrLog CVconnect" + controllerConnectionState + controllerConnectionState2);
		if (controllerConnectionState == -1 && controllerConnectionState2 == -1)
		{
			Invoke("GetCVControllerState", 0.02f);
		}
		if (controllerConnectionState != -1 && controllerConnectionState2 != -1)
		{
			controllerlink.controller0Connected = controllerConnectionState == 1;
			controllerlink.controller1Connected = controllerConnectionState2 == 1;
			if (!controllerlink.controller0Connected && controllerlink.controller1Connected && controllerlink.GetMainControllerIndex() == 0)
			{
				Controller.UPvr_SetMainHandNess(1);
			}
			if (controllerlink.controller0Connected || controllerlink.controller1Connected)
			{
				controllerlink.controllerType = controllerlink.GetControllerType();
			}
			controllerlink.mainHandID = controllerlink.GetMainControllerIndex();
			controllerlink.handness = (Pvr_Controller.UserHandNess)controllerlink.getHandness();
		}
	}

	private void SetSystemKey()
	{
		if (controllerlink.switchHomeKey && (Controller.UPvr_GetKeyLongPressed(0, Pvr_KeyCode.HOME) || Controller.UPvr_GetKeyLongPressed(1, Pvr_KeyCode.HOME)))
		{
			if (Pvr_UnitySDKManager.SDK.HmdOnlyrot)
			{
				Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(1, 0);
			}
			else if (controllerlink.trackingmode == 0 || controllerlink.trackingmode == 1)
			{
				Pvr_UnitySDKSensor.Instance.ResetUnitySDKSensor();
			}
			else
			{
				Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(1, 1);
			}
			if (Pvr_UnitySDKManager.SDK.ControllerOnlyrot || (controllerlink.controller0Connected && Controller.UPvr_GetControllerPOS(0).Equals(Vector3.zero)) || (controllerlink.controller1Connected && Controller.UPvr_GetControllerPOS(1).Equals(Vector3.zero)))
			{
				if (Controller.UPvr_GetKeyLongPressed(0, Pvr_KeyCode.HOME))
				{
					ResetController(0);
				}
				if (Controller.UPvr_GetKeyLongPressed(1, Pvr_KeyCode.HOME))
				{
					ResetController(1);
				}
			}
		}
		if (controllerlink.picoDevice)
		{
			if (controllerlink.switchHomeKey && (Controller.UPvr_GetKeyClick(0, Pvr_KeyCode.HOME) || (Controller.UPvr_GetKeyClick(1, Pvr_KeyCode.HOME) && !stopConnect)))
			{
				controllerlink.RebackToLauncher();
			}
			if (Controller.UPvr_GetKeyClick(0, Pvr_KeyCode.VOLUMEUP) || Controller.UPvr_GetKeyClick(1, Pvr_KeyCode.VOLUMEUP))
			{
				controllerlink.TurnUpVolume();
			}
			if (Controller.UPvr_GetKeyClick(0, Pvr_KeyCode.VOLUMEDOWN) || Controller.UPvr_GetKeyClick(1, Pvr_KeyCode.VOLUMEDOWN))
			{
				controllerlink.TurnDownVolume();
			}
			if (!Controller.UPvr_GetKey(0, Pvr_KeyCode.VOLUMEUP) && !Controller.UPvr_GetKey(0, Pvr_KeyCode.VOLUMEDOWN) && !Controller.UPvr_GetKey(1, Pvr_KeyCode.VOLUMEUP) && !Controller.UPvr_GetKey(1, Pvr_KeyCode.VOLUMEDOWN))
			{
				cTime = 1f;
			}
			if (Controller.UPvr_GetKey(0, Pvr_KeyCode.VOLUMEUP) || Controller.UPvr_GetKey(1, Pvr_KeyCode.VOLUMEUP))
			{
				cTime -= Time.deltaTime;
				if (cTime <= 0f)
				{
					cTime = 0.2f;
					controllerlink.TurnUpVolume();
				}
			}
			if (!Controller.UPvr_GetKey(0, Pvr_KeyCode.HOME) && !Controller.UPvr_GetKey(1, Pvr_KeyCode.HOME) && (Controller.UPvr_GetKey(0, Pvr_KeyCode.VOLUMEDOWN) || Controller.UPvr_GetKey(1, Pvr_KeyCode.VOLUMEDOWN)))
			{
				cTime -= Time.deltaTime;
				if (cTime <= 0f)
				{
					cTime = 0.2f;
					controllerlink.TurnDownVolume();
				}
			}
		}
		if (controllerlink.goblinserviceStarted && Controller.UPvr_GetKey(0, Pvr_KeyCode.HOME) && Controller.UPvr_GetKey(0, Pvr_KeyCode.VOLUMEDOWN) && !stopConnect)
		{
			disConnectTime += Time.deltaTime;
			if ((double)disConnectTime > 1.0)
			{
				DisConnectBLE();
				controllerlink.hummingBirdMac = "";
				stopConnect = true;
				disConnectTime = 0f;
			}
		}
	}

	private void TransformData(ControllerHand hand, int handId, int[] data)
	{
		keyOffset = ((handId == 1) ? 67 : 0);
		hand.TouchPadPosition.x = data[keyOffset];
		hand.TouchPadPosition.y = data[5 + keyOffset];
		TransSingleKey(hand.Home, 10 + keyOffset, data);
		TransSingleKey(hand.App, 15 + keyOffset, data);
		TransSingleKey(hand.Touch, 20 + keyOffset, data);
		TransSingleKey(hand.VolumeUp, 25 + keyOffset, data);
		TransSingleKey(hand.VolumeDown, 30 + keyOffset, data);
		TransSingleKey(hand.Trigger, 35 + keyOffset, data);
		if (controllerlink.goblinserviceStarted && !controllerlink.neoserviceStarted)
		{
			hand.TriggerNum = controllerlink.GetHBKeyValue();
		}
		if (!controllerlink.goblinserviceStarted && controllerlink.neoserviceStarted)
		{
			hand.TriggerNum = controllerlink.GetCVTriggerValue(handId);
		}
		hand.Battery = data[40 + keyOffset];
		if (data.Length == 47)
		{
			hand.SwipeDirection = (SwipeDirection)data[45];
			hand.TouchPadClick = (TouchPadClick)data[46];
		}
		else
		{
			switch (handId)
			{
			case 0:
				TransSingleKey(hand.X, 45 + keyOffset, data);
				TransSingleKey(hand.Y, 50 + keyOffset, data);
				TransSingleKey(hand.Left, 60 + keyOffset, data);
				break;
			case 1:
				TransSingleKey(hand.A, 45 + keyOffset, data);
				TransSingleKey(hand.B, 50 + keyOffset, data);
				TransSingleKey(hand.Right, 55 + keyOffset, data);
				break;
			}
			hand.SwipeDirection = (SwipeDirection)data[65 + keyOffset];
			hand.TouchPadClick = (TouchPadClick)data[66 + keyOffset];
		}
		hand.GripValue = controllerlink.GetNeo3GripValue(handId);
		TransformTouchData(hand, handId, controllerlink.GetNeo3TouchData(handId));
	}

	private void TransSingleKey(PvrControllerKey key, int beginIndex, int[] data)
	{
		key.State = Convert.ToBoolean(data[beginIndex]);
		key.PressedDown = Convert.ToBoolean(data[beginIndex + 1]);
		key.PressedUp = Convert.ToBoolean(data[beginIndex + 2]);
		key.LongPressed = Convert.ToBoolean(data[beginIndex + 3]);
		key.Click = Convert.ToBoolean(data[beginIndex + 4]);
	}

	private void TransformTouchData(ControllerHand hand, int handId, int[] data)
	{
		switch (handId)
		{
		case 0:
			TransSingleTouchValue(hand.X, 0, data);
			TransSingleTouchValue(hand.Y, 3, data);
			break;
		case 1:
			TransSingleTouchValue(hand.A, 0, data);
			TransSingleTouchValue(hand.B, 3, data);
			break;
		}
		TransSingleTouchValue(hand.Touch, 6, data);
		TransSingleTouchValue(hand.Trigger, 9, data);
		TransSingleTouchValue(hand.Thumbrest, 12, data);
	}

	private void TransSingleTouchValue(PvrControllerKey key, int beginIndex, int[] data)
	{
		key.Touch = Convert.ToBoolean(data[beginIndex]);
		key.TouchDown = Convert.ToBoolean(data[beginIndex + 1]);
		key.TouchUp = Convert.ToBoolean(data[beginIndex + 2]);
	}
}
public class Pvr_ControllerModuleInit : MonoBehaviour
{
	public ControllerVariety Variety;

	public bool IsCustomModel;

	[SerializeField]
	private GameObject dot;

	[SerializeField]
	private GameObject rayLine;

	[SerializeField]
	private GameObject controller;

	private bool moduleState = true;

	private void Awake()
	{
		if (Pvr_ControllerManager.Instance.LengthAdaptiveRay)
		{
			rayLine = base.transform.GetComponentInChildren<LineRenderer>(includeInactive: true).gameObject;
			rayLine.GetComponent<LineRenderer>().startWidth = 0.003f;
			rayLine.GetComponent<LineRenderer>().endWidth = 0.0015f;
		}
	}

	private void OnDestroy()
	{
	}

	private void ServiceStartSuccess()
	{
		RefreshRay();
	}

	private void ControllerStateChanged(string data)
	{
		if (Pvr_ControllerManager.controllerlink.controller0Connected || Pvr_ControllerManager.controllerlink.controller1Connected)
		{
			moduleState = true;
			controller.transform.localScale = Vector3.one;
		}
		RefreshRay();
	}

	private void MainControllerIDChanged(string data)
	{
		RefreshRay();
	}

	private void RefreshRay()
	{
		if (Variety == ControllerVariety.Controller0)
		{
			StartCoroutine(ShowOrHideRay(0));
		}
		if (Variety == ControllerVariety.Controller1)
		{
			StartCoroutine(ShowOrHideRay(1));
		}
	}

	private IEnumerator ShowOrHideRay(int id)
	{
		yield return null;
		yield return null;
		if (moduleState)
		{
			bool active = Controller.UPvr_GetMainHandNess() == id && Controller.UPvr_GetControllerState(id) == ControllerState.Connected;
			dot.SetActive(active);
			rayLine.SetActive(active);
		}
	}

	public void ForceHideOrShow(bool state)
	{
		dot.SetActive(state);
		rayLine.SetActive(state);
		controller.transform.localScale = (state ? Vector3.one : Vector3.zero);
		moduleState = state;
	}

	public void UpdateRay()
	{
		if (!Pvr_ControllerManager.Instance.LengthAdaptiveRay)
		{
			return;
		}
		bool flag = false;
		flag = ((Pvr_ControllerManager.controllerlink.controller0Connected || Pvr_ControllerManager.controllerlink.controller1Connected) ? true : false);
		if (flag && rayLine != null && rayLine.gameObject.activeSelf)
		{
			if (Controller.UPvr_GetDeviceType() == 1)
			{
				rayLine.GetComponent<LineRenderer>().SetPosition(0, base.transform.TransformPoint(0f, 0f, 0.058f));
			}
			else
			{
				rayLine.GetComponent<LineRenderer>().SetPosition(0, base.transform.TransformPoint(0f, 0.009f, 0.055f));
			}
			rayLine.GetComponent<LineRenderer>().SetPosition(1, dot.transform.position);
		}
	}
}
public class Pvr_ControllerPower : MonoBehaviour
{
	[SerializeField]
	private Sprite power1;

	[SerializeField]
	private Sprite power2;

	[SerializeField]
	private Sprite power3;

	[SerializeField]
	private Sprite power4;

	[SerializeField]
	private Sprite power5;

	[HideInInspector]
	public ControllerVariety variety;

	[HideInInspector]
	public ControllerDevice currentDevice;

	private Image powerImage;

	private int powerValue;

	private float power;

	private void Start()
	{
		powerImage = base.transform.GetComponent<Image>();
		powerValue = -1;
		variety = base.transform.GetComponentInParent<Pvr_ControllerModuleInit>().Variety;
		currentDevice = base.transform.GetComponentInParent<Pvr_ControllerVisual>().currentDevice;
	}

	private void Update()
	{
		RefreshPower((variety != 0) ? 1 : 0);
	}

	private void RefreshPower(int hand)
	{
		if (powerValue != Controller.UPvr_GetControllerPower(hand))
		{
			switch (Controller.UPvr_GetControllerPower(hand))
			{
			case 1:
				powerImage.sprite = power1;
				powerImage.color = Color.red;
				break;
			case 2:
				powerImage.sprite = power2;
				powerImage.color = Color.white;
				break;
			case 3:
				powerImage.sprite = power3;
				powerImage.color = Color.white;
				break;
			case 4:
				powerImage.sprite = power4;
				powerImage.color = Color.white;
				break;
			case 5:
				powerImage.sprite = power5;
				powerImage.color = Color.white;
				break;
			default:
				powerImage.sprite = power1;
				powerImage.color = Color.white;
				break;
			}
			powerValue = Controller.UPvr_GetControllerPower(hand);
		}
	}
}
public class Pvr_ControllerVisual : MonoBehaviour
{
	public ControllerDevice currentDevice;

	public Texture2D m_idle;

	public Texture2D m_app;

	public Texture2D m_home;

	public Texture2D m_touchpad;

	public Texture2D m_volUp;

	public Texture2D m_volDn;

	public Texture2D m_trigger;

	public Texture2D m_a;

	public Texture2D m_b;

	public Texture2D m_x;

	public Texture2D m_y;

	public Texture2D m_grip;

	private Renderer controllerRenderMat;

	[HideInInspector]
	public ControllerVariety variety;

	private void Awake()
	{
		controllerRenderMat = GetComponent<Renderer>();
	}

	private void Start()
	{
		variety = base.transform.GetComponentInParent<Pvr_ControllerModuleInit>().Variety;
	}

	private void Update()
	{
		ChangeKeyEffects((variety != 0) ? 1 : 0);
	}

	private void ChangeKeyEffects(int hand)
	{
		if (Controller.UPvr_GetKey(hand, Pvr_KeyCode.TOUCHPAD))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_touchpad);
		}
		else if (Controller.UPvr_GetKey(hand, Pvr_KeyCode.APP))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_app);
		}
		else if (Controller.UPvr_GetKey(hand, Pvr_KeyCode.HOME))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_home);
		}
		else if (Controller.UPvr_GetKey(hand, Pvr_KeyCode.VOLUMEUP))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_volUp);
		}
		else if (Controller.UPvr_GetKey(hand, Pvr_KeyCode.VOLUMEDOWN))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_volDn);
		}
		else if (Controller.UPvr_GetControllerTriggerValue(hand) > 0 || Controller.UPvr_GetKey(hand, Pvr_KeyCode.TRIGGER))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_trigger);
		}
		else if (Controller.UPvr_GetKey(hand, Pvr_KeyCode.X))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_x);
		}
		else if (Controller.UPvr_GetKey(hand, Pvr_KeyCode.Y))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_y);
		}
		else if (Controller.UPvr_GetKey(hand, Pvr_KeyCode.A))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_a);
		}
		else if (Controller.UPvr_GetKey(hand, Pvr_KeyCode.B))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_b);
		}
		else if (Controller.UPvr_GetKey(hand, Pvr_KeyCode.Left) || Controller.UPvr_GetKey(hand, Pvr_KeyCode.Right))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_grip);
		}
		else if (controllerRenderMat.material.GetTexture("_MainTex") != m_idle)
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_idle);
		}
	}
}
public class Pvr_ToolTips : MonoBehaviour
{
	public enum TipBtn
	{
		app,
		touchpad,
		home,
		volup,
		voldown,
		trigger,
		grip
	}

	private ControllerDevice currentDevice;

	private float tipsAlpha;

	public static Pvr_ToolTips tooltips;

	public void ChangeTipsText(TipBtn tip, string key)
	{
		switch (tip)
		{
		case TipBtn.app:
			base.transform.Find("apptip/btn/Text").GetComponent<Text>().text = key;
			break;
		case TipBtn.touchpad:
			base.transform.Find("touchtip/btn/Text").GetComponent<Text>().text = key;
			break;
		case TipBtn.home:
			base.transform.Find("hometip/btn/Text").GetComponent<Text>().text = key;
			break;
		case TipBtn.volup:
			base.transform.Find("volup/btn/Text").GetComponent<Text>().text = key;
			break;
		case TipBtn.voldown:
			base.transform.Find("voldown/btn/Text").GetComponent<Text>().text = key;
			break;
		case TipBtn.trigger:
			base.transform.Find("triggertip/btn/Text").GetComponent<Text>().text = key;
			break;
		case TipBtn.grip:
			base.transform.Find("grip/btn/Text").GetComponent<Text>().text = key;
			break;
		}
	}

	private void Awake()
	{
		tooltips = base.transform.GetComponent<Pvr_ToolTips>();
	}

	private void Update()
	{
		switch (currentDevice)
		{
		case ControllerDevice.Goblin:
		case ControllerDevice.G2:
			tipsAlpha = (330f - base.transform.parent.parent.parent.localRotation.eulerAngles.x) / 45f;
			if (base.transform.parent.parent.parent.localRotation.eulerAngles.x >= 270f && base.transform.parent.parent.parent.localRotation.eulerAngles.x <= 330f)
			{
				tipsAlpha = Mathf.Max(0f, tipsAlpha);
				tipsAlpha = ((tipsAlpha > 1f) ? 1f : tipsAlpha);
			}
			else
			{
				tipsAlpha = 0f;
			}
			GetComponent<CanvasGroup>().alpha = tipsAlpha;
			break;
		case ControllerDevice.Neo2:
		case ControllerDevice.Neo3:
			tipsAlpha = (330f - base.transform.parent.parent.parent.localRotation.eulerAngles.x) / 45f;
			if (base.transform.parent.parent.parent.localRotation.eulerAngles.x >= 270f && base.transform.parent.parent.parent.localRotation.eulerAngles.x <= 330f)
			{
				tipsAlpha = Mathf.Max(0f, tipsAlpha);
				tipsAlpha = ((tipsAlpha > 1f) ? 1f : tipsAlpha);
			}
			else
			{
				tipsAlpha = 0f;
			}
			GetComponent<CanvasGroup>().alpha = tipsAlpha;
			break;
		case ControllerDevice.Neo:
			break;
		}
	}

	private void LoadTextFromJson()
	{
		currentDevice = base.transform.GetComponentInParent<Pvr_ControllerVisual>().currentDevice;
		base.transform.Find("apptip/btn/Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("apptip");
		base.transform.Find("touchtip/btn/Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("touchtip");
		base.transform.Find("hometip/btn/Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("hometip");
		Transform transform = base.transform.Find("volup/btn/Text");
		if (transform != null)
		{
			transform.GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("voluptip");
		}
		Transform transform2 = base.transform.Find("voldown/btn/Text");
		if (transform2 != null)
		{
			transform2.GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("voldowntip");
		}
		Transform transform3 = base.transform.Find("triggertip/btn/Text");
		if (transform3 != null)
		{
			transform3.GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("triggertip");
		}
		Transform transform4 = base.transform.Find("grip/btn/Text");
		if (transform4 != null)
		{
			transform4.GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("griptip");
		}
	}

	public static void RefreshTips()
	{
		if (tooltips != null)
		{
			tooltips.LoadTextFromJson();
		}
	}
}
public class Pvr_TouchPadScroll : MonoBehaviour
{
	private ScrollRect scrollRect;

	private bool isHoving;

	private int mainHand;

	private SwipeDirection direction;

	private Vector2 currPos;

	private Vector2 tarPos;

	private float lerpSpeed = 10f;

	private Transform tranViewport;

	private float ignoreDis = 3f;

	private Vector2 lastTouchDownPos;

	private Vector2 lastTouchUpPos;

	private bool isTouching;

	private bool isClosed = true;

	private Vector2 vecOrigin = Vector2.zero;

	private Vector2 vecOriginNeo2 = new Vector2(128f, 128f);

	private void Awake()
	{
		scrollRect = base.gameObject.GetComponent<ScrollRect>();
		tranViewport = base.transform.Find("Viewport");
	}

	private void Update()
	{
		Process();
		UpdateTargetPos();
		UpdatePos();
	}

	private bool IsControllerConnect()
	{
		mainHand = Controller.UPvr_GetMainHandNess();
		if (mainHand == 0 && Pvr_ControllerManager.controllerlink.controller0Connected)
		{
			return true;
		}
		if (mainHand == 1 && Pvr_ControllerManager.controllerlink.controller1Connected)
		{
			return true;
		}
		return false;
	}

	private void UpdateTargetPos()
	{
		if (Controller.UPvr_GetKey(0, Pvr_KeyCode.TOUCHPAD) || Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.TOUCHPAD))
		{
			ResetParameter();
		}
		else if (isHoving)
		{
			if (Pvr_ControllerManager.controllerlink.GetControllerType() == 3)
			{
				ComputeTouchPos();
			}
			else
			{
				ComputeRockerPos();
			}
			if ((currPos - tarPos).sqrMagnitude <= 10f)
			{
				isClosed = true;
			}
		}
	}

	private void ComputeTouchPos()
	{
		mainHand = Controller.UPvr_GetMainHandNess();
		currPos = scrollRect.content.localPosition;
		Vector2 vector = vecOrigin;
		if (mainHand == 0 && Pvr_ControllerManager.controllerlink.controller0Connected)
		{
			vector = Controller.UPvr_GetTouchPadPosition(mainHand);
		}
		if (mainHand == 1 && Pvr_ControllerManager.controllerlink.controller1Connected)
		{
			vector = Controller.UPvr_GetTouchPadPosition(mainHand);
		}
		if ((vector - vecOrigin).sqrMagnitude >= 1f)
		{
			if (!isTouching)
			{
				lastTouchDownPos = vector;
				isTouching = true;
			}
			lastTouchUpPos.x = vector.x;
			if (Mathf.Abs(lastTouchUpPos.x - lastTouchDownPos.x) > ignoreDis)
			{
				Vector2 vector2 = new Vector2((lastTouchUpPos.x - lastTouchDownPos.x) * 10f, 0f);
				lastTouchDownPos.x = lastTouchUpPos.x;
				if (isClosed)
				{
					tarPos = currPos + vector2;
					isClosed = false;
				}
				else
				{
					tarPos += vector2;
				}
			}
		}
		else
		{
			lastTouchDownPos = vecOrigin;
			lastTouchUpPos = vecOrigin;
			isTouching = false;
			if ((double)scrollRect.horizontalScrollbar.value >= 0.999 || (double)scrollRect.horizontalScrollbar.value <= 0.0001)
			{
				isClosed = true;
			}
		}
	}

	private void ComputeRockerPos()
	{
		mainHand = Controller.UPvr_GetMainHandNess();
		currPos = scrollRect.content.localPosition;
		Vector2 vector = vecOriginNeo2;
		if (mainHand == 0 && Pvr_ControllerManager.controllerlink.controller0Connected)
		{
			vector = Controller.UPvr_GetTouchPadPosition(mainHand);
		}
		if (mainHand == 1 && Pvr_ControllerManager.controllerlink.controller1Connected)
		{
			vector = Controller.UPvr_GetTouchPadPosition(mainHand);
		}
		if (VerifyNeo2TouchValid(vector) && (vector - vecOriginNeo2).sqrMagnitude >= 1f)
		{
			if (!isTouching)
			{
				lastTouchDownPos = vector;
				isTouching = true;
			}
			lastTouchUpPos.x = vector.x;
			if (Mathf.Abs(lastTouchUpPos.x - lastTouchDownPos.x) > ignoreDis)
			{
				Vector2 vector2 = new Vector2((lastTouchUpPos.x - lastTouchDownPos.x) * 10f, 0f);
				lastTouchDownPos.x = lastTouchUpPos.x;
				if (isClosed)
				{
					tarPos = currPos + vector2;
					isClosed = false;
				}
				else
				{
					tarPos += vector2;
				}
			}
		}
		else
		{
			lastTouchDownPos = vecOriginNeo2;
			lastTouchUpPos = vecOriginNeo2;
			isTouching = false;
			if ((double)scrollRect.horizontalScrollbar.value >= 0.999 || (double)scrollRect.horizontalScrollbar.value <= 0.0001)
			{
				isClosed = true;
			}
		}
	}

	private bool VerifyNeo2TouchValid(Vector2 nowTouchPos)
	{
		if (nowTouchPos.x > vecOriginNeo2.x && nowTouchPos.x > lastTouchDownPos.x)
		{
			return true;
		}
		if (nowTouchPos.x < vecOriginNeo2.x && nowTouchPos.x < lastTouchDownPos.x)
		{
			return true;
		}
		return false;
	}

	private void UpdatePos()
	{
		if (Controller.UPvr_GetKey(0, Pvr_KeyCode.TOUCHPAD) || Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.TOUCHPAD))
		{
			ResetParameter();
		}
		else if (!isClosed && IsControllerConnect())
		{
			if ((double)scrollRect.horizontalScrollbar.value >= 0.9999 && tarPos.x <= currPos.x)
			{
				isClosed = true;
				return;
			}
			if ((double)scrollRect.horizontalScrollbar.value <= 0.0001 && tarPos.x >= currPos.x)
			{
				isClosed = true;
				return;
			}
			currPos.x = Mathf.Lerp(currPos.x, tarPos.x, lerpSpeed * Time.deltaTime);
			currPos.y = Mathf.Lerp(currPos.y, tarPos.y, lerpSpeed * Time.deltaTime);
			scrollRect.content.localPosition = currPos;
		}
	}

	private void ResetParameter()
	{
		currPos = scrollRect.content.localPosition;
		tarPos = scrollRect.content.localPosition;
		isClosed = true;
	}

	private void Process()
	{
		for (int i = 0; i < Pvr_InputModule.pointers.Count; i++)
		{
			Pvr_UIPointer pvr_UIPointer = Pvr_InputModule.pointers[i];
			if (pvr_UIPointer.gameObject.activeInHierarchy && pvr_UIPointer.enabled)
			{
				isHoving = IsHovering(pvr_UIPointer);
			}
		}
	}

	private bool IsHovering(Pvr_UIPointer pointer)
	{
		if (!IsControllerConnect())
		{
			return false;
		}
		foreach (GameObject item in pointer.pointerEventData.hovered)
		{
			if (FindTree(item.transform))
			{
				mainHand = Controller.UPvr_GetMainHandNess();
				if (mainHand == 0 && Pvr_ControllerManager.controllerlink.controller0Connected)
				{
					return true;
				}
				if (mainHand == 1 && Pvr_ControllerManager.controllerlink.controller1Connected)
				{
					return true;
				}
			}
		}
		return false;
	}

	private bool FindTree(Transform tran)
	{
		if (tran == base.transform || tran == tranViewport)
		{
			return true;
		}
		if (tran.IsChildOf(tranViewport))
		{
			return true;
		}
		return false;
	}
}
public class Pvr_TouchVisual : MonoBehaviour
{
	[HideInInspector]
	public ControllerDevice currentDevice;

	[HideInInspector]
	public ControllerVariety variety;

	private MeshRenderer touchRenderer;

	private void Start()
	{
		variety = base.transform.GetComponentInParent<Pvr_ControllerModuleInit>().Variety;
		currentDevice = GetComponentInParent<Pvr_ControllerVisual>().currentDevice;
		touchRenderer = GetComponent<MeshRenderer>();
	}

	private void Update()
	{
		ChangeEffects((variety != 0) ? 1 : 0);
	}

	private void ChangeEffects(int hand)
	{
		ControllerDevice controllerDevice = currentDevice;
		if (controllerDevice == ControllerDevice.G2)
		{
			if (Controller.UPvr_IsTouching(0))
			{
				touchRenderer.enabled = true;
				base.transform.localPosition = new Vector3(1.3f - Controller.UPvr_GetTouchPadPosition(hand).x * 0.01f, 1.6f, -1.7f - Controller.UPvr_GetTouchPadPosition(hand).y * 0.01f);
			}
			else
			{
				touchRenderer.enabled = false;
			}
		}
	}
}
public class DemoController : MonoBehaviour
{
	public delegate void showLoadingEventHandler();

	private Callback callback;

	private GameObject msg;

	private Pvr_UnitySDKManager picoVrManager;

	private string currentOrderID;

	public GameObject loading;

	public GameObject BG;

	public GameObject InputPanel;

	public static showLoadingEventHandler showLoading;

	private void Awake()
	{
		UnityEngine.Debug.Log(loading.name);
		UnityEngine.Debug.Log(BG.name);
		showLoading = (showLoadingEventHandler)Delegate.Combine(showLoading, new showLoadingEventHandler(StopLoading));
		InputManager.doEnter = (InputManager.doEnterEventHandler)Delegate.Combine(InputManager.doEnter, new InputManager.doEnterEventHandler(DoPayByCode));
		currentOrderID = "";
	}

	private void Start()
	{
		msg = GameObject.Find("MassageInfo");
		InitDelegate();
		callback = new Callback();
		picoVrManager = GameObject.Find("Pvr_UnitySDK").GetComponent<Pvr_UnitySDKManager>();
		InputPanel.SetActive(value: false);
	}

	private void Update()
	{
		if (picoVrManager != null && (Input.GetKeyDown(KeyCode.Y) || Input.GetKeyDown(KeyCode.Joystick1Button2)))
		{
			UnityEngine.Debug.Log("update");
			Pvr_UnitySDKSensor.Instance.ResetUnitySDKSensor();
		}
		if (Input.GetKeyDown(KeyCode.Joystick1Button1) || Input.GetKeyDown(KeyCode.Escape))
		{
			if (InputPanel.activeInHierarchy)
			{
				InputPanel.SetActive(value: false);
			}
			else
			{
				UnityEngine.Application.Quit();
			}
		}
	}

	private void InitDelegate()
	{
		foreach (string item in new ArrayList { "Login", "GetUserAPI", "PayOne", "PayCode", "QueryOrder" })
		{
			GameObject btnObj = GameObject.Find(item);
			btnObj.GetComponent<Button>().onClick.AddListener(delegate
			{
				OnClick(btnObj);
			});
		}
	}

	private void OnClick(GameObject btnObj)
	{
		switch (btnObj.name)
		{
		case "Login":
			StartLoading();
			LoginSDK.Login();
			break;
		case "PayOne":
			CommonDic.getInstance().setParameters("subject", "game");
			CommonDic.getInstance().setParameters("body", "gamePay");
			CommonDic.getInstance().setParameters("order_id", getRamdomTestOrderID());
			CommonDic.getInstance().setParameters("total", "1");
			CommonDic.getInstance().setParameters("goods_tag", "game");
			CommonDic.getInstance().setParameters("notify_url", "www.picovr.com");
			CommonDic.getInstance().setParameters("pay_code", "");
			StartLoading();
			PicoPaymentSDK.Pay(CommonDic.getInstance().PayOrderString());
			break;
		case "PayCode":
			InputPanel.SetActive(value: true);
			break;
		case "QueryOrder":
			StartLoading();
			PicoPaymentSDK.QueryOrder(currentOrderID);
			break;
		case "GetUserAPI":
			StartLoading();
			LoginSDK.GetUserAPI();
			break;
		}
	}

	public string getRamdomTestOrderID()
	{
		currentOrderID = (UnityEngine.Random.value * 65535f).ToString();
		return currentOrderID;
	}

	private void StartLoading()
	{
		loading.SetActive(value: true);
		BG.SetActive(value: true);
	}

	public void StopLoading()
	{
		if ((bool)loading && (bool)BG)
		{
			loading.SetActive(value: false);
			BG.SetActive(value: false);
		}
		else
		{
			UnityEngine.Debug.LogError("用户自定义，非演示demo");
		}
	}

	public void DoPayByCode()
	{
		CommonDic.getInstance().setParameters("subject", "game");
		CommonDic.getInstance().setParameters("body", "gamePay");
		CommonDic.getInstance().setParameters("order_id", getRamdomTestOrderID());
		CommonDic.getInstance().setParameters("total", "0");
		CommonDic.getInstance().setParameters("goods_tag", "game");
		CommonDic.getInstance().setParameters("notify_url", "www.picovr.com");
		CommonDic.getInstance().setParameters("pay_code", GameObject.Find("CodeText").GetComponent<Text>().text);
		UnityEngine.Debug.Log("商品码支付" + GameObject.Find("CodeText").GetComponent<Text>().text);
		StartLoading();
		GameObject.Find("CodeText").GetComponent<Text>().text = "";
		InputPanel.SetActive(value: false);
		PicoPaymentSDK.Pay(CommonDic.getInstance().PayOrderString());
	}

	private bool VerifyLocalToken()
	{
		if (CommonDic.getInstance().access_token.Equals(""))
		{
			GameObject.Find("MassageInfo").GetComponent<Text>().text = "{code:exception,msg:请先登录}";
			currentOrderID = "";
			StopLoading();
			return false;
		}
		return true;
	}
}
public class LoadingRatation : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
		base.gameObject.transform.Rotate(new Vector3(0f, 0f, -4f));
	}
}
public class InputManager : MonoBehaviour
{
	public delegate void doEnterEventHandler();

	public static doEnterEventHandler doEnter;

	private StringBuilder sb = new StringBuilder();

	private ArrayList btnsName = new ArrayList();

	private GameObject enter;

	private void Awake()
	{
		InitKeyBoard();
	}

	private void Start()
	{
	}

	private void Update()
	{
	}

	private void InitKeyBoard()
	{
		btnsName.Add("1");
		btnsName.Add("2");
		btnsName.Add("3");
		btnsName.Add("4");
		btnsName.Add("5");
		btnsName.Add("6");
		btnsName.Add("7");
		btnsName.Add("8");
		btnsName.Add("9");
		btnsName.Add("0");
		btnsName.Add("Q");
		btnsName.Add("W");
		btnsName.Add("E");
		btnsName.Add("R");
		btnsName.Add("T");
		btnsName.Add("Y");
		btnsName.Add("U");
		btnsName.Add("I");
		btnsName.Add("O");
		btnsName.Add("P");
		btnsName.Add("A");
		btnsName.Add("S");
		btnsName.Add("D");
		btnsName.Add("F");
		btnsName.Add("G");
		btnsName.Add("H");
		btnsName.Add("J");
		btnsName.Add("K");
		btnsName.Add("L");
		btnsName.Add("Z");
		btnsName.Add("X");
		btnsName.Add("C");
		btnsName.Add("V");
		btnsName.Add("B");
		btnsName.Add("N");
		btnsName.Add("M");
		btnsName.Add("Clear");
		btnsName.Add("Capslock");
		btnsName.Add("Enter");
		foreach (string item in btnsName)
		{
			GameObject btnObj = GameObject.Find(item);
			btnObj.GetComponent<Button>().onClick.AddListener(delegate
			{
				OnClick(btnObj);
			});
		}
		enter = GameObject.Find("Enter");
		enter.SetActive(sb.Length > 0);
	}

	private void OnClick(GameObject btnObj)
	{
		if (btnObj.name.Equals("Capslock"))
		{
			if (GameObject.Find("Q").transform.GetChild(0).GetComponent<Text>().text.Equals("Q"))
			{
				DoCapslock(IsUpper: true);
			}
			else
			{
				DoCapslock(IsUpper: false);
			}
		}
		else if (btnObj.name.Equals("Clear"))
		{
			GameObject.Find("CodeText").GetComponent<Text>().text = "";
			ClearBuffer();
		}
		else if (btnObj.name.Equals("Enter"))
		{
			ClearBuffer();
			doEnter();
		}
		else
		{
			EnterChar(btnObj.transform.GetChild(0).GetComponent<Text>().text);
		}
	}

	private void EnterChar(string s)
	{
		sb.Append(s);
		GameObject.Find("CodeText").GetComponent<Text>().text = sb.ToString();
		enter.SetActive(sb.Length > 0);
	}

	private void DoCapslock(bool IsUpper)
	{
		if (IsUpper)
		{
			foreach (string item in btnsName)
			{
				Text component = GameObject.Find(item).transform.GetChild(0).GetComponent<Text>();
				component.text = component.text.ToLower();
			}
			return;
		}
		foreach (string item2 in btnsName)
		{
			Text component2 = GameObject.Find(item2).transform.GetChild(0).GetComponent<Text>();
			component2.text = component2.text.ToUpper();
		}
	}

	private void ClearBuffer()
	{
		sb.Remove(0, sb.Length);
		enter.SetActive(sb.Length > 0);
	}
}
public class Callback : MonoBehaviour
{
	private static string IS_SUCCESS = "isSuccess";

	private static string MSG = "msg";

	private static string CODE = "code";

	public void LoginCallback(string LoginInfo)
	{
		JsonData jsonData = JsonMapper.ToObject(LoginInfo);
		SetMassage(LoginInfo);
		DemoController.showLoading();
		if (jsonData[IS_SUCCESS] != null)
		{
			CommonDic.getInstance().isSuccess = jsonData[IS_SUCCESS].ToString();
		}
		if (jsonData[MSG] != null)
		{
			CommonDic.getInstance().loginMsg = jsonData[MSG].ToString();
		}
		UnityEngine.Debug.Log("调用login回调:" + LoginInfo);
	}

	public void QueryOrPayCallback(string queryOrPayInfo)
	{
		JsonData jsonData = JsonMapper.ToObject(queryOrPayInfo);
		if (jsonData[CODE] != null)
		{
			CommonDic.getInstance().code = jsonData["code"].ToString();
		}
		if (jsonData[MSG] != null)
		{
			CommonDic.getInstance().msg = jsonData["msg"].ToString();
		}
		if (jsonData != null)
		{
			CommonDic.getInstance().order_info = jsonData[1].ToString();
		}
		SetMassage(queryOrPayInfo);
		DemoController.showLoading();
		UnityEngine.Debug.Log("调用pay回调:" + queryOrPayInfo);
	}

	public void UserInfoCallback(string userInfo)
	{
		CommonDic.getInstance().user_info = userInfo;
		SetMassage(userInfo);
		DemoController.showLoading();
		UnityEngine.Debug.Log("调用userInfo回调:" + userInfo);
	}

	public void SetMassage(string massage)
	{
		if (!GetCurrentGameObject().Equals(null))
		{
			GetCurrentGameObject().GetComponent<Text>().text = massage;
		}
		else
		{
			UnityEngine.Debug.LogError("无接收该Message的控件");
		}
	}

	public GameObject GetCurrentGameObject()
	{
		return GameObject.Find("MassageInfo");
	}

	public void ActivityForResultCallback(string activity)
	{
		PicoPaymentSDK.jo.Call("authCallback", activity);
	}
}
public class CommonDic
{
	private static CommonDic dic;

	private static Dictionary<string, string> mydic;

	private string _app_ID;

	private string _app_Key;

	private string _user_token;

	private string _access_token = "";

	private string _open_id;

	private string _refresh_token;

	private string _expires_in;

	private string _user_info;

	private string _subject;

	private string _body;

	private string _order_id;

	private string _total;

	private string _goods_tag;

	private string _notify_url;

	private string _trade_type;

	private string _pay_code = "";

	private string _order_info;

	private string _code;

	private string _msg = "null";

	private string _merchant_ID;

	private string _payKey;

	private string _isSuucess;

	private string _loginMsg;

	public string subject
	{
		get
		{
			return _subject;
		}
		set
		{
			_subject = value;
		}
	}

	public string body
	{
		get
		{
			return _body;
		}
		set
		{
			_body = value;
		}
	}

	public string order_id
	{
		get
		{
			return _order_id;
		}
		set
		{
			_order_id = value;
		}
	}

	public string total
	{
		get
		{
			return _total;
		}
		set
		{
			_total = value;
		}
	}

	public string goods_tag
	{
		get
		{
			return _goods_tag;
		}
		set
		{
			_goods_tag = value;
		}
	}

	public string notify_url
	{
		get
		{
			return _notify_url;
		}
		set
		{
			_notify_url = value;
		}
	}

	public string pay_code
	{
		get
		{
			return _pay_code;
		}
		set
		{
			_pay_code = value;
		}
	}

	public string trade_type
	{
		get
		{
			return _trade_type;
		}
		set
		{
			_trade_type = value;
		}
	}

	public string user_token
	{
		get
		{
			return _user_token;
		}
		set
		{
			_user_token = value;
		}
	}

	public string access_token
	{
		get
		{
			return _access_token;
		}
		set
		{
			_access_token = value;
		}
	}

	public string open_id
	{
		get
		{
			return _open_id;
		}
		set
		{
			_open_id = value;
		}
	}

	public string refresh_token
	{
		get
		{
			return _refresh_token;
		}
		set
		{
			_refresh_token = value;
		}
	}

	public string expires_in
	{
		get
		{
			return _expires_in;
		}
		set
		{
			_expires_in = value;
		}
	}

	public string isSuccess
	{
		get
		{
			return _isSuucess;
		}
		set
		{
			_isSuucess = value;
		}
	}

	public string loginMsg
	{
		get
		{
			return _loginMsg;
		}
		set
		{
			_loginMsg = value;
		}
	}

	public string user_info
	{
		get
		{
			return _user_info;
		}
		set
		{
			_user_info = value;
		}
	}

	public string order_info
	{
		get
		{
			return _order_info;
		}
		set
		{
			_order_info = value;
		}
	}

	public string code
	{
		get
		{
			return _code;
		}
		set
		{
			_code = value;
		}
	}

	public string msg
	{
		get
		{
			return _msg;
		}
		set
		{
			_msg = value;
		}
	}

	public string app_ID
	{
		get
		{
			return _app_ID;
		}
		set
		{
			_app_ID = value;
		}
	}

	public string app_Key
	{
		get
		{
			return _app_Key;
		}
		set
		{
			_app_Key = value;
		}
	}

	public string merchant_ID
	{
		get
		{
			return _merchant_ID;
		}
		set
		{
			_merchant_ID = value;
		}
	}

	public string paykey
	{
		get
		{
			return _payKey;
		}
		set
		{
			_payKey = value;
		}
	}

	public static CommonDic getInstance()
	{
		if (dic == null)
		{
			dic = new CommonDic();
		}
		if (mydic == null)
		{
			mydic = new Dictionary<string, string>();
			InitDicData(mydic);
		}
		return dic;
	}

	public Dictionary<string, string> getDic()
	{
		return mydic;
	}

	public void setParameters(string name, string value)
	{
		if (name.Equals("subject"))
		{
			subject = value;
		}
		if (name.Equals("body"))
		{
			body = value;
		}
		if (name.Equals("order_id"))
		{
			order_id = value;
		}
		if (name.Equals("total"))
		{
			total = value;
		}
		if (name.Equals("goods_tag"))
		{
			goods_tag = value;
		}
		if (name.Equals("notify_url"))
		{
			notify_url = value;
		}
		if (name.Equals("trade_type"))
		{
			trade_type = value;
		}
		if (name.Equals("pay_code"))
		{
			pay_code = value;
		}
	}

	public string PayOrderString()
	{
		return JsonMapper.ToJson(getInstance());
	}

	public static void InitDicData(Dictionary<string, string> mydic)
	{
		mydic.Add("00000", "网络异常");
		mydic.Add("10000", "登录成功");
		mydic.Add("10001", "用户未登陆");
		mydic.Add("10002", "请输入正确金额");
		mydic.Add("10003", "登陆过期，请重新登陆");
		mydic.Add("11000", "商户验证成功");
		mydic.Add("11001", "商户验证失败");
		mydic.Add("11002", "用户验证参数错误或请求过期");
		mydic.Add("11003", "商户未验证");
		mydic.Add("12000", "支付成功");
		mydic.Add("12001", "支付失败");
		mydic.Add("12003", "P币不足");
		mydic.Add("12004", "余额可用");
		mydic.Add("13000", "生成订单");
		mydic.Add("13001", "获取数据失败");
		mydic.Add("13002", "生成订单失败");
		mydic.Add("14000", "查询订单成功");
		mydic.Add("14001", "订单不存在/有误");
		mydic.Add("14002", "用户取消支付操作");
		mydic.Add("15000", "未输入商品信息");
		mydic.Add("15001", "未输入预付ID");
		mydic.Add("15002", "请输入Pico支付订单号或商户订单号");
		mydic.Add("NOAUTH", "商户无此接口权限");
		mydic.Add("SYSTEMERROR", "系统错误");
		mydic.Add("APP_ID_NOT_EXIST", "APP_ID不存在");
		mydic.Add("MCHID_NOT_EXIST", "MCHID不存在");
		mydic.Add("APP_ID_MCHID_NOT_MATCH", "app_id和mch_id不匹配ID");
		mydic.Add("LACK_PARAMS", "缺少参数");
		mydic.Add("SIGNERROR", "签名错误");
		mydic.Add("NO_DATA", "没有查询到数据");
	}
}
public class LoginSDK
{
	public static void Login()
	{
		PicoPaymentSDK.Login();
	}

	public static void GetUserAPI()
	{
		PicoPaymentSDK.GetUserAPI();
	}
}
public class PicoPaymentSDK
{
	private static AndroidJavaObject _jo = new AndroidJavaObject("com.pico.loginpaysdk.UnityInterface");

	public static AndroidJavaObject jo
	{
		get
		{
			return _jo;
		}
		set
		{
			_jo = value;
		}
	}

	public static void Login()
	{
		AndroidJavaObject @static = new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
		jo.Call("init", @static);
		jo.Call("authSSO");
	}

	public static void Pay(string payOrderJson)
	{
		AndroidJavaObject @static = new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
		jo.Call("init", @static);
		jo.Call("pay", payOrderJson);
	}

	public static void QueryOrder(string orderId)
	{
		AndroidJavaObject @static = new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
		jo.Call("init", @static);
		jo.Call("queryOrder", orderId);
	}

	public static void GetUserAPI()
	{
		AndroidJavaObject @static = new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
		jo.Call("init", @static);
		jo.Call("getUserAPI");
	}
}
public class Pvr_ToBService : MonoBehaviour
{
	public Text deviceInfoText;

	private void Awake()
	{
		InitToBService();
	}

	private void Start()
	{
		BindToBService();
	}

	private void OnDestory()
	{
		UnBindToBService();
	}

	private void InitToBService()
	{
		ToBService.UPvr_InitToBService();
		ToBService.UPvr_SetUnityObjectName(base.name);
	}

	private void BindToBService()
	{
		ToBService.UPvr_BindToBService();
	}

	private void UnBindToBService()
	{
		ToBService.UPvr_UnBindToBService();
	}

	private void BoolCallback(string value)
	{
		if (ToBService.BoolCallback != null)
		{
			ToBService.BoolCallback(bool.Parse(value));
		}
		ToBService.BoolCallback = null;
	}

	private void IntCallback(string value)
	{
		if (ToBService.IntCallback != null)
		{
			ToBService.IntCallback(int.Parse(value));
		}
		ToBService.IntCallback = null;
	}

	private void LongCallback(string value)
	{
		if (ToBService.LongCallback != null)
		{
			ToBService.LongCallback(int.Parse(value));
		}
		ToBService.LongCallback = null;
	}

	public void StateGetDeviceInfo()
	{
		string text = ToBService.UPvr_StateGetDeviceInfo(PBS_SystemInfoEnum.PUI_VERSION);
		deviceInfoText.text = "PUI_VERSION:" + text;
	}

	public void ControlSetDeviceAction()
	{
		ToBService.UPvr_ControlSetDeviceAction(PBS_DeviceControlEnum.DEVICE_CONTROL_SHUTDOWN, ControlSetDeviceActionCallBack);
	}

	private void ControlSetDeviceActionCallBack(int value)
	{
		UnityEngine.Debug.Log("ControlSetDeviceActionCallBack : " + value);
	}

	public void AppManager()
	{
		ToBService.UPvr_ControlAPPManger(PBS_PackageControlEnum.PACKAGE_SILENCE_UNINSTALL, "com.pico.ipd.test", AppManagerCallBack);
	}

	private void AppManagerCallBack(int value)
	{
		UnityEngine.Debug.Log("AppManagerCallBack : " + value);
	}
}
public class AchievementSample : MonoBehaviour
{
	public Text dataOutput;

	public InputField getDefinitionsByNameInputField;

	public InputField getProgressByNameInputField;

	public InputField unLockInputField;

	public InputField addCountInputField;

	public InputField addFieldsInputField;

	private void Start()
	{
		AchievementCore.RegisterNetwork();
	}

	private void OnDestroy()
	{
		AchievementCore.UnRegisterNetwork();
	}

	private void OnApplicationPause(bool pause)
	{
		if (!pause)
		{
			printOutputLine("Achievement Init");
			achievementInit();
		}
	}

	private void Update()
	{
		Pvr_UnitySDKAPI.Achievement.Request.RunCallbacks();
	}

	public void AsyncInitialize()
	{
		dataOutput.text = "> ";
		printOutputLine("AsyncInitialize");
		achievementInit();
	}

	public void GetDefinitionsByName()
	{
		dataOutput.text = "> ";
		printOutputLine("GetDefinitionsByName");
		string text = getDefinitionsByNameInputField.text;
		if (text != "")
		{
			string[] achievementNames = text.Split(',');
			getAchievementDefinition(achievementNames);
			getDefinitionsByNameInputField.text = "";
		}
		else
		{
			printOutputLine("Invalid Command");
		}
	}

	public void GetProgressByName()
	{
		dataOutput.text = "> ";
		printOutputLine("GetProgressByName");
		string text = getProgressByNameInputField.text;
		if (text != "")
		{
			string[] achievementNames = text.Split(',');
			getAchievementProgress(achievementNames);
			getProgressByNameInputField.text = "";
		}
		else
		{
			printOutputLine("Invalid Command");
		}
	}

	public void GetAllDefinitions()
	{
		dataOutput.text = "> ";
		printOutputLine("GetAllDefinitions");
		getAchievementAllDefinition();
	}

	public void GetAllProgress()
	{
		dataOutput.text = "> ";
		printOutputLine("GetAllProgress");
		getAchievementAllProgress();
	}

	public void UnLock()
	{
		dataOutput.text = "> ";
		printOutputLine("UnLock");
		string text = unLockInputField.text;
		if (text != "")
		{
			unlockAchievement(text);
			unLockInputField.text = "";
		}
		else
		{
			printOutputLine("Invalid Command");
		}
	}

	public void AddCount()
	{
		dataOutput.text = "> ";
		printOutputLine("AddCount");
		string text = addCountInputField.text;
		if (text != "")
		{
			string[] array = text.Split(',');
			if (array.Length > 1)
			{
				try
				{
					Convert.ToInt64(array[1]);
				}
				catch (Exception)
				{
					printOutputLine("Invalid Command");
					throw;
				}
				addCountAchievement(array[0], array[1]);
				addCountInputField.text = "";
			}
			else
			{
				printOutputLine("Invalid Command");
			}
		}
		else
		{
			printOutputLine("Invalid Command");
		}
	}

	public void AddFields()
	{
		dataOutput.text = "> ";
		printOutputLine("AddFields");
		string text = addFieldsInputField.text;
		if (text != "")
		{
			string[] array = text.Split(',');
			if (array.Length > 1)
			{
				addFieldsAchievement(array[0], array[1]);
				addFieldsInputField.text = "";
			}
			else
			{
				printOutputLine("Invalid Command");
			}
		}
		else
		{
			printOutputLine("Invalid Command");
		}
	}

	private void achievementInit()
	{
		Pvr_UnitySDKAPI.Achievement.Achievements.Init().OnComplete(initAchievementCallback);
	}

	private void getAchievementAllDefinition()
	{
		Pvr_UnitySDKAPI.Achievement.Achievements.GetAllDefinitions().OnComplete(achievementAllDefinitionCallback);
	}

	private void getAchievementAllProgress()
	{
		Pvr_UnitySDKAPI.Achievement.Achievements.GetAllProgress().OnComplete(achievementAllProgressCallback);
	}

	private void addFieldsAchievement(string achievementName, string fields)
	{
		Pvr_UnitySDKAPI.Achievement.Achievements.AddFields(achievementName, fields).OnComplete(achievementFieldsCallback);
	}

	private void addCountAchievement(string achievementName, string count)
	{
		Pvr_UnitySDKAPI.Achievement.Achievements.AddCount(achievementName, Convert.ToInt64(count)).OnComplete(achievementCountCallback);
	}

	private void unlockAchievement(string achievementName)
	{
		Pvr_UnitySDKAPI.Achievement.Achievements.Unlock(achievementName).OnComplete(achievementUnlockCallback);
	}

	private void getAchievementProgress(string[] achievementNames)
	{
		Pvr_UnitySDKAPI.Achievement.Achievements.GetProgressByName(achievementNames).OnComplete(achievementProgressCallback);
	}

	private void getAchievementDefinition(string[] achievementNames)
	{
		Pvr_UnitySDKAPI.Achievement.Achievements.GetDefinitionsByName(achievementNames).OnComplete(achievementDefinitionCallback);
	}

	private void printOutputLine(string newLine)
	{
		dataOutput.text = "> " + newLine + Environment.NewLine + dataOutput.text;
	}

	private void achievementAllDefinitionCallback(Pvr_Message<Pvr_AchievementDefinitionList> msg)
	{
		if (!msg.IsError)
		{
			printOutputLine("Received achievement definitions success");
			Pvr_AchievementDefinitionList achievementDefinitions = msg.GetAchievementDefinitions();
			if (achievementDefinitions.HasNextPage)
			{
				Pvr_UnitySDKAPI.Achievement.Achievements.GetNextAchievementDefinitionListPage(achievementDefinitions).OnComplete(achievementAllDefinitionCallback);
			}
			{
				foreach (Pvr_AchievementDefinition item in achievementDefinitions)
				{
					printOutputLine("Bitfield Name: " + item.Name.ToString());
					switch (item.Type)
					{
					case Pvr_UnitySDKAPI.Achievement.AchievementType.Simple:
						printOutputLine("Achievement Type: Simple");
						break;
					case Pvr_UnitySDKAPI.Achievement.AchievementType.Bitfield:
						printOutputLine("Achievement Type: Bitfield");
						printOutputLine("Bitfield Length: " + item.BitfieldLength);
						printOutputLine("Target: " + item.Target);
						break;
					case Pvr_UnitySDKAPI.Achievement.AchievementType.Count:
						printOutputLine("Achievement Type: Count");
						printOutputLine("Target: " + item.Target);
						break;
					default:
						printOutputLine("Achievement Type: Unknown");
						break;
					}
					printOutputLine("Bitfield Title: " + item.Title.ToString());
					printOutputLine("Bitfield Description: " + item.Description.ToString());
					printOutputLine("Bitfield UnlockedDescription: " + item.UnlockedDescription.ToString());
					printOutputLine("Bitfield UnlockedIcon: " + item.UnlockedIcon.ToString());
					printOutputLine("Bitfield LockedIcon: " + item.LockedIcon.ToString());
					printOutputLine("Bitfield IsSecrect: " + item.IsSecrect);
				}
				return;
			}
		}
		printOutputLine("Received achievement definitions error");
		Error error = msg.GetError();
		printOutputLine("Error: Message:" + error.Message + " Code: " + error.Code + " HttpCode: " + error.HttpCode);
	}

	private void achievementAllProgressCallback(Pvr_Message<Pvr_AchievementProgressList> msg)
	{
		if (!msg.IsError)
		{
			printOutputLine("Received achievement progress success");
			Pvr_AchievementProgressList achievementProgressList = msg.GetAchievementProgressList();
			if (achievementProgressList.HasNextPage)
			{
				Pvr_UnitySDKAPI.Achievement.Achievements.GetNextAchievementProgressListPage(achievementProgressList).OnComplete(achievementAllProgressCallback);
			}
			{
				foreach (Pvr_AchievementProgress item in achievementProgressList)
				{
					printOutputLine("Current Name: " + item.Name.ToString());
					if (item.IsUnlocked)
					{
						printOutputLine("Achievement Unlocked");
					}
					else
					{
						printOutputLine("Achievement Locked");
					}
					printOutputLine("Current Bitfield: " + item.Bitfield.ToString());
					printOutputLine("Current Count: " + item.Count);
					printOutputLine("Current UnlockTime: " + item.UnlockTime.ToString());
				}
				return;
			}
		}
		printOutputLine("Received achievement progress error");
		Error error = msg.GetError();
		printOutputLine("Error: Message:" + error.Message + " Code: " + error.Code + " HttpCode: " + error.HttpCode);
	}

	private void achievementFieldsCallback(Pvr_Message msg)
	{
		if (!msg.IsError)
		{
			printOutputLine("Achievement fields added.");
			return;
		}
		printOutputLine("Received achievement fields add error");
		Error error = msg.GetError();
		printOutputLine("Error: Message:" + error.Message + " Code: " + error.Code + " HttpCode: " + error.HttpCode);
	}

	private void achievementCountCallback(Pvr_Message msg)
	{
		if (!msg.IsError)
		{
			printOutputLine("Achievement count added.");
			return;
		}
		printOutputLine("Received achievement count add error");
		Error error = msg.GetError();
		printOutputLine("Error: Message:" + error.Message + " Code: " + error.Code + " HttpCode: " + error.HttpCode);
	}

	private void achievementUnlockCallback(Pvr_Message msg)
	{
		if (!msg.IsError)
		{
			printOutputLine("Achievement unlocked");
			return;
		}
		printOutputLine("Received achievement unlock error");
		Error error = msg.GetError();
		printOutputLine("Error: Message:" + error.Message + " Code: " + error.Code + " HttpCode: " + error.HttpCode);
	}

	private void achievementProgressCallback(Pvr_Message<Pvr_AchievementProgressList> msg)
	{
		if (!msg.IsError)
		{
			printOutputLine("Received achievement progress success");
			{
				foreach (Pvr_AchievementProgress achievementProgress in msg.GetAchievementProgressList())
				{
					if (achievementProgress.IsUnlocked)
					{
						printOutputLine("Achievement Unlocked");
					}
					else
					{
						printOutputLine("Achievement Locked");
					}
					printOutputLine("Current Bitfield: " + achievementProgress.Bitfield.ToString());
					printOutputLine("Current Count: " + achievementProgress.Count);
				}
				return;
			}
		}
		printOutputLine("Received achievement progress error");
		Error error = msg.GetError();
		printOutputLine("Error: Message:" + error.Message + " Code: " + error.Code + " HttpCode: " + error.HttpCode);
	}

	private void achievementDefinitionCallback(Pvr_Message<Pvr_AchievementDefinitionList> msg)
	{
		if (!msg.IsError)
		{
			printOutputLine("Received achievement definitions success");
			{
				foreach (Pvr_AchievementDefinition achievementDefinition in msg.GetAchievementDefinitions())
				{
					switch (achievementDefinition.Type)
					{
					case Pvr_UnitySDKAPI.Achievement.AchievementType.Simple:
						printOutputLine("Achievement Type: Simple");
						break;
					case Pvr_UnitySDKAPI.Achievement.AchievementType.Bitfield:
						printOutputLine("Achievement Type: Bitfield");
						printOutputLine("Bitfield Length: " + achievementDefinition.BitfieldLength);
						printOutputLine("Target: " + achievementDefinition.Target);
						break;
					case Pvr_UnitySDKAPI.Achievement.AchievementType.Count:
						printOutputLine("Achievement Type: Count");
						printOutputLine("Target: " + achievementDefinition.Target);
						break;
					default:
						printOutputLine("Achievement Type: Unknown");
						break;
					}
				}
				return;
			}
		}
		printOutputLine("Received achievement definitions error");
		Error error = msg.GetError();
		printOutputLine("Error: Message:" + error.Message + " Code: " + error.Code + " HttpCode: " + error.HttpCode);
	}

	private void initAchievementCallback(Pvr_Message msg)
	{
		if (!msg.IsError)
		{
			printOutputLine("Received init success");
			return;
		}
		printOutputLine("Received init error");
		Error error = msg.GetError();
		printOutputLine("Error: Message:" + error.Message + " Code: " + error.Code + " HttpCode: " + error.HttpCode);
	}

	private void LoginCallback(string LoginInfo)
	{
		UnityEngine.Debug.Log("Received loginCallback:" + LoginInfo);
		printOutputLine("Received loginCallback: " + LoginInfo);
	}
}
public class PLOG : MonoBehaviour
{
	public static int logLevel;

	public static void getConfigTraceLevel()
	{
		Render.UPvr_GetIntConfig(6, ref logLevel);
	}

	public static void D(string msg)
	{
		if (logLevel > 2)
		{
			UnityEngine.Debug.Log(msg);
		}
	}

	public static void I(string msg)
	{
		if (logLevel > 1)
		{
			UnityEngine.Debug.Log(msg);
		}
	}

	public static void W(string msg)
	{
		if (logLevel > 0)
		{
			UnityEngine.Debug.LogWarning(msg);
		}
	}

	public static void E(string msg)
	{
		UnityEngine.Debug.LogError(msg);
	}
}
public class CPicoSDKSettingAsset : ScriptableObject
{
	public bool IgnoreSDKSetting;

	public bool DontshowBuildWaring;

	public bool AppIDChecked;
}
[Serializable]
public class Pvr_UnitySDKProjectSetting : ScriptableObject
{
	public RenderTextureAntiAliasing rtAntiAlising;

	public RenderTextureDepth rtBitDepth;

	public RenderTextureFormat rtFormat;

	public bool usedefaultRenderTexture;

	public Vector2 customRTSize;

	public bool usedefaultfps;

	public int customfps;

	public bool usesinglepass;

	public bool usecontentprotect;

	public static Pvr_UnitySDKProjectSetting GetProjectConfig()
	{
		return Resources.Load<Pvr_UnitySDKProjectSetting>("ProjectSetting");
	}
}
public sealed class Pvr_UnitySDKPlatformSetting : ScriptableObject
{
	public enum simulationType
	{
		Null,
		Invalid,
		Valid
	}

	[SerializeField]
	private bool entitlementchecksimulation;

	[SerializeField]
	private bool startTimeEntitlementCheck;

	[SerializeField]
	public string appID;

	public List<string> deviceSN = new List<string>();

	private static Pvr_UnitySDKPlatformSetting instance;

	public static bool Entitlementchecksimulation
	{
		get
		{
			return Instance.entitlementchecksimulation;
		}
		set
		{
			if (Instance.entitlementchecksimulation != value)
			{
				Instance.entitlementchecksimulation = value;
			}
		}
	}

	public static bool StartTimeEntitlementCheck
	{
		get
		{
			return Instance.startTimeEntitlementCheck;
		}
		set
		{
			if (Instance.startTimeEntitlementCheck != value)
			{
				Instance.startTimeEntitlementCheck = value;
			}
		}
	}

	public static Pvr_UnitySDKPlatformSetting Instance
	{
		get
		{
			if (instance == null)
			{
				instance = Resources.Load<Pvr_UnitySDKPlatformSetting>("PlatformSettings");
			}
			return instance;
		}
		set
		{
			instance = value;
		}
	}
}
public class Pvr_UnitySDKManager : MonoBehaviour
{
	public delegate void EntitlementCheckResult(int ReturnValue);

	public static PlatForm platform;

	private static Pvr_UnitySDKManager sdk;

	[HideInInspector]
	public float EyesAspect = 1f;

	[HideInInspector]
	public int posStatus;

	[HideInInspector]
	public bool ismirroring;

	[HideInInspector]
	public Vector3 resetBasePos;

	[HideInInspector]
	public int trackingmode = -1;

	[HideInInspector]
	public int systemprop = -1;

	[HideInInspector]
	public bool systemFPS;

	[HideInInspector]
	public float[] headData = new float[7];

	[SerializeField]
	private bool rotfoldout;

	[SerializeField]
	private bool hmdOnlyrot;

	[SerializeField]
	private bool controllerOnlyrot;

	[SerializeField]
	private TrackingOrigin trackingOrigin;

	public bool ResetTrackerOnLoad;

	[HideInInspector]
	public Vector3 leftEyeOffset;

	[HideInInspector]
	public Vector3 rightEyeOffset;

	[HideInInspector]
	public Rect leftEyeRect;

	[HideInInspector]
	public Rect rightEyeRect;

	[HideInInspector]
	public Matrix4x4 leftEyeView;

	[HideInInspector]
	public Matrix4x4 rightEyeView;

	[HideInInspector]
	public Pvr_UnitySDKEditor pvr_UnitySDKEditor;

	[SerializeField]
	private bool vrModeEnabled = true;

	[HideInInspector]
	public Material Eyematerial;

	[HideInInspector]
	public Material Middlematerial;

	[HideInInspector]
	public bool newPicovrTriggered;

	[SerializeField]
	private bool showFPS;

	[HideInInspector]
	public Vector3 neckOffset = new Vector3(0f, 0.075f, 0.0805f);

	[SerializeField]
	private bool pVRNeck = true;

	[HideInInspector]
	public bool UseCustomNeckPara;

	[HideInInspector]
	public bool onResume;

	[HideInInspector]
	public bool isEnterVRMode;

	public bool isHasController;

	public Pvr_UnitySDKConfigProfile pvr_UnitySDKConfig;

	private GameObject calltoast;

	private GameObject msgtoast;

	private GameObject lowhmdBatterytoast;

	private GameObject lowphoneBatterytoast;

	private GameObject LowPhoneHealthtoast;

	private GameObject LowcontrollerBatterytoast;

	private bool lowControllerpowerstate;

	private float controllerpowershowtime;

	private bool UseToast = true;

	private int iPhoneHMDModeEnabled;

	private GameObject G3LiteTips;

	[SerializeField]
	private bool monoscopic;

	private bool mIsAndroid7;

	public static Func<bool> eventEnterVRMode;

	[HideInInspector]
	public bool ShowVideoSeethrough;

	public int SystemDebugFFRLevel = -1;

	public int SystemFFRLevel = -1;

	public int AppCheckResult = 100;

	public Action longPressHomeKeyAction;

	public static Pvr_UnitySDKManager SDK
	{
		get
		{
			if (sdk == null)
			{
				sdk = UnityEngine.Object.FindObjectOfType<Pvr_UnitySDKManager>();
			}
			return sdk;
		}
	}

	public bool Rotfoldout
	{
		get
		{
			return rotfoldout;
		}
		set
		{
			if (value != rotfoldout)
			{
				rotfoldout = value;
			}
		}
	}

	public bool HmdOnlyrot
	{
		get
		{
			return hmdOnlyrot;
		}
		set
		{
			if (value != hmdOnlyrot)
			{
				hmdOnlyrot = value;
			}
		}
	}

	public bool ControllerOnlyrot
	{
		get
		{
			return controllerOnlyrot;
		}
		set
		{
			if (value != controllerOnlyrot)
			{
				controllerOnlyrot = value;
			}
		}
	}

	public TrackingOrigin TrackingOrigin
	{
		get
		{
			return trackingOrigin;
		}
		set
		{
			if (value != trackingOrigin)
			{
				trackingOrigin = value;
				Sensor.UPvr_SetTrackingOriginType(value);
			}
		}
	}

	[HideInInspector]
	public bool VRModeEnabled
	{
		get
		{
			return vrModeEnabled;
		}
		set
		{
			if (value != vrModeEnabled)
			{
				vrModeEnabled = value;
			}
		}
	}

	[HideInInspector]
	public bool picovrTriggered { get; set; }

	public bool ShowFPS
	{
		get
		{
			return showFPS;
		}
		set
		{
			if (value != showFPS)
			{
				showFPS = value;
			}
		}
	}

	public bool PVRNeck
	{
		get
		{
			return pVRNeck;
		}
		set
		{
			if (value != pVRNeck)
			{
				pVRNeck = value;
			}
		}
	}

	[HideInInspector]
	public bool Monoscopic
	{
		get
		{
			return monoscopic;
		}
		set
		{
			if (value != monoscopic)
			{
				monoscopic = value;
				Render.UPvr_SetMonoMode(monoscopic);
			}
		}
	}

	public static event EntitlementCheckResult EntitlementCheckResultEvent;

	public void ChangeDefaultCustomRtSize(int w, int h)
	{
		Pvr_UnitySDKProjectSetting.GetProjectConfig().customRTSize = new Vector2(w, h);
	}

	public Vector3 EyeOffset(Eye eye)
	{
		if (eye != 0)
		{
			return rightEyeOffset;
		}
		return leftEyeOffset;
	}

	public Rect EyeRect(Eye eye)
	{
		if (eye != 0)
		{
			return rightEyeRect;
		}
		return leftEyeRect;
	}

	private bool SDKManagerInit()
	{
		if (SDKManagerInitConfigProfile())
		{
			mIsAndroid7 = SystemInfo.operatingSystem.Contains("Android OS 7.");
			PLOG.I("Android 7 = " + mIsAndroid7);
			if (SDKManagerInitCoreAbility())
			{
				return true;
			}
			return false;
		}
		return false;
	}

	private bool SDKManagerInitCoreAbility()
	{
		Sensor.UPvr_SetTrackingOriginType(trackingOrigin);
		Render.UPvr_SetMonoMode(monoscopic);
		if (Pvr_UnitySDKRender.Instance == null)
		{
			PLOG.I("pvr_UnitySDKRender init failed");
		}
		if (Pvr_UnitySDKSensor.Instance == null)
		{
			PLOG.I("pvr_UnitySDKSensor init failed");
		}
		Pvr_UnitySDKAPI.System.UPvr_StartHomeKeyReceiver(base.gameObject.name);
		return true;
	}

	public void smsReceivedCallback(string msg)
	{
		PLOG.I("PvrLog MSG" + msg);
		JsonData jsonData = JsonMapper.ToObject(msg);
		string text = "";
		if (msg.Contains("messageSender"))
		{
			text = (string)jsonData["messageSender"];
		}
		string text2 = "";
		if (msg.Contains("messageAdr"))
		{
			text2 = (string)jsonData["messageAdr"];
			if (text2.Substring(0, 3) == "+82")
			{
				text2 = "0" + text2.Remove(0, 3);
				text2 = TransformNumber(text2);
			}
			else if (text2.Substring(0, 1) != "+")
			{
				text2 = TransformNumber(text2);
			}
		}
		if (UseToast)
		{
			msgtoast.transform.Find("number").GetComponent<Text>().text = text2;
			msgtoast.transform.Find("name").GetComponent<Text>().text = text;
			if (text.Length == 0)
			{
				msgtoast.transform.Find("number").transform.localPosition = new Vector3(0f, 0f, 0f);
			}
			else
			{
				msgtoast.transform.Find("number").transform.localPosition = new Vector3(60f, 0f, 0f);
			}
			StartCoroutine(ToastManager(2, state: true, 0f));
			StartCoroutine(ToastManager(2, state: false, 5f));
		}
	}

	public void phoneStateCallback(string state)
	{
		PLOG.I("PvrLog phone" + state);
		JsonData jsonData = JsonMapper.ToObject(state);
		string text = "";
		if (state.Contains("phoneNumber"))
		{
			text = (string)jsonData["phoneNumber"];
			if (text.Substring(0, 3) == "+82")
			{
				text = "0" + text.Remove(0, 3);
				text = TransformNumber(text);
			}
			else if (text.Substring(0, 1) != "+")
			{
				text = TransformNumber(text);
			}
		}
		string text2 = "";
		if (state.Contains("contactName"))
		{
			text2 = (string)jsonData["contactName"];
		}
		if (UseToast)
		{
			calltoast.transform.Find("number").GetComponent<Text>().text = text;
			calltoast.transform.Find("name").GetComponent<Text>().text = text2;
			if (text2.Length == 0)
			{
				calltoast.transform.Find("number").transform.localPosition = new Vector3(0f, 0f, 0f);
			}
			else
			{
				calltoast.transform.Find("number").transform.localPosition = new Vector3(60f, 0f, 0f);
			}
			StartCoroutine(ToastManager(1, state: true, 0f));
			StartCoroutine(ToastManager(1, state: false, 5f));
		}
	}

	public void phoneBatteryStateCallback(string state)
	{
		PLOG.I("PvrLog phoneBatteryState" + state);
		JsonData jsonData = JsonMapper.ToObject(state);
		string value = "";
		if (state.Contains("phoneBatteryLevel"))
		{
			value = (string)jsonData["phoneBatteryLevel"];
		}
		string value2 = "";
		if (state.Contains("phoneBatteryHealth"))
		{
			value2 = (string)jsonData["phoneBatteryHealth"];
		}
		if (!UseToast)
		{
			return;
		}
		if (Convert.ToInt16(value) <= 5)
		{
			if (!lowhmdBatterytoast.activeSelf)
			{
				StartCoroutine(ToastManager(4, state: true, 0f));
				StartCoroutine(ToastManager(4, state: false, 3f));
			}
			else
			{
				StartCoroutine(ToastManager(4, state: true, 5f));
				StartCoroutine(ToastManager(4, state: false, 8f));
			}
		}
		if (Convert.ToInt16(value2) == 3)
		{
			StartCoroutine(ToastManager(5, state: true, 0f));
			StartCoroutine(ToastManager(5, state: false, 5f));
		}
	}

	public void hmdLowBatteryCallback(string level)
	{
		PLOG.I("PvrLog hmdLowBatteryCallback" + level);
		if (UseToast)
		{
			if (!lowphoneBatterytoast.activeSelf)
			{
				StartCoroutine(ToastManager(3, state: true, 0f));
				StartCoroutine(ToastManager(3, state: false, 3f));
			}
			else
			{
				StartCoroutine(ToastManager(3, state: true, 5f));
				StartCoroutine(ToastManager(3, state: false, 8f));
			}
		}
	}

	private string TransformNumber(string number)
	{
		if (number.Length == 11)
		{
			string text = number.Substring(0, 3);
			string text2 = number.Substring(3, 4);
			string text3 = number.Substring(7, 4);
			number = text + "-" + text2 + "-" + text3;
		}
		else if (number.Length == 10)
		{
			if (number.Substring(1, 1) == "1")
			{
				string text4 = number.Substring(0, 3);
				string text5 = number.Substring(3, 3);
				string text6 = number.Substring(6, 4);
				number = text4 + "-" + text5 + "-" + text6;
			}
			else
			{
				string text7 = number.Substring(0, 2);
				string text8 = number.Substring(2, 4);
				string text9 = number.Substring(6, 4);
				number = text7 + "-" + text8 + "-" + text9;
			}
		}
		else if (number.Length == 9)
		{
			if (number.Substring(1, 1) == "2")
			{
				string text10 = number.Substring(0, 2);
				string text11 = number.Substring(2, 3);
				string text12 = number.Substring(5, 4);
				number = text10 + "-" + text11 + "-" + text12;
			}
			else
			{
				number = "+82" + number.Remove(0, 1);
			}
		}
		return number;
	}

	public void onHmdOrientationReseted()
	{
	}

	private IEnumerator ToastManager(int type, bool state, float time)
	{
		yield return new WaitForSeconds(time);
		switch (type)
		{
		case 1:
			calltoast.SetActive(state);
			break;
		case 2:
			msgtoast.SetActive(state);
			break;
		case 3:
			lowhmdBatterytoast.SetActive(state);
			break;
		case 4:
			lowphoneBatterytoast.SetActive(state);
			break;
		case 5:
			LowPhoneHealthtoast.SetActive(state);
			break;
		case 6:
			LowcontrollerBatterytoast.SetActive(state);
			break;
		}
	}

	private void CheckControllerStateForG2(string state)
	{
		if (iPhoneHMDModeEnabled == 1 && Convert.ToBoolean(Convert.ToInt16(state)) && Controller.UPvr_GetControllerPower(0) == 0 && Pvr_ControllerManager.controllerlink.Controller0.Rotation.eulerAngles != Vector3.zero)
		{
			StartCoroutine(ToastManager(6, state: true, 0f));
			StartCoroutine(ToastManager(6, state: false, 3f));
		}
	}

	public void notificationCallback(string data)
	{
		JsonData jsonData = JsonMapper.ToObject(data);
		if (G3LiteTips == null)
		{
			G3LiteTips = UnityEngine.Object.Instantiate(Resources.Load("Prefabs/G3LiteTips") as GameObject, base.transform.Find("Head"), worldPositionStays: false);
		}
		JsonData jsonData2 = JsonMapper.ToObject(jsonData["str"].ToString());
		switch ((int)jsonData["type"])
		{
		case 0:
			SetProperty(0, jsonData2, "Sms");
			break;
		case 1:
			SetProperty(1, jsonData2, "Call");
			break;
		case 2:
			SetProperty(2, jsonData2, "Warnning");
			break;
		case 3:
			SetProperty(3, jsonData2, "Warnning");
			break;
		case 4:
			SetProperty(4, jsonData2, "Warnning");
			break;
		case 5:
		{
			Transform transform = G3LiteTips.transform.Find("Onlyimage");
			SetBaseProperty(transform, jsonData2["General"], "");
			SetImageProperty(transform, jsonData2["General"], "");
			transform.gameObject.SetActive(value: true);
			StartCoroutine(G3TipsManager(transform.gameObject, (int)jsonData2["General"]["time"]));
			break;
		}
		case -1:
			break;
		}
	}

	private Sprite LoadSprite(Vector2 size, string filepath)
	{
		int width = (int)size.x;
		int height = (int)size.y;
		Texture2D texture2D = new Texture2D(width, height);
		texture2D.LoadImage(ReadTex(filepath));
		return Sprite.Create(texture2D, new Rect(0f, 0f, texture2D.width, texture2D.height), new Vector2(0.5f, 0.5f));
	}

	private byte[] ReadTex(string path)
	{
		if (path == "")
		{
			return new byte[0];
		}
		FileStream fileStream = new FileStream(path, FileMode.Open, FileAccess.Read);
		fileStream.Seek(0L, SeekOrigin.Begin);
		byte[] array = new byte[fileStream.Length];
		fileStream.Read(array, 0, (int)fileStream.Length);
		fileStream.Close();
		fileStream.Dispose();
		fileStream = null;
		return array;
	}

	private void SetProperty(int type, JsonData data, string value)
	{
		Transform trans = G3LiteTips.transform.Find(value);
		SetBaseProperty(trans, data, "");
		SetImageProperty(trans, data, "");
		trans.gameObject.SetActive(value: true);
		StartCoroutine(G3TipsManager(trans.gameObject, (int)data["time"]));
		Transform transform = trans.transform.Find("icon");
		SetBaseProperty(transform, data, "icon_");
		SetImageProperty(transform, data, "icon_");
		Transform transform2 = trans.transform.Find("title");
		SetBaseProperty(transform2, data, "title_");
		SetTextProperty(transform2, data, "title_");
		if (type != 1)
		{
			Transform transform3 = trans.transform.Find("details");
			SetBaseProperty(transform3, data, "details_");
			SetTextProperty(transform3, data, "details_");
			Transform transform4 = trans.transform.Find("image1");
			SetBaseProperty(transform4, data, "image1_");
			SetImageProperty(transform4, data, "image1_");
		}
		if (type == 0 || type == 1)
		{
			Transform transform5 = trans.transform.Find("explain");
			SetBaseProperty(transform5, data, "explain_");
			SetTextProperty(transform5, data, "explain_");
			Transform transform6 = trans.transform.Find("source");
			SetBaseProperty(transform6, data, "source_");
			SetTextProperty(transform6, data, "source_");
		}
		if (type == 0)
		{
			Transform transform7 = trans.transform.Find("time");
			SetBaseProperty(transform7, data, "system_time_");
			SetTextProperty(transform7, data, "system_time_");
		}
		Transform transform8 = trans.transform.Find("Button");
		SetBaseProperty(transform8, data, "button_");
		SetImageProperty(transform8, data, "button_");
		transform8.GetComponent<Button>().onClick.AddListener(delegate
		{
			StartCoroutine(G3TipsManager(trans.gameObject, 0f));
		});
		Transform transform9 = transform8.transform.Find("Text");
		SetBaseProperty(transform9, data, "button_text_");
		SetTextProperty(transform9, data, "button_text_");
	}

	private void SetBaseProperty(Transform trans, JsonData data, string value)
	{
		string prop_name = value + "pos";
		string prop_name2 = value + "angles";
		string prop_name3 = value + "size";
		string prop_name4 = value + "scale";
		trans.GetComponent<RectTransform>().anchoredPosition3D = new Vector3(JsonToFloat(data[prop_name][0]), JsonToFloat(data[prop_name][1]), JsonToFloat(data[prop_name][2]));
		trans.GetComponent<RectTransform>().eulerAngles = new Vector3(JsonToFloat(data[prop_name2][0]), JsonToFloat(data[prop_name2][1]), JsonToFloat(data[prop_name2][2]));
		trans.GetComponent<RectTransform>().sizeDelta = new Vector2(JsonToFloat(data[prop_name3][0]), JsonToFloat(data[prop_name3][1]));
		trans.GetComponent<RectTransform>().localScale = new Vector3(JsonToFloat(data[prop_name4][0]), JsonToFloat(data[prop_name4][1]), JsonToFloat(data[prop_name4][2]));
	}

	private void SetImageProperty(Transform image, JsonData data, string value)
	{
		string prop_name = value + "sprite";
		string prop_name2 = value + "color";
		string prop_name3 = value + "size";
		image.GetComponent<Image>().sprite = LoadSprite(new Vector2(JsonToFloat(data[prop_name3][0]), JsonToFloat(data[prop_name3][1])), (string)data[prop_name]);
		image.GetComponent<Image>().color = new Color(JsonToFloat(data[prop_name2][0]), JsonToFloat(data[prop_name2][1]), JsonToFloat(data[prop_name2][2]), JsonToFloat(data[prop_name2][3]));
	}

	private void SetTextProperty(Transform text, JsonData data, string value)
	{
		string prop_name = value + "color";
		string prop_name2 = value + "font_size";
		string prop_name3 = value + "font_style";
		string prop_name4 = value + "text";
		text.GetComponent<Text>().text = (string)data[prop_name4];
		text.GetComponent<Text>().color = new Color(JsonToFloat(data[prop_name][0]), JsonToFloat(data[prop_name][1]), JsonToFloat(data[prop_name][2]), JsonToFloat(data[prop_name][3]));
		text.GetComponent<Text>().fontSize = (int)data[prop_name2];
		text.GetComponent<Text>().fontStyle = (FontStyle)(int)data[prop_name3];
	}

	private IEnumerator G3TipsManager(GameObject tip, float time)
	{
		yield return new WaitForSeconds(time);
		tip.SetActive(value: false);
	}

	private float JsonToFloat(JsonData data)
	{
		return Convert.ToSingle((string)data);
	}

	private bool SDKManagerInitFPS()
	{
		Transform[] componentsInChildren = GetComponentsInChildren<Transform>(includeInactive: true);
		GameObject gameObject = null;
		Transform[] array = componentsInChildren;
		foreach (Transform transform in array)
		{
			if (transform.gameObject.name == "FPS")
			{
				gameObject = transform.gameObject;
			}
		}
		if (gameObject != null)
		{
			if (systemFPS)
			{
				gameObject.SetActive(value: true);
				return true;
			}
			int res = 0;
			Render.UPvr_GetIntConfig(10, ref res);
			if (Convert.ToBoolean(res))
			{
				gameObject.SetActive(value: true);
				return true;
			}
			if (ShowFPS)
			{
				gameObject.SetActive(value: true);
				return true;
			}
			return false;
		}
		return false;
	}

	private bool SDKManagerInitConfigProfile()
	{
		pvr_UnitySDKConfig = Pvr_UnitySDKConfigProfile.Default;
		return true;
	}

	private bool SDKManagerInitEditor()
	{
		if (pvr_UnitySDKEditor == null)
		{
			pvr_UnitySDKEditor = base.gameObject.AddComponent<Pvr_UnitySDKEditor>();
		}
		else
		{
			pvr_UnitySDKEditor = null;
			pvr_UnitySDKEditor = base.gameObject.AddComponent<Pvr_UnitySDKEditor>();
		}
		return true;
	}

	private bool SDKManagerInitPara()
	{
		return true;
	}

	public void SDKManagerLongHomeKey()
	{
		if (Pvr_UnitySDKSensor.Instance == null)
		{
			return;
		}
		if (isHasController)
		{
			if (Controller.UPvr_GetControllerState(0) == ControllerState.Connected || Controller.UPvr_GetControllerState(1) == ControllerState.Connected)
			{
				Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(0, 1);
			}
			else
			{
				Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(1, 1);
			}
		}
		else
		{
			Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(1, 1);
		}
	}

	private void setLongHomeKey()
	{
		if (sdk.HmdOnlyrot)
		{
			if (Pvr_UnitySDKSensor.Instance != null)
			{
				PLOG.I(Pvr_UnitySDKSensor.Instance.ResetUnitySDKSensor() ? "Long Home Key to Reset Sensor Success!" : "Long Home Key to Reset Sensor Failed!");
			}
			return;
		}
		if (trackingmode == 4 || trackingmode == 5 || trackingmode == 6)
		{
			Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(1, 1);
		}
		else
		{
			if (trackingmode == 2 || trackingmode == 3)
			{
				if (isHasController && (Controller.UPvr_GetControllerState(0) == ControllerState.Connected || Controller.UPvr_GetControllerState(1) == ControllerState.Connected))
				{
					Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(0, 1);
				}
				else
				{
					Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(1, 1);
				}
			}
			if (trackingmode == 0 || trackingmode == 1)
			{
				Pvr_UnitySDKSensor.Instance.ResetUnitySDKSensor();
			}
		}
		if (longPressHomeKeyAction != null)
		{
			longPressHomeKeyAction();
		}
	}

	public void verifyAPPCallback(string code)
	{
		UnityEngine.Debug.Log("PvrLog verifyAPPCallback" + code);
		AppCheckResult = Convert.ToInt32(code);
		if (Pvr_UnitySDKManager.EntitlementCheckResultEvent != null)
		{
			Pvr_UnitySDKManager.EntitlementCheckResultEvent(AppCheckResult);
		}
	}

	public void IpdRefreshCallBack(string ipd)
	{
		UnityEngine.Debug.Log("PvrLog IpdRefreshCallBack");
		Pvr_UnitySDKEye[] eyes = Pvr_UnitySDKEyeManager.Instance.Eyes;
		for (int i = 0; i < eyes.Length; i++)
		{
			eyes[i].RefreshCameraPosition(Convert.ToSingle(ipd));
		}
	}

	private void Awake()
	{
		UnityEngine.Debug.Log("DISFT Unity Version:" + UnityEngine.Application.unityVersion);
		UnityEngine.Debug.Log("DISFT Customize NeckOffset:" + neckOffset);
		UnityEngine.Debug.Log("DISFT MSAA :" + Pvr_UnitySDKProjectSetting.GetProjectConfig().rtAntiAlising);
		if (GraphicsSettings.renderPipelineAsset != null)
		{
			UnityEngine.Debug.Log("DISFT LWRP = Enable");
		}
		UnityEngine.Debug.Log("DISFT Content Proctect :" + Pvr_UnitySDKProjectSetting.GetProjectConfig().usecontentprotect);
		int res = 0;
		LoadIsMirroringValue();
		if (!ismirroring)
		{
			Render.UPvr_GetIntConfig(18, ref res);
			if (res == 1)
			{
				UnityEngine.Debug.Log("DISFT ScreenOrientation.Portrait = Enable");
				Screen.orientation = ScreenOrientation.Portrait;
			}
		}
		else
		{
			Render.UPvr_GetIntConfig(19, ref res);
			Screen.orientation = ((res == 0) ? ScreenOrientation.Portrait : ScreenOrientation.LandscapeLeft);
		}
		new AndroidJavaClass("com.psmart.vrlib.VrActivity");
		new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
		Pvr_ControllerManager pvr_ControllerManager = UnityEngine.Object.FindObjectOfType<Pvr_ControllerManager>();
		isHasController = pvr_ControllerManager != null;
		PLOG.getConfigTraceLevel();
		Render.UPvr_GetIntConfig(5, ref trackingmode);
		UnityEngine.Application.targetFrameRate = 61;
		int res2 = 0;
		Render.UPvr_GetIntConfig(3, ref res2);
		if (res2 == 0)
		{
			SDK.HmdOnlyrot = true;
		}
		int res3 = -1;
		Render.UPvr_GetIntConfig(9, ref res3);
		float res4 = 0f;
		Render.UPvr_GetFloatConfig(6, ref res4);
		UnityEngine.Application.targetFrameRate = ((res3 > 0) ? res3 : ((int)res4));
		if (!Pvr_UnitySDKProjectSetting.GetProjectConfig().usedefaultfps)
		{
			if ((float)Pvr_UnitySDKProjectSetting.GetProjectConfig().customfps <= res4)
			{
				UnityEngine.Application.targetFrameRate = Pvr_UnitySDKProjectSetting.GetProjectConfig().customfps;
			}
			else
			{
				UnityEngine.Application.targetFrameRate = (int)res4;
			}
		}
		UnityEngine.Debug.Log("DISFT Customize FPS :" + UnityEngine.Application.targetFrameRate);
		if (!UseCustomNeckPara)
		{
			float res5 = 0f;
			float res6 = 0f;
			float res7 = 0f;
			int configsenum = 4;
			int configsenum2 = 5;
			Render.UPvr_GetFloatConfig(3, ref res5);
			Render.UPvr_GetFloatConfig(configsenum, ref res6);
			Render.UPvr_GetFloatConfig(configsenum2, ref res7);
			if (res5 != 0f || res6 != 0f || res7 != 0f)
			{
				neckOffset = new Vector3(res5, res6, res7);
			}
		}
		Render.UPvr_GetIntConfig(16, ref iPhoneHMDModeEnabled);
		Pvr_ControllerManager.ControllerStatusChangeEvent += CheckControllerStateForG2;
		InitUI();
		RefreshTextByLanguage();
	}

	private IEnumerator Start()
	{
		if (SDKManagerInit())
		{
			PLOG.I("SDK Init success.");
		}
		else
		{
			PLOG.E("SDK Init Failed.");
			UnityEngine.Application.Quit();
		}
		if (Pvr_UnitySDKRender.Instance != null)
		{
			Pvr_UnitySDKRender.Instance.ReInit();
		}
		SDKManagerInitFPS();
		if (Pvr_UnitySDKPlatformSetting.StartTimeEntitlementCheck)
		{
			if (Pvr_UnitySDKAPI.PlatformSettings.UPvr_IsCurrentDeviceValid() != Pvr_UnitySDKPlatformSetting.simulationType.Valid)
			{
				UnityEngine.Debug.Log("DISFT Entitlement Check Simulation DO NOT PASS");
				string appID = Pvr_UnitySDKPlatformSetting.Instance.appID;
				UnityEngine.Debug.Log("DISFT Start-time Entitlement Check Enable");
				PLOG.I("DISFT Start-time Entitlement Check APPID :" + appID);
				Pvr_UnitySDKAPI.PlatformSettings.UPvr_AppEntitlementCheckExtra(appID);
			}
			else
			{
				UnityEngine.Debug.Log("DISFT Entitlement Check Simulation PASS");
			}
		}
		yield return StartCoroutine(InitRenderThreadRoutine());
	}

	private IEnumerator InitRenderThreadRoutine()
	{
		PLOG.I("InitRenderThreadRoutine begin");
		int i = 0;
		while (i < 2)
		{
			yield return null;
			int num = i + 1;
			i = num;
		}
		UnityEngine.Debug.Log("InitRenderThreadRoutine after a wait");
		if (Pvr_UnitySDKRender.Instance != null)
		{
			Pvr_UnitySDKRender.Instance.IssueRenderThread();
		}
		else
		{
			UnityEngine.Debug.Log("InitRenderThreadRoutine pvr_UnitySDKRender == null");
		}
		UnityEngine.Debug.Log("InitRenderThreadRoutine end");
	}

	private void Update()
	{
		if (isHasController && iPhoneHMDModeEnabled == 1 && Controller.UPvr_GetControllerPower(0) == 0 && Pvr_ControllerManager.controllerlink.controller0Connected && Pvr_ControllerManager.controllerlink.Controller0.Rotation.eulerAngles != Vector3.zero)
		{
			if (!lowControllerpowerstate)
			{
				StartCoroutine(ToastManager(6, state: true, 0f));
				StartCoroutine(ToastManager(6, state: false, 3f));
				lowControllerpowerstate = true;
			}
			controllerpowershowtime += Time.deltaTime;
			if (controllerpowershowtime >= 3600f)
			{
				lowControllerpowerstate = false;
				controllerpowershowtime = 0f;
			}
		}
		if (Input.touchCount == 1 && Input.touches[0].phase == TouchPhase.Began)
		{
			newPicovrTriggered = true;
		}
		if (Input.GetKeyDown(KeyCode.JoystickButton0))
		{
			newPicovrTriggered = true;
		}
		if (Pvr_UnitySDKSensor.Instance != null)
		{
			Pvr_UnitySDKSensor.Instance.SensorUpdate();
		}
		picovrTriggered = newPicovrTriggered;
		newPicovrTriggered = false;
	}

	private void OnDestroy()
	{
		if (sdk == this)
		{
			sdk = null;
		}
		RenderTexture.active = null;
		Resources.UnloadUnusedAssets();
		GC.Collect();
		Pvr_ControllerManager.ControllerStatusChangeEvent -= CheckControllerStateForG2;
	}

	private void OnEnable()
	{
		if (sdk == null)
		{
			sdk = this;
		}
		else if (sdk != this)
		{
			sdk = this;
		}
	}

	private void OnDisable()
	{
		StopAllCoroutines();
	}

	private void OnPause()
	{
		Pvr_UnitySDKAPI.System.UPvr_StopHomeKeyReceiver();
		LeaveVRMode();
		if (Pvr_UnitySDKSensor.Instance != null)
		{
			Pvr_UnitySDKSensor.Instance.StopUnitySDKSensor();
		}
	}

	private void OnApplicationPause(bool pause)
	{
		bool flag = pause;
		UnityEngine.Debug.Log("OnApplicationPause-------------------------" + (flag ? "true" : "false"));
		if (Pvr_UnitySDKAPI.System.UPvr_IsPicoActivity() && !Pvr_UnitySDKRender.Instance.isShellMode)
		{
			bool flag2 = Pvr_UnitySDKAPI.System.UPvr_GetMainActivityPauseStatus();
			UnityEngine.Debug.Log("OnApplicationPause-------------------------Activity Pause State:" + flag2);
			pause = flag2;
		}
		if (flag == pause)
		{
			if (pause)
			{
				onResume = false;
				OnPause();
			}
			else
			{
				onResume = true;
				GL.InvalidateState();
				StartCoroutine(OnResume());
			}
		}
		else if (pause)
		{
			UnityEngine.Debug.Log("OnApplicationPause-------------------------Activity pause Unity resume");
			GL.InvalidateState();
			StartCoroutine(OnResume());
			onResume = false;
			OnPause();
		}
		else
		{
			UnityEngine.Debug.Log("OnApplicationPause-------------------------Activity resume Unity pause");
			OnPause();
			onResume = true;
			GL.InvalidateState();
			StartCoroutine(OnResume());
		}
	}

	public void EnterVRMode()
	{
		Pvr_UnitySDKPluginEvent.Issue(RenderEventType.Resume);
		isEnterVRMode = true;
		if (eventEnterVRMode != null)
		{
			eventEnterVRMode();
		}
	}

	public void LeaveVRMode()
	{
		Pvr_UnitySDKPluginEvent.Issue(RenderEventType.Pause);
		isEnterVRMode = false;
	}

	public void SixDofForceQuit()
	{
		UnityEngine.Application.Quit();
	}

	private void InitUI()
	{
		if (iPhoneHMDModeEnabled == 1)
		{
			Transform transform = UnityEngine.Object.Instantiate(Resources.Load("Prefabs/flamingo2Tips") as GameObject, base.transform.Find("Head"), worldPositionStays: false).transform;
			calltoast = transform.Find("Call").gameObject;
			msgtoast = transform.Find("Msg").gameObject;
			lowhmdBatterytoast = transform.Find("LowHmdBattery").gameObject;
			lowphoneBatterytoast = transform.Find("LowPhoneBattery").gameObject;
			LowPhoneHealthtoast = transform.Find("LowPhoneHealth").gameObject;
			LowcontrollerBatterytoast = transform.Find("LowControllerBattery").gameObject;
		}
	}

	private void RefreshTextByLanguage()
	{
		if (msgtoast != null)
		{
			msgtoast.transform.Find("Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("msgtoast0");
			msgtoast.transform.Find("string").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("msgtoast1");
			calltoast.transform.Find("Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("calltoast0");
			calltoast.transform.Find("Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("calltoast1");
			lowhmdBatterytoast.transform.Find("Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("lowhmdBatterytoast");
			lowphoneBatterytoast.transform.Find("Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("lowphoneBatterytoast");
			LowPhoneHealthtoast.transform.Find("Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("LowPhoneHealthtoast");
			LowcontrollerBatterytoast.transform.Find("Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("LowcontrollerBatterytoast");
		}
	}

	private void LoadIsMirroringValue()
	{
		AndroidJavaObject @static = new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
		AndroidJavaObject androidJavaObject = @static.Call<AndroidJavaObject>("getPackageManager", Array.Empty<object>());
		string text = @static.Call<string>("getPackageName", Array.Empty<object>());
		AndroidJavaObject androidJavaObject2 = androidJavaObject.Call<AndroidJavaObject>("getApplicationInfo", new object[2] { text, 128 }).Get<AndroidJavaObject>("metaData");
		ismirroring = Convert.ToBoolean(androidJavaObject2.Call<int>("getInt", new object[2] { "bypass_presentation", 0 }));
	}

	private IEnumerator OnResume()
	{
		int ability6dof = 0;
		Render.UPvr_GetIntConfig(3, ref ability6dof);
		RefreshTextByLanguage();
		if (Pvr_UnitySDKSensor.Instance != null)
		{
			Pvr_UnitySDKSensor.Instance.StartUnitySDKSensor();
			int res = -1;
			Render.UPvr_GetIntConfig(8, ref res);
			if (res != 1)
			{
				int res2 = -1;
				Render.UPvr_GetIntConfig(11, ref res2);
				if (res2 != 8)
				{
					Pvr_UnitySDKSensor.Instance.ResetUnitySDKSensor();
				}
			}
		}
		if (Pvr_UnitySDKAPI.System.UPvr_IsPicoActivity())
		{
			PLOG.I("onresume set monoPresentation success ?-------------" + Pvr_UnitySDKAPI.System.UPvr_SetMonoPresentation());
			PLOG.I("onresume presentation existed ?-------------" + Pvr_UnitySDKAPI.System.UPvr_IsPresentationExisted());
		}
		for (int j = 0; j < Pvr_UnitySDKEyeManager.Instance.Eyes.Length; j++)
		{
			Pvr_UnitySDKEyeManager.Instance.Eyes[j].RefreshCameraPosition(Pvr_UnitySDKAPI.System.UPvr_GetIPD());
		}
		int waitNum = 15;
		Render.UPvr_GetIntConfig(20, ref waitNum);
		int resetNum = 10;
		Render.UPvr_GetIntConfig(21, ref resetNum);
		for (int i = 0; i < waitNum; i++)
		{
			if (i == resetNum && ResetTrackerOnLoad && ability6dof == 1)
			{
				UnityEngine.Debug.Log("Reset Tracker OnLoad");
				Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(1, 1);
			}
			yield return null;
		}
		EnterVRMode();
		Pvr_UnitySDKAPI.System.UPvr_StartHomeKeyReceiver(base.gameObject.name);
		Pvr_UnitySDKEye.setLevel = false;
		if (longPressHomeKeyAction != null)
		{
			longPressHomeKeyAction();
		}
		if (Render.UPvr_GetIntSysProc("pvrsist.foveation.level", ref SystemDebugFFRLevel))
		{
			Render.SetFoveatedRenderingLevel((EFoveationLevel)SystemDebugFFRLevel);
			UnityEngine.Debug.Log("DISFT OnResume Get System Debug ffr level is : " + SystemDebugFFRLevel);
		}
		else
		{
			UnityEngine.Debug.Log("DISFT OnResume Get System Debug ffr level Error,ffr level is : " + SystemDebugFFRLevel);
		}
		if (SystemDebugFFRLevel == -1)
		{
			Render.UPvr_GetIntConfig(22, ref SystemFFRLevel);
			if (SystemFFRLevel != -1)
			{
				Render.SetFoveatedRenderingLevel((EFoveationLevel)SystemFFRLevel);
				UnityEngine.Debug.Log("DISFT OnResume Get System ffr level is : " + SystemFFRLevel);
			}
		}
	}
}
public class QuitGame : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.Escape))
		{
			UnityEngine.Application.Quit();
		}
	}
}
public class Pvr_UnityEyeMask : MonoBehaviour
{
	private class EyeMaskData
	{
		public Eye eyeSide;

		public Camera camera;

		public CommandBuffer cmdBuf;
	}

	private Shader eyeMaskShader;

	private Material eyeMaskMaterial;

	private Mesh eyeMaskMeshLeft;

	private Mesh eyeMaskMeshRight;

	private Mesh eyeMaskMeshBoth;

	private float zDir = -1f;

	private Color eyeMaskColor = Color.black;

	private List<EyeMaskData> cameraDataList = new List<EyeMaskData>();

	private void Awake()
	{
		UnityEngine.Debug.Log("DISFT EyeMask = Enable");
		if (SystemInfo.graphicsDeviceType == GraphicsDeviceType.OpenGLES3 || SystemInfo.graphicsDeviceType == GraphicsDeviceType.OpenGLES2)
		{
			zDir = -1f;
		}
		else if (SystemInfo.usesReversedZBuffer)
		{
			zDir = 1f;
		}
		else
		{
			zDir = 0f;
		}
	}

	private void OnEnable()
	{
		if (eyeMaskShader == null)
		{
			eyeMaskShader = Shader.Find("Pvr_UnitySDK/Pvr_EyeMask");
		}
		if (eyeMaskMaterial == null && eyeMaskShader != null)
		{
			eyeMaskMaterial = new Material(eyeMaskShader);
			eyeMaskMaterial.SetColor("_Color", eyeMaskColor);
		}
		if (eyeMaskMaterial == null)
		{
			base.enabled = false;
			UnityEngine.Debug.LogWarning("EyeMask materil is null or EyeMask shader not found!");
		}
		else
		{
			PrepareCameras();
			Camera.onPreRender = (Camera.CameraCallback)Delegate.Combine(Camera.onPreRender, new Camera.CameraCallback(OnCustomPreRender));
			CreateCommandBuffer();
		}
	}

	private void OnDisable()
	{
		Camera.onPreRender = (Camera.CameraCallback)Delegate.Remove(Camera.onPreRender, new Camera.CameraCallback(OnCustomPreRender));
		foreach (EyeMaskData cameraData in cameraDataList)
		{
			if (cameraData.camera != null && cameraData.cmdBuf != null)
			{
				RemoveCameraCommandBuffer(cameraData);
			}
		}
		CleanEyeMask();
	}

	private void CreateCommandBuffer()
	{
		if (VerifyCommadBuffer())
		{
			return;
		}
		if (eyeMaskMeshLeft == null || eyeMaskMeshRight == null)
		{
			eyeMaskMeshLeft = GetStencilMesh(Eye.LeftEye);
			eyeMaskMeshRight = GetStencilMesh(Eye.RightEye);
			if (eyeMaskMeshLeft == null || eyeMaskMeshRight == null)
			{
				UnityEngine.Debug.LogWarning("Stencil Mesh is not exist, disable EyeMask.");
				base.enabled = false;
				return;
			}
		}
		foreach (EyeMaskData cameraData in cameraDataList)
		{
			if (cameraData.eyeSide == Eye.LeftEye)
			{
				CommandBuffer commandBuffer = new CommandBuffer();
				commandBuffer.name = "EyeMaskLeft";
				commandBuffer.DrawMesh(eyeMaskMeshLeft, Matrix4x4.identity, eyeMaskMaterial, 0, 0);
				cameraData.cmdBuf = commandBuffer;
			}
			else if (cameraData.eyeSide == Eye.RightEye)
			{
				CommandBuffer commandBuffer2 = new CommandBuffer();
				commandBuffer2.name = "EyeMaskRight";
				commandBuffer2.DrawMesh(eyeMaskMeshRight, Matrix4x4.identity, eyeMaskMaterial, 0, 0);
				cameraData.cmdBuf = commandBuffer2;
			}
			else if (cameraData.eyeSide == Eye.BothEye)
			{
				if (eyeMaskMeshBoth == null)
				{
					eyeMaskMeshBoth = GetStencilMeshBoth(eyeMaskMeshLeft, eyeMaskMeshRight);
					float value = Mathf.Max(Mathf.Abs(eyeMaskMeshLeft.bounds.max.x), Mathf.Abs(eyeMaskMeshRight.bounds.min.x));
					eyeMaskMaterial.SetFloat("_MeshOffsetX", value);
				}
				CommandBuffer commandBuffer3 = new CommandBuffer();
				commandBuffer3.name = "EyeMaskBoth";
				commandBuffer3.DrawMesh(eyeMaskMeshBoth, Matrix4x4.identity, eyeMaskMaterial, 0, 1);
				cameraData.cmdBuf = commandBuffer3;
			}
		}
	}

	private void OnCustomPreRender(Camera cam)
	{
		if (!VerifyCommadBuffer())
		{
			UnityEngine.Debug.LogWarning("Verify CommandBuffer failed!");
			return;
		}
		foreach (EyeMaskData cameraData in cameraDataList)
		{
			if (!(cameraData.camera != cam))
			{
				RemoveCameraCommandBuffer(cameraData);
				AddCameraCommandBuffer(cameraData);
			}
		}
	}

	private Mesh GetStencilMesh(Eye eyeSide)
	{
		int vertexCount = 0;
		int triangleCount = 0;
		IntPtr vertexDataPtr = IntPtr.Zero;
		IntPtr indexDataPtr = IntPtr.Zero;
		Render.UPvr_GetStencilMesh((int)eyeSide, ref vertexCount, ref triangleCount, ref vertexDataPtr, ref indexDataPtr);
		if (vertexCount <= 0 || triangleCount <= 0 || vertexDataPtr == IntPtr.Zero || indexDataPtr == IntPtr.Zero)
		{
			return null;
		}
		Vector3[] array = new Vector3[vertexCount];
		int[] array2 = new int[triangleCount * 3];
		float[] array3 = new float[vertexCount * 3];
		int[] array4 = new int[triangleCount * 3];
		Marshal.Copy(vertexDataPtr, array3, 0, vertexCount * 3);
		Marshal.Copy(indexDataPtr, array4, 0, triangleCount * 3);
		for (int i = 0; i < vertexCount; i++)
		{
			array[i] = new Vector3(array3[3 * i], array3[3 * i + 1], zDir);
		}
		for (int j = 0; j < triangleCount; j++)
		{
			array2[3 * j] = array4[3 * j + 2];
			array2[3 * j + 1] = array4[3 * j + 1];
			array2[3 * j + 2] = array4[3 * j];
		}
		Mesh mesh = new Mesh();
		mesh.name = "EyeMaskMesh";
		mesh.vertices = array;
		mesh.SetIndices(array2, MeshTopology.Triangles, 0);
		return mesh;
	}

	private Mesh GetStencilMeshBoth(Mesh leftMesh, Mesh rightMesh)
	{
		float num = Mathf.Max(Mathf.Abs(leftMesh.bounds.max.x), Mathf.Abs(rightMesh.bounds.min.x));
		Mesh mesh = new Mesh();
		mesh.name = "EyeMaskBoth";
		CombineInstance combineInstance = default(CombineInstance);
		combineInstance.mesh = leftMesh;
		Matrix4x4 identity = Matrix4x4.identity;
		identity.SetTRS(Vector3.left * num, Quaternion.identity, Vector3.one);
		combineInstance.transform = identity;
		CombineInstance combineInstance2 = default(CombineInstance);
		combineInstance2.mesh = rightMesh;
		Matrix4x4 identity2 = Matrix4x4.identity;
		identity2.SetTRS(Vector3.right * num, Quaternion.identity, Vector3.one);
		combineInstance2.transform = identity2;
		CombineInstance[] combine = new CombineInstance[2] { combineInstance, combineInstance2 };
		mesh.CombineMeshes(combine);
		return mesh;
	}

	private bool VerifyCommadBuffer()
	{
		if (cameraDataList == null || cameraDataList.Count <= 0)
		{
			return false;
		}
		foreach (EyeMaskData cameraData in cameraDataList)
		{
			if (cameraData == null || cameraData.cmdBuf == null)
			{
				return false;
			}
		}
		return true;
	}

	private void PrepareCameras()
	{
		cameraDataList.Clear();
		if (Pvr_UnitySDKRender.Instance.StereoRenderPath == StereoRenderingPathPico.SinglePass)
		{
			if (Pvr_UnitySDKEyeManager.Instance.BothEyeCamera == null)
			{
				UnityEngine.Debug.LogWarning("BothEye Camera is null!");
				return;
			}
			EyeMaskData eyeMaskData = new EyeMaskData();
			eyeMaskData.eyeSide = Eye.BothEye;
			eyeMaskData.camera = Pvr_UnitySDKEyeManager.Instance.BothEyeCamera;
			cameraDataList.Add(eyeMaskData);
		}
		else if (Pvr_UnitySDKEyeManager.Instance.LeftEyeCamera == null || Pvr_UnitySDKEyeManager.Instance.RightEyeCamera == null)
		{
			UnityEngine.Debug.LogWarning("LeftEye or RightEye Camera is null!");
		}
		else
		{
			EyeMaskData eyeMaskData2 = new EyeMaskData();
			eyeMaskData2.eyeSide = Eye.LeftEye;
			eyeMaskData2.camera = Pvr_UnitySDKEyeManager.Instance.LeftEyeCamera;
			eyeMaskData2.cmdBuf = null;
			cameraDataList.Add(eyeMaskData2);
			EyeMaskData eyeMaskData3 = new EyeMaskData();
			eyeMaskData3.eyeSide = Eye.RightEye;
			eyeMaskData3.camera = Pvr_UnitySDKEyeManager.Instance.RightEyeCamera;
			eyeMaskData3.cmdBuf = null;
			cameraDataList.Add(eyeMaskData3);
		}
	}

	private void AddCameraCommandBuffer(EyeMaskData data)
	{
		data.camera.AddCommandBuffer(CameraEvent.BeforeForwardOpaque, data.cmdBuf);
	}

	private void RemoveCameraCommandBuffer(EyeMaskData data)
	{
		data.camera.RemoveCommandBuffer(CameraEvent.BeforeForwardOpaque, data.cmdBuf);
	}

	private void CleanEyeMask()
	{
		cameraDataList.Clear();
		eyeMaskMeshLeft = null;
		eyeMaskMeshRight = null;
		eyeMaskMeshBoth = null;
		eyeMaskShader = null;
		eyeMaskMaterial = null;
	}
}
[RequireComponent(typeof(Camera))]
public class Pvr_UnitySDKEye : MonoBehaviour
{
	public static List<Pvr_UnitySDKEye> Instances = new List<Pvr_UnitySDKEye>();

	public Eye eyeSide;

	private int eyeCameraOriginCullingMask;

	private CameraClearFlags eyeCameraOriginClearFlag;

	private Color eyeCameraOriginBackgroundColor;

	private int lastBoundaryState;

	private Matrix4x4 realProj = Matrix4x4.identity;

	private const int bufferSize = 3;

	private int IDIndex;

	private RenderEventType eventType;

	private int previousId;

	public static bool setLevel = false;

	private Material mat_Vignette;

	public Camera eyecamera { get; private set; }

	private void Awake()
	{
		Instances.Add(this);
		eyecamera = GetComponent<Camera>();
	}

	private void Start()
	{
		Setup(eyeSide);
		SetupUpdate();
		if (eyecamera != null)
		{
			eyeCameraOriginCullingMask = eyecamera.cullingMask;
			eyeCameraOriginClearFlag = eyecamera.clearFlags;
			eyeCameraOriginBackgroundColor = eyecamera.backgroundColor;
		}
	}

	private void Update()
	{
		if (!(eyecamera != null) || !eyecamera.enabled)
		{
			return;
		}
		int num = BoundarySystem.UPvr_GetSeeThroughState();
		if (num == lastBoundaryState)
		{
			return;
		}
		switch (num)
		{
		case 2:
			eyeCameraOriginCullingMask = eyecamera.cullingMask;
			eyeCameraOriginClearFlag = eyecamera.clearFlags;
			eyeCameraOriginBackgroundColor = eyecamera.backgroundColor;
			eyecamera.cullingMask = 0;
			eyecamera.clearFlags = CameraClearFlags.Color;
			eyecamera.backgroundColor = Color.black;
			break;
		case 1:
			if (lastBoundaryState == 2)
			{
				if (eyecamera.cullingMask == 0)
				{
					eyecamera.cullingMask = eyeCameraOriginCullingMask;
				}
				if (eyecamera.clearFlags == CameraClearFlags.Color)
				{
					eyecamera.clearFlags = eyeCameraOriginClearFlag;
				}
				if (eyecamera.backgroundColor == Color.black)
				{
					eyecamera.backgroundColor = eyeCameraOriginBackgroundColor;
				}
			}
			break;
		default:
			if (lastBoundaryState == 2 || lastBoundaryState == 1)
			{
				if (eyecamera.cullingMask == 0)
				{
					eyecamera.cullingMask = eyeCameraOriginCullingMask;
				}
				if (eyecamera.clearFlags == CameraClearFlags.Color)
				{
					eyecamera.clearFlags = eyeCameraOriginClearFlag;
				}
				if (eyecamera.backgroundColor == Color.black)
				{
					eyecamera.backgroundColor = eyeCameraOriginBackgroundColor;
				}
			}
			break;
		}
		lastBoundaryState = num;
	}

	private void OnEnable()
	{
		if (GraphicsSettings.renderPipelineAsset != null)
		{
			RenderPipeline.beginCameraRendering += MyPreRender;
		}
	}

	private void OnDisable()
	{
		if (GraphicsSettings.renderPipelineAsset != null)
		{
			RenderPipeline.beginCameraRendering -= MyPreRender;
		}
	}

	private void OnDestroy()
	{
		Instances.Remove(this);
	}

	public void MyPreRender(Camera camera)
	{
		if (!(camera.gameObject != base.gameObject))
		{
			OnPreRender();
		}
	}

	public void MyPreRender(ScriptableRenderContext context, Camera camera)
	{
		if (!(camera.gameObject != base.gameObject))
		{
			OnPreRender();
		}
	}

	public void MyPostRender(ScriptableRenderContext context, Camera camera)
	{
		if (!(camera.gameObject != base.gameObject))
		{
			OnPostRender();
		}
	}

	private void OnPreRender()
	{
		if (!eyecamera.enabled)
		{
			return;
		}
		if (Pvr_UnitySDKRender.Instance.StereoRendering != null)
		{
			if (Pvr_UnitySDKRender.Instance.isSwitchSDK)
			{
				return;
			}
			Pvr_UnitySDKRender.Instance.StereoRendering.OnSDKPreRender();
		}
		SetFFRParameter();
		Pvr_UnitySDKPluginEvent.Issue(RenderEventType.BeginEye);
	}

	private void OnPostRender()
	{
		if (!eyecamera.enabled)
		{
			return;
		}
		Pvr_UnitySDKAPI.System.UPvr_UnityEventData(Pvr_UnitySDKAPI.System.UPvr_GetEyeBufferData(Pvr_UnitySDKRender.Instance.eyeTextureIds[IDIndex]));
		Pvr_UnitySDKPluginEvent.Issue(eventType);
		if (Pvr_UnitySDKRender.Instance.StereoRendering != null)
		{
			if (Pvr_UnitySDKRender.Instance.isSwitchSDK)
			{
				return;
			}
			Pvr_UnitySDKRender.Instance.StereoRendering.OnSDKPostRender();
		}
		Pvr_UnitySDKPluginEvent.Issue(RenderEventType.EndEye);
	}

	public void EyeRender()
	{
		SetupUpdate();
		if (Pvr_UnitySDKRender.Instance.eyeTextures[IDIndex] != null)
		{
			Pvr_UnitySDKRender.Instance.eyeTextures[IDIndex].DiscardContents();
			eyecamera.targetTexture = Pvr_UnitySDKRender.Instance.eyeTextures[IDIndex];
		}
	}

	private void Setup(Eye eyeSide)
	{
		eyecamera = GetComponent<Camera>();
		switch (eyeSide)
		{
		case Eye.LeftEye:
		case Eye.RightEye:
			base.transform.localPosition = Pvr_UnitySDKManager.SDK.EyeOffset(eyeSide);
			break;
		case Eye.BothEye:
			base.transform.localPosition = Vector3.zero;
			break;
		}
		eyecamera.aspect = Pvr_UnitySDKManager.SDK.EyesAspect;
		eyecamera.rect = new Rect(0f, 0f, 1f, 1f);
		if (Pvr_UnitySDKRender.Instance.StereoRenderPath == StereoRenderingPathPico.MultiPass)
		{
			eventType = ((eyeSide == Eye.LeftEye) ? RenderEventType.LeftEyeEndFrame : RenderEventType.RightEyeEndFrame);
		}
		else
		{
			eventType = RenderEventType.BothEyeEndFrame;
		}
	}

	private void SetupUpdate()
	{
		if (eyeSide == Eye.LeftEye || eyeSide == Eye.RightEye)
		{
			eyecamera.enabled = !Pvr_UnitySDKManager.SDK.Monoscopic && Pvr_UnitySDKRender.Instance.StereoRenderPath != StereoRenderingPathPico.SinglePass;
		}
		else if (eyeSide == Eye.BothEye)
		{
			eyecamera.enabled = Pvr_UnitySDKRender.Instance.StereoRenderPath == StereoRenderingPathPico.SinglePass;
		}
		eyecamera.fieldOfView = Pvr_UnitySDKRender.Instance.EyeVFoV;
		eyecamera.aspect = Pvr_UnitySDKManager.SDK.EyesAspect;
		if (eyeSide == Eye.LeftEye || eyeSide == Eye.RightEye)
		{
			IDIndex = Pvr_UnitySDKRender.Instance.currEyeTextureIdx + (int)eyeSide * 3;
		}
		else if (eyeSide == Eye.BothEye)
		{
			IDIndex = Pvr_UnitySDKRender.Instance.currEyeTextureIdx;
			Pvr_UnitySDKRender.Instance.isSwitchSDK = Pvr_UnitySDKRender.Instance.lastEyeTextureIdx == Pvr_UnitySDKRender.Instance.currEyeTextureIdx;
			Pvr_UnitySDKRender.Instance.lastEyeTextureIdx = Pvr_UnitySDKRender.Instance.currEyeTextureIdx;
		}
	}

	public void RefreshCameraPosition(float ipd)
	{
		Pvr_UnitySDKManager.SDK.leftEyeOffset = new Vector3((0f - ipd) / 2f, 0f, 0f);
		Pvr_UnitySDKManager.SDK.rightEyeOffset = new Vector3(ipd / 2f, 0f, 0f);
		if (eyeSide == Eye.LeftEye || eyeSide == Eye.RightEye)
		{
			base.transform.localPosition = Pvr_UnitySDKManager.SDK.EyeOffset(eyeSide);
		}
		else if (eyeSide == Eye.BothEye)
		{
			eyecamera.stereoSeparation = ipd;
		}
	}

	private void DrawVignetteLine()
	{
		if (null == mat_Vignette)
		{
			mat_Vignette = new Material(Shader.Find("Diffuse"));
			if (null == mat_Vignette)
			{
				return;
			}
		}
		GL.PushMatrix();
		mat_Vignette.SetPass(0);
		GL.LoadOrtho();
		vignette();
		GL.PopMatrix();
	}

	private void vignette()
	{
		GL.Begin(7);
		GL.Color(Color.black);
		GL.Vertex3(0f, 1f, 0f);
		GL.Vertex3(1f, 1f, 0f);
		GL.Vertex3(1f, 0.995f, 0f);
		GL.Vertex3(0f, 0.995f, 0f);
		GL.Vertex3(0f, 0f, 0f);
		GL.Vertex3(0f, 0.005f, 0f);
		GL.Vertex3(1f, 0.005f, 0f);
		GL.Vertex3(1f, 0f, 0f);
		GL.Vertex(new Vector3(0f, 1f, 0f));
		GL.Vertex(new Vector3(0.005f, 1f, 0f));
		GL.Vertex(new Vector3(0.005f, 0f, 0f));
		GL.Vertex(new Vector3(0f, 0f, 0f));
		GL.Vertex(new Vector3(0.995f, 1f, 0f));
		GL.Vertex(new Vector3(1f, 1f, 0f));
		GL.Vertex(new Vector3(1f, 0f, 0f));
		GL.Vertex(new Vector3(0.995f, 0f, 0f));
		GL.End();
	}

	private void SetFFRParameter()
	{
		Vector3 vector = Vector3.zero;
		if (Pvr_UnitySDKManager.SDK.isEnterVRMode && Pvr_UnitySDKEyeManager.supportEyeTracking && Pvr_UnitySDKEyeManager.Instance.EyeTracking)
		{
			vector = Pvr_UnitySDKAPI.System.UPvr_getEyeTrackingPos();
		}
		int textureId = Pvr_UnitySDKRender.Instance.eyeTextureIds[IDIndex];
		Render.UPvr_SetFoveationResource(textureId, previousId, vector.x, vector.y);
		previousId = textureId;
	}
}
public class Pvr_UnitySDKEyeManager : MonoBehaviour
{
	private static Pvr_UnitySDKEyeManager instance;

	private Pvr_UnitySDKEye[] eyes;

	[HideInInspector]
	public Camera LeftEyeCamera;

	[HideInInspector]
	public Camera RightEyeCamera;

	[HideInInspector]
	public Camera MonoEyeCamera;

	[HideInInspector]
	public Camera BothEyeCamera;

	private int MonoEyeTextureID;

	private readonly int WaitSplashScreenFrames = 3;

	private int frameNum;

	[SerializeField]
	[HideInInspector]
	private bool foveatedRendering;

	[SerializeField]
	[HideInInspector]
	private EFoveationLevel foveationLevel;

	private int eyeTextureId;

	private RenderEventType eventType = RenderEventType.LeftEyeEndFrame;

	private Pvr_UnitySDKEyeOverlay compositeLayer;

	private int overlayLayerDepth = 1;

	private int underlayLayerDepth;

	private bool isHeadLocked;

	private int layerFlags;

	[HideInInspector]
	public bool EyeTracking;

	[HideInInspector]
	public Vector3 eyePoint;

	private EyeTrackingData eyePoseData;

	[HideInInspector]
	public static bool supportEyeTracking;

	[Tooltip("If true, specific color gradient when switching scenes.")]
	public bool screenFade;

	[Tooltip("Define the duration of screen fade.")]
	public float fadeTime = 5f;

	[Tooltip("Define the color of screen fade.")]
	public Color fadeColor = new Color(0f, 0f, 0f, 1f);

	public int renderQueue = 5000;

	private MeshRenderer fadeMeshRenderer;

	private MeshFilter fadeMeshFilter;

	private Material fadeMaterial;

	private float elapsedTime;

	private bool isFading;

	private float currentAlpha;

	private float nowFadeAlpha;

	public static Pvr_UnitySDKEyeManager Instance
	{
		get
		{
			if (instance == null)
			{
				PLOG.E("Pvr_UnitySDKEyeManager instance is not init yet...");
			}
			return instance;
		}
	}

	public Pvr_UnitySDKEye[] Eyes
	{
		get
		{
			if (eyes == null)
			{
				eyes = Pvr_UnitySDKEye.Instances.ToArray();
			}
			return eyes;
		}
	}

	[HideInInspector]
	public bool FoveatedRendering
	{
		get
		{
			return foveatedRendering;
		}
		set
		{
			if (value == foveatedRendering)
			{
				return;
			}
			foveatedRendering = value;
			if (UnityEngine.Application.isPlaying)
			{
				Render.UPvr_EnableFoveation(enable: true);
				if (!foveatedRendering)
				{
					Render.SetFoveatedRenderingLevel((EFoveationLevel)(-1));
				}
			}
		}
	}

	[HideInInspector]
	public EFoveationLevel FoveationLevel
	{
		get
		{
			return foveationLevel;
		}
		set
		{
			if (value != foveationLevel)
			{
				foveationLevel = value;
			}
		}
	}

	private void SetCameraEnableEditor()
	{
		MonoEyeCamera.enabled = !Pvr_UnitySDKManager.SDK.VRModeEnabled || Pvr_UnitySDKManager.SDK.Monoscopic;
		for (int i = 0; i < Eyes.Length; i++)
		{
			if (Eyes[i].eyeSide == Eye.LeftEye || Eyes[i].eyeSide == Eye.RightEye)
			{
				Eyes[i].eyecamera.enabled = Pvr_UnitySDKManager.SDK.VRModeEnabled;
			}
			else if (Eyes[i].eyeSide == Eye.BothEye)
			{
				Eyes[i].eyecamera.enabled = false;
			}
		}
	}

	private void SetCamerasEnableByStereoRendering()
	{
		MonoEyeCamera.enabled = Pvr_UnitySDKManager.SDK.Monoscopic && Pvr_UnitySDKRender.Instance.StereoRenderPath == StereoRenderingPathPico.MultiPass;
	}

	private void SetupMonoCamera()
	{
		base.transform.localPosition = Vector3.zero;
		MonoEyeCamera.aspect = Pvr_UnitySDKManager.SDK.EyesAspect;
		MonoEyeCamera.rect = new Rect(0f, 0f, 1f, 1f);
	}

	private void SetupUpdate()
	{
		MonoEyeCamera.fieldOfView = Pvr_UnitySDKRender.Instance.EyeVFoV;
		MonoEyeCamera.aspect = Pvr_UnitySDKManager.SDK.EyesAspect;
		MonoEyeTextureID = Pvr_UnitySDKRender.Instance.currEyeTextureIdx;
	}

	private void MonoEyeRender()
	{
		SetupUpdate();
		if (Pvr_UnitySDKRender.Instance.eyeTextures[MonoEyeTextureID] != null)
		{
			Pvr_UnitySDKRender.Instance.eyeTextures[MonoEyeTextureID].DiscardContents();
			MonoEyeCamera.targetTexture = Pvr_UnitySDKRender.Instance.eyeTextures[MonoEyeTextureID];
		}
	}

	private void Awake()
	{
		if (MonoEyeCamera == null)
		{
			MonoEyeCamera = GetComponent<Camera>();
		}
		if (LeftEyeCamera == null)
		{
			LeftEyeCamera = base.gameObject.transform.Find("LeftEye").GetComponent<Camera>();
		}
		if (RightEyeCamera == null)
		{
			RightEyeCamera = base.gameObject.transform.Find("RightEye").GetComponent<Camera>();
		}
		if (BothEyeCamera == null)
		{
			BothEyeCamera = base.gameObject.transform.Find("BothEye").GetComponent<Camera>();
		}
		if (BothEyeCamera != null)
		{
			BothEyeCamera.transform.GetComponent<Pvr_UnitySDKEye>().eyeSide = Eye.BothEye;
		}
		CreateFadeMesh();
		SetCurrentAlpha(0f);
		Render.UPvr_EnableFoveation(enable: true);
		if (foveatedRendering)
		{
			Render.SetFoveatedRenderingLevel(foveationLevel);
		}
		else
		{
			Render.SetFoveatedRenderingLevel((EFoveationLevel)(-1));
		}
		Pvr_UnitySDKManager.eventEnterVRMode = (Func<bool>)Delegate.Combine(Pvr_UnitySDKManager.eventEnterVRMode, new Func<bool>(SetEyeTrackingMode));
	}

	private void OnEnable()
	{
		if (instance == null)
		{
			instance = this;
		}
		else if (instance != this)
		{
			instance = this;
		}
		if (Pvr_UnitySDKRender.Instance.StereoRenderPath == StereoRenderingPathPico.SinglePass)
		{
			Pvr_UnitySDKRender.Instance.StereoRendering.InitEye(BothEyeCamera);
		}
		foreach (Pvr_UnitySDKEyeOverlay instance in Pvr_UnitySDKEyeOverlay.Instances)
		{
			instance.RefreshCamera();
			if (instance.overlayType == Pvr_UnitySDKEyeOverlay.OverlayType.Overlay)
			{
				if (instance.overlayShape == Pvr_UnitySDKEyeOverlay.OverlayShape.Cylinder)
				{
					UnityEngine.Debug.Log("DISFT Cylinder OverLay = Enable");
				}
				if (instance.overlayShape == Pvr_UnitySDKEyeOverlay.OverlayShape.Equirect)
				{
					UnityEngine.Debug.Log("DISFT 360 OverLay= Enable");
				}
				if (instance.overlayShape == Pvr_UnitySDKEyeOverlay.OverlayShape.Quad)
				{
					UnityEngine.Debug.Log("DISFT 2D OverLay= Enable");
				}
			}
			if (instance.overlayType == Pvr_UnitySDKEyeOverlay.OverlayType.Underlay)
			{
				UnityEngine.Debug.Log("DISFT UnderLay= Enable");
			}
		}
		GfxDeviceAdvanceFrameGLES();
		StartCoroutine("EndOfFrame");
		if (screenFade)
		{
			StartCoroutine(ScreenFade(1f, 0f));
		}
	}

	private void Start()
	{
		SetCamerasEnableByStereoRendering();
		SetupMonoCamera();
	}

	private void Update()
	{
		if (Pvr_UnitySDKRender.Instance.StereoRenderPath == StereoRenderingPathPico.SinglePass)
		{
			for (int i = 0; i < Eyes.Length; i++)
			{
				if (Eyes[i].isActiveAndEnabled && Eyes[i].eyeSide == Eye.BothEye)
				{
					Eyes[i].EyeRender();
				}
			}
		}
		if (Pvr_UnitySDKRender.Instance.StereoRenderPath != 0)
		{
			return;
		}
		if (!Pvr_UnitySDKManager.SDK.Monoscopic)
		{
			for (int j = 0; j < Eyes.Length; j++)
			{
				if (Eyes[j].isActiveAndEnabled && Eyes[j].eyeSide != Eye.BothEye)
				{
					Eyes[j].EyeRender();
				}
			}
		}
		else
		{
			MonoEyeRender();
		}
	}

	private void OnPause()
	{
		Pvr_UnitySDKManager.eventEnterVRMode = (Func<bool>)Delegate.Remove(Pvr_UnitySDKManager.eventEnterVRMode, new Func<bool>(SetEyeTrackingMode));
	}

	private void OnDisable()
	{
		StopAllCoroutines();
	}

	private void OnDestroy()
	{
		DestoryFadeMesh();
	}

	private void OnPostRender()
	{
		long data = Pvr_UnitySDKAPI.System.UPvr_GetEyeBufferData(Pvr_UnitySDKRender.Instance.eyeTextureIds[Pvr_UnitySDKRender.Instance.currEyeTextureIdx]);
		Pvr_UnitySDKAPI.System.UPvr_UnityEventData(data);
		Pvr_UnitySDKPluginEvent.Issue(RenderEventType.LeftEyeEndFrame);
		Pvr_UnitySDKAPI.System.UPvr_UnityEventData(data);
		Pvr_UnitySDKPluginEvent.Issue(RenderEventType.RightEyeEndFrame);
	}

	private IEnumerator EndOfFrame()
	{
		while (true)
		{
			yield return new WaitForEndOfFrame();
			if (!Pvr_UnitySDKManager.SDK.isEnterVRMode)
			{
				GL.Clear(clearDepth: false, clearColor: true, Color.black);
			}
			if (Pvr_UnitySDKRender.Instance.isFirstStartup && frameNum == WaitSplashScreenFrames)
			{
				Pvr_UnitySDKAPI.System.UPvr_RemovePlatformLogo();
				if (Pvr_UnitySDKManager.SDK.ResetTrackerOnLoad)
				{
					UnityEngine.Debug.Log("Reset Tracker OnLoad");
					Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(1, 1);
				}
				Pvr_UnitySDKAPI.System.UPvr_StartVRModel();
				Pvr_UnitySDKRender.Instance.isFirstStartup = false;
			}
			else if (Pvr_UnitySDKRender.Instance.isFirstStartup && frameNum < WaitSplashScreenFrames)
			{
				PLOG.I("frameNum:" + frameNum);
				frameNum++;
			}
			if (GraphicsSettings.renderPipelineAsset != null)
			{
				for (int i = 0; i < Eyes.Length; i++)
				{
					if (!Eyes[i].isActiveAndEnabled || !Eyes[i].eyecamera.enabled)
					{
						continue;
					}
					switch (Eyes[i].eyeSide)
					{
					case Eye.LeftEye:
						eyeTextureId = Pvr_UnitySDKRender.Instance.eyeTextureIds[Pvr_UnitySDKRender.Instance.currEyeTextureIdx];
						eventType = RenderEventType.LeftEyeEndFrame;
						break;
					case Eye.RightEye:
						if (!Pvr_UnitySDKManager.SDK.Monoscopic)
						{
							eyeTextureId = Pvr_UnitySDKRender.Instance.eyeTextureIds[Pvr_UnitySDKRender.Instance.currEyeTextureIdx + 3];
						}
						else
						{
							eyeTextureId = Pvr_UnitySDKRender.Instance.eyeTextureIds[Pvr_UnitySDKRender.Instance.currEyeTextureIdx];
						}
						eventType = RenderEventType.RightEyeEndFrame;
						break;
					case Eye.BothEye:
						eyeTextureId = Pvr_UnitySDKRender.Instance.eyeTextureIds[Pvr_UnitySDKRender.Instance.currEyeTextureIdx];
						eventType = RenderEventType.BothEyeEndFrame;
						break;
					}
					Pvr_UnitySDKAPI.System.UPvr_UnityEventData(Pvr_UnitySDKAPI.System.UPvr_GetEyeBufferData(eyeTextureId));
					Pvr_UnitySDKPluginEvent.Issue(eventType);
					Pvr_UnitySDKPluginEvent.Issue(RenderEventType.EndEye);
				}
			}
			int num = BoundarySystem.UPvr_GetSeeThroughState();
			if (Pvr_UnitySDKEyeOverlay.Instances.Count > 0 && num != 2)
			{
				overlayLayerDepth = 1;
				underlayLayerDepth = 0;
				Pvr_UnitySDKEyeOverlay.Instances.Sort();
				for (int j = 0; j < Pvr_UnitySDKEyeOverlay.Instances.Count; j++)
				{
					compositeLayer = Pvr_UnitySDKEyeOverlay.Instances[j];
					if (!compositeLayer.isActiveAndEnabled || (compositeLayer.layerTextures[0] == null && compositeLayer.layerTextures[1] == null && !compositeLayer.isExternalAndroidSurface) || (compositeLayer.layerTransform != null && !compositeLayer.layerTransform.gameObject.activeSelf))
					{
						continue;
					}
					layerFlags = 0;
					if (compositeLayer.overlayShape == Pvr_UnitySDKEyeOverlay.OverlayShape.Quad || compositeLayer.overlayShape == Pvr_UnitySDKEyeOverlay.OverlayShape.Cylinder)
					{
						if (compositeLayer.overlayType == Pvr_UnitySDKEyeOverlay.OverlayType.Overlay)
						{
							isHeadLocked = false;
							if (compositeLayer.layerTransform != null && compositeLayer.layerTransform.parent == base.transform)
							{
								isHeadLocked = true;
							}
							if (compositeLayer.isExternalAndroidSurface)
							{
								layerFlags |= 1;
								CreateExternalSurface(compositeLayer, overlayLayerDepth);
							}
							Render.UPvr_SetOverlayModelViewMatrix((int)compositeLayer.overlayType, (int)compositeLayer.overlayShape, compositeLayer.layerTextureIds[0], 0, overlayLayerDepth, isHeadLocked, layerFlags, compositeLayer.MVMatrixs[0], compositeLayer.ModelScales[0], compositeLayer.ModelRotations[0], compositeLayer.ModelTranslations[0], compositeLayer.CameraRotations[0], compositeLayer.CameraTranslations[0], compositeLayer.GetLayerColorScale(), compositeLayer.GetLayerColorOffset());
							Render.UPvr_SetOverlayModelViewMatrix((int)compositeLayer.overlayType, (int)compositeLayer.overlayShape, compositeLayer.layerTextureIds[1], 1, overlayLayerDepth, isHeadLocked, layerFlags, compositeLayer.MVMatrixs[1], compositeLayer.ModelScales[1], compositeLayer.ModelRotations[1], compositeLayer.ModelTranslations[1], compositeLayer.CameraRotations[1], compositeLayer.CameraTranslations[1], compositeLayer.GetLayerColorScale(), compositeLayer.GetLayerColorOffset());
							overlayLayerDepth++;
						}
						else if (compositeLayer.overlayType == Pvr_UnitySDKEyeOverlay.OverlayType.Underlay)
						{
							if (compositeLayer.isExternalAndroidSurface)
							{
								layerFlags |= 1;
								CreateExternalSurface(compositeLayer, underlayLayerDepth);
							}
							Render.UPvr_SetOverlayModelViewMatrix((int)compositeLayer.overlayType, (int)compositeLayer.overlayShape, compositeLayer.layerTextureIds[0], 0, underlayLayerDepth, isHeadLocked: false, layerFlags, compositeLayer.MVMatrixs[0], compositeLayer.ModelScales[0], compositeLayer.ModelRotations[0], compositeLayer.ModelTranslations[0], compositeLayer.CameraRotations[0], compositeLayer.CameraTranslations[0], compositeLayer.GetLayerColorScale(), compositeLayer.GetLayerColorOffset());
							Render.UPvr_SetOverlayModelViewMatrix((int)compositeLayer.overlayType, (int)compositeLayer.overlayShape, compositeLayer.layerTextureIds[1], 1, underlayLayerDepth, isHeadLocked: false, layerFlags, compositeLayer.MVMatrixs[1], compositeLayer.ModelScales[1], compositeLayer.ModelRotations[1], compositeLayer.ModelTranslations[1], compositeLayer.CameraRotations[1], compositeLayer.CameraTranslations[1], compositeLayer.GetLayerColorScale(), compositeLayer.GetLayerColorOffset());
							underlayLayerDepth++;
						}
					}
					else if (compositeLayer.overlayShape == Pvr_UnitySDKEyeOverlay.OverlayShape.Equirect)
					{
						if (compositeLayer.isExternalAndroidSurface)
						{
							layerFlags |= 1;
							CreateExternalSurface(compositeLayer, 0);
						}
						Render.UPvr_SetupLayerData(0, 0, compositeLayer.layerTextureIds[0], (int)compositeLayer.overlayShape, layerFlags, compositeLayer.GetLayerColorScale(), compositeLayer.GetLayerColorOffset());
						Render.UPvr_SetupLayerData(0, 1, compositeLayer.layerTextureIds[1], (int)compositeLayer.overlayShape, layerFlags, compositeLayer.GetLayerColorScale(), compositeLayer.GetLayerColorOffset());
					}
				}
			}
			Pvr_UnitySDKAPI.System.UPvr_UnityEventData(Pvr_UnitySDKAPI.System.UPvr_GetEyeBufferData(0));
			Pvr_UnitySDKPluginEvent.Issue(RenderEventType.TimeWarp);
			Pvr_UnitySDKRender.Instance.currEyeTextureIdx = Pvr_UnitySDKRender.Instance.nextEyeTextureIdx;
			Pvr_UnitySDKRender.Instance.nextEyeTextureIdx = (Pvr_UnitySDKRender.Instance.nextEyeTextureIdx + 1) % 3;
		}
	}

	private void CreateExternalSurface(Pvr_UnitySDKEyeOverlay overlayInstance, int layerDepth)
	{
		if (overlayInstance.externalAndroidSurfaceObject == IntPtr.Zero)
		{
			overlayInstance.externalAndroidSurfaceObject = Render.UPvr_CreateLayerAndroidSurface((int)overlayInstance.overlayType, layerDepth);
			UnityEngine.Debug.LogFormat("CreateExternalSurface: Overlay Type:{0}, LayerDepth:{1}, SurfaceObject:{2}", overlayInstance.overlayType, layerDepth, overlayInstance.externalAndroidSurfaceObject);
			if (overlayInstance.externalAndroidSurfaceObject != IntPtr.Zero && overlayInstance.externalAndroidSurfaceObjectCreated != null)
			{
				overlayInstance.externalAndroidSurfaceObjectCreated();
			}
		}
	}

	public bool SetEyeTrackingMode()
	{
		supportEyeTracking = (Pvr_UnitySDKAPI.System.UPvr_GetTrackingMode() & 4) != 0;
		bool result = false;
		if (EyeTracking && supportEyeTracking)
		{
			result = Pvr_UnitySDKAPI.System.UPvr_setTrackingMode(6);
		}
		UnityEngine.Debug.Log("SetEyeTrackingMode EyeTracking " + EyeTracking + " supportEyeTracking " + supportEyeTracking + " result " + result);
		return result;
	}

	public Vector3 GetEyeTrackingPos()
	{
		if (!Instance.EyeTracking)
		{
			return Vector3.zero;
		}
		bool flag = Pvr_UnitySDKAPI.System.UPvr_getEyeTrackingData(ref eyePoseData);
		if (!flag)
		{
			PLOG.E("UPvr_getEyeTrackingData failed " + flag);
			return Vector3.zero;
		}
		EyeDeviceInfo deviceInfo = GetDeviceInfo();
		Vector3 zero = Vector3.zero;
		zero.x = 0.5f * (deviceInfo.targetFrustumLeft.right - deviceInfo.targetFrustumLeft.left);
		zero.y = 0.5f * (deviceInfo.targetFrustumLeft.top - deviceInfo.targetFrustumLeft.bottom);
		zero.z = deviceInfo.targetFrustumLeft.near;
		Vector3 foveatedGazeDirection = eyePoseData.foveatedGazeDirection;
		float num = Vector3.Dot(foveatedGazeDirection, Vector3.forward);
		if (num > float.Epsilon)
		{
			eyePoint = foveatedGazeDirection * (zero.z / num);
			eyePoint.x /= zero.x;
			eyePoint.y /= zero.y;
		}
		return eyePoint;
	}

	private EyeDeviceInfo GetDeviceInfo()
	{
		float num = Mathf.Tan(Pvr_UnitySDKRender.Instance.EyeVFoV / 2f * ((float)Math.PI / 180f));
		float num2 = Mathf.Tan(Pvr_UnitySDKRender.Instance.EyeHFoV / 2f * ((float)Math.PI / 180f));
		EyeDeviceInfo result = default(EyeDeviceInfo);
		result.targetFrustumLeft.left = 0f - LeftEyeCamera.nearClipPlane * num2;
		result.targetFrustumLeft.right = LeftEyeCamera.nearClipPlane * num2;
		result.targetFrustumLeft.top = LeftEyeCamera.nearClipPlane * num;
		result.targetFrustumLeft.bottom = 0f - LeftEyeCamera.nearClipPlane * num;
		result.targetFrustumLeft.near = LeftEyeCamera.nearClipPlane;
		result.targetFrustumLeft.far = LeftEyeCamera.farClipPlane;
		result.targetFrustumRight.left = 0f - RightEyeCamera.nearClipPlane * num2;
		result.targetFrustumRight.right = RightEyeCamera.nearClipPlane * num2;
		result.targetFrustumRight.top = RightEyeCamera.nearClipPlane * num;
		result.targetFrustumRight.bottom = 0f - RightEyeCamera.nearClipPlane * num;
		result.targetFrustumRight.near = RightEyeCamera.nearClipPlane;
		result.targetFrustumRight.far = RightEyeCamera.farClipPlane;
		return result;
	}

	private void CreateFadeMesh()
	{
		fadeMaterial = new Material(Shader.Find("Pvr_UnitySDK/Fade"));
		fadeMeshFilter = base.gameObject.AddComponent<MeshFilter>();
		fadeMeshRenderer = base.gameObject.AddComponent<MeshRenderer>();
		Mesh mesh = new Mesh();
		fadeMeshFilter.mesh = mesh;
		Vector3[] array = new Vector3[4];
		float num = 2f;
		float num2 = 2f;
		float z = 1f;
		array[0] = new Vector3(0f - num, 0f - num2, z);
		array[1] = new Vector3(num, 0f - num2, z);
		array[2] = new Vector3(0f - num, num2, z);
		array[3] = new Vector3(num, num2, z);
		mesh.vertices = array;
		mesh.triangles = new int[6] { 0, 2, 1, 2, 3, 1 };
		mesh.normals = new Vector3[4]
		{
			-Vector3.forward,
			-Vector3.forward,
			-Vector3.forward,
			-Vector3.forward
		};
		mesh.uv = new Vector2[4]
		{
			new Vector2(0f, 0f),
			new Vector2(1f, 0f),
			new Vector2(0f, 1f),
			new Vector2(1f, 1f)
		};
	}

	private void DestoryFadeMesh()
	{
		if (fadeMeshRenderer != null)
		{
			UnityEngine.Object.Destroy(fadeMeshRenderer);
		}
		if (fadeMaterial != null)
		{
			UnityEngine.Object.Destroy(fadeMaterial);
		}
		if (fadeMeshFilter != null)
		{
			UnityEngine.Object.Destroy(fadeMeshFilter);
		}
	}

	public void SetCurrentAlpha(float alpha)
	{
		currentAlpha = alpha;
		SetMaterialAlpha();
	}

	private IEnumerator ScreenFade(float startAlpha, float endAlpha)
	{
		float elapsedTime = 0f;
		while (elapsedTime < fadeTime)
		{
			elapsedTime += Time.deltaTime;
			nowFadeAlpha = Mathf.Lerp(startAlpha, endAlpha, Mathf.Clamp01(elapsedTime / fadeTime));
			SetMaterialAlpha();
			yield return new WaitForEndOfFrame();
		}
	}

	private void SetMaterialAlpha()
	{
		Color color = fadeColor;
		color.a = Mathf.Max(currentAlpha, nowFadeAlpha);
		isFading = color.a > 0f;
		if (fadeMaterial != null)
		{
			fadeMaterial.color = color;
			fadeMaterial.renderQueue = renderQueue;
			fadeMeshRenderer.material = fadeMaterial;
			fadeMeshRenderer.enabled = isFading;
		}
	}

	public bool GfxDeviceAdvanceFrameGLES()
	{
		return false;
	}
}
public class Pvr_UnitySDKEyeOverlay : MonoBehaviour, IComparable<Pvr_UnitySDKEyeOverlay>
{
	public delegate void ExternalAndroidSurfaceObjectCreated();

	public enum OverlayShape
	{
		Quad,
		Cylinder,
		Equirect
	}

	public enum OverlayType
	{
		Overlay,
		Underlay
	}

	public enum OverlayTexFilterMode
	{
		NotCare,
		Nearest,
		Linear,
		Nearest_Mipmap_Nearest,
		Linear_Mipmap_Nearest,
		Nearest_Mipmap_Linear,
		Linear_Mipmap_Linear
	}

	public static List<Pvr_UnitySDKEyeOverlay> Instances = new List<Pvr_UnitySDKEyeOverlay>();

	public int layerIndex;

	public OverlayType overlayType;

	public OverlayShape overlayShape;

	public Transform layerTransform;

	public Texture[] layerTextures = new Texture[2];

	public int[] layerTextureIds = new int[2];

	public Matrix4x4[] MVMatrixs = new Matrix4x4[2];

	public Vector3[] ModelScales = new Vector3[2];

	public Quaternion[] ModelRotations = new Quaternion[2];

	public Vector3[] ModelTranslations = new Vector3[2];

	public Quaternion[] CameraRotations = new Quaternion[2];

	public Vector3[] CameraTranslations = new Vector3[2];

	public Camera[] layerEyeCamera = new Camera[2];

	public bool overrideColorScaleAndOffset;

	public Vector4 colorScale = Vector4.one;

	public Vector4 colorOffset = Vector4.zero;

	private Vector4 overlayLayerColorScaleDefault = Vector4.one;

	private Vector4 overlayLayerColorOffsetDefault = Vector4.zero;

	public bool isExternalAndroidSurface;

	public IntPtr externalAndroidSurfaceObject = IntPtr.Zero;

	public ExternalAndroidSurfaceObjectCreated externalAndroidSurfaceObjectCreated;

	public int CompareTo(Pvr_UnitySDKEyeOverlay other)
	{
		return layerIndex.CompareTo(other.layerIndex);
	}

	private void Awake()
	{
		Instances.Add(this);
		if (Pvr_UnitySDKRender.Instance.StereoRenderPath == StereoRenderingPathPico.SinglePass)
		{
			layerEyeCamera[0] = Pvr_UnitySDKEyeManager.Instance.BothEyeCamera;
			layerEyeCamera[1] = Pvr_UnitySDKEyeManager.Instance.BothEyeCamera;
		}
		else if (Pvr_UnitySDKManager.SDK.Monoscopic)
		{
			layerEyeCamera[0] = Pvr_UnitySDKEyeManager.Instance.MonoEyeCamera;
			layerEyeCamera[1] = Pvr_UnitySDKEyeManager.Instance.MonoEyeCamera;
		}
		else
		{
			layerEyeCamera[0] = Pvr_UnitySDKEyeManager.Instance.LeftEyeCamera;
			layerEyeCamera[1] = Pvr_UnitySDKEyeManager.Instance.RightEyeCamera;
		}
		layerTransform = GetComponent<Transform>();
		if (layerTransform != null)
		{
			MeshRenderer component = layerTransform.GetComponent<MeshRenderer>();
			if (component != null)
			{
				component.enabled = false;
			}
		}
		InitializeBuffer();
	}

	private void LateUpdate()
	{
		UpdateCoords();
	}

	private void OnDestroy()
	{
		Instances.Remove(this);
	}

	public void RefreshCamera()
	{
		if (Pvr_UnitySDKRender.Instance.StereoRenderPath == StereoRenderingPathPico.SinglePass)
		{
			layerEyeCamera[0] = Pvr_UnitySDKEyeManager.Instance.BothEyeCamera;
			layerEyeCamera[1] = Pvr_UnitySDKEyeManager.Instance.BothEyeCamera;
		}
		else if (Pvr_UnitySDKManager.SDK.Monoscopic)
		{
			layerEyeCamera[0] = Pvr_UnitySDKEyeManager.Instance.MonoEyeCamera;
			layerEyeCamera[1] = Pvr_UnitySDKEyeManager.Instance.MonoEyeCamera;
		}
		else
		{
			layerEyeCamera[0] = Pvr_UnitySDKEyeManager.Instance.LeftEyeCamera;
			layerEyeCamera[1] = Pvr_UnitySDKEyeManager.Instance.RightEyeCamera;
		}
	}

	private void InitializeBuffer()
	{
		OverlayShape overlayShape = this.overlayShape;
		if ((uint)overlayShape > 2u)
		{
			return;
		}
		for (int i = 0; i < layerTextureIds.Length; i++)
		{
			if (layerTextures[i] != null)
			{
				layerTextureIds[i] = layerTextures[i].GetNativeTexturePtr().ToInt32();
			}
			else
			{
				UnityEngine.Debug.LogWarning($"{(Eye)i} Texture is null!");
			}
		}
	}

	private void UpdateCoords()
	{
		if (layerTransform == null || !layerTransform.gameObject.activeSelf || layerEyeCamera[0] == null || layerEyeCamera[1] == null)
		{
			return;
		}
		for (int i = 0; i < MVMatrixs.Length; i++)
		{
			if (Pvr_UnitySDKRender.Instance.StereoRenderPath == StereoRenderingPathPico.SinglePass)
			{
				Matrix4x4[] stereoWorldToCameraMat = Pvr_UnitySDKSinglePass.GetStereoWorldToCameraMat();
				MVMatrixs[i] = stereoWorldToCameraMat[i] * layerTransform.localToWorldMatrix;
			}
			else
			{
				MVMatrixs[i] = layerEyeCamera[i].worldToCameraMatrix * layerTransform.localToWorldMatrix;
			}
			ModelScales[i] = layerTransform.localScale;
			ModelRotations[i] = layerTransform.rotation;
			ModelTranslations[i] = layerTransform.position;
			CameraRotations[i] = layerEyeCamera[i].transform.rotation;
			CameraTranslations[i] = layerEyeCamera[i].transform.position;
		}
	}

	public void SetTexture(Texture texture)
	{
		for (int i = 0; i < layerTextures.Length; i++)
		{
			layerTextures[i] = texture;
		}
		InitializeBuffer();
	}

	public void SetLayerColorScaleAndOffset(Vector4 scale, Vector4 offset)
	{
		colorScale = scale;
		colorOffset = offset;
	}

	public Vector4 GetLayerColorScale()
	{
		if (!overrideColorScaleAndOffset)
		{
			return overlayLayerColorScaleDefault;
		}
		return colorScale;
	}

	public Vector4 GetLayerColorOffset()
	{
		if (!overrideColorScaleAndOffset)
		{
			return overlayLayerColorOffsetDefault;
		}
		return colorOffset;
	}
}
public class Pvr_UnitySDKRender
{
	private static Pvr_UnitySDKRender instance;

	public AndroidJavaObject activity;

	public static AndroidJavaClass javaVrActivityClass;

	public static AndroidJavaClass javaSysActivityClass;

	public static AndroidJavaClass javaserviceClass;

	public static AndroidJavaClass javaVrActivityLongReceiver;

	public static AndroidJavaClass javaVrActivityClientClass;

	private bool canConnecttoActivity;

	private bool isInitrenderThread = true;

	private string model;

	private Vector2 prefinger1 = new Vector2(0f, 0f);

	private Vector2 prefinger2 = new Vector2(0f, 0f);

	public int eyeTextureCount = 6;

	public RenderTexture[] eyeTextures;

	public int[] eyeTextureIds;

	public int currEyeTextureIdx;

	public int nextEyeTextureIdx = 1;

	public int lastEyeTextureIdx;

	public bool isSwitchSDK;

	public int RenderviewNumber;

	public bool isFirstStartup = true;

	public bool isShellMode;

	private StereoRenderingPathPico stereoRenderPath;

	private float rtScaleFactor = 1f;

	private float eyeVFov = 90f;

	private float eyeHFov = 90f;

	public static Pvr_UnitySDKRender Instance
	{
		get
		{
			if (instance == null)
			{
				instance = new Pvr_UnitySDKRender();
			}
			return instance;
		}
		set
		{
			instance = value;
		}
	}

	public StereoRenderingPathPico StereoRenderPath => stereoRenderPath;

	public SDKStereoRendering StereoRendering { get; private set; }

	public float RtScaleFactor
	{
		get
		{
			return rtScaleFactor;
		}
		set
		{
			if (value != rtScaleFactor)
			{
				rtScaleFactor = value;
				ReCreateEyeBuffer();
			}
		}
	}

	public float EyeVFoV
	{
		get
		{
			return eyeVFov;
		}
		set
		{
			if (value != eyeVFov)
			{
				eyeVFov = value;
			}
		}
	}

	public float EyeHFoV
	{
		get
		{
			return eyeHFov;
		}
		set
		{
			if (value != eyeHFov)
			{
				eyeHFov = value;
			}
		}
	}

	public Pvr_UnitySDKRender()
	{
		if (!canConnecttoActivity)
		{
			ConnectToAndriod();
			PLOG.I("PvrLog Init Render Ability Success!");
			isInitrenderThread = false;
		}
		Init();
	}

	public void ConnectToAndriod()
	{
		try
		{
			UnityEngine.Debug.Log("PvrLog SDK Version :  " + Pvr_UnitySDKAPI.System.UPvr_GetSDKVersion().ToString() + "  Unity Script Version :" + Pvr_UnitySDKAPI.System.UPvr_GetUnitySDKVersion().ToString());
			AndroidJavaClass androidJavaClass = new AndroidJavaClass("com.unity3d.player.UnityPlayer");
			activity = androidJavaClass.GetStatic<AndroidJavaObject>("currentActivity");
			javaVrActivityClass = new AndroidJavaClass("com.psmart.vrlib.VrActivity");
			javaserviceClass = new AndroidJavaClass("com.picovr.picovrlib.hummingbirdclient.UnityClient");
			javaVrActivityLongReceiver = new AndroidJavaClass("com.psmart.vrlib.HomeKeyReceiver");
			javaSysActivityClass = new AndroidJavaClass("com.psmart.aosoperation.SysActivity");
			javaVrActivityClientClass = new AndroidJavaClass("com.psmart.vrlib.PvrClient");
			Pvr_UnitySDKAPI.System.Pvr_SetInitActivity(activity.GetRawObject(), javaVrActivityClass.GetRawClass());
			model = javaVrActivityClass.CallStatic<string>("Pvr_GetBuildModel", Array.Empty<object>());
			double[] result = new double[5];
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaVrActivityClass, "getDPIParameters", activity);
			int res = -1;
			Render.UPvr_GetIntConfig(4, ref res);
			string result2 = "";
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result2, javaserviceClass, "getSysproc", "persist.pvr.debug.appfps");
			if (result2 != "")
			{
				Pvr_UnitySDKManager.SDK.systemFPS = Convert.ToBoolean(Convert.ToInt16(result2));
			}
			if (res == 0)
			{
				Render.UPvr_ChangeScreenParameters(model, (int)result[0], (int)result[1], result[2], result[3], result[4]);
				Screen.sleepTimeout = -1;
			}
			if (Pvr_UnitySDKAPI.System.UPvr_IsPicoActivity())
			{
				UnityEngine.Debug.Log("ConnectToAndriod set monoPresentation success ?-------------" + Pvr_UnitySDKAPI.System.UPvr_SetMonoPresentation());
				UnityEngine.Debug.Log("ConnectToAndriod presentation existed ?-------------" + Pvr_UnitySDKAPI.System.UPvr_IsPresentationExisted());
			}
			isShellMode = GetIsShellMode();
			UnityEngine.Debug.Log("ConnectToAndriod isShellMode ?-------------" + isShellMode);
		}
		catch (AndroidJavaException ex)
		{
			PLOG.E("ConnectToAndriod--catch" + ex.Message);
		}
		canConnecttoActivity = true;
	}

	public void Init()
	{
		if (InitRenderAbility())
		{
			UnityEngine.Debug.Log("PvrLog Init Render Ability Success!");
			isInitrenderThread = false;
		}
		else
		{
			UnityEngine.Debug.Log("PvrLog Init Render Ability Failed!");
		}
	}

	private bool InitRenderAbility()
	{
		if (UpdateRenderParaFrame() && CreateEyeBuffer())
		{
			float num = Pvr_UnitySDKAPI.System.UPvr_GetIPD();
			Pvr_UnitySDKManager.SDK.leftEyeOffset = new Vector3((0f - num) / 2f, 0f, 0f);
			Pvr_UnitySDKManager.SDK.rightEyeOffset = new Vector3(num / 2f, 0f, 0f);
			return true;
		}
		return false;
	}

	private bool UpdateRenderParaFrame()
	{
		EyeVFoV = GetEyeVFOV();
		EyeHFoV = GetEyeHFOV();
		Pvr_UnitySDKManager.SDK.EyesAspect = EyeHFoV / EyeVFoV;
		return true;
	}

	private bool CreateEyeBuffer()
	{
		Vector2 eyeBufferResolution = GetEyeBufferResolution();
		if (isFirstStartup)
		{
			InitSinglePass();
			Pvr_UnitySDKAPI.System.UPvr_SetSinglePassDepthBufferWidthHeight((int)eyeBufferResolution.x, (int)eyeBufferResolution.y);
		}
		eyeTextures = new RenderTexture[eyeTextureCount];
		eyeTextureIds = new int[eyeTextureCount];
		for (int i = 0; i < eyeTextureCount; i++)
		{
			if (null == eyeTextures[i])
			{
				try
				{
					ConfigureEyeBuffer(i, eyeBufferResolution);
				}
				catch (Exception ex)
				{
					PLOG.E("ConfigureEyeBuffer ERROR " + ex.Message);
					throw;
				}
			}
			if (!eyeTextures[i].IsCreated())
			{
				eyeTextures[i].Create();
				eyeTextureIds[i] = eyeTextures[i].GetNativeTexturePtr().ToInt32();
			}
			eyeTextureIds[i] = eyeTextures[i].GetNativeTexturePtr().ToInt32();
		}
		return true;
	}

	private void InitSinglePass()
	{
		bool flag = true;
		if (GraphicsSettings.renderPipelineAsset != null)
		{
			flag = false;
			if (!BoundarySystem.UPvr_EnableLWRP(enable: true))
			{
				UnityEngine.Debug.Log("UPvr_EnableLWRP return false");
			}
			Vector2 eyeBufferResolution = GetEyeBufferResolution();
			if (!BoundarySystem.UPvr_SetViewportSize((int)eyeBufferResolution.x, (int)eyeBufferResolution.y))
			{
				UnityEngine.Debug.Log("UPvr_SetViewportSize return false");
			}
		}
		if (Pvr_UnitySDKProjectSetting.GetProjectConfig().usesinglepass)
		{
			bool flag2 = false;
			if (flag)
			{
				flag2 = Pvr_UnitySDKAPI.System.UPvr_EnableSinglePass(enable: true);
			}
			if (flag2)
			{
				StereoRendering = new Pvr_UnitySDKSinglePass();
				stereoRenderPath = StereoRenderingPathPico.SinglePass;
				eyeTextureCount = 3;
			}
			UnityEngine.Debug.Log("EnableSinglePass supportSinglePass " + flag + " result " + flag2);
		}
	}

	public float GetEyeVFOV()
	{
		float res = 102f;
		try
		{
			Render.UPvr_GetFloatConfig(1, ref res);
			if (res <= 0f)
			{
				res = 102f;
			}
		}
		catch (Exception ex)
		{
			PLOG.E("GetEyeVFOV ERROR! " + ex.Message);
			throw;
		}
		return res;
	}

	public float GetEyeHFOV()
	{
		float res = 102f;
		try
		{
			Render.UPvr_GetFloatConfig(2, ref res);
			if (res <= 0f)
			{
				res = 102f;
			}
		}
		catch (Exception ex)
		{
			PLOG.E("GetEyeHFOV ERROR! " + ex.Message);
			throw;
		}
		return res;
	}

	private void ConfigureEyeBuffer(int eyeTextureIndex, Vector2 resolution)
	{
		int width = (int)resolution.x;
		int height = (int)resolution.y;
		eyeTextures[eyeTextureIndex] = new RenderTexture(width, height, (int)Pvr_UnitySDKProjectSetting.GetProjectConfig().rtBitDepth, Pvr_UnitySDKProjectSetting.GetProjectConfig().rtFormat);
		if (StereoRenderPath == StereoRenderingPathPico.MultiPass)
		{
			eyeTextures[eyeTextureIndex].anisoLevel = 0;
			eyeTextures[eyeTextureIndex].antiAliasing = Mathf.Max(QualitySettings.antiAliasing, (int)Pvr_UnitySDKProjectSetting.GetProjectConfig().rtAntiAlising);
			UnityEngine.Debug.Log("MultiPass ConfigureEyeBuffer eyeTextureIndex " + eyeTextureIndex);
		}
		else if (StereoRenderPath == StereoRenderingPathPico.SinglePass)
		{
			eyeTextures[eyeTextureIndex].useMipMap = false;
			eyeTextures[eyeTextureIndex].wrapMode = TextureWrapMode.Clamp;
			eyeTextures[eyeTextureIndex].filterMode = FilterMode.Bilinear;
			eyeTextures[eyeTextureIndex].anisoLevel = 1;
			eyeTextures[eyeTextureIndex].dimension = TextureDimension.Tex2DArray;
			eyeTextures[eyeTextureIndex].volumeDepth = 2;
			UnityEngine.Debug.Log("SinglePass ConfigureEyeBuffer eyeTextureIndex " + eyeTextureIndex);
		}
		eyeTextures[eyeTextureIndex].Create();
		if (eyeTextures[eyeTextureIndex].IsCreated())
		{
			eyeTextureIds[eyeTextureIndex] = eyeTextures[eyeTextureIndex].GetNativeTexturePtr().ToInt32();
			UnityEngine.Debug.Log("eyeTextureIndex : " + eyeTextureIndex);
		}
	}

	public bool ReCreateEyeBuffer()
	{
		if (!Pvr_UnitySDKProjectSetting.GetProjectConfig().usedefaultRenderTexture)
		{
			for (int i = 0; i < eyeTextureCount; i++)
			{
				if (eyeTextures[i] != null)
				{
					eyeTextures[i].Release();
				}
			}
			Array.Clear(eyeTextures, 0, eyeTextures.Length);
			return CreateEyeBuffer();
		}
		return false;
	}

	public void ReInit()
	{
		if (canConnecttoActivity && isInitrenderThread)
		{
			Init();
		}
	}

	public void IssueRenderThread()
	{
		if (canConnecttoActivity && !isInitrenderThread)
		{
			switch (QualitySettings.activeColorSpace)
			{
			case ColorSpace.Gamma:
				Render.UPvr_SetColorspaceType(0);
				break;
			case ColorSpace.Linear:
				Render.UPvr_SetColorspaceType(1);
				break;
			}
			Pvr_UnitySDKPluginEvent.Issue(RenderEventType.InitRenderThread);
			isInitrenderThread = true;
			if (StereoRendering != null)
			{
				StereoRendering.OnSDKRenderInited();
			}
			UnityEngine.Debug.Log("PvrLog IssueRenderThread end");
		}
		else
		{
			PLOG.I("PvrLog IssueRenderThread  canConnecttoActivity = " + canConnecttoActivity);
		}
	}

	private void AutoAdpatForPico1s()
	{
		Vector2 position = Input.touches[0].position;
		Vector2 position2 = Input.touches[1].position;
		if (Vector2.Distance(prefinger1, position) > 2f && Vector2.Distance(prefinger2, position2) > 2f)
		{
			float midH = (Input.touches[0].position.x + Input.touches[1].position.x) / (float)Screen.width - 1f;
			float midV = (Input.touches[0].position.y + Input.touches[1].position.y) / (float)Screen.height - 1f;
			Render.UPvr_SetRatio(midH, midV);
		}
		prefinger1 = position;
		prefinger2 = position2;
	}

	public Vector2 GetEyeBufferResolution()
	{
		int res = 1024;
		int res2 = 1024;
		if (Pvr_UnitySDKProjectSetting.GetProjectConfig().usedefaultRenderTexture)
		{
			try
			{
				Render.UPvr_GetIntConfig(0, ref res);
				Render.UPvr_GetIntConfig(1, ref res2);
			}
			catch (Exception ex)
			{
				PLOG.E("GetEyeBufferResolution ERROR! " + ex.Message);
				throw;
			}
		}
		else
		{
			res = (int)(Pvr_UnitySDKProjectSetting.GetProjectConfig().customRTSize.x * RtScaleFactor);
			res2 = (int)(Pvr_UnitySDKProjectSetting.GetProjectConfig().customRTSize.y * RtScaleFactor);
		}
		Vector2 vector = new Vector2(res, res2);
		UnityEngine.Debug.Log(string.Concat("DISFT Customize RenderTexture:", vector, ", scaleFactor: ", RtScaleFactor));
		return vector;
	}

	public bool GetUsePredictedMatrix()
	{
		return true;
	}

	public bool GetIsShellMode()
	{
		if (activity == null)
		{
			return false;
		}
		using (AndroidJavaObject androidJavaObject = activity.Call<AndroidJavaObject>("getPackageManager", Array.Empty<object>()).Call<AndroidJavaObject>("getApplicationInfo", new object[2]
		{
			activity.Call<string>("getPackageName", Array.Empty<object>()),
			128
		}))
		{
			AndroidJavaObject androidJavaObject2 = androidJavaObject.Get<AndroidJavaObject>("metaData");
			if (androidJavaObject2 != null)
			{
				if (androidJavaObject2.Call<int>("getInt", new object[1] { "shell_mode" }) == 1)
				{
					return true;
				}
				return false;
			}
		}
		return false;
	}
}
public class Pvr_UnitySDKSinglePass : SDKStereoRendering
{
	private static Camera bothCamera;

	private Matrix4x4[] unity_StereoMatrixP = new Matrix4x4[2];

	private Matrix4x4[] unity_StereoMatrixInvP = new Matrix4x4[2];

	private static Matrix4x4[] unity_StereoWorldToCamera = new Matrix4x4[2];

	private Matrix4x4[] unity_StereoCameraToWorld = new Matrix4x4[2];

	private Matrix4x4[] unity_StereoMatrixVP = new Matrix4x4[2];

	private Vector3[] eyesOffset = new Vector3[2];

	private static Matrix4x4[] eyesOffsetMatrix = new Matrix4x4[2];

	private CommandBuffer commandBufferBeforeForwardOpaque;

	private CommandBuffer commandBufferBeforeSkybox;

	private CommandBuffer commandBufferAfterSkybox;

	public override void InitEye(Camera eye)
	{
		bothCamera = eye;
		bothCamera.stereoSeparation = 0.0625f;
		bothCamera.stereoConvergence = 0f;
		bothCamera.allowHDR = false;
		bothCamera.allowDynamicResolution = false;
		SetEyesPosition();
		SetEyeProjection();
		Pvr_UnitySDKSensor.EyeFovChanged = (Action)Delegate.Combine(Pvr_UnitySDKSensor.EyeFovChanged, new Action(SetEyeProjection));
		UnityEngine.Debug.Log("SinglePass Init success! CameraName = " + eye.transform.name + " eye.eyeSide " + eye.GetComponent<Pvr_UnitySDKEye>().eyeSide);
	}

	public override void OnSDKRenderInited()
	{
		OnSDKRenderInited_SinglePass();
	}

	public override void OnSDKPreRender()
	{
		SinglePassPreRender();
	}

	public override void OnSDKPostRender()
	{
		SwitchKeywordAndDeviceView(enable: false);
	}

	public void OnSDKRenderInited_SinglePass()
	{
		Shader.SetGlobalVectorArray("unity_StereoScaleOffset", new Vector4[2]
		{
			new Vector4(1f, 1f, 0f, 0f),
			new Vector4(1f, 1f, 0.5f, 0f)
		});
		SetAntiAliasing();
		UnityEngine.Debug.Log("OnSDKRenderInited_SinglePass");
	}

	private void SetAntiAliasing()
	{
		int num = Mathf.Max(QualitySettings.antiAliasing, (int)Pvr_UnitySDKProjectSetting.GetProjectConfig().rtAntiAlising);
		Pvr_UnitySDKAPI.System.UPvr_SetAntiAliasing(num);
		UnityEngine.Debug.Log("SetAntiAliasing  antiAliasing = " + num);
	}

	public void SetEyesPosition()
	{
		float res = 0.0625f;
		int configsenum = 0;
		if (Render.UPvr_GetFloatConfig(configsenum, ref res) != 0)
		{
			PLOG.E("Cannot get ipd");
			res = 0.0625f;
		}
		bothCamera.stereoSeparation = res;
		Vector3 vector = new Vector3((0f - res) / 2f, 0f, 0f);
		Vector3 vector2 = new Vector3(res / 2f, 0f, 0f);
		Vector3 vector3 = (vector + vector2) / 2f;
		bothCamera.transform.localPosition = vector3;
		bothCamera.transform.localRotation = Quaternion.identity;
		Vector3 vector4 = vector - vector3;
		Vector3 vector5 = vector2 - vector3;
		eyesOffset[0] = vector4;
		eyesOffset[1] = vector5;
		eyesOffsetMatrix[0] = Matrix4x4.TRS(vector4, Quaternion.identity, Vector3.one);
		eyesOffsetMatrix[1] = Matrix4x4.TRS(vector5, Quaternion.identity, Vector3.one);
	}

	public void SetEyeProjection()
	{
		Matrix4x4 projection = GetProjection(bothCamera.nearClipPlane, bothCamera.farClipPlane);
		Matrix4x4 projection2 = GetProjection(bothCamera.nearClipPlane, bothCamera.farClipPlane);
		SetStereoProjectionMatrix(projection, projection2);
	}

	private static Matrix4x4 GetProjection(float near, float far)
	{
		if (near < 0.01f)
		{
			near = 0.01f;
		}
		if (far < 0.02f)
		{
			far = 0.02f;
		}
		_ = Matrix4x4.identity;
		return MakeProjection(near, far);
	}

	public static Matrix4x4 MakeProjection(float n, float f)
	{
		Vector2 eyeBufferResolution = Pvr_UnitySDKRender.Instance.GetEyeBufferResolution();
		float num = Mathf.Tan(Pvr_UnitySDKRender.Instance.EyeVFoV / 2f * ((float)Math.PI / 180f));
		float num2 = 1f / num;
		Matrix4x4 zero = Matrix4x4.zero;
		zero[0, 0] = num2 / (eyeBufferResolution.x / eyeBufferResolution.y);
		zero[1, 1] = num2;
		zero[2, 2] = (0f - (f + n)) / (f - n);
		zero[2, 3] = -2f * f * n / (f - n);
		zero[3, 2] = -1f;
		return zero;
	}

	public void SetStereoProjectionMatrix(Matrix4x4 left, Matrix4x4 right)
	{
		unity_StereoMatrixP[0] = left;
		unity_StereoMatrixInvP[0] = left.inverse;
		unity_StereoMatrixP[1] = right;
		unity_StereoMatrixInvP[1] = right.inverse;
	}

	private void SwitchKeywordAndDeviceView(bool enable)
	{
		if (enable)
		{
			Shader.EnableKeyword("STEREO_MULTIVIEW_ON");
			Shader.EnableKeyword("UNITY_SINGLE_PASS_STEREO");
			XRSettings.showDeviceView = false;
		}
		else
		{
			XRSettings.showDeviceView = true;
			Shader.DisableKeyword("UNITY_SINGLE_PASS_STEREO");
			Shader.DisableKeyword("STEREO_MULTIVIEW_ON");
		}
	}

	public static Matrix4x4[] GetStereoWorldToCameraMat()
	{
		Matrix4x4 worldToCameraMatrix = bothCamera.worldToCameraMatrix;
		unity_StereoWorldToCamera[0] = eyesOffsetMatrix[0].inverse * worldToCameraMatrix;
		unity_StereoWorldToCamera[1] = eyesOffsetMatrix[1].inverse * worldToCameraMatrix;
		return unity_StereoWorldToCamera;
	}

	public void SinglePassPreRender()
	{
		SwitchKeywordAndDeviceView(enable: true);
		Shader.SetGlobalMatrixArray("unity_StereoCameraProjection", unity_StereoMatrixP);
		Shader.SetGlobalMatrixArray("unity_StereoCameraInvProjection", unity_StereoMatrixInvP);
		Shader.SetGlobalMatrixArray("unity_StereoMatrixP", unity_StereoMatrixP);
		Matrix4x4 worldToCameraMatrix = bothCamera.worldToCameraMatrix;
		Matrix4x4 cameraToWorldMatrix = bothCamera.cameraToWorldMatrix;
		unity_StereoCameraToWorld[0] = cameraToWorldMatrix * eyesOffsetMatrix[0];
		unity_StereoCameraToWorld[1] = cameraToWorldMatrix * eyesOffsetMatrix[1];
		Shader.SetGlobalMatrixArray("unity_StereoCameraToWorld", unity_StereoCameraToWorld);
		unity_StereoWorldToCamera[0] = eyesOffsetMatrix[0].inverse * worldToCameraMatrix;
		unity_StereoWorldToCamera[1] = eyesOffsetMatrix[1].inverse * worldToCameraMatrix;
		Shader.SetGlobalMatrixArray("unity_StereoWorldToCamera", unity_StereoWorldToCamera);
		Vector4[] values = new Vector4[2]
		{
			bothCamera.transform.position + eyesOffset[0],
			bothCamera.transform.position + eyesOffset[1]
		};
		Shader.SetGlobalVectorArray("unity_StereoWorldSpaceCameraPos", values);
		Shader.SetGlobalMatrixArray("unity_StereoMatrixV", unity_StereoWorldToCamera);
		Shader.SetGlobalMatrixArray("unity_StereoMatrixInvV", unity_StereoCameraToWorld);
		unity_StereoMatrixVP[0] = unity_StereoMatrixP[0] * unity_StereoWorldToCamera[0];
		unity_StereoMatrixVP[1] = unity_StereoMatrixP[1] * unity_StereoWorldToCamera[1];
		Shader.SetGlobalMatrixArray("unity_StereoMatrixVP", unity_StereoMatrixVP);
		SetRenderTextureWithDepth();
		SetCommandBuffers();
	}

	private void SetCommandBuffers()
	{
		if (commandBufferBeforeForwardOpaque == null)
		{
			commandBufferBeforeForwardOpaque = new CommandBuffer();
			Pvr_UnitySDKPluginEvent.SetSinglePassBeforeForwardOpaque(commandBufferBeforeForwardOpaque);
			commandBufferBeforeForwardOpaque.ClearRenderTarget(clearDepth: true, clearColor: true, bothCamera.backgroundColor);
			commandBufferBeforeForwardOpaque.name = "SinglePassPrepare";
		}
		bothCamera.RemoveCommandBuffer(CameraEvent.BeforeForwardOpaque, commandBufferBeforeForwardOpaque);
		bothCamera.AddCommandBuffer(CameraEvent.BeforeForwardOpaque, commandBufferBeforeForwardOpaque);
		if (commandBufferAfterSkybox == null)
		{
			commandBufferAfterSkybox = new CommandBuffer();
		}
		bothCamera.RemoveCommandBuffer(CameraEvent.AfterSkybox, commandBufferAfterSkybox);
		commandBufferAfterSkybox.Clear();
		commandBufferAfterSkybox.SetGlobalMatrixArray("unity_StereoMatrixVP", unity_StereoMatrixVP);
		commandBufferAfterSkybox.name = "SinglePassAfterSkyBox";
		bothCamera.AddCommandBuffer(CameraEvent.AfterSkybox, commandBufferAfterSkybox);
		if (commandBufferBeforeSkybox == null)
		{
			commandBufferBeforeSkybox = new CommandBuffer();
		}
		Matrix4x4 transpose = (Matrix4x4.LookAt(Vector3.zero, bothCamera.transform.forward, bothCamera.transform.up) * Matrix4x4.Scale(new Vector3(1f, 1f, -1f))).transpose;
		Matrix4x4 matrix4x = unity_StereoMatrixP[0];
		Matrix4x4 matrix4x2 = unity_StereoMatrixP[1];
		matrix4x.m22 = -1f;
		matrix4x2.m22 = -1f;
		Matrix4x4[] values = new Matrix4x4[2]
		{
			matrix4x * transpose,
			matrix4x2 * transpose
		};
		bothCamera.RemoveCommandBuffer(CameraEvent.BeforeSkybox, commandBufferBeforeSkybox);
		commandBufferBeforeSkybox.Clear();
		commandBufferBeforeSkybox.SetGlobalMatrixArray("unity_StereoMatrixVP", values);
		commandBufferBeforeSkybox.name = "SinglePassAfterSkybox";
		bothCamera.AddCommandBuffer(CameraEvent.BeforeSkybox, commandBufferBeforeSkybox);
	}

	private void SetRenderTextureWithDepth()
	{
		Pvr_UnitySDKAPI.System.UPvr_SetCurrentRenderTexture((uint)Pvr_UnitySDKRender.Instance.eyeTextureIds[Pvr_UnitySDKRender.Instance.currEyeTextureIdx]);
	}
}
public abstract class SDKStereoRendering
{
	public abstract void InitEye(Camera eye);

	public abstract void OnSDKRenderInited();

	public abstract void OnSDKPreRender();

	public abstract void OnSDKPostRender();
}
public class HighlightAtGaze : MonoBehaviour
{
	public Color HighlightColor = Color.red;

	public float AnimationTime = 0.1f;

	private Renderer myRenderer;

	private Color originalColor;

	private Color targetColor;

	private EyeTrackingGazeRay gazeRay;

	private void Start()
	{
		myRenderer = GetComponent<Renderer>();
		originalColor = myRenderer.material.color;
		targetColor = originalColor;
	}

	private void Update()
	{
		Pvr_UnitySDKAPI.System.UPvr_getEyeTrackingGazeRay(ref gazeRay);
		if (Physics.Raycast(new Ray(gazeRay.Origin, gazeRay.Direction), out var hitInfo))
		{
			if (hitInfo.transform.name == base.transform.name)
			{
				if (targetColor != HighlightColor)
				{
					targetColor = HighlightColor;
				}
			}
			else if (targetColor != originalColor)
			{
				targetColor = originalColor;
			}
		}
		else if (targetColor != originalColor)
		{
			targetColor = originalColor;
		}
		myRenderer.material.color = Color.Lerp(myRenderer.material.color, targetColor, Time.deltaTime * (1f / AnimationTime));
	}
}
public class RayVisualizer : MonoBehaviour
{
	private LineRenderer _line;

	private EyeTrackingGazeRay gazeRay;

	private void Start()
	{
		_line = base.gameObject.GetComponent<LineRenderer>();
		_line.startWidth = 0.002f;
		_line.endWidth = 0.002f;
	}

	private void Update()
	{
		Matrix4x4 matrix = Pvr_UnitySDKSensor.Instance.HeadPose.Matrix;
		Pvr_UnitySDKAPI.System.UPvr_getEyeTrackingGazeRay(ref gazeRay);
		_line.SetPosition(0, matrix.MultiplyPoint(new Vector3(0f, -0.05f, 0.2f)));
		_line.SetPosition(1, gazeRay.Origin + gazeRay.Direction * 20f);
	}
}
public class GetSeeThroughImage : MonoBehaviour
{
	public RawImage viewImage_left;

	public RawImage viewImage_right;

	private int width;

	private int height;

	private RenderTexture cameraTex_left;

	private RenderTexture cameraTex_right;

	private bool cameraPreview;

	private void Start()
	{
		CreateTexture();
	}

	private void Update()
	{
		if (Input.GetKey(KeyCode.JoystickButton0))
		{
			DrawTexture();
		}
	}

	private void OnDestory()
	{
		if (cameraPreview)
		{
			cameraPreview = false;
			BoundarySystem.UPvr_StopCameraFrame();
		}
	}

	private void CreateTexture()
	{
		width = 600;
		height = 600;
		BoundarySystem.UPvr_BoundarySetCameraImageRect(width, height);
		cameraTex_left = new RenderTexture(width, height, 24, RenderTextureFormat.Default);
		cameraTex_right = new RenderTexture(width, height, 24, RenderTextureFormat.Default);
		cameraTex_left.Create();
		cameraTex_right.Create();
		viewImage_left.texture = cameraTex_left;
		viewImage_right.texture = cameraTex_right;
	}

	private void DrawTexture()
	{
		if (!cameraPreview)
		{
			cameraPreview = true;
			BoundarySystem.UPvr_StartCameraFrame();
		}
		BoundarySystem.UPvr_BoundaryGetSeeThroughData(0, cameraTex_left);
		BoundarySystem.UPvr_BoundaryGetSeeThroughData(1, cameraTex_right);
	}
}
public class OverlayExternalSurfaceDemo : MonoBehaviour
{
	public string movieName;

	public Pvr_UnitySDKEyeOverlay.OverlayType overlayType;

	public Pvr_UnitySDKEyeOverlay.OverlayShape overlayShape;

	private Pvr_UnitySDKEyeOverlay overlay;

	private const string TAG = "[ExternalSurface]>>>>>>";

	private void Awake()
	{
		overlay = GetComponent<Pvr_UnitySDKEyeOverlay>();
		if (overlay == null)
		{
			UnityEngine.Debug.LogError("[ExternalSurface]>>>>>>Overlay is null!");
			overlay = base.gameObject.AddComponent<Pvr_UnitySDKEyeOverlay>();
		}
		overlay.overlayType = overlayType;
		overlay.overlayShape = overlayShape;
		overlay.isExternalAndroidSurface = true;
	}

	private void Start()
	{
		if (!string.IsNullOrEmpty(movieName))
		{
			StartPlay(UnityEngine.Application.streamingAssetsPath + "/" + movieName, null);
		}
	}

	private void StartPlay(string moviePath, string licenceUrl)
	{
		if (moviePath != string.Empty)
		{
			if (overlay.isExternalAndroidSurface)
			{
				Pvr_UnitySDKEyeOverlay.ExternalAndroidSurfaceObjectCreated externalAndroidSurfaceObjectCreated = delegate
				{
					UnityEngine.Debug.Log("[ExternalSurface]>>>>>>SurfaceObject created callback is Invoke().");
				};
				if (overlay.externalAndroidSurfaceObject == IntPtr.Zero)
				{
					UnityEngine.Debug.Log("[ExternalSurface]>>>>>>Register surfaceObject crreated callback");
					overlay.externalAndroidSurfaceObjectCreated = externalAndroidSurfaceObjectCreated;
				}
				else
				{
					UnityEngine.Debug.Log("[ExternalSurface]>>>>>>SurfaceObject is already created! Invoke callback");
					externalAndroidSurfaceObjectCreated();
				}
			}
		}
		else
		{
			UnityEngine.Debug.LogError("[ExternalSurface]>>>>>>Movie path is null!");
		}
	}
}
public class MoveCylinder : MonoBehaviour
{
	private Vector3 startingPosition;

	private Quaternion startingRotation;

	private void Start()
	{
		startingPosition = base.transform.localPosition;
		startingRotation = base.transform.rotation;
	}

	public void Reset()
	{
		base.transform.localPosition = startingPosition;
		base.transform.rotation = startingRotation;
	}
}
[RequireComponent(typeof(Collider))]
public class MoveSphere : MonoBehaviour
{
	private Vector3 startingPosition;

	private void Start()
	{
		startingPosition = base.transform.localPosition;
		SetGazedAt(gazedAt: false);
		base.gameObject.GetComponent<Rigidbody>().AddForce(Vector3.right * 120f);
	}

	private void OnTriggerEnter(Collider other)
	{
	}

	public void SetGazedAt(bool gazedAt)
	{
		GetComponent<Renderer>().material.color = (gazedAt ? Color.yellow : Color.blue);
	}

	public void Reset()
	{
		base.transform.localPosition = startingPosition;
		SetGazedAt(gazedAt: false);
		base.gameObject.GetComponent<Rigidbody>().Sleep();
		base.gameObject.GetComponent<Rigidbody>().AddForce(Vector3.right * 120f);
	}

	public void TeleportRandomly()
	{
		Vector3 onUnitSphere = UnityEngine.Random.onUnitSphere;
		onUnitSphere.y = Mathf.Clamp(onUnitSphere.y, 0.5f, 1f);
		float num = 2f * UnityEngine.Random.value + 1.5f;
		base.transform.localPosition = onUnitSphere * num;
	}
}
public class Resetbutton : MonoBehaviour
{
	public void DemoResetTracking()
	{
		if (Pvr_UnitySDKSensor.Instance != null)
		{
			Pvr_UnitySDKSensor.Instance.ResetUnitySDKSensor();
		}
	}
}
public class UserEntitlementCheck : MonoBehaviour
{
	private void OnEnable()
	{
		Pvr_UnitySDKManager.EntitlementCheckResultEvent += HandelEntitlementCheckResult;
	}

	private void OnDisable()
	{
		Pvr_UnitySDKManager.EntitlementCheckResultEvent -= HandelEntitlementCheckResult;
	}

	private void HandelEntitlementCheckResult(int resultCode)
	{
		UnityEngine.Debug.Log("The User Entitlement Check Result is :" + resultCode);
		switch (resultCode)
		{
		case 0:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: success");
			break;
		case -1:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: invalid params");
			break;
		case -2:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: service not exist");
			break;
		case -3:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: bind failed");
			break;
		case -4:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: exception");
			break;
		case -5:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: timeout");
			break;
		case 10:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: missing package name");
			break;
		case 11:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: missing appid");
			break;
		case 13:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: appid and package name not match");
			break;
		case 20:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: not login");
			break;
		case 21:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: not pay");
			break;
		case 31:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: invalid sn");
			break;
		default:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: unknown");
			break;
		}
	}
}
public class Pvr_UnitySDKHeadTrack : MonoBehaviour
{
	[Tooltip("If true, head tracking will affect the rotation of each Pvr_UnitySDK's cameras.")]
	public bool trackRotation = true;

	[Tooltip("If true, head tracking will affect the position of each Pvr_UnitySDK's cameras.")]
	public bool trackPosition = true;

	public Transform target;

	private bool updated;

	private bool dataClock;

	public Ray Gaze
	{
		get
		{
			UpdateHead();
			return new Ray(base.transform.position, base.transform.forward);
		}
	}

	private void Update()
	{
		updated = false;
		UpdateHead();
	}

	private void UpdateHead()
	{
		if (updated)
		{
			return;
		}
		updated = true;
		if (Pvr_UnitySDKManager.SDK == null)
		{
			return;
		}
		if (trackRotation)
		{
			Quaternion orientation = Pvr_UnitySDKSensor.Instance.HeadPose.Orientation;
			if (target == null)
			{
				base.transform.localRotation = orientation;
			}
			else
			{
				base.transform.rotation = orientation * target.rotation;
			}
		}
		else
		{
			Quaternion orientation2 = Pvr_UnitySDKSensor.Instance.HeadPose.Orientation;
			if (target == null)
			{
				base.transform.localRotation = Quaternion.identity;
			}
			else
			{
				base.transform.rotation = orientation2 * target.rotation;
			}
		}
		if (trackPosition)
		{
			Vector3 position = Pvr_UnitySDKSensor.Instance.HeadPose.Position;
			if (target == null)
			{
				base.transform.localPosition = position;
			}
			else
			{
				base.transform.position = target.position + target.rotation * position;
			}
		}
	}
}
public class Pvr_UnitySDKPose
{
	protected static readonly Matrix4x4 flipZ = Matrix4x4.Scale(new Vector3(1f, 1f, -1f));

	public Matrix4x4 RightHandedMatrix => flipZ * Matrix * flipZ;

	public Vector3 Position { get; protected set; }

	public Quaternion Orientation { get; protected set; }

	public Matrix4x4 Matrix { get; protected set; }

	public Pvr_UnitySDKPose(Matrix4x4 matrix)
	{
		Set(matrix);
	}

	public Pvr_UnitySDKPose(Vector3 position, Quaternion orientation)
	{
		Set(position, orientation);
	}

	public void Set(Vector3 position, Quaternion orientation)
	{
		Position = position;
		Orientation = orientation;
		Matrix = Matrix4x4.TRS(position, orientation, Vector3.one);
	}

	protected void Set(Matrix4x4 matrix)
	{
		Matrix = matrix;
		Position = matrix.GetColumn(3);
		Orientation = Quaternion.LookRotation(matrix.GetColumn(2), matrix.GetColumn(1));
	}

	private Quaternion NormalizeQuaternion(ref Quaternion q)
	{
		float num = 0f;
		for (int i = 0; i < 4; i++)
		{
			num += q[i] * q[i];
		}
		float num2 = 1f / Mathf.Sqrt(num);
		for (int j = 0; j < 4; j++)
		{
			q[j] *= num2;
		}
		return q;
	}
}
public class Pvr_UnitySDKSensor
{
	public delegate void Enter3DofModel();

	public delegate void Exit3DofModel();

	private static Pvr_UnitySDKSensor instance;

	private bool SensorStart;

	private bool SensorInit;

	private Quaternion UnityQuaternion = Quaternion.identity;

	private Vector3 UnityPosition = Vector3.zero;

	private Sensorindex sensorIndex;

	private bool dofClock;

	public static Action EyeFovChanged;

	public Pvr_UnitySDKPose HeadPose;

	private float vfov = 102f;

	private float hfov = 102f;

	private float w;

	private float x;

	private float y;

	private float z;

	private float px;

	private float py;

	private float pz;

	public static Pvr_UnitySDKSensor Instance
	{
		get
		{
			if (instance == null)
			{
				instance = new Pvr_UnitySDKSensor();
			}
			return instance;
		}
		set
		{
			instance = value;
		}
	}

	public static event Enter3DofModel Enter3DofModelEvent;

	public static event Exit3DofModel Exit3DofModelEvent;

	public Pvr_UnitySDKSensor()
	{
		Init();
	}

	public void Init()
	{
		InitUnitySDK6DofSensor();
		SensorInit = InitUnitySDKSensor();
		SensorStart = StartUnitySDKSensor();
		HeadPose = new Pvr_UnitySDKPose(Vector3.zero, Quaternion.identity);
	}

	public void SensorUpdate()
	{
		if (GetUnitySDKSensorState())
		{
			HeadPose.Set(UnityPosition, UnityQuaternion);
		}
	}

	public bool InitUnitySDKSensor()
	{
		bool result = false;
		try
		{
			if (Sensor.UPvr_Init((int)sensorIndex) == 0)
			{
				result = true;
			}
		}
		catch (Exception ex)
		{
			PLOG.E("InitUnitySDKSensor ERROR! " + ex.Message);
			throw;
		}
		return result;
	}

	public bool InitUnitySDK6DofSensor()
	{
		bool result = false;
		try
		{
			int res = 0;
			Render.UPvr_GetIntConfig(3, ref res);
			if (res == 1)
			{
				if (Sensor.UPvr_Enable6DofModule(!Pvr_UnitySDKManager.SDK.HmdOnlyrot) == 0 && !Pvr_UnitySDKManager.SDK.HmdOnlyrot)
				{
					result = true;
					Pvr_UnitySDKManager.SDK.PVRNeck = false;
				}
			}
			else
			{
				UnityEngine.Debug.LogWarning("This platform does not support 6 Dof !");
			}
		}
		catch (Exception ex)
		{
			PLOG.E("InitUnity6DofSDKSensor ERROR! " + ex.Message);
			throw;
		}
		return result;
	}

	public bool StartUnitySDKSensor()
	{
		bool result = false;
		try
		{
			if (Sensor.UPvr_StartSensor((int)sensorIndex) == 0)
			{
				result = true;
			}
		}
		catch (Exception ex)
		{
			PLOG.E("StartUnitySDKSensor ERROR! " + ex.Message);
			throw;
		}
		return result;
	}

	public bool StopUnitySDKSensor()
	{
		bool result = false;
		try
		{
			if (Sensor.UPvr_StopSensor((int)sensorIndex) == 0)
			{
				result = true;
			}
		}
		catch (Exception ex)
		{
			PLOG.E("StopUnitySDKSensor ERROR! " + ex.Message);
			throw;
		}
		return result;
	}

	public bool ResetUnitySDKSensor()
	{
		bool result = false;
		try
		{
			if (Sensor.UPvr_ResetSensor((int)sensorIndex) == 0)
			{
				result = true;
				PLOG.E("ResetUnitySDKSensor OK! ");
			}
		}
		catch (Exception ex)
		{
			PLOG.E("ResetUnitySDKSensor ERROR! " + ex.Message);
			throw;
		}
		return result;
	}

	public bool OptionalResetUnitySDKSensor(int resetRot, int resetPos)
	{
		bool result = false;
		try
		{
			if (Sensor.UPvr_OptionalResetSensor((int)sensorIndex, resetRot, resetPos) == 0)
			{
				result = true;
				UnityEngine.Debug.Log("PvrLog OptionalResetUnitySDKSensor OK!" + resetRot + resetPos);
			}
		}
		catch (Exception ex)
		{
			UnityEngine.Debug.LogError("OptionalResetUnitySDKSensor ERROR! " + ex.Message);
			throw;
		}
		return result;
	}

	public bool GetUnitySDKSensorState()
	{
		bool result = false;
		if (SensorInit && SensorStart)
		{
			try
			{
				int num = -1;
				if (Pvr_UnitySDKManager.SDK.ShowVideoSeethrough)
				{
					Pvr_BoundarySystem.Instance.CameraFramePtr = Pvr_BoundaryAPI.UPvr_GetCameraData_Ext();
					num = Pvr_BoundaryAPI.UPvr_GetMainSensorStateExt(ref x, ref y, ref z, ref w, ref px, ref py, ref pz, ref vfov, ref hfov, ref Pvr_UnitySDKRender.Instance.RenderviewNumber);
				}
				else
				{
					num = Sensor.UPvr_GetMainSensorState(ref x, ref y, ref z, ref w, ref px, ref py, ref pz, ref vfov, ref hfov, ref Pvr_UnitySDKRender.Instance.RenderviewNumber);
				}
				Pvr_UnitySDKManager.SDK.posStatus = Sensor.UPvr_Get6DofSensorQualityStatus();
				if (num == 0)
				{
					if (!Convert.ToBoolean(Pvr_UnitySDKManager.SDK.posStatus & 2))
					{
						if (!dofClock)
						{
							if (Pvr_UnitySDKSensor.Enter3DofModelEvent != null)
							{
								Pvr_UnitySDKSensor.Enter3DofModelEvent();
							}
							dofClock = true;
						}
					}
					else if (dofClock)
					{
						if (Pvr_UnitySDKSensor.Exit3DofModelEvent != null)
						{
							Pvr_UnitySDKSensor.Exit3DofModelEvent();
						}
						dofClock = false;
					}
					RefreshHeadData(x, y, z, w, px, py, pz);
					UnityQuaternion.Set(x, y, 0f - z, 0f - w);
					if (Pvr_UnitySDKRender.Instance.EyeVFoV != vfov)
					{
						Pvr_UnitySDKRender.Instance.EyeVFoV = vfov;
						if (EyeFovChanged != null)
						{
							EyeFovChanged();
						}
					}
					Pvr_UnitySDKRender.Instance.EyeHFoV = hfov;
					Pvr_UnitySDKManager.SDK.EyesAspect = hfov / vfov;
					result = true;
					if (Pvr_UnitySDKManager.SDK.HmdOnlyrot)
					{
						if (Pvr_UnitySDKManager.SDK.PVRNeck)
						{
							if (Pvr_UnitySDKManager.SDK.TrackingOrigin == TrackingOrigin.FloorLevel)
							{
								UnityPosition.Set(0f, py, 0f);
								UnityPosition += UnityQuaternion * Pvr_UnitySDKManager.SDK.neckOffset - Pvr_UnitySDKManager.SDK.neckOffset.y * Vector3.up;
							}
							else
							{
								UnityPosition = UnityQuaternion * Pvr_UnitySDKManager.SDK.neckOffset - Pvr_UnitySDKManager.SDK.neckOffset.y * Vector3.up;
							}
						}
					}
					else
					{
						UnityPosition.Set(px, py, 0f - pz);
					}
					if (PLOG.logLevel > 2)
					{
						PLOG.D("posStatus=" + Pvr_UnitySDKManager.SDK.posStatus);
						PLOG.D("PvrLog 6DoFHeadRotation:" + x + "," + y + "," + (0f - z) + "," + (0f - w) + ",Position:" + px + "," + py + "," + (0f - pz) + ",eulerAngles:" + UnityQuaternion.eulerAngles);
					}
				}
				if (num == -1)
				{
					PLOG.I("PvrLog Sensor update --- GetUnitySDKSensorState  -1 ");
				}
			}
			catch (Exception ex)
			{
				PLOG.E("GetUnitySDKSensorState ERROR! " + ex.Message);
				throw;
			}
		}
		return result;
	}

	public bool GetUnitySDKPSensorState()
	{
		bool result = false;
		try
		{
			if (Sensor.UPvr_ResetSensor((int)sensorIndex) == 0)
			{
				result = true;
			}
		}
		catch (Exception ex)
		{
			PLOG.E("GetUnitySDKPSensorState ERROR! " + ex.Message);
			throw;
		}
		return result;
	}

	private void RefreshHeadData(float x, float y, float z, float w, float px, float py, float pz)
	{
		Pvr_UnitySDKManager.SDK.headData[0] = x;
		Pvr_UnitySDKManager.SDK.headData[1] = y;
		Pvr_UnitySDKManager.SDK.headData[2] = z;
		Pvr_UnitySDKManager.SDK.headData[3] = w;
		Pvr_UnitySDKManager.SDK.headData[4] = px;
		Pvr_UnitySDKManager.SDK.headData[5] = py;
		Pvr_UnitySDKManager.SDK.headData[6] = pz;
	}
}
public class CLoadingAsset : ScriptableObject
{
	public int SplashScreenType;

	public List<Texture2D> splashImage = new List<Texture2D>();

	public Texture2D Inside_background;

	public bool UseSplashText;

	public string DefaultText;

	public string ChineseText;

	public string EnglishText;

	public string JapaneseText;

	public string KoreanText;

	public string FontSize;

	public Color FontColor;

	public string TextHeight;

	public bool UseCarousel;

	public int SplashTextAlignment;
}
[Serializable]
public class Pvr_UnitySDKConfigProfile
{
	public struct Lenses
	{
		public float separation;

		public float offset;

		public float distance;

		public int alignment;

		public const int AlignTop = -1;

		public const int AlignCenter = 0;

		public const int AlignBottom = 1;
	}

	public struct MaxFOV
	{
		public float upper;

		public float lower;

		public float inner;

		public float outer;
	}

	public struct Distortion
	{
		public float k1;

		public float k2;

		public float k3;

		public float k4;

		public float k5;

		public float k6;

		public float distort(float r)
		{
			return 0f;
		}

		public float distort(float r, float dist)
		{
			float num = r * dist * 1000f;
			return (k1 * Mathf.Pow(num, 5f) + k2 * Mathf.Pow(num, 4f) + k3 * Mathf.Pow(num, 3f) + k4 * Mathf.Pow(num, 2f) + k5 * num + k6) / 1000f / dist;
		}

		public float diatortInv(float radious)
		{
			return 0f;
		}
	}

	public struct Device
	{
		public Lenses devLenses;

		public MaxFOV devMaxFov;

		public Distortion devDistortion;

		public Distortion devDistortionInv;
	}

	public static readonly Device SimulateDevice = new Device
	{
		devLenses = 
		{
			separation = 0.062f,
			offset = 0f,
			distance = 0.0403196f,
			alignment = 0
		},
		devMaxFov = 
		{
			upper = 40f,
			lower = 40f,
			inner = 40f,
			outer = 40f
		},
		devDistortion = 
		{
			k1 = 2.333E-06f,
			k2 = -0.000126f,
			k3 = 0.002978f,
			k4 = -0.02615f,
			k5 = 1.089f,
			k6 = -0.0337f
		},
		devDistortionInv = 
		{
			k1 = 1.342E-08f,
			k2 = 1.665E-06f,
			k3 = -0.0002797f,
			k4 = 0.001166f,
			k5 = 0.9945f,
			k6 = 0.004805f
		}
	};

	public Device device;

	public static readonly Pvr_UnitySDKConfigProfile Default = new Pvr_UnitySDKConfigProfile
	{
		device = SimulateDevice
	};

	public Pvr_UnitySDKConfigProfile Clone()
	{
		return new Pvr_UnitySDKConfigProfile
		{
			device = device
		};
	}

	public static Pvr_UnitySDKConfigProfile GetPicoProfile()
	{
		return new Pvr_UnitySDKConfigProfile
		{
			device = SimulateDevice
		};
	}

	public float[] GetLeftEyeVisibleTanAngles(float width, float height)
	{
		float val = (float)Math.Tan((double)(0f - device.devMaxFov.outer) * Math.PI / 180.0);
		float val2 = (float)Math.Tan((double)device.devMaxFov.upper * Math.PI / 180.0);
		float val3 = (float)Math.Tan((double)device.devMaxFov.inner * Math.PI / 180.0);
		float val4 = (float)Math.Tan((double)(0f - device.devMaxFov.lower) * Math.PI / 180.0);
		float num = width / 4f;
		float num2 = height / 2f;
		float num3 = device.devLenses.separation / 2f - num;
		float num4 = 0f;
		float distance = device.devLenses.distance;
		float val5 = device.devDistortion.distort((num3 - num) / distance, device.devLenses.distance);
		float val6 = device.devDistortion.distort((num4 + num2) / distance, device.devLenses.distance);
		float val7 = device.devDistortion.distort((num3 + num) / distance, device.devLenses.distance);
		float val8 = device.devDistortion.distort((num4 - num) / distance, device.devLenses.distance);
		float num5 = Math.Max(val, val5);
		float num6 = Math.Min(val2, val6);
		float num7 = Math.Min(val3, val7);
		float num8 = Math.Max(val4, val8);
		return new float[4] { num5, num6, num7, num8 };
	}

	public float[] GetLeftEyeNoLensTanAngles(float width, float height)
	{
		float val = device.devDistortionInv.distort((float)Math.Tan((double)(0f - device.devMaxFov.outer) * Math.PI / 180.0), device.devLenses.distance);
		float val2 = device.devDistortionInv.distort((float)Math.Tan((double)device.devMaxFov.upper * Math.PI / 180.0), device.devLenses.distance);
		float val3 = device.devDistortionInv.distort((float)Math.Tan((double)device.devMaxFov.inner * Math.PI / 180.0), device.devLenses.distance);
		float val4 = device.devDistortionInv.distort((float)Math.Tan((double)(0f - device.devMaxFov.lower) * Math.PI / 180.0), device.devLenses.distance);
		float num = width / 4f;
		float num2 = height / 2f;
		float num3 = device.devLenses.separation / 2f - num;
		float num4 = 0f;
		float distance = device.devLenses.distance;
		float val5 = (num3 - num) / distance;
		float val6 = (num4 + num2) / distance;
		float val7 = (num3 + num) / distance;
		float val8 = (num4 - num) / distance;
		float num5 = Math.Min(val, val5);
		float num6 = Math.Min(val2, val6);
		float num7 = Math.Min(val3, val7);
		float num8 = Math.Max(val4, val8);
		return new float[4] { num5, num6, num7, num8 };
	}

	public Rect GetLeftEyeVisibleScreenRect(float[] undistortedFrustum, float width, float height)
	{
		float distance = device.devLenses.distance;
		float num = (width - device.devLenses.separation) / 2f;
		float num2 = height / 2f;
		float num3 = (undistortedFrustum[0] * distance + num) / width;
		float num4 = (undistortedFrustum[1] * distance + num2) / height;
		float num5 = (undistortedFrustum[2] * distance + num) / width;
		float num6 = (undistortedFrustum[3] * distance + num2) / height;
		return new Rect(num3, num6, num5 - num3, num4 - num6);
	}
}
[RequireComponent(typeof(Text))]
public class Pvr_UnitySDKFPS : MonoBehaviour
{
	public Text fpsText;

	private float updateInterval = 0.5f;

	private float accum;

	private int frames;

	private float timeLeft;

	private string strFps;

	private void Update()
	{
		if (fpsText != null)
		{
			ShowFps();
		}
	}

	private void ShowFps()
	{
		timeLeft -= Time.unscaledDeltaTime;
		accum += Time.unscaledDeltaTime;
		frames++;
		if ((double)timeLeft <= 0.0)
		{
			float num = (float)frames / accum;
			strFps = $"FPS: {num:f0}";
			fpsText.text = strFps;
			timeLeft += updateInterval;
			accum = 0f;
			frames = 0;
		}
	}
}
public class Pvr_GazeFuse : MonoBehaviour
{
	public GameObject gazeGameObject;

	private Image image;

	private void Start()
	{
		image = GetComponent<Image>();
	}

	private void Update()
	{
		if (gazeGameObject == null || Pvr_GazeInputModule.gazeGameObject == gazeGameObject)
		{
			FuseAmountChanged(Pvr_GazeInputModule.gazeFraction);
		}
	}

	private void FuseAmountChanged(float fuseAmount)
	{
		if (image != null)
		{
			image.fillAmount = fuseAmount;
		}
	}
}
public class Pvr_GazeInputModule : PointerInputModule
{
	public enum Mode
	{
		Click,
		Gaze
	}

	public Mode mode;

	[Header("Click Settings")]
	public string ClickInputName = "Submit";

	[Header("Gaze Settings")]
	public float GazeTimeInSeconds = 2f;

	public RaycastResult CurrentRaycast;

	private PointerEventData pointerEventData;

	private GameObject currentLookAtHandler;

	private float currentLookAtHandlerClickTime;

	public static float gazeFraction { get; private set; }

	public static GameObject gazeGameObject { get; private set; }

	public override void Process()
	{
		HandleLook();
		HandleSelection();
	}

	private void HandleLook()
	{
		if (pointerEventData == null)
		{
			pointerEventData = new PointerEventData(base.eventSystem);
		}
		pointerEventData.position = new Vector2(Screen.width / 2, Screen.height / 2);
		pointerEventData.delta = Vector2.zero;
		List<RaycastResult> list = new List<RaycastResult>();
		base.eventSystem.RaycastAll(pointerEventData, list);
		RaycastResult currentRaycast = (pointerEventData.pointerCurrentRaycast = BaseInputModule.FindFirstRaycast(list));
		CurrentRaycast = currentRaycast;
		ProcessMove(pointerEventData);
	}

	private void HandleSelection()
	{
		gazeFraction = 0f;
		if (pointerEventData.pointerEnter != null)
		{
			GameObject eventHandler = ExecuteEvents.GetEventHandler<IPointerClickHandler>(pointerEventData.pointerEnter);
			if (currentLookAtHandler != eventHandler)
			{
				gazeGameObject = (currentLookAtHandler = eventHandler);
				currentLookAtHandlerClickTime = Time.realtimeSinceStartup + GazeTimeInSeconds;
			}
			if (mode == Mode.Gaze && currentLookAtHandler != null)
			{
				gazeFraction = Mathf.Clamp01(1f - (currentLookAtHandlerClickTime - Time.realtimeSinceStartup) / GazeTimeInSeconds);
			}
			if ((currentLookAtHandler != null && mode == Mode.Gaze && Time.realtimeSinceStartup > currentLookAtHandlerClickTime) || (mode == Mode.Click && Input.GetButtonDown(ClickInputName)))
			{
				_ = EventSystem.current.currentSelectedGameObject != null;
				EventSystem.current.SetSelectedGameObject(currentLookAtHandler);
				gazeFraction = 0f;
				ExecuteEvents.ExecuteHierarchy(currentLookAtHandler, pointerEventData, ExecuteEvents.pointerClickHandler);
				currentLookAtHandlerClickTime = float.MaxValue;
				ExecuteEvents.ExecuteHierarchy(EventSystem.current.currentSelectedGameObject, pointerEventData, ExecuteEvents.deselectHandler);
			}
		}
		else
		{
			gazeGameObject = (currentLookAtHandler = null);
		}
	}
}
[RequireComponent(typeof(Pvr_GazeInputModule))]
public class Pvr_GazeInputModuleCrosshair : MonoBehaviour
{
	public static bool DisplayCrosshair = true;

	[Tooltip("Crosshair GameObject attached to your VR Camera")]
	public Transform Crosshair;

	private Pvr_GazeInputModule gazeInputModule;

	private Vector3 CrosshairOriginalScale;

	private float CrosshairOriginalDistance;

	private void Awake()
	{
		gazeInputModule = GetComponent<Pvr_GazeInputModule>();
	}

	private void Start()
	{
		CrosshairOriginalScale = Crosshair.localScale;
		CrosshairOriginalDistance = Crosshair.localPosition.z;
		Crosshair.gameObject.SetActive(value: false);
	}

	private void Update()
	{
		Crosshair.gameObject.SetActive(DisplayCrosshair);
		if (DisplayCrosshair)
		{
			float crossHairAtDistance = CrosshairOriginalDistance;
			if (gazeInputModule.CurrentRaycast.isValid)
			{
				crossHairAtDistance = gazeInputModule.CurrentRaycast.distance * 0.8f - 0.5f;
			}
			SetCrossHairAtDistance(crossHairAtDistance);
		}
	}

	private void SetCrossHairAtDistance(float dist)
	{
		Vector3 localPosition = Crosshair.localPosition;
		Crosshair.localPosition = new Vector3(localPosition.x, localPosition.y, dist);
		Crosshair.localScale = CrosshairOriginalScale * dist;
	}
}
public enum RenderEventType
{
	InitRenderThread = 1024,
	Pause,
	Resume,
	LeftEyeEndFrame,
	RightEyeEndFrame,
	TimeWarp,
	ResetVrModeParms,
	ShutdownRenderThread,
	BeginEye,
	EndEye,
	BoundaryRenderLeft,
	BoundaryRenderRight,
	BothEyeEndFrame,
	CameraFrameLeft,
	CameraFrameRight,
	StartCameraFrame,
	StopCameraFrame
}
public static class Pvr_UnitySDKPluginEvent
{
	private delegate void RenderEventDelegate(int eventId);

	private const uint IS_DATA_FLAG = 2147483648u;

	private const uint DATA_POS_MASK = 1073741824u;

	private const int DATA_POS_SHIFT = 30;

	private const uint EVENT_TYPE_MASK = 1056899072u;

	private const int EVENT_TYPE_SHIFT = 17;

	private const uint PAYLOAD_MASK = 65535u;

	private const int PAYLOAD_SHIFT = 16;

	private static RenderEventDelegate SetSinglePassBeforeForwardOpaqueHandle = SetSinglePassBeforeForwardOpaque;

	private static IntPtr SetSinglePassBeforeForwardOpaquePtr = Marshal.GetFunctionPointerForDelegate(SetSinglePassBeforeForwardOpaqueHandle);

	public static void Issue(RenderEventType eventType)
	{
		GL.IssuePluginEvent(Pvr_UnitySDKAPI.System.GetRenderEventFunc(), (int)eventType);
	}

	private static int EncodeType(int eventType)
	{
		return eventType & 0x7FFFFFFF;
	}

	private static int EncodeData(int eventId, int eventData, int pos)
	{
		return int.MinValue | ((pos << 30) & 0x40000000) | ((eventId << 17) & 0x3EFF0000) | ((eventData >>> pos * 16) & 0xFFFF);
	}

	private static int DecodeData(int eventData)
	{
		uint num = (uint)(eventData & 0x40000000) >> 30;
		return (eventData & 0xFFFF) << (int)(16 * num);
	}

	[MonoPInvokeCallback(typeof(RenderEventDelegate))]
	private static void SetSinglePassBeforeForwardOpaque(int eventId)
	{
		Pvr_UnitySDKAPI.System.UPvr_SinglePassBeforeForwardOpaque();
	}

	public static void SetSinglePassBeforeForwardOpaque(CommandBuffer cmd)
	{
		cmd.IssuePluginEvent(SetSinglePassBeforeForwardOpaquePtr, 0);
	}
}
public class Pvr_UnitySDKSightInputModule : BaseInputModule
{
	[Tooltip("Optional object to place at raycast intersections as a 3D cursor. Be sure it is on a layer that raycasts will ignore.")]
	public GameObject cursor;

	public int trigger;

	[HideInInspector]
	public float clickTime = 0.1f;

	[HideInInspector]
	public Vector2 hotspot = new Vector2(0.5f, 0.5f);

	private PointerEventData pointerData;

	public override bool ShouldActivateModule()
	{
		if (!base.ShouldActivateModule())
		{
			return false;
		}
		return Pvr_UnitySDKManager.SDK.VRModeEnabled;
	}

	public override void DeactivateModule()
	{
		base.DeactivateModule();
		if (pointerData != null)
		{
			HandlePendingClick();
			HandlePointerExitAndEnter(pointerData, null);
			pointerData = null;
		}
		base.eventSystem.SetSelectedGameObject(null, GetBaseEventData());
		if (cursor != null)
		{
			cursor.SetActive(value: false);
		}
	}

	public override bool IsPointerOverGameObject(int pointerId)
	{
		if (pointerData != null)
		{
			return pointerData.pointerEnter != null;
		}
		return false;
	}

	public override void Process()
	{
		CastRayFromGaze();
		UpdateCurrentObject();
		PlaceCursor();
		HandlePendingClick();
		HandleTrigger();
	}

	private void CastRayFromGaze()
	{
		if (pointerData == null)
		{
			pointerData = new PointerEventData(base.eventSystem);
		}
		pointerData.Reset();
		pointerData.position = new Vector2(hotspot.x * (float)Screen.width, hotspot.y * (float)Screen.height);
		base.eventSystem.RaycastAll(pointerData, m_RaycastResultCache);
		pointerData.pointerCurrentRaycast = BaseInputModule.FindFirstRaycast(m_RaycastResultCache);
		m_RaycastResultCache.Clear();
	}

	private void UpdateCurrentObject()
	{
		GameObject gameObject = pointerData.pointerCurrentRaycast.gameObject;
		HandlePointerExitAndEnter(pointerData, gameObject);
		if (ExecuteEvents.GetEventHandler<ISelectHandler>(gameObject) == base.eventSystem.currentSelectedGameObject)
		{
			ExecuteEvents.Execute(base.eventSystem.currentSelectedGameObject, GetBaseEventData(), ExecuteEvents.updateSelectedHandler);
		}
		else
		{
			base.eventSystem.SetSelectedGameObject(null, pointerData);
		}
	}

	private void PlaceCursor()
	{
		if (!(cursor == null))
		{
			GameObject gameObject = pointerData.pointerCurrentRaycast.gameObject;
			cursor.SetActive(gameObject != null);
			if (cursor.activeInHierarchy)
			{
				Camera enterEventCamera = pointerData.enterEventCamera;
				float num = pointerData.pointerCurrentRaycast.distance + enterEventCamera.nearClipPlane - 0.1f;
				cursor.transform.position = enterEventCamera.transform.position + enterEventCamera.transform.forward * num;
			}
		}
	}

	private void HandlePendingClick()
	{
		if (pointerData.eligibleForClick && (Pvr_UnitySDKManager.SDK.picovrTriggered || !(Time.unscaledTime - pointerData.clickTime < clickTime)))
		{
			ExecuteEvents.Execute(pointerData.pointerPress, pointerData, ExecuteEvents.pointerUpHandler);
			ExecuteEvents.Execute(pointerData.pointerPress, pointerData, ExecuteEvents.pointerClickHandler);
			pointerData.pointerPress = null;
			pointerData.rawPointerPress = null;
			pointerData.eligibleForClick = false;
			pointerData.clickCount = 0;
		}
	}

	private void HandleTrigger()
	{
		if (Pvr_UnitySDKManager.SDK.picovrTriggered)
		{
			GameObject gameObject = pointerData.pointerCurrentRaycast.gameObject;
			if (!(gameObject == null) && !(ExecuteEvents.GetEventHandler<IPointerClickHandler>(gameObject) == null))
			{
				pointerData.pointerPress = ExecuteEvents.GetEventHandler<IPointerClickHandler>(gameObject);
				pointerData.pressPosition = pointerData.position;
				pointerData.pointerPressRaycast = pointerData.pointerCurrentRaycast;
				pointerData.pointerPress = ExecuteEvents.ExecuteHierarchy(gameObject, pointerData, ExecuteEvents.pointerDownHandler) ?? ExecuteEvents.GetEventHandler<IPointerClickHandler>(gameObject);
				pointerData.rawPointerPress = gameObject;
				pointerData.eligibleForClick = true;
				pointerData.clickCount = 1;
				pointerData.clickTime = Time.unscaledTime;
			}
		}
	}
}
public class Pvr_ObjImporter
{
	private static Pvr_ObjImporter _instance;

	private List<int> triangles;

	private List<Vector3> vertices;

	private List<Vector2> uv;

	private List<Vector3> normals;

	private List<PvrVector3Int> faceData;

	private List<int> intArray;

	private const int MIN_POW_10 = -16;

	private const int MAX_POW_10 = 16;

	private const int NUM_POWS_10 = 33;

	private static readonly float[] pow10 = GenerateLookupTable();

	public static Pvr_ObjImporter Instance => _instance ?? (_instance = new Pvr_ObjImporter());

	public Mesh ImportFile(string filePath)
	{
		triangles = new List<int>();
		vertices = new List<Vector3>();
		uv = new List<Vector2>();
		normals = new List<Vector3>();
		faceData = new List<PvrVector3Int>();
		intArray = new List<int>();
		LoadMeshData(filePath);
		Vector3[] array = new Vector3[faceData.Count];
		Vector2[] array2 = new Vector2[faceData.Count];
		Vector3[] array3 = new Vector3[faceData.Count];
		for (int i = 0; i < faceData.Count; i++)
		{
			array[i] = vertices[faceData[i].x - 1];
			if (faceData[i].y >= 1)
			{
				array2[i] = uv[faceData[i].y - 1];
			}
			if (faceData[i].z >= 1)
			{
				array3[i] = normals[faceData[i].z - 1];
			}
		}
		Mesh mesh = new Mesh();
		mesh.vertices = array;
		mesh.uv = array2;
		mesh.normals = array3;
		mesh.triangles = triangles.ToArray();
		mesh.RecalculateBounds();
		return mesh;
	}

	private void LoadMeshData(string fileName)
	{
		StringBuilder stringBuilder = new StringBuilder();
		string text = File.ReadAllText(fileName);
		int num = 0;
		string text2 = null;
		int num2 = 0;
		StringBuilder sbInt = new StringBuilder();
		for (int i = 0; i < text.Length; i++)
		{
			if (text[i] != '\n')
			{
				continue;
			}
			stringBuilder.Remove(0, stringBuilder.Length);
			stringBuilder.Append(text, num + 1, i - num);
			num = i;
			if (stringBuilder[0] == 'o' && stringBuilder[1] == ' ')
			{
				sbInt.Remove(0, sbInt.Length);
				for (int j = 2; j < stringBuilder.Length; j++)
				{
					text2 += stringBuilder[j];
				}
			}
			else if (stringBuilder[0] == 'v' && stringBuilder[1] == ' ')
			{
				int start = 2;
				vertices.Add(new Vector3(GetFloat(stringBuilder, ref start, ref sbInt), GetFloat(stringBuilder, ref start, ref sbInt), GetFloat(stringBuilder, ref start, ref sbInt)));
			}
			else if (stringBuilder[0] == 'v' && stringBuilder[1] == 't' && stringBuilder[2] == ' ')
			{
				int start2 = 3;
				uv.Add(new Vector2(GetFloat(stringBuilder, ref start2, ref sbInt), GetFloat(stringBuilder, ref start2, ref sbInt)));
			}
			else if (stringBuilder[0] == 'v' && stringBuilder[1] == 'n' && stringBuilder[2] == ' ')
			{
				int start3 = 3;
				normals.Add(new Vector3(GetFloat(stringBuilder, ref start3, ref sbInt), GetFloat(stringBuilder, ref start3, ref sbInt), GetFloat(stringBuilder, ref start3, ref sbInt)));
			}
			else if (stringBuilder[0] == 'f' && stringBuilder[1] == ' ')
			{
				int start4 = 2;
				int num3 = 1;
				intArray.Clear();
				int num4 = 0;
				while (start4 < stringBuilder.Length && char.IsDigit(stringBuilder[start4]))
				{
					faceData.Add(new PvrVector3Int(GetInt(stringBuilder, ref start4, ref sbInt), GetInt(stringBuilder, ref start4, ref sbInt), GetInt(stringBuilder, ref start4, ref sbInt)));
					num3++;
					intArray.Add(num2);
					num2++;
				}
				num4 += num3;
				for (num3 = 1; num3 + 2 < num4; num3++)
				{
					triangles.Add(intArray[0]);
					triangles.Add(intArray[num3]);
					triangles.Add(intArray[num3 + 1]);
				}
			}
		}
	}

	private float GetFloat(StringBuilder sb, ref int start, ref StringBuilder sbFloat)
	{
		sbFloat.Remove(0, sbFloat.Length);
		while (start < sb.Length && (char.IsDigit(sb[start]) || sb[start] == '-' || sb[start] == '.'))
		{
			sbFloat.Append(sb[start]);
			start++;
		}
		start++;
		return ParseFloat(sbFloat);
	}

	private int GetInt(StringBuilder sb, ref int start, ref StringBuilder sbInt)
	{
		sbInt.Remove(0, sbInt.Length);
		while (start < sb.Length && char.IsDigit(sb[start]))
		{
			sbInt.Append(sb[start]);
			start++;
		}
		start++;
		return IntParseFast(sbInt);
	}

	private static float[] GenerateLookupTable()
	{
		float[] array = new float[320];
		for (int i = 0; i < array.Length; i++)
		{
			array[i] = (float)(i / 33) * Mathf.Pow(10f, i % 33 + -16);
		}
		return array;
	}

	private float ParseFloat(StringBuilder value)
	{
		float num = 0f;
		bool flag = false;
		int length = value.Length;
		int num2 = value.Length;
		for (int num3 = length - 1; num3 >= 0; num3--)
		{
			if (value[num3] == '.')
			{
				num2 = num3;
				break;
			}
		}
		int num4 = 16 + num2;
		for (int i = 0; i < num2; i++)
		{
			if (i != num2 && value[i] != '-')
			{
				num += pow10[(value[i] - 48) * 33 + num4 - i - 1];
			}
			else if (value[i] == '-')
			{
				flag = true;
			}
		}
		for (int j = num2 + 1; j < length; j++)
		{
			if (j != num2)
			{
				num += pow10[(value[j] - 48) * 33 + num4 - j];
			}
		}
		if (flag)
		{
			num = 0f - num;
		}
		return num;
	}

	private int IntParseFast(StringBuilder value)
	{
		int num = 0;
		for (int i = 0; i < value.Length; i++)
		{
			num = 10 * num + (value[i] - 48);
		}
		return num;
	}
}
public sealed class PvrVector3Int
{
	public int x { get; set; }

	public int y { get; set; }

	public int z { get; set; }

	public PvrVector3Int()
	{
	}

	public PvrVector3Int(int x, int y, int z)
	{
		this.x = x;
		this.y = y;
		this.z = z;
	}
}
public class Pvr_EnumFlags : PropertyAttribute
{
}
public enum ConfirmBtn
{
	App = 1,
	TouchPad = 2,
	Trigger = 4
}
public class Pvr_InputModule : PointerInputModule
{
	public static List<Pvr_UIPointer> pointers = new List<Pvr_UIPointer>();

	[Pvr_EnumFlags]
	public ConfirmBtn confirmBtn = ConfirmBtn.TouchPad;

	private List<RaycastResult> rayCasts = new List<RaycastResult>();

	private RaycastResult rayCastResult;

	public virtual void Initialise()
	{
		pointers.Clear();
	}

	public static void AddPoint(Pvr_UIPointer point)
	{
		if (!pointers.Contains(point))
		{
			pointers.Add(point);
		}
	}

	public static void RemovePoint(Pvr_UIPointer point)
	{
		if (pointers.Contains(point))
		{
			pointers.Remove(point);
		}
	}

	public override void Process()
	{
		if (Pvr_UnitySDKManager.SDK.isHasController)
		{
			if ((confirmBtn & ConfirmBtn.App) == ConfirmBtn.App)
			{
				Pvr_UIPointer.AppBtnValue = Controller.UPvr_GetKey(Pvr_ControllerManager.controllerlink.mainHandID, Pvr_KeyCode.APP);
			}
			if ((confirmBtn & ConfirmBtn.TouchPad) == ConfirmBtn.TouchPad)
			{
				Pvr_UIPointer.TouchBtnValue = Controller.UPvr_GetKey(Pvr_ControllerManager.controllerlink.mainHandID, Pvr_KeyCode.TOUCHPAD);
			}
			if ((confirmBtn & ConfirmBtn.Trigger) == ConfirmBtn.Trigger)
			{
				Pvr_UIPointer.TriggerBtnValue = Controller.UPvr_GetKey(Pvr_ControllerManager.controllerlink.mainHandID, Pvr_KeyCode.TRIGGER);
			}
		}
		for (int i = 0; i < pointers.Count; i++)
		{
			Pvr_UIPointer pvr_UIPointer = pointers[i];
			if (pvr_UIPointer.gameObject.activeInHierarchy && pvr_UIPointer.enabled)
			{
				List<RaycastResult> results = new List<RaycastResult>();
				if (pvr_UIPointer.PointerActive())
				{
					results = CheckRaycasts(pvr_UIPointer);
				}
				Hover(pvr_UIPointer, results);
				Click(pvr_UIPointer, results);
				Drag(pvr_UIPointer, results);
			}
		}
	}

	protected virtual List<RaycastResult> CheckRaycasts(Pvr_UIPointer pointer)
	{
		rayCastResult.worldPosition = pointer.GetOriginPosition();
		rayCastResult.worldNormal = pointer.GetOriginForward();
		pointer.pointerEventData.pointerCurrentRaycast = rayCastResult;
		base.eventSystem.RaycastAll(pointer.pointerEventData, rayCasts);
		return rayCasts;
	}

	protected virtual bool CheckTransformTree(Transform target, Transform source)
	{
		if (target == null)
		{
			return false;
		}
		if (target.Equals(source))
		{
			return true;
		}
		return CheckTransformTree(target.transform.parent, source);
	}

	protected virtual bool NoValidCollision(Pvr_UIPointer pointer, List<RaycastResult> results)
	{
		if (results.Count != 0)
		{
			return !CheckTransformTree(results[0].gameObject.transform, pointer.pointerEventData.pointerEnter.transform);
		}
		return true;
	}

	protected virtual bool IsHovering(Pvr_UIPointer pointer)
	{
		foreach (GameObject item in pointer.pointerEventData.hovered)
		{
			if ((bool)pointer.pointerEventData.pointerEnter && (bool)item && CheckTransformTree(item.transform, pointer.pointerEventData.pointerEnter.transform))
			{
				return true;
			}
		}
		return false;
	}

	protected virtual bool ValidElement(GameObject obj)
	{
		Pvr_UICanvas componentInParent = obj.GetComponentInParent<Pvr_UICanvas>();
		if (!componentInParent || !componentInParent.enabled)
		{
			return false;
		}
		return true;
	}

	protected virtual void CheckPointerHoverClick(Pvr_UIPointer pointer, List<RaycastResult> results)
	{
		if (pointer.hoverDurationTimer > 0f)
		{
			pointer.hoverDurationTimer -= Time.deltaTime;
		}
		if (pointer.canClickOnHover && pointer.hoverDurationTimer <= 0f)
		{
			pointer.canClickOnHover = false;
			ClickOnDown(pointer, results, forceClick: true);
		}
	}

	protected virtual void Hover(Pvr_UIPointer pointer, List<RaycastResult> results)
	{
		if ((bool)pointer.pointerEventData.pointerEnter)
		{
			CheckPointerHoverClick(pointer, results);
			if (!ValidElement(pointer.pointerEventData.pointerEnter))
			{
				pointer.pointerEventData.pointerEnter = null;
				return;
			}
			if (NoValidCollision(pointer, results))
			{
				ExecuteEvents.ExecuteHierarchy(pointer.pointerEventData.pointerEnter, pointer.pointerEventData, ExecuteEvents.pointerExitHandler);
				pointer.pointerEventData.hovered.Remove(pointer.pointerEventData.pointerEnter);
				pointer.pointerEventData.pointerEnter = null;
			}
			if (results.Count <= 0 || !(pointer.pointerEventData.pointerEnter != results[0].gameObject))
			{
				return;
			}
			{
				foreach (RaycastResult result in results)
				{
					if (!ValidElement(result.gameObject))
					{
						continue;
					}
					GameObject gameObject = ExecuteEvents.ExecuteHierarchy(result.gameObject, pointer.pointerEventData, ExecuteEvents.pointerEnterHandler);
					if (gameObject != null)
					{
						Selectable component = gameObject.GetComponent<Selectable>();
						if ((bool)component)
						{
							Navigation navigation = default(Navigation);
							navigation.mode = Navigation.Mode.None;
							component.navigation = navigation;
						}
						pointer.pointerEventData.hovered.Remove(pointer.pointerEventData.pointerEnter);
						pointer.OnUIPointerElementEnter(pointer.SetUIPointerEvent(result, gameObject, pointer.hoveringElement));
						pointer.hoveringElement = gameObject;
						pointer.pointerEventData.pointerCurrentRaycast = result;
						pointer.pointerEventData.pointerEnter = gameObject;
						pointer.pointerEventData.hovered.Add(pointer.pointerEventData.pointerEnter);
						break;
					}
					if (result.gameObject != pointer.hoveringElement)
					{
						pointer.OnUIPointerElementEnter(pointer.SetUIPointerEvent(result, result.gameObject, pointer.hoveringElement));
					}
					pointer.hoveringElement = result.gameObject;
				}
				return;
			}
		}
		foreach (RaycastResult result2 in results)
		{
			if (!ValidElement(result2.gameObject))
			{
				continue;
			}
			GameObject gameObject2 = ExecuteEvents.ExecuteHierarchy(result2.gameObject, pointer.pointerEventData, ExecuteEvents.pointerEnterHandler);
			if (gameObject2 != null)
			{
				Selectable component2 = gameObject2.GetComponent<Selectable>();
				if ((bool)component2)
				{
					Navigation navigation2 = default(Navigation);
					navigation2.mode = Navigation.Mode.None;
					component2.navigation = navigation2;
				}
				pointer.OnUIPointerElementEnter(pointer.SetUIPointerEvent(result2, gameObject2, pointer.hoveringElement));
				pointer.hoveringElement = gameObject2;
				pointer.pointerEventData.pointerCurrentRaycast = result2;
				pointer.pointerEventData.pointerEnter = gameObject2;
				pointer.pointerEventData.hovered.Add(pointer.pointerEventData.pointerEnter);
				break;
			}
			if (result2.gameObject != pointer.hoveringElement)
			{
				pointer.OnUIPointerElementEnter(pointer.SetUIPointerEvent(result2, result2.gameObject, pointer.hoveringElement));
			}
			pointer.hoveringElement = result2.gameObject;
		}
		if ((bool)pointer.hoveringElement && results.Count == 0)
		{
			pointer.OnUIPointerElementExit(pointer.SetUIPointerEvent(default(RaycastResult), null, pointer.hoveringElement));
			pointer.hoveringElement = null;
		}
	}

	protected virtual void Click(Pvr_UIPointer pointer, List<RaycastResult> results)
	{
		switch (pointer.clickMethod)
		{
		case Pvr_UIPointer.ClickMethods.ClickOnButtonUp:
			ClickOnUp(pointer, results);
			break;
		case Pvr_UIPointer.ClickMethods.ClickOnButtonDown:
			ClickOnDown(pointer, results);
			break;
		}
	}

	protected virtual void ClickOnUp(Pvr_UIPointer pointer, List<RaycastResult> results)
	{
		pointer.pointerEventData.eligibleForClick = pointer.ValidClick(checkLastClick: false);
		if (!AttemptClick(pointer))
		{
			IsEligibleClick(pointer, results);
		}
	}

	protected virtual void ClickOnDown(Pvr_UIPointer pointer, List<RaycastResult> results, bool forceClick = false)
	{
		pointer.pointerEventData.eligibleForClick = forceClick || pointer.ValidClick(checkLastClick: true);
		if (IsEligibleClick(pointer, results))
		{
			pointer.pointerEventData.eligibleForClick = false;
			AttemptClick(pointer);
		}
	}

	protected virtual bool IsEligibleClick(Pvr_UIPointer pointer, List<RaycastResult> results)
	{
		if (pointer.pointerEventData.eligibleForClick)
		{
			foreach (RaycastResult result in results)
			{
				if (ValidElement(result.gameObject))
				{
					GameObject gameObject = ExecuteEvents.ExecuteHierarchy(result.gameObject, pointer.pointerEventData, ExecuteEvents.pointerDownHandler);
					if (gameObject != null)
					{
						pointer.pointerEventData.pressPosition = pointer.pointerEventData.position;
						pointer.pointerEventData.pointerPressRaycast = result;
						pointer.pointerEventData.pointerPress = gameObject;
						return true;
					}
				}
			}
		}
		return false;
	}

	protected virtual bool AttemptClick(Pvr_UIPointer pointer)
	{
		if ((bool)pointer.pointerEventData.pointerPress)
		{
			if (!ValidElement(pointer.pointerEventData.pointerPress))
			{
				pointer.pointerEventData.pointerPress = null;
				return true;
			}
			if (pointer.pointerEventData.eligibleForClick)
			{
				if (!IsHovering(pointer))
				{
					ExecuteEvents.ExecuteHierarchy(pointer.pointerEventData.pointerPress, pointer.pointerEventData, ExecuteEvents.pointerUpHandler);
					pointer.pointerEventData.pointerPress = null;
				}
			}
			else
			{
				pointer.OnUIPointerElementClick(pointer.SetUIPointerEvent(pointer.pointerEventData.pointerPressRaycast, pointer.pointerEventData.pointerPress));
				ExecuteEvents.ExecuteHierarchy(pointer.pointerEventData.pointerPress, pointer.pointerEventData, ExecuteEvents.pointerClickHandler);
				ExecuteEvents.ExecuteHierarchy(pointer.pointerEventData.pointerPress, pointer.pointerEventData, ExecuteEvents.pointerUpHandler);
				pointer.pointerEventData.pointerPress = null;
			}
			return true;
		}
		return false;
	}

	protected virtual void Drag(Pvr_UIPointer pointer, List<RaycastResult> results)
	{
		pointer.pointerEventData.dragging = pointer.IsSelectionButtonPressed() && pointer.pointerEventData.delta != Vector2.zero;
		if ((bool)pointer.pointerEventData.pointerDrag)
		{
			if (!ValidElement(pointer.pointerEventData.pointerDrag))
			{
				pointer.pointerEventData.pointerDrag = null;
				return;
			}
			if (pointer.pointerEventData.dragging)
			{
				if (IsHovering(pointer))
				{
					ExecuteEvents.ExecuteHierarchy(pointer.pointerEventData.pointerDrag, pointer.pointerEventData, ExecuteEvents.dragHandler);
				}
				return;
			}
			ExecuteEvents.ExecuteHierarchy(pointer.pointerEventData.pointerDrag, pointer.pointerEventData, ExecuteEvents.dragHandler);
			ExecuteEvents.ExecuteHierarchy(pointer.pointerEventData.pointerDrag, pointer.pointerEventData, ExecuteEvents.endDragHandler);
			foreach (RaycastResult result in results)
			{
				ExecuteEvents.ExecuteHierarchy(result.gameObject, pointer.pointerEventData, ExecuteEvents.dropHandler);
			}
			pointer.pointerEventData.pointerDrag = null;
		}
		else
		{
			if (!pointer.pointerEventData.dragging)
			{
				return;
			}
			foreach (RaycastResult result2 in results)
			{
				if (ValidElement(result2.gameObject))
				{
					ExecuteEvents.ExecuteHierarchy(result2.gameObject, pointer.pointerEventData, ExecuteEvents.initializePotentialDrag);
					ExecuteEvents.ExecuteHierarchy(result2.gameObject, pointer.pointerEventData, ExecuteEvents.beginDragHandler);
					GameObject gameObject = ExecuteEvents.ExecuteHierarchy(result2.gameObject, pointer.pointerEventData, ExecuteEvents.dragHandler);
					if (gameObject != null)
					{
						pointer.pointerEventData.pointerDrag = gameObject;
						break;
					}
				}
			}
		}
	}
}
public class Pvr_UICanvas : MonoBehaviour
{
	public bool clickOnPointerCollision;

	public float autoActivateWithinDistance;

	protected BoxCollider canvasBoxCollider;

	protected Rigidbody canvasRigidBody;

	protected Coroutine draggablePanelCreation;

	protected const string CANVAS_DRAGGABLE_PANEL = "UICANVAS_DRAGGABLE_PANEL";

	protected virtual void OnEnable()
	{
		SetupCanvas();
	}

	protected virtual void OnDisable()
	{
		RemoveCanvas();
	}

	protected virtual void OnDestroy()
	{
		RemoveCanvas();
	}

	protected virtual void SetupCanvas()
	{
		Canvas component = GetComponent<Canvas>();
		if ((bool)component && component.renderMode == RenderMode.WorldSpace)
		{
			RectTransform component2 = component.GetComponent<RectTransform>();
			Vector2 sizeDelta = component2.sizeDelta;
			GraphicRaycaster component3 = component.gameObject.GetComponent<GraphicRaycaster>();
			Pvr_UIGraphicRaycaster pvr_UIGraphicRaycaster = component.gameObject.GetComponent<Pvr_UIGraphicRaycaster>();
			if (!pvr_UIGraphicRaycaster)
			{
				pvr_UIGraphicRaycaster = component.gameObject.AddComponent<Pvr_UIGraphicRaycaster>();
			}
			if ((bool)component3 && component3.enabled)
			{
				pvr_UIGraphicRaycaster.ignoreReversedGraphics = component3.ignoreReversedGraphics;
				pvr_UIGraphicRaycaster.blockingObjects = component3.blockingObjects;
				component3.enabled = false;
			}
			if (!component.gameObject.GetComponent<BoxCollider>())
			{
				float z = 0.1f / component2.localScale.z;
				canvasBoxCollider = component.gameObject.AddComponent<BoxCollider>();
				canvasBoxCollider.size = new Vector3(sizeDelta.x, sizeDelta.y, z);
				canvasBoxCollider.isTrigger = true;
			}
			if (!component.gameObject.GetComponent<Rigidbody>())
			{
				canvasRigidBody = component.gameObject.AddComponent<Rigidbody>();
				canvasRigidBody.isKinematic = true;
			}
			draggablePanelCreation = StartCoroutine(CreateDraggablePanel(component, sizeDelta));
		}
	}

	protected virtual IEnumerator CreateDraggablePanel(Canvas canvas, Vector2 canvasSize)
	{
		if ((bool)canvas && !canvas.transform.Find("UICANVAS_DRAGGABLE_PANEL"))
		{
			yield return null;
			GameObject obj = new GameObject("UICANVAS_DRAGGABLE_PANEL", typeof(RectTransform));
			obj.AddComponent<LayoutElement>().ignoreLayout = true;
			obj.AddComponent<Image>().color = Color.clear;
			obj.AddComponent<EventTrigger>();
			obj.transform.SetParent(canvas.transform);
			obj.GetComponent<RectTransform>().sizeDelta = canvasSize;
			obj.transform.localPosition = Vector3.zero;
			obj.transform.localRotation = Quaternion.identity;
			obj.transform.localScale = Vector3.one;
			obj.transform.SetAsFirstSibling();
		}
	}

	protected virtual void RemoveCanvas()
	{
		Canvas component = GetComponent<Canvas>();
		if ((bool)component)
		{
			GraphicRaycaster component2 = component.gameObject.GetComponent<GraphicRaycaster>();
			Pvr_UIGraphicRaycaster component3 = component.gameObject.GetComponent<Pvr_UIGraphicRaycaster>();
			if ((bool)component3)
			{
				UnityEngine.Object.Destroy(component3);
			}
			if ((bool)component2 && !component2.enabled)
			{
				component2.enabled = true;
			}
			if ((bool)canvasBoxCollider)
			{
				UnityEngine.Object.Destroy(canvasBoxCollider);
			}
			if ((bool)canvasRigidBody)
			{
				UnityEngine.Object.Destroy(canvasRigidBody);
			}
			StopCoroutine(draggablePanelCreation);
			Transform transform = component.transform.Find("UICANVAS_DRAGGABLE_PANEL");
			if ((bool)transform)
			{
				UnityEngine.Object.Destroy(transform.gameObject);
			}
		}
	}
}
public struct UIDraggableItemEventArgs
{
	public GameObject target;
}
public delegate void UIDraggableItemEventHandler(object sender, UIDraggableItemEventArgs e);
public class Pvr_UIDraggableItem : MonoBehaviour, IBeginDragHandler, IEventSystemHandler, IDragHandler, IEndDragHandler
{
	public bool restrictToDropZone;

	public bool restrictToOriginalCanvas;

	public float moveOffset = 0.1f;

	[HideInInspector]
	public GameObject validDropZone;

	protected RectTransform dragTransform;

	protected Vector3 startPosition;

	protected Quaternion startRotation;

	protected GameObject startDropZone;

	protected Transform startParent;

	protected Canvas startCanvas;

	protected CanvasGroup canvasGroup;

	protected Pvr_InputModule currentInputmodule;

	public event UIDraggableItemEventHandler DraggableItemDropped;

	public event UIDraggableItemEventHandler DraggableItemReset;

	public virtual void OnDraggableItemDropped(UIDraggableItemEventArgs e)
	{
		if (this.DraggableItemDropped != null)
		{
			this.DraggableItemDropped(this, e);
		}
	}

	public virtual void OnDraggableItemReset(UIDraggableItemEventArgs e)
	{
		if (this.DraggableItemReset != null)
		{
			this.DraggableItemReset(this, e);
		}
	}

	public void OnBeginDrag(PointerEventData eventData)
	{
		startPosition = base.transform.position;
		startRotation = base.transform.rotation;
		startParent = base.transform.parent;
		startCanvas = GetComponentInParent<Canvas>();
		canvasGroup.blocksRaycasts = false;
		if (restrictToDropZone)
		{
			startDropZone = GetComponentInParent<Pvr_UIDropZone>().gameObject;
			validDropZone = startDropZone;
		}
		SetDragPosition(eventData);
		Pvr_UIPointer pointer = GetPointer();
		if (pointer != null)
		{
			pointer.OnUIPointerElementDragStart(pointer.SetUIPointerEvent(pointer.pointerEventData.pointerPressRaycast, base.gameObject));
		}
	}

	public void OnDrag(PointerEventData eventData)
	{
		SetDragPosition(eventData);
	}

	public void OnEndDrag(PointerEventData eventData)
	{
		canvasGroup.blocksRaycasts = true;
		dragTransform = null;
		base.transform.position += base.transform.forward * moveOffset;
		bool flag = true;
		if (restrictToDropZone)
		{
			if (validDropZone != null && validDropZone != startDropZone)
			{
				base.transform.SetParent(validDropZone.transform);
			}
			else
			{
				ResetElement();
				flag = false;
			}
		}
		Canvas canvas = ((eventData.pointerEnter != null) ? eventData.pointerEnter.GetComponentInParent<Canvas>() : null);
		if (restrictToOriginalCanvas && canvas != null && canvas != startCanvas)
		{
			ResetElement();
			flag = false;
		}
		if (canvas == null)
		{
			ResetElement();
			flag = false;
		}
		if (flag)
		{
			Pvr_UIPointer pointer = GetPointer();
			if (pointer != null)
			{
				pointer.OnUIPointerElementDragEnd(pointer.SetUIPointerEvent(pointer.pointerEventData.pointerPressRaycast, base.gameObject));
			}
			OnDraggableItemDropped(SetEventPayload(validDropZone));
		}
		validDropZone = null;
		startParent = null;
		startCanvas = null;
	}

	protected virtual void OnEnable()
	{
		canvasGroup = GetComponent<CanvasGroup>();
		if (restrictToDropZone && GetComponentInParent<Pvr_UIDropZone>() == null)
		{
			base.enabled = false;
		}
		currentInputmodule = UnityEngine.Object.FindObjectOfType<Pvr_InputModule>();
	}

	protected virtual Pvr_UIPointer GetPointer()
	{
		foreach (Pvr_UIPointer pointer in Pvr_InputModule.pointers)
		{
			if (pointer.gameObject.activeInHierarchy && (bool)pointer)
			{
				return pointer;
			}
		}
		return null;
	}

	protected virtual void SetDragPosition(PointerEventData eventData)
	{
		if (eventData.pointerEnter != null && eventData.pointerEnter.transform as RectTransform != null)
		{
			dragTransform = eventData.pointerEnter.transform as RectTransform;
		}
		if (dragTransform != null && RectTransformUtility.ScreenPointToWorldPointInRectangle(dragTransform, eventData.position, eventData.pressEventCamera, out var worldPoint))
		{
			base.transform.position = worldPoint - base.transform.forward * moveOffset;
			base.transform.rotation = dragTransform.rotation;
		}
	}

	protected virtual void ResetElement()
	{
		base.transform.position = startPosition;
		base.transform.rotation = startRotation;
		base.transform.SetParent(startParent);
		OnDraggableItemReset(SetEventPayload(startParent.gameObject));
	}

	protected virtual UIDraggableItemEventArgs SetEventPayload(GameObject target)
	{
		UIDraggableItemEventArgs result = default(UIDraggableItemEventArgs);
		result.target = target;
		return result;
	}
}
public class Pvr_UIDropZone : MonoBehaviour, IPointerEnterHandler, IEventSystemHandler, IPointerExitHandler
{
	protected Pvr_UIDraggableItem droppableItem;

	public void OnPointerEnter(PointerEventData eventData)
	{
		if ((bool)eventData.pointerDrag)
		{
			Pvr_UIDraggableItem component = eventData.pointerDrag.GetComponent<Pvr_UIDraggableItem>();
			if ((bool)component && component.restrictToDropZone)
			{
				component.validDropZone = base.gameObject;
				droppableItem = component;
			}
		}
	}

	public void OnPointerExit(PointerEventData eventData)
	{
		if ((bool)droppableItem)
		{
			droppableItem.validDropZone = null;
		}
		droppableItem = null;
	}
}
public class Pvr_UIGraphicRaycaster : GraphicRaycaster
{
	protected Canvas currentCanvas;

	protected Vector2 lastKnownPosition;

	protected const float UI_CONTROL_OFFSET = 1E-05f;

	[NonSerialized]
	private static List<RaycastResult> s_RaycastResults = new List<RaycastResult>();

	protected virtual Canvas canvas
	{
		get
		{
			if (currentCanvas != null)
			{
				return currentCanvas;
			}
			currentCanvas = base.gameObject.GetComponent<Canvas>();
			return currentCanvas;
		}
	}

	public override void Raycast(PointerEventData eventData, List<RaycastResult> resultAppendList)
	{
		if (!(canvas == null))
		{
			Raycast(ray: new Ray(eventData.pointerCurrentRaycast.worldPosition, eventData.pointerCurrentRaycast.worldNormal), canvas: canvas, eventCamera: eventCamera, results: ref s_RaycastResults);
			SetNearestRaycast(ref eventData, ref resultAppendList, ref s_RaycastResults);
			s_RaycastResults.Clear();
		}
	}

	protected virtual void SetNearestRaycast(ref PointerEventData eventData, ref List<RaycastResult> resultAppendList, ref List<RaycastResult> raycastResults)
	{
		RaycastResult? raycastResult = null;
		for (int i = 0; i < raycastResults.Count; i++)
		{
			RaycastResult raycastResult2 = raycastResults[i];
			raycastResult2.index = resultAppendList.Count;
			if (!raycastResult.HasValue || raycastResult2.distance < raycastResult.Value.distance)
			{
				raycastResult = raycastResult2;
			}
			resultAppendList.Add(raycastResult2);
		}
		if (raycastResult.HasValue)
		{
			eventData.position = raycastResult.Value.screenPosition;
			eventData.delta = eventData.position - lastKnownPosition;
			lastKnownPosition = eventData.position;
			eventData.pointerCurrentRaycast = raycastResult.Value;
		}
	}

	protected virtual float GetHitDistance(Ray ray)
	{
		float result = float.MaxValue;
		if (canvas.renderMode != 0 && base.blockingObjects != 0)
		{
			float num = Vector3.Distance(ray.origin, canvas.transform.position);
			if (base.blockingObjects == BlockingObjects.ThreeD || base.blockingObjects == BlockingObjects.All)
			{
				Physics.Raycast(ray, out var hitInfo, num);
				if ((bool)hitInfo.collider)
				{
					result = hitInfo.distance;
				}
			}
			if (base.blockingObjects == BlockingObjects.TwoD || base.blockingObjects == BlockingObjects.All)
			{
				RaycastHit2D raycastHit2D = Physics2D.Raycast(ray.origin, ray.direction, num);
				if (raycastHit2D.collider != null)
				{
					result = raycastHit2D.fraction * num;
				}
			}
		}
		return result;
	}

	protected virtual void Raycast(Canvas canvas, Camera eventCamera, Ray ray, ref List<RaycastResult> results)
	{
		float hitDistance = GetHitDistance(ray);
		IList<Graphic> graphicsForCanvas = GraphicRegistry.GetGraphicsForCanvas(canvas);
		for (int i = 0; i < graphicsForCanvas.Count; i++)
		{
			Graphic graphic = graphicsForCanvas[i];
			if (graphic.depth == -1 || !graphic.raycastTarget)
			{
				continue;
			}
			Transform transform = graphic.transform;
			Vector3 forward = transform.forward;
			float num = Vector3.Dot(forward, transform.position - ray.origin) / Vector3.Dot(forward, ray.direction);
			if (!(num < 0f) && !(num - 1E-05f > hitDistance))
			{
				Vector3 point = ray.GetPoint(num);
				Vector2 vector = eventCamera.WorldToScreenPoint(point);
				if (RectTransformUtility.RectangleContainsScreenPoint(graphic.rectTransform, vector, eventCamera) && graphic.Raycast(vector, eventCamera))
				{
					RaycastResult raycastResult = default(RaycastResult);
					raycastResult.gameObject = graphic.gameObject;
					raycastResult.module = this;
					raycastResult.distance = num;
					raycastResult.screenPosition = vector;
					raycastResult.worldPosition = point;
					raycastResult.depth = graphic.depth;
					raycastResult.sortingLayer = canvas.sortingLayerID;
					raycastResult.sortingOrder = canvas.sortingOrder;
					RaycastResult item = raycastResult;
					results.Add(item);
				}
			}
		}
		results.Sort((RaycastResult g1, RaycastResult g2) => g2.depth.CompareTo(g1.depth));
	}
}
public struct UIPointerEventArgs
{
	public bool isActive;

	public GameObject currentTarget;

	public GameObject previousTarget;

	public RaycastResult raycastResult;
}
public delegate void UIPointerEventHandler(object sender, UIPointerEventArgs e);
public class Pvr_UIPointer : MonoBehaviour
{
	public enum ClickMethods
	{
		ClickOnButtonUp,
		ClickOnButtonDown
	}

	public ClickMethods clickMethod;

	[HideInInspector]
	public bool collisionClick;

	[HideInInspector]
	public bool pressToDrag;

	[HideInInspector]
	public GameObject autoActivatingCanvas;

	[HideInInspector]
	public PointerEventData pointerEventData;

	[HideInInspector]
	public GameObject hoveringElement;

	[HideInInspector]
	public float hoverDurationTimer;

	[HideInInspector]
	public bool canClickOnHover;

	public Transform pointerOriginTransform;

	protected bool pointerClicked;

	protected bool beamEnabledState;

	protected bool lastPointerPressState;

	protected bool lastPointerClickState;

	protected GameObject currentTarget;

	protected EventSystem cachedEventSystem;

	protected Pvr_InputModule cachedVRInputModule;

	protected Transform originalPointerOriginTransform;

	public static bool TouchBtnValue;

	public static bool AppBtnValue;

	public static bool TriggerBtnValue;

	public event UIPointerEventHandler UIPointerElementEnter;

	public event UIPointerEventHandler UIPointerElementExit;

	public event UIPointerEventHandler UIPointerElementClick;

	public event UIPointerEventHandler UIPointerElementDragStart;

	public event UIPointerEventHandler UIPointerElementDragEnd;

	public virtual bool PointerActive()
	{
		return true;
	}

	public virtual bool IsSelectionButtonPressed()
	{
		if (!Input.GetMouseButton(0) && !Input.GetKey(KeyCode.JoystickButton0) && !TouchBtnValue && !AppBtnValue)
		{
			return TriggerBtnValue;
		}
		return true;
	}

	public virtual Vector3 GetOriginPosition()
	{
		if (!pointerOriginTransform)
		{
			return base.transform.position;
		}
		return pointerOriginTransform.position;
	}

	public virtual Vector3 GetOriginForward()
	{
		if (!pointerOriginTransform)
		{
			return base.transform.forward;
		}
		return pointerOriginTransform.forward;
	}

	public virtual bool ValidClick(bool checkLastClick, bool lastClickState = false)
	{
		bool result = (collisionClick ? collisionClick : IsSelectionButtonPressed());
		if (!checkLastClick)
		{
			return result;
		}
		return result;
	}

	protected virtual void ResetHoverTimer()
	{
		hoverDurationTimer = 0f;
		canClickOnHover = false;
	}

	public virtual void OnUIPointerElementEnter(UIPointerEventArgs e)
	{
		if (e.currentTarget != currentTarget)
		{
			ResetHoverTimer();
		}
		currentTarget = e.currentTarget;
		if (this.UIPointerElementEnter != null)
		{
			this.UIPointerElementEnter(this, e);
		}
	}

	public virtual void OnUIPointerElementExit(UIPointerEventArgs e)
	{
		if (e.previousTarget == currentTarget)
		{
			ResetHoverTimer();
		}
		if (this.UIPointerElementExit != null)
		{
			this.UIPointerElementExit(this, e);
		}
	}

	public virtual void OnUIPointerElementClick(UIPointerEventArgs e)
	{
		if (e.currentTarget == currentTarget)
		{
			ResetHoverTimer();
		}
		if (this.UIPointerElementClick != null)
		{
			this.UIPointerElementClick(this, e);
		}
	}

	public virtual void OnUIPointerElementDragStart(UIPointerEventArgs e)
	{
		if (this.UIPointerElementDragStart != null)
		{
			this.UIPointerElementDragStart(this, e);
		}
	}

	public virtual void OnUIPointerElementDragEnd(UIPointerEventArgs e)
	{
		if (this.UIPointerElementDragEnd != null)
		{
			this.UIPointerElementDragEnd(this, e);
		}
	}

	public virtual UIPointerEventArgs SetUIPointerEvent(RaycastResult currentRaycastResult, GameObject currentTarget, GameObject lastTarget = null)
	{
		UIPointerEventArgs result = default(UIPointerEventArgs);
		result.isActive = PointerActive();
		result.currentTarget = currentTarget;
		result.previousTarget = lastTarget;
		result.raycastResult = currentRaycastResult;
		return result;
	}

	protected virtual void Awake()
	{
		originalPointerOriginTransform = pointerOriginTransform;
	}

	protected virtual void OnEnable()
	{
		pointerOriginTransform = originalPointerOriginTransform;
		ConfigureEventSystem();
		pointerClicked = false;
		lastPointerPressState = false;
		lastPointerClickState = false;
		beamEnabledState = false;
	}

	protected virtual void OnDisable()
	{
		Pvr_InputModule.RemovePoint(this);
	}

	protected virtual void ConfigureEventSystem()
	{
		if (!cachedEventSystem)
		{
			cachedEventSystem = UnityEngine.Object.FindObjectOfType<EventSystem>();
		}
		if (!cachedVRInputModule)
		{
			cachedVRInputModule = cachedEventSystem.GetComponent<Pvr_InputModule>();
		}
		if ((bool)cachedEventSystem && (bool)cachedVRInputModule && pointerEventData == null)
		{
			pointerEventData = new PointerEventData(cachedEventSystem);
		}
		Pvr_InputModule.AddPoint(this);
	}
}
[ExecuteInEditMode]
public class Pvr_UnitySDKEditor : MonoBehaviour
{
	private bool vrModeEnabled = true;

	private float mouseX;

	private float mouseY;

	private float mouseZ;

	private float neckModelScale;

	private bool autoUntiltHead;

	private static readonly Vector3 neckOffset = new Vector3(0f, 0.075f, 0.0805f);

	[HideInInspector]
	public Matrix4x4 headView;

	[HideInInspector]
	public Matrix4x4 leftEyeUndistortedProj;

	[HideInInspector]
	public Matrix4x4 rightEyeUndistortedProj;

	[HideInInspector]
	public Matrix4x4 leftEyeProj;

	[HideInInspector]
	public Matrix4x4 rightEyeProj;

	private const float TOUCH_TIME_LIMIT = 0.2f;

	private float touchStartTime;

	public Matrix4x4 UndistortedProjection(Eye eye)
	{
		if (eye != 0)
		{
			return rightEyeUndistortedProj;
		}
		return leftEyeUndistortedProj;
	}

	public Matrix4x4 Projection(Eye eye)
	{
		if (eye != 0)
		{
			return rightEyeProj;
		}
		return leftEyeProj;
	}

	private void Awake()
	{
		InitEyePara();
		InitEditorSensorPara();
	}

	private void Update()
	{
		SimulateInput();
		Pvr_UnitySDKManager.SDK.picovrTriggered = Pvr_UnitySDKManager.SDK.newPicovrTriggered;
		Pvr_UnitySDKManager.SDK.newPicovrTriggered = false;
	}

	public void InitEyePara()
	{
		ComputeEyesFromProfile();
		InitForEye(ref Pvr_UnitySDKManager.SDK.Eyematerial, ref Pvr_UnitySDKManager.SDK.Middlematerial);
		if (Pvr_UnitySDKRender.Instance == null)
		{
			PLOG.I("pvr_UnitySDKRender init failed");
		}
		if (Pvr_UnitySDKSensor.Instance == null)
		{
			PLOG.I("pvr_UnitySDKSensor init failed");
		}
		FovAdjust();
	}

	private void InitEditorSensorPara()
	{
		Pvr_UnitySDKManager.SDK.picovrTriggered = Pvr_UnitySDKManager.SDK.newPicovrTriggered;
		Pvr_UnitySDKManager.SDK.newPicovrTriggered = false;
	}

	public static Matrix4x4 MakeProjection(float l, float t, float r, float b, float n, float f)
	{
		Matrix4x4 zero = Matrix4x4.zero;
		zero[0, 0] = 2f * n / (r - l);
		zero[1, 1] = 2f * n / (t - b);
		zero[0, 2] = (r + l) / (r - l);
		zero[1, 2] = (t + b) / (t - b);
		zero[2, 2] = (n + f) / (n - f);
		zero[2, 3] = 2f * n * f / (n - f);
		zero[3, 2] = -1f;
		return zero;
	}

	public bool UpdateStatesensor()
	{
		UpdateSimulatedSensor();
		return true;
	}

	public void ComputeEyesFromProfile()
	{
		Vector2 vector = new Vector2(0.11f, 0.062f);
		Pvr_UnitySDKManager.SDK.leftEyeView = Matrix4x4.identity;
		Pvr_UnitySDKManager.SDK.leftEyeView[0, 3] = (0f - Pvr_UnitySDKManager.SDK.pvr_UnitySDKConfig.device.devLenses.separation) / 2f;
		float[] leftEyeVisibleTanAngles = Pvr_UnitySDKManager.SDK.pvr_UnitySDKConfig.GetLeftEyeVisibleTanAngles(vector.x, vector.y);
		leftEyeProj = MakeProjection(leftEyeVisibleTanAngles[0], leftEyeVisibleTanAngles[1], leftEyeVisibleTanAngles[2], leftEyeVisibleTanAngles[3], 1f, 1000f);
		leftEyeVisibleTanAngles = Pvr_UnitySDKManager.SDK.pvr_UnitySDKConfig.GetLeftEyeNoLensTanAngles(vector.x, vector.y);
		leftEyeUndistortedProj = MakeProjection(leftEyeVisibleTanAngles[0], leftEyeVisibleTanAngles[1], leftEyeVisibleTanAngles[2], leftEyeVisibleTanAngles[3], 1f, 1000f);
		Pvr_UnitySDKManager.SDK.leftEyeRect = Pvr_UnitySDKManager.SDK.pvr_UnitySDKConfig.GetLeftEyeVisibleScreenRect(leftEyeVisibleTanAngles, vector.x, vector.y);
		Pvr_UnitySDKManager.SDK.rightEyeView = Pvr_UnitySDKManager.SDK.leftEyeView;
		Pvr_UnitySDKManager.SDK.rightEyeView[0, 3] *= -1f;
		rightEyeProj = leftEyeProj;
		rightEyeProj[0, 2] *= -1f;
		rightEyeUndistortedProj = leftEyeUndistortedProj;
		rightEyeUndistortedProj[0, 2] *= -1f;
		Rect leftEyeRect = new Rect(0f, 0f, 0.5f, 1f);
		Rect rightEyeRect = new Rect(0.5f, 0f, 0.5f, 1f);
		Pvr_UnitySDKManager.SDK.leftEyeRect = leftEyeRect;
		Pvr_UnitySDKManager.SDK.rightEyeRect = rightEyeRect;
		Pvr_UnitySDKManager.SDK.leftEyeOffset = new Vector3((0f - Pvr_UnitySDKManager.SDK.pvr_UnitySDKConfig.device.devLenses.separation) / 2f, 0f, 0f);
		Pvr_UnitySDKManager.SDK.rightEyeOffset = new Vector3(Pvr_UnitySDKManager.SDK.pvr_UnitySDKConfig.device.devLenses.separation / 2f, 0f, 0f);
	}

	public bool ResetUnitySDKSensor()
	{
		mouseX = (mouseY = (mouseZ = 0f));
		return true;
	}

	private void SimulateInput()
	{
		if (Input.GetMouseButtonDown(0) && (Input.GetKey(KeyCode.LeftAlt) || Input.GetKey(KeyCode.RightAlt)))
		{
			EnableVEmodel();
		}
		if (Input.GetMouseButtonDown(0))
		{
			touchStartTime = Time.time;
		}
		else if (Input.GetMouseButtonUp(0))
		{
			if (Time.time - touchStartTime <= 0.2f)
			{
				Pvr_UnitySDKManager.SDK.newPicovrTriggered = true;
			}
			touchStartTime = 0f;
		}
		UpdateSimulatedSensor();
	}

	private void FovAdjust()
	{
		Pvr_UnitySDKRender.Instance.EyeVFoV = 2f * Pvr_UnitySDKManager.SDK.pvr_UnitySDKConfig.device.devMaxFov.upper;
	}

	private Rect RectAdjust(Rect eyeRect)
	{
		Rect result = new Rect(0f, 0f, 0.5f, 1f);
		result.width *= 2f * eyeRect.width;
		result.x = eyeRect.x + 2f * result.x * eyeRect.width;
		result.height *= eyeRect.height;
		result.y = eyeRect.y + result.y * eyeRect.height;
		return result;
	}

	private void UpdateSimulatedSensor()
	{
		bool flag = false;
		if (Input.GetKey(KeyCode.LeftAlt) || Input.GetKey(KeyCode.RightAlt))
		{
			mouseX += Input.GetAxis("Mouse X") * 5f;
			if (mouseX <= -180f)
			{
				mouseX += 360f;
			}
			else if (mouseX > 180f)
			{
				mouseX -= 360f;
			}
			mouseY -= Input.GetAxis("Mouse Y") * 2.4f;
			mouseY = Mathf.Clamp(mouseY, -91f, 91f);
		}
		else if (Input.GetKey(KeyCode.LeftControl) || Input.GetKey(KeyCode.RightControl))
		{
			flag = true;
			mouseZ += Input.GetAxis("Mouse X") * 5f;
			mouseZ = Mathf.Clamp(mouseZ, -91f, 91f);
		}
		if (!flag && autoUntiltHead)
		{
			mouseZ = Mathf.Lerp(mouseZ, 0f, Time.deltaTime / (Time.deltaTime + 0.1f));
		}
		Quaternion quaternion = Quaternion.Euler(mouseY, mouseX, mouseZ);
		Matrix4x4 matrix = Matrix4x4.TRS((quaternion * neckOffset - neckOffset.y * Vector3.up) * neckModelScale, quaternion, Vector3.one);
		Pvr_UnitySDKSensor.Instance.HeadPose = new Pvr_UnitySDKPose(matrix);
	}

	private void InitForEye(ref Material mat, ref Material mat1)
	{
		Shader shader = Shader.Find("Pvr_UnitySDK/Undistortion");
		Shader shader2 = Shader.Find("Pvr_UnitySDK/FillColor");
		if (shader == null || shader2 == null)
		{
			PLOG.E("Ths Shader Missing ！");
			return;
		}
		mat = new Material(shader);
		mat1 = new Material(shader2);
	}

	private void EnableVEmodel()
	{
		vrModeEnabled = !vrModeEnabled;
		Pvr_UnitySDKManager.SDK.VRModeEnabled = vrModeEnabled;
	}
}
public class Pvr_VolumePowerBrightness : MonoBehaviour
{
	private bool VolEnable;

	private bool BattEnable;

	public Text showResult;

	public Text setVolumnum;

	public Text setBrightnum;

	public string MusicPath;

	private void Awake()
	{
		InitBatteryVolClass();
		string startreceivre = base.gameObject.name;
		StartBatteryReceiver(startreceivre);
		StartAudioReceiver(startreceivre);
	}

	private void OnDisable()
	{
		if (VolEnable)
		{
			StopAudioReceiver();
		}
		if (BattEnable)
		{
			StopBatteryReceiver();
		}
	}

	public void GetMaxVolumeNumber()
	{
		int num = 0;
		num = VolumePowerBrightness.UPvr_GetMaxVolumeNumber();
		showResult.text = "Maximum volume: " + num;
	}

	public void GetCurrentVolumeNumber()
	{
		int num = 0;
		num = VolumePowerBrightness.UPvr_GetCurrentVolumeNumber();
		showResult.text = "Current volume：" + num;
	}

	public void VolumeUp()
	{
		if (!VolumePowerBrightness.UPvr_VolumeUp())
		{
			PLOG.E("VolumeUp Error");
		}
	}

	public void VolumeDown()
	{
		if (!VolumePowerBrightness.UPvr_VolumeDown())
		{
			PLOG.E("VolumeDown Error");
		}
	}

	public void SetVolumeNum()
	{
		int volume = new System.Random().Next(0, 15);
		setVolumnum.text = "Random number：" + volume;
		if (!VolumePowerBrightness.UPvr_SetVolumeNum(volume))
		{
			PLOG.E("SetVolumeNum Error");
		}
	}

	public void SetBrightness()
	{
		int brightness = new System.Random().Next(0, 255);
		setBrightnum.text = "Random number：" + brightness;
		if (!VolumePowerBrightness.UPvr_SetCommonBrightness(brightness))
		{
			PLOG.E("SetBrightness Error");
		}
	}

	public void GetCurrentBrightness()
	{
		int num = 0;
		num = VolumePowerBrightness.UPvr_GetCommonBrightness();
		showResult.text = "Current brightness：" + num;
	}

	public bool setAudio(string s)
	{
		PLOG.I(s.ToString());
		return true;
	}

	public bool setBattery(string s)
	{
		PLOG.I(s.ToString());
		return true;
	}

	private bool InitBatteryVolClass()
	{
		return VolumePowerBrightness.UPvr_InitBatteryVolClass();
	}

	private bool StartBatteryReceiver(string startreceivre)
	{
		BattEnable = VolumePowerBrightness.UPvr_StartBatteryReceiver(startreceivre);
		return BattEnable;
	}

	private bool StopBatteryReceiver()
	{
		return VolumePowerBrightness.UPvr_StopBatteryReceiver();
	}

	private bool StartAudioReceiver(string startreceivre)
	{
		VolEnable = VolumePowerBrightness.UPvr_StartAudioReceiver(startreceivre);
		return VolEnable;
	}

	private bool StopAudioReceiver()
	{
		return VolumePowerBrightness.UPvr_StopAudioReceiver();
	}
}
[CreateAssetMenu(fileName = "PlayFabSharedSettings", menuName = "PlayFab/CreateSharedSettings", order = 1)]
public class PlayFabSharedSettings : ScriptableObject
{
	public string TitleId;

	internal string VerticalName;

	public string ProductionEnvironmentUrl = "";

	public WebRequestType RequestType;

	public string AdvertisingIdType;

	public string AdvertisingIdValue;

	public bool DisableAdvertising;

	public bool DisableDeviceInfo;

	public bool DisableFocusTimeCollection;

	public int RequestTimeout = 2000;

	public bool RequestKeepAlive = true;

	public bool CompressApiData = true;

	public PlayFabLogLevel LogLevel = PlayFabLogLevel.Warning | PlayFabLogLevel.Error;

	public string LoggerHost = "";

	public int LoggerPort;

	public bool EnableRealTimeLogging;

	public int LogCapLimit = 30;
}
public class csControllerForSteamVR : MonoBehaviour
{
	public Transform thisT;

	public bool isBusy;

	[Tooltip("The device this action should apply to. Any if the action is not device specific.")]
	public SteamVR_Input_Sources inputSource;

	public SteamVR_Behaviour_Pose PoseBeheavior;

	public SteamVR_Action_Single triggerValue = SteamVR_Input.GetAction<SteamVR_Action_Single>("Squeeze");

	public SteamVR_Action_Boolean grabPinchAction = SteamVR_Input.GetAction<SteamVR_Action_Boolean>("GrabPinch");

	public SteamVR_Action_Vibration hapticAction = SteamVR_Input.GetAction<SteamVR_Action_Vibration>("Haptic");

	public SteamVR_Action_Boolean pressAction = SteamVR_Input.GetAction<SteamVR_Action_Boolean>("Teleport");

	public SteamVR_Action_Boolean stickAction = SteamVR_Input.GetAction<SteamVR_Action_Boolean>("StickPress");

	public SteamVR_Action_Boolean menuAction = SteamVR_Input.GetAction<SteamVR_Action_Boolean>("MenuPress");

	public SteamVR_Action_Vector2 moveAction = SteamVR_Input.GetAction<SteamVR_Action_Vector2>("Actions/Default/in/Move");

	public SteamVR_Action_Vector2 stickMoveAction = SteamVR_Input.GetAction<SteamVR_Action_Vector2>("StickMove");

	public SteamVR_Action_Boolean grabGripAction = SteamVR_Input.GetAction<SteamVR_Action_Boolean>("GrabGrip");

	public SteamVR_Action_Boolean padTouchAction = SteamVR_Input.GetAction<SteamVR_Action_Boolean>("PadTouch");

	private static float MaxH = 2000f;

	private static float TestTime = 0.1f;

	private static Coroutine TriggerHapticPulseCoroutine;

	private static float h1 = 0.05f;

	private static float Test1Power = 3500f;

	private void Awake()
	{
		PoseBeheavior.onTrackingChanged.AddListener(OnTrackChange);
	}

	private void OnTrackChange(SteamVR_Behaviour_Pose p, SteamVR_Input_Sources s, ETrackingResult r)
	{
		if (!GameManager.Player)
		{
			return;
		}
		if (r != ETrackingResult.Running_OK && r != ETrackingResult.Running_OutOfRange)
		{
			if (s == SteamVR_Input_Sources.LeftHand && csGameSettings.IsLeftMove)
			{
				GameManager.Player.SetIsFocus(isF: false);
			}
			else if (s == SteamVR_Input_Sources.RightHand && !csGameSettings.IsLeftMove)
			{
				GameManager.Player.SetIsFocus(isF: false);
			}
		}
		else if (s == SteamVR_Input_Sources.LeftHand && csGameSettings.IsLeftMove)
		{
			GameManager.Player.SetIsFocus(isF: true);
		}
		else if (s == SteamVR_Input_Sources.RightHand && !csGameSettings.IsLeftMove)
		{
			GameManager.Player.SetIsFocus(isF: true);
		}
	}

	public bool GetTriggerPress()
	{
		return OVRInput.Get(OVRInput.Button.PrimaryIndexTrigger, (inputSource == SteamVR_Input_Sources.LeftHand) ? OVRInput.Controller.LTouch : OVRInput.Controller.RTouch);
	}

	public bool GetTriggerPressDown()
	{
		return grabPinchAction.GetStateDown(inputSource);
	}

	public static bool GetPressDown_TriggerOC(bool isLeft)
	{
		if (csGameSettings.Channel == ChannelType.OculusGO)
		{
			return OVRInput.GetDown(OVRInput.Button.PrimaryIndexTrigger);
		}
		if (!OVRInput.GetDown(isLeft ? OVRInput.RawButton.LIndexTrigger : OVRInput.RawButton.RIndexTrigger))
		{
			return OVRInput.GetDown(OVRInput.Button.PrimaryIndexTrigger, isLeft ? OVRInput.Controller.LTouch : OVRInput.Controller.RTouch);
		}
		return true;
	}

	public static bool GetPressUp_TriggerOC(bool isLeft)
	{
		if (csGameSettings.Channel == ChannelType.OculusGO)
		{
			return OVRInput.GetUp(OVRInput.Button.PrimaryIndexTrigger);
		}
		if (!OVRInput.GetUp(isLeft ? OVRInput.RawButton.LIndexTrigger : OVRInput.RawButton.RIndexTrigger))
		{
			return OVRInput.GetUp(OVRInput.Button.PrimaryIndexTrigger, isLeft ? OVRInput.Controller.LTouch : OVRInput.Controller.RTouch);
		}
		return true;
	}

	public bool GetTriggerPressUp()
	{
		return OVRInput.GetUp(OVRInput.Button.PrimaryIndexTrigger, (inputSource == SteamVR_Input_Sources.LeftHand) ? OVRInput.Controller.LTouch : OVRInput.Controller.RTouch);
	}

	public bool GetPadPress()
	{
		return OVRInput.Get(OVRInput.Button.SecondaryThumbstick, (inputSource == SteamVR_Input_Sources.LeftHand) ? OVRInput.Controller.LTouch : OVRInput.Controller.RTouch);
	}

	public bool GetPadPressDown()
	{
		return OVRInput.GetDown(OVRInput.Button.SecondaryThumbstick, (inputSource == SteamVR_Input_Sources.LeftHand) ? OVRInput.Controller.LTouch : OVRInput.Controller.RTouch);
	}

	public bool GetPadPressUp()
	{
		return OVRInput.GetUp(OVRInput.Button.SecondaryThumbstick, (inputSource == SteamVR_Input_Sources.LeftHand) ? OVRInput.Controller.LTouch : OVRInput.Controller.RTouch);
	}

	public bool GetStickPress()
	{
		return OVRInput.Get(OVRInput.Button.SecondaryThumbstick, (inputSource == SteamVR_Input_Sources.LeftHand) ? OVRInput.Controller.LTouch : OVRInput.Controller.RTouch);
	}

	public bool GetStickPressDown()
	{
		return OVRInput.GetDown(OVRInput.Button.SecondaryThumbstick, (inputSource == SteamVR_Input_Sources.LeftHand) ? OVRInput.Controller.LTouch : OVRInput.Controller.RTouch);
	}

	public bool GetStickPressUp()
	{
		return OVRInput.GetUp(OVRInput.Button.SecondaryThumbstick, (inputSource == SteamVR_Input_Sources.LeftHand) ? OVRInput.Controller.LTouch : OVRInput.Controller.RTouch);
	}

	public float GetTriggerValue()
	{
		return OVRInput.Get(OVRInput.Axis1D.PrimaryIndexTrigger, (inputSource == SteamVR_Input_Sources.LeftHand) ? OVRInput.Controller.LTouch : OVRInput.Controller.RTouch);
	}

	public Vector2 GetPadAxis()
	{
		return OVRInput.Get(OVRInput.Axis2D.PrimaryThumbstick, (inputSource == SteamVR_Input_Sources.LeftHand) ? OVRInput.Controller.LTouch : OVRInput.Controller.RTouch);
	}

	public Vector2 GetStickAxis()
	{
		return OVRInput.Get(OVRInput.Axis2D.PrimaryThumbstick, (inputSource == SteamVR_Input_Sources.LeftHand) ? OVRInput.Controller.LTouch : OVRInput.Controller.RTouch);
	}

	public Vector3 GetVelocity()
	{
		return OVRInput.GetLocalControllerVelocity((inputSource == SteamVR_Input_Sources.LeftHand) ? OVRInput.Controller.LTouch : OVRInput.Controller.RTouch);
	}

	public bool GetGripDown()
	{
		return OVRInput.GetDown(OVRInput.Button.PrimaryHandTrigger, (inputSource == SteamVR_Input_Sources.LeftHand) ? OVRInput.Controller.LTouch : OVRInput.Controller.RTouch);
	}

	public bool GetGripPress()
	{
		return OVRInput.Get(OVRInput.Button.PrimaryHandTrigger, (inputSource == SteamVR_Input_Sources.LeftHand) ? OVRInput.Controller.LTouch : OVRInput.Controller.RTouch);
	}

	public bool GetGripUp()
	{
		return OVRInput.GetUp(OVRInput.Button.PrimaryHandTrigger, (inputSource == SteamVR_Input_Sources.LeftHand) ? OVRInput.Controller.LTouch : OVRInput.Controller.RTouch);
	}

	public bool GetMenuPressDown()
	{
		return OVRInput.GetDown(OVRInput.Button.Back, (inputSource == SteamVR_Input_Sources.LeftHand) ? OVRInput.Controller.LTouch : OVRInput.Controller.RTouch);
	}

	public static bool GetPressDown_MenuOC(bool isLeft)
	{
		if (csGameSettings.Channel == ChannelType.OculusGO)
		{
			if (!OVRInput.GetDown(OVRInput.RawButton.Back) && !OVRInput.GetDown(OVRInput.Button.Back, isLeft ? OVRInput.Controller.LTouch : OVRInput.Controller.RTouch))
			{
				return OVRInput.GetDown(OVRInput.Button.Two, isLeft ? OVRInput.Controller.LTouch : OVRInput.Controller.RTouch);
			}
			return true;
		}
		if (!OVRInput.GetDown(OVRInput.RawButton.Back) && !OVRInput.GetDown(OVRInput.Button.Back, isLeft ? OVRInput.Controller.LTouch : OVRInput.Controller.RTouch))
		{
			return OVRInput.GetDown(OVRInput.Button.Two, isLeft ? OVRInput.Controller.LTouch : OVRInput.Controller.RTouch);
		}
		return true;
	}

	public bool GetMenuPressUp()
	{
		return OVRInput.GetUp(OVRInput.Button.Two, (inputSource == SteamVR_Input_Sources.LeftHand) ? OVRInput.Controller.LTouch : OVRInput.Controller.RTouch);
	}

	public Vector3 GetAngularVelocity()
	{
		return OVRInput.GetLocalControllerVelocity((inputSource == SteamVR_Input_Sources.LeftHand) ? OVRInput.Controller.LTouch : OVRInput.Controller.RTouch);
	}

	public void TriggerHapticPulse(ushort microSecondsDuration)
	{
		if (csPlayerData.VibrationSwitch)
		{
			_ = (float)(int)microSecondsDuration / 1000000f;
			if (csGameSettings.Channel == ChannelType.OculusGO)
			{
				OVRInput.SetControllerVibration(0.5f, 0.5f);
			}
			else
			{
				OVRInput.SetControllerVibration(0.5f, 0.5f, (inputSource == SteamVR_Input_Sources.LeftHand) ? OVRInput.Controller.LTouch : OVRInput.Controller.RTouch);
			}
		}
	}

	public static void TriggerHapticPulse_Wave(bool lHand, ushort microSecondsDuration)
	{
		if (csPlayerData.VibrationSwitch)
		{
			if (csGameSettings.Channel == ChannelType.WaveVR_3Dof)
			{
				WaveVR_Controller.Input(WaveVR_Controller.EDeviceType.Dominant).TriggerHapticPulse(microSecondsDuration);
			}
			else
			{
				WaveVR_Controller.Input(lHand ? WaveVR_Controller.EDeviceType.NonDominant : WaveVR_Controller.EDeviceType.Dominant).TriggerHapticPulse(microSecondsDuration);
			}
		}
	}

	public void TriggerHapticPulse(float duration, float frequency, float amplitude)
	{
		if (csPlayerData.VibrationSwitch)
		{
			OVRInput.SetControllerVibration(0.5f, 0.5f, (inputSource == SteamVR_Input_Sources.LeftHand) ? OVRInput.Controller.LTouch : OVRInput.Controller.RTouch);
		}
	}

	public static void TriggerHapticPulse_OC(bool isL, int power)
	{
		if (csPlayerData.VibrationSwitch)
		{
			if ((float)power > MaxH)
			{
				power = (int)MaxH;
			}
			if (TriggerHapticPulseCoroutine == null)
			{
				csLocalizationManager.Instance.StartCoroutine(IETriggerHapticPulse(isL, power));
			}
		}
	}

	private static IEnumerator IETriggerHapticPulse(bool isL, int power)
	{
		if (csGameSettings.Channel == ChannelType.OculusGO)
		{
			OVRInput.SetControllerVibration(h1, (float)power / Test1Power);
		}
		else if (isL)
		{
			OVRInput.SetControllerVibration(h1, (float)power / Test1Power, isL ? OVRInput.Controller.LTouch : OVRInput.Controller.RTouch);
		}
		else
		{
			OVRInput.SetControllerVibration(h1, (float)power / Test1Power, isL ? OVRInput.Controller.LTouch : OVRInput.Controller.RTouch);
		}
		yield return new WaitForSecondsRealtime(TestTime);
		TriggerHapticPulseCoroutine = null;
		if (csGameSettings.Channel == ChannelType.OculusGO)
		{
			OVRInput.SetControllerVibration(0f, 0f);
		}
		else if (isL)
		{
			OVRInput.SetControllerVibration(0f, 0f, isL ? OVRInput.Controller.LTouch : OVRInput.Controller.RTouch);
		}
		else
		{
			OVRInput.SetControllerVibration(0f, 0f, isL ? OVRInput.Controller.LTouch : OVRInput.Controller.RTouch);
		}
	}

	public bool GetPadTouchUp()
	{
		return padTouchAction.GetStateUp(inputSource);
	}

	public bool GetPadTouch()
	{
		return OVRInput.Get(OVRInput.Axis2D.PrimaryThumbstick, (inputSource == SteamVR_Input_Sources.LeftHand) ? OVRInput.Controller.LTouch : OVRInput.Controller.RTouch).magnitude > 0.81f;
	}

	public bool GetPadTouchDown()
	{
		return padTouchAction.GetStateDown(inputSource);
	}
}
public class csHeadSetForSteamVR : MonoBehaviour
{
	public SteamVR_Input_Sources inputSource;

	public SteamVR_Action_Boolean headSetAction = SteamVR_Input.GetAction<SteamVR_Action_Boolean>("HeadsetOnHead");

	public bool HeadOn = true;

	private void Start()
	{
	}

	private void Update()
	{
		if (headSetAction != null && HeadOn != GetHeadSetOn())
		{
			HeadOn = GetHeadSetOn();
			if ((bool)GameManager.Player && GameManager.CurrentState == GameManager.GameState.Playing)
			{
				GameManager.Player.SetIsFocus(HeadOn);
			}
		}
	}

	public bool GetHeadSetOn()
	{
		return headSetAction.GetState(inputSource);
	}
}
public class csFPSCounter : MonoBehaviour
{
	public Transform target;

	public Text TitleText;

	private Transform thisT;

	public float frequency = 0.5f;

	public int FramesPerSec { get; protected set; }

	public void Init(Transform t)
	{
		target = t;
		thisT.position = target.position;
		thisT.rotation = target.rotation;
	}

	private void Awake()
	{
		thisT = base.transform;
	}

	public void ShowBoard(bool isShow)
	{
		thisT.position = target.position + Vector3.zero;
		thisT.rotation = target.rotation;
		base.gameObject.SetActive(isShow);
	}

	private void Update()
	{
		TitleText.text = FramesPerSec.ToString();
		if (!(target == null))
		{
			thisT.position = Vector3.Lerp(thisT.position, target.position + Vector3.zero, Time.deltaTime * 5f);
			thisT.rotation = Quaternion.Lerp(thisT.rotation, target.rotation, Time.deltaTime * 5f);
		}
	}

	private void Start()
	{
		StartCoroutine(FPS());
	}

	private IEnumerator FPS()
	{
		WaitForSeconds gap = new WaitForSeconds(frequency);
		while (true)
		{
			int lastFrameCount = Time.frameCount;
			float lastTime = Time.realtimeSinceStartup;
			yield return gap;
			float num = Time.realtimeSinceStartup - lastTime;
			int num2 = Time.frameCount - lastFrameCount;
			FramesPerSec = Mathf.RoundToInt((float)num2 / num);
		}
	}
}
public class csLeaderboard : MonoBehaviour
{
	public static csLeaderboard instance;

	public Dictionary<string, LeaderboardInfo> LeaderboardInfoByPlayerID = new Dictionary<string, LeaderboardInfo>();

	public Dictionary<string, LeaderboardInfo> LeaderboardInfoByPlayerID_Playfab = new Dictionary<string, LeaderboardInfo>();

	private bool hasFirstRead;

	public static Action<bool> RefreshLeaderboardAction;

	private void Awake()
	{
		if (instance == null)
		{
			instance = this;
			UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
			ReadData();
		}
		else
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}

	private void ReadData()
	{
		LeaderboardInfoByPlayerID = new Dictionary<string, LeaderboardInfo>();
		string @string = PlayerPrefs.GetString("LocalLeaderboard", "");
		UnityEngine.Debug.Log(@string);
		if (string.IsNullOrEmpty(@string))
		{
			LeaderboardInfoByPlayerID.Add("QWER", new LeaderboardInfo("foreach", 7945, 69, "CN"));
			LeaderboardInfoByPlayerID.Add("ASDF", new LeaderboardInfo("Startrails", 9924, 80, "CN"));
			LeaderboardInfoByPlayerID.Add("ZXCV", new LeaderboardInfo("猪头骑士", 480, 23, "CN"));
			LeaderboardInfoByPlayerID.Add("WERT", new LeaderboardInfo("DuyIfAnnn", 12138, 121, "CN"));
			LeaderboardInfoByPlayerID.Add("SDFG", new LeaderboardInfo("Cmzhe", 7682, 63, "CN"));
			LeaderboardInfoByPlayerID.Add("XCVB", new LeaderboardInfo("龙帥", 9528, 75, "CN"));
			LeaderboardInfoByPlayerID.Add("ERTY", new LeaderboardInfo("斯大玲", 10780, 110, "CN"));
			LeaderboardInfoByPlayerID.Add("DFGH", new LeaderboardInfo("Nop", 5103, 43, "CN"));
			LeaderboardInfoByPlayerID.Add("CVBN", new LeaderboardInfo("Aesthetica", 11532, 115, "CN"));
			LeaderboardInfoByPlayerID.Add("RTYU", new LeaderboardInfo("小小的太阳", 10615, 108, "CN"));
			SaveData();
		}
		else
		{
			string[] array = @string.Split(';');
			for (int i = 0; i < array.Length; i++)
			{
				string[] array2 = array[i].Split(',');
				string key = array2[0];
				string text = array2[1];
				int score = int.Parse(array2[2]);
				int time = int.Parse(array2[3]);
				string countrycode = array2[4];
				LeaderboardInfo value = new LeaderboardInfo(text, score, time, countrycode);
				LeaderboardInfoByPlayerID.Add(key, value);
			}
		}
		hasFirstRead = true;
		RefreshLeaderboard();
	}

	private void SaveData()
	{
		string text = "";
		for (int i = 0; i < LeaderboardInfoByPlayerID.Count; i++)
		{
			KeyValuePair<string, LeaderboardInfo> keyValuePair = LeaderboardInfoByPlayerID.ElementAt(i);
			text = text + keyValuePair.Key + ",";
			text = ((i != LeaderboardInfoByPlayerID.Count - 1) ? (text + keyValuePair.Value.m_Name + "," + keyValuePair.Value.m_Score + "," + keyValuePair.Value.m_Time + "," + keyValuePair.Value.CountryCode + ";") : (text + keyValuePair.Value.m_Name + "," + keyValuePair.Value.m_Score + "," + keyValuePair.Value.m_Time + "," + keyValuePair.Value.CountryCode));
		}
		PlayerPrefs.SetString("LocalLeaderboard", text);
	}

	public void TryRefresh()
	{
		RefreshLeaderboard();
	}

	private void RefreshLeaderboard()
	{
		if (hasFirstRead)
		{
			RefreshLeaderboardAction?.Invoke(obj: false);
		}
	}

	public void SavePlayerScore(int _score, int _time, string code)
	{
		if (LeaderboardInfoByPlayerID.ContainsKey(csPlayerData.PlayerID))
		{
			if (LeaderboardInfoByPlayerID[csPlayerData.PlayerID].m_Score < _score)
			{
				LeaderboardInfoByPlayerID[csPlayerData.PlayerID] = new LeaderboardInfo(csPlayerData.PlayerName, _score, _time, code);
			}
		}
		else
		{
			LeaderboardInfoByPlayerID.Add(csPlayerData.PlayerID, new LeaderboardInfo(csPlayerData.PlayerName, _score, _time, code));
		}
		SaveData();
	}

	public void SavePlayerScore_Playfab(int playerScore)
	{
		PlayFabClientAPI.UpdatePlayerStatistics(new UpdatePlayerStatisticsRequest
		{
			Statistics = new List<StatisticUpdate>
			{
				new StatisticUpdate
				{
					StatisticName = "global",
					Value = playerScore
				}
			}
		}, delegate(UpdatePlayerStatisticsResult result)
		{
			OnStatisticsUpdated(result);
		}, FailureCallback);
	}

	private void OnStatisticsUpdated(UpdatePlayerStatisticsResult updateResult)
	{
		UnityEngine.Debug.Log("Successfully submitted high score");
	}

	private void FailureCallback(PlayFabError error)
	{
		UnityEngine.Debug.LogWarning("Something went wrong with your API call. Here's some debug information:");
		UnityEngine.Debug.LogError(error.GenerateErrorReport());
	}

	public void GetLeaderboard_Playfab()
	{
		PlayFabClientAPI.GetLeaderboard(new GetLeaderboardRequest
		{
			StatisticName = "global",
			ProfileConstraints = new PlayerProfileViewConstraints
			{
				ShowDisplayName = true,
				ShowLocations = true
			}
		}, delegate(GetLeaderboardResult result)
		{
			LeaderboardInfoByPlayerID_Playfab = new Dictionary<string, LeaderboardInfo>();
			foreach (PlayerLeaderboardEntry item in result.Leaderboard)
			{
				string countrycode = "";
				if (item.Profile.Locations.Count > 0)
				{
					countrycode = item.Profile.Locations[0].CountryCode.ToString();
				}
				LeaderboardInfoByPlayerID_Playfab.Add(item.PlayFabId, new LeaderboardInfo(item.DisplayName, item.StatValue, 0, countrycode));
			}
			RefreshLeaderboardAction?.Invoke(obj: true);
		}, FailureCallback);
	}
}
public class LeaderboardInfo
{
	public string m_Name;

	public int m_Score;

	public int m_Time;

	public string CountryCode;

	public LeaderboardInfo(string _name, int _score, int _time, string _countrycode = "")
	{
		m_Name = _name;
		m_Score = _score;
		m_Time = _time;
		CountryCode = _countrycode;
	}
}
public class csLevelData : MonoBehaviour
{
	public LevelInfoList m_LevelInfoList;

	public static csLevelData instance;

	private void Awake()
	{
		if (instance == null)
		{
			instance = this;
			UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
		}
		else
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}

	public string GetDescriptionByMission(MissionDataInfo info)
	{
		switch (info._Type)
		{
		case csMissionType.Task_01:
			return csLocalizationManager.Instance.GetLocalText("TaskDesc_A_001");
		case csMissionType.Task_02:
			return string.Format(csLocalizationManager.Instance.GetLocalText("TaskDesc_A_002"), info.Parameter_1);
		case csMissionType.Task_03:
			return string.Format(csLocalizationManager.Instance.GetLocalText("TaskDesc_A_003"), info.Parameter_1);
		case csMissionType.Task_04:
			return string.Format(csLocalizationManager.Instance.GetLocalText("TaskDesc_A_004"), info.Parameter_1);
		case csMissionType.Task_05:
			return string.Format(csLocalizationManager.Instance.GetLocalText("TaskDesc_A_005"), info.Parameter_1);
		case csMissionType.Task_06:
			return string.Format(csLocalizationManager.Instance.GetLocalText("TaskDesc_A_006"), GetPreObjectString((PreObjectType)info.Parameter_1), info.Parameter_2);
		case csMissionType.Task_07:
			return string.Format(csLocalizationManager.Instance.GetLocalText("TaskDesc_A_007"), GetHorseSkillString((HorseSkill)info.Parameter_1), info.Parameter_2);
		case csMissionType.Task_08:
			return string.Format(csLocalizationManager.Instance.GetLocalText("TaskDesc_A_008"), csLocalizationManager.Instance.GetLocalText(csPlayerData.GetHorseInfo((HorseType)info.Parameter_1).Name));
		case csMissionType.Task_09:
			return string.Format(csLocalizationManager.Instance.GetLocalText("TaskDesc_A_009"), info.Parameter_1);
		case csMissionType.Task_10:
			return string.Format(csLocalizationManager.Instance.GetLocalText("TaskDesc_A_010"), info.Parameter_1);
		default:
			UnityEngine.Debug.LogError("没有相应的 csMissionType：" + info._Type);
			return "";
		}
	}

	private string GetPreObjectString(PreObjectType _type)
	{
		switch (_type)
		{
		case PreObjectType.Magnet:
			return csLocalizationManager.Instance.GetLocalText("Prop03");
		case PreObjectType.Sheild:
			return csLocalizationManager.Instance.GetLocalText("Prop02");
		case PreObjectType.RushPower:
			return csLocalizationManager.Instance.GetLocalText("Prop01");
		default:
			UnityEngine.Debug.LogError("没有相应的 PreObjectType：" + _type);
			return "";
		}
	}

	private string GetHorseSkillString(HorseSkill _type)
	{
		switch (_type)
		{
		case HorseSkill.Sprint:
			return csLocalizationManager.Instance.GetLocalText("Skill_001_A");
		case HorseSkill.Invincible:
			return csLocalizationManager.Instance.GetLocalText("Skill_002_A");
		case HorseSkill.Slow:
			return csLocalizationManager.Instance.GetLocalText("Skill_003_A");
		case HorseSkill.Strike:
			return csLocalizationManager.Instance.GetLocalText("Skill_004_A");
		case HorseSkill.Anticol:
			return csLocalizationManager.Instance.GetLocalText("Skill_005_A");
		case HorseSkill.Jump:
			return csLocalizationManager.Instance.GetLocalText("Skill_006_A");
		case HorseSkill.ShieldBuff:
			return csLocalizationManager.Instance.GetLocalText("Skill_007_A");
		case HorseSkill.Roar:
			return csLocalizationManager.Instance.GetLocalText("Skill_008_A");
		case HorseSkill.Fly:
			return csLocalizationManager.Instance.GetLocalText("Skill_009_A");
		default:
			UnityEngine.Debug.LogError("没有相应的 HorseSkill：" + _type);
			return "";
		}
	}
}
public class csLoadingSceneManager : MonoBehaviour
{
	public Image LvProgressValue;

	public float MinProgressWid = 358f;

	public float MaxProgressWid = 2048f;

	public CanvasGroup group;

	public csLoadingFade LoadFade;

	private float AimProgressWid;

	private UnityEngine.AsyncOperation loadAsync;

	public SpriteRenderer LoadImg;

	public void SetProgressValue(float percent, bool isReset = true)
	{
		if (percent > 1f)
		{
			percent = 1f;
		}
		AimProgressWid = Mathf.Lerp(MinProgressWid, MaxProgressWid, percent);
		if (isReset)
		{
			LvProgressValue.rectTransform.sizeDelta = new Vector2(AimProgressWid, 128f);
		}
	}

	private IEnumerator Start()
	{
		LoadImg.enabled = false;
		if (csGameSettings.IsLoadToGame)
		{
			loadAsync = SceneManager.LoadSceneAsync("TunnelRush");
			while (!loadAsync.isDone)
			{
				yield return null;
				SetProgressValue(loadAsync.progress);
				if (loadAsync.progress > 0.7f)
				{
					SetProgressValue(1f);
					if (group.alpha > 0f)
					{
						group.alpha = 0f;
					}
				}
			}
			yield break;
		}
		loadAsync = SceneManager.LoadSceneAsync("MainMenu");
		while (!loadAsync.isDone)
		{
			yield return null;
			SetProgressValue(loadAsync.progress);
			if (loadAsync.progress > 0.7f)
			{
				SetProgressValue(1f);
				if (group.alpha > 0f)
				{
					group.alpha = 0f;
				}
				LoadImg.transform.SetParent(csHMDIniter.instance.CurrentSetter.EyeCamT);
				LoadImg.transform.localEulerAngles = Vector3.zero;
				LoadImg.transform.localPosition = new Vector3(0f, 0f, 5f);
				LoadImg.enabled = true;
			}
		}
	}

	private void HideUI()
	{
	}
}
public class csOculusInputHandler : MonoBehaviour
{
	public static bool BackPressDown;

	private float doubleTapDelay = 0.25f;

	private float shortPressDelay = 0.25f;

	private float longPressDelay = 0.75f;

	private int downCount;

	private int upCount;

	private float initialDownTime = -1f;

	private bool waitForUp;

	private void Awake()
	{
		csGameSettings.Init();
		if (csGameSettings.Channel == ChannelType.OculusGO || csGameSettings.Channel == ChannelType.OculusQuest)
		{
			UnityEngine.Object.DontDestroyOnLoad(this);
		}
	}

	private void Update()
	{
		if (csGameSettings.Channel == ChannelType.OculusGO || csGameSettings.Channel == ChannelType.OculusQuest)
		{
			HandleBackButton();
		}
	}

	private void HandleBackButton()
	{
		switch (HandleBackButtonState())
		{
		case eBackButtonAction.SHORT_PRESS:
			BackPressDown = true;
			break;
		case eBackButtonAction.LONG_PRESS:
			BackPressDown = false;
			OVRManager.PlatformUIConfirmQuit();
			break;
		default:
			BackPressDown = false;
			break;
		}
	}

	private eBackButtonAction ResetAndSendAction(eBackButtonAction action)
	{
		downCount = 0;
		upCount = 0;
		initialDownTime = -1f;
		waitForUp = false;
		if (action == eBackButtonAction.LONG_PRESS)
		{
			waitForUp = true;
		}
		return action;
	}

	private eBackButtonAction HandleBackButtonState()
	{
		if (waitForUp)
		{
			if (Input.GetKeyDown(KeyCode.Escape) || Input.GetKey(KeyCode.Escape))
			{
				return eBackButtonAction.NONE;
			}
			waitForUp = false;
		}
		if (Input.GetKeyDown(KeyCode.Escape))
		{
			downCount++;
			if (downCount == 1)
			{
				initialDownTime = Time.realtimeSinceStartup;
			}
		}
		else if (downCount > 0)
		{
			if (Input.GetKey(KeyCode.Escape))
			{
				if (downCount <= upCount)
				{
					downCount++;
				}
				float num = Time.realtimeSinceStartup - initialDownTime;
				if (num > shortPressDelay)
				{
					_ = (num - shortPressDelay) / (longPressDelay - shortPressDelay);
				}
				if (num > longPressDelay)
				{
					return ResetAndSendAction(eBackButtonAction.LONG_PRESS);
				}
			}
			else if (initialDownTime >= 0f)
			{
				if (upCount < downCount)
				{
					upCount++;
				}
				float num2 = Time.realtimeSinceStartup - initialDownTime;
				if (num2 < doubleTapDelay)
				{
					if (downCount == 2 && upCount == 2)
					{
						return ResetAndSendAction(eBackButtonAction.DOUBLE_TAP);
					}
				}
				else if (num2 > shortPressDelay)
				{
					if (downCount == 1 && upCount == 1)
					{
						return ResetAndSendAction(eBackButtonAction.SHORT_PRESS);
					}
				}
				else if (num2 < longPressDelay)
				{
					return ResetAndSendAction(eBackButtonAction.NONE);
				}
			}
		}
		return eBackButtonAction.NONE;
	}
}
internal enum eBackButtonAction
{
	NONE,
	DOUBLE_TAP,
	SHORT_PRESS,
	LONG_PRESS
}
public class csPlatformLoginSetter : MonoBehaviour
{
	public GameObject[] WaveObjs;

	public GameObject[] PCObjs;

	public GameObject[] OCObjs;

	public GameObject[] QuestObjs;

	public GameObject[] PicoObjs;

	private void Awake()
	{
		csGameSettings.Init();
		switch (csGameSettings.Channel)
		{
		case ChannelType.OculusGO:
		{
			GameObject[] picoObjs = OCObjs;
			for (int i = 0; i < picoObjs.Length; i++)
			{
				picoObjs[i].SetActive(value: true);
			}
			break;
		}
		case ChannelType.OculusQuest:
		{
			GameObject[] picoObjs = QuestObjs;
			for (int i = 0; i < picoObjs.Length; i++)
			{
				picoObjs[i].SetActive(value: true);
			}
			break;
		}
		case ChannelType.PC:
		{
			GameObject[] picoObjs = PCObjs;
			for (int i = 0; i < picoObjs.Length; i++)
			{
				picoObjs[i].SetActive(value: true);
			}
			break;
		}
		case ChannelType.WaveVR_3Dof:
		case ChannelType.WaveVR_6Dof:
		{
			GameObject[] picoObjs = WaveObjs;
			for (int i = 0; i < picoObjs.Length; i++)
			{
				picoObjs[i].SetActive(value: true);
			}
			break;
		}
		case ChannelType.Pico6Dof:
		{
			GameObject[] picoObjs = PicoObjs;
			for (int i = 0; i < picoObjs.Length; i++)
			{
				picoObjs[i].SetActive(value: true);
			}
			break;
		}
		}
	}
}
public class csPlayerData
{
	public static UnityAction VolumeChangeAct;

	public static string PlayerCountry = "";

	public static bool HasLogin;

	private static int playerdiamond = -1;

	private static int playercoin = -1;

	private static int lastEndlessScore = -1;

	private static int bestEndlessScore = -1;

	private static float lastEndlessTime = -1f;

	private static float bestEndlessTime = -1f;

	private static int lastEndlessLevel = -1;

	private static int highestEndlessLevel = -1;

	private static bool vibrationSwitch;

	private static bool hasvibrationSwitchInit;

	private static int sensitivity = -1;

	private static int newAchievementCount = -1;

	private static Dictionary<HorseType, bool> HorseUnLockedDic = new Dictionary<HorseType, bool>();

	public static Dictionary<AheadBuff, int> BuffDataDic = new Dictionary<AheadBuff, int>();

	public static List<AheadBuff> EquipedBufflistInData = new List<AheadBuff>();

	public static List<AheadBuff> LevelBuffList = new List<AheadBuff>();

	public static List<BuffData> AheadBuffData = new List<BuffData>();

	public static List<bool> AwardUnlockList = new List<bool>();

	private static Dictionary<HorseType, csHorseInfo> HorseInfoDic = new Dictionary<HorseType, csHorseInfo>();

	public static List<HorseTypePrice> HorseTypeByPrice = new List<HorseTypePrice>();

	public const string PlayerLevelDataPath = "/PlayerLevelData.txt";

	public static Dictionary<int, PlayerLevelData> PlayerLevelDataDic = new Dictionary<int, PlayerLevelData>();

	private static bool HasInitPlayerLevelDataDic;

	private const string AchievementDataPath = "/AchievementData.txt";

	public static Dictionary<AchievementType, AchievementDataInfo> AchievementDic = new Dictionary<AchievementType, AchievementDataInfo>();

	private static bool HasInitAchievementDic;

	public static Action RefreshAchievementAction;

	public static string PlayerName
	{
		get
		{
			if (PlayerPrefs.HasKey("PlayerName"))
			{
				return PlayerPrefs.GetString("PlayerName");
			}
			return "Player";
		}
		set
		{
			PlayerPrefs.SetString("PlayerName", value);
		}
	}

	public static string PlayerID
	{
		get
		{
			if (PlayerPrefs.HasKey("PlayerID"))
			{
				return PlayerPrefs.GetString("PlayerID");
			}
			return SystemInfo.deviceUniqueIdentifier;
		}
		set
		{
			PlayerPrefs.SetString("PlayerID", value);
		}
	}

	public static int PlayerDiamond
	{
		get
		{
			if (playerdiamond < 0)
			{
				playerdiamond = PlayerPrefs.GetInt("PlayerDiamond", 0);
			}
			return playerdiamond;
		}
		set
		{
			PlayerPrefs.SetInt("PlayerDiamond", value);
			playerdiamond = value;
		}
	}

	public static int PlayerCoin
	{
		get
		{
			if (playercoin < 0)
			{
				playercoin = PlayerPrefs.GetInt("PlayerCoins", 0);
			}
			return playercoin;
		}
		set
		{
			PlayerPrefs.SetInt("PlayerCoins", value);
			playercoin = value;
		}
	}

	public static int LastEndlessScore
	{
		get
		{
			if (lastEndlessScore < 0)
			{
				lastEndlessScore = PlayerPrefs.GetInt("LastEndlessScore", 0);
			}
			return lastEndlessScore;
		}
		set
		{
			PlayerPrefs.SetInt("LastEndlessScore", value);
			lastEndlessScore = value;
		}
	}

	public static int BestEndlessScore
	{
		get
		{
			if (bestEndlessScore < 0)
			{
				bestEndlessScore = PlayerPrefs.GetInt("BestEndlessScore", 0);
			}
			return bestEndlessScore;
		}
		set
		{
			PlayerPrefs.SetInt("BestEndlessScore", value);
			bestEndlessScore = value;
		}
	}

	public static float LastEndlessTime
	{
		get
		{
			if (lastEndlessTime < 0f)
			{
				lastEndlessTime = PlayerPrefs.GetFloat("LastEndlessTime", 0f);
			}
			return lastEndlessTime;
		}
		set
		{
			PlayerPrefs.SetFloat("LastEndlessTime", value);
			lastEndlessTime = value;
		}
	}

	public static float BestEndlessTime
	{
		get
		{
			if (bestEndlessTime < 0f)
			{
				bestEndlessTime = PlayerPrefs.GetFloat("BestEndlessTime", 0f);
			}
			return bestEndlessTime;
		}
		set
		{
			PlayerPrefs.SetFloat("BestEndlessTime", value);
			bestEndlessTime = value;
		}
	}

	public static int LastEndlessLevel
	{
		get
		{
			if (lastEndlessLevel < 0)
			{
				lastEndlessLevel = PlayerPrefs.GetInt("LastEndlessLevel", 0);
			}
			return lastEndlessLevel;
		}
		set
		{
			PlayerPrefs.SetInt("LastEndlessLevel", value);
			lastEndlessLevel = value;
		}
	}

	public static int HighestEndlessLevel
	{
		get
		{
			if (highestEndlessLevel < 0)
			{
				highestEndlessLevel = PlayerPrefs.GetInt("HighestEndlessLevel", 0);
			}
			return highestEndlessLevel;
		}
		set
		{
			PlayerPrefs.SetInt("HighestEndlessLevel", value);
			highestEndlessLevel = value;
		}
	}

	public static bool VibrationSwitch
	{
		get
		{
			if (!hasvibrationSwitchInit)
			{
				vibrationSwitch = PlayerPrefs.GetInt("VibrationSwitch", 1) == 1;
				hasvibrationSwitchInit = true;
			}
			return vibrationSwitch;
		}
		set
		{
			vibrationSwitch = value;
			PlayerPrefs.SetInt("VibrationSwitch", vibrationSwitch ? 1 : 0);
		}
	}

	public static int MusicVolume
	{
		get
		{
			return PlayerPrefs.GetInt("MusicVolume", 10);
		}
		set
		{
			PlayerPrefs.SetInt("MusicVolume", value);
		}
	}

	public static int SoundFXVolume
	{
		get
		{
			return PlayerPrefs.GetInt("SoundFXVolume", 10);
		}
		set
		{
			PlayerPrefs.SetInt("SoundFXVolume", value);
		}
	}

	public static int Sensitivity
	{
		get
		{
			if (sensitivity == -1)
			{
				sensitivity = PlayerPrefs.GetInt("Sensitivity", 10);
			}
			return sensitivity;
		}
		set
		{
			sensitivity = value;
			PlayerPrefs.SetInt("Sensitivity", sensitivity);
		}
	}

	public static int NewAchievementCount
	{
		get
		{
			if (newAchievementCount == -1)
			{
				newAchievementCount = PlayerPrefs.GetInt("NewAchievementCount", 0);
			}
			return newAchievementCount;
		}
		set
		{
			newAchievementCount = value;
			PlayerPrefs.SetInt("NewAchievementCount", newAchievementCount);
		}
	}

	public static int GetHighestUnLockLevel
	{
		get
		{
			int num = 0;
			List<PlayerLevelData> list = PlayerLevelDataDic.Values.ToList();
			for (int i = 0; i < list.Count; i++)
			{
				if (list[i].isUnLock)
				{
					num++;
				}
			}
			if (num == 0)
			{
				num = 1;
			}
			return num;
		}
	}

	public static int CompeletAchievementCount
	{
		get
		{
			int num = 0;
			foreach (AchievementDataInfo value in AchievementDic.Values)
			{
				if (value.m_AchievementState != 0)
				{
					num++;
				}
			}
			return num;
		}
	}

	private static void InitHorseUnLockedInfo()
	{
		HorseUnLockedDic.Add(HorseType.Horse_Default, value: true);
		HorseUnLockedDic.Add(HorseType.Horse_1, GetUnlockInfoInPlayerPrefs(HorseType.Horse_1));
		HorseUnLockedDic.Add(HorseType.Horse_2, GetUnlockInfoInPlayerPrefs(HorseType.Horse_2));
		HorseUnLockedDic.Add(HorseType.Horse_3, GetUnlockInfoInPlayerPrefs(HorseType.Horse_3));
		HorseUnLockedDic.Add(HorseType.Horse_4, GetUnlockInfoInPlayerPrefs(HorseType.Horse_4));
		HorseUnLockedDic.Add(HorseType.Horse_5, GetUnlockInfoInPlayerPrefs(HorseType.Horse_5));
		HorseUnLockedDic.Add(HorseType.Horse_6, GetUnlockInfoInPlayerPrefs(HorseType.Horse_6));
		HorseUnLockedDic.Add(HorseType.Rhino_1, GetUnlockInfoInPlayerPrefs(HorseType.Rhino_1));
		HorseUnLockedDic.Add(HorseType.Crocodile, GetUnlockInfoInPlayerPrefs(HorseType.Crocodile));
		HorseUnLockedDic.Add(HorseType.Elephant, GetUnlockInfoInPlayerPrefs(HorseType.Elephant));
		HorseUnLockedDic.Add(HorseType.DragonBoss, GetUnlockInfoInPlayerPrefs(HorseType.DragonBoss));
	}

	public static void PackAheadBuff(AheadBuff b)
	{
		if (!EquipedBufflistInData.Contains(b))
		{
			EquipedBufflistInData.Add(b);
		}
	}

	public static void UnPackAheadBuff(AheadBuff b)
	{
		if (EquipedBufflistInData.Contains(b))
		{
			EquipedBufflistInData.Remove(b);
		}
	}

	public static void ApplyBuffListToLevel()
	{
		LevelBuffList.Clear();
		foreach (AheadBuff equipedBufflistInDatum in EquipedBufflistInData)
		{
			LevelBuffList.Add(equipedBufflistInDatum);
			OnUseAheadBuff(equipedBufflistInDatum);
		}
		foreach (AheadBuff levelBuff in LevelBuffList)
		{
			if (BuffDataDic[levelBuff] <= 0)
			{
				EquipedBufflistInData.Remove(levelBuff);
			}
		}
		WriteBuffData(BuffDataDic);
		SaveEquipBuffList();
	}

	public static void ClearLevelBuff()
	{
		LevelBuffList.Clear();
	}

	public static void InitAheadBuffData()
	{
		BuffData buffData = new BuffData();
		buffData.BuffName = AheadBuff.RushS;
		buffData.EffectValue = 10f;
		AheadBuffData.Add(buffData);
		buffData = new BuffData();
		buffData.BuffName = AheadBuff.RushM;
		buffData.EffectValue = 20f;
		AheadBuffData.Add(buffData);
		buffData = new BuffData();
		buffData.BuffName = AheadBuff.RushB;
		buffData.EffectValue = 30f;
		AheadBuffData.Add(buffData);
		buffData = new BuffData();
		buffData.BuffName = AheadBuff.ShieldS;
		buffData.EffectValue = 30f;
		AheadBuffData.Add(buffData);
		buffData = new BuffData();
		buffData.BuffName = AheadBuff.ShieldM;
		buffData.EffectValue = 60f;
		AheadBuffData.Add(buffData);
		buffData = new BuffData();
		buffData.BuffName = AheadBuff.ShieldB;
		buffData.EffectValue = 90f;
		AheadBuffData.Add(buffData);
		buffData = new BuffData();
		buffData.BuffName = AheadBuff.AddLifeS;
		buffData.EffectValue = 1f;
		AheadBuffData.Add(buffData);
		buffData = new BuffData();
		buffData.BuffName = AheadBuff.GoldBuffS;
		buffData.EffectValue = 1.1f;
		AheadBuffData.Add(buffData);
		buffData = new BuffData();
		buffData.BuffName = AheadBuff.GoldBuffM;
		buffData.EffectValue = 1.2f;
		AheadBuffData.Add(buffData);
		buffData = new BuffData();
		buffData.BuffName = AheadBuff.GoldBuffB;
		buffData.EffectValue = 1.3f;
		AheadBuffData.Add(buffData);
		buffData = new BuffData();
		buffData.BuffName = AheadBuff.ScoreBuffS;
		buffData.EffectValue = 1.05f;
		AheadBuffData.Add(buffData);
		buffData = new BuffData();
		buffData.BuffName = AheadBuff.ScoreBuffM;
		buffData.EffectValue = 1.08f;
		AheadBuffData.Add(buffData);
		buffData = new BuffData();
		buffData.BuffName = AheadBuff.ScoreBuffB;
		buffData.EffectValue = 1.1f;
		AheadBuffData.Add(buffData);
		BuffDataDic.Clear();
		string[] array = PlayerPrefs.GetString("AheadBuffData").Split(';');
		if (array.Length < Enum.GetValues(typeof(AheadBuff)).Length)
		{
			Dictionary<AheadBuff, int> dictionary = new Dictionary<AheadBuff, int>();
			foreach (AheadBuff value in Enum.GetValues(typeof(AheadBuff)))
			{
				dictionary.Add(value, 0);
			}
			WriteBuffData(dictionary);
		}
		string[] array2 = PlayerPrefs.GetString("EquipedAheadBuff", "").Split(';');
		EquipedBufflistInData.Clear();
		for (int i = 0; i < array2.Length; i++)
		{
			int result = 0;
			if (int.TryParse(array2[i], out result))
			{
				EquipedBufflistInData.Add((AheadBuff)result);
			}
		}
		array = PlayerPrefs.GetString("AheadBuffData").Split(';');
		for (int j = 0; j < array.Length; j++)
		{
			string[] array3 = array[j].Split('|');
			BuffDataDic.Add((AheadBuff)int.Parse(array3[0]), int.Parse(array3[1]));
		}
	}

	public static float GetAheadBuffValue(AheadBuff b)
	{
		return AheadBuffData.Find((BuffData x) => x.BuffName == b).EffectValue;
	}

	public static int GetAheadBuffNum(AheadBuff b)
	{
		return BuffDataDic[b];
	}

	public static void OnGetAheadBuff(AheadBuff b, int num)
	{
		BuffDataDic[b] += num;
		UnityEngine.Debug.Log("OnGet");
	}

	public static void OnUseAheadBuff(AheadBuff b, int num = 1)
	{
		BuffDataDic[b] -= num;
		if (BuffDataDic[b] <= 0)
		{
			BuffDataDic[b] = 0;
		}
	}

	public static void WriteBuffData(Dictionary<AheadBuff, int> dic)
	{
		string text = "";
		for (int i = 0; i < dic.Count; i++)
		{
			AheadBuff aheadBuff = dic.Keys.ToArray()[i];
			text = text + (int)aheadBuff + "|" + dic[aheadBuff];
			if (i < dic.Count - 1)
			{
				text += ";";
			}
		}
		PlayerPrefs.SetString("AheadBuffData", text);
	}

	public static void SaveEquipBuffList()
	{
		string text = "";
		for (int i = 0; i < EquipedBufflistInData.Count; i++)
		{
			AheadBuff aheadBuff = EquipedBufflistInData[i];
			text += (int)aheadBuff;
			if (i < EquipedBufflistInData.Count - 1)
			{
				text += ";";
			}
		}
		PlayerPrefs.SetString("EquipedAheadBuff", text);
	}

	public static void InitPlayerLevelAwardList()
	{
		string[] array = PlayerPrefs.GetString("AwardUnlockData").Split(';');
		if (array.Length < 15)
		{
			for (int i = 0; i < 15; i++)
			{
				AwardUnlockList.Add(item: false);
			}
			SaveAwardUnlockData();
		}
		array = PlayerPrefs.GetString("AwardUnlockData").Split(';');
		for (int j = 0; j < array.Length; j++)
		{
			AwardUnlockList.Add(array[j] == "1");
		}
	}

	public static void SaveAwardUnlockData()
	{
		string text = "";
		for (int i = 0; i < AwardUnlockList.Count; i++)
		{
			text += (AwardUnlockList[i] ? "1" : "0");
			if (i < AwardUnlockList.Count - 1)
			{
				text += ";";
			}
		}
		PlayerPrefs.SetString("AwardUnlockData", text);
	}

	private static bool GetUnlockInfoInPlayerPrefs(HorseType _type)
	{
		return PlayerPrefs.GetInt(_type.ToString(), 0) > 0;
	}

	public static int GetHorseBasicLevelInPlayerPrefs(HorseType _type)
	{
		return PlayerPrefs.GetInt(_type.ToString() + "_BasicLevel", 0);
	}

	public static void SetHorseBasicLevelInPlayerPrefs(HorseType _type, int lv)
	{
		PlayerPrefs.SetInt(_type.ToString() + "_BasicLevel", lv);
	}

	public static int GetHorseSpecialLevelInPlayerPrefs(HorseType _type)
	{
		return PlayerPrefs.GetInt(_type.ToString() + "_SpecialLevel", 0);
	}

	public static void SetHorseSpecialLevelInPlayerPrefs(HorseType _type, int lv)
	{
		PlayerPrefs.SetInt(_type.ToString() + "_SpecialLevel", lv);
	}

	public static int GetCurAwardStarNum()
	{
		return PlayerPrefs.GetInt("AwardStarNum");
	}

	public static void SetCurAwardStarNum(int n)
	{
		PlayerPrefs.SetInt("AwardStarNum", n);
	}

	public static bool GetHorseUnlockInfoByType(HorseType _type)
	{
		if (HorseUnLockedDic.Count == 0)
		{
			InitHorseUnLockedInfo();
		}
		return HorseUnLockedDic[_type];
	}

	public static void SetHorseUnlockedByType(HorseType _type)
	{
		HorseUnLockedDic[_type] = true;
		PlayerPrefs.SetInt(_type.ToString(), 1);
		AddAchievementSchedule_Horse(1);
		switch (_type)
		{
		case HorseType.Crocodile:
			AddAchievementSchedule(AchievementType.Target_022, 1);
			break;
		case HorseType.Rhino_1:
			AddAchievementSchedule(AchievementType.Target_023, 1);
			break;
		case HorseType.Elephant:
			AddAchievementSchedule(AchievementType.Target_024, 1);
			break;
		case HorseType.DragonBoss:
			AddAchievementSchedule(AchievementType.Target_025, 1);
			break;
		}
	}

	private static void InitHorseInfo()
	{
		List<int> list = new List<int>();
		List<int> list2 = new List<int>();
		list.Add(400);
		list.Add(800);
		list.Add(1200);
		list.Add(1600);
		list.Add(2000);
		list2.Add(0);
		list2.Add(0);
		list2.Add(0);
		list2.Add(0);
		list2.Add(0);
		csHorseInfo value = new csHorseInfo("Horse_001_A", 1, 30f, 3f, 0, "", "Horse_001_B", _IsGemPrice: false, 0, list, list2);
		HorseInfoDic.Add(HorseType.Horse_Default, value);
		HorseTypeByPrice.Add(new HorseTypePrice(HorseType.Horse_Default, HorseInfoDic[HorseType.Horse_Default].UnLockCoin));
		list = new List<int>();
		list2 = new List<int>();
		list.Add(1600);
		list.Add(3200);
		list.Add(4800);
		list.Add(6400);
		list.Add(8000);
		list2.Add(-6);
		list2.Add(-12);
		list2.Add(-18);
		list2.Add(-24);
		list2.Add(-30);
		value = new csHorseInfo("Horse_002_A", 5, 65f, 6f, 1, "", "Horse_002_B", _IsGemPrice: false, 12000, list, list2);
		HorseInfoDic.Add(HorseType.Horse_1, value);
		HorseTypeByPrice.Add(new HorseTypePrice(HorseType.Horse_1, HorseInfoDic[HorseType.Horse_1].UnLockCoin));
		list = new List<int>();
		list2 = new List<int>();
		list.Add(1600);
		list.Add(3200);
		list.Add(4800);
		list.Add(6400);
		list.Add(8000);
		list2.Add(-6);
		list2.Add(-12);
		list2.Add(-18);
		list2.Add(-24);
		list2.Add(-30);
		value = new csHorseInfo("Horse_003_A", 5, 60f, 5f, 2, "", "Horse_003_B", _IsGemPrice: false, 12000, list, list2);
		HorseInfoDic.Add(HorseType.Horse_2, value);
		HorseTypeByPrice.Add(new HorseTypePrice(HorseType.Horse_2, HorseInfoDic[HorseType.Horse_2].UnLockCoin));
		list = new List<int>();
		list2 = new List<int>();
		list.Add(1000);
		list.Add(2100);
		list.Add(3100);
		list.Add(4200);
		list.Add(5200);
		list2.Add(-4);
		list2.Add(-8);
		list2.Add(-12);
		list2.Add(-16);
		list2.Add(-20);
		value = new csHorseInfo("Horse_004_A", 4, 58f, 5f, 3, "", "Horse_004_B", _IsGemPrice: false, 8000, list, list2);
		HorseInfoDic.Add(HorseType.Horse_3, value);
		HorseTypeByPrice.Add(new HorseTypePrice(HorseType.Horse_3, HorseInfoDic[HorseType.Horse_3].UnLockCoin));
		list = new List<int>();
		list2 = new List<int>();
		list.Add(800);
		list.Add(1600);
		list.Add(2400);
		list.Add(3200);
		list.Add(4000);
		list2.Add(0);
		list2.Add(0);
		list2.Add(0);
		list2.Add(0);
		list2.Add(0);
		value = new csHorseInfo("Horse_005_A", 3, 40f, 4f, 4, "", "Horse_005_B", _IsGemPrice: false, 5000, list, list2);
		HorseInfoDic.Add(HorseType.Horse_4, value);
		HorseTypeByPrice.Add(new HorseTypePrice(HorseType.Horse_4, HorseInfoDic[HorseType.Horse_4].UnLockCoin));
		list = new List<int>();
		list2 = new List<int>();
		list.Add(1000);
		list.Add(2100);
		list.Add(3100);
		list.Add(4200);
		list.Add(5200);
		list2.Add(-6);
		list2.Add(-12);
		list2.Add(-18);
		list2.Add(-24);
		list2.Add(-30);
		value = new csHorseInfo("Horse_006_A", 4, 50f, 5f, 5, "", "Horse_006_B", _IsGemPrice: false, 8000, list, list2);
		HorseInfoDic.Add(HorseType.Horse_5, value);
		HorseTypeByPrice.Add(new HorseTypePrice(HorseType.Horse_5, HorseInfoDic[HorseType.Horse_5].UnLockCoin));
		list = new List<int>();
		list2 = new List<int>();
		list.Add(1600);
		list.Add(3200);
		list.Add(4800);
		list.Add(6400);
		list.Add(8000);
		list2.Add(-6);
		list2.Add(-12);
		list2.Add(-18);
		list2.Add(-24);
		list2.Add(-30);
		value = new csHorseInfo("Horse_007_A", 4, 55f, 6f, 6, "", "Horse_007_B", _IsGemPrice: false, 8000, list, list2);
		HorseInfoDic.Add(HorseType.Horse_6, value);
		HorseTypeByPrice.Add(new HorseTypePrice(HorseType.Horse_6, HorseInfoDic[HorseType.Horse_6].UnLockCoin));
		list = new List<int>();
		list2 = new List<int>();
		list.Add(2000);
		list.Add(4000);
		list.Add(6000);
		list.Add(8000);
		list.Add(10000);
		list2.Add(-6);
		list2.Add(-12);
		list2.Add(-18);
		list2.Add(-24);
		list2.Add(-30);
		value = new csHorseInfo("Horse_008_A", 6, 50f, 8f, 7, "", "Horse_008_B", _IsGemPrice: false, 18000, list, list2);
		HorseInfoDic.Add(HorseType.Rhino_1, value);
		HorseTypeByPrice.Add(new HorseTypePrice(HorseType.Rhino_1, HorseInfoDic[HorseType.Rhino_1].UnLockCoin));
		list = new List<int>();
		list2 = new List<int>();
		list.Add(2000);
		list.Add(4000);
		list.Add(6000);
		list.Add(8000);
		list.Add(10000);
		list2.Add(-6);
		list2.Add(-12);
		list2.Add(-18);
		list2.Add(-24);
		list2.Add(-30);
		value = new csHorseInfo("Horse_009_A", 6, 50f, 8f, 7, "", "Horse_009_B", _IsGemPrice: false, 18000, list, list2);
		HorseInfoDic.Add(HorseType.Crocodile, value);
		HorseTypeByPrice.Add(new HorseTypePrice(HorseType.Crocodile, HorseInfoDic[HorseType.Crocodile].UnLockCoin));
		list = new List<int>();
		list2 = new List<int>();
		list.Add(2400);
		list.Add(4800);
		list.Add(7200);
		list.Add(9600);
		list.Add(12000);
		list2.Add(-8);
		list2.Add(-16);
		list2.Add(-24);
		list2.Add(-32);
		list2.Add(-40);
		value = new csHorseInfo("Horse_010_A", 7, 50f, 8f, 7, "", "Horse_010_B", _IsGemPrice: false, 25000, list, list2);
		HorseInfoDic.Add(HorseType.Elephant, value);
		HorseTypeByPrice.Add(new HorseTypePrice(HorseType.Elephant, HorseInfoDic[HorseType.Elephant].UnLockCoin));
		list = new List<int>();
		list2 = new List<int>();
		list.Add(2800);
		list.Add(5600);
		list.Add(8400);
		list.Add(11200);
		list.Add(14000);
		list2.Add(-10);
		list2.Add(-20);
		list2.Add(-30);
		list2.Add(-40);
		list2.Add(-50);
		value = new csHorseInfo("Horse_011_A", 8, 50f, 8f, 7, "", "Horse_011_B", _IsGemPrice: false, 30000, list, list2);
		HorseInfoDic.Add(HorseType.DragonBoss, value);
		HorseTypeByPrice.Add(new HorseTypePrice(HorseType.DragonBoss, HorseInfoDic[HorseType.DragonBoss].UnLockCoin));
		HorseTypeByPrice.Sort(delegate(HorseTypePrice left, HorseTypePrice right)
		{
			if (left.m_Price > right.m_Price)
			{
				return 1;
			}
			return (left.m_Price != right.m_Price) ? (-1) : 0;
		});
	}

	public static csHorseInfo GetHorseInfo(HorseType _type)
	{
		if (HorseInfoDic.Count == 0)
		{
			InitHorseInfo();
		}
		return HorseInfoDic[_type];
	}

	public static void InitPlayerLevelDataDic()
	{
		if (!HasInitPlayerLevelDataDic)
		{
			HasInitPlayerLevelDataDic = true;
			string text = "";
			text = ((!File.Exists(UnityEngine.Application.persistentDataPath + "/PlayerLevelData.txt")) ? (Resources.Load("Profile/PlayerLevelData") as TextAsset).text : File.ReadAllText(UnityEngine.Application.persistentDataPath + "/PlayerLevelData.txt"));
			PlayerLevelDataList playerLevelDataList = JsonUtility.FromJson<PlayerLevelDataList>(text);
			PlayerLevelDataDic = new Dictionary<int, PlayerLevelData>();
			for (int i = 0; i < playerLevelDataList.m_PlayerLevelDataList.Count; i++)
			{
				PlayerLevelDataDic.Add(playerLevelDataList.m_PlayerLevelDataList[i].Level, playerLevelDataList.m_PlayerLevelDataList[i]);
			}
		}
	}

	public static void SavePlayerLevelDataDic()
	{
		PlayerLevelDataList obj = new PlayerLevelDataList(PlayerLevelDataDic.Values.ToList());
		StreamWriter streamWriter = ((!File.Exists(UnityEngine.Application.persistentDataPath + "/PlayerLevelData.txt")) ? File.CreateText(UnityEngine.Application.persistentDataPath + "/PlayerLevelData.txt") : new StreamWriter(UnityEngine.Application.persistentDataPath + "/PlayerLevelData.txt", append: false));
		streamWriter.Write(JsonUtility.ToJson(obj));
		streamWriter.Close();
		streamWriter.Dispose();
	}

	public static int GetStarsNum()
	{
		List<PlayerLevelData> list = PlayerLevelDataDic.Values.ToList();
		int num = 0;
		for (int i = 0; i < list.Count; i++)
		{
			num += list[i].StarsNum;
		}
		return num;
	}

	public static void InitAchievementDic()
	{
		if (HasInitAchievementDic)
		{
			return;
		}
		HasInitAchievementDic = true;
		string text = "";
		text = ((!File.Exists(UnityEngine.Application.persistentDataPath + "/AchievementData.txt")) ? (Resources.Load("Profile/AchievementData") as TextAsset).text : File.ReadAllText(UnityEngine.Application.persistentDataPath + "/AchievementData.txt"));
		AchievementDataList achievementDataList = JsonUtility.FromJson<AchievementDataList>(text);
		AchievementDic = new Dictionary<AchievementType, AchievementDataInfo>();
		for (int i = 0; i < achievementDataList.m_AchievementDataList.Count; i++)
		{
			if (achievementDataList.m_AchievementDataList[i].m_AchievementType != AchievementType.Target_021)
			{
				AchievementDic.Add(achievementDataList.m_AchievementDataList[i].m_AchievementType, achievementDataList.m_AchievementDataList[i]);
			}
		}
	}

	public static int GetFirstUnResivedAchievement()
	{
		int num = -1;
		foreach (AchievementDataInfo value in AchievementDic.Values)
		{
			num++;
			if (value.m_AchievementState == AchievementState.UnReceived)
			{
				return num;
			}
		}
		return -1;
	}

	public static void SaveAchievementDic()
	{
		AchievementDataList obj = new AchievementDataList(AchievementDic.Values.ToList());
		StreamWriter streamWriter = ((!File.Exists(UnityEngine.Application.persistentDataPath + "/AchievementData.txt")) ? File.CreateText(UnityEngine.Application.persistentDataPath + "/AchievementData.txt") : new StreamWriter(UnityEngine.Application.persistentDataPath + "/AchievementData.txt", append: false));
		streamWriter.Write(JsonUtility.ToJson(obj));
		streamWriter.Close();
		streamWriter.Dispose();
		RefreshAchievementAction?.Invoke();
	}

	public static void AddAchievementSchedule_Coin(int count, bool save = true)
	{
		AddAchievementSchedule(AchievementType.Target_001, count, save: false);
		AddAchievementSchedule(AchievementType.Target_002, count, save: false);
		AddAchievementSchedule(AchievementType.Target_003, count, save: false);
		AddAchievementSchedule(AchievementType.Target_004, count, save);
	}

	public static void AddAchievementSchedule_Dis(int count, bool save = true)
	{
		AddAchievementSchedule(AchievementType.Target_005, count, save: false);
		AddAchievementSchedule(AchievementType.Target_006, count, save: false);
		AddAchievementSchedule(AchievementType.Target_007, count, save: false);
		AddAchievementSchedule(AchievementType.Target_008, count, save);
	}

	public static void AddAchievementSchedule_Skill(int count, bool save = true)
	{
		AddAchievementSchedule(AchievementType.Target_009, count, save: false);
		AddAchievementSchedule(AchievementType.Target_010, count, save: false);
		AddAchievementSchedule(AchievementType.Target_011, count, save: false);
		AddAchievementSchedule(AchievementType.Target_012, count, save);
	}

	public static void AddAchievementSchedule_HitWall(int count, bool save = true)
	{
		AddAchievementSchedule(AchievementType.Target_013, count, save: false);
		AddAchievementSchedule(AchievementType.Target_014, count, save: false);
		AddAchievementSchedule(AchievementType.Target_015, count, save: false);
		AddAchievementSchedule(AchievementType.Target_016, count, save);
	}

	public static void AddAchievementSchedule_CrashWall(int count, bool save = true)
	{
		AddAchievementSchedule(AchievementType.Target_017, count, save: false);
		AddAchievementSchedule(AchievementType.Target_018, count, save: false);
		AddAchievementSchedule(AchievementType.Target_019, count, save: false);
		AddAchievementSchedule(AchievementType.Target_020, count, save);
	}

	public static void SetAchievementSchedule_MaxEndlessLevel(int count, bool save = true)
	{
		SetAchievementSchedule(AchievementType.Target_026, count, save: false);
		SetAchievementSchedule(AchievementType.Target_027, count, save: false);
		SetAchievementSchedule(AchievementType.Target_028, count, save: false);
		SetAchievementSchedule(AchievementType.Target_029, count, save);
	}

	public static void SetAchievementSchedule_MaxScore(int count, bool save = true)
	{
		SetAchievementSchedule(AchievementType.Target_030, count, save: false);
		SetAchievementSchedule(AchievementType.Target_031, count, save: false);
		SetAchievementSchedule(AchievementType.Target_032, count, save: false);
		SetAchievementSchedule(AchievementType.Target_033, count, save);
	}

	public static void SetAchievementSchedule_Stars(int count, bool save = true)
	{
		SetAchievementSchedule(AchievementType.Target_034, count, save: false);
		SetAchievementSchedule(AchievementType.Target_035, count, save: false);
		SetAchievementSchedule(AchievementType.Target_036, count, save: false);
		SetAchievementSchedule(AchievementType.Target_037, count, save);
	}

	public static void AddAchievementSchedule_DropDown(int count, bool save = true)
	{
		AddAchievementSchedule(AchievementType.Target_038, count, save: false);
		AddAchievementSchedule(AchievementType.Target_039, count, save: false);
		AddAchievementSchedule(AchievementType.Target_040, count, save: false);
		AddAchievementSchedule(AchievementType.Target_041, count, save);
	}

	public static void AddAchievementSchedule_Prop(int count, bool save = true)
	{
		AddAchievementSchedule(AchievementType.Target_042, count, save: false);
		AddAchievementSchedule(AchievementType.Target_043, count, save: false);
		AddAchievementSchedule(AchievementType.Target_044, count, save: false);
		AddAchievementSchedule(AchievementType.Target_045, count, save);
	}

	public static void AddAchievementSchedule_Horse(int count, bool save = true)
	{
		AddAchievementSchedule(AchievementType.Target_046, count, save: false);
		AddAchievementSchedule(AchievementType.Target_047, count, save: false);
		AddAchievementSchedule(AchievementType.Target_048, count, save: false);
		AddAchievementSchedule(AchievementType.Target_049, count, save);
	}

	public static void AddAchievementSchedule(AchievementType _type, int _value, bool save = true)
	{
		if (!AchievementDic.ContainsKey(_type) || AchievementDic[_type].m_AchievementState != 0)
		{
			return;
		}
		AchievementDic[_type].CurrentValue += _value;
		if (AchievementDic[_type].CurrentValue >= AchievementDic[_type].MaxValue)
		{
			AchievementDic[_type].CurrentValue = AchievementDic[_type].MaxValue;
			AchievementDic[_type].m_AchievementState = AchievementState.UnReceived;
			AchievementDic[_type].CompleteTime = DateTime.Now.Ticks.ToString();
			NewAchievementCount++;
			if ((bool)GameManager.instance)
			{
				GameManager.instance.TempAchievementList.Add(_type);
			}
		}
		if (save)
		{
			SaveAchievementDic();
		}
	}

	public static void SetAchievementSchedule(AchievementType _type, int _value, bool save = true)
	{
		if (!AchievementDic.ContainsKey(_type) || AchievementDic[_type].m_AchievementState != 0)
		{
			return;
		}
		AchievementDic[_type].CurrentValue = _value;
		if (AchievementDic[_type].CurrentValue >= AchievementDic[_type].MaxValue)
		{
			AchievementDic[_type].CurrentValue = AchievementDic[_type].MaxValue;
			AchievementDic[_type].m_AchievementState = AchievementState.UnReceived;
			AchievementDic[_type].CompleteTime = DateTime.Now.Ticks.ToString();
			NewAchievementCount++;
			if ((bool)GameManager.instance)
			{
				GameManager.instance.TempAchievementList.Add(_type);
			}
		}
		if (save)
		{
			SaveAchievementDic();
		}
	}

	public static void EditorCreateAchievementData()
	{
	}

	public static void EditorCreatePlayerLevelData()
	{
	}
}
public enum XRDeviceType
{
	Unknow,
	Oculus,
	Vive,
	Focus
}
public class csPlayfab : MonoBehaviour
{
	public static XRDeviceType CurrentDevice;

	public GameObject target;

	public static csPlayfab instance;

	private LoginResult SuccesLoginResult;

	public static Action<bool, string> ChangeNameCallBack;

	private void Awake()
	{
		if (instance == null)
		{
			instance = this;
		}
		if (XRDevice.model.Contains("Vive") || XRDevice.model.Contains("VIVE_Pro"))
		{
			CurrentDevice = XRDeviceType.Vive;
		}
		else if (XRDevice.model.Contains("Oculus") || XRDevice.model.Contains("quest") || XRDevice.model.Contains("Quest"))
		{
			CurrentDevice = XRDeviceType.Oculus;
		}
		else if (XRDevice.model.Contains("Focus") || XRDevice.model.Contains("focus"))
		{
			CurrentDevice = XRDeviceType.Focus;
		}
		else
		{
			CurrentDevice = XRDeviceType.Unknow;
		}
	}

	private void Start()
	{
		Login();
	}

	private void Login()
	{
		if (string.IsNullOrEmpty(PlayFabSettings.staticSettings.TitleId))
		{
			PlayFabSettings.staticSettings.TitleId = "7B2CA";
		}
		PlayFabClientAPI.LoginWithCustomID(new LoginWithCustomIDRequest
		{
			CustomId = string.Concat(CurrentDevice, SystemInfo.deviceUniqueIdentifier),
			CreateAccount = true,
			InfoRequestParameters = new GetPlayerCombinedInfoRequestParams
			{
				GetPlayerProfile = true,
				ProfileConstraints = new PlayerProfileViewConstraints
				{
					ShowLocations = true,
					ShowDisplayName = true
				}
			}
		}, OnLoginSuccess, OnLoginFailure);
	}

	private void OnLoginSuccess(LoginResult result)
	{
		csPlayerData.PlayerID = result.PlayFabId;
		SuccesLoginResult = result;
		csPlayerData.HasLogin = true;
		if (result.NewlyCreated)
		{
			string text = string.Concat(CurrentDevice, SystemInfo.deviceUniqueIdentifier);
			PlayFabClientAPI.UpdateUserTitleDisplayName(new UpdateUserTitleDisplayNameRequest
			{
				DisplayName = text.Substring(0, 20)
			}, FirstSetNameResult, FirestSetNameError);
			return;
		}
		PlayFabClientAPI.GetPlayerProfile(new GetPlayerProfileRequest
		{
			PlayFabId = SuccesLoginResult.PlayFabId
		}, OnGetProfile, delegate
		{
			SceneManager.LoadScene(0);
		});
	}

	private void OnGetProfile(GetPlayerProfileResult r)
	{
		if (string.IsNullOrEmpty(r.PlayerProfile.DisplayName))
		{
			string text = string.Concat(CurrentDevice, SystemInfo.deviceUniqueIdentifier);
			PlayFabClientAPI.UpdateUserTitleDisplayName(new UpdateUserTitleDisplayNameRequest
			{
				DisplayName = text.Substring(0, 20)
			}, FirstSetNameResult, FirestSetNameError);
			return;
		}
		csPlayerData.PlayerCountry = SuccesLoginResult.InfoResultPayload.PlayerProfile.Locations[0].CountryCode.ToString();
		if (!string.IsNullOrEmpty(SuccesLoginResult.InfoResultPayload.PlayerProfile.DisplayName.ToString()))
		{
			csPlayerData.PlayerName = SuccesLoginResult.InfoResultPayload.PlayerProfile.DisplayName.ToString();
		}
		StartCoroutine(StartToLoad());
	}

	private IEnumerator StartToLoad()
	{
		UnityEngine.AsyncOperation loadAsync = SceneManager.LoadSceneAsync(1);
		while (!loadAsync.isDone)
		{
			yield return null;
			if (loadAsync.progress > 0.9f)
			{
				target.SetActive(value: false);
			}
		}
	}

	public void GetPlayerLocation()
	{
		PlayFabClientAPI.GetPlayerProfile(new GetPlayerProfileRequest
		{
			ProfileConstraints = new PlayerProfileViewConstraints
			{
				ShowLocations = true
			}
		}, GetPlayerLocationResult, GetPlayerLocationFailure);
	}

	private void GetPlayerLocationResult(GetPlayerProfileResult result)
	{
		csPlayerData.PlayerCountry = result.PlayerProfile.Locations[0].CountryCode.ToString();
	}

	private void GetPlayerLocationFailure(PlayFabError error)
	{
		UnityEngine.Debug.LogWarning("Something went wrong with your first API call.  :(");
		UnityEngine.Debug.LogError("Here's some debug information:");
		UnityEngine.Debug.LogError(error.GenerateErrorReport());
	}

	private void OnLoginFailure(PlayFabError error)
	{
		UnityEngine.Debug.LogWarning("Something went wrong with your first API call.  :(");
		UnityEngine.Debug.LogError("Here's some debug information:");
		UnityEngine.Debug.LogError(error.GenerateErrorReport());
		SceneManager.LoadScene(1);
	}

	private void FirstSetNameResult(UpdateUserTitleDisplayNameResult result)
	{
		csPlayerData.PlayerName = result.DisplayName;
		SceneManager.LoadScene(1);
	}

	private void SetPlayerCountryCode(GetPlayerProfileResult r)
	{
		csPlayerData.PlayerCountry = r.PlayerProfile.Locations[0].CountryCode.ToString();
		SceneManager.LoadScene(1);
	}

	private void FirestSetNameError(PlayFabError error)
	{
		UnityEngine.Debug.LogWarning("Something went wrong with your first API call.  :(");
		UnityEngine.Debug.LogError("Here's some debug information:");
		UnityEngine.Debug.LogError(error.GenerateErrorReport());
		SceneManager.LoadScene(1);
	}

	public void ChangeNameIngame(string name)
	{
		PlayFabClientAPI.UpdateUserTitleDisplayName(new UpdateUserTitleDisplayNameRequest
		{
			DisplayName = name
		}, IngameSetNameResult, IngameSetNameError);
	}

	private void IngameSetNameResult(UpdateUserTitleDisplayNameResult result)
	{
		csPlayerData.PlayerName = result.DisplayName;
		ChangeNameCallBack(arg1: true, "");
	}

	private void IngameSetNameError(PlayFabError error)
	{
		UnityEngine.Debug.LogError(error.GenerateErrorReport());
		Action<bool, string> changeNameCallBack = ChangeNameCallBack;
		int error2 = (int)error.Error;
		changeNameCallBack(arg1: false, error2.ToString());
	}
}
public class csQueSetter : MonoBehaviour
{
	public Renderer HandR;

	private void OnEnable()
	{
		HandR.sharedMaterial.renderQueue = 3006;
	}
}
public class csSwrodCollider : MonoBehaviour
{
	public csWeaponHand hand;

	private void OnTriggerEnter(Collider other)
	{
		csMosterBase component = other.GetComponent<csMosterBase>();
		if ((bool)component)
		{
			component.Recycle(base.transform);
			hand.controller.TriggerHapticPulse(1500);
		}
	}
}
public class csWeaponHand : MonoBehaviour
{
	public GameObject WeaponTest;

	public Transform HandTrans;

	public Vector3 HoldWeaponRotation;

	public csControllerForSteamVR controller;

	private Quaternion InitLocalRotation;

	public bool showWeapon;

	private void Start()
	{
		if (csGameSettings.WeaponMode)
		{
			InitLocalRotation = HandTrans.localRotation;
			controller = GetComponent<csControllerForSteamVR>();
		}
		WeaponTest.gameObject.SetActive(value: false);
	}

	private void Update()
	{
		if (csGameSettings.WeaponMode && (bool)GameManager.instance && GameManager.CurrentState == GameManager.GameState.Playing)
		{
			if (controller.GetTriggerPress())
			{
				ShowWeapon(show: true);
			}
			else
			{
				ShowWeapon(show: false);
			}
		}
	}

	private void ShowWeapon(bool show)
	{
		showWeapon = show;
		if (showWeapon)
		{
			HandTrans.localRotation = Quaternion.Euler(HoldWeaponRotation);
		}
		else
		{
			HandTrans.localRotation = InitLocalRotation;
		}
		WeaponTest.gameObject.SetActive(showWeapon);
	}
}
public class AppEntitlementCheck : MonoBehaviour
{
	public static AppEntitlementCheck m_instance;

	private void Awake()
	{
		csGameSettings.Init();
		if (csGameSettings.Channel == ChannelType.OculusGO && m_instance == null)
		{
			m_instance = this;
			UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
		}
		if (csGameSettings.Channel == ChannelType.OculusQuest && m_instance == null)
		{
			m_instance = this;
			UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
		}
	}

	private void Start()
	{
		if (csGameSettings.Channel == ChannelType.OculusGO)
		{
			try
			{
				if (!Core.IsInitialized())
				{
					Core.AsyncInitialize("2632698510118193");
				}
				checkEntitlement();
			}
			catch (UnityException)
			{
				if (csGameSettings.NeedDRM)
				{
					UnityEngine.Application.Quit();
				}
			}
		}
		if (csGameSettings.Channel != ChannelType.OculusQuest)
		{
			return;
		}
		try
		{
			if (!Core.IsInitialized())
			{
				Core.AsyncInitialize("4363910233635475");
			}
			checkEntitlement();
		}
		catch (UnityException)
		{
			if (csGameSettings.NeedDRM)
			{
				UnityEngine.Application.Quit();
			}
		}
	}

	private void checkEntitlement()
	{
		Entitlements.IsUserEntitledToApplication().OnComplete(getEntitlementCallback);
	}

	private void getEntitlementCallback(Oculus.Platform.Message msg)
	{
		if (msg.IsError && csGameSettings.NeedDRM)
		{
			UnityEngine.Application.Quit();
		}
	}
}
public class PlayFabLogin : MonoBehaviour
{
	public void Start()
	{
	}

	private void Login()
	{
		if (string.IsNullOrEmpty(PlayFabSettings.staticSettings.TitleId))
		{
			PlayFabSettings.staticSettings.TitleId = "7B2CA";
		}
		PlayFabClientAPI.LoginWithCustomID(new LoginWithCustomIDRequest
		{
			CustomId = SystemInfo.deviceUniqueIdentifier,
			CreateAccount = true
		}, OnLoginSuccess, OnLoginFailure);
	}

	private void OnLoginSuccess(LoginResult result)
	{
		UnityEngine.Debug.Log("Congratulations, you made your first successful API call!");
	}

	private void OnLoginFailure(PlayFabError error)
	{
		UnityEngine.Debug.LogWarning("Something went wrong with your first API call.  :(");
		UnityEngine.Debug.LogError("Here's some debug information:");
		UnityEngine.Debug.LogError(error.GenerateErrorReport());
	}

	public void SubmitScore(int playerScore)
	{
		PlayFabClientAPI.UpdatePlayerStatistics(new UpdatePlayerStatisticsRequest
		{
			Statistics = new List<StatisticUpdate>
			{
				new StatisticUpdate
				{
					StatisticName = "global",
					Value = playerScore
				}
			}
		}, delegate(UpdatePlayerStatisticsResult result)
		{
			OnStatisticsUpdated(result);
		}, FailureCallback);
	}

	private void OnStatisticsUpdated(UpdatePlayerStatisticsResult updateResult)
	{
		UnityEngine.Debug.Log("Successfully submitted high score");
	}

	private void FailureCallback(PlayFabError error)
	{
		UnityEngine.Debug.LogWarning("Something went wrong with your API call. Here's some debug information:");
		UnityEngine.Debug.LogError(error.GenerateErrorReport());
	}

	private void GetLeaderboard()
	{
		PlayFabClientAPI.GetLeaderboard(new GetLeaderboardRequest
		{
			StatisticName = "global",
			ProfileConstraints = new PlayerProfileViewConstraints
			{
				ShowDisplayName = true,
				ShowLocations = true
			}
		}, delegate(GetLeaderboardResult result)
		{
			UnityEngine.Debug.Log("Leaderboard version: " + result.Version);
			foreach (PlayerLeaderboardEntry item in result.Leaderboard)
			{
				UnityEngine.Debug.Log(item.Position);
				UnityEngine.Debug.Log(string.Concat(item.PlayFabId + " ", item.Profile.Locations, item.DisplayName));
				if (item.Profile.Locations != null)
				{
					UnityEngine.Debug.LogError(item.Profile.Locations.Count);
					for (int i = 0; i < item.Profile.Locations.Count; i++)
					{
						UnityEngine.Debug.LogError(item.Profile.Locations[i].CountryCode);
					}
				}
			}
		}, FailureCallback);
	}

	private void OnGUI()
	{
		if (GUILayout.Button("Login"))
		{
			Login();
		}
		if (GUILayout.Button("UploadScore"))
		{
			SubmitScore(3000);
		}
		if (GUILayout.Button("GetLeaderboardc"))
		{
			GetLeaderboard();
		}
	}
}
public class csAbilityPopHint : MonoBehaviour
{
	public CanvasGroup thisCG;

	public TextMeshProUGUI DesTxt;

	public TextMeshProUGUI TitleTxt;

	private DG.Tweening.Tween tweener;

	private void Start()
	{
		thisCG.alpha = 0f;
	}

	public void SetAbilityHint(Sprite s, string title, string des, int lv)
	{
		csLocalizationManager.Instance.CheckTextFontType(TitleTxt);
		csLocalizationManager.Instance.CheckTextFontType(DesTxt);
		TitleTxt.text = title;
		DesTxt.text = des;
	}

	public void PopShowHint(bool isShow)
	{
		if (tweener != null && !tweener.IsComplete())
		{
			tweener.Kill();
		}
		if (isShow)
		{
			tweener = thisCG.DOFade(1f, 0.5f);
		}
		else
		{
			tweener = thisCG.DOFade(0f, 0.5f);
		}
	}
}
public class csAchievementItem : MonoBehaviour
{
	public AchievementType m_AchievementType;

	public TextMeshProUGUI TitleText;

	public TextMeshProUGUI DescriptionText;

	public Image AchievementIcon;

	public Image Slider;

	public Image Img_CanAward;

	public Image AwardIcon;

	public TextMeshProUGUI AwardCount;

	public Button GetAwardBtn;

	public DOTweenAnimation btnAnimator;

	public TextMeshProUGUI StateText;

	public TextMeshProUGUI CompeletTime;

	public TextMeshProUGUI ProgressText_Current;

	public TextMeshProUGUI ProgressText_Max;

	public Sprite CoinSprite;

	public Sprite DiamondSprite;

	public csBtnClipPlayer clipPlayer;

	public csAchievementPanel AchievePanel;

	public void InitData(AchievementDataInfo info, bool isfirst = false)
	{
		m_AchievementType = info.m_AchievementType;
		csLocalizationManager.Instance.CheckTextFontType(TitleText);
		TitleText.text = csLocalizationManager.Instance.GetLocalText(m_AchievementType.ToString() + "_B");
		csLocalizationManager.Instance.CheckTextFontType(DescriptionText);
		if (m_AchievementType == AchievementType.Target_022)
		{
			DescriptionText.text = string.Format(csLocalizationManager.Instance.GetLocalText(m_AchievementType.ToString() + "_A"), csLocalizationManager.Instance.GetLocalText("Horse_009_A"));
		}
		else if (m_AchievementType == AchievementType.Target_023)
		{
			DescriptionText.text = string.Format(csLocalizationManager.Instance.GetLocalText(m_AchievementType.ToString() + "_A"), csLocalizationManager.Instance.GetLocalText("Horse_008_A"));
		}
		else if (m_AchievementType == AchievementType.Target_024)
		{
			DescriptionText.text = string.Format(csLocalizationManager.Instance.GetLocalText(m_AchievementType.ToString() + "_A"), csLocalizationManager.Instance.GetLocalText("Horse_010_A"));
		}
		else if (m_AchievementType == AchievementType.Target_025)
		{
			DescriptionText.text = string.Format(csLocalizationManager.Instance.GetLocalText(m_AchievementType.ToString() + "_A"), csLocalizationManager.Instance.GetLocalText("Horse_011_A"));
		}
		else
		{
			DescriptionText.text = string.Format(csLocalizationManager.Instance.GetLocalText(m_AchievementType.ToString() + "_A"), info.MaxValue);
		}
		if (info.CurrentValue > 0)
		{
			Slider.enabled = true;
		}
		else
		{
			Slider.enabled = false;
		}
		float num = (float)info.CurrentValue / (float)info.MaxValue * 1114.7f;
		Slider.rectTransform.sizeDelta = new Vector2((num > 140f) ? num : 140f, 193f);
		AwardCount.text = info.AwardCount.ToString();
		csLocalizationManager.Instance.CheckTextFontType(StateText);
		if (info.m_AchievementState == AchievementState.Received)
		{
			StateText.gameObject.SetActive(value: true);
			AchievementIcon.color = new Color(1f, 1f, 1f, 1f);
			StateText.text = csLocalizationManager.Instance.GetLocalText("Achievement07");
			GetAwardBtn.gameObject.SetActive(value: false);
			Img_CanAward.enabled = false;
			if (!string.IsNullOrEmpty(info.CompleteTime))
			{
				DateTime dateTime = new DateTime(long.Parse(info.CompleteTime));
				CompeletTime.text = dateTime.Year + "/" + dateTime.Month + "/" + dateTime.Day;
			}
			ProgressText_Current.text = info.MaxValue.ToString();
			ProgressText_Max.text = info.MaxValue.ToString();
		}
		else if (info.m_AchievementState == AchievementState.UnComplet)
		{
			StateText.gameObject.SetActive(value: true);
			AchievementIcon.color = new Color(0.5f, 0.5f, 0.5f, 1f);
			StateText.text = csLocalizationManager.Instance.GetLocalText("Achievement06");
			GetAwardBtn.gameObject.SetActive(value: false);
			Img_CanAward.enabled = false;
			ProgressText_Current.text = info.CurrentValue.ToString();
			ProgressText_Max.text = info.MaxValue.ToString();
		}
		else
		{
			StateText.gameObject.SetActive(value: false);
			GetAwardBtn.gameObject.SetActive(value: true);
			Img_CanAward.enabled = true;
			btnAnimator.DOPlay();
			GetAwardBtn.onClick.RemoveAllListeners();
			clipPlayer.AddEventToButton();
			GetAwardBtn.onClick.AddListener(OnClickGetAwardBtn);
			ProgressText_Current.text = info.MaxValue.ToString();
			ProgressText_Max.text = info.MaxValue.ToString();
			if (!string.IsNullOrEmpty(info.CompleteTime))
			{
				DateTime dateTime2 = new DateTime(long.Parse(info.CompleteTime));
				CompeletTime.text = dateTime2.Year + "/" + dateTime2.Month + "/" + dateTime2.Day;
			}
		}
		if (info.m_AwardType == AchievementAwardType.Coin)
		{
			AwardIcon.sprite = CoinSprite;
		}
		else
		{
			AwardIcon.sprite = DiamondSprite;
		}
		if (isfirst)
		{
			Sprite sprite = Sprite.Create(Resources.Load(m_AchievementType.ToString()) as Texture2D, new Rect(0f, 0f, 256f, 256f), Vector2.zero);
			AchievementIcon.sprite = sprite;
		}
	}

	private void OnClickGetAwardBtn()
	{
		List<ResultAwardData> list = new List<ResultAwardData>();
		if (csPlayerData.AchievementDic[m_AchievementType].m_AwardType == AchievementAwardType.Coin)
		{
			int awardCount = csPlayerData.AchievementDic[m_AchievementType].AwardCount;
			csPlayerData.PlayerCoin += awardCount;
			csPlayerData.AddAchievementSchedule_Coin(awardCount, save: false);
			list.Add(new ResultAwardData(awardCount, 0, AheadBuff.RushS, 0));
		}
		else if (csPlayerData.AchievementDic[m_AchievementType].m_AwardType == AchievementAwardType.Diamond)
		{
			csPlayerData.PlayerDiamond += csPlayerData.AchievementDic[m_AchievementType].AwardCount;
			list.Add(new ResultAwardData(0, csPlayerData.AchievementDic[m_AchievementType].AwardCount, AheadBuff.RushS, 0));
		}
		csPlayerData.AchievementDic[m_AchievementType].m_AchievementState = AchievementState.Received;
		csPlayerData.SaveAchievementDic();
		AchievePanel.AchievementGiftPanel.SetAwards(list);
		AchievePanel.AchievementGiftPanel.Show(isShow: true);
	}
}
public class csButtonActions : MonoBehaviour
{
	[HideInInspector]
	public Button m_btn;

	public UnityAction onBtnEnterAct;

	public UnityAction onBtnExitAct;

	private void Awake()
	{
		m_btn = GetComponent<Button>();
		EventTriggerListener.GetListener(m_btn.gameObject).onPointerEnter = OnMouseEnter;
		EventTriggerListener.GetListener(m_btn.gameObject).onPointerExit = OnMouseExit;
	}

	private void OnMouseEnter(GameObject go)
	{
		if (m_btn.interactable)
		{
			onBtnEnterAct?.Invoke();
		}
	}

	private void OnMouseExit(GameObject go)
	{
		onBtnExitAct?.Invoke();
	}
}
public class csButtonGroup : MonoBehaviour
{
	public List<csButtonSelect> ButtonList = new List<csButtonSelect>();

	public int CurrentSelectIndex;

	public Action<int> OnSetIndex;

	private void Awake()
	{
		for (int i = 0; i < ButtonList.Count; i++)
		{
			if (!ButtonList[i].m_btn)
			{
				ButtonList[i].m_btn = ButtonList[i].GetComponent<Button>();
			}
			ButtonList[i].m_btn.onClick.AddListener(ButtonList[i].SwitchBtn);
			ButtonList[i].SwitchIndex = i;
			ButtonList[i].m_Group = this;
		}
	}

	public void SetCurrntIndex(int index)
	{
		for (int i = 0; i < ButtonList.Count; i++)
		{
			ButtonList[i].SetSwitched(index == i);
		}
		CurrentSelectIndex = index;
		OnSetIndex?.Invoke(CurrentSelectIndex);
	}

	public void SetSwitchObjByIndex(bool isSwitched, int index)
	{
		ButtonList[index].SetSwitched(isSwitched);
	}
}
public class csButtonSelect : MonoBehaviour
{
	[HideInInspector]
	public Button m_btn;

	public GameObject[] OnSelectObjs;

	public GameObject[] NormalObjs;

	public GameObject[] OnSwitchedObjs;

	public UnityAction onBtnEnterAct;

	public UnityAction onBtnExitAct;

	public bool ZoomSelectd;

	private Vector3 ScaleAwake;

	private float scale = 1.05f;

	[HideInInspector]
	public csButtonGroup m_Group;

	public int SwitchIndex;

	private void Awake()
	{
		if (!m_btn)
		{
			m_btn = GetComponent<Button>();
		}
		EventTriggerListener.GetListener(m_btn.gameObject).onPointerEnter = OnMouseEnter;
		EventTriggerListener.GetListener(m_btn.gameObject).onPointerExit = OnMouseExit;
		m_btn.onClick.AddListener(delegate
		{
			m_btn.enabled = false;
			m_btn.enabled = true;
		});
		ScaleAwake = base.transform.localScale;
	}

	private void OnDisable()
	{
		OnMouseExit(base.gameObject);
	}

	private void OnMouseEnter(GameObject go)
	{
		if (m_btn.interactable)
		{
			m_btn.OnPointerEnter(new PointerEventData(EventSystem.current));
			if (ZoomSelectd)
			{
				base.transform.localScale = ScaleAwake * scale;
			}
			for (int i = 0; i < OnSelectObjs.Length; i++)
			{
				OnSelectObjs[i].SetActive(value: true);
			}
			for (int j = 0; j < NormalObjs.Length; j++)
			{
				NormalObjs[j].SetActive(value: false);
			}
			onBtnEnterAct?.Invoke();
		}
	}

	private void OnMouseExit(GameObject go)
	{
		m_btn.OnPointerExit(new PointerEventData(EventSystem.current));
		if (ZoomSelectd)
		{
			base.transform.localScale = ScaleAwake;
		}
		for (int i = 0; i < OnSelectObjs.Length; i++)
		{
			OnSelectObjs[i].SetActive(value: false);
		}
		for (int j = 0; j < NormalObjs.Length; j++)
		{
			NormalObjs[j].SetActive(value: true);
		}
		m_btn.OnDeselect(new PointerEventData(EventSystem.current));
		onBtnExitAct?.Invoke();
	}

	private void PlayClickEffect()
	{
		if ((bool)csEffectManager.instance)
		{
			csEffectManager.instance.PlayClickEffect(base.transform.position, base.transform.rotation);
		}
	}

	public void SwitchBtn()
	{
		m_Group.SetCurrntIndex(SwitchIndex);
	}

	public void SetSwitched(bool isswitched)
	{
		for (int i = 0; i < OnSwitchedObjs.Length; i++)
		{
			OnSwitchedObjs[i].SetActive(isswitched);
		}
	}
}
public class csEffectManager : MonoBehaviour
{
	public static csEffectManager instance;

	public ParticleSystem UIClickEffect;

	public Vector3 hitPosition;

	private void Awake()
	{
		if (instance == null)
		{
			instance = this;
			UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
		}
		else
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}

	private void Start()
	{
		if (csGameSettings.Channel != 0)
		{
			UIClickEffect.gameObject.SetActive(value: false);
		}
	}

	public void PlayClickEffect()
	{
		UIClickEffect.transform.position = hitPosition;
		UIClickEffect.transform.rotation = Quaternion.identity;
		if (UIClickEffect.isPlaying)
		{
			UIClickEffect.Stop();
		}
		float num = Vector3.Distance(csHMDIniter.instance.CurrentSetter.camT.position, hitPosition);
		float startSize = Mathf.Clamp(0.15f * num + 0.2f, 0.3f, 0.8f);
		UIClickEffect.startSize = startSize;
		UIClickEffect.Play();
	}

	public void PlayClickEffect(Vector3 Point, Quaternion rot)
	{
		UIClickEffect.transform.position = Point;
		UIClickEffect.transform.rotation = rot;
		if (UIClickEffect.isPlaying)
		{
			UIClickEffect.Stop();
		}
		float num = Vector3.Distance(csHMDIniter.instance.CurrentSetter.camT.position, Point);
		float startSize = Mathf.Clamp(0.15f * num + 0.2f, 0.3f, 0.8f);
		UIClickEffect.startSize = startSize;
		UIClickEffect.Play();
	}
}
public class csHorseDirectSelect : MonoBehaviour
{
	public csMainHorseShop m_HorseShop;

	public GameObject DirectSelectItem;

	public Transform HorseItemParentT;

	public Sprite[] HeadSprites;

	public List<csHorseDirectSelectItem> HorseItemList = new List<csHorseDirectSelectItem>();

	private bool isInited;

	public ScrollRect scrollRect;

	private int FakeIdNum = 3;

	public RectTransform viewPointTransform;

	public RectTransform contentTransform;

	public ContentSizeFitter Ffitter;

	public void InitHorseItemList()
	{
		if (isInited)
		{
			return;
		}
		isInited = true;
		for (int i = 0; i < 11 + FakeIdNum * 2; i++)
		{
			int num = i - FakeIdNum;
			if (num < 0)
			{
				num = 11 + num;
			}
			if (num >= 11)
			{
				num -= 11;
			}
			GameObject obj = UnityEngine.Object.Instantiate(DirectSelectItem);
			csHorseDirectSelectItem component = obj.GetComponent<csHorseDirectSelectItem>();
			obj.transform.SetParent(HorseItemParentT);
			obj.transform.localPosition = Vector3.zero;
			obj.transform.localScale = Vector3.one;
			obj.transform.localEulerAngles = Vector3.zero;
			HorseType horseType = csPlayerData.HorseTypeByPrice[num].m_HorseType;
			csPlayerData.GetHorseInfo(horseType);
			Sprite sHead = HeadSprites[(int)horseType];
			component.InitHorseItem(sHead, horseType, this, i - FakeIdNum);
			HorseItemList.Add(component);
		}
	}

	public void SelectHorse(HorseType ht, int hid)
	{
		if (!m_HorseShop.isBusy)
		{
			m_HorseShop.DirSelect(ht, hid);
			SetHorse(ht, hid);
		}
	}

	public void SetHorse(HorseType ht, int hid)
	{
		for (int i = 0; i < HorseItemList.Count; i++)
		{
			HorseItemList[i].SetChosen(isChosen: false);
		}
		int num = HorseItemList.FindIndex((csHorseDirectSelectItem x) => x.HorseTypeIndex >= 0 && x.HorseTypeIndex < csPlayerData.HorseTypeByPrice.Count && csPlayerData.HorseTypeByPrice[x.HorseTypeIndex].m_HorseType == ht);
		if (num >= 0)
		{
			Ffitter.SetLayoutHorizontal();
			CenterOnItem(HorseItemList[num].GetComponent<RectTransform>(), hid);
			HorseItemList[num].SetChosen(isChosen: true);
		}
	}

	public void SetHorseNoTween(HorseType ht, int hid)
	{
		for (int i = 0; i < HorseItemList.Count; i++)
		{
			HorseItemList[i].SetChosen(isChosen: false);
		}
		int num = HorseItemList.FindIndex((csHorseDirectSelectItem x) => x.HorseTypeIndex >= 0 && x.HorseTypeIndex < csPlayerData.HorseTypeByPrice.Count && csPlayerData.HorseTypeByPrice[x.HorseTypeIndex].m_HorseType == ht);
		if (num >= 0)
		{
			Ffitter.SetLayoutHorizontal();
			CenterOnItemNoTween(HorseItemList[num].GetComponent<RectTransform>(), hid);
			HorseItemList[num].SetChosen(isChosen: true);
		}
	}

	public void CenterOnItemNoTween(RectTransform target, int hid)
	{
		Vector3 vector = new Vector3(0f, 0f, 0f);
		Vector2 vector2 = new Vector2(0f, 0f);
		Vector2 vector3 = new Vector2(0f, 0f);
		new Vector2(0f, 0f);
		Vector2 vector4 = GetWorldPointInWidget(scrollRect.GetComponent<RectTransform>(), GetWidgetWorldPoint(viewPointTransform));
		vector3 = GetWorldPointInWidget(scrollRect.GetComponent<RectTransform>(), GetWidgetWorldPoint(target));
		vector = vector4 - vector3;
		vector.z = 0f;
		vector2 = new Vector2(vector.x / (contentTransform.rect.width - viewPointTransform.rect.width), vector.y / (contentTransform.rect.height - viewPointTransform.rect.height));
		vector2 = scrollRect.normalizedPosition - vector2;
		vector2.x = Mathf.Clamp01(vector2.x);
		vector2.y = Mathf.Clamp01(vector2.y);
		scrollRect.normalizedPosition = vector2;
	}

	public void CenterOnItem(RectTransform target, int hid)
	{
		Vector3 vector = new Vector3(0f, 0f, 0f);
		Vector2 vector2 = new Vector2(0f, 0f);
		Vector2 vector3 = new Vector2(0f, 0f);
		Vector2 vector4 = new Vector2(0f, 0f);
		vector4 = GetWorldPointInWidget(scrollRect.GetComponent<RectTransform>(), GetWidgetWorldPoint(viewPointTransform));
		if (hid < 0)
		{
			int index = HorseItemList.FindIndex((csHorseDirectSelectItem x) => x.HorseTypeIndex == 11 + hid + FakeIdNum);
			vector3 = GetWorldPointInWidget(scrollRect.GetComponent<RectTransform>(), GetWidgetWorldPoint(HorseItemList[index].GetComponent<RectTransform>()));
			vector = vector4 - vector3;
			vector2 = new Vector2(vector.x / (contentTransform.rect.width - viewPointTransform.rect.width), vector.y / (contentTransform.rect.height - viewPointTransform.rect.height));
			vector2 = scrollRect.normalizedPosition - vector2;
			vector2.x = Mathf.Clamp01(vector2.x);
			vector2.y = Mathf.Clamp01(vector2.y);
			scrollRect.normalizedPosition = vector2;
		}
		else if (hid >= 11)
		{
			int index2 = HorseItemList.FindIndex((csHorseDirectSelectItem x) => x.HorseTypeIndex == hid - 11 - FakeIdNum);
			vector3 = GetWorldPointInWidget(scrollRect.GetComponent<RectTransform>(), GetWidgetWorldPoint(HorseItemList[index2].GetComponent<RectTransform>()));
			vector = vector4 - vector3;
			vector2 = new Vector2(vector.x / (contentTransform.rect.width - viewPointTransform.rect.width), vector.y / (contentTransform.rect.height - viewPointTransform.rect.height));
			vector2 = scrollRect.normalizedPosition - vector2;
			vector2.x = Mathf.Clamp01(vector2.x);
			vector2.y = Mathf.Clamp01(vector2.y);
			scrollRect.normalizedPosition = vector2;
		}
		vector3 = GetWorldPointInWidget(scrollRect.GetComponent<RectTransform>(), GetWidgetWorldPoint(target));
		vector = vector4 - vector3;
		vector.z = 0f;
		UnityEngine.Debug.Log(contentTransform.rect.width);
		vector2 = new Vector2(vector.x / (contentTransform.rect.width - viewPointTransform.rect.width), vector.y / (contentTransform.rect.height - viewPointTransform.rect.height));
		vector2 = scrollRect.normalizedPosition - vector2;
		vector2.x = Mathf.Clamp01(vector2.x);
		vector2.y = Mathf.Clamp01(vector2.y);
		DOTween.To(() => scrollRect.normalizedPosition, delegate(Vector2 x)
		{
			scrollRect.normalizedPosition = x;
		}, vector2, 0.1f);
	}

	private Vector3 GetWidgetWorldPoint(RectTransform target)
	{
		Vector3 vector = new Vector3((0.5f - target.pivot.x) * target.rect.size.x, (0.5f - target.pivot.y) * target.rect.size.y, 0f);
		Vector3 position = target.localPosition + vector;
		return target.parent.TransformPoint(position);
	}

	private Vector3 GetWorldPointInWidget(RectTransform target, Vector3 worldPoint)
	{
		return target.InverseTransformPoint(worldPoint);
	}
}
public class csHorseDirectSelectItem : MonoBehaviour
{
	public RectTransform BkgRT;

	public Image HorseHead;

	public GameObject ChosenObj;

	public HorseType m_HorseType;

	public int HorseTypeIndex = -5;

	private csHorseDirectSelect selManager;

	public void InitHorseItem(Sprite sHead, HorseType hType, csHorseDirectSelect selM, int id)
	{
		HorseHead.overrideSprite = sHead;
		m_HorseType = hType;
		selManager = selM;
		HorseTypeIndex = id;
	}

	public void SetChosen(bool isChosen)
	{
		ChosenObj.SetActive(isChosen);
		if (isChosen)
		{
			BkgRT.localScale = 1.2f * Vector3.one;
		}
		else
		{
			BkgRT.localScale = Vector3.one;
		}
	}

	public void OnItemSelect()
	{
		selManager.SelectHorse(m_HorseType, HorseTypeIndex);
	}
}
public class csLeaderboardInfoList : MonoBehaviour
{
	public List<csLeaderboardInfoUI> LeaderboardInfoUIList;

	public csLeaderboardInfoUI MineLeaderBoardInfo;

	public csButtonGroup m_Group;

	public GameObject body;

	public List<Sprite> Flags;

	public Sprite UnknowFlag;

	public int PageIndex;

	private int MaxIndex;

	public Text PageText;

	public GameObject LeftBtn;

	public GameObject RightBtn;

	public GameObject LoadingObj;

	public bool isPlayFab;

	private void Awake()
	{
		csLeaderboard.RefreshLeaderboardAction = (Action<bool>)Delegate.Combine(csLeaderboard.RefreshLeaderboardAction, new Action<bool>(SwitchLeaderBoard));
	}

	public void HidePanel()
	{
		body.SetActive(value: false);
	}

	public void ShowPanel()
	{
		body.SetActive(value: true);
	}

	private void Start()
	{
		m_Group.OnSetIndex = OnSwitchLeaderboard;
		LoadingObj.SetActive(value: false);
		m_Group.SetCurrntIndex(1);
	}

	private void OnDestroy()
	{
		csLeaderboard.RefreshLeaderboardAction = (Action<bool>)Delegate.Remove(csLeaderboard.RefreshLeaderboardAction, new Action<bool>(SwitchLeaderBoard));
	}

	public void TurnLeft()
	{
		if (PageIndex != 0)
		{
			PageIndex--;
			RefreshUI(isPlayFab);
		}
	}

	public void TurnRight()
	{
		if (PageIndex != MaxIndex - 1)
		{
			PageIndex++;
			RefreshUI(isPlayFab);
		}
	}

	private void OnSwitchLeaderboard(int index)
	{
		if (index == 1)
		{
			if ((bool)csLeaderboard.instance)
			{
				csLeaderboard.instance.TryRefresh();
			}
		}
		else if ((bool)csLeaderboard.instance && csPlayerData.HasLogin)
		{
			csLeaderboard.instance.GetLeaderboard_Playfab();
			LoadingObj.SetActive(value: true);
		}
	}

	public void SwitchLeaderBoard(bool _isPlayfab)
	{
		isPlayFab = _isPlayfab;
		PageIndex = 0;
		RefreshUI(isPlayFab);
		if (isPlayFab)
		{
			LoadingObj.SetActive(value: false);
		}
	}

	public void RefreshUI(bool _isPlayfab)
	{
		if (!_isPlayfab)
		{
			Dictionary<string, LeaderboardInfo> dictionary = csLeaderboard.instance.LeaderboardInfoByPlayerID.OrderByDescending(delegate(KeyValuePair<string, LeaderboardInfo> entry)
			{
				KeyValuePair<string, LeaderboardInfo> keyValuePair2 = entry;
				return keyValuePair2.Value.m_Score;
			}).ToDictionary((KeyValuePair<string, LeaderboardInfo> pair) => pair.Key, (KeyValuePair<string, LeaderboardInfo> pair) => pair.Value);
			MaxIndex = csLeaderboard.instance.LeaderboardInfoByPlayerID.Count / 10;
			if (csLeaderboard.instance.LeaderboardInfoByPlayerID.Count % 10 > 0)
			{
				MaxIndex++;
			}
			List<LeaderboardInfo> list = dictionary.Values.ToList();
			for (int i = 0; i < LeaderboardInfoUIList.Count; i++)
			{
				if (PageIndex * 10 + i < list.Count)
				{
					LeaderboardInfoUIList[i].SetInfo(list[PageIndex * 10 + i], PageIndex * 10 + i + 1);
				}
				else
				{
					LeaderboardInfoUIList[i].SetActive(show: false);
				}
			}
			int num = 0;
			MineLeaderBoardInfo.SetActive(show: false);
			foreach (KeyValuePair<string, LeaderboardInfo> item in dictionary)
			{
				if (item.Value.m_Name.Contains(csPlayerData.PlayerName))
				{
					MineLeaderBoardInfo.SetInfo(item.Value, num + 1);
				}
				num++;
			}
			PageText.text = PageIndex + 1 + "/" + MaxIndex;
		}
		else
		{
			Dictionary<string, LeaderboardInfo> dictionary2 = csLeaderboard.instance.LeaderboardInfoByPlayerID_Playfab.OrderByDescending(delegate(KeyValuePair<string, LeaderboardInfo> entry)
			{
				KeyValuePair<string, LeaderboardInfo> keyValuePair = entry;
				return keyValuePair.Value.m_Score;
			}).ToDictionary((KeyValuePair<string, LeaderboardInfo> pair) => pair.Key, (KeyValuePair<string, LeaderboardInfo> pair) => pair.Value);
			MaxIndex = csLeaderboard.instance.LeaderboardInfoByPlayerID_Playfab.Count / 10;
			if (csLeaderboard.instance.LeaderboardInfoByPlayerID_Playfab.Count % 10 > 0)
			{
				MaxIndex++;
			}
			List<LeaderboardInfo> list2 = dictionary2.Values.ToList();
			for (int j = 0; j < LeaderboardInfoUIList.Count; j++)
			{
				if (PageIndex * 10 + j < list2.Count)
				{
					LeaderboardInfoUIList[j].SetInfo(list2[PageIndex * 10 + j], PageIndex * 10 + j + 1);
				}
				else
				{
					LeaderboardInfoUIList[j].SetActive(show: false);
				}
			}
			int num2 = 0;
			foreach (KeyValuePair<string, LeaderboardInfo> item2 in dictionary2)
			{
				if (item2.Key.Contains(csPlayerData.PlayerID))
				{
					MineLeaderBoardInfo.SetInfo(item2.Value, num2 + 1);
				}
				num2++;
			}
			PageText.text = PageIndex + 1 + "/" + MaxIndex;
		}
		RightBtn.SetActive(PageIndex < MaxIndex - 1);
		LeftBtn.SetActive(PageIndex > 0);
	}
}
public class csLeaderboardInfoUI : MonoBehaviour
{
	public TextMeshProUGUI RankText;

	public TextMeshProUGUI NameText;

	public TextMeshProUGUI ScoreText;

	public TextMeshProUGUI TimeText;

	public Image FlagIcon;

	public csLeaderboardInfoList LeaderboardPanel;

	public void SetInfo(LeaderboardInfo info, int num)
	{
		RankText.text = num.ToString();
		NameText.text = info.m_Name;
		ScoreText.text = info.m_Score.ToString();
		FlagIcon.enabled = true;
		bool flag = false;
		for (int i = 0; i < LeaderboardPanel.Flags.Count; i++)
		{
			if (LeaderboardPanel.Flags[i].name == info.CountryCode)
			{
				FlagIcon.sprite = LeaderboardPanel.Flags[i];
				flag = true;
			}
		}
		if (!flag)
		{
			FlagIcon.sprite = LeaderboardPanel.UnknowFlag;
		}
		SetActive(show: true);
	}

	private string TimeToString(int _s)
	{
		int num = _s / 60;
		int num2 = _s % 60;
		return $"{num:D2}" + ":" + $"{num2:D2}";
	}

	public void SetActive(bool show)
	{
		RankText.gameObject.SetActive(show);
		NameText.gameObject.SetActive(show);
		ScoreText.gameObject.SetActive(show);
		TimeText.gameObject.SetActive(value: false);
		FlagIcon.gameObject.SetActive(show);
	}
}
public class csLevelAwardPanel : MonoBehaviour
{
	public List<csLevelAwardPanelIcon> LevelAwardList = new List<csLevelAwardPanelIcon>();

	public CanvasGroup thisCG;

	public GameObject thisG;

	public Transform thisT;

	public Sprite AddLifeS;

	public Sprite GoldBuffS;

	public Sprite GoldBuffB;

	public Sprite RushS;

	public Sprite RushB;

	public Sprite ScoreBuffS;

	public Sprite ScoreBuffB;

	public Sprite ShieldS;

	public Sprite ShieldB;

	public Sprite S_Award_Money;

	public Sprite S_Award_Gem;

	private int curLevel;

	private UnityAction onAwardGet;

	public void Show(bool isShow)
	{
		thisG.SetActive(isShow);
		if (isShow)
		{
			csMainSceneAudioPlayer.instance.PlayAudio2D("OpenBox");
		}
	}

	public void SetAwards(int level, UnityAction act)
	{
		curLevel = level;
		onAwardGet = act;
		foreach (csLevelAwardPanelIcon levelAward in LevelAwardList)
		{
			levelAward.SetAwardOn(isOn: false);
		}
		int num = 0;
		if (csGameData.Instance.LevelAwardDataInfo[level - 1].CoinNum > 0)
		{
			LevelAwardList[num].SetAwardMoney(csGameData.Instance.LevelAwardDataInfo[level - 1].CoinNum, S_Award_Money, csLocalizationManager.Instance.GetLocalText("PropShopMenu02"));
			num++;
		}
		if (csGameData.Instance.LevelAwardDataInfo[level - 1].GemNum > 0)
		{
			LevelAwardList[num].SetAwardGem(csGameData.Instance.LevelAwardDataInfo[level - 1].GemNum, S_Award_Gem, csLocalizationManager.Instance.GetLocalText("PropShopMenu03"));
			num++;
		}
		if (csGameData.Instance.LevelAwardDataInfo[level - 1].LevelAward.Count <= 0)
		{
			return;
		}
		for (int i = 0; i < csGameData.Instance.LevelAwardDataInfo[level - 1].LevelAward.Count; i++)
		{
			string text = "";
			Sprite s;
			switch (csGameData.Instance.LevelAwardDataInfo[level - 1].LevelAward[i].AwardBuff)
			{
			default:
				s = RushS;
				text = csLocalizationManager.Instance.GetLocalText("Item_A_001");
				break;
			case AheadBuff.AddLifeS:
				s = AddLifeS;
				text = csLocalizationManager.Instance.GetLocalText("Item_A_005");
				break;
			case AheadBuff.GoldBuffS:
				s = GoldBuffS;
				text = csLocalizationManager.Instance.GetLocalText("Item_A_006");
				break;
			case AheadBuff.GoldBuffB:
				s = GoldBuffB;
				text = csLocalizationManager.Instance.GetLocalText("Item_A_007");
				break;
			case AheadBuff.RushS:
				s = RushS;
				text = csLocalizationManager.Instance.GetLocalText("Item_A_001");
				break;
			case AheadBuff.RushB:
				s = RushB;
				text = csLocalizationManager.Instance.GetLocalText("Item_A_002");
				break;
			case AheadBuff.ScoreBuffS:
				s = ScoreBuffS;
				text = csLocalizationManager.Instance.GetLocalText("Item_A_008");
				break;
			case AheadBuff.ScoreBuffB:
				s = ScoreBuffB;
				text = csLocalizationManager.Instance.GetLocalText("Item_A_009");
				break;
			case AheadBuff.ShieldS:
				s = ShieldS;
				text = csLocalizationManager.Instance.GetLocalText("Item_A_003");
				break;
			case AheadBuff.ShieldB:
				s = ShieldB;
				text = csLocalizationManager.Instance.GetLocalText("Item_A_004");
				break;
			}
			LevelAwardList[num].SetAwardProp(csGameData.Instance.LevelAwardDataInfo[level - 1].LevelAward[i].AwardNum, s, text);
			num++;
		}
	}

	public void OnConfirmAward()
	{
		csPlayerData.AwardUnlockList[curLevel - 1] = false;
		csPlayerData.SaveAwardUnlockData();
		csPlayerData.PlayerCoin += csGameData.Instance.LevelAwardDataInfo[curLevel - 1].CoinNum;
		csPlayerData.PlayerDiamond += csGameData.Instance.LevelAwardDataInfo[curLevel - 1].GemNum;
		List<LevelAward> levelAward = csGameData.Instance.LevelAwardDataInfo[curLevel - 1].LevelAward;
		for (int i = 0; i < levelAward.Count; i++)
		{
			csPlayerData.OnGetAheadBuff(levelAward[i].AwardBuff, levelAward[i].AwardNum);
		}
		csMainMenuCanvas.instance.RefreshMainMenuCoin();
		onAwardGet?.Invoke();
		Show(isShow: false);
	}
}
public class csLevelAwardPanelIcon : MonoBehaviour
{
	public GameObject thisG;

	public Image IconImg;

	public TextMeshProUGUI NumTxt;

	private void Awake()
	{
		thisG = base.gameObject;
	}

	public void SetAwardOn(bool isOn)
	{
		thisG.SetActive(isOn);
	}

	public void SetAwardMoney(int money, Sprite s, string pname, bool DefaultOpen = true)
	{
		NumTxt.text = "x" + money;
		IconImg.overrideSprite = s;
		if (DefaultOpen)
		{
			SetAwardOn(isOn: true);
		}
	}

	public void SetAwardGem(int gem, Sprite s, string pname, bool DefaultOpen = true)
	{
		NumTxt.text = "x" + gem;
		IconImg.overrideSprite = s;
		if (DefaultOpen)
		{
			SetAwardOn(isOn: true);
		}
	}

	public void SetAwardProp(int num, Sprite s, string pname, bool DefaultOpen = true)
	{
		NumTxt.text = "x" + num;
		IconImg.overrideSprite = s;
		if (DefaultOpen)
		{
			SetAwardOn(isOn: true);
		}
	}
}
public class csLevelInfo : MonoBehaviour
{
	public TextMeshProUGUI LevelTitleText;

	public TextMeshProUGUI LevelDescriptionText;

	public TextMeshProUGUI BestScoreText;

	public GameObject NewRecordObj_Score;

	public TextMeshProUGUI MissionDescriptionText_1;

	public TextMeshProUGUI MissionDescriptionText_2;

	public TextMeshProUGUI MissionDescriptionText_3;

	public List<csPropItemInMenu> PropItemList;

	public Sprite Null;

	public Sprite AddLifeS;

	public Sprite GoldBuffS;

	public Sprite GoldBuffB;

	public Sprite RushS;

	public Sprite RushB;

	public Sprite ScoreBuffS;

	public Sprite ScoreBuffB;

	public Sprite ShieldS;

	public Sprite ShieldB;

	public List<csLevelInfoAward> AwardInfoList = new List<csLevelInfoAward>();

	public Sprite S_Award_Money;

	public Sprite S_Award_Gem;

	public Image LevelBGImg;

	public Sprite[] LevelSprites;

	public GameObject StartGameBtnObj;

	public void InitLevelInfo(PlayerLevelData data, bool doanim)
	{
		csLocalizationManager.Instance.CheckTextFontType(LevelTitleText);
		csLocalizationManager.Instance.CheckTextFontType(LevelDescriptionText);
		LevelTitleText.text = csLocalizationManager.Instance.GetLocalText("Level_" + data.Level + "_A");
		LevelDescriptionText.text = csLocalizationManager.Instance.GetLocalText("Level_" + data.Level + "_B");
		BestScoreText.text = data.BestScore.ToString();
		LevelBGImg.overrideSprite = LevelSprites[data.Level - 1];
		NewRecordObj_Score.SetActive(data.LastScore == data.BestScore && data.BestScore != 0);
		LevelInfo levelInfo = csLevelData.instance.m_LevelInfoList.m_LevelInfoList[data.Level - 1];
		csLocalizationManager.Instance.CheckTextFontType(MissionDescriptionText_1);
		csLocalizationManager.Instance.CheckTextFontType(MissionDescriptionText_2);
		csLocalizationManager.Instance.CheckTextFontType(MissionDescriptionText_3);
		MissionDescriptionText_1.text = csLevelData.instance.GetDescriptionByMission(levelInfo.m_MissionDataList[0]);
		MissionDescriptionText_2.text = csLevelData.instance.GetDescriptionByMission(levelInfo.m_MissionDataList[1]);
		MissionDescriptionText_3.text = csLevelData.instance.GetDescriptionByMission(levelInfo.m_MissionDataList[2]);
		int num = 0;
		foreach (csLevelInfoAward awardInfo in AwardInfoList)
		{
			awardInfo.SetAwardOn(isOn: false);
		}
		if (csGameData.Instance.LevelAwardDataInfo[data.Level - 1].CoinNum > 0)
		{
			AwardInfoList[num].SetAwardMoney(csGameData.Instance.LevelAwardDataInfo[data.Level - 1].CoinNum, S_Award_Money);
			num++;
		}
		if (csGameData.Instance.LevelAwardDataInfo[data.Level - 1].GemNum > 0)
		{
			AwardInfoList[num].SetAwardGem(csGameData.Instance.LevelAwardDataInfo[data.Level - 1].GemNum, S_Award_Gem);
			num++;
		}
		if (csGameData.Instance.LevelAwardDataInfo[data.Level - 1].LevelAward.Count > 0)
		{
			for (int i = 0; i < csGameData.Instance.LevelAwardDataInfo[data.Level - 1].LevelAward.Count; i++)
			{
				Sprite s = csGameData.Instance.LevelAwardDataInfo[data.Level - 1].LevelAward[i].AwardBuff switch
				{
					AheadBuff.AddLifeS => AddLifeS, 
					AheadBuff.GoldBuffS => GoldBuffS, 
					AheadBuff.GoldBuffB => GoldBuffB, 
					AheadBuff.RushS => RushS, 
					AheadBuff.RushB => RushB, 
					AheadBuff.ScoreBuffS => ScoreBuffS, 
					AheadBuff.ScoreBuffB => ScoreBuffB, 
					AheadBuff.ShieldS => ShieldS, 
					AheadBuff.ShieldB => ShieldB, 
					_ => RushS, 
				};
				AwardInfoList[num].SetAwardProp(csGameData.Instance.LevelAwardDataInfo[data.Level - 1].LevelAward[i].AwardNum, s);
				num++;
			}
		}
		for (int j = 0; j < PropItemList.Count; j++)
		{
			if (j < csPlayerData.EquipedBufflistInData.Count)
			{
				PropItemList[j].SetPropUI(GetPropString(hasprop: true, csPlayerData.EquipedBufflistInData[j]), GetPropSprite(hasprop: true, csPlayerData.EquipedBufflistInData[j]), ChangeIsOn: true);
			}
			else
			{
				PropItemList[j].SetPropUI(GetPropString(hasprop: false, AheadBuff.AddLifeS), GetPropSprite(hasprop: false, AheadBuff.AddLifeS), ChangeIsOn: false);
			}
		}
		base.transform.localScale = Vector3.one;
		if (doanim)
		{
			base.transform.DOScale(new Vector3(0.9f, 0.9f, 0.9f), 0.01f).SetEase(Ease.InBounce);
			base.transform.DOScale(new Vector3(1f, 1f, 1f), 0.4f).SetEase(Ease.OutBounce).SetDelay(0.01f);
		}
		StartGameBtnObj.SetActive(data.isUnLock);
	}

	private string GetPropString(bool hasprop, AheadBuff type)
	{
		string result = "";
		if (!hasprop)
		{
			return result;
		}
		switch (type)
		{
		case AheadBuff.AddLifeS:
			result = csLocalizationManager.Instance.GetLocalText("Item_A_005");
			break;
		case AheadBuff.GoldBuffS:
			result = csLocalizationManager.Instance.GetLocalText("Item_A_006");
			break;
		case AheadBuff.GoldBuffB:
			result = csLocalizationManager.Instance.GetLocalText("Item_A_007");
			break;
		case AheadBuff.RushS:
			result = csLocalizationManager.Instance.GetLocalText("Item_A_001");
			break;
		case AheadBuff.RushB:
			result = csLocalizationManager.Instance.GetLocalText("Item_A_002");
			break;
		case AheadBuff.ScoreBuffS:
			result = csLocalizationManager.Instance.GetLocalText("Item_A_008");
			break;
		case AheadBuff.ScoreBuffB:
			result = csLocalizationManager.Instance.GetLocalText("Item_A_009");
			break;
		case AheadBuff.ShieldS:
			result = csLocalizationManager.Instance.GetLocalText("Item_A_003");
			break;
		case AheadBuff.ShieldB:
			result = csLocalizationManager.Instance.GetLocalText("Item_A_004");
			break;
		}
		return result;
	}

	private Sprite GetPropSprite(bool hasprop, AheadBuff type)
	{
		Sprite result = Null;
		if (!hasprop)
		{
			return result;
		}
		switch (type)
		{
		case AheadBuff.AddLifeS:
			result = AddLifeS;
			break;
		case AheadBuff.GoldBuffS:
			result = GoldBuffS;
			break;
		case AheadBuff.GoldBuffB:
			result = GoldBuffB;
			break;
		case AheadBuff.RushS:
			result = RushS;
			break;
		case AheadBuff.RushB:
			result = RushB;
			break;
		case AheadBuff.ScoreBuffS:
			result = ScoreBuffS;
			break;
		case AheadBuff.ScoreBuffB:
			result = ScoreBuffB;
			break;
		case AheadBuff.ShieldS:
			result = ShieldS;
			break;
		case AheadBuff.ShieldB:
			result = ShieldB;
			break;
		}
		return result;
	}

	public static string FormatFloatTimeToStr(bool full, float value)
	{
		string text = "00:00:00";
		if (full)
		{
			return TimeSpan.FromSeconds(Mathf.FloorToInt(value)).ToString();
		}
		int num = (int)(value % 1f * 100f);
		return TimeSpan.FromSeconds(Mathf.FloorToInt(value)).ToString().Substring(3) + "." + ((num < 10) ? ("0" + num) : num.ToString());
	}

	public void ShowPropSelect()
	{
		csMainMenuCanvas.instance.BackFromShopAction = ((csMainStartPanel)csMainMenuCanvas.instance.MenuObjDic[MainMenuType.MainMenu]).ShowLevelSelect;
		csMainMenuCanvas.instance.OpenMenu(MainMenuType.PropShop, "PropShop");
	}
}
public class csLevelInfoAward : MonoBehaviour
{
	public GameObject thisG;

	public Image IconImg;

	public TextMeshProUGUI NumTxt;

	private void Awake()
	{
		thisG = base.gameObject;
	}

	public void SetAwardOn(bool isOn)
	{
		thisG.SetActive(isOn);
	}

	public void SetAwardMoney(int money, Sprite s)
	{
		NumTxt.text = money.ToString();
		IconImg.overrideSprite = s;
		SetAwardOn(isOn: true);
	}

	public void SetAwardGem(int gem, Sprite s)
	{
		NumTxt.text = gem.ToString();
		IconImg.overrideSprite = s;
		SetAwardOn(isOn: true);
	}

	public void SetAwardProp(int num, Sprite s)
	{
		NumTxt.text = num.ToString();
		IconImg.overrideSprite = s;
		SetAwardOn(isOn: true);
	}
}
public class csLevelItem : MonoBehaviour
{
	public csLevelItemGroup LevelPanel;

	public GameObject LockObj;

	public GameObject UnLockObj;

	public GameObject[] Stars;

	public int Level;

	public TextMeshProUGUI[] LevelText;

	public Button m_button;

	public TextMeshProUGUI UnLockConditionText;

	public Image LevelBkg;

	public TextMeshProUGUI BestTimeTitle;

	public TextMeshProUGUI BestTimeTxt;

	public GameObject GiftObj;

	public csTweenAnimPlayer TweenAnimPlayer;

	private static List<int> PlayedLevelList = new List<int>();

	public void InitData(int level, int starcount, bool isLock, ExtraUnLockType _type, int _Parameter, Sprite levelsprite)
	{
		LevelBkg.overrideSprite = levelsprite;
		SetLevel(level);
		SetLock(isLock);
		GiftObj.SetActive(csPlayerData.AwardUnlockList[Level - 1]);
		StartCoroutine(PlayBoxAnim(level));
		PlayerLevelData playerLevelData = csPlayerData.PlayerLevelDataDic[level];
		if (playerLevelData.BestTime > 0f)
		{
			BestTimeTitle.enabled = true;
			BestTimeTxt.enabled = true;
			BestTimeTxt.text = FormatFloatTimeToStr(full: false, playerLevelData.BestTime);
		}
		else
		{
			BestTimeTitle.enabled = false;
			BestTimeTxt.enabled = false;
		}
		m_button.interactable = !isLock;
		if (isLock)
		{
			SetStars(-1);
			UnLockConditionText.gameObject.SetActive(value: true);
			string text = csLocalizationManager.Instance.GetLocalText("Prop04");
			switch (_type)
			{
			case ExtraUnLockType.StarNum:
				text = csLocalizationManager.Instance.GetLocalText("Prop05") + " " + _Parameter;
				break;
			case ExtraUnLockType.MaxEndlessLevel:
				text = csLocalizationManager.Instance.GetLocalText("Prop06") + " " + _Parameter;
				break;
			}
			csLocalizationManager.Instance.CheckTextFontType(UnLockConditionText);
			UnLockConditionText.text = text;
		}
		else
		{
			SetStars(starcount);
			UnLockConditionText.gameObject.SetActive(value: false);
		}
	}

	private IEnumerator PlayBoxAnim(int level)
	{
		yield return new WaitForSeconds(0.5f);
		if (csPlayerData.AwardUnlockList[Level - 1])
		{
			if (!PlayedLevelList.Contains(level))
			{
				csMainSceneAudioPlayer.instance.PlayAudio2D("LevelFirstPassBoxPopOut");
				TweenAnimPlayer.AnimOnOpen.DOPlay();
				PlayedLevelList.Add(level);
			}
			else
			{
				TweenAnimPlayer.AnimIdle.DOPlay();
			}
		}
	}

	private void SetLevel(int level)
	{
		for (int i = 0; i < LevelText.Length; i++)
		{
			csLocalizationManager.Instance.CheckTextFontType(LevelText[i]);
			LevelText[i].text = csLocalizationManager.Instance.GetLocalText("Level_" + level + "_A");
		}
		Level = level;
	}

	private void SetStars(int count)
	{
		if (count < 0)
		{
			for (int i = 0; i < Stars.Length; i++)
			{
				Stars[i].SetActive(value: false);
			}
		}
		else
		{
			for (int j = 0; j < Stars.Length; j++)
			{
				Stars[j].SetActive(j == count);
			}
		}
	}

	private void SetLock(bool isLocked)
	{
		LockObj.SetActive(isLocked);
		UnLockObj.SetActive(!isLocked);
	}

	public static string FormatFloatTimeToStr(bool full, float value)
	{
		string text = "00:00:00";
		if (full)
		{
			return TimeSpan.FromSeconds(Mathf.FloorToInt(value)).ToString();
		}
		int num = (int)(value % 1f * 100f);
		return TimeSpan.FromSeconds(Mathf.FloorToInt(value)).ToString().Substring(3) + "." + ((num < 10) ? ("0" + num) : num.ToString());
	}

	public void OnGetAwardClick()
	{
		LevelPanel.TryGetOpenLevelAward(Level);
	}
}
public class csLevelItemGroup : MonoBehaviour
{
	public List<csLevelItem> LevelItemlist = new List<csLevelItem>();

	public csButtonGroup m_Group;

	public int PageIndex;

	public GameObject LeftBtn;

	public GameObject RightBtn;

	public csLevelInfo m_LevelInfo;

	public csLevelAwardPanel m_LevelAward;

	public TextMeshProUGUI PageIndexText;

	public List<Sprite> LevelBkgList = new List<Sprite>();

	public csFadeManager PlayerCamFade;

	public int t;

	private void Awake()
	{
		m_Group.OnSetIndex = SetLevelIndex;
		m_LevelAward.Show(isShow: false);
		RefreshLevelInfo();
	}

	private void OnEnable()
	{
		if (csGameSettings.CurrentSelectedLevel == 1)
		{
			csGameSettings.CurrentSelectedLevel = csPlayerData.GetHighestUnLockLevel;
		}
		SetByLevel(csGameSettings.CurrentSelectedLevel);
	}

	private void RefreshLevelInfo()
	{
		bool flag = false;
		List<PlayerLevelData> list = new List<PlayerLevelData>(csPlayerData.PlayerLevelDataDic.Values.ToList());
		for (int i = 0; i < list.Count - 1; i++)
		{
			if (i == 0)
			{
				if (csLevelData.instance.m_LevelInfoList.m_LevelInfoList[i].m_UnLockType == ExtraUnLockType.MaxEndlessLevel)
				{
					if (csPlayerData.HighestEndlessLevel >= csLevelData.instance.m_LevelInfoList.m_LevelInfoList[i].UnLockParameter && !csPlayerData.PlayerLevelDataDic[list[i].Level].isUnLock && !flag)
					{
						csPlayerData.PlayerLevelDataDic[list[i].Level].isUnLock = true;
						flag = true;
					}
				}
				else if (csLevelData.instance.m_LevelInfoList.m_LevelInfoList[i].m_UnLockType == ExtraUnLockType.StarNum && csPlayerData.GetStarsNum() >= csLevelData.instance.m_LevelInfoList.m_LevelInfoList[i].UnLockParameter && !csPlayerData.PlayerLevelDataDic[list[i].Level].isUnLock && !flag)
				{
					csPlayerData.PlayerLevelDataDic[list[i].Level].isUnLock = true;
					flag = true;
				}
			}
			if (!list[i].isUnLock)
			{
				continue;
			}
			if (csLevelData.instance.m_LevelInfoList.m_LevelInfoList[i + 1].m_UnLockType == ExtraUnLockType.MaxEndlessLevel)
			{
				if (csPlayerData.HighestEndlessLevel >= csLevelData.instance.m_LevelInfoList.m_LevelInfoList[i + 1].UnLockParameter && !csPlayerData.PlayerLevelDataDic[list[i + 1].Level].isUnLock && !flag)
				{
					list[i + 1].isUnLock = true;
					csPlayerData.PlayerLevelDataDic[list[i + 1].Level].isUnLock = true;
					flag = true;
				}
			}
			else if (csLevelData.instance.m_LevelInfoList.m_LevelInfoList[i + 1].m_UnLockType == ExtraUnLockType.StarNum && csPlayerData.GetStarsNum() >= csLevelData.instance.m_LevelInfoList.m_LevelInfoList[i + 1].UnLockParameter && !csPlayerData.PlayerLevelDataDic[list[i + 1].Level].isUnLock && !flag)
			{
				list[i + 1].isUnLock = true;
				csPlayerData.PlayerLevelDataDic[list[i + 1].Level].isUnLock = true;
				flag = true;
			}
		}
		if (flag)
		{
			csPlayerData.SavePlayerLevelDataDic();
		}
	}

	private void SetByLevel(int level)
	{
		csGameSettings.CurrentSelectedLevel = level;
		int pageByIndex = (level - 1) / 6;
		SetPageByIndex(pageByIndex);
	}

	private void SetLevelIndex(int index)
	{
		csGameSettings.CurrentSelectedLevel = index + 1 + PageIndex * 6;
		m_LevelInfo.InitLevelInfo(csPlayerData.PlayerLevelDataDic[csGameSettings.CurrentSelectedLevel], doanim: true);
	}

	public void TurnLeft()
	{
		if (PageIndex != 0)
		{
			PageIndex--;
			SetAllLevel();
		}
	}

	public void TurnRight()
	{
		if (PageIndex != 2)
		{
			PageIndex++;
			SetAllLevel();
		}
	}

	private void SetPageByIndex(int index)
	{
		PageIndex = index;
		SetAllLevel(isSetPage: true);
	}

	public void TryGetOpenLevelAward(int level)
	{
		csGameSettings.SetHintOn(isOn: true);
		m_LevelAward.SetAwards(level, delegate
		{
			SetAllLevel();
			csGameSettings.SetHintOn(isOn: false);
		});
		m_LevelAward.Show(isShow: true);
	}

	public void SetAllLevel(bool isSetPage = false)
	{
		for (int i = 0; i < LevelItemlist.Count; i++)
		{
			int num = i + 1 + 6 * PageIndex;
			if (num <= 15)
			{
				LevelItemlist[i].InitData(num, csPlayerData.PlayerLevelDataDic[num].StarsNum, !csPlayerData.PlayerLevelDataDic[num].isUnLock, csLevelData.instance.m_LevelInfoList.m_LevelInfoList[num - 1].m_UnLockType, csLevelData.instance.m_LevelInfoList.m_LevelInfoList[num - 1].UnLockParameter, LevelBkgList[num - 1]);
			}
			LevelItemlist[i].gameObject.SetActive(num <= 15);
			if (csGameSettings.CurrentSelectedLevel == num)
			{
				m_Group.SetSwitchObjByIndex(isSwitched: true, i);
			}
			else
			{
				m_Group.SetSwitchObjByIndex(isSwitched: false, i);
			}
		}
		m_LevelInfo.InitLevelInfo(csPlayerData.PlayerLevelDataDic[csGameSettings.CurrentSelectedLevel], isSetPage);
		LeftBtn.SetActive(PageIndex != 0);
		RightBtn.SetActive(PageIndex != 2);
		PageIndexText.text = PageIndex + 1 + "/" + 3;
	}
}
public class csLevelUpInfoUI : MonoBehaviour
{
	public csMainHorseShop HoreseShop;

	public GameObject body;

	public Image[] BasicStars;

	public Image[] SpecialStars;

	private bool isBasicGem;

	private bool isSpecialGem;

	public Sprite SpriteCoin;

	public Sprite SpriteGem;

	public Image[] BIconCoin;

	public TextMeshProUGUI[] BasicPriceTxtPro;

	public Image[] SIconCoin;

	public TextMeshProUGUI[] SpecialPriceTxtPro;

	public Button BasicBuyBtn;

	public GameObject[] basicBuyCountObj;

	public TextMeshProUGUI[] BasicBuyTxtPro;

	public Button SpecialBuyBtn;

	public GameObject[] specialBuyCountObj;

	public TextMeshProUGUI[] SpecialBuyTxtPro;

	public GameObject SpecialBar;

	private HorseType CurType;

	private int curBasicLevel;

	private int curSpeicalLevel;

	public void InitHorseLevel(HorseType hType)
	{
		CurType = hType;
		Image[] basicStars = BasicStars;
		for (int i = 0; i < basicStars.Length; i++)
		{
			basicStars[i].enabled = false;
		}
		basicStars = SpecialStars;
		for (int i = 0; i < basicStars.Length; i++)
		{
			basicStars[i].enabled = false;
		}
		curBasicLevel = csPlayerData.GetHorseBasicLevelInPlayerPrefs(hType);
		curSpeicalLevel = csPlayerData.GetHorseSpecialLevelInPlayerPrefs(hType);
		for (int j = 0; j < curBasicLevel; j++)
		{
			BasicStars[j].enabled = true;
		}
		for (int k = 0; k < curSpeicalLevel; k++)
		{
			SpecialStars[k].enabled = true;
		}
		if (curBasicLevel == 5)
		{
			BasicBuyBtn.interactable = false;
			basicBuyCountObj[0].SetActive(value: false);
			basicBuyCountObj[1].SetActive(value: false);
			TextMeshProUGUI[] basicBuyTxtPro = BasicBuyTxtPro;
			foreach (TextMeshProUGUI textMeshProUGUI in basicBuyTxtPro)
			{
				csLocalizationManager.Instance.CheckTextFontType(textMeshProUGUI);
				textMeshProUGUI.text = csLocalizationManager.Instance.GetLocalText("HorseShopMenu13");
			}
		}
		else
		{
			BasicBuyBtn.interactable = true;
			basicBuyCountObj[0].SetActive(value: true);
			basicBuyCountObj[1].SetActive(value: true);
			TextMeshProUGUI[] basicBuyTxtPro = BasicBuyTxtPro;
			for (int i = 0; i < basicBuyTxtPro.Length; i++)
			{
				basicBuyTxtPro[i].text = "";
			}
		}
		if (curSpeicalLevel == 5)
		{
			SpecialBuyBtn.interactable = false;
			specialBuyCountObj[0].SetActive(value: false);
			specialBuyCountObj[1].SetActive(value: false);
			TextMeshProUGUI[] basicBuyTxtPro = SpecialBuyTxtPro;
			foreach (TextMeshProUGUI textMeshProUGUI2 in basicBuyTxtPro)
			{
				csLocalizationManager.Instance.CheckTextFontType(textMeshProUGUI2);
				textMeshProUGUI2.text = csLocalizationManager.Instance.GetLocalText("HorseShopMenu13");
			}
		}
		else
		{
			SpecialBuyBtn.interactable = true;
			specialBuyCountObj[0].SetActive(value: true);
			specialBuyCountObj[1].SetActive(value: true);
			TextMeshProUGUI[] basicBuyTxtPro = SpecialBuyTxtPro;
			for (int i = 0; i < basicBuyTxtPro.Length; i++)
			{
				basicBuyTxtPro[i].text = "";
			}
		}
		int num = 0;
		if (curBasicLevel < 5)
		{
			num = csPlayerData.GetHorseInfo(hType).BasicPriceList[curBasicLevel];
		}
		int num2 = 0;
		if (curSpeicalLevel < 5)
		{
			num2 = csPlayerData.GetHorseInfo(hType).SpeicalPriceList[curSpeicalLevel];
			if (num2 == 0)
			{
				SpecialBar.SetActive(value: false);
			}
			else
			{
				SpecialBar.SetActive(value: true);
			}
		}
		isBasicGem = num < 0;
		isSpecialGem = num2 < 0;
		if (isBasicGem)
		{
			BIconCoin[0].overrideSprite = SpriteGem;
			BIconCoin[1].overrideSprite = SpriteGem;
		}
		else
		{
			BIconCoin[0].overrideSprite = SpriteCoin;
			BIconCoin[1].overrideSprite = SpriteCoin;
		}
		if (isSpecialGem)
		{
			SIconCoin[0].overrideSprite = SpriteGem;
			SIconCoin[1].overrideSprite = SpriteGem;
		}
		else
		{
			SIconCoin[0].overrideSprite = SpriteCoin;
			SIconCoin[1].overrideSprite = SpriteCoin;
		}
		TextMeshProUGUI obj = BasicPriceTxtPro[0];
		string text2 = (BasicPriceTxtPro[1].text = Mathf.Abs(num).ToString());
		obj.text = text2;
		TextMeshProUGUI obj2 = SpecialPriceTxtPro[0];
		text2 = (SpecialPriceTxtPro[1].text = Mathf.Abs(num2).ToString());
		obj2.text = text2;
	}

	public void BuyBasic()
	{
		int num = csPlayerData.GetHorseInfo(CurType).BasicPriceList[curBasicLevel];
		isBasicGem = num < 0;
		if ((isBasicGem ? csPlayerData.PlayerDiamond : csPlayerData.PlayerCoin) > Mathf.Abs(num))
		{
			if (curBasicLevel >= 5)
			{
				return;
			}
			if (isBasicGem)
			{
				csPlayerData.PlayerDiamond -= Mathf.Abs(num);
				HoreseShop.RefreshCoinAfterPurchase(2);
			}
			else
			{
				csPlayerData.PlayerCoin -= Mathf.Abs(num);
				HoreseShop.RefreshCoinAfterPurchase(1);
			}
			HoreseShop.RefreshCoin();
			curBasicLevel++;
			csMainSceneManager.instance.DoLevelUpOnHorseItem();
			for (int i = 0; i < curBasicLevel; i++)
			{
				BasicStars[i].enabled = true;
			}
			csPlayerData.SetHorseBasicLevelInPlayerPrefs(CurType, curBasicLevel);
			if (curBasicLevel == 5)
			{
				BasicBuyBtn.interactable = false;
				TextMeshProUGUI[] basicBuyTxtPro = BasicBuyTxtPro;
				for (int j = 0; j < basicBuyTxtPro.Length; j++)
				{
					basicBuyTxtPro[j].text = "";
				}
			}
			else
			{
				BasicBuyBtn.interactable = true;
				TextMeshProUGUI[] basicBuyTxtPro = BasicBuyTxtPro;
				foreach (TextMeshProUGUI textMeshProUGUI in basicBuyTxtPro)
				{
					csLocalizationManager.Instance.CheckTextFontType(textMeshProUGUI);
					textMeshProUGUI.text = csLocalizationManager.Instance.GetLocalText("HorseShopMenu07");
				}
				num = csPlayerData.GetHorseInfo(CurType).BasicPriceList[curBasicLevel];
				isBasicGem = num < 0;
				if (isBasicGem)
				{
					BIconCoin[0].overrideSprite = SpriteGem;
				}
				else
				{
					BIconCoin[1].overrideSprite = SpriteCoin;
				}
			}
			TextMeshProUGUI obj = BasicPriceTxtPro[0];
			string text2 = (BasicPriceTxtPro[1].text = Mathf.Abs(num).ToString());
			obj.text = text2;
			BasicBuyBtn.OnDeselect(new PointerEventData(EventSystem.current));
			csMainSceneAudioPlayer.instance.PlayAudio2D("LevelUp");
			HoreseShop.RefreshHorseInfo(CurType);
		}
		else if (isBasicGem)
		{
			csMainMenuCanvas.instance.PopHintM.ShowHint(csLocalizationManager.Instance.GetLocalText("PopHint05"));
		}
		else
		{
			csMainMenuCanvas.instance.MsgPanel.SetMsg("", csLocalizationManager.Instance.GetLocalText("PopHint02"));
			csMainMenuCanvas.instance.MsgPanel.ShowHint(delegate
			{
				csMainMenuCanvas.instance.OpenMenu(MainMenuType.PropShop, "CoinShop");
			}, null);
		}
	}

	public void BuySpecial()
	{
		int num = csPlayerData.GetHorseInfo(CurType).SpeicalPriceList[curSpeicalLevel];
		isSpecialGem = num < 0;
		if ((isSpecialGem ? csPlayerData.PlayerDiamond : csPlayerData.PlayerCoin) > Mathf.Abs(num))
		{
			if (curSpeicalLevel >= 5)
			{
				return;
			}
			if (isSpecialGem)
			{
				csPlayerData.PlayerDiamond -= Mathf.Abs(num);
				HoreseShop.RefreshCoinAfterPurchase(2);
			}
			else
			{
				csPlayerData.PlayerCoin -= Mathf.Abs(num);
				HoreseShop.RefreshCoinAfterPurchase(1);
			}
			HoreseShop.RefreshCoin();
			curSpeicalLevel++;
			csMainSceneManager.instance.DoLevelUpOnHorseItem();
			for (int i = 0; i < curSpeicalLevel; i++)
			{
				SpecialStars[i].enabled = true;
			}
			csPlayerData.SetHorseSpecialLevelInPlayerPrefs(CurType, curSpeicalLevel);
			if (curSpeicalLevel == 5)
			{
				SpecialBuyBtn.interactable = false;
				TextMeshProUGUI[] specialBuyTxtPro = SpecialBuyTxtPro;
				foreach (TextMeshProUGUI textMeshProUGUI in specialBuyTxtPro)
				{
					csLocalizationManager.Instance.CheckTextFontType(textMeshProUGUI);
					textMeshProUGUI.text = csLocalizationManager.Instance.GetLocalText("HorseShopMenu13");
				}
			}
			else
			{
				SpecialBuyBtn.interactable = true;
				TextMeshProUGUI[] specialBuyTxtPro = SpecialBuyTxtPro;
				foreach (TextMeshProUGUI textMeshProUGUI2 in specialBuyTxtPro)
				{
					csLocalizationManager.Instance.CheckTextFontType(textMeshProUGUI2);
					textMeshProUGUI2.text = csLocalizationManager.Instance.GetLocalText("HorseShopMenu07");
				}
			}
			if (curSpeicalLevel < 5)
			{
				num = csPlayerData.GetHorseInfo(CurType).SpeicalPriceList[curSpeicalLevel];
			}
			isSpecialGem = num < 0;
			if (isSpecialGem)
			{
				SIconCoin[0].overrideSprite = SpriteGem;
				SIconCoin[1].overrideSprite = SpriteGem;
			}
			else
			{
				SIconCoin[0].overrideSprite = SpriteCoin;
				SIconCoin[1].overrideSprite = SpriteCoin;
			}
			TextMeshProUGUI obj = SpecialPriceTxtPro[0];
			string text2 = (SpecialPriceTxtPro[1].text = Mathf.Abs(num).ToString());
			obj.text = text2;
			SpecialBuyBtn.OnDeselect(new PointerEventData(EventSystem.current));
			csMainSceneAudioPlayer.instance.PlayAudio2D("LevelUp");
			HoreseShop.RefreshHorseInfo(CurType);
		}
		else if (isSpecialGem)
		{
			csMainMenuCanvas.instance.PopHintM.ShowHint(csLocalizationManager.Instance.GetLocalText("PopHint05"));
		}
		else
		{
			csMainMenuCanvas.instance.MsgPanel.SetMsg("", csLocalizationManager.Instance.GetLocalText("PopHint02"));
			csMainMenuCanvas.instance.MsgPanel.ShowHint(delegate
			{
				csMainMenuCanvas.instance.OpenMenu(MainMenuType.PropShop, "CoinShop");
			}, null);
		}
	}

	public void HidePanel()
	{
		body.SetActive(value: false);
	}

	public void ShowPanel()
	{
		body.SetActive(value: true);
	}
}
public class csMountInfoUI : MonoBehaviour
{
	public bool isMainInfo = true;

	public csButtonSelect BasicBuyActionBtn;

	public csAbilityPopHint AbilityHint;

	public TextMeshProUGUI NameTextPro;

	public GameObject NextLevelHintObj;

	public TextMeshProUGUI SteeringSpeedTextPro;

	public TextMeshProUGUI SteeringSpeedNextTextPro;

	public TextMeshProUGUI CoinBonusTextPro;

	public TextMeshProUGUI CoinBonusNextTextPro;

	public TextMeshProUGUI ScoreBonusTextPro;

	public TextMeshProUGUI ScoreBonusNextTextPro;

	public Image[] HeartBKG;

	public Image[] HeartInner;

	public Image HeadIcon;

	public TextMeshProUGUI StoryTextPro;

	public csStarsGroup starsGroup;

	public Sprite[] HeadSprites;

	public Sprite S_SkillSprint;

	public Sprite S_SkillInvincible;

	public Sprite S_SkillSlow;

	public Sprite S_SkillAnticol;

	public Sprite S_SkillJump;

	public Sprite S_SkillShieldBuff;

	public Sprite S_SkillRoar;

	public Sprite S_SkillFly;

	public Sprite S_SkillStrike;

	public Sprite S_PropShield;

	public Sprite S_PropRushPower;

	public Sprite S_PropMag;

	public HorseType curHorseType;

	private HorseData CurHorseData;

	public int horseBasicLevel;

	public int horseSpecLevel;

	public List<csSkillBuffBtn> SkillBuffBtns = new List<csSkillBuffBtn>();

	public TextMeshProUGUI TextNoSkillPro;

	public GameObject SkillHint;

	private bool ShowNextHP;

	private string TempNameID;

	private string TempStoryID;

	private void Awake()
	{
		if (!isMainInfo)
		{
			csButtonSelect basicBuyActionBtn = BasicBuyActionBtn;
			basicBuyActionBtn.onBtnEnterAct = (UnityAction)Delegate.Combine(basicBuyActionBtn.onBtnEnterAct, (UnityAction)delegate
			{
				ShowNextLevelHint(isShow: true);
			});
			csButtonSelect basicBuyActionBtn2 = BasicBuyActionBtn;
			basicBuyActionBtn2.onBtnExitAct = (UnityAction)Delegate.Combine(basicBuyActionBtn2.onBtnExitAct, (UnityAction)delegate
			{
				ShowNextLevelHint(isShow: false);
			});
		}
		if (!isMainInfo)
		{
			ShowNextLevelHint(isShow: false);
		}
		TextNoSkillPro.enabled = false;
	}

	public void RefreshUI(csHorseInfo info, HorseType ht)
	{
		curHorseType = ht;
		CurHorseData = csGameData.Instance.HorseTypeToDataDic[curHorseType];
		horseBasicLevel = csPlayerData.GetHorseBasicLevelInPlayerPrefs(curHorseType);
		horseSpecLevel = csPlayerData.GetHorseSpecialLevelInPlayerPrefs(curHorseType);
		starsGroup.SetStars(info.StarNum);
		if ((bool)HeadIcon)
		{
			HeadIcon.sprite = HeadSprites[(int)ht];
		}
		TempNameID = info.Name;
		SteeringSpeedTextPro.text = info.SteeringSpeed + "s";
		TempStoryID = info.StoryContent;
		RefreshText();
		SetBasicData();
	}

	private void RefreshText()
	{
		if (!string.IsNullOrEmpty(TempStoryID))
		{
			csLocalizationManager.Instance.CheckTextFontType(StoryTextPro);
			StoryTextPro.text = csLocalizationManager.Instance.GetLocalText(TempStoryID);
		}
		if (!string.IsNullOrEmpty(TempNameID))
		{
			csLocalizationManager.Instance.CheckTextFontType(NameTextPro);
			NameTextPro.text = csLocalizationManager.Instance.GetLocalText(TempNameID);
		}
	}

	private void Start()
	{
		csLocalizationManager.updateLocalText = (Action)Delegate.Combine(csLocalizationManager.updateLocalText, new Action(RefreshText));
	}

	private void OnDestroy()
	{
		if (!isMainInfo)
		{
			csButtonSelect basicBuyActionBtn = BasicBuyActionBtn;
			basicBuyActionBtn.onBtnEnterAct = (UnityAction)Delegate.Remove(basicBuyActionBtn.onBtnEnterAct, (UnityAction)delegate
			{
				ShowNextLevelHint(isShow: true);
			});
			csButtonSelect basicBuyActionBtn2 = BasicBuyActionBtn;
			basicBuyActionBtn2.onBtnExitAct = (UnityAction)Delegate.Remove(basicBuyActionBtn2.onBtnExitAct, (UnityAction)delegate
			{
				ShowNextLevelHint(isShow: false);
			});
		}
		csLocalizationManager.updateLocalText = (Action)Delegate.Remove(csLocalizationManager.updateLocalText, new Action(RefreshText));
	}

	private void SetBasicData()
	{
		Image[] heartInner = HeartInner;
		for (int k = 0; k < heartInner.Length; k++)
		{
			heartInner[k].enabled = false;
		}
		heartInner = HeartBKG;
		for (int k = 0; k < heartInner.Length; k++)
		{
			heartInner[k].enabled = false;
		}
		for (int l = 0; l < CurHorseData.BasicDataByLevel[5].LifeMax; l++)
		{
			HeartBKG[l].enabled = true;
		}
		for (int m = 0; m < CurHorseData.BasicDataByLevel[horseBasicLevel].LifeMax; m++)
		{
			HeartInner[m].color = Color.white;
			HeartInner[m].enabled = true;
		}
		SteeringSpeedTextPro.text = $"{CurHorseData.BasicDataByLevel[horseBasicLevel].SteerSpeed * 10f:N2}" + " Gs";
		CoinBonusTextPro.text = (int)(CurHorseData.BasicDataByLevel[horseBasicLevel].GoldMultiplier * 100f) + "%";
		ScoreBonusTextPro.text = (int)(CurHorseData.BasicDataByLevel[horseBasicLevel].GoldMultiplier * 100f) + "%";
		if (!isMainInfo && horseBasicLevel < 5)
		{
			SteeringSpeedNextTextPro.text = $"{CurHorseData.BasicDataByLevel[horseBasicLevel + 1].SteerSpeed * 10f:N2}" + " Gs";
			CoinBonusNextTextPro.text = (int)(CurHorseData.BasicDataByLevel[horseBasicLevel + 1].GoldMultiplier * 100f) + "%";
			ScoreBonusNextTextPro.text = (int)(CurHorseData.BasicDataByLevel[horseBasicLevel + 1].GoldMultiplier * 100f) + "%";
			if (CurHorseData.BasicDataByLevel[horseBasicLevel + 1].LifeMax - CurHorseData.BasicDataByLevel[horseBasicLevel].LifeMax > 0)
			{
				ShowNextHP = true;
			}
		}
		if ((bool)SkillHint)
		{
			SkillHint.SetActive(value: false);
		}
		if (CurHorseData.SkillDataByLevel[5].EffectItemIDList.Count == 0 && CurHorseData.SkillDataByLevel[5].EffectSkillIDList.Count == 0)
		{
			foreach (csSkillBuffBtn skillBuffBtn in SkillBuffBtns)
			{
				skillBuffBtn.ThisG.SetActive(value: false);
			}
			TextNoSkillPro.enabled = true;
			return;
		}
		TextNoSkillPro.enabled = false;
		int num = 0;
		foreach (csSkillBuffBtn skillBuffBtn2 in SkillBuffBtns)
		{
			skillBuffBtn2.ThisG.SetActive(value: false);
		}
		bool flag = false;
		for (int n = 0; n < CurHorseData.SkillDataByLevel[5].EffectSkillIDList.Count; n++)
		{
			SkillBuffBtns[num].ThisG.SetActive(value: true);
			SkillBuffBtns[num].SetSkillBuff(isSkill: true, (int)CurHorseData.SkillDataByLevel[5].EffectSkillIDList[n]);
			switch (CurHorseData.SkillDataByLevel[5].EffectSkillIDList[n])
			{
			case HorseSkill.Fly:
				flag = true;
				break;
			case HorseSkill.Invincible:
				flag = true;
				break;
			case HorseSkill.Jump:
				flag = true;
				break;
			case HorseSkill.Roar:
				flag = true;
				break;
			case HorseSkill.Slow:
				flag = true;
				break;
			case HorseSkill.Sprint:
				flag = true;
				break;
			}
			num++;
		}
		if (flag && (bool)SkillHint)
		{
			SkillHint.SetActive(value: true);
		}
		for (int num2 = 0; num2 < CurHorseData.SkillDataByLevel[5].EffectItemIDList.Count; num2++)
		{
			SkillBuffBtns[num].ThisG.SetActive(value: true);
			SkillBuffBtns[num].SetSkillBuff(isSkill: false, (int)CurHorseData.SkillDataByLevel[5].EffectItemIDList[num2]);
			num++;
		}
		int j;
		for (j = 0; j < CurHorseData.SkillDataByLevel[horseSpecLevel].EffectSkillIDList.Count; j++)
		{
			SkillBuffBtns.Find((csSkillBuffBtn x) => x.m_SkillType == CurHorseData.SkillDataByLevel[horseSpecLevel].EffectSkillIDList[j]).SetSkillOn(isOn: true);
		}
		int i;
		for (i = 0; i < CurHorseData.SkillDataByLevel[horseSpecLevel].EffectItemIDList.Count; i++)
		{
			SkillBuffBtns.Find((csSkillBuffBtn x) => x.m_PropType == CurHorseData.SkillDataByLevel[horseSpecLevel].EffectItemIDList[i]).SetSkillOn(isOn: true);
		}
	}

	public void SetPopHint(Sprite s, bool isSkill, int ID)
	{
		string title = "标题";
		string text = "技能说明";
		if (isSkill)
		{
			HorseSkill horseSkill = (HorseSkill)ID;
			title = csLocalizationManager.Instance.GetLocalText("Skill" + ID);
			text = csLocalizationManager.Instance.GetLocalText("Skill" + ID + "Des");
			switch (horseSkill)
			{
			case HorseSkill.Anticol:
				text = string.Format(text, "<color=#ff0000ff>" + CurHorseData.SkillDataByLevel[horseSpecLevel].SkillCDFactor * csGameData.Instance.SkillTypeToDataDic[horseSkill].LevelData[horseSpecLevel].CDTime + "</color>");
				break;
			case HorseSkill.Fly:
				text = string.Format(text, "<color=#ff0000ff>" + CurHorseData.SkillDataByLevel[horseSpecLevel].SkillTimeFactor * csGameData.Instance.SkillTypeToDataDic[horseSkill].LevelData[horseSpecLevel].EffectTime + "</color>", "<color=#ff0000ff>" + CurHorseData.SkillDataByLevel[horseSpecLevel].SkillCDFactor * csGameData.Instance.SkillTypeToDataDic[horseSkill].LevelData[horseSpecLevel].CDTime + "</color>");
				break;
			case HorseSkill.Invincible:
				text = string.Format(text, "<color=#ff0000ff>" + CurHorseData.SkillDataByLevel[horseSpecLevel].SkillTimeFactor * csGameData.Instance.SkillTypeToDataDic[horseSkill].LevelData[horseSpecLevel].EffectTime + "</color>", "<color=#ff0000ff>" + CurHorseData.SkillDataByLevel[horseSpecLevel].SkillCDFactor * csGameData.Instance.SkillTypeToDataDic[horseSkill].LevelData[horseSpecLevel].CDTime + "</color>");
				break;
			case HorseSkill.Jump:
				text = string.Format(text, "<color=#ff0000ff>" + CurHorseData.SkillDataByLevel[horseSpecLevel].SkillCDFactor * csGameData.Instance.SkillTypeToDataDic[horseSkill].LevelData[horseSpecLevel].CDTime + "</color>");
				break;
			case HorseSkill.Roar:
				text = string.Format(text, "<color=#ff0000ff>" + CurHorseData.SkillDataByLevel[horseSpecLevel].SkillCDFactor * csGameData.Instance.SkillTypeToDataDic[horseSkill].LevelData[horseSpecLevel].CDTime + "</color>");
				break;
			case HorseSkill.Slow:
				text = string.Format(text, "<color=#ff0000ff>" + CurHorseData.SkillDataByLevel[horseSpecLevel].SkillTimeFactor * csGameData.Instance.SkillTypeToDataDic[horseSkill].LevelData[horseSpecLevel].EffectTime + "</color>", "<color=#ff0000ff>" + CurHorseData.SkillDataByLevel[horseSpecLevel].SkillCDFactor * csGameData.Instance.SkillTypeToDataDic[horseSkill].LevelData[horseSpecLevel].CDTime + "</color>");
				break;
			case HorseSkill.Sprint:
				text = string.Format(text, "<color=#ff0000ff>" + CurHorseData.SkillDataByLevel[horseSpecLevel].SkillTimeFactor * csGameData.Instance.SkillTypeToDataDic[horseSkill].LevelData[horseSpecLevel].EffectTime + "</color>", "<color=#ff0000ff>" + CurHorseData.SkillDataByLevel[horseSpecLevel].SkillCDFactor * csGameData.Instance.SkillTypeToDataDic[horseSkill].LevelData[horseSpecLevel].CDTime + "</color>");
				break;
			case HorseSkill.Strike:
				text = string.Format(text, "<color=#ff0000ff>" + CurHorseData.SkillDataByLevel[horseSpecLevel].SkillCDFactor * csGameData.Instance.SkillTypeToDataDic[horseSkill].LevelData[horseSpecLevel].CDTime + "</color>");
				break;
			}
		}
		else
		{
			switch ((PreObjectType)ID)
			{
			case PreObjectType.Magnet:
				title = csLocalizationManager.Instance.GetLocalText("Prop03Tit");
				text = csLocalizationManager.Instance.GetLocalText("Prop03Des");
				text = string.Format(text, "<color=#ff0000ff>" + csGameSettings.MagTime * CurHorseData.SkillDataByLevel[horseSpecLevel].ItemTimeFactor + "</color>");
				break;
			case PreObjectType.Sheild:
				title = csLocalizationManager.Instance.GetLocalText("Prop02Tit");
				text = csLocalizationManager.Instance.GetLocalText("Prop02Des");
				text = string.Format(text, "<color=#ff0000ff>" + csGameSettings.SheildTime * CurHorseData.SkillDataByLevel[horseSpecLevel].ItemTimeFactor + "</color>");
				break;
			case PreObjectType.RushPower:
				title = csLocalizationManager.Instance.GetLocalText("Prop01Tit");
				text = csLocalizationManager.Instance.GetLocalText("Prop01Des");
				text = string.Format(text, "<color=#ff0000ff>" + csGameSettings.RushTime * CurHorseData.SkillDataByLevel[horseSpecLevel].ItemTimeFactor + "</color>");
				break;
			}
		}
		AbilityHint.SetAbilityHint(s, title, text, horseSpecLevel);
	}

	public void TryShowPopHint(bool isShow)
	{
		if (isShow)
		{
			AbilityHint.PopShowHint(isShow: true);
		}
		else
		{
			AbilityHint.PopShowHint(isShow: false);
		}
	}

	public void ShowNextLevelHint(bool isShow)
	{
		if (isShow)
		{
			NextLevelHintObj.SetActive(value: true);
			if (ShowNextHP)
			{
				HeartInner[CurHorseData.BasicDataByLevel[horseBasicLevel].LifeMax].color = Color.green;
				HeartInner[CurHorseData.BasicDataByLevel[horseBasicLevel].LifeMax].enabled = true;
			}
		}
		else
		{
			NextLevelHintObj.SetActive(value: false);
			if (ShowNextHP)
			{
				HeartInner[CurHorseData.BasicDataByLevel[horseBasicLevel].LifeMax].color = Color.white;
				HeartInner[CurHorseData.BasicDataByLevel[horseBasicLevel].LifeMax].enabled = false;
			}
		}
	}

	public void HidePanel()
	{
		base.gameObject.SetActive(value: false);
	}

	public void ShowPanel()
	{
		base.gameObject.SetActive(value: true);
	}
}
public class csObjectPlayClip : MonoBehaviour
{
	public string clipName;

	public void PlayPressSound()
	{
		if (clipName == "")
		{
			UnityEngine.Debug.Log("Your Clip name is null");
		}
		else if ((bool)csMainSceneAudioPlayer.instance)
		{
			csMainSceneAudioPlayer.instance.PlayAudio2D(clipName);
		}
	}
}
public class csPropItemInMenu : MonoBehaviour
{
	public Image PropIcon;

	public TextMeshProUGUI PropText;

	public GameObject ChangePropObj;

	public Button AddBtn;

	public void SetChangeProp(bool isOn)
	{
		AddBtn.interactable = !isOn;
		ChangePropObj.SetActive(isOn);
	}

	public void SetPropUI(string str, Sprite icon, bool ChangeIsOn)
	{
		csLocalizationManager.Instance.CheckTextFontType(PropText);
		PropText.text = str;
		PropIcon.sprite = icon;
		SetChangeProp(ChangeIsOn);
	}
}
public class csSkillBuffBtn : MonoBehaviour
{
	public csMountInfoUI MountUI;

	public GameObject ThisG;

	public Button m_btn;

	public HorseSkill m_SkillType;

	public PreObjectType m_PropType;

	public TextMeshProUGUI LvTxtPro;

	public Image InnerImg;

	private CanvasGroup ThisCanvasG;

	public UnityAction onBtnEnterAct;

	public UnityAction onBtnExitAct;

	public bool IsBuffSkill;

	private void Awake()
	{
		m_btn = GetComponent<Button>();
		EventTriggerListener.GetListener(m_btn.gameObject).onPointerEnter = OnMouseEnter;
		EventTriggerListener.GetListener(m_btn.gameObject).onPointerExit = OnMouseExit;
		ThisG = base.gameObject;
		InnerImg = base.transform.GetChild(0).GetComponent<Image>();
		ThisCanvasG = GetComponent<CanvasGroup>();
	}

	private void OnMouseEnter(GameObject go)
	{
		if (m_btn.interactable)
		{
			m_btn.OnPointerEnter(new PointerEventData(EventSystem.current));
			ShowBuffHint();
			onBtnEnterAct?.Invoke();
		}
	}

	private void OnMouseExit(GameObject go)
	{
		m_btn.OnPointerExit(new PointerEventData(EventSystem.current));
		m_btn.OnDeselect(new PointerEventData(EventSystem.current));
		HideBuffHint();
		onBtnExitAct?.Invoke();
	}

	public void ShowBuffHint()
	{
		MountUI.SetPopHint(InnerImg.overrideSprite, IsBuffSkill, IsBuffSkill ? ((int)m_SkillType) : ((int)m_PropType));
		MountUI.TryShowPopHint(isShow: true);
	}

	public void HideBuffHint()
	{
		MountUI.TryShowPopHint(isShow: false);
	}

	public void SetSkillBuff(bool isSkill, int ID)
	{
		ThisCanvasG.alpha = 0.2f;
		LvTxtPro.text = "Lv." + MountUI.horseSpecLevel;
		IsBuffSkill = isSkill;
		if (isSkill)
		{
			m_SkillType = (HorseSkill)ID;
			m_PropType = PreObjectType.GoldCoin;
			switch (m_SkillType)
			{
			case HorseSkill.Anticol:
				InnerImg.overrideSprite = MountUI.S_SkillAnticol;
				break;
			case HorseSkill.Fly:
				InnerImg.overrideSprite = MountUI.S_SkillFly;
				break;
			case HorseSkill.Invincible:
				InnerImg.overrideSprite = MountUI.S_SkillInvincible;
				break;
			case HorseSkill.Jump:
				InnerImg.overrideSprite = MountUI.S_SkillJump;
				break;
			case HorseSkill.Roar:
				InnerImg.overrideSprite = MountUI.S_SkillRoar;
				break;
			case HorseSkill.ShieldBuff:
				InnerImg.overrideSprite = MountUI.S_SkillShieldBuff;
				break;
			case HorseSkill.Slow:
				InnerImg.overrideSprite = MountUI.S_SkillSlow;
				break;
			case HorseSkill.Sprint:
				InnerImg.overrideSprite = MountUI.S_SkillSprint;
				break;
			case HorseSkill.Strike:
				InnerImg.overrideSprite = MountUI.S_SkillStrike;
				break;
			case HorseSkill.None:
				break;
			}
		}
		else
		{
			m_PropType = (PreObjectType)ID;
			m_SkillType = HorseSkill.None;
			switch (m_PropType)
			{
			case PreObjectType.Sheild:
				InnerImg.overrideSprite = MountUI.S_PropShield;
				break;
			case PreObjectType.RushPower:
				InnerImg.overrideSprite = MountUI.S_PropRushPower;
				break;
			case PreObjectType.Magnet:
				InnerImg.overrideSprite = MountUI.S_PropMag;
				break;
			}
		}
	}

	public void SetSkillOn(bool isOn)
	{
		if (isOn)
		{
			ThisCanvasG.alpha = 1f;
		}
	}
}
public class csStarsGroup : MonoBehaviour
{
	public GameObject[] wholeStars;

	public GameObject halfStar;

	public HorizontalLayoutGroup layout;

	public float[] spacingValues;

	public void SetStars(int level)
	{
		int num = level / 2;
		int num2 = level % 2;
		int num3 = num;
		if (num2 > 0)
		{
			halfStar.SetActive(value: true);
			num3++;
		}
		else
		{
			halfStar.SetActive(value: false);
		}
		for (int i = 0; i < wholeStars.Length; i++)
		{
			if (i < num)
			{
				wholeStars[i].SetActive(value: true);
			}
			else
			{
				wholeStars[i].SetActive(value: false);
			}
		}
	}

	private void SetLayout(int count)
	{
		if (count > 0)
		{
			layout.spacing = spacingValues[count - 1];
		}
	}
}
public class EventTriggerListener : EventTrigger
{
	public delegate void UIDelegate(GameObject go);

	public UIDelegate onPointerEnter;

	public UIDelegate onPointerExit;

	public UIDelegate onPointerDown;

	public UIDelegate onPointerUp;

	public UIDelegate onPointerClick;

	public UIDelegate onInitializePotentialDrag;

	public UIDelegate onBeginDrag;

	public UIDelegate onDrag;

	public UIDelegate onEndDrag;

	public UIDelegate onDrop;

	public UIDelegate onScroll;

	public UIDelegate onUpdateSelected;

	public UIDelegate onSelect;

	public UIDelegate onDeselect;

	public UIDelegate onMove;

	public UIDelegate onSubmit;

	public UIDelegate onCancel;

	public static EventTriggerListener GetListener(GameObject go)
	{
		EventTriggerListener eventTriggerListener = go.GetComponent<EventTriggerListener>();
		if (eventTriggerListener == null)
		{
			eventTriggerListener = go.AddComponent<EventTriggerListener>();
		}
		return eventTriggerListener;
	}

	public override void OnPointerEnter(PointerEventData eventData)
	{
		if (onPointerEnter != null)
		{
			onPointerEnter(base.gameObject);
		}
	}

	public override void OnPointerExit(PointerEventData eventData)
	{
		if (onPointerExit != null)
		{
			onPointerExit(base.gameObject);
		}
	}

	public override void OnPointerDown(PointerEventData eventData)
	{
		if (onPointerDown != null)
		{
			onPointerDown(base.gameObject);
		}
	}

	public override void OnPointerUp(PointerEventData eventData)
	{
		if (onPointerUp != null)
		{
			onPointerUp(base.gameObject);
		}
	}

	public override void OnPointerClick(PointerEventData eventData)
	{
		if (onPointerClick != null)
		{
			onPointerClick(base.gameObject);
		}
	}

	public override void OnInitializePotentialDrag(PointerEventData eventData)
	{
		if (onInitializePotentialDrag != null)
		{
			onInitializePotentialDrag(base.gameObject);
		}
	}

	public override void OnBeginDrag(PointerEventData eventData)
	{
		if (onBeginDrag != null)
		{
			onBeginDrag(base.gameObject);
		}
	}

	public override void OnDrag(PointerEventData eventData)
	{
		if (onDrag != null)
		{
			onDrag(base.gameObject);
		}
	}

	public override void OnEndDrag(PointerEventData eventData)
	{
		if (onEndDrag != null)
		{
			onEndDrag(base.gameObject);
		}
	}

	public override void OnDrop(PointerEventData eventData)
	{
		if (onDrop != null)
		{
			onDrop(base.gameObject);
		}
	}

	public override void OnScroll(PointerEventData eventData)
	{
		if (onScroll != null)
		{
			onScroll(base.gameObject);
		}
	}

	public override void OnUpdateSelected(BaseEventData eventData)
	{
		if (onUpdateSelected != null)
		{
			onUpdateSelected(base.gameObject);
		}
	}

	public override void OnSelect(BaseEventData eventData)
	{
		if (onSelect != null)
		{
			onSelect(base.gameObject);
		}
	}

	public override void OnDeselect(BaseEventData eventData)
	{
		if (onDeselect != null)
		{
			onDeselect(base.gameObject);
		}
	}

	public override void OnMove(AxisEventData eventData)
	{
		if (onMove != null)
		{
			onMove(base.gameObject);
		}
	}

	public override void OnSubmit(BaseEventData eventData)
	{
		if (onSubmit != null)
		{
			onSubmit(base.gameObject);
		}
	}

	public override void OnCancel(BaseEventData eventData)
	{
		if (onCancel != null)
		{
			onCancel(base.gameObject);
		}
	}
}
public class anim : MonoBehaviour
{
	private float DEFAULT_POWER = 0.8f;

	private float MIN_TIME = 3.5f;

	private float MAX_TIME = 4.5f;

	private MaterialPropertyBlock prop_;

	private float default_;

	private float a_;

	private void Start()
	{
		prop_ = new MaterialPropertyBlock();
		a_ = DEFAULT_POWER;
	}

	private void Update()
	{
		if (Time.time >= MIN_TIME && Time.time <= MAX_TIME)
		{
			float num = DEFAULT_POWER / (MAX_TIME - MIN_TIME);
			float num2 = Time.time - MIN_TIME;
			a_ -= num * num2;
		}
		prop_.Clear();
		prop_.SetFloat("_EdgePower", a_);
		base.gameObject.GetComponent<Renderer>().SetPropertyBlock(prop_);
	}
}
public class TestRotate : MonoBehaviour
{
	private void Awake()
	{
		UnityEngine.Debug.Log(Uri.EscapeDataString("fasdfasdfds"));
		UnityEngine.Debug.Log(Uri.EscapeDataString("fasdfa#sdfds"));
		UnityEngine.Debug.Log(Uri.EscapeDataString("fasdf'a#sdfds"));
		UnityEngine.Debug.Log(Uri.EscapeDataString("fasdf‘a#sdfds"));
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.Space))
		{
			base.transform.rotation = Quaternion.Euler(0f, 0f, 45f) * base.transform.rotation;
		}
	}
}
public class RandomColors : MonoBehaviour
{
	public float TimeSet;

	public float RandTime;

	private bool invertColor;

	private Renderer Mtl;

	public Color color_start;

	public Color color_end;

	public Color Result;

	public float duration = 2f;

	private void Start()
	{
		RandTime = UnityEngine.Random.Range(5, 10);
		Mtl = GetComponent<Renderer>();
	}

	private void Update()
	{
		TimeSet += Time.deltaTime;
		if (TimeSet >= RandTime)
		{
			if (!invertColor)
			{
				GetComponent<Collider>().enabled = true;
				Mtl.material.SetColor("_Color", color_end);
			}
			if (invertColor)
			{
				GetComponent<Collider>().enabled = false;
				Mtl.material.SetColor("_Color", color_start);
			}
			invertColor = !invertColor;
			TimeSet = 0f;
		}
	}
}
public class SoundInTact : MonoBehaviour
{
	public float BPMs;

	public float WantedSecs;

	public Color colorStart;

	public Color colorEnd;

	public Color Result;

	public float duration = 2f;

	public bool isToonShader;

	private void Start()
	{
	}

	private void Update()
	{
		float t = Mathf.PingPong(Time.time, BPMs) / BPMs;
		Result = Color.Lerp(colorStart, colorEnd, t);
		if (!isToonShader)
		{
			GetComponent<Renderer>().material.SetColor("_TintColor", Result);
		}
		if (isToonShader)
		{
			GetComponent<Renderer>().material.SetColor("_OutlineColor", Result);
		}
	}
}
public class RopeSett : MonoBehaviour
{
	public GameObject Rope;

	public LineRenderer LineRope;

	public GameObject[] ArrayPoint;

	public Vector3 AddForce;

	public AudioClip Sound;

	public bool OneForce;

	private void Start()
	{
		Rope.SetActive(value: true);
	}

	private void Update()
	{
		if (!(LineRope == null))
		{
			LineRope.SetPosition(0, ArrayPoint[0].transform.position);
			LineRope.SetPosition(1, ArrayPoint[1].transform.position);
			LineRope.SetPosition(2, ArrayPoint[2].transform.position);
			LineRope.SetPosition(3, ArrayPoint[3].transform.position);
			LineRope.SetPosition(4, ArrayPoint[4].transform.position);
			LineRope.SetPosition(5, ArrayPoint[5].transform.position);
			LineRope.SetPosition(6, ArrayPoint[6].transform.position);
			LineRope.SetPosition(7, ArrayPoint[7].transform.position);
			LineRope.SetPosition(8, ArrayPoint[8].transform.position);
			LineRope.SetPosition(9, ArrayPoint[9].transform.position);
			LineRope.SetPosition(10, ArrayPoint[10].transform.position);
		}
	}
}
[ExecuteInEditMode]
[RequireComponent(typeof(MeshFilter))]
[RequireComponent(typeof(MeshRenderer))]
public class VolumetricFog : MonoBehaviour
{
	public enum ShapeType
	{
		Cube,
		Cylinder
	}

	public enum FogMode
	{
		Exp,
		Linear
	}

	public enum FadeMode
	{
		Smooth,
		Linear
	}

	public enum ViewMode
	{
		FirstPerson,
		ThirdPerson
	}

	private const string FirstPersonFogShader = "Hidden/J3Tech/Volumetric Fog/First Person Volumetric Fog";

	private const string FirstPersonFogCullOffShader = "Hidden/J3Tech/Volumetric Fog/First Person Volumetric Fog Cull Off";

	private const string ThirdPersonFogShader = "Hidden/J3Tech/Volumetric Fog/Third Person Volumetric Fog";

	public ShapeType Type;

	public float Visibility = 10f;

	public Color FogColor = new Color(1f, 1f, 1f, 1f);

	public FogMode Mode;

	public Vector3 Size = Vector3.one * 50f;

	public float StartFade;

	public float EndFade = 1f;

	public FadeMode Fade;

	public ViewMode View;

	public Transform ThirdPerson;

	public bool CullOff = true;

	private Vector3 _vectorOne = Vector3.one;

	private Transform _transform;

	private Material _material;

	public Material Mat
	{
		get
		{
			if (!_material)
			{
				_material = new Material(Shader.Find((View != 0) ? "Hidden/J3Tech/Volumetric Fog/Third Person Volumetric Fog" : (CullOff ? "Hidden/J3Tech/Volumetric Fog/First Person Volumetric Fog Cull Off" : "Hidden/J3Tech/Volumetric Fog/First Person Volumetric Fog")));
			}
			return _material;
		}
		set
		{
			_material = value;
		}
	}

	[Conditional("UNITY_EDITOR")]
	private void ResetScale()
	{
		if (!_transform)
		{
			_transform = base.transform;
		}
		if (_transform.lossyScale != _vectorOne)
		{
			_transform.localScale = new Vector3(_transform.localScale.x / _transform.lossyScale.x, _transform.localScale.y / _transform.lossyScale.y, _transform.localScale.y / _transform.lossyScale.y);
		}
	}

	private void Start()
	{
		GetComponent<Renderer>();
		_transform = base.transform;
		UpdateVolumetricFog();
	}

	private void Update()
	{
		if (View == ViewMode.ThirdPerson && (bool)ThirdPerson)
		{
			_material.SetVector("_Center", ThirdPerson.position);
		}
	}

	public Mesh CreateMesh()
	{
		return Type switch
		{
			ShapeType.Cube => Cube.GetMesh(Size), 
			ShapeType.Cylinder => Cylinder.GetMesh(Size), 
			_ => Cube.GetMesh(Size), 
		};
	}

	public void UpdateMesh()
	{
		MeshFilter component = GetComponent<MeshFilter>();
		if ((bool)component)
		{
			Vector3 vector = Size * 0.5f;
			component.sharedMesh = CreateMesh();
			Bounds bounds = default(Bounds);
			bounds.SetMinMax(-vector, vector);
			component.sharedMesh.bounds = bounds;
		}
	}

	public void UpdateMaterial()
	{
		Renderer component = GetComponent<Renderer>();
		if ((bool)component)
		{
			Mat.shader = Shader.Find((View != 0) ? "Hidden/J3Tech/Volumetric Fog/Third Person Volumetric Fog" : (CullOff ? "Hidden/J3Tech/Volumetric Fog/First Person Volumetric Fog Cull Off" : "Hidden/J3Tech/Volumetric Fog/First Person Volumetric Fog"));
			Mat.SetFloat("_Visibility", Visibility);
			Mat.SetColor("_Color", FogColor);
			float num = Size.y * 0.5f;
			Mat.SetFloat("_Start", Mathf.Clamp(StartFade * Size.y - num, 0f - num, num));
			Mat.SetFloat("_End", Mathf.Clamp(EndFade * Size.y - num, 0f - num, num));
			Mat.SetVector("_Size", Size * 0.5f);
			if (Mode == FogMode.Exp)
			{
				Mat.EnableKeyword("EXP");
				Mat.DisableKeyword("LINEAR");
			}
			else
			{
				Mat.EnableKeyword("LINEAR");
				Mat.DisableKeyword("EXP");
			}
			if (Type == ShapeType.Cube)
			{
				Mat.EnableKeyword("CUBE");
				Mat.DisableKeyword("CYLINDER");
			}
			else
			{
				Mat.EnableKeyword("CYLINDER");
				Mat.DisableKeyword("CUBE");
			}
			if (Fade == FadeMode.Smooth)
			{
				Mat.EnableKeyword("SMOOTH_FADE");
				Mat.DisableKeyword("LINEAR_FADE");
			}
			else
			{
				Mat.EnableKeyword("LINEAR_FADE");
				Mat.DisableKeyword("SMOOTH_FADE");
			}
			component.material = Mat;
		}
	}

	public void UpdateVolumetricFog()
	{
		UpdateMesh();
		UpdateMaterial();
	}

	public void AddCamera(Camera cam)
	{
		cam.depthTextureMode |= DepthTextureMode.Depth;
	}

	private void OnWillRenderObject()
	{
		if (Camera.current.depthTextureMode == DepthTextureMode.None)
		{
			Camera.current.depthTextureMode |= DepthTextureMode.Depth;
		}
	}
}
public static class Cube
{
	private static readonly Vector3[] _verts = new Vector3[8]
	{
		new Vector3(-0.5f, -0.5f, -0.5f),
		new Vector3(0.5f, -0.5f, -0.5f),
		new Vector3(0.5f, 0.5f, -0.5f),
		new Vector3(0.5f, -0.5f, 0.5f),
		new Vector3(0.5f, 0.5f, 0.5f),
		new Vector3(-0.5f, 0.5f, -0.5f),
		new Vector3(-0.5f, 0.5f, 0.5f),
		new Vector3(-0.5f, -0.5f, 0.5f)
	};

	private static readonly int[] _indices = new int[36]
	{
		0, 2, 1, 0, 5, 2, 3, 6, 7, 3,
		4, 6, 1, 4, 3, 1, 2, 4, 7, 5,
		0, 7, 6, 5, 7, 1, 3, 7, 0, 1,
		5, 4, 2, 5, 6, 4
	};

	public static Mesh GetMesh(Vector3 scale)
	{
		Mesh mesh = new Mesh();
		Vector3[] array = new Vector3[_verts.Length];
		for (int i = 0; i < _verts.Length; i++)
		{
			array[i] = Vector3.Scale(_verts[i], scale);
		}
		mesh.vertices = array;
		mesh.triangles = _indices;
		mesh.hideFlags = HideFlags.DontSave;
		mesh.name = "Cube Fog";
		return mesh;
	}
}
public static class Cylinder
{
	private static readonly Vector3[] _verts = new Vector3[88]
	{
		new Vector3(-0.476f, -0.5f, -0.155f),
		new Vector3(-0.405f, -0.5f, -0.294f),
		new Vector3(-0.294f, -0.5f, -0.405f),
		new Vector3(-0.155f, -0.5f, -0.476f),
		new Vector3(0f, -0.5f, -0.5f),
		new Vector3(0.155f, -0.5f, -0.476f),
		new Vector3(0.294f, -0.5f, -0.405f),
		new Vector3(0.405f, -0.5f, -0.294f),
		new Vector3(0.476f, -0.5f, -0.155f),
		new Vector3(0.5f, -0.5f, 0f),
		new Vector3(0.476f, -0.5f, 0.155f),
		new Vector3(0.405f, -0.5f, 0.294f),
		new Vector3(0.294f, -0.5f, 0.405f),
		new Vector3(0.155f, -0.5f, 0.476f),
		new Vector3(0f, -0.5f, 0.5f),
		new Vector3(-0.155f, -0.5f, 0.476f),
		new Vector3(-0.294f, -0.5f, 0.405f),
		new Vector3(-0.405f, -0.5f, 0.294f),
		new Vector3(-0.476f, -0.5f, 0.155f),
		new Vector3(-0.5f, -0.5f, 0f),
		new Vector3(-0.476f, 0.5f, -0.155f),
		new Vector3(-0.405f, 0.5f, -0.294f),
		new Vector3(-0.294f, 0.5f, -0.405f),
		new Vector3(-0.155f, 0.5f, -0.476f),
		new Vector3(0f, 0.5f, -0.5f),
		new Vector3(0.155f, 0.5f, -0.476f),
		new Vector3(0.294f, 0.5f, -0.405f),
		new Vector3(0.405f, 0.5f, -0.294f),
		new Vector3(0.476f, 0.5f, -0.155f),
		new Vector3(0.5f, 0.5f, 0f),
		new Vector3(0.476f, 0.5f, 0.155f),
		new Vector3(0.405f, 0.5f, 0.294f),
		new Vector3(0.294f, 0.5f, 0.405f),
		new Vector3(0.155f, 0.5f, 0.476f),
		new Vector3(0f, 0.5f, 0.5f),
		new Vector3(-0.155f, 0.5f, 0.476f),
		new Vector3(-0.294f, 0.5f, 0.405f),
		new Vector3(-0.405f, 0.5f, 0.294f),
		new Vector3(-0.476f, 0.5f, 0.155f),
		new Vector3(-0.5f, 0.5f, 0f),
		new Vector3(0f, -0.5f, 0f),
		new Vector3(0f, 0.5f, 0f),
		new Vector3(0.5f, -0.5f, 0f),
		new Vector3(0.5f, 0.5f, 0f),
		new Vector3(-0.5f, -0.5f, 0f),
		new Vector3(-0.476f, 0.5f, -0.155f),
		new Vector3(-0.476f, -0.5f, -0.155f),
		new Vector3(-0.5f, 0.5f, 0f),
		new Vector3(-0.405f, -0.5f, -0.294f),
		new Vector3(-0.476f, -0.5f, -0.155f),
		new Vector3(-0.294f, -0.5f, -0.405f),
		new Vector3(-0.155f, -0.5f, -0.476f),
		new Vector3(0f, -0.5f, -0.5f),
		new Vector3(0.155f, -0.5f, -0.476f),
		new Vector3(0.294f, -0.5f, -0.405f),
		new Vector3(0.405f, -0.5f, -0.294f),
		new Vector3(0.476f, -0.5f, -0.155f),
		new Vector3(0.5f, -0.5f, 0f),
		new Vector3(0.476f, -0.5f, 0.155f),
		new Vector3(0.405f, -0.5f, 0.294f),
		new Vector3(0.294f, -0.5f, 0.405f),
		new Vector3(0.155f, -0.5f, 0.476f),
		new Vector3(0f, -0.5f, 0.5f),
		new Vector3(-0.155f, -0.5f, 0.476f),
		new Vector3(-0.294f, -0.5f, 0.405f),
		new Vector3(-0.405f, -0.5f, 0.294f),
		new Vector3(-0.476f, -0.5f, 0.155f),
		new Vector3(-0.5f, -0.5f, 0f),
		new Vector3(-0.476f, 0.5f, -0.155f),
		new Vector3(-0.405f, 0.5f, -0.294f),
		new Vector3(-0.294f, 0.5f, -0.405f),
		new Vector3(-0.155f, 0.5f, -0.476f),
		new Vector3(0f, 0.5f, -0.5f),
		new Vector3(0.155f, 0.5f, -0.476f),
		new Vector3(0.294f, 0.5f, -0.405f),
		new Vector3(0.405f, 0.5f, -0.294f),
		new Vector3(0.476f, 0.5f, -0.155f),
		new Vector3(0.5f, 0.5f, 0f),
		new Vector3(0.476f, 0.5f, 0.155f),
		new Vector3(0.405f, 0.5f, 0.294f),
		new Vector3(0.294f, 0.5f, 0.405f),
		new Vector3(0.155f, 0.5f, 0.476f),
		new Vector3(0f, 0.5f, 0.5f),
		new Vector3(-0.155f, 0.5f, 0.476f),
		new Vector3(-0.294f, 0.5f, 0.405f),
		new Vector3(-0.405f, 0.5f, 0.294f),
		new Vector3(-0.476f, 0.5f, 0.155f),
		new Vector3(-0.5f, 0.5f, 0f)
	};

	private static readonly int[] _indices = new int[240]
	{
		0, 21, 1, 0, 20, 21, 1, 21, 22, 1,
		22, 2, 2, 22, 23, 2, 23, 3, 3, 23,
		24, 3, 24, 4, 4, 24, 25, 4, 25, 5,
		5, 25, 26, 5, 26, 6, 6, 26, 27, 6,
		27, 7, 7, 27, 28, 7, 28, 8, 8, 28,
		29, 8, 29, 9, 42, 30, 10, 42, 43, 30,
		10, 30, 31, 10, 31, 11, 11, 31, 32, 11,
		32, 12, 12, 32, 33, 12, 33, 13, 13, 33,
		34, 13, 34, 14, 14, 34, 35, 14, 35, 15,
		15, 35, 36, 15, 36, 16, 16, 36, 37, 16,
		37, 17, 17, 37, 38, 17, 38, 18, 18, 38,
		39, 18, 39, 19, 44, 45, 46, 44, 47, 45,
		48, 40, 49, 50, 40, 48, 51, 40, 50, 52,
		40, 51, 53, 40, 52, 54, 40, 53, 55, 40,
		54, 56, 40, 55, 57, 40, 56, 58, 40, 57,
		59, 40, 58, 60, 40, 59, 61, 40, 60, 62,
		40, 61, 63, 40, 62, 64, 40, 63, 65, 40,
		64, 66, 40, 65, 67, 40, 66, 49, 40, 67,
		68, 41, 69, 69, 41, 70, 70, 41, 71, 71,
		41, 72, 72, 41, 73, 73, 41, 74, 74, 41,
		75, 75, 41, 76, 76, 41, 77, 77, 41, 78,
		78, 41, 79, 79, 41, 80, 80, 41, 81, 81,
		41, 82, 82, 41, 83, 83, 41, 84, 84, 41,
		85, 85, 41, 86, 86, 41, 87, 87, 41, 68
	};

	public static Mesh GetMesh(Vector3 scale)
	{
		Mesh mesh = new Mesh();
		Vector3[] array = new Vector3[_verts.Length];
		for (int i = 0; i < _verts.Length; i++)
		{
			array[i] = Vector3.Scale(_verts[i], scale);
		}
		mesh.vertices = array;
		mesh.triangles = _indices;
		mesh.hideFlags = HideFlags.DontSave;
		mesh.name = "Cylinder Fog";
		return mesh;
	}
}
public class RotateObject : MonoBehaviour
{
	public bool rot_x;

	public bool rot_y;

	public bool rot_z;

	public float speed;

	private void Start()
	{
	}

	private void Update()
	{
		if (rot_y)
		{
			base.transform.Rotate(0f, speed * Time.deltaTime, 0f);
		}
		if (rot_x)
		{
			base.transform.Rotate(speed * Time.deltaTime, 0f, 0f);
		}
		if (rot_z)
		{
			base.transform.Rotate(0f, 0f, speed * Time.deltaTime);
		}
	}
}
public class AddForceByPlayer : MonoBehaviour
{
	public Rigidbody rigidbody;

	public float f;

	private void Update()
	{
		rigidbody.AddForce(-GameManager.Player.thisT.up * f, ForceMode.Force);
	}
}
public class Beats : MonoBehaviour
{
	public Transform[] targets;

	[Header("Visualization Parameters")]
	public int numberOfSampleGroups = 11;

	[Range(1f, 2f)]
	public float distance;

	[Header("Audio Analysis Parameters")]
	[Tooltip("How many samples of the currently playing audio to get each frame.")]
	public int sampleSize = 1024;

	private float[] samples;

	[Tooltip("How fast or slow the cubes should shrink back down after getting popped up by the audio.")]
	public float smoothSpeed;

	[Tooltip("How much to scale up or down the size of the cube based on the magnitude of the audio playing.")]
	public float visScale = 0.001f;

	private float logBase;

	private float maxBeatSize;

	public float thisBeat;

	public Vector3 newScale;

	public float threshold = 0.002f;

	public AudioSource music;

	public static Beats instance;

	private void Awake()
	{
		if (instance == null)
		{
			instance = this;
		}
	}

	private void Start()
	{
		maxBeatSize = 0f;
		samples = new float[sampleSize];
		logBase = Mathf.Log(sampleSize, numberOfSampleGroups);
		if (SceneManager.GetActiveScene().name == "MainMenu")
		{
			music = csMainSceneAudioPlayer.instance.ASSBGM;
		}
	}

	private void Update()
	{
		if (music == null)
		{
			return;
		}
		music.GetSpectrumData(samples, 0, FFTWindow.Hamming);
		for (int i = 0; i < numberOfSampleGroups; i++)
		{
			int lowFreq = Mathf.FloorToInt(Mathf.Pow(i, logBase));
			int highFreq = Mathf.FloorToInt(Mathf.Pow(i + 1, logBase)) - 1;
			thisBeat = GetBeatScale(lowFreq, highFreq);
			if (thisBeat > maxBeatSize)
			{
				maxBeatSize = thisBeat;
			}
			float num = 1f + visScale * ((thisBeat > threshold) ? thisBeat : 0f);
			if (num > 1.3f)
			{
				num = 1.3f;
			}
			newScale = new Vector3(num, num, num);
			for (int j = 0; j < targets.Length; j++)
			{
				targets[j].localScale = Vector3.Lerp(targets[j].localScale, newScale, 1f);
			}
		}
	}

	private float GetBeatScale(int lowFreq, int highFreq)
	{
		float num = 0f;
		for (int i = lowFreq; i <= highFreq; i++)
		{
			num += samples[i];
		}
		return num;
	}
}
public class csGameData : MonoBehaviour
{
	[Header("关卡奖励配置表")]
	public List<LevelAwardData> LevelAwardDataInfo = new List<LevelAwardData>();

	[Header("星数奖励配置表")]
	public List<LevelAwardData> StarAwardDataInfo = new List<LevelAwardData>();

	private List<int> StarAwardNumList = new List<int>();

	[Header("无尽箱子基础概率")]
	public float EndlessBoxBaseRate = 0.1f;

	[Header("时间除数")]
	public float EndlessBoxDivisor = 3000f;

	[Header("无尽箱子概率上限")]
	public float EndlessBoxMaxRate = 0.8f;

	[Header("关卡箱子基础概率")]
	public float LevelBoxBaseRate = 0.1f;

	[Header("关卡除数")]
	public float LevelBoxDivisor = 50f;

	[Header("关卡箱子概率上限")]
	public float LevelBoxMaxRate = 0.8f;

	[Header("随机一个物品概率")]
	public float OneGiftRate = 0.5f;

	[Header("随机两个物品概率")]
	public float TwoGiftRate = 0.35f;

	[Header("随机三个物品概率")]
	public float ThreeGiftRate = 0.15f;

	[Header("物品是金币概率")]
	public float CoinRate = 0.5f;

	[Header("物品是钻石概率")]
	public float GemRate = 0.35f;

	[Header("物品是Buff概率")]
	public float BuffRate = 0.15f;

	[Header("金币权重表")]
	public List<IntAwardRightData> CoinDataList = new List<IntAwardRightData>();

	private int maxCoinValue;

	[Header("钻石权重表")]
	public List<IntAwardRightData> GemDataList = new List<IntAwardRightData>();

	private int maxGemValue;

	[Header("Buff权重表")]
	public List<BuffAwardRightData> BuffDataList = new List<BuffAwardRightData>();

	private int maxBuffValue;

	private static csGameData instance;

	public Dictionary<HorseType, HorseData> HorseTypeToDataDic = new Dictionary<HorseType, HorseData>();

	public Dictionary<HorseSkill, SkillLevelData> SkillTypeToDataDic = new Dictionary<HorseSkill, SkillLevelData>();

	public Dictionary<PreObjectType, ItemLevelData> ItemTypeToDataDic = new Dictionary<PreObjectType, ItemLevelData>();

	private static bool hasInit;

	public static csGameData Instance
	{
		get
		{
			if (instance == null)
			{
				(instance = new GameObject("GameData").AddComponent<csGameData>()).InitHorse();
			}
			return instance;
		}
	}

	private void StartAwardDataAwake()
	{
		for (int i = 0; i < StarAwardDataInfo.Count; i++)
		{
			StarAwardNumList.Add(int.Parse(StarAwardDataInfo[i].LevelNum));
		}
	}

	public int GetClosestStarAwardStarNum(int num)
	{
		int result = -1;
		int num2 = -1;
		for (int i = 0; i < StarAwardNumList.Count && StarAwardNumList[i] <= num; i++)
		{
			num2 = i;
		}
		if (num2 != -1)
		{
			result = StarAwardNumList[num2];
		}
		return result;
	}

	public LevelAwardData GetClosestStarAwardData(int num)
	{
		LevelAwardData result = null;
		int num2 = -1;
		for (int i = 0; i < StarAwardNumList.Count && StarAwardNumList[i] <= num; i++)
		{
			num2 = i;
		}
		if (num2 != -1)
		{
			result = StarAwardDataInfo[num2];
		}
		return result;
	}

	public int GetClosestStarAwardIndex(int num)
	{
		int result = -1;
		for (int i = 0; i < StarAwardNumList.Count && StarAwardNumList[i] < num; i++)
		{
			result = i;
		}
		return result;
	}

	public int GetStarAwardNumList(int Index)
	{
		return StarAwardNumList[Index];
	}

	public LevelAwardData GetAwardDataByStarNum(int snum)
	{
		int index = StarAwardNumList.FindIndex((int x) => x == snum);
		return StarAwardDataInfo[index];
	}

	public float GetEndlessBoxRate(float time)
	{
		return Mathf.Clamp(EndlessBoxBaseRate + time / EndlessBoxDivisor, 0f, EndlessBoxMaxRate);
	}

	public float GetLevelBoxRate(float level)
	{
		return Mathf.Clamp(LevelBoxBaseRate + level / LevelBoxDivisor, 0f, LevelBoxMaxRate);
	}

	public int GetRndBoxItemNum()
	{
		int num = 1;
		float num2 = UnityEngine.Random.Range(0, 100);
		if (num2 < OneGiftRate * 100f)
		{
			return 1;
		}
		if (num2 < (OneGiftRate + TwoGiftRate) * 100f)
		{
			return 2;
		}
		return 3;
	}

	public AwardItemType GetRndItemType()
	{
		AwardItemType awardItemType = AwardItemType.Coin;
		float num = UnityEngine.Random.Range(0, 100);
		if (num < CoinRate * 100f)
		{
			return AwardItemType.Coin;
		}
		if (num < (CoinRate + GemRate) * 100f)
		{
			return AwardItemType.Gem;
		}
		return AwardItemType.Prop;
	}

	public void CoinAwake()
	{
		for (int i = 0; i < CoinDataList.Count; i++)
		{
			maxCoinValue += CoinDataList[i].Right;
		}
	}

	public int GetRndCoinItemNum()
	{
		int num = UnityEngine.Random.Range(0, maxCoinValue * 100);
		int index = 0;
		for (int i = 0; i < CoinDataList.Count; i++)
		{
			if (num < CoinDataList[i].Right * 100)
			{
				index = i;
				break;
			}
			num -= CoinDataList[i].Right * 100;
		}
		return CoinDataList[index].GiftNum;
	}

	public void GemAwake()
	{
		for (int i = 0; i < GemDataList.Count; i++)
		{
			maxGemValue += GemDataList[i].Right;
		}
	}

	public int GetRndGemItemNum()
	{
		int num = UnityEngine.Random.Range(0, maxGemValue * 100);
		int index = 0;
		for (int i = 0; i < GemDataList.Count; i++)
		{
			if (num < GemDataList[i].Right * 100)
			{
				index = i;
				break;
			}
			num -= GemDataList[i].Right * 100;
		}
		return GemDataList[index].GiftNum;
	}

	public void BuffAwake()
	{
		for (int i = 0; i < BuffDataList.Count; i++)
		{
			maxBuffValue += BuffDataList[i].Right;
		}
	}

	public BuffAwardRightData GetRndBuffItem()
	{
		int num = UnityEngine.Random.Range(0, maxBuffValue * 100);
		int index = 0;
		for (int i = 0; i < BuffDataList.Count; i++)
		{
			if (num < BuffDataList[i].Right * 100)
			{
				index = i;
				break;
			}
			num -= BuffDataList[i].Right * 100;
		}
		return BuffDataList[index];
	}

	private void Awake()
	{
		if (instance == null)
		{
			instance = this;
			InitHorse();
			UnityEngine.Object.DontDestroyOnLoad(this);
			CoinAwake();
			GemAwake();
			BuffAwake();
			StartAwardDataAwake();
		}
		else if (instance != this)
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}

	public void InitHorse()
	{
		if (!hasInit)
		{
			hasInit = true;
			HorseDataJsonList horseDataJsonList = JsonUtility.FromJson<HorseDataJsonList>((Resources.Load("Profile/HorseData") as TextAsset).text);
			for (int i = 0; i < horseDataJsonList.HorseDataList.Count; i++)
			{
				HorseTypeToDataDic.Add(horseDataJsonList.HorseDataList[i].HosrseType, horseDataJsonList.HorseDataList[i]);
			}
			SkillLevelDataList skillLevelDataList = JsonUtility.FromJson<SkillLevelDataList>((Resources.Load("Profile/SkillData") as TextAsset).text);
			for (int j = 0; j < skillLevelDataList.SkillDataList.Count; j++)
			{
				SkillTypeToDataDic.Add(skillLevelDataList.SkillDataList[j].Skilltype, skillLevelDataList.SkillDataList[j]);
			}
			ItemLevelDataList itemLevelDataList = JsonUtility.FromJson<ItemLevelDataList>((Resources.Load("Profile/ItemData") as TextAsset).text);
			for (int k = 0; k < itemLevelDataList.ItemDataList.Count; k++)
			{
				ItemTypeToDataDic.Add(itemLevelDataList.ItemDataList[k].ItemType, itemLevelDataList.ItemDataList[k]);
			}
		}
	}
}
public class csGameSettings : MonoBehaviour
{
	public static bool IsLoadToGame = true;

	public static bool isFromMainScene = false;

	public static float Jumpgravity = 9f;

	public const int MaxHorseNum = 11;

	private static csGameProfile profile;

	public static float PlayerSpeedAdding = 0.2f;

	public static int CurrentSelectedLevel = 1;

	public const int MaxLevelCount = 15;

	public const int MaxEndlessLevelCount = 60;

	public const int MaxLevelInOnePage = 6;

	public const int MaxPageIndex = 2;

	public static GameMode CurrentGameMode = GameMode.EndlessMode;

	public static bool WeaponMode = false;

	public static bool IsLoading = false;

	public static bool EnglishOnly = false;

	public static bool NeedDRM = true;

	public const int ChangeNameCost = 2000;

	public static int CurEndParticleIndexInner = 0;

	public const int EndParticleNumInner = 5;

	public static int CurEndParticleIndexOut = 0;

	public const int EndParticleNumOut = 4;

	public static float SheildTime = 25f;

	public static float MagTime = 25f;

	public static float RushTime = 15f;

	public static int SmashGold = 50;

	public static bool ShowLevelPanel = false;

	public static bool HintUIOnly = false;

	private static csFadeManager PlayerCamFade;

	public static bool IsLeftMove
	{
		get
		{
			return PlayerPrefs.GetInt("LHandMove", 1) == 1;
		}
		set
		{
			PlayerPrefs.SetInt("LHandMove", value ? 1 : (-1));
		}
	}

	public static bool IsSkillTeached
	{
		get
		{
			return PlayerPrefs.GetInt("IsSkillTeached", 0) == 1;
		}
		set
		{
			PlayerPrefs.SetInt("IsSkillTeached", value ? 1 : 0);
		}
	}

	public static bool SkipEndlessLevel
	{
		get
		{
			return PlayerPrefs.GetInt("SkipELevel", -1) == 1;
		}
		set
		{
			PlayerPrefs.SetInt("SkipELevel", value ? 1 : (-1));
		}
	}

	public static HorseType PlayerHorseType
	{
		get
		{
			return (HorseType)PlayerPrefs.GetInt("PlayerHorseType", 0);
		}
		set
		{
			PlayerPrefs.SetInt("PlayerHorseType", (int)value);
		}
	}

	public static ChannelType Channel
	{
		get
		{
			if (profile == null)
			{
				Init();
			}
			return profile.CurrentChannel;
		}
	}

	public static void Init()
	{
		profile = Resources.Load<csGameProfile>("GameProfile");
	}

	public static int GetMoneyByDeadTime(int deadtime)
	{
		int num = 999;
		return deadtime switch
		{
			1 => 100, 
			2 => 300, 
			3 => 500, 
			4 => -10, 
			5 => -15, 
			_ => -20, 
		};
	}

	public static int GetGemByDeadTime(int deadtime)
	{
		int num = 999;
		return deadtime switch
		{
			1 => -1, 
			2 => -3, 
			3 => -5, 
			4 => -10, 
			5 => -15, 
			_ => -20, 
		};
	}

	public static int GetCoinByEndlessLevel(int level)
	{
		int num = 0;
		if (level <= 5)
		{
			return 5 * level;
		}
		if (level <= 10)
		{
			return 25 + (level - 5) * 10;
		}
		if (level <= 15)
		{
			return 75 + (level - 10) * 15;
		}
		if (level <= 20)
		{
			return 150 + (level - 15) * 20;
		}
		if (level <= 30)
		{
			return 250 + (level - 20) * 25;
		}
		return 500 + (level - 30) * 30;
	}

	public static int GetCoinForOneLevel(int level)
	{
		int num = 0;
		if (level <= 5)
		{
			return 5;
		}
		if (level <= 10)
		{
			return 10;
		}
		if (level <= 15)
		{
			return 15;
		}
		if (level <= 20)
		{
			return 20;
		}
		if (level <= 30)
		{
			return 25;
		}
		return 30;
	}

	public static void SetHintOn(bool isOn)
	{
		if (isOn)
		{
			HintUIOnly = true;
			if (PlayerCamFade == null)
			{
				PlayerCamFade = UnityEngine.Object.FindObjectOfType<csFadeManager>();
			}
			PlayerCamFade.SetHintSprite(isOn: true);
		}
		else
		{
			HintUIOnly = false;
			if (PlayerCamFade == null)
			{
				PlayerCamFade = UnityEngine.Object.FindObjectOfType<csFadeManager>();
			}
			PlayerCamFade.SetHintSprite(isOn: false);
		}
	}
}
public class csHMDDataSetter : MonoBehaviour
{
	public Transform EyeCamT;

	public Animator HandAnimL;

	public Animator HandAnimR;

	public csControllerRotationCopy ConRotCopy;

	public Transform LeftHandAnchor;

	public Transform RightHandAnchor;

	public csFadeManager PlayerCamFade;

	public Transform[] LHandEndTs;

	public Transform[] RHandEndTs;

	public Renderer LHandMR;

	public Renderer RHandMR;

	public Transform LHandT;

	public Transform RHandT;

	public Transform RidingHandT;

	public Transform camT;

	public csControllerForSteamVR LhandController;

	public csControllerForSteamVR RhandController;

	public csHeadSetForSteamVR headController;

	public Transform HandRotWithOutX;

	public bool UseTrackingT;

	public Transform TrackingT;

	public bool UseCenterRotate;

	public Transform TrackingTCenter;

	public MeshRenderer MR_FarColor;

	public Camera WaveBCam;

	public Camera WaveLCam;

	public Camera WaveRCam;

	public Transform CopyT;

	public GameObject LhandModelO;

	public GameObject RhandModelO;

	private float XOffset = 0.1f;

	private void OnEnable()
	{
		if (SceneManager.GetActiveScene().name == "MainMenu")
		{
			camT.GetComponent<Camera>().clearFlags = CameraClearFlags.Skybox;
			if (csGameSettings.Channel == ChannelType.OculusGO)
			{
				WaveLCam.clearFlags = CameraClearFlags.Skybox;
				WaveRCam.clearFlags = CameraClearFlags.Skybox;
			}
		}
	}

	public void ResetHand()
	{
		if (csGameSettings.Channel != ChannelType.OculusGO)
		{
			return;
		}
		csHMDIniter.instance.curHand = OVRInput.GetDominantHand();
		if (OVRInput.GetDominantHand() == OVRInput.Handedness.LeftHanded)
		{
			LhandModelO.SetActive(value: true);
			RhandModelO.SetActive(value: false);
			HandAnimL.SetInteger("AnimationState", 2);
			ConRotCopy.targetT = LeftHandAnchor;
			CopyT.localPosition = new Vector3(0f - XOffset, CopyT.localPosition.y, CopyT.localPosition.z);
			if ((bool)GameManager.instance)
			{
				GameManager.instance.OnHandChange(isL: true);
			}
		}
		else
		{
			LhandModelO.SetActive(value: false);
			RhandModelO.SetActive(value: true);
			HandAnimR.SetInteger("AnimationState", 2);
			ConRotCopy.targetT = RightHandAnchor;
			CopyT.localPosition = new Vector3(XOffset, CopyT.localPosition.y, CopyT.localPosition.z);
			if ((bool)GameManager.instance)
			{
				GameManager.instance.OnHandChange(isL: false);
			}
		}
	}

	public void SetControllerHand(bool isL)
	{
		if (csGameSettings.Channel == ChannelType.WaveVR_3Dof)
		{
			if (isL)
			{
				LhandModelO.SetActive(value: true);
				RhandModelO.SetActive(value: false);
				HandAnimL.SetInteger("AnimationState", 2);
				CopyT.localPosition = new Vector3(0f - XOffset, CopyT.localPosition.y, CopyT.localPosition.z);
			}
			else
			{
				LhandModelO.SetActive(value: false);
				RhandModelO.SetActive(value: true);
				HandAnimR.SetInteger("AnimationState", 2);
				CopyT.localPosition = new Vector3(XOffset, CopyT.localPosition.y, CopyT.localPosition.z);
			}
		}
		if (csGameSettings.Channel == ChannelType.OculusGO)
		{
			if (isL)
			{
				LhandModelO.SetActive(value: true);
				RhandModelO.SetActive(value: false);
				HandAnimL.SetInteger("AnimationState", 2);
				CopyT.localPosition = new Vector3(0f - XOffset, CopyT.localPosition.y, CopyT.localPosition.z);
			}
			else
			{
				LhandModelO.SetActive(value: false);
				RhandModelO.SetActive(value: true);
				HandAnimR.SetInteger("AnimationState", 2);
				CopyT.localPosition = new Vector3(XOffset, CopyT.localPosition.y, CopyT.localPosition.z);
			}
		}
	}
}
public class csHMDIniter : MonoBehaviour
{
	public bool InsideScene;

	public bool InLoading;

	public Transform thisT;

	public csCamRest CamRester;

	public Dictionary<ChannelType, string> HmdPrefabNameDic = new Dictionary<ChannelType, string>();

	public csHMDDataSetter CurrentSetter;

	public PlayerControl player;

	public bool initDone;

	public static csHMDIniter instance;

	private Transform HmdTrans;

	public OVRInput.Handedness curHand;

	private void Awake()
	{
		HmdPrefabNameDic.Add(ChannelType.PC, "[CameraRig]PCNew");
		HmdPrefabNameDic.Add(ChannelType.WaveVR_3Dof, "WaveVR_HMDNew_3Dof");
		HmdPrefabNameDic.Add(ChannelType.WaveVR_6Dof, "WaveVR_HMDNew_6Dof");
		HmdPrefabNameDic.Add(ChannelType.OculusQuest, "OculusRig_Quest");
		HmdPrefabNameDic.Add(ChannelType.OculusGO, "OculusRig_GO");
		HmdPrefabNameDic.Add(ChannelType.Pico6Dof, "Pvr6Dof_CamRig");
		thisT = base.transform;
		if (instance == null)
		{
			instance = this;
		}
	}

	private void Start()
	{
		if (HmdTrans != null)
		{
			return;
		}
		GameObject gameObject = UnityEngine.Object.Instantiate(Resources.Load("MultiPlatformHDM/" + HmdPrefabNameDic[csGameSettings.Channel]) as GameObject);
		HmdTrans = gameObject.transform;
		gameObject.transform.SetParent(thisT);
		Transform obj = gameObject.transform;
		Vector3 localPosition = (gameObject.transform.localEulerAngles = Vector3.zero);
		obj.localPosition = localPosition;
		CurrentSetter = gameObject.GetComponent<csHMDDataSetter>();
		CamRester.childT = CurrentSetter.EyeCamT;
		if (InsideScene)
		{
			player.HandAnimL = CurrentSetter.HandAnimL;
			player.HandAnimR = CurrentSetter.HandAnimR;
			player.PlayerCamFade = CurrentSetter.PlayerCamFade;
			player.LHandEndTs = CurrentSetter.LHandEndTs;
			player.RHandEndTs = CurrentSetter.RHandEndTs;
			player.LHandMR = CurrentSetter.LHandMR;
			player.RHandMR = CurrentSetter.RHandMR;
			player.LHandT = CurrentSetter.LHandT;
			player.RHandT = CurrentSetter.RHandT;
			if (csGameSettings.WeaponMode && (bool)CurrentSetter.RHandT.GetComponent<csWeaponHand>())
			{
				player.RightWeaponHand = CurrentSetter.RHandT.GetComponent<csWeaponHand>();
			}
			CurrentSetter.LHandT.GetComponent<ViveUILaserPointer>().laserAlwaysOn = false;
			CurrentSetter.RHandT.GetComponent<ViveUILaserPointer>().laserAlwaysOn = false;
			player.RidingHandT = CurrentSetter.RidingHandT;
			player.camT = CurrentSetter.EyeCamT;
			player.LhandController = CurrentSetter.LhandController;
			player.RhandController = CurrentSetter.RhandController;
			player.headController = CurrentSetter.headController;
			player.HandRotWithOutX = CurrentSetter.HandRotWithOutX;
			player.UseTrackingT = CurrentSetter.UseTrackingT;
			player.UseCenterRotate = CurrentSetter.UseCenterRotate;
			if (CurrentSetter.UseTrackingT)
			{
				player.TrackingT = CurrentSetter.TrackingT;
			}
			if (CurrentSetter.UseCenterRotate)
			{
				player.CenterRotateT = CurrentSetter.TrackingTCenter;
			}
			player.PlayerCamFade.SetFadeAlpha(1f);
			initDone = true;
			GameManager.instance.RigObject = gameObject;
			if (csGameSettings.Channel == ChannelType.OculusGO)
			{
				CurrentSetter.ResetHand();
			}
		}
		if (InLoading)
		{
			CurrentSetter.LHandT.GetComponent<ViveUILaserPointer>().laserAlwaysOn = false;
			CurrentSetter.RHandT.GetComponent<ViveUILaserPointer>().laserAlwaysOn = false;
		}
	}

	private void Update()
	{
		if (csGameSettings.Channel == ChannelType.OculusGO && curHand != OVRInput.GetDominantHand())
		{
			CurrentSetter.ResetHand();
		}
	}

	public void SetOffset(float OffsetY)
	{
		if (HmdTrans == null)
		{
			Start();
		}
		player.PlayerCamFade.FadeIn(null, 0.4f);
		HmdTrans.transform.localPosition = Vector3.up * OffsetY;
	}

	public void SetOffsetLerp(float OffsetY)
	{
		if (HmdTrans == null)
		{
			Start();
		}
		HmdTrans.transform.DOLocalMoveY(OffsetY, 0.1f).SetEase(Ease.Linear);
	}
}
public class csHorseIniter : MonoBehaviour
{
	public HorseType DefaultInitType = HorseType.None;

	private float presetScale = 1f;

	[HideInInspector]
	public Transform HorseInitT;

	private GameObject CurHorseObj;

	public HorseType CurType = HorseType.None;

	public csHorseModelController curHorseCtrl;

	private void Awake()
	{
		HorseInitT = base.transform.Find("HorseInitPos");
	}

	private void Start()
	{
	}

	public csHorseModelController InitHorse(HorseType type, bool onPlatform = false)
	{
		if ((bool)CurHorseObj)
		{
			if (CurType == type)
			{
				curHorseCtrl = CurHorseObj.GetComponent<csHorseModelController>();
				return curHorseCtrl;
			}
			UnityEngine.Object.Destroy(CurHorseObj);
		}
		CurType = type;
		CurHorseObj = UnityEngine.Object.Instantiate(csHorseObjectManager.instance.HorseList.Find((HorseObject x) => x.m_Type == type).m_PrefabObj);
		CurHorseObj.transform.SetParent(HorseInitT);
		CurHorseObj.transform.localScale = new Vector3(presetScale, presetScale, presetScale);
		Transform obj = CurHorseObj.transform;
		Vector3 localPosition = (CurHorseObj.transform.localEulerAngles = Vector3.zero);
		obj.localPosition = localPosition;
		if (onPlatform)
		{
			switch (CurType)
			{
			case HorseType.Horse_Default:
			case HorseType.Horse_1:
			case HorseType.Horse_2:
			case HorseType.Horse_3:
			case HorseType.Horse_4:
			case HorseType.Horse_5:
			case HorseType.Horse_6:
			case HorseType.Crocodile:
			case HorseType.DragonBoss:
			{
				Transform obj2 = CurHorseObj.transform;
				localPosition = (CurHorseObj.transform.localEulerAngles = Vector3.zero - Vector3.forward * 0.43f);
				obj2.localPosition = localPosition;
				break;
			}
			}
		}
		curHorseCtrl = CurHorseObj.GetComponent<csHorseModelController>();
		return curHorseCtrl;
	}

	public void DestroyHorse()
	{
		if ((bool)CurHorseObj)
		{
			CurHorseObj.SetActive(value: false);
		}
	}

	public void OpenHorse()
	{
		if ((bool)CurHorseObj)
		{
			CurHorseObj.SetActive(value: true);
		}
	}
}
[Serializable]
public class HorseObject
{
	public HorseType m_Type;

	public GameObject m_PrefabObj;
}
public class csHorseModelController : MonoBehaviour
{
	public Transform LookTarget;

	[HideInInspector]
	public Transform RopeStartTL;

	[HideInInspector]
	public Transform RopeStartTR;

	public GameObject reinBase;

	public Animator HorseAnim;

	public HorseBarRotator HorseBarL;

	public HorseBarRotator HorseBarR;

	public float CamYOffset;

	public Material GhostMat;

	public List<Material> HorseOriMatList = new List<Material>();

	public Renderer[] HorseRnds;

	public void Awake()
	{
		HorseBarRotator[] componentsInChildren = base.transform.GetComponentsInChildren<HorseBarRotator>();
		foreach (HorseBarRotator horseBarRotator in componentsInChildren)
		{
			if (horseBarRotator.name.Equals("BarR"))
			{
				HorseBarR = horseBarRotator;
				RopeStartTR = horseBarRotator.transform.GetChild(0);
			}
			else
			{
				HorseBarL = horseBarRotator;
				RopeStartTL = horseBarRotator.transform.GetChild(0);
			}
		}
		for (int j = 0; j < HorseRnds.Length; j++)
		{
			HorseOriMatList.Add(HorseRnds[j].material);
		}
	}

	private void Start()
	{
		if (reinBase != null)
		{
			reinBase.SetActive(value: false);
		}
	}

	public void SetRun(bool isRun)
	{
		HorseAnim.SetBool("Stand", !isRun);
		HorseAnim.SetFloat("Vertical", isRun ? 10 : 0);
		if (reinBase != null)
		{
			reinBase.SetActive(value: true);
		}
		if (isRun)
		{
			SetSpeed(1f);
		}
		HorseAnim.SetBool("_Jump", value: false);
	}

	public void SetShow(bool isShow)
	{
		for (int i = 0; i < HorseRnds.Length; i++)
		{
			HorseRnds[i].enabled = isShow;
		}
	}

	public void SetInvincible(bool isinvince)
	{
		if (isinvince)
		{
			for (int i = 0; i < HorseRnds.Length; i++)
			{
				HorseRnds[i].material = GhostMat;
			}
		}
		else
		{
			for (int j = 0; j < HorseRnds.Length; j++)
			{
				HorseRnds[j].material = HorseOriMatList[j];
			}
		}
	}

	public void SetJump(bool isJump)
	{
		HorseAnim.SetBool("_Jump", isJump);
	}

	public void SetSpeed(float val)
	{
		HorseAnim.speed = val;
	}

	public void SetFly(bool isFly)
	{
		HorseAnim.SetBool("fly", isFly);
	}
}
public class csHorseObjectManager : MonoBehaviour
{
	public static csHorseObjectManager instance;

	public List<HorseObject> HorseList = new List<HorseObject>();

	private void Awake()
	{
		instance = this;
	}
}
public class csHoserRotatorItem : MonoBehaviour
{
	public GameObject selectEffect;

	public csHorseIniter initer;

	private bool isOpenEffect;

	public int CurrentPos;

	[HideInInspector]
	public Transform effectT;

	public MeshRenderer mat;

	public Material normalMat;

	public Material selectmat;

	private void Start()
	{
		effectT = selectEffect.transform;
	}

	public void OpenEffect(bool isLeft)
	{
		mat.material = selectmat;
		selectEffect.SetActive(value: true);
		initer.transform.DOLocalMove(new Vector3(0f, 0f, 12.13f), 0.4f).SetDelay(0.2f);
		if (isLeft)
		{
			float y = initer.transform.localEulerAngles.y + 180f;
			initer.transform.DOLocalRotate(new Vector3(0f, y, 0f), 1f);
		}
		else
		{
			float y2 = initer.transform.localEulerAngles.y - 180f;
			initer.transform.DOLocalRotate(new Vector3(0f, y2, 0f), 1f);
		}
	}

	public void CloseEffect(bool isFar)
	{
		selectEffect.SetActive(value: false);
		mat.material = normalMat;
		if (isFar)
		{
			initer.transform.DOLocalMove(new Vector3(0f, -10f, 12.13f), 0.4f);
		}
		else
		{
			initer.transform.DOLocalMove(new Vector3(0f, -0.79f, 12.13f), 0.4f);
		}
	}

	public void CloseEffect(bool isFar, bool needRotate, bool isLeft)
	{
		CloseEffect(isFar);
		if (needRotate)
		{
			if (isLeft)
			{
				float y = initer.transform.localEulerAngles.y + 180f;
				initer.transform.DOLocalRotate(new Vector3(0f, y, 0f), 1f);
			}
			else
			{
				float y2 = initer.transform.localEulerAngles.y - 180f;
				initer.transform.DOLocalRotate(new Vector3(0f, y2, 0f), 1f);
			}
		}
		else
		{
			initer.transform.localEulerAngles = new Vector3(0f, 180f, 0f);
		}
	}

	public void CloseEffectWhenOpenPanel(bool isFar, bool needRotate, bool isLeft, float rotY)
	{
		CloseEffect(isFar);
		if (needRotate)
		{
			if (isLeft)
			{
				float y = initer.transform.localEulerAngles.y + 180f;
				initer.transform.DOLocalRotate(new Vector3(0f, y, 0f), 1f);
			}
			else
			{
				float y2 = initer.transform.localEulerAngles.y - 180f;
				initer.transform.DOLocalRotate(new Vector3(0f, y2, 0f), 1f);
			}
		}
		else
		{
			initer.transform.localEulerAngles = new Vector3(0f, rotY, 0f);
		}
	}
}
public class csInGameMissionData : MonoBehaviour
{
	public int HitTimes;

	public int CrashWallTimes;

	public int DropTimes;

	public int LostHP;

	public Dictionary<PreObjectType, int> PreObjectDic = new Dictionary<PreObjectType, int>();

	public Dictionary<HorseSkill, int> HorseSkillDic = new Dictionary<HorseSkill, int>();

	public List<MissionDataInfo> InGameMissionDataList = new List<MissionDataInfo>();

	public int SkillUsedCount;

	public int PropUsedCount;

	public void ResetMission()
	{
		if (csGameSettings.CurrentGameMode == GameMode.LevelMode)
		{
			Init();
		}
		HitTimes = 0;
		DropTimes = 0;
		LostHP = 0;
		SkillUsedCount = 0;
		PropUsedCount = 0;
		CrashWallTimes = 0;
	}

	public void Init()
	{
		PreObjectDic = new Dictionary<PreObjectType, int>();
		PreObjectDic.Add(PreObjectType.Magnet, 0);
		PreObjectDic.Add(PreObjectType.Sheild, 0);
		PreObjectDic.Add(PreObjectType.RushPower, 0);
		HorseSkillDic = new Dictionary<HorseSkill, int>();
		HorseSkillDic.Add(HorseSkill.Sprint, 0);
		HorseSkillDic.Add(HorseSkill.Invincible, 0);
		HorseSkillDic.Add(HorseSkill.Slow, 0);
		HorseSkillDic.Add(HorseSkill.Strike, 0);
		HorseSkillDic.Add(HorseSkill.Anticol, 0);
		HorseSkillDic.Add(HorseSkill.Jump, 0);
		HorseSkillDic.Add(HorseSkill.ShieldBuff, 0);
		HorseSkillDic.Add(HorseSkill.Roar, 0);
		HorseSkillDic.Add(HorseSkill.Fly, 0);
		InGameMissionDataList = new List<MissionDataInfo>();
		for (int i = 0; i < csLevelData.instance.m_LevelInfoList.m_LevelInfoList[csGameSettings.CurrentSelectedLevel - 1].m_MissionDataList.Count; i++)
		{
			InGameMissionDataList.Add(new MissionDataInfo(csLevelData.instance.m_LevelInfoList.m_LevelInfoList[csGameSettings.CurrentSelectedLevel - 1].m_MissionDataList[i]));
		}
	}

	public void AddPreObjectTimes(PreObjectType _type)
	{
		if (csGameSettings.CurrentGameMode == GameMode.LevelMode && PreObjectDic.ContainsKey(_type))
		{
			PreObjectDic[_type]++;
		}
		PropUsedCount++;
	}

	public void AddHorseSkillTimes(HorseSkill _type)
	{
		if (csGameSettings.CurrentGameMode == GameMode.LevelMode && HorseSkillDic.ContainsKey(_type))
		{
			HorseSkillDic[_type]++;
		}
		SkillUsedCount++;
	}

	public void SetMissionComplet(csMissionType _type)
	{
		for (int i = 0; i < InGameMissionDataList.Count; i++)
		{
			if (InGameMissionDataList[i]._Type == _type)
			{
				InGameMissionDataList[i].isComplet = true;
			}
		}
	}

	public int GetMissionIndexByType(csMissionType _type)
	{
		for (int i = 0; i < InGameMissionDataList.Count; i++)
		{
			if (InGameMissionDataList[i]._Type == _type)
			{
				return i;
			}
		}
		return -1;
	}

	public void JudgeDataOnGameEnd()
	{
		if (GameManager.instance.HasCompeletLevel)
		{
			int missionIndexByType = GetMissionIndexByType(csMissionType.Task_02);
			if (missionIndexByType != -1 && HitTimes <= InGameMissionDataList[missionIndexByType].Parameter_1)
			{
				SetMissionComplet(csMissionType.Task_02);
			}
			int missionIndexByType2 = GetMissionIndexByType(csMissionType.Task_03);
			if (missionIndexByType2 != -1 && DropTimes <= InGameMissionDataList[missionIndexByType2].Parameter_1)
			{
				SetMissionComplet(csMissionType.Task_03);
			}
			int missionIndexByType3 = GetMissionIndexByType(csMissionType.Task_04);
			if (missionIndexByType3 != -1 && LostHP <= InGameMissionDataList[missionIndexByType3].Parameter_1)
			{
				SetMissionComplet(csMissionType.Task_04);
			}
			int missionIndexByType4 = GetMissionIndexByType(csMissionType.Task_05);
			if (missionIndexByType4 != -1 && GameManager.LevelManager.CoinGetThisRun >= InGameMissionDataList[missionIndexByType4].Parameter_1)
			{
				SetMissionComplet(csMissionType.Task_05);
			}
			int missionIndexByType5 = GetMissionIndexByType(csMissionType.Task_06);
			if (missionIndexByType5 != -1 && PreObjectDic[(PreObjectType)InGameMissionDataList[missionIndexByType5].Parameter_1] >= InGameMissionDataList[missionIndexByType5].Parameter_2)
			{
				SetMissionComplet(csMissionType.Task_06);
			}
			int missionIndexByType6 = GetMissionIndexByType(csMissionType.Task_07);
			if (missionIndexByType6 != -1 && HorseSkillDic[(HorseSkill)InGameMissionDataList[missionIndexByType6].Parameter_1] >= InGameMissionDataList[missionIndexByType6].Parameter_2)
			{
				SetMissionComplet(csMissionType.Task_07);
			}
			int missionIndexByType7 = GetMissionIndexByType(csMissionType.Task_08);
			if (missionIndexByType7 != -1 && csGameSettings.PlayerHorseType == (HorseType)InGameMissionDataList[missionIndexByType7].Parameter_1)
			{
				SetMissionComplet(csMissionType.Task_08);
			}
			int missionIndexByType8 = GetMissionIndexByType(csMissionType.Task_09);
			if (missionIndexByType8 != -1 && GameManager.LevelManager.TotalDistance * GameManager.Player.hd.BasicData.ScoreMultiplier * GameManager.Player.scoreBuffVal >= (float)InGameMissionDataList[missionIndexByType8].Parameter_1)
			{
				SetMissionComplet(csMissionType.Task_09);
			}
			int missionIndexByType9 = GetMissionIndexByType(csMissionType.Task_10);
			if (missionIndexByType9 != -1 && GameManager.instance.GameTime <= (float)InGameMissionDataList[missionIndexByType9].Parameter_1)
			{
				SetMissionComplet(csMissionType.Task_10);
			}
		}
	}

	public bool JudgeMissionComplete(int id)
	{
		csMissionType type = InGameMissionDataList[id]._Type;
		bool result = false;
		int missionIndexByType = GetMissionIndexByType(type);
		if (missionIndexByType == -1)
		{
			return false;
		}
		int missionIndexByType2 = GetMissionIndexByType(csMissionType.Task_02);
		if (missionIndexByType == missionIndexByType2 && missionIndexByType2 != -1 && HitTimes <= InGameMissionDataList[missionIndexByType2].Parameter_1)
		{
			result = true;
		}
		int missionIndexByType3 = GetMissionIndexByType(csMissionType.Task_03);
		if (missionIndexByType == missionIndexByType3 && missionIndexByType3 != -1 && DropTimes <= InGameMissionDataList[missionIndexByType3].Parameter_1)
		{
			result = true;
		}
		int missionIndexByType4 = GetMissionIndexByType(csMissionType.Task_04);
		if (missionIndexByType == missionIndexByType4 && missionIndexByType4 != -1 && LostHP <= InGameMissionDataList[missionIndexByType4].Parameter_1)
		{
			result = true;
		}
		int missionIndexByType5 = GetMissionIndexByType(csMissionType.Task_05);
		if (missionIndexByType == missionIndexByType5 && missionIndexByType5 != -1 && GameManager.LevelManager.CoinGetThisRun >= InGameMissionDataList[missionIndexByType5].Parameter_1)
		{
			result = true;
		}
		int missionIndexByType6 = GetMissionIndexByType(csMissionType.Task_06);
		if (missionIndexByType == missionIndexByType6 && missionIndexByType6 != -1 && PreObjectDic[(PreObjectType)InGameMissionDataList[missionIndexByType6].Parameter_1] >= InGameMissionDataList[missionIndexByType6].Parameter_2)
		{
			result = true;
		}
		int missionIndexByType7 = GetMissionIndexByType(csMissionType.Task_07);
		if (missionIndexByType == missionIndexByType7 && missionIndexByType7 != -1 && HorseSkillDic[(HorseSkill)InGameMissionDataList[missionIndexByType7].Parameter_1] >= InGameMissionDataList[missionIndexByType7].Parameter_2)
		{
			result = true;
		}
		int missionIndexByType8 = GetMissionIndexByType(csMissionType.Task_08);
		if (missionIndexByType == missionIndexByType8 && missionIndexByType8 != -1 && csGameSettings.PlayerHorseType == (HorseType)InGameMissionDataList[missionIndexByType8].Parameter_1)
		{
			result = true;
		}
		int missionIndexByType9 = GetMissionIndexByType(csMissionType.Task_09);
		if (missionIndexByType == missionIndexByType9 && missionIndexByType9 != -1 && GameManager.LevelManager.TotalDistance * GameManager.Player.hd.BasicData.ScoreMultiplier * GameManager.Player.scoreBuffVal >= (float)InGameMissionDataList[missionIndexByType9].Parameter_1)
		{
			result = true;
		}
		int missionIndexByType10 = GetMissionIndexByType(csMissionType.Task_10);
		if (missionIndexByType == missionIndexByType10 && missionIndexByType10 != -1 && GameManager.instance.GameTime <= (float)InGameMissionDataList[missionIndexByType10].Parameter_1)
		{
			result = true;
		}
		return result;
	}
}
public class csTutorialManager : MonoBehaviour
{
	public static csTutorialManager instance;

	public TutorialStep CurTStep;

	private PlayerControl player;

	private Coroutine TutorialCor;

	private void Awake()
	{
		instance = this;
	}

	public void PlayTutorial(PlayerControl p)
	{
		player = p;
		TutorialCor = StartCoroutine(TutorialStart());
	}

	private IEnumerator TutorialStart()
	{
		CurTStep = TutorialStep.StraightRun;
		player.SetTutorialState(0);
		GameManager.MenuSystem.HUD.levelTextGameobject.SetActive(value: false);
		while (CurTStep == TutorialStep.StraightRun)
		{
			yield return null;
		}
		CurTStep = TutorialStep.None;
		player.SetTutorialState(1);
		player.SpeedLineObject.SetActive(value: false);
		player.PauseHorse();
		player.curHorse.HorseModelController.SetRun(isRun: false);
		GameManager.instance.TutorialHintCanvas.SetText(csLocalizationManager.Instance.GetLocalText("CanvasIngame26"), NeedHand: true);
		GameManager.instance.SetControllerHintState(1);
		GameManager.instance.ShowTutorialScreenMenu();
		GameManager.instance.ShowControllerHintScreenMenu();
		yield return new WaitForSeconds(2f);
		CurTStep = TutorialStep.WaitForTurnL;
		while (CurTStep == TutorialStep.WaitForTurnL)
		{
			yield return null;
		}
		player.SpeedLineObject.SetActive(value: true);
		player.PlayHorse();
		player.curHorse.HorseModelController.SetRun(isRun: true);
		GameManager.instance.HideTutorialScreenMenu();
		GameManager.instance.SetControllerHintState(0);
		GameManager.instance.ShowControllerHintScreenMenu();
		player.SetTutorialState(2);
		while (CurTStep == TutorialStep.TurningL)
		{
			yield return null;
		}
		CurTStep = TutorialStep.StraightRun;
		player.SetTutorialState(0);
		while (CurTStep == TutorialStep.StraightRun)
		{
			yield return null;
		}
		CurTStep = TutorialStep.None;
		player.SetTutorialState(1);
		player.SpeedLineObject.SetActive(value: false);
		player.PauseHorse();
		player.curHorse.HorseModelController.SetRun(isRun: false);
		GameManager.instance.TutorialHintCanvas.SetArrow(NeedArrow: true, isLeft: false);
		GameManager.instance.TutorialHintCanvas.SetText(csLocalizationManager.Instance.GetLocalText("CanvasIngame261"), NeedHand: true);
		GameManager.instance.ShowTutorialScreenMenu();
		GameManager.instance.SetControllerHintState(2);
		GameManager.instance.ShowControllerHintScreenMenu();
		yield return new WaitForSeconds(2f);
		CurTStep = TutorialStep.WaitForTurnR;
		while (CurTStep == TutorialStep.WaitForTurnR)
		{
			yield return null;
		}
		player.SpeedLineObject.SetActive(value: true);
		player.PlayHorse();
		player.curHorse.HorseModelController.SetRun(isRun: true);
		GameManager.instance.HideTutorialScreenMenu();
		GameManager.instance.SetControllerHintState(0);
		GameManager.instance.ShowControllerHintScreenMenu();
		player.SetTutorialState(3);
		while (CurTStep == TutorialStep.TurningR)
		{
			yield return null;
		}
		player.SetTutorialState(5);
		while (CurTStep == TutorialStep.StraightRun)
		{
			yield return null;
		}
		player.SpeedLineObject.SetActive(value: false);
		player.PauseHorse();
		player.curHorse.HorseModelController.SetRun(isRun: false);
		player.SetTutorialState(1);
		SoundManager.PlaySfx("TutorialFinish");
		GameManager.instance.TutorialHintCanvas.SetArrow(NeedArrow: false, isLeft: false);
		GameManager.instance.TutorialHintCanvas.SetText(csLocalizationManager.Instance.GetLocalText("CanvasIngame251"), NeedHand: false);
		GameManager.instance.ShowTutorialScreenMenu();
		GameManager.instance.HideControllerHintScreenMenu();
		yield return new WaitForSeconds(4f);
		player.SpeedLineObject.SetActive(value: true);
		player.PlayHorse();
		player.curHorse.HorseModelController.SetRun(isRun: true);
		GameManager.instance.HideTutorialScreenMenu();
		player.SetTutorialState(4);
	}

	public void Reset()
	{
		CurTStep = TutorialStep.None;
		if (TutorialCor != null)
		{
			StopCoroutine(TutorialCor);
		}
		GameManager.instance.HideControllerHintScreenMenu();
	}

	public void SetTutorialState(TutorialStep Step)
	{
		CurTStep = Step;
	}
}
public enum TutorialStep
{
	None,
	StraightRun,
	WaitForTurnL,
	TurningL,
	WaitForTurnR,
	TurningR
}
public class csTutorialTrigger : MonoBehaviour
{
	public TutorialStep TriggerState = TutorialStep.WaitForTurnL;

	public bool IsUsed;
}
public class HorseBarRotator : MonoBehaviour
{
	public Transform thisT;

	public float StartAngle;

	public float EndAngle = -35f;

	private void Awake()
	{
		thisT = base.transform;
	}

	public void SetBarRotate(float percent)
	{
		thisT.transform.localEulerAngles = new Vector3(0f, Mathf.Lerp(StartAngle, EndAngle, percent), 0f);
	}
}
public class HorseController : MonoBehaviour
{
	public Transform thisT;

	public Transform LookAtTarget;

	public csHorseModelController HorseModelController;

	private csFollower HorseFollower;

	private void Awake()
	{
		HorseFollower = GetComponent<csFollower>();
	}

	public void SetHorseLook(bool isLeft, float dis, float maxDis)
	{
		Vector3 localPosition = LookAtTarget.localPosition;
		localPosition.x = dis;
		LookAtTarget.localPosition = localPosition;
		if ((bool)HorseModelController.HorseBarL)
		{
			if (dis < 0f)
			{
				HorseModelController.HorseBarL.SetBarRotate((0f - dis) / maxDis);
				HorseModelController.HorseBarR.SetBarRotate(0f);
			}
			else
			{
				HorseModelController.HorseBarL.SetBarRotate(0f);
				HorseModelController.HorseBarR.SetBarRotate(dis / maxDis);
			}
		}
	}

	public void DoHorseReset()
	{
		HorseModelController.SetShow(isShow: true);
		HorseFollower.enabled = true;
	}

	public void DoHorseDrop(UnityAction actAfter)
	{
		HorseFollower.enabled = false;
		StartCoroutine(HorseDropCor(actAfter));
	}

	private IEnumerator HorseDropCor(UnityAction actAfter)
	{
		float RunTime = 3f;
		float t = 0f;
		float jumpgravity = csGameSettings.Jumpgravity;
		Vector3 startPos = thisT.transform.localPosition;
		while (t < RunTime)
		{
			t += Time.deltaTime;
			thisT.transform.localPosition = startPos + HorseFollower.targetT.forward * 20f * t - Vector3.up * 0.5f * t * t * jumpgravity;
			yield return new WaitForFixedUpdate();
		}
		actAfter?.Invoke();
	}
}
public class Multi_csObjectPool : MonoBehaviour
{
	public static Multi_csObjectPool Instance;

	public List<Multi_csGameObject> m_GameObjectPrefabs = new List<Multi_csGameObject>();

	private Dictionary<PreObjectType, Queue<GameObject>> m_GameObjcetsByType = new Dictionary<PreObjectType, Queue<GameObject>>();

	private Dictionary<GameObject, Multi_csGameObject> m_GameObjectByGO = new Dictionary<GameObject, Multi_csGameObject>();

	private Dictionary<GameObject, csGoldCoin> GoldScriptDic = new Dictionary<GameObject, csGoldCoin>();

	private void Awake()
	{
		Instance = this;
		for (int i = 0; i < m_GameObjectPrefabs.Count; i++)
		{
			Queue<GameObject> queue = new Queue<GameObject>();
			for (int j = 0; j < m_GameObjectPrefabs[i].m_MaxSize; j++)
			{
				GameObject gameObject = UnityEngine.Object.Instantiate(m_GameObjectPrefabs[i].m_Object);
				gameObject.transform.SetParent(base.transform);
				queue.Enqueue(gameObject);
				m_GameObjectByGO[gameObject] = m_GameObjectPrefabs[i];
				if (m_GameObjectPrefabs[i].m_Type == PreObjectType.GoldCoin)
				{
					GoldScriptDic[gameObject] = gameObject.GetComponent<csGoldCoin>();
				}
				gameObject.SetActive(value: false);
			}
			m_GameObjcetsByType[m_GameObjectPrefabs[i].m_Type] = queue;
		}
	}

	public csGoldCoin GoldScriptByObj(GameObject obj)
	{
		if (!GoldScriptDic.ContainsKey(obj))
		{
			return null;
		}
		return GoldScriptDic[obj];
	}

	public GameObject GetObjectByType(PreObjectType type, Vector3 postion, Vector3 fwd)
	{
		if (m_GameObjcetsByType[type].Count == 0)
		{
			return null;
		}
		GameObject obj = m_GameObjcetsByType[type].Dequeue();
		obj.transform.position = postion;
		obj.transform.rotation = Quaternion.LookRotation(fwd);
		obj.SetActive(value: true);
		return obj;
	}

	public void ReturnGameObjectIntoPool(GameObject go, bool delay)
	{
		if (delay)
		{
			if (m_GameObjectByGO.ContainsKey(go))
			{
				StartCoroutine(DelayToReset_GO(go));
			}
		}
		else if (m_GameObjectByGO.ContainsKey(go))
		{
			if (!m_GameObjcetsByType[m_GameObjectByGO[go].m_Type].Contains(go))
			{
				m_GameObjcetsByType[m_GameObjectByGO[go].m_Type].Enqueue(go);
			}
			if (go != null && base.transform != null)
			{
				go.transform.SetParent(base.transform);
				go.SetActive(value: false);
			}
		}
	}

	private IEnumerator DelayToReset_GO(GameObject go)
	{
		yield return new WaitForSeconds(5f);
		go.transform.SetParent(base.transform);
		go.SetActive(value: false);
		if (!m_GameObjcetsByType[m_GameObjectByGO[go].m_Type].Contains(go))
		{
			m_GameObjcetsByType[m_GameObjectByGO[go].m_Type].Enqueue(go);
		}
	}
}
[Serializable]
public class Multi_csGameObject
{
	public PreObjectType m_Type;

	public GameObject m_Object;

	public int m_MaxSize;
}
public class PoolObjSelfReturn : MonoBehaviour
{
	public float returnTime = 2f;

	private void OnEnable()
	{
		StartCoroutine(StartReturn());
	}

	private IEnumerator StartReturn()
	{
		yield return new WaitForSeconds(returnTime);
		Multi_csObjectPool.Instance.ReturnGameObjectIntoPool(base.gameObject, delay: true);
	}
}
public class PoolObjSelfReturn_MoveTo : MonoBehaviour
{
	public float returnTime = 2f;

	public float SpeedFly = 1f;

	public Transform thisT;

	public AudioClip[] ClipAdd;

	public AudioSource AS;

	public Transform finalPos;

	private void OnEnable()
	{
		StartCoroutine(StartReturn());
	}

	private IEnumerator StartReturn()
	{
		SpeedFly = 1f;
		float bustTime = UnityEngine.Random.Range(0.2f, 0.6f);
		float timer = bustTime;
		thisT.rotation = Quaternion.LookRotation(Vector3.up);
		thisT.Rotate(base.transform.forward, UnityEngine.Random.Range(0, 360));
		while (timer > 0f)
		{
			timer -= Time.deltaTime;
			SpeedFly = Mathf.Lerp(0f, 1f, timer / bustTime);
			base.transform.Translate(base.transform.forward * Time.deltaTime);
			yield return null;
		}
		thisT.rotation = Quaternion.LookRotation(finalPos.position - thisT.position);
		while (Vector3.Distance(thisT.position, finalPos.position) > 0.1f)
		{
			if (thisT.rotation != Quaternion.LookRotation(finalPos.position - thisT.position))
			{
				thisT.rotation = Quaternion.Lerp(thisT.rotation, Quaternion.LookRotation(finalPos.position - thisT.position), Time.deltaTime * 20f * SpeedFly);
			}
			SpeedFly += Time.deltaTime * 5f;
			base.transform.Translate(Vector3.forward * SpeedFly * Time.deltaTime);
			yield return null;
		}
		AS.PlayOneShot(ClipAdd[UnityEngine.Random.Range(0, ClipAdd.Length)]);
		Multi_csObjectPool.Instance.ReturnGameObjectIntoPool(base.gameObject, delay: false);
	}
}
public class csAudioTest : MonoBehaviour
{
	public AudioSource ass;

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.Space))
		{
			ass.pitch += 0.1f;
			ass.Play();
		}
		if (Input.GetKeyDown(KeyCode.R))
		{
			ass.pitch = 1f;
		}
	}
}
public class csCamRest : MonoBehaviour
{
	public Transform childT;

	private Transform thisT;

	private void Awake()
	{
		thisT = base.transform;
	}

	private void Update()
	{
		if ((bool)childT)
		{
			thisT.localPosition = -childT.localPosition;
		}
	}
}
public class csControllerRotationCopy : MonoBehaviour
{
	public Transform targetT;

	public Vector3 Offset;

	private Transform thisT;

	private void Awake()
	{
		thisT = base.transform;
	}

	private void Update()
	{
		thisT.localRotation = targetT.localRotation;
	}
}
public class csCubeList : MonoBehaviour
{
	public Transform[] cubeList;
}
public class csDeactiveOnParticleDone : MonoBehaviour
{
	public ParticleSystem particle;

	private GameObject thisG;

	private void Awake()
	{
		thisG = base.gameObject;
	}

	private void Update()
	{
		if (!particle.isPlaying)
		{
			thisG.SetActive(value: false);
		}
	}
}
public class csDuoPillarMoveAnim : MonoBehaviour
{
	public Transform moveTargetL;

	public Transform moveTargetR;

	public Vector2 LmoveRangeX;

	public Vector2 RmoveRangeX;

	public float moveDuration = 0.5f;

	public float waitTime = 4f;

	private IEnumerator Start()
	{
		while (true)
		{
			if (moveTargetL != null)
			{
				moveTargetL.transform.DOLocalMoveX(LmoveRangeX.x, moveDuration).SetEase(Ease.Linear);
			}
			if (moveTargetR != null)
			{
				moveTargetR.transform.DOLocalMoveX(RmoveRangeX.x, moveDuration).SetEase(Ease.Linear);
			}
			yield return new WaitForSeconds(waitTime);
			if (moveTargetL != null)
			{
				moveTargetL.transform.DOLocalMoveX(LmoveRangeX.y, moveDuration).SetEase(Ease.Linear);
			}
			if (moveTargetR != null)
			{
				moveTargetR.transform.DOLocalMoveX(RmoveRangeX.y, moveDuration).SetEase(Ease.Linear);
			}
			yield return new WaitForSeconds(waitTime);
		}
	}
}
public class csFadeManager : MonoBehaviour
{
	[SerializeField]
	private SpriteRenderer img;

	[SerializeField]
	private GameObject[] needToDeActiveObjs;

	public CanvasGroup LoadingCG;

	[SerializeField]
	private SpriteRenderer HintImg;

	private void Awake()
	{
		LoadingCG.alpha = 0f;
		SetHintSprite(isOn: false);
	}

	public void SetHintSprite(bool isOn)
	{
		if (isOn)
		{
			HintImg.color = new Color32(0, 0, 0, 200);
		}
		else
		{
			HintImg.color = new Color32(0, 0, 0, 0);
		}
	}

	public void SetFadeAlpha(float a)
	{
		img.color = new Color(img.color.r, img.color.g, img.color.b, a);
	}

	public void FadeIn(TweenCallback callback = null, float fadeTime = 1f)
	{
		base.gameObject.SetActive(value: true);
		img.DOFade(0f, fadeTime).OnComplete(delegate
		{
			if (callback != null)
			{
				callback();
			}
		}).SetUpdate(isIndependentUpdate: true);
	}

	public void FadeOut(TweenCallback callback = null, float fadeTime = 1f, bool needLoading = false)
	{
		img.DOFade(1f, 1f).OnComplete(delegate
		{
			if (needToDeActiveObjs.Length != 0)
			{
				for (int i = 0; i < needToDeActiveObjs.Length; i++)
				{
					needToDeActiveObjs[i].SetActive(value: false);
				}
			}
			if (callback != null && !needLoading)
			{
				callback();
			}
		}).SetUpdate(isIndependentUpdate: true);
	}
}
public class csFollower : MonoBehaviour
{
	public Transform targetT;

	public Vector3 offset;

	private Transform thisT;

	public float offsety = -2f;

	private bool first = true;

	private void Awake()
	{
		thisT = base.transform;
		thisT.position = targetT.position + targetT.up * offsety;
		thisT.rotation = Quaternion.LookRotation(targetT.forward, targetT.up);
	}

	private void Update()
	{
		if (first)
		{
			first = false;
		}
		else
		{
			thisT.position = Vector3.Lerp(thisT.position, targetT.position + targetT.up * offsety, 1f);
		}
		thisT.rotation = Quaternion.Lerp(thisT.rotation, Quaternion.LookRotation(targetT.forward, targetT.up), 1f);
	}
}
public class csFollowerRotation : MonoBehaviour
{
	public Transform targetT;

	public Vector3 offset;

	private Transform thisT;

	private void Awake()
	{
		thisT = base.transform;
	}

	private void Update()
	{
		thisT.rotation = Quaternion.LookRotation(-targetT.forward, targetT.up);
	}
}
public class csGizmosZ : MonoBehaviour
{
	private void OnDrawGizmos()
	{
		Gizmos.color = Color.red;
		Gizmos.DrawSphere(base.transform.position, 0.15f);
		Gizmos.DrawLine(base.transform.position, base.transform.position + base.transform.forward * 1f);
	}
}
public class csIngameAchievementItem : MonoBehaviour
{
	public Transform YesImage;

	public Text AchievementTitle;

	public void Init(AchievementType m_AchievementType)
	{
		YesImage.transform.localScale = Vector3.one * 1.5f;
		YesImage.DOScale(1f, 0.3f);
		AchievementTitle.text = csLocalizationManager.Instance.GetLocalText(m_AchievementType.ToString() + "_B");
	}
}
public class csLightEffectAnim : MonoBehaviour
{
	public float scrollSpeed = 0.5f;

	public Renderer rend;

	private void Update()
	{
		float y = Time.time * scrollSpeed;
		rend.material.SetTextureOffset("_MainTex", new Vector2(0f, y));
	}
}
public class csLoadingFade : MonoBehaviour
{
	[SerializeField]
	private SpriteRenderer img;

	public void SetFadeAlpha(float a)
	{
		img.color = new Color(img.color.r, img.color.g, img.color.b, a);
	}

	public void FadeIn(TweenCallback callback = null, float fadeTime = 1f)
	{
		base.gameObject.SetActive(value: true);
		img.DOFade(0f, fadeTime).OnComplete(delegate
		{
			if (callback != null)
			{
				callback();
			}
		}).SetUpdate(isIndependentUpdate: true);
	}

	public void FadeOut(TweenCallback callback = null, float fadeTime = 1f, bool needLoading = false)
	{
		img.DOFade(1f, 1f).OnComplete(delegate
		{
			if (callback != null && !needLoading)
			{
				callback();
			}
		}).SetUpdate(isIndependentUpdate: true);
	}
}
public class csMainmenuRoadAnimation : MonoBehaviour
{
	public Transform[] roadItemList;

	public float gapTime = 0.2f;

	public float moveTime = 0.3f;

	public float moveEndY = 18.56f;

	public void StartLoading()
	{
		StartCoroutine(LoadingRoadAnim());
	}

	private IEnumerator LoadingRoadAnim()
	{
		while (true)
		{
			for (int i = 0; i < roadItemList.Length; i++)
			{
				roadItemList[i].DOLocalMoveY(moveEndY + (float)i * 0.5f, moveTime);
				yield return new WaitForSeconds(gapTime);
			}
		}
	}
}
public class csMovingBallCheck : MonoBehaviour
{
	public bool TouchLeft;

	public bool TouchRight;

	public Transform leftPoint;

	public Transform LStopT;

	public Transform rightPoint;

	public Transform RStopT;

	private void OnTriggerEnter(Collider ote)
	{
		if (ote.name == "LCollider" && !TouchLeft)
		{
			TouchLeft = true;
			TouchRight = false;
		}
		if (ote.name == "RCollider" && !TouchRight)
		{
			TouchLeft = false;
			TouchRight = true;
		}
	}

	private void OnTriggerExit(Collider ote)
	{
		if (ote.name == "LCollider" && TouchLeft)
		{
			TouchLeft = false;
		}
		if (ote.name == "RCollider" && TouchRight)
		{
			TouchRight = false;
		}
	}
}
public class csNPCFollower : MonoBehaviour
{
	public Transform targetPosT;

	public Transform targetRotT;

	public Vector3 offset;

	private Transform thisT;

	public float offsety = -2f;

	private void Awake()
	{
		thisT = base.transform;
	}

	private void Update()
	{
		thisT.position = Vector3.Lerp(thisT.position, targetPosT.position + thisT.up * offsety, 1f);
		thisT.rotation = Quaternion.Lerp(thisT.rotation, Quaternion.LookRotation(targetRotT.forward, targetRotT.up), 0.2f);
	}
}
public class csOffsetMaterialAnim : MonoBehaviour
{
	public Renderer mr;

	public float moveSpeed = 2f;

	private float offsetX;

	public bool isOffsetY;

	private void Update()
	{
		offsetX += moveSpeed * Time.deltaTime;
		if (!isOffsetY)
		{
			mr.material.SetTextureOffset("_MainTex", new Vector2(0f, offsetX));
		}
		else
		{
			mr.material.SetTextureOffset("_MainTex", new Vector2(offsetX, 0f));
		}
	}
}
public class csOffsetPositionAnim : MonoBehaviour
{
	public Transform moveTarget;

	private Transform thisT;

	[Tooltip("移动时间")]
	public float moveDuration = 2f;

	[Tooltip("等待时间")]
	public float waitTime = 2f;

	public float offsetValue = 5f;

	public bool isFristMoveUp;

	[Tooltip("平滑过渡")]
	public Ease ease = Ease.InOutQuad;

	private void Awake()
	{
		if (moveTarget == null)
		{
			moveTarget = base.transform;
		}
	}

	private IEnumerator Start()
	{
		while (true)
		{
			if (isFristMoveUp)
			{
				moveTarget.transform.DOLocalMoveY(moveTarget.localPosition.y + offsetValue, moveDuration).SetEase(ease);
				yield return new WaitForSeconds(waitTime);
				moveTarget.transform.DOLocalMoveY(moveTarget.localPosition.y - offsetValue, moveDuration).SetEase(ease);
				yield return new WaitForSeconds(waitTime);
			}
			else
			{
				moveTarget.transform.DOLocalMoveY(moveTarget.localPosition.y - offsetValue, moveDuration).SetEase(ease);
				yield return new WaitForSeconds(waitTime);
				moveTarget.transform.DOLocalMoveY(moveTarget.localPosition.y + offsetValue, moveDuration).SetEase(ease);
				yield return new WaitForSeconds(waitTime);
			}
		}
	}
}
public class csPillarMoveAnim : MonoBehaviour
{
	public Transform moveTarget;

	public Vector3 moveRangeX;

	public float moveDuration = 0.5f;

	public float waitTime = 4f;

	private IEnumerator Start()
	{
		while (true)
		{
			moveTarget.transform.DOLocalMoveX(moveRangeX.x, moveDuration);
			yield return new WaitForSeconds(waitTime);
			moveTarget.transform.DOLocalMoveX(moveRangeX.y, moveDuration);
			yield return new WaitForSeconds(waitTime);
		}
	}
}
public class csRope : MonoBehaviour
{
	public Renderer Rope1MR;

	public Renderer Rope2MR;

	public Transform[] targetStartsT;

	public Transform[] targetEndsT;

	public LineRenderer[] ropeLines;

	public bool isShow = true;

	private void Update()
	{
		ropeLines[0].SetPosition(0, targetStartsT[0].position);
		ropeLines[0].SetPosition(1, targetEndsT[0].position);
		ropeLines[1].SetPosition(0, targetStartsT[1].position);
		ropeLines[1].SetPosition(1, targetEndsT[1].position);
	}

	public void HideRope()
	{
		Rope1MR.enabled = false;
		Rope2MR.enabled = false;
		isShow = false;
	}

	public void ShowRope()
	{
		Rope1MR.enabled = true;
		Rope2MR.enabled = true;
		isShow = true;
	}
}
public class csRopeAnim : MonoBehaviour
{
	public Renderer mr;

	public float moveSpeed = 2f;

	private float offsetX;

	private void Update()
	{
		offsetX += moveSpeed * Time.deltaTime;
		mr.material.SetTextureOffset("_MainTex", new Vector2(offsetX, 0f));
	}
}
public enum MainMenuType
{
	MainMenu,
	Loading,
	HorseShop,
	PropShop,
	Achievement,
	Endless,
	BoxAward,
	ChangeName
}
public enum UIHintType
{
	ScoreHint
}
[Serializable]
public class csUIHintObject
{
	public UIHintType m_Type;

	public GameObject m_Object;

	public int m_MaxSize;
}
public class HorseTypePrice
{
	public HorseType m_HorseType;

	public int m_Price;

	public HorseTypePrice(HorseType ht, int p)
	{
		m_HorseType = ht;
		m_Price = p;
	}
}
public enum ShopItem
{
	Item_001_RushS = 1,
	Item_002_RushM = 2,
	Item_003_RushB = 3,
	Item_004_ShieldS = 4,
	Item_005_ShieldM = 5,
	Item_006_ShieldB = 6,
	Item_007_AddLifeS = 7,
	Item_008_GoldBuffS = 8,
	Item_009_GoldBuffM = 9,
	Item_010_GoldBuffB = 10,
	Item_011_ScoreBuffS = 11,
	Item_012_ScoreBuffM = 12,
	Item_013_ScoreBuffB = 13,
	Item_080_GoldS = 80,
	Item_081_GoldM = 81,
	Item_082_GoldB = 82,
	Item_083_GoldL = 83,
	Item_090_GemS = 90,
	Item_091_GemM = 91,
	Item_092_GemB = 92
}
[Serializable]
public class LevelAward
{
	public AheadBuff AwardBuff;

	public int AwardNum;
}
[Serializable]
public class LevelAwardData
{
	public string LevelNum;

	public int CoinNum;

	public int GemNum;

	public List<LevelAward> LevelAward = new List<LevelAward>();
}
[Serializable]
public class IntAwardRightData
{
	public int GiftNum;

	public int Right;
}
[Serializable]
public class BuffAwardRightData
{
	public AheadBuff BuffType;

	public int BuffNum;

	public int Right;
}
public enum AheadBuff
{
	RushS = 1,
	RushM,
	RushB,
	ShieldS,
	ShieldM,
	ShieldB,
	AddLifeS,
	GoldBuffS,
	GoldBuffM,
	GoldBuffB,
	ScoreBuffS,
	ScoreBuffM,
	ScoreBuffB
}
[Serializable]
public class BuffData
{
	public AheadBuff BuffName;

	public float EffectValue;
}
[Serializable]
public class HorseBasicLevelData
{
	public int Level;

	public float SteerSpeed;

	public float GoldMultiplier;

	public int LifeMax;

	public float Luck;

	public float ScoreMultiplier;

	public HorseBasicLevelData(int l, float ss, float gm, int lm, float lu, float sm)
	{
		Level = l;
		SteerSpeed = ss;
		GoldMultiplier = gm;
		LifeMax = lm;
		Luck = lm;
		ScoreMultiplier = sm;
	}
}
[Serializable]
public class PropObjRight
{
	public PreObjectType ItemType = PreObjectType.RushPower;

	public int Right = 10;
}
[Serializable]
public class HorseSkillLevelData
{
	public int Level;

	public List<PreObjectType> EffectItemIDList;

	public List<HorseSkill> EffectSkillIDList;

	public float SkillTimeFactor;

	public float SkillCDFactor;

	public float ItemTimeFactor;

	public HorseSkillLevelData(int l, List<PreObjectType> EItemID, List<HorseSkill> hsl, float _SkillTimeFactor, float _SkillCDFactor, float _ItemTimeFactor)
	{
		Level = l;
		EffectItemIDList = EItemID;
		EffectSkillIDList = hsl;
		SkillTimeFactor = _SkillTimeFactor;
		SkillCDFactor = _SkillCDFactor;
		ItemTimeFactor = _ItemTimeFactor;
	}
}
[Serializable]
public class ItemLevelDataList
{
	public List<ItemLevelData> ItemDataList;

	public ItemLevelDataList(List<ItemLevelData> sdl)
	{
		ItemDataList = sdl;
	}
}
[Serializable]
public class ItemLevelData
{
	public string ItemID;

	public PreObjectType ItemType;

	public List<ItemDataObject> LevelData;

	public ItemLevelData(string id, PreObjectType st, List<ItemDataObject> ld)
	{
		ItemID = id;
		ItemType = st;
		LevelData = ld;
	}
}
[Serializable]
public class ItemDataObject
{
	public int Level;

	public float AddEffectTime;

	public ItemDataObject(int l, float at)
	{
		Level = l;
		AddEffectTime = at;
	}
}
[Serializable]
public class SkillLevelDataList
{
	public List<SkillLevelData> SkillDataList;

	public SkillLevelDataList(List<SkillLevelData> sdl)
	{
		SkillDataList = sdl;
	}
}
[Serializable]
public class SkillLevelData
{
	public string SkillID;

	public HorseSkill Skilltype;

	public List<SkillDataObject> LevelData;

	public SkillLevelData(string id, HorseSkill st, List<SkillDataObject> ld)
	{
		SkillID = id;
		Skilltype = st;
		LevelData = ld;
	}
}
[Serializable]
public class SkillDataObject
{
	public int Level;

	public float EffectTime;

	public float CDTime;

	public SkillDataObject(int l, float etime, float cd)
	{
		Level = l;
		EffectTime = etime;
		CDTime = cd;
	}
}
[Serializable]
public class HorseData
{
	public HorseType HosrseType;

	public string HorseNameID;

	public int Price;

	public List<HorseBasicLevelData> BasicDataByLevel = new List<HorseBasicLevelData>();

	public List<HorseSkillLevelData> SkillDataByLevel = new List<HorseSkillLevelData>();

	public HorseData(HorseType ht, string nId, int pr, List<HorseBasicLevelData> Bl, List<HorseSkillLevelData> Sl)
	{
		HosrseType = ht;
		HorseNameID = nId;
		Price = pr;
		BasicDataByLevel = Bl;
		SkillDataByLevel = Sl;
	}
}
public class HorseDataInGame
{
	public HorseType HosrseType;

	public string HorseNameID;

	public int Price;

	public HorseBasicLevelData BasicData;

	public HorseSkillLevelData SkillData;

	public HorseDataInGame(HorseType ht, string nId, int pr, HorseBasicLevelData Bl, HorseSkillLevelData Sl)
	{
		HosrseType = ht;
		HorseNameID = nId;
		Price = pr;
		BasicData = Bl;
		SkillData = Sl;
	}
}
public class HorseDataJsonList
{
	public List<HorseData> HorseDataList;

	public HorseDataJsonList(List<HorseData> HL)
	{
		HorseDataList = HL;
	}
}
public enum HorseSkill
{
	None,
	Sprint,
	Invincible,
	Slow,
	Strike,
	Anticol,
	Jump,
	ShieldBuff,
	Roar,
	Fly
}
public enum ChannelType
{
	PC,
	WaveVR_3Dof,
	WaveVR_6Dof,
	OculusGO,
	OculusQuest,
	Pico6Dof
}
public enum HorseType
{
	Horse_Default = 0,
	Horse_1 = 1,
	Horse_2 = 2,
	Horse_3 = 3,
	Horse_4 = 4,
	Horse_5 = 5,
	Horse_6 = 6,
	Rhino_1 = 7,
	Crocodile = 8,
	Elephant = 9,
	DragonBoss = 10,
	None = 99
}
public enum FlagType
{
	unknow,
	CN
}
public enum PreObjectType
{
	GoldCoin,
	Sheild,
	RushPower,
	Magnet,
	HPAdd_Small,
	HPAdd_Big,
	Particle_HitWall,
	Particle_HitRollCube,
	Monster_1,
	BloodEffect
}
public enum SceneObstacleType
{
	Jumper = 1,
	SpeedBurster
}
[Serializable]
public class LevelInfoList
{
	public List<LevelInfo> m_LevelInfoList = new List<LevelInfo>();

	public LevelInfoList(List<LevelInfo> _LevelInfoList)
	{
		m_LevelInfoList = _LevelInfoList;
	}
}
[Serializable]
public class LevelInfo
{
	public int Level;

	public ExtraUnLockType m_UnLockType;

	public int UnLockParameter;

	public List<MissionDataInfo> m_MissionDataList = new List<MissionDataInfo>();

	public LevelInfo(int _Level, ExtraUnLockType _UnLockType, int _UnLockParameter, List<MissionDataInfo> _MissionDataList)
	{
		Level = _Level;
		m_UnLockType = _UnLockType;
		UnLockParameter = _UnLockParameter;
		m_MissionDataList = _MissionDataList;
	}
}
[Serializable]
public class PlayerLevelDataList
{
	public List<PlayerLevelData> m_PlayerLevelDataList = new List<PlayerLevelData>();

	public PlayerLevelDataList(List<PlayerLevelData> _PlayerLevelDataList)
	{
		m_PlayerLevelDataList = _PlayerLevelDataList;
	}
}
[Serializable]
public class PlayerLevelData
{
	public int Level;

	public int StarsNum;

	public bool isUnLock;

	public int BestScore;

	public int LastScore;

	public float BestTime;

	public float LastTime;

	public PlayerLevelData(int _level, int _stars, bool _isunlock, int _bestscore, int _lastscore, float _besttime, float _lasttime)
	{
		Level = _level;
		StarsNum = _stars;
		isUnLock = _isunlock;
		BestScore = _bestscore;
		LastScore = _lastscore;
		BestTime = _besttime;
		LastTime = _lasttime;
	}
}
public enum ExtraUnLockType
{
	None,
	StarNum,
	MaxEndlessLevel
}
public enum csMissionType
{
	Task_01 = 1001,
	Task_02,
	Task_03,
	Task_04,
	Task_05,
	Task_06,
	Task_07,
	Task_08,
	Task_09,
	Task_10
}
[Serializable]
public class MissionDataInfo
{
	public csMissionType _Type;

	[NonSerialized]
	public bool isComplet;

	public int Parameter_1;

	public int Parameter_2;

	public MissionDataInfo(MissionDataInfo _info)
	{
		_Type = _info._Type;
		isComplet = _info.isComplet;
		Parameter_1 = _info.Parameter_1;
		Parameter_2 = _info.Parameter_2;
	}
}
public enum GameMode
{
	LevelMode,
	EndlessMode
}
public enum AchievementType
{
	Target_001,
	Target_002,
	Target_003,
	Target_004,
	Target_005,
	Target_006,
	Target_007,
	Target_008,
	Target_009,
	Target_010,
	Target_011,
	Target_012,
	Target_013,
	Target_014,
	Target_015,
	Target_016,
	Target_017,
	Target_018,
	Target_019,
	Target_020,
	Target_021,
	Target_022,
	Target_023,
	Target_024,
	Target_025,
	Target_026,
	Target_027,
	Target_028,
	Target_029,
	Target_030,
	Target_031,
	Target_032,
	Target_033,
	Target_034,
	Target_035,
	Target_036,
	Target_037,
	Target_038,
	Target_039,
	Target_040,
	Target_041,
	Target_042,
	Target_043,
	Target_044,
	Target_045,
	Target_046,
	Target_047,
	Target_048,
	Target_049
}
public enum AchievementAwardType
{
	None,
	Coin,
	Diamond
}
public enum AchievementState
{
	UnComplet,
	UnReceived,
	Received
}
[Serializable]
public class AchievementDataList
{
	public List<AchievementDataInfo> m_AchievementDataList = new List<AchievementDataInfo>();

	public AchievementDataList(List<AchievementDataInfo> _AchievementDataList)
	{
		m_AchievementDataList = _AchievementDataList;
	}
}
[Serializable]
public class AchievementDataInfo
{
	public AchievementType m_AchievementType;

	public int MaxValue;

	public int CurrentValue;

	public AchievementAwardType m_AwardType;

	public int AwardCount;

	public AchievementState m_AchievementState;

	public string CompleteTime = "";

	public AchievementDataInfo(AchievementType _AchievementType, int _MaxValue, int _CurrentValue, AchievementAwardType _AwardType, int _AwardCount, AchievementState _AchievementState, string _CompleteTime = "")
	{
		m_AchievementType = _AchievementType;
		MaxValue = _MaxValue;
		CurrentValue = _CurrentValue;
		m_AwardType = _AwardType;
		AwardCount = _AwardCount;
		m_AchievementState = _AchievementState;
		CompleteTime = _CompleteTime;
	}
}
public enum CurrencyType
{
	Coin,
	Gem,
	Money
}
public enum ItemShopColType
{
	PropShop,
	CoinShop,
	GemShop
}
public enum AwardItemType
{
	Prop,
	Coin,
	Gem
}
public class csHorseInfo
{
	public string Name;

	public int StarNum;

	public float RunningSpeed;

	public float SteeringSpeed;

	public int AbilityIconIndex;

	public string AbilityContent;

	public string StoryContent;

	public bool IsGemPrice;

	public int UnLockCoin;

	public List<int> BasicPriceList;

	public List<int> SpeicalPriceList;

	public csHorseInfo(string _Name, int _StarNum, float _RunningSpeed, float _SteeringSpeed, int _AbilityIconIndex, string _AbilityContent, string _StoryContent, bool _IsGemPrice, int _UnLockCoin, List<int> bpl, List<int> spl)
	{
		Name = _Name;
		StarNum = _StarNum;
		RunningSpeed = _RunningSpeed;
		SteeringSpeed = _SteeringSpeed;
		AbilityIconIndex = _AbilityIconIndex;
		AbilityContent = _AbilityContent;
		StoryContent = _StoryContent;
		IsGemPrice = _IsGemPrice;
		UnLockCoin = _UnLockCoin;
		BasicPriceList = bpl;
		SpeicalPriceList = spl;
	}
}
public class ResultAwardData
{
	public int CoinNum;

	public int GemNum;

	public AheadBuff AwardBuff;

	public int BuffNum;

	public ResultAwardData(int c, int gemn, AheadBuff buff, int n)
	{
		CoinNum = c;
		GemNum = gemn;
		AwardBuff = buff;
		BuffNum = n;
	}
}
[Serializable]
public class TextFontData
{
	public Language Lan;

	public TMP_FontAsset FontAsset;

	public TMP_FontAsset FontAssetSmall;

	public TMP_FontAsset FontAssetBold;

	public TMP_FontAsset FontAssetDepth;

	public TMP_FontAsset FontAssetBoldDepth;

	public Font FDefault;

	public Font FBold;
}
public class csGoldCoin : csPropBase
{
	public int GoldNum = 1;

	private Transform HorseRootPosT;

	private bool MagTrigged;

	public override void OnCollected()
	{
		Apply();
		GameManager.Player.PlayGoldGet();
		Multi_csObjectPool.Instance.ReturnGameObjectIntoPool(base.gameObject, delay: false);
	}

	protected override void Apply()
	{
		if (GameManager.CurrentState == GameManager.GameState.Playing)
		{
			GameManager.LevelManager.OnCoinGet(GoldNum);
		}
	}

	public void TriggerMag()
	{
		if (!MagTrigged)
		{
			MagTrigged = true;
			if (base.gameObject.activeSelf)
			{
				StartCoroutine(MagLerpCor());
			}
			else
			{
				MagTrigged = false;
			}
		}
	}

	private void OnDisable()
	{
		MagTrigged = false;
	}

	private IEnumerator MagLerpCor()
	{
		float time = 0.5f;
		float oriTime = time;
		if (HorseRootPosT == null)
		{
			HorseRootPosT = GameManager.Player.transform;
		}
		Vector3 startPos = thisT.position;
		while (time > 0f)
		{
			time -= Time.deltaTime;
			thisT.position = Vector3.Lerp(HorseRootPosT.position + Vector3.forward * 3f - HorseRootPosT.up * 1f, startPos, time / oriTime);
			yield return null;
		}
	}
}
public class csMosterBase : MonoBehaviour
{
	public void Recycle(Transform finalpos)
	{
		Multi_csObjectPool.Instance.GetObjectByType(PreObjectType.BloodEffect, base.transform.position, Vector3.forward).GetComponent<PoolObjSelfReturn_MoveTo>().finalPos = finalpos;
		Multi_csObjectPool.Instance.ReturnGameObjectIntoPool(base.gameObject, delay: false);
	}
}
public class csMovingPillar : MonoBehaviour
{
	public Transform dt1;

	public float waitTime = 3f;

	public float moveTime = 0.2f;

	public float Dt1DownPosY = 11.1f;

	public float Dt1UpPosY = 14f;

	private IEnumerator Start()
	{
		if (!(dt1 != null))
		{
			yield break;
		}
		while (true)
		{
			if (dt1 != null)
			{
				dt1.DOLocalMoveY(Dt1UpPosY, moveTime).SetEase(Ease.Linear);
			}
			yield return new WaitForSeconds(waitTime);
			if (dt1 != null)
			{
				dt1.DOLocalMoveY(Dt1DownPosY, moveTime).SetEase(Ease.Linear);
			}
			yield return new WaitForSeconds(waitTime);
		}
	}
}
public class csPropBase : Interactable
{
	public PreObjectType PropObjType;

	public AudioClip[] OnGetClip;

	public Transform thisT;

	private void Awake()
	{
		thisT = base.transform;
	}

	public override void OnCollected()
	{
		Apply();
		GameManager.Player.ASSSelf.PlayOneShot(OnGetClip[UnityEngine.Random.Range(0, OnGetClip.Length)]);
		Multi_csObjectPool.Instance.ReturnGameObjectIntoPool(base.gameObject, delay: false);
	}

	protected override void Apply()
	{
	}
}
public class csPropHPAdd : csPropBase
{
	protected override void Apply()
	{
		if (GameManager.CurrentState == GameManager.GameState.Playing)
		{
			if (PropObjType == PreObjectType.HPAdd_Small)
			{
				GameManager.Player.OnHPAdd(1);
			}
			else
			{
				GameManager.Player.OnHPAdd(3);
			}
		}
	}
}
public class csPropIniter : MonoBehaviour
{
	public PreObjectType PropObjType;

	public Transform thisT;

	private void Awake()
	{
		thisT = base.transform;
	}

	public void DestroyShowCase()
	{
		Transform child = base.transform.GetChild(0);
		if ((bool)child)
		{
			UnityEngine.Object.DestroyImmediate(child.gameObject);
		}
	}
}
public class csPropMagnet : csPropBase
{
	protected override void Apply()
	{
		if (GameManager.CurrentState == GameManager.GameState.Playing)
		{
			GameManager.Player.SetMagOn();
		}
	}
}
public class csPropPowerUp : csPropBase
{
	protected override void Apply()
	{
		if (GameManager.CurrentState == GameManager.GameState.Playing)
		{
			GameManager.Player.SetRushOn();
		}
	}
}
public class csPropSheild : csPropBase
{
	protected override void Apply()
	{
		if (GameManager.CurrentState == GameManager.GameState.Playing)
		{
			GameManager.Player.SetSheildOn();
		}
	}
}
public class csPropTrigger : MonoBehaviour
{
}
public class csSceneItemOpenAndClose : MonoBehaviour
{
	public Transform dt1;

	public Transform dt2;

	public float waitTime = 3f;

	public float moveTime = 0.2f;

	public float Dt1DownPosY = 11.1f;

	public float Dt1UpPosY = 14f;

	public float Dt2DownPosY = -2.4f;

	public float Dt2UpPosY = -5f;

	private IEnumerator Start()
	{
		if (!(dt1 != null) && !(dt2 != null))
		{
			yield break;
		}
		while (true)
		{
			if (dt1 != null)
			{
				dt1.DOLocalMoveY(Dt1UpPosY, moveTime);
			}
			if (dt2 != null)
			{
				dt2.DOLocalMoveY(Dt2UpPosY, moveTime);
			}
			yield return new WaitForSeconds(waitTime);
			if (dt1 != null)
			{
				dt1.DOLocalMoveY(Dt1DownPosY, moveTime);
			}
			if (dt2 != null)
			{
				dt2.DOLocalMoveY(Dt2DownPosY, moveTime);
			}
			yield return new WaitForSeconds(waitTime);
		}
	}
}
public class csSceneItemOpenAndCloseOneDoor : MonoBehaviour
{
	public Transform dt1;

	public float waitTime = 3f;

	public float moveTime = 0.2f;

	public float Dt1DownPosX = 11.1f;

	public float Dt1UpPosX = 14f;

	private IEnumerator Start()
	{
		if (!(dt1 != null))
		{
			yield break;
		}
		while (true)
		{
			if (dt1 != null)
			{
				dt1.DOLocalMoveX(Dt1UpPosX, moveTime).SetEase(Ease.Linear);
			}
			yield return new WaitForSeconds(waitTime);
			if (dt1 != null)
			{
				dt1.DOLocalMoveX(Dt1DownPosX, moveTime).SetEase(Ease.Linear);
			}
			yield return new WaitForSeconds(waitTime);
		}
	}
}
public class csSceneItemSixPillar : MonoBehaviour
{
	public Transform[] itemList;

	public float waitTime = 3f;

	public float moveTime = 0.2f;

	public float waitTimeAdd = 0.2f;

	public float DownPosY = 11.1f;

	public float UpPosY = 14f;

	public float moveTimeAdd = 0.3f;

	public float downWaitTime = 2f;

	private float[] localPosList;

	private IEnumerator Start()
	{
		localPosList = new float[8];
		for (int num = 0; num < itemList.Length; num++)
		{
			localPosList[num] = itemList[num].localPosition.y;
		}
		if (itemList.Length == 0)
		{
			yield break;
		}
		while (true)
		{
			int startIndex = UnityEngine.Random.Range(0, 8);
			int nextIndex = ((startIndex + 1 != 8) ? (startIndex + 1) : 0);
			if (startIndex > nextIndex)
			{
				int count = 0;
				for (int j = nextIndex; j < startIndex; j++)
				{
					_ = itemList[j].position;
					float endValue = UpPosY + (float)count * DownPosY;
					itemList[j].DOLocalMoveY(endValue, moveTime + (float)count * moveTimeAdd).SetEase(Ease.Linear);
					yield return new WaitForSeconds(waitTime + (float)count * waitTimeAdd);
					count++;
				}
				yield return new WaitForSeconds(downWaitTime);
				for (int j = nextIndex; j < startIndex; j++)
				{
					float endValue2 = localPosList[j];
					itemList[j].DOLocalMoveY(endValue2, moveTime).SetEase(Ease.Linear);
					yield return new WaitForSeconds(waitTime);
					count++;
				}
			}
			else
			{
				int count = 0;
				for (int j = nextIndex + 1; j < 8; j++)
				{
					float endValue3 = UpPosY + (float)count * DownPosY;
					itemList[j].DOLocalMoveY(endValue3, moveTime + (float)count * moveTimeAdd).SetEase(Ease.Linear);
					yield return new WaitForSeconds(waitTime + (float)count * waitTimeAdd);
					count++;
				}
				for (int j = 0; j < startIndex; j++)
				{
					_ = itemList[j].position;
					itemList[j].DOLocalMoveY(UpPosY + (float)count * DownPosY, moveTime + (float)count * moveTimeAdd).SetEase(Ease.Linear);
					yield return new WaitForSeconds(waitTime + (float)count * waitTimeAdd);
					count++;
				}
				yield return new WaitForSeconds(downWaitTime);
				for (int j = nextIndex + 1; j < 8; j++)
				{
					itemList[j].DOLocalMoveY(localPosList[j], moveTime).SetEase(Ease.Linear);
					yield return new WaitForSeconds(waitTime);
					count++;
				}
				for (int j = 0; j < startIndex; j++)
				{
					itemList[j].DOLocalMoveY(localPosList[j], moveTime).SetEase(Ease.Linear);
					yield return new WaitForSeconds(waitTime);
					count++;
				}
			}
			yield return new WaitForSeconds(downWaitTime);
		}
	}

	private void OnDrawGizmos()
	{
		for (int i = 0; i < itemList.Length; i++)
		{
			Gizmos.color = Color.red;
		}
	}
}
public class csSceneObstacleBase : Interactable
{
	protected bool Usable = true;

	public AudioClip[] OnGetClip;

	public SceneObstacleType ObstacleType = SceneObstacleType.Jumper;

	public override void OnCollected()
	{
		if (Usable)
		{
			Apply();
			if (OnGetClip.Length != 0)
			{
				GameManager.Player.ASSSelf.PlayOneShot(OnGetClip[UnityEngine.Random.Range(0, OnGetClip.Length)]);
			}
			GameManager.Player.OnIntactObstacle(ObstacleType);
			Usable = false;
		}
	}

	protected override void Apply()
	{
	}
}
public class csSceneObstacleJumper : csSceneObstacleBase
{
	public bool ForceJump;

	public float JumpHeight = 5f;

	public float JumpDist = 5f;

	public override void OnCollected()
	{
		if (Usable)
		{
			Apply();
			if (OnGetClip.Length != 0)
			{
				GameManager.Player.ASSSelf.PlayOneShot(OnGetClip[UnityEngine.Random.Range(0, OnGetClip.Length)]);
			}
			GameManager.Player.OnIntactObstacle(ObstacleType, JumpHeight, ForceJump ? JumpDist : 0f);
			Usable = false;
		}
	}
}
public class csSceneObstacleSpeedBurst : csSceneObstacleBase
{
}
public class csTunnelColorChild : MonoBehaviour
{
	public MeshRenderer mr;

	public SCENEOBJTYPE type;

	[HideInInspector]
	public Vector3 originalScale;

	private void Awake()
	{
		mr = GetComponent<MeshRenderer>();
		originalScale = base.transform.localScale;
		if (type == SCENEOBJTYPE.WALL && base.gameObject.GetComponent<Collider>() == null)
		{
			base.gameObject.AddComponent<MeshCollider>();
		}
	}

	public bool IsActive()
	{
		return base.gameObject.activeSelf;
	}
}
public enum SCENEOBJTYPE
{
	NONE = -1,
	WALL,
	OBSTACLE,
	ROLLCUBE
}
public class csTunnelSpreader : Interactable
{
	public float StartRadius = 8f;

	public float EndRadus = 11.4f;

	public Transform StartT;

	public Transform EndT;

	public float Length;

	private bool IsUsed = true;

	public Collider Col;

	private void Awake()
	{
		Length = EndT.localPosition.z - StartT.localPosition.z;
	}

	public override void OnCollected()
	{
		Apply();
	}

	protected override void Apply()
	{
		GameManager.Player.OnEnableRoadCheck(isEnable: true, this);
		Col.enabled = false;
		IsUsed = false;
	}

	private void Update()
	{
		if (!IsUsed && EndT.position.z < 0f)
		{
			IsUsed = true;
			GameManager.Player.OnEnableRoadCheck(isEnable: false, this);
		}
	}
}
public class csLocalImage : MonoBehaviour
{
	public string id;

	private Image m_Sprite;

	private void Awake()
	{
		m_Sprite = GetComponent<Image>();
	}

	private void OnEnable()
	{
		if (m_Sprite != null)
		{
			m_Sprite.overrideSprite = csLocalizationManager.Instance.GetLocalSprite(id);
		}
		csLocalizationManager.updateLocalText = (Action)Delegate.Combine(csLocalizationManager.updateLocalText, new Action(UpdateLocalText));
	}

	private void OnDisable()
	{
		csLocalizationManager.updateLocalText = (Action)Delegate.Remove(csLocalizationManager.updateLocalText, new Action(UpdateLocalText));
	}

	private void UpdateLocalText()
	{
		if (!(csLocalizationManager.Instance == null) && m_Sprite != null)
		{
			m_Sprite.overrideSprite = csLocalizationManager.Instance.GetLocalSprite(id);
		}
	}
}
public class csLocalizationManager : MonoBehaviour
{
	public static csLocalizationManager Instance;

	private Dictionary<Language, Dictionary<string, string>> m_LanguageTextDic = new Dictionary<Language, Dictionary<string, string>>();

	private Dictionary<Language, Dictionary<string, Sprite>> m_LanguageSpriteDic = new Dictionary<Language, Dictionary<string, Sprite>>();

	public Language m_CurrentLanguage;

	private Dictionary<string, string> m_CurrentLocalTexts = new Dictionary<string, string>();

	private Dictionary<string, Sprite> m_CurrentLocalSprites = new Dictionary<string, Sprite>();

	public List<Sprite> m_LocalSprites;

	public static Action updateLocalText;

	public TMP_FontAsset DefaultFontAsset;

	public TMP_FontAsset DefaultFontAsset_Small;

	public TMP_FontAsset DefaultFontAssetDepth;

	public TMP_FontAsset DefaultFontAssetBold;

	public TMP_FontAsset DefaultFontAssetBoldDepth;

	public Font DefaultFont;

	public Font DefaultFontBold;

	public List<TextFontData> FontDataList = new List<TextFontData>();

	private Dictionary<Language, TMP_FontAsset> FontAssDic = new Dictionary<Language, TMP_FontAsset>();

	private Dictionary<Language, TMP_FontAsset> FontAssDicSmall = new Dictionary<Language, TMP_FontAsset>();

	private Dictionary<Language, TMP_FontAsset> FontAssDepthDic = new Dictionary<Language, TMP_FontAsset>();

	private Dictionary<Language, TMP_FontAsset> FontAssDicBold = new Dictionary<Language, TMP_FontAsset>();

	private Dictionary<Language, TMP_FontAsset> FontAssBoldDepthDic = new Dictionary<Language, TMP_FontAsset>();

	private Dictionary<Language, Font> FontDic = new Dictionary<Language, Font>();

	private Dictionary<Language, Font> FontBoldDic = new Dictionary<Language, Font>();

	private Dictionary<Text, FontType> TextFontTypeDic = new Dictionary<Text, FontType>();

	private Dictionary<TextMeshProUGUI, FontType> TextProFontTypeDic = new Dictionary<TextMeshProUGUI, FontType>();

	private void Awake()
	{
		if (Instance == null)
		{
			Instance = this;
			UnityEngine.Object.DontDestroyOnLoad(this);
			for (int i = 0; i < Enum.GetValues(typeof(Language)).Length; i++)
			{
				TMP_FontAsset value = DefaultFontAsset;
				TMP_FontAsset defaultFontAsset_Small = DefaultFontAsset_Small;
				TMP_FontAsset value2 = DefaultFontAssetDepth;
				TMP_FontAsset value3 = DefaultFontAssetBold;
				TMP_FontAsset value4 = DefaultFontAssetBoldDepth;
				Font value5 = DefaultFont;
				Font value6 = DefaultFontBold;
				foreach (TextFontData fontData in FontDataList)
				{
					if (fontData.Lan == (Language)i)
					{
						value = fontData.FontAsset;
						value2 = fontData.FontAssetDepth;
						value3 = fontData.FontAssetBold;
						value4 = fontData.FontAssetBoldDepth;
						value5 = fontData.FDefault;
						value6 = fontData.FBold;
					}
				}
				FontAssDic.Add((Language)i, value);
				FontAssDicSmall.Add((Language)i, defaultFontAsset_Small);
				FontAssDepthDic.Add((Language)i, value2);
				FontAssDicBold.Add((Language)i, value3);
				FontAssBoldDepthDic.Add((Language)i, value4);
				FontDic.Add((Language)i, value5);
				FontBoldDic.Add((Language)i, value6);
				Dictionary<Language, Dictionary<string, string>> languageTextDic = m_LanguageTextDic;
				int key = i;
				Language language = (Language)i;
				languageTextDic.Add((Language)key, ReadLocalizationData(language.ToString()));
				switch ((Language)i)
				{
				case Language.ChineseSimplified:
					m_LanguageSpriteDic.Add((Language)i, ReadLocalSpriteData("cn"));
					break;
				case Language.English:
					m_LanguageSpriteDic.Add((Language)i, ReadLocalSpriteData("en"));
					break;
				default:
					m_LanguageSpriteDic.Add((Language)i, ReadLocalSpriteData("en"));
					break;
				}
			}
			if (PlayerPrefs.GetInt("CurrentLanguage", -1) == -1)
			{
				if (!csGameSettings.EnglishOnly && (UnityEngine.Application.systemLanguage == SystemLanguage.Chinese || UnityEngine.Application.systemLanguage == SystemLanguage.ChineseSimplified || UnityEngine.Application.systemLanguage == SystemLanguage.ChineseTraditional))
				{
					m_CurrentLanguage = Language.ChineseSimplified;
				}
				else
				{
					m_CurrentLanguage = Language.English;
				}
			}
			else if (csGameSettings.EnglishOnly)
			{
				m_CurrentLanguage = Language.English;
			}
			else
			{
				m_CurrentLanguage = (Language)PlayerPrefs.GetInt("CurrentLanguage", -1);
			}
			SetLanguage(m_CurrentLanguage);
		}
		else
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}

	public TMP_FontAsset GetCurrentFontAssetByType(FontType ft)
	{
		return ft switch
		{
			FontType.DefaultSmall => FontAssDicSmall[m_CurrentLanguage], 
			FontType.DefaultDepth => FontAssDepthDic[m_CurrentLanguage], 
			FontType.Bold => FontAssDicBold[m_CurrentLanguage], 
			FontType.BoldDepth => FontAssBoldDepthDic[m_CurrentLanguage], 
			_ => FontAssDic[m_CurrentLanguage], 
		};
	}

	public Font GetCurrentFontType(FontType ft)
	{
		switch (ft)
		{
		default:
			return FontDic[m_CurrentLanguage];
		case FontType.Bold:
		case FontType.BoldDepth:
			return FontBoldDic[m_CurrentLanguage];
		}
	}

	public Sprite GetLocalSprite(string id)
	{
		return m_CurrentLocalSprites[id];
	}

	public Sprite GetLocalSprite(string id, Language regionType)
	{
		return m_LanguageSpriteDic[regionType][id];
	}

	public string GetLocalText(string id)
	{
		if (!m_CurrentLocalTexts.ContainsKey(id))
		{
			UnityEngine.Debug.LogError(id);
		}
		return m_CurrentLocalTexts[id];
	}

	private Dictionary<string, string> ReadLocalizationData(string filename)
	{
		Dictionary<string, string> dictionary = new Dictionary<string, string>();
		string path = "Localization/" + filename;
		string text = "";
		TextAsset textAsset = Resources.Load(path) as TextAsset;
		if (textAsset == null)
		{
			UnityEngine.Debug.Log("Can't find asset " + filename);
		}
		else
		{
			StringReader stringReader = new StringReader(textAsset.text);
			while ((text = stringReader.ReadLine()) != null)
			{
				if (text.Contains(";"))
				{
					string[] array = text.Split(';');
					dictionary.Add(array[0], array[1]);
				}
			}
			stringReader.Dispose();
		}
		return dictionary;
	}

	private Dictionary<string, Sprite> ReadLocalSpriteData(string filename)
	{
		Dictionary<string, Sprite> dictionary = new Dictionary<string, Sprite>();
		for (int i = 0; i < m_LocalSprites.Count; i++)
		{
			string[] array = m_LocalSprites[i].name.Split('_');
			if (array[1] == filename)
			{
				dictionary.Add(array[0], m_LocalSprites[i]);
			}
		}
		return dictionary;
	}

	public void SetLanguage(Language language)
	{
		PlayerPrefs.SetInt("CurrentLanguage", (int)language);
		m_CurrentLanguage = language;
		m_CurrentLocalSprites = m_LanguageSpriteDic[m_CurrentLanguage];
		m_CurrentLocalTexts = m_LanguageTextDic[m_CurrentLanguage];
		if (updateLocalText != null)
		{
			updateLocalText();
		}
	}

	public void CheckTextFontType(Text t)
	{
		_ = DefaultFont;
		if (!TextFontTypeDic.ContainsKey(t))
		{
			if (t.font == Instance.DefaultFont)
			{
				TextFontTypeDic.Add(t, FontType.Default);
			}
			else if (t.font == Instance.DefaultFontBold)
			{
				TextFontTypeDic.Add(t, FontType.Bold);
			}
		}
		t.font = GetCurrentFontType(TextFontTypeDic[t]);
	}

	public void CheckTextFontType(TextMeshProUGUI t)
	{
		_ = DefaultFont;
		if (!TextProFontTypeDic.ContainsKey(t))
		{
			if (t.font == Instance.DefaultFontAsset)
			{
				TextProFontTypeDic.Add(t, FontType.Default);
			}
			else if (t.font == Instance.DefaultFontAsset_Small)
			{
				TextProFontTypeDic.Add(t, FontType.DefaultSmall);
			}
			else if (t.font == Instance.DefaultFontAssetDepth)
			{
				TextProFontTypeDic.Add(t, FontType.DefaultDepth);
			}
			else if (t.font == Instance.DefaultFontAssetBold)
			{
				TextProFontTypeDic.Add(t, FontType.Bold);
			}
			else if (t.font == Instance.DefaultFontAssetBoldDepth)
			{
				TextProFontTypeDic.Add(t, FontType.BoldDepth);
			}
			else
			{
				UnityEngine.Debug.LogError(t.gameObject.name + " Font:" + t.font.ToString(), t.gameObject);
			}
		}
		t.font = GetCurrentFontAssetByType(TextProFontTypeDic[t]);
	}
}
public enum Language
{
	ChineseSimplified,
	English
}
public enum FontType
{
	None,
	Default,
	DefaultSmall,
	DefaultDepth,
	Bold,
	BoldDepth
}
public class csLocalSpriteRenderer : MonoBehaviour
{
	public string m_ID = "";

	private SpriteRenderer m_Sprite;

	private void Awake()
	{
		m_Sprite = GetComponent<SpriteRenderer>();
	}

	private void OnEnable()
	{
		if (m_Sprite != null)
		{
			m_Sprite.sprite = csLocalizationManager.Instance.GetLocalSprite(m_ID);
		}
	}
}
public class csLocalText : MonoBehaviour
{
	public string m_ID;

	public bool UsingProText;

	private TextMeshProUGUI m_TextPro;

	private Text m_Text;

	private FontType DefaultFontType;

	private void Awake()
	{
		if (UsingProText)
		{
			m_TextPro = GetComponent<TextMeshProUGUI>();
		}
		else
		{
			m_Text = GetComponent<Text>();
		}
	}

	private void OnEnable()
	{
		csLocalizationManager.updateLocalText = (Action)Delegate.Combine(csLocalizationManager.updateLocalText, new Action(UpdateLocalText));
		UpdateLocalText();
	}

	private void OnDisable()
	{
		csLocalizationManager.updateLocalText = (Action)Delegate.Remove(csLocalizationManager.updateLocalText, new Action(UpdateLocalText));
	}

	private void UpdateLocalText()
	{
		if (csLocalizationManager.Instance == null)
		{
			return;
		}
		if (DefaultFontType == FontType.None)
		{
			DefaultFontType = FontType.Default;
			if (UsingProText)
			{
				if (m_TextPro.font == csLocalizationManager.Instance.DefaultFontAsset)
				{
					DefaultFontType = FontType.Default;
				}
				else if (m_TextPro.font == csLocalizationManager.Instance.DefaultFontAssetDepth)
				{
					DefaultFontType = FontType.DefaultDepth;
				}
				else if (m_TextPro.font == csLocalizationManager.Instance.DefaultFontAssetBold)
				{
					DefaultFontType = FontType.Bold;
				}
				else if (m_TextPro.font == csLocalizationManager.Instance.DefaultFontAssetBoldDepth)
				{
					DefaultFontType = FontType.BoldDepth;
				}
			}
			else if (m_Text.font == csLocalizationManager.Instance.DefaultFont)
			{
				DefaultFontType = FontType.Default;
			}
			else if (m_Text.font == csLocalizationManager.Instance.DefaultFontBold)
			{
				DefaultFontType = FontType.Bold;
			}
		}
		if (UsingProText)
		{
			m_TextPro.font = csLocalizationManager.Instance.GetCurrentFontAssetByType(DefaultFontType);
			m_TextPro.text = csLocalizationManager.Instance.GetLocalText(m_ID);
			if (m_TextPro.text.Contains("\\n"))
			{
				m_TextPro.text = m_TextPro.text.Replace("\\n", "\n");
			}
		}
		else
		{
			m_Text.font = csLocalizationManager.Instance.GetCurrentFontType(DefaultFontType);
			m_Text.text = csLocalizationManager.Instance.GetLocalText(m_ID);
			if (m_Text.text.Contains("\\n"))
			{
				m_Text.text = m_Text.text.Replace("\\n", "\n");
			}
		}
	}
}
public class csAchievementGiftPanel : MonoBehaviour
{
	public GameObject thisG;

	public List<csLevelAwardPanelIcon> AwardIconList = new List<csLevelAwardPanelIcon>();

	public Sprite AddLifeS;

	public Sprite GoldBuffS;

	public Sprite GoldBuffB;

	public Sprite RushS;

	public Sprite RushB;

	public Sprite ScoreBuffS;

	public Sprite ScoreBuffB;

	public Sprite ShieldS;

	public Sprite ShieldB;

	public Sprite S_Award_Money;

	public Sprite S_Award_Gem;

	public void Show(bool isShow)
	{
		thisG.SetActive(isShow);
		csGameSettings.SetHintOn(isShow);
	}

	public void SetAwards(List<ResultAwardData> AwardData)
	{
		foreach (csLevelAwardPanelIcon awardIcon in AwardIconList)
		{
			awardIcon.SetAwardOn(isOn: false);
		}
		for (int i = 0; i < AwardData.Count; i++)
		{
			AwardIconList[i].SetAwardOn(isOn: true);
		}
		for (int j = 0; j < AwardData.Count; j++)
		{
			if (AwardData[j].CoinNum > 0)
			{
				AwardIconList[j].SetAwardMoney(AwardData[j].CoinNum, S_Award_Money, csLocalizationManager.Instance.GetLocalText("PropShopMenu02"), DefaultOpen: false);
				continue;
			}
			if (AwardData[j].GemNum > 0)
			{
				AwardIconList[j].SetAwardGem(AwardData[j].GemNum, S_Award_Gem, csLocalizationManager.Instance.GetLocalText("PropShopMenu03"), DefaultOpen: false);
				continue;
			}
			string text = "";
			Sprite s;
			switch (AwardData[j].AwardBuff)
			{
			default:
				s = RushS;
				text = csLocalizationManager.Instance.GetLocalText("Item_A_001");
				break;
			case AheadBuff.AddLifeS:
				s = AddLifeS;
				text = csLocalizationManager.Instance.GetLocalText("Item_A_005");
				break;
			case AheadBuff.GoldBuffS:
				s = GoldBuffS;
				text = csLocalizationManager.Instance.GetLocalText("Item_A_006");
				break;
			case AheadBuff.GoldBuffB:
				s = GoldBuffB;
				text = csLocalizationManager.Instance.GetLocalText("Item_A_007");
				break;
			case AheadBuff.RushS:
				s = RushS;
				text = csLocalizationManager.Instance.GetLocalText("Item_A_001");
				break;
			case AheadBuff.RushB:
				s = RushB;
				text = csLocalizationManager.Instance.GetLocalText("Item_A_002");
				break;
			case AheadBuff.ScoreBuffS:
				s = ScoreBuffS;
				text = csLocalizationManager.Instance.GetLocalText("Item_A_008");
				break;
			case AheadBuff.ScoreBuffB:
				s = ScoreBuffB;
				text = csLocalizationManager.Instance.GetLocalText("Item_A_009");
				break;
			case AheadBuff.ShieldS:
				s = ShieldS;
				text = csLocalizationManager.Instance.GetLocalText("Item_A_003");
				break;
			case AheadBuff.ShieldB:
				s = ShieldB;
				text = csLocalizationManager.Instance.GetLocalText("Item_A_004");
				break;
			}
			AwardIconList[j].SetAwardProp(AwardData[j].BuffNum, s, text, DefaultOpen: false);
		}
	}

	public void OnConfirm()
	{
		Show(isShow: false);
	}
}
public class csAchievementPanel : csMainMenuPanelBase
{
	public GameObject ItemPrefab;

	public GameObject ItemContainerPrefab;

	public Transform ItemParentTrans;

	public GameObject TurnLeftBtn;

	public GameObject TurnRightBtn;

	public ScrollRect sr;

	public TextMeshProUGUI PageIndexText;

	public TextMeshProUGUI CompeletInfoText;

	private int PageIndex;

	private int MaxPageNum;

	private const int MaxCountInOnePage = 5;

	public List<csAchievementItem> ItemList = new List<csAchievementItem>();

	public csAchievementGiftPanel AchievementGiftPanel;

	private Transform tempContainer;

	public override void AwakeInit()
	{
		base.AwakeInit();
	}

	public override void StartInit()
	{
		base.StartInit();
		int num = 0;
		foreach (KeyValuePair<AchievementType, AchievementDataInfo> item in csPlayerData.AchievementDic)
		{
			if (num % 5 == 0)
			{
				GameObject gameObject = UnityEngine.Object.Instantiate(ItemContainerPrefab);
				gameObject.transform.parent = ItemParentTrans;
				gameObject.transform.localScale = Vector3.one;
				gameObject.transform.localPosition = Vector3.zero;
				gameObject.transform.localRotation = Quaternion.identity;
				gameObject.SetActive(value: true);
				tempContainer = gameObject.transform;
				MaxPageNum++;
			}
			GameObject obj = UnityEngine.Object.Instantiate(ItemPrefab);
			obj.transform.parent = tempContainer;
			obj.transform.localScale = Vector3.one;
			obj.transform.localPosition = Vector3.zero;
			obj.transform.localRotation = Quaternion.identity;
			obj.SetActive(value: true);
			csAchievementItem component = obj.GetComponent<csAchievementItem>();
			component.InitData(item.Value, isfirst: true);
			component.AchievePanel = this;
			ItemList.Add(component);
			num++;
		}
		csPlayerData.RefreshAchievementAction = (Action)Delegate.Combine(csPlayerData.RefreshAchievementAction, new Action(Refresh));
		csLocalizationManager.updateLocalText = (Action)Delegate.Combine(csLocalizationManager.updateLocalText, new Action(Refresh));
		AchievementGiftPanel.thisG.SetActive(value: false);
		SetCompeletInfo();
	}

	public void Refresh()
	{
		AchievementGiftPanel.thisG.SetActive(value: false);
		for (int i = 0; i < ItemList.Count; i++)
		{
			ItemList[i].InitData(csPlayerData.AchievementDic[ItemList[i].m_AchievementType]);
		}
		SetCompeletInfo();
	}

	private void SetCompeletInfo()
	{
		csLocalizationManager.Instance.CheckTextFontType(CompeletInfoText);
		CompeletInfoText.text = csLocalizationManager.Instance.GetLocalText("Achievement07") + " " + csPlayerData.CompeletAchievementCount + "/" + csPlayerData.AchievementDic.Count;
	}

	private void OnDestroy()
	{
		csPlayerData.RefreshAchievementAction = (Action)Delegate.Remove(csPlayerData.RefreshAchievementAction, new Action(Refresh));
		csLocalizationManager.updateLocalText = (Action)Delegate.Remove(csLocalizationManager.updateLocalText, new Action(Refresh));
	}

	public override void Show(UnityAction act, string msg = "")
	{
		base.Show(act);
		int firstUnResivedAchievement = csPlayerData.GetFirstUnResivedAchievement();
		if (firstUnResivedAchievement >= 0)
		{
			int pageByIndex = firstUnResivedAchievement / 5;
			SetPageByIndex(pageByIndex);
		}
		else
		{
			SetPageByIndex(0);
		}
		csPlayerData.NewAchievementCount = 0;
	}

	public override void Hide(UnityAction act)
	{
		base.Hide(act);
	}

	public void TurnLeft()
	{
		if (PageIndex != 0)
		{
			PageIndex--;
			SetScroll();
		}
	}

	public void TurnRight()
	{
		if (PageIndex != MaxPageNum - 1)
		{
			PageIndex++;
			SetScroll();
		}
	}

	private void SetPageByIndex(int index)
	{
		if (index > MaxPageNum - 1)
		{
			index = MaxPageNum - 1;
		}
		if (index < 0)
		{
			index = 0;
		}
		PageIndex = index;
		SetScroll();
	}

	private void SetScroll()
	{
		sr.verticalNormalizedPosition = (float)(MaxPageNum - 1 - PageIndex) / (float)(MaxPageNum - 1);
		TurnLeftBtn.gameObject.SetActive(PageIndex != 0);
		TurnRightBtn.gameObject.SetActive(PageIndex != MaxPageNum - 1);
		PageIndexText.text = PageIndex + 1 + "/" + MaxPageNum;
	}
}
public class csBoxAward : csMainMenuPanelBase
{
	public TextMeshProUGUI AwardContectText;

	public csLevelAwardPanelIcon AwardIcon;

	public Sprite RushS;

	public Sprite ShieldS;

	public Sprite S_Award_Money;

	public Sprite S_Award_Gem;

	public DOTweenAnimation tweener;

	public void BackToMenu()
	{
		csMainMenuCanvas.instance.BackToMenu();
	}

	public override void Show(UnityAction act, string msg = "")
	{
		base.Show(act);
		tweener.DOPlay();
		csMainSceneAudioPlayer.instance.PlayAudio2D("OpenBox");
		int num = UnityEngine.Random.Range(0, 119);
		if (num < 50)
		{
			AddCoin(100);
			AwardIcon.SetAwardMoney(100, S_Award_Money, csLocalizationManager.Instance.GetLocalText("PropShopMenu02"));
		}
		else if (num < 75)
		{
			AddCoin(200);
			AwardIcon.SetAwardMoney(200, S_Award_Money, csLocalizationManager.Instance.GetLocalText("PropShopMenu02"));
		}
		else if (num < 85)
		{
			AddCoin(500);
			AwardIcon.SetAwardMoney(500, S_Award_Money, csLocalizationManager.Instance.GetLocalText("PropShopMenu02"));
		}
		else if (num < 90)
		{
			AddCoin(1000);
			AwardIcon.SetAwardMoney(1000, S_Award_Money, csLocalizationManager.Instance.GetLocalText("PropShopMenu02"));
		}
		else if (num < 95)
		{
			AddDiamond(10);
			AwardIcon.SetAwardGem(10, S_Award_Gem, csLocalizationManager.Instance.GetLocalText("PropShopMenu03"));
		}
		else if (num < 97)
		{
			AddDiamond(20);
			AwardIcon.SetAwardGem(20, S_Award_Gem, csLocalizationManager.Instance.GetLocalText("PropShopMenu03"));
		}
		else if (num < 98)
		{
			AddDiamond(30);
			AwardIcon.SetAwardGem(30, S_Award_Gem, csLocalizationManager.Instance.GetLocalText("PropShopMenu03"));
		}
		else if (num < 99)
		{
			AddDiamond(50);
			AwardIcon.SetAwardGem(50, S_Award_Gem, csLocalizationManager.Instance.GetLocalText("PropShopMenu03"));
		}
		else if (num < 109)
		{
			AddProp(AheadBuff.RushS);
			AwardIcon.SetAwardProp(1, RushS, csLocalizationManager.Instance.GetLocalText("Item_A_001"));
		}
		else
		{
			AddProp(AheadBuff.ShieldS);
			AwardIcon.SetAwardProp(1, ShieldS, csLocalizationManager.Instance.GetLocalText("Item_A_003"));
		}
	}

	private void AddCoin(int Count)
	{
		csPlayerData.PlayerCoin += Count;
		csPlayerData.AddAchievementSchedule_Coin(Count);
		csLocalizationManager.Instance.CheckTextFontType(AwardContectText);
		AwardContectText.text = string.Format(csLocalizationManager.Instance.GetLocalText("BoxAward1"), Count);
	}

	private void AddDiamond(int Count)
	{
		csPlayerData.PlayerDiamond += Count;
		csLocalizationManager.Instance.CheckTextFontType(AwardContectText);
		AwardContectText.text = string.Format(csLocalizationManager.Instance.GetLocalText("BoxAward2"), Count);
	}

	private void AddProp(AheadBuff _type)
	{
		csPlayerData.OnGetAheadBuff(_type, 1);
		csLocalizationManager.Instance.CheckTextFontType(AwardContectText);
		AwardContectText.text = csLocalizationManager.Instance.GetLocalText("BoxAward3") + GetPropString(hasprop: true, _type);
	}

	private string GetPropString(bool hasprop, AheadBuff type)
	{
		string result = "";
		if (!hasprop)
		{
			return result;
		}
		switch (type)
		{
		case AheadBuff.AddLifeS:
			result = csLocalizationManager.Instance.GetLocalText("Item_A_005");
			break;
		case AheadBuff.GoldBuffS:
			result = csLocalizationManager.Instance.GetLocalText("Item_A_006");
			break;
		case AheadBuff.GoldBuffB:
			result = csLocalizationManager.Instance.GetLocalText("Item_A_007");
			break;
		case AheadBuff.RushS:
			result = csLocalizationManager.Instance.GetLocalText("Item_A_001");
			break;
		case AheadBuff.RushB:
			result = csLocalizationManager.Instance.GetLocalText("Item_A_002");
			break;
		case AheadBuff.ScoreBuffS:
			result = csLocalizationManager.Instance.GetLocalText("Item_A_008");
			break;
		case AheadBuff.ScoreBuffB:
			result = csLocalizationManager.Instance.GetLocalText("Item_A_009");
			break;
		case AheadBuff.ShieldS:
			result = csLocalizationManager.Instance.GetLocalText("Item_A_003");
			break;
		case AheadBuff.ShieldB:
			result = csLocalizationManager.Instance.GetLocalText("Item_A_004");
			break;
		}
		return result;
	}
}
public class csBtnClipPlayer : MonoBehaviour
{
	private Button thisB;

	public string BtnClipName = "ButtonPress";

	private void Start()
	{
		AddEventToButton();
	}

	public void AddEventToButton()
	{
		if (thisB == null)
		{
			thisB = GetComponent<Button>();
		}
		if ((bool)thisB)
		{
			thisB.onClick.AddListener(PlayPressSound);
		}
	}

	private void PlayPressSound()
	{
		if ((bool)csMainSceneAudioPlayer.instance)
		{
			csMainSceneAudioPlayer.instance.PlayAudio2D(BtnClipName);
		}
	}
}
public class csColumeInPropShop : MonoBehaviour
{
	public Image SelectedImg;

	public void SetSelect(bool isSelect)
	{
		SelectedImg.gameObject.SetActive(isSelect);
	}
}
public class csEndlessPanel : csMainMenuPanelBase
{
	public TextMeshProUGUI BestScoreText;

	public TextMeshProUGUI BestTimeText;

	public TextMeshProUGUI BestLevelText;

	public GameObject NewRecordObj_Score;

	public GameObject NewRecordObj_Time;

	public GameObject NewRecordObj_Level;

	public List<csPropItemInMenu> PropItemList;

	public Sprite Null;

	public Sprite AddLifeS;

	public Sprite GoldBuffS;

	public Sprite GoldBuffB;

	public Sprite RushS;

	public Sprite RushB;

	public Sprite ScoreBuffS;

	public Sprite ScoreBuffB;

	public Sprite ShieldS;

	public Sprite ShieldB;

	public TextMeshProUGUI[] LevelNumTxt;

	public DOTweenAnimation TweenAnim;

	public GameObject SkipBlocker;

	public Image SkipTick;

	private void OnEnable()
	{
		BestScoreText.text = csPlayerData.BestEndlessScore.ToString();
		if (csPlayerData.BestEndlessTime < 3600f)
		{
			BestTimeText.text = FormatFloatTimeToStr(full: false, csPlayerData.BestEndlessTime);
		}
		else
		{
			BestTimeText.text = FormatFloatTimeToStr(full: true, csPlayerData.BestEndlessTime);
		}
		BestLevelText.text = csPlayerData.HighestEndlessLevel.ToString();
		NewRecordObj_Score.SetActive(csPlayerData.BestEndlessScore == csPlayerData.LastEndlessScore && csPlayerData.BestEndlessScore != 0);
		NewRecordObj_Time.SetActive(csPlayerData.BestEndlessTime == csPlayerData.LastEndlessTime && csPlayerData.BestEndlessTime != 0f);
		NewRecordObj_Level.SetActive(csPlayerData.HighestEndlessLevel == csPlayerData.LastEndlessLevel && csPlayerData.HighestEndlessLevel != 0);
		for (int i = 0; i < PropItemList.Count; i++)
		{
			if (i < csPlayerData.EquipedBufflistInData.Count)
			{
				PropItemList[i].SetPropUI(GetPropString(hasprop: true, csPlayerData.EquipedBufflistInData[i]), GetPropSprite(hasprop: true, csPlayerData.EquipedBufflistInData[i]), ChangeIsOn: true);
			}
			else
			{
				PropItemList[i].SetPropUI(GetPropString(hasprop: false, AheadBuff.AddLifeS), GetPropSprite(hasprop: false, AheadBuff.AddLifeS), ChangeIsOn: false);
			}
		}
		SkipTick.enabled = csGameSettings.SkipEndlessLevel;
		SetLevelSkipPanel(csPlayerData.HighestEndlessLevel);
	}

	private void SetLevelSkipPanel(int level)
	{
		int num = level / 10 * 10 + 1;
		if (num < 10)
		{
			SkipBlocker.SetActive(value: true);
			TweenAnim.enabled = false;
			for (int i = 0; i < LevelNumTxt.Length; i++)
			{
				LevelNumTxt[i].text = (1 + i).ToString();
			}
		}
		else
		{
			SkipBlocker.SetActive(value: false);
			TweenAnim.enabled = true;
			for (int j = 0; j < LevelNumTxt.Length; j++)
			{
				LevelNumTxt[j].text = (num - 2 + j).ToString();
			}
		}
	}

	private string GetPropString(bool hasprop, AheadBuff type)
	{
		string result = "";
		if (!hasprop)
		{
			return result;
		}
		switch (type)
		{
		case AheadBuff.AddLifeS:
			result = csLocalizationManager.Instance.GetLocalText("Item_A_005");
			break;
		case AheadBuff.GoldBuffS:
			result = csLocalizationManager.Instance.GetLocalText("Item_A_006");
			break;
		case AheadBuff.GoldBuffB:
			result = csLocalizationManager.Instance.GetLocalText("Item_A_007");
			break;
		case AheadBuff.RushS:
			result = csLocalizationManager.Instance.GetLocalText("Item_A_001");
			break;
		case AheadBuff.RushB:
			result = csLocalizationManager.Instance.GetLocalText("Item_A_002");
			break;
		case AheadBuff.ScoreBuffS:
			result = csLocalizationManager.Instance.GetLocalText("Item_A_008");
			break;
		case AheadBuff.ScoreBuffB:
			result = csLocalizationManager.Instance.GetLocalText("Item_A_009");
			break;
		case AheadBuff.ShieldS:
			result = csLocalizationManager.Instance.GetLocalText("Item_A_003");
			break;
		case AheadBuff.ShieldB:
			result = csLocalizationManager.Instance.GetLocalText("Item_A_004");
			break;
		}
		return result;
	}

	private Sprite GetPropSprite(bool hasprop, AheadBuff type)
	{
		Sprite result = Null;
		if (!hasprop)
		{
			return result;
		}
		switch (type)
		{
		case AheadBuff.AddLifeS:
			result = AddLifeS;
			break;
		case AheadBuff.GoldBuffS:
			result = GoldBuffS;
			break;
		case AheadBuff.GoldBuffB:
			result = GoldBuffB;
			break;
		case AheadBuff.RushS:
			result = RushS;
			break;
		case AheadBuff.RushB:
			result = RushB;
			break;
		case AheadBuff.ScoreBuffS:
			result = ScoreBuffS;
			break;
		case AheadBuff.ScoreBuffB:
			result = ScoreBuffB;
			break;
		case AheadBuff.ShieldS:
			result = ShieldS;
			break;
		case AheadBuff.ShieldB:
			result = ShieldB;
			break;
		}
		return result;
	}

	public static string FormatFloatTimeToStr(bool full, float value)
	{
		string text = "00:00:00";
		if (full)
		{
			return TimeSpan.FromSeconds(Mathf.FloorToInt(value)).ToString();
		}
		int num = (int)(value % 1f * 100f);
		return TimeSpan.FromSeconds(Mathf.FloorToInt(value)).ToString().Substring(3) + "." + ((num < 10) ? ("0" + num) : num.ToString());
	}

	public void BackToMenu()
	{
		csMainMenuCanvas.instance.BackToMenu();
	}

	public void StartEndLess()
	{
		csMainMenuCanvas.instance.StartGame(GameMode.EndlessMode);
	}

	public void ShowPropSelect()
	{
		csMainMenuCanvas.instance.BackFromShopAction = ((csMainStartPanel)csMainMenuCanvas.instance.MenuObjDic[MainMenuType.MainMenu]).StartGame;
		csMainMenuCanvas.instance.OpenMenu(MainMenuType.PropShop, "PropShop");
	}

	public void OnSkipLevelBtnClick()
	{
		csGameSettings.SkipEndlessLevel = !csGameSettings.SkipEndlessLevel;
		SkipTick.enabled = csGameSettings.SkipEndlessLevel;
	}
}
public class csFollowRotate : MonoBehaviour
{
	public Transform thisT;

	public Transform followT;

	private void Update()
	{
		thisT.rotation = followT.rotation;
	}
}
public class csHorseshopManager : MonoBehaviour
{
	public Transform roadT;

	public Transform horsePosT;

	public Transform horsePosLink;

	public Transform normalPosT;

	public csMainmenuRoadAnimation roadAnimation;

	private bool isUp;

	private void Start()
	{
	}

	public void PlayHorsePosAnim(bool isUp)
	{
		if (isUp)
		{
			csMainSceneAudioPlayer.instance.PlayAudio2D("RoadMove");
			normalPosT.DOLocalMoveY(-5f, 0.3f);
			horsePosT.DOLocalMoveY(-3f, 0.3f).SetDelay(0.5f);
		}
		else
		{
			csMainSceneAudioPlayer.instance.PlayAudio2D("RoadMove");
			horsePosT.DOLocalMoveY(-12f, 1f);
			normalPosT.DOLocalMoveY(-0.21f, 0.3f).SetDelay(0.5f);
		}
	}

	public void PrepareRoad()
	{
		roadT.DOLocalMoveY(0f, 0.8f);
		roadAnimation.StartLoading();
	}

	public void TurnBase(bool isL, TweenCallback OnRotateDoneAct)
	{
		horsePosT.DORotate(new Vector3(0f, horsePosT.localEulerAngles.y + (float)(isL ? 45 : (-45)), 0f), 1.1f).OnComplete(OnRotateDoneAct);
	}

	public void SetBase(int horseIndex)
	{
		horsePosT.localEulerAngles = new Vector3(0f, -45 * horseIndex, 0f);
	}
}
public class csItemInPropShop : MonoBehaviour
{
	public csMianPropShop ItemShopM;

	public Transform EquipedT;

	private float EquipY = 1f;

	private float UnEquipY;

	public Button EquipBtn;

	public TextMeshProUGUI DesTxt;

	private csLocalText DesLocal;

	public TextMeshProUGUI NameTxt;

	private csLocalText NameLocal;

	public Text[] PriceTxt;

	public Text ItemNumTxt;

	public Text ItemAmtTxt;

	public Text[] EquipTxt;

	public Image CurrencyImg;

	public int m_Price = 1000;

	public int m_ItemAmount = 1;

	public int m_ItemNum = 1;

	public ShopItem m_ItemType;

	public CurrencyType m_Currency;

	public bool isEquipable;

	public bool isEquiped;

	public DOTweenAnimation ItemCountAnimator;

	private Tweener CurT;

	private void Start()
	{
		SetPurchaseItem(m_ItemType, m_Price, m_Currency, m_ItemAmount);
		InitData();
	}

	public void SetPurchaseItem(ShopItem itemtype, int price, CurrencyType cType, int itemAmt)
	{
		m_ItemType = itemtype;
		m_Price = price;
		m_Currency = cType;
		m_ItemAmount = itemAmt;
		DesLocal = DesTxt.GetComponent<csLocalText>();
		NameLocal = NameTxt.GetComponent<csLocalText>();
		switch (itemtype)
		{
		case ShopItem.Item_001_RushS:
			DesTxt.text = string.Format(csLocalizationManager.Instance.GetLocalText(DesLocal.m_ID), csPlayerData.GetAheadBuffValue(AheadBuff.RushS));
			break;
		case ShopItem.Item_002_RushM:
			DesTxt.text = string.Format(csLocalizationManager.Instance.GetLocalText(DesLocal.m_ID), csPlayerData.GetAheadBuffValue(AheadBuff.RushM));
			break;
		case ShopItem.Item_003_RushB:
			DesTxt.text = string.Format(csLocalizationManager.Instance.GetLocalText(DesLocal.m_ID), csPlayerData.GetAheadBuffValue(AheadBuff.RushB));
			break;
		case ShopItem.Item_004_ShieldS:
			DesTxt.text = string.Format(csLocalizationManager.Instance.GetLocalText(DesLocal.m_ID), csPlayerData.GetAheadBuffValue(AheadBuff.ShieldS));
			break;
		case ShopItem.Item_005_ShieldM:
			DesTxt.text = string.Format(csLocalizationManager.Instance.GetLocalText(DesLocal.m_ID), csPlayerData.GetAheadBuffValue(AheadBuff.ShieldM));
			break;
		case ShopItem.Item_006_ShieldB:
			DesTxt.text = string.Format(csLocalizationManager.Instance.GetLocalText(DesLocal.m_ID), csPlayerData.GetAheadBuffValue(AheadBuff.ShieldB));
			break;
		case ShopItem.Item_007_AddLifeS:
			DesTxt.text = string.Format(csLocalizationManager.Instance.GetLocalText(DesLocal.m_ID), csPlayerData.GetAheadBuffValue(AheadBuff.AddLifeS));
			break;
		case ShopItem.Item_008_GoldBuffS:
			DesTxt.text = string.Format(csLocalizationManager.Instance.GetLocalText(DesLocal.m_ID), csPlayerData.GetAheadBuffValue(AheadBuff.GoldBuffS));
			break;
		case ShopItem.Item_009_GoldBuffM:
			DesTxt.text = string.Format(csLocalizationManager.Instance.GetLocalText(DesLocal.m_ID), csPlayerData.GetAheadBuffValue(AheadBuff.GoldBuffM));
			break;
		case ShopItem.Item_010_GoldBuffB:
			DesTxt.text = string.Format(csLocalizationManager.Instance.GetLocalText(DesLocal.m_ID), csPlayerData.GetAheadBuffValue(AheadBuff.GoldBuffB));
			break;
		case ShopItem.Item_011_ScoreBuffS:
			DesTxt.text = string.Format(csLocalizationManager.Instance.GetLocalText(DesLocal.m_ID), csPlayerData.GetAheadBuffValue(AheadBuff.ScoreBuffS));
			break;
		case ShopItem.Item_012_ScoreBuffM:
			DesTxt.text = string.Format(csLocalizationManager.Instance.GetLocalText(DesLocal.m_ID), csPlayerData.GetAheadBuffValue(AheadBuff.ScoreBuffM));
			break;
		case ShopItem.Item_013_ScoreBuffB:
			DesTxt.text = string.Format(csLocalizationManager.Instance.GetLocalText(DesLocal.m_ID), csPlayerData.GetAheadBuffValue(AheadBuff.ScoreBuffB));
			break;
		case ShopItem.Item_080_GoldS:
		case ShopItem.Item_081_GoldM:
		case ShopItem.Item_082_GoldB:
		case ShopItem.Item_083_GoldL:
		case ShopItem.Item_090_GemS:
		case ShopItem.Item_091_GemM:
		case ShopItem.Item_092_GemB:
			DesTxt.text = string.Format(csLocalizationManager.Instance.GetLocalText(DesLocal.m_ID), m_Price, m_ItemAmount);
			NameTxt.text = string.Format(csLocalizationManager.Instance.GetLocalText(NameLocal.m_ID), m_ItemAmount);
			break;
		}
	}

	public void InitStatus(bool isE, int curNum)
	{
		DesLocal = DesTxt.GetComponent<csLocalText>();
		NameLocal = NameTxt.GetComponent<csLocalText>();
		switch (m_ItemType)
		{
		case ShopItem.Item_001_RushS:
			DesTxt.text = string.Format(csLocalizationManager.Instance.GetLocalText(DesLocal.m_ID), csPlayerData.GetAheadBuffValue(AheadBuff.RushS));
			break;
		case ShopItem.Item_002_RushM:
			DesTxt.text = string.Format(csLocalizationManager.Instance.GetLocalText(DesLocal.m_ID), csPlayerData.GetAheadBuffValue(AheadBuff.RushM));
			break;
		case ShopItem.Item_003_RushB:
			DesTxt.text = string.Format(csLocalizationManager.Instance.GetLocalText(DesLocal.m_ID), csPlayerData.GetAheadBuffValue(AheadBuff.RushB));
			break;
		case ShopItem.Item_004_ShieldS:
			DesTxt.text = string.Format(csLocalizationManager.Instance.GetLocalText(DesLocal.m_ID), csPlayerData.GetAheadBuffValue(AheadBuff.ShieldS));
			break;
		case ShopItem.Item_005_ShieldM:
			DesTxt.text = string.Format(csLocalizationManager.Instance.GetLocalText(DesLocal.m_ID), csPlayerData.GetAheadBuffValue(AheadBuff.ShieldM));
			break;
		case ShopItem.Item_006_ShieldB:
			DesTxt.text = string.Format(csLocalizationManager.Instance.GetLocalText(DesLocal.m_ID), csPlayerData.GetAheadBuffValue(AheadBuff.ShieldB));
			break;
		case ShopItem.Item_007_AddLifeS:
			DesTxt.text = string.Format(csLocalizationManager.Instance.GetLocalText(DesLocal.m_ID), csPlayerData.GetAheadBuffValue(AheadBuff.AddLifeS));
			break;
		case ShopItem.Item_008_GoldBuffS:
			DesTxt.text = string.Format(csLocalizationManager.Instance.GetLocalText(DesLocal.m_ID), csPlayerData.GetAheadBuffValue(AheadBuff.GoldBuffS));
			break;
		case ShopItem.Item_009_GoldBuffM:
			DesTxt.text = string.Format(csLocalizationManager.Instance.GetLocalText(DesLocal.m_ID), csPlayerData.GetAheadBuffValue(AheadBuff.GoldBuffM));
			break;
		case ShopItem.Item_010_GoldBuffB:
			DesTxt.text = string.Format(csLocalizationManager.Instance.GetLocalText(DesLocal.m_ID), csPlayerData.GetAheadBuffValue(AheadBuff.GoldBuffB));
			break;
		case ShopItem.Item_011_ScoreBuffS:
			DesTxt.text = string.Format(csLocalizationManager.Instance.GetLocalText(DesLocal.m_ID), csPlayerData.GetAheadBuffValue(AheadBuff.ScoreBuffS));
			break;
		case ShopItem.Item_012_ScoreBuffM:
			DesTxt.text = string.Format(csLocalizationManager.Instance.GetLocalText(DesLocal.m_ID), csPlayerData.GetAheadBuffValue(AheadBuff.ScoreBuffM));
			break;
		case ShopItem.Item_013_ScoreBuffB:
			DesTxt.text = string.Format(csLocalizationManager.Instance.GetLocalText(DesLocal.m_ID), csPlayerData.GetAheadBuffValue(AheadBuff.ScoreBuffB));
			break;
		case ShopItem.Item_080_GoldS:
		case ShopItem.Item_081_GoldM:
		case ShopItem.Item_082_GoldB:
		case ShopItem.Item_083_GoldL:
		case ShopItem.Item_090_GemS:
		case ShopItem.Item_091_GemM:
		case ShopItem.Item_092_GemB:
			DesTxt.text = string.Format(csLocalizationManager.Instance.GetLocalText(DesLocal.m_ID), m_Price, m_ItemAmount);
			NameTxt.text = string.Format(csLocalizationManager.Instance.GetLocalText(NameLocal.m_ID), m_ItemAmount);
			break;
		}
		if (!isEquipable)
		{
			return;
		}
		m_ItemNum = curNum;
		ItemNumTxt.text = "X" + curNum;
		isEquiped = isE;
		if (m_ItemNum <= 0)
		{
			EquipBtn.interactable = false;
		}
		else
		{
			EquipBtn.interactable = true;
		}
		if (isEquiped)
		{
			EquipedT.localScale = new Vector3(EquipY, EquipY, EquipY);
			Text[] equipTxt = EquipTxt;
			foreach (Text text in equipTxt)
			{
				csLocalizationManager.Instance.CheckTextFontType(text);
				text.text = csLocalizationManager.Instance.GetLocalText("PropShopMenu06");
			}
			return;
		}
		EquipedT.localScale = new Vector3(UnEquipY, UnEquipY, UnEquipY);
		if (m_ItemNum <= 0)
		{
			Text[] equipTxt = EquipTxt;
			foreach (Text text2 in equipTxt)
			{
				csLocalizationManager.Instance.CheckTextFontType(text2);
				text2.text = csLocalizationManager.Instance.GetLocalText("PropShopMenu07");
			}
		}
		else
		{
			Text[] equipTxt = EquipTxt;
			foreach (Text text3 in equipTxt)
			{
				csLocalizationManager.Instance.CheckTextFontType(text3);
				text3.text = csLocalizationManager.Instance.GetLocalText("PropShopMenu05");
			}
		}
	}

	public void RefrshStatus(int curNum)
	{
		if (!isEquipable)
		{
			return;
		}
		m_ItemNum = curNum;
		ItemNumTxt.text = "X" + curNum;
		Text[] equipTxt;
		if (m_ItemNum <= 0)
		{
			EquipBtn.interactable = false;
			equipTxt = EquipTxt;
			foreach (Text text in equipTxt)
			{
				csLocalizationManager.Instance.CheckTextFontType(text);
				text.text = csLocalizationManager.Instance.GetLocalText("PropShopMenu07");
			}
			return;
		}
		EquipBtn.interactable = true;
		ItemCountAnimator.DOPlay();
		equipTxt = EquipTxt;
		foreach (Text text2 in equipTxt)
		{
			csLocalizationManager.Instance.CheckTextFontType(text2);
			text2.text = csLocalizationManager.Instance.GetLocalText(isEquiped ? "PropShopMenu06" : "PropShopMenu05");
		}
	}

	public void SetToEquipState(bool isE)
	{
		isEquiped = isE;
		if (CurT != null && !CurT.IsComplete())
		{
			CurT.Kill();
		}
		float num = (isE ? EquipY : UnEquipY);
		CurT = EquipedT.DOScale(new Vector3(num, num, num), 0.2f);
		if (isEquiped)
		{
			Text[] equipTxt = EquipTxt;
			foreach (Text text in equipTxt)
			{
				csLocalizationManager.Instance.CheckTextFontType(text);
				text.text = csLocalizationManager.Instance.GetLocalText("PropShopMenu06");
			}
		}
		else
		{
			Text[] equipTxt = EquipTxt;
			foreach (Text text2 in equipTxt)
			{
				csLocalizationManager.Instance.CheckTextFontType(text2);
				text2.text = csLocalizationManager.Instance.GetLocalText(isEquiped ? "PropShopMenu06" : "PropShopMenu05");
			}
		}
	}

	private void InitData()
	{
		switch (m_Currency)
		{
		case CurrencyType.Coin:
			CurrencyImg.overrideSprite = ItemShopM.S_Currency_Coin;
			break;
		case CurrencyType.Gem:
			CurrencyImg.overrideSprite = ItemShopM.S_Currency_Gem;
			break;
		case CurrencyType.Money:
			CurrencyImg.overrideSprite = ItemShopM.S_Currency_Money;
			break;
		}
		Text[] priceTxt = PriceTxt;
		for (int i = 0; i < priceTxt.Length; i++)
		{
			priceTxt[i].text = m_Price.ToString();
		}
		if ((bool)ItemAmtTxt)
		{
			ItemAmtTxt.text = m_ItemAmount.ToString();
		}
	}

	public void CallPurchase()
	{
		ItemShopM.OnPurchaseCall(m_ItemType, m_Currency, m_Price, m_ItemAmount);
	}

	public void CallEquip()
	{
		ItemShopM.OnEquipCall(m_ItemType);
	}
}
public class csMainHorseShop : csMainMenuPanelBase
{
	public bool isBusy;

	private int curHorseIndex;

	public Button CenterButton;

	public TextMeshProUGUI[] CenterButtonTextsPro;

	public Transform[] CenterBtnTxtT;

	public TextMeshProUGUI[] CoinTextPro;

	public Transform CoinAnimT;

	public Transform GemAinmT;

	public TextMeshProUGUI MyCoinTextPro;

	public TextMeshProUGUI MyGemTextPro;

	public GameObject[] CoinObj;

	public csMountInfoUI MountInfoUI;

	public csLevelUpInfoUI LevelInfoUI;

	private HorseType tempHorseType;

	public Sprite DisableSprite_HaveHorse;

	public Sprite DisableSprite_NotHaveHorse;

	private Color BtnTextInitColor;

	public csHorseDirectSelect m_HorseSelect;

	public bool isBtnForPay;

	[SerializeField]
	private int tempHorsePrice;

	private csHorseInfo curHorseInfo;

	public override void StartInit()
	{
		BtnTextInitColor = CenterButtonTextsPro[0].color;
	}

	public override void Show(UnityAction act, string msg = "")
	{
		base.Show(act);
		if (msg == "")
		{
			ShopInit();
		}
		else
		{
			UnityEngine.Debug.LogError(msg);
			HorseType ht = (HorseType)int.Parse(msg);
			ShopInitWithHorse(ht);
		}
		RefreshCoin();
	}

	public void RefreshCoin()
	{
		MyCoinTextPro.text = csPlayerData.PlayerCoin.ToString();
		MyGemTextPro.text = csPlayerData.PlayerDiamond.ToString();
	}

	public void RefreshCoinAfterPurchase(int state = 0)
	{
		switch (state)
		{
		case 0:
			CoinAnimT.DOPunchScale(Vector3.one * 1.03f, 0.12f);
			GemAinmT.DOPunchScale(Vector3.one * 1.03f, 0.12f);
			break;
		case 1:
			CoinAnimT.DOPunchScale(Vector3.one * 1.03f, 0.12f);
			break;
		case 2:
			GemAinmT.DOPunchScale(Vector3.one * 1.03f, 0.12f);
			break;
		}
	}

	private void ShopInit()
	{
		curHorseIndex = csPlayerData.HorseTypeByPrice.FindIndex((HorseTypePrice x) => x.m_HorseType == csGameSettings.PlayerHorseType);
		tempHorseType = csGameSettings.PlayerHorseType;
		m_HorseSelect.InitHorseItemList();
		StartCoroutine(RefreshDirItemAfter(csGameSettings.PlayerHorseType));
		RefreshHorseInfo(csGameSettings.PlayerHorseType);
		csMainSceneManager.instance.InitRotatorInfoWhenOpenPanel(csGameSettings.PlayerHorseType);
	}

	private void ShopInitWithHorse(HorseType ht)
	{
		curHorseIndex = csPlayerData.HorseTypeByPrice.FindIndex((HorseTypePrice x) => x.m_HorseType == ht);
		tempHorseType = csGameSettings.PlayerHorseType;
		m_HorseSelect.InitHorseItemList();
		StartCoroutine(RefreshDirItemAfter(ht));
		RefreshHorseInfo(ht);
		csMainSceneManager.instance.InitRotatorInfoWhenOpenPanel(ht);
	}

	private IEnumerator RefreshDirItemAfter(HorseType ht)
	{
		yield return new WaitForEndOfFrame();
		m_HorseSelect.SetHorseNoTween(ht, curHorseIndex);
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.LeftArrow))
		{
			ChooseLeft(isLeft: true);
		}
		else if (Input.GetKeyDown(KeyCode.RightArrow))
		{
			ChooseLeft(isLeft: false);
		}
	}

	public void ChooseLeft(bool isLeft)
	{
		if (isBusy)
		{
			return;
		}
		isBusy = true;
		int num = 0;
		if (isLeft)
		{
			curHorseIndex--;
			num = curHorseIndex;
			if (curHorseIndex < 0)
			{
				curHorseIndex = 10;
			}
		}
		else
		{
			curHorseIndex++;
			num = curHorseIndex;
			if (curHorseIndex >= 11)
			{
				curHorseIndex = 0;
			}
		}
		csMainSceneManager.instance.ChooseRotatorAnim(isLeft, csPlayerData.HorseTypeByPrice[curHorseIndex].m_HorseType);
		m_HorseSelect.SetHorse(csPlayerData.HorseTypeByPrice[curHorseIndex].m_HorseType, num);
		csMainSceneManager.instance.HorseShopM.TurnBase(isLeft, delegate
		{
			isBusy = false;
			if (isLeft)
			{
				csMainSceneManager.instance.ChooseHorse(csPlayerData.HorseTypeByPrice[curHorseIndex].m_HorseType);
				RefreshHorseInfo(csPlayerData.HorseTypeByPrice[curHorseIndex].m_HorseType);
				csMainSceneAudioPlayer.instance.PlayAudio2DHorse("Choose_" + csPlayerData.HorseTypeByPrice[curHorseIndex].m_HorseType);
			}
			else
			{
				csMainSceneManager.instance.ChooseHorse(csPlayerData.HorseTypeByPrice[curHorseIndex].m_HorseType);
				RefreshHorseInfo(csPlayerData.HorseTypeByPrice[curHorseIndex].m_HorseType);
				csMainSceneAudioPlayer.instance.PlayAudio2DHorse("Choose_" + csPlayerData.HorseTypeByPrice[curHorseIndex].m_HorseType);
			}
		});
	}

	public void DirSelect(HorseType ht, int hid)
	{
		if (isBusy || ht == csPlayerData.HorseTypeByPrice[curHorseIndex].m_HorseType)
		{
			return;
		}
		isBusy = true;
		bool isLeft = hid < curHorseIndex;
		curHorseIndex = csPlayerData.HorseTypeByPrice.FindIndex((HorseTypePrice x) => x.m_HorseType == ht);
		csMainSceneManager.instance.ChooseRotatorAnim(isLeft, csPlayerData.HorseTypeByPrice[curHorseIndex].m_HorseType);
		csMainSceneManager.instance.HorseShopM.TurnBase(isLeft, delegate
		{
			isBusy = false;
			if (isLeft)
			{
				csMainSceneManager.instance.ChooseHorse(csPlayerData.HorseTypeByPrice[curHorseIndex].m_HorseType);
				RefreshHorseInfo(csPlayerData.HorseTypeByPrice[curHorseIndex].m_HorseType);
				csMainSceneAudioPlayer.instance.PlayAudio2DHorse("Choose_" + csPlayerData.HorseTypeByPrice[curHorseIndex].m_HorseType);
			}
			else
			{
				csMainSceneManager.instance.ChooseHorse(csPlayerData.HorseTypeByPrice[curHorseIndex].m_HorseType);
				RefreshHorseInfo(csPlayerData.HorseTypeByPrice[curHorseIndex].m_HorseType);
				csMainSceneAudioPlayer.instance.PlayAudio2DHorse("Choose_" + csPlayerData.HorseTypeByPrice[curHorseIndex].m_HorseType);
			}
		});
	}

	public void GoBackToMain()
	{
		csMainMenuCanvas.instance.BackFromShop();
		csMainSceneManager.instance.ChooseHorse(tempHorseType);
		RefreshHorseInfo(tempHorseType);
	}

	public void RefreshHorseInfo(HorseType _type)
	{
		csHorseInfo csHorseInfo2 = (curHorseInfo = csPlayerData.GetHorseInfo(_type));
		MountInfoUI.RefreshUI(csHorseInfo2, _type);
		TextMeshProUGUI[] coinTextPro = CoinTextPro;
		for (int i = 0; i < coinTextPro.Length; i++)
		{
			coinTextPro[i].text = csHorseInfo2.UnLockCoin.ToString();
		}
		MyCoinTextPro.text = csPlayerData.PlayerCoin.ToString();
		tempHorsePrice = csHorseInfo2.UnLockCoin;
		CenterButtonTextsPro[0].color = BtnTextInitColor;
		if (csPlayerData.GetHorseUnlockInfoByType(_type))
		{
			LevelInfoUI.ShowPanel();
			LevelInfoUI.InitHorseLevel(_type);
			if (tempHorseType == _type)
			{
				SetCenterBtnText(csLocalizationManager.Instance.GetLocalText("HorseShopMenu11"), iscenter: true);
				SpriteState spriteState = default(SpriteState);
				spriteState.highlightedSprite = CenterButton.spriteState.highlightedSprite;
				spriteState.pressedSprite = CenterButton.spriteState.pressedSprite;
				spriteState.disabledSprite = DisableSprite_HaveHorse;
				CenterButton.spriteState = spriteState;
				CenterButton.interactable = false;
				CenterButtonTextsPro[0].color = Color.black;
			}
			else
			{
				SetCenterBtnText(csLocalizationManager.Instance.GetLocalText("HorseShopMenu12"), iscenter: true);
				CenterButton.interactable = true;
				isBtnForPay = false;
			}
			CoinObj[0].gameObject.SetActive(value: false);
			CoinObj[1].gameObject.SetActive(value: false);
			return;
		}
		LevelInfoUI.HidePanel();
		if (csHorseInfo2.UnLockCoin > csPlayerData.PlayerCoin)
		{
			SpriteState spriteState2 = default(SpriteState);
			spriteState2.highlightedSprite = CenterButton.spriteState.highlightedSprite;
			spriteState2.pressedSprite = CenterButton.spriteState.pressedSprite;
			spriteState2.disabledSprite = DisableSprite_NotHaveHorse;
			CenterButton.spriteState = spriteState2;
			CenterButton.interactable = true;
			CenterButton.interactable = true;
			isBtnForPay = true;
			TextMeshProUGUI obj = CenterButtonTextsPro[0];
			string text2 = (CenterButtonTextsPro[1].text = "");
			obj.text = text2;
		}
		else
		{
			TextMeshProUGUI obj2 = CenterButtonTextsPro[0];
			string text2 = (CenterButtonTextsPro[1].text = "");
			obj2.text = text2;
			CenterButton.interactable = true;
			isBtnForPay = true;
		}
		CoinObj[0].gameObject.SetActive(value: true);
		CoinObj[1].gameObject.SetActive(value: true);
	}

	public void OnClickCenterBtn()
	{
		if (isBtnForPay)
		{
			if (tempHorsePrice > csPlayerData.PlayerCoin)
			{
				csMainMenuCanvas.instance.MsgPanel.SetMsg("", csLocalizationManager.Instance.GetLocalText("PopHint02"));
				csMainMenuCanvas.instance.MsgPanel.ShowHint(delegate
				{
					csMainMenuCanvas.instance.BackFromShopAction = delegate
					{
						csMainMenuCanvas.instance.GotoShopWithType(csPlayerData.HorseTypeByPrice[curHorseIndex].m_HorseType);
					};
					csMainSceneManager.instance.HorseShopM.PlayHorsePosAnim(isUp: false);
					csMainSceneAudioPlayer.instance.LerpBGM(1f);
					csMainMenuCanvas.instance.OpenMenu(MainMenuType.PropShop, "CoinShop");
				}, delegate
				{
				});
			}
			else
			{
				csPlayerData.PlayerCoin -= tempHorsePrice;
				csPlayerData.SetHorseUnlockedByType(csPlayerData.HorseTypeByPrice[curHorseIndex].m_HorseType);
				RefreshHorseInfo(csPlayerData.HorseTypeByPrice[curHorseIndex].m_HorseType);
				csMainSceneAudioPlayer.instance.PlayAudio2D("PurchaseSuccess");
			}
		}
		else
		{
			tempHorseType = csPlayerData.HorseTypeByPrice[curHorseIndex].m_HorseType;
			csMainSceneManager.instance.ChooseHorse(csPlayerData.HorseTypeByPrice[curHorseIndex].m_HorseType);
			RefreshHorseInfo(csPlayerData.HorseTypeByPrice[curHorseIndex].m_HorseType);
			csMainSceneAudioPlayer.instance.PlayAudio2D("HorseEquip");
			csGameSettings.PlayerHorseType = tempHorseType;
		}
	}

	private void SetCenterBtnText(string str, bool iscenter)
	{
		for (int i = 0; i < CenterButtonTextsPro.Length; i++)
		{
			csLocalizationManager.Instance.CheckTextFontType(CenterButtonTextsPro[i]);
			CenterButtonTextsPro[i].text = str;
		}
		for (int j = 0; j < CenterBtnTxtT.Length; j++)
		{
			CenterBtnTxtT[j].transform.localPosition = (iscenter ? new Vector3(0f, 0f, 0f) : new Vector3(26.88f, 0f, 0f));
		}
	}
}
public class csMainMenuCanvas : MonoBehaviour
{
	public MainMenuType CurMainMenuType;

	public Dictionary<MainMenuType, csMainMenuPanelBase> MenuObjDic = new Dictionary<MainMenuType, csMainMenuPanelBase>();

	public static csMainMenuCanvas instance;

	public csFadeManager PlayerCamFade;

	public Action BackFromShopAction;

	public csPopHint PopHintM;

	public csMainMsgPanel MsgPanel;

	private float duration_minute = 30f;

	public float m_second;

	private float totalSecond;

	public bool isCountDown;

	public Action UpdateBoxProgress;

	private void Awake()
	{
		instance = this;
		csPlayerData.InitAchievementDic();
		csPlayerData.InitPlayerLevelDataDic();
		csPlayerData.InitPlayerLevelAwardList();
		CheckDateTime();
	}

	public void AddToMenuDic(MainMenuType t, csMainMenuPanelBase g)
	{
		if (!MenuObjDic.ContainsKey(t))
		{
			MenuObjDic.Add(t, g);
		}
	}

	private IEnumerator Start()
	{
		yield return new WaitForSeconds(0.1f);
		OpenMenu(MainMenuType.MainMenu);
	}

	public void OpenMenu(MainMenuType t, string msg = "")
	{
		foreach (csMainMenuPanelBase value in MenuObjDic.Values)
		{
			value.Hide(null);
		}
		MenuObjDic[t].Show(null, msg);
	}

	public void HideAllPanel()
	{
		foreach (csMainMenuPanelBase value in MenuObjDic.Values)
		{
			value.Hide(null);
		}
	}

	public void StartGame(GameMode _mode)
	{
		csGameSettings.CurrentGameMode = _mode;
		StartCoroutine(StartGameFade());
	}

	private IEnumerator StartGameFade()
	{
		HideAllPanel();
		csMainSceneManager.instance.HorseShopM.PrepareRoad();
		csMainSceneAudioPlayer.instance.PlayAudio2D("GameStart");
		csMainSceneAudioPlayer.instance.FadeBGM(isOut: true);
		yield return new WaitForSeconds(0.8f);
		csMainSceneManager.instance.StartRun();
		OpenMenu(MainMenuType.Loading);
		yield return new WaitForSeconds(1.5f);
		if (PlayerCamFade == null)
		{
			PlayerCamFade = UnityEngine.Object.FindObjectOfType<csFadeManager>();
		}
		csGameSettings.isFromMainScene = true;
		if ((bool)PlayerCamFade)
		{
			PlayerCamFade.FadeOut(delegate
			{
			}, 1f, needLoading: true);
		}
		yield return new WaitForSeconds(1f);
		csGameSettings.IsLoadToGame = true;
		SceneManager.LoadScene("LoadingScene");
	}

	public void GotoShop()
	{
		OpenMenu(MainMenuType.HorseShop);
		foreach (csHoserRotatorItem horseRotator in csMainSceneManager.instance.horseRotatorList)
		{
			horseRotator.initer.OpenHorse();
		}
		csMainSceneManager.instance.HorseShopM.PlayHorsePosAnim(isUp: true);
		csMainSceneAudioPlayer.instance.LerpBGM(0.3f);
	}

	public void GotoShopWithType(HorseType ht)
	{
		int num = (int)ht;
		OpenMenu(MainMenuType.HorseShop, num.ToString());
		csMainSceneManager.instance.HorseShopM.PlayHorsePosAnim(isUp: true);
		csMainSceneAudioPlayer.instance.LerpBGM(0.3f);
	}

	public void GotoPropShop()
	{
		OpenMenu(MainMenuType.PropShop);
		csMainSceneAudioPlayer.instance.LerpBGM(0.3f);
	}

	public void BackFromShop()
	{
		OpenMenu(MainMenuType.MainMenu);
		foreach (csHoserRotatorItem horseRotator in csMainSceneManager.instance.horseRotatorList)
		{
			horseRotator.initer.DestroyHorse();
		}
		csMainSceneManager.instance.HorseShopM.PlayHorsePosAnim(isUp: false);
		csMainSceneAudioPlayer.instance.LerpBGM(1f);
	}

	public void BackToMenu()
	{
		OpenMenu(MainMenuType.MainMenu);
		csMainSceneAudioPlayer.instance.LerpBGM(1f);
	}

	public void GotoAchievement()
	{
		OpenMenu(MainMenuType.Achievement);
	}

	private void LateUpdate()
	{
		if (csGameSettings.Channel == ChannelType.OculusGO && CurMainMenuType == MainMenuType.MainMenu && (OVRInput.Get(OVRInput.Button.Back) || Input.GetKeyDown(KeyCode.Escape)))
		{
			instance.MsgPanel.SetMsg(csLocalizationManager.Instance.GetLocalText("PopHint07"), csLocalizationManager.Instance.GetLocalText("MainMenu41"));
			instance.MsgPanel.ShowHint(delegate
			{
				UnityEngine.Application.Quit();
			}, null);
		}
	}

	public void RefreshMainMenuCoin()
	{
		((csMainStartPanel)MenuObjDic[MainMenuType.MainMenu]).RefreshCoin();
	}

	private void CheckDateTime()
	{
		string @string = PlayerPrefs.GetString("BoxAwardTime", "");
		if (!string.IsNullOrEmpty(@string))
		{
			long num = long.Parse(@string);
			long ticks = DateTime.Now.Ticks - num;
			TimeSpan timeSpan = new TimeSpan(ticks);
			if (timeSpan.TotalMinutes <= (double)duration_minute)
			{
				float persent = 1f - (float)timeSpan.TotalMinutes / duration_minute;
				CountDown(persent);
			}
			else
			{
				ResetTime();
			}
		}
		else
		{
			ShowBoxBtn(open: true);
		}
	}

	private void ResetTime()
	{
		PlayerPrefs.SetString("BoxAwardTime", "");
		ShowBoxBtn(open: true);
	}

	public void SaveDateTime()
	{
		string text = DateTime.Now.Ticks.ToString();
		UnityEngine.Debug.Log(text);
		PlayerPrefs.SetString("BoxAwardTime", text);
	}

	private void ShowBoxBtn(bool open)
	{
		StartCoroutine(IEShowBoxBtn(open));
	}

	private IEnumerator IEShowBoxBtn(bool open)
	{
		while (!MenuObjDic.ContainsKey(MainMenuType.MainMenu))
		{
			yield return new WaitForEndOfFrame();
		}
		((csMainStartPanel)MenuObjDic[MainMenuType.MainMenu]).ShowBoxBtn(open);
	}

	private void CountDown(float persent)
	{
		ShowBoxBtn(open: false);
		totalSecond = duration_minute * 60f;
		m_second = totalSecond * persent;
		instance.StartCoroutine(IECountDown());
	}

	private IEnumerator IECountDown()
	{
		isCountDown = true;
		while (m_second > 0f)
		{
			m_second -= 1f;
			UpdateBoxProgress?.Invoke();
			yield return new WaitForSeconds(1f);
		}
		isCountDown = false;
		ResetTime();
	}

	public void OpenBox()
	{
		CountDown(1f);
		SaveDateTime();
		OpenMenu(MainMenuType.BoxAward);
	}

	public float ProgressScale()
	{
		return m_second / totalSecond;
	}
}
public class csMainMenuPanelBase : MonoBehaviour
{
	public MainMenuType m_MenuType;

	public GameObject thisG;

	private void Awake()
	{
		thisG = base.gameObject;
		AwakeInit();
	}

	protected void Start()
	{
		csMainMenuCanvas.instance.AddToMenuDic(m_MenuType, this);
		StartInit();
		Hide(null);
	}

	public virtual void AwakeInit()
	{
	}

	public virtual void StartInit()
	{
	}

	public virtual void Show(UnityAction act, string msg = "")
	{
		thisG.SetActive(value: true);
		act?.Invoke();
	}

	public virtual void Hide(UnityAction act)
	{
		thisG.SetActive(value: false);
		act?.Invoke();
	}
}
public class csMainMenuSetting : MonoBehaviour
{
	public csButtonGroup m_SwitchVibrationBtn_Group;

	public Image MusicSlider;

	public Image SoundSlider;

	public Image SensitivitySlider;

	public Text PlayerNameText;

	public TextMeshProUGUI LanguageTextPro;

	private int MusicVolume;

	private int SoundVolume;

	private int SensitivityValue;

	private int languagecount;

	private int LangeuageIndex;

	private void Awake()
	{
		Language language = Language.ChineseSimplified;
		languagecount = Enum.GetNames(language.GetType()).Length;
	}

	private void OnEnable()
	{
		m_SwitchVibrationBtn_Group.OnSetIndex = OnSwitchVibrationBtn;
		m_SwitchVibrationBtn_Group.SetCurrntIndex((!csPlayerData.VibrationSwitch) ? 1 : 0);
		MusicVolume = csPlayerData.MusicVolume;
		SoundVolume = csPlayerData.SoundFXVolume;
		SensitivityValue = csPlayerData.Sensitivity;
		MusicSlider.fillAmount = (float)MusicVolume / 10f;
		SoundSlider.fillAmount = (float)SoundVolume / 10f;
		SensitivitySlider.fillAmount = (float)SensitivityValue / 10f;
		PlayerNameText.text = csPlayerData.PlayerName;
		LangeuageIndex = (int)csLocalizationManager.Instance.m_CurrentLanguage;
		csLocalizationManager.updateLocalText = (Action)Delegate.Combine(csLocalizationManager.updateLocalText, new Action(RefreshLanguageText));
		RefreshLanguageText();
	}

	private void OnDisable()
	{
		csLocalizationManager.updateLocalText = (Action)Delegate.Remove(csLocalizationManager.updateLocalText, new Action(RefreshLanguageText));
	}

	private void OnSwitchVibrationBtn(int index)
	{
		csPlayerData.VibrationSwitch = index == 0;
	}

	public void ChangeMusicValue(bool isAdd)
	{
		if ((!isAdd || MusicVolume != 10) && (isAdd || MusicVolume != 0))
		{
			if (isAdd)
			{
				MusicVolume++;
			}
			else
			{
				MusicVolume--;
			}
			MusicSlider.fillAmount = (float)MusicVolume / 10f;
			csPlayerData.MusicVolume = MusicVolume;
			csPlayerData.VolumeChangeAct?.Invoke();
		}
	}

	public void ChangeSoundValue(bool isAdd)
	{
		if ((!isAdd || SoundVolume != 10) && (isAdd || SoundVolume != 0))
		{
			if (isAdd)
			{
				SoundVolume++;
			}
			else
			{
				SoundVolume--;
			}
			SoundSlider.fillAmount = (float)SoundVolume / 10f;
			csPlayerData.SoundFXVolume = SoundVolume;
			csPlayerData.VolumeChangeAct?.Invoke();
		}
	}

	public void ChangeSensitivityValue(bool isAdd)
	{
		if ((!isAdd || SensitivityValue != 10) && (isAdd || SensitivityValue != 0))
		{
			if (isAdd)
			{
				SensitivityValue++;
			}
			else
			{
				SensitivityValue--;
			}
			SensitivitySlider.fillAmount = (float)SensitivityValue / 10f;
			csPlayerData.Sensitivity = SensitivityValue;
		}
	}

	public void TurnLeft()
	{
		if (LangeuageIndex != 0)
		{
			LangeuageIndex--;
			SetLangeuage();
		}
	}

	public void TurnRight()
	{
		if (LangeuageIndex != languagecount - 1)
		{
			LangeuageIndex++;
			SetLangeuage();
		}
	}

	private void SetLangeuage()
	{
		if (csGameSettings.EnglishOnly)
		{
			csLocalizationManager.Instance.SetLanguage(Language.English);
		}
		else
		{
			csLocalizationManager.Instance.SetLanguage((Language)LangeuageIndex);
		}
	}

	private void RefreshLanguageText()
	{
		string localText = csLocalizationManager.Instance.GetLocalText("Prop07");
		csLocalizationManager.Instance.CheckTextFontType(LanguageTextPro);
		LanguageTextPro.text = localText;
	}

	public void OpenChangeNamePanel()
	{
		csMainMenuCanvas.instance.OpenMenu(MainMenuType.ChangeName);
	}
}
public class csMainMsgPanel : MonoBehaviour
{
	public GameObject thisG;

	public TextMeshProUGUI TitleTxt;

	public TextMeshProUGUI ContentTxt;

	public TextMeshProUGUI[] YesTexts;

	public TextMeshProUGUI[] NoTexts;

	private UnityAction YesAct;

	private UnityAction NoAct;

	private void Awake()
	{
		thisG.SetActive(value: false);
	}

	public void SetMsg(string t, string c)
	{
		csLocalizationManager.Instance.CheckTextFontType(TitleTxt);
		csLocalizationManager.Instance.CheckTextFontType(ContentTxt);
		TitleTxt.text = t;
		ContentTxt.text = c;
	}

	public void ShowHint(UnityAction actYes, UnityAction actNo)
	{
		thisG.SetActive(value: true);
		YesAct = actYes;
		NoAct = actNo;
		csGameSettings.SetHintOn(isOn: true);
	}

	public void OnYesBtn()
	{
		Close();
		YesAct?.Invoke();
	}

	public void OnNoBtn()
	{
		Close();
		NoAct?.Invoke();
	}

	public void Close()
	{
		csGameSettings.SetHintOn(isOn: false);
		thisG.SetActive(value: false);
	}
}
public class csMainSceneAudioPlayer : MonoBehaviour
{
	public static csMainSceneAudioPlayer instance;

	public AudioSource ASSplayer2D;

	public AudioSource ASSplayer2DHorse;

	public List<AduioClipObject> AObjectList = new List<AduioClipObject>();

	private Dictionary<string, AudioClip> ClipByName = new Dictionary<string, AudioClip>();

	public AudioSource ASSLoop;

	public AudioSource ASSBGM;

	private DG.Tweening.Tween BGMTweener;

	private void Awake()
	{
		instance = this;
		for (int i = 0; i < AObjectList.Count; i++)
		{
			ClipByName.Add(AObjectList[i].AduioName, AObjectList[i].m_Clip);
		}
		ASSplayer2D.volume = 1f * ((float)csPlayerData.SoundFXVolume / 10f);
		ASSplayer2DHorse.volume = 1f * ((float)csPlayerData.SoundFXVolume / 10f);
		ASSBGM.volume = 1f * ((float)csPlayerData.MusicVolume / 10f);
		csPlayerData.VolumeChangeAct = (UnityAction)Delegate.Combine(csPlayerData.VolumeChangeAct, new UnityAction(OnAudioVolChange));
	}

	private void OnDestroy()
	{
		csPlayerData.VolumeChangeAct = (UnityAction)Delegate.Remove(csPlayerData.VolumeChangeAct, new UnityAction(OnAudioVolChange));
	}

	public void OnAudioVolChange()
	{
		ASSplayer2D.volume = 1f * ((float)csPlayerData.SoundFXVolume / 10f);
		ASSplayer2DHorse.volume = 1f * ((float)csPlayerData.SoundFXVolume / 10f);
		ASSBGM.volume = 1f * ((float)csPlayerData.MusicVolume / 10f);
	}

	private void Start()
	{
		ASSBGM.Play();
	}

	public void FadeBGM(bool isOut)
	{
		if (BGMTweener != null && !BGMTweener.IsComplete())
		{
			BGMTweener.Kill();
		}
		if (isOut)
		{
			BGMTweener = ASSBGM.DOFade(0f * ((float)csPlayerData.MusicVolume / 10f), 0.5f);
		}
		else
		{
			BGMTweener = ASSBGM.DOFade(1f * ((float)csPlayerData.MusicVolume / 10f), 0.5f);
		}
	}

	public void LerpBGM(float vol)
	{
		if (BGMTweener != null && !BGMTweener.IsComplete())
		{
			BGMTweener.Kill();
		}
		BGMTweener = ASSBGM.DOFade(vol * ((float)csPlayerData.MusicVolume / 10f), 0.5f);
	}

	public void PlayAudio2D(string name, float vol = 1f)
	{
		ASSplayer2D.PlayOneShot(ClipByName[name], vol);
	}

	public void PlayAudio2DHorse(string name, float vol = 1f)
	{
		ASSplayer2DHorse.Stop();
		ASSplayer2DHorse.PlayOneShot(ClipByName[name], vol);
	}

	public void PlayAudio2DClip(AudioClip ac, float vol = 1f)
	{
		ASSplayer2D.PlayOneShot(ac, vol);
	}

	public void PlayAudioLoop(string name, float vol = 1f)
	{
		ASSLoop.clip = ClipByName[name];
		ASSLoop.Play();
	}

	public void PlayAudio(string name, Vector3 pos, float vol = 1f)
	{
		AudioSource.PlayClipAtPoint(ClipByName[name], pos, vol);
	}
}
[Serializable]
public class AduioClipObject
{
	public string AduioName;

	public AudioClip m_Clip;
}
public class csMainSceneManager : MonoBehaviour
{
	public static csMainSceneManager instance;

	public Transform PlayerRunRoot;

	public csHorseshopManager HorseShopM;

	public csHorseIniter PlayerHorseIniter;

	private csHorseModelController CurrentHorse;

	public List<csHoserRotatorItem> horseRotatorList = new List<csHoserRotatorItem>();

	public Dictionary<HorseType, AudioClip> TypeToShoeClip = new Dictionary<HorseType, AudioClip>();

	public AudioClip ShoeClip_Horse;

	public AudioClip ShoeClip_WoodenHorse;

	public AudioClip ShoeClip_Dragon;

	public AudioClip ShoeClip_Croco;

	public AudioClip ShoeClip_Elephant;

	public AudioClip ShoeClip_Rhino;

	private string ABuffIndex = "1";

	private int currentChosenIndex;

	public ParticleSystem LevelUpParticle;

	private csHoserRotatorItem curRotatorItem;

	private void Awake()
	{
		instance = this;
		csGameSettings.Init();
		TypeToShoeClip.Add(HorseType.Horse_Default, ShoeClip_Horse);
		TypeToShoeClip.Add(HorseType.Horse_1, ShoeClip_Horse);
		TypeToShoeClip.Add(HorseType.Horse_2, ShoeClip_Horse);
		TypeToShoeClip.Add(HorseType.Horse_3, ShoeClip_Horse);
		TypeToShoeClip.Add(HorseType.Horse_4, ShoeClip_Horse);
		TypeToShoeClip.Add(HorseType.Horse_5, ShoeClip_WoodenHorse);
		TypeToShoeClip.Add(HorseType.Horse_6, ShoeClip_WoodenHorse);
		TypeToShoeClip.Add(HorseType.Rhino_1, ShoeClip_Rhino);
		TypeToShoeClip.Add(HorseType.Crocodile, ShoeClip_Croco);
		TypeToShoeClip.Add(HorseType.Elephant, ShoeClip_Elephant);
		TypeToShoeClip.Add(HorseType.DragonBoss, ShoeClip_Dragon);
		csPlayerData.InitAheadBuffData();
	}

	private void Start()
	{
		if (!csPlayerData.GetHorseUnlockInfoByType(csGameSettings.PlayerHorseType))
		{
			csGameSettings.PlayerHorseType = HorseType.Horse_Default;
		}
		CurrentHorse = PlayerHorseIniter.InitHorse(csGameSettings.PlayerHorseType);
		csHMDIniter.instance.SetOffsetLerp(CurrentHorse.CamYOffset);
		csMainMenuCanvas.instance.transform.DOLocalMove(new Vector3(0f, CurrentHorse.CamYOffset, 4f), 0.1f).SetEase(Ease.Linear);
	}

	public void StartRun()
	{
		CurrentHorse.SetRun(isRun: true);
		PlayerRunRoot.DOMoveZ(80f, 5f).SetEase(Ease.Linear);
		csPlayerData.ApplyBuffListToLevel();
		csHMDIniter.instance.CurrentSetter.LHandT.GetComponent<ViveUILaserPointer>().enabled = false;
		csHMDIniter.instance.CurrentSetter.RHandT.GetComponent<ViveUILaserPointer>().enabled = false;
		csMainSceneAudioPlayer.instance.PlayAudio2DClip(TypeToShoeClip[csGameSettings.PlayerHorseType]);
	}

	public void ChooseHorse(HorseType horseType)
	{
		float camYOffset = csHorseObjectManager.instance.HorseList.Find((HorseObject x) => x.m_Type == horseType).m_PrefabObj.GetComponent<csHorseModelController>().CamYOffset;
		csHMDIniter.instance.SetOffsetLerp(camYOffset);
		if (horseType == HorseType.Crocodile)
		{
			CurrentHorse = PlayerHorseIniter.InitHorse(horseType);
			csMainMenuCanvas.instance.transform.DOLocalMove(new Vector3(0f, camYOffset, 4f), 0.1f).SetEase(Ease.Linear);
		}
		else
		{
			csMainMenuCanvas.instance.transform.DOLocalMove(new Vector3(0f, camYOffset, 4f), 0.1f).SetEase(Ease.Linear).OnComplete(delegate
			{
				CurrentHorse = PlayerHorseIniter.InitHorse(horseType);
			});
		}
	}

	public void InitRotatorInfo(HorseType t)
	{
		horseRotatorList[currentChosenIndex].initer.InitHorse(t, onPlatform: true);
		horseRotatorList[GetRotatorIndexByInt(currentChosenIndex + 1)].initer.InitHorse(GetHorseTypeByOffset(t, 1), onPlatform: true);
		horseRotatorList[GetRotatorIndexByInt(currentChosenIndex + 2)].initer.InitHorse(GetHorseTypeByOffset(t, 2), onPlatform: true);
		horseRotatorList[GetRotatorIndexByInt(currentChosenIndex - 1)].initer.InitHorse(GetHorseTypeByOffset(t, -1), onPlatform: true);
		horseRotatorList[GetRotatorIndexByInt(currentChosenIndex - 2)].initer.InitHorse(GetHorseTypeByOffset(t, -2), onPlatform: true);
	}

	public void InitRotatorInfoWhenOpenPanel(HorseType t)
	{
		horseRotatorList[currentChosenIndex].initer.InitHorse(t, onPlatform: true);
		horseRotatorList[GetRotatorIndexByInt(currentChosenIndex + 1)].initer.InitHorse(GetHorseTypeByOffset(t, 1), onPlatform: true);
		horseRotatorList[GetRotatorIndexByInt(currentChosenIndex + 2)].initer.InitHorse(GetHorseTypeByOffset(t, 2), onPlatform: true);
		horseRotatorList[GetRotatorIndexByInt(currentChosenIndex - 1)].initer.InitHorse(GetHorseTypeByOffset(t, -1), onPlatform: true);
		horseRotatorList[GetRotatorIndexByInt(currentChosenIndex - 2)].initer.InitHorse(GetHorseTypeByOffset(t, -2), onPlatform: true);
		for (int i = 0; i < horseRotatorList.Count; i++)
		{
			if (horseRotatorList[i].initer.CurType == t)
			{
				horseRotatorList[i].OpenEffect(isLeft: true);
				curRotatorItem = horseRotatorList[i];
			}
			else if (i == GetRotatorIndexByInt(currentChosenIndex + 3) || i == GetRotatorIndexByInt(currentChosenIndex + 4) || i == GetRotatorIndexByInt(currentChosenIndex + 5))
			{
				horseRotatorList[i].CloseEffectWhenOpenPanel(isFar: true, needRotate: false, isLeft: false, 0f);
			}
			else if (i == GetRotatorIndexByInt(currentChosenIndex + 1) || i == GetRotatorIndexByInt(currentChosenIndex + 7))
			{
				horseRotatorList[i].CloseEffectWhenOpenPanel(isFar: false, needRotate: false, isLeft: false, 0f);
			}
			else if (i == GetRotatorIndexByInt(currentChosenIndex + 2) || i == GetRotatorIndexByInt(currentChosenIndex + 6))
			{
				horseRotatorList[i].CloseEffectWhenOpenPanel(isFar: false, needRotate: false, isLeft: false, 180f);
			}
		}
	}

	public int GetRotatorIndexByInt(int inIndex)
	{
		int num = inIndex;
		if (num >= 8)
		{
			num = inIndex - 8;
		}
		if (num < 0)
		{
			num = 8 + inIndex;
		}
		return num;
	}

	public HorseType GetHorseTypeByOffset(HorseType t, int offset)
	{
		int num = csPlayerData.HorseTypeByPrice.FindIndex((HorseTypePrice x) => x.m_HorseType == t);
		num += offset;
		if (num < 0)
		{
			num = 11 + num;
		}
		if (num >= 11)
		{
			num -= 11;
		}
		return csPlayerData.HorseTypeByPrice[num].m_HorseType;
	}

	public void ChooseRotatorAnim(bool isLeft, HorseType t)
	{
		if (isLeft)
		{
			currentChosenIndex = GetRotatorIndexByInt(currentChosenIndex - 1);
		}
		else
		{
			currentChosenIndex = GetRotatorIndexByInt(currentChosenIndex + 1);
		}
		InitRotatorInfo(t);
		for (int i = 0; i < horseRotatorList.Count; i++)
		{
			if (horseRotatorList[i].initer.CurType == t)
			{
				curRotatorItem = horseRotatorList[i];
				horseRotatorList[i].OpenEffect(isLeft);
			}
			else if (i == GetRotatorIndexByInt(currentChosenIndex + 3) || i == GetRotatorIndexByInt(currentChosenIndex + 4) || i == GetRotatorIndexByInt(currentChosenIndex + 5))
			{
				horseRotatorList[i].CloseEffect(isFar: true, needRotate: false, isLeft);
			}
			else if (i == GetRotatorIndexByInt(currentChosenIndex + 1) || i == GetRotatorIndexByInt(currentChosenIndex + 7))
			{
				horseRotatorList[i].CloseEffect(isFar: false, needRotate: true, isLeft);
			}
			else if (i == GetRotatorIndexByInt(currentChosenIndex + 2) || i == GetRotatorIndexByInt(currentChosenIndex + 6))
			{
				horseRotatorList[i].CloseEffect(isFar: false, needRotate: false, isLeft);
			}
		}
		curRotatorItem.initer.curHorseCtrl.HorseAnim.Play("ChoosePose", 0, 0f);
	}

	public void DoLevelUpOnHorseItem()
	{
		if ((bool)curRotatorItem)
		{
			LevelUpParticle.transform.position = curRotatorItem.effectT.position + Vector3.up * 0.02f;
			LevelUpParticle.Stop();
			LevelUpParticle.Play();
		}
	}
}
public class csMainStartPanel : csMainMenuPanelBase
{
	public Text NameText;

	public TextMeshProUGUI CoinTextPro;

	public TextMeshProUGUI GemsTextPro;

	public csMountInfoUI MountInfoUI;

	public GameObject MidMenuBody;

	public GameObject LevelSelectBody;

	public Transform levelStartPanel;

	public csLeaderboardInfoList leaderboardPanel;

	public GameObject LeaderboardObj;

	public GameObject SettingObj;

	public Button BoxBtn;

	public DOTweenAnimation boxBtnAnimation;

	public Image BoxSlider;

	public TextMeshProUGUI BoxProgressText;

	public GameObject AchievementTips;

	public TextMeshProUGUI AchievementTipsTextPro;

	public Image BoxImg;

	public Sprite BoxEnableSprie;

	public Sprite BoxDisabeSprite;

	public override void AwakeInit()
	{
		base.AwakeInit();
		SettingObj.SetActive(value: false);
	}

	public override void StartInit()
	{
		base.StartInit();
		csPlayerData.RefreshAchievementAction = (Action)Delegate.Combine(csPlayerData.RefreshAchievementAction, new Action(RefreshAchievementTips));
	}

	public void OnDestroy()
	{
		csPlayerData.RefreshAchievementAction = (Action)Delegate.Remove(csPlayerData.RefreshAchievementAction, new Action(RefreshAchievementTips));
	}

	private void RefreshAchievementTips()
	{
		AchievementTips.SetActive(csPlayerData.NewAchievementCount > 0);
		if (csPlayerData.NewAchievementCount > 0)
		{
			AchievementTipsTextPro.text = csPlayerData.NewAchievementCount.ToString();
		}
	}

	public void StartGame()
	{
		csMainMenuCanvas.instance.OpenMenu(MainMenuType.Endless);
	}

	public void StartLevelMode()
	{
		if (csPlayerData.PlayerLevelDataDic[csGameSettings.CurrentSelectedLevel].isUnLock)
		{
			csMainMenuCanvas.instance.StartGame(GameMode.LevelMode);
		}
	}

	public void ShowLevelSelect()
	{
		MidMenuBody.SetActive(value: false);
		LevelSelectBody.SetActive(value: true);
		leaderboardPanel.HidePanel();
		SettingObj.SetActive(value: false);
	}

	public void ShowMidMenu()
	{
		MidMenuBody.SetActive(value: true);
		LevelSelectBody.SetActive(value: false);
		leaderboardPanel.ShowPanel();
		SettingObj.SetActive(value: false);
	}

	public void ToShop()
	{
		csMainMenuCanvas.instance.GotoShop();
	}

	public override void Show(UnityAction act, string msg = "")
	{
		csGameSettings.IsLoading = false;
		NameText.text = csPlayerData.PlayerName;
		CoinTextPro.text = csPlayerData.PlayerCoin.ToString();
		GemsTextPro.text = csPlayerData.PlayerDiamond.ToString();
		csHorseInfo horseInfo = csPlayerData.GetHorseInfo(csGameSettings.PlayerHorseType);
		MountInfoUI.RefreshUI(horseInfo, csGameSettings.PlayerHorseType);
		ShowMidMenu();
		csMainMenuCanvas.instance.UpdateBoxProgress = OnUpdateBoxProgress;
		base.Show(act);
		RefreshAchievementTips();
		if (csGameSettings.ShowLevelPanel)
		{
			csGameSettings.ShowLevelPanel = false;
			ShowLevelSelect();
		}
	}

	public void RefreshCoin()
	{
		CoinTextPro.text = csPlayerData.PlayerCoin.ToString();
		GemsTextPro.text = csPlayerData.PlayerDiamond.ToString();
	}

	public void ShowSetting()
	{
		leaderboardPanel.HidePanel();
		SettingObj.SetActive(value: true);
		LevelSelectBody.SetActive(value: false);
	}

	public void ShowLeaderboard()
	{
		leaderboardPanel.ShowPanel();
		SettingObj.SetActive(value: false);
		LevelSelectBody.SetActive(value: false);
	}

	public void ShowBoxBtn(bool open)
	{
		BoxBtn.interactable = open;
		if (open)
		{
			boxBtnAnimation.DOPlay();
		}
		else
		{
			boxBtnAnimation.DOKill();
		}
		BoxImg.overrideSprite = (open ? BoxEnableSprie : BoxDisabeSprite);
		BoxSlider.gameObject.SetActive(!open);
		BoxProgressText.gameObject.SetActive(!open);
	}

	private void OnUpdateBoxProgress()
	{
		BoxSlider.fillAmount = csMainMenuCanvas.instance.ProgressScale();
		BoxProgressText.text = $"{(int)csMainMenuCanvas.instance.m_second / 60:00}" + ":" + $"{(int)csMainMenuCanvas.instance.m_second % 60:00}";
	}

	public void OpenBox()
	{
		csMainMenuCanvas.instance.OpenBox();
	}
}
public class csMianPropShop : csMainMenuPanelBase
{
	public Sprite S_Currency_Coin;

	public Sprite S_Currency_Gem;

	public Sprite S_Currency_Money;

	public GameObject PropContainer;

	public GameObject CoinContainer;

	public GameObject GemContainer;

	public csColumeInPropShop PropColInShop;

	public csColumeInPropShop CoinColInShop;

	public csColumeInPropShop GemColInShop;

	public Text GemsText;

	public DOTweenAnimation coinLabelAnim;

	public DOTweenAnimation GemLabelAnim;

	public Text CoinText;

	public static ItemShopColType curShopColType;

	public List<csItemInPropShop> PropShopItemList = new List<csItemInPropShop>();

	public List<csItemInPropShop> CoinShopItemList = new List<csItemInPropShop>();

	private void Awake()
	{
		PropContainer.SetActive(value: false);
		CoinContainer.SetActive(value: false);
		GemContainer.SetActive(value: false);
		PropColInShop.SetSelect(isSelect: false);
		CoinColInShop.SetSelect(isSelect: false);
		GemColInShop.SetSelect(isSelect: false);
	}

	public void OnPurchaseCall(ShopItem itemtype, CurrencyType ctype, int price, int itemamt)
	{
		if (ctype == CurrencyType.Coin)
		{
			if (price > csPlayerData.PlayerCoin)
			{
				csMainMenuCanvas.instance.MsgPanel.SetMsg("", csLocalizationManager.Instance.GetLocalText("PopHint02"));
				csMainMenuCanvas.instance.MsgPanel.ShowHint(delegate
				{
					SetToCol(ItemShopColType.CoinShop);
				}, null);
				return;
			}
			csPlayerData.PlayerCoin -= price;
		}
		if (ctype == CurrencyType.Gem)
		{
			if (price > csPlayerData.PlayerDiamond)
			{
				csMainMenuCanvas.instance.PopHintM.ShowHint(csLocalizationManager.Instance.GetLocalText("PopHint03"));
				return;
			}
			csMainMenuCanvas.instance.MsgPanel.SetMsg("", csLocalizationManager.Instance.GetLocalText("PopHint06"));
			csMainMenuCanvas.instance.MsgPanel.ShowHint(delegate
			{
				csPlayerData.PlayerDiamond -= price;
				ShopItem shopItem = itemtype;
				if ((uint)(shopItem - 80) <= 3u)
				{
					csPlayerData.PlayerCoin += itemamt;
					RefreshCoinAfterPurchase();
				}
			}, null);
		}
		switch (itemtype)
		{
		case ShopItem.Item_001_RushS:
		case ShopItem.Item_002_RushM:
		case ShopItem.Item_003_RushB:
		case ShopItem.Item_004_ShieldS:
		case ShopItem.Item_005_ShieldM:
		case ShopItem.Item_006_ShieldB:
		case ShopItem.Item_007_AddLifeS:
		case ShopItem.Item_008_GoldBuffS:
		case ShopItem.Item_009_GoldBuffM:
		case ShopItem.Item_010_GoldBuffB:
		case ShopItem.Item_011_ScoreBuffS:
		case ShopItem.Item_012_ScoreBuffM:
		case ShopItem.Item_013_ScoreBuffB:
			csPlayerData.OnGetAheadBuff((AheadBuff)itemtype, itemamt);
			PropShopItemList.Find((csItemInPropShop x) => x.m_ItemType == itemtype).RefrshStatus(csPlayerData.BuffDataDic[(AheadBuff)itemtype]);
			csPlayerData.WriteBuffData(csPlayerData.BuffDataDic);
			RefreshCoinAfterPurchase(1);
			break;
		case ShopItem.Item_090_GemS:
		case ShopItem.Item_091_GemM:
		case ShopItem.Item_092_GemB:
			csPlayerData.PlayerDiamond += itemamt;
			RefreshCoinAfterPurchase(2);
			break;
		}
	}

	public void OnEquipCall(ShopItem itemtype)
	{
		AheadBuff aheadBuff = (AheadBuff)itemtype;
		if (!csPlayerData.EquipedBufflistInData.Contains(aheadBuff))
		{
			bool flag = false;
			if (aheadBuff == AheadBuff.RushS || aheadBuff == AheadBuff.RushM || aheadBuff == AheadBuff.RushB)
			{
				if (aheadBuff != AheadBuff.RushS && csPlayerData.EquipedBufflistInData.Contains(AheadBuff.RushS))
				{
					flag = true;
					PropShopItemList.Find((csItemInPropShop x) => x.m_ItemType == ShopItem.Item_001_RushS).SetToEquipState(isE: false);
					csPlayerData.UnPackAheadBuff(AheadBuff.RushS);
				}
				if (aheadBuff != AheadBuff.RushM && csPlayerData.EquipedBufflistInData.Contains(AheadBuff.RushM))
				{
					flag = true;
					PropShopItemList.Find((csItemInPropShop x) => x.m_ItemType == ShopItem.Item_002_RushM).SetToEquipState(isE: false);
					csPlayerData.UnPackAheadBuff(AheadBuff.RushM);
				}
				if (aheadBuff != AheadBuff.RushB && csPlayerData.EquipedBufflistInData.Contains(AheadBuff.RushB))
				{
					flag = true;
					PropShopItemList.Find((csItemInPropShop x) => x.m_ItemType == ShopItem.Item_003_RushB).SetToEquipState(isE: false);
					csPlayerData.UnPackAheadBuff(AheadBuff.RushB);
				}
			}
			if (aheadBuff == AheadBuff.ShieldS || aheadBuff == AheadBuff.ShieldM || aheadBuff == AheadBuff.ShieldB)
			{
				if (aheadBuff != AheadBuff.ShieldS && csPlayerData.EquipedBufflistInData.Contains(AheadBuff.ShieldS))
				{
					flag = true;
					PropShopItemList.Find((csItemInPropShop x) => x.m_ItemType == ShopItem.Item_004_ShieldS).SetToEquipState(isE: false);
					csPlayerData.UnPackAheadBuff(AheadBuff.ShieldS);
				}
				if (aheadBuff != AheadBuff.ShieldM && csPlayerData.EquipedBufflistInData.Contains(AheadBuff.ShieldM))
				{
					flag = true;
					PropShopItemList.Find((csItemInPropShop x) => x.m_ItemType == ShopItem.Item_005_ShieldM).SetToEquipState(isE: false);
					csPlayerData.UnPackAheadBuff(AheadBuff.ShieldM);
				}
				if (aheadBuff != AheadBuff.ShieldB && csPlayerData.EquipedBufflistInData.Contains(AheadBuff.ShieldB))
				{
					flag = true;
					PropShopItemList.Find((csItemInPropShop x) => x.m_ItemType == ShopItem.Item_006_ShieldB).SetToEquipState(isE: false);
					csPlayerData.UnPackAheadBuff(AheadBuff.ShieldB);
				}
			}
			if (aheadBuff == AheadBuff.GoldBuffS || aheadBuff == AheadBuff.GoldBuffM || aheadBuff == AheadBuff.GoldBuffB)
			{
				if (aheadBuff != AheadBuff.GoldBuffS && csPlayerData.EquipedBufflistInData.Contains(AheadBuff.GoldBuffS))
				{
					flag = true;
					PropShopItemList.Find((csItemInPropShop x) => x.m_ItemType == ShopItem.Item_008_GoldBuffS).SetToEquipState(isE: false);
					csPlayerData.UnPackAheadBuff(AheadBuff.GoldBuffS);
				}
				if (aheadBuff != AheadBuff.GoldBuffM && csPlayerData.EquipedBufflistInData.Contains(AheadBuff.GoldBuffM))
				{
					flag = true;
					PropShopItemList.Find((csItemInPropShop x) => x.m_ItemType == ShopItem.Item_009_GoldBuffM).SetToEquipState(isE: false);
					csPlayerData.UnPackAheadBuff(AheadBuff.GoldBuffM);
				}
				if (aheadBuff != AheadBuff.GoldBuffB && csPlayerData.EquipedBufflistInData.Contains(AheadBuff.GoldBuffB))
				{
					flag = true;
					PropShopItemList.Find((csItemInPropShop x) => x.m_ItemType == ShopItem.Item_010_GoldBuffB).SetToEquipState(isE: false);
					csPlayerData.UnPackAheadBuff(AheadBuff.GoldBuffB);
				}
			}
			if (aheadBuff == AheadBuff.ScoreBuffS || aheadBuff == AheadBuff.ScoreBuffM || aheadBuff == AheadBuff.ScoreBuffB)
			{
				if (aheadBuff != AheadBuff.ScoreBuffS && csPlayerData.EquipedBufflistInData.Contains(AheadBuff.ScoreBuffS))
				{
					flag = true;
					PropShopItemList.Find((csItemInPropShop x) => x.m_ItemType == ShopItem.Item_011_ScoreBuffS).SetToEquipState(isE: false);
					csPlayerData.UnPackAheadBuff(AheadBuff.ScoreBuffS);
				}
				if (aheadBuff != AheadBuff.ScoreBuffM && csPlayerData.EquipedBufflistInData.Contains(AheadBuff.ScoreBuffM))
				{
					flag = true;
					PropShopItemList.Find((csItemInPropShop x) => x.m_ItemType == ShopItem.Item_012_ScoreBuffM).SetToEquipState(isE: false);
					csPlayerData.UnPackAheadBuff(AheadBuff.ScoreBuffM);
				}
				if (aheadBuff != AheadBuff.ScoreBuffB && csPlayerData.EquipedBufflistInData.Contains(AheadBuff.ScoreBuffB))
				{
					flag = true;
					PropShopItemList.Find((csItemInPropShop x) => x.m_ItemType == ShopItem.Item_013_ScoreBuffB).SetToEquipState(isE: false);
					csPlayerData.UnPackAheadBuff(AheadBuff.ScoreBuffB);
				}
			}
			if (csPlayerData.EquipedBufflistInData.Count >= 3 && !flag)
			{
				csMainMenuCanvas.instance.PopHintM.ShowHint(csLocalizationManager.Instance.GetLocalText("PopHint04"));
				return;
			}
			if (csPlayerData.BuffDataDic[aheadBuff] > 0)
			{
				PropShopItemList.Find((csItemInPropShop x) => x.m_ItemType == itemtype).SetToEquipState(isE: true);
				csPlayerData.PackAheadBuff(aheadBuff);
			}
		}
		else
		{
			if (csPlayerData.BuffDataDic[aheadBuff] > 0)
			{
				PropShopItemList.Find((csItemInPropShop x) => x.m_ItemType == itemtype).SetToEquipState(isE: false);
			}
			csPlayerData.UnPackAheadBuff(aheadBuff);
		}
		csPlayerData.SaveEquipBuffList();
	}

	public override void Show(UnityAction act, string msg = "")
	{
		base.Show(act);
		ReFreshPropShop();
		ReFreshCoinShop();
		SetToCol(curShopColType);
		if (msg == "PropShop")
		{
			SetToCol(ItemShopColType.PropShop);
		}
		if (msg == "CoinShop")
		{
			SetToCol(ItemShopColType.CoinShop);
		}
		if (msg == "GemShop")
		{
			SetToCol(ItemShopColType.GemShop);
		}
		RefreshCoin();
	}

	public void RefreshCoin()
	{
		CoinText.text = csPlayerData.PlayerCoin.ToString();
		GemsText.text = csPlayerData.PlayerDiamond.ToString();
	}

	public void RefreshCoinAfterPurchase(int state = 0)
	{
		switch (state)
		{
		case 0:
			coinLabelAnim.DORewindAndPlayNext();
			GemLabelAnim.DORewindAndPlayNext();
			break;
		case 1:
			coinLabelAnim.DORewindAndPlayNext();
			break;
		case 2:
			GemLabelAnim.DORewindAndPlayNext();
			break;
		}
		RefreshCoin();
	}

	private void ReFreshPropShop()
	{
		foreach (csItemInPropShop propShopItem in PropShopItemList)
		{
			propShopItem.InitStatus(csPlayerData.EquipedBufflistInData.Contains((AheadBuff)propShopItem.m_ItemType), csPlayerData.BuffDataDic[(AheadBuff)propShopItem.m_ItemType]);
		}
	}

	private void ReFreshCoinShop()
	{
		foreach (csItemInPropShop coinShopItem in CoinShopItemList)
		{
			coinShopItem.InitStatus(isE: false, -1);
		}
	}

	public void SetToColBtn(int col)
	{
		SetToCol((ItemShopColType)col);
	}

	public void SetToCol(ItemShopColType cType)
	{
		if (cType != ItemShopColType.GemShop)
		{
			curShopColType = cType;
			PropContainer.SetActive(value: false);
			CoinContainer.SetActive(value: false);
			GemContainer.SetActive(value: false);
			PropColInShop.SetSelect(isSelect: false);
			CoinColInShop.SetSelect(isSelect: false);
			GemColInShop.SetSelect(isSelect: false);
			switch (cType)
			{
			case ItemShopColType.PropShop:
				PropContainer.SetActive(value: true);
				PropColInShop.SetSelect(isSelect: true);
				break;
			case ItemShopColType.CoinShop:
				CoinContainer.SetActive(value: true);
				CoinColInShop.SetSelect(isSelect: true);
				break;
			case ItemShopColType.GemShop:
				GemContainer.SetActive(value: true);
				GemColInShop.SetSelect(isSelect: true);
				break;
			}
		}
	}

	public void BackToMainBtn()
	{
		csMainMenuCanvas.instance.OpenMenu(MainMenuType.MainMenu);
		csMainMenuCanvas.instance.BackFromShopAction?.Invoke();
		csMainMenuCanvas.instance.BackFromShopAction = null;
	}
}
public class csPopHint : MonoBehaviour
{
	public CanvasGroup CGroup;

	public TextMeshProUGUI HintTxt;

	private Tweener tweener1;

	private Tweener tweener2;

	private void Awake()
	{
		CGroup.alpha = 0f;
	}

	public void ShowHint(string hint)
	{
		csLocalizationManager.Instance.CheckTextFontType(HintTxt);
		HintTxt.text = hint;
		CGroup.alpha = 1f;
		if (tweener1 != null && !tweener1.IsComplete())
		{
			tweener1.Kill();
		}
		if (tweener2 != null && !tweener2.IsComplete())
		{
			tweener2.Kill();
		}
		tweener1 = CGroup.DOFade(1f, 2f).OnComplete(delegate
		{
			tweener2 = CGroup.DOFade(0f, 1f);
		});
	}
}
public class csTweenAnimPlayer : MonoBehaviour
{
	public DOTweenAnimation AnimIdle;

	public DOTweenAnimation AnimOnOpen;
}
public class ControllerPosHint : MenuScreen
{
	public Transform ControllerT;

	public Image RedL;

	public Image RedR;

	public Image GreenL;

	public Image GreenR;

	public Sprite RedSpriteN;

	public Sprite RedSpriteS;

	private bool TriggerLeft;

	private bool TriggerRight;

	public Image ControlerImg;

	public Sprite ControllerGo;

	public Sprite ControllerGear;

	protected override void Awake()
	{
		base.Awake();
		if (csGameSettings.Channel == ChannelType.OculusGO)
		{
			switch (OVRPlugin.GetSystemHeadsetType())
			{
			case OVRPlugin.SystemHeadset.Oculus_Quest:
				ControlerImg.overrideSprite = ControllerGo;
				break;
			case OVRPlugin.SystemHeadset.Rift_CV1:
				ControlerImg.overrideSprite = ControllerGo;
				break;
			case OVRPlugin.SystemHeadset.Rift_S:
				ControlerImg.overrideSprite = ControllerGo;
				break;
			default:
				ControlerImg.overrideSprite = ControllerGear;
				break;
			}
		}
	}

	public void SetHandPos(float percent)
	{
		percent = Mathf.Clamp(percent, -1f, 1f);
		float num = percent * 320f;
		ControllerT.transform.localPosition = new Vector3(num, 0f, 0f);
		if (num < -270f && !TriggerLeft)
		{
			TriggerLeft = true;
			if (base.gameObject.activeSelf)
			{
				StartCoroutine(StartPlause());
			}
			RedL.overrideSprite = RedSpriteS;
		}
		if (num >= -270f && TriggerLeft)
		{
			TriggerLeft = false;
			RedL.overrideSprite = RedSpriteN;
		}
		if (num > 270f && !TriggerRight)
		{
			TriggerRight = true;
			if (base.gameObject.activeSelf)
			{
				StartCoroutine(StartPlause());
			}
			RedR.overrideSprite = RedSpriteS;
		}
		if (num <= 270f && TriggerRight)
		{
			TriggerRight = false;
			RedR.overrideSprite = RedSpriteN;
		}
	}

	public void SetUIState(int state)
	{
		switch (state)
		{
		case 0:
			GreenL.enabled = false;
			GreenR.enabled = false;
			break;
		case 1:
			GreenL.enabled = true;
			GreenR.enabled = false;
			break;
		case 2:
			GreenL.enabled = false;
			GreenR.enabled = true;
			break;
		}
	}

	private void OnEnable()
	{
		if (TriggerLeft || TriggerRight)
		{
			StartCoroutine(StartPlause());
		}
	}

	private IEnumerator StartPlause()
	{
		float paulsetime = 0.3f;
		float timer = 0f;
		while (TriggerLeft || TriggerRight)
		{
			if (timer <= 0f)
			{
				timer = paulsetime;
				if (csPlayerData.VibrationSwitch)
				{
					if (csGameSettings.IsLeftMove)
					{
						csControllerForSteamVR.TriggerHapticPulse_OC(isL: true, 1500);
					}
					else
					{
						csControllerForSteamVR.TriggerHapticPulse_OC(isL: false, 1500);
					}
				}
			}
			timer -= Time.deltaTime;
			yield return null;
		}
	}
}
public class CountDownScreen : MenuScreen
{
	public TextMeshProUGUI CountDownTxt;

	public void DOCountDown(int CDTime, UnityAction OnCDDoneAct)
	{
		CountDownTxt.text = CDTime.ToString();
		SoundManager.PlaySfx("CountDown");
		StartCoroutine(DoCountDown(CDTime, OnCDDoneAct));
	}

	private IEnumerator DoCountDown(int t, UnityAction OnCDDoneAct)
	{
		while (t >= 0)
		{
			yield return new WaitForSecondsRealtime(1f);
			t--;
			if (t > 0)
			{
				SoundManager.PlaySfx("CountDown");
				CountDownTxt.text = t.ToString();
			}
			else if (t == 0)
			{
				SoundManager.PlaySfx("RaceStart");
				CountDownTxt.text = "GO";
			}
		}
		OnCDDoneAct?.Invoke();
		Hide(0.3f);
	}
}
public class csHeartController : MonoBehaviour
{
	public Transform thisT;

	public GameObject thisG;

	public Image ValueImg;

	private float DistanceGap = 180f;

	public void InitPos(int index, int MaxHeart)
	{
		float num = (float)(-(MaxHeart - 1)) * DistanceGap / 2f;
		thisT.transform.localPosition = new Vector3(num + (float)index * DistanceGap, 0f, 0f);
	}

	public void SetValue(bool isOn)
	{
		ValueImg.enabled = isOn;
	}
}
public class csHUDBuffHint : MonoBehaviour
{
	public HUD HudManager;

	public PreObjectType buffType;

	public GameObject thisG;

	public Transform thisT;

	public Image SliderImg;

	public bool BuffIsOn;

	public GameObject BounsParticle;

	public TextMeshProUGUI PerTxt;

	private float OriTime;

	private float buffTimer;

	public void SetBuffOn(bool isOn, float time, bool withBouns = false)
	{
		if (isOn)
		{
			if (!thisG.activeSelf)
			{
				thisG.SetActive(value: true);
			}
			OriTime = (buffTimer = time);
			SliderImg.fillAmount = 1f;
			if (!BuffIsOn)
			{
				BuffIsOn = true;
				csLocalizationManager.Instance.StartCoroutine(BuffCountDown());
			}
			if (withBouns)
			{
				BounsParticle.SetActive(value: true);
			}
		}
		else if (thisG.activeSelf)
		{
			thisG.SetActive(value: false);
		}
	}

	public void ClearBuff()
	{
		BuffIsOn = false;
		thisG.SetActive(value: false);
	}

	public void SetBuffParent(Transform parentT)
	{
		thisT.SetParent(parentT);
		Transform obj = thisT;
		Vector3 localPosition = (thisT.localEulerAngles = Vector3.zero);
		obj.localPosition = localPosition;
	}

	private IEnumerator BuffCountDown()
	{
		while (buffTimer > 0f)
		{
			yield return null;
			buffTimer -= Time.deltaTime;
			float num = buffTimer / OriTime;
			SliderImg.fillAmount = Mathf.Lerp(0f, 1f, num);
			PerTxt.text = (int)(num * 100f) + "%";
		}
		HudManager.OnBuffEnd(buffType);
	}
}
public class csHUDSkillHint : MonoBehaviour
{
	public HUD HudManager;

	public HorseSkill skillType;

	public GameObject thisG;

	public Transform thisT;

	public Image FillImg;

	public Image BanSkillImg;

	public Text PerTxt;

	public GameObject TriggerHintO;

	public Animator SilenceHint;

	private float OriTime;

	private float buffTimer;

	private Coroutine SkillCDCor;

	private Coroutine SkillEffectCor;

	public void SetSkillHintPos(Transform t, float time, bool ShowHint)
	{
		thisT.SetParent(t);
		Transform obj = thisT;
		Vector3 localPosition = (thisT.localEulerAngles = Vector3.zero);
		obj.localPosition = localPosition;
		thisG.SetActive(value: true);
		buffTimer = 0f;
		OriTime = time;
		TriggerHintO.SetActive(ShowHint);
		if (ShowHint)
		{
			StartCoroutine(SelfHintOff());
		}
	}

	public void RefreshSkillHint(bool ShowHint)
	{
		if (!csGameSettings.IsSkillTeached)
		{
			csGameSettings.IsSkillTeached = true;
			TriggerHintO.SetActive(ShowHint);
			if (ShowHint)
			{
				StartCoroutine(SelfHintOff());
			}
		}
	}

	private IEnumerator SelfHintOff()
	{
		yield return new WaitForSeconds(120f);
		TriggerHintO.SetActive(value: false);
	}

	public void SetSkillOff()
	{
		FillImg.fillAmount = 0f;
		PerTxt.text = "0%";
		TriggerHintO.SetActive(value: false);
	}

	public void DoSilenceSkill(bool isSilence)
	{
		if ((bool)BanSkillImg)
		{
			BanSkillImg.enabled = isSilence;
		}
	}

	public void OnSilenceSkillCall()
	{
		if ((bool)SilenceHint)
		{
			SilenceHint.Play("SilenceIconAnimation");
		}
	}

	public void StartSkillCD()
	{
		if (SkillEffectCor != null)
		{
			StopCoroutine(SkillEffectCor);
		}
		SkillCDCor = csLocalizationManager.Instance.StartCoroutine(SkillCountDown());
	}

	public void StartSkillEffecting(float aftime)
	{
		SkillEffectCor = csLocalizationManager.Instance.StartCoroutine(SkillCEffecting(aftime));
	}

	public void ClearSkill()
	{
		if (SkillCDCor != null)
		{
			StopCoroutine(SkillCDCor);
		}
		if (SkillEffectCor != null)
		{
			StopCoroutine(SkillEffectCor);
		}
		FillImg.fillAmount = 1f;
		PerTxt.text = "100%";
	}

	public void SetBuffParent(Transform parentT)
	{
		thisT.SetParent(parentT);
		Transform obj = thisT;
		Vector3 localPosition = (thisT.localEulerAngles = Vector3.zero);
		obj.localPosition = localPosition;
	}

	private IEnumerator SkillCountDown()
	{
		buffTimer = 0f;
		while (buffTimer < OriTime)
		{
			yield return null;
			buffTimer += Time.deltaTime;
			float num = buffTimer / OriTime;
			FillImg.fillAmount = Mathf.Lerp(0f, 1f, num);
			PerTxt.text = (int)(num * 100f) + "%";
		}
	}

	private IEnumerator SkillCEffecting(float afTime)
	{
		float Effecttime = afTime;
		FillImg.fillAmount = 1f;
		while (Effecttime > 0f)
		{
			yield return null;
			Effecttime -= Time.deltaTime;
			FillImg.fillAmount = Effecttime / afTime;
			PerTxt.text = (int)Effecttime + "s";
		}
	}
}
public class csMissionInPause : MonoBehaviour
{
	public GameObject thisG;

	public TextMeshProUGUI MissionText1;

	public TextMeshProUGUI MissionText2;

	public TextMeshProUGUI MissionText3;

	public Image MissionStar1;

	public Image MissionStar2;

	public Image MissionStar3;

	private bool MissionIsSet;

	private void Awake()
	{
		thisG.SetActive(value: false);
	}

	public void ShowMissions(bool isShow)
	{
		thisG.SetActive(isShow);
		if (isShow)
		{
			if (!MissionIsSet)
			{
				MissionIsSet = true;
				csLocalizationManager.Instance.CheckTextFontType(MissionText1);
				csLocalizationManager.Instance.CheckTextFontType(MissionText2);
				csLocalizationManager.Instance.CheckTextFontType(MissionText3);
				MissionText1.text = csLevelData.instance.GetDescriptionByMission(GameManager.instance.m_InGameMissionData.InGameMissionDataList[0]);
				MissionText2.text = csLevelData.instance.GetDescriptionByMission(GameManager.instance.m_InGameMissionData.InGameMissionDataList[1]);
				MissionText3.text = csLevelData.instance.GetDescriptionByMission(GameManager.instance.m_InGameMissionData.InGameMissionDataList[2]);
			}
			RefreshMissionStar();
		}
	}

	public void RefreshMissionStar()
	{
		MissionStar1.enabled = GameManager.instance.m_InGameMissionData.JudgeMissionComplete(0);
		MissionStar2.enabled = GameManager.instance.m_InGameMissionData.JudgeMissionComplete(1);
		MissionStar3.enabled = GameManager.instance.m_InGameMissionData.JudgeMissionComplete(2);
	}
}
public class csResultBoxAward : MonoBehaviour
{
	public GameObject thisG;

	public GameObject MainUI;

	public Transform thisT;

	public List<csLevelAwardPanelIcon> LevelAwardList = new List<csLevelAwardPanelIcon>();

	public CanvasGroup thisCG;

	public Image BoxImg;

	public Sprite BoxClosed_Rnd;

	public Sprite BoxOpend_Rnd;

	public Sprite BoxClosed_Star;

	public Sprite BoxOpend_Star;

	public Sprite AddLifeS;

	public Sprite GoldBuffS;

	public Sprite GoldBuffB;

	public Sprite RushS;

	public Sprite RushB;

	public Sprite ScoreBuffS;

	public Sprite ScoreBuffB;

	public Sprite ShieldS;

	public Sprite ShieldB;

	public Sprite S_Award_Money;

	public Sprite S_Award_Gem;

	private List<ResultAwardData> curAwardData = new List<ResultAwardData>();

	public bool IsAwardAdded;

	public bool IsStartAward;

	public Button ConfirmBtn;

	public csResultLevelStarProgress LevelStarP;

	private bool IsShowStarBox;

	public void Hide()
	{
		thisG.SetActive(value: false);
	}

	public void HideMain()
	{
		MainUI.SetActive(value: false);
	}

	public void ShowMain()
	{
		MainUI.SetActive(value: true);
	}

	public void Show(bool withStar, bool isStarBox)
	{
		LevelStarP.gameObject.SetActive(withStar);
		thisG.SetActive(value: true);
		IsShowStarBox = isStarBox;
		BoxImg.overrideSprite = (IsShowStarBox ? BoxClosed_Star : BoxClosed_Rnd);
		IsAwardAdded = false;
		ConfirmBtn.gameObject.SetActive(value: true);
		foreach (csLevelAwardPanelIcon levelAward in LevelAwardList)
		{
			levelAward.SetAwardOn(isOn: false);
		}
	}

	public void SetAwards(List<ResultAwardData> AwardData, bool isStarAward)
	{
		IsStartAward = isStarAward;
		curAwardData = AwardData;
		for (int i = 0; i < AwardData.Count; i++)
		{
			if (AwardData[i].CoinNum > 0)
			{
				LevelAwardList[i].SetAwardMoney(AwardData[i].CoinNum, S_Award_Money, csLocalizationManager.Instance.GetLocalText("PropShopMenu02"), DefaultOpen: false);
				continue;
			}
			if (AwardData[i].GemNum > 0)
			{
				LevelAwardList[i].SetAwardGem(AwardData[i].GemNum, S_Award_Gem, csLocalizationManager.Instance.GetLocalText("PropShopMenu03"), DefaultOpen: false);
				continue;
			}
			string text = "";
			Sprite s;
			switch (AwardData[i].AwardBuff)
			{
			default:
				s = RushS;
				text = csLocalizationManager.Instance.GetLocalText("Item_A_001");
				break;
			case AheadBuff.AddLifeS:
				s = AddLifeS;
				text = csLocalizationManager.Instance.GetLocalText("Item_A_005");
				break;
			case AheadBuff.GoldBuffS:
				s = GoldBuffS;
				text = csLocalizationManager.Instance.GetLocalText("Item_A_006");
				break;
			case AheadBuff.GoldBuffB:
				s = GoldBuffB;
				text = csLocalizationManager.Instance.GetLocalText("Item_A_007");
				break;
			case AheadBuff.RushS:
				s = RushS;
				text = csLocalizationManager.Instance.GetLocalText("Item_A_001");
				break;
			case AheadBuff.RushB:
				s = RushB;
				text = csLocalizationManager.Instance.GetLocalText("Item_A_002");
				break;
			case AheadBuff.ScoreBuffS:
				s = ScoreBuffS;
				text = csLocalizationManager.Instance.GetLocalText("Item_A_008");
				break;
			case AheadBuff.ScoreBuffB:
				s = ScoreBuffB;
				text = csLocalizationManager.Instance.GetLocalText("Item_A_009");
				break;
			case AheadBuff.ShieldS:
				s = ShieldS;
				text = csLocalizationManager.Instance.GetLocalText("Item_A_003");
				break;
			case AheadBuff.ShieldB:
				s = ShieldB;
				text = csLocalizationManager.Instance.GetLocalText("Item_A_004");
				break;
			}
			LevelAwardList[i].SetAwardProp(AwardData[i].BuffNum, s, text, DefaultOpen: false);
		}
		if (!IsStartAward)
		{
			return;
		}
		for (int j = 0; j < curAwardData.Count; j++)
		{
			if (curAwardData[j].CoinNum > 0)
			{
				csPlayerData.PlayerCoin += curAwardData[j].CoinNum;
			}
			else if (curAwardData[j].GemNum > 0)
			{
				csPlayerData.PlayerDiamond += curAwardData[j].GemNum;
			}
			else
			{
				csPlayerData.OnGetAheadBuff(curAwardData[j].AwardBuff, curAwardData[j].BuffNum);
			}
		}
		csPlayerData.SetCurAwardStarNum(csGameData.Instance.GetClosestStarAwardStarNum(csPlayerData.GetStarsNum()));
	}

	public void OnAwardConfirm()
	{
		if (IsAwardAdded)
		{
			return;
		}
		BoxImg.overrideSprite = (IsShowStarBox ? BoxOpend_Star : BoxOpend_Rnd);
		ConfirmBtn.gameObject.SetActive(value: false);
		IsAwardAdded = true;
		if (!IsStartAward)
		{
			for (int i = 0; i < curAwardData.Count; i++)
			{
				LevelAwardList[i].SetAwardOn(isOn: true);
				if (curAwardData[i].CoinNum > 0)
				{
					csPlayerData.PlayerCoin += curAwardData[i].CoinNum;
				}
				else if (curAwardData[i].GemNum > 0)
				{
					csPlayerData.PlayerDiamond += curAwardData[i].GemNum;
				}
				else
				{
					csPlayerData.OnGetAheadBuff(curAwardData[i].AwardBuff, curAwardData[i].BuffNum);
				}
			}
		}
		if (IsStartAward)
		{
			LevelStarP.Nodes[1].SetStateOnly(-1);
			for (int j = 0; j < curAwardData.Count; j++)
			{
				LevelAwardList[j].SetAwardOn(isOn: true);
			}
		}
	}
}
public class csResultLevelStarProgress : MonoBehaviour
{
	public List<csResultProgressNode> Nodes = new List<csResultProgressNode>();

	public Image ProgressValueImg1;

	public Image ProgressValueImg2;

	public float MinProgressWid = 473f;

	public float MinProgressMax = 473f;

	public Text StarNumTxt;

	public void SetStarProgress(int centerStarNum)
	{
		ProgressValueImg1.rectTransform.sizeDelta = new Vector2(0f, 44.5f);
		ProgressValueImg2.rectTransform.sizeDelta = new Vector2(0f, 44.5f);
		if (csGameData.Instance.GetClosestStarAwardIndex(centerStarNum) == -1 && csPlayerData.GetCurAwardStarNum() < csGameData.Instance.GetStarAwardNumList(0))
		{
			Nodes[0].SetState(-5, 0);
			if (centerStarNum >= csGameData.Instance.GetStarAwardNumList(0))
			{
				Nodes[1].SetState(0, csGameData.Instance.GetStarAwardNumList(0));
			}
			else
			{
				Nodes[1].SetState(1, csGameData.Instance.GetStarAwardNumList(0));
			}
			Nodes[2].SetState(1, csGameData.Instance.GetStarAwardNumList(1));
			SetBarProgress((float)centerStarNum / (float)csGameData.Instance.GetStarAwardNumList(0));
		}
		else
		{
			int closestStarAwardIndex = csGameData.Instance.GetClosestStarAwardIndex(centerStarNum);
			closestStarAwardIndex = ((closestStarAwardIndex >= 0) ? closestStarAwardIndex : 0);
			if (closestStarAwardIndex + 1 >= csGameData.Instance.StarAwardDataInfo.Count)
			{
				Nodes[0].SetState(-1, csGameData.Instance.GetStarAwardNumList(closestStarAwardIndex - 2));
				Nodes[1].SetState(-1, csGameData.Instance.GetStarAwardNumList(closestStarAwardIndex - 1));
				Nodes[2].SetState(-1, csGameData.Instance.GetStarAwardNumList(closestStarAwardIndex));
				SetBarProgress(2f);
			}
			else if (closestStarAwardIndex + 2 >= csGameData.Instance.StarAwardDataInfo.Count)
			{
				Nodes[0].SetState(-1, csGameData.Instance.GetStarAwardNumList(closestStarAwardIndex - 1));
				Nodes[1].SetState(-1, csGameData.Instance.GetStarAwardNumList(closestStarAwardIndex));
				int state = -1;
				if (csPlayerData.GetStarsNum() > csGameData.Instance.GetStarAwardNumList(closestStarAwardIndex + 1))
				{
					state = 0;
				}
				if (csPlayerData.GetStarsNum() < csGameData.Instance.GetStarAwardNumList(closestStarAwardIndex + 1))
				{
					state = 1;
				}
				if (csGameData.Instance.GetStarAwardNumList(closestStarAwardIndex + 1) == csPlayerData.GetCurAwardStarNum())
				{
					state = -1;
				}
				Nodes[2].SetState(state, csGameData.Instance.GetStarAwardNumList(closestStarAwardIndex + 1));
			}
			else if (closestStarAwardIndex == 0 && csGameData.Instance.GetClosestStarAwardStarNum(csPlayerData.GetStarsNum()) > csPlayerData.GetCurAwardStarNum())
			{
				Nodes[0].SetState(-5, 0);
				Nodes[1].SetState(0, csGameData.Instance.GetStarAwardNumList(closestStarAwardIndex));
				Nodes[2].SetState(1, csGameData.Instance.GetStarAwardNumList(closestStarAwardIndex + 1));
				SetBarProgress((float)centerStarNum / (float)csGameData.Instance.GetStarAwardNumList(closestStarAwardIndex));
			}
			else if (csGameData.Instance.GetClosestStarAwardStarNum(csPlayerData.GetStarsNum()) > csPlayerData.GetCurAwardStarNum())
			{
				Nodes[0].SetState(-1, csGameData.Instance.GetStarAwardNumList(closestStarAwardIndex - 1));
				Nodes[1].SetState(0, csGameData.Instance.GetStarAwardNumList(closestStarAwardIndex));
				Nodes[2].SetState(1, csGameData.Instance.GetStarAwardNumList(closestStarAwardIndex + 1));
				SetBarProgress((float)(centerStarNum - csGameData.Instance.GetStarAwardNumList(closestStarAwardIndex - 1)) / (float)(csGameData.Instance.GetStarAwardNumList(closestStarAwardIndex) - csGameData.Instance.GetStarAwardNumList(closestStarAwardIndex - 1)));
			}
			else
			{
				Nodes[0].SetState(-1, csGameData.Instance.GetStarAwardNumList(closestStarAwardIndex));
				Nodes[1].SetState(1, csGameData.Instance.GetStarAwardNumList(closestStarAwardIndex + 1));
				Nodes[2].SetState(1, csGameData.Instance.GetStarAwardNumList(closestStarAwardIndex + 2));
				SetBarProgress((float)(centerStarNum - csGameData.Instance.GetStarAwardNumList(closestStarAwardIndex)) / (float)(csGameData.Instance.GetStarAwardNumList(closestStarAwardIndex + 1) - csGameData.Instance.GetStarAwardNumList(closestStarAwardIndex)));
			}
		}
		StarNumTxt.text = "x" + centerStarNum;
	}

	private void SetBarProgress(float percent)
	{
		if (percent > 1f)
		{
			ProgressValueImg2.rectTransform.sizeDelta = new Vector2(473f * (percent - 1f), 44.5f);
		}
		ProgressValueImg1.rectTransform.sizeDelta = new Vector2(473f * percent, 44.5f);
	}
}
public class csResultProgressNode : MonoBehaviour
{
	public TextMeshProUGUI StarNumTxt;

	public GameObject Awarded;

	public GameObject CanAward;

	public GameObject NoAward;

	public void SetState(int state, int starNum)
	{
		base.gameObject.SetActive(value: true);
		Awarded.SetActive(value: false);
		CanAward.SetActive(value: false);
		NoAward.SetActive(value: false);
		StarNumTxt.text = "x" + starNum;
		switch (state)
		{
		case -1:
			Awarded.SetActive(value: true);
			break;
		case 0:
			CanAward.SetActive(value: true);
			break;
		case 1:
			NoAward.SetActive(value: true);
			break;
		case -5:
			base.gameObject.SetActive(value: false);
			break;
		case -4:
		case -3:
		case -2:
			break;
		}
	}

	public void SetStateOnly(int state)
	{
		base.gameObject.SetActive(value: true);
		Awarded.SetActive(value: false);
		CanAward.SetActive(value: false);
		NoAward.SetActive(value: false);
		switch (state)
		{
		case -1:
			Awarded.SetActive(value: true);
			break;
		case 0:
			CanAward.SetActive(value: true);
			break;
		case 1:
			NoAward.SetActive(value: true);
			break;
		case -5:
			base.gameObject.SetActive(value: false);
			break;
		case -4:
		case -3:
		case -2:
			break;
		}
	}
}
public class csScoreHint : MonoBehaviour
{
	protected CanvasGroup m_CGroup;

	public Text T_Line;

	public Transform thisT;

	public float flytimer = 1f;

	public bool isAnimating;

	private int index;

	public Color AddColor = Color.blue;

	public Color MinusColor = Color.red;

	private void Awake()
	{
		thisT = base.transform;
		m_CGroup = base.transform.GetChild(0).GetComponent<CanvasGroup>();
		m_CGroup.alpha = 0f;
	}

	public virtual void DoOnEnable()
	{
	}

	private void OnEnable()
	{
		DoOnEnable();
	}

	public virtual void DoAnimate(UnityAction animdowncallback, float addtime = 0f)
	{
		csLocalizationManager.Instance.StartCoroutine(DoAnimating(animdowncallback, addtime));
	}

	public void SpeedUp()
	{
		flytimer = 0.7f;
	}

	private IEnumerator DoAnimating(UnityAction animdowncallback, float addtime = 0f)
	{
		isAnimating = true;
		m_CGroup.transform.localScale = Vector3.zero;
		m_CGroup.transform.localPosition = Vector3.zero;
		m_CGroup.DOFade(1f, 0.3f);
		m_CGroup.transform.DOScale(1f, 0.2f).SetEase(Ease.OutBounce);
		GameManager.instance.ScoreHintIndex++;
		if (GameManager.instance.ScoreHintIndex > 6)
		{
			GameManager.instance.ScoreHintIndex = 0;
		}
		else
		{
			CancelInvoke("InvokeTime");
			Invoke("InvokeTime", 3f);
		}
		m_CGroup.transform.DOLocalMoveY(thisT.localPosition.y + 20f + 50f * (float)GameManager.instance.ScoreHintIndex, 0.3f);
		flytimer = 2f + addtime;
		yield return new WaitForSeconds(0.3f);
		while (flytimer > 0f)
		{
			yield return null;
			flytimer -= Time.deltaTime;
			m_CGroup.transform.Translate(Vector3.up * 0.06f * Time.deltaTime);
		}
		m_CGroup.DOFade(0f, 0.3f);
		yield return new WaitForSeconds(0.3f);
		isAnimating = false;
		GameManager.MenuSystem.HUD.ReturnHintObjectIntoPool(this, delay: false);
		animdowncallback();
	}

	private void InvokeTime()
	{
		GameManager.instance.ScoreHintIndex = 0;
	}

	public virtual void SetContent(bool isAdd, int Score)
	{
		if (isAdd)
		{
			T_Line.color = AddColor;
			T_Line.text = "+" + Score;
		}
		else
		{
			T_Line.color = MinusColor;
			T_Line.text = "-" + Score;
		}
	}
}
public class csSettingPanel : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
	}
}
public class MenuHandChoose : MenuScreen
{
	public Button[] InteractBtns;

	public void ChooseRidingHand(bool isLeft)
	{
		GameManager.Player.SetRopeHand(isLeft, withFade: true);
		GameManager.instance.OnHandChosen(isLeft);
	}

	public override void Show(float fade, TransitionDirection direction = TransitionDirection.Forward, DeerCat.SimpleTween.Callback callback = null)
	{
		base.Show(fade, direction, callback);
		Button[] interactBtns = InteractBtns;
		for (int i = 0; i < interactBtns.Length; i++)
		{
			interactBtns[i].interactable = true;
		}
	}

	public override void Hide(float fade, TransitionDirection direction = TransitionDirection.Back, DeerCat.SimpleTween.Callback callback = null)
	{
		base.Hide(fade, direction, callback);
		Button[] interactBtns = InteractBtns;
		for (int i = 0; i < interactBtns.Length; i++)
		{
			interactBtns[i].interactable = false;
		}
	}
}
public class PauseMenu : MenuScreen
{
	public csMissionInPause missionPanel;

	public Button[] InteractBtns;

	public void ResumeGame()
	{
		if (isBtnInteractable)
		{
			GameManager.instance.ResumeGame();
			SoundManager.PlaySfx("ButtonPress");
		}
	}

	public override void Show(float fade, TransitionDirection direction = TransitionDirection.Forward, DeerCat.SimpleTween.Callback callback = null)
	{
		base.Show(fade, direction, callback);
		missionPanel.ShowMissions(csGameSettings.CurrentGameMode == GameMode.LevelMode);
		Button[] interactBtns = InteractBtns;
		for (int i = 0; i < interactBtns.Length; i++)
		{
			interactBtns[i].interactable = true;
		}
	}

	public override void Hide(float fade, TransitionDirection direction = TransitionDirection.Back, DeerCat.SimpleTween.Callback callback = null)
	{
		base.Hide(fade, direction, callback);
		Button[] interactBtns = InteractBtns;
		for (int i = 0; i < interactBtns.Length; i++)
		{
			interactBtns[i].interactable = false;
		}
	}

	public void Restart()
	{
		GameManager.instance.RestartGameBtn();
	}

	public void ToSettings()
	{
		GameManager.instance.GotoSetting();
		SoundManager.PlaySfx("ButtonPress");
	}

	public void ToMainMenu()
	{
		GameManager.instance.BackToMainBtn();
	}
}
public class SettingsInGame : MenuScreen
{
	public csButtonGroup m_SwitchVibrationBtn_Group;

	public Image MusicSlider;

	public Image SoundSlider;

	public Image SensitivitySlider;

	private int MusicVolume;

	private int SoundVolume;

	private int SensitivityValue;

	private void OnEnable()
	{
		m_SwitchVibrationBtn_Group.OnSetIndex = OnSwitchVibrationBtn;
		m_SwitchVibrationBtn_Group.SetCurrntIndex((!csPlayerData.VibrationSwitch) ? 1 : 0);
		MusicVolume = csPlayerData.MusicVolume;
		SoundVolume = csPlayerData.SoundFXVolume;
		SensitivityValue = csPlayerData.Sensitivity;
		MusicSlider.fillAmount = (float)MusicVolume / 10f;
		SoundSlider.fillAmount = (float)SoundVolume / 10f;
		SensitivitySlider.fillAmount = (float)SensitivityValue / 10f;
	}

	private void OnSwitchVibrationBtn(int index)
	{
		SoundManager.PlaySfx("ButtonPress");
		csPlayerData.VibrationSwitch = index == 0;
	}

	public void ChangeMusicValue(bool isAdd)
	{
		if ((!isAdd || MusicVolume != 10) && (isAdd || MusicVolume != 0))
		{
			SoundManager.PlaySfx("ButtonPress");
			if (isAdd)
			{
				MusicVolume++;
			}
			else
			{
				MusicVolume--;
			}
			MusicSlider.fillAmount = (float)MusicVolume / 10f;
			csPlayerData.MusicVolume = MusicVolume;
			csPlayerData.VolumeChangeAct?.Invoke();
		}
	}

	public void ChangeSoundValue(bool isAdd)
	{
		if ((!isAdd || SoundVolume != 10) && (isAdd || SoundVolume != 0))
		{
			SoundManager.PlaySfx("ButtonPress");
			if (isAdd)
			{
				SoundVolume++;
			}
			else
			{
				SoundVolume--;
			}
			SoundSlider.fillAmount = (float)SoundVolume / 10f;
			csPlayerData.SoundFXVolume = SoundVolume;
			csPlayerData.VolumeChangeAct?.Invoke();
		}
	}

	public void ChangeSensitivityValue(bool isAdd)
	{
		if ((!isAdd || SensitivityValue != 10) && (isAdd || SensitivityValue != 0))
		{
			SoundManager.PlaySfx("ButtonPress");
			if (isAdd)
			{
				SensitivityValue++;
			}
			else
			{
				SensitivityValue--;
			}
			SensitivitySlider.fillAmount = (float)SensitivityValue / 10f;
			csPlayerData.Sensitivity = SensitivityValue;
		}
	}

	public void BackFromSetting()
	{
		SoundManager.PlaySfx("ButtonPress");
		GameManager.instance.BackFromSetting();
	}
}
public class TutorialChoose : MenuScreen
{
	public Button[] InteractBtns;

	public void ChooseNeedTutorial(bool isNeed)
	{
		GameManager.instance.OnTutorialChosenAndStart(isNeed);
	}

	public override void Show(float fade, TransitionDirection direction = TransitionDirection.Forward, DeerCat.SimpleTween.Callback callback = null)
	{
		base.Show(fade, direction, callback);
		Button[] interactBtns = InteractBtns;
		for (int i = 0; i < interactBtns.Length; i++)
		{
			interactBtns[i].interactable = true;
		}
	}

	public override void Hide(float fade, TransitionDirection direction = TransitionDirection.Back, DeerCat.SimpleTween.Callback callback = null)
	{
		base.Hide(fade, direction, callback);
		Button[] interactBtns = InteractBtns;
		for (int i = 0; i < interactBtns.Length; i++)
		{
			interactBtns[i].interactable = false;
		}
	}
}
public class TutorialHint : MenuScreen
{
	public TextMeshProUGUI HintTxt;

	public Image HandImg;

	public Image ArrowImg;

	public GameObject FinishObj;

	public Transform ImgRotator;

	public Sprite HandSpriteL;

	public Sprite HandSpriteR;

	public Image ControlerImg;

	public Sprite ControllerGo;

	public Sprite ControllerGear;

	public void SetHandSprite(bool isLeft)
	{
		if (csGameSettings.Channel == ChannelType.OculusGO)
		{
			switch (OVRPlugin.GetSystemHeadsetType())
			{
			case OVRPlugin.SystemHeadset.Oculus_Quest:
				ControlerImg.overrideSprite = ControllerGo;
				break;
			case OVRPlugin.SystemHeadset.Rift_CV1:
				ControlerImg.overrideSprite = ControllerGo;
				break;
			case OVRPlugin.SystemHeadset.Rift_S:
				ControlerImg.overrideSprite = ControllerGo;
				break;
			default:
				ControlerImg.overrideSprite = ControllerGear;
				break;
			}
		}
		HandImg.overrideSprite = (isLeft ? HandSpriteL : HandSpriteR);
	}

	public void SetArrow(bool NeedArrow, bool isLeft)
	{
		ArrowImg.enabled = NeedArrow;
		if (isLeft)
		{
			ImgRotator.transform.localEulerAngles = Vector3.zero;
		}
		else
		{
			ImgRotator.transform.localEulerAngles = new Vector3(0f, 180f, 0f);
		}
	}

	public void SetText(string txt, bool NeedHand)
	{
		ImgRotator.gameObject.SetActive(NeedHand);
		HandImg.enabled = NeedHand;
		if (NeedHand)
		{
			FinishObj.SetActive(value: false);
			HintTxt.transform.localPosition = new Vector3(0f, -318f, 0f);
		}
		else
		{
			HintTxt.transform.localPosition = new Vector3(0f, -318f, 0f);
			FinishObj.SetActive(value: true);
		}
		csLocalizationManager.Instance.CheckTextFontType(HintTxt);
		HintTxt.text = txt;
		HintTxt.text = HintTxt.text.Replace("//n", "/n");
	}
}
public class NpcPlayer : MonoBehaviour
{
	public Transform thisT;

	public Transform NPCRoot;

	public Transform HorsPosT;

	public CameraLookAheadNPC CamLookAhead;

	private bool isRotating;

	private bool RRotate = true;

	public float RotateSpeed = 20f;

	private void Update()
	{
		if (isRotating)
		{
			NPCRoot.Rotate(Vector3.forward, RotateSpeed * Time.deltaTime);
		}
	}

	public void TryRotate()
	{
		if (!isRotating)
		{
			isRotating = true;
			RRotate = UnityEngine.Random.Range(0, 100) > 50;
		}
	}

	public void StopRotate()
	{
		if (isRotating)
		{
			isRotating = false;
		}
	}
}
public class NpcPlayerAI : MonoBehaviour
{
	public NpcPlayer thisP;

	public float CheckDist = 20f;

	public Transform CheckPosT;

	private void Start()
	{
		StartCoroutine(PosZLerp());
	}

	private IEnumerator PosZLerp()
	{
		while (true)
		{
			float LerpTime = UnityEngine.Random.Range(3, 10);
			float ZPos = UnityEngine.Random.Range(5f, 35f);
			float startZ = thisP.thisT.position.z;
			float timer = LerpTime;
			while (timer > 0f)
			{
				yield return null;
				timer -= Time.deltaTime;
				thisP.thisT.position = new Vector3(thisP.thisT.position.x, thisP.thisT.position.y, Mathf.Lerp(ZPos, startZ, timer / LerpTime));
			}
		}
	}

	private void Update()
	{
		bool flag = false;
		_ = new Vector3[11];
		Vector3 vector = thisP.HorsPosT.position - thisP.NPCRoot.position + thisP.HorsPosT.position.z * Vector3.forward;
		if (Physics.SphereCast(vector - GameManager.Player.collisionRadius * Vector3.forward, GameManager.Player.collisionRadius, Vector3.forward, out var _, CheckDist + 2f * GameManager.Player.collisionRadius))
		{
			flag = true;
		}
		UnityEngine.Debug.DrawLine(vector, vector + Vector3.forward * (CheckDist + 2f * GameManager.Player.collisionRadius));
		if (flag)
		{
			thisP.TryRotate();
		}
		else
		{
			thisP.StopRotate();
		}
	}
}
public class csMovingTriangleTrigger : csPropBase
{
	public MovingTriangleRail ParentRail;

	public override void OnCollected()
	{
		if (GameManager.CurrentState == GameManager.GameState.Playing)
		{
			Apply();
			base.gameObject.SetActive(value: false);
			ParentRail.StartMoving();
		}
	}

	protected override void Apply()
	{
	}
}
public class csQuestionTunnel : MonoBehaviour
{
	public MeshRenderer CenterHintR;

	public csQuestionTunnelPassHint[] HintPasses;

	public Transform[] AwardTransT;

	public LevelBlock ParentBlock;

	public GameObject AwardCoinIniter;

	public Color[] CenterColors;

	private void Awake()
	{
		SetQuestion();
	}

	private void SetQuestion()
	{
		int num = UnityEngine.Random.Range(0, CenterColors.Length);
		CenterHintR.material.SetColor("_Color", CenterColors[num]);
		CenterHintR.material.SetColor("_EmissionColor", CenterColors[num]);
		int num2 = UnityEngine.Random.Range(0, HintPasses.Length);
		for (int i = 0; i < HintPasses.Length; i++)
		{
			int num3 = i + num2;
			if (num3 >= HintPasses.Length)
			{
				num3 -= HintPasses.Length;
			}
			HintPasses[num3].SetPassState(i, i == num);
		}
	}

	public void DoDudge(bool isCorrect, int Id)
	{
		if (isCorrect)
		{
			UnityEngine.Debug.LogError("奖励");
			switch (UnityEngine.Random.Range(0, 3))
			{
			case 0:
				AwardCoinIniter.transform.position = AwardTransT[Id].position;
				AwardCoinIniter.transform.rotation = AwardTransT[Id].rotation;
				InitProps();
				break;
			case 1:
				GameManager.Player.PlayGoldGet();
				GameManager.LevelManager.OnCoinGetOnlyCoin(UnityEngine.Random.Range(50, 101));
				break;
			case 2:
				GameManager.LevelManager.OnScoreGet(1000);
				break;
			}
		}
		else
		{
			UnityEngine.Debug.LogError("惩罚");
			switch (UnityEngine.Random.Range(0, 3))
			{
			case 1:
				GameManager.Player.ForceHPDrop();
				break;
			case 2:
				GameManager.LevelManager.OnScoreGet(-1000);
				break;
			case 0:
				break;
			}
		}
	}

	public void DestroyPropShowCase()
	{
		csPropIniter[] componentsInChildren = AwardCoinIniter.GetComponentsInChildren<csPropIniter>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			componentsInChildren[i].DestroyShowCase();
		}
	}

	public void InitProps()
	{
		AwardCoinIniter.SetActive(value: true);
		DestroyPropShowCase();
		csPropIniter[] componentsInChildren = AwardCoinIniter.GetComponentsInChildren<csPropIniter>();
		foreach (csPropIniter csPropIniter2 in componentsInChildren)
		{
			GameObject objectByType = Multi_csObjectPool.Instance.GetObjectByType(csPropIniter2.PropObjType, csPropIniter2.transform.position, csPropIniter2.transform.forward);
			objectByType.transform.SetParent(csPropIniter2.thisT);
			ParentBlock.PropsObjList.Add(objectByType);
			if (csPropIniter2.PropObjType == PreObjectType.GoldCoin)
			{
				ParentBlock.CoinTransList.Add(Multi_csObjectPool.Instance.GoldScriptByObj(objectByType));
			}
		}
	}
}
public class csQuestionTunnelPassHint : csPropBase
{
	public bool IsCorrectHint;

	public MeshRenderer PassHintR;

	public csQuestionTunnel ParentTunnel;

	public int HintID;

	public Color[] CenterColors;

	public void SetPassState(int PassIndex, bool isCorrect)
	{
		IsCorrectHint = isCorrect;
		PassHintR.material.SetColor("_Color", CenterColors[PassIndex]);
		PassHintR.material.SetColor("_EmissionColor", CenterColors[PassIndex]);
	}

	public override void OnCollected()
	{
		if (GameManager.CurrentState == GameManager.GameState.Playing)
		{
			Apply();
			base.gameObject.SetActive(value: false);
			ParentTunnel.DoDudge(IsCorrectHint, HintID);
		}
	}

	protected override void Apply()
	{
	}
}
public class csRandomDoor : MonoBehaviour
{
	public Transform DoorPosT;

	public Transform DoorLT;

	public Transform DoorRT;

	public float OpenTime = 1f;

	public float DoorWidth = 4f;

	public float LPos;

	public float MPos;

	public float RPos;

	public void StartDoor()
	{
		switch (UnityEngine.Random.Range(0, 3))
		{
		case 0:
			DoorPosT.DOLocalMoveX(LPos, OpenTime);
			break;
		case 1:
			DoorPosT.DOLocalMoveX(MPos, OpenTime);
			break;
		case 2:
			DoorPosT.DOLocalMoveX(RPos, OpenTime);
			break;
		}
		DoorLT.DOLocalMoveX((0f - DoorWidth) / 2f, OpenTime);
		DoorRT.DOLocalMoveX(DoorWidth / 2f, OpenTime);
	}
}
public class csRandomDoorTrigger : csPropBase
{
	public csRandomDoor ParentDoor;

	public override void OnCollected()
	{
		if (GameManager.CurrentState == GameManager.GameState.Playing)
		{
			Apply();
			base.gameObject.SetActive(value: false);
		}
	}

	protected override void Apply()
	{
		ParentDoor.StartDoor();
	}
}
public class csRotateToPlayerDir : MonoBehaviour
{
	public Transform rotateTarget;

	public Transform insideTarget;

	public Transform insideObj;

	public float roateSpeed = 0.1f;

	public float insideRotateSpeed = 2f;

	private Quaternion tar;

	private Quaternion tarQua;

	public float angleX;

	private Vector3 dir = Vector3.zero;

	private float RotateDir = 1f;

	private void FixedUpdate()
	{
		dir = new Vector3(GameManager.Player.thisT.position.x, GameManager.Player.thisT.position.y, rotateTarget.position.z) - rotateTarget.position;
		angleX = GameManager.Player.moveDis;
		if (angleX > 0f)
		{
			RotateDir = 1f;
		}
		else
		{
			RotateDir = -1f;
		}
		tar = Quaternion.LookRotation(dir, Vector3.forward);
		rotateTarget.rotation = Quaternion.Lerp(rotateTarget.rotation, tar, roateSpeed);
		insideObj.position = insideTarget.position;
		float num = Quaternion.Angle(rotateTarget.rotation, tar);
		if (num > 1f)
		{
			insideObj.localEulerAngles = new Vector3(0f, 0f, insideObj.localEulerAngles.z + RotateDir * num * insideRotateSpeed * Time.deltaTime);
		}
	}
}
public class csRotateToPlayerDirCanStop : MonoBehaviour
{
	public csMovingBallCheck movingBallCheck;

	public Transform cubeT;

	public Transform rotateTarget;

	public Transform insideTarget;

	public Transform insideObj;

	public float roateSpeed = 0.1f;

	public float insideRotateSpeed = 2f;

	public MeshRenderer material;

	private Quaternion tar;

	private Quaternion tarQua;

	public float angleX;

	private Vector3 dir = Vector3.zero;

	public float RotateDir = 1f;

	private bool isleft;

	private void FixedUpdate()
	{
		if (Vector3.Distance(GameManager.Player.thisT.position, base.transform.position) > 500f)
		{
			return;
		}
		angleX = GameManager.Player.moveDis;
		if (angleX > 0f)
		{
			RotateDir = 1f;
		}
		else
		{
			RotateDir = -1f;
		}
		isleft = Vector3.Cross(-cubeT.up, GameManager.Player.thisT.position).z < 0f;
		dir = new Vector3(GameManager.Player.thisT.position.x, GameManager.Player.thisT.position.y, rotateTarget.position.z) - rotateTarget.position;
		tar = Quaternion.LookRotation(dir, Vector3.forward);
		if (movingBallCheck.TouchLeft)
		{
			if (Vector3.Cross(movingBallCheck.LStopT.position - rotateTarget.position, dir).z < 0f)
			{
				tar = Quaternion.LookRotation(movingBallCheck.LStopT.position - rotateTarget.position, Vector3.forward);
				rotateTarget.rotation = tar;
				insideObj.position = insideTarget.position;
				return;
			}
		}
		else if (movingBallCheck.TouchRight && Vector3.Cross(movingBallCheck.RStopT.position - rotateTarget.position, dir).z > 0f)
		{
			tar = Quaternion.LookRotation(movingBallCheck.RStopT.position - rotateTarget.position, Vector3.forward);
			rotateTarget.rotation = tar;
			insideObj.position = insideTarget.position;
			return;
		}
		float num = Quaternion.Angle(rotateTarget.rotation, tar);
		rotateTarget.rotation = Quaternion.RotateTowards(rotateTarget.rotation, tar, roateSpeed * 20f * Time.deltaTime);
		insideObj.position = insideTarget.position;
		if (num > 1f)
		{
			insideObj.localEulerAngles = new Vector3(0f, 0f, insideObj.localEulerAngles.z + RotateDir * roateSpeed * 20f * Time.deltaTime * insideRotateSpeed * Time.deltaTime);
		}
	}
}
public class csSmallTunnelTrigger : csPropBase
{
	public bool isEnter;

	public float HeightMul = 0.2f;

	public override void OnCollected()
	{
		if (GameManager.CurrentState == GameManager.GameState.Playing)
		{
			Apply();
			base.gameObject.SetActive(value: false);
		}
	}

	protected override void Apply()
	{
		GameManager.Player.OnEnterSmallTunnel(isEnter, HeightMul);
	}
}
public class csThreeMovingPillar : MonoBehaviour
{
	public Transform[] targets;

	public float DurationTime = 0.3f;

	public float Delay = 2f;

	private int index;

	private IEnumerator Start()
	{
		while (true)
		{
			targets[index].DOLocalMoveY(26f, 0.3f);
			yield return new WaitForSeconds(Delay);
			targets[index].DOLocalMoveY(0f, 0.3f);
			index++;
			if (index > 2)
			{
				index = 0;
			}
		}
	}
}
public class csTunnelBKGController : MonoBehaviour
{
	[Tooltip("亮度乘数")]
	[Header("亮度乘数")]
	public float HighlightMultiplier = 1f;

	public Renderer[] BeatColorRnds;

	public Transform[] BeatScaleTransforms;

	[Header("拉伸乘数")]
	public float AddingScale = 300f;

	[Header("最大拉伸")]
	public float MaxScale = 5f;

	private float threshold = 0.002f;

	private Dictionary<Mesh, Material> SharedMatDic = new Dictionary<Mesh, Material>();

	private float duration = 5f;

	private float smoothness = 0.02f;

	private void Start()
	{
		Renderer[] beatColorRnds = BeatColorRnds;
		foreach (Renderer renderer in beatColorRnds)
		{
			if (!SharedMatDic.ContainsKey(renderer.GetComponent<MeshFilter>().sharedMesh))
			{
				Material value = (renderer.sharedMaterial = new Material(renderer.sharedMaterial));
				SharedMatDic.Add(renderer.GetComponent<MeshFilter>().sharedMesh, value);
			}
			else
			{
				renderer.sharedMaterial = SharedMatDic[renderer.GetComponent<MeshFilter>().sharedMesh];
			}
		}
		StartCoroutine(BeatLerp());
	}

	private IEnumerator BeatLerp()
	{
		float progress = 0f;
		float increment = smoothness / duration;
		while (progress < 1f)
		{
			foreach (Material value2 in SharedMatDic.Values)
			{
				value2.SetFloat("_Emission", Mathf.Lerp(value2.GetFloat("_Emission"), Beats.instance.thisBeat * 500f * HighlightMultiplier, progress));
			}
			float value = 1f + AddingScale * ((Beats.instance.thisBeat > threshold) ? Beats.instance.thisBeat : 0f);
			value = Mathf.Clamp(value, 1f, MaxScale);
			Transform[] beatScaleTransforms = BeatScaleTransforms;
			for (int i = 0; i < beatScaleTransforms.Length; i++)
			{
				beatScaleTransforms[i].localScale = Vector3.one * value;
			}
			progress += increment;
			yield return new WaitForSeconds(smoothness);
		}
		duration = 5f;
		StartCoroutine(BeatLerp());
	}

	private void Update()
	{
		if (base.transform.position.z < -500f)
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}
}
public class csGameProfile : ScriptableObject
{
	public string Version = "0.0.8";

	public string ProductName = "Neon Sprint";

	public ChannelType CurrentChannel;
}
public class MovingTriangleRail : MonoBehaviour
{
	public Transform TriangleT;

	public Transform MoveBoardT;

	public Transform TriangleEndPosT;

	public float MoveSpeed = 5f;

	private bool isMoving;

	private Vector3 MoveDir;

	public float RndMin = 1f;

	public float RndMax = 1.5f;

	private float RotmultiPlier = 1f;

	public Vector3 axis = Vector3.forward;

	public float RotSpeed = 100f;

	public void StartMoving()
	{
		isMoving = true;
		MoveDir = (TriangleEndPosT.localPosition - MoveBoardT.localPosition).normalized;
		RotmultiPlier = UnityEngine.Random.Range(RndMin, RndMax);
	}

	private void Update()
	{
		if (isMoving)
		{
			MoveBoardT.transform.Translate(MoveDir * MoveSpeed * Time.deltaTime);
			TriangleT.Rotate(RotmultiPlier * axis * RotSpeed * Time.deltaTime);
			if (MoveBoardT.transform.localPosition.z < TriangleEndPosT.localPosition.z)
			{
				isMoving = false;
			}
		}
	}
}
public class csViveport : MonoBehaviour
{
	private class MyLicenseChecker : Viveport.Api.LicenseChecker
	{
		public override void OnSuccess(long issueTime, long expirationTime, int latestVersion, bool updateRequired)
		{
			m_Logined = true;
		}

		public override void OnFailure(int errorCode, string errorMessage)
		{
			m_NeedQuitGame = true;
			log = errorMessage;
		}
	}

	public static GameObject m_ThisG;

	public static csViveport instance;

	private const string APP_ID6DOF = "138f7ca4-fcc5-4553-8501-e899cdc0c160";

	private const string APP_KEY6DOF = "MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCzp+1F9bVYMdgwcaXB7Avsog1h7ziFHfdfmIgus6prOVlM7swRoo2D4GPLsxs7USg3/JcDc1MHJ47srWBTKwns/MdWo+I02CatRQ6UA8SaZqGJIBF3JoCqHwN1jmREHcTLDDV8VGaY+afkkLa41YEaqN8IKQzJcmAHlQqP/5zO5QIDAQAB";

	private const string APP_ID3DOF = "75d6488b-a417-43c2-88fb-47a6d7cf3b3f";

	private const string APP_KEY3DOF = "MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCh1JH/+nmHAHP7fUhePqeoIWBB+eYgAmT2ZnI61hioIHm3FoEWPyGAL9Sp0ZV0SXp17+Yrb5rzm7g1tt23q1KyT0Wvt4/wC9CFGoVfHWuA0Xn4baAO70sWEe9ENRoAyXbONGS4tQ/uFc75QnALcNOsSlIy09ivfJq7kNqzovzlcQIDAQAB";

	private static string UserID = "";

	private static string NickName = "";

	public static bool m_Logined = false;

	public static bool m_NeedQuitGame = false;

	public static bool isArcadeMode = false;

	public Text LogMsg;

	private static string log;

	private void Awake()
	{
		csGameSettings.Init();
		if (instance == null)
		{
			instance = this;
		}
	}

	private void Start()
	{
		if (csGameSettings.Channel == ChannelType.WaveVR_3Dof || csGameSettings.Channel == ChannelType.WaveVR_6Dof)
		{
			if (m_ThisG == null)
			{
				m_ThisG = base.gameObject;
				UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
			}
			else
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
			if (csGameSettings.Channel == ChannelType.WaveVR_3Dof)
			{
				Viveport.Api.Init(InitStatusHandler, "75d6488b-a417-43c2-88fb-47a6d7cf3b3f");
			}
			else
			{
				Viveport.Api.Init(InitStatusHandler, "138f7ca4-fcc5-4553-8501-e899cdc0c160");
			}
		}
	}

	private void Update()
	{
		if (m_NeedQuitGame && csGameSettings.NeedDRM)
		{
			UnityEngine.Application.Quit();
		}
	}

	private static void InitStatusHandler(int nResult)
	{
		if (nResult != 0)
		{
			m_NeedQuitGame = true;
		}
		else
		{
			Viveport.UserStats.IsReady(IsReadyHandler);
		}
	}

	private static void IsReadyHandler(int nResult)
	{
		if (nResult != 0)
		{
			m_NeedQuitGame = true;
			return;
		}
		UserID = Viveport.User.GetUserId();
		NickName = Viveport.User.GetUserName();
		if (csGameSettings.Channel == ChannelType.WaveVR_3Dof)
		{
			Viveport.Api.GetLicense(new MyLicenseChecker(), "75d6488b-a417-43c2-88fb-47a6d7cf3b3f", "MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCh1JH/+nmHAHP7fUhePqeoIWBB+eYgAmT2ZnI61hioIHm3FoEWPyGAL9Sp0ZV0SXp17+Yrb5rzm7g1tt23q1KyT0Wvt4/wC9CFGoVfHWuA0Xn4baAO70sWEe9ENRoAyXbONGS4tQ/uFc75QnALcNOsSlIy09ivfJq7kNqzovzlcQIDAQAB");
		}
		else
		{
			Viveport.Api.GetLicense(new MyLicenseChecker(), "138f7ca4-fcc5-4553-8501-e899cdc0c160", "MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCzp+1F9bVYMdgwcaXB7Avsog1h7ziFHfdfmIgus6prOVlM7swRoo2D4GPLsxs7USg3/JcDc1MHJ47srWBTKwns/MdWo+I02CatRQ6UA8SaZqGJIBF3JoCqHwN1jmREHcTLDDV8VGaY+afkkLa41YEaqN8IKQzJcmAHlQqP/5zO5QIDAQAB");
		}
	}

	private static void IsArcadeLeaderboardReadyHandler(int nResult)
	{
	}
}
public class ViveportDemo : MonoBehaviour
{
	private class MyLicenseChecker : Viveport.Api.LicenseChecker
	{
		public override void OnSuccess(long issueTime, long expirationTime, int latestVersion, bool updateRequired)
		{
			Viveport.Core.Logger.Log("[MyLicenseChecker] issueTime: " + issueTime);
			Viveport.Core.Logger.Log("[MyLicenseChecker] expirationTime: " + expirationTime);
			Viveport.Core.Logger.Log("[MyLicenseChecker] latestVersion: " + latestVersion);
			Viveport.Core.Logger.Log("[MyLicenseChecker] updateRequired: " + updateRequired);
		}

		public override void OnFailure(int errorCode, string errorMessage)
		{
			Viveport.Core.Logger.Log("[MyLicenseChecker] errorCode: " + errorCode);
			Viveport.Core.Logger.Log("[MyLicenseChecker] errorMessage: " + errorMessage);
		}
	}

	private int nInitValue;

	private int nResult;

	private int nWidth = 150;

	private int nHeight = 100;

	private int nXStart = 10;

	private int nYStart = 35;

	private string stringToEdit = "ID_Stat1";

	private string StatsCount = "80";

	private string achivToEdit = "ID_Achievement1";

	private string leaderboardToEdit = "ID_Leaderboard1";

	private string leaderboardUserName = "Karl";

	private string leaderboardScore = "1000";

	private static bool bInit = true;

	private static bool bIsReady = false;

	private static bool bUserProfileIsReady = false;

	private static bool bArcadeIsReady = false;

	private static bool bTokenIsReady = false;

	private static string msgBuffer = "";

	private static string APP_ID = "bd67b286-aafc-449d-8896-bb7e9b351876";

	private static string APP_KEY = "MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDFypCg0OHfBC+VZLSWPbNSgDo9qg/yQORDwGy1rKIboMj3IXn4Zy6h6bgn8kiMY7VI0lPwIj9lijT3ZxkzuTsI5GsK//Y1bqeTol4OUFR+47gj+TUuekAS2WMtglKox+/7mO6CA1gV+jZrAKo6YSVmPd+oFsgisRcqEgNh5MIURQIDAQAB";

	private static void Log(string msg)
	{
		msgBuffer = msg + "\n" + msgBuffer;
		Viveport.Core.Logger.Log(msg);
	}

	private void Start()
	{
		Viveport.Api.Init(InitStatusHandler, APP_ID);
	}

	private void Update()
	{
	}

	private void OnGUI()
	{
		GUIStyle gUIStyle = new GUIStyle("button");
		GUIStyle gUIStyle2 = new GUIStyle("button");
		gUIStyle.fontSize = 23;
		gUIStyle2.fontSize = 23;
		GUIStyle gUIStyle3 = new GUIStyle("guiStyle");
		gUIStyle3.fontSize = 40;
		gUIStyle3.alignment = TextAnchor.UpperLeft;
		msgBuffer = GUI.TextArea(new Rect(10f, nYStart + 4 * nWidth + 20, 1600f, 800f), msgBuffer, gUIStyle3);
		if (!bInit)
		{
			GUI.contentColor = Color.white;
		}
		else
		{
			GUI.contentColor = Color.grey;
		}
		if (GUI.Button(new Rect(nXStart, nYStart, nWidth, nHeight), "Init", gUIStyle) && !bInit)
		{
			Viveport.Api.Init(InitStatusHandler, APP_ID);
		}
		if (bInit)
		{
			GUI.contentColor = Color.white;
		}
		else
		{
			GUI.contentColor = Color.grey;
		}
		if (GUI.Button(new Rect(nXStart + (nWidth + 10), nYStart, nWidth, nHeight), "Shutdown", gUIStyle) && bInit)
		{
			Viveport.Api.Shutdown(ShutdownHandler);
		}
		if (GUI.Button(new Rect(nXStart + 2 * (nWidth + 10), nYStart, nWidth, nHeight), "Version", gUIStyle) && bInit)
		{
			Viveport.Core.Logger.Log("Version: " + Viveport.Api.Version());
		}
		if (GUI.Button(new Rect(nXStart + 4 * (nWidth + 10), nYStart, nWidth, nHeight), "StatIsReady", gUIStyle) && bInit)
		{
			Viveport.UserStats.IsReady(IsReadyHandler);
		}
		if (GUI.Button(new Rect(nXStart + 6 * (nWidth + 10), nYStart, nWidth, nHeight), "DRM", gUIStyle))
		{
			if (bInit)
			{
				Viveport.Api.GetLicense(new MyLicenseChecker(), APP_ID, APP_KEY);
			}
			else
			{
				Viveport.Core.Logger.Log("Please make sure init & isReady are successful.");
			}
		}
		if (GUI.Button(new Rect(nXStart + 7 * (nWidth + 10), nYStart, nWidth, nHeight), "UserProfileIsReady", gUIStyle2))
		{
			if (bInit && bIsReady)
			{
				Viveport.User.IsReady(UserProfileIsReadyHandler);
			}
			else
			{
				Log("Please make sure init & isReady are successful.");
			}
		}
		if (GUI.Button(new Rect(nXStart + 8 * (nWidth + 10), nYStart, nWidth, nHeight), "UserProfile", gUIStyle))
		{
			if (bInit && bIsReady && bUserProfileIsReady)
			{
				Log("UserId: " + Viveport.User.GetUserId());
				Log("userName: " + Viveport.User.GetUserName());
				Log("userAvatarUrl: " + Viveport.User.GetUserAvatarUrl());
			}
			else
			{
				Log("Please make sure init & isReady are successful.");
			}
		}
		stringToEdit = GUI.TextField(new Rect(10f, nWidth + 10, 120f, 20f), stringToEdit, 50);
		StatsCount = GUI.TextField(new Rect(130f, nWidth + 10, 220f, 20f), StatsCount, 50);
		if (GUI.Button(new Rect(nXStart, nYStart + nWidth + 10, nWidth, nHeight), "DownloadStat", gUIStyle))
		{
			if (bInit && bIsReady)
			{
				Viveport.UserStats.DownloadStats(DownloadStatsHandler);
			}
			else
			{
				Viveport.Core.Logger.Log("Please make sure init & isReady are successful.");
			}
		}
		if (GUI.Button(new Rect(nXStart + (nWidth + 10), nYStart + nWidth + 10, nWidth, nHeight), "UploadStat", gUIStyle))
		{
			if (bInit && bIsReady)
			{
				Viveport.UserStats.UploadStats(UploadStatsHandler);
			}
			else
			{
				Viveport.Core.Logger.Log("Please make sure init & isReady are successful.");
			}
		}
		if (GUI.Button(new Rect(nXStart + 2 * (nWidth + 10), nYStart + nWidth + 10, nWidth, nHeight), "GetStat", gUIStyle))
		{
			if (bInit && bIsReady)
			{
				nResult = Viveport.UserStats.GetStat(stringToEdit, nInitValue);
				Viveport.Core.Logger.Log("Get " + stringToEdit + " stat name as => " + nResult);
			}
			else
			{
				Viveport.Core.Logger.Log("Please make sure init & isReady are successful.");
			}
		}
		if (GUI.Button(new Rect(nXStart + 3 * (nWidth + 10), nYStart + nWidth + 10, nWidth, nHeight), "SetStat", gUIStyle))
		{
			if (bInit && bIsReady)
			{
				Viveport.Core.Logger.Log("MaxStep is => " + int.Parse(StatsCount));
				nResult = int.Parse(StatsCount);
				Viveport.UserStats.SetStat(stringToEdit, nResult);
				Viveport.Core.Logger.Log("Set" + stringToEdit + " stat name as =>" + nResult);
			}
			else
			{
				Viveport.Core.Logger.Log("Please make sure init & isReady are successful.");
			}
		}
		achivToEdit = GUI.TextField(new Rect(10f, 2 * nWidth + 15, 120f, 20f), achivToEdit, 50);
		if (GUI.Button(new Rect(nXStart, nYStart + 2 * nWidth + 10, nWidth, nHeight), "GetAchieve", gUIStyle))
		{
			if (bInit && bIsReady)
			{
				bool flag = false;
				flag = Viveport.UserStats.GetAchievement(achivToEdit);
				Viveport.Core.Logger.Log("Get achievement => " + achivToEdit + " , and value is => " + flag);
			}
			else
			{
				Viveport.Core.Logger.Log("Please make sure init & isReady are successful.");
			}
		}
		if (GUI.Button(new Rect(nXStart + nWidth + 10, nYStart + 2 * nWidth + 10, nWidth, nHeight), "SetAchieve", gUIStyle))
		{
			if (bInit && bIsReady)
			{
				Viveport.UserStats.SetAchievement(achivToEdit);
				Viveport.Core.Logger.Log("Set achievement => " + achivToEdit);
			}
			else
			{
				Viveport.Core.Logger.Log("Please make sure init & isReady are successful.");
			}
		}
		if (GUI.Button(new Rect(nXStart + 2 * (nWidth + 10), nYStart + 2 * nWidth + 10, nWidth, nHeight), "ClearAchieve", gUIStyle))
		{
			if (bInit && bIsReady)
			{
				Viveport.UserStats.ClearAchievement(achivToEdit);
				Viveport.Core.Logger.Log("Clear achievement => " + achivToEdit);
			}
			else
			{
				Viveport.Core.Logger.Log("Please make sure init & isReady are successful.");
			}
		}
		if (GUI.Button(new Rect(nXStart + 3 * (nWidth + 10), nYStart + 2 * nWidth + 10, nWidth, nHeight), "Achieve&Time", gUIStyle))
		{
			if (bInit && bIsReady)
			{
				int num = 0;
				num = Viveport.UserStats.GetAchievementUnlockTime(achivToEdit);
				Viveport.Core.Logger.Log("The achievement's unlock time is =>" + num);
			}
			else
			{
				Viveport.Core.Logger.Log("Please make sure init & isReady are successful.");
			}
		}
		if (GUI.Button(new Rect(nXStart + 4 * (nWidth + 10), nYStart + 2 * nWidth + 10, nWidth, nHeight), "Achieve Name", gUIStyle))
		{
			if (bInit && bIsReady)
			{
				string achievementDisplayAttribute = Viveport.UserStats.GetAchievementDisplayAttribute(achivToEdit, Viveport.UserStats.AchievementDisplayAttribute.Name);
				Viveport.Core.Logger.Log("The achievement's name is =>" + achievementDisplayAttribute);
			}
			else
			{
				Viveport.Core.Logger.Log("Please make sure init & isReady are successful.");
			}
		}
		if (GUI.Button(new Rect(nXStart + 5 * (nWidth + 10), nYStart + 2 * nWidth + 10, nWidth, nHeight), "Achieve Desctiption", gUIStyle))
		{
			if (bInit && bIsReady)
			{
				string achievementDisplayAttribute2 = Viveport.UserStats.GetAchievementDisplayAttribute(achivToEdit, Viveport.UserStats.AchievementDisplayAttribute.Desc, Locale.US);
				Viveport.Core.Logger.Log("The achievement's description is =>" + achievementDisplayAttribute2);
			}
			else
			{
				Viveport.Core.Logger.Log("Please make sure init & isReady are successful.");
			}
		}
		leaderboardToEdit = GUI.TextField(new Rect(10f, 3 * nWidth + 20, 160f, 20f), leaderboardToEdit, 150);
		if (GUI.Button(new Rect(nXStart, nYStart + 3 * nWidth + 20, nWidth, nHeight), "DL Around", gUIStyle))
		{
			if (bInit && bIsReady)
			{
				Viveport.UserStats.DownloadLeaderboardScores(DownloadLeaderboardHandler, leaderboardToEdit, Viveport.UserStats.LeaderBoardRequestType.GlobalDataAroundUser, Viveport.UserStats.LeaderBoardTimeRange.AllTime, -5, 5);
				Viveport.Core.Logger.Log("DownloadLeaderboardScores");
			}
			else
			{
				Viveport.Core.Logger.Log("Please make sure init & isReady are successful.");
			}
		}
		if (GUI.Button(new Rect(nXStart + (nWidth + 10), nYStart + 3 * nWidth + 20, nWidth, nHeight), "DL not Around", gUIStyle))
		{
			if (bInit && bIsReady)
			{
				Viveport.UserStats.DownloadLeaderboardScores(DownloadLeaderboardHandler, leaderboardToEdit, Viveport.UserStats.LeaderBoardRequestType.GlobalData, Viveport.UserStats.LeaderBoardTimeRange.AllTime, 0, 10);
				Viveport.Core.Logger.Log("DownloadLeaderboardScores");
			}
			else
			{
				Viveport.Core.Logger.Log("Please make sure init & isReady are successful.");
			}
		}
		leaderboardScore = GUI.TextField(new Rect(170f, 3 * nWidth + 20, 160f, 20f), leaderboardScore, 50);
		if (GUI.Button(new Rect(nXStart + 2 * (nWidth + 10), nYStart + 3 * nWidth + 20, nWidth, nHeight), "Upload LB", gUIStyle))
		{
			if (bInit && bIsReady)
			{
				Viveport.UserStats.UploadLeaderboardScore(UploadLeaderboardScoreHandler, leaderboardToEdit, int.Parse(leaderboardScore));
				Viveport.Core.Logger.Log("UploadLeaderboardScore");
			}
			else
			{
				Viveport.Core.Logger.Log("Please make sure init & isReady are successful.");
			}
		}
		if (GUI.Button(new Rect(nXStart + 3 * (nWidth + 10), nYStart + 3 * nWidth + 20, nWidth, nHeight), "Get LB count", gUIStyle))
		{
			if (bInit && bIsReady)
			{
				nResult = Viveport.UserStats.GetLeaderboardScoreCount();
				Viveport.Core.Logger.Log("GetLeaderboardScoreCount=> " + nResult);
			}
			else
			{
				Viveport.Core.Logger.Log("Please make sure init & isReady are successful.");
			}
		}
		if (GUI.Button(new Rect(nXStart + 4 * (nWidth + 10), nYStart + 3 * nWidth + 20, nWidth, nHeight), "Get LB Score", gUIStyle))
		{
			if (bInit && bIsReady)
			{
				int leaderboardScoreCount = Viveport.UserStats.GetLeaderboardScoreCount();
				Viveport.Core.Logger.Log("GetLeaderboardScoreCount => " + leaderboardScoreCount);
				for (int i = 0; i < leaderboardScoreCount; i++)
				{
					Leaderboard leaderboard = Viveport.UserStats.GetLeaderboardScore(i);
					Viveport.Core.Logger.Log("UserName = " + leaderboard.UserName + ", Score = " + leaderboard.Score + ", Rank = " + leaderboard.Rank);
				}
			}
			else
			{
				Viveport.Core.Logger.Log("Please make sure init & isReady are successful.");
			}
		}
		if (GUI.Button(new Rect(nXStart + 5 * (nWidth + 10), nYStart + 3 * nWidth + 20, nWidth, nHeight), "Get Sort Method", gUIStyle))
		{
			if (bInit && bIsReady)
			{
				int leaderboardSortMethod = (int)Viveport.UserStats.GetLeaderboardSortMethod();
				Viveport.Core.Logger.Log("GetLeaderboardSortMethod=> " + leaderboardSortMethod);
			}
			else
			{
				Viveport.Core.Logger.Log("Please make sure init & isReady are successful.");
			}
		}
		if (GUI.Button(new Rect(nXStart + 6 * (nWidth + 10), nYStart + 3 * nWidth + 20, nWidth, nHeight), "Get Disp Type", gUIStyle))
		{
			if (bInit && bIsReady)
			{
				int leaderboardDisplayType = (int)Viveport.UserStats.GetLeaderboardDisplayType();
				Viveport.Core.Logger.Log("GetLeaderboardDisplayType=> " + leaderboardDisplayType);
			}
			else
			{
				Viveport.Core.Logger.Log("Please make sure init & isReady are successful.");
			}
		}
	}

	private static void InitStatusHandler(int nResult)
	{
		if (nResult == 0)
		{
			bInit = true;
			bIsReady = false;
			bArcadeIsReady = false;
			Viveport.Core.Logger.Log("InitStatusHandler is successful");
		}
		else
		{
			bInit = false;
			Viveport.Core.Logger.Log("InitStatusHandler error : " + nResult);
		}
	}

	private static void IsReadyHandler(int nResult)
	{
		if (nResult == 0)
		{
			bIsReady = true;
			bArcadeIsReady = false;
			Viveport.Core.Logger.Log("IsReadyHandler is successful");
		}
		else
		{
			bIsReady = false;
			Viveport.Core.Logger.Log("IsReadyHandler error: " + nResult);
		}
	}

	private static void IsTokenReadyHandler(int nResult)
	{
		if (nResult == 0)
		{
			bTokenIsReady = true;
			Viveport.Core.Logger.Log("IsTokenReadyHandler is successful");
		}
		else
		{
			bTokenIsReady = false;
			Viveport.Core.Logger.Log("IsTokenReadyHandler error: " + nResult);
		}
	}

	private static void UserProfileIsReadyHandler(int nResult)
	{
		if (nResult == 0)
		{
			bUserProfileIsReady = true;
			Log("UserProfileIsReadyHandler is successful");
		}
		else
		{
			bUserProfileIsReady = false;
			Log("UserProfileIsReadyHandler error: " + nResult);
		}
	}

	private static void GetSessionTokenHandler(int nResult, string message)
	{
		if (nResult == 0)
		{
			Viveport.Core.Logger.Log("GetSessionTokenHandler is successful, token:" + message);
		}
		else if (message.Length != 0)
		{
			Viveport.Core.Logger.Log("GetSessionTokenHandler error: " + nResult + ", message:" + message);
		}
		else
		{
			Viveport.Core.Logger.Log("GetSessionTokenHandler error: " + nResult);
		}
	}

	private static void QueryRunTimeHandler(int nResult, int nMode)
	{
		if (nResult == 0)
		{
			Viveport.Core.Logger.Log("QueryRunTimeHandler is successful" + nResult + "Running mode is " + nMode);
		}
		else
		{
			Viveport.Core.Logger.Log("QueryRunTimeHandler error: " + nResult);
		}
	}

	private static void IsArcadeLeaderboardReadyHandler(int nResult)
	{
		if (nResult == 0)
		{
			bArcadeIsReady = true;
			bIsReady = false;
			Viveport.Core.Logger.Log("IsArcadeLeaderboardReadyHandler is successful");
		}
		else
		{
			bArcadeIsReady = false;
			Viveport.Core.Logger.Log("IsArcadeLeaderboardReadyHandler error: " + nResult);
		}
	}

	private static void ShutdownHandler(int nResult)
	{
		if (nResult == 0)
		{
			bInit = false;
			bIsReady = false;
			Viveport.Core.Logger.Log("ShutdownHandler is successful");
		}
		else
		{
			Viveport.Core.Logger.Log("ShutdownHandler error: " + nResult);
		}
	}

	private static void DownloadStatsHandler(int nResult)
	{
		if (nResult == 0)
		{
			Viveport.Core.Logger.Log("DownloadStatsHandler is successful ");
		}
		else
		{
			Viveport.Core.Logger.Log("DownloadStatsHandler error: " + nResult);
		}
	}

	private static void UploadStatsHandler(int nResult)
	{
		if (nResult == 0)
		{
			Viveport.Core.Logger.Log("UploadStatsHandler is successful");
		}
		else
		{
			Viveport.Core.Logger.Log("UploadStatsHandler error: " + nResult);
		}
	}

	private static void DownloadLeaderboardHandler(int nResult)
	{
		if (nResult == 0)
		{
			Viveport.Core.Logger.Log("DownloadLeaderboardHandler is successful");
		}
		else
		{
			Viveport.Core.Logger.Log("DownloadLeaderboardHandler error: " + nResult);
		}
	}

	private static void UploadLeaderboardScoreHandler(int nResult)
	{
		if (nResult == 0)
		{
			Viveport.Core.Logger.Log("UploadLeaderboardScoreHandler is successful.");
		}
		else
		{
			Viveport.Core.Logger.Log("UploadLeaderboardScoreHandler error : " + nResult);
		}
	}
}
public class ViveportDemo_ArcadeSession : MonoBehaviour
{
	private int nWidth = 120;

	private int nHeight = 40;

	private int nXStart = 10;

	private int nYStart = 35;

	private static string VIVEPORT_ARCADE_APP_TEST_ID = "app_test_id";

	private void Start()
	{
		Viveport.Api.Init(InitStatusHandler, VIVEPORT_ARCADE_APP_TEST_ID);
	}

	private void Update()
	{
	}

	private void InitStatusHandler(int nResult)
	{
		Viveport.Core.Logger.Log("InitStatusHandler: " + nResult);
		if (nResult != 0)
		{
			Viveport.Core.Logger.Log("Platform setup error ...");
		}
		else
		{
			Viveport.Core.Logger.Log("Session IsReady");
		}
	}
}
public class ViveportDemo_Deeplink : MonoBehaviour
{
	private class MyDeeplinkChecker : Viveport.Deeplink.DeeplinkChecker
	{
		public override void OnSuccess()
		{
			Viveport.Core.Logger.Log("Deeplink is successful");
		}

		public override void OnFailure(int errorCode, string errorMessage)
		{
			Viveport.Core.Logger.Log("Deeplink is failure ErrorCode : " + errorCode + "ErrorMessage : " + errorMessage);
		}
	}

	private int nWidth = 180;

	private int nHeight = 100;

	private int nXStart = 10;

	private int nYStart = 35;

	private static string APP_ID = "76d0898e-8772-49a9-aa55-1ec251a21686";

	private static string LaunchAPPID = "05634fed-6dc5-4aa8-865d-af6027f4ec09";

	private static string LaunchStoreAPPID = "05634fed-6dc5-4aa8-865d-af6027f4ec09";

	private static string LaunchData = "LaunchData";

	private static bool bInit = false;

	private void Start()
	{
		Viveport.Api.Init(InitStatusHandler, APP_ID);
	}

	private void OnGUI()
	{
		GUIStyle gUIStyle = new GUIStyle("button");
		gUIStyle.fontSize = 23;
		if (!bInit)
		{
			GUI.contentColor = Color.white;
		}
		else
		{
			GUI.contentColor = Color.gray;
		}
		if (GUI.Button(new Rect(nXStart, nYStart, nWidth, nHeight), "Init", gUIStyle) && !bInit)
		{
			Viveport.Api.Init(InitStatusHandler, APP_ID);
		}
		if (bInit)
		{
			GUI.contentColor = Color.white;
		}
		else
		{
			GUI.contentColor = Color.grey;
		}
		if (GUI.Button(new Rect(nXStart + 2 * (nWidth + 10), nYStart, nWidth, nHeight), "Shutdown", gUIStyle) && bInit)
		{
			Viveport.Api.Shutdown(ShutdownHandler);
		}
		if (GUI.Button(new Rect(nXStart + (nWidth + 10), nYStart, nWidth, nHeight), "GoToApp", gUIStyle) && bInit)
		{
			Viveport.Deeplink.GoToApp(new MyDeeplinkChecker(), LaunchAPPID, LaunchData);
		}
		if (GUI.Button(new Rect(nXStart + (nWidth + 10), nYStart + 125, nWidth, nHeight), "GoToStroe", gUIStyle) && bInit)
		{
			Viveport.Deeplink.GoToStore(new MyDeeplinkChecker(), LaunchStoreAPPID);
		}
		if (GUI.Button(new Rect(nXStart + (nWidth + 10), nYStart + 250, nWidth, nHeight), "GoToAppOrGoToStore", gUIStyle) && bInit)
		{
			Viveport.Deeplink.GoToAppOrGoToStore(new MyDeeplinkChecker(), LaunchStoreAPPID, LaunchData);
		}
		if (GUI.Button(new Rect(nXStart + (nWidth + 10), nYStart + 375, nWidth, nHeight), "GoToAppOrGoToStore", gUIStyle) && bInit)
		{
			string appLaunchData = Viveport.Deeplink.GetAppLaunchData();
			Viveport.Core.Logger.Log("GetAppLaunchData : " + appLaunchData);
		}
	}

	private static void InitStatusHandler(int nResult)
	{
		if (nResult == 0)
		{
			bInit = true;
			Viveport.Core.Logger.Log("InitStatusHandler is successful");
		}
		else
		{
			bInit = false;
			Viveport.Core.Logger.Log("InitStatusHandler error : " + nResult);
		}
	}

	private static void ShutdownHandler(int nResult)
	{
	}
}
public class ViveportDemo_DLC : MonoBehaviour
{
	private int nWidth = 180;

	private int nHeight = 100;

	private int nXStart = 10;

	private int nYStart = 35;

	private static string APP_ID = "76d0898e-8772-49a9-aa55-1ec251a21686";

	private static bool bInit = true;

	private void Start()
	{
		Viveport.Api.Init(InitStatusHandler, APP_ID);
	}

	private void OnGUI()
	{
		GUIStyle gUIStyle = new GUIStyle("button");
		gUIStyle.fontSize = 23;
		if (!bInit)
		{
			GUI.contentColor = Color.white;
		}
		else
		{
			GUI.contentColor = Color.gray;
		}
		if (GUI.Button(new Rect(nXStart, nYStart, nWidth, nHeight), "Init", gUIStyle) && !bInit)
		{
			Viveport.Api.Init(InitStatusHandler, APP_ID);
		}
		if (bInit)
		{
			GUI.contentColor = Color.white;
		}
		else
		{
			GUI.contentColor = Color.grey;
		}
		if (GUI.Button(new Rect(nXStart + (nWidth + 10), nYStart, nWidth, nHeight), "Shutdown", gUIStyle) && bInit)
		{
			Viveport.Api.Shutdown(ShutdownHandler);
		}
	}

	private static void InitStatusHandler(int nResult)
	{
	}

	private static void ShutdownHandler(int nResult)
	{
	}

	private static void IsDLCReadyHandler(int nResult)
	{
	}
}
public class ViveportDemo_IAP : MonoBehaviour
{
	public class Item
	{
		public string ticket = "test_id";

		public string[] items;

		public string subscription_ticket = "unity_test_subscriptionId";
	}

	private class Result : Viveport.IAPurchase.IAPurchaseListener
	{
		public Item mItem = new Item();

		public override void OnSuccess(string pchCurrencyName)
		{
			bIsReady_Done = true;
			Viveport.Core.Logger.Log("[OnSuccess] pchCurrencyName=" + pchCurrencyName);
		}

		public override void OnRequestSuccess(string pchPurchaseId)
		{
			mItem.ticket = pchPurchaseId;
			Viveport.Core.Logger.Log("[OnRequestSuccess] pchPurchaseId=" + pchPurchaseId + ",mItem.ticket=" + mItem.ticket);
		}

		public override void OnPurchaseSuccess(string pchPurchaseId)
		{
			Viveport.Core.Logger.Log("[OnPurchaseSuccess] pchPurchaseId=" + pchPurchaseId);
			if (mItem.ticket == pchPurchaseId)
			{
				Viveport.Core.Logger.Log("[OnPurchaseSuccess] give items to user");
			}
		}

		public override void OnQuerySuccess(Viveport.IAPurchase.QueryResponse response)
		{
			Viveport.Core.Logger.Log("[OnQuerySuccess] purchaseId=" + response.purchase_id + ",status=" + response.status);
		}

		public override void OnQuerySuccess(Viveport.IAPurchase.QueryListResponse response)
		{
			Viveport.Core.Logger.Log("[OnQueryListSuccess] total=" + response.total + ", from=" + response.from + ", to=" + response.to);
			foreach (Viveport.IAPurchase.QueryResponse2 purchase in response.purchaseList)
			{
				Viveport.Core.Logger.Log("purchase_id=" + purchase.purchase_id + ", user_data=" + purchase.user_data + ", price=" + purchase.price + ", currency=" + purchase.currency + ", paid_timestamp=" + purchase.paid_timestamp);
			}
		}

		public override void OnBalanceSuccess(string pchBalance)
		{
			Viveport.Core.Logger.Log("[OnBalanceSuccess] pchBalance=" + pchBalance);
		}

		public override void OnRequestSubscriptionSuccess(string pchSubscriptionId)
		{
			mItem.subscription_ticket = pchSubscriptionId;
			Viveport.Core.Logger.Log("[OnRequestSubscriptionSuccess] pchSubscriptionId=" + pchSubscriptionId + ",mItem.subscription_ticket=" + mItem.subscription_ticket);
		}

		public override void OnRequestSubscriptionWithPlanIDSuccess(string pchSubscriptionId)
		{
			mItem.subscription_ticket = pchSubscriptionId;
			Viveport.Core.Logger.Log("[OnRequestSubscriptionWithPlanIDSuccess] pchSubscriptionId=" + pchSubscriptionId + ",mItem.subscription_ticket=" + mItem.subscription_ticket);
		}

		public override void OnSubscribeSuccess(string pchSubscriptionId)
		{
			Viveport.Core.Logger.Log("[OnSubscribeSuccess] pchSubscriptionId=" + pchSubscriptionId);
			if (mItem.subscription_ticket == pchSubscriptionId)
			{
				Viveport.Core.Logger.Log("[OnSubscribeSuccess] give virtual items to user");
			}
		}

		public override void OnQuerySubscriptionSuccess(Viveport.IAPurchase.Subscription[] subscriptionlist)
		{
			int num = subscriptionlist.Length;
			Viveport.Core.Logger.Log("[OnQuerySubscriptionSuccess] subscriptionlist size =" + num);
			if (num <= 0)
			{
				return;
			}
			for (int i = 0; i < num; i++)
			{
				Viveport.Core.Logger.Log("[OnQuerySubscriptionSuccess] subscriptionlist[" + i + "].status =" + subscriptionlist[i].status + ", subscriptionlist[" + i + "].plan_id = " + subscriptionlist[i].plan_id);
				if (subscriptionlist[i].plan_id == "pID" && subscriptionlist[i].status == "ACTIVE")
				{
					bIsDuplicatedSubscription = true;
				}
			}
		}

		public override void OnQuerySubscriptionListSuccess(Viveport.IAPurchase.Subscription[] subscriptionlist)
		{
			int num = subscriptionlist.Length;
			Viveport.Core.Logger.Log("[OnQuerySubscriptionListSuccess] subscriptionlist size =" + num);
			if (num <= 0)
			{
				return;
			}
			for (int i = 0; i < num; i++)
			{
				Viveport.Core.Logger.Log("[OnQuerySubscriptionListSuccess] subscriptionlist[" + i + "].status =" + subscriptionlist[i].status + ", subscriptionlist[" + i + "].plan_id = " + subscriptionlist[i].plan_id);
				if (subscriptionlist[i].plan_id == "pID" && subscriptionlist[i].status == "ACTIVE")
				{
					bIsDuplicatedSubscription = true;
				}
			}
		}

		public override void OnCancelSubscriptionSuccess(bool bCanceled)
		{
			Viveport.Core.Logger.Log("[OnCancelSubscriptionSuccess] bCanceled=" + bCanceled);
		}

		public override void OnFailure(int nCode, string pchMessage)
		{
			Viveport.Core.Logger.Log("[OnFailed] " + nCode + ", " + pchMessage);
		}
	}

	private int nWidth = 240;

	private int nHeight = 120;

	private int nXStart = 10;

	private int nYStart = 40;

	private static string IAP_APP_TEST_ID = "app_VIVEPORT_ID";

	private static string IAP_APP_TEST_KEY = "app_API_Key";

	private Result mListener;

	private static bool bIsDuplicatedSubscription = false;

	private static bool bInit_Done = false;

	private static bool bIsReady_Done = false;

	private static bool bShutdown_Done = false;

	private Text winText;

	private void Start()
	{
		Viveport.Core.Logger.Log("mListener: " + mListener);
		mListener = new Result();
		Viveport.Core.Logger.Log("mListener end: " + mListener);
		Viveport.Api.Init(InitStatusHandler, IAP_APP_TEST_ID);
	}

	private void Update()
	{
	}

	private void OnGUI()
	{
		new GUIStyle("button");
		GUIStyle gUIStyle = new GUIStyle("button");
		gUIStyle.fontSize = 24;
		if (GUI.Button(new Rect(nXStart, nYStart, nWidth, nHeight), "IsReady", gUIStyle))
		{
			Viveport.Core.Logger.Log("IsReady");
			Viveport.IAPurchase.IsReady(mListener, IAP_APP_TEST_KEY);
		}
		if (GUI.Button(new Rect(nXStart, nYStart + nWidth + 10, nWidth, nHeight), "Request", gUIStyle))
		{
			Viveport.Core.Logger.Log("Request");
			mListener.mItem.items = new string[3];
			mListener.mItem.items[0] = "sword";
			mListener.mItem.items[1] = "knife";
			mListener.mItem.items[2] = "medicine";
			Viveport.IAPurchase.Request(mListener, "1");
		}
		if (GUI.Button(new Rect(nXStart, nYStart + 2 * nWidth + 20, nWidth, nHeight), "Purchase", gUIStyle))
		{
			Viveport.Core.Logger.Log("Purchase mListener.mItem.ticket=" + mListener.mItem.ticket);
			Viveport.IAPurchase.Purchase(mListener, mListener.mItem.ticket);
		}
		if (GUI.Button(new Rect(nXStart, nYStart + 3 * nWidth + 30, nWidth, nHeight), "Query", gUIStyle))
		{
			Viveport.Core.Logger.Log("Query");
			Viveport.IAPurchase.Query(mListener, mListener.mItem.ticket);
		}
		if (GUI.Button(new Rect(nXStart, nYStart + 4 * nWidth + 40, nWidth, nHeight), "GetBalance", gUIStyle))
		{
			Viveport.Core.Logger.Log("GetBalance");
			Viveport.IAPurchase.GetBalance(mListener);
		}
		if (GUI.Button(new Rect(nXStart + nWidth + 10, nYStart + nWidth + 10, nWidth + 70, nHeight), "RequestSubscription", gUIStyle))
		{
			Viveport.Core.Logger.Log("RequestSubscription");
			Viveport.IAPurchase.RequestSubscription(mListener, "1", "month", 1, "day", 2, 3, "pID");
		}
		if (GUI.Button(new Rect(nXStart + nWidth + 350, nYStart + nWidth + 10, nWidth + 70, nHeight), "RequestWithUserData", gUIStyle))
		{
			Viveport.Core.Logger.Log("Request");
			Viveport.IAPurchase.Request(mListener, "1", "Knife");
		}
		if (GUI.Button(new Rect(nXStart + nWidth + 10, nYStart + 2 * nWidth + 20, nWidth + 120, nHeight), "RequestSubscriptionWithPlanID", gUIStyle))
		{
			Viveport.Core.Logger.Log("RequestSubscriptionWithPlanID");
			Viveport.IAPurchase.RequestSubscriptionWithPlanID(mListener, "pID");
		}
		if (GUI.Button(new Rect(nXStart + nWidth + 10, nYStart + 3 * nWidth + 30, nWidth, nHeight), "Subscribe", gUIStyle))
		{
			Viveport.Core.Logger.Log("Subscribe bIsDuplicatedSubscription=" + bIsDuplicatedSubscription);
			Viveport.IAPurchase.Subscribe(mListener, mListener.mItem.subscription_ticket);
		}
		if (GUI.Button(new Rect(nXStart + nWidth + 10, nYStart + 4 * nWidth + 40, nWidth + 50, nHeight), "QuerySubscription", gUIStyle))
		{
			Viveport.Core.Logger.Log("QuerySubscription");
			bIsDuplicatedSubscription = false;
			Viveport.IAPurchase.QuerySubscription(mListener, mListener.mItem.subscription_ticket);
		}
		if (GUI.Button(new Rect(nXStart + nWidth + 10, nYStart + 5 * nWidth + 50, nWidth + 50, nHeight), "CancelSubscription", gUIStyle))
		{
			Viveport.Core.Logger.Log("CancelSubscription");
			Viveport.IAPurchase.CancelSubscription(mListener, mListener.mItem.subscription_ticket);
		}
		if (GUI.Button(new Rect(nXStart + nWidth + 10, nYStart + 6 * nWidth + 50, nWidth + 50, nHeight), "QueryPurchaseList", gUIStyle))
		{
			Viveport.Core.Logger.Log("QueryPurchaseList");
			Viveport.IAPurchase.Query(mListener);
		}
		if (GUI.Button(new Rect(nXStart + nWidth + 10, nYStart + 7 * nWidth + 40, nWidth + 50, nHeight), "QuerySubscriptionList", gUIStyle))
		{
			Viveport.Core.Logger.Log("QuerySubscriptionList");
			Viveport.IAPurchase.QuerySubscriptionList(mListener);
		}
	}

	private static void InitStatusHandler(int nResult)
	{
		bInit_Done = true;
		bShutdown_Done = false;
		Viveport.Core.Logger.Log("InitStatusHandler: " + nResult);
	}

	private static void ShutdownStatusHandler(int nResult)
	{
		bShutdown_Done = true;
		bInit_Done = false;
		bIsReady_Done = false;
		Viveport.Core.Logger.Log("ShutdownStatusHandler: " + nResult);
	}
}
public class ViveportDemo_MainThreadDispatcher : MonoBehaviour
{
	private class ThisCallbackWillNotWorkFine : Viveport.IAPurchase.IAPurchaseListener
	{
		public override void OnSuccess(string pchCurrencyName)
		{
			myApiResultText.text = $"The Currency is: {pchCurrencyName}";
		}
	}

	private class ThisCallbackWillWorkFine_01 : Viveport.IAPurchase.IAPurchaseListener
	{
		public override void OnSuccess(string pchCurrencyName)
		{
			Action action = delegate
			{
				myApiResultText.text = $"The Currency is: {pchCurrencyName}";
			};
			MainThreadDispatcher.Instance().Enqueue(action);
		}
	}

	private class ThisCallbackWillWorkFine_02 : Viveport.IAPurchase.IAPurchaseListener
	{
		public override void OnSuccess(string pchCurrencyName)
		{
			MainThreadDispatcher.Instance().Enqueue(ShowResult(pchCurrencyName));
		}

		private IEnumerator ShowResult(string pchCurrencyName)
		{
			myApiResultText.text = $"The Currency is: {pchCurrencyName}";
			yield return null;
		}
	}

	public Text uiText;

	private static Text myApiResultText;

	private static readonly string appId = "Your APP ID";

	private static readonly string apiKey = "Your API KEY";

	private void Start()
	{
		myApiResultText = uiText;
		Viveport.Api.Init(InitCallback, appId);
	}

	private void InitCallback(int errorCode)
	{
		if (errorCode == 0)
		{
			Viveport.IAPurchase.IsReady(new ThisCallbackWillWorkFine_01(), apiKey);
		}
	}
}
public class ViveportDemo_Subscription : MonoBehaviour
{
	private int nWidth = 180;

	private int nHeight = 100;

	private static bool bIsReady = false;

	private int nXStart = 10;

	private int nYStart = 35;

	private static string APP_ID = "76d0898e-8772-49a9-aa55-1ec251a21686";

	private static bool bInit = true;

	private void Start()
	{
		Viveport.Api.Init(InitStatusHandler, APP_ID);
	}

	private void OnGUI()
	{
		GUIStyle gUIStyle = new GUIStyle("button");
		gUIStyle.fontSize = 23;
		if (!bInit)
		{
			GUI.contentColor = Color.white;
		}
		else
		{
			GUI.contentColor = Color.gray;
		}
		if (GUI.Button(new Rect(nXStart, nYStart, nWidth, nHeight), "Init", gUIStyle) && !bInit)
		{
			Viveport.Api.Init(InitStatusHandler, APP_ID);
		}
		if (bInit)
		{
			GUI.contentColor = Color.white;
		}
		else
		{
			GUI.contentColor = Color.grey;
		}
		if (GUI.Button(new Rect(nXStart + (nWidth + 10), nYStart, nWidth, nHeight), "Shutdown", gUIStyle) && bInit)
		{
			Viveport.Api.Shutdown(ShutdownHandler);
		}
		if (GUI.Button(new Rect(nXStart + 2 * (nWidth + 10), nYStart, nWidth, nHeight), "IsReady", gUIStyle) && bInit)
		{
			Viveport.Subscription.IsReady(IsReadyHandler);
		}
		if (GUI.Button(new Rect(nXStart + 3 * (nWidth + 10), nYStart, nWidth, nHeight), "GetUserStatus", gUIStyle) && bInit && bIsReady)
		{
			SubscriptionStatus userStatus = Viveport.Subscription.GetUserStatus();
			string text = (userStatus.Platforms.Contains(SubscriptionStatus.Platform.Windows) ? "true" : "false");
			string text2 = (userStatus.Platforms.Contains(SubscriptionStatus.Platform.Android) ? "true" : "false");
			string text3 = "";
			text3 = userStatus.Type switch
			{
				SubscriptionStatus.TransactionType.Unknown => "Unknown", 
				SubscriptionStatus.TransactionType.Paid => "Paid", 
				SubscriptionStatus.TransactionType.Redeem => "Redeem", 
				SubscriptionStatus.TransactionType.FreeTrial => "FreeTrial", 
				_ => "Unknown", 
			};
			Viveport.Core.Logger.Log("User is a Windows subscriber: " + text + ".  User is a Android subscriber: " + text2 + ".  transactionType :" + text3);
		}
	}

	private static void InitStatusHandler(int nResult)
	{
		if (nResult == 0)
		{
			bInit = true;
			bIsReady = false;
			Viveport.Core.Logger.Log("InitStatusHandler is successful");
		}
		else
		{
			bInit = false;
			Viveport.Core.Logger.Log("InitStatusHandler error : " + nResult);
		}
	}

	private static void ShutdownHandler(int nResult)
	{
	}

	private static void IsReadyHandler(int nResult, string message)
	{
		if (nResult == 0)
		{
			Viveport.Core.Logger.Log("Subscription is ready");
			bIsReady = true;
			return;
		}
		Viveport.Core.Logger.Log("Subscription IsReadyHandler error: " + nResult + " Message : " + message);
	}
}
[RequireComponent(typeof(MeshFilter), typeof(MeshRenderer))]
public class Beam : MonoBehaviour
{
	public float startWidth = 0.01f;

	public float endWidth = 0.02f;

	public float startOffset = 0.03f;

	public float endOffset = 10f;

	public int count = 3;

	public bool updateEveryFrame;

	public bool makeTail = true;

	private int maxUVAngle = 30;

	private const float epsilon = 0.001f;

	public List<Vector3> vertices;

	public List<Vector2> uvs;

	public List<Vector3> normals;

	public List<int> indices;

	public Vector3 position;

	private void Validate()
	{
		if (startWidth < 0.001f)
		{
			startWidth = 0.001f;
		}
		if (endWidth < 0.001f)
		{
			endWidth = 0.001f;
		}
		if (startOffset < 0.001f)
		{
			startOffset = 0.001f;
		}
		if (endOffset < 0.002f)
		{
			endOffset = 0.002f;
		}
		if (endOffset < startOffset)
		{
			endOffset = startOffset + 0.001f;
		}
		if (count < 3)
		{
			count = 3;
		}
		int num = 360 / count;
		if (num > 30)
		{
			maxUVAngle = 30;
		}
		else
		{
			maxUVAngle = num;
		}
	}

	private void OnEnable()
	{
		Validate();
		GetComponent<MeshFilter>().mesh = createMesh();
		GetComponent<MeshRenderer>().enabled = true;
	}

	public void Update()
	{
		if (updateEveryFrame)
		{
			Validate();
			GetComponent<MeshFilter>().mesh = createMesh();
		}
	}

	private Mesh createMesh()
	{
		Mesh mesh = new Mesh();
		int num = count + 1;
		int capacity = num * 2 + (makeTail ? 1 : 0);
		int capacity2 = num * 6 + (makeTail ? (count * 3) : 0);
		vertices = new List<Vector3>(capacity);
		uvs = new List<Vector2>(capacity);
		normals = new List<Vector3>(capacity);
		indices = new List<int>(capacity2);
		Matrix4x4 matrix4x = default(Matrix4x4);
		Matrix4x4 matrix4x2 = default(Matrix4x4);
		for (int i = 0; i < num; i++)
		{
			int num2 = (int)((float)i * 360f / (float)count);
			int num3 = i * maxUVAngle / count;
			matrix4x.SetTRS(new Vector3(0f, 0f, 0f), Quaternion.AngleAxis(num2, new Vector3(0f, 0f, 1f)), new Vector3(1f, 1f, 1f));
			matrix4x2.SetTRS(new Vector3(0f, 0f, 0f), Quaternion.AngleAxis(num3, new Vector3(0f, 0f, 1f)), new Vector3(1f, 1f, 1f));
			vertices.Add(matrix4x.MultiplyVector(new Vector3(0f, startWidth, startOffset)));
			uvs.Add(new Vector2(0.5f, 0.5f));
			normals.Add(matrix4x.MultiplyVector(new Vector3(0f, 1f, 0f)).normalized);
			vertices.Add(matrix4x.MultiplyVector(new Vector3(0f, endWidth, endOffset)));
			Vector2 item = matrix4x2.MultiplyVector(new Vector3(0f, 0.5f, 0f));
			item.x += 0.5f;
			item.y += 0.5f;
			uvs.Add(item);
			normals.Add(matrix4x.MultiplyVector(new Vector3(0f, 1f, 0f)).normalized);
		}
		for (int j = 0; j < count; j++)
		{
			int item2 = j * 2;
			int item3 = j * 2 + 1;
			int item4 = j * 2 + 2;
			int item5 = j * 2 + 3;
			indices.Add(item2);
			indices.Add(item5);
			indices.Add(item3);
			indices.Add(item2);
			indices.Add(item4);
			indices.Add(item5);
		}
		if (makeTail)
		{
			vertices.Add(new Vector3(0f, 0f, 0f));
			uvs.Add(new Vector2(0.5f, 0.5f));
			normals.Add(new Vector3(0f, 0f, 0f));
			int item6 = count * 2;
			for (int k = 0; k < count; k++)
			{
				int num4 = k * 2;
				indices.Add(item6);
				indices.Add(num4 + 2);
				indices.Add(num4);
			}
		}
		mesh.vertices = vertices.ToArray();
		mesh.SetUVs(0, uvs);
		mesh.SetUVs(1, uvs);
		mesh.normals = normals.ToArray();
		mesh.SetIndices(indices.ToArray(), MeshTopology.Triangles, 0);
		mesh.name = "Beam";
		return mesh;
	}
}
internal class WaveVR_COMMITINFO
{
	public static string wavevr_version = "\ncommit e2b72ee11611286f5845a3fb99a242dfeb92b02b\n";
}
public class ControllerConnectionStateReactor : MonoBehaviour
{
	private static string LOG_TAG = "WaveVRConnReactor";

	public WVR_DeviceType type;

	private bool connected;

	public List<GameObject> targetGameObjects = new List<GameObject>();

	private bool mFocusCapturedBySystem;

	private void PrintDebugLog(string msg)
	{
		WVR_Log.Log.d(LOG_TAG, string.Concat(type, ", ", msg));
	}

	private void OnEnable()
	{
		if (!UnityEngine.Application.isEditor)
		{
			WaveVR_Utils.Event.Listen(WaveVR_Utils.Event.DEVICE_CONNECTED, onDeviceConnected);
			if (checkConnection() != connected)
			{
				connected = !connected;
			}
			setActive(connected && !mFocusCapturedBySystem);
		}
	}

	private void OnDisable()
	{
		if (!UnityEngine.Application.isEditor)
		{
			WaveVR_Utils.Event.Remove(WaveVR_Utils.Event.DEVICE_CONNECTED, onDeviceConnected);
		}
	}

	private void Update()
	{
		if (connected)
		{
			bool flag = false;
			if (WaveVR.Instance.Initialized)
			{
				flag = WaveVR.Instance.FocusCapturedBySystem;
			}
			if (flag != mFocusCapturedBySystem)
			{
				mFocusCapturedBySystem = flag;
				PrintDebugLog("Focus is " + (mFocusCapturedBySystem ? " captured by system" : " not captured"));
				setActive(!mFocusCapturedBySystem);
			}
		}
	}

	private bool checkConnection()
	{
		return WaveVR.Instance.getDeviceByType(type).connected;
	}

	private void setActive(bool active)
	{
		foreach (GameObject targetGameObject in targetGameObjects)
		{
			if (targetGameObject != null)
			{
				targetGameObject.SetActive(active);
			}
		}
	}

	private void onDeviceConnected(params object[] args)
	{
		bool flag = false;
		WVR_DeviceType wVR_DeviceType = type;
		WaveVR.Device deviceByType = WaveVR.Instance.getDeviceByType(type);
		flag = deviceByType.connected;
		wVR_DeviceType = deviceByType.type;
		PrintDebugLog(string.Concat("onDeviceConnected() ", wVR_DeviceType, " is ", flag ? "connected" : "disconnected", ", left-handed? ", WaveVR_Controller.IsLeftHanded.ToString()));
		if (connected != flag)
		{
			connected = flag;
			setActive(connected && !mFocusCapturedBySystem);
		}
	}
}
[RequireComponent(typeof(FadeManger))]
public class ControllerFadeManager : MonoBehaviour
{
	private FadeManger fadeManager;

	private float AngleHide = 15f;

	private void Start()
	{
		fadeManager = GetComponent<FadeManger>();
		MeshRenderer[] componentsInChildren = GetComponentsInChildren<MeshRenderer>();
		fadeManager.Materials = new List<Material>();
		MeshRenderer[] array = componentsInChildren;
		foreach (MeshRenderer meshRenderer in array)
		{
			if (!(meshRenderer == null))
			{
				Material material = meshRenderer.material;
				if (material != null && material.shader.name == "WaveVR/UnlitControllerShader" && material.HasProperty("_FadeAlpha") && !fadeManager.Materials.Contains(material))
				{
					fadeManager.Materials.Add(material);
				}
			}
		}
	}

	private void Update()
	{
		if (fadeManager != null)
		{
			if (Mathf.Acos(Vector3.Dot(base.transform.forward, Vector3.up)) * 57.29578f < AngleHide)
			{
				fadeManager.Fade(fadeOut: true);
			}
			else
			{
				fadeManager.Fade(fadeOut: false);
			}
		}
	}
}
public class WaveVR_EventHandler : MonoBehaviour, IPointerEnterHandler, IEventSystemHandler, IPointerExitHandler, IPointerDownHandler, IBeginDragHandler, IDragHandler, IEndDragHandler, IDropHandler, IPointerUpHandler, IPointerHoverHandler
{
	private const string LOG_TAG = "WaveVR_EventHandler";

	private WaitForEndOfFrame waitForEndOfFrame = new WaitForEndOfFrame();

	private Vector3 goPosition;

	private float goPositionZ;

	private void TeleportRandomly()
	{
		Vector3 onUnitSphere = UnityEngine.Random.onUnitSphere;
		onUnitSphere.y = Mathf.Clamp(onUnitSphere.y, 0.5f, 1f);
		onUnitSphere.z = Mathf.Clamp(onUnitSphere.z, 3f, 10f);
		float num = 2f * UnityEngine.Random.value + 1.5f;
		base.transform.localPosition = onUnitSphere * num;
	}

	private void Rotate()
	{
		base.transform.Rotate(72f * (10f * Time.deltaTime), 0f, 0f);
		base.transform.Rotate(0f, 72f * (10f * Time.deltaTime), 0f);
	}

	public void OnPointerEnter(PointerEventData eventData)
	{
		WVR_Log.Log.d("WaveVR_EventHandler", "OnPointerEnter, camera: " + eventData.enterEventCamera);
	}

	public void OnPointerExit(PointerEventData eventData)
	{
	}

	public void OnPointerDown(PointerEventData eventData)
	{
		WVR_Log.Log.d("WaveVR_EventHandler", "OnPointerDown()");
	}

	public void OnPointerUp(PointerEventData eventData)
	{
		WVR_Log.Log.d("WaveVR_EventHandler", "OnPointerUp()");
	}

	public void OnBeginDrag(PointerEventData eventData)
	{
		goPosition = base.transform.position;
		goPositionZ = base.transform.position.z;
		WVR_Log.Log.d("WaveVR_EventHandler", "OnBeginDrag() position: " + goPosition);
		StartCoroutine("TrackPointer");
	}

	public void OnDrag(PointerEventData eventData)
	{
		Camera enterEventCamera = eventData.enterEventCamera;
		if (enterEventCamera != null)
		{
			goPosition = enterEventCamera.ScreenToWorldPoint(new Vector3(eventData.position.x, eventData.position.y, goPositionZ));
		}
	}

	public void OnEndDrag(PointerEventData eventData)
	{
		WVR_Log.Log.d("WaveVR_EventHandler", "OnEndDrag() position: " + goPosition);
		StopCoroutine("TrackPointer");
	}

	public void OnDrop(PointerEventData eventData)
	{
		Camera enterEventCamera = eventData.enterEventCamera;
		goPosition = enterEventCamera.ScreenToWorldPoint(new Vector3(eventData.position.x, eventData.position.y, goPositionZ));
		WVR_Log.Log.i("WaveVR_EventHandler", "WaveVR_EventHandler::OnDrop, position: " + goPosition);
		TeleportRandomly();
	}

	public void OnPointerHover(PointerEventData eventData)
	{
		base.transform.Rotate(0f, 12f * (10f * Time.deltaTime), 0f);
	}

	private IEnumerator TrackPointer()
	{
		while (true)
		{
			yield return waitForEndOfFrame;
			base.transform.position = goPosition;
		}
	}
}
public class WaveVR_Raycast : MonoBehaviour
{
	private static string LOG_TAG = "WaveVR_Raycast";

	public WVR_DeviceType index = WVR_DeviceType.WVR_DeviceType_Controller_Right;

	public bool ListenToDevice = true;

	public bool AddLineRenderer = true;

	public GameObject raycastObject;

	public float distance;

	private LineRenderer lr;

	private void PrintDebugLog(string msg)
	{
		WVR_Log.Log.d(LOG_TAG, string.Concat(index, ", ", msg));
	}

	private void initLineRenderer()
	{
		lr = base.gameObject.AddComponent<LineRenderer>();
		lr.startWidth = 0.02f;
		lr.endWidth = 0.01f;
		lr.material = new Material(Shader.Find("Particles/Additive"));
		lr.useWorldSpace = true;
		lr.enabled = !ListenToDevice;
	}

	private void shotRaycast()
	{
		Vector3 position = base.transform.position;
		Vector3 vector = base.transform.TransformDirection(new Vector3(0f, 0f, 1f));
		float num = 10f;
		if (Physics.Raycast(position, vector, out var hitInfo))
		{
			raycastObject = hitInfo.collider.gameObject;
			distance = hitInfo.distance;
			return;
		}
		RaycastHit2D raycastHit2D = Physics2D.Raycast(position, vector, num);
		if ((bool)raycastHit2D.collider)
		{
			raycastObject = raycastHit2D.collider.gameObject;
			distance = raycastHit2D.distance;
		}
		else
		{
			raycastObject = null;
		}
	}

	private void updateLineRenderer()
	{
		Vector3 position = base.transform.position;
		Vector3 vector = base.transform.TransformDirection(new Vector3(0f, 0f, 1f));
		float num = 10f;
		Vector3 position2 = position;
		Vector3 position3 = vector * num;
		lr.SetPosition(0, position2);
		lr.SetPosition(1, position3);
		lr.startColor = Color.yellow;
		lr.endColor = Color.yellow;
	}

	private void onDeviceConnected(params object[] args)
	{
		WVR_DeviceType wVR_DeviceType = (WVR_DeviceType)args[0];
		bool flag = (bool)args[1];
		if (WaveVR_Controller.Input(index).DeviceType == wVR_DeviceType)
		{
			PrintDebugLog(string.Concat("onDeviceConnected() ", wVR_DeviceType, " is ", flag ? "connected" : "disconnected", ", left-handed? ", WaveVR_Controller.IsLeftHanded.ToString()));
			if (lr != null)
			{
				lr.enabled = flag;
			}
		}
	}

	private void OnRenderModelLoaded(params object[] args)
	{
		if ((int)args[2] == (int)index)
		{
			bool flag = (bool)args[1];
			WVR_Log.Log.i(LOG_TAG, "set lr.enabled = " + flag);
			if (lr != null)
			{
				lr.enabled = flag;
			}
		}
	}

	private void Start()
	{
		if (AddLineRenderer)
		{
			initLineRenderer();
		}
	}

	private void Update()
	{
		shotRaycast();
		if (AddLineRenderer && lr.enabled)
		{
			updateLineRenderer();
		}
	}

	private void onDestroy()
	{
		UnityEngine.Object.Destroy(GetComponent<Renderer>().material);
	}

	private void OnEnable()
	{
		if (ListenToDevice)
		{
			if (WaveVR.Instance.Initialized)
			{
				lr.enabled = WaveVR.Instance.getDeviceByType(index).connected;
			}
			else
			{
				lr.enabled = false;
			}
			WaveVR_Utils.Event.Listen(WaveVR_Utils.Event.DEVICE_CONNECTED, onDeviceConnected);
			WaveVR_Utils.Event.Listen("render_model_loaded", OnRenderModelLoaded);
		}
	}

	private void OnDisable()
	{
		if (ListenToDevice)
		{
			WaveVR_Utils.Event.Remove(WaveVR_Utils.Event.DEVICE_CONNECTED, onDeviceConnected);
			WaveVR_Utils.Event.Remove("render_model_loaded", OnRenderModelLoaded);
		}
	}
}
public class FadeManger : MonoBehaviour
{
	public float FadeTime = 0.2f;

	public List<Material> Materials;

	private float InternalFadeTime = 0.2f;

	private bool isInTransition;

	private bool IsFadeOut;

	private float alpha = 1f;

	public void Fade(bool fadeOut)
	{
		if (isInTransition)
		{
			if (IsFadeOut != fadeOut)
			{
				IsFadeOut = fadeOut;
				alpha = 1f - alpha;
			}
		}
		else if (IsFadeOut != fadeOut)
		{
			isInTransition = true;
			IsFadeOut = fadeOut;
			InternalFadeTime = FadeTime;
			alpha = (IsFadeOut ? 1 : 0);
		}
	}

	private void Update()
	{
		if (!isInTransition || Materials == null || Materials.Count == 0)
		{
			return;
		}
		if (IsFadeOut)
		{
			alpha -= Time.deltaTime * (1f / InternalFadeTime);
			if (alpha < 0f)
			{
				alpha = 0f;
				isInTransition = false;
			}
		}
		else
		{
			alpha += Time.deltaTime * (1f / InternalFadeTime);
			if (alpha > 1f)
			{
				isInTransition = false;
				alpha = 1f;
			}
		}
		foreach (Material material in Materials)
		{
			material.SetFloat("_FadeAlpha", alpha);
		}
	}
}
public class FollowTransform : MonoBehaviour
{
	public enum DOF
	{
		TRACK_6DOF,
		TRACK_3DOF
	}

	public GameObject target;

	public DOF howTargetTrackHMD = DOF.TRACK_3DOF;

	public bool followPostion = true;

	public bool followRotation;

	private WaveVR_DevicePoseTracker inverter;

	private void OnEnable()
	{
		if (target == null)
		{
			UnityEngine.Debug.LogError("FollowTransform havn't set a target");
			base.enabled = false;
		}
		else if (target.GetComponent<Rigidbody>() == null)
		{
			UnityEngine.Debug.LogError("FollowTransform's target didn't have a Rigidbody");
			base.enabled = false;
		}
		else
		{
			WaveVR_Utils.Event.Listen(WaveVR_Utils.Event.AFTER_NEW_POSES, OnAfterNewPoses);
			Expand();
		}
	}

	private void OnDisable()
	{
		WaveVR_Utils.Event.Remove(WaveVR_Utils.Event.AFTER_NEW_POSES, OnAfterNewPoses);
	}

	private void Expand()
	{
		inverter = target.GetComponentInChildren<WaveVR_DevicePoseTracker>();
		if (inverter == null)
		{
			GameObject gameObject = new GameObject("OriginPredictor");
			inverter = gameObject.AddComponent<WaveVR_DevicePoseTracker>();
			gameObject.transform.SetParent(target.transform, worldPositionStays: false);
		}
		inverter.type = WaveVR_Controller.EDeviceType.Head;
		if (howTargetTrackHMD == DOF.TRACK_3DOF)
		{
			inverter.trackPosition = false;
		}
		else
		{
			inverter.trackPosition = true;
		}
		inverter.inversePosition = true;
		inverter.inverseRotation = true;
	}

	private void OnAfterNewPoses(params object[] args)
	{
		if (!(inverter == null))
		{
			if (followPostion)
			{
				base.transform.localPosition = inverter.transform.position;
				target.transform.localPosition = Vector3.zero;
			}
			if (followRotation)
			{
				base.transform.localRotation = inverter.transform.rotation;
				target.transform.localRotation = Quaternion.identity;
			}
		}
	}
}
public enum EGazeTriggerMouseKey
{
	LeftClick,
	RightClick,
	MiddleClick
}
public enum EGazeTriggerButton
{
	System = 0,
	Menu = 1,
	Grip = 2,
	DPad_Left = 3,
	DPad_Up = 4,
	DPad_Right = 5,
	DPad_Down = 6,
	Volume_Up = 7,
	Volume_Down = 8,
	DigitalTrigger = 9,
	Touchpad = 16,
	Trigger = 17
}
public enum EGazeTriggerDevice
{
	HMD,
	NonDominantController,
	DominantController,
	HMDWithNonDominantController,
	HMDWithDominantController,
	HMDWithTwoControllers
}
public enum EGazeInputEvent
{
	PointerDown,
	PointerClick,
	PointerSubmit
}
[Obsolete("This script is obsoleted, please use WaveVR_GazeInputModule instead.")]
public class GazeInputModule : PointerInputModule
{
	private static string LOG_TAG = "GazeInputModule";

	public bool progressRate;

	public float RateTextZPosition = 0.5f;

	public bool progressCounter;

	public float CounterTextZPosition = 0.5f;

	public float TimeToGaze = 2f;

	public EGazeInputEvent InputEvent = EGazeInputEvent.PointerSubmit;

	public GameObject Head;

	public bool BtnControl;

	[HideInInspector]
	public EGazeTriggerDevice GazeDevice;

	[HideInInspector]
	public EGazeTriggerButton ButtonToTrigger = EGazeTriggerButton.Trigger;

	[HideInInspector]
	public bool WithTimeGaze;

	private bool defWithTimeGaze;

	private bool btnPressDown;

	private bool btnPressed;

	private bool btnPressUp;

	private bool HmdEnterPressDown;

	private float currUnscaledTime;

	private PointerEventData pointerData;

	private float gazeTime;

	private Text progressText;

	private Text counterText;

	private WaveVR_Reticle gazePointer;

	private GameObject percentCanvas;

	private GameObject counterCanvas;

	private bool EnableGaze;

	private Canvas[] sceneCanvases;

	private bool focusCapturedBySystem;

	private void PrintDebugLog(string msg)
	{
		WVR_Log.Log.d(LOG_TAG, msg, logInEditor: true);
	}

	public void SetWithTimeGaze(bool withTimer)
	{
		if (WVR_Log.Log.gpl.Print)
		{
			WVR_Log.Log.d(LOG_TAG, "SetWithTimeGaze() withTimer: " + withTimer, logInEditor: true);
		}
		WithTimeGaze = withTimer;
		defWithTimeGaze = WithTimeGaze;
	}

	private Vector3 GetIntersectionPosition(Camera cam, RaycastResult raycastResult)
	{
		if (cam == null)
		{
			return Vector3.zero;
		}
		float num = raycastResult.distance + cam.nearClipPlane;
		return cam.transform.position + cam.transform.forward * num;
	}

	private void CastToCenterOfScreen()
	{
		if (pointerData == null)
		{
			pointerData = new PointerEventData(base.eventSystem);
		}
		pointerData.Reset();
		pointerData.position = new Vector2(0.5f * (float)Screen.width, 0.5f * (float)Screen.height);
		if (Head != null)
		{
			Camera component = Head.GetComponent<Camera>();
			GraphicRaycast(component);
			if (pointerData.pointerCurrentRaycast.gameObject == null)
			{
				PhysicsRaycaster component2 = Head.GetComponent<PhysicsRaycaster>();
				PhysicRaycast(component2);
			}
		}
	}

	private void GraphicRaycast(Camera event_camera)
	{
		List<RaycastResult> list = new List<RaycastResult>();
		pointerData.pointerCurrentRaycast = default(RaycastResult);
		Canvas[] array = sceneCanvases;
		foreach (Canvas canvas in array)
		{
			GraphicRaycaster component = canvas.GetComponent<GraphicRaycaster>();
			if (component == null)
			{
				continue;
			}
			canvas.worldCamera = event_camera;
			component.Raycast(pointerData, list);
			RaycastResult raycastResult = BaseInputModule.FindFirstRaycast(list);
			pointerData.pointerCurrentRaycast = raycastResult;
			list.Clear();
			_ = raycastResult.module != null;
			if (raycastResult.gameObject != null)
			{
				if (raycastResult.worldPosition == Vector3.zero)
				{
					raycastResult.worldPosition = GetIntersectionPosition(raycastResult.module.eventCamera, raycastResult);
					pointerData.pointerCurrentRaycast = raycastResult;
				}
				pointerData.position = raycastResult.screenPosition;
				break;
			}
		}
	}

	private void PhysicRaycast(PhysicsRaycaster raycaster)
	{
		if (raycaster == null)
		{
			return;
		}
		List<RaycastResult> list = new List<RaycastResult>();
		raycaster.Raycast(pointerData, list);
		RaycastResult raycastResult = BaseInputModule.FindFirstRaycast(list);
		pointerData.pointerCurrentRaycast = raycastResult;
		if (raycastResult.gameObject != null)
		{
			if (raycastResult.worldPosition == Vector3.zero)
			{
				raycastResult.worldPosition = GetIntersectionPosition(raycastResult.module.eventCamera, raycastResult);
				pointerData.pointerCurrentRaycast = raycastResult;
			}
			pointerData.position = raycastResult.screenPosition;
		}
	}

	private GameObject GetCurrentGameObject(PointerEventData pointerData)
	{
		if (pointerData != null && pointerData.enterEventCamera != null)
		{
			return pointerData.pointerCurrentRaycast.gameObject;
		}
		return null;
	}

	private Vector3 GetIntersectionPosition(PointerEventData pointerData)
	{
		if (null == pointerData.enterEventCamera)
		{
			return Vector3.zero;
		}
		float num = pointerData.pointerCurrentRaycast.distance + pointerData.enterEventCamera.nearClipPlane;
		return pointerData.enterEventCamera.transform.position + pointerData.enterEventCamera.transform.forward * num;
	}

	private void UpdateProgressDistance(PointerEventData pointerEvent)
	{
		Vector3 intersectionPosition = GetIntersectionPosition(pointerEvent);
		if (!(gazePointer == null))
		{
			if (percentCanvas != null)
			{
				Vector3 localPosition = new Vector3(percentCanvas.transform.localPosition.x, percentCanvas.transform.localPosition.y, intersectionPosition.z - ((RateTextZPosition >= 0f) ? RateTextZPosition : 0f));
				percentCanvas.transform.localPosition = localPosition;
			}
			if (counterCanvas != null)
			{
				Vector3 localPosition2 = new Vector3(counterCanvas.transform.localPosition.x, counterCanvas.transform.localPosition.y, intersectionPosition.z - ((CounterTextZPosition >= 0f) ? CounterTextZPosition : 0f));
				counterCanvas.transform.localPosition = localPosition2;
			}
		}
	}

	private void UpdateReticle(GameObject preGazedObject, PointerEventData pointerEvent)
	{
		if (gazePointer == null)
		{
			return;
		}
		GameObject currentGameObject = GetCurrentGameObject(pointerEvent);
		Vector3 intersectionPosition = GetIntersectionPosition(pointerEvent);
		bool isInteractive = pointerEvent.pointerPress != null || ExecuteEvents.GetEventHandler<IPointerClickHandler>(currentGameObject) != null;
		if (currentGameObject == preGazedObject)
		{
			if (!(currentGameObject != null))
			{
				gazePointer.OnGazeExit(pointerEvent.enterEventCamera, preGazedObject);
				return;
			}
			gazePointer.OnGazeStay(pointerEvent.enterEventCamera, currentGameObject, intersectionPosition, isInteractive);
		}
		else
		{
			if (preGazedObject != null)
			{
				gazePointer.OnGazeExit(pointerEvent.enterEventCamera, preGazedObject);
			}
			if (currentGameObject != null)
			{
				gazePointer.OnGazeEnter(pointerEvent.enterEventCamera, currentGameObject, intersectionPosition, isInteractive);
			}
		}
		UpdateProgressDistance(pointerEvent);
	}

	private void UpdateButtonStates()
	{
		btnPressDown = Input.GetMouseButtonDown(0);
		btnPressed = Input.GetMouseButton(0);
		btnPressUp = Input.GetMouseButtonUp(0);
		if (GazeDevice == EGazeTriggerDevice.HMD || GazeDevice == EGazeTriggerDevice.HMDWithNonDominantController || GazeDevice == EGazeTriggerDevice.HMDWithDominantController || GazeDevice == EGazeTriggerDevice.HMDWithTwoControllers)
		{
			btnPressDown |= WaveVR_Controller.Input(WaveVR_Controller.EDeviceType.Head).GetPressDown((WVR_InputId)ButtonToTrigger);
			btnPressed |= WaveVR_Controller.Input(WaveVR_Controller.EDeviceType.Head).GetPress((WVR_InputId)ButtonToTrigger);
			btnPressUp |= WaveVR_Controller.Input(WaveVR_Controller.EDeviceType.Head).GetPressUp((WVR_InputId)ButtonToTrigger);
		}
		if (GazeDevice == EGazeTriggerDevice.NonDominantController || GazeDevice == EGazeTriggerDevice.HMDWithNonDominantController || GazeDevice == EGazeTriggerDevice.HMDWithTwoControllers)
		{
			btnPressDown |= WaveVR_Controller.Input(WaveVR_Controller.EDeviceType.NonDominant).GetPressDown((WVR_InputId)ButtonToTrigger);
			btnPressed |= WaveVR_Controller.Input(WaveVR_Controller.EDeviceType.NonDominant).GetPress((WVR_InputId)ButtonToTrigger);
			btnPressUp |= WaveVR_Controller.Input(WaveVR_Controller.EDeviceType.NonDominant).GetPressUp((WVR_InputId)ButtonToTrigger);
		}
		if (GazeDevice == EGazeTriggerDevice.DominantController || GazeDevice == EGazeTriggerDevice.HMDWithDominantController || GazeDevice == EGazeTriggerDevice.HMDWithTwoControllers)
		{
			btnPressDown |= WaveVR_Controller.Input(WaveVR_Controller.EDeviceType.Dominant).GetPressDown((WVR_InputId)ButtonToTrigger);
			btnPressed |= WaveVR_Controller.Input(WaveVR_Controller.EDeviceType.Dominant).GetPress((WVR_InputId)ButtonToTrigger);
			btnPressUp |= WaveVR_Controller.Input(WaveVR_Controller.EDeviceType.Dominant).GetPressUp((WVR_InputId)ButtonToTrigger);
		}
	}

	private void UpdateProgressText()
	{
		if (!progressRate || Head == null)
		{
			if (progressText != null)
			{
				progressText.text = "";
			}
			return;
		}
		if (progressText == null)
		{
			Text[] componentsInChildren = Head.transform.GetComponentsInChildren<Text>();
			foreach (Text text in componentsInChildren)
			{
				if (text.gameObject.name.Equals("ProgressText"))
				{
					PrintDebugLog("UpdateProgressText() Found ProgressText.");
					progressText = text;
					break;
				}
			}
		}
		if (!(progressText == null))
		{
			if (pointerData.pointerCurrentRaycast.gameObject == null)
			{
				progressText.text = "";
				return;
			}
			float f = (currUnscaledTime - gazeTime) % TimeToGaze / TimeToGaze * 100f;
			progressText.text = Mathf.Floor(f) + "%";
		}
	}

	private void UpdateCounterText()
	{
		if (!progressCounter || Head == null)
		{
			if (counterText != null)
			{
				counterText.text = "";
			}
			return;
		}
		if (counterText == null)
		{
			Text[] componentsInChildren = Head.transform.GetComponentsInChildren<Text>();
			foreach (Text text in componentsInChildren)
			{
				if (text.gameObject.name.Equals("CounterText"))
				{
					PrintDebugLog("UpdateCounterText() Found CounterText.");
					counterText = text;
					break;
				}
			}
		}
		if (!(counterText == null))
		{
			if (pointerData.pointerCurrentRaycast.gameObject == null)
			{
				counterText.text = "";
			}
			else if (counterText != null)
			{
				counterText.text = Math.Round(TimeToGaze - (currUnscaledTime - gazeTime) % TimeToGaze, 2).ToString();
			}
		}
	}

	private void OnTriggeGaze()
	{
		GameObject gameObject = pointerData.pointerCurrentRaycast.gameObject;
		UpdateReticle(gameObject, pointerData);
		bool flag = false;
		HmdEnterPressDown = WaveVR_Controller.Input(WaveVR_Controller.EDeviceType.Head).GetPressDown(WVR_InputId.WVR_InputId_15);
		if (HmdEnterPressDown)
		{
			flag = true;
		}
		if (pointerData.pointerEnter != gameObject)
		{
			PrintDebugLog(string.Concat("OnTriggeGaze() pointerEnter: ", pointerData.pointerEnter, ", currentOverGO: ", gameObject));
			HandlePointerExitAndEnter(pointerData, gameObject);
			if (gameObject != null)
			{
				gazeTime = currUnscaledTime;
			}
		}
		else if (gameObject != null)
		{
			if (gazePointer != null)
			{
				gazePointer.triggerProgressBar(switchOn: true);
			}
			if (currUnscaledTime - gazeTime > TimeToGaze)
			{
				flag = true;
				gazeTime = currUnscaledTime;
			}
			else
			{
				float progressBarTime = (currUnscaledTime - gazeTime) / TimeToGaze * 100f;
				if (gazePointer != null)
				{
					gazePointer.setProgressBarTime(progressBarTime);
				}
			}
			if (BtnControl)
			{
				if (!WithTimeGaze)
				{
					gazeTime = currUnscaledTime;
					gazePointer.triggerProgressBar(switchOn: false);
				}
				UpdateButtonStates();
				if (btnPressDown)
				{
					flag = true;
					gazeTime = currUnscaledTime;
				}
			}
		}
		else if (gazePointer != null)
		{
			gazePointer.triggerProgressBar(switchOn: false);
		}
		pointerData.delta = Vector2.zero;
		pointerData.dragging = false;
		DeselectIfSelectionChanged(gameObject, pointerData);
		if (flag)
		{
			PrintDebugLog("OnTriggeGaze() selected " + gameObject.name);
			if (InputEvent == EGazeInputEvent.PointerClick)
			{
				ExecuteEvents.ExecuteHierarchy(gameObject, pointerData, ExecuteEvents.pointerClickHandler);
				pointerData.clickTime = currUnscaledTime;
			}
			else if (InputEvent == EGazeInputEvent.PointerDown)
			{
				pointerData.pressPosition = pointerData.position;
				pointerData.pointerPressRaycast = pointerData.pointerCurrentRaycast;
				ExecuteEvents.ExecuteHierarchy(ExecuteEvents.ExecuteHierarchy(gameObject, pointerData, ExecuteEvents.pointerDownHandler), pointerData, ExecuteEvents.pointerUpHandler);
			}
			else if (InputEvent == EGazeInputEvent.PointerSubmit)
			{
				ExecuteEvents.ExecuteHierarchy(gameObject, pointerData, ExecuteEvents.submitHandler);
			}
		}
	}

	private void GazeControl()
	{
		bool connected = WaveVR_Controller.Input(WaveVR_Controller.EDeviceType.Dominant).connected;
		bool connected2 = WaveVR_Controller.Input(WaveVR_Controller.EDeviceType.NonDominant).connected;
		if (WaveVR_ButtonList.Instance == null)
		{
			WithTimeGaze = true;
		}
		else
		{
			WithTimeGaze = defWithTimeGaze;
			if (!connected && !connected2 && !WaveVR_ButtonList.Instance.IsButtonAvailable(WaveVR_Controller.EDeviceType.Head, WVR_InputId.WVR_InputId_15))
			{
				WithTimeGaze = true;
			}
		}
		CastToCenterOfScreen();
		currUnscaledTime = Time.unscaledTime;
		OnTriggeGaze();
		UpdateProgressText();
		UpdateCounterText();
	}

	protected override void OnEnable()
	{
		base.OnEnable();
		EnableGaze = true;
		if (gazePointer == null)
		{
			if (Head == null)
			{
				if (WaveVR_InputModuleManager.Instance != null)
				{
					Head = WaveVR_InputModuleManager.Instance.gameObject;
				}
				else
				{
					Head = WaveVR_Render.Instance.gameObject;
				}
			}
			if (Head != null)
			{
				gazePointer = Head.GetComponentInChildren<WaveVR_Reticle>();
			}
		}
		if (gazePointer != null)
		{
			PrintDebugLog("OnEnable() Head: " + Head.name + ", enable pointer, percent and counter canvas.");
			percentCanvas = gazePointer.transform.Find("PercentCanvas").gameObject;
			counterCanvas = gazePointer.transform.Find("CounterCanvas").gameObject;
			ActivaeGazePointerCanvas(active: true);
		}
		sceneCanvases = UnityEngine.Object.FindObjectsOfType<Canvas>();
		defWithTimeGaze = WithTimeGaze;
	}

	protected override void OnDisable()
	{
		base.OnDisable();
		EnableGaze = false;
		ActivaeGazePointerCanvas(active: false);
		if (pointerData != null)
		{
			HandlePointerExitAndEnter(pointerData, null);
		}
	}

	private void ActivaeGazePointerCanvas(bool active)
	{
		if (gazePointer != null)
		{
			MeshRenderer componentInChildren = gazePointer.gameObject.GetComponentInChildren<MeshRenderer>();
			if (componentInChildren != null)
			{
				PrintDebugLog("ActivaeGazePointerCanvas() " + (active ? "enable" : "disable") + " pointer.");
				componentInChildren.enabled = active;
			}
			else
			{
				WVR_Log.Log.e(LOG_TAG, "ActivaeGazePointerCanvas() Oooooooooooooops! Why no MeshRender!!??");
			}
		}
		if (percentCanvas != null)
		{
			PrintDebugLog("ActivaeGazePointerCanvas() " + (active ? "enable" : "disable") + " percentCanvas.");
			percentCanvas.SetActive(active);
		}
		if (counterCanvas != null)
		{
			PrintDebugLog("ActivaeGazePointerCanvas() " + (active ? "enable" : "disable") + " counterCanvas.");
			counterCanvas.SetActive(active);
		}
	}

	public override void Process()
	{
		if (WaveVR.Instance.Initialized && focusCapturedBySystem != WaveVR.Instance.FocusCapturedBySystem)
		{
			focusCapturedBySystem = WaveVR.Instance.FocusCapturedBySystem;
			if (focusCapturedBySystem)
			{
				PrintDebugLog("Process() focus is captured by system.");
				EnableGaze = false;
				ActivaeGazePointerCanvas(active: false);
				if (pointerData != null)
				{
					HandlePointerExitAndEnter(pointerData, null);
				}
			}
			else
			{
				PrintDebugLog("Process() focus is gained.");
				EnableGaze = true;
				ActivaeGazePointerCanvas(active: true);
			}
		}
		if (EnableGaze)
		{
			GazeControl();
		}
	}
}
public class GOEventTrigger : MonoBehaviour
{
	private static string LOG_TAG = "WaveVR_GOEventTrigger";

	private Vector3 startPosition;

	private Color defaultColor = Color.gray;

	private Color changedColor = Color.red;

	private void Start()
	{
		startPosition = base.transform.localPosition;
		WVR_Log.Log.d(LOG_TAG, "Start()");
	}

	public void OnEnter()
	{
		WVR_Log.Log.d(LOG_TAG, "OnEnter");
		ChangeColor(change: true);
	}

	public void OnTrigger()
	{
		WVR_Log.Log.d(LOG_TAG, "OnTrigger");
		TeleportRandomly();
	}

	public void OnExit()
	{
		WVR_Log.Log.d(LOG_TAG, "OnExit");
		ChangeColor(change: false);
	}

	public void OnQuitGame()
	{
		WVR_Log.Log.d(LOG_TAG, "Quit Game");
		UnityEngine.Application.Quit();
	}

	public void OnGazeReset()
	{
		base.transform.localPosition = startPosition;
		ChangeColor(change: false);
	}

	public void OnShowButton()
	{
		WVR_Log.Log.d(LOG_TAG, "OnShowButton");
		base.transform.gameObject.SetActive(value: true);
	}

	public void OnHideButton()
	{
		WVR_Log.Log.d(LOG_TAG, "OnHideButton");
		base.transform.gameObject.SetActive(value: false);
	}

	public void ChangeColor(string color)
	{
		if (color.Equals("blue"))
		{
			GetComponent<Renderer>().material.color = Color.blue;
		}
		else if (color.Equals("cyan"))
		{
			GetComponent<Renderer>().material.color = Color.cyan;
		}
	}

	private void ChangeColor(bool change)
	{
		GetComponent<Renderer>().material.color = (change ? changedColor : defaultColor);
	}

	private void TeleportRandomly()
	{
		Vector3 onUnitSphere = UnityEngine.Random.onUnitSphere;
		onUnitSphere.y = Mathf.Clamp(onUnitSphere.y, 0.5f, 1f);
		onUnitSphere.z = Mathf.Clamp(onUnitSphere.z, 3f, 10f);
		float num = 2f * UnityEngine.Random.value + 1.5f;
		base.transform.localPosition = onUnitSphere * num;
	}
}
[RequireComponent(typeof(MeshFilter), typeof(MeshRenderer))]
public class IndicatorLine : MonoBehaviour
{
	private static string LOG_TAG = "IndicatorLine";

	[Header("Line customization")]
	[Range(0.0004f, 0.001f)]
	public float startWidth = 0.0004f;

	[Range(0.0004f, 0.001f)]
	public float endWidth = 0.0004f;

	[Range(0.02f, 0.2f)]
	public float lineLength = 0.03f;

	public Color lineColor = Color.white;

	public ButtonIndication.Alignment alignment;

	private float startOffset;

	private float endOffset = 0.03f;

	private int count = 12;

	private bool makeTail = true;

	private int maxUVAngle = 30;

	private int Count = -1;

	private int verticesCount = -1;

	private int indicesCount = -1;

	private List<Vector3> vertices = new List<Vector3>();

	private List<Vector2> uvs = new List<Vector2>();

	private List<Vector3> normals = new List<Vector3>();

	private List<int> indices = new List<int>();

	private List<Color32> colors = new List<Color32>();

	private Vector3 position;

	private Mesh updateMesh;

	private void Validate()
	{
		endOffset = lineLength;
		if (alignment == ButtonIndication.Alignment.LEFT)
		{
			endOffset *= -1f;
		}
		if (count < 3)
		{
			count = 3;
		}
		int num = 360 / count;
		if (num > 30)
		{
			maxUVAngle = 30;
		}
		else
		{
			maxUVAngle = num;
		}
	}

	private void OnEnable()
	{
		updateMesh = new Mesh();
		Count = count + 1;
		verticesCount = Count * 2 + (makeTail ? 1 : 0);
		indicesCount = Count * 6 + (makeTail ? (count * 3) : 0);
		uvs = new List<Vector2>(verticesCount);
		vertices = new List<Vector3>(verticesCount);
		normals = new List<Vector3>(verticesCount);
		indices = new List<int>(indicesCount);
		Validate();
	}

	private void Start()
	{
		updateMeshSettings();
	}

	public void Update()
	{
	}

	public void Circle(Texture2D tex, int cx, int cy, int r, Color col)
	{
		for (int i = 0; i <= r; i++)
		{
			int num = (int)Mathf.Ceil(Mathf.Sqrt(r * r - i * i));
			for (int j = 0; j <= num; j++)
			{
				int x = cx + i;
				int x2 = cx - i;
				int y = cy + j;
				int y2 = cy - j;
				tex.SetPixel(x, y, col);
				tex.SetPixel(x2, y, col);
				tex.SetPixel(x, y2, col);
				tex.SetPixel(x2, y2, col);
			}
		}
		tex.Apply();
	}

	public void updateMeshSettings()
	{
		WVR_Log.Log.d(LOG_TAG, "updateMeshSettings");
		Validate();
		GetComponent<MeshFilter>().mesh = createMesh();
		MeshRenderer component = GetComponent<MeshRenderer>();
		component.enabled = true;
		component.material = new Material(Shader.Find("Unlit/Texture"));
		Texture2D texture2D = new Texture2D(256, 256, TextureFormat.ARGB32, mipChain: false);
		Color color = lineColor;
		for (int i = 0; i < 256; i++)
		{
			for (int j = 0; j < 256; j++)
			{
				texture2D.SetPixel(i, j, color);
			}
		}
		texture2D.Apply();
		component.material.mainTexture = texture2D;
	}

	private Mesh createMesh()
	{
		updateMesh.Clear();
		uvs.Clear();
		vertices.Clear();
		normals.Clear();
		indices.Clear();
		colors.Clear();
		Matrix4x4 matrix4x = default(Matrix4x4);
		Matrix4x4 matrix4x2 = default(Matrix4x4);
		WVR_Log.Log.d(LOG_TAG, "Count: " + Count + ", count: " + count);
		for (int i = 0; i < Count; i++)
		{
			int num = (int)((float)i * 360f / (float)count);
			int num2 = i * maxUVAngle / count;
			matrix4x.SetTRS(new Vector3(0f, 0f, 0f), Quaternion.AngleAxis(num, new Vector3(1f, 0f, 0f)), new Vector3(1f, 1f, 1f));
			matrix4x2.SetTRS(new Vector3(0f, 0f, 0f), Quaternion.AngleAxis(num2, new Vector3(1f, 0f, 0f)), new Vector3(1f, 1f, 1f));
			vertices.Add(matrix4x.MultiplyVector(new Vector3(startOffset, 0f, startWidth)));
			uvs.Add(new Vector2(0.5f, 0.5f));
			colors.Add(lineColor);
			normals.Add(matrix4x.MultiplyVector(new Vector3(0f, 1f, 0f)).normalized);
			vertices.Add(matrix4x.MultiplyVector(new Vector3(endOffset, 0f, endWidth)));
			Vector2 item = matrix4x2.MultiplyVector(new Vector3(0f, 0.5f, 0f));
			item.x += 0.5f;
			item.y += 0.5f;
			uvs.Add(item);
			colors.Add(lineColor);
			normals.Add(matrix4x.MultiplyVector(new Vector3(0f, 1f, 0f)).normalized);
		}
		for (int j = 0; j < count; j++)
		{
			int item2 = j * 2;
			int item3 = j * 2 + 1;
			int item4 = j * 2 + 2;
			int item5 = j * 2 + 3;
			indices.Add(item2);
			indices.Add(item5);
			indices.Add(item3);
			indices.Add(item2);
			indices.Add(item4);
			indices.Add(item5);
		}
		if (makeTail)
		{
			vertices.Add(new Vector3(0f, 0f, 0f));
			colors.Add(lineColor);
			uvs.Add(new Vector2(0.5f, 0.5f));
			normals.Add(new Vector3(0f, 0f, 0f));
			int item6 = count * 2;
			for (int k = 0; k < count; k++)
			{
				int num3 = k * 2;
				indices.Add(item6);
				indices.Add(num3 + 2);
				indices.Add(num3);
			}
		}
		updateMesh.vertices = vertices.ToArray();
		updateMesh.colors32 = colors.ToArray();
		updateMesh.normals = normals.ToArray();
		updateMesh.SetIndices(indices.ToArray(), MeshTopology.Triangles, 0);
		updateMesh.name = "IndicatorLine";
		return updateMesh;
	}
}
public class QuaternionToEuler : MonoBehaviour
{
	public float x;

	public float y;

	public float z;

	public float w;

	private void Start()
	{
	}

	private void Update()
	{
		base.transform.localRotation = new Quaternion(x, y, z, w);
	}
}
public class QuitApplication : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
	}

	public void ExitGame()
	{
		UnityEngine.Application.Quit();
	}

	public void BackToUpLayer()
	{
		SceneManager.LoadScene(0);
	}
}
[RequireComponent(typeof(MeshRenderer), typeof(MeshFilter))]
public class RingMeshDrawer : MonoBehaviour
{
	private const string LOG_TAG = "RingMeshDrawer";

	private const float DEF_RING_WIDTH = 0.01f;

	public float RingWidth = 0.01f;

	private const float MIN_RING_WIDTH = 0.001f;

	private const float DEF_INNER_CIRCLE_RADIUS = 0.02f;

	public float InnerCircleRadius = 0.02f;

	private const float MIN_INNER_CIRCLE_RADIUS = 0.001f;

	[HideInInspector]
	public Vector3 RingPosition = Vector3.zero;

	private const float DEF_RING_DISTANCE = 2f;

	public float RingDistance = 2f;

	private const float MIN_RING_DISTANCE = 0.3f;

	public Color Color = Color.white;

	public Color ProgressColor = new Color(0f, 245f, 255f);

	[HideInInspector]
	public int RingPercent;

	private const float percentAngle = 3.6f;

	private const string RING_MATERIAL = "RingUnlitTransparentMat";

	private Material ringMaterial;

	private Material ringMaterialInstance;

	private MeshRenderer meshRend;

	private const int RENDER_QUEUE_MIN = 1000;

	private const int RENDER_QUEUE_MAX = 5000;

	private MeshFilter meshFilt;

	private Camera mCamera;

	private bool mEnabled;

	private Vector3 ringPos = Vector3.zero;

	private const int VERTEX_COUNT = 400;

	private Vector3[] ringVert = new Vector3[400];

	private Color[] ringColor = new Color[400];

	private const int TRIANGLE_COUNT = 600;

	private int[] ringTriangle = new int[600];

	private Vector2[] ringUv = new Vector2[400];

	private void DEBUG(string msg)
	{
		if (WVR_Log.Log.EnableDebugLog)
		{
			WVR_Log.Log.d("RingMeshDrawer", msg, logInEditor: true);
		}
	}

	private bool ValidateParameters()
	{
		if (meshRend == null || meshFilt == null)
		{
			return false;
		}
		if (mCamera == null && WaveVR_InputModuleManager.Instance != null)
		{
			mCamera = WaveVR_InputModuleManager.Instance.gameObject.GetComponent<Camera>();
		}
		if (mCamera == null)
		{
			return false;
		}
		if (RingWidth < 0.001f)
		{
			RingWidth = 0.01f;
		}
		if (InnerCircleRadius < 0.001f)
		{
			InnerCircleRadius = 0.02f;
		}
		if (RingDistance < 0.3f)
		{
			RingDistance = 2f;
		}
		return true;
	}

	private void OnEnable()
	{
		if (!mEnabled)
		{
			meshRend = GetComponent<MeshRenderer>();
			ringMaterial = Resources.Load("RingUnlitTransparentMat") as Material;
			if (ringMaterial != null)
			{
				ringMaterialInstance = UnityEngine.Object.Instantiate(ringMaterial);
			}
			if (ringMaterialInstance != null)
			{
				meshRend.material = ringMaterialInstance;
				meshRend.material.renderQueue = 5000;
				DEBUG("OnEnable() ring material: " + meshRend.material.name);
			}
			else
			{
				DEBUG("OnEnable() CANNOT load material.");
			}
			meshFilt = base.gameObject.GetComponent<MeshFilter>();
			mEnabled = true;
		}
	}

	private void Update()
	{
		if (ValidateParameters())
		{
			base.transform.localPosition = Vector3.zero;
			base.transform.localRotation = Quaternion.identity;
			ringPos = RingPosition;
			if (ringPos == Vector3.zero)
			{
				ringPos.z += RingDistance;
			}
			ringPos.z = ((ringPos.z < 0.3f) ? RingDistance : ringPos.z);
			float num = RingWidth * (ringPos.z / 2f);
			float num2 = InnerCircleRadius * (ringPos.z / 2f);
			DrawRing(num + num2, num2, RingPercent, ringPos);
		}
	}

	private void OnDisable()
	{
		if (mEnabled)
		{
			meshFilt.mesh.Clear();
			ringMaterial = null;
			ringMaterialInstance = null;
			mEnabled = false;
			DEBUG("OnDisable()");
		}
	}

	public void DrawRing(float radius, float innerRadius, int percent, Vector3 position)
	{
		float num = 90f;
		for (int i = 0; i < 400; i += 2)
		{
			float f = num * ((float)Math.PI / 180f);
			float num2 = Mathf.Cos(f);
			float num3 = Mathf.Sin(f);
			ringVert[i].x = radius * num2 + position.x - innerRadius / 2f;
			ringVert[i].y = radius * num3 + position.y + innerRadius / 2f;
			ringVert[i].z = position.z;
			ringColor[i] = ((i <= percent * 2 && i > 0) ? ProgressColor : Color);
			ringVert[i + 1].x = innerRadius * num2 + position.x - innerRadius / 2f;
			ringVert[i + 1].y = innerRadius * num3 + position.y + innerRadius / 2f;
			ringVert[i + 1].z = position.z;
			ringColor[i + 1] = ((i <= percent * 2 && i > 0) ? ProgressColor : Color);
			num -= 3.6f;
		}
		int num4 = 0;
		int num5 = 0;
		while (num4 < 600)
		{
			ringTriangle[num4] = num5;
			ringTriangle[num4 + 1] = num5 + 3;
			ringTriangle[num4 + 2] = num5 + 1;
			ringTriangle[num4 + 3] = num5 + 2;
			ringTriangle[num4 + 4] = num5 + 3;
			ringTriangle[num4 + 5] = num5;
			num4 += 6;
			num5 += 2;
		}
		for (int j = 0; j < 400; j++)
		{
			ringUv[j].x = ringVert[j].x / radius / 2f + 0.5f;
			ringUv[j].y = ringVert[j].z / radius / 2f + 0.5f;
		}
		Mesh mesh = meshFilt.mesh;
		mesh.Clear();
		mesh.vertices = ringVert;
		mesh.colors = ringColor;
		mesh.triangles = ringTriangle;
		mesh.uv = ringUv;
	}
}
[Serializable]
public class BatteryPercentage
{
	public float minBatteryPercentage;

	public float maxBatteryPercentage;

	public Texture texture;
}
public class UniversalControllerActions : MonoBehaviour
{
	public enum AxisMapping
	{
		Y_Axis,
		Z_Axis
	}

	private static string LOG_TAG = "UniversalControllerActions";

	public WVR_DeviceType device = WVR_DeviceType.WVR_DeviceType_Controller_Right;

	public bool useSystemConfig = true;

	public GameObject TouchPad;

	public GameObject Touch_Dot;

	public AxisMapping touch_YAxis_mapping = AxisMapping.Z_Axis;

	public GameObject Touch_Press;

	public GameObject Trigger_Press;

	public GameObject VolumeUp_Press;

	public GameObject VolumeDown_Press;

	public GameObject Grip_Press;

	public GameObject DigitalTrigger_Press;

	public GameObject Menu_Press;

	public GameObject Home_Press;

	public GameObject Battery_Change;

	public List<BatteryPercentage> batteryPercentages = new List<BatteryPercentage>();

	private Vector3 originPosition;

	private MeshRenderer batteryMeshRenderer;

	private Mesh toucheffectMesh;

	private Mesh touchpadMesh;

	private bool isTouchPressed;

	private Color materialColor = new Color(0f, 179f, 227f, 255f);

	private bool currentIsLeftHandMode;

	private int batteryLevels;

	private int t;

	private void PrintDebugLog(string msg)
	{
		WVR_Log.Log.d(LOG_TAG, string.Concat("device: ", device, ", ", msg), logInEditor: true);
	}

	private Color StringToColor(string color_string)
	{
		float r = Convert.ToInt32(color_string.Substring(1, 2), 16);
		float g = Convert.ToInt32(color_string.Substring(3, 2), 16);
		float b = Convert.ToInt32(color_string.Substring(5, 2), 16);
		float a = Convert.ToInt32(color_string.Substring(7, 2), 16);
		return new Color(r, g, b, a);
	}

	private Texture2D GetTexture2D(string texture_path)
	{
		if (File.Exists(texture_path))
		{
			byte[] data = File.ReadAllBytes(texture_path);
			Texture2D texture2D = new Texture2D(1, 1);
			texture2D.LoadImage(data);
			return texture2D;
		}
		return null;
	}

	public void Circle(Texture2D tex, int cx, int cy, int r, Color col)
	{
		for (int i = 0; i <= r; i++)
		{
			int num = (int)Mathf.Ceil(Mathf.Sqrt(r * r - i * i));
			for (int j = 0; j <= num; j++)
			{
				int x = cx + i;
				int x2 = cx - i;
				int y = cy + j;
				int y2 = cy - j;
				tex.SetPixel(x, y, col);
				tex.SetPixel(x2, y, col);
				tex.SetPixel(x, y2, col);
				tex.SetPixel(x2, y2, col);
			}
		}
		tex.Apply();
	}

	private void ReadJsonValues()
	{
		string controllerConfig = WaveVR_Utils.OEMConfig.getControllerConfig();
		if (controllerConfig.Equals(""))
		{
			return;
		}
		try
		{
			JSONNode jSONNode = JSONNode.Parse(controllerConfig);
			string text = "";
			text = jSONNode["model"]["touchpad_dot_use_texture"].Value;
			if (text.ToLower().Equals("false"))
			{
				WVR_Log.Log.d(LOG_TAG, "touchpad_dot_use_texture = false, create texture");
				if (Touch_Dot != null)
				{
					text = jSONNode["model"]["touchpad_dot_color"].Value;
					if (!text.Equals(""))
					{
						WVR_Log.Log.d(LOG_TAG, "touchpad_dot_color: " + text);
						materialColor = StringToColor(text);
						Texture2D texture2D = new Texture2D(256, 256, TextureFormat.ARGB32, mipChain: false);
						Color clear = Color.clear;
						clear.r = 1f;
						clear.g = 1f;
						clear.b = 1f;
						clear.a = 0f;
						for (int i = 0; i < 256; i++)
						{
							for (int j = 0; j < 256; j++)
							{
								texture2D.SetPixel(i, j, clear);
							}
						}
						texture2D.Apply();
						Circle(texture2D, 128, 128, 100, materialColor);
						Touch_Dot.GetComponent<MeshRenderer>().material.mainTexture = texture2D;
					}
				}
			}
			else
			{
				WVR_Log.Log.d(LOG_TAG, "touchpad_dot_use_texture = true");
				text = jSONNode["model"]["touchpad_dot_texture_name"].Value;
				if (!text.Equals("") && File.Exists(text))
				{
					byte[] data = File.ReadAllBytes(text);
					Texture2D texture2D2 = new Texture2D(1, 1);
					texture2D2.LoadImage(data);
					if (Touch_Dot != null)
					{
						WVR_Log.Log.d(LOG_TAG, "touchpad_dot_texture_name: " + text);
						Material obj = Touch_Dot.GetComponentInChildren<MeshRenderer>().materials[0];
						obj.mainTexture = texture2D2;
						obj.color = materialColor;
					}
				}
			}
			text = jSONNode["battery"]["battery_level_count"].Value;
			if (text.Equals(""))
			{
				return;
			}
			batteryLevels = Convert.ToInt32(text, 10);
			if (batteryLevels <= 0)
			{
				return;
			}
			bool flag = true;
			string text2 = "";
			string text3 = "";
			string text4 = "";
			for (int k = 0; k < batteryLevels; k++)
			{
				text2 = jSONNode["battery"]["battery_levels"][k]["level_texture_name"].Value;
				text3 = jSONNode["battery"]["battery_levels"][k]["level_min_value"].Value;
				text4 = jSONNode["battery"]["battery_levels"][k]["level_max_value"].Value;
				if (!text2.Equals("") && !text3.Equals("") && !text4.Equals(""))
				{
					if (GetTexture2D(text2) == null)
					{
						flag = false;
						break;
					}
					continue;
				}
				flag = false;
				break;
			}
			if (!flag)
			{
				return;
			}
			WVR_Log.Log.d(LOG_TAG, "updateBatteryTextures, battery_level_count: " + batteryLevels);
			batteryPercentages.Clear();
			for (int l = 0; l < batteryLevels; l++)
			{
				text2 = jSONNode["battery"]["battery_levels"][l]["level_texture_name"].Value;
				text3 = jSONNode["battery"]["battery_levels"][l]["level_min_value"].Value;
				text4 = jSONNode["battery"]["battery_levels"][l]["level_max_value"].Value;
				if (!text2.Equals("") && !text3.Equals("") && !text4.Equals(""))
				{
					Texture texture2D3 = GetTexture2D(text2);
					if (texture2D3 != null)
					{
						BatteryPercentage batteryPercentage = new BatteryPercentage();
						batteryPercentage.texture = texture2D3;
						batteryPercentage.minBatteryPercentage = float.Parse(text3);
						batteryPercentage.maxBatteryPercentage = float.Parse(text4);
						WVR_Log.Log.d(LOG_TAG, "updateBatteryTextures, level: " + l + ", min = " + text3 + ", max = " + text4 + ", texName = " + text2);
						batteryPercentages.Add(batteryPercentage);
					}
				}
			}
		}
		catch (Exception ex)
		{
			WVR_Log.Log.e(LOG_TAG, "JsonParse failed: " + ex.ToString());
		}
	}

	private void OnEnable()
	{
		if (useSystemConfig)
		{
			WVR_Log.Log.d(LOG_TAG, "use system config in controller model!");
			ReadJsonValues();
		}
		else
		{
			WVR_Log.Log.w(LOG_TAG, "use custom config in controller model!");
		}
		resetButtonState();
		WaveVR_Utils.Event.Listen(WaveVR_Utils.Event.BATTERY_STATUS_UPDATE, onBatteryStatusUpdate);
	}

	private void OnDisable()
	{
		WaveVR_Utils.Event.Remove(WaveVR_Utils.Event.BATTERY_STATUS_UPDATE, onBatteryStatusUpdate);
	}

	private void OnApplicationPause(bool pauseStatus)
	{
		if (!pauseStatus)
		{
			WVR_Log.Log.d(LOG_TAG, "Pause(" + pauseStatus + ") and reset button state");
			resetButtonState();
		}
	}

	private void onBatteryStatusUpdate(params object[] args)
	{
		WVR_Log.Log.d(LOG_TAG, "receive battery status update event");
		_ = Battery_Change != null;
	}

	private bool updateBatteryInfo()
	{
		if (UnityEngine.Application.isEditor)
		{
			return false;
		}
		WVR_DeviceType deviceType = WaveVR_Controller.Input(device).DeviceType;
		float num = Interop.WVR_GetDeviceBatteryPercentage(deviceType);
		PrintDebugLog(string.Concat("updateBatteryInfo() _type: ", deviceType, ", percentage: ", num));
		if (num < 0f)
		{
			PrintDebugLog(string.Concat("updateBatteryInfo() _type: ", deviceType, " BatteryPercentage is negative, return false"));
			return false;
		}
		foreach (BatteryPercentage batteryPercentage in batteryPercentages)
		{
			if (num >= batteryPercentage.minBatteryPercentage && num <= batteryPercentage.maxBatteryPercentage)
			{
				batteryMeshRenderer.material.mainTexture = batteryPercentage.texture;
				WVR_Log.Log.d(LOG_TAG, string.Concat("BatteryPercentage device: ", device, ", between ", batteryPercentage.minBatteryPercentage, " and ", batteryPercentage.maxBatteryPercentage));
				Battery_Change.SetActive(value: true);
			}
		}
		return true;
	}

	private void Start()
	{
		if (TouchPad != null && Touch_Dot != null)
		{
			originPosition = Touch_Dot.transform.localPosition;
			Touch_Dot.SetActive(value: false);
			toucheffectMesh = Touch_Dot.GetComponent<MeshFilter>().mesh;
			touchpadMesh = TouchPad.GetComponent<MeshFilter>().mesh;
			WVR_Log.Log.d(LOG_TAG, "Touch Y-axis mapping to " + touch_YAxis_mapping);
		}
		if (Battery_Change != null)
		{
			batteryMeshRenderer = Battery_Change.GetComponent<MeshRenderer>();
			Battery_Change.SetActive(value: false);
		}
		resetButtonState();
	}

	private void resetButtonState()
	{
		WVR_Log.Log.d(LOG_TAG, "reset button state");
		if (Touch_Dot != null)
		{
			Touch_Dot.SetActive(value: false);
		}
		if (Grip_Press != null)
		{
			Grip_Press.SetActive(value: false);
		}
		if (Trigger_Press != null)
		{
			Trigger_Press.SetActive(value: false);
		}
		if (VolumeUp_Press != null)
		{
			VolumeUp_Press.SetActive(value: false);
		}
		if (VolumeDown_Press != null)
		{
			VolumeDown_Press.SetActive(value: false);
		}
		if (Touch_Press != null)
		{
			Touch_Press.SetActive(value: false);
		}
		if (DigitalTrigger_Press != null)
		{
			DigitalTrigger_Press.SetActive(value: false);
		}
		if (Menu_Press != null)
		{
			Menu_Press.SetActive(value: false);
		}
		if (Home_Press != null)
		{
			Home_Press.SetActive(value: false);
		}
	}

	private void Update()
	{
		if (currentIsLeftHandMode != WaveVR_Controller.IsLeftHanded)
		{
			currentIsLeftHandMode = WaveVR_Controller.IsLeftHanded;
			WVR_Log.Log.d(LOG_TAG, "Controller role is changed to " + (currentIsLeftHandMode ? "Left" : "Right"));
			resetButtonState();
		}
		if (Battery_Change != null && t++ > 150)
		{
			t = 0;
		}
		if (WaveVR_Controller.Input(device).GetPressDown(WVR_InputId.WVR_InputId_17))
		{
			WVR_Log.Log.d(LOG_TAG, "WVR_InputId_Alias1_Trigger press down");
			if (Trigger_Press != null)
			{
				Trigger_Press.SetActive(value: true);
			}
		}
		if (WaveVR_Controller.Input(device).GetPress(WVR_InputId.WVR_InputId_17) && Trigger_Press != null)
		{
			Trigger_Press.SetActive(value: true);
		}
		if (WaveVR_Controller.Input(device).GetPressUp(WVR_InputId.WVR_InputId_17))
		{
			WVR_Log.Log.d(LOG_TAG, "WVR_InputId_Alias1_Trigger press up");
			if (Trigger_Press != null)
			{
				Trigger_Press.SetActive(value: false);
			}
		}
		if (WaveVR_Controller.Input(device).GetPressDown(WVR_InputId.WVR_InputId_7))
		{
			WVR_Log.Log.d(LOG_TAG, "WVR_InputId_Alias1_Volume_Up press down");
			if (VolumeUp_Press != null)
			{
				VolumeUp_Press.SetActive(value: true);
			}
		}
		if (WaveVR_Controller.Input(device).GetPress(WVR_InputId.WVR_InputId_7) && VolumeUp_Press != null)
		{
			VolumeUp_Press.SetActive(value: true);
		}
		if (WaveVR_Controller.Input(device).GetPressUp(WVR_InputId.WVR_InputId_7))
		{
			WVR_Log.Log.d(LOG_TAG, "WVR_InputId_Alias1_Volume_Up press up");
			if (VolumeUp_Press != null)
			{
				VolumeUp_Press.SetActive(value: false);
			}
		}
		if (WaveVR_Controller.Input(device).GetPressDown(WVR_InputId.WVR_InputId_8))
		{
			WVR_Log.Log.d(LOG_TAG, "WVR_InputId_Alias1_Volume_Down press down");
			if (VolumeDown_Press != null)
			{
				VolumeDown_Press.SetActive(value: true);
			}
		}
		if (WaveVR_Controller.Input(device).GetPress(WVR_InputId.WVR_InputId_8) && VolumeDown_Press != null)
		{
			VolumeDown_Press.SetActive(value: true);
		}
		if (WaveVR_Controller.Input(device).GetPressUp(WVR_InputId.WVR_InputId_8))
		{
			WVR_Log.Log.d(LOG_TAG, "WVR_InputId_Alias1_Volume_Down press up");
			if (VolumeDown_Press != null)
			{
				VolumeDown_Press.SetActive(value: false);
			}
		}
		if (WaveVR_Controller.Input(device).GetPressDown(WVR_InputId.WVR_InputId_2))
		{
			WVR_Log.Log.d(LOG_TAG, "WVR_InputId_Alias1_Grip press down");
			if (Grip_Press != null)
			{
				Grip_Press.SetActive(value: true);
			}
		}
		if (WaveVR_Controller.Input(device).GetPress(WVR_InputId.WVR_InputId_2) && Grip_Press != null)
		{
			Grip_Press.SetActive(value: true);
		}
		if (WaveVR_Controller.Input(device).GetPressUp(WVR_InputId.WVR_InputId_2))
		{
			WVR_Log.Log.d(LOG_TAG, "WVR_InputId_Alias1_Grip press up");
			if (Grip_Press != null)
			{
				Grip_Press.SetActive(value: false);
			}
		}
		if (WaveVR_Controller.Input(device).GetPressDown(WVR_InputId.WVR_InputId_9))
		{
			WVR_Log.Log.d(LOG_TAG, "WVR_InputId_Alias1_Digital_Trigger press down");
			if (DigitalTrigger_Press != null)
			{
				DigitalTrigger_Press.SetActive(value: true);
			}
		}
		if (WaveVR_Controller.Input(device).GetPress(WVR_InputId.WVR_InputId_9) && DigitalTrigger_Press != null)
		{
			DigitalTrigger_Press.SetActive(value: true);
		}
		if (WaveVR_Controller.Input(device).GetPressUp(WVR_InputId.WVR_InputId_9))
		{
			WVR_Log.Log.d(LOG_TAG, "WVR_InputId_Alias1_Digital_Trigger press up");
			if (DigitalTrigger_Press != null)
			{
				DigitalTrigger_Press.SetActive(value: false);
			}
		}
		if (WaveVR_Controller.Input(device).GetPressDown(WVR_InputId.WVR_InputId_1))
		{
			WVR_Log.Log.d(LOG_TAG, "WVR_InputId_Alias1_Menu press down");
			if (Menu_Press != null)
			{
				Menu_Press.SetActive(value: true);
			}
		}
		if (WaveVR_Controller.Input(device).GetPress(WVR_InputId.WVR_InputId_1) && Menu_Press != null)
		{
			Menu_Press.SetActive(value: true);
		}
		if (WaveVR_Controller.Input(device).GetPressUp(WVR_InputId.WVR_InputId_1))
		{
			WVR_Log.Log.d(LOG_TAG, "WVR_InputId_Alias1_Menu press up");
			if (Menu_Press != null)
			{
				Menu_Press.SetActive(value: false);
			}
		}
		if (WaveVR_Controller.Input(device).GetPressDown(WVR_InputId.WVR_InputId_0))
		{
			WVR_Log.Log.d(LOG_TAG, "WVR_InputId_Alias1_System press down");
			if (Home_Press != null)
			{
				Home_Press.SetActive(value: true);
			}
		}
		if (WaveVR_Controller.Input(device).GetPress(WVR_InputId.WVR_InputId_0) && Home_Press != null)
		{
			Home_Press.SetActive(value: true);
		}
		if (WaveVR_Controller.Input(device).GetPressUp(WVR_InputId.WVR_InputId_0))
		{
			WVR_Log.Log.d(LOG_TAG, "WVR_InputId_Alias1_System press up");
			if (Home_Press != null)
			{
				Home_Press.SetActive(value: false);
			}
		}
		if (WaveVR_Controller.Input(device).GetPressDown(WVR_InputId.WVR_InputId_16))
		{
			isTouchPressed = true;
			if (Touch_Press != null)
			{
				Touch_Press.SetActive(value: true);
			}
		}
		if (WaveVR_Controller.Input(device).GetPress(WVR_InputId.WVR_InputId_16) && Touch_Press != null)
		{
			if (Touch_Dot != null)
			{
				Touch_Dot.SetActive(value: false);
			}
			Touch_Press.SetActive(value: true);
		}
		if (WaveVR_Controller.Input(device).GetPressUp(WVR_InputId.WVR_InputId_16))
		{
			isTouchPressed = false;
			if (Touch_Press != null)
			{
				Touch_Press.SetActive(value: false);
			}
		}
		if (WaveVR_Controller.Input(device).GetTouchDown(WVR_InputId.WVR_InputId_16) && !isTouchPressed && Touch_Dot != null)
		{
			Touch_Dot.SetActive(value: true);
		}
		if (WaveVR_Controller.Input(device).GetTouchUp(WVR_InputId.WVR_InputId_16) && Touch_Dot != null)
		{
			Touch_Dot.SetActive(value: false);
		}
		if (!WaveVR_Controller.Input(device).GetTouch(WVR_InputId.WVR_InputId_16) || isTouchPressed)
		{
			return;
		}
		if (Touch_Dot != null)
		{
			Touch_Dot.SetActive(value: true);
		}
		if (TouchPad != null && Touch_Dot != null)
		{
			Vector2 axis = WaveVR_Controller.Input(device).GetAxis(WVR_InputId.WVR_InputId_16);
			float num = axis.x * (touchpadMesh.bounds.size.x * TouchPad.transform.localScale.x - toucheffectMesh.bounds.size.x * Touch_Dot.transform.localScale.x) / 2f;
			float num2 = 0f;
			num2 = ((touch_YAxis_mapping != 0) ? (axis.y * (touchpadMesh.bounds.size.z * TouchPad.transform.localScale.z - toucheffectMesh.bounds.size.z * Touch_Dot.transform.localScale.z) / 2f) : (axis.y * (touchpadMesh.bounds.size.z * TouchPad.transform.localScale.z - toucheffectMesh.bounds.size.z * Touch_Dot.transform.localScale.z) / 2f));
			if (WVR_Log.Log.gpl.Print)
			{
				WVR_Log.Log.d(LOG_TAG, "WVR_InputId_Alias1_Touchpad axis x: " + axis.x + ", xangle: " + num + " axis.y: " + axis.y + ", yangle: " + num2);
			}
			Vector3 zero = Vector3.zero;
			zero = ((touch_YAxis_mapping != 0) ? new Vector3(num, 0f, num2) : new Vector3(num, num2, 0f));
			Touch_Dot.transform.localPosition = originPosition + zero;
		}
	}
}
public class WaveVR_Resource
{
	private static string LOG_TAG = "WaveVR_Resource";

	private static WaveVR_Resource mInstance = null;

	private string mPreferredLanguage = "system";

	private string mCountry = "system";

	private bool useSystemLanguageFlag = true;

	public static WaveVR_Resource instance
	{
		get
		{
			if (mInstance == null)
			{
				mInstance = new WaveVR_Resource();
			}
			return mInstance;
		}
	}

	public string getString(string stringName)
	{
		WVR_Log.Log.d(LOG_TAG, "getString, string " + stringName);
		string text = "";
		text = ((!useSystemLanguageFlag) ? Interop.WVR_GetStringByLanguage(stringName, mPreferredLanguage, mCountry) : Interop.WVR_GetStringBySystemLanguage(stringName));
		WVR_Log.Log.d(LOG_TAG, "getString, ret string = " + text);
		return text;
	}

	public string getStringByLanguage(string stringName, string lang, string country)
	{
		WVR_Log.Log.d(LOG_TAG, "getPreferredString, string " + stringName + " language is " + lang + " country is " + country);
		string text = Interop.WVR_GetStringByLanguage(stringName, lang, country);
		WVR_Log.Log.d(LOG_TAG, "getStringByLanguage, ret string = " + text);
		return text;
	}

	public string getSystemLanguage()
	{
		string text = Interop.WVR_GetSystemLanguage();
		WVR_Log.Log.d(LOG_TAG, "getSystemLanguage, ret language = " + text);
		return text;
	}

	public string getSystemCountry()
	{
		string text = Interop.WVR_GetSystemCountry();
		WVR_Log.Log.d(LOG_TAG, "getSystemCountry, ret country = " + text);
		return text;
	}

	public bool setPreferredLanguage(string lang, string country)
	{
		if (lang == "" && country == "")
		{
			return false;
		}
		useSystemLanguageFlag = false;
		mPreferredLanguage = lang;
		mCountry = country;
		return true;
	}

	public void useSystemLanguage()
	{
		mPreferredLanguage = "system";
		mCountry = "system";
		useSystemLanguageFlag = true;
	}
}
public class WVR_Android : Interop.WVR_Base
{
	private class RequestCompleteHandler : AndroidJavaProxy
	{
		internal RequestCompleteHandler()
			: base(new AndroidJavaClass("com.htc.vr.permission.client.PermissionCallback"))
		{
		}

		public void onRequestCompletedwithObject(AndroidJavaObject resultObject)
		{
			_ = mCallback;
			List<WVR_RequestResult> list = new List<WVR_RequestResult>();
			bool[] array = null;
			AndroidJavaObject androidJavaObject = resultObject.Get<AndroidJavaObject>("result");
			if (androidJavaObject != null && androidJavaObject.GetRawObject() != IntPtr.Zero)
			{
				try
				{
					array = AndroidJNI.FromBooleanArray(androidJavaObject.GetRawObject());
				}
				catch (Exception)
				{
				}
			}
			string[] array2 = null;
			AndroidJavaObject androidJavaObject2 = resultObject.Get<AndroidJavaObject>("requestPermissions");
			if (androidJavaObject2 != null && androidJavaObject2.GetRawObject() != IntPtr.Zero)
			{
				array2 = AndroidJNIHelper.ConvertFromJNIArray<string[]>(androidJavaObject2.GetRawObject());
			}
			if (array2 != null && array != null)
			{
				WVR_RequestResult item = default(WVR_RequestResult);
				for (int i = 0; i < array2.Length; i++)
				{
					item.mPermission = array2[i];
					item.mGranted = array[i];
					list.Add(item);
				}
			}
			mCallback(list);
		}
	}

	private class RequestUsbCompleteHandler : AndroidJavaProxy
	{
		internal RequestUsbCompleteHandler()
			: base(new AndroidJavaClass("com.htc.vr.permission.client.UsbPermissionCallback"))
		{
		}

		public void onRequestCompletedwithObject(AndroidJavaObject resultObject)
		{
			_ = mUsbCallback;
			bool result = resultObject.Get<bool>("result");
			mUsbCallback(result);
		}
	}

	public class OEMConfigCallback : AndroidJavaProxy
	{
		internal OEMConfigCallback()
			: base(new AndroidJavaClass("com.htc.vr.unity.WVRUnityVRActivity$OEMConfigCallback"))
		{
		}

		public void onConfigChanged()
		{
			if (OEMChangedCallback != null)
			{
				OEMChangedCallback();
			}
		}
	}

	private const string PERMISSION_MANAGER_CLASSNAME = "com.htc.vr.permission.client.PermissionManager";

	private static WVR_RequestCompleteCallback mCallback = null;

	private static WVR_RequestUsbCompleteCallback mUsbCallback = null;

	private AndroidJavaObject permissionsManager;

	private const string RESOURCE_WRAPPER_CLASSNAME = "com.htc.vr.unity.ResourceWrapper";

	private AndroidJavaObject ResourceWrapper;

	private const string OEM_CONFIG_CLASSNAME = "com.htc.vr.unity.WVRUnityVRActivity";

	private static WVR_OnOEMConfigChanged OEMChangedCallback = null;

	private static AndroidJavaObject mOEMConfig = null;

	public static OEMConfigCallback mOEMCallback = new OEMConfigCallback();

	[DllImport("wvr_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_PollEventQueue")]
	public static extern bool WVR_PollEventQueue_Android(ref WVR_Event_t e);

	public override bool PollEventQueue(ref WVR_Event_t e)
	{
		return WVR_PollEventQueue_Android(ref e);
	}

	[DllImport("wvr_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_GetInputDeviceCapability")]
	public static extern int WVR_GetInputDeviceCapability_Android(WVR_DeviceType type, WVR_InputType inputType);

	public override int GetInputDeviceCapability(WVR_DeviceType type, WVR_InputType inputType)
	{
		return WVR_GetInputDeviceCapability_Android(type, inputType);
	}

	[DllImport("wvr_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_GetInputDeviceAnalogType")]
	public static extern WVR_AnalogType WVR_GetInputDeviceAnalogType_Android(WVR_DeviceType type, WVR_InputId id);

	public override WVR_AnalogType GetInputDeviceAnalogType(WVR_DeviceType type, WVR_InputId id)
	{
		return WVR_GetInputDeviceAnalogType_Android(type, id);
	}

	[DllImport("wvr_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_GetInputDeviceState")]
	public static extern bool WVR_GetInputDeviceState_Android(WVR_DeviceType type, uint inputMask, ref uint buttons, ref uint touches, [In][Out] WVR_AnalogState_t[] analogArray, uint analogArrayCount);

	public override bool GetInputDeviceState(WVR_DeviceType type, uint inputMask, ref uint buttons, ref uint touches, [In][Out] WVR_AnalogState_t[] analogArray, uint analogArrayCount)
	{
		return WVR_GetInputDeviceState_Android(type, inputMask, ref buttons, ref touches, analogArray, analogArrayCount);
	}

	[DllImport("wvr_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_GetInputTypeCount")]
	public static extern int WVR_GetInputTypeCount_Android(WVR_DeviceType type, WVR_InputType inputType);

	public override int GetInputTypeCount(WVR_DeviceType type, WVR_InputType inputType)
	{
		return WVR_GetInputTypeCount_Android(type, inputType);
	}

	[DllImport("wvr_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_GetInputButtonState")]
	public static extern bool WVR_GetInputButtonState_Android(WVR_DeviceType type, WVR_InputId id);

	public override bool GetInputButtonState(WVR_DeviceType type, WVR_InputId id)
	{
		return WVR_GetInputButtonState_Android(type, id);
	}

	[DllImport("wvr_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_GetInputTouchState")]
	public static extern bool WVR_GetInputTouchState_Android(WVR_DeviceType type, WVR_InputId id);

	public override bool GetInputTouchState(WVR_DeviceType type, WVR_InputId id)
	{
		return WVR_GetInputTouchState_Android(type, id);
	}

	[DllImport("wvr_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_GetInputAnalogAxis")]
	public static extern WVR_Axis_t WVR_GetInputAnalogAxis_Android(WVR_DeviceType type, WVR_InputId id);

	public override WVR_Axis_t GetInputAnalogAxis(WVR_DeviceType type, WVR_InputId id)
	{
		return WVR_GetInputAnalogAxis_Android(type, id);
	}

	[DllImport("wvr_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_GetPoseState")]
	public static extern void WVR_GetPoseState_Android(WVR_DeviceType type, WVR_PoseOriginModel originModel, uint predictedMilliSec, ref WVR_PoseState_t poseState);

	public override void GetPoseState(WVR_DeviceType type, WVR_PoseOriginModel originModel, uint predictedMilliSec, ref WVR_PoseState_t poseState)
	{
		WVR_GetPoseState_Android(type, originModel, predictedMilliSec, ref poseState);
	}

	[DllImport("wvr_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_GetSyncPose")]
	public static extern void WVR_GetSyncPose_Android(WVR_PoseOriginModel originModel, [In][Out] WVR_DevicePosePair_t[] poseArray, uint pairArrayCount);

	public override void GetSyncPose(WVR_PoseOriginModel originModel, [In][Out] WVR_DevicePosePair_t[] poseArray, uint pairArrayCount)
	{
		WVR_GetSyncPose_Android(originModel, poseArray, pairArrayCount);
	}

	[DllImport("wvr_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_IsDeviceConnected")]
	public static extern bool WVR_IsDeviceConnected_Android(WVR_DeviceType type);

	public override bool IsDeviceConnected(WVR_DeviceType type)
	{
		return WVR_IsDeviceConnected_Android(type);
	}

	[DllImport("wvr_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_TriggerVibration")]
	public static extern void WVR_TriggerVibration_Android(WVR_DeviceType type, WVR_InputId id, uint durationMicroSec, uint frequency, WVR_Intensity intensity);

	public override void TriggerVibration(WVR_DeviceType type, WVR_InputId id, uint durationMicroSec, uint frequency, WVR_Intensity intensity)
	{
		WVR_TriggerVibration_Android(type, id, durationMicroSec, frequency, intensity);
	}

	[DllImport("wvr_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_InAppRecenter")]
	public static extern void WVR_InAppRecenter_Android(WVR_RecenterType recenterType);

	public override void InAppRecenter(WVR_RecenterType recenterType)
	{
		WVR_InAppRecenter_Android(recenterType);
	}

	[DllImport("wvr_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_SetNeckModelEnabled")]
	public static extern void WVR_SetNeckModelEnabled_Android(bool enabled);

	public override void SetNeckModelEnabled(bool enabled)
	{
		WVR_SetNeckModelEnabled_Android(enabled);
	}

	[DllImport("wvr_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_SetNeckModel")]
	public static extern void WVR_SetNeckModel_Android(WVR_SimulationType simulationType);

	public override void SetNeckModel(WVR_SimulationType simulationType)
	{
		WVR_SetNeckModel_Android(simulationType);
	}

	[DllImport("wvr_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_SetArmModel")]
	public static extern void WVR_SetArmModel_Android(WVR_SimulationType simulationType);

	public override void SetArmModel(WVR_SimulationType simulationType)
	{
		WVR_SetArmModel_Android(simulationType);
	}

	[DllImport("wvr_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_SetArmSticky")]
	public static extern void WVR_SetArmSticky_Android(bool stickyArm);

	public override void SetArmSticky(bool stickyArm)
	{
		WVR_SetArmSticky_Android(stickyArm);
	}

	[DllImport("wvr_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_SetInputRequest")]
	public static extern bool WVR_SetInputRequest_Android(WVR_DeviceType type, WVR_InputAttribute_t[] request, uint size);

	public override bool SetInputRequest(WVR_DeviceType type, WVR_InputAttribute_t[] request, uint size)
	{
		return WVR_SetInputRequest_Android(type, request, size);
	}

	[DllImport("wvr_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_GetInputMappingPair")]
	public static extern bool WVR_GetInputMappingPair_Android(WVR_DeviceType type, WVR_InputId destination, ref WVR_InputMappingPair_t pair);

	public override bool GetInputMappingPair(WVR_DeviceType type, WVR_InputId destination, ref WVR_InputMappingPair_t pair)
	{
		return WVR_GetInputMappingPair_Android(type, destination, ref pair);
	}

	[DllImport("wvr_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_GetInputMappingTable")]
	public static extern uint WVR_GetInputMappingTable_Android(WVR_DeviceType type, [In][Out] WVR_InputMappingPair_t[] table, uint size);

	public override uint GetInputMappingTable(WVR_DeviceType type, [In][Out] WVR_InputMappingPair_t[] table, uint size)
	{
		return WVR_GetInputMappingTable_Android(type, table, size);
	}

	[DllImport("wvr_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_GetArena")]
	public static extern WVR_Arena_t WVR_GetArena_Android();

	public override WVR_Arena_t GetArena()
	{
		return WVR_GetArena_Android();
	}

	[DllImport("wvr_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_SetArena")]
	public static extern bool WVR_SetArena_Android(ref WVR_Arena_t arena);

	public override bool SetArena(ref WVR_Arena_t arena)
	{
		return WVR_SetArena_Android(ref arena);
	}

	[DllImport("wvr_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_GetArenaVisible")]
	public static extern WVR_ArenaVisible WVR_GetArenaVisible_Android();

	public override WVR_ArenaVisible GetArenaVisible()
	{
		return WVR_GetArenaVisible_Android();
	}

	[DllImport("wvr_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_SetArenaVisible")]
	public static extern void WVR_SetArenaVisible_Android(WVR_ArenaVisible config);

	public override void SetArenaVisible(WVR_ArenaVisible config)
	{
		WVR_SetArenaVisible_Android(config);
	}

	[DllImport("wvr_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_IsOverArenaRange")]
	public static extern bool WVR_IsOverArenaRange_Android();

	public override bool IsOverArenaRange()
	{
		return WVR_IsOverArenaRange_Android();
	}

	[DllImport("wvr_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_GetDeviceBatteryPercentage")]
	public static extern float WVR_GetDeviceBatteryPercentage_Android(WVR_DeviceType type);

	public override float GetDeviceBatteryPercentage(WVR_DeviceType type)
	{
		return WVR_GetDeviceBatteryPercentage_Android(type);
	}

	[DllImport("wvr_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_GetBatteryStatus")]
	public static extern WVR_BatteryStatus WVR_GetBatteryStatus_Android(WVR_DeviceType type);

	public override WVR_BatteryStatus GetBatteryStatus(WVR_DeviceType type)
	{
		return WVR_GetBatteryStatus_Android(type);
	}

	[DllImport("wvr_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_GetChargeStatus")]
	public static extern WVR_ChargeStatus WVR_GetChargeStatus_Android(WVR_DeviceType type);

	public override WVR_ChargeStatus GetChargeStatus(WVR_DeviceType type)
	{
		return WVR_GetChargeStatus_Android(type);
	}

	[DllImport("wvr_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_GetBatteryTemperatureStatus")]
	public static extern WVR_BatteryTemperatureStatus WVR_GetBatteryTemperatureStatus_Android(WVR_DeviceType type);

	public override WVR_BatteryTemperatureStatus GetBatteryTemperatureStatus(WVR_DeviceType type)
	{
		return WVR_GetBatteryTemperatureStatus_Android(type);
	}

	[DllImport("wvr_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_GetBatteryTemperature")]
	public static extern float WVR_GetBatteryTemperature_Android(WVR_DeviceType type);

	public override float GetBatteryTemperature(WVR_DeviceType type)
	{
		return WVR_GetBatteryTemperature_Android(type);
	}

	[DllImport("wvr_api", CallingConvention = CallingConvention.Cdecl)]
	public static extern WVR_Result WVR_StartHandGesture();

	public override WVR_Result StartHandGesture()
	{
		return WVR_StartHandGesture();
	}

	[DllImport("wvr_api", CallingConvention = CallingConvention.Cdecl)]
	public static extern void WVR_StopHandGesture();

	public override void StopHandGesture()
	{
		WVR_StopHandGesture();
	}

	[DllImport("wvr_api", CallingConvention = CallingConvention.Cdecl)]
	public static extern WVR_Result WVR_GetHandGestureData(ref WVR_HandGestureData_t data);

	public override WVR_Result GetHandGestureData(ref WVR_HandGestureData_t data)
	{
		return WVR_GetHandGestureData(ref data);
	}

	[DllImport("wvr_api", CallingConvention = CallingConvention.Cdecl)]
	public static extern WVR_Result WVR_StartHandTracking();

	public override WVR_Result StartHandTracking()
	{
		return WVR_StartHandTracking();
	}

	[DllImport("wvr_api", CallingConvention = CallingConvention.Cdecl)]
	public static extern void WVR_StopHandTracking();

	public override void StopHandTracking()
	{
		WVR_StopHandTracking();
	}

	[DllImport("wvr_api", CallingConvention = CallingConvention.Cdecl)]
	public static extern WVR_Result WVR_GetHandTrackingData(ref WVR_HandTrackingData_t data, WVR_PoseOriginModel originModel, uint predictedMilliSec);

	public override WVR_Result GetHandTrackingData(ref WVR_HandTrackingData_t data, WVR_PoseOriginModel originModel, uint predictedMilliSec)
	{
		return WVR_GetHandTrackingData(ref data, originModel, predictedMilliSec);
	}

	[DllImport("wvr_api", CallingConvention = CallingConvention.Cdecl)]
	public static extern ulong WVR_GetSupportedFeatures();

	public override ulong GetSupportedFeatures()
	{
		return WVR_GetSupportedFeatures();
	}

	[DllImport("wvr_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_Init")]
	public static extern WVR_InitError WVR_Init_Android(WVR_AppType eType);

	public override WVR_InitError Init(WVR_AppType eType)
	{
		return WVR_Init_Android(eType);
	}

	[DllImport("wvr_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_Quit")]
	public static extern void WVR_Quit_Android();

	public override void Quit()
	{
		WVR_Quit_Android();
	}

	[DllImport("wvr_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_GetInitErrorString")]
	public static extern IntPtr WVR_GetInitErrorString_Android(WVR_InitError error);

	public override IntPtr GetInitErrorString(WVR_InitError error)
	{
		return WVR_GetInitErrorString_Android(error);
	}

	[DllImport("wvr_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_GetWaveRuntimeVersion")]
	public static extern uint WVR_GetWaveRuntimeVersion_Android();

	public override uint GetWaveRuntimeVersion()
	{
		return WVR_GetWaveRuntimeVersion_Android();
	}

	[DllImport("wvr_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_GetWaveSDKVersion")]
	public static extern uint WVR_GetWaveSDKVersion_Android();

	public override uint GetWaveSDKVersion()
	{
		return WVR_GetWaveSDKVersion_Android();
	}

	[DllImport("wvr_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_IsInputFocusCapturedBySystem")]
	public static extern bool WVR_IsInputFocusCapturedBySystem_Android();

	public override bool IsInputFocusCapturedBySystem()
	{
		return WVR_IsInputFocusCapturedBySystem_Android();
	}

	[DllImport("wvr_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_RenderInit")]
	internal static extern WVR_RenderError WVR_RenderInit_Android(ref WVR_RenderInitParams_t param);

	internal override WVR_RenderError RenderInit(ref WVR_RenderInitParams_t param)
	{
		return WVR_RenderInit_Android(ref param);
	}

	[DllImport("wvr_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_SetPerformanceLevels")]
	internal static extern bool WVR_SetPerformanceLevels_Android(WVR_PerfLevel cpuLevel, WVR_PerfLevel gpuLevel);

	internal override bool SetPerformanceLevels(WVR_PerfLevel cpuLevel, WVR_PerfLevel gpuLevel)
	{
		return WVR_SetPerformanceLevels_Android(cpuLevel, gpuLevel);
	}

	[DllImport("wvr_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_EnableAdaptiveQuality")]
	internal static extern bool WVR_EnableAdaptiveQuality_Android(bool enable, uint flags);

	internal override bool EnableAdaptiveQuality(bool enable, uint flags)
	{
		return WVR_EnableAdaptiveQuality_Android(enable, flags);
	}

	[DllImport("wvr_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_IsAdaptiveQualityEnabled")]
	internal static extern bool WVR_IsAdaptiveQualityEnabled_Android();

	internal override bool IsAdaptiveQualityEnabled()
	{
		return WVR_IsAdaptiveQualityEnabled_Android();
	}

	[DllImport("wvr_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_StartCamera")]
	public static extern bool WVR_StartCamera_Android(ref WVR_CameraInfo_t info);

	public override bool StartCamera(ref WVR_CameraInfo_t info)
	{
		return WVR_StartCamera_Android(ref info);
	}

	[DllImport("wvr_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_StopCamera")]
	public static extern void WVR_StopCamera_Android();

	public override void StopCamera()
	{
		WVR_StopCamera_Android();
	}

	[DllImport("wvr_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_UpdateTexture")]
	public static extern bool WVR_UpdateTexture_Android(uint textureid);

	public override bool UpdateTexture(IntPtr textureid)
	{
		return WVR_UpdateTexture_Android((uint)(int)textureid);
	}

	[DllImport("wvr_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_GetCameraIntrinsic")]
	public static extern bool WVR_GetCameraIntrinsic_Android(WVR_CameraPosition position, ref WVR_CameraIntrinsic_t intrinsic);

	public override bool GetCameraIntrinsic(WVR_CameraPosition position, ref WVR_CameraIntrinsic_t intrinsic)
	{
		return WVR_GetCameraIntrinsic_Android(position, ref intrinsic);
	}

	[DllImport("wvr_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_GetCameraFrameBuffer")]
	public static extern bool WVR_GetCameraFrameBuffer_Android(IntPtr pFramebuffer, uint frameBufferSize);

	public override bool GetCameraFrameBuffer(IntPtr pFramebuffer, uint frameBufferSize)
	{
		return WVR_GetCameraFrameBuffer_Android(pFramebuffer, frameBufferSize);
	}

	[DllImport("wvrutility", CallingConvention = CallingConvention.Cdecl, EntryPoint = "GetFrameBufferWithPoseState")]
	public static extern bool GetFrameBufferWithPoseState_Android(IntPtr pFramebuffer, uint frameBufferSize, WVR_PoseOriginModel origin, uint predictInMs, ref WVR_PoseState_t poseState);

	public override bool GetFrameBufferWithPoseState(IntPtr pFramebuffer, uint frameBufferSize, WVR_PoseOriginModel origin, uint predictInMs, ref WVR_PoseState_t poseState)
	{
		return GetFrameBufferWithPoseState_Android(pFramebuffer, frameBufferSize, origin, predictInMs, ref poseState);
	}

	[DllImport("wvrutility", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ReleaseAll")]
	public static extern void ReleaseCameraTexture_Android();

	public override void ReleaseCameraTexture()
	{
		ReleaseCameraTexture_Android();
	}

	[DllImport("wvrutility", CallingConvention = CallingConvention.Cdecl, EntryPoint = "DrawTextureWithBuffer")]
	public static extern bool DrawTextureWithBuffer_Android(uint textureId, WVR_CameraImageFormat imgFormat, IntPtr frameBuffer, uint size, uint width, uint height);

	public override bool DrawTextureWithBuffer(IntPtr textureId, WVR_CameraImageFormat imgFormat, IntPtr frameBuffer, uint size, uint width, uint height)
	{
		return DrawTextureWithBuffer_Android((uint)(int)textureId, imgFormat, frameBuffer, size, width, height);
	}

	[DllImport("wvr_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_IsDeviceSuspend")]
	public static extern bool WVR_IsDeviceSuspend_Android(WVR_DeviceType type);

	public override bool IsDeviceSuspend(WVR_DeviceType type)
	{
		return WVR_IsDeviceSuspend_Android(type);
	}

	[DllImport("wvr_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_ConvertMatrixQuaternion")]
	public static extern void WVR_ConvertMatrixQuaternion_Android(ref WVR_Matrix4f_t mat, ref WVR_Quatf_t quat, bool m2q);

	public override void ConvertMatrixQuaternion(ref WVR_Matrix4f_t mat, ref WVR_Quatf_t quat, bool m2q)
	{
		WVR_ConvertMatrixQuaternion_Android(ref mat, ref quat, m2q);
	}

	[DllImport("wvr_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_GetDegreeOfFreedom")]
	public static extern WVR_NumDoF WVR_GetDegreeOfFreedom_Android(WVR_DeviceType type);

	public override WVR_NumDoF GetDegreeOfFreedom(WVR_DeviceType type)
	{
		return WVR_GetDegreeOfFreedom_Android(type);
	}

	[DllImport("wvr_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_SetParameters")]
	public static extern void WVR_SetParameters_Android(WVR_DeviceType type, IntPtr pchValue);

	public override void SetParameters(WVR_DeviceType type, IntPtr pchValue)
	{
		WVR_SetParameters_Android(type, pchValue);
	}

	[DllImport("wvr_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_GetParameters")]
	public static extern uint WVR_GetParameters_Android(WVR_DeviceType type, IntPtr pchValue, IntPtr retValue, uint unBufferSize);

	public override uint GetParameters(WVR_DeviceType type, IntPtr pchValue, IntPtr retValue, uint unBufferSize)
	{
		return WVR_GetParameters_Android(type, pchValue, retValue, unBufferSize);
	}

	[DllImport("wvr_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_GetDefaultControllerRole")]
	public static extern WVR_DeviceType WVR_GetDefaultControllerRole_Android();

	public override WVR_DeviceType GetDefaultControllerRole()
	{
		return WVR_GetDefaultControllerRole_Android();
	}

	[DllImport("wvr_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_SetInteractionMode")]
	public static extern bool WVR_SetInteractionMode_Android(WVR_InteractionMode mode);

	public override bool SetInteractionMode(WVR_InteractionMode mode)
	{
		return WVR_SetInteractionMode_Android(mode);
	}

	[DllImport("wvr_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_GetInteractionMode")]
	public static extern WVR_InteractionMode WVR_GetInteractionMode_Android();

	public override WVR_InteractionMode GetInteractionMode()
	{
		return WVR_GetInteractionMode_Android();
	}

	[DllImport("wvr_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_SetGazeTriggerType")]
	public static extern bool WVR_SetGazeTriggerType_Android(WVR_GazeTriggerType type);

	public override bool SetGazeTriggerType(WVR_GazeTriggerType type)
	{
		return WVR_SetGazeTriggerType_Android(type);
	}

	[DllImport("wvr_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_GetGazeTriggerType")]
	public static extern WVR_GazeTriggerType WVR_GetGazeTriggerType_Android();

	public override WVR_GazeTriggerType GetGazeTriggerType()
	{
		return WVR_GetGazeTriggerType_Android();
	}

	[DllImport("wvr_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_GetDeviceErrorState")]
	public static extern bool WVR_GetDeviceErrorState_Android(WVR_DeviceType dev_type, WVR_DeviceErrorState error_state);

	public override bool GetDeviceErrorState(WVR_DeviceType dev_type, WVR_DeviceErrorState error_state)
	{
		return WVR_GetDeviceErrorState_Android(dev_type, error_state);
	}

	[DllImport("wvr_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_GetRenderTargetSize")]
	public static extern void WVR_GetRenderTargetSize_Android(ref uint width, ref uint height);

	public override void GetRenderTargetSize(ref uint width, ref uint height)
	{
		WVR_GetRenderTargetSize_Android(ref width, ref height);
	}

	[DllImport("wvr_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_GetProjection")]
	public static extern WVR_Matrix4f_t WVR_GetProjection_Android(WVR_Eye eye, float near, float far);

	public override WVR_Matrix4f_t GetProjection(WVR_Eye eye, float near, float far)
	{
		return WVR_GetProjection_Android(eye, near, far);
	}

	[DllImport("wvr_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_GetClippingPlaneBoundary")]
	public static extern void WVR_GetClippingPlaneBoundary_Android(WVR_Eye eye, ref float left, ref float right, ref float top, ref float bottom);

	public override void GetClippingPlaneBoundary(WVR_Eye eye, ref float left, ref float right, ref float top, ref float bottom)
	{
		WVR_GetClippingPlaneBoundary_Android(eye, ref left, ref right, ref top, ref bottom);
	}

	[DllImport("wvr_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_SetOverfillRatio")]
	public static extern void WVR_SetOverfillRatio_Android(float ratioX, float ratioY);

	public override void SetOverfillRatio(float ratioX, float ratioY)
	{
		WVR_SetOverfillRatio_Android(ratioX, ratioY);
	}

	[DllImport("wvr_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_GetTransformFromEyeToHead")]
	public static extern WVR_Matrix4f_t WVR_GetTransformFromEyeToHead_Android(WVR_Eye eye, WVR_NumDoF dof);

	public override WVR_Matrix4f_t GetTransformFromEyeToHead(WVR_Eye eye, WVR_NumDoF dof)
	{
		return WVR_GetTransformFromEyeToHead_Android(eye, dof);
	}

	[DllImport("wvr_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_SubmitFrame")]
	public static extern WVR_SubmitError WVR_SubmitFrame_Android(WVR_Eye eye, [In][Out] WVR_TextureParams_t[] param, [In][Out] WVR_PoseState_t[] pose, WVR_SubmitExtend extendMethod);

	public override WVR_SubmitError SubmitFrame(WVR_Eye eye, [In][Out] WVR_TextureParams_t[] param, [In][Out] WVR_PoseState_t[] pose, WVR_SubmitExtend extendMethod)
	{
		return WVR_SubmitFrame_Android(eye, param, pose, extendMethod);
	}

	[DllImport("wvr_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_PreRenderEye")]
	public static extern void WVR_PreRenderEye_Android(WVR_Eye eye, [In][Out] WVR_TextureParams_t[] param, [In][Out] WVR_RenderFoveationParams[] foveationParams);

	public override void PreRenderEye(WVR_Eye eye, [In][Out] WVR_TextureParams_t[] param, [In][Out] WVR_RenderFoveationParams[] foveationParams)
	{
		WVR_PreRenderEye_Android(eye, param, foveationParams);
	}

	[DllImport("wvr_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_RequestScreenshot")]
	public static extern bool WVR_RequestScreenshot_Android(uint width, uint height, WVR_ScreenshotMode mode, IntPtr filename);

	public override bool RequestScreenshot(uint width, uint height, WVR_ScreenshotMode mode, IntPtr filename)
	{
		return WVR_RequestScreenshot_Android(width, height, mode, filename);
	}

	[DllImport("wvr_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_RenderMask")]
	public static extern void WVR_RenderMask_Android(WVR_Eye eye);

	public override void RenderMask(WVR_Eye eye)
	{
		WVR_RenderMask_Android(eye);
	}

	[DllImport("wvr_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_GetRenderProps")]
	public static extern bool WVR_GetRenderProps_Android(ref WVR_RenderProps_t props);

	public override bool GetRenderProps(ref WVR_RenderProps_t props)
	{
		return WVR_GetRenderProps_Android(ref props);
	}

	[DllImport("wvr_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_ObtainTextureQueue")]
	public static extern IntPtr WVR_ObtainTextureQueue_Android(WVR_TextureTarget target, WVR_TextureFormat format, WVR_TextureType type, uint width, uint height, int level);

	public override IntPtr ObtainTextureQueue(WVR_TextureTarget target, WVR_TextureFormat format, WVR_TextureType type, uint width, uint height, int level)
	{
		return WVR_ObtainTextureQueue_Android(target, format, type, width, height, level);
	}

	[DllImport("wvr_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_GetTextureQueueLength")]
	public static extern uint WVR_GetTextureQueueLength_Android(IntPtr handle);

	public override uint GetTextureQueueLength(IntPtr handle)
	{
		return WVR_GetTextureQueueLength_Android(handle);
	}

	[DllImport("wvr_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_GetTexture")]
	public static extern WVR_TextureParams_t WVR_GetTexture_Android(IntPtr handle, int index);

	public override WVR_TextureParams_t GetTexture(IntPtr handle, int index)
	{
		return WVR_GetTexture_Android(handle, index);
	}

	[DllImport("wvr_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_GetAvailableTextureIndex")]
	public static extern int WVR_GetAvailableTextureIndex_Android(IntPtr handle);

	public override int GetAvailableTextureIndex(IntPtr handle)
	{
		return WVR_GetAvailableTextureIndex_Android(handle);
	}

	[DllImport("wvr_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_ReleaseTextureQueue")]
	public static extern void WVR_ReleaseTextureQueue_Android(IntPtr handle);

	public override void ReleaseTextureQueue(IntPtr handle)
	{
		WVR_ReleaseTextureQueue_Android(handle);
	}

	[DllImport("wvr_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_IsRenderFoveationSupport")]
	public static extern bool WVR_IsRenderFoveationSupport_Android();

	public override bool IsRenderFoveationSupport()
	{
		return WVR_IsRenderFoveationSupport_Android();
	}

	[DllImport("wvr_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_RenderFoveation")]
	public static extern void WVR_RenderFoveation_Android(bool enable);

	public override void RenderFoveation(bool enable)
	{
		WVR_RenderFoveation_Android(enable);
	}

	[DllImport("wvr_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_SetPosePredictEnabled")]
	public static extern void WVR_SetPosePredictEnabled_Android(WVR_DeviceType type, bool enabled_position_predict, bool enable_rotation_predict);

	public override void SetPosePredictEnabled(WVR_DeviceType type, bool enabled_position_predict, bool enable_rotation_predict)
	{
		WVR_SetPosePredictEnabled_Android(type, enabled_position_predict, enable_rotation_predict);
	}

	[DllImport("wvr_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_ShowPassthroughOverlay")]
	public static extern bool WVR_ShowPassthroughOverlay_Android(bool show);

	public override bool ShowPassthroughOverlay(bool show)
	{
		return WVR_ShowPassthroughOverlay_Android(show);
	}

	[DllImport("wvr_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_EnableAutoPassthrough")]
	public static extern void WVR_EnableAutoPassthrough_Android(bool enable);

	public override void EnableAutoPassthrough(bool enable)
	{
		WVR_EnableAutoPassthrough_Android(enable);
	}

	[DllImport("wvr_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_IsPassthroughOverlayVisible")]
	public static extern bool WVR_IsPassthroughOverlayVisible_Android();

	public override bool IsPassthroughOverlayVisible()
	{
		return WVR_IsPassthroughOverlayVisible_Android();
	}

	public override string DeployRenderModelAssets(int deviceIndex, string renderModelName)
	{
		AndroidJavaClass androidJavaClass = new AndroidJavaClass("com.htc.vr.unity.WVRUnityVRActivity");
		if (androidJavaClass == null || deviceIndex == -1)
		{
			return "";
		}
		AndroidJavaObject androidJavaObject = androidJavaClass.CallStatic<AndroidJavaObject>("getInstance", Array.Empty<object>());
		if (androidJavaObject != null)
		{
			AndroidJavaObject androidJavaObject2 = androidJavaObject.Call<AndroidJavaObject>("getControllerModelFileDescriptor", new object[1] { deviceIndex });
			if (androidJavaObject2 != null)
			{
				AndroidJavaObject androidJavaObject3 = new AndroidJavaObject("com.htc.vr.unity.FileUtils", androidJavaObject, androidJavaObject2);
				if (androidJavaObject3 != null)
				{
					string text = androidJavaObject3.Call<string>("deployRenderModelAssets", new object[1] { renderModelName });
					if (!(text == ""))
					{
						androidJavaClass = null;
						return text;
					}
				}
			}
		}
		androidJavaClass = null;
		return "";
	}

	[DllImport("wvr_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_SetFocusedController")]
	public static extern void WVR_SetFocusedController_Android(WVR_DeviceType focusController);

	public override void SetFocusedController(WVR_DeviceType focusController)
	{
		WVR_SetFocusedController_Android(focusController);
	}

	[DllImport("wvr_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_GetFocusedController")]
	public static extern WVR_DeviceType WVR_GetFocusedController_Android();

	public override WVR_DeviceType GetFocusedController()
	{
		return WVR_GetFocusedController_Android();
	}

	[DllImport("wvrassimp", CallingConvention = CallingConvention.Cdecl, EntryPoint = "OpenMesh")]
	public static extern bool WVR_OpenMesh_Android(string filename, ref uint sessiionid, IntPtr errorCode, bool merge);

	public override bool OpenMesh(string filename, ref uint sessionid, IntPtr errorCode, bool merge)
	{
		return WVR_OpenMesh_Android(filename, ref sessionid, errorCode, merge);
	}

	[DllImport("wvrassimp", CallingConvention = CallingConvention.Cdecl, EntryPoint = "getSectionCount")]
	public static extern bool WVR_getSectionCount_Android(uint sessionid, ref uint sectionCount);

	public override bool GetSectionCount(uint sessionid, ref uint sectionCount)
	{
		return WVR_getSectionCount_Android(sessionid, ref sectionCount);
	}

	[DllImport("wvrassimp", CallingConvention = CallingConvention.Cdecl, EntryPoint = "getMeshData")]
	public static extern bool WVR_getMeshData_Android(uint sessionid, [In][Out] FBXInfo_t[] infoArray);

	public override bool GetMeshData(uint sessionid, [In][Out] FBXInfo_t[] infoArray)
	{
		return WVR_getMeshData_Android(sessionid, infoArray);
	}

	[DllImport("wvrassimp", CallingConvention = CallingConvention.Cdecl, EntryPoint = "getSectionData")]
	public static extern bool WVR_getSectionData_Android(uint sessionid, uint sectionIndiceIndex, [In][Out] Vector3[] vecticeArray, [In][Out] Vector3[] normalArray, [In][Out] Vector2[] uvArray, [In][Out] int[] indiceArray, ref bool active);

	public override bool GetSectionData(uint sessionid, uint sectionIndiceIndex, [In][Out] Vector3[] vecticeArray, [In][Out] Vector3[] normalArray, [In][Out] Vector2[] uvArray, [In][Out] int[] indiceArray, ref bool active)
	{
		return WVR_getSectionData_Android(sessionid, sectionIndiceIndex, vecticeArray, normalArray, uvArray, indiceArray, ref active);
	}

	[DllImport("wvrassimp", CallingConvention = CallingConvention.Cdecl, EntryPoint = "releaseMesh")]
	public static extern void WVR_releaseMesh_Android(uint sessionid);

	public override void ReleaseMesh(uint sessionid)
	{
		WVR_releaseMesh_Android(sessionid);
	}

	private AndroidJavaObject javaArrayFromCS(string[] values)
	{
		AndroidJavaClass androidJavaClass = new AndroidJavaClass("java.lang.reflect.Array");
		AndroidJavaObject androidJavaObject = androidJavaClass.CallStatic<AndroidJavaObject>("newInstance", new object[2]
		{
			new AndroidJavaClass("java.lang.String"),
			values.Length
		});
		for (int i = 0; i < values.Length; i++)
		{
			androidJavaClass.CallStatic("set", androidJavaObject, i, new AndroidJavaObject("java.lang.String", values[i]));
		}
		return androidJavaObject;
	}

	public override bool IsPermissionInitialed()
	{
		bool result = false;
		if (permissionsManager == null)
		{
			AndroidJavaClass androidJavaClass = new AndroidJavaClass("com.htc.vr.permission.client.PermissionManager");
			if (androidJavaClass != null)
			{
				permissionsManager = androidJavaClass.CallStatic<AndroidJavaObject>("getInstance", Array.Empty<object>());
			}
		}
		if (permissionsManager != null)
		{
			result = permissionsManager.Call<bool>("isInitialized", Array.Empty<object>());
		}
		return result;
	}

	public override bool ShowDialogOnScene()
	{
		if (!IsPermissionInitialed())
		{
			return false;
		}
		return permissionsManager.Call<bool>("showDialogOnVRScene", Array.Empty<object>());
	}

	public override bool IsPermissionGranted(string permission)
	{
		if (!IsPermissionInitialed())
		{
			return false;
		}
		return permissionsManager.Call<bool>("isPermissionGranted", new object[1] { permission });
	}

	public override bool ShouldGrantPermission(string permission)
	{
		if (!IsPermissionInitialed())
		{
			return false;
		}
		return permissionsManager.Call<bool>("shouldGrantPermission", new object[1] { permission });
	}

	public override void RequestPermissions(string[] permissions, WVR_RequestCompleteCallback cb)
	{
		if (!IsPermissionInitialed())
		{
			return;
		}
		mCallback = cb;
		if (!permissionsManager.Call<bool>("isShow2D", Array.Empty<object>()))
		{
			permissionsManager.Call("requestPermissions", javaArrayFromCS(permissions), new RequestCompleteHandler());
			return;
		}
		using (AndroidJavaClass androidJavaClass = new AndroidJavaClass("com.unity3d.player.UnityPlayer"))
		{
			using AndroidJavaObject androidJavaObject = androidJavaClass.GetStatic<AndroidJavaObject>("currentActivity");
			androidJavaObject.Call("setRequestPermissionCallback", new RequestCompleteHandler());
		}
		permissionsManager.Call("requestPermissions", javaArrayFromCS(permissions), new RequestCompleteHandler());
	}

	public override void RequestUsbPermission(WVR_RequestUsbCompleteCallback cb)
	{
		if (IsPermissionInitialed())
		{
			mUsbCallback = cb;
			permissionsManager.Call("requestUsbPermission", new RequestUsbCompleteHandler());
		}
	}

	private bool initializeResourceObject()
	{
		if (ResourceWrapper == null)
		{
			AndroidJavaClass androidJavaClass = new AndroidJavaClass("com.htc.vr.unity.ResourceWrapper");
			if (androidJavaClass != null)
			{
				ResourceWrapper = androidJavaClass.CallStatic<AndroidJavaObject>("getInstance", Array.Empty<object>());
			}
		}
		if (ResourceWrapper != null)
		{
			return true;
		}
		return false;
	}

	public override string GetStringBySystemLanguage(string stringName)
	{
		string result = "";
		if (initializeResourceObject())
		{
			result = ResourceWrapper.Call<string>("getStringByName", new object[1] { stringName });
		}
		return result;
	}

	public override string GetStringByLanguage(string stringName, string lang, string country)
	{
		string result = "";
		if (initializeResourceObject())
		{
			result = ResourceWrapper.Call<string>("getPreferredStringByName", new object[3] { stringName, lang, country });
		}
		return result;
	}

	public override string GetSystemLanguage()
	{
		string result = "";
		if (initializeResourceObject())
		{
			result = ResourceWrapper.Call<string>("getSystemLanguage", Array.Empty<object>());
		}
		return result;
	}

	public override string GetSystemCountry()
	{
		string result = "";
		if (initializeResourceObject())
		{
			result = ResourceWrapper.Call<string>("getSystemCountry", Array.Empty<object>());
		}
		return result;
	}

	private static void initAJC()
	{
		if (mOEMConfig == null)
		{
			AndroidJavaClass androidJavaClass = new AndroidJavaClass("com.htc.vr.unity.WVRUnityVRActivity");
			if (androidJavaClass != null)
			{
				mOEMConfig = androidJavaClass.CallStatic<AndroidJavaObject>("getInstance", Array.Empty<object>());
				mOEMConfig.Call("setOEMChangedCB", mOEMCallback);
			}
		}
	}

	public override string GetOEMConfigByKey(string key)
	{
		string text = "";
		initAJC();
		if (mOEMConfig != null)
		{
			text = mOEMConfig.Call<string>("getJsonRawData", new object[1] { key });
		}
		text.Trim(' ');
		if (text.Length == 0 || text[0] != '{' || text[text.Length - 1] != '}')
		{
			return "";
		}
		return text;
	}

	public override void SetOEMConfigChangedCallback(WVR_OnOEMConfigChanged cb)
	{
		OEMChangedCallback = cb;
	}
}
public class WVR_HVR : Interop.WVR_Base
{
	[DllImport("wave_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_PollEventQueue")]
	public static extern bool WVR_PollEventQueue_HVR(ref WVR_Event_t e);

	public override bool PollEventQueue(ref WVR_Event_t e)
	{
		return WVR_PollEventQueue_HVR(ref e);
	}

	[DllImport("wave_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_GetInputDeviceCapability")]
	public static extern int WVR_GetInputDeviceCapability_HVR(WVR_DeviceType type, WVR_InputType inputType);

	public override int GetInputDeviceCapability(WVR_DeviceType type, WVR_InputType inputType)
	{
		return WVR_GetInputDeviceCapability_HVR(type, inputType);
	}

	[DllImport("wave_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_GetInputDeviceAnalogType")]
	public static extern WVR_AnalogType WVR_GetInputDeviceAnalogType_HVR(WVR_DeviceType type, WVR_InputId id);

	public override WVR_AnalogType GetInputDeviceAnalogType(WVR_DeviceType type, WVR_InputId id)
	{
		return WVR_GetInputDeviceAnalogType_HVR(type, id);
	}

	[DllImport("wave_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_GetInputDeviceState")]
	public static extern bool WVR_GetInputDeviceState_HVR(WVR_DeviceType type, uint inputMask, ref uint buttons, ref uint touches, [In][Out] WVR_AnalogState_t[] analogArray, uint analogArrayCount);

	public override bool GetInputDeviceState(WVR_DeviceType type, uint inputMask, ref uint buttons, ref uint touches, [In][Out] WVR_AnalogState_t[] analogArray, uint analogArrayCount)
	{
		return WVR_GetInputDeviceState_HVR(type, inputMask, ref buttons, ref touches, analogArray, analogArrayCount);
	}

	[DllImport("wave_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_GetInputTypeCount")]
	public static extern int WVR_GetInputTypeCount_HVR(WVR_DeviceType type, WVR_InputType inputType);

	public override int GetInputTypeCount(WVR_DeviceType type, WVR_InputType inputType)
	{
		return WVR_GetInputTypeCount_HVR(type, inputType);
	}

	[DllImport("wave_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_GetInputButtonState")]
	public static extern bool WVR_GetInputButtonState_HVR(WVR_DeviceType type, WVR_InputId id);

	public override bool GetInputButtonState(WVR_DeviceType type, WVR_InputId id)
	{
		return WVR_GetInputButtonState_HVR(type, id);
	}

	[DllImport("wave_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_GetInputTouchState")]
	public static extern bool WVR_GetInputTouchState_HVR(WVR_DeviceType type, WVR_InputId id);

	public override bool GetInputTouchState(WVR_DeviceType type, WVR_InputId id)
	{
		return WVR_GetInputTouchState_HVR(type, id);
	}

	[DllImport("wave_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_GetInputAnalogAxis")]
	public static extern WVR_Axis_t WVR_GetInputAnalogAxis_HVR(WVR_DeviceType type, WVR_InputId id);

	public override WVR_Axis_t GetInputAnalogAxis(WVR_DeviceType type, WVR_InputId id)
	{
		return WVR_GetInputAnalogAxis_HVR(type, id);
	}

	[DllImport("wave_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_GetPoseState")]
	public static extern void WVR_GetPoseState_HVR(WVR_DeviceType type, WVR_PoseOriginModel originModel, uint predictedMilliSec, ref WVR_PoseState_t poseState);

	public override void GetPoseState(WVR_DeviceType type, WVR_PoseOriginModel originModel, uint predictedMilliSec, ref WVR_PoseState_t poseState)
	{
		WVR_GetPoseState_HVR(type, originModel, predictedMilliSec, ref poseState);
	}

	[DllImport("wave_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_SetTextureBounds")]
	public static extern void WVR_SetTextureBounds_HVR([In][Out] WVR_TextureBound_t[] textureBound);

	public override void SetTextureBounds([In][Out] WVR_TextureBound_t[] textureBound)
	{
		WVR_Log.Log.i("WVR_HVR", "WVR_SetTextureBounds()");
		WVR_SetTextureBounds_HVR(textureBound);
	}

	[DllImport("wave_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_WaitGetPoseIndex")]
	public static extern void WVR_WaitGetPoseIndex_HVR(WVR_PoseOriginModel originModel, [In][Out] WVR_DevicePosePair_t[] poseArray, uint pairArrayCount, ref uint frameIndex);

	public override void WaitGetPoseIndex(WVR_PoseOriginModel originModel, [In][Out] WVR_DevicePosePair_t[] poseArray, uint pairArrayCount, ref uint frameIndex)
	{
		WVR_Log.Log.i("WVR_HVR", "WVR_WaitGetPoseIndex()");
		WVR_WaitGetPoseIndex_HVR(originModel, poseArray, pairArrayCount, ref frameIndex);
	}

	[DllImport("wave_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_GetLastPoseIndex")]
	public static extern void WVR_GetLastPoseIndex_HVR(WVR_PoseOriginModel originModel, [In][Out] WVR_DevicePosePair_t[] poseArray, uint pairArrayCount, ref uint frameIndex);

	public override void GetLastPoseIndex(WVR_PoseOriginModel originModel, [In][Out] WVR_DevicePosePair_t[] poseArray, uint pairArrayCount, ref uint frameIndex)
	{
		WVR_Log.Log.i("WVR_HVR", "GetLastPoseIndex()");
		WVR_GetLastPoseIndex_HVR(originModel, poseArray, pairArrayCount, ref frameIndex);
	}

	[DllImport("wave_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_GetSyncPose")]
	public static extern void WVR_GetSyncPose_HVR(WVR_PoseOriginModel originModel, [In][Out] WVR_DevicePosePair_t[] poseArray, uint pairArrayCount);

	public override void GetSyncPose(WVR_PoseOriginModel originModel, [In][Out] WVR_DevicePosePair_t[] poseArray, uint pairArrayCount)
	{
		WVR_Log.Log.i("WVR_HVR", "GetSyncPose()");
		WVR_GetSyncPose_HVR(originModel, poseArray, pairArrayCount);
	}

	[DllImport("wave_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_IsDeviceConnected")]
	public static extern bool WVR_IsDeviceConnected_HVR(WVR_DeviceType type);

	public override bool IsDeviceConnected(WVR_DeviceType type)
	{
		return WVR_IsDeviceConnected_HVR(type);
	}

	[DllImport("wave_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_TriggerVibration")]
	public static extern void WVR_TriggerVibration_HVR(WVR_DeviceType type, WVR_InputId id, uint durationMicroSec, uint frequency, WVR_Intensity intensity);

	public override void TriggerVibration(WVR_DeviceType type, WVR_InputId id, uint durationMicroSec, uint frequency, WVR_Intensity intensity)
	{
		WVR_TriggerVibration_HVR(type, id, durationMicroSec, frequency, intensity);
	}

	[DllImport("wave_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_InAppRecenter")]
	public static extern void WVR_InAppRecenter_HVR(WVR_RecenterType recenterType);

	public override void InAppRecenter(WVR_RecenterType recenterType)
	{
		WVR_InAppRecenter_HVR(recenterType);
	}

	[DllImport("wave_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_SetNeckModelEnabled")]
	public static extern void WVR_SetNeckModelEnabled_HVR(bool enabled);

	public override void SetNeckModelEnabled(bool enabled)
	{
	}

	[DllImport("wave_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_SetNeckModel")]
	public static extern void WVR_SetNeckModel_HVR(WVR_SimulationType simulationType);

	public override void SetNeckModel(WVR_SimulationType simulationType)
	{
		WVR_SetNeckModel_HVR(simulationType);
	}

	[DllImport("wave_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_SetArmModel")]
	public static extern void WVR_SetArmModel_HVR(WVR_SimulationType simulationType);

	public override void SetArmModel(WVR_SimulationType simulationType)
	{
	}

	[DllImport("wave_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_SetArmSticky")]
	public static extern void WVR_SetArmSticky_HVR(bool stickyArm);

	public override void SetArmSticky(bool stickyArm)
	{
	}

	[DllImport("wave_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_SetInputRequest")]
	public static extern bool WVR_SetInputRequest_HVR(WVR_DeviceType type, WVR_InputAttribute_t[] request, uint size);

	public override bool SetInputRequest(WVR_DeviceType type, WVR_InputAttribute_t[] request, uint size)
	{
		return WVR_SetInputRequest_HVR(type, request, size);
	}

	[DllImport("wave_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_GetInputMappingPair")]
	public static extern bool WVR_GetInputMappingPair_HVR(WVR_DeviceType type, WVR_InputId destination, ref WVR_InputMappingPair_t pair);

	public override bool GetInputMappingPair(WVR_DeviceType type, WVR_InputId destination, ref WVR_InputMappingPair_t pair)
	{
		return WVR_GetInputMappingPair_HVR(type, destination, ref pair);
	}

	[DllImport("wave_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_GetInputMappingTable")]
	public static extern uint WVR_GetInputMappingTable_HVR(WVR_DeviceType type, [In][Out] WVR_InputMappingPair_t[] table, uint size);

	public override uint GetInputMappingTable(WVR_DeviceType type, [In][Out] WVR_InputMappingPair_t[] table, uint size)
	{
		return WVR_GetInputMappingTable_HVR(type, table, size);
	}

	[DllImport("wave_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_GetArena")]
	public static extern WVR_Arena_t WVR_GetArena_HVR();

	public override WVR_Arena_t GetArena()
	{
		return WVR_GetArena_HVR();
	}

	[DllImport("wave_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_SetArena")]
	public static extern bool WVR_SetArena_HVR(ref WVR_Arena_t arena);

	public override bool SetArena(ref WVR_Arena_t arena)
	{
		return WVR_SetArena_HVR(ref arena);
	}

	[DllImport("wave_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_GetArenaVisible")]
	public static extern WVR_ArenaVisible WVR_GetArenaVisible_HVR();

	public override WVR_ArenaVisible GetArenaVisible()
	{
		return WVR_GetArenaVisible_HVR();
	}

	[DllImport("wave_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_SetArenaVisible")]
	public static extern void WVR_SetArenaVisible_HVR(WVR_ArenaVisible config);

	public override void SetArenaVisible(WVR_ArenaVisible config)
	{
		WVR_SetArenaVisible_HVR(config);
	}

	[DllImport("wave_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_IsOverArenaRange")]
	public static extern bool WVR_IsOverArenaRange_HVR();

	public override bool IsOverArenaRange()
	{
		return WVR_IsOverArenaRange_HVR();
	}

	[DllImport("wave_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_GetDeviceBatteryPercentage")]
	public static extern float WVR_GetDeviceBatteryPercentage_HVR(WVR_DeviceType type);

	public override float GetDeviceBatteryPercentage(WVR_DeviceType type)
	{
		return WVR_GetDeviceBatteryPercentage_HVR(type);
	}

	[DllImport("wave_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_GetBatteryStatus")]
	public static extern WVR_BatteryStatus WVR_GetBatteryStatus_HVR(WVR_DeviceType type);

	public override WVR_BatteryStatus GetBatteryStatus(WVR_DeviceType type)
	{
		return WVR_GetBatteryStatus_HVR(type);
	}

	[DllImport("wave_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_GetChargeStatus")]
	public static extern WVR_ChargeStatus WVR_GetChargeStatus_HVR(WVR_DeviceType type);

	public override WVR_ChargeStatus GetChargeStatus(WVR_DeviceType type)
	{
		return WVR_GetChargeStatus_HVR(type);
	}

	[DllImport("wave_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_GetBatteryTemperatureStatus")]
	public static extern WVR_BatteryTemperatureStatus WVR_GetBatteryTemperatureStatus_HVR(WVR_DeviceType type);

	public override WVR_BatteryTemperatureStatus GetBatteryTemperatureStatus(WVR_DeviceType type)
	{
		return WVR_GetBatteryTemperatureStatus_HVR(type);
	}

	[DllImport("wave_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_GetBatteryTemperature")]
	public static extern float WVR_GetBatteryTemperature_HVR(WVR_DeviceType type);

	public override float GetBatteryTemperature(WVR_DeviceType type)
	{
		return WVR_GetBatteryTemperature_HVR(type);
	}

	[DllImport("wave_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_Init")]
	public static extern WVR_InitError WVR_Init_HVR(WVR_AppType eType);

	public override WVR_InitError Init(WVR_AppType eType)
	{
		WVR_Log.Log.i("WVR_HVR", "Init()");
		return WVR_Init_HVR(eType);
	}

	[DllImport("wave_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_Quit")]
	public static extern void WVR_Quit_HVR();

	public override void Quit()
	{
		WVR_Log.Log.i("WVR_HVR", "Quit()");
		WVR_Quit_HVR();
	}

	[DllImport("wave_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_GetInitErrorString")]
	public static extern IntPtr WVR_GetInitErrorString_HVR(WVR_InitError error);

	public override IntPtr GetInitErrorString(WVR_InitError error)
	{
		WVR_Log.Log.i("WVR_HVR", "GetInitErrorString()");
		return WVR_GetInitErrorString_HVR(error);
	}

	[DllImport("wave_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_GetWaveRuntimeVersion")]
	public static extern uint WVR_GetWaveRuntimeVersion_HVR();

	public override uint GetWaveRuntimeVersion()
	{
		WVR_Log.Log.i("WVR_HVR", "GetWaveRuntimeVersion()");
		return WVR_GetWaveRuntimeVersion_HVR();
	}

	[DllImport("wave_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_GetWaveSDKVersion")]
	public static extern uint WVR_GetWaveSDKVersion_HVR();

	public override uint GetWaveSDKVersion()
	{
		WVR_Log.Log.i("WVR_HVR", "GetWaveSDKVersion()");
		return 1u;
	}

	[DllImport("wave_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_IsInputFocusCapturedBySystem")]
	public static extern bool WVR_IsInputFocusCapturedBySystem_HVR();

	public override bool IsInputFocusCapturedBySystem()
	{
		WVR_Log.Log.i("WVR_HVR", "IsInputFocusCapturedBySystem()");
		return WVR_IsInputFocusCapturedBySystem_HVR();
	}

	[DllImport("wave_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_RenderInit")]
	internal static extern WVR_RenderError WVR_RenderInit_HVR(ref WVR_RenderInitParams_t param);

	internal override WVR_RenderError RenderInit(ref WVR_RenderInitParams_t param)
	{
		return WVR_RenderInit_HVR(ref param);
	}

	[DllImport("wave_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_SetPerformanceLevels")]
	internal static extern bool WVR_SetPerformanceLevels_HVR(WVR_PerfLevel cpuLevel, WVR_PerfLevel gpuLevel);

	internal override bool SetPerformanceLevels(WVR_PerfLevel cpuLevel, WVR_PerfLevel gpuLevel)
	{
		WVR_Log.Log.i("WVR_HVR", "SetPerformanceLevels()");
		return false;
	}

	[DllImport("wave_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_EnableAdaptiveQuality")]
	internal static extern bool WVR_EnableAdaptiveQuality_HVR(bool enable, uint flags);

	internal override bool EnableAdaptiveQuality(bool enable, uint flags)
	{
		WVR_Log.Log.i("WVR_HVR", "EnableAdaptiveQuality()");
		return false;
	}

	[DllImport("wave_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_IsAdaptiveQualityEnabled")]
	internal static extern bool WVR_IsAdaptiveQualityEnabled_HVR();

	internal override bool IsAdaptiveQualityEnabled()
	{
		WVR_Log.Log.i("WVR_HVR", "IsAdaptiveQualityEnabled()");
		return WVR_IsAdaptiveQualityEnabled_HVR();
	}

	[DllImport("wave_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_StartCamera")]
	public static extern bool WVR_StartCamera_HVR(ref WVR_CameraInfo_t info);

	public override bool StartCamera(ref WVR_CameraInfo_t info)
	{
		WVR_Log.Log.i("WVR_HVR", "StartCamera()");
		return WVR_StartCamera_HVR(ref info);
	}

	[DllImport("wave_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_StopCamera")]
	public static extern void WVR_StopCamera_HVR();

	public override void StopCamera()
	{
		WVR_Log.Log.i("WVR_HVR", "StopCamera()");
		WVR_StopCamera_HVR();
	}

	[DllImport("wave_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_UpdateTexture")]
	public static extern bool WVR_UpdateTexture_HVR(IntPtr textureid);

	public override bool UpdateTexture(IntPtr textureid)
	{
		WVR_Log.Log.i("WVR_HVR", "UpdateTexture()");
		return WVR_UpdateTexture_HVR(textureid);
	}

	[DllImport("wave_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "DrawTextureWithBuffer")]
	public static extern bool DrawTextureWithBuffer_HVR(IntPtr textureId, WVR_CameraImageFormat imgFormat, IntPtr frameBuffer, uint size, uint width, uint height);

	public override bool DrawTextureWithBuffer(IntPtr textureId, WVR_CameraImageFormat imgFormat, IntPtr frameBuffer, uint size, uint width, uint height)
	{
		return DrawTextureWithBuffer_HVR(textureId, imgFormat, frameBuffer, size, width, height);
	}

	[DllImport("wave_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_GetCameraIntrinsic")]
	public static extern bool WVR_GetCameraIntrinsic_HVR(WVR_CameraPosition position, ref WVR_CameraIntrinsic_t intrinsic);

	public override bool GetCameraIntrinsic(WVR_CameraPosition position, ref WVR_CameraIntrinsic_t intrinsic)
	{
		WVR_Log.Log.i("WVR_HVR", "GetCameraIntrinsic()");
		return WVR_GetCameraIntrinsic_HVR(position, ref intrinsic);
	}

	[DllImport("wave_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_IsDeviceSuspend")]
	public static extern bool WVR_IsDeviceSuspend_HVR(WVR_DeviceType type);

	public override bool IsDeviceSuspend(WVR_DeviceType type)
	{
		WVR_Log.Log.i("WVR_HVR", "IsDeviceSuspend()");
		return WVR_IsDeviceSuspend_HVR(type);
	}

	[DllImport("wave_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_ConvertMatrixQuaternion")]
	public static extern void WVR_ConvertMatrixQuaternion_HVR(ref WVR_Matrix4f_t mat, ref WVR_Quatf_t quat, bool m2q);

	public override void ConvertMatrixQuaternion(ref WVR_Matrix4f_t mat, ref WVR_Quatf_t quat, bool m2q)
	{
		WVR_Log.Log.i("WVR_HVR", "ConvertMatrixQuaternion()");
		WVR_ConvertMatrixQuaternion_HVR(ref mat, ref quat, m2q);
	}

	[DllImport("wave_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_GetDegreeOfFreedom")]
	public static extern WVR_NumDoF WVR_GetDegreeOfFreedom_HVR(WVR_DeviceType type);

	public override WVR_NumDoF GetDegreeOfFreedom(WVR_DeviceType type)
	{
		WVR_Log.Log.i("WVR_HVR", "GetDegreeOfFreedom()");
		return WVR_GetDegreeOfFreedom_HVR(type);
	}

	[DllImport("wave_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_SetParameters")]
	public static extern void WVR_SetParameters_HVR(WVR_DeviceType type, IntPtr pchValue);

	public override void SetParameters(WVR_DeviceType type, IntPtr pchValue)
	{
		WVR_Log.Log.i("WVR_HVR", "SetParameters()");
		WVR_SetParameters_HVR(type, pchValue);
	}

	[DllImport("wave_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_GetParameters")]
	public static extern uint WVR_GetParameters_HVR(WVR_DeviceType type, IntPtr pchValue, IntPtr retValue, uint unBufferSize);

	public override uint GetParameters(WVR_DeviceType type, IntPtr pchValue, IntPtr retValue, uint unBufferSize)
	{
		WVR_Log.Log.i("WVR_HVR", "GetParameters()");
		return WVR_GetParameters_HVR(type, pchValue, retValue, unBufferSize);
	}

	[DllImport("wave_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_GetDefaultControllerRole")]
	public static extern WVR_DeviceType WVR_GetDefaultControllerRole_HVR();

	public override WVR_DeviceType GetDefaultControllerRole()
	{
		return WVR_GetDefaultControllerRole_HVR();
	}

	[DllImport("wave_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_SetInteractionMode")]
	public static extern bool WVR_SetInteractionMode_HVR(WVR_InteractionMode mode);

	public override bool SetInteractionMode(WVR_InteractionMode mode)
	{
		return WVR_SetInteractionMode_HVR(mode);
	}

	[DllImport("wave_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_GetInteractionMode")]
	public static extern WVR_InteractionMode WVR_GetInteractionMode_HVR();

	public override WVR_InteractionMode GetInteractionMode()
	{
		return WVR_GetInteractionMode_HVR();
	}

	[DllImport("wave_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_SetGazeTriggerType")]
	public static extern bool WVR_SetGazeTriggerType_HVR(WVR_GazeTriggerType type);

	public override bool SetGazeTriggerType(WVR_GazeTriggerType type)
	{
		return WVR_SetGazeTriggerType_HVR(type);
	}

	[DllImport("wave_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_GetGazeTriggerType")]
	public static extern WVR_GazeTriggerType WVR_GetGazeTriggerType_HVR();

	public override WVR_GazeTriggerType GetGazeTriggerType()
	{
		return WVR_GetGazeTriggerType_HVR();
	}

	[DllImport("wave_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_GetDeviceErrorState")]
	public static extern bool WVR_GetDeviceErrorState_HVR(WVR_DeviceType dev_type, WVR_DeviceErrorState error_state);

	public override bool GetDeviceErrorState(WVR_DeviceType dev_type, WVR_DeviceErrorState error_state)
	{
		WVR_Log.Log.i("WVR_HVR", "GetDeviceErrorState()");
		return WVR_GetDeviceErrorState_HVR(dev_type, error_state);
	}

	[DllImport("wave_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_GetRenderTargetSize")]
	public static extern void WVR_GetRenderTargetSize_HVR(ref uint width, ref uint height);

	public override void GetRenderTargetSize(ref uint width, ref uint height)
	{
		WVR_Log.Log.i("WVR_HVR", "GetRenderTargetSize()");
		WVR_GetRenderTargetSize_HVR(ref width, ref height);
	}

	[DllImport("wave_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_GetProjection")]
	public static extern WVR_Matrix4f_t WVR_GetProjection_HVR(WVR_Eye eye, float near, float far);

	public override WVR_Matrix4f_t GetProjection(WVR_Eye eye, float near, float far)
	{
		WVR_Log.Log.i("WVR_HVR", "GetProjection()");
		return WVR_GetProjection_HVR(eye, near, far);
	}

	[DllImport("wave_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_GetClippingPlaneBoundary")]
	public static extern void WVR_GetClippingPlaneBoundary_HVR(WVR_Eye eye, ref float left, ref float right, ref float top, ref float bottom);

	public override void GetClippingPlaneBoundary(WVR_Eye eye, ref float left, ref float right, ref float top, ref float bottom)
	{
		WVR_Log.Log.i("WVR_HVR", "GetClippingPlaneBoundary()");
		WVR_GetClippingPlaneBoundary_HVR(eye, ref left, ref right, ref top, ref bottom);
	}

	[DllImport("wave_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_SetOverfillRatio")]
	public static extern void WVR_SetOverfillRatio_HVR(float ratioX, float ratioY);

	public override void SetOverfillRatio(float ratioX, float ratioY)
	{
		WVR_Log.Log.i("WVR_HVR", "SetOverfillRatio()");
		WVR_SetOverfillRatio_HVR(ratioX, ratioY);
	}

	[DllImport("wave_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_GetTransformFromEyeToHead")]
	public static extern WVR_Matrix4f_t WVR_GetTransformFromEyeToHead_HVR(WVR_Eye eye, WVR_NumDoF dof);

	public override WVR_Matrix4f_t GetTransformFromEyeToHead(WVR_Eye eye, WVR_NumDoF dof)
	{
		WVR_Log.Log.i("WVR_HVR", "GetTransformFromEyeToHead()");
		return WVR_GetTransformFromEyeToHead_HVR(eye, dof);
	}

	[DllImport("wave_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_SubmitFrame")]
	public static extern WVR_SubmitError WVR_SubmitFrame_HVR(WVR_Eye eye, [In][Out] WVR_TextureParams_t[] param, [In][Out] WVR_PoseState_t[] pose, WVR_SubmitExtend extendMethod);

	public override WVR_SubmitError SubmitFrame(WVR_Eye eye, [In][Out] WVR_TextureParams_t[] param, [In][Out] WVR_PoseState_t[] pose, WVR_SubmitExtend extendMethod)
	{
		WVR_Log.Log.i("WVR_HVR", "SubmitFrame()");
		return WVR_SubmitFrame_HVR(eye, param, pose, extendMethod);
	}

	[DllImport("wave_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_SetSubmitParams")]
	public static extern void WVR_SetSubmitParams_HVR(WVR_Eye eye, [Out] WVR_TextureParams_t[] param, [Out] WVR_PoseState_t[] pose, WVR_SubmitExtend extendMethod);

	public override void SetSubmitParams(WVR_Eye eye, [In][Out] WVR_TextureParams_t[] param, [In][Out] WVR_PoseState_t[] pose, WVR_SubmitExtend extendMethod)
	{
		WVR_Log.Log.i("WVR_HVR", "SetSubmitParams()");
		WVR_SetSubmitParams_HVR(eye, param, pose, extendMethod);
	}

	[DllImport("wave_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_RequestScreenshot")]
	public static extern bool WVR_RequestScreenshot_HVR(uint width, uint height, WVR_ScreenshotMode mode, IntPtr filename);

	public override bool RequestScreenshot(uint width, uint height, WVR_ScreenshotMode mode, IntPtr filename)
	{
		WVR_Log.Log.i("WVR_HVR", "RequestScreenshot()");
		return WVR_RequestScreenshot_HVR(width, height, mode, filename);
	}

	[DllImport("wave_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_RenderMask")]
	public static extern void WVR_RenderMask_HVR(WVR_Eye eye);

	public override void RenderMask(WVR_Eye eye)
	{
		WVR_Log.Log.i("WVR_HVR", "RenderMask()");
		WVR_RenderMask_HVR(eye);
	}

	[DllImport("wave_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_GetRenderProps")]
	public static extern bool WVR_GetRenderProps_HVR(ref WVR_RenderProps_t props);

	public override bool GetRenderProps(ref WVR_RenderProps_t props)
	{
		WVR_Log.Log.i("WVR_HVR", "GetRenderProps()");
		return WVR_GetRenderProps_HVR(ref props);
	}

	[DllImport("wave_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_ObtainTextureQueue")]
	public static extern IntPtr WVR_ObtainTextureQueue_HVR(WVR_TextureTarget target, WVR_TextureFormat format, WVR_TextureType type, uint width, uint height, int level);

	public override IntPtr ObtainTextureQueue(WVR_TextureTarget target, WVR_TextureFormat format, WVR_TextureType type, uint width, uint height, int level)
	{
		WVR_Log.Log.i("WVR_HVR", "ObtainTextureQueue()");
		return WVR_ObtainTextureQueue_HVR(target, format, type, width, height, level);
	}

	[DllImport("wave_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_GetTextureQueueLength")]
	public static extern uint WVR_GetTextureQueueLength_HVR(IntPtr handle);

	public override uint GetTextureQueueLength(IntPtr handle)
	{
		WVR_Log.Log.i("WVR_HVR", "GetTextureQueueLength()");
		return WVR_GetTextureQueueLength_HVR(handle);
	}

	[DllImport("wave_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_GetTexture")]
	public static extern WVR_TextureParams_t WVR_GetTexture_HVR(IntPtr handle, int index);

	public override WVR_TextureParams_t GetTexture(IntPtr handle, int index)
	{
		WVR_Log.Log.i("WVR_HVR", "GetTexture()");
		return WVR_GetTexture_HVR(handle, index);
	}

	[DllImport("wave_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_GetAvailableTextureIndex")]
	public static extern int WVR_GetAvailableTextureIndex_HVR(IntPtr handle);

	public override int GetAvailableTextureIndex(IntPtr handle)
	{
		WVR_Log.Log.i("WVR_HVR", "GetAvailableTextureIndex()");
		return WVR_GetAvailableTextureIndex_HVR(handle);
	}

	[DllImport("wave_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_ReleaseTextureQueue")]
	public static extern void WVR_ReleaseTextureQueue_HVR(IntPtr handle);

	public override void ReleaseTextureQueue(IntPtr handle)
	{
		WVR_Log.Log.i("WVR_HVR", "ReleaseTextureQueue()");
		WVR_ReleaseTextureQueue_HVR(handle);
	}

	[DllImport("wave_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_IsRenderFoveationSupport")]
	public static extern bool WVR_IsRenderFoveationSupport_HVR();

	public override bool IsRenderFoveationSupport()
	{
		return WVR_IsRenderFoveationSupport_HVR();
	}

	[DllImport("wave_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_RenderFoveation")]
	public static extern void WVR_RenderFoveation_HVR(bool enable);

	public override void RenderFoveation(bool enable)
	{
		WVR_Log.Log.i("WVR_HVR", "RenderFoveation()");
		WVR_RenderFoveation_HVR(enable);
	}

	[DllImport("wave_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_SetFocusedController")]
	public static extern void WVR_SetFocusedController_HVR(WVR_DeviceType focusController);

	public override void SetFocusedController(WVR_DeviceType focusController)
	{
		WVR_Log.Log.i("WVR_HVR", "SetFocusedController()");
		WVR_SetFocusedController_HVR(focusController);
	}

	[DllImport("wave_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_GetFocusedController")]
	public static extern WVR_DeviceType WVR_GetFocusedController_HVR();

	public override WVR_DeviceType GetFocusedController()
	{
		WVR_Log.Log.i("WVR_HVR", "GetFocusedController()");
		return WVR_GetFocusedController_HVR();
	}

	[DllImport("wave_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_StoreRenderTextures")]
	public static extern IntPtr WVR_StoreRenderTexturesHVR(IntPtr[] texturesIDs, int size, bool eEye, WVR_TextureTarget target);

	public override IntPtr StoreRenderTextures(IntPtr[] texturesIDs, int size, bool eEye, WVR_TextureTarget target)
	{
		WVR_Log.Log.i("WVR_HVR", "StoreRenderTextures()");
		return WVR_StoreRenderTexturesHVR(texturesIDs, size, eEye, target);
	}
}
[Serializable]
public class MeshObject
{
	public string MeshName;

	public bool hasEffect;

	public GameObject gameObject;

	public Vector3 originPosition;

	public Material originMat;

	public Material effectMat;
}
public class WaveVR_AdaptiveControllerActions : MonoBehaviour
{
	public class WVR_InputObject
	{
		public WVR_InputId destination;

		public WVR_InputId sourceId;
	}

	private enum keyMappingInputType
	{
		TouchDown,
		TouchUp,
		PressDown,
		PressUp
	}

	private static string LOG_TAG = "WaveVR_AdaptiveControllerActions";

	public bool enableButtonEffect = true;

	public WaveVR_Controller.EDeviceType device = WaveVR_Controller.EDeviceType.Dominant;

	public bool useSystemConfig = true;

	public Color buttonEffectColor = new Color(0f, 179f, 227f, 255f);

	public bool collectInStart = true;

	private int volume_index;

	private static readonly WVR_InputId[] pressIds = new WVR_InputId[14]
	{
		WVR_InputId.WVR_InputId_0,
		WVR_InputId.WVR_InputId_1,
		WVR_InputId.WVR_InputId_2,
		WVR_InputId.WVR_InputId_3,
		WVR_InputId.WVR_InputId_4,
		WVR_InputId.WVR_InputId_5,
		WVR_InputId.WVR_InputId_6,
		WVR_InputId.WVR_InputId_7,
		WVR_InputId.WVR_InputId_8,
		WVR_InputId.WVR_InputId_9,
		WVR_InputId.WVR_InputId_16,
		WVR_InputId.WVR_InputId_17,
		WVR_InputId.WVR_InputId_7,
		WVR_InputId.WVR_InputId_8
	};

	private static readonly string[] PressEffectNames = new string[14]
	{
		"__CM__HomeButton", "__CM__AppButton", "__CM__Grip", "__CM__DPad_Left", "__CM__DPad_Up", "__CM__DPad_Right", "__CM__DPad_Down", "__CM__VolumeUp", "__CM__VolumeDown", "__CM__DigitalTriggerKey",
		"__CM__TouchPad", "__CM__TriggerKey", "__CM__VolumeKey", "__CM__VolumeKey"
	};

	private MeshObject[] pressObjectArrays = new MeshObject[pressIds.Length];

	private static readonly WVR_InputId[] touchIds = new WVR_InputId[1] { WVR_InputId.WVR_InputId_16 };

	private static readonly string[] TouchEffectNames = new string[1] { "__CM__TouchPad_Touch" };

	private MeshObject[] touchObjectArrays = new MeshObject[touchIds.Length];

	private GameObject touchpad;

	private Mesh touchpadMesh;

	private Mesh toucheffectMesh;

	private bool currentIsLeftHandMode;

	private int touch_index = -1;

	private Material effectMat;

	private Material touchMat;

	private bool mergeToOneBone;

	private bool isTouchPadSetting;

	private Vector3 touchCenter = new Vector3(0f, 0f, 0f);

	private float raidus;

	private Vector3 touchPtW;

	private Vector3 touchPtU;

	private Vector3 touchPtV;

	private float touchptHeight;

	private ModelSpecify modelSpecify;

	private void PrintDebugLog(string msg)
	{
		WVR_Log.Log.d(LOG_TAG, string.Concat("device: ", device, ", ", msg));
	}

	private void PrintInfoLog(string msg)
	{
		WVR_Log.Log.i(LOG_TAG, string.Concat("device: ", device, ", ", msg));
	}

	private void onAdaptiveControllerModelReady(params object[] args)
	{
		if ((WaveVR_Controller.EDeviceType)args[0] == device)
		{
			CollectEffectObjects();
		}
	}

	private void OnEnable()
	{
		if (device == WaveVR_Controller.EDeviceType.Dominant)
		{
			modelSpecify = ModelSpecify.MS_Dominant;
		}
		else
		{
			modelSpecify = ModelSpecify.MS_NonDominant;
		}
		resetButtonState();
		WaveVR_Utils.Event.Listen(WaveVR_Utils.Event.ADAPTIVE_CONTROLLER_READY, onAdaptiveControllerModelReady);
	}

	private void OnDisable()
	{
		WaveVR_Utils.Event.Remove(WaveVR_Utils.Event.ADAPTIVE_CONTROLLER_READY, onAdaptiveControllerModelReady);
	}

	private void OnApplicationPause(bool pauseStatus)
	{
		if (!pauseStatus)
		{
			PrintInfoLog("Pause(" + pauseStatus + ") and reset button state");
			resetButtonState();
		}
	}

	private void resetButtonState()
	{
		PrintDebugLog("reset button state");
		if (!enableButtonEffect)
		{
			PrintInfoLog("enable button effect : false");
			return;
		}
		for (int i = 0; i < pressObjectArrays.Length; i++)
		{
			if (pressObjectArrays[i] != null && pressObjectArrays[i].hasEffect && pressObjectArrays[i].gameObject != null && pressObjectArrays[i].originMat != null && pressObjectArrays[i].effectMat != null)
			{
				pressObjectArrays[i].gameObject.GetComponent<MeshRenderer>().material = pressObjectArrays[i].originMat;
				if (mergeToOneBone)
				{
					pressObjectArrays[i].gameObject.SetActive(value: false);
				}
			}
		}
		for (int j = 0; j < touchObjectArrays.Length; j++)
		{
			if (touchObjectArrays[j] != null && touchObjectArrays[j].hasEffect && touchObjectArrays[j].gameObject != null && touchObjectArrays[j].originMat != null && touchObjectArrays[j].effectMat != null)
			{
				touchObjectArrays[j].gameObject.GetComponent<MeshRenderer>().material = touchObjectArrays[j].originMat;
				touchObjectArrays[j].gameObject.SetActive(value: false);
			}
		}
	}

	private void Start()
	{
		resetButtonState();
		if (collectInStart)
		{
			CollectEffectObjects();
		}
	}

	private void Update()
	{
		if (!enableButtonEffect)
		{
			return;
		}
		if (currentIsLeftHandMode != WaveVR_Controller.IsLeftHanded)
		{
			currentIsLeftHandMode = WaveVR_Controller.IsLeftHanded;
			PrintInfoLog("Controller role is changed to " + (currentIsLeftHandMode ? "Left" : "Right") + " and reset button state");
			resetButtonState();
		}
		for (int i = 0; i < pressIds.Length; i++)
		{
			if (pressObjectArrays[i] == null)
			{
				continue;
			}
			if (WaveVR_Controller.Input(device).GetPressDown(pressIds[i]))
			{
				int pressInputMapping = GetPressInputMapping(i, keyMappingInputType.PressDown);
				if (pressInputMapping == -1)
				{
					continue;
				}
				if (pressObjectArrays[pressInputMapping].hasEffect)
				{
					if (pressObjectArrays[pressInputMapping].gameObject != null && pressObjectArrays[pressInputMapping].originMat != null && pressObjectArrays[pressInputMapping].effectMat != null)
					{
						pressObjectArrays[pressInputMapping].gameObject.GetComponent<MeshRenderer>().material = pressObjectArrays[pressInputMapping].effectMat;
						if (mergeToOneBone)
						{
							pressObjectArrays[pressInputMapping].gameObject.SetActive(value: true);
						}
					}
				}
				else
				{
					PrintInfoLog(string.Concat(pressIds[pressInputMapping], " doesn't have effect"));
				}
			}
			if (!WaveVR_Controller.Input(device).GetPressUp(pressIds[i]))
			{
				continue;
			}
			int pressInputMapping2 = GetPressInputMapping(i, keyMappingInputType.PressUp);
			if (pressInputMapping2 == -1)
			{
				continue;
			}
			if (pressObjectArrays[pressInputMapping2].hasEffect)
			{
				if (pressObjectArrays[pressInputMapping2].gameObject != null && pressObjectArrays[pressInputMapping2].originMat != null && pressObjectArrays[pressInputMapping2].effectMat != null)
				{
					pressObjectArrays[pressInputMapping2].gameObject.GetComponent<MeshRenderer>().material = pressObjectArrays[pressInputMapping2].originMat;
					if (mergeToOneBone)
					{
						pressObjectArrays[pressInputMapping2].gameObject.SetActive(value: false);
					}
				}
			}
			else
			{
				PrintInfoLog(string.Concat(pressIds[pressInputMapping2], " doesn't have effect"));
			}
		}
		for (int j = 0; j < touchIds.Length; j++)
		{
			if (touchObjectArrays[j] == null)
			{
				continue;
			}
			if (WaveVR_Controller.Input(device).GetTouchDown(touchIds[j]))
			{
				int num = (touch_index = GetTouchInputMapping(j, keyMappingInputType.TouchDown));
				if (num == -1)
				{
					continue;
				}
				if (touchObjectArrays[num].hasEffect)
				{
					if (touchObjectArrays[num].gameObject != null && touchObjectArrays[num].originMat != null && touchObjectArrays[num].effectMat != null)
					{
						touchObjectArrays[num].gameObject.GetComponent<MeshRenderer>().material = touchObjectArrays[num].effectMat;
						touchObjectArrays[num].gameObject.SetActive(value: true);
					}
				}
				else
				{
					PrintInfoLog(string.Concat(touchIds[num], " doesn't have effect"));
				}
			}
			if (WaveVR_Controller.Input(device).GetTouch(touchIds[j]))
			{
				int num2 = touch_index;
				if (num2 == -1)
				{
					continue;
				}
				if (touchObjectArrays[num2].hasEffect && touchObjectArrays[num2].MeshName == "__CM__TouchPad_Touch" && touchObjectArrays[num2].gameObject != null && touchObjectArrays[num2].originMat != null && touchObjectArrays[num2].effectMat != null)
				{
					Vector2 axis = WaveVR_Controller.Input(device).GetAxis(WVR_InputId.WVR_InputId_16);
					if (isTouchPadSetting)
					{
						float num3 = touchCenter.x / 100f + axis.x * raidus * touchPtU.x / 100f + axis.y * raidus * touchPtW.x / 100f + touchptHeight * touchPtV.x / 100f;
						float num4 = touchCenter.y / 100f + axis.x * raidus * touchPtU.y / 100f + axis.y * raidus * touchPtW.y / 100f + touchptHeight * touchPtV.y / 100f;
						float num5 = touchCenter.z / 100f + axis.x * raidus * touchPtU.z / 100f + axis.y * raidus * touchPtW.z / 100f + touchptHeight * touchPtV.z / 100f;
						if (WVR_Log.Log.gpl.Print)
						{
							WVR_Log.Log.d(LOG_TAG, string.Concat("device: ", device, ", Touchpad axis x: ", axis.x, " axis.y: ", axis.y, ", xangle: ", num3, ", yangle: ", num4, ", zangle: ", num5));
						}
						Vector3 position = base.transform.TransformPoint(num3, num4, num5);
						touchObjectArrays[num2].gameObject.transform.position = position;
					}
					else
					{
						float num6 = axis.x * (touchpadMesh.bounds.size.x * touchpad.transform.localScale.x - toucheffectMesh.bounds.size.x * touchObjectArrays[num2].gameObject.transform.localScale.x) / 2f;
						float num7 = axis.y * (touchpadMesh.bounds.size.z * touchpad.transform.localScale.z - toucheffectMesh.bounds.size.z * touchObjectArrays[num2].gameObject.transform.localScale.z) / 2f;
						float num8 = touchpadMesh.bounds.size.y * touchpad.transform.localScale.y;
						float num9 = Mathf.Abs(touchpadMesh.bounds.max.y);
						if (WVR_Log.Log.gpl.Print)
						{
							WVR_Log.Log.d(LOG_TAG, string.Concat("device: ", device, ", Touchpad axis x: ", axis.x, " axis.y: ", axis.y, ", xangle: ", num6, ", yangle: ", num7, ", height: ", num8, ",h: ", num9));
						}
						Vector3 zero = Vector3.zero;
						zero = new Vector3(num6, num9, num7);
						touchObjectArrays[num2].gameObject.transform.localPosition = touchObjectArrays[num2].originPosition + zero;
					}
				}
			}
			if (!WaveVR_Controller.Input(device).GetTouchUp(touchIds[j]))
			{
				continue;
			}
			int touchInputMapping = GetTouchInputMapping(j, keyMappingInputType.TouchUp);
			if (touchInputMapping == -1)
			{
				continue;
			}
			if (touchObjectArrays[touchInputMapping].hasEffect)
			{
				if (touchObjectArrays[touchInputMapping].gameObject != null && touchObjectArrays[touchInputMapping].originMat != null && touchObjectArrays[touchInputMapping].effectMat != null)
				{
					touchObjectArrays[touchInputMapping].gameObject.GetComponent<MeshRenderer>().material = touchObjectArrays[touchInputMapping].originMat;
					touchObjectArrays[touchInputMapping].gameObject.SetActive(value: false);
				}
			}
			else
			{
				PrintInfoLog(string.Concat(touchIds[touchInputMapping], " doesn't have effect"));
			}
		}
	}

	private bool GetTouchPadParam()
	{
		WVR_DeviceType deviceType = WaveVR_Controller.Input(device).DeviceType;
		if (!WaveVR_Controller.Input(device).connected)
		{
			PrintDebugLog("Device is disconnect: ");
			return false;
		}
		IntPtr intPtr = Marshal.StringToHGlobalAnsi("GetRenderModelName");
		IntPtr intPtr2 = Marshal.AllocHGlobal(64);
		uint unBufferSize = 64u;
		uint num = Interop.WVR_GetParameters(deviceType, intPtr, intPtr2, unBufferSize);
		string text = Marshal.PtrToStringAnsi(intPtr2);
		Marshal.FreeHGlobal(intPtr);
		Marshal.FreeHGlobal(intPtr2);
		if (num == 0)
		{
			PrintDebugLog("Get render model name fail!");
			return false;
		}
		PrintDebugLog("current render model name: " + text);
		ModelResource renderModelResource = WaveVR_ControllerResourceHolder.Instance.getRenderModelResource(text, modelSpecify, mergeToOneBone);
		if (renderModelResource == null && modelSpecify == ModelSpecify.MS_NonDominant)
		{
			renderModelResource = WaveVR_ControllerResourceHolder.Instance.getRenderModelResource(text, ModelSpecify.MS_Dominant, mergeToOneBone);
		}
		if (renderModelResource == null || renderModelResource.TouchSetting == null)
		{
			PrintDebugLog("Get render model resource fail!");
			return false;
		}
		touchCenter = renderModelResource.TouchSetting.touchCenter;
		touchPtW = renderModelResource.TouchSetting.touchPtW;
		touchPtU = renderModelResource.TouchSetting.touchPtU;
		touchPtV = renderModelResource.TouchSetting.touchPtV;
		raidus = renderModelResource.TouchSetting.raidus;
		touchptHeight = renderModelResource.TouchSetting.touchptHeight;
		PrintDebugLog("touchCenter! x: " + touchCenter.x + " ,y: " + touchCenter.y + " ,z: " + touchCenter.z);
		PrintDebugLog("touchPtW! x: " + touchPtW.x + " ,y: " + touchPtW.y + " ,z: " + touchPtW.z);
		PrintDebugLog("touchPtU! x: " + touchPtU.x + " ,y: " + touchPtU.y + " ,z: " + touchPtU.z);
		PrintDebugLog("touchPtV! x: " + touchPtV.x + " ,y: " + touchPtV.y + " ,z: " + touchPtV.z);
		PrintDebugLog("raidus: " + raidus);
		PrintDebugLog("Floating distance : " + touchptHeight);
		return true;
	}

	private int GetPressInputMapping(int pressIds_Index, keyMappingInputType status)
	{
		WVR_InputId destination = pressIds[pressIds_Index];
		if (!WaveVR_ButtonList.Instance.GetInputMappingPair(device, ref destination))
		{
			PrintInfoLog("GetInputMappingPair failed.");
			return -1;
		}
		int num = -1;
		for (int i = 0; i < pressIds.Length; i++)
		{
			if (destination == pressIds[i])
			{
				num = i;
				break;
			}
		}
		if (pressObjectArrays[pressIds_Index].hasEffect && pressObjectArrays[pressIds_Index].MeshName == "__CM__VolumeKey")
		{
			num = volume_index;
		}
		if (num >= 0 && num < pressIds.Length)
		{
			PrintInfoLog(string.Concat(status.ToString(), " button: ", pressIds[pressIds_Index], " is mapped to ", destination));
		}
		else
		{
			PrintInfoLog("Can't get index in touchIds.");
		}
		return num;
	}

	private int GetTouchInputMapping(int touchIds_Index, keyMappingInputType status)
	{
		WVR_InputId destination = touchIds[touchIds_Index];
		if (!WaveVR_ButtonList.Instance.GetInputMappingPair(device, ref destination))
		{
			PrintInfoLog("GetInputMappingPair failed.");
			return -1;
		}
		int num = -1;
		for (int i = 0; i < touchIds.Length; i++)
		{
			if (destination == touchIds[i])
			{
				num = i;
				break;
			}
		}
		if (num >= 0 && num < touchIds.Length)
		{
			PrintInfoLog(string.Concat(status.ToString(), " button: ", touchIds[touchIds_Index], " is mapped to ", destination));
		}
		else
		{
			PrintInfoLog("Can't get index in touchIds.");
		}
		return num;
	}

	private void CollectEffectObjects()
	{
		effectMat = Resources.Load("ColorOffsetMaterial") as Material;
		touchMat = new Material(Shader.Find("Unlit/Texture"));
		if (useSystemConfig)
		{
			PrintInfoLog("use system config in controller model!");
			ReadJsonValues();
		}
		else
		{
			WVR_Log.Log.w(LOG_TAG, "use custom config in controller model!");
		}
		int childCount = base.transform.childCount;
		PrintDebugLog("childCount: " + childCount);
		effectMat.color = buttonEffectColor;
		WaveVR_RenderModel component = GetComponent<WaveVR_RenderModel>();
		if (component != null)
		{
			mergeToOneBone = component.mergeToOneBone;
		}
		isTouchPadSetting = GetTouchPadParam();
		for (int i = 0; i < PressEffectNames.Length; i++)
		{
			pressObjectArrays[i] = new MeshObject();
			pressObjectArrays[i].MeshName = PressEffectNames[i];
			pressObjectArrays[i].hasEffect = false;
			pressObjectArrays[i].gameObject = null;
			pressObjectArrays[i].originPosition = new Vector3(0f, 0f, 0f);
			pressObjectArrays[i].originMat = null;
			pressObjectArrays[i].effectMat = null;
			bool flag = false;
			for (int j = 0; j < childCount; j++)
			{
				GameObject gameObject = base.transform.GetChild(j).gameObject;
				string text = gameObject.name.Split("."[0])[0];
				if (!(pressObjectArrays[i].MeshName == text))
				{
					continue;
				}
				switch (text)
				{
				case "__CM__VolumeKey":
				case "__CM__VolumeUp":
				case "__CM__VolumeDown":
					volume_index = i;
					break;
				}
				PrintInfoLog(text + " is found, active = " + gameObject.activeInHierarchy);
				pressObjectArrays[i].gameObject = gameObject;
				pressObjectArrays[i].originPosition = gameObject.transform.localPosition;
				pressObjectArrays[i].originMat = gameObject.GetComponent<MeshRenderer>().material;
				pressObjectArrays[i].effectMat = effectMat;
				pressObjectArrays[i].hasEffect = true;
				if (text == "__CM__TouchPad")
				{
					touchpad = pressObjectArrays[i].gameObject;
					touchpadMesh = touchpad.GetComponent<MeshFilter>().mesh;
					if (touchpadMesh != null)
					{
						PrintInfoLog("touchpad is found! ");
					}
				}
				flag = true;
				break;
			}
			if (!flag)
			{
				PrintInfoLog(pressObjectArrays[i].MeshName + " is not found");
			}
		}
		for (int k = 0; k < TouchEffectNames.Length; k++)
		{
			touchObjectArrays[k] = new MeshObject();
			touchObjectArrays[k].MeshName = TouchEffectNames[k];
			touchObjectArrays[k].hasEffect = false;
			touchObjectArrays[k].gameObject = null;
			touchObjectArrays[k].originPosition = new Vector3(0f, 0f, 0f);
			touchObjectArrays[k].originMat = null;
			touchObjectArrays[k].effectMat = null;
			bool flag2 = false;
			for (int l = 0; l < childCount; l++)
			{
				GameObject gameObject2 = base.transform.GetChild(l).gameObject;
				string text2 = gameObject2.name.Split("."[0])[0];
				if (!(touchObjectArrays[k].MeshName == text2))
				{
					continue;
				}
				PrintInfoLog(text2 + " is found, active = " + gameObject2.activeInHierarchy);
				touchObjectArrays[k].gameObject = gameObject2;
				touchObjectArrays[k].originPosition = gameObject2.transform.localPosition;
				touchObjectArrays[k].originMat = gameObject2.GetComponent<MeshRenderer>().material;
				touchObjectArrays[k].effectMat = effectMat;
				touchObjectArrays[k].hasEffect = true;
				if (text2 == "__CM__TouchPad_Touch")
				{
					toucheffectMesh = touchObjectArrays[k].gameObject.GetComponent<MeshFilter>().mesh;
					if (toucheffectMesh != null)
					{
						PrintInfoLog("toucheffectMesh is found! ");
					}
				}
				flag2 = true;
				break;
			}
			if (!flag2)
			{
				PrintInfoLog(touchObjectArrays[k].MeshName + " is not found");
			}
		}
		resetButtonState();
	}

	private Color StringToColor(string color_string)
	{
		float r = Convert.ToInt32(color_string.Substring(1, 2), 16);
		float g = Convert.ToInt32(color_string.Substring(3, 2), 16);
		float b = Convert.ToInt32(color_string.Substring(5, 2), 16);
		float a = Convert.ToInt32(color_string.Substring(7, 2), 16);
		return new Color(r, g, b, a);
	}

	private Texture2D GetTexture2D(string texture_path)
	{
		if (File.Exists(texture_path))
		{
			byte[] data = File.ReadAllBytes(texture_path);
			Texture2D texture2D = new Texture2D(1, 1);
			texture2D.LoadImage(data);
			return texture2D;
		}
		return null;
	}

	public void Circle(Texture2D tex, int cx, int cy, int r, Color col)
	{
		for (int i = 0; i <= r; i++)
		{
			int num = (int)Mathf.Ceil(Mathf.Sqrt(r * r - i * i));
			for (int j = 0; j <= num; j++)
			{
				int x = cx + i;
				int x2 = cx - i;
				int y = cy + j;
				int y2 = cy - j;
				tex.SetPixel(x, y, col);
				tex.SetPixel(x2, y, col);
				tex.SetPixel(x, y2, col);
				tex.SetPixel(x2, y2, col);
			}
		}
		tex.Apply();
	}

	private void ReadJsonValues()
	{
		string controllerConfig = WaveVR_Utils.OEMConfig.getControllerConfig();
		if (controllerConfig.Equals(""))
		{
			return;
		}
		JSONNode jSONNode = JSONNode.Parse(controllerConfig);
		string text = "";
		text = jSONNode["model"]["touchpad_dot_use_texture"].Value;
		if (text.ToLower().Equals("false"))
		{
			PrintDebugLog("touchpad_dot_use_texture = false, create texture");
			text = jSONNode["model"]["touchpad_dot_color"].Value;
			if (text.Equals(""))
			{
				return;
			}
			PrintInfoLog("touchpad_dot_color: " + text);
			buttonEffectColor = StringToColor(text);
			Texture2D texture2D = new Texture2D(256, 256, TextureFormat.ARGB32, mipChain: false);
			Color clear = Color.clear;
			clear.r = 1f;
			clear.g = 1f;
			clear.b = 1f;
			clear.a = 0f;
			for (int i = 0; i < 256; i++)
			{
				for (int j = 0; j < 256; j++)
				{
					texture2D.SetPixel(i, j, clear);
				}
			}
			texture2D.Apply();
			Circle(texture2D, 128, 128, 100, buttonEffectColor);
			touchMat.mainTexture = texture2D;
		}
		else
		{
			PrintDebugLog("touchpad_dot_use_texture = true");
			text = jSONNode["model"]["touchpad_dot_texture_name"].Value;
			if (!text.Equals("") && File.Exists(text))
			{
				byte[] data = File.ReadAllBytes(text);
				Texture2D texture2D2 = new Texture2D(1, 1);
				texture2D2.LoadImage(data);
				PrintInfoLog("touchpad_dot_texture_name: " + text);
				touchMat.mainTexture = texture2D2;
				touchMat.color = buttonEffectColor;
			}
		}
	}
}
public class WaveVR_ControllerInstanceManager : MonoBehaviour
{
	[Serializable]
	private class ControllerInstance
	{
		public WVR_DeviceType type;

		public GameObject instance;

		public int index;

		public bool eventEnabled;

		public bool showBeam;

		public bool showPointer;
	}

	private enum CComponent
	{
		Beam,
		ControllerPointer
	}

	private static string LOG_TAG = "WaveVR_ControllerInstanceManager";

	private static WaveVR_ControllerInstanceManager instance = null;

	private int ControllerIdx;

	private GameObject eventSystem;

	private List<ControllerInstance> ctrInstanceList = new List<ControllerInstance>();

	public WVR_DeviceType ControllerFocus = WVR_DeviceType.WVR_DeviceType_Controller_Right;

	private WVR_DeviceType lastControllerFocus;

	private bool mFocusCapturedBySystem;

	public bool EnableSingleBeam = true;

	private bool rConnected;

	private bool lConnected;

	public static WaveVR_ControllerInstanceManager Instance
	{
		get
		{
			if (instance == null)
			{
				WVR_Log.Log.i(LOG_TAG, "Instance, create WaveVR_ControllerInstanceManager GameObject", logInEditor: true);
				instance = new GameObject("WaveVR_ControllerInstanceManager").AddComponent<WaveVR_ControllerInstanceManager>();
				UnityEngine.Object.DontDestroyOnLoad(instance);
			}
			return instance;
		}
	}

	private void PrintDebugLog(string msg)
	{
		if (WVR_Log.Log.EnableDebugLog)
		{
			WVR_Log.Log.d(LOG_TAG, msg, logInEditor: true);
		}
	}

	private bool getEventSystemParameter(WVR_DeviceType type)
	{
		bool result = false;
		if (EventSystem.current == null)
		{
			EventSystem eventSystem = UnityEngine.Object.FindObjectOfType<EventSystem>();
			if (eventSystem != null)
			{
				this.eventSystem = eventSystem.gameObject;
			}
		}
		else
		{
			this.eventSystem = EventSystem.current.gameObject;
		}
		if (this.eventSystem != null)
		{
			WaveVR_ControllerInputModule component = this.eventSystem.GetComponent<WaveVR_ControllerInputModule>();
			if (component != null)
			{
				switch (type)
				{
				case WVR_DeviceType.WVR_DeviceType_Controller_Right:
					result = component.DomintEventEnabled;
					PrintDebugLog("getEventSystemParameter() DomintEventEnabled is " + result);
					break;
				case WVR_DeviceType.WVR_DeviceType_Controller_Left:
					result = component.NoDomtEventEnabled;
					PrintDebugLog("getEventSystemParameter() NoDomtEventEnabled is " + result);
					break;
				}
			}
		}
		return result;
	}

	private bool getComponentParameter(GameObject controller, CComponent comp)
	{
		bool result = false;
		int childCount = controller.transform.childCount;
		for (int i = 0; i < childCount; i++)
		{
			GameObject gameObject = controller.transform.GetChild(i).gameObject;
			switch (comp)
			{
			case CComponent.Beam:
			{
				WaveVR_Beam componentInChildren2 = gameObject.GetComponentInChildren<WaveVR_Beam>();
				if (!(componentInChildren2 != null))
				{
					continue;
				}
				result = componentInChildren2.ShowBeam;
				PrintDebugLog("getComponentParameter() wb.ShowBeam is " + result);
				break;
			}
			case CComponent.ControllerPointer:
			{
				WaveVR_ControllerPointer componentInChildren = gameObject.GetComponentInChildren<WaveVR_ControllerPointer>();
				if (!(componentInChildren != null))
				{
					continue;
				}
				result = componentInChildren.ShowPointer;
				PrintDebugLog("getComponentParameter() wcp.ShowPointer is " + result);
				break;
			}
			default:
				continue;
			}
			break;
		}
		return result;
	}

	public int registerControllerInstance(WVR_DeviceType type, GameObject controller)
	{
		PrintDebugLog(string.Concat("registerControllerInstance() ", type, ", controller: ", (controller != null) ? controller.name : "null"));
		if (type != WVR_DeviceType.WVR_DeviceType_Controller_Left && type != WVR_DeviceType.WVR_DeviceType_Controller_Right)
		{
			PrintDebugLog("registerControllerInstance, type is not allowed");
			return 0;
		}
		if (controller == null)
		{
			PrintDebugLog("registerControllerInstance, controller is null");
			return 0;
		}
		ControllerIdx++;
		ControllerInstance controllerInstance = new ControllerInstance();
		controllerInstance.type = type;
		controllerInstance.instance = controller;
		controllerInstance.index = ControllerIdx;
		controllerInstance.eventEnabled = getEventSystemParameter(type);
		controllerInstance.showBeam = getComponentParameter(controller, CComponent.Beam);
		controllerInstance.showPointer = getComponentParameter(controller, CComponent.ControllerPointer);
		ctrInstanceList.Add(controllerInstance);
		PrintDebugLog(string.Concat("registerControllerInstance, add controller index: ", controllerInstance.index, ", type: ", controllerInstance.type, ", name: ", controllerInstance.instance.name, ", event able: ", controllerInstance.eventEnabled.ToString(), ", ShowBeam: ", controllerInstance.showBeam.ToString(), ", showPointer: ", controllerInstance.showPointer.ToString()));
		return ControllerIdx;
	}

	public void removeControllerInstance(int index)
	{
		ControllerInstance controllerInstance = null;
		foreach (ControllerInstance ctrInstance in ctrInstanceList)
		{
			if (ctrInstance.index == index)
			{
				PrintDebugLog("removeControllerInstance, remove controller index: " + ctrInstance.index + ", type: " + ctrInstance.type);
				controllerInstance = ctrInstance;
			}
		}
		if (controllerInstance != null)
		{
			ctrInstanceList.Remove(controllerInstance);
		}
	}

	private void onDeviceConnected(params object[] args)
	{
		WVR_DeviceType wVR_DeviceType = (WVR_DeviceType)args[0];
		bool flag = (bool)args[1];
		PrintDebugLog(string.Concat("onDeviceConnected() device ", wVR_DeviceType, " is ", flag ? "connected." : "disconnected.", ", left-handed? ", WaveVR_Controller.IsLeftHanded.ToString()));
		WaveVR.Device deviceByType = WaveVR.Instance.getDeviceByType(WVR_DeviceType.WVR_DeviceType_Controller_Right);
		WaveVR.Device deviceByType2 = WaveVR.Instance.getDeviceByType(WVR_DeviceType.WVR_DeviceType_Controller_Left);
		if (wVR_DeviceType == deviceByType.type)
		{
			rConnected = deviceByType.connected;
			PrintDebugLog("onDeviceConnected() rConnected: " + rConnected);
		}
		if (wVR_DeviceType == deviceByType2.type)
		{
			lConnected = deviceByType2.connected;
			PrintDebugLog("onDeviceConnected() lConnected: " + lConnected);
		}
	}

	private void onSystemFocusChanged(params object[] args)
	{
		bool flag = (bool)args[0];
		if (mFocusCapturedBySystem != flag)
		{
			mFocusCapturedBySystem = flag;
			if (!mFocusCapturedBySystem)
			{
				ControllerFocus = Interop.WVR_GetFocusedController();
				PrintDebugLog("onSystemFocusChanged() get focus controller " + ControllerFocus);
			}
		}
	}

	private void OnEnable()
	{
		WaveVR_Utils.Event.Listen(WaveVR_Utils.Event.DEVICE_CONNECTED, onDeviceConnected);
		WaveVR_Utils.Event.Listen(WaveVR_Utils.Event.SYSTEMFOCUS_CHANGED, onSystemFocusChanged);
		WaveVR_Utils.Event.Listen(WaveVR_Utils.Event.OEM_CONFIG_CHANGED, onOEMConfigChanged);
		checkControllerConnected();
	}

	private void OnDisable()
	{
		WaveVR_Utils.Event.Remove(WaveVR_Utils.Event.DEVICE_CONNECTED, onDeviceConnected);
		WaveVR_Utils.Event.Remove(WaveVR_Utils.Event.SYSTEMFOCUS_CHANGED, onSystemFocusChanged);
		WaveVR_Utils.Event.Remove(WaveVR_Utils.Event.OEM_CONFIG_CHANGED, onOEMConfigChanged);
	}

	private void Awake()
	{
		ControllerFocus = Interop.WVR_GetFocusedController();
		PrintDebugLog("Start() Focus controller: " + ControllerFocus);
	}

	private void onOEMConfigChanged(params object[] args)
	{
		PrintDebugLog("onOEMConfigChanged");
		ReadJsonValues();
	}

	private void ReadJsonValues()
	{
		string singleBeamEnableConfig = WaveVR_Utils.OEMConfig.getSingleBeamEnableConfig();
		if (!singleBeamEnableConfig.Equals(""))
		{
			try
			{
				JSONNode jSONNode = JSONNode.Parse(singleBeamEnableConfig);
				string text = "";
				text = jSONNode["enable"].Value;
				if (!text.Equals("") && !text.Equals("true", StringComparison.OrdinalIgnoreCase))
				{
					EnableSingleBeam = false;
				}
			}
			catch (Exception ex)
			{
				WVR_Log.Log.e(LOG_TAG, "JsonParse failed: " + ex.ToString());
			}
		}
		PrintDebugLog("enable Single Beam: " + EnableSingleBeam);
	}

	private void Start()
	{
		ReadJsonValues();
	}

	private void OnDestroy()
	{
		PrintDebugLog("OnDestroy");
	}

	private void OnApplicationPause(bool pauseStatus)
	{
		if (!pauseStatus)
		{
			ControllerFocus = Interop.WVR_GetFocusedController();
			PrintDebugLog("Application resume, Focus controller: " + ControllerFocus);
			ReadJsonValues();
		}
	}

	private void Update()
	{
		if (mFocusCapturedBySystem)
		{
			return;
		}
		if (ctrInstanceList.Count < 1)
		{
			lastControllerFocus = WVR_DeviceType.WVR_DeviceType_Invalid;
			return;
		}
		if (WVR_Log.Log.gpl.Print)
		{
			PrintDebugLog(string.Concat("Controller instance: ", ctrInstanceList.Count, ", Focus controller: ", ControllerFocus, ", enable single beam: ", EnableSingleBeam.ToString()));
		}
		if (ctrInstanceList.Count == 1)
		{
			ForceSetActiveOfEmitter(ctrInstanceList[0], enabled: true);
			ActivateEventSystem(ctrInstanceList[0].type, enabled: true);
			return;
		}
		if (ControllerFocus == WVR_DeviceType.WVR_DeviceType_Controller_Right && (WaveVR_Controller.Input(WVR_DeviceType.WVR_DeviceType_Controller_Left).GetPressUp(WVR_InputId.WVR_InputId_9) || WaveVR_Controller.Input(WVR_DeviceType.WVR_DeviceType_Controller_Left).GetPressUp(WVR_InputId.WVR_InputId_17)))
		{
			ControllerFocus = WVR_DeviceType.WVR_DeviceType_Controller_Left;
			PrintDebugLog("Update() Controller focus changes from Right to Left, set to runtime.");
		}
		if (ControllerFocus == WVR_DeviceType.WVR_DeviceType_Controller_Left && (WaveVR_Controller.Input(WVR_DeviceType.WVR_DeviceType_Controller_Right).GetPressUp(WVR_InputId.WVR_InputId_9) || WaveVR_Controller.Input(WVR_DeviceType.WVR_DeviceType_Controller_Right).GetPressUp(WVR_InputId.WVR_InputId_17)))
		{
			ControllerFocus = WVR_DeviceType.WVR_DeviceType_Controller_Right;
			PrintDebugLog("Update() Controller focus changes from Left to Right, set to runtime.");
		}
		if (lastControllerFocus != ControllerFocus)
		{
			lastControllerFocus = ControllerFocus;
			PrintDebugLog("Update() focus set to: " + ControllerFocus);
			Interop.WVR_SetFocusedController(ControllerFocus);
		}
		SetActiveOfEmitter();
	}

	private void printAllChildren(GameObject go)
	{
		int childCount = go.transform.childCount;
		for (int i = 0; i < childCount; i++)
		{
			GameObject gameObject = go.transform.GetChild(i).gameObject;
			PrintDebugLog("-- " + gameObject.name + " " + gameObject.activeInHierarchy);
			printAllChildren(gameObject);
		}
	}

	private void checkControllerConnected()
	{
		rConnected = WaveVR.Instance.getDeviceByType(WVR_DeviceType.WVR_DeviceType_Controller_Right).connected;
		lConnected = WaveVR.Instance.getDeviceByType(WVR_DeviceType.WVR_DeviceType_Controller_Left).connected;
		PrintDebugLog("checkControllerConnected() rConnected: " + rConnected + ", lConnected: " + lConnected);
	}

	private void SetActiveOfEmitter()
	{
		foreach (ControllerInstance ctrInstance in ctrInstanceList)
		{
			ForceSetActiveOfEmitter(ctrInstance, ctrInstance.type == ControllerFocus || !EnableSingleBeam);
			ActivateEventSystem(ctrInstance.type, ctrInstance.type == ControllerFocus || !EnableSingleBeam);
		}
	}

	private void ForceSetActiveOfEmitter(ControllerInstance ci, bool enabled)
	{
		GameObject gameObject = ci.instance;
		if (gameObject != null)
		{
			if (ci.showBeam != enabled)
			{
				WaveVR_Beam componentInChildren = gameObject.GetComponentInChildren<WaveVR_Beam>();
				if (componentInChildren != null)
				{
					ci.showBeam = enabled;
					componentInChildren.ShowBeam = enabled;
					PrintDebugLog(string.Concat("ForceSetActiveOfEmitter() Set ", ci.type, " controller ", gameObject.name, ", index: ", ci.index, ", beam: ", componentInChildren.ShowBeam.ToString()));
				}
			}
			if (ci.showPointer != enabled)
			{
				WaveVR_ControllerPointer componentInChildren2 = gameObject.GetComponentInChildren<WaveVR_ControllerPointer>();
				if (componentInChildren2 != null)
				{
					ci.showPointer = enabled;
					componentInChildren2.ShowPointer = enabled;
					PrintDebugLog(string.Concat("ForceSetActiveOfEmitter() Set ", ci.type, " controller ", gameObject.name, ", index: ", ci.index, ", pointer: ", componentInChildren2.ShowPointer.ToString()));
				}
			}
		}
		else
		{
			if (WVR_Log.Log.gpl.Print)
			{
				PrintDebugLog(string.Concat("ForceSetActiveOfEmitter() controller ", ci.type, " , index: ", ci.index, " controller is null, remove it from list."));
			}
			removeControllerInstance(ci.index);
		}
	}

	private void ActivateEventSystem(WVR_DeviceType type, bool enabled)
	{
		if (EventSystem.current == null)
		{
			EventSystem eventSystem = UnityEngine.Object.FindObjectOfType<EventSystem>();
			if (eventSystem != null)
			{
				this.eventSystem = eventSystem.gameObject;
			}
		}
		else
		{
			this.eventSystem = EventSystem.current.gameObject;
		}
		if (!(this.eventSystem != null))
		{
			return;
		}
		WaveVR_ControllerInputModule component = this.eventSystem.GetComponent<WaveVR_ControllerInputModule>();
		if (!(component != null))
		{
			return;
		}
		switch (type)
		{
		case WVR_DeviceType.WVR_DeviceType_Controller_Right:
			if (component.DomintEventEnabled != enabled)
			{
				component.DomintEventEnabled = enabled;
				PrintDebugLog("Forced set DomintEventEnabled to " + component.DomintEventEnabled);
			}
			break;
		case WVR_DeviceType.WVR_DeviceType_Controller_Left:
			if (component.NoDomtEventEnabled != enabled)
			{
				component.NoDomtEventEnabled = enabled;
				PrintDebugLog("Forced set NoDomtEventEnabled to " + component.NoDomtEventEnabled);
			}
			break;
		}
	}
}
[RequireComponent(typeof(MeshRenderer))]
public class WaveVR_ControllerPointer : MonoBehaviour
{
	private const string LOG_TAG = "WaveVR_ControllerPointer";

	public WaveVR_Controller.EDeviceType device;

	public bool ShowPointer = true;

	public bool Blink;

	public float PointerOuterDiameterMin = 0.01f;

	[HideInInspector]
	public float PointerOuterDiameter = 0.024f;

	public bool UseDefaultTexture = true;

	private const string defaultPointerResource_Texture = "focused_dot";

	private Texture2D defaultTexture;

	public Texture2D CustomTexture;

	[HideInInspector]
	public string TextureName;

	private const float pointerDistanceMin = 0.5f;

	[HideInInspector]
	public const float pointerDistanceMax = 100f;

	[HideInInspector]
	public float PointerDistanceInMeters = 1.3f;

	public bool useTexture = true;

	private MeshFilter pointerMeshFilter;

	private Mesh pointerMesh;

	private const string defaultPointerResource_Material = "ControllerPointer";

	private Material pointerMaterial;

	private Material pointerMaterialInstance;

	private Color colorFactor = Color.white;

	[HideInInspector]
	public Color PointerColor = Color.white;

	[HideInInspector]
	public Color borderColor = new Color(119f, 119f, 119f, 255f);

	[HideInInspector]
	public Color focusColor = new Color(255f, 255f, 255f, 255f);

	[HideInInspector]
	public Color focusBorderColor = new Color(119f, 119f, 119f, 255f);

	private const int PointerRenderQueueMin = 1000;

	private const int PointerRenderQueueMax = 5000;

	public int PointerRenderQueue = 5000;

	private int reticleSegments = 20;

	[HideInInspector]
	public float kpointerGrowthAngle = 90f;

	private float colorFlickerTime;

	private bool isPointerEnabled;

	private bool pointerInitialized;

	private void PrintDebugLog(string msg)
	{
		if (WVR_Log.Log.EnableDebugLog)
		{
			WVR_Log.Log.d("WaveVR_ControllerPointer", msg, logInEditor: true);
		}
	}

	private void ReadJsonValues()
	{
		string controllerConfig = WaveVR_Utils.OEMConfig.getControllerConfig();
		if (controllerConfig.Equals(""))
		{
			return;
		}
		try
		{
			JSONNode jSONNode = JSONNode.Parse(controllerConfig);
			string text = "";
			text = jSONNode["pointer"]["diameter"].Value;
			if (!text.Equals("") && IsFloat(text))
			{
				PointerOuterDiameterMin = float.Parse(text);
			}
			text = jSONNode["pointer"]["distance"].Value;
			if (!text.Equals("") && IsFloat(text))
			{
				PointerDistanceInMeters = float.Parse(text);
			}
			text = jSONNode["pointer"]["use_texture"].Value;
			if (!text.Equals("") && IsBoolean(text))
			{
				useTexture = bool.Parse(text);
			}
			if (text.ToLower().Equals("false"))
			{
				PrintDebugLog(string.Concat("ReadJsonValues() ", device, ", controller_pointer_use_texture = false, create texture"));
				if (pointerMaterialInstance != null)
				{
					text = jSONNode["pointer"]["color"].Value;
					if (!text.Equals(""))
					{
						PointerColor = StringToColor32(text, 0);
					}
					text = jSONNode["pointer"]["border_color"].Value;
					if (!text.Equals(""))
					{
						borderColor = StringToColor32(text, 1);
					}
					text = jSONNode["pointer"]["focus_color"].Value;
					if (!text.Equals(""))
					{
						focusColor = StringToColor32(text, 2);
					}
					text = jSONNode["pointer"]["focus_border_color"].Value;
					if (!text.Equals(""))
					{
						focusBorderColor = StringToColor32(text, 3);
					}
				}
			}
			else
			{
				PrintDebugLog(string.Concat("ReadJsonValues() ", device, ", controller_pointer_use_texture = true"));
				text = jSONNode["pointer"]["pointer_texture_name"].Value;
				if (!text.Equals(""))
				{
					TextureName = text;
				}
			}
			text = jSONNode["pointer"]["Blink"].Value;
			if (!text.Equals("") && IsBoolean(text))
			{
				Blink = bool.Parse(text);
			}
			text = jSONNode["pointer"]["use_texture"].Value;
			if (!text.Equals("") && IsBoolean(text))
			{
				useTexture = bool.Parse(text);
			}
			PrintDebugLog(string.Concat("ReadJsonValues() ", device, ", diameter: ", PointerOuterDiameterMin, ", distance: ", PointerDistanceInMeters, ", use_texture: ", useTexture.ToString(), ", color: ", PointerColor, ", pointer_texture_name: ", TextureName, ", Blink: ", Blink.ToString()));
		}
		catch (Exception ex)
		{
			WVR_Log.Log.e("WaveVR_ControllerPointer", ex.ToString(), logInEditor: true);
		}
	}

	private bool IsBoolean(string value)
	{
		try
		{
			PrintDebugLog(value + " Convert to bool success: " + Convert.ToBoolean(value));
			return true;
		}
		catch (Exception ex)
		{
			WVR_Log.Log.e("WaveVR_ControllerPointer", value + " Convert to bool failed: " + ex.ToString(), logInEditor: true);
			return false;
		}
	}

	private bool IsFloat(string value)
	{
		try
		{
			PrintDebugLog(value + " Convert to float success: " + Convert.ToSingle(value));
			return true;
		}
		catch (Exception ex)
		{
			WVR_Log.Log.e("WaveVR_ControllerPointer", value + " Convert to float failed: " + ex.ToString(), logInEditor: true);
			return false;
		}
	}

	private bool IsNumeric(string value)
	{
		try
		{
			PrintDebugLog(value + " Convert to int success: " + Convert.ToInt32(value));
			return true;
		}
		catch (Exception ex)
		{
			WVR_Log.Log.e("WaveVR_ControllerPointer", value + " Convert to Int failed: " + ex.ToString(), logInEditor: true);
			return false;
		}
	}

	private Color32 StringToColor32(string color_string, int value)
	{
		try
		{
			byte[] bytes = BitConverter.GetBytes(Convert.ToInt32(color_string.Substring(1, 2), 16));
			byte[] bytes2 = BitConverter.GetBytes(Convert.ToInt32(color_string.Substring(3, 2), 16));
			byte[] bytes3 = BitConverter.GetBytes(Convert.ToInt32(color_string.Substring(5, 2), 16));
			return new Color32(a: BitConverter.GetBytes(Convert.ToInt32(color_string.Substring(7, 2), 16))[0], r: bytes[0], g: bytes2[0], b: bytes3[0]);
		}
		catch (Exception ex)
		{
			WVR_Log.Log.e("WaveVR_ControllerPointer", "StringToColor32: " + ex.ToString(), logInEditor: true);
			return value switch
			{
				1 => new Color(119f, 119f, 119f, 255f), 
				2 => new Color(255f, 255f, 255f, 255f), 
				3 => new Color(119f, 119f, 119f, 255f), 
				_ => Color.white, 
			};
		}
	}

	private void Awake()
	{
	}

	private void Start()
	{
	}

	private void OnEnable()
	{
		if (!isPointerEnabled)
		{
			pointerMaterial = Resources.Load("ControllerPointer") as Material;
			if (pointerMaterial != null)
			{
				pointerMaterialInstance = UnityEngine.Object.Instantiate(pointerMaterial);
			}
			if (pointerMaterialInstance == null)
			{
				PrintDebugLog(string.Concat("OnEnable() ", device, ", Can NOT load default material"));
			}
			else
			{
				PrintDebugLog(string.Concat("OnEnable() ", device, ", controller pointer material: ", pointerMaterialInstance.name));
			}
			defaultTexture = (Texture2D)Resources.Load("focused_dot");
			if (defaultTexture == null)
			{
				WVR_Log.Log.e("WaveVR_ControllerPointer", "OnEnable() Can NOT load default texture", logInEditor: true);
			}
			pointerMeshFilter = base.gameObject.GetComponent<MeshFilter>();
			if (pointerMeshFilter == null)
			{
				pointerMeshFilter = base.gameObject.AddComponent<MeshFilter>();
			}
			GameObject gameObject = GameObject.CreatePrimitive(PrimitiveType.Quad);
			pointerMesh = UnityEngine.Object.Instantiate(gameObject.GetComponent<MeshFilter>().sharedMesh);
			pointerMesh.name = "CtrlQuadPointer";
			gameObject.SetActive(value: false);
			UnityEngine.Object.Destroy(gameObject);
			isPointerEnabled = true;
		}
	}

	private void OnDisable()
	{
		PrintDebugLog("OnDisable() " + device);
		removePointer();
		isPointerEnabled = false;
	}

	private void Update()
	{
		if (ShowPointer)
		{
			if (!pointerInitialized)
			{
				if (device == WaveVR_Controller.EDeviceType.Head)
				{
					PrintDebugLog("Update() Head, show pointer");
				}
				if (device == WaveVR_Controller.EDeviceType.Dominant)
				{
					PrintDebugLog("Update() Dominant, show pointer");
				}
				if (device == WaveVR_Controller.EDeviceType.NonDominant)
				{
					PrintDebugLog("Update() NonDominant, show pointer");
				}
				initialPointer();
			}
		}
		else if (pointerInitialized)
		{
			if (device == WaveVR_Controller.EDeviceType.Head)
			{
				PrintDebugLog("Update() Head, hide pointer");
			}
			if (device == WaveVR_Controller.EDeviceType.Dominant)
			{
				PrintDebugLog("Update() Dominant, hide pointer");
			}
			if (device == WaveVR_Controller.EDeviceType.NonDominant)
			{
				PrintDebugLog("Update() NonDominant, hide pointer");
			}
			removePointer();
		}
		PointerDistanceInMeters = Mathf.Clamp(PointerDistanceInMeters, 0.5f, 100f);
		if (Blink)
		{
			if (Time.unscaledTime - colorFlickerTime >= 0.5f)
			{
				colorFlickerTime = Time.unscaledTime;
				colorFactor = ((colorFactor != Color.white) ? (colorFactor = Color.white) : (colorFactor = Color.black));
			}
		}
		else
		{
			colorFactor = PointerColor;
		}
		if (pointerMaterialInstance != null)
		{
			pointerMaterialInstance.renderQueue = PointerRenderQueue;
			pointerMaterialInstance.SetColor("_Color", colorFactor);
			pointerMaterialInstance.SetFloat("_useTexture", useTexture ? 1f : 0f);
			pointerMaterialInstance.SetFloat("_OuterDiameter", PointerOuterDiameter);
			pointerMaterialInstance.SetFloat("_DistanceInMeters", PointerDistanceInMeters);
		}
		else if (WVR_Log.Log.gpl.Print)
		{
			if (device == WaveVR_Controller.EDeviceType.Head)
			{
				PrintDebugLog("Update() Head, Pointer material is null!!");
			}
			if (device == WaveVR_Controller.EDeviceType.Dominant)
			{
				PrintDebugLog("Update() Dominant, Pointer material is null!!");
			}
			if (device == WaveVR_Controller.EDeviceType.NonDominant)
			{
				PrintDebugLog("Update() NonDominant, Pointer material is null!!");
			}
		}
		if (WVR_Log.Log.gpl.Print)
		{
			PrintDebugLog(string.Concat(device, " ", base.gameObject.name, " is ", ShowPointer ? "shown" : "hidden", ", pointer color: ", colorFactor, ", use texture: ", useTexture.ToString(), ", pointer outer diameter: ", PointerOuterDiameter, ", pointer distance: ", PointerDistanceInMeters, ", render queue: ", PointerRenderQueue));
		}
	}

	private void CreatePointerMesh()
	{
		Vector3[] array = new Vector3[(reticleSegments + 1) * 2];
		int num = 0;
		for (int i = 0; i <= reticleSegments; i++)
		{
			float f = (float)i / (float)reticleSegments * (float)Math.PI * 2f;
			float x = Mathf.Sin(f);
			float y = Mathf.Cos(f);
			array[num++] = new Vector3(x, y, 0f);
			array[num++] = new Vector3(x, y, 1f);
		}
		int[] array2 = new int[(reticleSegments + 1) * 6];
		int num2 = 0;
		int num3 = 0;
		for (int j = 0; j < reticleSegments; j++)
		{
			array2[num3++] = num2 + 1;
			array2[num3++] = num2;
			array2[num3++] = num2 + 2;
			array2[num3++] = num2 + 1;
			array2[num3++] = num2 + 2;
			array2[num3++] = num2 + 3;
			num2 += 2;
		}
		if (device == WaveVR_Controller.EDeviceType.Head)
		{
			PrintDebugLog("CreatePointerMesh() Head, create Mesh and add MeshFilter component.");
		}
		if (device == WaveVR_Controller.EDeviceType.Dominant)
		{
			PrintDebugLog("CreatePointerMesh() Dominant, create Mesh and add MeshFilter component.");
		}
		if (device == WaveVR_Controller.EDeviceType.NonDominant)
		{
			PrintDebugLog("CreatePointerMesh() NonDominant, create Mesh and add MeshFilter component.");
		}
		pointerMesh = new Mesh();
		pointerMesh.vertices = array;
		pointerMesh.triangles = array2;
		pointerMesh.name = "WaveVR_Mesh_Q";
		pointerMesh.RecalculateBounds();
	}

	private void initialPointer()
	{
		if (!isPointerEnabled)
		{
			if (device == WaveVR_Controller.EDeviceType.Head)
			{
				PrintDebugLog("initialPointer() Head, pointer is not enabled yet, do NOT initial.");
			}
			if (device == WaveVR_Controller.EDeviceType.Dominant)
			{
				PrintDebugLog("initialPointer() Dominant, pointer is not enabled yet, do NOT initial.");
			}
			if (device == WaveVR_Controller.EDeviceType.NonDominant)
			{
				PrintDebugLog("initialPointer() NonDominant, pointer is not enabled yet, do NOT initial.");
			}
			return;
		}
		if (device == WaveVR_Controller.EDeviceType.Head)
		{
			PrintDebugLog("initialPointer() Head.");
		}
		if (device == WaveVR_Controller.EDeviceType.Dominant)
		{
			PrintDebugLog("initialPointer() Dominant.");
		}
		if (device == WaveVR_Controller.EDeviceType.NonDominant)
		{
			PrintDebugLog("initialPointer() NonDominant.");
		}
		if (!useTexture)
		{
			colorFlickerTime = Time.unscaledTime;
			CreatePointerMesh();
			PrintDebugLog(string.Concat("initialPointer() ", device, " be used to user custom mesh. ( WaveVR_Mesh_Q mesh )"));
		}
		else
		{
			PrintDebugLog(string.Concat("initialPointer() ", device, " be used to default mesh. ( CtrlQuadPointer mesh )"));
		}
		pointerMeshFilter.mesh = pointerMesh;
		if (pointerMaterialInstance != null)
		{
			if (UseDefaultTexture || null == CustomTexture)
			{
				if (device == WaveVR_Controller.EDeviceType.Head)
				{
					PrintDebugLog("initialPointer() Head, use default texture.");
				}
				if (device == WaveVR_Controller.EDeviceType.Dominant)
				{
					PrintDebugLog("initialPointer() Dominant, use default texture.");
				}
				if (device == WaveVR_Controller.EDeviceType.NonDominant)
				{
					PrintDebugLog("initialPointer() NonDominant, use default texture.");
				}
				pointerMaterialInstance.mainTexture = defaultTexture;
				pointerMaterialInstance.SetTexture("_MainTex", defaultTexture);
			}
			else
			{
				if (device == WaveVR_Controller.EDeviceType.Head)
				{
					PrintDebugLog("initialPointer() Head, use custom texture.");
				}
				if (device == WaveVR_Controller.EDeviceType.Dominant)
				{
					PrintDebugLog("initialPointer() Dominant, use custom texture.");
				}
				if (device == WaveVR_Controller.EDeviceType.NonDominant)
				{
					PrintDebugLog("initialPointer() NonDominant, use custom texture.");
				}
				pointerMaterialInstance.mainTexture = CustomTexture;
				pointerMaterialInstance.SetTexture("_MainTex", CustomTexture);
			}
		}
		else
		{
			WVR_Log.Log.e("WaveVR_ControllerPointer", "initialPointer() Pointer material is null!!", logInEditor: true);
		}
		Renderer component = GetComponent<Renderer>();
		component.enabled = true;
		component.material = pointerMaterialInstance;
		component.sortingOrder = 32767;
		pointerInitialized = true;
	}

	private void removePointer()
	{
		if (device == WaveVR_Controller.EDeviceType.Head)
		{
			PrintDebugLog("removePointer() Head");
		}
		if (device == WaveVR_Controller.EDeviceType.Dominant)
		{
			PrintDebugLog("removePointer() Dominant");
		}
		if (device == WaveVR_Controller.EDeviceType.NonDominant)
		{
			PrintDebugLog("removePointer() NonDominant");
		}
		GetComponent<Renderer>();
		GetComponent<Renderer>().enabled = false;
		pointerInitialized = false;
	}

	public void OnPointerEnter(Camera camera, GameObject target, Vector3 intersectionPosition, bool isInteractive)
	{
		SetPointerTarget(intersectionPosition, isInteractive);
	}

	private void SetPointerTarget(Vector3 target, bool interactive)
	{
		Vector3 vector = base.transform.InverseTransformPoint(target);
		PointerDistanceInMeters = Mathf.Clamp(vector.z, 0.5f, 100f);
		PointerOuterDiameter = PointerOuterDiameterMin + PointerDistanceInMeters / kpointerGrowthAngle;
		if (WVR_Log.Log.gpl.Print)
		{
			PrintDebugLog(string.Concat("SetPointerTarget() ", device, ", ", base.gameObject.name, ", SetPointerTarget() interactive: ", interactive.ToString(), ", targetLocalPosition.z: ", vector.z, ", PointerDistanceInMeters: ", PointerDistanceInMeters, ", PointerOuterDiameter: ", PointerOuterDiameter));
		}
	}
}
public enum ModelSpecify
{
	MS_Dominant,
	MS_NonDominant
}
[Serializable]
public class BatteryIndicator
{
	public int level;

	public float min;

	public float max;

	public string texturePath;

	public bool textureLoaded;

	public Texture2D batteryTexture;
}
[Serializable]
public class TouchSetting
{
	public Vector3 touchForward;

	public Vector3 touchCenter;

	public Vector3 touchRight;

	public Vector3 touchPtU;

	public Vector3 touchPtW;

	public Vector3 touchPtV;

	public float raidus;

	public float touchptHeight;
}
[Serializable]
public class ModelResource
{
	public string renderModelName;

	public ModelSpecify modelSpecify;

	public bool mergeToOne;

	public uint sectionCount;

	public FBXInfo_t[] FBXInfo;

	public MeshInfo_t[] SectionInfo;

	public bool parserReady;

	public Texture2D modelTexture;

	public bool isTouchSetting;

	public TouchSetting TouchSetting;

	public bool isBatterySetting;

	public List<BatteryIndicator> batteryTextureList;
}
public class WaveVR_ControllerResourceHolder
{
	private static string LOG_TAG = "WaveVR_ControllerResourceHolder";

	private Thread mthread;

	private static WaveVR_ControllerResourceHolder instance = null;

	public List<ModelResource> renderModelList = new List<ModelResource>();

	public static WaveVR_ControllerResourceHolder Instance
	{
		get
		{
			if (instance == null)
			{
				WVR_Log.Log.i(LOG_TAG, "create WaveVR_ControllerResourceHolder instance");
				instance = new WaveVR_ControllerResourceHolder();
			}
			return instance;
		}
	}

	private void PrintDebugLog(string msg)
	{
		WVR_Log.Log.d(LOG_TAG, msg);
	}

	private void PrintInfoLog(string msg)
	{
		WVR_Log.Log.i(LOG_TAG, msg);
	}

	private void PrintWarningLog(string msg)
	{
		WVR_Log.Log.w(LOG_TAG, msg);
	}

	public bool isRenderModelExist(string renderModel, ModelSpecify ms, bool merge)
	{
		foreach (ModelResource renderModel2 in renderModelList)
		{
			if (renderModel2.renderModelName == renderModel && renderModel2.mergeToOne == merge && renderModel2.modelSpecify == ms)
			{
				return true;
			}
		}
		return false;
	}

	public ModelResource getRenderModelResource(string renderModel, ModelSpecify ms, bool merge)
	{
		foreach (ModelResource renderModel2 in renderModelList)
		{
			if (renderModel2.renderModelName == renderModel && renderModel2.mergeToOne == merge && renderModel2.modelSpecify == ms)
			{
				return renderModel2;
			}
		}
		return null;
	}

	public bool addRenderModel(string renderModel, string ModelFolder, ModelSpecify ms, bool merge)
	{
		if (isRenderModelExist(renderModel, ms, merge))
		{
			return false;
		}
		string text = ModelFolder + "/";
		string text2 = ModelFolder + "/";
		if (ms == ModelSpecify.MS_Dominant)
		{
			text += "controller00.fbx";
			text2 += "controller00.png";
		}
		else
		{
			text += "controller01.fbx";
			text2 += "controller01.png";
		}
		if (!File.Exists(text))
		{
			return false;
		}
		if (!File.Exists(text2))
		{
			return false;
		}
		PrintDebugLog("---  start  ---");
		ModelResource newMR = new ModelResource();
		newMR.renderModelName = renderModel;
		newMR.mergeToOne = merge;
		newMR.parserReady = false;
		newMR.modelSpecify = ms;
		renderModelList.Add(newMR);
		mthread = new Thread((ThreadStart)delegate
		{
			readNativeData(newMR, merge, ModelFolder, ms);
		});
		mthread.Start();
		PrintDebugLog("---  Read image file start  ---");
		byte[] array = File.ReadAllBytes(text2);
		PrintDebugLog("---  Read image file end  ---");
		PrintDebugLog("---  Load image start  ---");
		Texture2D texture2D = new Texture2D(2, 2, TextureFormat.BGRA32, mipChain: false);
		if (texture2D.LoadImage(array))
		{
			PrintDebugLog("---  Load image end  ---, size: " + array.Length);
		}
		else
		{
			PrintWarningLog("failed to load texture");
		}
		newMR.modelTexture = texture2D;
		PrintDebugLog("---  Parse battery image start  ---");
		newMR.isBatterySetting = getBatteryIndicatorParam(newMR, ModelFolder, ms);
		PrintDebugLog("---  Parse battery image end  ---");
		PrintDebugLog("---  end  ---");
		return true;
	}

	private void readNativeData(ModelResource curr, bool mergeTo, string modelFolderPath, ModelSpecify ms)
	{
		PrintDebugLog("---  thread start  ---");
		PrintInfoLog("Render model name: " + curr.renderModelName + ", merge = " + curr.mergeToOne);
		IntPtr intPtr = Marshal.AllocHGlobal(64);
		string text = modelFolderPath + "/";
		text = ((ms != 0) ? (text + "controller01.fbx") : (text + "controller00.fbx"));
		uint sessionid = 0u;
		uint sectionCount = 0u;
		string text2 = "";
		if (File.Exists(text))
		{
			bool num = Interop.WVR_OpenMesh(text, ref sessionid, intPtr, mergeTo);
			text2 = Marshal.PtrToStringAnsi(intPtr);
			if (!num)
			{
				PrintWarningLog("FBX parse failed: " + text2);
				return;
			}
			PrintInfoLog("FBX parse succeed, sessionid = " + sessionid);
			if (!Interop.WVR_GetSectionCount(sessionid, ref sectionCount) || sectionCount == 0)
			{
				PrintWarningLog("failed to load mesh");
				return;
			}
			curr.sectionCount = sectionCount;
			curr.FBXInfo = new FBXInfo_t[curr.sectionCount];
			curr.SectionInfo = new MeshInfo_t[curr.sectionCount];
			for (int i = 0; i < curr.sectionCount; i++)
			{
				curr.FBXInfo[i] = default(FBXInfo_t);
				curr.SectionInfo[i] = default(MeshInfo_t);
				curr.FBXInfo[i].meshName = Marshal.AllocHGlobal(256);
			}
			if (!Interop.WVR_GetMeshData(sessionid, curr.FBXInfo))
			{
				for (int j = 0; j < sectionCount; j++)
				{
					Marshal.FreeHGlobal(curr.FBXInfo[j].meshName);
				}
				curr.SectionInfo = null;
				curr.FBXInfo = null;
				Interop.WVR_ReleaseMesh(sessionid);
				return;
			}
			for (uint num2 = 0u; num2 < curr.sectionCount; num2++)
			{
				curr.SectionInfo[num2]._vectice = new Vector3[curr.FBXInfo[num2].verticeCount];
				for (int k = 0; k < curr.FBXInfo[num2].verticeCount; k++)
				{
					curr.SectionInfo[num2]._vectice[k] = default(Vector3);
				}
				curr.SectionInfo[num2]._normal = new Vector3[curr.FBXInfo[num2].normalCount];
				for (int l = 0; l < curr.FBXInfo[num2].verticeCount; l++)
				{
					curr.SectionInfo[num2]._normal[l] = default(Vector3);
				}
				curr.SectionInfo[num2]._uv = new Vector2[curr.FBXInfo[num2].uvCount];
				for (int m = 0; m < curr.FBXInfo[num2].verticeCount; m++)
				{
					curr.SectionInfo[num2]._uv[m] = default(Vector2);
				}
				curr.SectionInfo[num2]._indice = new int[curr.FBXInfo[num2].indiceCount];
				for (int n = 0; n < curr.FBXInfo[num2].verticeCount; n++)
				{
					curr.SectionInfo[num2]._indice[n] = 0;
				}
				bool active = false;
				if (Interop.WVR_GetSectionData(sessionid, num2, curr.SectionInfo[num2]._vectice, curr.SectionInfo[num2]._normal, curr.SectionInfo[num2]._uv, curr.SectionInfo[num2]._indice, ref active))
				{
					curr.SectionInfo[num2]._active = active;
					PrintInfoLog("i = " + num2 + ", name = " + Marshal.PtrToStringAnsi(curr.FBXInfo[num2].meshName) + ", active = " + curr.SectionInfo[num2]._active.ToString());
					PrintInfoLog("i = " + num2 + ", relative transform = [" + curr.FBXInfo[num2].matrix.m0 + " , " + curr.FBXInfo[num2].matrix.m1 + " , " + curr.FBXInfo[num2].matrix.m2 + " , " + curr.FBXInfo[num2].matrix.m3 + "] ");
					PrintInfoLog("i = " + num2 + ", relative transform = [" + curr.FBXInfo[num2].matrix.m4 + " , " + curr.FBXInfo[num2].matrix.m5 + " , " + curr.FBXInfo[num2].matrix.m6 + " , " + curr.FBXInfo[num2].matrix.m7 + "] ");
					PrintInfoLog("i = " + num2 + ", relative transform = [" + curr.FBXInfo[num2].matrix.m8 + " , " + curr.FBXInfo[num2].matrix.m9 + " , " + curr.FBXInfo[num2].matrix.m10 + " , " + curr.FBXInfo[num2].matrix.m11 + "] ");
					PrintInfoLog("i = " + num2 + ", relative transform = [" + curr.FBXInfo[num2].matrix.m12 + " , " + curr.FBXInfo[num2].matrix.m13 + " , " + curr.FBXInfo[num2].matrix.m14 + " , " + curr.FBXInfo[num2].matrix.m15 + "] ");
					PrintInfoLog("i = " + num2 + ", vertice count = " + curr.FBXInfo[num2].verticeCount + ", normal count = " + curr.FBXInfo[num2].normalCount + ", uv count = " + curr.FBXInfo[num2].uvCount + ", indice count = " + curr.FBXInfo[num2].indiceCount);
				}
			}
			Interop.WVR_ReleaseMesh(sessionid);
			curr.isTouchSetting = GetTouchPadParam(curr, modelFolderPath, ms);
			curr.parserReady = true;
			PrintDebugLog("---  thread end  ---");
		}
		else
		{
			PrintWarningLog("FBX is not found");
		}
	}

	private bool GetTouchPadParam(ModelResource curr, string modelFolderPath, ModelSpecify ms)
	{
		if (curr == null)
		{
			PrintWarningLog("Model resource is null!");
			return false;
		}
		string text = modelFolderPath + "/";
		text = ((ms != 0) ? (text + "Touchpad01.json") : (text + "Touchpad.json"));
		if (!File.Exists(text))
		{
			PrintWarningLog(text + " is not found!");
			return false;
		}
		StreamReader streamReader = new StreamReader(text);
		string text2 = streamReader.ReadToEnd();
		PrintInfoLog("Touchpad json: " + text2);
		streamReader.Close();
		if (text2.Equals(""))
		{
			PrintWarningLog("JsonString is empty!");
			return false;
		}
		curr.TouchSetting = new TouchSetting();
		try
		{
			JSONNode jSONNode = JSONNode.Parse(text2);
			string text3 = "";
			string text4 = "";
			string text5 = "";
			string text6 = "";
			text3 = jSONNode["center"]["x"].Value;
			text4 = jSONNode["center"]["y"].Value;
			text5 = jSONNode["center"]["z"].Value;
			if (text3.Equals("") || text4.Equals("") || text5.Equals(""))
			{
				PrintWarningLog("Touch Center pointer is not found!");
				return false;
			}
			curr.TouchSetting.touchCenter = new Vector3(float.Parse(text3), float.Parse(text4), float.Parse(text5));
			PrintDebugLog("Touch Center pointer is found! x: " + curr.TouchSetting.touchCenter.x + " ,y: " + curr.TouchSetting.touchCenter.y + " ,z: " + curr.TouchSetting.touchCenter.z);
			text3 = jSONNode["up"]["x"].Value;
			text4 = jSONNode["up"]["y"].Value;
			text5 = jSONNode["up"]["z"].Value;
			if (text3.Equals("") || text4.Equals("") || text5.Equals(""))
			{
				PrintWarningLog("Touch Up pointer is not found!");
				return false;
			}
			curr.TouchSetting.touchForward = new Vector3(float.Parse(text3), float.Parse(text4), float.Parse(text5));
			PrintDebugLog("Touch Up pointer is found! x: " + curr.TouchSetting.touchForward.x + " ,y: " + curr.TouchSetting.touchForward.y + " ,z: " + curr.TouchSetting.touchForward.z);
			text3 = jSONNode["right"]["x"].Value;
			text4 = jSONNode["right"]["y"].Value;
			text5 = jSONNode["right"]["z"].Value;
			if (text3.Equals("") || text4.Equals("") || text5.Equals(""))
			{
				PrintWarningLog("Touch right pointer is not found!");
				return false;
			}
			curr.TouchSetting.touchRight = new Vector3(float.Parse(text3), float.Parse(text4), float.Parse(text5));
			PrintDebugLog("Touch right pointer is found! x: " + curr.TouchSetting.touchRight.x + " ,y: " + curr.TouchSetting.touchRight.y + " ,z: " + curr.TouchSetting.touchRight.z);
			text6 = jSONNode["FloatingDistance"].Value;
			if (text6.Equals(""))
			{
				PrintWarningLog("floatingStr is not found!");
				return false;
			}
			curr.TouchSetting.touchptHeight = float.Parse(text6);
			PrintInfoLog("Floating distance : " + curr.TouchSetting.touchptHeight);
			curr.TouchSetting.touchPtW = (curr.TouchSetting.touchForward - curr.TouchSetting.touchCenter).normalized;
			curr.TouchSetting.touchPtU = (curr.TouchSetting.touchRight - curr.TouchSetting.touchCenter).normalized;
			curr.TouchSetting.touchPtV = Vector3.Cross(curr.TouchSetting.touchPtU, curr.TouchSetting.touchPtW).normalized;
			curr.TouchSetting.raidus = (curr.TouchSetting.touchForward - curr.TouchSetting.touchCenter).magnitude;
			PrintInfoLog("touchPtW! x: " + curr.TouchSetting.touchPtW.x + " ,y: " + curr.TouchSetting.touchPtW.y + " ,z: " + curr.TouchSetting.touchPtW.z);
			PrintInfoLog("touchPtU! x: " + curr.TouchSetting.touchPtU.x + " ,y: " + curr.TouchSetting.touchPtU.y + " ,z: " + curr.TouchSetting.touchPtU.z);
			PrintInfoLog("touchPtV! x: " + curr.TouchSetting.touchPtV.x + " ,y: " + curr.TouchSetting.touchPtV.y + " ,z: " + curr.TouchSetting.touchPtV.z);
			PrintInfoLog("raidus: " + curr.TouchSetting.raidus);
		}
		catch (Exception ex)
		{
			WVR_Log.Log.e(LOG_TAG, "JsonParse failed: " + ex.ToString());
			return false;
		}
		return true;
	}

	private bool getBatteryIndicatorParam(ModelResource curr, string modelFolderPath, ModelSpecify ms)
	{
		if (curr == null)
		{
			PrintWarningLog("Model resource is null!");
			return false;
		}
		string text = modelFolderPath + "/";
		text = ((ms != 0) ? (text + "BatteryIndicator01.json") : (text + "BatteryIndicator.json"));
		if (!File.Exists(text))
		{
			PrintWarningLog(text + " is not found!");
			return false;
		}
		StreamReader streamReader = new StreamReader(text);
		string text2 = streamReader.ReadToEnd();
		PrintInfoLog("BatteryIndicator json: " + text2);
		streamReader.Close();
		if (text2.Equals(""))
		{
			PrintWarningLog("JsonString is empty!");
			return false;
		}
		JSONNode jSONNode = JSONNode.Parse(text2);
		string text3 = "";
		text3 = jSONNode["LevelCount"].Value;
		if (text3.Equals(""))
		{
			PrintWarningLog("Battery level is not found!");
			return false;
		}
		int num = int.Parse(text3);
		PrintInfoLog("Battery level is " + num);
		if (num <= 0)
		{
			PrintWarningLog("Battery level is less or equal to 0!");
			return false;
		}
		List<BatteryIndicator> list = new List<BatteryIndicator>();
		for (int i = 0; i < num; i++)
		{
			string value = jSONNode["BatteryLevel"][i]["min"].Value;
			string value2 = jSONNode["BatteryLevel"][i]["max"].Value;
			string value3 = jSONNode["BatteryLevel"][i]["path"].Value;
			if (value.Equals("") || value2.Equals("") || value3.Equals(""))
			{
				PrintWarningLog("Min, Max or Path is not found!");
				num = 0;
				list.Clear();
				return false;
			}
			string text4 = modelFolderPath + "/" + value3;
			if (!File.Exists(text4))
			{
				PrintWarningLog(text4 + " is not found!");
				num = 0;
				list.Clear();
				return false;
			}
			BatteryIndicator batteryIndicator = new BatteryIndicator();
			batteryIndicator.level = i;
			batteryIndicator.min = float.Parse(value);
			batteryIndicator.max = float.Parse(value2);
			batteryIndicator.texturePath = text4;
			byte[] array = File.ReadAllBytes(text4);
			PrintDebugLog("Image size: " + array.Length);
			batteryIndicator.batteryTexture = new Texture2D(2, 2, TextureFormat.BGRA32, mipChain: false);
			batteryIndicator.textureLoaded = batteryIndicator.batteryTexture.LoadImage(array);
			PrintInfoLog("Battery Level: " + batteryIndicator.level + " min: " + batteryIndicator.min + " max: " + batteryIndicator.max + " path: " + batteryIndicator.texturePath + " loaded: " + batteryIndicator.textureLoaded.ToString());
			list.Add(batteryIndicator);
		}
		curr.batteryTextureList = list;
		PrintInfoLog("BatteryIndicator is ready!");
		return true;
	}
}
public class WaveVR_ControllerRootToEmitter : MonoBehaviour
{
	private static string LOG_TAG = "WaveVR_ControllerRootToEmitter";

	public WaveVR_Controller.EDeviceType deviceType = WaveVR_Controller.EDeviceType.Dominant;

	public GameObject[] moveToEmitter;

	private GameObject emitter;

	private void PrintDebugLog(string msg)
	{
		WVR_Log.Log.d(LOG_TAG, string.Concat(deviceType, ", ", msg));
	}

	private void OnEnable()
	{
		WaveVR_Utils.Event.Listen(WaveVR_Utils.Event.ADAPTIVE_CONTROLLER_READY, onAdaptiveControllerModelReady);
	}

	private void OnDisable()
	{
		WaveVR_Utils.Event.Remove(WaveVR_Utils.Event.ADAPTIVE_CONTROLLER_READY, onAdaptiveControllerModelReady);
	}

	private void Start()
	{
	}

	private void Update()
	{
	}

	private void onAdaptiveControllerModelReady(params object[] args)
	{
		WaveVR_Controller.EDeviceType eDeviceType = (WaveVR_Controller.EDeviceType)args[0];
		if (deviceType != eDeviceType)
		{
			return;
		}
		WaveVR_RenderModel componentInChildren = GetComponentInChildren<WaveVR_RenderModel>();
		if (componentInChildren != null)
		{
			GameObject gameObject = componentInChildren.gameObject;
			int childCount = gameObject.transform.childCount;
			PrintDebugLog("onAdaptiveControllerModelReady() model child: " + childCount);
			for (int i = 0; i < childCount; i++)
			{
				GameObject gameObject2 = gameObject.transform.GetChild(i).gameObject;
				if (!(gameObject2.name == "__CM__Emitter") && !(gameObject2.name == "_[CM]_Emitter"))
				{
					continue;
				}
				emitter = gameObject2;
				PrintDebugLog("emitter local position (" + emitter.transform.localPosition.x + ", " + emitter.transform.localPosition.y + ", " + emitter.transform.localPosition.z + ")");
				PrintDebugLog("emitter local EulerAngles " + emitter.transform.localEulerAngles);
				if (moveToEmitter == null)
				{
					break;
				}
				PrintDebugLog("__CM__Emitter is found, update objects' parent");
				GameObject[] array = moveToEmitter;
				foreach (GameObject gameObject3 in array)
				{
					if (gameObject3 != null)
					{
						PrintDebugLog("Move " + gameObject3.name + " to be children of emitter");
						gameObject3.transform.parent = emitter.transform;
						gameObject3.transform.localRotation = Quaternion.identity;
						gameObject3.transform.localPosition = Vector3.zero;
						gameObject3.SetActive(value: false);
						gameObject3.SetActive(value: true);
					}
				}
				break;
			}
		}
		else
		{
			PrintDebugLog("WaveVR_RenderModel is not found");
		}
	}
}
public class WaveVR_RenderModel : MonoBehaviour
{
	public enum ControllerHand
	{
		Controller_Dominant,
		Controller_NonDominant
	}

	public enum LoadingState
	{
		LoadingState_NOT_LOADED,
		LoadingState_LOADING,
		LoadingState_LOADED
	}

	private static string LOG_TAG = "WaveVR_RenderModel";

	public ControllerHand WhichHand;

	public GameObject defaultModel;

	public bool updateDynamically;

	public bool mergeToOneBone;

	private GameObject controllerSpawned;

	private WaveVR_Controller.EDeviceType deviceType = WaveVR_Controller.EDeviceType.Dominant;

	private bool connected;

	private string renderModelNamePath = "";

	private string renderModelName = "";

	private IntPtr ptrParameterName = IntPtr.Zero;

	private IntPtr ptrResult = IntPtr.Zero;

	private List<Color32> colors = new List<Color32>();

	private GameObject meshCom;

	private GameObject meshGO;

	private Mesh updateMesh;

	private Material modelMat;

	private Material ImgMaterial;

	private WaitForEndOfFrame wfef;

	private WaitForSeconds wfs;

	private bool showBatterIndicator = true;

	private bool isBatteryIndicatorReady;

	private BatteryIndicator currentBattery;

	private GameObject batteryGO;

	private MeshRenderer batteryMR;

	private ModelResource modelResource;

	private ModelSpecify modelSpecify;

	private LoadingState mLoadingState;

	private int t;

	private bool IsFocusCapturedBySystemLastFrame;

	private string emitterMeshName = "__CM__Emitter";

	private void PrintDebugLog(string msg)
	{
		WVR_Log.Log.d(LOG_TAG, string.Concat("Hand: ", WhichHand, ", ", msg));
	}

	private void PrintInfoLog(string msg)
	{
		WVR_Log.Log.i(LOG_TAG, string.Concat("Hand: ", WhichHand, ", ", msg));
	}

	private void PrintWarningLog(string msg)
	{
		WVR_Log.Log.w(LOG_TAG, string.Concat("Hand: ", WhichHand, ", ", msg));
	}

	private void OnEnable()
	{
		PrintDebugLog("OnEnable");
		if (mLoadingState == LoadingState.LoadingState_LOADING)
		{
			deleteChild("RenderModel doesn't expect model is in loading, delete all children");
		}
		if (WhichHand == ControllerHand.Controller_Dominant)
		{
			deviceType = WaveVR_Controller.EDeviceType.Dominant;
			modelSpecify = ModelSpecify.MS_Dominant;
		}
		else
		{
			deviceType = WaveVR_Controller.EDeviceType.NonDominant;
			modelSpecify = ModelSpecify.MS_NonDominant;
		}
		connected = checkConnection();
		if (connected)
		{
			WaveVR.Device deviceByType = WaveVR.Instance.getDeviceByType(deviceType);
			if (mLoadingState == LoadingState.LoadingState_LOADED)
			{
				if (isRenderModelNameSameAsPrevious())
				{
					PrintDebugLog("OnEnable - Controller connected, model was loaded!");
				}
				else
				{
					deleteChild("Controller load when OnEnable, render model is different!");
					onLoadController(deviceByType.type);
				}
			}
			else
			{
				PrintDebugLog("Controller load when OnEnable!");
				onLoadController(deviceByType.type);
			}
		}
		WaveVR_Utils.Event.Listen(WaveVR_Utils.Event.DEVICE_CONNECTED, onDeviceConnected);
		WaveVR_Utils.Event.Listen(WaveVR_Utils.Event.OEM_CONFIG_CHANGED, onOEMConfigChanged);
	}

	private void OnDisable()
	{
		PrintDebugLog("OnDisable");
		if (mLoadingState == LoadingState.LoadingState_LOADING)
		{
			deleteChild("RenderModel doesn't complete creating meshes before OnDisable, delete all children");
		}
		WaveVR_Utils.Event.Remove(WaveVR_Utils.Event.DEVICE_CONNECTED, onDeviceConnected);
		WaveVR_Utils.Event.Remove(WaveVR_Utils.Event.OEM_CONFIG_CHANGED, onOEMConfigChanged);
	}

	private void onOEMConfigChanged(params object[] args)
	{
		PrintDebugLog("onOEMConfigChanged");
		ReadJsonValues();
	}

	private void ReadJsonValues()
	{
		showBatterIndicator = false;
		string batteryConfig = WaveVR_Utils.OEMConfig.getBatteryConfig();
		if (!batteryConfig.Equals(""))
		{
			try
			{
				JSONNode jSONNode = JSONNode.Parse(batteryConfig);
				string text = "";
				text = jSONNode["show"].Value;
				if (!text.Equals("") && text.Equals("2"))
				{
					showBatterIndicator = true;
				}
			}
			catch (Exception ex)
			{
				WVR_Log.Log.e(LOG_TAG, "JsonParse failed: " + ex.ToString());
			}
		}
		PrintDebugLog("showBatterIndicator: " + showBatterIndicator);
	}

	private void onDeviceConnected(params object[] args)
	{
		WVR_DeviceType wVR_DeviceType = (WVR_DeviceType)args[0];
		WVR_DeviceType wVR_DeviceType2 = WVR_DeviceType.WVR_DeviceType_Invalid;
		bool flag = false;
		WaveVR.Device deviceByType = WaveVR.Instance.getDeviceByType(deviceType);
		flag = deviceByType.connected;
		wVR_DeviceType2 = deviceByType.type;
		if (wVR_DeviceType != wVR_DeviceType2)
		{
			PrintDebugLog(string.Concat("onDeviceConnected() event type is ", wVR_DeviceType, ", this.deviceType is ", wVR_DeviceType2, ", skip"));
			return;
		}
		PrintDebugLog(string.Concat("onDeviceConnected() ", wVR_DeviceType2, " is ", flag ? "connected" : "disconnected", ", left-handed? ", WaveVR_Controller.IsLeftHanded.ToString()));
		if (connected == flag)
		{
			return;
		}
		connected = flag;
		if (!connected)
		{
			return;
		}
		if (mLoadingState == LoadingState.LoadingState_LOADED)
		{
			if (isRenderModelNameSameAsPrevious())
			{
				PrintDebugLog("onDeviceConnected - Controller connected, model was loaded!");
				return;
			}
			deleteChild("Controller load when onDeviceConnected, render model is different!");
			onLoadController(wVR_DeviceType2);
		}
		else if (mLoadingState == LoadingState.LoadingState_LOADING)
		{
			PrintDebugLog("onDeviceConnected - Controller connected, model is loading!");
		}
		else
		{
			PrintDebugLog("Controller load when onDeviceConnected!");
			onLoadController(wVR_DeviceType2);
		}
	}

	private bool isRenderModelNameSameAsPrevious()
	{
		WVR_DeviceType type = WaveVR_Controller.Input(deviceType).DeviceType;
		bool num = WaveVR_Controller.Input(deviceType).connected;
		bool result = false;
		if (!num)
		{
			return result;
		}
		string s = "GetRenderModelName";
		ptrParameterName = Marshal.StringToHGlobalAnsi(s);
		ptrResult = Marshal.AllocHGlobal(64);
		uint unBufferSize = 64u;
		Interop.WVR_GetParameters(type, ptrParameterName, ptrResult, unBufferSize);
		string text = Marshal.PtrToStringAnsi(ptrResult);
		PrintDebugLog("previous render model: " + renderModelName + ", current render model name: " + text);
		if (text == renderModelName)
		{
			result = true;
		}
		Marshal.FreeHGlobal(ptrParameterName);
		Marshal.FreeHGlobal(ptrResult);
		return result;
	}

	private void Start()
	{
		PrintDebugLog("start() connect: " + connected.ToString() + " Which hand: " + WhichHand);
		wfs = new WaitForSeconds(1f);
		ReadJsonValues();
		if (updateDynamically)
		{
			PrintDebugLog("updateDynamically, start a coroutine to check connection and render model name periodly");
			StartCoroutine(checkRenderModelAndDelete());
		}
	}

	private void Update()
	{
		if (Interop.WVR_IsInputFocusCapturedBySystem())
		{
			IsFocusCapturedBySystemLastFrame = true;
			return;
		}
		if (IsFocusCapturedBySystemLastFrame || t-- < 0)
		{
			updateBatteryLevel();
			t = 200;
			IsFocusCapturedBySystemLastFrame = false;
		}
		if (WVR_Log.Log.gpl.Print)
		{
			WVR_Log.Log.d(LOG_TAG, string.Concat("Update() render model ", WhichHand, " connect ? ", connected.ToString(), ", child object count ? ", base.transform.childCount, ", showBatterIndicator: ", showBatterIndicator.ToString(), ", hasBattery: ", isBatteryIndicatorReady.ToString()));
		}
	}

	private void onLoadController(WVR_DeviceType type)
	{
		mLoadingState = LoadingState.LoadingState_LOADING;
		PrintDebugLog("Pos: " + base.transform.localPosition.x + " " + base.transform.localPosition.y + " " + base.transform.localPosition.z);
		PrintDebugLog("Rot: " + base.transform.localEulerAngles);
		if (Interop.WVR_GetWaveRuntimeVersion() < 2)
		{
			PrintDebugLog("onLoadController in old service");
			if (defaultModel != null)
			{
				controllerSpawned = UnityEngine.Object.Instantiate(defaultModel, base.transform);
				controllerSpawned.transform.parent = base.transform;
			}
			mLoadingState = LoadingState.LoadingState_NOT_LOADED;
			return;
		}
		string s = "GetRenderModelName";
		ptrParameterName = Marshal.StringToHGlobalAnsi(s);
		ptrResult = Marshal.AllocHGlobal(64);
		uint unBufferSize = 64u;
		if (Interop.WVR_GetParameters(type, ptrParameterName, ptrResult, unBufferSize) == 0)
		{
			PrintDebugLog("Can not find render model.");
			if (defaultModel != null)
			{
				PrintDebugLog("Can't load controller model from DS, load default model");
				controllerSpawned = UnityEngine.Object.Instantiate(defaultModel, base.transform);
				controllerSpawned.transform.parent = base.transform;
				mLoadingState = LoadingState.LoadingState_NOT_LOADED;
			}
			Marshal.FreeHGlobal(ptrParameterName);
			Marshal.FreeHGlobal(ptrResult);
			return;
		}
		renderModelName = Marshal.PtrToStringAnsi(ptrResult);
		int num = -1;
		s = "backdoor_get_device_index";
		ptrParameterName = Marshal.StringToHGlobalAnsi(s);
		IntPtr intPtr = Marshal.AllocHGlobal(2);
		Interop.WVR_GetParameters(type, ptrParameterName, intPtr, 2u);
		int result = 0;
		if (int.TryParse(Marshal.PtrToStringAnsi(intPtr), out result))
		{
			num = result;
		}
		PrintInfoLog("get controller id from runtime is " + renderModelName + ", deviceIndex = " + num);
		string text = Interop.WVR_DeployRenderModelAssets(num, renderModelName);
		mLoadingState = ((text != "") ? LoadingState.LoadingState_LOADING : LoadingState.LoadingState_NOT_LOADED);
		if (text != "")
		{
			modelResource = null;
			renderModelNamePath = text + "Model";
			if (WaveVR_ControllerResourceHolder.Instance.addRenderModel(renderModelName, renderModelNamePath, modelSpecify, mergeToOneBone))
			{
				PrintDebugLog(string.Concat("Add ", renderModelName, " with ", modelSpecify, " model sucessfully!"));
			}
			modelResource = WaveVR_ControllerResourceHolder.Instance.getRenderModelResource(renderModelName, modelSpecify, mergeToOneBone);
			if (modelResource == null && modelSpecify == ModelSpecify.MS_NonDominant)
			{
				if (WaveVR_ControllerResourceHolder.Instance.addRenderModel(renderModelName, renderModelNamePath, ModelSpecify.MS_Dominant, mergeToOneBone))
				{
					PrintDebugLog("Add " + renderModelName + " Dominant model sucessfully!");
				}
				modelResource = WaveVR_ControllerResourceHolder.Instance.getRenderModelResource(renderModelName, ModelSpecify.MS_Dominant, mergeToOneBone);
			}
			if (modelResource != null)
			{
				mLoadingState = LoadingState.LoadingState_LOADING;
				PrintDebugLog(string.Concat("Starting load ", renderModelName, " with <", modelResource.modelSpecify, "> model!"));
				ImgMaterial = new Material(Shader.Find("Unlit/Texture"));
				wfef = new WaitForEndOfFrame();
				StartCoroutine(SpawnRenderModel());
			}
			else
			{
				PrintDebugLog("Model is null!");
				if (defaultModel != null)
				{
					PrintDebugLog("Can't load controller model from DS, load default model");
					controllerSpawned = UnityEngine.Object.Instantiate(defaultModel, base.transform);
					controllerSpawned.transform.parent = base.transform;
					mLoadingState = LoadingState.LoadingState_LOADED;
				}
			}
		}
		Marshal.FreeHGlobal(ptrParameterName);
		Marshal.FreeHGlobal(ptrResult);
	}

	private IEnumerator SpawnRenderModel()
	{
		while (modelResource == null || !modelResource.parserReady)
		{
			PrintDebugLog("SpawnRenderModel is waiting");
			yield return wfef;
		}
		PrintDebugLog("Start to spawn all meshes!");
		if (modelResource == null)
		{
			PrintDebugLog("modelResource is null, skipping spawn objects");
			mLoadingState = LoadingState.LoadingState_NOT_LOADED;
			yield return null;
		}
		for (uint i = 0u; i < modelResource.sectionCount; i++)
		{
			string text = Marshal.PtrToStringAnsi(modelResource.FBXInfo[i].meshName);
			meshCom = null;
			meshGO = null;
			bool flag = false;
			for (uint num = 0u; num < i; num++)
			{
				if (Marshal.PtrToStringAnsi(modelResource.FBXInfo[num].meshName).Equals(text))
				{
					flag = true;
				}
			}
			if (flag)
			{
				PrintDebugLog(text + " is created! skip.");
				continue;
			}
			if (mergeToOneBone && modelResource.SectionInfo[i]._active)
			{
				text = "Merge_" + text;
			}
			updateMesh = new Mesh();
			meshCom = new GameObject();
			meshCom.AddComponent<MeshRenderer>();
			meshCom.AddComponent<MeshFilter>();
			meshGO = UnityEngine.Object.Instantiate(meshCom);
			meshGO.transform.parent = base.transform;
			meshGO.name = text;
			Matrix4x4 matrix = WaveVR_Utils.RigidTransform.toMatrix44(modelResource.FBXInfo[i].matrix);
			Vector3 position = matrix.GetPosition();
			meshGO.transform.localPosition = new Vector3(position.x, position.y, 0f - position.z);
			meshGO.transform.localRotation = WaveVR_Utils.GetRotation(matrix);
			Vector3 localEulerAngles = meshGO.transform.localEulerAngles;
			meshGO.transform.localEulerAngles = new Vector3(0f - localEulerAngles.x, localEulerAngles.y, localEulerAngles.z);
			meshGO.transform.localScale = matrix.GetScale();
			PrintDebugLog("i = " + i + " MeshGO = " + text + ", localPosition: " + meshGO.transform.localPosition.x + ", " + meshGO.transform.localPosition.y + ", " + meshGO.transform.localPosition.z);
			PrintDebugLog("i = " + i + " MeshGO = " + text + ", localRotation: " + meshGO.transform.localEulerAngles);
			PrintDebugLog("i = " + i + " MeshGO = " + text + ", localScale: " + meshGO.transform.localScale);
			MeshFilter component = meshGO.GetComponent<MeshFilter>();
			updateMesh.Clear();
			updateMesh.vertices = modelResource.SectionInfo[i]._vectice;
			updateMesh.uv = modelResource.SectionInfo[i]._uv;
			updateMesh.uv2 = modelResource.SectionInfo[i]._uv;
			updateMesh.colors32 = colors.ToArray();
			updateMesh.normals = modelResource.SectionInfo[i]._normal;
			updateMesh.SetIndices(modelResource.SectionInfo[i]._indice, MeshTopology.Triangles, 0);
			updateMesh.name = text;
			if (component != null)
			{
				component.mesh = updateMesh;
			}
			MeshRenderer component2 = meshGO.GetComponent<MeshRenderer>();
			if (component2 != null)
			{
				if (ImgMaterial == null)
				{
					PrintDebugLog("ImgMaterial is null");
				}
				component2.material = ImgMaterial;
				component2.material.mainTexture = modelResource.modelTexture;
				component2.enabled = true;
			}
			if (text.Equals(emitterMeshName))
			{
				PrintDebugLog(text + " is found, set " + text + " active: true");
				meshGO.SetActive(value: true);
			}
			else if (text.Equals("__CM__Battery"))
			{
				isBatteryIndicatorReady = false;
				if (modelResource.isBatterySetting && modelResource.batteryTextureList != null)
				{
					batteryMR = meshGO.GetComponent<MeshRenderer>();
					Material material = Resources.Load("TransparentMat") as Material;
					if (material != null)
					{
						batteryMR.material = material;
					}
					batteryMR.material.mainTexture = modelResource.batteryTextureList[0].batteryTexture;
					batteryMR.enabled = true;
					isBatteryIndicatorReady = true;
				}
				meshGO.SetActive(value: false);
				PrintDebugLog(text + " is found, set " + text + " active: false (waiting for update");
				batteryGO = meshGO;
			}
			else if (text == "__CM__TouchPad_Touch")
			{
				PrintDebugLog(text + " is found, set " + text + " active: false");
				meshGO.SetActive(value: false);
			}
			else
			{
				PrintDebugLog("set " + text + " active: " + modelResource.SectionInfo[i]._active);
				meshGO.SetActive(modelResource.SectionInfo[i]._active);
			}
			yield return wfef;
		}
		PrintDebugLog(string.Concat("send ", deviceType, " ADAPTIVE_CONTROLLER_READY "));
		WaveVR_Utils.Event.Send(WaveVR_Utils.Event.ADAPTIVE_CONTROLLER_READY, deviceType);
		Resources.UnloadUnusedAssets();
		mLoadingState = LoadingState.LoadingState_LOADED;
	}

	private void updateBatteryLevel()
	{
		if (!(batteryGO != null))
		{
			return;
		}
		if (showBatterIndicator && isBatteryIndicatorReady)
		{
			if (modelResource == null || modelResource.batteryTextureList == null)
			{
				return;
			}
			bool flag = false;
			float num = Interop.WVR_GetDeviceBatteryPercentage(WaveVR.Instance.getDeviceByType(deviceType).type);
			if (num < 0f)
			{
				PrintDebugLog("updateBatteryLevel BatteryPercentage is negative, return");
				batteryGO.SetActive(value: false);
				return;
			}
			foreach (BatteryIndicator batteryTexture in modelResource.batteryTextureList)
			{
				if (num >= batteryTexture.min / 100f && num <= batteryTexture.max / 100f)
				{
					currentBattery = batteryTexture;
					flag = true;
					break;
				}
			}
			if (flag)
			{
				if (batteryMR != null)
				{
					batteryMR.material.mainTexture = currentBattery.batteryTexture;
					PrintDebugLog("updateBatteryLevel battery level to " + currentBattery.level + ", battery percent: " + num);
					batteryGO.SetActive(value: true);
				}
				else
				{
					PrintDebugLog("updateBatteryLevel Can't get battery mesh renderer");
					batteryGO.SetActive(value: false);
				}
			}
			else
			{
				batteryGO.SetActive(value: false);
			}
		}
		else
		{
			batteryGO.SetActive(value: false);
		}
	}

	private IEnumerator checkRenderModelAndDelete()
	{
		while (true)
		{
			DeleteControllerWhenDisconnect();
			yield return wfs;
		}
	}

	private void deleteChild(string reason)
	{
		PrintInfoLog(reason);
		int childCount = base.transform.childCount;
		for (int i = 0; i < childCount; i++)
		{
			PrintInfoLog("deleteChild: " + base.transform.GetChild(i).gameObject.name);
			UnityEngine.Object.Destroy(base.transform.GetChild(i).gameObject);
		}
		mLoadingState = LoadingState.LoadingState_NOT_LOADED;
	}

	private void DeleteControllerWhenDisconnect()
	{
		if (mLoadingState != LoadingState.LoadingState_LOADED)
		{
			return;
		}
		if (WaveVR_Controller.Input(deviceType).connected)
		{
			WVR_DeviceType type = WaveVR_Controller.Input(deviceType).DeviceType;
			string s = "GetRenderModelName";
			ptrParameterName = Marshal.StringToHGlobalAnsi(s);
			ptrResult = Marshal.AllocHGlobal(64);
			uint unBufferSize = 64u;
			uint num = Interop.WVR_GetParameters(type, ptrParameterName, ptrResult, unBufferSize);
			string text = Marshal.PtrToStringAnsi(ptrResult);
			Marshal.FreeHGlobal(ptrParameterName);
			Marshal.FreeHGlobal(ptrResult);
			if (num != 0 && text != renderModelName)
			{
				deleteChild("Destroy controller prefeb because render model is different");
			}
		}
		else
		{
			deleteChild("Destroy controller prefeb because it is disconnect");
		}
	}

	private bool checkConnection()
	{
		return WaveVR.Instance.getDeviceByType(deviceType).connected;
	}
}
[Serializable]
public class ButtonIndication
{
	public enum Alignment
	{
		RIGHT,
		LEFT
	}

	public enum KeyIndicator
	{
		Trigger,
		TouchPad,
		DigitalTrigger,
		App,
		Home,
		Volume,
		VolumeUp,
		VolumeDown,
		Grip,
		DPad_Left,
		DPad_Right,
		DPad_Up,
		DPad_Down
	}

	public KeyIndicator keyType;

	public Alignment alignment;

	public Vector3 indicationOffset = new Vector3(0f, 0f, 0f);

	public bool useMultiLanguage;

	public string indicationText = "system";

	public bool followButtonRotation;
}
[Serializable]
public class ComponentsIndication
{
	public string Name;

	public string Description = "system";

	public GameObject SourceObject;

	public GameObject LineIndicator;

	public GameObject DestObject;

	public ButtonIndication.Alignment alignment;

	public Vector3 Offset;

	public bool followButtonRoration;
}
public class WaveVR_ShowIndicator : MonoBehaviour
{
	private static string LOG_TAG = "WaveVR_ShowIndicator";

	[Header("Indication feature")]
	public bool showIndicator;

	[Range(0f, 90f)]
	public float showIndicatorAngle = 30f;

	public bool hideIndicatorByRoll = true;

	public bool basedOnEmitter = true;

	[Header("Line customization")]
	[Range(0.01f, 0.1f)]
	public float lineLength = 0.03f;

	[Range(0.0001f, 0.1f)]
	public float lineStartWidth = 0.0004f;

	[Range(0.0001f, 0.1f)]
	public float lineEndWidth = 0.0004f;

	public Color lineColor = Color.white;

	[Header("Text customization")]
	[Range(0.01f, 0.2f)]
	public float textCharacterSize = 0.08f;

	[Range(0.01f, 0.2f)]
	public float zhCharactarSize = 0.07f;

	[Range(50f, 200f)]
	public int textFontSize = 100;

	public Color textColor = Color.white;

	[Header("Indications")]
	public List<ButtonIndication> buttonIndicationList = new List<ButtonIndication>();

	private WaveVR_Resource rw;

	private string sysLang;

	private string sysCountry;

	private int checkCount;

	private GameObject indicatorPrefab;

	private GameObject linePrefab;

	private List<ComponentsIndication> compInd = new List<ComponentsIndication>();

	private GameObject _HMD;

	private bool needRedraw = true;

	private GameObject Emitter;

	private void PrintDebugLog(string msg)
	{
		WVR_Log.Log.d(LOG_TAG, msg);
	}

	private void PrintInfoLog(string msg)
	{
		WVR_Log.Log.i(LOG_TAG, msg);
	}

	private void resetIndicator()
	{
		if (showIndicator)
		{
			rw = WaveVR_Resource.instance;
			sysLang = rw.getSystemLanguage();
			sysCountry = rw.getSystemCountry();
			needRedraw = true;
			clearResourceAndObject();
		}
	}

	private void OnApplicationPause(bool pauseStatus)
	{
		if (pauseStatus)
		{
			resetIndicator();
		}
	}

	private void clearResourceAndObject()
	{
		PrintDebugLog("clear Indicator!");
		foreach (ComponentsIndication item in compInd)
		{
			if (item.DestObject != null)
			{
				UnityEngine.Object.Destroy(item.DestObject);
			}
			if (item.LineIndicator != null)
			{
				UnityEngine.Object.Destroy(item.LineIndicator);
			}
		}
		compInd.Clear();
		Resources.UnloadUnusedAssets();
	}

	private void onAdaptiveControllerModelReady(params object[] args)
	{
		createIndicator();
	}

	private void OnEnable()
	{
		WaveVR_Utils.Event.Listen(WaveVR_Utils.Event.ADAPTIVE_CONTROLLER_READY, onAdaptiveControllerModelReady);
	}

	private void OnDisable()
	{
		WaveVR_Utils.Event.Remove(WaveVR_Utils.Event.ADAPTIVE_CONTROLLER_READY, onAdaptiveControllerModelReady);
	}

	private void Start()
	{
	}

	public void createIndicator()
	{
		if (!showIndicator)
		{
			return;
		}
		clearResourceAndObject();
		PrintDebugLog("create Indicator!");
		rw = WaveVR_Resource.instance;
		indicatorPrefab = Resources.Load("ComponentIndicator") as GameObject;
		if (indicatorPrefab == null)
		{
			PrintInfoLog("ComponentIndicator is not found!");
			return;
		}
		PrintDebugLog("ComponentIndicator is found!");
		linePrefab = Resources.Load("LineIndicator") as GameObject;
		if (linePrefab == null)
		{
			PrintInfoLog("LineIndicator is not found!");
			return;
		}
		PrintDebugLog("LineIndicator is found!");
		if (_HMD == null)
		{
			_HMD = WaveVR_Render.Instance.gameObject;
		}
		if (_HMD == null)
		{
			PrintInfoLog("Can't get HMD!");
			return;
		}
		int childCount = base.transform.childCount;
		for (int i = 0; i < childCount; i++)
		{
			GameObject gameObject = base.transform.GetChild(i).gameObject;
			PrintInfoLog("child name is " + gameObject.name);
		}
		PrintInfoLog("showIndicatorAngle: " + showIndicatorAngle + ", hideIndicatorByRoll: " + hideIndicatorByRoll.ToString() + ", basedOnEmitter: " + basedOnEmitter.ToString());
		PrintInfoLog("Line settings--\n lineLength: " + lineLength + ", lineStartWidth: " + lineStartWidth + ", lineEndWidth: " + lineEndWidth + ", lineColor: " + lineColor);
		PrintInfoLog("Text settings--\n textCharacterSize: " + textCharacterSize + ", zhCharactarSize: " + zhCharactarSize + ", textFontSize: " + textFontSize + ", textColor: " + textColor);
		foreach (ButtonIndication buttonIndication in buttonIndicationList)
		{
			PrintInfoLog(string.Concat("keyType: ", buttonIndication.keyType, ", alignment: ", buttonIndication.alignment, ", offset: ", buttonIndication.indicationOffset, ", useMultiLanguage: ", buttonIndication.useMultiLanguage.ToString(), ", indication: ", buttonIndication.indicationText, ", followRotation: ", buttonIndication.followButtonRotation.ToString()));
			string text = null;
			string text2 = null;
			string text3 = null;
			string text4 = null;
			switch (buttonIndication.keyType)
			{
			case ButtonIndication.KeyIndicator.Trigger:
				text = "_[CM]_TriggerKey";
				text2 = "__CM__TriggerKey";
				text3 = "__CM__TriggerKey.__CM__TriggerKey";
				text4 = "TriggerKey";
				break;
			case ButtonIndication.KeyIndicator.TouchPad:
				text = "_[CM]_TouchPad";
				text2 = "__CM__TouchPad";
				text3 = "__CM__TouchPad.__CM__TouchPad";
				text4 = "TouchPad";
				break;
			case ButtonIndication.KeyIndicator.Grip:
				text = "_[CM]_Grip";
				text2 = "__CM__Grip";
				text3 = "__CM__Grip.__CM__Grip";
				text4 = "Grip";
				break;
			case ButtonIndication.KeyIndicator.DPad_Left:
				text = "_[CM]_DPad_Left";
				text2 = "__CM__DPad_Left";
				text3 = "__CM__DPad_Left.__CM__DPad_Left";
				text4 = "DPad_Left";
				break;
			case ButtonIndication.KeyIndicator.DPad_Right:
				text = "_[CM]_DPad_Right";
				text2 = "__CM__DPad_Right";
				text3 = "__CM__DPad_Right.__CM__DPad_Right";
				text4 = "DPad_Right";
				break;
			case ButtonIndication.KeyIndicator.DPad_Up:
				text = "_[CM]_DPad_Up";
				text2 = "__CM__DPad_Up";
				text3 = "__CM__DPad_Up.__CM__DPad_Up";
				text4 = "DPad_Up";
				break;
			case ButtonIndication.KeyIndicator.DPad_Down:
				text = "_[CM]_DPad_Down";
				text2 = "__CM__DPad_Down";
				text3 = "__CM__DPad_Down.__CM__DPad_Down";
				text4 = "DPad_Down";
				break;
			case ButtonIndication.KeyIndicator.App:
				text = "_[CM]_AppButton";
				text2 = "__CM__AppButton";
				text3 = "__CM__AppButton.__CM__AppButton";
				text4 = "AppKey";
				break;
			case ButtonIndication.KeyIndicator.Home:
				text = "_[CM]_HomeButton";
				text2 = "__CM__HomeButton";
				text3 = "__CM__HomeButton.__CM__HomeButton";
				text4 = "HomeKey";
				break;
			case ButtonIndication.KeyIndicator.Volume:
				text = "_[CM]_VolumeKey";
				text2 = "__CM__VolumeKey";
				text3 = "__CM__VolumeKey.__CM__VolumeKey";
				text4 = "VolumeKey";
				break;
			case ButtonIndication.KeyIndicator.VolumeUp:
				text = "_[CM]_VolumeUp";
				text2 = "__CM__VolumeUp";
				text3 = "__CM__VolumeUp.__CM__VolumeUp";
				text4 = "VolumeUp";
				break;
			case ButtonIndication.KeyIndicator.VolumeDown:
				text = "_[CM]_VolumeDown";
				text2 = "__CM__VolumeDown";
				text3 = "__CM__VolumeDown.__CM__VolumeDown";
				text4 = "VolumeDown";
				break;
			case ButtonIndication.KeyIndicator.DigitalTrigger:
				text = "_[CM]_DigitalTriggerKey";
				text2 = "__CM__DigitalTriggerKey";
				text3 = "__CM__DigitalTriggerKey.__CM__DigitalTriggerKey";
				text4 = "DigitalTriggerKey";
				break;
			default:
				text = "_[CM]_unknown";
				text2 = "__CM__unknown";
				text3 = "__CM__unknown.__CM__unknown";
				text4 = "unknown";
				PrintDebugLog("Unknown key type!");
				break;
			}
			Transform transform = base.transform.Find(text);
			if (transform == null)
			{
				transform = base.transform.Find(text2);
				if (transform == null)
				{
					transform = base.transform.Find(text3);
				}
			}
			if (transform != null)
			{
				ComponentsIndication componentsIndication = new ComponentsIndication();
				componentsIndication.Name = text;
				componentsIndication.SourceObject = transform.gameObject;
				componentsIndication.alignment = buttonIndication.alignment;
				componentsIndication.followButtonRoration = buttonIndication.followButtonRotation;
				componentsIndication.LineIndicator = null;
				Vector3 position = base.transform.TransformPoint(new Vector3(0f, transform.localPosition.y, transform.localPosition.z) + buttonIndication.indicationOffset);
				Quaternion rotation = Quaternion.identity;
				if (buttonIndication.followButtonRotation)
				{
					rotation = base.transform.rotation;
				}
				GameObject gameObject2 = UnityEngine.Object.Instantiate(linePrefab, position, rotation);
				gameObject2.name = text + "Line";
				IndicatorLine component = gameObject2.GetComponent<IndicatorLine>();
				component.lineColor = lineColor;
				component.lineLength = lineLength;
				component.startWidth = lineStartWidth;
				component.endWidth = lineEndWidth;
				component.alignment = buttonIndication.alignment;
				component.updateMeshSettings();
				if (buttonIndication.followButtonRotation)
				{
					gameObject2.transform.parent = componentsIndication.SourceObject.transform;
				}
				gameObject2.SetActive(value: false);
				componentsIndication.LineIndicator = gameObject2;
				componentsIndication.DestObject = null;
				GameObject gameObject3 = UnityEngine.Object.Instantiate(position: (buttonIndication.alignment != 0) ? base.transform.TransformPoint(new Vector3(lineLength * -1f, transform.localPosition.y, transform.localPosition.z) + buttonIndication.indicationOffset) : base.transform.TransformPoint(new Vector3(lineLength, transform.localPosition.y, transform.localPosition.z) + buttonIndication.indicationOffset), original: indicatorPrefab, rotation: base.transform.rotation);
				gameObject3.name = text + "Ind";
				if (buttonIndication.followButtonRotation)
				{
					gameObject3.transform.parent = componentsIndication.SourceObject.transform;
				}
				PrintInfoLog(string.Concat(" Source PartName: ", transform.gameObject.name, " pos: ", transform.position, " Rot: ", transform.rotation));
				PrintInfoLog(string.Concat(" Line Name: ", gameObject2.name, " pos: ", gameObject2.transform.position, " Rot: ", gameObject2.transform.rotation));
				PrintInfoLog(string.Concat(" Destination Name: ", gameObject3.name, " pos: ", gameObject3.transform.position, " Rot: ", gameObject3.transform.rotation));
				int childCount2 = gameObject3.transform.childCount;
				for (int j = 0; j < childCount2; j++)
				{
					GameObject gameObject4 = gameObject3.transform.GetChild(j).gameObject;
					if (buttonIndication.alignment == ButtonIndication.Alignment.LEFT)
					{
						float x = gameObject4.transform.localPosition.x;
						gameObject4.transform.localPosition = new Vector3(x * -1f, gameObject4.transform.localPosition.y, gameObject4.transform.localPosition.z);
					}
					TextMesh component2 = gameObject4.GetComponent<TextMesh>();
					MeshRenderer component3 = gameObject4.GetComponent<MeshRenderer>();
					if (component2 == null)
					{
						PrintInfoLog(" tm is null ");
					}
					if (component3 == null)
					{
						PrintInfoLog(" mr is null ");
					}
					if (!(component2 != null) || !(component3 != null))
					{
						continue;
					}
					component2.characterSize = textCharacterSize;
					if (gameObject4.name != "Shadow")
					{
						component3.material.SetColor("_Color", textColor);
					}
					else
					{
						PrintDebugLog(" Shadow found ");
					}
					component2.fontSize = textFontSize;
					if (buttonIndication.useMultiLanguage)
					{
						sysLang = rw.getSystemLanguage();
						sysCountry = rw.getSystemCountry();
						PrintDebugLog(" System language is " + sysLang);
						if (sysLang.StartsWith("zh"))
						{
							PrintDebugLog(" Chinese language");
							component2.characterSize = zhCharactarSize;
						}
						if (buttonIndication.indicationText == "system")
						{
							component2.text = rw.getString(text4);
							PrintInfoLog(" Name: " + gameObject3.name + " uses default multi-language -> " + component2.text);
						}
						else
						{
							component2.text = rw.getString(buttonIndication.indicationText);
							PrintInfoLog(" Name: " + gameObject3.name + " uses custom multi-language -> " + component2.text);
						}
					}
					else
					{
						if (buttonIndication.indicationText == "system")
						{
							component2.text = text4;
						}
						else
						{
							component2.text = buttonIndication.indicationText;
						}
						PrintInfoLog(" Name: " + gameObject3.name + " didn't uses multi-language -> " + component2.text);
					}
					if (buttonIndication.alignment == ButtonIndication.Alignment.LEFT)
					{
						component2.anchor = TextAnchor.MiddleRight;
						component2.alignment = TextAlignment.Right;
					}
				}
				gameObject3.SetActive(value: false);
				componentsIndication.DestObject = gameObject3;
				componentsIndication.Offset = buttonIndication.indicationOffset;
				PrintInfoLog(componentsIndication.Name + " line -> " + componentsIndication.LineIndicator.name + " destObjName -> " + componentsIndication.DestObject.name);
				compInd.Add(componentsIndication);
			}
			else
			{
				PrintInfoLog("Neither " + text + " or " + text2 + " or " + text3 + " is not in the model!");
			}
		}
		Emitter = null;
		if (basedOnEmitter)
		{
			WaveVR_RenderModel componentInChildren = GetComponentInChildren<WaveVR_RenderModel>();
			if (componentInChildren != null)
			{
				GameObject gameObject5 = componentInChildren.gameObject;
				int childCount3 = gameObject5.transform.childCount;
				for (int k = 0; k < childCount3; k++)
				{
					GameObject gameObject6 = gameObject5.transform.GetChild(k).gameObject;
					if (gameObject6.name == "__CM__Emitter" || gameObject6.name == "_[CM]_Emitter")
					{
						Emitter = gameObject6;
					}
				}
			}
		}
		needRedraw = false;
	}

	private void Update()
	{
		if (!showIndicator || _HMD == null)
		{
			return;
		}
		checkCount++;
		if (checkCount > 50)
		{
			checkCount = 0;
			if (rw != null && (rw.getSystemLanguage() != sysLang || rw.getSystemCountry() != sysCountry))
			{
				resetIndicator();
			}
		}
		if (needRedraw)
		{
			createIndicator();
		}
		Vector3 from = ((!basedOnEmitter || !(Emitter != null)) ? (base.transform.rotation * Vector3.forward) : (Emitter.transform.rotation * Vector3.forward));
		Vector3 from2 = base.transform.rotation * Vector3.right;
		_ = base.transform.rotation * Vector3.up;
		float num = Vector3.Angle(from, _HMD.transform.forward);
		float num2 = Vector3.Angle(from2, _HMD.transform.right);
		if (from.y < showIndicatorAngle / 90f || num < showIndicatorAngle)
		{
			foreach (ComponentsIndication item in compInd)
			{
				if (item.LineIndicator != null)
				{
					item.LineIndicator.SetActive(value: false);
				}
				if (item.DestObject != null)
				{
					item.DestObject.SetActive(value: false);
				}
			}
			return;
		}
		if (hideIndicatorByRoll && num2 > 90f)
		{
			foreach (ComponentsIndication item2 in compInd)
			{
				if (item2.LineIndicator != null)
				{
					item2.LineIndicator.SetActive(value: false);
				}
				if (item2.DestObject != null)
				{
					item2.DestObject.SetActive(value: false);
				}
			}
			return;
		}
		foreach (ComponentsIndication item3 in compInd)
		{
			if (item3.SourceObject != null)
			{
				item3.SourceObject.SetActive(value: true);
			}
			if (item3.LineIndicator != null)
			{
				item3.LineIndicator.SetActive(value: true);
			}
			if (!(item3.DestObject != null))
			{
				continue;
			}
			item3.DestObject.SetActive(value: true);
			if (item3.followButtonRoration)
			{
				continue;
			}
			item3.LineIndicator.transform.position = item3.SourceObject.transform.position + item3.Offset;
			if (item3.alignment == ButtonIndication.Alignment.RIGHT)
			{
				item3.DestObject.transform.position = new Vector3(base.transform.position.x + lineLength, item3.SourceObject.transform.position.y, item3.SourceObject.transform.position.z) + item3.Offset;
			}
			else
			{
				item3.DestObject.transform.position = new Vector3(base.transform.position.x - lineLength, item3.SourceObject.transform.position.y, item3.SourceObject.transform.position.z) + item3.Offset;
				TextMesh[] componentsInChildren = item3.DestObject.GetComponentsInChildren<TextMesh>();
				foreach (TextMesh textMesh in componentsInChildren)
				{
					if (textMesh != null)
					{
						textMesh.anchor = TextAnchor.MiddleRight;
						textMesh.alignment = TextAlignment.Right;
					}
				}
			}
			Transform[] componentsInChildren2 = item3.DestObject.GetComponentsInChildren<Transform>();
			foreach (Transform transform in componentsInChildren2)
			{
				if (transform != null)
				{
					transform.rotation = Quaternion.identity;
				}
			}
		}
	}
}
public interface IPointerHoverHandler : IEventSystemHandler
{
	void OnPointerHover(PointerEventData eventData);
}
public class WaveVR_AddEventSystemGUI : MonoBehaviour
{
	private bool added;

	private void OnEnable()
	{
		if ((Canvas)base.gameObject.GetComponent(typeof(Canvas)) != null)
		{
			WaveVR_EventSystemGUIProvider.AddEventGUI(base.gameObject);
			added = true;
		}
	}

	private void OnDisable()
	{
		if (added)
		{
			WaveVR_EventSystemGUIProvider.RemoveEventGUI(base.gameObject);
			added = false;
		}
	}
}
public class WaveVR_EventSystemControllerProvider
{
	public class ControllerModel
	{
		public WaveVR_Controller.EDeviceType DeviceType { get; set; }

		public GameObject Model { get; set; }

		public bool HasLoader { get; set; }

		public ControllerModel(WaveVR_Controller.EDeviceType type, GameObject model)
		{
			DeviceType = type;
			Model = model;
			HasLoader = false;
		}
	}

	private const string LOG_TAG = "WaveVR_EventSystemControllerProvider";

	private static WaveVR_EventSystemControllerProvider instance;

	private List<ControllerModel> ControllerModels = new List<ControllerModel>();

	public static WaveVR_EventSystemControllerProvider Instance
	{
		get
		{
			if (instance == null)
			{
				instance = new WaveVR_EventSystemControllerProvider();
			}
			return instance;
		}
	}

	private void PrintDebugLog(string msg)
	{
		if (WVR_Log.Log.EnableDebugLog)
		{
			WVR_Log.Log.d("WaveVR_EventSystemControllerProvider", msg);
		}
	}

	private WaveVR_EventSystemControllerProvider()
	{
	}

	public void SetControllerModel(WaveVR_Controller.EDeviceType type, GameObject model)
	{
		PrintDebugLog(string.Concat("SetControllerModel() type: ", type, ", Model: ", (model != null) ? model.name : "null"));
		bool flag = false;
		for (int i = 0; i < ControllerModels.Count; i++)
		{
			if (ControllerModels[i].DeviceType == type)
			{
				if (ControllerModels[i].Model != null)
				{
					ControllerModels[i].Model.SetActive(value: false);
				}
				ControllerModels[i].Model = model;
				ControllerModels[i].Model.SetActive(value: true);
				flag = true;
				break;
			}
		}
		if (!flag)
		{
			ControllerModels.Add(new ControllerModel(type, model));
		}
	}

	public GameObject GetControllerModel(WaveVR_Controller.EDeviceType type)
	{
		for (int i = 0; i < ControllerModels.Count; i++)
		{
			if (ControllerModels[i].DeviceType == type)
			{
				return ControllerModels[i].Model;
			}
		}
		return null;
	}

	public void MarkControllerLoader(WaveVR_Controller.EDeviceType type, bool value)
	{
		PrintDebugLog(string.Concat(type, " ", value ? "has" : "doesn't have", " ControllerLoader."));
		for (int i = 0; i < ControllerModels.Count; i++)
		{
			if (ControllerModels[i].DeviceType == type)
			{
				ControllerModels[i].HasLoader = value;
				break;
			}
		}
	}

	public bool HasControllerLoader(WaveVR_Controller.EDeviceType type)
	{
		for (int i = 0; i < ControllerModels.Count; i++)
		{
			if (ControllerModels[i].DeviceType == type)
			{
				return ControllerModels[i].HasLoader;
			}
		}
		return false;
	}
}
internal static class WaveVR_EventSystemGUIProvider
{
	private static List<GameObject> EventGUIs = new List<GameObject>();

	public static void AddEventGUI(GameObject go)
	{
		EventGUIs.Add(go);
	}

	public static void RemoveEventGUI(GameObject go)
	{
		EventGUIs.Remove(go);
	}

	public static GameObject[] GetEventGUIs()
	{
		if (EventGUIs.Count == 0)
		{
			return null;
		}
		return EventGUIs.ToArray();
	}
}
public static class WaveVR_ExecuteEvents
{
	public static ExecuteEvents.EventFunction<IPointerHoverHandler> pointerHoverHandler => HoverExecutor;

	private static void HoverExecutor(IPointerHoverHandler handler, BaseEventData eventData)
	{
		handler.OnPointerHover(ExecuteEvents.ValidateEventData<PointerEventData>(eventData));
	}
}
public class WaveVR_GazeInputModule : PointerInputModule
{
	public enum EGazeTriggerMouseKey
	{
		LeftClick,
		RightClick,
		MiddleClick
	}

	public enum EGazeInputEvent
	{
		PointerDown,
		PointerClick,
		PointerSubmit
	}

	private static string LOG_TAG = "WaveVR_GazeInputModule";

	public bool UseWaveVRReticle;

	private bool useWaveVRReticle;

	public bool TimerControl = true;

	private bool timerControlDefault;

	public float TimeToGaze = 2f;

	public bool ProgressRate;

	public float RateTextZPosition = 0.5f;

	public bool ProgressCounter;

	public float CounterTextZPosition = 0.5f;

	public EGazeInputEvent InputEvent = EGazeInputEvent.PointerSubmit;

	public bool ButtonControl;

	public List<WaveVR_Controller.EDeviceType> ButtonControlDevices = new List<WaveVR_Controller.EDeviceType>();

	public List<WaveVR_ButtonList.EButtons> ButtonControlKeys = new List<WaveVR_ButtonList.EButtons>();

	public GameObject Head;

	private bool btnPressDown;

	private bool btnPressed;

	private bool btnPressUp;

	private bool HmdEnterPressDown;

	private float currUnscaledTime;

	private Vector3 gazeTargetPos = Vector3.zero;

	private Vector3 gazeScreenPos = Vector3.zero;

	private Vector3 gazeScreenPos2D = Vector2.zero;

	private PointerEventData pointerData;

	private List<RaycastResult> physicsRaycastResultsGaze = new List<RaycastResult>();

	private List<GameObject> physicsRaycastObjectsGaze = new List<GameObject>();

	private List<GameObject> prePhysicsRaycastObjectsGaze = new List<GameObject>();

	private List<GameObject> physicsRaycastObjectsTmp = new List<GameObject>();

	private List<GameObject> prePhysicsRaycastObjectsTmp = new List<GameObject>();

	private List<RaycastResult> graphicRaycastResultsGaze = new List<RaycastResult>();

	private List<GameObject> graphicRaycastObjectsGaze = new List<GameObject>();

	private List<GameObject> preGraphicRaycastObjectsGaze = new List<GameObject>();

	private List<GameObject> graphicRaycastObjectsTmp = new List<GameObject>();

	private List<GameObject> preGraphicRaycastObjectsTmp = new List<GameObject>();

	private float gazeTime;

	private Text progressText;

	private Text counterText;

	private WaveVR_Reticle gazePointer;

	private GameObject percentCanvas;

	private GameObject counterCanvas;

	private Vector3 ringPos = Vector3.zero;

	private GameObject preGazeObject;

	private bool mEnabled;

	private bool mEnableGaze;

	private RingMeshDrawer ringMesh;

	private bool focusCapturedBySystem;

	private void DEBUG(string msg)
	{
		if (WVR_Log.Log.EnableDebugLog)
		{
			WVR_Log.Log.d(LOG_TAG, msg, logInEditor: true);
		}
	}

	public void EnableTimerControl(bool enable)
	{
		if (WVR_Log.Log.gpl.Print)
		{
			DEBUG("EnableTimerControl() enable: " + enable);
		}
		TimerControl = enable;
		timerControlDefault = TimerControl;
	}

	private Vector3 GetIntersectionPosition(Camera cam, RaycastResult raycastResult)
	{
		if (cam == null)
		{
			return Vector3.zero;
		}
		float num = raycastResult.distance + cam.nearClipPlane;
		return cam.transform.position + cam.transform.forward * num;
	}

	private void ResetPointerEventData()
	{
		if (pointerData == null)
		{
			pointerData = new PointerEventData(base.eventSystem);
		}
		pointerData.position = gazeScreenPos2D;
	}

	private void CastToCenterOfScreen()
	{
		Camera component = Head.GetComponent<Camera>();
		gazeScreenPos2D.x = 0.5f * (float)Screen.width;
		gazeScreenPos2D.y = 0.5f * (float)Screen.height;
		gazeTargetPos = Vector3.zero;
		if (ringMesh != null)
		{
			ringMesh.RingPosition = gazeTargetPos;
		}
		ResetPointerEventData();
		GraphicRaycast(component);
		PhysicsRaycaster physicsRaycaster = null;
		physicsRaycaster = Head.GetComponent<PhysicsRaycaster>();
		if (physicsRaycaster != null)
		{
			ResetPointerEventData();
			PhysicsRaycast(physicsRaycaster);
		}
	}

	private void EnterExitPhysicsObject()
	{
		physicsRaycastObjectsTmp = physicsRaycastObjectsGaze;
		prePhysicsRaycastObjectsTmp = prePhysicsRaycastObjectsGaze;
		if (physicsRaycastObjectsTmp.Count == 0 && prePhysicsRaycastObjectsTmp.Count == 0)
		{
			return;
		}
		for (int i = 0; i < physicsRaycastObjectsTmp.Count; i++)
		{
			if (!prePhysicsRaycastObjectsTmp.Contains(physicsRaycastObjectsTmp[i]))
			{
				ExecuteEvents.Execute(physicsRaycastObjectsTmp[i], pointerData, ExecuteEvents.pointerEnterHandler);
				DEBUG("EnterExitPhysicsObject() enter: " + physicsRaycastObjectsTmp[i]);
			}
		}
		for (int j = 0; j < prePhysicsRaycastObjectsTmp.Count; j++)
		{
			if (!physicsRaycastObjectsTmp.Contains(prePhysicsRaycastObjectsTmp[j]))
			{
				ExecuteEvents.Execute(prePhysicsRaycastObjectsTmp[j], pointerData, ExecuteEvents.pointerExitHandler);
				DEBUG("EnterExitPhysicsObject() exit: " + prePhysicsRaycastObjectsTmp[j]);
			}
		}
		prePhysicsRaycastObjectsTmp.Clear();
		for (int k = 0; k < physicsRaycastObjectsTmp.Count; k++)
		{
			prePhysicsRaycastObjectsTmp.Add(physicsRaycastObjectsTmp[k]);
		}
		physicsRaycastObjectsGaze = physicsRaycastObjectsTmp;
		prePhysicsRaycastObjectsGaze = prePhysicsRaycastObjectsTmp;
	}

	private void EnterExitGraphicObject()
	{
		graphicRaycastObjectsTmp = graphicRaycastObjectsGaze;
		preGraphicRaycastObjectsTmp = preGraphicRaycastObjectsGaze;
		if (graphicRaycastObjectsTmp.Count == 0 && preGraphicRaycastObjectsTmp.Count == 0)
		{
			return;
		}
		for (int i = 0; i < graphicRaycastObjectsTmp.Count; i++)
		{
			if (!preGraphicRaycastObjectsTmp.Contains(graphicRaycastObjectsTmp[i]))
			{
				ExecuteEvents.Execute(graphicRaycastObjectsTmp[i], pointerData, ExecuteEvents.pointerEnterHandler);
				DEBUG("EnterExitGraphicObject() enter: " + graphicRaycastObjectsTmp[i]);
			}
		}
		for (int j = 0; j < preGraphicRaycastObjectsTmp.Count; j++)
		{
			if (!graphicRaycastObjectsTmp.Contains(preGraphicRaycastObjectsTmp[j]))
			{
				ExecuteEvents.Execute(preGraphicRaycastObjectsTmp[j], pointerData, ExecuteEvents.pointerExitHandler);
				DEBUG("EnterExitGraphicObject() exit: " + preGraphicRaycastObjectsTmp[j]);
			}
		}
		preGraphicRaycastObjectsTmp.Clear();
		for (int k = 0; k < graphicRaycastObjectsTmp.Count; k++)
		{
			preGraphicRaycastObjectsTmp.Add(graphicRaycastObjectsTmp[k]);
		}
		graphicRaycastObjectsGaze = graphicRaycastObjectsTmp;
		preGraphicRaycastObjectsGaze = preGraphicRaycastObjectsTmp;
	}

	private void ExitAllObjects()
	{
		prePhysicsRaycastObjectsTmp = prePhysicsRaycastObjectsGaze;
		preGraphicRaycastObjectsTmp = preGraphicRaycastObjectsGaze;
		if (prePhysicsRaycastObjectsTmp.Count != 0 || preGraphicRaycastObjectsTmp.Count != 0)
		{
			for (int i = 0; i < prePhysicsRaycastObjectsTmp.Count; i++)
			{
				ExecuteEvents.Execute(prePhysicsRaycastObjectsTmp[i], pointerData, ExecuteEvents.pointerExitHandler);
				DEBUG("ExitAllObjects() exit: " + prePhysicsRaycastObjectsTmp[i]);
			}
			prePhysicsRaycastObjectsTmp.Clear();
			for (int j = 0; j < preGraphicRaycastObjectsTmp.Count; j++)
			{
				ExecuteEvents.Execute(preGraphicRaycastObjectsTmp[j], pointerData, ExecuteEvents.pointerExitHandler);
				DEBUG("ExitAllObjects() exit: " + preGraphicRaycastObjectsTmp[j]);
			}
			preGraphicRaycastObjectsTmp.Clear();
			prePhysicsRaycastObjectsGaze = prePhysicsRaycastObjectsTmp;
			preGraphicRaycastObjectsGaze = preGraphicRaycastObjectsTmp;
		}
	}

	private void PhysicsRaycast(PhysicsRaycaster raycaster)
	{
		RaycastResult raycastResult = default(RaycastResult);
		physicsRaycastObjectsGaze.Clear();
		physicsRaycastResultsGaze.Clear();
		raycaster.Raycast(pointerData, physicsRaycastResultsGaze);
		for (int i = 0; i < physicsRaycastResultsGaze.Count; i++)
		{
			physicsRaycastObjectsGaze.Add(physicsRaycastResultsGaze[i].gameObject);
		}
		raycastResult = BaseInputModule.FindFirstRaycast(physicsRaycastResultsGaze);
		_ = raycastResult.module != null;
		if (raycastResult.gameObject != null)
		{
			if (raycastResult.worldPosition == Vector3.zero)
			{
				raycastResult.worldPosition = GetIntersectionPosition(raycastResult.module.eventCamera, raycastResult);
			}
			float num = Mathf.Abs(raycastResult.worldPosition.z - raycastResult.module.eventCamera.transform.position.z);
			float num2 = Mathf.Abs(pointerData.pointerCurrentRaycast.worldPosition.z - raycastResult.module.eventCamera.transform.position.z);
			if (pointerData.pointerCurrentRaycast.gameObject == null || num2 > num)
			{
				pointerData.pointerCurrentRaycast = raycastResult;
				pointerData.position = raycastResult.screenPosition;
			}
		}
	}

	private void GraphicRaycast(Camera event_camera)
	{
		pointerData.pointerCurrentRaycast = default(RaycastResult);
		GraphicRaycaster[] array = UnityEngine.Object.FindObjectsOfType<GraphicRaycaster>();
		graphicRaycastObjectsGaze.Clear();
		for (int i = 0; i < array.Length; i++)
		{
			if (!(array[i].gameObject != null) || !(array[i].gameObject.GetComponent<Canvas>() != null))
			{
				continue;
			}
			array[i].gameObject.GetComponent<Canvas>().worldCamera = event_camera;
			array[i].Raycast(pointerData, graphicRaycastResultsGaze);
			if (graphicRaycastResultsGaze.Count == 0)
			{
				continue;
			}
			for (int j = 0; j < graphicRaycastResultsGaze.Count; j++)
			{
				graphicRaycastObjectsGaze.Add(graphicRaycastResultsGaze[j].gameObject);
			}
			RaycastResult raycastResult = BaseInputModule.FindFirstRaycast(graphicRaycastResultsGaze);
			graphicRaycastResultsGaze.Clear();
			_ = raycastResult.module != null;
			if (!(raycastResult.gameObject != null))
			{
				continue;
			}
			if (raycastResult.worldPosition == Vector3.zero)
			{
				raycastResult.worldPosition = GetIntersectionPosition(raycastResult.module.eventCamera, raycastResult);
			}
			float num = Mathf.Abs(raycastResult.worldPosition.z - raycastResult.module.eventCamera.transform.position.z);
			float num2 = Mathf.Abs(pointerData.pointerCurrentRaycast.worldPosition.z - raycastResult.module.eventCamera.transform.position.z);
			bool flag = false;
			if (pointerData.pointerCurrentRaycast.gameObject == null)
			{
				flag = true;
			}
			else if (num2 > num)
			{
				DEBUG(string.Concat("GraphicRaycast() ", pointerData.pointerCurrentRaycast.gameObject.name, ", position: ", pointerData.pointerCurrentRaycast.worldPosition, ", distance: ", num2, " is farer than ", raycastResult.gameObject.name, ", position: ", raycastResult.worldPosition, ", new distance: ", num));
				flag = true;
			}
			else if (num2 == num)
			{
				int sortingOrder = pointerData.pointerCurrentRaycast.sortingOrder;
				int sortingOrder2 = raycastResult.sortingOrder;
				if (sortingOrder < sortingOrder2)
				{
					DEBUG("GraphicRaycast() " + pointerData.pointerCurrentRaycast.gameObject.name + " sorting order: " + sortingOrder + " is smaller than " + raycastResult.gameObject.name + " sorting order: " + sortingOrder2);
					flag = true;
				}
			}
			if (flag)
			{
				pointerData.pointerCurrentRaycast = raycastResult;
				pointerData.position = raycastResult.screenPosition;
			}
		}
	}

	private GameObject GetCurrentGameObject(PointerEventData pointerData)
	{
		if (pointerData != null && pointerData.enterEventCamera != null)
		{
			return pointerData.pointerCurrentRaycast.gameObject;
		}
		return null;
	}

	private Vector3 GetIntersectionPosition(PointerEventData pointerData)
	{
		if (null == pointerData.enterEventCamera)
		{
			return Vector3.zero;
		}
		float num = pointerData.pointerCurrentRaycast.distance + pointerData.enterEventCamera.nearClipPlane;
		return pointerData.enterEventCamera.transform.position + pointerData.enterEventCamera.transform.forward * num;
	}

	private void UpdateProgressDistance(PointerEventData pointerEvent)
	{
		Vector3 intersectionPosition = GetIntersectionPosition(pointerEvent);
		if (!(gazePointer == null))
		{
			if (percentCanvas != null)
			{
				Vector3 localPosition = new Vector3(percentCanvas.transform.localPosition.x, percentCanvas.transform.localPosition.y, intersectionPosition.z - ((RateTextZPosition >= 0f) ? RateTextZPosition : 0f));
				percentCanvas.transform.localPosition = localPosition;
			}
			if (counterCanvas != null)
			{
				Vector3 localPosition2 = new Vector3(counterCanvas.transform.localPosition.x, counterCanvas.transform.localPosition.y, intersectionPosition.z - ((CounterTextZPosition >= 0f) ? CounterTextZPosition : 0f));
				counterCanvas.transform.localPosition = localPosition2;
			}
		}
	}

	private void UpdateReticle(GameObject preGazedObject, PointerEventData pointerEvent)
	{
		if (gazePointer == null)
		{
			return;
		}
		GameObject currentGameObject = GetCurrentGameObject(pointerEvent);
		Vector3 intersectionPosition = GetIntersectionPosition(pointerEvent);
		WaveVR_RaycastResultProvider.Instance.SetRaycastResult(WaveVR_Controller.EDeviceType.Head, currentGameObject, intersectionPosition);
		bool isInteractive = pointerEvent.pointerPress != null || ExecuteEvents.GetEventHandler<IPointerClickHandler>(currentGameObject) != null;
		if (currentGameObject == preGazedObject)
		{
			if (!(currentGameObject != null))
			{
				gazePointer.OnGazeExit(pointerEvent.enterEventCamera, preGazedObject);
				return;
			}
			gazePointer.OnGazeStay(pointerEvent.enterEventCamera, currentGameObject, intersectionPosition, isInteractive);
		}
		else
		{
			if (preGazedObject != null)
			{
				gazePointer.OnGazeExit(pointerEvent.enterEventCamera, preGazedObject);
			}
			if (currentGameObject != null)
			{
				gazePointer.OnGazeEnter(pointerEvent.enterEventCamera, currentGameObject, intersectionPosition, isInteractive);
			}
		}
		UpdateProgressDistance(pointerEvent);
	}

	private void UpdateButtonStates()
	{
		btnPressDown = false;
		btnPressed = false;
		btnPressUp = false;
		for (int i = 0; i < ButtonControlDevices.Count; i++)
		{
			for (int j = 0; j < ButtonControlKeys.Count; j++)
			{
				btnPressDown |= WaveVR_Controller.Input(ButtonControlDevices[i]).GetPressDown(ButtonControlKeys[j]);
				btnPressed |= WaveVR_Controller.Input(ButtonControlDevices[i]).GetPress(ButtonControlKeys[j]);
				btnPressUp |= WaveVR_Controller.Input(ButtonControlDevices[i]).GetPressUp(ButtonControlKeys[j]);
			}
		}
	}

	private void UpdateProgressText()
	{
		if (!ProgressRate)
		{
			if (progressText != null)
			{
				progressText.text = "";
			}
			return;
		}
		if (progressText == null)
		{
			Text[] componentsInChildren = Head.transform.GetComponentsInChildren<Text>();
			for (int i = 0; i < componentsInChildren.Length; i++)
			{
				if (componentsInChildren[i].gameObject.name.Equals("ProgressText"))
				{
					DEBUG("UpdateProgressText() Found ProgressText.");
					progressText = componentsInChildren[i];
					break;
				}
			}
		}
		if (!(progressText == null))
		{
			if (pointerData.pointerCurrentRaycast.gameObject == null)
			{
				progressText.text = "";
				return;
			}
			float f = (currUnscaledTime - gazeTime) % TimeToGaze / TimeToGaze * 100f;
			progressText.text = Mathf.Floor(f) + "%";
		}
	}

	private void UpdateCounterText()
	{
		if (!ProgressCounter)
		{
			if (counterText != null)
			{
				counterText.text = "";
			}
			return;
		}
		if (counterText == null)
		{
			Text[] componentsInChildren = Head.transform.GetComponentsInChildren<Text>();
			for (int i = 0; i < componentsInChildren.Length; i++)
			{
				if (componentsInChildren[i].gameObject.name.Equals("CounterText"))
				{
					DEBUG("UpdateCounterText() Found CounterText.");
					counterText = componentsInChildren[i];
					break;
				}
			}
		}
		if (!(counterText == null))
		{
			if (pointerData.pointerCurrentRaycast.gameObject == null)
			{
				counterText.text = "";
			}
			else if (counterText != null)
			{
				counterText.text = Math.Round(TimeToGaze - (currUnscaledTime - gazeTime) % TimeToGaze, 2).ToString();
			}
		}
	}

	private void OnTriggeGaze()
	{
		UpdateReticle(preGazeObject, pointerData);
		GameObject gameObject = pointerData.pointerCurrentRaycast.gameObject;
		bool flag = pointerData.pointerPress != null || ExecuteEvents.GetEventHandler<IPointerClickHandler>(gameObject) != null;
		bool flag2 = false;
		HmdEnterPressDown = WaveVR_Controller.Input(WaveVR_Controller.EDeviceType.Head).GetPressDown(WVR_InputId.WVR_InputId_15);
		if (HmdEnterPressDown)
		{
			flag2 = true;
		}
		EnterExitGraphicObject();
		EnterExitPhysicsObject();
		if (preGazeObject != gameObject)
		{
			DEBUG("preGazeObject: " + ((preGazeObject != null) ? preGazeObject.name : "null") + ", curGazeObject: " + ((gameObject != null) ? gameObject.name : "null"));
			if (gameObject != null)
			{
				gazeTime = currUnscaledTime;
			}
		}
		else if (gameObject != null)
		{
			if (useWaveVRReticle && gazePointer != null)
			{
				gazePointer.triggerProgressBar(switchOn: true);
			}
			if (TimerControl)
			{
				if (currUnscaledTime - gazeTime > TimeToGaze)
				{
					flag2 = true;
					gazeTime = currUnscaledTime;
				}
				float num = (currUnscaledTime - gazeTime) / TimeToGaze * 100f;
				if (useWaveVRReticle && gazePointer != null)
				{
					gazePointer.setProgressBarTime(num);
				}
				else if (ringMesh != null)
				{
					ringMesh.RingPercent = (flag ? ((int)num) : 0);
				}
			}
			if (ButtonControl)
			{
				if (!TimerControl)
				{
					if (useWaveVRReticle && gazePointer != null)
					{
						gazePointer.triggerProgressBar(switchOn: false);
					}
					else if (ringMesh != null)
					{
						ringMesh.RingPercent = 0;
					}
				}
				UpdateButtonStates();
				if (btnPressDown)
				{
					flag2 = true;
					gazeTime = currUnscaledTime;
				}
			}
		}
		else if (useWaveVRReticle && gazePointer != null)
		{
			gazePointer.triggerProgressBar(switchOn: false);
		}
		else if (ringMesh != null)
		{
			ringMesh.RingPercent = 0;
		}
		pointerData.delta = Vector2.zero;
		pointerData.dragging = false;
		DeselectIfSelectionChanged(gameObject, pointerData);
		if (flag2)
		{
			DEBUG("OnTriggeGaze() selected " + gameObject.name);
			if (InputEvent == EGazeInputEvent.PointerClick)
			{
				ExecuteEvents.ExecuteHierarchy(gameObject, pointerData, ExecuteEvents.pointerClickHandler);
				pointerData.clickTime = currUnscaledTime;
			}
			else if (InputEvent == EGazeInputEvent.PointerDown)
			{
				pointerData.pressPosition = pointerData.position;
				pointerData.pointerPressRaycast = pointerData.pointerCurrentRaycast;
				ExecuteEvents.ExecuteHierarchy(ExecuteEvents.ExecuteHierarchy(gameObject, pointerData, ExecuteEvents.pointerDownHandler), pointerData, ExecuteEvents.pointerUpHandler);
			}
			else if (InputEvent == EGazeInputEvent.PointerSubmit)
			{
				ExecuteEvents.ExecuteHierarchy(gameObject, pointerData, ExecuteEvents.submitHandler);
			}
		}
	}

	private void GazeControl()
	{
		bool connected = WaveVR_Controller.Input(WaveVR_Controller.EDeviceType.Dominant).connected;
		bool connected2 = WaveVR_Controller.Input(WaveVR_Controller.EDeviceType.NonDominant).connected;
		TimerControl = timerControlDefault;
		if (WaveVR_ButtonList.Instance == null || !ButtonControl)
		{
			TimerControl = true;
		}
		else if (!connected && !connected2 && !WaveVR_ButtonList.Instance.IsButtonAvailable(WaveVR_Controller.EDeviceType.Head, WVR_InputId.WVR_InputId_15))
		{
			TimerControl = true;
		}
		preGazeObject = GetCurrentGameObject(pointerData);
		CastToCenterOfScreen();
		currUnscaledTime = Time.unscaledTime;
		OnTriggeGaze();
		UpdateProgressText();
		UpdateCounterText();
	}

	protected override void OnEnable()
	{
		if (mEnabled)
		{
			return;
		}
		base.OnEnable();
		mEnableGaze = true;
		if (Head == null)
		{
			if (WaveVR_InputModuleManager.Instance != null)
			{
				Head = WaveVR_InputModuleManager.Instance.gameObject;
			}
			else
			{
				Head = WaveVR_Render.Instance.gameObject;
			}
		}
		if (gazePointer == null && Head != null)
		{
			gazePointer = Head.GetComponentInChildren<WaveVR_Reticle>();
		}
		if (gazePointer != null)
		{
			DEBUG("OnEnable() Head: " + Head.name + ", enable pointer, percent and counter canvas.");
			percentCanvas = gazePointer.transform.Find("PercentCanvas").gameObject;
			counterCanvas = gazePointer.transform.Find("CounterCanvas").gameObject;
		}
		timerControlDefault = TimerControl;
		if (ringMesh == null && Head != null)
		{
			ringMesh = Head.GetComponentInChildren<RingMeshDrawer>();
			DEBUG("OnEnable() found ringMesh " + ((ringMesh != null) ? ringMesh.gameObject.name : "null"));
		}
		mEnabled = true;
	}

	protected override void OnDisable()
	{
		if (mEnabled)
		{
			DEBUG("OnDisable()");
			base.OnDisable();
			mEnableGaze = false;
			ActivateGazePointerCanvas(active: false);
			ActivateMeshDrawer(active: false);
			ringMesh = null;
			ExitAllObjects();
			mEnabled = false;
		}
	}

	public override void Process()
	{
		useWaveVRReticle = UseWaveVRReticle;
		if (Head == null || !WaveVR.Instance.Initialized)
		{
			if (WVR_Log.Log.gpl.Print)
			{
				DEBUG("Process() Ooooooooooooops! Check the Head settings or WaveVR initialization!!");
			}
			return;
		}
		if (focusCapturedBySystem != WaveVR.Instance.FocusCapturedBySystem)
		{
			focusCapturedBySystem = WaveVR.Instance.FocusCapturedBySystem;
			if (focusCapturedBySystem)
			{
				DEBUG("Process() focus is captured by system, exit all objects.");
				ExitAllObjects();
			}
			else
			{
				DEBUG("Process() get focus, reset the timer.");
				gazeTime = Time.unscaledTime;
			}
		}
		if (!focusCapturedBySystem)
		{
			if (mEnableGaze)
			{
				ActivatePointerAndRing(active: true);
				GazeControl();
			}
			else
			{
				ActivatePointerAndRing(active: false);
				ActivateMeshDrawer(active: false);
			}
		}
	}

	public void ActivatePointerAndRing(bool active)
	{
		if (active)
		{
			ActivateGazePointerCanvas(useWaveVRReticle);
			ActivateMeshDrawer(!useWaveVRReticle);
		}
		else
		{
			ActivateGazePointerCanvas(active: false);
			ActivateMeshDrawer(active: false);
		}
	}

	private void ActivateGazePointerCanvas(bool active)
	{
		if (gazePointer != null)
		{
			MeshRenderer componentInChildren = gazePointer.gameObject.GetComponentInChildren<MeshRenderer>();
			if (componentInChildren != null)
			{
				if (componentInChildren.enabled != active)
				{
					DEBUG(active ? "ActivateGazePointerCanvas() enable pointer." : "ActivateGazePointerCanvas() disable pointer.");
					componentInChildren.enabled = active;
				}
			}
			else if (WVR_Log.Log.gpl.Print)
			{
				WVR_Log.Log.e(LOG_TAG, "ActivateGazePointerCanvas() Oooooooooooops! No MeshRenderer of " + gazePointer.gameObject.name);
			}
		}
		if (percentCanvas != null && percentCanvas.activeSelf != active)
		{
			DEBUG(active ? "ActivateGazePointerCanvas() enable percentCanvas." : "ActivateGazePointerCanvas() disable percentCanvas.");
			percentCanvas.SetActive(active);
		}
		if (counterCanvas != null && counterCanvas.activeSelf != active)
		{
			DEBUG(active ? "ActivateGazePointerCanvas() enable counterCanvas." : "ActivateGazePointerCanvas() disable counterCanvas.");
			counterCanvas.SetActive(active);
		}
	}

	private void ActivateMeshDrawer(bool active)
	{
		if (!(ringMesh != null))
		{
			return;
		}
		MeshRenderer componentInChildren = ringMesh.gameObject.GetComponentInChildren<MeshRenderer>();
		if (componentInChildren != null)
		{
			if (componentInChildren.enabled != active)
			{
				DEBUG(active ? "ActivateMeshDrawer() enable ring mesh." : "ActivateMeshDrawer() disable ring mesh.");
				componentInChildren.enabled = active;
			}
		}
		else if (WVR_Log.Log.gpl.Print)
		{
			WVR_Log.Log.e(LOG_TAG, "ActivateMeshDrawer() Oooooooooooops! No MeshRenderer of " + ringMesh.gameObject.name);
		}
	}
}
public enum WaveVR_EInputModule
{
	Controller,
	Gaze
}
public class WaveVR_InputModuleManager : MonoBehaviour
{
	[Serializable]
	public class CGazeInputModule
	{
		public bool UseWaveVRReticle;

		public bool TimerControl = true;

		public float TimeToGaze = 2f;

		public bool ProgressRate;

		public float RateTextZPosition = 0.5f;

		public bool ProgressCounter;

		public float CounterTextZPosition = 0.5f;

		public WaveVR_GazeInputModule.EGazeInputEvent InputEvent = WaveVR_GazeInputModule.EGazeInputEvent.PointerSubmit;

		public bool ButtonControl;

		public List<WaveVR_Controller.EDeviceType> ButtonControlDevices = new List<WaveVR_Controller.EDeviceType>();

		public List<WaveVR_ButtonList.EButtons> ButtonControlKeys = new List<WaveVR_ButtonList.EButtons>();

		public GameObject Head;
	}

	[Serializable]
	public class CControllerInputModule
	{
		public bool DominantEventEnabled = true;

		public GameObject DominantController;

		public LayerMask DominantRaycastMask = -1;

		public bool NonDominantEventEnabled = true;

		public GameObject NonDominantController;

		public LayerMask NonDominantRaycastMask = -1;

		public List<WaveVR_ButtonList.EButtons> ButtonToTrigger = new List<WaveVR_ButtonList.EButtons>();

		public WaveVR_ControllerInputModule.ERaycastMode RaycastMode = WaveVR_ControllerInputModule.ERaycastMode.Mouse;

		public ERaycastStartPoint RaycastStartPoint;

		[Tooltip("Will be obsoleted soon!")]
		public string CanvasTag = "EventCanvas";
	}

	private const string LOG_TAG = "WaveVR_InputModuleManager";

	public bool EnableInputModule = true;

	public bool OverrideSystemSettings;

	public bool AutoGaze;

	public bool AlwaysShowController;

	public WaveVR_EInputModule CustomInputModule;

	public CGazeInputModule Gaze = new CGazeInputModule();

	public CControllerInputModule Controller = new CControllerInputModule();

	public float FixedBeamLength = 9.5f;

	private static WaveVR_InputModuleManager instance;

	private bool preOverrideSystemSettings;

	private WaveVR_EInputModule InteractionMode_User;

	private WVR_InteractionMode InteractionMode_System = WVR_InteractionMode.WVR_InteractionMode_Controller;

	private WVR_InteractionMode InteractionMode_Current = WVR_InteractionMode.WVR_InteractionMode_Controller;

	private WVR_GazeTriggerType gazeTriggerType_User = WVR_GazeTriggerType.WVR_GazeTriggerType_Timeout;

	private WVR_GazeTriggerType gazeTriggerType_System = WVR_GazeTriggerType.WVR_GazeTriggerType_Timeout;

	private WVR_GazeTriggerType gazeTriggerType_User_pre = WVR_GazeTriggerType.WVR_GazeTriggerType_Timeout;

	private GameObject Head;

	private GameObject eventSystem;

	private WaveVR_GazeInputModule gazeInputModule;

	private WaveVR_ControllerInputModule controllerInputModule;

	private MeshRenderer gazePointerRenderer;

	private MeshRenderer gazeRingRenderer;

	public static WaveVR_InputModuleManager Instance => instance;

	private void DEBUG(string msg)
	{
		if (WVR_Log.Log.EnableDebugLog)
		{
			WVR_Log.Log.d("WaveVR_InputModuleManager", msg, logInEditor: true);
		}
	}

	private void initInteractionModeAndGazeTriggerType()
	{
		preOverrideSystemSettings = OverrideSystemSettings;
		InteractionMode_User = CustomInputModule;
		updateGazeTriggerType_User();
		if (OverrideSystemSettings)
		{
			InteractionMode_System = WaveVR.Instance.InteractionMode;
			gazeTriggerType_System = WaveVR.Instance.GazeTriggerType;
			Interop.WVR_SetInteractionMode((InteractionMode_User == WaveVR_EInputModule.Controller) ? WVR_InteractionMode.WVR_InteractionMode_Controller : WVR_InteractionMode.WVR_InteractionMode_Gaze);
			Interop.WVR_SetGazeTriggerType(gazeTriggerType_User);
			gazeTriggerType_User_pre = gazeTriggerType_User;
			initializeInputModuleByCustomSettings();
		}
		else
		{
			Interop.WVR_SetInteractionMode(WVR_InteractionMode.WVR_InteractionMode_SystemDefault);
			InteractionMode_System = WaveVR.Instance.InteractionMode;
			gazeTriggerType_System = WaveVR.Instance.GazeTriggerType;
			initializeInputModuleBySystemSetting();
		}
		InteractionMode_Current = GetInteractionMode();
		DEBUG("initInteractionModeAndGazeTriggerType() OverrideSystemSettings: " + OverrideSystemSettings);
		DEBUG(string.Concat("initInteractionModeAndGazeTriggerType() Interaction Mode - System: ", InteractionMode_System, ", User: ", InteractionMode_User, ", Current: ", InteractionMode_Current));
		DEBUG(string.Concat("initInteractionModeAndGazeTriggerType() Gaze Trigger - System: ", gazeTriggerType_System, ", User: ", gazeTriggerType_User));
	}

	private void updateInteractionModeAndGazeTriggerType()
	{
		if (WVR_Log.Log.gpl.Print)
		{
			DEBUG(OverrideSystemSettings ? "updateInteractionModeAndGazeTriggerType() OverrideSystemSettings is true." : "updateInteractionModeAndGazeTriggerType() OverrideSystemSettings is false.");
			DEBUG((InteractionMode_System == WVR_InteractionMode.WVR_InteractionMode_Gaze) ? "updateInteractionModeAndGazeTriggerType() InteractionMode_System is gaze." : "updateInteractionModeAndGazeTriggerType() InteractionMode_System is controller.");
			DEBUG((InteractionMode_User == WaveVR_EInputModule.Controller) ? "updateInteractionModeAndGazeTriggerType() InteractionMode_User is controller." : "updateInteractionModeAndGazeTriggerType() InteractionMode_User is gaze.");
			if (gazeTriggerType_System == WVR_GazeTriggerType.WVR_GazeTriggerType_Timeout)
			{
				DEBUG("updateInteractionModeAndGazeTriggerType() gazeTriggerType_System is timeout.");
			}
			if (gazeTriggerType_System == WVR_GazeTriggerType.WVR_GazeTriggerType_Button)
			{
				DEBUG("updateInteractionModeAndGazeTriggerType() gazeTriggerType_System is button.");
			}
			if (gazeTriggerType_System == WVR_GazeTriggerType.WVR_GazeTriggerType_TimeoutButton)
			{
				DEBUG("updateInteractionModeAndGazeTriggerType() gazeTriggerType_System is timeout & button.");
			}
			if (gazeTriggerType_User == WVR_GazeTriggerType.WVR_GazeTriggerType_Timeout)
			{
				DEBUG("updateInteractionModeAndGazeTriggerType() gazeTriggerType_User is timeout.");
			}
			if (gazeTriggerType_User == WVR_GazeTriggerType.WVR_GazeTriggerType_Button)
			{
				DEBUG("updateInteractionModeAndGazeTriggerType() gazeTriggerType_User is button.");
			}
			if (gazeTriggerType_User == WVR_GazeTriggerType.WVR_GazeTriggerType_TimeoutButton)
			{
				DEBUG("updateInteractionModeAndGazeTriggerType() gazeTriggerType_User is timeout & button.");
			}
		}
		if (OverrideSystemSettings)
		{
			if (InteractionMode_User != CustomInputModule || preOverrideSystemSettings != OverrideSystemSettings)
			{
				if (InteractionMode_User != CustomInputModule)
				{
					InteractionMode_User = CustomInputModule;
					DEBUG((InteractionMode_User == WaveVR_EInputModule.Controller) ? "updateInteractionModeAndGazeTriggerType() InteractionMode_User is controller." : "updateInteractionModeAndGazeTriggerType() InteractionMode_User is gaze.");
				}
				if (preOverrideSystemSettings != OverrideSystemSettings)
				{
					preOverrideSystemSettings = OverrideSystemSettings;
					DEBUG(OverrideSystemSettings ? "updateInteractionModeAndGazeTriggerType() OverrideSystemSettings is true." : "updateInteractionModeAndGazeTriggerType() OverrideSystemSettings is false.");
				}
				Interop.WVR_SetInteractionMode((InteractionMode_User == WaveVR_EInputModule.Controller) ? WVR_InteractionMode.WVR_InteractionMode_Controller : WVR_InteractionMode.WVR_InteractionMode_Gaze);
			}
			updateGazeTriggerType_User();
			if (gazeTriggerType_User_pre != gazeTriggerType_User)
			{
				gazeTriggerType_User_pre = gazeTriggerType_User;
				Interop.WVR_SetGazeTriggerType(gazeTriggerType_User);
				if (gazeTriggerType_User == WVR_GazeTriggerType.WVR_GazeTriggerType_Timeout)
				{
					DEBUG("updateInteractionModeAndGazeTriggerType() gazeTriggerType_User is timeout.");
				}
				if (gazeTriggerType_User == WVR_GazeTriggerType.WVR_GazeTriggerType_Button)
				{
					DEBUG("updateInteractionModeAndGazeTriggerType() gazeTriggerType_User is button.");
				}
				if (gazeTriggerType_User == WVR_GazeTriggerType.WVR_GazeTriggerType_TimeoutButton)
				{
					DEBUG("updateInteractionModeAndGazeTriggerType() gazeTriggerType_User is timeout & button.");
				}
			}
			updateInputModuleByCustomSettings();
		}
		else
		{
			if (preOverrideSystemSettings != OverrideSystemSettings)
			{
				preOverrideSystemSettings = OverrideSystemSettings;
				Interop.WVR_SetInteractionMode(WVR_InteractionMode.WVR_InteractionMode_SystemDefault);
			}
			InteractionMode_System = WaveVR.Instance.InteractionMode;
			gazeTriggerType_System = WaveVR.Instance.GazeTriggerType;
			updateInputModuleBySystemSetting();
		}
	}

	private void updateGazeTriggerType_User()
	{
		if (Gaze.ButtonControl)
		{
			if (Gaze.TimerControl)
			{
				gazeTriggerType_User = WVR_GazeTriggerType.WVR_GazeTriggerType_TimeoutButton;
			}
			else
			{
				gazeTriggerType_User = WVR_GazeTriggerType.WVR_GazeTriggerType_Button;
			}
		}
		else
		{
			gazeTriggerType_User = WVR_GazeTriggerType.WVR_GazeTriggerType_Timeout;
		}
	}

	private void Awake()
	{
		if (instance == null)
		{
			instance = this;
		}
	}

	private void Start()
	{
		if (EventSystem.current == null)
		{
			EventSystem eventSystem = UnityEngine.Object.FindObjectOfType<EventSystem>();
			if (eventSystem != null)
			{
				this.eventSystem = eventSystem.gameObject;
				DEBUG("Start() find current EventSystem: " + this.eventSystem.name);
			}
			if (this.eventSystem == null)
			{
				DEBUG("Start() could not find EventSystem, create new one.");
				this.eventSystem = new GameObject("EventSystem", typeof(EventSystem));
			}
		}
		else
		{
			this.eventSystem = EventSystem.current.gameObject;
		}
		StandaloneInputModule component = this.eventSystem.GetComponent<StandaloneInputModule>();
		if (component != null)
		{
			component.enabled = false;
		}
		GazeInputModule component2 = this.eventSystem.GetComponent<GazeInputModule>();
		if (component2 != null)
		{
			UnityEngine.Object.Destroy(component2);
		}
		gazeInputModule = this.eventSystem.GetComponent<WaveVR_GazeInputModule>();
		WaveVR_Reticle componentInChildren = base.gameObject.GetComponentInChildren<WaveVR_Reticle>();
		if (componentInChildren != null)
		{
			gazePointerRenderer = componentInChildren.gameObject.GetComponent<MeshRenderer>();
			DEBUG("Start() found " + componentInChildren.gameObject.name);
		}
		RingMeshDrawer componentInChildren2 = base.gameObject.GetComponentInChildren<RingMeshDrawer>();
		if (componentInChildren2 != null)
		{
			gazeRingRenderer = componentInChildren2.gameObject.GetComponent<MeshRenderer>();
			DEBUG("Start() found " + componentInChildren.gameObject.name);
		}
		ActivateGazePointer(active: false);
		controllerInputModule = this.eventSystem.GetComponent<WaveVR_ControllerInputModule>();
		initInteractionModeAndGazeTriggerType();
		if (!EnableInputModule)
		{
			disableAllInputModules();
		}
	}

	public void Update()
	{
		if (WaveVR_Render.Instance != null)
		{
			Head = WaveVR_Render.Instance.gameObject;
		}
		if (Head != null)
		{
			base.gameObject.transform.position = Head.transform.position;
			base.gameObject.transform.rotation = Head.transform.rotation;
		}
		if (!EnableInputModule)
		{
			disableAllInputModules();
		}
		else
		{
			if (WaveVR.Instance.FocusCapturedBySystem)
			{
				return;
			}
			updateInteractionModeAndGazeTriggerType();
			WVR_InteractionMode interactionMode = GetInteractionMode();
			if (InteractionMode_Current != interactionMode)
			{
				InteractionMode_Current = interactionMode;
				if (InteractionMode_Current == WVR_InteractionMode.WVR_InteractionMode_Controller)
				{
					DEBUG("Update() InteractionMode_Current is controller.");
				}
				if (InteractionMode_Current == WVR_InteractionMode.WVR_InteractionMode_Gaze)
				{
					DEBUG("Update() InteractionMode_Current is gaze.");
				}
				WaveVR_Utils.Event.Send(WaveVR_Utils.Event.INTERACTION_MODE_CHANGED, InteractionMode_Current, AlwaysShowController);
			}
		}
	}

	private void ActivateGazePointer(bool active)
	{
		if (gazeInputModule != null)
		{
			gazeInputModule.ActivatePointerAndRing(active);
			return;
		}
		if (gazePointerRenderer != null)
		{
			gazePointerRenderer.enabled = false;
			DEBUG("ActivateGazePointer() no gaze input module, disable the gaze reticle.");
		}
		if (gazeRingRenderer != null)
		{
			gazeRingRenderer.enabled = false;
			DEBUG("ActivateGazePointer() no gaze input module, disable the gaze ring.");
		}
	}

	private void CreateGazeInputModule()
	{
		if (gazeInputModule == null)
		{
			eventSystem.SetActive(value: false);
			gazeInputModule = eventSystem.AddComponent<WaveVR_GazeInputModule>();
			SetGazeInputModuleParameters();
			eventSystem.SetActive(value: true);
		}
	}

	private void SetGazeInputModuleParameters()
	{
		if (gazeInputModule != null)
		{
			gazeInputModule.enabled = false;
			gazeInputModule.UseWaveVRReticle = Gaze.UseWaveVRReticle;
			gazeInputModule.TimerControl = Gaze.TimerControl;
			gazeInputModule.TimeToGaze = Gaze.TimeToGaze;
			gazeInputModule.ProgressRate = Gaze.ProgressRate;
			gazeInputModule.RateTextZPosition = Gaze.RateTextZPosition;
			gazeInputModule.ProgressCounter = Gaze.ProgressCounter;
			gazeInputModule.CounterTextZPosition = Gaze.CounterTextZPosition;
			gazeInputModule.InputEvent = Gaze.InputEvent;
			gazeInputModule.ButtonControl = Gaze.ButtonControl;
			gazeInputModule.ButtonControlDevices = Gaze.ButtonControlDevices;
			gazeInputModule.ButtonControlKeys = Gaze.ButtonControlKeys;
			gazeInputModule.Head = Gaze.Head;
			gazeInputModule.enabled = true;
		}
	}

	private void updateGazeInputModule()
	{
		if (gazeInputModule == null)
		{
			return;
		}
		if (OverrideSystemSettings)
		{
			gazeInputModule.ButtonControl = Gaze.ButtonControl;
			gazeInputModule.EnableTimerControl(Gaze.TimerControl);
			return;
		}
		switch (gazeTriggerType_System)
		{
		case WVR_GazeTriggerType.WVR_GazeTriggerType_Button:
			gazeInputModule.ButtonControl = true;
			gazeInputModule.EnableTimerControl(enable: false);
			break;
		case WVR_GazeTriggerType.WVR_GazeTriggerType_TimeoutButton:
			gazeInputModule.ButtonControl = true;
			gazeInputModule.EnableTimerControl(enable: true);
			break;
		default:
			gazeInputModule.ButtonControl = false;
			gazeInputModule.EnableTimerControl(enable: false);
			break;
		}
	}

	private void SetActiveGaze(bool value)
	{
		if (gazeInputModule != null)
		{
			gazeInputModule.enabled = value;
		}
		else if (value)
		{
			CreateGazeInputModule();
		}
	}

	public void UseWaveVRReticle(bool use)
	{
		Gaze.UseWaveVRReticle = use;
		if (gazeInputModule != null)
		{
			gazeInputModule.UseWaveVRReticle = Gaze.UseWaveVRReticle;
		}
	}

	private void CreateControllerInputModule()
	{
		if (controllerInputModule == null)
		{
			eventSystem.SetActive(value: false);
			controllerInputModule = eventSystem.AddComponent<WaveVR_ControllerInputModule>();
			SetControllerInputModuleParameters();
			eventSystem.SetActive(value: true);
		}
	}

	private void SetControllerInputModuleParameters()
	{
		if (controllerInputModule != null)
		{
			controllerInputModule.enabled = false;
			controllerInputModule.DomintEventEnabled = Controller.DominantEventEnabled;
			if (Controller.DominantController != null && Controller.DominantController.GetComponentInChildren<WaveVR_ControllerLoader>() == null)
			{
				controllerInputModule.DominantController = Controller.DominantController;
			}
			controllerInputModule.DominantRaycastMask = Controller.DominantRaycastMask;
			controllerInputModule.NoDomtEventEnabled = Controller.NonDominantEventEnabled;
			if (Controller.NonDominantController != null && Controller.NonDominantController.GetComponentInChildren<WaveVR_ControllerLoader>() == null)
			{
				controllerInputModule.NonDominantController = Controller.NonDominantController;
			}
			controllerInputModule.NonDominantRaycastMask = Controller.NonDominantRaycastMask;
			controllerInputModule.ButtonToTrigger = Controller.ButtonToTrigger;
			controllerInputModule.RaycastMode = Controller.RaycastMode;
			controllerInputModule.RaycastStartPoint = Controller.RaycastStartPoint;
			controllerInputModule.CanvasTag = Controller.CanvasTag;
			controllerInputModule.FixedBeamLength = FixedBeamLength;
			controllerInputModule.enabled = true;
		}
	}

	private void updateControllerInputModule()
	{
		if (!(controllerInputModule == null))
		{
			controllerInputModule.RaycastMode = Controller.RaycastMode;
		}
	}

	private void SetActiveController(bool value)
	{
		if (controllerInputModule != null)
		{
			controllerInputModule.enabled = value;
		}
		else if (value)
		{
			CreateControllerInputModule();
		}
	}

	private bool IsAnyControllerConnected()
	{
		bool result = false;
		for (int i = 0; i < WaveVR.DeviceTypes.Length; i++)
		{
			if (WaveVR.DeviceTypes[i] != WVR_DeviceType.WVR_DeviceType_HMD && WaveVR.Instance.Initialized && WaveVR.Instance.getDeviceByType(WaveVR.DeviceTypes[i]).connected)
			{
				result = true;
				break;
			}
		}
		return result;
	}

	private void initializeInputModuleByCustomSettings()
	{
		switch (InteractionMode_User)
		{
		case WaveVR_EInputModule.Controller:
			SetActiveGaze(value: false);
			if (controllerInputModule == null)
			{
				CreateControllerInputModule();
			}
			else
			{
				SetControllerInputModuleParameters();
			}
			break;
		case WaveVR_EInputModule.Gaze:
			SetActiveController(value: false);
			ActivateGazePointer(active: true);
			if (gazeInputModule == null)
			{
				CreateGazeInputModule();
			}
			else
			{
				SetGazeInputModuleParameters();
			}
			break;
		}
	}

	private void initializeInputModuleBySystemSetting()
	{
		switch (InteractionMode_System)
		{
		case WVR_InteractionMode.WVR_InteractionMode_Controller:
			SetActiveGaze(value: false);
			if (controllerInputModule == null)
			{
				CreateControllerInputModule();
			}
			else
			{
				SetControllerInputModuleParameters();
			}
			break;
		case WVR_InteractionMode.WVR_InteractionMode_Gaze:
			SetActiveController(value: false);
			ActivateGazePointer(active: true);
			if (gazeInputModule == null)
			{
				CreateGazeInputModule();
			}
			else
			{
				SetGazeInputModuleParameters();
			}
			break;
		}
	}

	private void disableAllInputModules()
	{
		SetActiveController(value: false);
		SetActiveGaze(value: false);
	}

	private void updateInputModuleByCustomSettings()
	{
		switch (InteractionMode_User)
		{
		case WaveVR_EInputModule.Gaze:
			ActivateGazePointer(active: true);
			SetActiveGaze(value: true);
			SetActiveController(value: false);
			updateGazeInputModule();
			break;
		case WaveVR_EInputModule.Controller:
			SetActiveGaze(value: false);
			if (IsAnyControllerConnected())
			{
				SetActiveController(value: true);
				updateControllerInputModule();
				break;
			}
			SetActiveController(value: false);
			if (AutoGaze)
			{
				SetActiveGaze(value: true);
				updateGazeInputModule();
			}
			break;
		}
	}

	private void updateInputModuleBySystemSetting()
	{
		switch (InteractionMode_System)
		{
		case WVR_InteractionMode.WVR_InteractionMode_Gaze:
			ActivateGazePointer(active: true);
			SetActiveGaze(value: true);
			SetActiveController(value: false);
			updateGazeInputModule();
			break;
		case WVR_InteractionMode.WVR_InteractionMode_Controller:
			SetActiveGaze(value: false);
			if (IsAnyControllerConnected())
			{
				SetActiveController(value: true);
				updateControllerInputModule();
				break;
			}
			SetActiveController(value: false);
			if (AutoGaze)
			{
				SetActiveGaze(value: true);
				updateGazeInputModule();
			}
			break;
		}
	}

	public WaveVR_ControllerInputModule.ERaycastMode GetRaycastMode()
	{
		if (controllerInputModule != null)
		{
			return controllerInputModule.RaycastMode;
		}
		return Controller.RaycastMode;
	}

	public WVR_InteractionMode GetInteractionMode()
	{
		WVR_InteractionMode result = ((InteractionMode_User == WaveVR_EInputModule.Controller) ? WVR_InteractionMode.WVR_InteractionMode_Controller : WVR_InteractionMode.WVR_InteractionMode_Gaze);
		if (!OverrideSystemSettings)
		{
			return InteractionMode_System;
		}
		return result;
	}

	public WVR_GazeTriggerType GetGazeTriggerType()
	{
		if (!OverrideSystemSettings)
		{
			return gazeTriggerType_System;
		}
		return gazeTriggerType_User;
	}

	public WVR_GazeTriggerType GetUserGazeTriggerType()
	{
		return gazeTriggerType_User;
	}

	public void SetControllerBeamLength(WaveVR_Controller.EDeviceType dt, float length)
	{
		if (controllerInputModule != null)
		{
			controllerInputModule.ChangeBeamLength(dt, length);
		}
	}
}
public class WaveVR_RaycastResult
{
	public GameObject gameObject { get; set; }

	public Vector3 worldPosition { get; set; }

	public WaveVR_RaycastResult()
	{
		gameObject = null;
		worldPosition = Vector3.zero;
	}
}
public class WaveVR_RaycastResultProvider
{
	public class ERaycastResult
	{
		public WaveVR_Controller.EDeviceType Type;

		public WaveVR_RaycastResult Result;

		public ERaycastResult(WaveVR_Controller.EDeviceType type, WaveVR_RaycastResult result)
		{
			Type = type;
			Result = result;
		}
	}

	private const string LOG_TAG = "WaveVR_RaycastResultProvider";

	private static WaveVR_RaycastResultProvider instance;

	private List<ERaycastResult> RaycastResults = new List<ERaycastResult>();

	public static WaveVR_RaycastResultProvider Instance
	{
		get
		{
			if (instance == null)
			{
				instance = new WaveVR_RaycastResultProvider();
			}
			return instance;
		}
	}

	private void PrintDebugLog(string msg)
	{
		WVR_Log.Log.d("WaveVR_RaycastResultProvider", msg);
	}

	private WaveVR_RaycastResultProvider()
	{
		for (int i = 0; i < WaveVR_Controller.DeviceTypes.Length; i++)
		{
			RaycastResults.Add(new ERaycastResult(WaveVR_Controller.DeviceTypes[i], new WaveVR_RaycastResult()));
		}
	}

	public void SetRaycastResult(WaveVR_Controller.EDeviceType device, GameObject gameObject, Vector3 worldPosition)
	{
		for (int i = 0; i < RaycastResults.Count; i++)
		{
			if (RaycastResults[i].Type == device)
			{
				RaycastResults[i].Result.gameObject = gameObject;
				RaycastResults[i].Result.worldPosition = worldPosition;
				break;
			}
		}
	}

	public WaveVR_RaycastResult GetRaycastResult(WVR_DeviceType type)
	{
		WaveVR_Controller.EDeviceType eDeviceByWVRType = WaveVR_Controller.GetEDeviceByWVRType(type);
		return GetRaycastResult(eDeviceByWVRType);
	}

	public WaveVR_RaycastResult GetRaycastResult(WaveVR_Controller.EDeviceType device)
	{
		for (int i = 0; i < RaycastResults.Count; i++)
		{
			if (RaycastResults[i].Type == device)
			{
				return RaycastResults[i].Result;
			}
		}
		return null;
	}
}
public class WaveVR_SetAsEventSystemController : MonoBehaviour
{
	private bool added;

	public WaveVR_Controller.EDeviceType Type = WaveVR_Controller.EDeviceType.Dominant;

	private void OnEnable()
	{
		WaveVR_EventSystemControllerProvider.Instance.SetControllerModel(Type, base.gameObject);
		added = true;
	}

	private void OnDisable()
	{
		if (added)
		{
			WaveVR_EventSystemControllerProvider.Instance.SetControllerModel(Type, null);
			added = false;
		}
	}
}
[RequireComponent(typeof(MeshRenderer), typeof(MeshFilter))]
public class WaveVR_GesturePointer : MonoBehaviour
{
	private enum DrawMode
	{
		FORWARD,
		UPWARD
	}

	private const string LOG_TAG = "WaveVR_GesturePointer";

	[Tooltip("Right hand or left hand pointer.")]
	public WaveVR_GestureManager.EGestureHand Hand;

	private DrawMode drawMode = DrawMode.UPWARD;

	private const float DEF_RING_WIDTH = 0.005f;

	private const float MIN_RING_WIDTH = 0.001f;

	[Tooltip("Set the width of the pointer's ring.")]
	public float PointerRingWidth = 0.005f;

	private const float DEF_INNER_CIRCLE_RADIUS = 0.005f;

	private const float MIN_INNER_CIRCLE_RADIUS = 0.001f;

	[Tooltip("Set the radius of the pointer's inner circle.")]
	public float PointerCircleRadius = 0.005f;

	private Vector3 pointerOffset = Vector3.zero;

	private Vector3 pointerFrameOffset = Vector3.zero;

	private Vector3 pointerWorldPosition = Vector3.zero;

	private const float DEF_POINTER_DISTANCE = 1f;

	private const float MIN_POINTER_DISTANCE = 0.1f;

	[Tooltip("Set the z-coordinate of the pointer.")]
	public float PointerDistance = 1f;

	private float pointerDistance = 1f;

	[Tooltip("Set the ring background color.")]
	public Color PointerColor = Color.white;

	[Tooltip("Set the ring foreground progess color.")]
	public Color ProgressColor = new Color(0f, 245f, 255f);

	private Mesh mMesh;

	private const string POINTER_MATERIAL_NAME = "RingUnlitTransparentMat";

	[Tooltip("Empty for using the default material or set a customized material.")]
	public Material PointerMaterial;

	private Material pointerMaterialInstance;

	private MeshRenderer pointerMeshRend;

	private MeshFilter pointerMeshFilter;

	private const int POINTER_MATERIAL_RENDER_QUEUE_MIN = 1000;

	private const int POINTER_MATERIAL_RENDER_QUEUE_MAX = 5000;

	[Tooltip("Set the Material's renderQueue.")]
	public int PointerRenderQueue = 5000;

	[Tooltip("Set the MeshRenderer's sortingOrder.")]
	public int PointerSortingOrder = 32767;

	private bool isHovering;

	[HideInInspector]
	public bool ShowPointer = true;

	private bool mEnabled;

	private const int VERTEX_COUNT = 400;

	private Vector3[] ringVert = new Vector3[400];

	private Color[] ringColor = new Color[400];

	private const int TRIANGLE_COUNT = 600;

	private int[] ringTriangle = new int[600];

	private Vector2[] ringUv = new Vector2[400];

	private const float percentAngle = 3.6f;

	private int frameCount;

	private int frameInterval = 20;

	private int beginVertex;

	private int endVertex = 20;

	private void DEBUG(string msg)
	{
		if (WVR_Log.Log.EnableDebugLog)
		{
			WVR_Log.Log.d("WaveVR_GesturePointer", msg, logInEditor: true);
		}
	}

	private bool ValidateParameters()
	{
		if (pointerMeshRend == null || pointerMeshFilter == null)
		{
			return false;
		}
		if (PointerRingWidth < 0.001f)
		{
			PointerRingWidth = 0.005f;
		}
		if (PointerCircleRadius < 0.001f)
		{
			PointerCircleRadius = 0.005f;
		}
		if (PointerDistance < 0.1f)
		{
			PointerDistance = 1f;
		}
		if (PointerRenderQueue < 1000 || PointerRenderQueue > 5000)
		{
			PointerRenderQueue = 5000;
		}
		return true;
	}

	private void OnEnable()
	{
		if (!mEnabled)
		{
			if (mMesh == null)
			{
				mMesh = new Mesh();
			}
			if (mMesh != null)
			{
				mMesh.name = base.gameObject.name + " Mesh " + Hand;
			}
			if (PointerMaterial == null)
			{
				PointerMaterial = Resources.Load("RingUnlitTransparentMat") as Material;
			}
			if (PointerMaterial != null)
			{
				pointerMaterialInstance = UnityEngine.Object.Instantiate(PointerMaterial);
			}
			pointerMeshFilter = GetComponent<MeshFilter>();
			pointerMeshRend = GetComponent<MeshRenderer>();
			SetPointerActive(ShowPointer);
			WaveVR_GesturePointerProvider.Instance.SetGesturePointer(Hand, base.gameObject);
			mEnabled = true;
			DEBUG("OnEnable()");
		}
	}

	private void OnDisable()
	{
		if (mEnabled)
		{
			pointerMeshFilter.mesh.Clear();
			PointerMaterial = null;
			UnityEngine.Object.Destroy(pointerMaterialInstance);
			mEnabled = false;
			DEBUG("OnDisable()");
		}
	}

	private void Update()
	{
		if (!ValidateParameters())
		{
			return;
		}
		if (pointerMeshRend.enabled != ShowPointer)
		{
			SetPointerActive(ShowPointer);
		}
		if (!pointerMeshRend.enabled)
		{
			return;
		}
		if (drawMode == DrawMode.UPWARD)
		{
			pointerDistance = pointerFrameOffset.y;
		}
		if (drawMode == DrawMode.FORWARD)
		{
			pointerDistance = pointerFrameOffset.z;
		}
		pointerFrameOffset = pointerOffset;
		if (pointerFrameOffset == Vector3.zero)
		{
			pointerDistance = PointerDistance;
		}
		pointerDistance = ((pointerDistance < 0.1f) ? PointerDistance : pointerDistance);
		if (drawMode == DrawMode.FORWARD)
		{
			pointerFrameOffset.z = pointerDistance;
		}
		if (drawMode == DrawMode.UPWARD)
		{
			pointerFrameOffset.y = pointerDistance;
		}
		float num = PointerRingWidth * (1f + pointerDistance / 1f * 0.1f);
		float num2 = PointerCircleRadius * (1f + pointerDistance / 1f * 0.1f);
		if (pointerOffset != Vector3.zero)
		{
			pointerWorldPosition = base.transform.position + pointerFrameOffset;
		}
		else
		{
			if (drawMode == DrawMode.FORWARD)
			{
				pointerWorldPosition = base.transform.position + base.transform.forward.normalized * pointerDistance;
			}
			if (drawMode == DrawMode.UPWARD)
			{
				pointerWorldPosition = base.transform.position + base.transform.up.normalized * pointerDistance;
			}
		}
		DrawRingRoll(num + num2, num2, pointerFrameOffset, isHovering);
	}

	private void SetPointerActive(bool active)
	{
		pointerMeshRend.enabled = active;
		if (pointerMeshRend.enabled)
		{
			pointerMeshRend.enabled = true;
			pointerMeshRend.sortingOrder = PointerSortingOrder;
			if (pointerMaterialInstance != null)
			{
				pointerMeshRend.material = pointerMaterialInstance;
				pointerMeshRend.material.renderQueue = PointerRenderQueue;
			}
		}
	}

	private void DrawRingRoll(float radius, float innerRadius, Vector3 offset, bool active)
	{
		frameCount++;
		frameCount %= frameInterval;
		if (frameCount == 0)
		{
			beginVertex = endVertex;
			endVertex += 20;
		}
		if (endVertex > 200)
		{
			beginVertex = 0;
			endVertex = 20;
		}
		float num = 90f;
		for (int i = 0; i < 400; i += 2)
		{
			float f = num * ((float)Math.PI / 180f);
			float num2 = Mathf.Cos(f);
			float num3 = Mathf.Sin(f);
			if (drawMode == DrawMode.FORWARD)
			{
				ringVert[i].x = offset.x + radius * num2;
				ringVert[i].y = offset.y + radius * num3;
				ringVert[i].z = offset.z;
			}
			if (drawMode == DrawMode.UPWARD)
			{
				ringVert[i].x = offset.x + radius * num2;
				ringVert[i].y = offset.y;
				ringVert[i].z = offset.z + radius * num3;
			}
			ringColor[i] = ((active && i > beginVertex && i < endVertex) ? ProgressColor : PointerColor);
			if (drawMode == DrawMode.FORWARD)
			{
				ringVert[i + 1].x = offset.x + innerRadius * num2;
				ringVert[i + 1].y = offset.y + innerRadius * num3;
				ringVert[i + 1].z = offset.z;
			}
			if (drawMode == DrawMode.UPWARD)
			{
				ringVert[i + 1].x = offset.x + innerRadius * num2;
				ringVert[i + 1].y = offset.y;
				ringVert[i + 1].z = offset.z + innerRadius * num3;
			}
			ringColor[i + 1] = ((active && i > beginVertex && i < endVertex) ? ProgressColor : PointerColor);
			num -= 3.6f;
		}
		int num4 = 0;
		int num5 = 0;
		while (num4 < 600)
		{
			ringTriangle[num4] = num5;
			ringTriangle[num4 + 1] = num5 + 3;
			ringTriangle[num4 + 2] = num5 + 1;
			ringTriangle[num4 + 3] = num5 + 2;
			ringTriangle[num4 + 4] = num5 + 3;
			ringTriangle[num4 + 5] = num5;
			num4 += 6;
			num5 += 2;
		}
		for (int j = 0; j < 400; j++)
		{
			ringUv[j].x = ringVert[j].x / radius / 2f + 0.5f;
			ringUv[j].y = ringVert[j].z / radius / 2f + 0.5f;
		}
		mMesh.Clear();
		mMesh.vertices = ringVert;
		mMesh.colors = ringColor;
		mMesh.triangles = ringTriangle;
		mMesh.uv = ringUv;
		pointerMeshFilter.mesh = mMesh;
	}

	public Vector3 GetPointerPosition()
	{
		return pointerWorldPosition;
	}

	public void OnHover(bool hovering, Vector3 intersecPosition)
	{
		pointerOffset = intersecPosition;
		OnHover(hovering);
	}

	public void OnHover(bool hovering)
	{
		isHovering = hovering;
	}
}
public class WaveVR_GesturePointerProvider
{
	private class GesturePointer
	{
		public WaveVR_GestureManager.EGestureHand Hand { get; set; }

		public GameObject Pointer { get; set; }

		public GesturePointer(WaveVR_GestureManager.EGestureHand type, GameObject pointer)
		{
			Hand = type;
			Pointer = pointer;
		}
	}

	private const string LOG_TAG = "WaveVR_GesturePointerProvider";

	private List<GesturePointer> gesturePointers = new List<GesturePointer>();

	private WaveVR_GestureManager.EGestureHand[] gestureHandList = new WaveVR_GestureManager.EGestureHand[2]
	{
		WaveVR_GestureManager.EGestureHand.RIGHT,
		WaveVR_GestureManager.EGestureHand.LEFT
	};

	private static WaveVR_GesturePointerProvider instance;

	public static WaveVR_GesturePointerProvider Instance
	{
		get
		{
			if (instance == null)
			{
				instance = new WaveVR_GesturePointerProvider();
			}
			return instance;
		}
	}

	private void DEBUG(string msg)
	{
		if (WVR_Log.Log.EnableDebugLog)
		{
			WVR_Log.Log.d("WaveVR_GesturePointerProvider", msg, logInEditor: true);
		}
	}

	private WaveVR_GesturePointerProvider()
	{
		for (int i = 0; i < gestureHandList.Length; i++)
		{
			gesturePointers.Add(new GesturePointer(gestureHandList[i], null));
		}
	}

	public void SetGesturePointer(WaveVR_GestureManager.EGestureHand hand, GameObject pointer)
	{
		DEBUG(string.Concat("SetGesturePointer() ", hand, ", pointer: ", (pointer != null) ? pointer.name : "null"));
		for (int i = 0; i < gestureHandList.Length; i++)
		{
			if (gestureHandList[i] == hand)
			{
				if (gesturePointers[i].Pointer != null)
				{
					gesturePointers[i].Pointer.GetComponent<WaveVR_GesturePointer>().ShowPointer = false;
				}
				gesturePointers[i].Pointer = pointer;
				gesturePointers[i].Pointer.GetComponent<WaveVR_GesturePointer>().ShowPointer = true;
			}
		}
	}

	public GameObject GetGesturePointer(WaveVR_GestureManager.EGestureHand hand)
	{
		int index = 0;
		for (int i = 0; i < gestureHandList.Length; i++)
		{
			if (gestureHandList[i] == hand)
			{
				index = i;
				if (gesturePointers[i].Pointer != null)
				{
					gesturePointers[i].Pointer.GetComponent<WaveVR_GesturePointer>().ShowPointer = true;
				}
			}
			else if (gesturePointers[i].Pointer != null)
			{
				gesturePointers[i].Pointer.GetComponent<WaveVR_GesturePointer>().ShowPointer = false;
			}
		}
		return gesturePointers[index].Pointer;
	}
}
public class WaveVR_GestureInputModule : BaseInputModule
{
	private const string LOG_TAG = "WaveVR_GestureInputModule";

	[Tooltip("If not selected, no events will be sent.")]
	public bool EnableEvent = true;

	[Tooltip("The gesture used to trigger events.")]
	public WaveVR_GestureManager.EStaticGestures SelectGesture = WaveVR_GestureManager.EStaticGestures.FIST;

	[SerializeField]
	private bool forceModuleActive = true;

	private WVR_HandGestureType currentGestureRight;

	private WVR_HandGestureType previousGestureRight;

	private WVR_HandGestureType currentGestureLeft;

	private WVR_HandGestureType previousGestureLeft;

	private WaveVR_GestureManager.EGestureHand gestureFocusHand;

	private GameObject pointerObject;

	private WaveVR_GesturePointer gesturePointer;

	private Camera eventCamera;

	private PhysicsRaycaster pointerPhysicsRaycaster;

	private PointerEventData mPointerEventData;

	private readonly Vector2 centerOfScreen = new Vector2(0.5f * (float)Screen.width, 0.5f * (float)Screen.height);

	private GameObject prevRaycastedObject;

	private bool mInputModuleEnabled;

	private RaycastResult firstRaycastResult;

	private GraphicRaycaster[] graphic_raycasters;

	private List<RaycastResult> graphicRaycastResults = new List<RaycastResult>();

	private List<GameObject> graphicRaycastObjects = new List<GameObject>();

	private List<GameObject> preGraphicRaycastObjects = new List<GameObject>();

	private List<RaycastResult> physicsRaycastResults = new List<RaycastResult>();

	private List<GameObject> physicsRaycastObjects = new List<GameObject>();

	private List<GameObject> prePhysicsRaycastObjects = new List<GameObject>();

	private const float DRAG_TIME = 0.3f;

	public bool ForceModuleActive
	{
		get
		{
			return forceModuleActive;
		}
		set
		{
			forceModuleActive = value;
		}
	}

	private void DEBUG(string msg)
	{
		if (WVR_Log.Log.EnableDebugLog)
		{
			WVR_Log.Log.d("WaveVR_GestureInputModule", string.Concat(gestureFocusHand, ", ", msg), logInEditor: true);
		}
	}

	private void INFO(string msg)
	{
		WVR_Log.Log.i("WaveVR_GestureInputModule", msg, logInEditor: true);
	}

	public override bool IsModuleSupported()
	{
		return forceModuleActive;
	}

	public override bool ShouldActivateModule()
	{
		if (!base.ShouldActivateModule())
		{
			return false;
		}
		if (forceModuleActive)
		{
			return true;
		}
		return false;
	}

	public override void DeactivateModule()
	{
		base.DeactivateModule();
	}

	private bool ValidateParameters()
	{
		gestureFocusHand = WaveVR_GestureManager.GestureFocusHand;
		GameObject gameObject = WaveVR_GesturePointerProvider.Instance.GetGesturePointer(gestureFocusHand);
		if (gameObject != null && (object)pointerObject != gameObject)
		{
			pointerObject = gameObject;
			gesturePointer = pointerObject.GetComponent<WaveVR_GesturePointer>();
		}
		if (pointerObject == null)
		{
			gesturePointer = null;
		}
		if (WaveVR_GesturePointerTracker.Instance != null)
		{
			if (eventCamera == null)
			{
				eventCamera = WaveVR_GesturePointerTracker.Instance.GetPointerTrackerCamera();
			}
			if (pointerPhysicsRaycaster == null)
			{
				pointerPhysicsRaycaster = WaveVR_GesturePointerTracker.Instance.GetPhysicsRaycaster();
			}
		}
		if (gesturePointer == null || eventCamera == null)
		{
			if (WVR_Log.Log.gpl.Print)
			{
				if (gesturePointer == null)
				{
					WVR_Log.Log.i("WaveVR_GestureInputModule", "ValidateParameters() No pointer of " + gestureFocusHand, logInEditor: true);
				}
				if (eventCamera == null)
				{
					WVR_Log.Log.i("WaveVR_GestureInputModule", "ValidateParameters() Forget to put GesturePointerTracker??");
				}
			}
			return false;
		}
		if (!EnableEvent)
		{
			return false;
		}
		return true;
	}

	private void ResetPointerEventData()
	{
		if (mPointerEventData == null)
		{
			mPointerEventData = new PointerEventData(base.eventSystem);
			mPointerEventData.pointerCurrentRaycast = default(RaycastResult);
		}
		mPointerEventData.Reset();
		mPointerEventData.position = new Vector2(0.5f * (float)eventCamera.pixelWidth, 0.5f * (float)eventCamera.pixelHeight);
		firstRaycastResult.Clear();
		mPointerEventData.pointerCurrentRaycast = firstRaycastResult;
	}

	private GameObject GetRaycastedObject()
	{
		if (mPointerEventData == null)
		{
			return null;
		}
		return mPointerEventData.pointerCurrentRaycast.gameObject;
	}

	private Vector3 GetIntersectionPosition(RaycastResult raycastResult)
	{
		if (eventCamera == null)
		{
			return Vector3.zero;
		}
		float num = raycastResult.distance + eventCamera.nearClipPlane;
		return eventCamera.transform.forward * num + eventCamera.transform.position;
	}

	protected override void OnEnable()
	{
		if (!mInputModuleEnabled)
		{
			base.OnEnable();
			DEBUG("OnEnable()");
			StandaloneInputModule component = base.gameObject.GetComponent<StandaloneInputModule>();
			if (component != null)
			{
				component.enabled = false;
			}
			mInputModuleEnabled = true;
		}
	}

	protected override void OnDisable()
	{
		if (mInputModuleEnabled)
		{
			base.OnDisable();
			DEBUG("OnDisable()");
			mInputModuleEnabled = false;
		}
	}

	public override void Process()
	{
		if (!ValidateParameters())
		{
			return;
		}
		prevRaycastedObject = GetRaycastedObject();
		ResetPointerEventData();
		GraphicRaycast();
		PhysicsRaycast();
		GameObject raycastedObject = GetRaycastedObject();
		previousGestureRight = currentGestureRight;
		currentGestureRight = WaveVR_GestureManager.Instance.GetCurrentRightHandStaticGesture();
		previousGestureLeft = currentGestureLeft;
		currentGestureLeft = WaveVR_GestureManager.Instance.GetCurrentLeftHandStaticGesture();
		bool flag = false;
		bool flag2 = false;
		if (gestureFocusHand == WaveVR_GestureManager.EGestureHand.RIGHT)
		{
			if (previousGestureLeft != currentGestureLeft && currentGestureLeft == (WVR_HandGestureType)SelectGesture)
			{
				WaveVR_GestureManager.GestureFocusHand = WaveVR_GestureManager.EGestureHand.LEFT;
				return;
			}
			flag = currentGestureRight == (WVR_HandGestureType)SelectGesture && currentGestureRight != WVR_HandGestureType.WVR_HandGestureType_Invalid;
			flag2 = previousGestureRight == (WVR_HandGestureType)SelectGesture && currentGestureRight == WVR_HandGestureType.WVR_HandGestureType_Unknown;
		}
		if (gestureFocusHand == WaveVR_GestureManager.EGestureHand.LEFT)
		{
			if (previousGestureRight != currentGestureRight && currentGestureRight == (WVR_HandGestureType)SelectGesture)
			{
				WaveVR_GestureManager.GestureFocusHand = WaveVR_GestureManager.EGestureHand.RIGHT;
				return;
			}
			flag = currentGestureLeft == (WVR_HandGestureType)SelectGesture && currentGestureLeft != WVR_HandGestureType.WVR_HandGestureType_Invalid;
			flag2 = previousGestureLeft == (WVR_HandGestureType)SelectGesture && currentGestureLeft == WVR_HandGestureType.WVR_HandGestureType_Unknown;
		}
		OnGraphicPointerEnterExit();
		OnPhysicsPointerEnterExit();
		if (raycastedObject != null && raycastedObject == prevRaycastedObject)
		{
			OnPointerHover();
			gesturePointer.OnHover(hovering: true);
		}
		else
		{
			gesturePointer.OnHover(hovering: false);
		}
		if (!mPointerEventData.eligibleForClick)
		{
			if (flag)
			{
				OnPointerDown();
			}
		}
		else if (mPointerEventData.eligibleForClick)
		{
			if (flag || flag2)
			{
				OnPointerDrag();
			}
			else
			{
				OnPointerUp();
			}
		}
		GetIntersectionPosition(mPointerEventData.pointerCurrentRaycast);
	}

	private void GraphicRaycast()
	{
		if (eventCamera == null)
		{
			return;
		}
		graphic_raycasters = UnityEngine.Object.FindObjectsOfType<GraphicRaycaster>();
		graphicRaycastObjects.Clear();
		for (int i = 0; i < graphic_raycasters.Length; i++)
		{
			if (graphic_raycasters[i].gameObject.name.Equals("Blocker") || !(graphic_raycasters[i].gameObject.GetComponent<Canvas>() != null))
			{
				continue;
			}
			graphic_raycasters[i].gameObject.GetComponent<Canvas>().worldCamera = eventCamera;
			graphic_raycasters[i].Raycast(mPointerEventData, graphicRaycastResults);
			if (graphicRaycastResults.Count == 0)
			{
				continue;
			}
			for (int j = 0; j < graphicRaycastResults.Count; j++)
			{
				graphicRaycastObjects.Add(graphicRaycastResults[j].gameObject);
			}
			firstRaycastResult = BaseInputModule.FindFirstRaycast(graphicRaycastResults);
			graphicRaycastResults.Clear();
			if (!(firstRaycastResult.gameObject != null))
			{
				continue;
			}
			if (firstRaycastResult.worldPosition == Vector3.zero)
			{
				firstRaycastResult.worldPosition = GetIntersectionPosition(firstRaycastResult);
			}
			float num = Mathf.Abs(firstRaycastResult.worldPosition.z - firstRaycastResult.module.eventCamera.transform.position.z);
			float num2 = Mathf.Abs(mPointerEventData.pointerCurrentRaycast.worldPosition.z - firstRaycastResult.module.eventCamera.transform.position.z);
			bool flag = false;
			if (mPointerEventData.pointerCurrentRaycast.gameObject == null)
			{
				flag = true;
			}
			else if (num2 > num)
			{
				DEBUG(string.Concat("GraphicRaycast() ", mPointerEventData.pointerCurrentRaycast.gameObject.name, ", position: ", mPointerEventData.pointerCurrentRaycast.worldPosition, ", distance: ", num2, " is farer than ", firstRaycastResult.gameObject.name, ", position: ", firstRaycastResult.worldPosition, ", new distance: ", num));
				flag = true;
			}
			else if (num2 == num)
			{
				int sortingOrder = mPointerEventData.pointerCurrentRaycast.sortingOrder;
				int sortingOrder2 = firstRaycastResult.sortingOrder;
				if (sortingOrder < sortingOrder2)
				{
					DEBUG("GraphicRaycast() " + mPointerEventData.pointerCurrentRaycast.gameObject.name + " sorting order: " + sortingOrder + " is smaller than " + firstRaycastResult.gameObject.name + " sorting order: " + sortingOrder2);
					flag = true;
				}
			}
			if (flag)
			{
				mPointerEventData.pointerCurrentRaycast = firstRaycastResult;
				mPointerEventData.position = firstRaycastResult.screenPosition;
			}
		}
	}

	private void PhysicsRaycast()
	{
		if (eventCamera == null || pointerPhysicsRaycaster == null)
		{
			return;
		}
		physicsRaycastResults.Clear();
		physicsRaycastObjects.Clear();
		pointerPhysicsRaycaster.Raycast(mPointerEventData, physicsRaycastResults);
		if (physicsRaycastResults.Count == 0)
		{
			return;
		}
		for (int i = 0; i < physicsRaycastResults.Count; i++)
		{
			if (!(physicsRaycastResults[i].gameObject.GetComponent<WaveVR_BonePose>() != null))
			{
				physicsRaycastObjects.Add(physicsRaycastResults[i].gameObject);
			}
		}
		firstRaycastResult = BaseInputModule.FindFirstRaycast(physicsRaycastResults);
		physicsRaycastResults.Clear();
		if (firstRaycastResult.gameObject != null)
		{
			if (firstRaycastResult.worldPosition == Vector3.zero)
			{
				firstRaycastResult.worldPosition = GetIntersectionPosition(firstRaycastResult);
			}
			float num = Mathf.Abs(firstRaycastResult.worldPosition.z - firstRaycastResult.module.eventCamera.transform.position.z);
			float num2 = Mathf.Abs(mPointerEventData.pointerCurrentRaycast.worldPosition.z - firstRaycastResult.module.eventCamera.transform.position.z);
			if (mPointerEventData.pointerCurrentRaycast.gameObject == null || num2 > num)
			{
				mPointerEventData.pointerCurrentRaycast = firstRaycastResult;
				mPointerEventData.position = firstRaycastResult.screenPosition;
			}
		}
	}

	private void OnGraphicPointerEnterExit()
	{
		if (graphicRaycastObjects.Count != 0)
		{
			for (int i = 0; i < graphicRaycastObjects.Count; i++)
			{
				if (graphicRaycastObjects[i] != null && !preGraphicRaycastObjects.Contains(graphicRaycastObjects[i]))
				{
					ExecuteEvents.Execute(graphicRaycastObjects[i], mPointerEventData, ExecuteEvents.pointerEnterHandler);
					DEBUG("OnGraphicPointerEnterExit() enter: " + graphicRaycastObjects[i]);
				}
			}
		}
		if (preGraphicRaycastObjects.Count != 0)
		{
			for (int j = 0; j < preGraphicRaycastObjects.Count; j++)
			{
				if (preGraphicRaycastObjects[j] != null && !graphicRaycastObjects.Contains(preGraphicRaycastObjects[j]))
				{
					ExecuteEvents.Execute(preGraphicRaycastObjects[j], mPointerEventData, ExecuteEvents.pointerExitHandler);
					DEBUG("OnGraphicPointerEnterExit() exit: " + preGraphicRaycastObjects[j]);
				}
			}
		}
		CopyList(graphicRaycastObjects, preGraphicRaycastObjects);
	}

	private void OnPhysicsPointerEnterExit()
	{
		if (physicsRaycastObjects.Count != 0)
		{
			for (int i = 0; i < physicsRaycastObjects.Count; i++)
			{
				if (physicsRaycastObjects[i] != null && !prePhysicsRaycastObjects.Contains(physicsRaycastObjects[i]))
				{
					ExecuteEvents.Execute(physicsRaycastObjects[i], mPointerEventData, ExecuteEvents.pointerEnterHandler);
					DEBUG("OnPhysicsPointerEnterExit() enter: " + physicsRaycastObjects[i]);
				}
			}
		}
		if (prePhysicsRaycastObjects.Count != 0)
		{
			for (int j = 0; j < prePhysicsRaycastObjects.Count; j++)
			{
				if (prePhysicsRaycastObjects[j] != null && !physicsRaycastObjects.Contains(prePhysicsRaycastObjects[j]))
				{
					ExecuteEvents.Execute(prePhysicsRaycastObjects[j], mPointerEventData, ExecuteEvents.pointerExitHandler);
					DEBUG("OnPhysicsPointerEnterExit() exit: " + prePhysicsRaycastObjects[j]);
				}
			}
		}
		CopyList(physicsRaycastObjects, prePhysicsRaycastObjects);
	}

	private void OnPointerHover()
	{
		ExecuteEvents.ExecuteHierarchy(GetRaycastedObject(), mPointerEventData, WaveVR_ExecuteEvents.pointerHoverHandler);
	}

	private void OnPointerDown()
	{
		GameObject raycastedObject = GetRaycastedObject();
		if (!(raycastedObject == null))
		{
			mPointerEventData.pressPosition = mPointerEventData.position;
			mPointerEventData.pointerPressRaycast = mPointerEventData.pointerCurrentRaycast;
			mPointerEventData.pointerPress = ExecuteEvents.ExecuteHierarchy(raycastedObject, mPointerEventData, ExecuteEvents.pointerDownHandler) ?? ExecuteEvents.GetEventHandler<IPointerClickHandler>(raycastedObject);
			DEBUG(string.Concat("OnPointerDown() send Pointer Down to ", mPointerEventData.pointerPress, ", current GameObject is ", raycastedObject));
			mPointerEventData.pointerDrag = ExecuteEvents.GetEventHandler<IDragHandler>(raycastedObject);
			if (mPointerEventData.pointerDrag != null)
			{
				DEBUG(string.Concat("OnPointerDown() send initializePotentialDrag to ", mPointerEventData.pointerDrag, ", current GameObject is ", raycastedObject));
				ExecuteEvents.Execute(mPointerEventData.pointerDrag, mPointerEventData, ExecuteEvents.initializePotentialDrag);
			}
			mPointerEventData.rawPointerPress = raycastedObject;
			mPointerEventData.eligibleForClick = true;
			mPointerEventData.delta = Vector2.zero;
			mPointerEventData.dragging = false;
			mPointerEventData.useDragThreshold = true;
			mPointerEventData.clickCount = 1;
			mPointerEventData.clickTime = Time.unscaledTime;
		}
	}

	private void OnPointerDrag()
	{
		if (!(Time.unscaledTime - mPointerEventData.clickTime < 0.3f) && !(mPointerEventData.pointerDrag == null))
		{
			if (!mPointerEventData.dragging)
			{
				DEBUG("OnPointerDrag() send BeginDrag to " + mPointerEventData.pointerDrag);
				ExecuteEvents.Execute(mPointerEventData.pointerDrag, mPointerEventData, ExecuteEvents.beginDragHandler);
				mPointerEventData.dragging = true;
			}
			else
			{
				ExecuteEvents.Execute(mPointerEventData.pointerDrag, mPointerEventData, ExecuteEvents.dragHandler);
			}
		}
	}

	private void OnPointerUp()
	{
		GameObject raycastedObject = GetRaycastedObject();
		if (mPointerEventData.pointerPress != null)
		{
			DEBUG("OnPointerUp() send Pointer Up to " + mPointerEventData.pointerPress);
			ExecuteEvents.Execute(mPointerEventData.pointerPress, mPointerEventData, ExecuteEvents.pointerUpHandler);
		}
		if (mPointerEventData.eligibleForClick)
		{
			GameObject eventHandler = ExecuteEvents.GetEventHandler<IPointerClickHandler>(raycastedObject);
			if (eventHandler != null)
			{
				if (eventHandler == mPointerEventData.pointerPress)
				{
					DEBUG("OnPointerUp() send Pointer Click to " + mPointerEventData.pointerPress);
					ExecuteEvents.Execute(mPointerEventData.pointerPress, mPointerEventData, ExecuteEvents.pointerClickHandler);
				}
				else
				{
					DEBUG(string.Concat("OnTriggerUpMouse() pointer down object ", mPointerEventData.pointerPress, " is different with click object ", eventHandler));
				}
			}
			if (mPointerEventData.dragging)
			{
				if (ExecuteEvents.GetEventHandler<IDropHandler>(raycastedObject) == mPointerEventData.pointerDrag)
				{
					DEBUG("OnPointerUp() send Pointer Drop to " + mPointerEventData.pointerDrag);
					ExecuteEvents.Execute(mPointerEventData.pointerDrag, mPointerEventData, ExecuteEvents.dropHandler);
				}
				DEBUG("OnPointerUp() send Pointer endDrag to " + mPointerEventData.pointerDrag);
				ExecuteEvents.Execute(mPointerEventData.pointerDrag, mPointerEventData, ExecuteEvents.endDragHandler);
				mPointerEventData.pointerDrag = null;
				mPointerEventData.dragging = false;
			}
		}
		mPointerEventData.pointerPress = null;
		mPointerEventData.rawPointerPress = null;
		mPointerEventData.eligibleForClick = false;
		mPointerEventData.clickCount = 0;
		mPointerEventData.clickTime = 0f;
	}

	private void CopyList(List<GameObject> src, List<GameObject> dst)
	{
		dst.Clear();
		for (int i = 0; i < src.Count; i++)
		{
			dst.Add(src[i]);
		}
	}
}
[RequireComponent(typeof(Camera), typeof(PhysicsRaycaster))]
public class WaveVR_GesturePointerTracker : MonoBehaviour
{
	private const string LOG_TAG = "WaveVR_GesturePointerTracker";

	private static WaveVR_GesturePointerTracker instance;

	private WaveVR_GestureManager.EGestureHand gestureFocusHand;

	private GameObject pointerObject;

	private WaveVR_GesturePointer gesturePointer;

	private Vector3 pointerPosition = Vector3.zero;

	private Vector3 lookDirection = Vector3.zero;

	public static WaveVR_GesturePointerTracker Instance => instance;

	private void DEBUG(string msg)
	{
		if (WVR_Log.Log.EnableDebugLog)
		{
			WVR_Log.Log.d("WaveVR_GesturePointerTracker", msg, logInEditor: true);
		}
	}

	private bool ValidateParameters()
	{
		gestureFocusHand = WaveVR_GestureManager.GestureFocusHand;
		GameObject gameObject = WaveVR_GesturePointerProvider.Instance.GetGesturePointer(gestureFocusHand);
		if (gameObject != null && (object)pointerObject != gameObject)
		{
			pointerObject = gameObject;
			gesturePointer = pointerObject.GetComponent<WaveVR_GesturePointer>();
		}
		if (pointerObject == null || gesturePointer == null)
		{
			return false;
		}
		return true;
	}

	private void Awake()
	{
		instance = this;
	}

	private void Start()
	{
		GetComponent<Camera>().enabled = false;
		base.transform.position = WaveVR_Render.Instance.righteye.transform.position;
		DEBUG("Start() " + base.gameObject.name);
	}

	private void Update()
	{
		if (ValidateParameters())
		{
			pointerPosition = gesturePointer.GetPointerPosition();
			lookDirection = pointerPosition - base.transform.position;
			base.transform.rotation = Quaternion.LookRotation(lookDirection);
		}
	}

	public Camera GetPointerTrackerCamera()
	{
		return GetComponent<Camera>();
	}

	public PhysicsRaycaster GetPhysicsRaycaster()
	{
		return GetComponent<PhysicsRaycaster>();
	}
}
public abstract class IWaveVR_BonePose : MonoBehaviour
{
	private static WaveVR_BonePoseImpl instance;

	public static WaveVR_BonePoseImpl Instance
	{
		get
		{
			if (instance == null)
			{
				instance = new WaveVR_BonePoseImpl();
			}
			return instance;
		}
	}

	private void OnEnable()
	{
		if (instance == null)
		{
			instance = new WaveVR_BonePoseImpl();
		}
	}

	public WaveVR_Utils.RigidTransform GetBoneTransform(WaveVR_BonePoseImpl.Bones bone_type)
	{
		return Instance.GetBoneTransform(bone_type);
	}

	public bool IsBonePoseValid(WaveVR_BonePoseImpl.Bones bone_type)
	{
		return Instance.IsBonePoseValid(bone_type);
	}

	public bool IsHandPoseValid(WaveVR_GestureManager.EGestureHand hand)
	{
		return Instance.IsHandPoseValid(hand);
	}
}
public class WaveVR_BonePose : IWaveVR_BonePose
{
	private const string LOG_TAG = "WaveVR_BonePose";

	[Tooltip("The bone type.")]
	public WaveVR_BonePoseImpl.Bones BoneType;

	[Tooltip("Hide the bone with invalid poses.")]
	public bool HideInvalidBone = true;

	private bool mEnabled;

	private MeshRenderer meshRend;

	private List<GameObject> childrenObjects = new List<GameObject>();

	private List<bool> childrenObjectsState = new List<bool>();

	private bool objectsShown = true;

	private WaveVR_Utils.RigidTransform boneTransform = WaveVR_Utils.RigidTransform.identity;

	public bool Valid => IsBonePoseValid();

	public Vector3 Position => GetBoneTransform().pos;

	public Quaternion Rotation => GetBoneTransform().rot;

	private void DEBUG(string msg)
	{
		if (WVR_Log.Log.EnableDebugLog)
		{
			WVR_Log.Log.d("WaveVR_BonePose", string.Concat(BoneType, ", ", msg), logInEditor: true);
		}
	}

	public bool IsBonePoseValid()
	{
		return IsBonePoseValid(BoneType);
	}

	public WaveVR_Utils.RigidTransform GetBoneTransform()
	{
		return GetBoneTransform(BoneType);
	}

	private void OnEnable()
	{
		if (!mEnabled)
		{
			meshRend = GetComponent<MeshRenderer>();
			childrenObjects.Clear();
			childrenObjectsState.Clear();
			for (int i = 0; i < base.transform.childCount; i++)
			{
				childrenObjects.Add(base.transform.GetChild(i).gameObject);
				childrenObjectsState.Add(base.transform.GetChild(i).gameObject.activeSelf);
				DEBUG("OnEnable() " + base.gameObject.name + " has child: " + childrenObjects[i].name + ", active? " + childrenObjectsState[i]);
			}
			mEnabled = true;
		}
	}

	private void OnDisable()
	{
		if (mEnabled)
		{
			DEBUG("OnDisable() Restore children objects.");
			ForceActivateObjects(active: true);
			mEnabled = false;
		}
	}

	private void Update()
	{
		if (!WaveVR_GestureManager.Instance.EnableHandTracking)
		{
			return;
		}
		boneTransform = GetBoneTransform(BoneType);
		if (Valid)
		{
			base.gameObject.transform.localPosition = boneTransform.pos;
			if (BoneType == WaveVR_BonePoseImpl.Bones.LEFT_WRIST || BoneType == WaveVR_BonePoseImpl.Bones.RIGHT_WRIST)
			{
				base.gameObject.transform.localRotation = boneTransform.rot;
			}
			if (WVR_Log.Log.gpl.Print)
			{
				DEBUG("Position (" + boneTransform.pos.x + ", " + boneTransform.pos.y + ", " + boneTransform.pos.z + ")");
			}
		}
		ActivateObjects();
	}

	private void ActivateObjects()
	{
		bool flag = true;
		if (HideInvalidBone)
		{
			flag &= Valid;
		}
		if (flag != objectsShown)
		{
			DEBUG("ActivateObjects() valid pose: " + Valid);
			ForceActivateObjects(flag);
		}
	}

	private void ForceActivateObjects(bool active)
	{
		DEBUG("ForceActivateObjects() " + active);
		if (meshRend != null)
		{
			meshRend.enabled = active;
		}
		for (int i = 0; i < childrenObjects.Count; i++)
		{
			if (!(childrenObjects[i] == null) && childrenObjectsState[i])
			{
				DEBUG("ForceActivateTargetObjects() " + (active ? "activate" : "deactivate") + " " + childrenObjects[i].name);
				childrenObjects[i].SetActive(active);
			}
		}
		objectsShown = active;
	}
}
public class WaveVR_BonePoseImpl
{
	public enum Bones
	{
		ROOT,
		LEFT_WRIST,
		LEFT_THUMB_JOINT1,
		LEFT_THUMB_JOINT2,
		LEFT_THUMB_JOINT3,
		LEFT_THUMB_TIP,
		LEFT_INDEX_JOINT1,
		LEFT_INDEX_JOINT2,
		LEFT_INDEX_JOINT3,
		LEFT_INDEX_TIP,
		LEFT_MIDDLE_JOINT1,
		LEFT_MIDDLE_JOINT2,
		LEFT_MIDDLE_JOINT3,
		LEFT_MIDDLE_TIP,
		LEFT_RING_JOINT1,
		LEFT_RING_JOINT2,
		LEFT_RING_JOINT3,
		LEFT_RING_TIP,
		LEFT_PINKY_JOINT1,
		LEFT_PINKY_JOINT2,
		LEFT_PINKY_JOINT3,
		LEFT_PINKY_TIP,
		RIGHT_WRIST,
		RIGHT_THUMB_JOINT1,
		RIGHT_THUMB_JOINT2,
		RIGHT_THUMB_JOINT3,
		RIGHT_THUMB_TIP,
		RIGHT_INDEX_JOINT1,
		RIGHT_INDEX_JOINT2,
		RIGHT_INDEX_JOINT3,
		RIGHT_INDEX_TIP,
		RIGHT_MIDDLE_JOINT1,
		RIGHT_MIDDLE_JOINT2,
		RIGHT_MIDDLE_JOINT3,
		RIGHT_MIDDLE_TIP,
		RIGHT_RING_JOINT1,
		RIGHT_RING_JOINT2,
		RIGHT_RING_JOINT3,
		RIGHT_RING_TIP,
		RIGHT_PINKY_JOINT1,
		RIGHT_PINKY_JOINT2,
		RIGHT_PINKY_JOINT3,
		RIGHT_PINKY_TIP
	}

	private class BoneData
	{
		private WaveVR_Utils.RigidTransform rigidTransform = WaveVR_Utils.RigidTransform.identity;

		private bool valid;

		public BoneData()
		{
			rigidTransform = WaveVR_Utils.RigidTransform.identity;
			valid = false;
		}

		public WaveVR_Utils.RigidTransform GetTransform()
		{
			return rigidTransform;
		}

		public Vector3 GetPosition()
		{
			return rigidTransform.pos;
		}

		public void SetPosition(Vector3 in_pos)
		{
			rigidTransform.pos = in_pos;
		}

		public Quaternion GetRotation()
		{
			return rigidTransform.rot;
		}

		public void SetRotation(Quaternion in_rot)
		{
			rigidTransform.rot = in_rot;
		}

		public bool IsValidPose()
		{
			return valid;
		}

		public void SetValidPose(bool in_valid)
		{
			valid = in_valid;
		}
	}

	private const string LOG_TAG = "WaveVR_BonePoseImpl";

	private static Bones[] leftBones = new Bones[21]
	{
		Bones.LEFT_WRIST,
		Bones.LEFT_THUMB_JOINT1,
		Bones.LEFT_THUMB_JOINT2,
		Bones.LEFT_THUMB_JOINT3,
		Bones.LEFT_THUMB_TIP,
		Bones.LEFT_INDEX_JOINT1,
		Bones.LEFT_INDEX_JOINT2,
		Bones.LEFT_INDEX_JOINT3,
		Bones.LEFT_INDEX_TIP,
		Bones.LEFT_MIDDLE_JOINT1,
		Bones.LEFT_MIDDLE_JOINT2,
		Bones.LEFT_MIDDLE_JOINT3,
		Bones.LEFT_MIDDLE_TIP,
		Bones.LEFT_RING_JOINT1,
		Bones.LEFT_RING_JOINT2,
		Bones.LEFT_RING_JOINT3,
		Bones.LEFT_RING_TIP,
		Bones.LEFT_PINKY_JOINT1,
		Bones.LEFT_PINKY_JOINT2,
		Bones.LEFT_PINKY_JOINT3,
		Bones.LEFT_PINKY_TIP
	};

	private static Bones[] rightBones = new Bones[21]
	{
		Bones.RIGHT_WRIST,
		Bones.RIGHT_THUMB_JOINT1,
		Bones.RIGHT_THUMB_JOINT2,
		Bones.RIGHT_THUMB_JOINT3,
		Bones.RIGHT_THUMB_TIP,
		Bones.RIGHT_INDEX_JOINT1,
		Bones.RIGHT_INDEX_JOINT2,
		Bones.RIGHT_INDEX_JOINT3,
		Bones.RIGHT_INDEX_TIP,
		Bones.RIGHT_MIDDLE_JOINT1,
		Bones.RIGHT_MIDDLE_JOINT2,
		Bones.RIGHT_MIDDLE_JOINT3,
		Bones.RIGHT_MIDDLE_TIP,
		Bones.RIGHT_RING_JOINT1,
		Bones.RIGHT_RING_JOINT2,
		Bones.RIGHT_RING_JOINT3,
		Bones.RIGHT_RING_TIP,
		Bones.RIGHT_PINKY_JOINT1,
		Bones.RIGHT_PINKY_JOINT2,
		Bones.RIGHT_PINKY_JOINT3,
		Bones.RIGHT_PINKY_TIP
	};

	private BoneData[] boneDatas;

	private int prevFrame_tracking = -1;

	private bool hasHandTrackingData;

	private WVR_HandTrackingData_t handTrackingData;

	private WaveVR_Utils.RigidTransform rtWristLeft = WaveVR_Utils.RigidTransform.identity;

	private WaveVR_Utils.RigidTransform rtWristRight = WaveVR_Utils.RigidTransform.identity;

	private void DEBUG(string msg)
	{
		if (WVR_Log.Log.EnableDebugLog)
		{
			WVR_Log.Log.d("WaveVR_BonePoseImpl", msg, logInEditor: true);
		}
	}

	public WaveVR_BonePoseImpl()
	{
		DEBUG("WaveVR_BonePoseImpl()");
		boneDatas = new BoneData[Enum.GetNames(typeof(Bones)).Length];
		for (int i = 0; i < Enum.GetNames(typeof(Bones)).Length; i++)
		{
			boneDatas[i] = new BoneData();
			boneDatas[i].SetValidPose(in_valid: false);
		}
	}

	private bool AllowGetTrackingData()
	{
		if (Time.frameCount != prevFrame_tracking)
		{
			prevFrame_tracking = Time.frameCount;
			return true;
		}
		return false;
	}

	public WaveVR_Utils.RigidTransform GetBoneTransform(Bones bone_type)
	{
		if (AllowGetTrackingData())
		{
			hasHandTrackingData = WaveVR_GestureManager.Instance.GetHandTrackingData(ref handTrackingData, WaveVR_Render.Instance.origin, 0u);
			if (hasHandTrackingData)
			{
				if (handTrackingData.left.IsValidPose)
				{
					UpdateLeftHandTrackingData();
				}
				if (handTrackingData.right.IsValidPose)
				{
					UpdateRightHandTrackingData();
				}
			}
		}
		return boneDatas[(int)bone_type].GetTransform();
	}

	public bool IsBonePoseValid(Bones bone_type)
	{
		for (int i = 0; i < leftBones.Length; i++)
		{
			if (leftBones[i] == bone_type)
			{
				return IsHandPoseValid(WaveVR_GestureManager.EGestureHand.LEFT);
			}
		}
		for (int j = 0; j < rightBones.Length; j++)
		{
			if (rightBones[j] == bone_type)
			{
				return IsHandPoseValid(WaveVR_GestureManager.EGestureHand.RIGHT);
			}
		}
		return false;
	}

	public bool IsHandPoseValid(WaveVR_GestureManager.EGestureHand hand)
	{
		if (hasHandTrackingData)
		{
			switch (hand)
			{
			case WaveVR_GestureManager.EGestureHand.LEFT:
				return handTrackingData.left.IsValidPose;
			case WaveVR_GestureManager.EGestureHand.RIGHT:
				return handTrackingData.right.IsValidPose;
			}
		}
		return false;
	}

	private void UpdateLeftHandTrackingData()
	{
		rtWristLeft.update(handTrackingData.left.PoseMatrix);
		Vector3 pos = rtWristLeft.pos;
		Quaternion rot = rtWristLeft.rot;
		boneDatas[1].SetPosition(pos);
		boneDatas[1].SetRotation(rot);
		boneDatas[1].SetValidPose(handTrackingData.left.IsValidPose);
		Vector3 position = WaveVR_Utils.GetPosition(handTrackingData.leftFinger.thumb.joint1);
		Quaternion rotation = Quaternion.LookRotation(position - pos);
		boneDatas[2].SetPosition(position);
		boneDatas[2].SetRotation(rotation);
		boneDatas[2].SetValidPose(handTrackingData.left.IsValidPose);
		Vector3 position2 = WaveVR_Utils.GetPosition(handTrackingData.leftFinger.thumb.joint2);
		Quaternion rotation2 = Quaternion.LookRotation(position2 - position);
		boneDatas[3].SetPosition(position2);
		boneDatas[3].SetRotation(rotation2);
		boneDatas[3].SetValidPose(handTrackingData.left.IsValidPose);
		Vector3 position3 = WaveVR_Utils.GetPosition(handTrackingData.leftFinger.thumb.joint3);
		Quaternion rotation3 = Quaternion.LookRotation(position3 - position2);
		boneDatas[4].SetPosition(position3);
		boneDatas[4].SetRotation(rotation3);
		boneDatas[4].SetValidPose(handTrackingData.left.IsValidPose);
		Vector3 position4 = WaveVR_Utils.GetPosition(handTrackingData.leftFinger.thumb.tip);
		Quaternion rotation4 = Quaternion.LookRotation(position4 - position3);
		boneDatas[5].SetPosition(position4);
		boneDatas[5].SetRotation(rotation4);
		boneDatas[5].SetValidPose(handTrackingData.left.IsValidPose);
		Vector3 position5 = WaveVR_Utils.GetPosition(handTrackingData.leftFinger.index.joint1);
		Quaternion rotation5 = Quaternion.LookRotation(position5 - pos);
		boneDatas[6].SetPosition(position5);
		boneDatas[6].SetRotation(rotation5);
		boneDatas[6].SetValidPose(handTrackingData.left.IsValidPose);
		Vector3 position6 = WaveVR_Utils.GetPosition(handTrackingData.leftFinger.index.joint2);
		Quaternion rotation6 = Quaternion.LookRotation(position6 - position5);
		boneDatas[7].SetPosition(position6);
		boneDatas[7].SetRotation(rotation6);
		boneDatas[7].SetValidPose(handTrackingData.left.IsValidPose);
		Vector3 position7 = WaveVR_Utils.GetPosition(handTrackingData.leftFinger.index.joint3);
		Quaternion rotation7 = Quaternion.LookRotation(position7, position6);
		boneDatas[8].SetPosition(position7);
		boneDatas[8].SetRotation(rotation7);
		boneDatas[8].SetValidPose(handTrackingData.left.IsValidPose);
		Vector3 position8 = WaveVR_Utils.GetPosition(handTrackingData.leftFinger.index.tip);
		Quaternion rotation8 = Quaternion.LookRotation(position8 - position7);
		boneDatas[9].SetPosition(position8);
		boneDatas[9].SetRotation(rotation8);
		boneDatas[9].SetValidPose(handTrackingData.left.IsValidPose);
		Vector3 position9 = WaveVR_Utils.GetPosition(handTrackingData.leftFinger.middle.joint1);
		Quaternion rotation9 = Quaternion.LookRotation(position9 - pos);
		boneDatas[10].SetPosition(position9);
		boneDatas[10].SetRotation(rotation9);
		boneDatas[10].SetValidPose(handTrackingData.left.IsValidPose);
		Vector3 position10 = WaveVR_Utils.GetPosition(handTrackingData.leftFinger.middle.joint2);
		Quaternion rotation10 = Quaternion.LookRotation(position10 - position9);
		boneDatas[11].SetPosition(position10);
		boneDatas[11].SetRotation(rotation10);
		boneDatas[11].SetValidPose(handTrackingData.left.IsValidPose);
		Vector3 position11 = WaveVR_Utils.GetPosition(handTrackingData.leftFinger.middle.joint3);
		Quaternion rotation11 = Quaternion.LookRotation(position11 - position10);
		boneDatas[12].SetPosition(position11);
		boneDatas[12].SetRotation(rotation11);
		boneDatas[12].SetValidPose(handTrackingData.left.IsValidPose);
		Vector3 position12 = WaveVR_Utils.GetPosition(handTrackingData.leftFinger.middle.tip);
		Quaternion rotation12 = Quaternion.LookRotation(position12 - position11);
		boneDatas[13].SetPosition(position12);
		boneDatas[13].SetRotation(rotation12);
		boneDatas[13].SetValidPose(handTrackingData.left.IsValidPose);
		Vector3 position13 = WaveVR_Utils.GetPosition(handTrackingData.leftFinger.ring.joint1);
		Quaternion rotation13 = Quaternion.LookRotation(position13 - pos);
		boneDatas[14].SetPosition(position13);
		boneDatas[14].SetRotation(rotation13);
		boneDatas[14].SetValidPose(handTrackingData.left.IsValidPose);
		Vector3 position14 = WaveVR_Utils.GetPosition(handTrackingData.leftFinger.ring.joint2);
		Quaternion rotation14 = Quaternion.LookRotation(position14 - position13);
		boneDatas[15].SetPosition(position14);
		boneDatas[15].SetRotation(rotation14);
		boneDatas[15].SetValidPose(handTrackingData.left.IsValidPose);
		Vector3 position15 = WaveVR_Utils.GetPosition(handTrackingData.leftFinger.ring.joint3);
		Quaternion rotation15 = Quaternion.LookRotation(position15 - position14);
		boneDatas[16].SetPosition(position15);
		boneDatas[16].SetRotation(rotation15);
		boneDatas[16].SetValidPose(handTrackingData.left.IsValidPose);
		Vector3 position16 = WaveVR_Utils.GetPosition(handTrackingData.leftFinger.ring.tip);
		Quaternion rotation16 = Quaternion.LookRotation(position16 - position15);
		boneDatas[17].SetPosition(position16);
		boneDatas[17].SetRotation(rotation16);
		boneDatas[17].SetValidPose(handTrackingData.left.IsValidPose);
		Vector3 position17 = WaveVR_Utils.GetPosition(handTrackingData.leftFinger.pinky.joint1);
		Quaternion rotation17 = Quaternion.LookRotation(position17 - pos);
		boneDatas[18].SetPosition(position17);
		boneDatas[18].SetRotation(rotation17);
		boneDatas[18].SetValidPose(handTrackingData.left.IsValidPose);
		Vector3 position18 = WaveVR_Utils.GetPosition(handTrackingData.leftFinger.pinky.joint2);
		Quaternion rotation18 = Quaternion.LookRotation(position18 - position17);
		boneDatas[19].SetPosition(position18);
		boneDatas[19].SetRotation(rotation18);
		boneDatas[19].SetValidPose(handTrackingData.left.IsValidPose);
		Vector3 position19 = WaveVR_Utils.GetPosition(handTrackingData.leftFinger.pinky.joint3);
		Quaternion rotation19 = Quaternion.LookRotation(position19 - position18);
		boneDatas[20].SetPosition(position19);
		boneDatas[20].SetRotation(rotation19);
		boneDatas[20].SetValidPose(handTrackingData.left.IsValidPose);
		Vector3 position20 = WaveVR_Utils.GetPosition(handTrackingData.leftFinger.pinky.tip);
		Quaternion rotation20 = Quaternion.LookRotation(position20 - position19);
		boneDatas[21].SetPosition(position20);
		boneDatas[21].SetRotation(rotation20);
		boneDatas[21].SetValidPose(handTrackingData.left.IsValidPose);
	}

	private void UpdateRightHandTrackingData()
	{
		rtWristRight.update(handTrackingData.right.PoseMatrix);
		Vector3 pos = rtWristRight.pos;
		Quaternion rot = rtWristRight.rot;
		boneDatas[22].SetPosition(pos);
		boneDatas[22].SetRotation(rot);
		boneDatas[22].SetValidPose(handTrackingData.right.IsValidPose);
		Vector3 position = WaveVR_Utils.GetPosition(handTrackingData.rightFinger.thumb.joint1);
		Quaternion rotation = Quaternion.LookRotation(position - pos);
		boneDatas[23].SetPosition(position);
		boneDatas[23].SetRotation(rotation);
		boneDatas[23].SetValidPose(handTrackingData.right.IsValidPose);
		Vector3 position2 = WaveVR_Utils.GetPosition(handTrackingData.rightFinger.thumb.joint2);
		Quaternion rotation2 = Quaternion.LookRotation(position2 - position);
		boneDatas[24].SetPosition(position2);
		boneDatas[24].SetRotation(rotation2);
		boneDatas[24].SetValidPose(handTrackingData.right.IsValidPose);
		Vector3 position3 = WaveVR_Utils.GetPosition(handTrackingData.rightFinger.thumb.joint3);
		Quaternion rotation3 = Quaternion.LookRotation(position3 - position2);
		boneDatas[25].SetPosition(position3);
		boneDatas[25].SetRotation(rotation3);
		boneDatas[25].SetValidPose(handTrackingData.right.IsValidPose);
		Vector3 position4 = WaveVR_Utils.GetPosition(handTrackingData.rightFinger.thumb.tip);
		Quaternion rotation4 = Quaternion.LookRotation(position4 - position3);
		boneDatas[26].SetPosition(position4);
		boneDatas[26].SetRotation(rotation4);
		boneDatas[26].SetValidPose(handTrackingData.right.IsValidPose);
		Vector3 position5 = WaveVR_Utils.GetPosition(handTrackingData.rightFinger.index.joint1);
		Quaternion rotation5 = Quaternion.LookRotation(position5 - pos);
		boneDatas[27].SetPosition(position5);
		boneDatas[27].SetRotation(rotation5);
		boneDatas[27].SetValidPose(handTrackingData.right.IsValidPose);
		Vector3 position6 = WaveVR_Utils.GetPosition(handTrackingData.rightFinger.index.joint2);
		Quaternion rotation6 = Quaternion.LookRotation(position6 - position5);
		boneDatas[28].SetPosition(position6);
		boneDatas[28].SetRotation(rotation6);
		boneDatas[28].SetValidPose(handTrackingData.right.IsValidPose);
		Vector3 position7 = WaveVR_Utils.GetPosition(handTrackingData.rightFinger.index.joint3);
		Quaternion rotation7 = Quaternion.LookRotation(position7, position6);
		boneDatas[29].SetPosition(position7);
		boneDatas[29].SetRotation(rotation7);
		boneDatas[29].SetValidPose(handTrackingData.right.IsValidPose);
		Vector3 position8 = WaveVR_Utils.GetPosition(handTrackingData.rightFinger.index.tip);
		Quaternion rotation8 = Quaternion.LookRotation(position8 - position7);
		boneDatas[30].SetPosition(position8);
		boneDatas[30].SetRotation(rotation8);
		boneDatas[30].SetValidPose(handTrackingData.right.IsValidPose);
		Vector3 position9 = WaveVR_Utils.GetPosition(handTrackingData.rightFinger.middle.joint1);
		Quaternion rotation9 = Quaternion.LookRotation(position9 - pos);
		boneDatas[31].SetPosition(position9);
		boneDatas[31].SetRotation(rotation9);
		boneDatas[31].SetValidPose(handTrackingData.right.IsValidPose);
		Vector3 position10 = WaveVR_Utils.GetPosition(handTrackingData.rightFinger.middle.joint2);
		Quaternion rotation10 = Quaternion.LookRotation(position10 - position9);
		boneDatas[32].SetPosition(position10);
		boneDatas[32].SetRotation(rotation10);
		boneDatas[32].SetValidPose(handTrackingData.right.IsValidPose);
		Vector3 position11 = WaveVR_Utils.GetPosition(handTrackingData.rightFinger.middle.joint3);
		Quaternion rotation11 = Quaternion.LookRotation(position11 - position10);
		boneDatas[33].SetPosition(position11);
		boneDatas[33].SetRotation(rotation11);
		boneDatas[33].SetValidPose(handTrackingData.right.IsValidPose);
		Vector3 position12 = WaveVR_Utils.GetPosition(handTrackingData.rightFinger.middle.tip);
		Quaternion rotation12 = Quaternion.LookRotation(position12 - position11);
		boneDatas[34].SetPosition(position12);
		boneDatas[34].SetRotation(rotation12);
		boneDatas[34].SetValidPose(handTrackingData.right.IsValidPose);
		Vector3 position13 = WaveVR_Utils.GetPosition(handTrackingData.rightFinger.ring.joint1);
		Quaternion rotation13 = Quaternion.LookRotation(position13 - pos);
		boneDatas[35].SetPosition(position13);
		boneDatas[35].SetRotation(rotation13);
		boneDatas[35].SetValidPose(handTrackingData.right.IsValidPose);
		Vector3 position14 = WaveVR_Utils.GetPosition(handTrackingData.rightFinger.ring.joint2);
		Quaternion rotation14 = Quaternion.LookRotation(position14 - position13);
		boneDatas[36].SetPosition(position14);
		boneDatas[36].SetRotation(rotation14);
		boneDatas[36].SetValidPose(handTrackingData.right.IsValidPose);
		Vector3 position15 = WaveVR_Utils.GetPosition(handTrackingData.rightFinger.ring.joint3);
		Quaternion rotation15 = Quaternion.LookRotation(position15 - position14);
		boneDatas[37].SetPosition(position15);
		boneDatas[37].SetRotation(rotation15);
		boneDatas[37].SetValidPose(handTrackingData.right.IsValidPose);
		Vector3 position16 = WaveVR_Utils.GetPosition(handTrackingData.rightFinger.ring.tip);
		Quaternion rotation16 = Quaternion.LookRotation(position16 - position15);
		boneDatas[38].SetPosition(position16);
		boneDatas[38].SetRotation(rotation16);
		boneDatas[38].SetValidPose(handTrackingData.right.IsValidPose);
		Vector3 position17 = WaveVR_Utils.GetPosition(handTrackingData.rightFinger.pinky.joint1);
		Quaternion rotation17 = Quaternion.LookRotation(position17 - pos);
		boneDatas[39].SetPosition(position17);
		boneDatas[39].SetRotation(rotation17);
		boneDatas[39].SetValidPose(handTrackingData.right.IsValidPose);
		Vector3 position18 = WaveVR_Utils.GetPosition(handTrackingData.rightFinger.pinky.joint2);
		Quaternion rotation18 = Quaternion.LookRotation(position18 - position17);
		boneDatas[40].SetPosition(position18);
		boneDatas[40].SetRotation(rotation18);
		boneDatas[40].SetValidPose(handTrackingData.right.IsValidPose);
		Vector3 position19 = WaveVR_Utils.GetPosition(handTrackingData.rightFinger.pinky.joint3);
		Quaternion rotation19 = Quaternion.LookRotation(position19 - position18);
		boneDatas[41].SetPosition(position19);
		boneDatas[41].SetRotation(rotation19);
		boneDatas[41].SetValidPose(handTrackingData.right.IsValidPose);
		Vector3 position20 = WaveVR_Utils.GetPosition(handTrackingData.rightFinger.pinky.tip);
		Quaternion rotation20 = Quaternion.LookRotation(position20 - position19);
		boneDatas[42].SetPosition(position20);
		boneDatas[42].SetRotation(rotation20);
		boneDatas[42].SetValidPose(handTrackingData.right.IsValidPose);
	}
}
public class WaveVR_GestureManager : MonoBehaviour
{
	public enum EGestureHand
	{
		RIGHT,
		LEFT
	}

	public enum EStaticGestures
	{
		FIST = 2,
		FIVE,
		OK,
		THUMBUP,
		INDEXUP
	}

	private const string LOG_TAG = "WaveVR_GestureManager";

	private static WaveVR_GestureManager instance = null;

	[HideInInspector]
	public static EGestureHand GestureFocusHand = EGestureHand.RIGHT;

	public bool EnableHandGesture = true;

	private bool preEnableHandGesture = true;

	private WVR_HandGestureData_t handGestureData;

	public bool EnableHandTracking = true;

	private bool preEnableHandTracking = true;

	private bool hasHandGesture;

	private WVR_HandGestureType prevStaticGestureLeft;

	private WVR_HandGestureType currStaticGestureLeft;

	private WVR_HandGestureType prevStaticGestureRight;

	private WVR_HandGestureType currStaticGestureRight;

	private WaveVR_Utils.HandGestureStatus handGestureStatus;

	private static ReaderWriterLockSlim handGestureStatusRWLock = new ReaderWriterLockSlim();

	private object handGestureThreadLock = new object();

	private WaveVR_Utils.HandTrackingStatus handTrackingStatus;

	private static ReaderWriterLockSlim handTrackingStatusRWLock = new ReaderWriterLockSlim();

	private object handTrackingThreadLocker = new object();

	public static WaveVR_GestureManager Instance => instance;

	private event WaveVR_Utils.HandGestureResultDelegate handGestureResultCB;

	private event WaveVR_Utils.HandTrackingResultDelegate handTrackingResultCB;

	private void DEBUG(string msg)
	{
		if (WVR_Log.Log.EnableDebugLog)
		{
			WVR_Log.Log.d("WaveVR_GestureManager", msg, logInEditor: true);
		}
	}

	private void Awake()
	{
		if (instance == null)
		{
			instance = this;
		}
	}

	private void Start()
	{
		preEnableHandGesture = EnableHandGesture;
		if (EnableHandGesture)
		{
			DEBUG("Start() Start hand gesture.");
			StartHandGesture();
		}
		preEnableHandTracking = EnableHandTracking;
		if (EnableHandTracking)
		{
			DEBUG("Start() Start hand tracking.");
			StartHandTracking();
		}
	}

	private void Update()
	{
		if (preEnableHandGesture != EnableHandGesture)
		{
			preEnableHandGesture = EnableHandGesture;
			if (EnableHandGesture)
			{
				DEBUG("Update() Start hand gesture.");
				StartHandGesture();
			}
			if (!EnableHandGesture)
			{
				DEBUG("Update() Stop hand gesture.");
				StopHandGesture();
			}
		}
		if (preEnableHandTracking != EnableHandTracking)
		{
			preEnableHandTracking = EnableHandTracking;
			if (EnableHandTracking)
			{
				DEBUG("Update() Start hand tracking.");
				StartHandTracking();
			}
			if (!EnableHandTracking)
			{
				DEBUG("Update() Stop hand tracking.");
				StopHandTracking();
			}
		}
		hasHandGesture = GetHandGestureData(ref handGestureData);
		if (hasHandGesture)
		{
			UpdateLeftHandGestureData(handGestureData);
			UpdateRightHandGestureData(handGestureData);
		}
	}

	private void OnEnable()
	{
		WaveVR_Utils.Event.Listen(WaveVR_Utils.Event.ALL_VREVENT, OnEvent);
	}

	private void OnDisable()
	{
		WaveVR_Utils.Event.Remove(WaveVR_Utils.Event.ALL_VREVENT, OnEvent);
	}

	private void UpdateLeftHandGestureData(WVR_HandGestureData_t data)
	{
		prevStaticGestureLeft = currStaticGestureLeft;
		currStaticGestureLeft = data.left;
		if (currStaticGestureLeft != prevStaticGestureLeft)
		{
			DEBUG("UpdateLeftHandGestureData() Receives " + currStaticGestureLeft);
			WaveVR_Utils.Event.Send(WaveVR_Utils.Event.HAND_STATIC_GESTURE_LEFT, currStaticGestureLeft);
		}
	}

	public WVR_HandGestureType GetCurrentLeftHandStaticGesture()
	{
		return currStaticGestureLeft;
	}

	private void UpdateRightHandGestureData(WVR_HandGestureData_t data)
	{
		prevStaticGestureRight = currStaticGestureRight;
		currStaticGestureRight = data.right;
		if (currStaticGestureRight != prevStaticGestureRight)
		{
			DEBUG("UpdateLeftHandGestureData() Receives " + currStaticGestureRight);
			WaveVR_Utils.Event.Send(WaveVR_Utils.Event.HAND_STATIC_GESTURE_RIGHT, currStaticGestureRight);
		}
	}

	public WVR_HandGestureType GetCurrentRightHandStaticGesture()
	{
		return currStaticGestureRight;
	}

	private void OnEvent(params object[] args)
	{
		switch (((WVR_Event_t)args[0]).common.type)
		{
		case WVR_EventType.WVR_EventType_HandGesture_Abnormal:
			DEBUG("OnEvent() WVR_EventType_HandGesture_Abnormal, restart the hand gesture component.");
			RestartHandGesture();
			break;
		case WVR_EventType.WVR_EventType_HandTracking_Abnormal:
			DEBUG("OnEvent() WVR_EventType_HandTracking_Abnormal, restart the hand tracking component.");
			RestartHandTracking();
			break;
		}
	}

	private void SetHandGestureStatus(WaveVR_Utils.HandGestureStatus status)
	{
		try
		{
			handGestureStatusRWLock.TryEnterWriteLock(2000);
			handGestureStatus = status;
		}
		catch (Exception ex)
		{
			WVR_Log.Log.e("WaveVR_GestureManager", "SetHandGestureStatus() " + ex.Message, logInEditor: true);
			throw;
		}
		finally
		{
			handGestureStatusRWLock.ExitWriteLock();
		}
	}

	public WaveVR_Utils.HandGestureStatus GetHandGestureStatus()
	{
		if ((WaveVR.Instance.GetSupportedFeatures() & 0x20) == 0L)
		{
			return WaveVR_Utils.HandGestureStatus.UNSUPPORT;
		}
		try
		{
			handGestureStatusRWLock.TryEnterReadLock(2000);
			return handGestureStatus;
		}
		catch (Exception ex)
		{
			WVR_Log.Log.e("WaveVR_GestureManager", "GetHandGestureStatus() " + ex.Message, logInEditor: true);
			throw;
		}
		finally
		{
			handGestureStatusRWLock.ExitReadLock();
		}
	}

	private void StartHandGestureLock()
	{
		bool flag = false;
		if (WaveVR.Instance.IsHandGestureEnabled())
		{
			flag = true;
			SetHandGestureStatus(WaveVR_Utils.HandGestureStatus.AVAILABLE);
		}
		WaveVR_Utils.HandGestureStatus handGestureStatus = GetHandGestureStatus();
		if (EnableHandGesture && (handGestureStatus == WaveVR_Utils.HandGestureStatus.NOT_START || handGestureStatus == WaveVR_Utils.HandGestureStatus.START_FAILURE))
		{
			SetHandGestureStatus(WaveVR_Utils.HandGestureStatus.STARTING);
			flag = WaveVR.Instance.StartHandGesture();
			SetHandGestureStatus((!flag) ? WaveVR_Utils.HandGestureStatus.START_FAILURE : WaveVR_Utils.HandGestureStatus.AVAILABLE);
		}
		handGestureStatus = GetHandGestureStatus();
		DEBUG("StartHandGestureLock() " + flag.ToString() + ", status: " + handGestureStatus);
		WaveVR_Utils.Event.Send(WaveVR_Utils.Event.HAND_GESTURE_STATUS, handGestureStatus);
		if (this.handGestureResultCB != null)
		{
			this.handGestureResultCB(this, flag);
			this.handGestureResultCB = null;
		}
	}

	private void StartHandGestureThread()
	{
		lock (handGestureThreadLock)
		{
			DEBUG("StartHandGestureThread()");
			StartHandGestureLock();
		}
	}

	private void StartHandGesture()
	{
		new Thread(StartHandGestureThread).Start();
	}

	private void StopHandGestureLock()
	{
		if (!WaveVR.Instance.IsHandGestureEnabled())
		{
			SetHandGestureStatus(WaveVR_Utils.HandGestureStatus.NOT_START);
		}
		WaveVR_Utils.HandGestureStatus handGestureStatus = GetHandGestureStatus();
		if (handGestureStatus == WaveVR_Utils.HandGestureStatus.AVAILABLE)
		{
			DEBUG("StopHandGestureLock()");
			SetHandGestureStatus(WaveVR_Utils.HandGestureStatus.STOPING);
			WaveVR.Instance.StopHandGesture();
			SetHandGestureStatus(WaveVR_Utils.HandGestureStatus.NOT_START);
		}
		handGestureStatus = GetHandGestureStatus();
		WaveVR_Utils.Event.Send(WaveVR_Utils.Event.HAND_GESTURE_STATUS, handGestureStatus);
	}

	private void StopHandGestureThread()
	{
		lock (handGestureThreadLock)
		{
			DEBUG("StopHandGestureThread()");
			StopHandGestureLock();
		}
	}

	private void StopHandGesture()
	{
		new Thread(StopHandGestureThread).Start();
	}

	private void RestartHandGestureThread()
	{
		lock (handGestureThreadLock)
		{
			DEBUG("RestartHandGestureThread()");
			StopHandGestureLock();
			StartHandGestureLock();
		}
	}

	public void RestartHandGesture()
	{
		new Thread(RestartHandGestureThread).Start();
	}

	public void RestartHandGesture(WaveVR_Utils.HandGestureResultDelegate callback)
	{
		if (this.handGestureResultCB == null)
		{
			this.handGestureResultCB = callback;
		}
		else
		{
			handGestureResultCB += callback;
		}
		RestartHandGesture();
	}

	private bool GetHandGestureData(ref WVR_HandGestureData_t data)
	{
		bool result = false;
		if (GetHandGestureStatus() == WaveVR_Utils.HandGestureStatus.AVAILABLE)
		{
			result = WaveVR.Instance.GetHandGestureData(ref data);
		}
		return result;
	}

	private void SetHandTrackingStatus(WaveVR_Utils.HandTrackingStatus status)
	{
		try
		{
			handTrackingStatusRWLock.TryEnterWriteLock(2000);
			handTrackingStatus = status;
		}
		catch (Exception ex)
		{
			WVR_Log.Log.e("WaveVR_GestureManager", "SetHandTrackingStatus() " + ex.Message, logInEditor: true);
			throw;
		}
		finally
		{
			handTrackingStatusRWLock.ExitWriteLock();
		}
	}

	public WaveVR_Utils.HandTrackingStatus GetHandTrackingStatus()
	{
		if ((WaveVR.Instance.GetSupportedFeatures() & 0x10) == 0L)
		{
			return WaveVR_Utils.HandTrackingStatus.UNSUPPORT;
		}
		try
		{
			handTrackingStatusRWLock.TryEnterReadLock(2000);
			return handTrackingStatus;
		}
		catch (Exception ex)
		{
			WVR_Log.Log.e("WaveVR_GestureManager", "GetHandTrackingStatus() " + ex.Message, logInEditor: true);
			throw;
		}
		finally
		{
			handTrackingStatusRWLock.ExitReadLock();
		}
	}

	private void StartHandTrackingLock()
	{
		bool flag = false;
		if (WaveVR.Instance.IsHandTrackingEnabled())
		{
			flag = true;
			SetHandTrackingStatus(WaveVR_Utils.HandTrackingStatus.AVAILABLE);
		}
		WaveVR_Utils.HandTrackingStatus handTrackingStatus = GetHandTrackingStatus();
		if (EnableHandTracking && (handTrackingStatus == WaveVR_Utils.HandTrackingStatus.NOT_START || handTrackingStatus == WaveVR_Utils.HandTrackingStatus.START_FAILURE))
		{
			SetHandTrackingStatus(WaveVR_Utils.HandTrackingStatus.STARTING);
			flag = WaveVR.Instance.StartHandTracking();
			SetHandTrackingStatus((!flag) ? WaveVR_Utils.HandTrackingStatus.START_FAILURE : WaveVR_Utils.HandTrackingStatus.AVAILABLE);
		}
		handTrackingStatus = GetHandTrackingStatus();
		DEBUG("StartHandTrackingLock() " + flag.ToString() + ", status: " + handTrackingStatus);
		WaveVR_Utils.Event.Send(WaveVR_Utils.Event.HAND_TRACKING_STATUS, handTrackingStatus);
		if (this.handTrackingResultCB != null)
		{
			this.handTrackingResultCB(this, flag);
			this.handTrackingResultCB = null;
		}
	}

	private void StartHandTrackingThread()
	{
		lock (handTrackingThreadLocker)
		{
			DEBUG("StartHandTrackingThread()");
			StartHandTrackingLock();
		}
	}

	private void StartHandTracking()
	{
		new Thread(StartHandTrackingThread).Start();
	}

	private void StopHandTrackingLock()
	{
		if (!WaveVR.Instance.IsHandTrackingEnabled())
		{
			SetHandTrackingStatus(WaveVR_Utils.HandTrackingStatus.NOT_START);
		}
		WaveVR_Utils.HandTrackingStatus handTrackingStatus = GetHandTrackingStatus();
		if (handTrackingStatus == WaveVR_Utils.HandTrackingStatus.AVAILABLE)
		{
			DEBUG("StopHandTrackingLock()");
			SetHandTrackingStatus(WaveVR_Utils.HandTrackingStatus.STOPING);
			WaveVR.Instance.StopHandTracking();
			SetHandTrackingStatus(WaveVR_Utils.HandTrackingStatus.NOT_START);
		}
		handTrackingStatus = GetHandTrackingStatus();
		WaveVR_Utils.Event.Send(WaveVR_Utils.Event.HAND_TRACKING_STATUS, handTrackingStatus);
	}

	private void StopHandTrackingThread()
	{
		lock (handTrackingThreadLocker)
		{
			DEBUG("StopHandTrackingThread()");
			StopHandTrackingLock();
		}
	}

	private void StopHandTracking()
	{
		new Thread(StopHandTrackingThread).Start();
	}

	private void RestartHandTrackingThread()
	{
		lock (handTrackingThreadLocker)
		{
			DEBUG("RestartHandTrackingThread()");
			StopHandTrackingLock();
			StartHandTrackingLock();
		}
	}

	public void RestartHandTracking()
	{
		new Thread(RestartHandTrackingThread).Start();
	}

	public void RestartHandTracking(WaveVR_Utils.HandTrackingResultDelegate callback)
	{
		if (this.handTrackingResultCB == null)
		{
			this.handTrackingResultCB = callback;
		}
		else
		{
			handTrackingResultCB += callback;
		}
		RestartHandTracking();
	}

	public bool GetHandTrackingData(ref WVR_HandTrackingData_t data, WVR_PoseOriginModel originModel, uint predictedMilliSec)
	{
		bool result = false;
		if (GetHandTrackingStatus() == WaveVR_Utils.HandTrackingStatus.AVAILABLE)
		{
			result = WaveVR.Instance.GetHandTrackingData(ref data, originModel, predictedMilliSec);
		}
		return result;
	}
}
public class WaveVR_ControllerPoseTracker : MonoBehaviour
{
	private static string LOG_TAG = "WaveVR_ControllerPoseTracker";

	public WaveVR_Controller.EDeviceType Type;

	public bool InversePosition;

	public bool TrackPosition = true;

	public WVR_SimulationOption SimulationOption;

	private WVR_SimulationOption currSimulationOption;

	private bool bSetupSimulation;

	public bool FollowHead;

	private bool currFollowHead;

	private bool bSetupFollowHead;

	public bool InverseRotation;

	public bool TrackRotation = true;

	public WVR_TrackTiming TrackTiming = WVR_TrackTiming.WhenNewPoses;

	[HideInInspector]
	public bool ApplyNeckOffset;

	[Range(0f, 0.2f)]
	public float ElbowRaiseYaxis;

	[Range(0f, 0.4f)]
	public float ElbowRaiseZaxis;

	private GameObject Head;

	[HideInInspector]
	private bool SetCustomHand;

	private bool cptEnabled;

	private WVR_DevicePosePair_t wvr_pose;

	private WaveVR_Utils.RigidTransform rigid_pose = WaveVR_Utils.RigidTransform.identity;

	private Vector3 v3ChangeAxisX = new Vector3(1f, 1f, 1f);

	private const float BodyAngularVelocityUpperBound = 0.2f;

	private const float ControllerAngularVelocityUpperBound = 30f;

	private void PrintDebugLog(string msg)
	{
		if (WVR_Log.Log.EnableDebugLog)
		{
			WVR_Log.Log.d(LOG_TAG, msg);
		}
	}

	private void PrintErrorLog(string msg)
	{
		WVR_Log.Log.e(LOG_TAG, string.Concat(Type, ", ", msg));
	}

	private void OnEnable()
	{
		if (!cptEnabled)
		{
			if (Head == null && WaveVR_Render.Instance != null)
			{
				Head = WaveVR_Render.Instance.gameObject;
			}
			if (TrackTiming == WVR_TrackTiming.WhenNewPoses)
			{
				WaveVR_Utils.Event.Listen(WaveVR_Utils.Event.NEW_POSES, OnNewPoses);
			}
			SetupPoseSimulation();
			cptEnabled = true;
			PrintDebugLog(string.Concat("OnEnable() ", Type, ", TrackPosition: ", TrackPosition.ToString(), ", SimulationOption: ", SimulationOption, ", FollowHead: ", FollowHead.ToString(), ", TrackRotation: ", TrackRotation.ToString(), ", TrackTiming: ", TrackTiming));
		}
	}

	private void OnDisable()
	{
		PrintDebugLog(string.Concat("OnDisable()", Type, "\nLocal Pos: ", base.transform.localPosition.x, ", ", base.transform.localPosition.y, ", ", base.transform.localPosition.z, "\nPos: ", base.transform.position.x, ", ", base.transform.position.y, ", ", base.transform.position.z, "\nLocal rot: ", base.transform.localRotation.x, ", ", base.transform.localRotation.y, ", ", base.transform.localRotation.z));
		if (TrackTiming == WVR_TrackTiming.WhenNewPoses)
		{
			WaveVR_Utils.Event.Remove(WaveVR_Utils.Event.NEW_POSES, OnNewPoses);
		}
		bSetupSimulation = false;
		bSetupFollowHead = false;
		cptEnabled = false;
	}

	private void Update()
	{
		if (FollowHead != currFollowHead)
		{
			bSetupFollowHead = false;
		}
		if (SimulationOption != currSimulationOption)
		{
			bSetupSimulation = false;
		}
		SetupPoseSimulation();
		if (TrackTiming != WVR_TrackTiming.WhenNewPoses && WaveVR.Instance.Initialized)
		{
			WaveVR.Device deviceByType = WaveVR.Instance.getDeviceByType(Type);
			if (deviceByType.connected)
			{
				wvr_pose = deviceByType.pose;
				rigid_pose = deviceByType.rigidTransform;
			}
			updateDevicePose(wvr_pose, rigid_pose);
		}
	}

	private void SetupPoseSimulation()
	{
		if (!WaveVR.Instance.Initialized)
		{
			return;
		}
		if (!bSetupSimulation)
		{
			currSimulationOption = SimulationOption;
			if (currSimulationOption == WVR_SimulationOption.WhenNoPosition)
			{
				WaveVR.Instance.SetPoseSimulation(WVR_SimulationType.WVR_SimulationType_Auto);
			}
			else if (currSimulationOption == WVR_SimulationOption.ForceSimulation)
			{
				WaveVR.Instance.SetPoseSimulation(WVR_SimulationType.WVR_SimulationType_ForceOn);
			}
			else
			{
				WaveVR.Instance.SetPoseSimulation(WVR_SimulationType.WVR_SimulationType_ForceOff);
			}
			bSetupSimulation = true;
			PrintDebugLog(string.Concat("SetupPoseSimulation() ", Type, ", simulation option: ", currSimulationOption));
		}
		if (!bSetupFollowHead)
		{
			currFollowHead = FollowHead;
			WaveVR.Instance.SetPoseSimulationFollowHead(currFollowHead);
			bSetupFollowHead = true;
			PrintDebugLog(string.Concat("SetupPoseSimulation() ", Type, ", follow head: ", currFollowHead.ToString()));
		}
	}

	private void OnNewPoses(params object[] args)
	{
		WVR_DevicePosePair_t[] array = (WVR_DevicePosePair_t[])args[0];
		WaveVR_Utils.RigidTransform[] array2 = (WaveVR_Utils.RigidTransform[])args[1];
		WVR_DeviceType deviceType = WaveVR_Controller.Input(Type).DeviceType;
		for (int i = 0; i < array.Length; i++)
		{
			if (deviceType == array[i].type)
			{
				wvr_pose = array[i];
				rigid_pose = array2[i];
			}
		}
		updateDevicePose(wvr_pose, rigid_pose);
	}

	private void updateDevicePose(WVR_DevicePosePair_t pose, WaveVR_Utils.RigidTransform rtPose)
	{
		if (TrackPosition)
		{
			if (InversePosition)
			{
				base.transform.localPosition = -rtPose.pos;
			}
			else
			{
				base.transform.localPosition = rtPose.pos;
			}
			if (SetCustomHand && !pose.pose.Is6DoFPose)
			{
				v3ChangeAxisX.x = ((WaveVR_Controller.Input(Type).DeviceType == WVR_DeviceType.WVR_DeviceType_Controller_Right) ? 1 : (-1));
				base.transform.localPosition = Vector3.Scale(base.transform.localPosition, v3ChangeAxisX);
			}
		}
		if (TrackRotation)
		{
			if (InverseRotation)
			{
				base.transform.localRotation = Quaternion.Inverse(rtPose.rot);
			}
			else
			{
				base.transform.localRotation = rtPose.rot;
			}
		}
	}

	private float BodyRotationFilter1(WVR_DevicePosePair_t pose)
	{
		return Mathf.Clamp((new Vector3(pose.pose.AngularVelocity.v0, pose.pose.AngularVelocity.v1, pose.pose.AngularVelocity.v2).magnitude - 0.2f) / 30f, 0f, 0.2f);
	}
}
public sealed class WaveVR_DevicePoseTracker : MonoBehaviour
{
	private static string LOG_TAG = "WaveVR_DevicePoseTracker";

	public WaveVR_Controller.EDeviceType type;

	public bool inversePosition;

	public bool trackPosition = true;

	[Tooltip("Effective only when Track Position is true.")]
	public bool EnableNeckModel = true;

	public bool inverseRotation;

	public bool trackRotation = true;

	public WVR_TrackTiming timing = WVR_TrackTiming.WhenNewPoses;

	private WVR_DevicePosePair_t wvr_pose;

	private WaveVR_Utils.RigidTransform rigid_pose = WaveVR_Utils.RigidTransform.identity;

	private void Update()
	{
		if (timing != WVR_TrackTiming.WhenNewPoses && WaveVR.Instance.Initialized)
		{
			WaveVR.Device deviceByType = WaveVR.Instance.getDeviceByType(type);
			if (deviceByType.connected)
			{
				wvr_pose = deviceByType.pose;
				rigid_pose = deviceByType.rigidTransform;
			}
			updatePose(wvr_pose, rigid_pose);
		}
	}

	private void OnNewPoses(params object[] args)
	{
		WVR_DevicePosePair_t[] array = (WVR_DevicePosePair_t[])args[0];
		WaveVR_Utils.RigidTransform[] array2 = (WaveVR_Utils.RigidTransform[])args[1];
		WVR_DeviceType deviceType = WaveVR_Controller.Input(type).DeviceType;
		for (int i = 0; i < array.Length; i++)
		{
			if (deviceType == array[i].type)
			{
				wvr_pose = array[i];
				rigid_pose = array2[i];
			}
		}
		updatePose(wvr_pose, rigid_pose);
	}

	private void updatePose(WVR_DevicePosePair_t pose, WaveVR_Utils.RigidTransform rtPose)
	{
		if (trackPosition)
		{
			if (inversePosition)
			{
				base.transform.localPosition = -rtPose.pos;
			}
			else
			{
				base.transform.localPosition = rtPose.pos;
			}
		}
		if (trackRotation)
		{
			if (inverseRotation)
			{
				base.transform.localRotation = Quaternion.Inverse(rtPose.rot);
			}
			else
			{
				base.transform.localRotation = rtPose.rot;
			}
		}
	}

	private void OnEnable()
	{
		if (timing == WVR_TrackTiming.WhenNewPoses)
		{
			WaveVR_Utils.Event.Listen(WaveVR_Utils.Event.NEW_POSES, OnNewPoses);
		}
		if (type == WaveVR_Controller.EDeviceType.Head)
		{
			WVR_Log.Log.i(LOG_TAG, string.Concat("OnEnable() ", type, ", WVR_SetNeckModelEnabled to ", EnableNeckModel.ToString()));
			WaveVR.Instance.SetNeckModelEnabled(EnableNeckModel);
		}
		WVR_Log.Log.d(LOG_TAG, string.Concat("OnEnable() ", type, ", trackPosition: ", trackPosition.ToString(), ", trackRotation: ", trackRotation.ToString(), ", timing: ", timing));
	}

	private void OnDisable()
	{
		if (timing == WVR_TrackTiming.WhenNewPoses)
		{
			WaveVR_Utils.Event.Remove(WaveVR_Utils.Event.NEW_POSES, OnNewPoses);
		}
	}
}
[Obsolete("WaveVR_PoseSimulator is deprecated.")]
public class WaveVR_PoseSimulator : MonoBehaviour
{
	private static WaveVR_PoseSimulator instance = null;

	private WaveVR_Utils.RigidTransform rtPose_head = WaveVR_Utils.RigidTransform.identity;

	private WaveVR_Utils.RigidTransform rtPose_head_onGround = WaveVR_Utils.RigidTransform.identity;

	private WaveVR_Utils.RigidTransform rtPose_right = WaveVR_Utils.RigidTransform.identity;

	private WaveVR_Utils.RigidTransform rtPose_left = WaveVR_Utils.RigidTransform.identity;

	private WaveVR_Utils.WVR_ButtonState_t btn_right;

	private WaveVR_Utils.WVR_ButtonState_t btn_left;

	private WVR_Axis_t axis_right;

	private WVR_Axis_t axis_left;

	private const string MOUSE_X = "Mouse X";

	private const string MOUSE_Y = "Mouse Y";

	private const string MOUSE_SCROLLWHEEL = "Mouse ScrollWheel";

	private float shiftX_head;

	private float shiftY_head;

	private float shiftZ_head;

	private float angleX_head;

	private float angleY_head;

	private float angleZ_head;

	private float shiftX_right;

	private float shiftY_right;

	private float shiftZ_right;

	private float angleX_right;

	private float angleY_right;

	private float angleZ_right;

	private float shiftX_left;

	private float shiftY_left;

	private float shiftZ_left;

	private float angleX_left;

	private float angleY_left;

	private float angleZ_left;

	private static readonly KeyCode[] KeyCode_Head = new KeyCode[3]
	{
		KeyCode.LeftAlt,
		KeyCode.LeftControl,
		KeyCode.LeftShift
	};

	private static readonly KeyCode[] KeyCode_Right = new KeyCode[7]
	{
		KeyCode.RightAlt,
		KeyCode.RightControl,
		KeyCode.RightShift,
		KeyCode.UpArrow,
		KeyCode.DownArrow,
		KeyCode.LeftArrow,
		KeyCode.RightArrow
	};

	private static readonly KeyCode[] KeyCode_Left = new KeyCode[3]
	{
		KeyCode.LeftAlt,
		KeyCode.LeftControl,
		KeyCode.LeftShift
	};

	public static WaveVR_PoseSimulator Instance
	{
		get
		{
			if (instance == null)
			{
				instance = new GameObject("WaveVRPoseSimulator").AddComponent<WaveVR_PoseSimulator>();
				UnityEngine.Object.DontDestroyOnLoad(instance);
			}
			return instance;
		}
	}

	public void GetRigidTransform(WVR_DeviceType type, ref WaveVR_Utils.RigidTransform rtPose, WVR_PoseOriginModel origin)
	{
		switch (type)
		{
		case WVR_DeviceType.WVR_DeviceType_HMD:
			if (origin == WVR_PoseOriginModel.WVR_PoseOriginModel_OriginOnGround)
			{
				rtPose = rtPose_head_onGround;
			}
			else
			{
				rtPose = rtPose_head;
			}
			break;
		case WVR_DeviceType.WVR_DeviceType_Controller_Right:
			rtPose = rtPose_right;
			break;
		case WVR_DeviceType.WVR_DeviceType_Controller_Left:
			rtPose = rtPose_left;
			break;
		}
	}

	private void UpdateHeadPose(float axis_x, float axis_y, float axis_z)
	{
		Vector3 zero = Vector3.zero;
		Vector3 zero2 = Vector3.zero;
		Quaternion identity = Quaternion.identity;
		if (Input.GetKey(KeyCode_Head[0]))
		{
			angleX_head -= axis_y * 2.4f;
			angleX_head = Mathf.Clamp(angleX_head, -89f, 89f);
			angleY_head += axis_x * 5f;
			if (angleY_head <= -180f)
			{
				angleY_head += 360f;
			}
			else if (angleY_head > 180f)
			{
				angleY_head -= 360f;
			}
		}
		if (Input.GetKey(KeyCode_Head[1]))
		{
			angleZ_head += axis_x * 5f;
			angleZ_head = Mathf.Clamp(angleZ_head, -89f, 89f);
		}
		identity = Quaternion.Euler(angleX_head, angleY_head, angleZ_head);
		if (Input.GetKey(KeyCode_Head[2]))
		{
			Vector3 vector = identity * new Vector3(axis_x / 5f, axis_y / 5f, axis_z);
			shiftX_head += vector.x;
			shiftY_head += vector.y;
			shiftZ_head += vector.z;
		}
		zero = new Vector3(shiftX_head, shiftY_head, shiftZ_head);
		zero2 = new Vector3(shiftX_head, shiftY_head + 1.75f, shiftZ_head);
		rtPose_head.update(zero, identity);
		rtPose_head_onGround.update(zero2, identity);
	}

	private void UpdateRightHandPose(float axis_x, float axis_y, float axis_z)
	{
		Vector3 zero = Vector3.zero;
		Quaternion identity = Quaternion.identity;
		if (Input.GetKey(KeyCode_Right[0]))
		{
			angleY_right += axis_x / 2f;
			angleX_right -= axis_y * 1.5f;
		}
		if (Input.GetKey(KeyCode_Right[1]))
		{
			angleZ_right += axis_z * 5f;
		}
		if (Input.GetKey(KeyCode_Right[2]))
		{
			shiftX_right += axis_x / 5f;
			shiftY_right += axis_y / 5f;
			shiftZ_right += axis_z;
		}
		if (Input.GetKey(KeyCode_Right[3]))
		{
			shiftY_right += 10f * Time.deltaTime;
		}
		if (Input.GetKey(KeyCode_Right[4]))
		{
			shiftY_right -= 10f * Time.deltaTime;
		}
		if (Input.GetKey(KeyCode_Right[5]))
		{
			shiftX_right -= 10f * Time.deltaTime;
		}
		if (Input.GetKey(KeyCode_Right[6]))
		{
			shiftX_right += 10f * Time.deltaTime;
		}
		zero = new Vector3(shiftX_right, shiftY_right, shiftZ_right);
		identity = Quaternion.Euler(angleX_right, angleY_right, angleZ_right);
		rtPose_right.update(zero, identity);
	}

	private void UpdateLefHandPose(float axis_x, float axis_y, float axis_z)
	{
		Vector3 zero = Vector3.zero;
		Quaternion identity = Quaternion.identity;
		if (Input.GetKey(KeyCode_Left[0]))
		{
			angleY_left += axis_x / 2f;
			angleX_left -= axis_y * 1.5f;
		}
		if (Input.GetKey(KeyCode_Left[1]))
		{
			angleZ_left += axis_z * 5f;
		}
		if (Input.GetKey(KeyCode_Left[2]))
		{
			shiftX_left += axis_x / 5f;
			shiftY_left += axis_y / 5f;
			shiftZ_left += axis_z;
		}
		zero = new Vector3(shiftX_left, shiftY_left, shiftZ_left);
		identity = Quaternion.Euler(angleX_left, angleY_left, angleZ_left);
		rtPose_left.update(zero, identity);
	}

	public void Update()
	{
		float axis = Input.GetAxis("Mouse X");
		float axis2 = Input.GetAxis("Mouse Y");
		float axis3 = Input.GetAxis("Mouse ScrollWheel");
		UpdateHeadPose(axis, axis2, axis3);
		UpdateRightHandPose(axis, axis2, axis3);
	}
}
public enum WVR_TrackTiming
{
	WhenUpdate,
	WhenNewPoses
}
public enum WVR_SimulationOption
{
	WhenNoPosition,
	ForceSimulation,
	NoSimulation
}
public class WaveVR_PoseTrackerManager : MonoBehaviour
{
	private const string LOG_TAG = "WaveVR_PoseTrackerManager";

	public WaveVR_Controller.EDeviceType Type = WaveVR_Controller.EDeviceType.Dominant;

	public bool TrackPosition = true;

	public bool EnableNeckModel = true;

	public WVR_SimulationOption SimulationOption;

	public bool FollowHead;

	public bool TrackRotation = true;

	public WVR_TrackTiming TrackTiming = WVR_TrackTiming.WhenNewPoses;

	private List<GameObject> IncludedObjects = new List<GameObject>();

	private List<bool> IncludedStates = new List<bool>();

	private bool showTrackedObject = true;

	private bool connected;

	private bool mFocusCapturedBySystem;

	public bool poseUpdated;

	private bool hasNewPose;

	private bool gazeOnly;

	private WaveVR_DevicePoseTracker devicePoseTracker;

	private WaveVR_ControllerPoseTracker ctrlerPoseTracker;

	private bool ptmEnabled;

	private void PrintDebugLog(string msg)
	{
		if (WVR_Log.Log.EnableDebugLog)
		{
			WVR_Log.Log.d("WaveVR_PoseTrackerManager", msg, logInEditor: true);
		}
	}

	private void OnEnable()
	{
		if (!ptmEnabled)
		{
			IncludedObjects.Clear();
			IncludedStates.Clear();
			int childCount = base.transform.childCount;
			for (int i = 0; i < childCount; i++)
			{
				IncludedObjects.Add(base.transform.GetChild(i).gameObject);
				IncludedStates.Add(base.transform.GetChild(i).gameObject.activeSelf);
				PrintDebugLog(string.Concat("OnEnable() ", Type, ", ", base.gameObject.name, " has child: ", IncludedObjects[i].name, ", active? ", IncludedStates[i].ToString()));
			}
			WaveVR.Device deviceByType = WaveVR.Instance.getDeviceByType(Type);
			connected = deviceByType.connected;
			ForceActivateTargetObjects(active: false);
			poseUpdated = false;
			hasNewPose = false;
			WaveVR_Utils.Event.Listen(WaveVR_Utils.Event.DEVICE_CONNECTED, onDeviceConnected);
			WaveVR_Utils.Event.Listen(WaveVR_Utils.Event.NEW_POSES, OnNewPoses);
			WaveVR_Utils.Event.Listen(WaveVR_Utils.Event.SYSTEMFOCUS_CHANGED, onSystemFocusChanged);
			ptmEnabled = true;
		}
	}

	private void Awake()
	{
		if (!TrackPosition)
		{
			SimulationOption = WVR_SimulationOption.NoSimulation;
			FollowHead = false;
		}
		base.gameObject.SetActive(value: false);
		PrintDebugLog(string.Concat("Awake() ", Type, ", TrackPosition: ", TrackPosition.ToString(), ", SimulationOption: ", SimulationOption, ", FollowHead: ", FollowHead.ToString(), ", TrackRotation: ", TrackRotation.ToString(), ", TrackTiming: ", TrackTiming));
		if (base.gameObject.GetComponent<WaveVR_PointerCameraTracker>() == null)
		{
			if (Type == WaveVR_Controller.EDeviceType.Head)
			{
				PrintDebugLog(string.Concat("Awake() ", Type, ", load WaveVR_DevicePoseTracker."));
				devicePoseTracker = base.gameObject.AddComponent<WaveVR_DevicePoseTracker>();
				if (null != devicePoseTracker)
				{
					devicePoseTracker.type = Type;
					devicePoseTracker.trackPosition = TrackPosition;
					devicePoseTracker.EnableNeckModel = EnableNeckModel;
					devicePoseTracker.trackRotation = TrackRotation;
					devicePoseTracker.timing = TrackTiming;
				}
			}
			else
			{
				PrintDebugLog(string.Concat("Awake() ", Type, ", load WaveVR_ControllerPoseTracker."));
				ctrlerPoseTracker = base.gameObject.AddComponent<WaveVR_ControllerPoseTracker>();
				if (null != ctrlerPoseTracker)
				{
					ctrlerPoseTracker.Type = Type;
					ctrlerPoseTracker.TrackPosition = TrackPosition;
					ctrlerPoseTracker.SimulationOption = SimulationOption;
					ctrlerPoseTracker.FollowHead = FollowHead;
					ctrlerPoseTracker.TrackRotation = TrackRotation;
					ctrlerPoseTracker.TrackTiming = TrackTiming;
				}
			}
		}
		base.gameObject.SetActive(value: true);
	}

	private void Update()
	{
		if (!UnityEngine.Application.isEditor && WVR_Log.Log.gpl.Print)
		{
			if (Type == WaveVR_Controller.EDeviceType.Head)
			{
				PrintDebugLog(showTrackedObject ? "Update() Head, showTrackedObject is true." : "Update() Head, showTrackedObject is false.");
			}
			if (Type == WaveVR_Controller.EDeviceType.Dominant)
			{
				PrintDebugLog(showTrackedObject ? "Update() Dominant, showTrackedObject is true." : "Update() Dominant, showTrackedObject is false.");
			}
			if (Type == WaveVR_Controller.EDeviceType.NonDominant)
			{
				PrintDebugLog(showTrackedObject ? "Update() NonDominant, showTrackedObject is true." : "Update() NonDominant, showTrackedObject is false.");
			}
			for (int i = 0; i < IncludedObjects.Count; i++)
			{
				if (IncludedObjects[i] != null)
				{
					PrintDebugLog(string.Concat("Update() ", Type, ", Update() GameObject ", IncludedObjects[i].name, " is ", IncludedObjects[i].activeSelf ? "active." : "inactive."));
				}
			}
		}
		if (connected)
		{
			ActivateTargetObjects();
			poseUpdated = hasNewPose;
		}
	}

	private void OnDisable()
	{
		if (ptmEnabled)
		{
			PrintDebugLog(string.Concat("OnDisable() ", Type, ", restore children objects."));
			ForceActivateTargetObjects(active: true);
			WaveVR_Utils.Event.Remove(WaveVR_Utils.Event.DEVICE_CONNECTED, onDeviceConnected);
			WaveVR_Utils.Event.Remove(WaveVR_Utils.Event.NEW_POSES, OnNewPoses);
			WaveVR_Utils.Event.Remove(WaveVR_Utils.Event.SYSTEMFOCUS_CHANGED, onSystemFocusChanged);
			ptmEnabled = false;
		}
	}

	private void OnDestroy()
	{
		IncludedObjects.Clear();
		IncludedStates.Clear();
	}

	private bool hideEventController()
	{
		bool result = false;
		WVR_InteractionMode interactionMode = WaveVR.Instance.InteractionMode;
		if (WaveVR_InputModuleManager.Instance != null)
		{
			interactionMode = WaveVR_InputModuleManager.Instance.GetInteractionMode();
		}
		gazeOnly = interactionMode == WVR_InteractionMode.WVR_InteractionMode_Gaze;
		GameObject controllerModel = WaveVR_EventSystemControllerProvider.Instance.GetControllerModel(Type);
		if ((object)base.gameObject == controllerModel)
		{
			result = gazeOnly;
		}
		return result;
	}

	public void ActivateTargetObjects()
	{
		bool flag = hideEventController();
		bool flag2 = true;
		if (WaveVR_InputModuleManager.Instance != null)
		{
			flag2 = WaveVR_InputModuleManager.Instance.EnableInputModule;
		}
		bool flag3 = connected && !mFocusCapturedBySystem && poseUpdated && !flag && flag2;
		if (showTrackedObject != flag3)
		{
			if (Type == WaveVR_Controller.EDeviceType.Head)
			{
				PrintDebugLog(connected ? "ActivateTargetObjects() Head, connected is true." : "ActivateTargetObjects() Head, connected is false.");
				PrintDebugLog(mFocusCapturedBySystem ? "ActivateTargetObjects() Head, mFocusCapturedBySystem is true." : "ActivateTargetObjects() Head, mFocusCapturedBySystem is false.");
				PrintDebugLog(gazeOnly ? "ActivateTargetObjects() Head, gazeOnly is true." : "ActivateTargetObjects() Head, gazeOnly is false.");
				PrintDebugLog(flag2 ? "ActivateTargetObjects() Head, _has_input_module_enabled is true." : "ActivateTargetObjects() Head, _has_input_module_enabled is false.");
			}
			if (Type == WaveVR_Controller.EDeviceType.Dominant)
			{
				PrintDebugLog(connected ? "ActivateTargetObjects() Dominant, connected is true." : "ActivateTargetObjects() Dominant, connected is false.");
				PrintDebugLog(mFocusCapturedBySystem ? "ActivateTargetObjects() Dominant, mFocusCapturedBySystem is true." : "ActivateTargetObjects() Dominant, mFocusCapturedBySystem is false.");
				PrintDebugLog(gazeOnly ? "ActivateTargetObjects() Dominant, gazeOnly is true." : "ActivateTargetObjects() Dominant, gazeOnly is false.");
				PrintDebugLog(flag2 ? "ActivateTargetObjects() Dominant, _has_input_module_enabled is true." : "ActivateTargetObjects() Dominant, _has_input_module_enabled is false.");
			}
			if (Type == WaveVR_Controller.EDeviceType.NonDominant)
			{
				PrintDebugLog(connected ? "ActivateTargetObjects() NonDominant, connected is true." : "ActivateTargetObjects() NonDominant, connected is false.");
				PrintDebugLog(mFocusCapturedBySystem ? "ActivateTargetObjects() NonDominant, mFocusCapturedBySystem is true." : "ActivateTargetObjects() NonDominant, mFocusCapturedBySystem is false.");
				PrintDebugLog(gazeOnly ? "ActivateTargetObjects() NonDominant, gazeOnly is true." : "ActivateTargetObjects() NonDominant, gazeOnly is false.");
				PrintDebugLog(flag2 ? "ActivateTargetObjects() NonDominant, _has_input_module_enabled is true." : "ActivateTargetObjects() NonDominant, _has_input_module_enabled is false.");
			}
			ForceActivateTargetObjects(flag3);
		}
	}

	private void ForceActivateTargetObjects(bool active)
	{
		for (int i = 0; i < IncludedObjects.Count; i++)
		{
			if (!(IncludedObjects[i] == null) && IncludedStates[i])
			{
				PrintDebugLog(string.Concat("ForceActivateTargetObjects() ", Type, ", ", active ? "activate" : "deactivate", " ", IncludedObjects[i].name));
				IncludedObjects[i].SetActive(active);
			}
		}
		showTrackedObject = active;
	}

	private void onDeviceConnected(params object[] args)
	{
		if (!ptmEnabled)
		{
			if (Type == WaveVR_Controller.EDeviceType.Head)
			{
				PrintDebugLog("onDeviceConnected() Head, do NOTHING when disabled.");
			}
			if (Type == WaveVR_Controller.EDeviceType.Dominant)
			{
				PrintDebugLog("onDeviceConnected() Dominant, do NOTHING when disabled.");
			}
			if (Type == WaveVR_Controller.EDeviceType.NonDominant)
			{
				PrintDebugLog("onDeviceConnected() NonDominant, do NOTHING when disabled.");
			}
			return;
		}
		WVR_DeviceType num = (WVR_DeviceType)args[0];
		bool flag = (bool)args[1];
		if (Type == WaveVR_Controller.EDeviceType.Head)
		{
			PrintDebugLog(flag ? "onDeviceConnected() Head is connected. " : "onDeviceConnected() Head is disconnected. ");
		}
		if (Type == WaveVR_Controller.EDeviceType.Dominant)
		{
			PrintDebugLog(flag ? "onDeviceConnected() Dominant is connected. " : "onDeviceConnected() Dominant is disconnected. ");
		}
		if (Type == WaveVR_Controller.EDeviceType.NonDominant)
		{
			PrintDebugLog(flag ? "onDeviceConnected() NonDominant is connected. " : "onDeviceConnected() NonDominant is disconnected. ");
		}
		if (num == WaveVR_Controller.Input(Type).DeviceType)
		{
			connected = flag;
			ActivateTargetObjects();
		}
	}

	private void OnNewPoses(params object[] args)
	{
		if (!ptmEnabled)
		{
			if (Type == WaveVR_Controller.EDeviceType.Head)
			{
				PrintDebugLog("OnNewPoses() Head, do NOTHING when disabled.");
			}
			if (Type == WaveVR_Controller.EDeviceType.Dominant)
			{
				PrintDebugLog("OnNewPoses() Dominant, do NOTHING when disabled.");
			}
			if (Type == WaveVR_Controller.EDeviceType.NonDominant)
			{
				PrintDebugLog("OnNewPoses() NonDominant, do NOTHING when disabled.");
			}
		}
		else if (!hasNewPose)
		{
			if (Type == WaveVR_Controller.EDeviceType.Head)
			{
				PrintDebugLog("OnNewPoses() Head, pose updated.");
			}
			if (Type == WaveVR_Controller.EDeviceType.Dominant)
			{
				PrintDebugLog("OnNewPoses() Dominant, pose updated.");
			}
			if (Type == WaveVR_Controller.EDeviceType.NonDominant)
			{
				PrintDebugLog("OnNewPoses() NonDominant, pose updated.");
			}
			hasNewPose = true;
		}
	}

	private void onSystemFocusChanged(params object[] args)
	{
		if (!ptmEnabled)
		{
			if (Type == WaveVR_Controller.EDeviceType.Head)
			{
				PrintDebugLog("onSystemFocusChanged() Head, do NOTHING when disabled.");
			}
			if (Type == WaveVR_Controller.EDeviceType.Dominant)
			{
				PrintDebugLog("onSystemFocusChanged() Dominant, do NOTHING when disabled.");
			}
			if (Type == WaveVR_Controller.EDeviceType.NonDominant)
			{
				PrintDebugLog("onSystemFocusChanged() NonDominant, do NOTHING when disabled.");
			}
			return;
		}
		mFocusCapturedBySystem = (bool)args[0];
		if (Type == WaveVR_Controller.EDeviceType.Head)
		{
			PrintDebugLog(mFocusCapturedBySystem ? "onSystemFocusChanged() Head, focus is captured by system." : "onSystemFocusChanged() Head, focus is NOT captured by system.");
		}
		if (Type == WaveVR_Controller.EDeviceType.Dominant)
		{
			PrintDebugLog(mFocusCapturedBySystem ? "onSystemFocusChanged() Dominant, focus is captured by system." : "onSystemFocusChanged() Dominant, focus is NOT captured by system.");
		}
		if (Type == WaveVR_Controller.EDeviceType.NonDominant)
		{
			PrintDebugLog(mFocusCapturedBySystem ? "onSystemFocusChanged() NonDominant, focus is captured by system." : "onSystemFocusChanged() NonDominant, focus is NOT captured by system.");
		}
		ActivateTargetObjects();
	}
}
public class WaveVR : IDisposable
{
	public class Device
	{
		public WVR_DeviceType type { get; private set; }

		public int index { get; private set; }

		public bool connected => instance.isValidPose[index];

		public WVR_DevicePosePair_t pose => instance.poses[instance.deviceIndexMap[index]];

		public WaveVR_Utils.RigidTransform rigidTransform => instance.rtPoses[instance.deviceIndexMap[index]];

		public Device(WVR_DeviceType type)
		{
			this.type = type;
			for (int i = 0; i < DeviceTypes.Length; i++)
			{
				if (DeviceTypes[i] == type)
				{
					index = i;
					break;
				}
			}
		}
	}

	[SerializeField]
	public bool editor;

	private static string LOG_TAG = "WVR_WaveVR";

	private static WaveVR instance = null;

	public bool Initialized;

	private ulong supportedFeatures;

	public bool FocusCapturedBySystem;

	private bool handTrackingEnabled;

	private bool handGestureEnabled;

	public WVR_InteractionMode InteractionMode = WVR_InteractionMode.WVR_InteractionMode_SystemDefault;

	public WVR_GazeTriggerType GazeTriggerType = WVR_GazeTriggerType.WVR_GazeTriggerType_Timeout;

	public static WVR_DeviceType[] DeviceTypes = new WVR_DeviceType[3]
	{
		WVR_DeviceType.WVR_DeviceType_HMD,
		WVR_DeviceType.WVR_DeviceType_Controller_Right,
		WVR_DeviceType.WVR_DeviceType_Controller_Left
	};

	private bool[] isValidPose = new bool[DeviceTypes.Length];

	private uint[] deviceIndexMap = new uint[DeviceTypes.Length];

	public uint frameInx;

	private WVR_DevicePosePair_t[] poses = new WVR_DevicePosePair_t[DeviceTypes.Length];

	private WaveVR_Utils.RigidTransform[] rtPoses = new WaveVR_Utils.RigidTransform[DeviceTypes.Length];

	public static WaveVR_Render.StereoRenderingPath UnityPlayerSettingsStereoRenderingPath = WaveVR_Render.StereoRenderingPath.SinglePass;

	public static WaveVR Instance
	{
		get
		{
			if (instance == null)
			{
				instance = new WaveVR();
			}
			return instance;
		}
	}

	public Device hmd { get; private set; }

	public Device controllerLeft { get; private set; }

	public Device controllerRight { get; private set; }

	[Obsolete("Please check WaveVR.Instance directly")]
	public static bool Hmd => Instance != null;

	private void PrintDebugLog(string msg)
	{
		if (WVR_Log.Log.EnableDebugLog)
		{
			WVR_Log.Log.d(LOG_TAG, msg, logInEditor: true);
		}
	}

	private void PrintInfoLog(string msg)
	{
		WVR_Log.Log.i(LOG_TAG, msg, logInEditor: true);
	}

	private void PrintErrorLog(string msg)
	{
		WVR_Log.Log.e(LOG_TAG, msg, logInEditor: true);
	}

	public Device getDeviceByType(WVR_DeviceType type)
	{
		switch (type)
		{
		case WVR_DeviceType.WVR_DeviceType_HMD:
			return hmd;
		case WVR_DeviceType.WVR_DeviceType_Controller_Right:
			if (!WaveVR_Controller.IsLeftHanded)
			{
				return controllerRight;
			}
			return controllerLeft;
		case WVR_DeviceType.WVR_DeviceType_Controller_Left:
			if (!WaveVR_Controller.IsLeftHanded)
			{
				return controllerLeft;
			}
			return controllerRight;
		default:
			Assert.raiseExceptions = true;
			return hmd;
		}
	}

	public Device getDeviceByType(WaveVR_Controller.EDeviceType type)
	{
		switch (type)
		{
		case WaveVR_Controller.EDeviceType.Head:
			return hmd;
		case WaveVR_Controller.EDeviceType.Dominant:
			if (!WaveVR_Controller.IsLeftHanded)
			{
				return controllerRight;
			}
			return controllerLeft;
		case WaveVR_Controller.EDeviceType.NonDominant:
			if (!WaveVR_Controller.IsLeftHanded)
			{
				return controllerLeft;
			}
			return controllerRight;
		default:
			return null;
		}
	}

	private void ReportError(WVR_InitError error)
	{
		switch (error)
		{
		case WVR_InitError.WVR_InitError_NotInitialized:
			PrintErrorLog("WaveVR: Not initialized");
			UnityEngine.Application.Quit();
			break;
		case WVR_InitError.WVR_InitError_Unknown:
			PrintErrorLog("WaveVR: Unknown error during initializing");
			break;
		case WVR_InitError.WVR_InitError_None:
			break;
		}
	}

	private WaveVR()
	{
		PrintInfoLog("WaveVR()+ commit: " + WaveVR_COMMITINFO.wavevr_version);
		WVR_InitError wVR_InitError = Interop.WVR_Init(WVR_AppType.WVR_AppType_VRContent);
		if (wVR_InitError != 0)
		{
			ReportError(wVR_InitError);
			Interop.WVR_Quit();
			Initialized = false;
			PrintErrorLog("WaveVR() initialize simulator failed, WVR_Quit()");
			return;
		}
		WaveVR_Utils.notifyActivityUnityStarted();
		Initialized = true;
		PrintInfoLog("WaveVR() initialization succeeded.");
		UnityPlayerSettingsStereoRenderingPath = (WaveVR_Render.IsVRSinglePassBuildTimeSupported() ? WaveVR_Render.StereoRenderingPath.SinglePass : WaveVR_Render.StereoRenderingPath.MultiPass);
		PrintInfoLog("UnityPlayerSettingsStereoRenderingPath = " + UnityPlayerSettingsStereoRenderingPath);
		for (int i = 0; i < 3; i++)
		{
			poses[i] = default(WVR_DevicePosePair_t);
			isValidPose[i] = false;
			deviceIndexMap[i] = 0u;
		}
		hmd = new Device(WVR_DeviceType.WVR_DeviceType_HMD);
		controllerLeft = new Device(WVR_DeviceType.WVR_DeviceType_Controller_Left);
		controllerRight = new Device(WVR_DeviceType.WVR_DeviceType_Controller_Right);
		SetLeftHandedMode();
		UpdateAllConnection();
		SetDefaultButtons();
		supportedFeatures = Interop.WVR_GetSupportedFeatures();
		PrintInfoLog("WaveVR() supportedFeatures: " + supportedFeatures);
		PrintInfoLog("WaveVR()-");
	}

	~WaveVR()
	{
		Dispose();
	}

	public void onLoadLevel()
	{
		if (Initialized)
		{
			PrintInfoLog("onLoadLevel() reset all connection");
			for (int i = 0; i < DeviceTypes.Length; i++)
			{
				poses[i] = default(WVR_DevicePosePair_t);
				isValidPose[i] = false;
			}
		}
	}

	public void Dispose()
	{
		if (Initialized)
		{
			PrintInfoLog("Stop Hand Gesture before WVR_Quit.");
			StopHandGesture();
			PrintInfoLog("Stop Hand Tracking before WVR_Quit.");
			StopHandTracking();
			Interop.WVR_Quit();
			PrintInfoLog("WVR_Quit");
			instance = null;
			Initialized = false;
			GC.SuppressFinalize(this);
		}
	}

	public static void SafeDispose()
	{
		if (instance != null)
		{
			instance.Dispose();
		}
	}

	public int is6DoFTracking()
	{
		if (!Initialized)
		{
			return 0;
		}
		return Interop.WVR_GetDegreeOfFreedom(WVR_DeviceType.WVR_DeviceType_HMD) switch
		{
			WVR_NumDoF.WVR_NumDoF_6DoF => 6, 
			WVR_NumDoF.WVR_NumDoF_3DoF => 3, 
			_ => 0, 
		};
	}

	public void UpdateEachFrame(WVR_PoseOriginModel origin)
	{
		if (Initialized)
		{
			UpdateEachFrame(origin, isSimulator: false);
		}
	}

	public void UpdateEachFrame(WVR_PoseOriginModel origin, bool isSimulator)
	{
		if (!Initialized)
		{
			return;
		}
		if (WVR_Log.Log.gpl.Print)
		{
			PrintDebugLog("UpdateEachFrame()");
		}
		bool flag = Interop.WVR_IsInputFocusCapturedBySystem();
		if (FocusCapturedBySystem != flag)
		{
			FocusCapturedBySystem = flag;
			WaveVR_Utils.Event.Send(WaveVR_Utils.Event.SYSTEMFOCUS_CHANGED, FocusCapturedBySystem);
			if (!FocusCapturedBySystem)
			{
				PrintInfoLog("UpdateEachFrame() get system focus, update button events.");
				UpdateButtonEvents();
			}
			else
			{
				PrintInfoLog("UpdateEachFrame() lost system focus.");
			}
		}
		InteractionMode = Interop.WVR_GetInteractionMode();
		GazeTriggerType = Interop.WVR_GetGazeTriggerType();
		Interop.WVR_GetSyncPose(origin, poses, (uint)poses.Length);
		for (uint num = 0u; num < DeviceTypes.Length; num++)
		{
			bool flag2 = false;
			for (uint num2 = 0u; num2 < poses.Length; num2++)
			{
				WVR_DevicePosePair_t wVR_DevicePosePair_t = poses[num2];
				if (wVR_DevicePosePair_t.type == DeviceTypes[num])
				{
					flag2 = true;
					bool connectionStatus = GetConnectionStatus(DeviceTypes[num]);
					if (connectionStatus)
					{
						connectionStatus = wVR_DevicePosePair_t.pose.IsValidPose;
					}
					deviceIndexMap[num] = num2;
					if (isValidPose[num] != connectionStatus)
					{
						isValidPose[num] = connectionStatus;
						PrintInfoLog(WVR_Log.Log.CSB.Append("UpdateEachFrame() device ").Append(DeviceTypes[num].Name()).Append(" pose is ")
							.Append(isValidPose[num] ? "valid." : "invalid.")
							.ToString());
						WaveVR_Utils.Event.Send(WaveVR_Utils.Event.DEVICE_CONNECTED, DeviceTypes[num], isValidPose[num]);
					}
					if (isValidPose[num])
					{
						rtPoses[num2].update(wVR_DevicePosePair_t.pose.PoseMatrix);
					}
					break;
				}
			}
			if (!flag2 && isValidPose[num])
			{
				isValidPose[num] = false;
				PrintInfoLog(WVR_Log.Log.CSB.Append("UpdateEachFrame() device ").Append(DeviceTypes[num].Name()).Append(" pose is invalid.")
					.ToString());
				WaveVR_Utils.Event.Send(WaveVR_Utils.Event.DEVICE_CONNECTED, DeviceTypes[num], isValidPose[num]);
			}
		}
		for (int i = 0; i < poses.Length; i++)
		{
			WVR_DeviceType type = poses[i].type;
			bool connectionStatus2 = GetConnectionStatus(type);
			bool flag3 = poses[i].pose.IsValidPose;
			if (WVR_Log.Log.gpl.Print)
			{
				PrintDebugLog(WVR_Log.Log.CSB.Append("UpdateEachFrame() device ").Append(type.Name()).Append(" is ")
					.Append(connectionStatus2 ? "connected" : "disconnected")
					.Append(", pose is ")
					.Append(flag3 ? "valid" : "invalid")
					.Append(", pos: {")
					.Append(rtPoses[i].pos.x)
					.Append(", ")
					.Append(rtPoses[i].pos.y)
					.Append(", ")
					.Append(rtPoses[i].pos.z)
					.Append("}")
					.Append(", rot: {")
					.Append(rtPoses[i].rot.x)
					.Append(", ")
					.Append(rtPoses[i].rot.y)
					.Append(", ")
					.Append(rtPoses[i].rot.z)
					.Append(", ")
					.Append(rtPoses[i].rot.w)
					.Append("}")
					.ToString());
			}
		}
		try
		{
			WaveVR_Utils.Event.Send(WaveVR_Utils.Event.NEW_POSES, poses, rtPoses);
		}
		catch (Exception ex)
		{
			PrintErrorLog("Send NEW_POSES Event Exception : " + ex);
		}
		if (WVR_Log.Log.gpl.Print)
		{
			PrintDebugLog("UpdateEachFrame() after new pose.");
		}
		try
		{
			WaveVR_Utils.Event.Send(WaveVR_Utils.Event.AFTER_NEW_POSES);
		}
		catch (Exception ex2)
		{
			PrintErrorLog("Send AFTER_NEW_POSES Event Exception : " + ex2);
		}
	}

	public int SetQualityLevel(int level, bool applyExpensiveChanges = true)
	{
		if (!Initialized)
		{
			return -1;
		}
		return WaveVR_Render.Instance.SetQualityLevel(level, applyExpensiveChanges);
	}

	public bool SetLeftHandedMode(bool leftHandedInEditor = false)
	{
		if (!Initialized)
		{
			return false;
		}
		bool result = false;
		bool flag = false;
		flag = Interop.WVR_GetDefaultControllerRole() == WVR_DeviceType.WVR_DeviceType_Controller_Left;
		if (WaveVR_Controller.IsLeftHanded != flag)
		{
			result = true;
			WVR_Log.Log.i(LOG_TAG, WVR_Log.Log.CSB.Append("SetLeftHandedMode() Set left-handed mode to ").Append(flag).ToString());
			WaveVR_Controller.SetLeftHandedMode(flag);
		}
		else
		{
			WVR_Log.Log.i(LOG_TAG, WVR_Log.Log.CSB.Append("SetLeftHandedMode() not change default role: ").Append(flag ? "LEFT." : "RIGHT.").ToString());
		}
		return result;
	}

	private bool GetConnectionStatus(WVR_DeviceType type)
	{
		if (type == WVR_DeviceType.WVR_DeviceType_Invalid)
		{
			return false;
		}
		return WaveVR_Controller.Input(WaveVR_Controller.Input(type).DeviceType).connected;
	}

	public void SetConnectionStatus(WVR_DeviceType type, bool conn)
	{
		if (Initialized && type != 0)
		{
			PrintInfoLog(string.Concat("SetConnectionStatus() ", type, " is ", conn ? "connected." : "disconnected."));
			WaveVR_Controller.Input(WaveVR_Controller.Input(type).DeviceType).connected = conn;
		}
	}

	public void UpdateAllConnection()
	{
		if (Initialized)
		{
			for (int i = 0; i < DeviceTypes.Length; i++)
			{
				SetConnectionStatus(DeviceTypes[i], IsDeviceConnected(DeviceTypes[i]));
			}
			UpdateAllPoseState();
		}
	}

	private void UpdateAllPoseState()
	{
		for (int i = 0; i < DeviceTypes.Length; i++)
		{
			if (!GetConnectionStatus(DeviceTypes[i]))
			{
				isValidPose[i] = false;
				PrintInfoLog(string.Concat("UpdateAllPoseState() ", DeviceTypes[i], " pose is ", isValidPose[i] ? "valid." : "invalid."));
				WaveVR_Utils.Event.Send(WaveVR_Utils.Event.DEVICE_CONNECTED, DeviceTypes[i], isValidPose[i]);
			}
		}
	}

	public void UpdateButtonEvents()
	{
		if (Initialized)
		{
			PrintInfoLog("ResetButtonEvents() Reset button events.");
			for (int i = 0; i < DeviceTypes.Length; i++)
			{
				WaveVR_Controller.Input(DeviceTypes[i]).UpdateButtonEvents();
			}
		}
	}

	public void ResetAllButtonStates()
	{
		PrintInfoLog("ResetAllButtonStates() Reset button states.");
		for (int i = 0; i < DeviceTypes.Length; i++)
		{
			WaveVR_Controller.Input(DeviceTypes[i]).ResetAllButtonStates();
		}
	}

	public void SetDefaultButtons()
	{
		if (!Initialized)
		{
			return;
		}
		PrintInfoLog("SetDefaultButtons()");
		WVR_InputAttribute_t[] array = new WVR_InputAttribute_t[1];
		array[0].id = WVR_InputId.WVR_InputId_15;
		array[0].capability = 1u;
		array[0].axis_type = WVR_AnalogType.WVR_AnalogType_None;
		WVR_DeviceType deviceType = WaveVR_Controller.Input(WaveVR_Controller.EDeviceType.Head).DeviceType;
		if (!Interop.WVR_SetInputRequest(deviceType, array, (uint)array.Length))
		{
			return;
		}
		uint num = 32u;
		WVR_InputMappingPair_t[] array2 = new WVR_InputMappingPair_t[num];
		uint num2 = Interop.WVR_GetInputMappingTable(deviceType, array2, num);
		if (num2 != 0)
		{
			for (int i = 0; i < (int)num2; i++)
			{
				WVR_Log.Log.d(LOG_TAG, WVR_Log.Log.CSB.Append("SetDefaultButtons() ").Append(deviceType.Name()).Append(" button: ")
					.Append(array2[i].source.id)
					.Append(" is mapping to HMD input ID: ")
					.Append(array2[i].destination.id)
					.ToString());
			}
		}
	}

	public void SetPoseSimulation(WVR_SimulationType type)
	{
		if (Initialized)
		{
			PrintInfoLog("SetPoseSimulation() " + type);
			Interop.WVR_SetArmModel(type);
		}
	}

	public void SetPoseSimulationFollowHead(bool follow)
	{
		if (Initialized)
		{
			PrintInfoLog("SetPoseSimulationFollowHead ()" + follow);
			Interop.WVR_SetArmSticky(follow);
		}
	}

	public void SetNeckModelEnabled(bool enabled)
	{
		if (Initialized)
		{
			PrintInfoLog("SetNeckModelEnabled() " + enabled);
			Interop.WVR_SetNeckModelEnabled(enabled);
		}
	}

	public bool StartHandGesture()
	{
		if (Initialized && !handGestureEnabled)
		{
			ulong num = GetSupportedFeatures();
			PrintInfoLog("StartHandGesture() supported feature: " + num);
			if ((num & 0x20) == 0L)
			{
				return false;
			}
			WVR_Result wVR_Result = Interop.WVR_StartHandGesture();
			handGestureEnabled = wVR_Result == WVR_Result.WVR_Success;
			PrintInfoLog("StartHandGesture() " + wVR_Result);
		}
		return handGestureEnabled;
	}

	public void StopHandGesture()
	{
		if (Initialized && handGestureEnabled)
		{
			PrintInfoLog("StopHandGesture() Starts.");
			Interop.WVR_StopHandGesture();
			PrintInfoLog("StopHandGesture() Ends.");
			handGestureEnabled = false;
		}
	}

	public bool IsHandGestureEnabled()
	{
		return handGestureEnabled;
	}

	public bool GetHandGestureData(ref WVR_HandGestureData_t data)
	{
		bool result = false;
		if (handGestureEnabled)
		{
			result = Interop.WVR_GetHandGestureData(ref data) == WVR_Result.WVR_Success;
		}
		return result;
	}

	public bool StartHandTracking()
	{
		if (Initialized && !handTrackingEnabled)
		{
			ulong num = GetSupportedFeatures();
			PrintInfoLog("StartHandTracking() supported feature: " + num);
			if ((num & 0x10) == 0L)
			{
				return false;
			}
			WVR_Result wVR_Result = Interop.WVR_StartHandTracking();
			handTrackingEnabled = wVR_Result == WVR_Result.WVR_Success;
			PrintInfoLog("StartHandTracking() " + wVR_Result);
		}
		return handTrackingEnabled;
	}

	public void StopHandTracking()
	{
		if (Initialized && handTrackingEnabled)
		{
			PrintInfoLog("StopHandTracking() Starts.");
			Interop.WVR_StopHandTracking();
			PrintInfoLog("StopHandTracking() Ends.");
			handTrackingEnabled = false;
		}
	}

	public bool IsHandTrackingEnabled()
	{
		return handTrackingEnabled;
	}

	public bool GetHandTrackingData(ref WVR_HandTrackingData_t data, WVR_PoseOriginModel originModel, uint predictedMilliSec)
	{
		bool result = false;
		if (handTrackingEnabled)
		{
			result = Interop.WVR_GetHandTrackingData(ref data, originModel, predictedMilliSec) == WVR_Result.WVR_Success;
		}
		return result;
	}

	public ulong GetSupportedFeatures()
	{
		return supportedFeatures;
	}

	private bool IsDeviceConnected(WVR_DeviceType device)
	{
		if (!Initialized)
		{
			return false;
		}
		return Interop.WVR_IsDeviceConnected(device);
	}
}
[RequireComponent(typeof(MeshFilter), typeof(MeshRenderer))]
public class WaveVR_Beam : MonoBehaviour
{
	private static string LOG_TAG = "WaveVR_Beam";

	public bool ShowBeam = true;

	public bool ListenToDevice;

	public WaveVR_Controller.EDeviceType device;

	public float StartWidth = 0.000625f;

	public float EndWidth = 0.00125f;

	private const float minimal_length = 0.1f;

	private float preStartOffset = 0.015f;

	public float StartOffset = 0.015f;

	[HideInInspector]
	public float endOffsetMin = 0.5f;

	[HideInInspector]
	public float endOffsetMax = 99.5f;

	private float preEndOffset = 0.8f;

	public float EndOffset = 0.8f;

	private Color32 preStartColor = new Color32(byte.MaxValue, byte.MaxValue, byte.MaxValue, byte.MaxValue);

	public Color32 StartColor = new Color32(byte.MaxValue, byte.MaxValue, byte.MaxValue, byte.MaxValue);

	private Color32 TailColor = new Color32(byte.MaxValue, byte.MaxValue, byte.MaxValue, byte.MaxValue);

	private Color32 preEndColor = new Color32(byte.MaxValue, byte.MaxValue, byte.MaxValue, byte.MaxValue);

	public Color32 EndColor = new Color32(byte.MaxValue, byte.MaxValue, byte.MaxValue, byte.MaxValue);

	public bool useDefaultMaterial = true;

	public Material customMat;

	private int count = 3;

	public bool updateEveryFrame;

	private bool makeTail = true;

	private string textureName;

	private int maxUVAngle = 30;

	private const float epsilon = 0.0001f;

	private bool isBeamEnable;

	private bool connected;

	private int Count = -1;

	private int verticesCount = -1;

	private int indicesCount = -1;

	private List<Vector3> vertices = new List<Vector3>();

	private List<Vector2> uvs = new List<Vector2>();

	private List<Vector3> normals = new List<Vector3>();

	private List<int> indices = new List<int>();

	private List<Color32> colors = new List<Color32>();

	private Vector3 position;

	private Mesh emptyMesh;

	private Mesh updateMesh;

	private Material materialComp;

	private MeshFilter mf_beam;

	private MeshRenderer meshRenderer;

	private bool meshIsCreated;

	private bool toUpdateBeam;

	private const string CtrColorBeam3 = "CtrColorBeam3";

	private Matrix4x4 mat44_rot = Matrix4x4.zero;

	private Matrix4x4 mat44_uv = Matrix4x4.zero;

	private Vector3 vec3_vertices_start = Vector3.zero;

	private Vector3 vec3_vertices_end = Vector3.zero;

	private readonly Vector2 vec2_05_05 = new Vector2(0.5f, 0.5f);

	private readonly Vector3 vec3_0_05_0 = new Vector3(0f, 0.5f, 0f);

	private void PrintDebugLog(string msg)
	{
		if (WVR_Log.Log.EnableDebugLog)
		{
			WVR_Log.Log.d(LOG_TAG, msg, logInEditor: true);
		}
	}

	public void SetEndOffset(float end_offset)
	{
		EndOffset = end_offset;
		PrintDebugLog(string.Concat("SetEndOffset() ", device, ", ", EndOffset));
	}

	public void SetEndOffset(Vector3 target, bool interactive)
	{
		EndOffset = base.transform.InverseTransformPoint(target).z - endOffsetMin;
	}

	public void ResetEndOffset()
	{
		EndOffset = endOffsetMax;
		PrintDebugLog(string.Concat("ResetEndOffset() ", device, ", EndOffset: ", EndOffset, ", endOffsetMin: ", endOffsetMin, ", endOffsetMax: ", endOffsetMax));
	}

	private bool Color32Equal(Color32 color1, Color32 color2)
	{
		if (color1.r == color2.r && color1.g == color2.g && color1.b == color2.b && color1.a == color2.a)
		{
			return true;
		}
		return false;
	}

	private void ValidateBeamAttributes()
	{
		if (EndOffset < endOffsetMin || EndOffset > endOffsetMax)
		{
			EndOffset = preEndOffset;
		}
		if (preEndOffset != EndOffset)
		{
			preEndOffset = EndOffset;
			toUpdateBeam = true;
		}
		if (StartOffset >= EndOffset - 0.1f)
		{
			StartOffset = preStartOffset;
		}
		if (preStartOffset != StartOffset)
		{
			preStartOffset = StartOffset;
			toUpdateBeam = true;
			PrintDebugLog(string.Concat("ValidateBeamAttributes() ", device, ", StartOffset: ", StartOffset));
		}
		if (!Color32Equal(preStartColor, StartColor))
		{
			preStartColor = StartColor;
			toUpdateBeam = true;
			PrintDebugLog(string.Concat("ValidateBeamAttributes() ", device, ", StartColor: ", StartColor.ToString()));
		}
		if (!Color32Equal(preEndColor, EndColor))
		{
			preEndColor = EndColor;
			toUpdateBeam = true;
			PrintDebugLog(string.Concat("ValidateBeamAttributes() ", device, ", EndColor: ", EndColor.ToString()));
		}
	}

	private void ReadJsonValues()
	{
		string controllerConfig = WaveVR_Utils.OEMConfig.getControllerConfig();
		if (controllerConfig.Equals(""))
		{
			return;
		}
		try
		{
			JSONNode jSONNode = JSONNode.Parse(controllerConfig);
			string text = "";
			text = jSONNode["beam"]["start_width"].Value;
			if (!text.Equals("") && IsFloat(text))
			{
				StartWidth = float.Parse(text);
			}
			text = jSONNode["beam"]["end_width"].Value;
			if (!text.Equals("") && IsFloat(text))
			{
				EndWidth = float.Parse(text);
			}
			text = jSONNode["beam"]["start_offset"].Value;
			if (!text.Equals("") && IsFloat(text))
			{
				StartOffset = float.Parse(text);
			}
			text = jSONNode["beam"]["length"].Value;
			if (!text.Equals("") && IsFloat(text))
			{
				EndOffset = float.Parse(text);
			}
			text = jSONNode["beam"]["start_color"].Value;
			if (!text.Equals(""))
			{
				UpdateStartColor(text);
			}
			text = jSONNode["beam"]["end_color"].Value;
			if (!text.Equals(""))
			{
				UpdateEndColor(text);
			}
			PrintDebugLog(string.Concat("ReadJsonValues() ", device, ", StartWidth: ", StartWidth, ", EndWidth: ", EndWidth, ", StartOffset: ", StartOffset, ", EndOffset: ", EndOffset, ", StartColor: ", StartColor.ToString(), ", EndColor: ", EndColor.ToString()));
		}
		catch (Exception ex)
		{
			WVR_Log.Log.e(LOG_TAG, "JsonParse failed: " + ex.ToString());
		}
	}

	private bool IsBoolean(string value)
	{
		try
		{
			PrintDebugLog(value + " Convert to bool success: " + Convert.ToBoolean(value));
			return true;
		}
		catch (Exception ex)
		{
			WVR_Log.Log.e(LOG_TAG, value + " Convert to bool failed: " + ex.ToString());
			return false;
		}
	}

	private bool IsFloat(string value)
	{
		try
		{
			PrintDebugLog(value + " Convert to float success: " + Convert.ToSingle(value));
			return true;
		}
		catch (Exception ex)
		{
			WVR_Log.Log.e(LOG_TAG, value + " Convert to float failed: " + ex.ToString());
			return false;
		}
	}

	private bool IsNumeric(string value)
	{
		try
		{
			PrintDebugLog(value + " Convert to int success: " + Convert.ToInt32(value));
			return true;
		}
		catch (Exception ex)
		{
			WVR_Log.Log.e(LOG_TAG, value + " Convert to Int failed: " + ex.ToString());
			return false;
		}
	}

	private void Validate()
	{
		if (StartWidth < 0.0001f)
		{
			StartWidth = 0.0001f;
		}
		if (EndWidth < 0.0001f)
		{
			EndWidth = 0.0001f;
		}
		if (StartOffset < 0.0001f)
		{
			StartOffset = 0.0001f;
		}
		if (EndOffset < 0.0002f)
		{
			EndOffset = 0.0002f;
		}
		if (EndOffset < StartOffset)
		{
			EndOffset = StartOffset + 0.0001f;
		}
		if (count < 3)
		{
			count = 3;
		}
		int num = 360 / count;
		if (num > 30)
		{
			maxUVAngle = 30;
		}
		else
		{
			maxUVAngle = num;
		}
	}

	private void Awake()
	{
		emptyMesh = new Mesh();
		updateMesh = new Mesh();
	}

	private void Start()
	{
	}

	private void OnEnable()
	{
		if (!isBeamEnable)
		{
			TailColor = StartColor;
			Count = count + 1;
			verticesCount = Count * 2 + (makeTail ? 1 : 0);
			indicesCount = Count * 6 + (makeTail ? (count * 3) : 0);
			GameObject gameObject = base.transform.parent.gameObject;
			mf_beam = GetComponent<MeshFilter>();
			meshRenderer = GetComponent<MeshRenderer>();
			if (!useDefaultMaterial && customMat != null)
			{
				PrintDebugLog(string.Concat("OnEnable() ", device, ", Use custom config and material"));
				meshRenderer.material = customMat;
			}
			else
			{
				PrintDebugLog(string.Concat("OnEnable() ", device, ", Use default material"));
				Material material = Resources.Load("CtrColorBeam3") as Material;
				if (material == null)
				{
					PrintDebugLog(string.Concat("OnEnable() ", device, ", Can NOT load default material"));
				}
				meshRenderer.material = material;
			}
			meshRenderer.enabled = false;
			preEndOffset = EndOffset;
			preStartOffset = StartOffset;
			preStartColor = StartColor;
			PrintDebugLog(string.Concat("OnEnable() ", device, ", parent name: ", gameObject.name, ", localPos: ", gameObject.transform.localPosition.x, ", ", gameObject.transform.localPosition.y, ", ", gameObject.transform.localPosition.z, ", parent local EulerAngles: ", gameObject.transform.localEulerAngles.ToString(), ", show beam: ", meshRenderer.enabled.ToString(), ", StartWidth: ", StartWidth, ", EndWidth: ", EndWidth, ", StartOffset: ", StartOffset, ", EndOffset: ", EndOffset, ", StartColor: ", StartColor.ToString(), ", EndColor: ", EndColor.ToString()));
			isBeamEnable = true;
		}
		connected = false;
	}

	private void OnDisable()
	{
		PrintDebugLog("OnDisable() " + device);
		showBeamMesh(show: false);
		isBeamEnable = false;
	}

	private void OnApplicationPause(bool pauseStatus)
	{
		if (!pauseStatus)
		{
			PrintDebugLog(string.Concat("OnApplicationPause() ", device, ", App resume, reset connection."));
			connected = false;
		}
	}

	public void Update()
	{
		ValidateBeamAttributes();
		if (updateEveryFrame || toUpdateBeam)
		{
			createBeamMesh();
			if (toUpdateBeam)
			{
				toUpdateBeam = !toUpdateBeam;
			}
		}
		if (ListenToDevice)
		{
			bool flag = checkConnection();
			if (connected != flag)
			{
				connected = flag;
			}
			showBeamMesh(ShowBeam && connected);
		}
		else
		{
			showBeamMesh(ShowBeam);
		}
		if (WVR_Log.Log.gpl.Print)
		{
			PrintDebugLog(string.Concat("Update() ", device, ", ", base.gameObject.name, " is ", ShowBeam ? "shown" : "hidden", ", start offset: ", StartOffset, ", end offset: ", EndOffset, ", start width: ", StartWidth, ", end width: ", EndWidth, ", start color: ", StartColor, ", end color: ", EndColor));
		}
	}

	private void createMesh()
	{
		updateMesh.Clear();
		uvs.Clear();
		vertices.Clear();
		normals.Clear();
		indices.Clear();
		colors.Clear();
		mat44_rot = Matrix4x4.zero;
		mat44_uv = Matrix4x4.zero;
		for (int i = 0; i < Count; i++)
		{
			int num = (int)((float)i * 360f / (float)count);
			int num2 = i * maxUVAngle / count;
			mat44_rot.SetTRS(Vector3.zero, Quaternion.AngleAxis(num, Vector3.forward), Vector3.one);
			mat44_uv.SetTRS(Vector3.zero, Quaternion.AngleAxis(num2, Vector3.forward), Vector3.one);
			vec3_vertices_start.y = StartWidth;
			vec3_vertices_start.z = StartOffset;
			vertices.Add(mat44_rot.MultiplyVector(vec3_vertices_start));
			uvs.Add(vec2_05_05);
			colors.Add(StartColor);
			normals.Add(mat44_rot.MultiplyVector(Vector3.up).normalized);
			vec3_vertices_end.y = EndWidth;
			vec3_vertices_end.z = EndOffset;
			vertices.Add(mat44_rot.MultiplyVector(vec3_vertices_end));
			Vector2 item = mat44_uv.MultiplyVector(vec3_0_05_0);
			item.x += 0.5f;
			item.y += 0.5f;
			uvs.Add(item);
			colors.Add(EndColor);
			normals.Add(mat44_rot.MultiplyVector(Vector3.up).normalized);
		}
		for (int j = 0; j < count; j++)
		{
			int item2 = j * 2;
			int item3 = j * 2 + 1;
			int item4 = j * 2 + 2;
			int item5 = j * 2 + 3;
			indices.Add(item2);
			indices.Add(item5);
			indices.Add(item3);
			indices.Add(item2);
			indices.Add(item4);
			indices.Add(item5);
		}
		if (makeTail)
		{
			vertices.Add(Vector3.zero);
			colors.Add(TailColor);
			uvs.Add(vec2_05_05);
			normals.Add(Vector3.zero);
			int item6 = count * 2;
			for (int k = 0; k < count; k++)
			{
				int num3 = k * 2;
				indices.Add(item6);
				indices.Add(num3 + 2);
				indices.Add(num3);
			}
		}
		updateMesh.vertices = vertices.ToArray();
		updateMesh.colors32 = colors.ToArray();
		updateMesh.normals = normals.ToArray();
		updateMesh.SetIndices(indices.ToArray(), MeshTopology.Triangles, 0);
		updateMesh.name = "Beam";
	}

	private void createBeamMesh()
	{
		Validate();
		createMesh();
		meshIsCreated = true;
	}

	private void showBeamMesh(bool show)
	{
		if (!meshIsCreated && show)
		{
			createBeamMesh();
		}
		if (meshRenderer.enabled != show)
		{
			if (device == WaveVR_Controller.EDeviceType.Head)
			{
				PrintDebugLog(show ? "showBeamMesh() Head, show beam." : "showBeamMesh() Head, hide beam.");
			}
			if (device == WaveVR_Controller.EDeviceType.Dominant)
			{
				PrintDebugLog(show ? "showBeamMesh() Dominant, show beam." : "showBeamMesh() Dominant, hide beam.");
			}
			if (device == WaveVR_Controller.EDeviceType.NonDominant)
			{
				PrintDebugLog(show ? "showBeamMesh() NonDominant, show beam." : "showBeamMesh() NonDominant, hide beam.");
			}
			mf_beam.mesh = (show ? updateMesh : emptyMesh);
			meshRenderer.enabled = show;
		}
	}

	private Color32 StringToColor32(string color_string)
	{
		try
		{
			byte[] bytes = BitConverter.GetBytes(Convert.ToInt32(color_string.Substring(1, 2), 16));
			byte[] bytes2 = BitConverter.GetBytes(Convert.ToInt32(color_string.Substring(3, 2), 16));
			byte[] bytes3 = BitConverter.GetBytes(Convert.ToInt32(color_string.Substring(5, 2), 16));
			return new Color32(a: BitConverter.GetBytes(Convert.ToInt32(color_string.Substring(7, 2), 16))[0], r: bytes[0], g: bytes2[0], b: bytes3[0]);
		}
		catch (Exception ex)
		{
			WVR_Log.Log.e(LOG_TAG, "StringToColor32 failed: " + ex.ToString());
			return new Color32(byte.MaxValue, byte.MaxValue, byte.MaxValue, 77);
		}
	}

	private void UpdateStartColor(string color_string)
	{
		try
		{
			byte[] bytes = BitConverter.GetBytes(Convert.ToInt32(color_string.Substring(1, 2), 16));
			byte[] bytes2 = BitConverter.GetBytes(Convert.ToInt32(color_string.Substring(3, 2), 16));
			byte[] bytes3 = BitConverter.GetBytes(Convert.ToInt32(color_string.Substring(5, 2), 16));
			byte[] bytes4 = BitConverter.GetBytes(Convert.ToInt32(color_string.Substring(7, 2), 16));
			StartColor.r = bytes[0];
			StartColor.g = bytes2[0];
			StartColor.b = bytes3[0];
			StartColor.a = bytes4[0];
		}
		catch (Exception ex)
		{
			WVR_Log.Log.e(LOG_TAG, "UpdateStartColor failed: " + ex.ToString());
			StartColor = new Color32(byte.MaxValue, byte.MaxValue, byte.MaxValue, byte.MaxValue);
		}
	}

	private void UpdateEndColor(string color_string)
	{
		try
		{
			byte[] bytes = BitConverter.GetBytes(Convert.ToInt32(color_string.Substring(1, 2), 16));
			byte[] bytes2 = BitConverter.GetBytes(Convert.ToInt32(color_string.Substring(3, 2), 16));
			byte[] bytes3 = BitConverter.GetBytes(Convert.ToInt32(color_string.Substring(5, 2), 16));
			byte[] bytes4 = BitConverter.GetBytes(Convert.ToInt32(color_string.Substring(7, 2), 16));
			EndColor.r = bytes[0];
			EndColor.g = bytes2[0];
			EndColor.b = bytes3[0];
			EndColor.a = bytes4[0];
		}
		catch (Exception ex)
		{
			string color_string2 = "#FFFFFF4D";
			WVR_Log.Log.e(LOG_TAG, "UpdateEndColor failed: " + ex.ToString());
			EndColor = StringToColor32(color_string2);
		}
	}

	private bool checkConnection()
	{
		bool flag = false;
		WaveVR.Device deviceByType = WaveVR.Instance.getDeviceByType(device);
		flag = deviceByType.connected;
		_ = deviceByType.type;
		return flag;
	}
}
public class WaveVR_ButtonList : MonoBehaviour
{
	public enum EButtons
	{
		Unavailable = 0,
		Menu = 1,
		Grip = 2,
		DPadUp = 4,
		DPadRight = 5,
		DPadDown = 6,
		DPadLeft = 3,
		VolumeUp = 7,
		VolumeDown = 8,
		Back = 14,
		Enter = 15,
		Touchpad = 16,
		Trigger = 17,
		Thumbstick = 18
	}

	public enum EHmdButtons
	{
		Menu = 1,
		DPadUp = 4,
		DPadRight = 5,
		DPadDown = 6,
		DPadLeft = 3,
		VolumeUp = 7,
		VolumeDown = 8,
		Enter = 15,
		Touchpad = 16
	}

	public enum EControllerButtons
	{
		Menu = 1,
		Grip = 2,
		DPadUp = 4,
		DPadRight = 5,
		DPadDown = 6,
		DPadLeft = 3,
		VolumeUp = 7,
		VolumeDown = 8,
		Touchpad = 16,
		Trigger = 17,
		Thumbstick = 18
	}

	private static string LOG_TAG = "WaveVR_ButtonList";

	public List<EHmdButtons> HmdButtons;

	private WVR_InputAttribute_t[] inputAttributes_hmd;

	private List<WVR_InputId> usableButtons_hmd = new List<WVR_InputId>();

	private bool hmd_connected;

	public List<EControllerButtons> DominantButtons;

	private WVR_InputAttribute_t[] inputAttributes_Dominant;

	private List<WVR_InputId> usableButtons_dominant = new List<WVR_InputId>();

	private bool dominant_connected;

	public List<EControllerButtons> NonDominantButtons;

	private WVR_InputAttribute_t[] inputAttributes_NonDominant;

	private List<WVR_InputId> usableButtons_nonDominant = new List<WVR_InputId>();

	private bool nodomint_connected;

	private const uint inputTableSize = 32u;

	private WVR_InputMappingPair_t[] inputTableHMD = new WVR_InputMappingPair_t[32];

	private uint inputTableHMDSize;

	private WVR_InputMappingPair_t[] inputTableDominant = new WVR_InputMappingPair_t[32];

	private uint inputTableDominantSize;

	private WVR_InputMappingPair_t[] inputTableNonDominant = new WVR_InputMappingPair_t[32];

	private uint inputTableNonDominantSize;

	private static WaveVR_ButtonList instance = null;

	public static WaveVR_ButtonList Instance => instance;

	private void INFO(string msg)
	{
		WVR_Log.Log.i(LOG_TAG, msg, logInEditor: true);
	}

	private void DEBUG(string msg)
	{
		if (WVR_Log.Log.EnableDebugLog)
		{
			WVR_Log.Log.d(LOG_TAG, msg, logInEditor: true);
		}
	}

	public EButtons GetEButtonsType(WVR_InputId button)
	{
		EButtons eButtons = EButtons.Unavailable;
		return button switch
		{
			WVR_InputId.WVR_InputId_1 => EButtons.Menu, 
			WVR_InputId.WVR_InputId_2 => EButtons.Grip, 
			WVR_InputId.WVR_InputId_4 => EButtons.DPadUp, 
			WVR_InputId.WVR_InputId_5 => EButtons.DPadRight, 
			WVR_InputId.WVR_InputId_6 => EButtons.DPadDown, 
			WVR_InputId.WVR_InputId_3 => EButtons.DPadLeft, 
			WVR_InputId.WVR_InputId_7 => EButtons.VolumeUp, 
			WVR_InputId.WVR_InputId_8 => EButtons.VolumeDown, 
			WVR_InputId.WVR_InputId_14 => EButtons.Back, 
			WVR_InputId.WVR_InputId_15 => EButtons.Enter, 
			WVR_InputId.WVR_InputId_16 => EButtons.Touchpad, 
			WVR_InputId.WVR_InputId_17 => EButtons.Trigger, 
			WVR_InputId.WVR_InputId_18 => EButtons.Thumbstick, 
			_ => EButtons.Unavailable, 
		};
	}

	private List<EButtons> ToEButtons(List<EHmdButtons> eList)
	{
		List<EButtons> list = new List<EButtons>();
		for (int i = 0; i < eList.Count; i++)
		{
			if (!list.Contains((EButtons)eList[i]))
			{
				list.Add((EButtons)eList[i]);
			}
		}
		return list;
	}

	private List<EButtons> ToEButtons(List<EControllerButtons> eList)
	{
		List<EButtons> list = new List<EButtons>();
		for (int i = 0; i < eList.Count; i++)
		{
			if (!list.Contains((EButtons)eList[i]))
			{
				list.Add((EButtons)eList[i]);
			}
		}
		return list;
	}

	private void Awake()
	{
		if (instance == null)
		{
			instance = this;
		}
	}

	private void Start()
	{
		INFO("Start()");
		ResetAllInputRequest();
	}

	private void Update()
	{
		bool connected = WaveVR_Controller.Input(WaveVR_Controller.EDeviceType.Head).connected;
		bool connected2 = WaveVR_Controller.Input(WaveVR_Controller.EDeviceType.Dominant).connected;
		bool connected3 = WaveVR_Controller.Input(WaveVR_Controller.EDeviceType.NonDominant).connected;
		if (hmd_connected != connected)
		{
			hmd_connected = connected;
			if (hmd_connected)
			{
				DEBUG("Update() HMD is connected.");
			}
		}
		if (dominant_connected != connected2)
		{
			dominant_connected = connected2;
			if (dominant_connected)
			{
				DEBUG("Update() Dominant is connected.");
			}
		}
		if (nodomint_connected != connected3)
		{
			nodomint_connected = connected3;
			if (nodomint_connected)
			{
				DEBUG("Update() NonDominant is connected.");
			}
		}
	}

	public bool GetInputMappingPair(WaveVR_Controller.EDeviceType device, ref EButtons destination)
	{
		WVR_InputId destination2 = (WVR_InputId)destination;
		bool inputMappingPair = GetInputMappingPair(device, ref destination2);
		if (inputMappingPair)
		{
			destination = GetEButtonsType(destination2);
		}
		return inputMappingPair;
	}

	public bool GetInputMappingPair(WaveVR_Controller.EDeviceType device, ref WVR_InputId destination)
	{
		if (!WaveVR.Instance.Initialized)
		{
			return false;
		}
		bool result = false;
		int num = 0;
		switch (device)
		{
		case WaveVR_Controller.EDeviceType.Head:
			if (inputTableHMDSize == 0)
			{
				break;
			}
			for (num = 0; num < (int)inputTableHMDSize; num++)
			{
				if (inputTableHMD[num].destination.id == destination)
				{
					destination = inputTableHMD[num].source.id;
					result = true;
				}
			}
			break;
		case WaveVR_Controller.EDeviceType.Dominant:
			if (inputTableDominantSize == 0)
			{
				break;
			}
			for (num = 0; num < (int)inputTableDominantSize; num++)
			{
				if (inputTableDominant[num].destination.id == destination)
				{
					destination = inputTableDominant[num].source.id;
					result = true;
				}
			}
			break;
		case WaveVR_Controller.EDeviceType.NonDominant:
			if (inputTableNonDominantSize == 0)
			{
				break;
			}
			for (num = 0; num < (int)inputTableNonDominantSize; num++)
			{
				if (inputTableNonDominant[num].destination.id == destination)
				{
					destination = inputTableNonDominant[num].source.id;
					result = true;
				}
			}
			break;
		}
		return result;
	}

	private void setupButtonAttributes(WaveVR_Controller.EDeviceType device, List<EButtons> buttons, WVR_InputAttribute_t[] inputAttributes, int count)
	{
		WVR_DeviceType deviceType = WaveVR_Controller.Input(device).DeviceType;
		for (int i = 0; i < count; i++)
		{
			switch (buttons[i])
			{
			case EButtons.Menu:
			case EButtons.Grip:
			case EButtons.DPadLeft:
			case EButtons.DPadUp:
			case EButtons.DPadRight:
			case EButtons.DPadDown:
			case EButtons.VolumeUp:
			case EButtons.VolumeDown:
			case EButtons.Back:
			case EButtons.Enter:
				inputAttributes[i].id = (WVR_InputId)buttons[i];
				inputAttributes[i].capability = 1u;
				inputAttributes[i].axis_type = WVR_AnalogType.WVR_AnalogType_None;
				break;
			case EButtons.Touchpad:
			case EButtons.Thumbstick:
				inputAttributes[i].id = (WVR_InputId)buttons[i];
				inputAttributes[i].capability = 7u;
				inputAttributes[i].axis_type = WVR_AnalogType.WVR_AnalogType_2D;
				break;
			case EButtons.Trigger:
				inputAttributes[i].id = (WVR_InputId)buttons[i];
				inputAttributes[i].capability = 7u;
				inputAttributes[i].axis_type = WVR_AnalogType.WVR_AnalogType_1D;
				break;
			}
			DEBUG(string.Concat("setupButtonAttributes() ", device, " (", deviceType, ") ", buttons[i], ", capability: ", inputAttributes[i].capability, ", analog type: ", inputAttributes[i].axis_type));
		}
	}

	private void createHmdRequestAttributes()
	{
		INFO("createHmdRequestAttributes()");
		List<EButtons> list = ToEButtons(HmdButtons);
		if (!list.Contains(EButtons.Enter))
		{
			list.Add(EButtons.Enter);
		}
		int count = list.Count;
		inputAttributes_hmd = new WVR_InputAttribute_t[count];
		setupButtonAttributes(WaveVR_Controller.EDeviceType.Head, list, inputAttributes_hmd, count);
	}

	private void createDominantRequestAttributes()
	{
		INFO("createDominantRequestAttributes()");
		List<EButtons> list = ToEButtons(DominantButtons);
		int count = list.Count;
		inputAttributes_Dominant = new WVR_InputAttribute_t[count];
		setupButtonAttributes(WaveVR_Controller.EDeviceType.Dominant, list, inputAttributes_Dominant, count);
	}

	private void createNonDominantRequestAttributes()
	{
		INFO("createNonDominantRequestAttributes()");
		List<EButtons> list = ToEButtons(NonDominantButtons);
		int count = list.Count;
		inputAttributes_NonDominant = new WVR_InputAttribute_t[count];
		setupButtonAttributes(WaveVR_Controller.EDeviceType.NonDominant, list, inputAttributes_NonDominant, count);
	}

	public bool IsButtonAvailable(WaveVR_Controller.EDeviceType device, EButtons button)
	{
		return IsButtonAvailable(device, (WVR_InputId)button);
	}

	public bool IsButtonAvailable(WaveVR_Controller.EDeviceType device, WVR_InputId button)
	{
		return device switch
		{
			WaveVR_Controller.EDeviceType.Head => usableButtons_hmd.Contains(button), 
			WaveVR_Controller.EDeviceType.Dominant => usableButtons_dominant.Contains(button), 
			WaveVR_Controller.EDeviceType.NonDominant => usableButtons_nonDominant.Contains(button), 
			_ => false, 
		};
	}

	private void SetHmdInputRequest()
	{
		usableButtons_hmd.Clear();
		if (!WaveVR.Instance.Initialized)
		{
			return;
		}
		WVR_DeviceType deviceType = WaveVR_Controller.Input(WaveVR_Controller.EDeviceType.Head).DeviceType;
		if (!Interop.WVR_SetInputRequest(deviceType, inputAttributes_hmd, (uint)inputAttributes_hmd.Length))
		{
			return;
		}
		inputTableHMDSize = Interop.WVR_GetInputMappingTable(deviceType, inputTableHMD, 32u);
		if (inputTableHMDSize == 0)
		{
			return;
		}
		for (int i = 0; i < (int)inputTableHMDSize; i++)
		{
			if (inputTableHMD[i].source.capability != 0)
			{
				usableButtons_hmd.Add(inputTableHMD[i].destination.id);
				DEBUG(string.Concat("SetHmdInputRequest() ", deviceType, " button: ", inputTableHMD[i].source.id, "(capability: ", inputTableHMD[i].source.capability, ") is mapping to HMD input ID: ", inputTableHMD[i].destination.id));
			}
			else
			{
				DEBUG(string.Concat("SetHmdInputRequest() ", deviceType, " source button ", inputTableHMD[i].source.id, " has invalid capability."));
			}
		}
	}

	private void SetDominantInputRequest()
	{
		usableButtons_dominant.Clear();
		if (!WaveVR.Instance.Initialized)
		{
			return;
		}
		WVR_DeviceType deviceType = WaveVR_Controller.Input(WaveVR_Controller.EDeviceType.Dominant).DeviceType;
		if (!Interop.WVR_SetInputRequest(deviceType, inputAttributes_Dominant, (uint)inputAttributes_Dominant.Length))
		{
			return;
		}
		inputTableDominantSize = Interop.WVR_GetInputMappingTable(deviceType, inputTableDominant, 32u);
		if (inputTableDominantSize == 0)
		{
			return;
		}
		for (int i = 0; i < (int)inputTableDominantSize; i++)
		{
			if (inputTableDominant[i].source.capability != 0)
			{
				usableButtons_dominant.Add(inputTableDominant[i].destination.id);
				DEBUG(string.Concat("SetDominantInputRequest() ", deviceType, " button: ", inputTableDominant[i].source.id, "(capability: ", inputTableDominant[i].source.capability, ") is mapping to Dominant input ID: ", inputTableDominant[i].destination.id));
			}
			else
			{
				DEBUG(string.Concat("SetDominantInputRequest() ", deviceType, " source button ", inputTableDominant[i].source.id, " has invalid capability."));
			}
		}
	}

	private void SetNonDominantInputRequest()
	{
		usableButtons_nonDominant.Clear();
		if (!WaveVR.Instance.Initialized)
		{
			return;
		}
		WVR_DeviceType deviceType = WaveVR_Controller.Input(WaveVR_Controller.EDeviceType.NonDominant).DeviceType;
		if (!Interop.WVR_SetInputRequest(deviceType, inputAttributes_NonDominant, (uint)inputAttributes_NonDominant.Length))
		{
			return;
		}
		inputTableNonDominantSize = Interop.WVR_GetInputMappingTable(deviceType, inputTableNonDominant, 32u);
		if (inputTableNonDominantSize == 0)
		{
			return;
		}
		for (int i = 0; i < (int)inputTableNonDominantSize; i++)
		{
			if (inputTableNonDominant[i].source.capability != 0)
			{
				usableButtons_nonDominant.Add(inputTableNonDominant[i].destination.id);
				DEBUG(string.Concat("SetNonDominantInputRequest() ", deviceType, " button: ", inputTableNonDominant[i].source.id, "(capability: ", inputTableNonDominant[i].source.capability, ") is mapping to NonDominant input ID: ", inputTableNonDominant[i].destination.id));
			}
			else
			{
				DEBUG(string.Concat("SetNonDominantInputRequest() ", deviceType, " source button ", inputTableNonDominant[i].source.id, " has invalid capability."));
			}
		}
	}

	private void ResetInputRequest(WaveVR_Controller.EDeviceType device)
	{
		DEBUG("ResetInputRequest() " + device);
		switch (device)
		{
		case WaveVR_Controller.EDeviceType.Head:
			createHmdRequestAttributes();
			SetHmdInputRequest();
			break;
		case WaveVR_Controller.EDeviceType.Dominant:
			createDominantRequestAttributes();
			SetDominantInputRequest();
			break;
		case WaveVR_Controller.EDeviceType.NonDominant:
			createNonDominantRequestAttributes();
			SetNonDominantInputRequest();
			break;
		}
	}

	public void SetupHmdButtonList(List<EHmdButtons> list)
	{
		DEBUG("SetupHmdButtonList()");
		HmdButtons = list;
		ResetInputRequest(WaveVR_Controller.EDeviceType.Head);
	}

	public void SetupControllerButtonList(WaveVR_Controller.EDeviceType device, List<EControllerButtons> list)
	{
		DEBUG("SetupControllerButtonList() " + device);
		switch (device)
		{
		case WaveVR_Controller.EDeviceType.Dominant:
			DominantButtons = list;
			ResetInputRequest(WaveVR_Controller.EDeviceType.Dominant);
			break;
		case WaveVR_Controller.EDeviceType.NonDominant:
			NonDominantButtons = list;
			ResetInputRequest(WaveVR_Controller.EDeviceType.NonDominant);
			break;
		}
	}

	public void ResetAllInputRequest()
	{
		DEBUG("ResetAllInputRequest()");
		ResetInputRequest(WaveVR_Controller.EDeviceType.Head);
		ResetInputRequest(WaveVR_Controller.EDeviceType.Dominant);
		ResetInputRequest(WaveVR_Controller.EDeviceType.NonDominant);
	}
}
[RequireComponent(typeof(Camera))]
public class WaveVR_Camera : MonoBehaviour, IEquatable<Camera>
{
	private class RenderThreadContext : wvr.render.utils.Message
	{
		public int antialiasing;

		public uint textureId;

		public uint depthId;

		public static void IssueUpdateConfig(RenderThreadSyncObject syncObj, uint textureId, uint depthId, int antialiasing)
		{
			PreAllocatedQueue queue = syncObj.Queue;
			lock (queue)
			{
				RenderThreadContext renderThreadContext = queue.Obtain<RenderThreadContext>();
				renderThreadContext.textureId = textureId;
				renderThreadContext.depthId = depthId;
				renderThreadContext.antialiasing = antialiasing;
				queue.Enqueue(renderThreadContext);
			}
			syncObj.IssueEvent();
		}

		public static void ReceiveBeforeOpaque(PreAllocatedQueue queue)
		{
			if (contextRTOnly.textureId == 0)
			{
				WVR_Log.Log.w(TAG, "Single pass textures are not ready");
				return;
			}
			int attachment = 36064;
			int attachment2 = 33306;
			int target = 36009;
			UGL.FramebufferTexture2D(target, attachment, 3553, 0u, 0);
			UGL.FramebufferRenderbuffer(target, attachment2, 36161, 0u);
			if (contextRTOnly.antialiasing > 1)
			{
				UGL.FramebufferTextureMultisampleMultiviewOVR(target, attachment, contextRTOnly.textureId, 0, contextRTOnly.antialiasing, 0, 2);
				UGL.FramebufferTextureMultisampleMultiviewOVR(target, attachment2, contextRTOnly.depthId, 0, contextRTOnly.antialiasing, 0, 2);
			}
			else
			{
				UGL.FramebufferTextureMultiviewOVR(target, attachment, contextRTOnly.textureId, 0, 0, 2);
				UGL.FramebufferTextureMultiviewOVR(target, attachment2, contextRTOnly.depthId, 0, 0, 2);
			}
			UGL.Clear(17664u);
			contextRTOnly.textureId = 0u;
			contextRTOnly.depthId = 0u;
		}

		public static void ReceiveUpdateConfig(PreAllocatedQueue queue)
		{
			lock (queue)
			{
				RenderThreadContext renderThreadContext = (RenderThreadContext)queue.Dequeue();
				renderThreadContext.CopyTo(contextRTOnly);
				queue.Release(renderThreadContext);
			}
		}

		public void CopyTo(RenderThreadContext dest)
		{
			dest.antialiasing = antialiasing;
			dest.textureId = textureId;
			dest.depthId = depthId;
		}
	}

	private static string TAG = "WVR_Camera";

	public WVR_Eye eye = WVR_Eye.WVR_Eye_None;

	private Camera cam;

	private static readonly RenderThreadContext contextRTOnly = new RenderThreadContext();

	private static readonly RenderThreadSyncObject RTSOBeforeOpaque = new RenderThreadSyncObject(RenderThreadContext.ReceiveBeforeOpaque);

	private static readonly RenderThreadSyncObject RTSOUpdateConfig = new RenderThreadSyncObject(RenderThreadContext.ReceiveUpdateConfig);

	private Matrix4x4 unity_SingleCullMatrixP;

	private readonly Matrix4x4[] unity_StereoMatrixP = new Matrix4x4[2]
	{
		Matrix4x4.identity,
		Matrix4x4.identity
	};

	private readonly Matrix4x4[] unity_StereoMatrixInvP = new Matrix4x4[2]
	{
		Matrix4x4.identity,
		Matrix4x4.identity
	};

	private readonly Matrix4x4[] unity_StereoWorldToCamera = new Matrix4x4[2]
	{
		Matrix4x4.identity,
		Matrix4x4.identity
	};

	private readonly Matrix4x4[] unity_StereoCameraToWorld = new Matrix4x4[2]
	{
		Matrix4x4.identity,
		Matrix4x4.identity
	};

	private readonly Matrix4x4[] unity_StereoMatrixVP = new Matrix4x4[2]
	{
		Matrix4x4.identity,
		Matrix4x4.identity
	};

	private readonly Vector4[] eyesOffset = new Vector4[2];

	private readonly Matrix4x4[] eyesOffsetMatrix = new Matrix4x4[2];

	private readonly Matrix4x4[] eyesOffsetMatrixInv = new Matrix4x4[2];

	private readonly Matrix4x4[] skybox_MatrixVP = new Matrix4x4[2]
	{
		Matrix4x4.identity,
		Matrix4x4.identity
	};

	private readonly Vector4[] unity_StereoScaleOffset = new Vector4[2]
	{
		new Vector4(1f, 1f, 0f, 0f),
		new Vector4(1f, 1f, 0f, 0f)
	};

	private readonly Vector4[] stereoWorldSpaceCameraPos = new Vector4[2]
	{
		Vector4.zero,
		Vector4.zero
	};

	private CommandBuffer cmdBufBeforeForwardOpaque;

	private CommandBuffer cmdBufBeforeSkybox;

	private CommandBuffer cmdBufAfterSkybox;

	private bool needInitPropertyId = true;

	private int id_unity_StereoCameraProjection;

	private int id_unity_StereoCameraInvProjection;

	private int id_unity_StereoMatrixP;

	private int id_unity_StereoCameraToWorld;

	private int id_unity_StereoWorldToCamera;

	private int id_unity_StereoWorldSpaceCameraPos;

	private int id_unity_StereoMatrixV;

	private int id_unity_StereoMatrixInvV;

	private int id_unity_StereoMatrixVP;

	private int id_unity_StereoScaleOffset;

	private void Start()
	{
		cam = GetComponent<Camera>();
	}

	public Camera GetCamera()
	{
		if (cam != null)
		{
			return cam;
		}
		cam = GetComponent<Camera>();
		return cam;
	}

	[Obsolete("Use GetCamera() inestad.")]
	public Camera getCamera()
	{
		if (cam != null)
		{
			return cam;
		}
		cam = GetComponent<Camera>();
		return cam;
	}

	public bool Equals(Camera other)
	{
		return cam == other;
	}

	private void OnPreRender()
	{
		if (eye == WVR_Eye.WVR_Eye_Both)
		{
			SinglePassPreRender();
		}
	}

	private void OnPostRender()
	{
		if (eye == WVR_Eye.WVR_Eye_Both)
		{
			SinglePassPostRender();
		}
	}

	private void SetStereoViewAndCullingMatrix(Matrix4x4 left, Matrix4x4 right)
	{
		cam.SetStereoViewMatrix(Camera.StereoscopicEye.Left, left);
		cam.SetStereoViewMatrix(Camera.StereoscopicEye.Right, right);
		if (!cam.areVRStereoViewMatricesWithinSingleCullTolerance)
		{
			WVR_Log.Log.e(TAG, "The Camera.areVRStereoViewMatricesWithinSingleCullTolerance are false.  SinglePass may not enabled.");
		}
	}

	private void DebugLogMatrix(ref Matrix4x4 m, string name)
	{
		WVR_Log.Log.w(TAG, name + ":\n/ " + m.m00 + " " + m.m01 + " " + m.m02 + " " + m.m03 + " \\\n| " + m.m10 + " " + m.m11 + " " + m.m12 + " " + m.m13 + " |\n| " + m.m20 + " " + m.m21 + " " + m.m22 + " " + m.m23 + " |\n\\ " + m.m30 + " " + m.m31 + " " + m.m32 + " " + m.m33 + " /");
	}

	private void PrepareCommandBuffers()
	{
		if (cmdBufBeforeForwardOpaque == null)
		{
			cmdBufBeforeForwardOpaque = new CommandBuffer();
			RTSOBeforeOpaque.IssueInCommandBuffer(cmdBufBeforeForwardOpaque);
			cmdBufBeforeForwardOpaque.name = "SinglePassPrepare";
		}
		cam.RemoveCommandBuffer(CameraEvent.BeforeForwardOpaque, cmdBufBeforeForwardOpaque);
		cam.AddCommandBuffer(CameraEvent.BeforeForwardOpaque, cmdBufBeforeForwardOpaque);
		if (cmdBufAfterSkybox == null)
		{
			cmdBufAfterSkybox = new CommandBuffer();
		}
		cam.RemoveCommandBuffer(CameraEvent.AfterSkybox, cmdBufAfterSkybox);
		cmdBufAfterSkybox.Clear();
		cmdBufAfterSkybox.SetGlobalMatrixArray(id_unity_StereoMatrixVP, unity_StereoMatrixVP);
		cmdBufAfterSkybox.name = "SinglePassAfterSkyBox";
		cam.AddCommandBuffer(CameraEvent.AfterSkybox, cmdBufAfterSkybox);
		if (cmdBufBeforeSkybox == null)
		{
			cmdBufBeforeSkybox = new CommandBuffer();
		}
		Matrix4x4 rhs = (Matrix4x4.LookAt(Vector3.zero, cam.transform.forward, cam.transform.up) * Matrix4x4.Scale(new Vector3(1f, 1f, -1f))).transpose;
		Matrix4x4 lhs = unity_StereoMatrixP[0];
		Matrix4x4 lhs2 = unity_StereoMatrixP[1];
		lhs.m22 = -1f;
		lhs2.m22 = -1f;
		M4Multiply(ref skybox_MatrixVP[0], ref lhs, ref rhs);
		M4Multiply(ref skybox_MatrixVP[1], ref lhs2, ref rhs);
		cam.RemoveCommandBuffer(CameraEvent.BeforeSkybox, cmdBufBeforeSkybox);
		cmdBufBeforeSkybox.Clear();
		cmdBufBeforeSkybox.SetGlobalMatrixArray(id_unity_StereoMatrixVP, skybox_MatrixVP);
		cmdBufBeforeSkybox.name = "SinglePassBeforeSkybox";
		cam.AddCommandBuffer(CameraEvent.BeforeSkybox, cmdBufBeforeSkybox);
	}

	private void SinglePassPreRender()
	{
		if (needInitPropertyId)
		{
			id_unity_StereoCameraProjection = Shader.PropertyToID("unity_StereoCameraProjection");
			id_unity_StereoCameraInvProjection = Shader.PropertyToID("unity_StereoCameraInvProjection");
			id_unity_StereoMatrixP = Shader.PropertyToID("unity_StereoMatrixP");
			id_unity_StereoCameraToWorld = Shader.PropertyToID("unity_StereoCameraToWorld");
			id_unity_StereoWorldToCamera = Shader.PropertyToID("unity_StereoWorldToCamera");
			id_unity_StereoWorldSpaceCameraPos = Shader.PropertyToID("unity_StereoWorldSpaceCameraPos");
			id_unity_StereoMatrixV = Shader.PropertyToID("unity_StereoMatrixV");
			id_unity_StereoMatrixInvV = Shader.PropertyToID("unity_StereoMatrixInvV");
			id_unity_StereoMatrixVP = Shader.PropertyToID("unity_StereoMatrixVP");
			id_unity_StereoScaleOffset = Shader.PropertyToID("unity_StereoScaleOffset");
			needInitPropertyId = false;
		}
		TexturePoolRenderTexture2DArray both = WaveVR_Render.Instance.textureManager.both;
		if (both != null)
		{
			RenderThreadContext.IssueUpdateConfig(RTSOUpdateConfig, (uint)both.currentPtr, (uint)both.currentDepthPtr, cam.allowMSAA ? QualitySettings.antiAliasing : 0);
			Shader.SetGlobalMatrixArray(id_unity_StereoCameraProjection, unity_StereoMatrixP);
			Shader.SetGlobalMatrixArray(id_unity_StereoCameraInvProjection, unity_StereoMatrixInvP);
			Shader.SetGlobalMatrixArray(id_unity_StereoMatrixP, unity_StereoMatrixP);
			Matrix4x4 rhs = cam.worldToCameraMatrix;
			Matrix4x4 lhs = cam.cameraToWorldMatrix;
			M4Multiply(ref unity_StereoCameraToWorld[0], ref lhs, ref eyesOffsetMatrix[0]);
			M4Multiply(ref unity_StereoCameraToWorld[1], ref lhs, ref eyesOffsetMatrix[1]);
			M4Multiply(ref unity_StereoWorldToCamera[0], ref eyesOffsetMatrixInv[0], ref rhs);
			M4Multiply(ref unity_StereoWorldToCamera[1], ref eyesOffsetMatrixInv[1], ref rhs);
			Shader.SetGlobalMatrixArray(id_unity_StereoCameraToWorld, unity_StereoCameraToWorld);
			Shader.SetGlobalMatrixArray(id_unity_StereoWorldToCamera, unity_StereoWorldToCamera);
			Vector4 lhs2 = cam.transform.position;
			V4Add(ref stereoWorldSpaceCameraPos[0], ref lhs2, ref eyesOffset[0]);
			V4Add(ref stereoWorldSpaceCameraPos[1], ref lhs2, ref eyesOffset[1]);
			Shader.SetGlobalVectorArray(id_unity_StereoWorldSpaceCameraPos, stereoWorldSpaceCameraPos);
			Shader.SetGlobalMatrixArray(id_unity_StereoMatrixV, unity_StereoWorldToCamera);
			Shader.SetGlobalMatrixArray(id_unity_StereoMatrixInvV, unity_StereoCameraToWorld);
			M4Multiply(ref unity_StereoMatrixVP[0], ref unity_StereoMatrixP[0], ref unity_StereoWorldToCamera[0]);
			M4Multiply(ref unity_StereoMatrixVP[1], ref unity_StereoMatrixP[1], ref unity_StereoWorldToCamera[1]);
			Shader.SetGlobalMatrixArray(id_unity_StereoMatrixVP, unity_StereoMatrixVP);
			Shader.SetGlobalVectorArray(id_unity_StereoScaleOffset, unity_StereoScaleOffset);
			PrepareCommandBuffers();
		}
	}

	private void SinglePassPostRender()
	{
		cam.ResetStereoViewMatrices();
	}

	public void SetEyesPosition(Vector3 left, Vector3 right)
	{
		eyesOffset[0] = left;
		eyesOffset[1] = right;
		eyesOffsetMatrix[0] = Matrix4x4.TRS(left, Quaternion.identity, base.transform.localScale);
		eyesOffsetMatrix[1] = Matrix4x4.TRS(right, Quaternion.identity, base.transform.localScale);
		eyesOffsetMatrixInv[0] = eyesOffsetMatrix[0].inverse;
		eyesOffsetMatrixInv[1] = eyesOffsetMatrix[1].inverse;
	}

	public void SetStereoCullingMatrix()
	{
		cam.cullingMatrix = unity_SingleCullMatrixP * cam.worldToCameraMatrix;
	}

	public void SetStereoProjectionMatrix(Matrix4x4 left, Matrix4x4 right, Matrix4x4 cull)
	{
		GetCamera();
		cam.ResetStereoProjectionMatrices();
		unity_StereoMatrixP[0] = left;
		unity_StereoMatrixInvP[0] = left.inverse;
		unity_StereoMatrixP[1] = right;
		unity_StereoMatrixInvP[1] = right.inverse;
		unity_SingleCullMatrixP = cull;
		DebugLogMatrix(ref unity_SingleCullMatrixP, "unity_SingleCullMatrixP");
	}

	private static void M4Multiply(ref Matrix4x4 mout, ref Matrix4x4 lhs, ref Matrix4x4 rhs)
	{
		mout.m00 = lhs.m00 * rhs.m00 + lhs.m01 * rhs.m10 + lhs.m02 * rhs.m20 + lhs.m03 * rhs.m30;
		mout.m10 = lhs.m10 * rhs.m00 + lhs.m11 * rhs.m10 + lhs.m12 * rhs.m20 + lhs.m13 * rhs.m30;
		mout.m20 = lhs.m20 * rhs.m00 + lhs.m21 * rhs.m10 + lhs.m22 * rhs.m20 + lhs.m23 * rhs.m30;
		mout.m30 = lhs.m30 * rhs.m00 + lhs.m31 * rhs.m10 + lhs.m32 * rhs.m20 + lhs.m33 * rhs.m30;
		mout.m01 = lhs.m00 * rhs.m01 + lhs.m01 * rhs.m11 + lhs.m02 * rhs.m21 + lhs.m03 * rhs.m31;
		mout.m11 = lhs.m10 * rhs.m01 + lhs.m11 * rhs.m11 + lhs.m12 * rhs.m21 + lhs.m13 * rhs.m31;
		mout.m21 = lhs.m20 * rhs.m01 + lhs.m21 * rhs.m11 + lhs.m22 * rhs.m21 + lhs.m23 * rhs.m31;
		mout.m31 = lhs.m30 * rhs.m01 + lhs.m31 * rhs.m11 + lhs.m32 * rhs.m21 + lhs.m33 * rhs.m31;
		mout.m02 = lhs.m00 * rhs.m02 + lhs.m01 * rhs.m12 + lhs.m02 * rhs.m22 + lhs.m03 * rhs.m32;
		mout.m12 = lhs.m10 * rhs.m02 + lhs.m11 * rhs.m12 + lhs.m12 * rhs.m22 + lhs.m13 * rhs.m32;
		mout.m22 = lhs.m20 * rhs.m02 + lhs.m21 * rhs.m12 + lhs.m22 * rhs.m22 + lhs.m23 * rhs.m32;
		mout.m32 = lhs.m30 * rhs.m02 + lhs.m31 * rhs.m12 + lhs.m32 * rhs.m22 + lhs.m33 * rhs.m32;
		mout.m03 = lhs.m00 * rhs.m03 + lhs.m01 * rhs.m13 + lhs.m02 * rhs.m23 + lhs.m03 * rhs.m33;
		mout.m13 = lhs.m10 * rhs.m03 + lhs.m11 * rhs.m13 + lhs.m12 * rhs.m23 + lhs.m13 * rhs.m33;
		mout.m23 = lhs.m20 * rhs.m03 + lhs.m21 * rhs.m13 + lhs.m22 * rhs.m23 + lhs.m23 * rhs.m33;
		mout.m33 = lhs.m30 * rhs.m03 + lhs.m31 * rhs.m13 + lhs.m32 * rhs.m23 + lhs.m33 * rhs.m33;
	}

	private static void V4Add(ref Vector4 vout, ref Vector4 lhs, ref Vector4 rhs)
	{
		vout.x = lhs.x + rhs.x;
		vout.y = lhs.y + rhs.y;
		vout.z = lhs.z + rhs.z;
		vout.w = lhs.w + rhs.w;
	}
}
public class WaveVR_CameraTexture
{
	public delegate void UpdateCameraCompleted(IntPtr nativeTextureId);

	[Obsolete("StartCameraCompleted delegate is not used in the future")]
	public delegate void StartCameraCompleted(bool result);

	private static string LOG_TAG = "WVR_CameraTexture";

	private WVR_CameraInfo_t camerainfo;

	private bool mStarted;

	private IntPtr nativeTextureId = IntPtr.Zero;

	private IntPtr mframeBuffer = IntPtr.Zero;

	private bool syncPose;

	private WVR_PoseState_t mPoseState;

	private WVR_PoseOriginModel origin = WVR_PoseOriginModel.WVR_PoseOriginModel_OriginOnGround;

	private static WaveVR_CameraTexture mInstance;

	private const bool DEBUG = false;

	public bool isStarted => mStarted;

	public static WaveVR_CameraTexture instance
	{
		get
		{
			if (mInstance == null)
			{
				mInstance = new WaveVR_CameraTexture();
			}
			return mInstance;
		}
	}

	public static event UpdateCameraCompleted UpdateCameraCompletedDelegate;

	[Obsolete("StartCameraCompletedDelegate is not used in the future")]
	public static event StartCameraCompleted StartCameraCompletedDelegate;

	private void PrintDebugLog(string msg)
	{
	}

	private void OnUpdateCameraCompleted(params object[] args)
	{
		if (WaveVR_CameraTexture.UpdateCameraCompletedDelegate != null)
		{
			WaveVR_CameraTexture.UpdateCameraCompletedDelegate(nativeTextureId);
		}
	}

	public IntPtr getNativeTextureId()
	{
		if (!mStarted)
		{
			return IntPtr.Zero;
		}
		return nativeTextureId;
	}

	public bool startCamera()
	{
		if (mStarted)
		{
			return false;
		}
		WaveVR_Utils.Event.Listen("DrawCameraCompleted", OnUpdateCameraCompleted);
		mStarted = Interop.WVR_StartCamera(ref camerainfo);
		WVR_Log.Log.i(LOG_TAG, string.Concat("startCamera, result = ", mStarted.ToString(), " format: ", camerainfo.imgFormat, " size: ", camerainfo.size, " width: ", camerainfo.width, " height: ", camerainfo.height));
		if (mStarted)
		{
			PrintDebugLog("allocate frame buffer");
			mframeBuffer = Marshal.AllocHGlobal((int)camerainfo.size);
			for (int i = 0; i < camerainfo.size; i++)
			{
				Marshal.WriteByte(mframeBuffer, i, 0);
			}
			if (syncPose)
			{
				mPoseState = default(WVR_PoseState_t);
			}
		}
		if (WaveVR_CameraTexture.StartCameraCompletedDelegate != null)
		{
			WaveVR_CameraTexture.StartCameraCompletedDelegate(mStarted);
		}
		return mStarted;
	}

	public void enableSyncPose(bool enable)
	{
		WVR_Log.Log.i(LOG_TAG, "enableSyncPose: " + enable);
		syncPose = enable;
	}

	[Obsolete("Please use getImageType instead")]
	public WVR_CameraImageType GetCameraImageType()
	{
		return camerainfo.imgType;
	}

	public WVR_CameraImageType getImageType()
	{
		if (!mStarted)
		{
			return WVR_CameraImageType.WVR_CameraImageType_Invalid;
		}
		return camerainfo.imgType;
	}

	[Obsolete("Please use getImageFormat instead")]
	public WVR_CameraImageFormat GetCameraImageFormat()
	{
		if (!mStarted)
		{
			return WVR_CameraImageFormat.WVR_CameraImageFormat_Invalid;
		}
		return camerainfo.imgFormat;
	}

	public WVR_CameraImageFormat getImageFormat()
	{
		if (!mStarted)
		{
			return WVR_CameraImageFormat.WVR_CameraImageFormat_Invalid;
		}
		return camerainfo.imgFormat;
	}

	[Obsolete("Please use getImageWidth instead")]
	public uint GetCameraImageWidth()
	{
		if (!mStarted)
		{
			return 0u;
		}
		return camerainfo.width;
	}

	public uint getImageWidth()
	{
		if (!mStarted)
		{
			return 0u;
		}
		return camerainfo.width;
	}

	[Obsolete("Please use getImageHeight instead")]
	public uint GetCameraImageHeight()
	{
		if (!mStarted)
		{
			return 0u;
		}
		return camerainfo.height;
	}

	public uint getImageHeight()
	{
		if (!mStarted)
		{
			return 0u;
		}
		return camerainfo.height;
	}

	public uint getImageSize()
	{
		if (!mStarted)
		{
			return 0u;
		}
		return camerainfo.size;
	}

	public bool isEnableSyncPose()
	{
		if (!mStarted)
		{
			return false;
		}
		return syncPose;
	}

	public IntPtr getNativeFrameBuffer()
	{
		if (!mStarted)
		{
			return IntPtr.Zero;
		}
		return mframeBuffer;
	}

	public void stopCamera()
	{
		if (mStarted)
		{
			WaveVR_Utils.Event.Remove("DrawCameraCompleted", OnUpdateCameraCompleted);
			if (syncPose)
			{
				WVR_Log.Log.i(LOG_TAG, "Reset WaveVR_Render submit pose");
				WaveVR_Render.ResetPoseUsedOnSubmit();
			}
			Interop.WVR_StopCamera();
			if (mframeBuffer != IntPtr.Zero)
			{
				Marshal.FreeHGlobal(mframeBuffer);
				mframeBuffer = IntPtr.Zero;
			}
			WVR_Log.Log.i(LOG_TAG, "Release native texture resources");
			WaveVR_Utils.SendRenderEvent(25);
			mStarted = false;
		}
	}

	public WVR_PoseState_t getFramePose()
	{
		return mPoseState;
	}

	public void updateTexture(IntPtr textureId)
	{
		if (!mStarted)
		{
			WVR_Log.Log.w(LOG_TAG, "Camera not start yet");
			return;
		}
		PrintDebugLog("updateTexture start");
		nativeTextureId = textureId;
		if (WaveVR_Render.Instance != null)
		{
			origin = WaveVR_Render.Instance.origin;
		}
		if (mframeBuffer != IntPtr.Zero)
		{
			uint num = 0u;
			PrintDebugLog("updateTexture frameBuffer and PoseState, predict time:" + num);
			Interop.WVR_GetFrameBufferWithPoseState(mframeBuffer, camerainfo.size, origin, num, ref mPoseState);
			if (syncPose)
			{
				PrintDebugLog("Sync camera frame buffer with poseState, timeStamp: " + mPoseState.PoseTimestamp_ns);
				WaveVR_Render.SetPoseUsedOnSubmit(mPoseState);
			}
			PrintDebugLog("send event to draw OpenGL");
			WaveVR_Utils.SendRenderEvent(24);
		}
	}

	static WaveVR_CameraTexture()
	{
		WaveVR_CameraTexture.UpdateCameraCompletedDelegate = null;
		WaveVR_CameraTexture.StartCameraCompletedDelegate = null;
		mInstance = null;
	}
}
[RequireComponent(typeof(Canvas))]
[Obsolete("The Canvas ScreenSpaceCamera is not workable in VR mode. (Unity design)")]
public class WaveVR_CanvasEye : MonoBehaviour
{
	private Canvas canvas;

	private void Start()
	{
		canvas = GetComponent<Canvas>();
		canvas.worldCamera = null;
	}

	private void OnEnable()
	{
		if ((bool)WaveVR_Render.Instance)
		{
			WaveVR_Render instance = WaveVR_Render.Instance;
			instance.beforeRenderEye = (WaveVR_Render.RenderCallbackWithEyeAndCamera)Delegate.Combine(instance.beforeRenderEye, new WaveVR_Render.RenderCallbackWithEyeAndCamera(MyRenderEye));
		}
	}

	private void OnDisable()
	{
		if ((bool)WaveVR_Render.Instance)
		{
			WaveVR_Render instance = WaveVR_Render.Instance;
			instance.beforeRenderEye = (WaveVR_Render.RenderCallbackWithEyeAndCamera)Delegate.Remove(instance.beforeRenderEye, new WaveVR_Render.RenderCallbackWithEyeAndCamera(MyRenderEye));
		}
	}

	private void MyRenderEye(WaveVR_Render render, WVR_Eye eye, WaveVR_Camera wvrCamera)
	{
		if (eye != WVR_Eye.WVR_Eye_Both)
		{
			Camera camera = wvrCamera.GetCamera();
			canvas.worldCamera = camera;
			canvas.renderMode = RenderMode.ScreenSpaceCamera;
		}
	}
}
public class WaveVR_Controller
{
	public enum EDeviceType
	{
		Head = 1,
		Dominant,
		NonDominant
	}

	public class Device
	{
		private static WVR_InputId[] pressIds = new WVR_InputId[15]
		{
			WVR_InputId.WVR_InputId_0,
			WVR_InputId.WVR_InputId_1,
			WVR_InputId.WVR_InputId_2,
			WVR_InputId.WVR_InputId_3,
			WVR_InputId.WVR_InputId_4,
			WVR_InputId.WVR_InputId_5,
			WVR_InputId.WVR_InputId_6,
			WVR_InputId.WVR_InputId_7,
			WVR_InputId.WVR_InputId_8,
			WVR_InputId.WVR_InputId_9,
			WVR_InputId.WVR_InputId_14,
			WVR_InputId.WVR_InputId_15,
			WVR_InputId.WVR_InputId_16,
			WVR_InputId.WVR_InputId_17,
			WVR_InputId.WVR_InputId_18
		};

		private int[] prevFrameCount_press = new int[pressIds.Length];

		private bool[] state_press = new bool[pressIds.Length];

		private bool[] prevState_press = new bool[pressIds.Length];

		private bool[] event_state_press = new bool[pressIds.Length];

		private static WVR_InputId[] touchIds = new WVR_InputId[3]
		{
			WVR_InputId.WVR_InputId_16,
			WVR_InputId.WVR_InputId_17,
			WVR_InputId.WVR_InputId_18
		};

		private int[] prevFrameCount_touch = new int[touchIds.Length];

		private bool[] state_touch = new bool[touchIds.Length];

		private bool[] prevState_touch = new bool[touchIds.Length];

		private bool[] event_state_touch = new bool[touchIds.Length];

		private int prevFrame_connected = -1;

		private bool _connected;

		private int prevFrame_pose = -1;

		private WVR_PoseState_t pose;

		private WaveVR_Utils.RigidTransform rtPose = WaveVR_Utils.RigidTransform.identity;

		private WVR_Vector3f_t vel;

		private Vector3 v3velocity = Vector3.zero;

		private WVR_Vector3f_t aVel;

		private Vector3 v3AngularVelocity = Vector3.zero;

		private WVR_Axis_t axis;

		public WVR_DeviceType DeviceType { get; private set; }

		public bool connected
		{
			get
			{
				return _connected;
			}
			set
			{
				_connected = value;
				DEBUG(string.Concat("Device ", DeviceType, " is ", _connected ? "connected." : "disconnected."));
			}
		}

		public WaveVR_Utils.RigidTransform transform
		{
			get
			{
				if (!WaveVR.Instance.Initialized)
				{
					return rtPose;
				}
				switch (DeviceType)
				{
				case WVR_DeviceType.WVR_DeviceType_HMD:
					rtPose = WaveVR.Instance.hmd.rigidTransform;
					break;
				case WVR_DeviceType.WVR_DeviceType_Controller_Right:
					rtPose = WaveVR.Instance.controllerRight.rigidTransform;
					break;
				case WVR_DeviceType.WVR_DeviceType_Controller_Left:
					rtPose = WaveVR.Instance.controllerLeft.rigidTransform;
					break;
				}
				return rtPose;
			}
		}

		[Obsolete("This variable will be obsoleted in next release, please use V3Velocity instead.")]
		public WVR_Vector3f_t velocity
		{
			get
			{
				if (!WaveVR.Instance.Initialized)
				{
					return vel;
				}
				switch (DeviceType)
				{
				case WVR_DeviceType.WVR_DeviceType_HMD:
					vel = WaveVR.Instance.hmd.pose.pose.Velocity;
					break;
				case WVR_DeviceType.WVR_DeviceType_Controller_Right:
					vel = WaveVR.Instance.controllerRight.pose.pose.Velocity;
					break;
				case WVR_DeviceType.WVR_DeviceType_Controller_Left:
					vel = WaveVR.Instance.controllerLeft.pose.pose.Velocity;
					break;
				}
				return vel;
			}
		}

		public Vector3 V3Velocity
		{
			get
			{
				if (!WaveVR.Instance.Initialized)
				{
					return v3velocity;
				}
				switch (DeviceType)
				{
				case WVR_DeviceType.WVR_DeviceType_HMD:
					WaveVR_Utils.GetVectorFromGL(WaveVR.Instance.hmd.pose.pose.Velocity, out v3velocity);
					break;
				case WVR_DeviceType.WVR_DeviceType_Controller_Right:
					WaveVR_Utils.GetVectorFromGL(WaveVR.Instance.controllerRight.pose.pose.Velocity, out v3velocity);
					break;
				case WVR_DeviceType.WVR_DeviceType_Controller_Left:
					WaveVR_Utils.GetVectorFromGL(WaveVR.Instance.controllerLeft.pose.pose.Velocity, out v3velocity);
					break;
				}
				return v3velocity;
			}
		}

		[Obsolete("This variable will be obsoleted in next release, please use V3AngularVelocity instead.")]
		public WVR_Vector3f_t AngularVelocity
		{
			get
			{
				if (!WaveVR.Instance.Initialized)
				{
					return aVel;
				}
				switch (DeviceType)
				{
				case WVR_DeviceType.WVR_DeviceType_HMD:
					aVel = WaveVR.Instance.hmd.pose.pose.AngularVelocity;
					break;
				case WVR_DeviceType.WVR_DeviceType_Controller_Right:
					aVel = WaveVR.Instance.controllerRight.pose.pose.AngularVelocity;
					break;
				case WVR_DeviceType.WVR_DeviceType_Controller_Left:
					aVel = WaveVR.Instance.controllerLeft.pose.pose.AngularVelocity;
					break;
				}
				return aVel;
			}
		}

		public Vector3 V3AngularVelocity
		{
			get
			{
				if (!WaveVR.Instance.Initialized)
				{
					return v3AngularVelocity;
				}
				switch (DeviceType)
				{
				case WVR_DeviceType.WVR_DeviceType_HMD:
					WaveVR_Utils.GetVectorFromGL(WaveVR.Instance.hmd.pose.pose.AngularVelocity, out v3AngularVelocity);
					break;
				case WVR_DeviceType.WVR_DeviceType_Controller_Right:
					WaveVR_Utils.GetVectorFromGL(WaveVR.Instance.controllerRight.pose.pose.AngularVelocity, out v3AngularVelocity);
					break;
				case WVR_DeviceType.WVR_DeviceType_Controller_Left:
					WaveVR_Utils.GetVectorFromGL(WaveVR.Instance.controllerLeft.pose.pose.AngularVelocity, out v3AngularVelocity);
					break;
				}
				return v3AngularVelocity;
			}
		}

		public Device(WVR_DeviceType dt)
		{
			DEBUG("Initialize WaveVR_Controller Device: " + dt);
			DeviceType = dt;
			ResetAllButtonStates();
		}

		public void SetEventState_Press(WVR_InputId btn, bool down)
		{
			for (int i = 0; i < pressIds.Length; i++)
			{
				if (pressIds[i] == btn)
				{
					event_state_press[i] = down;
					DEBUG(string.Concat("SetEventState_Press() ", DeviceType, ", ", pressIds[i], ": ", event_state_press[i].ToString()));
					break;
				}
			}
		}

		public bool GetEventState_Press(WVR_InputId btn)
		{
			bool result = false;
			for (int i = 0; i < pressIds.Length; i++)
			{
				if (pressIds[i] == btn)
				{
					result = event_state_press[i];
					break;
				}
			}
			return result;
		}

		public void SetEventState_Touch(WVR_InputId btn, bool down)
		{
			for (int i = 0; i < touchIds.Length; i++)
			{
				if (touchIds[i] == btn)
				{
					event_state_touch[i] = down;
					DEBUG(string.Concat("SetEventState_Touch() ", DeviceType, ", ", touchIds[i], ": ", event_state_touch[i].ToString()));
					break;
				}
			}
		}

		public bool GetEventState_Touch(WVR_InputId btn)
		{
			bool result = false;
			for (int i = 0; i < touchIds.Length; i++)
			{
				if (touchIds[i] == btn)
				{
					result = event_state_touch[i];
					break;
				}
			}
			return result;
		}

		private bool AllowGetConnectionState()
		{
			if (Time.frameCount != prevFrame_connected)
			{
				prevFrame_connected = Time.frameCount;
				return true;
			}
			return false;
		}

		private bool AllowGetPoseState()
		{
			if (!_connected)
			{
				return false;
			}
			if (Time.frameCount != prevFrame_pose)
			{
				prevFrame_pose = Time.frameCount;
				return true;
			}
			return false;
		}

		private bool AllowPressActionInAFrame(WVR_InputId _id)
		{
			for (uint num = 0u; num < pressIds.Length; num++)
			{
				if (_id == pressIds[num] && Time.frameCount != prevFrameCount_press[num])
				{
					prevFrameCount_press[num] = Time.frameCount;
					return true;
				}
			}
			return false;
		}

		private bool AllowTouchActionInAFrame(WVR_InputId _id)
		{
			for (uint num = 0u; num < touchIds.Length; num++)
			{
				if (_id == touchIds[num] && Time.frameCount != prevFrameCount_touch[num])
				{
					prevFrameCount_touch[num] = Time.frameCount;
					return true;
				}
			}
			return false;
		}

		private void Update_PressState(WVR_InputId _id)
		{
			if (!AllowPressActionInAFrame(_id))
			{
				return;
			}
			bool eventState_Press = GetEventState_Press(_id);
			for (int i = 0; i < pressIds.Length; i++)
			{
				if (_id == pressIds[i])
				{
					prevState_press[i] = state_press[i];
					state_press[i] = eventState_Press;
				}
			}
		}

		private void Update_TouchState(WVR_InputId _id)
		{
			if (!AllowTouchActionInAFrame(_id))
			{
				return;
			}
			bool eventState_Touch = GetEventState_Touch(_id);
			for (int i = 0; i < touchIds.Length; i++)
			{
				if (_id == touchIds[i])
				{
					prevState_touch[i] = state_touch[i];
					state_touch[i] = eventState_Touch;
				}
			}
		}

		public void ResetAllButtonStates()
		{
			DEBUG("ResetAllButtonStates() " + DeviceType);
			for (int i = 0; i < pressIds.Length; i++)
			{
				prevFrameCount_press[i] = -1;
				state_press[i] = false;
				prevState_press[i] = false;
				event_state_press[i] = false;
			}
			for (int j = 0; j < touchIds.Length; j++)
			{
				prevFrameCount_touch[j] = -1;
				state_touch[j] = false;
				prevState_touch[j] = false;
				event_state_touch[j] = false;
			}
		}

		public void ResetButtonEvents()
		{
			DEBUG("ResetButtonEvents() " + DeviceType);
			for (int i = 0; i < pressIds.Length; i++)
			{
				event_state_press[i] = false;
			}
			for (int j = 0; j < touchIds.Length; j++)
			{
				event_state_touch[j] = false;
			}
		}

		public void UpdateButtonEvents()
		{
			if (WaveVR.Instance.Initialized)
			{
				for (int i = 0; i < pressIds.Length; i++)
				{
					bool flag = Interop.WVR_GetInputButtonState(DeviceType, pressIds[i]);
					event_state_press[i] = flag;
					DEBUG(WVR_Log.Log.CSB.Append("UpdateButtonEvents() ").Append(DeviceType.Name()).Append(" ")
						.Append(pressIds[i].Name())
						.Append(" is ")
						.Append(event_state_press[i] ? "pressed." : "not pressed.")
						.ToString());
				}
				for (int j = 0; j < touchIds.Length; j++)
				{
					bool flag2 = Interop.WVR_GetInputTouchState(DeviceType, touchIds[j]);
					event_state_touch[j] = flag2;
					DEBUG(WVR_Log.Log.CSB.Append("UpdateButtonEvents() ").Append(DeviceType.Name()).Append(" ")
						.Append(touchIds[j].Name())
						.Append(" is ")
						.Append(event_state_touch[j] ? "touched." : "not touched.")
						.ToString());
				}
			}
		}

		public bool GetPress(WaveVR_ButtonList.EButtons btn)
		{
			return GetPress((WVR_InputId)btn);
		}

		public bool GetPress(WVR_InputId _id)
		{
			bool result = false;
			Update_PressState(_id);
			for (int i = 0; i < pressIds.Length; i++)
			{
				if (_id == pressIds[i])
				{
					result = state_press[i];
					break;
				}
			}
			return result;
		}

		public bool GetPressDown(WaveVR_ButtonList.EButtons btn)
		{
			return GetPressDown((WVR_InputId)btn);
		}

		public bool GetPressDown(WVR_InputId _id)
		{
			bool result = false;
			Update_PressState(_id);
			for (int i = 0; i < pressIds.Length; i++)
			{
				if (_id == pressIds[i])
				{
					result = !prevState_press[i] && state_press[i];
					break;
				}
			}
			return result;
		}

		public bool GetPressUp(WaveVR_ButtonList.EButtons btn)
		{
			return GetPressUp((WVR_InputId)btn);
		}

		public bool GetPressUp(WVR_InputId _id)
		{
			bool result = false;
			Update_PressState(_id);
			for (int i = 0; i < pressIds.Length; i++)
			{
				if (_id == pressIds[i])
				{
					result = prevState_press[i] && !state_press[i];
					break;
				}
			}
			return result;
		}

		public bool GetTouch(WaveVR_ButtonList.EButtons btn)
		{
			return GetTouch((WVR_InputId)btn);
		}

		public bool GetTouch(WVR_InputId _id)
		{
			bool result = false;
			Update_TouchState(_id);
			for (int i = 0; i < touchIds.Length; i++)
			{
				if (_id == touchIds[i])
				{
					result = state_touch[i];
					break;
				}
			}
			return result;
		}

		public bool GetTouchDown(WaveVR_ButtonList.EButtons btn)
		{
			return GetTouchDown((WVR_InputId)btn);
		}

		public bool GetTouchDown(WVR_InputId _id)
		{
			bool result = false;
			Update_TouchState(_id);
			for (int i = 0; i < touchIds.Length; i++)
			{
				if (_id == touchIds[i])
				{
					result = !prevState_touch[i] && state_touch[i];
					break;
				}
			}
			return result;
		}

		public bool GetTouchUp(WaveVR_ButtonList.EButtons btn)
		{
			return GetTouchUp((WVR_InputId)btn);
		}

		public bool GetTouchUp(WVR_InputId _id)
		{
			bool result = false;
			Update_TouchState(_id);
			for (int i = 0; i < touchIds.Length; i++)
			{
				if (_id == touchIds[i])
				{
					result = prevState_touch[i] && !state_touch[i];
					break;
				}
			}
			return result;
		}

		public Vector2 GetAxis(WaveVR_ButtonList.EButtons btn)
		{
			return GetAxis((WVR_InputId)btn);
		}

		public Vector2 GetAxis(WVR_InputId btn)
		{
			if (!_connected || !GetTouch(btn))
			{
				return Vector2.zero;
			}
			axis = Interop.WVR_GetInputAnalogAxis(DeviceType, btn);
			return new Vector2(axis.x, axis.y);
		}

		public void TriggerHapticPulse(uint durationMicroSec = 1000000u, WVR_InputId id = WVR_InputId.WVR_InputId_16)
		{
			TriggerVibration(id, durationMicroSec, 1u, WVR_Intensity.WVR_Intensity_Normal);
		}

		public void TriggerVibration(WVR_InputId id, uint durationMicroSec, uint frequency, WVR_Intensity intensity)
		{
			if (connected)
			{
				Interop.WVR_TriggerVibration(DeviceType, id, durationMicroSec, frequency, intensity);
			}
		}
	}

	private static string LOG_TAG = "WaveVR_Controller";

	private static bool isLeftHanded = false;

	public static EDeviceType[] DeviceTypes = new EDeviceType[3]
	{
		EDeviceType.Head,
		EDeviceType.Dominant,
		EDeviceType.NonDominant
	};

	private static Device[] devices;

	public static bool IsLeftHanded => isLeftHanded;

	private static void DEBUG(string msg)
	{
		if (WVR_Log.Log.EnableDebugLog)
		{
			WVR_Log.Log.d(LOG_TAG, msg, logInEditor: true);
		}
	}

	public static void SetLeftHandedMode(bool lefthanded)
	{
		isLeftHanded = lefthanded;
		DEBUG("SetLeftHandedMode() left handed? " + isLeftHanded);
	}

	public static EDeviceType GetEDeviceByWVRType(WVR_DeviceType type)
	{
		if (type == Input(EDeviceType.Dominant).DeviceType)
		{
			return EDeviceType.Dominant;
		}
		if (type == Input(EDeviceType.NonDominant).DeviceType)
		{
			return EDeviceType.NonDominant;
		}
		return EDeviceType.Head;
	}

	public static Device Input(WVR_DeviceType deviceIndex)
	{
		if (isLeftHanded)
		{
			switch (deviceIndex)
			{
			case WVR_DeviceType.WVR_DeviceType_Controller_Right:
				deviceIndex = WVR_DeviceType.WVR_DeviceType_Controller_Left;
				break;
			case WVR_DeviceType.WVR_DeviceType_Controller_Left:
				deviceIndex = WVR_DeviceType.WVR_DeviceType_Controller_Right;
				break;
			}
		}
		return ChangeRole(deviceIndex);
	}

	public static Device Input(EDeviceType type)
	{
		WVR_DeviceType deviceIndex = WVR_DeviceType.WVR_DeviceType_Invalid;
		switch (type)
		{
		case EDeviceType.Head:
			deviceIndex = WVR_DeviceType.WVR_DeviceType_HMD;
			break;
		case EDeviceType.Dominant:
			deviceIndex = (isLeftHanded ? WVR_DeviceType.WVR_DeviceType_Controller_Left : WVR_DeviceType.WVR_DeviceType_Controller_Right);
			break;
		case EDeviceType.NonDominant:
			deviceIndex = (isLeftHanded ? WVR_DeviceType.WVR_DeviceType_Controller_Right : WVR_DeviceType.WVR_DeviceType_Controller_Left);
			break;
		}
		return ChangeRole(deviceIndex);
	}

	private static Device ChangeRole(WVR_DeviceType deviceIndex)
	{
		if (devices == null)
		{
			devices = new Device[Enum.GetNames(typeof(WVR_DeviceType)).Length];
			uint num = 0u;
			devices[num++] = new Device(WVR_DeviceType.WVR_DeviceType_Invalid);
			devices[num++] = new Device(WVR_DeviceType.WVR_DeviceType_HMD);
			devices[num++] = new Device(WVR_DeviceType.WVR_DeviceType_Controller_Right);
			devices[num++] = new Device(WVR_DeviceType.WVR_DeviceType_Controller_Left);
		}
		for (uint num2 = 0u; num2 < devices.Length; num2++)
		{
			if (deviceIndex == devices[num2].DeviceType)
			{
				return devices[num2];
			}
		}
		return null;
	}
}
public enum ERaycastStartPoint
{
	CenterOfEyes,
	LeftEye,
	RightEye
}
public class WaveVR_ControllerInputModule : BaseInputModule
{
	public enum ERaycastMode
	{
		Beam,
		Fixed,
		Mouse
	}

	[Serializable]
	public class CBeamConfig
	{
		public float StartWidth;

		public float EndWidth;

		public float StartOffset;

		public float EndOffset;

		public Color32 StartColor;

		public Color32 EndColor;

		public void assignedTo(CBeamConfig src)
		{
			StartWidth = src.StartWidth;
			EndWidth = src.EndWidth;
			StartOffset = src.StartOffset;
			EndOffset = src.EndOffset;
			StartColor = src.StartColor;
			EndColor = src.EndColor;
		}
	}

	public class RaycastModeSetting
	{
		public ERaycastMode Mode { get; set; }

		public CBeamConfig Config { get; set; }

		public RaycastModeSetting(ERaycastMode mode, CBeamConfig config)
		{
			Mode = mode;
			Config = config;
		}
	}

	public class EventController
	{
		private List<RaycastModeSetting> raycastModeSettings;

		public WaveVR_Controller.EDeviceType device { get; set; }

		public GameObject controller { get; set; }

		public GameObject prevRaycastedObject { get; set; }

		public PointerEventData event_data { get; set; }

		public WaveVR_ControllerPointer pointer { get; set; }

		public bool pointerEnabled { get; set; }

		public WaveVR_Beam beam { get; set; }

		public bool beamEnabled { get; set; }

		public bool eligibleForButtonClick { get; set; }

		public void SetBeamConfig(ERaycastMode mode, CBeamConfig config)
		{
			for (int i = 0; i < raycastModeSettings.Count; i++)
			{
				if (raycastModeSettings[i].Mode == mode)
				{
					raycastModeSettings[i].Config.assignedTo(config);
				}
			}
		}

		public CBeamConfig GetBeamConfig(ERaycastMode mode)
		{
			for (int i = 0; i < raycastModeSettings.Count; i++)
			{
				if (raycastModeSettings[i].Mode == mode)
				{
					return raycastModeSettings[i].Config;
				}
			}
			return null;
		}

		public EventController(WaveVR_Controller.EDeviceType type)
		{
			device = type;
			controller = null;
			prevRaycastedObject = null;
			event_data = null;
			eligibleForButtonClick = false;
			beam = null;
			beamEnabled = false;
			pointer = null;
			pointerEnabled = false;
			raycastModeSettings = new List<RaycastModeSetting>();
			for (int i = 0; i < RaycastModes.Length; i++)
			{
				ERaycastMode mode = RaycastModes[i];
				raycastModeSettings.Add(new RaycastModeSetting(mode, new CBeamConfig()));
			}
		}
	}

	private const string LOG_TAG = "WaveVR_ControllerInputModule";

	public static ERaycastMode[] RaycastModes = new ERaycastMode[3]
	{
		ERaycastMode.Beam,
		ERaycastMode.Fixed,
		ERaycastMode.Mouse
	};

	[HideInInspector]
	public bool UnityMode;

	[HideInInspector]
	public bool UnityMode_PriorDrag;

	public bool DomintEventEnabled = true;

	public GameObject DominantController;

	public LayerMask DominantRaycastMask = -1;

	public bool NoDomtEventEnabled = true;

	public GameObject NonDominantController;

	public LayerMask NonDominantRaycastMask = -1;

	public List<WaveVR_ButtonList.EButtons> ButtonToTrigger = new List<WaveVR_ButtonList.EButtons>();

	private GameObject Head;

	[HideInInspector]
	public ERaycastMode RaycastMode = ERaycastMode.Mouse;

	[HideInInspector]
	public ERaycastStartPoint RaycastStartPoint;

	[Tooltip("Will be obsoleted soon!")]
	public string CanvasTag = "EventCanvas";

	private const float CLICK_TIME = 0.2f;

	private const float DRAG_TIME = 0.2f;

	private const float raycastStartPointOffset = 0.0315f;

	private GameObject pointCameraNoDomt;

	private GameObject pointCameraDomint;

	public float FixedBeamLength = 9.5f;

	private float lengthFromBeamToPointer = 0.5f;

	private Color32 FlexiblePointerColor = Color.blue;

	private ERaycastMode preRaycastMode;

	private bool toChangeBeamPointer = true;

	private Vector3 DomintIntersectPos_prev = Vector3.zero;

	private Vector3 NoDomtIntersectPos_prev = Vector3.zero;

	[SerializeField]
	private bool mForceModuleActive = true;

	private CBeamConfig mouseBeamConfig = new CBeamConfig
	{
		StartWidth = 0.000625f,
		EndWidth = 0.00125f,
		StartOffset = 0.015f,
		EndOffset = 0.8f,
		StartColor = new Color32(byte.MaxValue, byte.MaxValue, byte.MaxValue, byte.MaxValue),
		EndColor = new Color32(byte.MaxValue, byte.MaxValue, byte.MaxValue, 77)
	};

	private CBeamConfig fixedBeamConfig = new CBeamConfig
	{
		StartWidth = 0.000625f,
		EndWidth = 0.00125f,
		StartOffset = 0.015f,
		EndOffset = 9.5f,
		StartColor = new Color32(byte.MaxValue, byte.MaxValue, byte.MaxValue, byte.MaxValue),
		EndColor = new Color32(byte.MaxValue, byte.MaxValue, byte.MaxValue, byte.MaxValue)
	};

	private CBeamConfig flexibleBeamConfig = new CBeamConfig
	{
		StartWidth = 0.000625f,
		EndWidth = 0.00125f,
		StartOffset = 0.015f,
		EndOffset = 0.8f,
		StartColor = new Color32(byte.MaxValue, byte.MaxValue, byte.MaxValue, byte.MaxValue),
		EndColor = new Color32(byte.MaxValue, byte.MaxValue, byte.MaxValue, 0)
	};

	private List<EventController> EventControllers = new List<EventController>();

	private bool enableControllerInputModule;

	private List<RaycastResult> physicsRaycastResultsDominant = new List<RaycastResult>();

	private List<RaycastResult> physicsRaycastResultsNoDomint = new List<RaycastResult>();

	private List<GameObject> physicsRaycastObjectsDominant = new List<GameObject>();

	private List<GameObject> prePhysicsRaycastObjectsDominant = new List<GameObject>();

	private List<GameObject> physicsRaycastObjectsNoDomint = new List<GameObject>();

	private List<GameObject> prePhysicsRaycastObjectsNoDomint = new List<GameObject>();

	private List<GameObject> physicsRaycastObjectsTmp = new List<GameObject>();

	private List<GameObject> prePhysicsRaycastObjectsTmp = new List<GameObject>();

	private List<RaycastResult> graphicRaycastResultsDominant = new List<RaycastResult>();

	private List<RaycastResult> graphicRaycastResultsNoDomint = new List<RaycastResult>();

	private List<GameObject> graphicRaycastObjectsDominant = new List<GameObject>();

	private List<GameObject> preGraphicRaycastObjectsDominant = new List<GameObject>();

	private List<GameObject> graphicRaycastObjectsNoDomint = new List<GameObject>();

	private List<GameObject> preGraphicRaycastObjectsNoDomint = new List<GameObject>();

	private List<GameObject> graphicRaycastObjectsTmp = new List<GameObject>();

	private List<GameObject> preGraphicRaycastObjectsTmp = new List<GameObject>();

	private Vector2 centerOfScreen = new Vector2(0.5f * (float)Screen.width, 0.5f * (float)Screen.height);

	public bool ForceModuleActive
	{
		get
		{
			return mForceModuleActive;
		}
		set
		{
			mForceModuleActive = value;
		}
	}

	private void DEBUG(string msg)
	{
		if (WVR_Log.Log.EnableDebugLog)
		{
			WVR_Log.Log.d("WaveVR_ControllerInputModule", msg, logInEditor: true);
		}
	}

	private void INFO(string msg)
	{
		WVR_Log.Log.i("WaveVR_ControllerInputModule", msg, logInEditor: true);
	}

	public override bool IsModuleSupported()
	{
		return mForceModuleActive;
	}

	public override bool ShouldActivateModule()
	{
		if (!base.ShouldActivateModule())
		{
			return false;
		}
		if (mForceModuleActive)
		{
			return true;
		}
		return false;
	}

	public override void DeactivateModule()
	{
		base.DeactivateModule();
		for (int i = 0; i < WaveVR_Controller.DeviceTypes.Length; i++)
		{
			WaveVR_Controller.EDeviceType dt = WaveVR_Controller.DeviceTypes[i];
			EventController eventController = GetEventController(dt);
			if (eventController != null)
			{
				INFO("DeactivateModule()");
				ExitAllObjects(eventController);
			}
		}
	}

	private EventController GetEventController(WaveVR_Controller.EDeviceType dt)
	{
		for (int i = 0; i < EventControllers.Count; i++)
		{
			if (EventControllers[i].device == dt)
			{
				return EventControllers[i];
			}
		}
		return null;
	}

	private void UpdateControllerModelInProcess()
	{
		for (int i = 0; i < WaveVR_Controller.DeviceTypes.Length; i++)
		{
			WaveVR_Controller.EDeviceType eDeviceType = WaveVR_Controller.DeviceTypes[i];
			if (eDeviceType == WaveVR_Controller.EDeviceType.Head)
			{
				continue;
			}
			EventController eventController = GetEventController(eDeviceType);
			GameObject controller = eventController.controller;
			GameObject controllerModel = WaveVR_EventSystemControllerProvider.Instance.GetControllerModel(eDeviceType);
			LayerMask mask = -1;
			if (eDeviceType == WaveVR_Controller.EDeviceType.Dominant)
			{
				mask = DominantRaycastMask;
			}
			if (eDeviceType == WaveVR_Controller.EDeviceType.NonDominant)
			{
				mask = NonDominantRaycastMask;
			}
			if (controller == null)
			{
				if (controllerModel != null)
				{
					if (eDeviceType == WaveVR_Controller.EDeviceType.Head)
					{
						DEBUG("UpdateControllerModelInProcess() Head replace null with new controller instance.");
					}
					if (eDeviceType == WaveVR_Controller.EDeviceType.Dominant)
					{
						DEBUG("UpdateControllerModelInProcess() Dominant replace null with new controller instance.");
					}
					if (eDeviceType == WaveVR_Controller.EDeviceType.NonDominant)
					{
						DEBUG("UpdateControllerModelInProcess() Non-Dominant replace null with new controller instance.");
					}
					SetupEventController(eventController, controllerModel, mask);
				}
			}
			else if (controllerModel == null)
			{
				if (WaveVR_EventSystemControllerProvider.Instance.HasControllerLoader(eDeviceType))
				{
					if (eDeviceType == WaveVR_Controller.EDeviceType.Head)
					{
						DEBUG("UpdateControllerModelInProcess() Head clear controller instance.");
					}
					if (eDeviceType == WaveVR_Controller.EDeviceType.Dominant)
					{
						DEBUG("UpdateControllerModelInProcess() Dominant clear controller instance.");
					}
					if (eDeviceType == WaveVR_Controller.EDeviceType.NonDominant)
					{
						DEBUG("UpdateControllerModelInProcess() Non-Dominant clear controller instance.");
					}
					SetupEventController(eventController, null, mask);
				}
			}
			else if ((object)controller != controllerModel)
			{
				if (eDeviceType == WaveVR_Controller.EDeviceType.Head)
				{
					DEBUG("UpdateControllerModelInProcess() Head set new controller instance.");
				}
				if (eDeviceType == WaveVR_Controller.EDeviceType.Dominant)
				{
					DEBUG("UpdateControllerModelInProcess() Dominant set new controller instance.");
				}
				if (eDeviceType == WaveVR_Controller.EDeviceType.NonDominant)
				{
					DEBUG("UpdateControllerModelInProcess() NonDominant set new controller instance.");
				}
				SetupEventController(eventController, controllerModel, mask);
			}
		}
	}

	private void SetupEventController(EventController eventController, GameObject controller_model, LayerMask mask)
	{
		if (eventController.controller != null)
		{
			DEBUG("SetupEventController() deactivate " + eventController.controller.name);
			eventController.controller.SetActive(value: false);
		}
		eventController.controller = controller_model;
		if (!(eventController.controller != null))
		{
			return;
		}
		DEBUG("SetupEventController() activate " + eventController.controller.name);
		eventController.controller.SetActive(value: true);
		eventController.SetBeamConfig(ERaycastMode.Beam, flexibleBeamConfig);
		eventController.SetBeamConfig(ERaycastMode.Fixed, fixedBeamConfig);
		eventController.SetBeamConfig(ERaycastMode.Mouse, mouseBeamConfig);
		eventController.beam = eventController.controller.GetComponentInChildren<WaveVR_Beam>(includeInactive: true);
		if (eventController.beam != null)
		{
			DEBUG("SetupEventController() set up WaveVR_Beam: " + eventController.beam.gameObject.name + " of " + eventController.device);
			SetupEventControllerBeam(eventController, Vector3.zero, updateRaycastConfig: true);
		}
		PhysicsRaycaster physicsRaycaster = eventController.controller.GetComponentInChildren<PhysicsRaycaster>();
		eventController.pointer = eventController.controller.GetComponentInChildren<WaveVR_ControllerPointer>(includeInactive: true);
		if (eventController.pointer != null)
		{
			DEBUG("SetupEventController() set up WaveVR_ControllerPointer: " + eventController.pointer.gameObject.name + " of " + eventController.device);
			if (physicsRaycaster == null)
			{
				DEBUG("SetupEventController() add PhysicsRaycaster on " + eventController.pointer.gameObject.name);
				physicsRaycaster = eventController.pointer.gameObject.AddComponent<PhysicsRaycaster>();
			}
			SetupEventControllerPointer(eventController);
		}
		else if (physicsRaycaster == null)
		{
			DEBUG("SetupEventController() add PhysicsRaycaster on " + eventController.controller.name);
			physicsRaycaster = eventController.controller.AddComponent<PhysicsRaycaster>();
		}
		physicsRaycaster.eventMask = mask;
		DEBUG("SetupEventController() physics mask: " + physicsRaycaster.eventMask.value);
		Camera component = physicsRaycaster.gameObject.GetComponent<Camera>();
		if (component != null)
		{
			component.stereoTargetEye = StereoTargetEyeMask.None;
			component.enabled = false;
		}
		Camera component2 = eventController.controller.GetComponent<Camera>();
		if (component2 != null)
		{
			DEBUG("SetupEventController() found controller camera of " + eventController.controller.name);
			component2.enabled = false;
		}
	}

	private void SetupEventControllerBeam(EventController eventController, Vector3 intersectionPosition, bool updateRaycastConfig = false)
	{
		if (eventController.beam == null)
		{
			return;
		}
		CBeamConfig beamConfig = eventController.GetBeamConfig(RaycastMode);
		if (updateRaycastConfig)
		{
			beamConfig.StartWidth = eventController.beam.StartWidth;
			beamConfig.EndWidth = eventController.beam.EndWidth;
			beamConfig.StartOffset = eventController.beam.StartOffset;
			beamConfig.StartColor = eventController.beam.StartColor;
			beamConfig.EndColor = eventController.beam.EndColor;
			switch (RaycastMode)
			{
			case ERaycastMode.Beam:
			case ERaycastMode.Mouse:
				beamConfig.EndOffset = eventController.beam.EndOffset;
				break;
			case ERaycastMode.Fixed:
				beamConfig.EndOffset = FixedBeamLength;
				break;
			}
			eventController.SetBeamConfig(RaycastMode, beamConfig);
			DEBUG(string.Concat("SetupEventControllerBeam() ", eventController.device, ", ", RaycastMode, " mode config - StartWidth: ", beamConfig.StartWidth, ", EndWidth: ", beamConfig.EndWidth, ", StartOffset: ", beamConfig.StartOffset, ", EndOffset: ", beamConfig.EndOffset, ", StartColor: ", beamConfig.StartColor.ToString(), ", EndColor: ", beamConfig.EndColor.ToString()));
		}
		eventController.beam.StartWidth = beamConfig.StartWidth;
		eventController.beam.EndWidth = beamConfig.EndWidth;
		eventController.beam.StartOffset = beamConfig.StartOffset;
		eventController.beam.EndOffset = beamConfig.EndOffset;
		eventController.beam.StartColor = beamConfig.StartColor;
		eventController.beam.EndColor = beamConfig.EndColor;
		DEBUG(string.Concat("SetupEventControllerBeam() ", eventController.device, ", ", RaycastMode, " mode, StartWidth: ", eventController.beam.StartWidth, ", EndWidth: ", eventController.beam.EndWidth, ", StartOffset: ", eventController.beam.StartOffset, ", length: ", eventController.beam.EndOffset, ", StartColor: ", eventController.beam.StartColor.ToString(), ", EndColor: ", eventController.beam.EndColor.ToString()));
	}

	private void SetupEventControllerPointer(EventController eventController, Camera eventCamera, Vector3 intersectionPosition)
	{
		if (eventController.pointer == null)
		{
			return;
		}
		float num = 0f;
		float num2 = 0f;
		GameObject raycastedObject = GetRaycastedObject(eventController.device);
		switch (RaycastMode)
		{
		case ERaycastMode.Mouse:
			num = ((!(eventController.beam != null)) ? (mouseBeamConfig.EndOffset + lengthFromBeamToPointer) : (eventController.beam.EndOffset + eventController.beam.endOffsetMin));
			num2 = eventController.pointer.PointerOuterDiameterMin + num / eventController.pointer.kpointerGrowthAngle;
			eventController.pointer.PointerDistanceInMeters = num;
			eventController.pointer.PointerOuterDiameter = num2;
			eventController.pointer.PointerColor = Color.white;
			eventController.pointer.PointerRenderQueue = 5000;
			break;
		case ERaycastMode.Fixed:
			num = ((!(eventController.beam != null)) ? (fixedBeamConfig.EndOffset + lengthFromBeamToPointer) : (eventController.beam.EndOffset + eventController.beam.endOffsetMin));
			num2 = eventController.pointer.PointerOuterDiameterMin * num;
			eventController.pointer.PointerDistanceInMeters = num;
			eventController.pointer.PointerOuterDiameter = num2;
			eventController.pointer.PointerRenderQueue = 1000;
			break;
		case ERaycastMode.Beam:
			if (raycastedObject != null)
			{
				eventController.pointer.OnPointerEnter(eventCamera, raycastedObject, intersectionPosition, isInteractive: true);
				eventController.pointer.PointerColor = FlexiblePointerColor;
			}
			else
			{
				eventController.pointer.PointerColor = Color.white;
				if (eventController.beam != null)
				{
					eventController.pointer.PointerDistanceInMeters = eventController.beam.EndOffset + eventController.beam.endOffsetMin;
				}
			}
			num = eventController.pointer.PointerDistanceInMeters;
			num2 = eventController.pointer.PointerOuterDiameterMin + num / eventController.pointer.kpointerGrowthAngle;
			eventController.pointer.PointerOuterDiameter = num2;
			eventController.pointer.PointerRenderQueue = 5000;
			break;
		}
		DEBUG(string.Concat("SetupEventControllerPointer() ", eventController.device, ", ", RaycastMode, " mode, pointerDistanceInMeters: ", num, ", pointerOuterDiameter: ", num2));
	}

	private void SetupEventControllerPointer(EventController eventController)
	{
		if (!(eventController.pointer == null))
		{
			SetupEventControllerPointer(eventController, null, Vector3.zero);
		}
	}

	public void ChangeBeamLength(WaveVR_Controller.EDeviceType dt, float length)
	{
		EventController eventController = GetEventController(dt);
		if (eventController != null)
		{
			if (RaycastMode == ERaycastMode.Fixed || RaycastMode == ERaycastMode.Mouse)
			{
				CBeamConfig beamConfig = eventController.GetBeamConfig(RaycastMode);
				beamConfig.EndOffset = length;
				eventController.SetBeamConfig(RaycastMode, beamConfig);
			}
			SetupEventControllerBeam(eventController, Vector3.zero);
			SetupEventControllerPointer(eventController);
		}
	}

	private void SetupPointerCamera(WaveVR_Controller.EDeviceType type)
	{
		if (Head == null)
		{
			DEBUG("SetupPointerCamera() no Head!!");
			return;
		}
		switch (type)
		{
		case WaveVR_Controller.EDeviceType.Dominant:
			pointCameraDomint = new GameObject("PointerCameraR");
			if (!(pointCameraDomint == null))
			{
				DEBUG("SetupPointerCamera() Dominant - add component WaveVR_PointerCameraTracker");
				pointCameraDomint.AddComponent<WaveVR_PointerCameraTracker>();
				DEBUG("SetupPointerCamera() Dominant add component - WaveVR_PoseTrackerManager");
				pointCameraDomint.AddComponent<WaveVR_PoseTrackerManager>();
				PhysicsRaycaster physicsRaycaster2 = pointCameraDomint.AddComponent<PhysicsRaycaster>();
				if (physicsRaycaster2 != null)
				{
					physicsRaycaster2.eventMask = DominantRaycastMask;
					DEBUG("SetupPointerCamera() Dominant - set physics raycast mask to " + physicsRaycaster2.eventMask.value);
				}
				pointCameraDomint.transform.SetParent(Head.transform, worldPositionStays: false);
				DEBUG("SetupPointerCamera() Dominant - set pointerCamera parent to " + pointCameraDomint.transform.parent.name);
				if (WaveVR_Render.Instance != null && WaveVR_Render.Instance.righteye != null)
				{
					pointCameraDomint.transform.position = WaveVR_Render.Instance.righteye.transform.position;
				}
				else if (RaycastStartPoint == ERaycastStartPoint.LeftEye)
				{
					pointCameraDomint.transform.localPosition = new Vector3(-0.0315f, 0f, 0.15f);
				}
				else if (RaycastStartPoint == ERaycastStartPoint.RightEye)
				{
					pointCameraDomint.transform.localPosition = new Vector3(0.0315f, 0f, 0.15f);
				}
				else
				{
					pointCameraDomint.transform.localPosition = new Vector3(0f, 0f, 0.15f);
				}
				Camera component4 = pointCameraDomint.GetComponent<Camera>();
				if (component4 != null)
				{
					component4.enabled = false;
					component4.fieldOfView = 1f;
					component4.nearClipPlane = 0.01f;
				}
				WaveVR_PointerCameraTracker component5 = pointCameraDomint.GetComponent<WaveVR_PointerCameraTracker>();
				if (component5 != null)
				{
					component5.setDeviceType(type);
				}
				WaveVR_PoseTrackerManager component6 = pointCameraDomint.GetComponent<WaveVR_PoseTrackerManager>();
				if (component6 != null)
				{
					DEBUG("SetupPointerCamera() Dominant - disable WaveVR_PoseTrackerManager");
					component6.Type = type;
					component6.TrackPosition = false;
					component6.TrackRotation = false;
					component6.enabled = false;
				}
			}
			break;
		case WaveVR_Controller.EDeviceType.NonDominant:
			pointCameraNoDomt = new GameObject("PointerCameraL");
			if (!(pointCameraNoDomt == null))
			{
				DEBUG("SetupPointerCamera() NonDominant - add component WaveVR_PointerCameraTracker");
				pointCameraNoDomt.AddComponent<WaveVR_PointerCameraTracker>();
				DEBUG("SetupPointerCamera() NonDominant add component - WaveVR_PoseTrackerManager");
				pointCameraNoDomt.AddComponent<WaveVR_PoseTrackerManager>();
				PhysicsRaycaster physicsRaycaster = pointCameraNoDomt.AddComponent<PhysicsRaycaster>();
				if (physicsRaycaster != null)
				{
					physicsRaycaster.eventMask = NonDominantRaycastMask;
					DEBUG("SetupPointerCamera() NonDominant - set physics raycast mask to " + physicsRaycaster.eventMask.value);
				}
				pointCameraNoDomt.transform.SetParent(Head.transform, worldPositionStays: false);
				DEBUG("SetupPointerCamera() NonDominant - set pointerCamera parent to " + pointCameraNoDomt.transform.parent.name);
				if (WaveVR_Render.Instance != null && WaveVR_Render.Instance.lefteye != null)
				{
					pointCameraNoDomt.transform.position = WaveVR_Render.Instance.lefteye.transform.position;
				}
				else if (RaycastStartPoint == ERaycastStartPoint.LeftEye)
				{
					pointCameraNoDomt.transform.localPosition = new Vector3(-0.0315f, 0f, 0.15f);
				}
				else if (RaycastStartPoint == ERaycastStartPoint.RightEye)
				{
					pointCameraNoDomt.transform.localPosition = new Vector3(0.0315f, 0f, 0.15f);
				}
				else
				{
					pointCameraNoDomt.transform.localPosition = new Vector3(0f, 0f, 0.15f);
				}
				Camera component = pointCameraNoDomt.GetComponent<Camera>();
				if (component != null)
				{
					component.enabled = false;
					component.fieldOfView = 1f;
					component.nearClipPlane = 0.01f;
				}
				WaveVR_PointerCameraTracker component2 = pointCameraNoDomt.GetComponent<WaveVR_PointerCameraTracker>();
				if (component2 != null)
				{
					component2.setDeviceType(type);
				}
				WaveVR_PoseTrackerManager component3 = pointCameraNoDomt.GetComponent<WaveVR_PoseTrackerManager>();
				if (component3 != null)
				{
					DEBUG("SetupPointerCamera() NonDominant - disable WaveVR_PoseTrackerManager");
					component3.Type = type;
					component3.TrackPosition = false;
					component3.TrackRotation = false;
					component3.enabled = false;
				}
			}
			break;
		}
	}

	protected override void OnEnable()
	{
		if (!enableControllerInputModule)
		{
			base.OnEnable();
			DEBUG("OnEnable()");
			enableControllerInputModule = true;
			for (int i = 0; i < WaveVR_Controller.DeviceTypes.Length; i++)
			{
				EventControllers.Add(new EventController(WaveVR_Controller.DeviceTypes[i]));
			}
			if (DominantController != null)
			{
				EventController eventController = GetEventController(WaveVR_Controller.EDeviceType.Dominant);
				SetupEventController(eventController, DominantController, DominantRaycastMask);
			}
			if (NonDominantController != null)
			{
				EventController eventController2 = GetEventController(WaveVR_Controller.EDeviceType.NonDominant);
				SetupEventController(eventController2, NonDominantController, NonDominantRaycastMask);
			}
			if (Head == null && WaveVR_Render.Instance != null)
			{
				Head = WaveVR_Render.Instance.gameObject;
				DEBUG("OnEnable() set up Head to " + Head.name);
			}
			preRaycastMode = RaycastMode;
		}
	}

	protected override void OnDisable()
	{
		if (!enableControllerInputModule)
		{
			return;
		}
		base.OnDisable();
		DEBUG("OnDisable()");
		enableControllerInputModule = false;
		for (int i = 0; i < WaveVR_Controller.DeviceTypes.Length; i++)
		{
			WaveVR_Controller.EDeviceType dt = WaveVR_Controller.DeviceTypes[i];
			EventController eventController = GetEventController(dt);
			if (eventController != null)
			{
				ExitAllObjects(eventController);
			}
		}
		EventControllers.Clear();
	}

	public override void Process()
	{
		if (!enableControllerInputModule)
		{
			return;
		}
		UpdateControllerModelInProcess();
		if (Head == null && WaveVR_Render.Instance != null)
		{
			Head = WaveVR_Render.Instance.gameObject;
			DEBUG("Process() setup Head to " + Head.name);
		}
		for (int i = 0; i < WaveVR_Controller.DeviceTypes.Length; i++)
		{
			WaveVR_Controller.EDeviceType eDeviceType = WaveVR_Controller.DeviceTypes[i];
			if (eDeviceType == WaveVR_Controller.EDeviceType.Head)
			{
				continue;
			}
			EventController eventController = GetEventController(eDeviceType);
			if (eventController == null)
			{
				continue;
			}
			GameObject controller = eventController.controller;
			if (controller == null)
			{
				continue;
			}
			CheckBeamPointerActive(eventController);
			if ((eDeviceType == WaveVR_Controller.EDeviceType.Dominant && !DomintEventEnabled) || (eDeviceType == WaveVR_Controller.EDeviceType.NonDominant && !NoDomtEventEnabled))
			{
				ExitAllObjects(eventController);
				continue;
			}
			if (WaveVR.Instance.Initialized && WaveVR.Instance.FocusCapturedBySystem)
			{
				ExitAllObjects(eventController);
				continue;
			}
			bool flag = false;
			WaveVR.Device deviceByType = WaveVR.Instance.getDeviceByType(eDeviceType);
			if (deviceByType != null)
			{
				flag = deviceByType.connected;
			}
			if (!flag)
			{
				ExitAllObjects(eventController);
				continue;
			}
			eventController.prevRaycastedObject = GetRaycastedObject(eDeviceType);
			if ((eDeviceType == WaveVR_Controller.EDeviceType.NonDominant && pointCameraNoDomt == null) || (eDeviceType == WaveVR_Controller.EDeviceType.Dominant && pointCameraDomint == null))
			{
				SetupPointerCamera(eDeviceType);
			}
			Camera camera = null;
			if (RaycastMode == ERaycastMode.Mouse)
			{
				camera = ((eDeviceType != WaveVR_Controller.EDeviceType.NonDominant) ? ((pointCameraDomint != null) ? pointCameraDomint.GetComponent<Camera>() : null) : ((pointCameraNoDomt != null) ? pointCameraNoDomt.GetComponent<Camera>() : null));
				ResetPointerEventData_Hybrid(eDeviceType, camera);
			}
			else
			{
				camera = (Camera)controller.GetComponentInChildren(typeof(Camera));
				ResetPointerEventData(eDeviceType);
			}
			if (camera == null)
			{
				continue;
			}
			GraphicRaycast(eventController, camera);
			PhysicsRaycaster physicsRaycaster = null;
			physicsRaycaster = ((RaycastMode != ERaycastMode.Mouse) ? controller.GetComponentInChildren<PhysicsRaycaster>() : camera.GetComponent<PhysicsRaycaster>());
			if (physicsRaycaster != null)
			{
				if (RaycastMode == ERaycastMode.Mouse)
				{
					ResetPointerEventData_Hybrid(eDeviceType, camera);
				}
				else
				{
					ResetPointerEventData(eDeviceType);
				}
				PhysicsRaycast(eventController, physicsRaycaster);
			}
			GameObject raycastedObject = GetRaycastedObject(eDeviceType);
			EnterExitGraphicObject(eventController);
			EnterExitPhysicsObject(eventController);
			if (raycastedObject != null && raycastedObject == eventController.prevRaycastedObject)
			{
				OnTriggerHover(eDeviceType, eventController.event_data);
			}
			bool flag2 = false;
			bool flag3 = false;
			bool flag4 = false;
			for (int j = 0; j < ButtonToTrigger.Count; j++)
			{
				flag2 |= WaveVR_Controller.Input(eDeviceType).GetPressDown(ButtonToTrigger[j]);
				flag3 |= WaveVR_Controller.Input(eDeviceType).GetPress(ButtonToTrigger[j]);
				flag4 |= WaveVR_Controller.Input(eDeviceType).GetPressUp(ButtonToTrigger[j]);
			}
			if (!flag2 && flag3)
			{
				if (!UnityMode)
				{
					OnDrag(eDeviceType, eventController.event_data);
				}
				else
				{
					OnDragMouse(eDeviceType, eventController.event_data);
				}
			}
			else if (!(Time.unscaledTime - eventController.event_data.clickTime < 0.2f))
			{
				if (flag2 && !eventController.event_data.eligibleForClick)
				{
					OnTriggerDown(eDeviceType, eventController.event_data);
				}
				else if (!flag3)
				{
					if (!UnityMode)
					{
						OnTriggerUp(eDeviceType, eventController.event_data);
					}
					else
					{
						OnTriggerUpMouse(eDeviceType, eventController.event_data);
					}
				}
			}
			PointerEventData event_data = eventController.event_data;
			Vector3 intersectionPosition = GetIntersectionPosition(event_data.enterEventCamera, event_data.pointerCurrentRaycast);
			WaveVR_RaycastResultProvider.Instance.SetRaycastResult(eDeviceType, eventController.event_data.pointerCurrentRaycast.gameObject, intersectionPosition);
			if (toChangeBeamPointer || preRaycastMode != RaycastMode)
			{
				if (RaycastMode == ERaycastMode.Beam)
				{
					DEBUG("Process() controller raycast mode is flexible beam.");
				}
				if (RaycastMode == ERaycastMode.Fixed)
				{
					DEBUG("Process() controller raycast mode is fixed beam.");
				}
				if (RaycastMode == ERaycastMode.Mouse)
				{
					DEBUG("Process() controller raycast mode is mouse.");
				}
				SetupEventControllerBeam(eventController, intersectionPosition);
				SetupEventControllerPointer(eventController, event_data.enterEventCamera, intersectionPosition);
				toChangeBeamPointer = false;
			}
			Vector3 vector = ((eDeviceType == WaveVR_Controller.EDeviceType.Dominant) ? DomintIntersectPos_prev : NoDomtIntersectPos_prev);
			if (!(vector != intersectionPosition))
			{
				continue;
			}
			vector = intersectionPosition;
			if (RaycastMode == ERaycastMode.Beam && raycastedObject != null)
			{
				if (eventController.pointer != null)
				{
					eventController.pointer.OnPointerEnter(event_data.enterEventCamera, raycastedObject, intersectionPosition, isInteractive: true);
				}
				if (eventController.beam != null)
				{
					eventController.beam.SetEndOffset(intersectionPosition, interactive: false);
				}
				if (WVR_Log.Log.gpl.Print)
				{
					DEBUG(string.Concat("Process() ", eDeviceType, ", _intersectionPosition_prev (", vector.x, ", ", vector.y, ", ", vector.z, ")"));
				}
			}
			if (eDeviceType == WaveVR_Controller.EDeviceType.Dominant)
			{
				DomintIntersectPos_prev = vector;
			}
			if (eDeviceType == WaveVR_Controller.EDeviceType.NonDominant)
			{
				NoDomtIntersectPos_prev = vector;
			}
		}
		preRaycastMode = RaycastMode;
		SetPointerCameraTracker();
	}

	private void PhysicsRaycast(EventController event_controller, PhysicsRaycaster raycaster)
	{
		RaycastResult raycastResult = default(RaycastResult);
		if (event_controller.device == WaveVR_Controller.EDeviceType.Dominant)
		{
			physicsRaycastObjectsDominant.Clear();
			physicsRaycastResultsDominant.Clear();
			raycaster.Raycast(event_controller.event_data, physicsRaycastResultsDominant);
			for (int i = 0; i < physicsRaycastResultsDominant.Count; i++)
			{
				physicsRaycastObjectsDominant.Add(physicsRaycastResultsDominant[i].gameObject);
			}
			raycastResult = BaseInputModule.FindFirstRaycast(physicsRaycastResultsDominant);
		}
		else if (event_controller.device == WaveVR_Controller.EDeviceType.NonDominant)
		{
			physicsRaycastObjectsNoDomint.Clear();
			physicsRaycastResultsNoDomint.Clear();
			raycaster.Raycast(event_controller.event_data, physicsRaycastResultsNoDomint);
			for (int j = 0; j < physicsRaycastResultsNoDomint.Count; j++)
			{
				physicsRaycastObjectsNoDomint.Add(physicsRaycastResultsNoDomint[j].gameObject);
			}
			raycastResult = BaseInputModule.FindFirstRaycast(physicsRaycastResultsNoDomint);
		}
		_ = raycastResult.module != null;
		if (raycastResult.gameObject != null)
		{
			if (raycastResult.worldPosition == Vector3.zero)
			{
				raycastResult.worldPosition = GetIntersectionPosition(raycastResult.module.eventCamera, raycastResult);
			}
			float num = Mathf.Abs(raycastResult.worldPosition.z - raycastResult.module.eventCamera.transform.position.z);
			float num2 = Mathf.Abs(event_controller.event_data.pointerCurrentRaycast.worldPosition.z - raycastResult.module.eventCamera.transform.position.z);
			if (event_controller.event_data.pointerCurrentRaycast.gameObject == null || num2 > num)
			{
				event_controller.event_data.pointerCurrentRaycast = raycastResult;
				event_controller.event_data.position = raycastResult.screenPosition;
			}
		}
	}

	private void GraphicRaycast(EventController event_controller, Camera event_camera)
	{
		if (event_controller.device == WaveVR_Controller.EDeviceType.Head)
		{
			return;
		}
		RaycastResult raycastResult = default(RaycastResult);
		event_controller.event_data.pointerCurrentRaycast = raycastResult;
		GraphicRaycaster[] array = UnityEngine.Object.FindObjectsOfType<GraphicRaycaster>();
		if (event_controller.device == WaveVR_Controller.EDeviceType.Dominant)
		{
			graphicRaycastObjectsDominant.Clear();
		}
		if (event_controller.device == WaveVR_Controller.EDeviceType.NonDominant)
		{
			graphicRaycastObjectsNoDomint.Clear();
		}
		for (int i = 0; i < array.Length; i++)
		{
			if (!(array[i].gameObject != null) || !(array[i].gameObject.GetComponent<Canvas>() != null))
			{
				continue;
			}
			array[i].gameObject.GetComponent<Canvas>().worldCamera = event_camera;
			if (event_controller.device == WaveVR_Controller.EDeviceType.Dominant)
			{
				array[i].Raycast(event_controller.event_data, graphicRaycastResultsDominant);
				if (graphicRaycastResultsDominant.Count == 0)
				{
					continue;
				}
				for (int j = 0; j < graphicRaycastResultsDominant.Count; j++)
				{
					graphicRaycastObjectsDominant.Add(graphicRaycastResultsDominant[j].gameObject);
				}
				raycastResult = BaseInputModule.FindFirstRaycast(graphicRaycastResultsDominant);
				graphicRaycastResultsDominant.Clear();
			}
			if (event_controller.device == WaveVR_Controller.EDeviceType.NonDominant)
			{
				array[i].Raycast(event_controller.event_data, graphicRaycastResultsNoDomint);
				if (graphicRaycastResultsNoDomint.Count == 0)
				{
					continue;
				}
				for (int k = 0; k < graphicRaycastResultsNoDomint.Count; k++)
				{
					graphicRaycastObjectsNoDomint.Add(graphicRaycastResultsNoDomint[k].gameObject);
				}
				raycastResult = BaseInputModule.FindFirstRaycast(graphicRaycastResultsNoDomint);
				graphicRaycastResultsNoDomint.Clear();
			}
			_ = raycastResult.module != null;
			if (!(raycastResult.gameObject != null))
			{
				continue;
			}
			if (raycastResult.worldPosition == Vector3.zero)
			{
				raycastResult.worldPosition = GetIntersectionPosition(raycastResult.module.eventCamera, raycastResult);
			}
			float num = Mathf.Abs(raycastResult.worldPosition.z - raycastResult.module.eventCamera.transform.position.z);
			float num2 = Mathf.Abs(event_controller.event_data.pointerCurrentRaycast.worldPosition.z - raycastResult.module.eventCamera.transform.position.z);
			bool flag = false;
			if (event_controller.event_data.pointerCurrentRaycast.gameObject == null)
			{
				flag = true;
			}
			else if (num2 > num)
			{
				DEBUG(string.Concat("GraphicRaycast() ", event_controller.device, ", ", event_controller.event_data.pointerCurrentRaycast.gameObject.name, ", position: ", event_controller.event_data.pointerCurrentRaycast.worldPosition, ", distance: ", num2, " is farer than ", raycastResult.gameObject.name, ", position: ", raycastResult.worldPosition, ", new distance: ", num));
				flag = true;
			}
			else if (num2 == num)
			{
				int sortingOrder = event_controller.event_data.pointerCurrentRaycast.sortingOrder;
				int sortingOrder2 = raycastResult.sortingOrder;
				if (sortingOrder < sortingOrder2)
				{
					DEBUG(string.Concat("GraphicRaycast() ", event_controller.device, ", ", event_controller.event_data.pointerCurrentRaycast.gameObject.name, " sorting order: ", sortingOrder, " is smaller than ", raycastResult.gameObject.name, " sorting order: ", sortingOrder2));
					flag = true;
				}
			}
			if (flag)
			{
				event_controller.event_data.pointerCurrentRaycast = raycastResult;
				event_controller.event_data.position = raycastResult.screenPosition;
			}
		}
	}

	private bool IsPhysicalRaycasted(EventController event_controller, GameObject go)
	{
		if (event_controller.device == WaveVR_Controller.EDeviceType.Dominant)
		{
			return physicsRaycastObjectsDominant.Contains(go);
		}
		if (event_controller.device == WaveVR_Controller.EDeviceType.NonDominant)
		{
			return physicsRaycastObjectsNoDomint.Contains(go);
		}
		return false;
	}

	private bool IsGraphicRaycasted(EventController event_controller, GameObject go)
	{
		if (event_controller.device == WaveVR_Controller.EDeviceType.Dominant)
		{
			return graphicRaycastObjectsDominant.Contains(go);
		}
		if (event_controller.device == WaveVR_Controller.EDeviceType.NonDominant)
		{
			return graphicRaycastObjectsNoDomint.Contains(go);
		}
		return false;
	}

	private void EnterExitPhysicsObject(EventController event_controller)
	{
		if (event_controller.device == WaveVR_Controller.EDeviceType.Dominant)
		{
			CopyList(physicsRaycastObjectsDominant, physicsRaycastObjectsTmp);
			CopyList(prePhysicsRaycastObjectsDominant, prePhysicsRaycastObjectsTmp);
		}
		else if (event_controller.device == WaveVR_Controller.EDeviceType.NonDominant)
		{
			CopyList(physicsRaycastObjectsNoDomint, physicsRaycastObjectsTmp);
			CopyList(prePhysicsRaycastObjectsNoDomint, prePhysicsRaycastObjectsTmp);
		}
		if (physicsRaycastObjectsTmp.Count != 0)
		{
			for (int i = 0; i < physicsRaycastObjectsTmp.Count; i++)
			{
				if (physicsRaycastObjectsTmp[i] != null && !prePhysicsRaycastObjectsTmp.Contains(physicsRaycastObjectsTmp[i]))
				{
					ExecuteEvents.Execute(physicsRaycastObjectsTmp[i], event_controller.event_data, ExecuteEvents.pointerEnterHandler);
					DEBUG("EnterExitPhysicsObject() enter: " + physicsRaycastObjectsTmp[i]);
				}
			}
		}
		if (prePhysicsRaycastObjectsTmp.Count != 0)
		{
			for (int j = 0; j < prePhysicsRaycastObjectsTmp.Count; j++)
			{
				if (prePhysicsRaycastObjectsTmp[j] != null && !physicsRaycastObjectsTmp.Contains(prePhysicsRaycastObjectsTmp[j]))
				{
					ExecuteEvents.Execute(prePhysicsRaycastObjectsTmp[j], event_controller.event_data, ExecuteEvents.pointerExitHandler);
					DEBUG("EnterExitPhysicsObject() exit: " + prePhysicsRaycastObjectsTmp[j]);
				}
			}
		}
		prePhysicsRaycastObjectsTmp.Clear();
		for (int k = 0; k < physicsRaycastObjectsTmp.Count; k++)
		{
			prePhysicsRaycastObjectsTmp.Add(physicsRaycastObjectsTmp[k]);
		}
		if (event_controller.device == WaveVR_Controller.EDeviceType.Dominant)
		{
			CopyList(physicsRaycastObjectsTmp, physicsRaycastObjectsDominant);
			CopyList(prePhysicsRaycastObjectsTmp, prePhysicsRaycastObjectsDominant);
		}
		if (event_controller.device == WaveVR_Controller.EDeviceType.NonDominant)
		{
			CopyList(physicsRaycastObjectsTmp, physicsRaycastObjectsNoDomint);
			CopyList(prePhysicsRaycastObjectsTmp, prePhysicsRaycastObjectsNoDomint);
		}
	}

	private void EnterExitGraphicObject(EventController event_controller)
	{
		if (event_controller.device == WaveVR_Controller.EDeviceType.Dominant)
		{
			CopyList(graphicRaycastObjectsDominant, graphicRaycastObjectsTmp);
			CopyList(preGraphicRaycastObjectsDominant, preGraphicRaycastObjectsTmp);
		}
		else if (event_controller.device == WaveVR_Controller.EDeviceType.NonDominant)
		{
			CopyList(graphicRaycastObjectsNoDomint, graphicRaycastObjectsTmp);
			CopyList(preGraphicRaycastObjectsNoDomint, preGraphicRaycastObjectsTmp);
		}
		if (graphicRaycastObjectsTmp.Count != 0)
		{
			for (int i = 0; i < graphicRaycastObjectsTmp.Count; i++)
			{
				if (graphicRaycastObjectsTmp[i] != null && !preGraphicRaycastObjectsTmp.Contains(graphicRaycastObjectsTmp[i]))
				{
					ExecuteEvents.Execute(graphicRaycastObjectsTmp[i], event_controller.event_data, ExecuteEvents.pointerEnterHandler);
					DEBUG("EnterExitGraphicObject() enter: " + graphicRaycastObjectsTmp[i]);
				}
			}
		}
		if (preGraphicRaycastObjectsTmp.Count != 0)
		{
			for (int j = 0; j < preGraphicRaycastObjectsTmp.Count; j++)
			{
				if (preGraphicRaycastObjectsTmp[j] != null && !graphicRaycastObjectsTmp.Contains(preGraphicRaycastObjectsTmp[j]))
				{
					ExecuteEvents.Execute(preGraphicRaycastObjectsTmp[j], event_controller.event_data, ExecuteEvents.pointerExitHandler);
					DEBUG("EnterExitGraphicObject() exit: " + preGraphicRaycastObjectsTmp[j]);
				}
			}
		}
		preGraphicRaycastObjectsTmp.Clear();
		for (int k = 0; k < graphicRaycastObjectsTmp.Count; k++)
		{
			preGraphicRaycastObjectsTmp.Add(graphicRaycastObjectsTmp[k]);
		}
		if (event_controller.device == WaveVR_Controller.EDeviceType.Dominant)
		{
			CopyList(graphicRaycastObjectsTmp, graphicRaycastObjectsDominant);
			CopyList(preGraphicRaycastObjectsTmp, preGraphicRaycastObjectsDominant);
		}
		if (event_controller.device == WaveVR_Controller.EDeviceType.NonDominant)
		{
			CopyList(graphicRaycastObjectsTmp, graphicRaycastObjectsNoDomint);
			CopyList(preGraphicRaycastObjectsTmp, preGraphicRaycastObjectsNoDomint);
		}
	}

	private void ExitAllObjects(EventController event_controller)
	{
		if (event_controller.device == WaveVR_Controller.EDeviceType.Dominant)
		{
			CopyList(prePhysicsRaycastObjectsDominant, prePhysicsRaycastObjectsTmp);
			CopyList(preGraphicRaycastObjectsDominant, preGraphicRaycastObjectsTmp);
		}
		else if (event_controller.device == WaveVR_Controller.EDeviceType.NonDominant)
		{
			CopyList(prePhysicsRaycastObjectsNoDomint, prePhysicsRaycastObjectsTmp);
			CopyList(preGraphicRaycastObjectsNoDomint, preGraphicRaycastObjectsTmp);
		}
		if (prePhysicsRaycastObjectsTmp.Count != 0)
		{
			for (int i = 0; i < prePhysicsRaycastObjectsTmp.Count; i++)
			{
				if (prePhysicsRaycastObjectsTmp[i] != null)
				{
					ExecuteEvents.Execute(prePhysicsRaycastObjectsTmp[i], event_controller.event_data, ExecuteEvents.pointerExitHandler);
					DEBUG("ExitAllObjects() exit: " + prePhysicsRaycastObjectsTmp[i]);
				}
			}
			prePhysicsRaycastObjectsTmp.Clear();
		}
		if (preGraphicRaycastObjectsTmp.Count != 0)
		{
			for (int j = 0; j < preGraphicRaycastObjectsTmp.Count; j++)
			{
				if (preGraphicRaycastObjectsTmp[j] != null)
				{
					ExecuteEvents.Execute(preGraphicRaycastObjectsTmp[j], event_controller.event_data, ExecuteEvents.pointerExitHandler);
					DEBUG("ExitAllObjects() exit: " + preGraphicRaycastObjectsTmp[j]);
				}
			}
			preGraphicRaycastObjectsTmp.Clear();
		}
		if (event_controller.device == WaveVR_Controller.EDeviceType.Dominant)
		{
			CopyList(prePhysicsRaycastObjectsTmp, prePhysicsRaycastObjectsDominant);
			CopyList(preGraphicRaycastObjectsTmp, preGraphicRaycastObjectsDominant);
		}
		if (event_controller.device == WaveVR_Controller.EDeviceType.NonDominant)
		{
			CopyList(prePhysicsRaycastObjectsTmp, prePhysicsRaycastObjectsNoDomint);
			CopyList(preGraphicRaycastObjectsTmp, preGraphicRaycastObjectsNoDomint);
		}
	}

	private void OnTriggerDown(WaveVR_Controller.EDeviceType type, PointerEventData event_data)
	{
		GameObject raycastedObject = GetRaycastedObject(type);
		if (!(raycastedObject == null))
		{
			event_data.pressPosition = event_data.position;
			event_data.pointerPressRaycast = event_data.pointerCurrentRaycast;
			event_data.pointerPress = ExecuteEvents.ExecuteHierarchy(raycastedObject, event_data, ExecuteEvents.pointerDownHandler) ?? ExecuteEvents.GetEventHandler<IPointerClickHandler>(raycastedObject);
			DEBUG(string.Concat("OnTriggerDown() device: ", type, " send Pointer Down to ", event_data.pointerPress, ", current GameObject is ", raycastedObject));
			event_data.pointerDrag = ExecuteEvents.GetEventHandler<IDragHandler>(raycastedObject);
			if (event_data.pointerDrag != null)
			{
				DEBUG(string.Concat("OnTriggerDown() device: ", type, " send initializePotentialDrag to ", event_data.pointerDrag, ", current GameObject is ", raycastedObject));
				ExecuteEvents.Execute(event_data.pointerDrag, event_data, ExecuteEvents.initializePotentialDrag);
			}
			event_data.rawPointerPress = raycastedObject;
			event_data.eligibleForClick = true;
			event_data.delta = Vector2.zero;
			event_data.dragging = false;
			event_data.useDragThreshold = true;
			event_data.clickCount = 1;
			event_data.clickTime = Time.unscaledTime;
		}
	}

	private void OnTriggerUp(WaveVR_Controller.EDeviceType type, PointerEventData event_data)
	{
		if (event_data.eligibleForClick || event_data.dragging)
		{
			GameObject raycastedObject = GetRaycastedObject(type);
			if (event_data.pointerPress != null)
			{
				DEBUG(string.Concat("OnTriggerUp type: ", type, " send Pointer Up to ", event_data.pointerPress));
				ExecuteEvents.Execute(event_data.pointerPress, event_data, ExecuteEvents.pointerUpHandler);
			}
			if (event_data.eligibleForClick)
			{
				DEBUG(string.Concat("OnTriggerUp type: ", type, " send Pointer Click to ", event_data.pointerPress));
				ExecuteEvents.Execute(event_data.pointerPress, event_data, ExecuteEvents.pointerClickHandler);
			}
			else if (event_data.dragging)
			{
				DEBUG(string.Concat("OnTriggerUp type: ", type, " send Pointer Drop to ", raycastedObject, ", EndDrag to ", event_data.pointerDrag));
				ExecuteEvents.ExecuteHierarchy(raycastedObject, event_data, ExecuteEvents.dropHandler);
				ExecuteEvents.Execute(event_data.pointerDrag, event_data, ExecuteEvents.endDragHandler);
				event_data.pointerDrag = null;
				event_data.dragging = false;
			}
			event_data.pointerPress = null;
			event_data.rawPointerPress = null;
			event_data.eligibleForClick = false;
			event_data.clickCount = 0;
			event_data.clickTime = 0f;
		}
	}

	private void OnTriggerUpMouse(WaveVR_Controller.EDeviceType type, PointerEventData event_data)
	{
		if (!event_data.eligibleForClick && !event_data.dragging)
		{
			return;
		}
		GameObject raycastedObject = GetRaycastedObject(type);
		if (event_data.pointerPress != null)
		{
			DEBUG(string.Concat("OnTriggerUpMouse() type: ", type, " send Pointer Up to ", event_data.pointerPress));
			ExecuteEvents.Execute(event_data.pointerPress, event_data, ExecuteEvents.pointerUpHandler);
		}
		if (event_data.eligibleForClick)
		{
			GameObject eventHandler = ExecuteEvents.GetEventHandler<IPointerClickHandler>(raycastedObject);
			if (!UnityMode_PriorDrag)
			{
				if (eventHandler != null)
				{
					if (eventHandler == event_data.pointerPress)
					{
						DEBUG(string.Concat("OnTriggerUpMouse() type: ", type, " send Pointer Click to ", event_data.pointerPress));
						ExecuteEvents.Execute(event_data.pointerPress, event_data, ExecuteEvents.pointerClickHandler);
					}
					else
					{
						DEBUG(string.Concat("OnTriggerUpMouse() type: ", type, " pointer down object ", event_data.pointerPress, " is different with click object ", eventHandler));
					}
				}
				else if (event_data.dragging)
				{
					if (ExecuteEvents.GetEventHandler<IDropHandler>(raycastedObject) == event_data.pointerDrag)
					{
						DEBUG(string.Concat("OnTriggerUpMouse() type: ", type, " send Pointer Drop to ", event_data.pointerDrag));
						ExecuteEvents.Execute(event_data.pointerDrag, event_data, ExecuteEvents.dropHandler);
					}
					DEBUG(string.Concat("OnTriggerUpMouse() type: ", type, " send Pointer endDrag to ", event_data.pointerDrag));
					ExecuteEvents.Execute(event_data.pointerDrag, event_data, ExecuteEvents.endDragHandler);
					event_data.pointerDrag = null;
					event_data.dragging = false;
				}
			}
			else if (event_data.dragging)
			{
				if (ExecuteEvents.GetEventHandler<IDropHandler>(raycastedObject) == event_data.pointerDrag)
				{
					DEBUG(string.Concat("OnTriggerUpMouse() type: ", type, " send Pointer Drop to ", event_data.pointerDrag));
					ExecuteEvents.Execute(event_data.pointerDrag, event_data, ExecuteEvents.dropHandler);
				}
				DEBUG(string.Concat("OnTriggerUpMouse() type: ", type, " send Pointer endDrag to ", event_data.pointerDrag));
				ExecuteEvents.Execute(event_data.pointerDrag, event_data, ExecuteEvents.endDragHandler);
				event_data.pointerDrag = null;
				event_data.dragging = false;
			}
			else if (eventHandler != null)
			{
				if (eventHandler == event_data.pointerPress)
				{
					DEBUG(string.Concat("OnTriggerUpMouse() type: ", type, " send Pointer Click to ", event_data.pointerPress));
					ExecuteEvents.Execute(event_data.pointerPress, event_data, ExecuteEvents.pointerClickHandler);
				}
				else
				{
					DEBUG(string.Concat("OnTriggerUpMouse() type: ", type, " pointer down object ", event_data.pointerPress, " is different with click object ", eventHandler));
				}
			}
		}
		event_data.pointerPress = null;
		event_data.rawPointerPress = null;
		event_data.eligibleForClick = false;
		event_data.clickCount = 0;
		event_data.clickTime = 0f;
	}

	private void OnDrag(WaveVR_Controller.EDeviceType type, PointerEventData event_data)
	{
		if (Time.unscaledTime - event_data.clickTime < 0.2f || event_data.pointerDrag == null)
		{
			return;
		}
		if (event_data.pointerDrag != null && !event_data.dragging)
		{
			DEBUG(string.Concat("OnDrag() device: ", type, " send BeginDrag to ", event_data.pointerDrag));
			ExecuteEvents.Execute(event_data.pointerDrag, event_data, ExecuteEvents.beginDragHandler);
			event_data.dragging = true;
		}
		if (event_data.dragging && event_data.pointerDrag != null)
		{
			if (event_data.pointerPress != null && event_data.pointerPress != event_data.pointerDrag)
			{
				DEBUG(string.Concat("OnDrag device: ", type, " send Pointer Up to ", event_data.pointerPress, ", drag object: ", event_data.pointerDrag));
				ExecuteEvents.Execute(event_data.pointerPress, event_data, ExecuteEvents.pointerUpHandler);
				event_data.eligibleForClick = false;
				event_data.pointerPress = null;
				event_data.rawPointerPress = null;
			}
			ExecuteEvents.Execute(event_data.pointerDrag, event_data, ExecuteEvents.dragHandler);
		}
	}

	private void OnDragMouse(WaveVR_Controller.EDeviceType type, PointerEventData event_data)
	{
		if (!(Time.unscaledTime - event_data.clickTime < 0.2f) && !(event_data.pointerDrag == null))
		{
			if (!event_data.dragging)
			{
				DEBUG(string.Concat("OnDragMouse() device: ", type, " send BeginDrag to ", event_data.pointerDrag));
				ExecuteEvents.Execute(event_data.pointerDrag, event_data, ExecuteEvents.beginDragHandler);
				event_data.dragging = true;
			}
			else
			{
				ExecuteEvents.Execute(event_data.pointerDrag, event_data, ExecuteEvents.dragHandler);
			}
		}
	}

	private void OnTriggerHover(WaveVR_Controller.EDeviceType type, PointerEventData event_data)
	{
		ExecuteEvents.ExecuteHierarchy(GetRaycastedObject(type), event_data, WaveVR_ExecuteEvents.pointerHoverHandler);
	}

	private void OnTriggerEnterAndExit(WaveVR_Controller.EDeviceType type, PointerEventData event_data)
	{
		GameObject raycastedObject = GetRaycastedObject(type);
		if (event_data.pointerEnter != raycastedObject)
		{
			DEBUG(string.Concat("OnTriggerEnterAndExit() ", type, ", enter: ", raycastedObject, ", exit: ", event_data.pointerEnter));
			HandlePointerExitAndEnter(event_data, raycastedObject);
			DEBUG(string.Concat("OnTriggerEnterAndExit() ", type, ", pointerEnter: ", event_data.pointerEnter, ", camera: ", event_data.enterEventCamera));
		}
	}

	private void onButtonClick(EventController event_controller)
	{
		GameObject raycastedObject = GetRaycastedObject(event_controller.device);
		event_controller.eligibleForButtonClick = false;
		if (!(raycastedObject == null))
		{
			Button component = raycastedObject.GetComponent<Button>();
			if (component != null)
			{
				DEBUG(string.Concat("onButtonClick() trigger Button.onClick to ", component, " from ", event_controller.device));
				component.onClick.Invoke();
			}
			else
			{
				DEBUG(string.Concat("onButtonClick() ", event_controller.device, ", ", raycastedObject.name, " does NOT contain Button!"));
			}
		}
	}

	private void ResetPointerEventData(WaveVR_Controller.EDeviceType type)
	{
		EventController eventController = GetEventController(type);
		if (eventController != null)
		{
			if (eventController.event_data == null)
			{
				eventController.event_data = new PointerEventData(base.eventSystem);
			}
			eventController.event_data.Reset();
			eventController.event_data.position = centerOfScreen;
		}
	}

	private void ResetPointerEventData_Hybrid(WaveVR_Controller.EDeviceType type, Camera eventCam)
	{
		EventController eventController = GetEventController(type);
		if (eventController != null && eventCam != null)
		{
			if (eventController.event_data == null)
			{
				eventController.event_data = new PointerEventData(EventSystem.current);
			}
			eventController.event_data.Reset();
			eventController.event_data.position = new Vector2(0.5f * (float)eventCam.pixelWidth, 0.5f * (float)eventCam.pixelHeight);
		}
	}

	private Vector3 GetIntersectionPosition(Camera cam, RaycastResult raycastResult)
	{
		if (cam == null)
		{
			return Vector3.zero;
		}
		float num = raycastResult.distance + cam.nearClipPlane;
		return cam.transform.forward * num + cam.transform.position;
	}

	private GameObject GetRaycastedObject(WaveVR_Controller.EDeviceType type)
	{
		EventController eventController = GetEventController(type);
		if (eventController != null)
		{
			PointerEventData event_data = eventController.event_data;
			if (event_data != null)
			{
				return event_data.pointerCurrentRaycast.gameObject;
			}
		}
		return null;
	}

	private void CheckBeamPointerActive(EventController eventController)
	{
		if (eventController == null)
		{
			return;
		}
		if (eventController.pointer != null)
		{
			bool flag = eventController.pointer.gameObject.activeSelf && eventController.pointer.ShowPointer;
			if (eventController.pointerEnabled != flag)
			{
				eventController.pointerEnabled = flag;
				toChangeBeamPointer = eventController.pointerEnabled;
				DEBUG(string.Concat("CheckBeamPointerActive() ", eventController.device, ", pointer is ", eventController.pointerEnabled ? "active." : "inactive."));
			}
		}
		else
		{
			eventController.pointerEnabled = false;
		}
		if (eventController.beam != null)
		{
			bool flag2 = eventController.beam.gameObject.activeSelf && eventController.beam.ShowBeam;
			if (eventController.beamEnabled != flag2)
			{
				eventController.beamEnabled = flag2;
				toChangeBeamPointer = eventController.beamEnabled;
				DEBUG(string.Concat("CheckBeamPointerActive() ", eventController.device, ", beam is ", eventController.beamEnabled ? "active." : "inactive."));
			}
		}
		else
		{
			eventController.beamEnabled = false;
		}
	}

	private void SetPointerCameraTracker()
	{
		for (int i = 0; i < WaveVR_Controller.DeviceTypes.Length; i++)
		{
			WaveVR_Controller.EDeviceType eDeviceType = WaveVR_Controller.DeviceTypes[i];
			if (eDeviceType == WaveVR_Controller.EDeviceType.Head || GetEventController(eDeviceType) == null)
			{
				continue;
			}
			WaveVR_PointerCameraTracker waveVR_PointerCameraTracker = null;
			switch (eDeviceType)
			{
			case WaveVR_Controller.EDeviceType.Dominant:
				if (pointCameraDomint != null)
				{
					waveVR_PointerCameraTracker = pointCameraDomint.GetComponent<WaveVR_PointerCameraTracker>();
				}
				break;
			case WaveVR_Controller.EDeviceType.NonDominant:
				if (pointCameraNoDomt != null)
				{
					waveVR_PointerCameraTracker = pointCameraNoDomt.GetComponent<WaveVR_PointerCameraTracker>();
				}
				break;
			}
			if (!(waveVR_PointerCameraTracker != null) || !(waveVR_PointerCameraTracker.reticleObject == null))
			{
				continue;
			}
			EventController eventController = GetEventController(eDeviceType);
			bool flag = true;
			WaveVR.Device deviceByType = WaveVR.Instance.getDeviceByType(eDeviceType);
			if (deviceByType != null)
			{
				flag = deviceByType.connected;
			}
			if (eventController != null && flag)
			{
				if (eventController.pointer == null && eventController.controller != null)
				{
					eventController.pointer = eventController.controller.GetComponentInChildren<WaveVR_ControllerPointer>();
				}
				if (eventController.pointer != null)
				{
					waveVR_PointerCameraTracker.reticleObject = eventController.pointer.gameObject;
				}
			}
		}
	}

	private GameObject[] MergeArray(GameObject[] start, GameObject[] end)
	{
		GameObject[] array = null;
		if (start == null)
		{
			if (end != null)
			{
				array = end;
			}
		}
		else if (end == null)
		{
			array = start;
		}
		else
		{
			uint num = 0u;
			for (int i = 0; i < start.Length; i++)
			{
				for (int j = 0; j < end.Length; j++)
				{
					if ((object)start[i] == end[j])
					{
						num++;
						end[j] = null;
					}
				}
			}
			array = new GameObject[start.Length + end.Length - num];
			uint num2 = 0u;
			for (int k = 0; k < start.Length; k++)
			{
				array[num2++] = start[k];
			}
			for (int l = 0; l < end.Length; l++)
			{
				if (end[l] != null)
				{
					array[num2++] = end[l];
				}
			}
		}
		return array;
	}

	private void CopyList(List<GameObject> src, List<GameObject> dst)
	{
		dst.Clear();
		for (int i = 0; i < src.Count; i++)
		{
			dst.Add(src[i]);
		}
	}
}
[Obsolete("This interface is obsoleted.")]
public class WaveVR_ControllerListener : MonoBehaviour
{
	public class Device
	{
		public delegate void ButtonEventHandler();

		public delegate void ConnectionEventHandler(bool value);

		public static ulong Input_Mask_Menu = 2uL;

		public static ulong Input_Mask_Grip = 4uL;

		public static ulong Input_Mask_Touchpad = 65536uL;

		public static ulong Input_Mask_Trigger = 131072uL;

		public IEnumerator ieConnection;

		public IEnumerator iePressMenu;

		public IEnumerator iePressGrip;

		public IEnumerator iePressTouchpad;

		public IEnumerator iePressTrigger;

		public IEnumerator ieTouchTouchpad;

		public IEnumerator ieTouchTrigger;

		internal WaveVR_Utils.RigidTransform rtPose = WaveVR_Utils.RigidTransform.identity;

		internal WaveVR_Utils.WVR_ButtonState_t state;

		internal WaveVR_Utils.WVR_ButtonState_t pre_state;

		internal WVR_Axis_t axis;

		internal WVR_PoseState_t pose;

		private WaitForEndOfFrame waitForEndOfFrame = new WaitForEndOfFrame();

		public WVR_DeviceType DeviceType { get; private set; }

		public WaveVR_Utils.RigidTransform transform
		{
			get
			{
				if (!WaveVR.Instance.Initialized)
				{
					return rtPose;
				}
				switch (DeviceType)
				{
				case WVR_DeviceType.WVR_DeviceType_HMD:
					rtPose = WaveVR.Instance.hmd.rigidTransform;
					break;
				case WVR_DeviceType.WVR_DeviceType_Controller_Right:
					rtPose = WaveVR.Instance.controllerRight.rigidTransform;
					break;
				case WVR_DeviceType.WVR_DeviceType_Controller_Left:
					rtPose = WaveVR.Instance.controllerLeft.rigidTransform;
					break;
				}
				return rtPose;
			}
		}

		public bool connected { get; private set; }

		public event ButtonEventHandler PressDownListenersMenu;

		public event ButtonEventHandler PressDownListenersGrip;

		public event ButtonEventHandler PressDownListenersTouchpad;

		public event ButtonEventHandler PressDownListenersTrigger;

		public event ButtonEventHandler PressUpListenersMenu;

		public event ButtonEventHandler PressUpListenersGrip;

		public event ButtonEventHandler PressUpListenersTouchpad;

		public event ButtonEventHandler PressUpListenersTrigger;

		public event ButtonEventHandler TouchDownListenersTouchpad;

		public event ButtonEventHandler TouchDownListenersTrigger;

		public event ButtonEventHandler TouchUpListenersTouchpad;

		public event ButtonEventHandler TouchUpListenersTrigger;

		public event ConnectionEventHandler ConnectionStatusListeners;

		public Device(WVR_DeviceType dt)
		{
			WVR_Log.Log.i(LOG_TAG, "Initialize WaveVR_Controller Device: " + dt);
			DeviceType = dt;
			ieConnection = PollingConnectionStatus();
			iePressMenu = PollingPressState_Menu();
			iePressGrip = PollingPressState_Grip();
			iePressTouchpad = PollingPressState_Touchpad();
			iePressTrigger = PollingPressState_Trigger();
			ieTouchTouchpad = PollingTouchState_Touchpad();
			ieTouchTrigger = PollingTouchState_Trigger();
		}

		private IEnumerator PollingConnectionStatus()
		{
			while (true)
			{
				yield return waitForEndOfFrame;
				bool flag = WaveVR_Controller.Input(DeviceType).connected;
				if (connected != flag)
				{
					connected = !connected;
					if (this.ConnectionStatusListeners != null)
					{
						this.ConnectionStatusListeners(connected);
					}
				}
			}
		}

		public bool GetPress(WVR_InputId _id)
		{
			bool result = false;
			switch (_id)
			{
			case WVR_InputId.WVR_InputId_1:
				result = (state.BtnPressed & Input_Mask_Menu) != 0L;
				break;
			case WVR_InputId.WVR_InputId_2:
				result = (state.BtnPressed & Input_Mask_Grip) != 0L;
				break;
			case WVR_InputId.WVR_InputId_16:
				result = (state.BtnPressed & Input_Mask_Touchpad) != 0L;
				break;
			case WVR_InputId.WVR_InputId_17:
				result = (state.BtnPressed & Input_Mask_Trigger) != 0L;
				break;
			}
			return result;
		}

		private IEnumerator PollingPressState_Menu()
		{
			while (true)
			{
				yield return waitForEndOfFrame;
				bool press = WaveVR_Controller.Input(DeviceType).GetPress(WVR_InputId.WVR_InputId_1);
				ulong num = state.BtnPressed & Input_Mask_Menu;
				if (num == 0L)
				{
					pre_state.BtnPressed &= ~Input_Mask_Menu;
				}
				else
				{
					pre_state.BtnPressed |= num;
				}
				if (press)
				{
					state.BtnPressed |= Input_Mask_Menu;
				}
				else
				{
					state.BtnPressed &= ~Input_Mask_Menu;
				}
				if ((pre_state.BtnPressed ^ state.BtnPressed) != 0L)
				{
					if ((state.BtnPressed & Input_Mask_Menu) != 0L && (pre_state.BtnPressed & Input_Mask_Menu) == 0L && this.PressDownListenersMenu != null)
					{
						this.PressDownListenersMenu();
					}
					if ((state.BtnPressed & Input_Mask_Menu) == 0L && (pre_state.BtnPressed & Input_Mask_Menu) != 0L && this.PressUpListenersMenu != null)
					{
						this.PressUpListenersMenu();
					}
				}
			}
		}

		private IEnumerator PollingPressState_Grip()
		{
			while (true)
			{
				yield return waitForEndOfFrame;
				bool press = WaveVR_Controller.Input(DeviceType).GetPress(WVR_InputId.WVR_InputId_2);
				ulong num = state.BtnPressed & Input_Mask_Grip;
				if (num == 0L)
				{
					pre_state.BtnPressed &= ~Input_Mask_Grip;
				}
				else
				{
					pre_state.BtnPressed |= num;
				}
				if (press)
				{
					state.BtnPressed |= Input_Mask_Grip;
				}
				else
				{
					state.BtnPressed &= ~Input_Mask_Grip;
				}
				if ((pre_state.BtnPressed ^ state.BtnPressed) != 0L)
				{
					if ((state.BtnPressed & Input_Mask_Grip) != 0L && (pre_state.BtnPressed & Input_Mask_Grip) == 0L && this.PressDownListenersGrip != null)
					{
						this.PressDownListenersGrip();
					}
					if ((state.BtnPressed & Input_Mask_Grip) == 0L && (pre_state.BtnPressed & Input_Mask_Grip) != 0L && this.PressUpListenersGrip != null)
					{
						this.PressUpListenersGrip();
					}
				}
			}
		}

		private IEnumerator PollingPressState_Touchpad()
		{
			while (true)
			{
				yield return waitForEndOfFrame;
				bool press = WaveVR_Controller.Input(DeviceType).GetPress(WVR_InputId.WVR_InputId_16);
				ulong num = state.BtnPressed & Input_Mask_Touchpad;
				if (num == 0L)
				{
					pre_state.BtnPressed &= ~Input_Mask_Touchpad;
				}
				else
				{
					pre_state.BtnPressed |= num;
				}
				if (press)
				{
					state.BtnPressed |= Input_Mask_Touchpad;
				}
				else
				{
					state.BtnPressed &= ~Input_Mask_Touchpad;
				}
				if ((pre_state.BtnPressed ^ state.BtnPressed) != 0L)
				{
					if ((state.BtnPressed & Input_Mask_Touchpad) != 0L && (pre_state.BtnPressed & Input_Mask_Touchpad) == 0L && this.PressDownListenersTouchpad != null)
					{
						this.PressDownListenersTouchpad();
					}
					if ((state.BtnPressed & Input_Mask_Touchpad) == 0L && (pre_state.BtnPressed & Input_Mask_Touchpad) != 0L && this.PressUpListenersTouchpad != null)
					{
						this.PressUpListenersTouchpad();
					}
				}
			}
		}

		private IEnumerator PollingPressState_Trigger()
		{
			while (true)
			{
				yield return waitForEndOfFrame;
				bool press = WaveVR_Controller.Input(DeviceType).GetPress(WVR_InputId.WVR_InputId_17);
				ulong num = state.BtnPressed & Input_Mask_Trigger;
				if (num == 0L)
				{
					pre_state.BtnPressed &= ~Input_Mask_Trigger;
				}
				else
				{
					pre_state.BtnPressed |= num;
				}
				if (press)
				{
					state.BtnPressed |= Input_Mask_Trigger;
				}
				else
				{
					state.BtnPressed &= ~Input_Mask_Trigger;
				}
				if ((pre_state.BtnPressed ^ state.BtnPressed) != 0L)
				{
					if ((state.BtnPressed & Input_Mask_Trigger) != 0L && (pre_state.BtnPressed & Input_Mask_Trigger) == 0L && this.PressDownListenersTrigger != null)
					{
						this.PressDownListenersTrigger();
					}
					if ((state.BtnPressed & Input_Mask_Trigger) == 0L && (pre_state.BtnPressed & Input_Mask_Trigger) != 0L && this.PressUpListenersTrigger != null)
					{
						this.PressUpListenersTrigger();
					}
				}
			}
		}

		public bool GetTouch(WVR_InputId _id)
		{
			bool result = false;
			switch (_id)
			{
			case WVR_InputId.WVR_InputId_16:
				result = (state.BtnTouched & Input_Mask_Touchpad) != 0L;
				break;
			case WVR_InputId.WVR_InputId_17:
				result = (state.BtnTouched & Input_Mask_Trigger) != 0L;
				break;
			}
			return result;
		}

		private IEnumerator PollingTouchState_Touchpad()
		{
			while (true)
			{
				yield return waitForEndOfFrame;
				bool touch = WaveVR_Controller.Input(DeviceType).GetTouch(WVR_InputId.WVR_InputId_16);
				ulong num = state.BtnTouched & Input_Mask_Touchpad;
				if (num == 0L)
				{
					pre_state.BtnTouched &= ~Input_Mask_Touchpad;
				}
				else
				{
					pre_state.BtnTouched |= num;
				}
				if (touch)
				{
					state.BtnTouched |= Input_Mask_Touchpad;
				}
				else
				{
					state.BtnTouched &= ~Input_Mask_Touchpad;
				}
				if ((pre_state.BtnTouched ^ state.BtnTouched) != 0L)
				{
					if ((state.BtnTouched & Input_Mask_Touchpad) != 0L && (pre_state.BtnTouched & Input_Mask_Touchpad) == 0L && this.TouchDownListenersTouchpad != null)
					{
						this.TouchDownListenersTouchpad();
					}
					if ((state.BtnTouched & Input_Mask_Touchpad) == 0L && (pre_state.BtnTouched & Input_Mask_Touchpad) != 0L && this.TouchUpListenersTouchpad != null)
					{
						this.TouchUpListenersTouchpad();
					}
				}
			}
		}

		private IEnumerator PollingTouchState_Trigger()
		{
			while (true)
			{
				yield return waitForEndOfFrame;
				bool touch = WaveVR_Controller.Input(DeviceType).GetTouch(WVR_InputId.WVR_InputId_17);
				ulong num = state.BtnTouched & Input_Mask_Trigger;
				if (num == 0L)
				{
					pre_state.BtnTouched &= ~Input_Mask_Trigger;
				}
				else
				{
					pre_state.BtnTouched |= num;
				}
				if (touch)
				{
					state.BtnTouched |= Input_Mask_Trigger;
				}
				else
				{
					state.BtnTouched &= ~Input_Mask_Trigger;
				}
				if ((pre_state.BtnTouched ^ state.BtnTouched) != 0L)
				{
					if ((state.BtnTouched & Input_Mask_Trigger) != 0L && (pre_state.BtnTouched & Input_Mask_Trigger) == 0L && this.TouchDownListenersTrigger != null)
					{
						this.TouchDownListenersTrigger();
					}
					if ((state.BtnTouched & Input_Mask_Trigger) == 0L && (pre_state.BtnTouched & Input_Mask_Trigger) != 0L && this.TouchUpListenersTrigger != null)
					{
						this.TouchUpListenersTrigger();
					}
				}
			}
		}

		public Vector2 GetAxis(WVR_InputId _id)
		{
			if (_id != WVR_InputId.WVR_InputId_16 && _id != WVR_InputId.WVR_InputId_17)
			{
				WVR_Log.Log.e(LOG_TAG, string.Concat("GetAxis, button ", _id, " does NOT have axis!"));
				return Vector2.zero;
			}
			return WaveVR_Controller.Input(DeviceType).GetAxis(_id);
		}

		public void TriggerHapticPulse(uint _durationMicroSec = 1000000u, WVR_InputId _id = WVR_InputId.WVR_InputId_16)
		{
			WaveVR_Controller.Input(DeviceType).TriggerHapticPulse(10000u);
		}
	}

	private static string LOG_TAG = "WaveVR_ControllerListener";

	private static WaveVR_ControllerListener instance = null;

	private static Device[] devices;

	public static WaveVR_ControllerListener Instance
	{
		get
		{
			if (instance == null)
			{
				WVR_Log.Log.i(LOG_TAG, "Instance, create WaveVR_ControllerListener GameObject");
				instance = new GameObject("WaveVR_ControllerListener").AddComponent<WaveVR_ControllerListener>();
				UnityEngine.Object.DontDestroyOnLoad(instance);
			}
			return instance;
		}
	}

	public Device ChangeRole(WVR_DeviceType deviceIndex)
	{
		if (devices == null)
		{
			devices = new Device[Enum.GetNames(typeof(WVR_DeviceType)).Length];
			uint num = 0u;
			devices[num++] = new Device(WVR_DeviceType.WVR_DeviceType_HMD);
			devices[num++] = new Device(WVR_DeviceType.WVR_DeviceType_Controller_Right);
			devices[num++] = new Device(WVR_DeviceType.WVR_DeviceType_Controller_Left);
		}
		for (uint num2 = 0u; num2 < devices.Length; num2++)
		{
			if (deviceIndex == devices[num2].DeviceType)
			{
				return devices[num2];
			}
		}
		return null;
	}

	public Device Input(WVR_DeviceType deviceIndex)
	{
		if (WaveVR_Controller.IsLeftHanded)
		{
			switch (deviceIndex)
			{
			case WVR_DeviceType.WVR_DeviceType_Controller_Right:
				deviceIndex = WVR_DeviceType.WVR_DeviceType_Controller_Left;
				break;
			case WVR_DeviceType.WVR_DeviceType_Controller_Left:
				deviceIndex = WVR_DeviceType.WVR_DeviceType_Controller_Right;
				break;
			}
		}
		return ChangeRole(deviceIndex);
	}

	public Device Input(WaveVR_Controller.EDeviceType type)
	{
		WVR_DeviceType deviceType = WaveVR_Controller.Input(type).DeviceType;
		return ChangeRole(deviceType);
	}

	private void Start()
	{
		StartCoroutine(Input(WVR_DeviceType.WVR_DeviceType_Controller_Left).ieConnection);
		StartCoroutine(Input(WVR_DeviceType.WVR_DeviceType_Controller_Left).iePressMenu);
		StartCoroutine(Input(WVR_DeviceType.WVR_DeviceType_Controller_Left).iePressGrip);
		StartCoroutine(Input(WVR_DeviceType.WVR_DeviceType_Controller_Left).iePressTouchpad);
		StartCoroutine(Input(WVR_DeviceType.WVR_DeviceType_Controller_Left).iePressTrigger);
		StartCoroutine(Input(WVR_DeviceType.WVR_DeviceType_Controller_Left).ieTouchTouchpad);
		StartCoroutine(Input(WVR_DeviceType.WVR_DeviceType_Controller_Left).ieTouchTrigger);
		StartCoroutine(Input(WVR_DeviceType.WVR_DeviceType_Controller_Right).ieConnection);
		StartCoroutine(Input(WVR_DeviceType.WVR_DeviceType_Controller_Right).iePressMenu);
		StartCoroutine(Input(WVR_DeviceType.WVR_DeviceType_Controller_Right).iePressGrip);
		StartCoroutine(Input(WVR_DeviceType.WVR_DeviceType_Controller_Right).iePressTouchpad);
		StartCoroutine(Input(WVR_DeviceType.WVR_DeviceType_Controller_Right).iePressTrigger);
		StartCoroutine(Input(WVR_DeviceType.WVR_DeviceType_Controller_Right).ieTouchTouchpad);
		StartCoroutine(Input(WVR_DeviceType.WVR_DeviceType_Controller_Right).ieTouchTrigger);
	}

	private void Update()
	{
	}
}
public class WaveVR_ControllerLoader : MonoBehaviour
{
	public enum ControllerHand
	{
		Dominant,
		Non_Dominant
	}

	public enum CComponent
	{
		One_Bone,
		Multi_Component
	}

	public enum CTrackingSpace
	{
		REAL_POSITION_ONLY,
		FAKE_POSITION_ONLY,
		AUTO_POSITION_ONLY,
		ROTATION_ONLY,
		ROTATION_AND_REAL_POSITION,
		ROTATION_AND_FAKE_POSITION,
		ROTATION_AND_AUTO_POSITION,
		CTS_SYSTEM
	}

	public enum ControllerType
	{
		ControllerType_None,
		ControllerType_Generic,
		ControllerType_Resources,
		ControllerType_AssetBundles,
		ControllerType_AdaptiveController
	}

	public enum CLoadingState
	{
		LoadingState_NOT_LOADED,
		LoadingState_LOADING,
		LoadingState_LOADED
	}

	private static string LOG_TAG = "WaveVR_ControllerLoader";

	[Header("Loading options")]
	public ControllerHand WhichHand;

	public CComponent ControllerComponents = CComponent.Multi_Component;

	public bool TrackPosition = true;

	public WVR_SimulationOption SimulationOption;

	public bool FollowHead;

	public bool TrackRotation = true;

	[Header("Indication feature")]
	public bool overwriteIndicatorSettings = true;

	public bool showIndicator;

	public bool hideIndicatorByRoll = true;

	public bool basedOnEmitter = true;

	[Range(0f, 90f)]
	public float showIndicatorAngle = 30f;

	[Header("Line customization")]
	[Range(0.01f, 0.1f)]
	public float lineLength = 0.03f;

	[Range(0.0001f, 0.1f)]
	public float lineStartWidth = 0.0004f;

	[Range(0.0001f, 0.1f)]
	public float lineEndWidth = 0.0004f;

	public Color lineColor = Color.white;

	[Header("Text customization")]
	[Range(0.01f, 0.2f)]
	public float textCharacterSize = 0.08f;

	[Range(0.01f, 0.2f)]
	public float zhCharactarSize = 0.07f;

	[Range(50f, 200f)]
	public int textFontSize = 100;

	public Color textColor = Color.white;

	[Header("Indications")]
	public bool useIndicatorSystemConfig = true;

	public List<ButtonIndication> buttonIndicationList = new List<ButtonIndication>();

	[Header("AdaptiveLoading")]
	public bool adaptiveLoading = true;

	public bool enableEmitter = true;

	public bool sendEvent = true;

	[Header("ButtonEffect")]
	public bool enableButtonEffect = true;

	public bool useEffectSystemConfig = true;

	public Color32 buttonEffectColor = new Color32(0, 179, 227, byte.MaxValue);

	[Header("Beam")]
	public bool ShowBeam = true;

	public bool useBeamSystemConfig = true;

	public bool updateEveryFrame;

	public float StartWidth = 0.000625f;

	public float EndWidth = 0.00125f;

	public float StartOffset = 0.015f;

	public float EndOffset = 0.8f;

	public Color32 StartColor = new Color32(byte.MaxValue, byte.MaxValue, byte.MaxValue, byte.MaxValue);

	public Color32 EndColor = new Color32(byte.MaxValue, byte.MaxValue, byte.MaxValue, 77);

	public bool useDefaultMaterial = true;

	public Material customMat;

	[Header("Controller pointer")]
	public bool showPointer = true;

	public bool usePointerSystemConfig = true;

	public bool Blink;

	public bool UseDefaultTexture = true;

	public Texture2D customTexture;

	public float PointerOuterDiameterMin = 0.01f;

	private float PointerDistanceInMeters = 1.3f;

	public bool useTexture = true;

	public Color PointerColor = Color.white;

	private Color borderColor = new Color(119f, 119f, 119f, 255f);

	private Color focusColor = new Color(255f, 255f, 255f, 255f);

	private Color focusBorderColor = new Color(119f, 119f, 119f, 255f);

	private string TextureName;

	private ControllerType controllerType;

	private GameObject controllerPrefab;

	private GameObject originalControllerPrefab;

	private string controllerFileName = "";

	private string controllerModelFoler = "Controller/";

	private string genericControllerFileName = "Generic_";

	private List<AssetBundle> loadedAssetBundle = new List<AssetBundle>();

	private string renderModelNamePath = "";

	private WaveVR_Controller.EDeviceType focusController = WaveVR_Controller.EDeviceType.Dominant;

	private WaveVR_Controller.EDeviceType deviceType = WaveVR_Controller.EDeviceType.Dominant;

	private string renderModelName = "";

	private bool connected;

	private CLoadingState mLoadingState;

	private string parameterName = "GetRenderModelName";

	private IntPtr ptrParameterName = IntPtr.Zero;

	private IntPtr ptrResult = IntPtr.Zero;

	private uint resultVertLength = 64u;

	private int bufferSize = 64;

	private WaveVR_ControllerInstanceManager CtrInstanceMgr;

	private int ControllerIdx;

	private ModelSpecify modelSpecify;

	private bool forceCheckRenderModelName;

	private bool lastFrameConnection;

	private GameObject eventSystem;

	private void PrintDebugLog(string msg)
	{
		WVR_Log.Log.d(LOG_TAG, string.Concat("Hand: ", WhichHand, ", ", msg), logInEditor: true);
	}

	private void PrintInfoLog(string msg)
	{
		WVR_Log.Log.i(LOG_TAG, string.Concat("Hand: ", WhichHand, ", ", msg), logInEditor: true);
	}

	private void PrintWarningLog(string msg)
	{
		WVR_Log.Log.w(LOG_TAG, string.Concat("Hand: ", WhichHand, ", ", msg), logInEditor: true);
	}

	private void checkAndCreateCIM()
	{
		GameObject[] array = UnityEngine.Object.FindObjectsOfType<GameObject>();
		foreach (GameObject gameObject in array)
		{
			if (gameObject.name.Equals("WaveVR_ControllerInstanceManager"))
			{
				PrintDebugLog("WaveVR_ControllerInstanceManager is found in scene!");
				CtrInstanceMgr = gameObject.GetComponent<WaveVR_ControllerInstanceManager>();
				break;
			}
		}
		if (CtrInstanceMgr == null)
		{
			PrintDebugLog("controllerInstanceManager is NOT found in scene! create it.");
			CtrInstanceMgr = WaveVR_ControllerInstanceManager.Instance;
		}
	}

	private void OnEnable()
	{
		resetControllerState();
		if (WhichHand == ControllerHand.Dominant)
		{
			deviceType = WaveVR_Controller.EDeviceType.Dominant;
			modelSpecify = ModelSpecify.MS_Dominant;
		}
		else
		{
			deviceType = WaveVR_Controller.EDeviceType.NonDominant;
			modelSpecify = ModelSpecify.MS_NonDominant;
		}
		WaveVR_Utils.Event.Listen(WaveVR_Utils.Event.DEVICE_CONNECTED, onDeviceConnected);
	}

	private void resetControllerState()
	{
		controllerPrefab = null;
		controllerFileName = "";
		mLoadingState = CLoadingState.LoadingState_NOT_LOADED;
		genericControllerFileName = "Generic_";
		renderModelName = "";
		ControllerIdx = 0;
		connected = false;
	}

	private void OnDisable()
	{
		WaveVR_Utils.Event.Remove(WaveVR_Utils.Event.DEVICE_CONNECTED, onDeviceConnected);
	}

	private void OnDestroy()
	{
		PrintDebugLog("OnDestroy");
		removeControllerFromMgr("OnDestroy()");
	}

	private void Start()
	{
		loadedAssetBundle.Clear();
		if (checkConnection() != connected)
		{
			connected = !connected;
		}
		if (connected && WaveVR.Instance.Initialized)
		{
			WaveVR.Device deviceByType = WaveVR.Instance.getDeviceByType(deviceType);
			onLoadController(deviceByType.type);
		}
		WaveVR_EventSystemControllerProvider.Instance.MarkControllerLoader(deviceType, value: true);
		forceCheckRenderModelName = true;
	}

	private void onDeviceConnected(params object[] args)
	{
		WVR_DeviceType wVR_DeviceType = (WVR_DeviceType)args[0];
		bool flag = (bool)args[1];
		PrintDebugLog(string.Concat("onDeviceConnected() device ", wVR_DeviceType, " is ", flag ? "connected." : "disconnected."));
		if (wVR_DeviceType == WaveVR_Controller.Input(deviceType).DeviceType)
		{
			connected = flag;
			if (connected && controllerPrefab == null)
			{
				onLoadController(wVR_DeviceType);
			}
		}
	}

	private void removeControllerFromMgr(string funcName)
	{
		if (CtrInstanceMgr != null && ControllerIdx != 0)
		{
			CtrInstanceMgr.removeControllerInstance(ControllerIdx);
			PrintDebugLog(funcName + " remove controller: " + ControllerIdx);
			ControllerIdx = 0;
		}
	}

	private void UpdateFocusController()
	{
		WVR_DeviceType num = Interop.WVR_GetFocusedController();
		if (num == WVR_DeviceType.WVR_DeviceType_Controller_Right)
		{
			focusController = WaveVR_Controller.EDeviceType.Dominant;
		}
		if (num == WVR_DeviceType.WVR_DeviceType_Controller_Left)
		{
			focusController = WaveVR_Controller.EDeviceType.NonDominant;
		}
	}

	private void onLoadController(WVR_DeviceType type)
	{
		if (mLoadingState != 0)
		{
			PrintDebugLog("Controller model is loading or already loaded! state: " + mLoadingState);
			return;
		}
		mLoadingState = CLoadingState.LoadingState_LOADING;
		controllerFileName = "";
		controllerModelFoler = "Controller/";
		genericControllerFileName = "Generic_";
		checkAndCreateCIM();
		if (renderModelName == "")
		{
			ptrParameterName = Marshal.StringToHGlobalAnsi(parameterName);
			ptrResult = Marshal.AllocHGlobal(bufferSize);
			for (int i = 0; i < bufferSize; i++)
			{
				Marshal.WriteByte(ptrResult, i, 0);
			}
			uint num = Interop.WVR_GetParameters(type, ptrParameterName, ptrResult, resultVertLength);
			string text = Marshal.PtrToStringAnsi(ptrResult);
			Marshal.FreeHGlobal(ptrParameterName);
			Marshal.FreeHGlobal(ptrResult);
			if (num != 0)
			{
				renderModelName = text;
			}
		}
		int deviceIndex = -1;
		string s = "backdoor_get_device_index";
		ptrParameterName = Marshal.StringToHGlobalAnsi(s);
		IntPtr intPtr = Marshal.AllocHGlobal(2);
		Marshal.WriteByte(intPtr, 0, 0);
		Interop.WVR_GetParameters(type, ptrParameterName, intPtr, 2u);
		int result = 0;
		if (int.TryParse(Marshal.PtrToStringAnsi(intPtr), out result))
		{
			deviceIndex = result;
		}
		Marshal.FreeHGlobal(ptrParameterName);
		Marshal.FreeHGlobal(intPtr);
		PrintInfoLog("get controller id from runtime is " + renderModelName);
		controllerFileName += renderModelName;
		controllerFileName += "_";
		if (ControllerComponents == CComponent.Multi_Component)
		{
			controllerFileName += "MC_";
		}
		else
		{
			controllerFileName += "OB_";
		}
		if (WhichHand == ControllerHand.Dominant)
		{
			controllerFileName += "R";
		}
		else
		{
			controllerFileName += "L";
		}
		PrintInfoLog("controller file name is " + controllerFileName);
		bool flag = false;
		controllerType = ControllerType.ControllerType_None;
		if (adaptiveLoading)
		{
			if (Interop.WVR_GetWaveRuntimeVersion() >= 2)
			{
				PrintInfoLog("Start adaptive loading");
				string text2 = Interop.WVR_DeployRenderModelAssets(deviceIndex, renderModelName);
				if (text2 != "")
				{
					string text3 = text2 + "Model";
					flag = loadMeshAndImageByDevice(text3);
					if (flag)
					{
						PrintInfoLog("Model FBX is found!");
					}
					if (!flag)
					{
						string unityVersion = UnityEngine.Application.unityVersion;
						PrintInfoLog("Application built by Unity version : " + unityVersion);
						renderModelNamePath = text2 + "Unity";
						switch (checkAssetBundlesVersion(unityVersion))
						{
						case 1:
							renderModelNamePath += "/5.6";
							break;
						case 2:
							renderModelNamePath += "/2017.3";
							break;
						}
						flag = tryLoadModelFromRuntime(renderModelNamePath, controllerFileName);
						if (!flag)
						{
							PrintInfoLog("Try to load generic controller model from runtime");
							string text4 = genericControllerFileName;
							flag = tryLoadModelFromRuntime(modelName: (WhichHand != 0) ? (text4 + "MC_L") : (text4 + "MC_R"), renderModelNamePath: renderModelNamePath);
						}
					}
				}
			}
			else
			{
				PrintInfoLog("API Level(2) is larger than Runtime Version (" + Interop.WVR_GetWaveRuntimeVersion() + ")");
			}
		}
		else
		{
			PrintInfoLog("Disable adaptive loading, use package resource loading");
		}
		if (!flag)
		{
			PrintWarningLog("Start package resource loading");
			originalControllerPrefab = Resources.Load(controllerModelFoler + controllerFileName) as GameObject;
			if (originalControllerPrefab == null)
			{
				WVR_Log.Log.e(LOG_TAG, "Can't load preferred controller model from package: " + controllerFileName);
			}
			else
			{
				PrintInfoLog(controllerFileName + " controller model is found!");
				controllerType = ControllerType.ControllerType_Resources;
				flag = true;
			}
		}
		if (!flag)
		{
			PrintInfoLog(controllerFileName + " controller model is not found from runtime and package!");
			originalControllerPrefab = loadGenericControllerModelFromPackage(genericControllerFileName);
			if (originalControllerPrefab == null)
			{
				WVR_Log.Log.e(LOG_TAG, "Can't load generic controller model, Please check file under Resources/" + controllerModelFoler + genericControllerFileName + ".prefab is exist!");
			}
			else
			{
				PrintInfoLog(genericControllerFileName + " controller model is found!");
				controllerType = ControllerType.ControllerType_Generic;
				flag = true;
			}
		}
		if (flag && originalControllerPrefab != null)
		{
			UpdateFocusController();
			PrintInfoLog(string.Concat("Instantiate controller model, controller type: ", controllerType, ", focus: ", focusController));
			SetControllerOptions(originalControllerPrefab);
			if (controllerType == ControllerType.ControllerType_AdaptiveController)
			{
				PresetAdaptiveControllerParameters(originalControllerPrefab);
			}
			SetControllerBeamParameters(originalControllerPrefab);
			SetControllerPointerParameters(originalControllerPrefab);
			controllerPrefab = UnityEngine.Object.Instantiate(originalControllerPrefab);
			controllerPrefab.transform.parent = base.transform.parent;
			ApplyIndicatorParameters();
			WaveVR_EventSystemControllerProvider.Instance.SetControllerModel(deviceType, controllerPrefab);
			if (controllerType == ControllerType.ControllerType_AdaptiveController)
			{
				setEventSystemParameter();
			}
			if (CtrInstanceMgr != null)
			{
				WVR_DeviceType type2 = ((deviceType == WaveVR_Controller.EDeviceType.Dominant) ? WVR_DeviceType.WVR_DeviceType_Controller_Right : WVR_DeviceType.WVR_DeviceType_Controller_Left);
				ControllerIdx = CtrInstanceMgr.registerControllerInstance(type2, controllerPrefab);
				PrintDebugLog("onLoadController() controller index: " + ControllerIdx);
			}
			PrintDebugLog(string.Concat("onLoadController() broadcast ", deviceType, " CONTROLLER_MODEL_LOADED"));
			WaveVR_Utils.Event.Send(WaveVR_Utils.Event.CONTROLLER_MODEL_LOADED, deviceType, controllerPrefab);
			mLoadingState = CLoadingState.LoadingState_LOADED;
		}
		if (adaptiveLoading && controllerType == ControllerType.ControllerType_AssetBundles)
		{
			PrintInfoLog("loadedAssetBundle length: " + loadedAssetBundle.Count);
			foreach (AssetBundle item in loadedAssetBundle)
			{
				item.Unload(unloadAllLoadedObjects: false);
			}
			loadedAssetBundle.Clear();
		}
		Resources.UnloadUnusedAssets();
		GC.Collect();
	}

	private bool loadMeshAndImageByDevice(string renderModelNamePath)
	{
		string text = renderModelNamePath + "/";
		string text2 = renderModelNamePath + "/";
		string path = text + "controller00.fbx";
		text2 += "controller00.png";
		bool flag = false;
		flag = File.Exists(path);
		PrintInfoLog("FBX exist = " + flag);
		if (flag)
		{
			bool flag2 = File.Exists(text2);
			PrintInfoLog("PNG exist: " + flag2);
			flag = flag2;
			if (flag)
			{
				originalControllerPrefab = Resources.Load("AdaptiveController") as GameObject;
				flag = ((originalControllerPrefab != null) ? true : false);
			}
			else
			{
				WaveVR_Utils.Event.Send(WaveVR_Utils.Event.DS_ASSETS_NOT_FOUND, deviceType);
			}
		}
		else
		{
			WaveVR_Utils.Event.Send(WaveVR_Utils.Event.DS_ASSETS_NOT_FOUND, deviceType);
		}
		PrintInfoLog("Files and prefab are ready: " + flag);
		if (flag)
		{
			controllerType = ControllerType.ControllerType_AdaptiveController;
			if (WaveVR_ControllerResourceHolder.Instance.addRenderModel(renderModelName, renderModelNamePath, modelSpecify, merge: true))
			{
				PrintInfoLog(string.Concat("Added ", modelSpecify, " render model, name: ", renderModelName));
			}
			else
			{
				PrintInfoLog(string.Concat(renderModelName, " adding ", modelSpecify, " model failure!"));
				if (WaveVR_ControllerResourceHolder.Instance.addRenderModel(renderModelName, renderModelNamePath, ModelSpecify.MS_Dominant, merge: true))
				{
					PrintInfoLog(string.Concat("Added MS_Dominant render model for name: ", renderModelName, " cant find ", modelSpecify, " model"));
				}
				else
				{
					PrintInfoLog(string.Concat(renderModelName, ", ", modelSpecify, " will use MS_Dominant model!"));
				}
			}
		}
		return flag;
	}

	private bool tryLoadModelFromRuntime(string renderModelNamePath, string modelName)
	{
		string text = renderModelNamePath + "/Unity";
		PrintInfoLog("tryLoadModelFromRuntime, path is " + text);
		foreach (AssetBundle item in loadedAssetBundle)
		{
			item.Unload(unloadAllLoadedObjects: false);
		}
		loadedAssetBundle.Clear();
		AssetBundle assetBundle = AssetBundle.LoadFromFile(text);
		if (assetBundle != null)
		{
			loadedAssetBundle.Add(assetBundle);
			AssetBundleManifest assetBundleManifest = assetBundle.LoadAsset<AssetBundleManifest>("AssetBundleManifest");
			if (assetBundleManifest != null)
			{
				PrintDebugLog(text + " loaded");
				string[] allAssetBundles = assetBundleManifest.GetAllAssetBundles();
				for (int i = 0; i < allAssetBundles.Length; i++)
				{
					string text2 = renderModelNamePath + "/" + allAssetBundles[i];
					assetBundle = AssetBundle.LoadFromFile(text2);
					loadedAssetBundle.Add(assetBundle);
					PrintDebugLog(text2 + " loaded");
				}
				PrintInfoLog("All asset Bundles loaded, start loading asset");
				originalControllerPrefab = assetBundle.LoadAsset<GameObject>(modelName);
				if (originalControllerPrefab != null && verifyControllerPrefab(originalControllerPrefab))
				{
					PrintInfoLog("adaptive load controller model " + modelName + " success");
					controllerType = ControllerType.ControllerType_AssetBundles;
					return true;
				}
			}
			else
			{
				PrintWarningLog("Can't find AssetBundleManifest!!");
			}
		}
		else
		{
			PrintWarningLog("Load " + text + " failed");
		}
		PrintInfoLog("adaptive load controller model " + modelName + " from " + renderModelNamePath + " fail!");
		return false;
	}

	private bool verifyControllerPrefab(GameObject go)
	{
		bool result = true;
		if (renderModelName.StartsWith("WVR_CONTROLLER_ASPEN") || renderModelName.StartsWith("WVR_CONTROLLER_FINCH3DOF"))
		{
			result = false;
		}
		return result;
	}

	private int checkAssetBundlesVersion(string version)
	{
		if (version.StartsWith("5.6.3") || version.StartsWith("5.6.4") || version.StartsWith("5.6.5") || version.StartsWith("5.6.6") || version.StartsWith("2017.1") || version.StartsWith("2017.2"))
		{
			return 1;
		}
		if (version.StartsWith("2017.3") || version.StartsWith("2017.4") || version.StartsWith("2018.1"))
		{
			return 2;
		}
		return 0;
	}

	private GameObject loadGenericControllerModelFromPackage(string tmpGeneric)
	{
		tmpGeneric = ((WhichHand != 0) ? (tmpGeneric + "MC_L") : (tmpGeneric + "MC_R"));
		WVR_Log.Log.w(LOG_TAG, "Can't find preferred controller model, load generic controller : " + tmpGeneric);
		if (adaptiveLoading)
		{
			PrintInfoLog("Please update controller models from device service to have better experience!");
		}
		return Resources.Load(controllerModelFoler + tmpGeneric) as GameObject;
	}

	private void SetControllerOptions(GameObject controller_prefab)
	{
		WaveVR_PoseTrackerManager component = controller_prefab.GetComponent<WaveVR_PoseTrackerManager>();
		if (component != null)
		{
			component.TrackPosition = TrackPosition;
			component.SimulationOption = SimulationOption;
			component.FollowHead = FollowHead;
			component.TrackRotation = TrackRotation;
			component.Type = deviceType;
			PrintInfoLog(string.Concat("set ", deviceType, " to WaveVR_PoseTrackerManager"));
		}
	}

	private void OnApplicationPause(bool pauseStatus)
	{
		if (!pauseStatus)
		{
			PrintInfoLog("App resume and forceCheckRenderModelName");
			forceCheckRenderModelName = true;
		}
	}

	private void Update()
	{
		if (Interop.WVR_IsInputFocusCapturedBySystem() && mLoadingState == CLoadingState.LoadingState_NOT_LOADED)
		{
			WVR_DeviceType wVR_DeviceType = WaveVR_Controller.Input(deviceType).DeviceType;
			if (WaveVR_Controller.Input(wVR_DeviceType).connected)
			{
				ptrParameterName = Marshal.StringToHGlobalAnsi(parameterName);
				ptrResult = Marshal.AllocHGlobal(bufferSize);
				for (int i = 0; i < bufferSize; i++)
				{
					Marshal.WriteByte(ptrResult, i, 0);
				}
				uint num = Interop.WVR_GetParameters(wVR_DeviceType, ptrParameterName, ptrResult, resultVertLength);
				string text = Marshal.PtrToStringAnsi(ptrResult);
				Marshal.FreeHGlobal(ptrParameterName);
				Marshal.FreeHGlobal(ptrResult);
				if (num != 0)
				{
					renderModelName = text;
					PrintInfoLog("Load controller in background");
					onLoadController(wVR_DeviceType);
				}
			}
		}
		if (mLoadingState == CLoadingState.LoadingState_LOADED)
		{
			checkConnectionAndModelName();
		}
	}

	private void checkConnectionAndModelName()
	{
		if (controllerPrefab == null)
		{
			return;
		}
		bool flag = WaveVR_Controller.Input(deviceType).connected;
		WVR_DeviceType wVR_DeviceType = WaveVR_Controller.Input(deviceType).DeviceType;
		if (flag == lastFrameConnection && !forceCheckRenderModelName)
		{
			return;
		}
		PrintInfoLog("connection state changed or force check!");
		if (flag)
		{
			PrintInfoLog("Check render model name when controller is connected");
			ptrParameterName = Marshal.StringToHGlobalAnsi(parameterName);
			ptrResult = Marshal.AllocHGlobal(bufferSize);
			for (int i = 0; i < bufferSize; i++)
			{
				Marshal.WriteByte(ptrResult, i, 0);
			}
			uint num = Interop.WVR_GetParameters(wVR_DeviceType, ptrParameterName, ptrResult, resultVertLength);
			string text = Marshal.PtrToStringAnsi(ptrResult);
			PrintInfoLog("previous render model name:" + renderModelName);
			PrintInfoLog("render model name from runtime:" + text);
			Marshal.FreeHGlobal(ptrParameterName);
			Marshal.FreeHGlobal(ptrResult);
			if (num != 0 && !text.Equals(renderModelName))
			{
				renderModelName = text;
				PrintDebugLog(string.Concat("Render model change device: ", wVR_DeviceType, ", new render model name: ", renderModelName));
				PrintInfoLog(string.Concat("Destroy controller prefeb because render model is changed, broadcast ", deviceType, " CONTROLLER_MODEL_UNLOADED"));
				removeControllerFromMgr("DeleteControllerWhenDisconnect()");
				UnityEngine.Object.Destroy(controllerPrefab);
				resetControllerState();
				WaveVR_Utils.Event.Send(WaveVR_Utils.Event.CONTROLLER_MODEL_UNLOADED, deviceType);
				Resources.UnloadUnusedAssets();
				GC.Collect();
				if (flag)
				{
					connected = flag;
					onLoadController(wVR_DeviceType);
				}
			}
			forceCheckRenderModelName = false;
		}
		else
		{
			PrintInfoLog(string.Concat("Destroy controller prefeb because it is disconnect, broadcast ", deviceType, " CONTROLLER_MODEL_UNLOADED"));
			removeControllerFromMgr("DeleteControllerWhenDisconnect()");
			UnityEngine.Object.Destroy(controllerPrefab);
			resetControllerState();
			controllerPrefab = null;
			WaveVR_Utils.Event.Send(WaveVR_Utils.Event.CONTROLLER_MODEL_UNLOADED, deviceType);
			Resources.UnloadUnusedAssets();
			GC.Collect();
		}
		lastFrameConnection = flag;
	}

	private bool checkConnection()
	{
		if (!WaveVR.Instance.Initialized)
		{
			return false;
		}
		return WaveVR.Instance.getDeviceByType(deviceType).connected;
	}

	private void SetControllerBeamParameters(GameObject ctrlr)
	{
		if (ctrlr == null)
		{
			return;
		}
		WaveVR_Beam componentInChildren = ctrlr.GetComponentInChildren<WaveVR_Beam>();
		if (componentInChildren != null)
		{
			componentInChildren.ShowBeam = enableEmitter && ShowBeam;
			if (useBeamSystemConfig)
			{
				ReadJsonValues_Beam();
			}
			componentInChildren.ListenToDevice = true;
			componentInChildren.device = deviceType;
			componentInChildren.updateEveryFrame = updateEveryFrame;
			componentInChildren.StartWidth = StartWidth;
			componentInChildren.EndWidth = EndWidth;
			componentInChildren.StartOffset = StartOffset;
			componentInChildren.EndOffset = EndOffset;
			componentInChildren.StartColor = StartColor;
			componentInChildren.EndColor = EndColor;
			componentInChildren.useDefaultMaterial = useDefaultMaterial;
			componentInChildren.customMat = customMat;
			PrintDebugLog(string.Concat("SetControllerBeamParameters() Beam ->show: ", componentInChildren.ShowBeam.ToString(), ", ListenToDevice: ", componentInChildren.ListenToDevice.ToString(), ", device: ", componentInChildren.device, ", use system config: ", useBeamSystemConfig.ToString(), ", updateEveryFrame: ", componentInChildren.updateEveryFrame.ToString(), ", StartWidth: ", componentInChildren.StartWidth, ", EndWidth: ", componentInChildren.EndWidth, ", StartOffset: ", componentInChildren.StartOffset, ", EndOffset: ", componentInChildren.EndOffset, ", StartColor: ", componentInChildren.StartColor, ", EndColor: ", componentInChildren.EndColor, ", useDefaultMaterial: ", componentInChildren.useDefaultMaterial.ToString(), ", customMat: ", componentInChildren.customMat));
		}
	}

	private void SetControllerPointerParameters(GameObject ctrlr)
	{
		if (ctrlr == null)
		{
			return;
		}
		WaveVR_ControllerPointer componentInChildren = ctrlr.GetComponentInChildren<WaveVR_ControllerPointer>();
		if (componentInChildren != null)
		{
			componentInChildren.ShowPointer = enableEmitter && showPointer;
			if (usePointerSystemConfig)
			{
				ReadJsonValues_Pointer();
			}
			componentInChildren.device = deviceType;
			componentInChildren.Blink = Blink;
			componentInChildren.useTexture = useTexture;
			componentInChildren.PointerOuterDiameterMin = PointerOuterDiameterMin;
			componentInChildren.PointerDistanceInMeters = PointerDistanceInMeters;
			componentInChildren.UseDefaultTexture = UseDefaultTexture;
			componentInChildren.CustomTexture = customTexture;
			componentInChildren.TextureName = TextureName;
			componentInChildren.PointerColor = PointerColor;
			componentInChildren.borderColor = borderColor;
			componentInChildren.focusColor = focusColor;
			componentInChildren.focusBorderColor = focusBorderColor;
			PrintDebugLog(string.Concat("Pointer -> show: ", componentInChildren.ShowPointer.ToString(), ", device: ", componentInChildren.device, ", useSystemConfig: ", usePointerSystemConfig.ToString(), ", Blink: ", componentInChildren.Blink.ToString(), ", useTexture: ", componentInChildren.useTexture.ToString(), ", PointerOuterDiameterMin: ", componentInChildren.PointerOuterDiameterMin, ", UseDefaultTexture: ", componentInChildren.UseDefaultTexture.ToString(), ", customTexture: ", componentInChildren.CustomTexture));
		}
	}

	private void UpdateStartColor(string color_string)
	{
		byte[] bytes = BitConverter.GetBytes(Convert.ToInt32(color_string.Substring(1, 2), 16));
		byte[] bytes2 = BitConverter.GetBytes(Convert.ToInt32(color_string.Substring(3, 2), 16));
		byte[] bytes3 = BitConverter.GetBytes(Convert.ToInt32(color_string.Substring(5, 2), 16));
		byte[] bytes4 = BitConverter.GetBytes(Convert.ToInt32(color_string.Substring(7, 2), 16));
		StartColor.r = bytes[0];
		StartColor.g = bytes2[0];
		StartColor.b = bytes3[0];
		StartColor.a = bytes4[0];
	}

	private void UpdateEndColor(string color_string)
	{
		byte[] bytes = BitConverter.GetBytes(Convert.ToInt32(color_string.Substring(1, 2), 16));
		byte[] bytes2 = BitConverter.GetBytes(Convert.ToInt32(color_string.Substring(3, 2), 16));
		byte[] bytes3 = BitConverter.GetBytes(Convert.ToInt32(color_string.Substring(5, 2), 16));
		byte[] bytes4 = BitConverter.GetBytes(Convert.ToInt32(color_string.Substring(7, 2), 16));
		EndColor.r = bytes[0];
		EndColor.g = bytes2[0];
		EndColor.b = bytes3[0];
		EndColor.a = bytes4[0];
	}

	private void ReadJsonValues_Beam()
	{
		string controllerConfig = WaveVR_Utils.OEMConfig.getControllerConfig();
		if (!controllerConfig.Equals(""))
		{
			JSONNode jSONNode = JSONNode.Parse(controllerConfig);
			string text = "";
			text = jSONNode["beam"]["start_width"].Value;
			if (!text.Equals(""))
			{
				StartWidth = float.Parse(text);
			}
			text = jSONNode["beam"]["end_width"].Value;
			if (!text.Equals(""))
			{
				EndWidth = float.Parse(text);
			}
			text = jSONNode["beam"]["start_offset"].Value;
			if (!text.Equals(""))
			{
				StartOffset = float.Parse(text);
			}
			text = jSONNode["beam"]["length"].Value;
			if (!text.Equals(""))
			{
				EndOffset = float.Parse(text);
			}
			text = jSONNode["beam"]["start_color"].Value;
			if (!text.Equals(""))
			{
				UpdateStartColor(text);
			}
			text = jSONNode["beam"]["end_color"].Value;
			if (!text.Equals(""))
			{
				UpdateEndColor(text);
			}
		}
	}

	private void ReadJsonValues_Pointer()
	{
		string controllerConfig = WaveVR_Utils.OEMConfig.getControllerConfig();
		if (controllerConfig.Equals(""))
		{
			return;
		}
		try
		{
			JSONNode jSONNode = JSONNode.Parse(controllerConfig);
			string text = "";
			text = jSONNode["pointer"]["diameter"].Value;
			if (!text.Equals("") && IsFloat(text))
			{
				PointerOuterDiameterMin = float.Parse(text);
			}
			text = jSONNode["pointer"]["use_texture"].Value;
			if (!text.Equals("") && IsBoolean(text))
			{
				useTexture = bool.Parse(text);
			}
			text = jSONNode["pointer"]["color"].Value;
			if (!text.Equals(""))
			{
				PointerColor = StringToColor32(text, 0);
			}
			text = jSONNode["pointer"]["border_color"].Value;
			if (!text.Equals(""))
			{
				borderColor = StringToColor32(text, 1);
			}
			text = jSONNode["pointer"]["focus_color"].Value;
			if (!text.Equals(""))
			{
				focusColor = StringToColor32(text, 2);
			}
			text = jSONNode["pointer"]["focus_border_color"].Value;
			if (!text.Equals(""))
			{
				focusBorderColor = StringToColor32(text, 3);
			}
			text = jSONNode["pointer"]["pointer_texture_name"].Value;
			if (!text.Equals(""))
			{
				TextureName = text;
			}
			text = jSONNode["pointer"]["Blink"].Value;
			if (!text.Equals("") && IsBoolean(text))
			{
				Blink = bool.Parse(text);
			}
			PrintDebugLog(string.Concat("ReadJsonValues() diameter: ", PointerOuterDiameterMin, ", distance: ", PointerDistanceInMeters, ", use_texture: ", useTexture.ToString(), ", color: ", PointerColor, ", pointer_texture_name: ", TextureName, ", Blink: ", Blink.ToString()));
		}
		catch (Exception ex)
		{
			WVR_Log.Log.e(LOG_TAG, ex.ToString());
		}
	}

	private static bool IsFloat(string value)
	{
		try
		{
			float num = Convert.ToSingle(value);
			WVR_Log.Log.d(LOG_TAG, value + " Convert to float success: " + num);
			return true;
		}
		catch (Exception ex)
		{
			WVR_Log.Log.e(LOG_TAG, value + " Convert to float failed: " + ex.ToString());
			return false;
		}
	}

	private static bool IsBoolean(string value)
	{
		try
		{
			bool flag = Convert.ToBoolean(value);
			WVR_Log.Log.d(LOG_TAG, value + " Convert to bool success: " + flag);
			return true;
		}
		catch (Exception ex)
		{
			WVR_Log.Log.e(LOG_TAG, value + " Convert to bool failed: " + ex.ToString());
			return false;
		}
	}

	private Color32 StringToColor32(string color_string, int value)
	{
		try
		{
			byte[] bytes = BitConverter.GetBytes(Convert.ToInt32(color_string.Substring(1, 2), 16));
			byte[] bytes2 = BitConverter.GetBytes(Convert.ToInt32(color_string.Substring(3, 2), 16));
			byte[] bytes3 = BitConverter.GetBytes(Convert.ToInt32(color_string.Substring(5, 2), 16));
			return new Color32(a: BitConverter.GetBytes(Convert.ToInt32(color_string.Substring(7, 2), 16))[0], r: bytes[0], g: bytes2[0], b: bytes3[0]);
		}
		catch (Exception ex)
		{
			WVR_Log.Log.e(LOG_TAG, "StringToColor32: " + ex.ToString());
			return value switch
			{
				1 => new Color(119f, 119f, 119f, 255f), 
				2 => new Color(255f, 255f, 255f, 255f), 
				3 => new Color(119f, 119f, 119f, 255f), 
				_ => Color.white, 
			};
		}
	}

	private void PresetAdaptiveControllerParameters(GameObject ctrPrefab)
	{
		WaveVR_ControllerRootToEmitter component = ctrPrefab.GetComponent<WaveVR_ControllerRootToEmitter>();
		if (component != null)
		{
			PrintInfoLog("set WaveVR_ControllerRootToEmitter deviceType to " + deviceType);
			component.deviceType = deviceType;
		}
		else
		{
			PrintInfoLog("No WaveVR_ControllerRootToEmitter!");
		}
		int childCount = ctrPrefab.transform.childCount;
		for (int i = 0; i < childCount; i++)
		{
			PrintInfoLog(ctrPrefab.transform.GetChild(i).gameObject.name);
			if (!(ctrPrefab.transform.GetChild(i).gameObject.name == "Model"))
			{
				continue;
			}
			GameObject obj = ctrPrefab.transform.GetChild(i).gameObject;
			WaveVR_RenderModel component2 = obj.GetComponent<WaveVR_RenderModel>();
			if (component2 != null)
			{
				component2.WhichHand = (WaveVR_RenderModel.ControllerHand)WhichHand;
				component2.updateDynamically = false;
				component2.mergeToOneBone = true;
				PrintDebugLog("Model -> WhichHand: " + component2.WhichHand);
			}
			WaveVR_AdaptiveControllerActions component3 = obj.GetComponent<WaveVR_AdaptiveControllerActions>();
			if (!(component3 != null))
			{
				continue;
			}
			component3.enableButtonEffect = enableButtonEffect;
			if (component3.enableButtonEffect)
			{
				PrintInfoLog("AdaptiveController button effect is active");
				component3.device = deviceType;
				component3.useSystemConfig = useEffectSystemConfig;
				if (!useEffectSystemConfig)
				{
					component3.buttonEffectColor = buttonEffectColor;
				}
				PrintDebugLog(string.Concat("Effect -> device: ", component3.device, ", useSystemConfig: ", component3.useSystemConfig.ToString(), "buttonEffectColor", component3.buttonEffectColor));
			}
			component3.collectInStart = false;
		}
	}

	private void setEventSystemParameter()
	{
		if (EventSystem.current == null)
		{
			EventSystem eventSystem = UnityEngine.Object.FindObjectOfType<EventSystem>();
			if (eventSystem != null)
			{
				this.eventSystem = eventSystem.gameObject;
			}
		}
		else
		{
			this.eventSystem = EventSystem.current.gameObject;
		}
		if (!(this.eventSystem != null))
		{
			return;
		}
		WaveVR_ControllerInputModule component = this.eventSystem.GetComponent<WaveVR_ControllerInputModule>();
		if (component != null)
		{
			switch (deviceType)
			{
			case WaveVR_Controller.EDeviceType.Dominant:
				component.DomintEventEnabled = enableEmitter && sendEvent;
				PrintInfoLog("Forced set RightEventEnabled to " + component.DomintEventEnabled);
				break;
			case WaveVR_Controller.EDeviceType.NonDominant:
				component.NoDomtEventEnabled = enableEmitter && sendEvent;
				PrintInfoLog("Forced set LeftEventEnabled to " + component.NoDomtEventEnabled);
				break;
			}
		}
	}

	private void ApplyIndicatorParameters()
	{
		if (!overwriteIndicatorSettings)
		{
			return;
		}
		WaveVR_ShowIndicator waveVR_ShowIndicator = null;
		int childCount = controllerPrefab.transform.childCount;
		bool flag = false;
		for (int i = 0; i < childCount; i++)
		{
			PrintInfoLog(controllerPrefab.transform.GetChild(i).gameObject.name);
			waveVR_ShowIndicator = controllerPrefab.transform.GetChild(i).gameObject.GetComponentInChildren<WaveVR_ShowIndicator>();
			if (waveVR_ShowIndicator != null)
			{
				flag = true;
				break;
			}
		}
		if (flag)
		{
			PrintInfoLog("WaveVR_ControllerLoader forced update WaveVR_ShowIndicator parameter!");
			waveVR_ShowIndicator.showIndicator = showIndicator;
			if (!showIndicator)
			{
				PrintInfoLog("WaveVR_ControllerLoader forced don't show WaveVR_ShowIndicator!");
				return;
			}
			waveVR_ShowIndicator.showIndicator = showIndicator;
			waveVR_ShowIndicator.showIndicatorAngle = showIndicatorAngle;
			waveVR_ShowIndicator.hideIndicatorByRoll = hideIndicatorByRoll;
			waveVR_ShowIndicator.basedOnEmitter = basedOnEmitter;
			waveVR_ShowIndicator.lineColor = lineColor;
			waveVR_ShowIndicator.lineEndWidth = lineEndWidth;
			waveVR_ShowIndicator.lineStartWidth = lineStartWidth;
			waveVR_ShowIndicator.lineLength = lineLength;
			waveVR_ShowIndicator.textCharacterSize = textCharacterSize;
			waveVR_ShowIndicator.zhCharactarSize = zhCharactarSize;
			waveVR_ShowIndicator.textColor = textColor;
			waveVR_ShowIndicator.textFontSize = textFontSize;
			waveVR_ShowIndicator.buttonIndicationList.Clear();
			if (useIndicatorSystemConfig)
			{
				PrintInfoLog("WaveVR_ControllerLoader uses system default button indication!");
				addbuttonIndicationList();
			}
			else
			{
				PrintInfoLog("WaveVR_ControllerLoader uses customized button indication!");
				if (buttonIndicationList.Count == 0)
				{
					PrintInfoLog("WaveVR_ControllerLoader doesn't have button indication!");
					return;
				}
			}
			foreach (ButtonIndication buttonIndication in buttonIndicationList)
			{
				PrintInfoLog("use multilanguage: " + buttonIndication.useMultiLanguage);
				PrintInfoLog("indication: " + buttonIndication.indicationText);
				PrintInfoLog("alignment: " + buttonIndication.alignment);
				PrintInfoLog("offset: " + buttonIndication.indicationOffset);
				PrintInfoLog("keyType: " + buttonIndication.keyType);
				PrintInfoLog("followRotation: " + buttonIndication.followButtonRotation);
				waveVR_ShowIndicator.buttonIndicationList.Add(buttonIndication);
			}
			waveVR_ShowIndicator.createIndicator();
		}
		else
		{
			PrintInfoLog("Controller model doesn't support button indication feature!");
		}
	}

	private void addbuttonIndicationList()
	{
		buttonIndicationList.Clear();
		ButtonIndication buttonIndication = new ButtonIndication();
		buttonIndication.keyType = ButtonIndication.KeyIndicator.Home;
		buttonIndication.alignment = ButtonIndication.Alignment.RIGHT;
		buttonIndication.indicationOffset = new Vector3(0f, 0f, 0f);
		buttonIndication.useMultiLanguage = true;
		buttonIndication.indicationText = "system";
		buttonIndication.followButtonRotation = true;
		buttonIndicationList.Add(buttonIndication);
		ButtonIndication buttonIndication2 = new ButtonIndication();
		buttonIndication2.keyType = ButtonIndication.KeyIndicator.App;
		buttonIndication2.alignment = ButtonIndication.Alignment.LEFT;
		buttonIndication2.indicationOffset = new Vector3(0f, 0.0004f, 0f);
		buttonIndication2.useMultiLanguage = true;
		buttonIndication2.indicationText = "system";
		buttonIndication2.followButtonRotation = true;
		buttonIndicationList.Add(buttonIndication2);
		ButtonIndication buttonIndication3 = new ButtonIndication();
		buttonIndication3.keyType = ButtonIndication.KeyIndicator.Grip;
		buttonIndication3.alignment = ButtonIndication.Alignment.RIGHT;
		buttonIndication3.indicationOffset = new Vector3(0f, 0f, 0.01f);
		buttonIndication3.useMultiLanguage = true;
		buttonIndication3.indicationText = "system";
		buttonIndication3.followButtonRotation = true;
		buttonIndicationList.Add(buttonIndication3);
		ButtonIndication buttonIndication4 = new ButtonIndication();
		buttonIndication4.keyType = ButtonIndication.KeyIndicator.Trigger;
		buttonIndication4.alignment = ButtonIndication.Alignment.RIGHT;
		buttonIndication4.indicationOffset = new Vector3(0f, 0f, 0f);
		buttonIndication4.useMultiLanguage = true;
		buttonIndication4.indicationText = "system";
		buttonIndication4.followButtonRotation = true;
		buttonIndicationList.Add(buttonIndication4);
		ButtonIndication buttonIndication5 = new ButtonIndication();
		buttonIndication5.keyType = ButtonIndication.KeyIndicator.DigitalTrigger;
		buttonIndication5.alignment = ButtonIndication.Alignment.RIGHT;
		buttonIndication5.indicationOffset = new Vector3(0f, 0f, 0f);
		buttonIndication5.useMultiLanguage = true;
		buttonIndication5.indicationText = "system";
		buttonIndication5.followButtonRotation = true;
		buttonIndicationList.Add(buttonIndication5);
		ButtonIndication buttonIndication6 = new ButtonIndication();
		buttonIndication6.keyType = ButtonIndication.KeyIndicator.TouchPad;
		buttonIndication6.alignment = ButtonIndication.Alignment.LEFT;
		buttonIndication6.indicationOffset = new Vector3(0f, 0f, 0f);
		buttonIndication6.useMultiLanguage = true;
		buttonIndication6.indicationText = "system";
		buttonIndication6.followButtonRotation = true;
		buttonIndicationList.Add(buttonIndication6);
		ButtonIndication buttonIndication7 = new ButtonIndication();
		buttonIndication7.keyType = ButtonIndication.KeyIndicator.Volume;
		buttonIndication7.alignment = ButtonIndication.Alignment.RIGHT;
		buttonIndication7.indicationOffset = new Vector3(0f, 0f, 0f);
		buttonIndication7.useMultiLanguage = true;
		buttonIndication7.indicationText = "system";
		buttonIndication7.followButtonRotation = true;
		buttonIndicationList.Add(buttonIndication7);
	}
}
public class WaveVR_ControllerManager : MonoBehaviour
{
	public enum CIndex
	{
		invalid = -1,
		Dominant,
		NonDominant
	}

	private static string LOG_TAG = "WaveVR_ControllerManager";

	public GameObject Dominant;

	public GameObject NonDominant;

	private GameObject[] ControllerObjects;

	private bool[] ControllerConnected = new bool[2];

	private void PrintDebugLog(string msg)
	{
		WVR_Log.Log.d(LOG_TAG, msg);
	}

	private void Awake()
	{
		ControllerObjects = new GameObject[2] { Dominant, NonDominant };
	}

	private void OnEnable()
	{
		for (int i = 0; i < ControllerObjects.Length; i++)
		{
			GameObject gameObject = ControllerObjects[i];
			if (gameObject != null)
			{
				PrintDebugLog("OnEnable() disable controller " + i);
				gameObject.SetActive(value: false);
			}
		}
		checkConnection();
		WaveVR_Utils.Event.Listen(WaveVR_Utils.Event.DEVICE_CONNECTED, onDeviceConnected);
	}

	private void OnDisable()
	{
		WaveVR_Utils.Event.Remove(WaveVR_Utils.Event.DEVICE_CONNECTED, onDeviceConnected);
	}

	private void BroadcastToObjects(CIndex index)
	{
		GameObject gameObject = ControllerObjects[(int)index];
		if (gameObject != null)
		{
			if (!ControllerConnected[(int)index])
			{
				PrintDebugLog("BroadcastToObjects() disable controller " + index);
				gameObject.SetActive(value: false);
				return;
			}
			PrintDebugLog("BroadcastToObjects() enable controller " + index);
			gameObject.SetActive(value: true);
			WaveVR_Controller.EDeviceType eDeviceType = ((index == CIndex.Dominant) ? WaveVR_Controller.EDeviceType.Dominant : WaveVR_Controller.EDeviceType.NonDominant);
			gameObject.BroadcastMessage("SetDeviceIndex", eDeviceType, SendMessageOptions.DontRequireReceiver);
		}
	}

	private void checkConnection()
	{
		bool flag = false;
		bool flag2 = false;
		WaveVR.Device deviceByType = WaveVR.Instance.getDeviceByType(WaveVR_Controller.EDeviceType.Dominant);
		if (deviceByType != null)
		{
			flag = deviceByType.connected;
		}
		WaveVR.Device deviceByType2 = WaveVR.Instance.getDeviceByType(WaveVR_Controller.EDeviceType.NonDominant);
		if (deviceByType2 != null)
		{
			flag2 = deviceByType2.connected;
		}
		if (ControllerConnected[0] != flag)
		{
			PrintDebugLog("checkConnection() dominant device  is " + (flag ? "connected" : "disconnected") + ", left-handed? " + WaveVR_Controller.IsLeftHanded);
			ControllerConnected[0] = flag;
			BroadcastToObjects(CIndex.Dominant);
		}
		if (ControllerConnected[1] != flag2)
		{
			PrintDebugLog("checkConnection() non-dominant device  is " + (flag2 ? "connected" : "disconnected") + ", left-handed? " + WaveVR_Controller.IsLeftHanded);
			ControllerConnected[1] = flag2;
			BroadcastToObjects(CIndex.NonDominant);
		}
	}

	private void onDeviceConnected(params object[] args)
	{
		WVR_DeviceType wVR_DeviceType = (WVR_DeviceType)args[0];
		bool flag = (bool)args[1];
		PrintDebugLog(string.Concat("onDeviceConnected() device ", wVR_DeviceType, " is ", flag ? "connected." : "disconnected."));
		checkConnection();
	}
}
[RequireComponent(typeof(Camera))]
public class WaveVR_Distortion : MonoBehaviour
{
}
[RequireComponent(typeof(Text))]
public class WaveVR_FPS : MonoBehaviour
{
	private Text textField;

	private float fps = 75f;

	private float targetfps = 75f;

	private float accTime;

	private void Awake()
	{
		textField = GetComponent<Text>();
		accTime = 0f;
	}

	private void LateUpdate()
	{
		float unscaledDeltaTime = Time.unscaledDeltaTime;
		accTime += unscaledDeltaTime;
		if (unscaledDeltaTime == 0f)
		{
			textField.text = "0fps";
			return;
		}
		string text = "";
		float t = unscaledDeltaTime / (0.5f + unscaledDeltaTime);
		float b = 1f / unscaledDeltaTime;
		fps = Mathf.Lerp(fps, b, t);
		float f = ((fps > targetfps) ? targetfps : fps);
		if (!(accTime < 0.2f))
		{
			accTime = 0f;
			text = text + Mathf.RoundToInt(f) + "fps";
			textField.text = text;
		}
	}

	private void Start()
	{
		int targetFrameRate = UnityEngine.Application.targetFrameRate;
		if (targetFrameRate > 0)
		{
			targetfps = targetFrameRate;
		}
	}
}
public class WaveVR_IMEManager
{
	public class InputResult
	{
		private int mId;

		private string mContent;

		private int mErrorCode;

		public string InputContent => mContent;

		public int ErrorCode => mErrorCode;

		public int Id => mId;

		public InputResult(int id, string content, int errorCode)
		{
			mId = id;
			mContent = content;
			mErrorCode = errorCode;
		}
	}

	public class IMEParameter
	{
		public int id;

		public int type;

		public int mode;

		public string exist;

		public int cursor;

		public int selectStart;

		public int selectEnd;

		public double[] pos;

		public double[] rot;

		public int width;

		public int height;

		public int shadow;

		public string locale;

		public string title;

		public int buttonId;

		public int extraInt;

		public string extraString;

		public IMEParameter(int id, int type, int mode, string exist, int cursor, int selectStart, int selectEnd, double[] pos, double[] rot, int width, int height, int shadow, string locale, string title, int extraInt, string extraString, int buttonId)
		{
			this.id = id;
			this.type = type;
			this.mode = mode;
			this.exist = exist;
			this.cursor = cursor;
			this.selectStart = selectStart;
			this.selectEnd = selectEnd;
			this.pos = pos;
			this.rot = rot;
			this.width = width;
			this.height = height;
			this.shadow = shadow;
			this.locale = locale;
			this.title = title;
			this.buttonId = buttonId;
			this.extraInt = extraInt;
			this.extraString = extraString;
		}

		public IMEParameter(int id, int type, int mode, string exist, int cursor, int selectStart, int selectEnd, double[] pos, double[] rot, int width, int height, int shadow, string locale, string title, int buttonId)
		{
			this.id = id;
			this.type = type;
			this.mode = mode;
			this.exist = exist;
			this.cursor = cursor;
			this.selectStart = selectStart;
			this.selectEnd = selectEnd;
			this.pos = pos;
			this.rot = rot;
			this.width = width;
			this.height = height;
			this.shadow = shadow;
			this.locale = locale;
			this.title = title;
			this.buttonId = buttonId;
			extraInt = 0;
			extraString = null;
		}

		public IMEParameter(int id, int type, int mode, string exist, int cursor, double[] pos, double[] rot, int width, int height, int shadow, string locale, string title, int buttonId)
		{
			this.id = id;
			this.type = type;
			this.mode = mode;
			this.exist = exist;
			this.cursor = cursor;
			selectStart = 0;
			selectEnd = 0;
			this.pos = pos;
			this.rot = rot;
			this.width = width;
			this.height = height;
			this.shadow = shadow;
			this.locale = locale;
			this.title = title;
			this.buttonId = buttonId;
			extraInt = 0;
			extraString = null;
		}

		public IMEParameter(int id, int type, int mode, double[] pos, double[] rot, int width, int height, int shadow, string locale, string title, int buttonId)
		{
			this.id = id;
			this.type = type;
			this.mode = mode;
			exist = null;
			cursor = 0;
			selectStart = 0;
			selectEnd = 0;
			this.pos = pos;
			this.rot = rot;
			this.width = width;
			this.height = height;
			this.shadow = shadow;
			this.locale = locale;
			this.title = title;
			this.buttonId = buttonId;
			extraInt = 0;
			extraString = null;
		}

		public IMEParameter(int id, int type, int mode, double[] pos, double[] rot, int width, int height, int shadow, int buttonId)
		{
			this.id = id;
			this.type = type;
			this.mode = mode;
			exist = null;
			cursor = 0;
			selectStart = 0;
			selectEnd = 0;
			this.pos = pos;
			this.rot = rot;
			this.width = width;
			this.height = height;
			this.shadow = shadow;
			locale = null;
			title = null;
			this.buttonId = buttonId;
			extraInt = 0;
			extraString = null;
		}
	}

	public delegate void inputCompleteCallback(InputResult results);

	private class RequestCompleteHandler : AndroidJavaProxy
	{
		internal RequestCompleteHandler()
			: base(new AndroidJavaClass("com.htc.vr.ime.client.IMECallback"))
		{
		}

		public void onInputCompletedwithObject(AndroidJavaObject resultObject)
		{
			WVR_Log.Log.i(LOG_TAG, "unity callback with result object");
			if (mCallback == null)
			{
				WVR_Log.Log.w(LOG_TAG, "unity callback but user callback is null ");
			}
			int id = resultObject.Get<int>("id");
			int errorCode = resultObject.Get<int>("errorCode");
			string content = resultObject.Get<string>("inputContent");
			InputResult results = new InputResult(id, content, errorCode);
			mCallback(results);
		}
	}

	private static string LOG_TAG = "WVR_IMEManager";

	private const string IME_MANAGER_CLASSNAME = "com.htc.vr.ime.client.IMEManager";

	private AndroidJavaObject imeManager;

	private static WaveVR_IMEManager mInstance = null;

	private bool inited;

	private static inputCompleteCallback mCallback = null;

	public static WaveVR_IMEManager instance
	{
		get
		{
			if (mInstance == null)
			{
				mInstance = new WaveVR_IMEManager();
			}
			return mInstance;
		}
	}

	private AndroidJavaObject javaArrayFromCS(string[] values)
	{
		AndroidJavaClass androidJavaClass = new AndroidJavaClass("java.lang.reflect.Array");
		AndroidJavaObject androidJavaObject = androidJavaClass.CallStatic<AndroidJavaObject>("newInstance", new object[2]
		{
			new AndroidJavaClass("java.lang.String"),
			values.Length
		});
		for (int i = 0; i < values.Length; i++)
		{
			androidJavaClass.CallStatic("set", androidJavaObject, i, new AndroidJavaObject("java.lang.String", values[i]));
		}
		return androidJavaObject;
	}

	private AndroidJavaObject javaIMEParameterFromCS(IMEParameter parameter)
	{
		return new AndroidJavaObject("com.htc.vr.ime.server.IMEParameter", parameter.id, parameter.type, parameter.mode, parameter.exist, parameter.cursor, parameter.selectStart, parameter.selectEnd, parameter.pos, parameter.rot, parameter.width, parameter.height, parameter.shadow, parameter.locale, parameter.title, parameter.extraInt, parameter.extraString, parameter.buttonId);
	}

	private void initializeJavaObject()
	{
		WVR_Log.Log.d(LOG_TAG, "initializeJavaObject");
		AndroidJavaClass androidJavaClass = new AndroidJavaClass("com.htc.vr.ime.client.IMEManager");
		if (androidJavaClass == null)
		{
			WVR_Log.Log.e(LOG_TAG, "AndroidJavaClass is null");
			return;
		}
		imeManager = androidJavaClass.CallStatic<AndroidJavaObject>("getInstance", Array.Empty<object>());
		if (imeManager != null)
		{
			WVR_Log.Log.d(LOG_TAG, "imeManager get object success");
		}
		else
		{
			WVR_Log.Log.e(LOG_TAG, "imeManager get object failed");
		}
	}

	public bool isInitialized()
	{
		if (imeManager == null)
		{
			initializeJavaObject();
		}
		if (imeManager == null)
		{
			WVR_Log.Log.e(LOG_TAG, "isInitialized failed because fail to get imeManager object");
			return false;
		}
		inited = imeManager.Call<bool>("isInitialized", Array.Empty<object>());
		return inited;
	}

	public void showKeyboard(IMEParameter parameter, inputCompleteCallback cb)
	{
		WVR_Log.Log.d(LOG_TAG, "showKeyboard");
		if (imeManager == null)
		{
			initializeJavaObject();
		}
		if (imeManager == null)
		{
			WVR_Log.Log.e(LOG_TAG, "isInitialized failed because fail to get imeManager object");
			return;
		}
		mCallback = cb;
		imeManager.Call("showKeyboard", javaIMEParameterFromCS(parameter), new RequestCompleteHandler());
	}

	public void hideKeyboard()
	{
		WVR_Log.Log.d(LOG_TAG, "hideKeyboard");
		if (imeManager == null)
		{
			WVR_Log.Log.e(LOG_TAG, "hideKeyboard() failed because fail to get imeManager object");
		}
		else
		{
			imeManager.Call("hideKeyboard");
		}
	}

	public int getKeyboardState()
	{
		if (imeManager == null)
		{
			initializeJavaObject();
		}
		if (imeManager == null)
		{
			WVR_Log.Log.e(LOG_TAG, "isInitialized failed because fail to get imeManager object");
			return -1;
		}
		return imeManager.Call<int>("getKeyboardState", Array.Empty<object>());
	}
}
public class WaveVR_IMEManagerWrapper
{
	public enum Locale
	{
		en_US,
		zh_CN
	}

	public enum Action
	{
		Done,
		Enter,
		Search,
		Go,
		Send,
		Next,
		Submit
	}

	public delegate void InputDoneCallback(InputResult results);

	public class InputResult
	{
		private string mContent;

		public InputResult(string content)
		{
			mContent = content;
		}

		public string GetContent()
		{
			return mContent;
		}
	}

	private static string LOG_TAG = "IMEManagerWrapper";

	private static int VERSION_ID = 3;

	private static WaveVR_IMEManager mIMEManager = null;

	private static WaveVR_IMEManagerWrapper mInstance = null;

	private WaveVR_IMEManager.IMEParameter mParameter;

	private static InputDoneCallback mCallback = null;

	private static int CONTROLLER_BUTTON_DEFAULT = 240;

	private WaveVR_IMEManagerWrapper()
	{
		InitParameter();
	}

	public static WaveVR_IMEManagerWrapper GetInstance()
	{
		if (mInstance == null || mIMEManager == null)
		{
			mInstance = new WaveVR_IMEManagerWrapper();
			mIMEManager = WaveVR_IMEManager.instance;
			mIMEManager.isInitialized();
		}
		WVR_Log.Log.d(LOG_TAG, "VERSION_ID=" + VERSION_ID);
		return mInstance;
	}

	public void SetText(string text)
	{
		mParameter.exist = text;
	}

	public void SetTitle(string title)
	{
		mParameter.title = title;
	}

	public void SetLocale(Locale locale)
	{
		WVR_Log.Log.d(LOG_TAG, "SetLocale, locale = " + locale);
		switch (locale)
		{
		case Locale.en_US:
			mParameter.locale = "en_US";
			break;
		case Locale.zh_CN:
			mParameter.locale = "zh_CN";
			break;
		default:
			mParameter.locale = "";
			break;
		}
	}

	public void SetCallback(InputDoneCallback callback)
	{
		mCallback = callback;
	}

	public void Show()
	{
		mIMEManager.showKeyboard(mParameter, inputDoneCallback);
	}

	public void Hide()
	{
		mIMEManager.hideKeyboard();
	}

	public void SetAction(Action action)
	{
		mParameter.extraString = "action=" + (int)action;
	}

	public void InitParameter()
	{
		int id = 0;
		int type = 2;
		int mode = 2;
		string exist = "";
		int cursor = 0;
		int selectStart = 0;
		int selectEnd = 0;
		double[] pos = new double[3] { 0.0, 0.0, -1.0 };
		double[] rot = new double[4] { 1.0, 0.0, 0.0, 0.0 };
		int width = 800;
		int height = 800;
		int shadow = 100;
		string locale = "";
		string title = "";
		int extraInt = 0;
		string extraString = "";
		int cONTROLLER_BUTTON_DEFAULT = CONTROLLER_BUTTON_DEFAULT;
		mParameter = new WaveVR_IMEManager.IMEParameter(id, type, mode, exist, cursor, selectStart, selectEnd, pos, rot, width, height, shadow, locale, title, extraInt, extraString, cONTROLLER_BUTTON_DEFAULT);
	}

	private void inputDoneCallback(WaveVR_IMEManager.InputResult results)
	{
		if (mCallback != null)
		{
			InputResult results2 = new InputResult(results.InputContent);
			mCallback(results2);
		}
	}
}
public class WaveVR_Init : MonoBehaviour
{
	private const string LOG_TAG = "WaveVR_Init";

	private static WaveVR_Init _instance;

	private bool toCheckStatesWhenNoEvent;

	private WVR_Event_t vrevent;

	public static WaveVR_Init Instance
	{
		get
		{
			if (_instance == null)
			{
				_instance = UnityEngine.Object.FindObjectOfType<WaveVR_Init>();
				if (_instance == null)
				{
					WVR_Log.Log.i("WaveVR_Init", "WaveVR_Init create an instance");
					_instance = new GameObject("[WaveVR]").AddComponent<WaveVR_Init>();
				}
			}
			return _instance;
		}
	}

	private void PrintDebugLog(string msg)
	{
		if (WVR_Log.Log.EnableDebugLog)
		{
			WVR_Log.Log.d("WaveVR_Init", msg, logInEditor: true);
		}
	}

	private void signalSurfaceState(string msg)
	{
		WaveVR_Render.signalSurfaceState(msg);
	}

	private void Start()
	{
		if (WaveVR.Instance.Initialized)
		{
			WVR_Log.Log.i("WaveVR_Init", "Start()", logInEditor: true);
			WaveVR.Instance.onLoadLevel();
			WaveVR.Instance.UpdateAllConnection();
			WaveVR.Instance.SetLeftHandedMode();
		}
	}

	private void Awake()
	{
		if (_instance == null)
		{
			_instance = this;
		}
		if (_instance != this)
		{
			WVR_Log.Log.w("WaveVR_Init", "Has another [WaveVR] object in a scene. Destory this.");
			UnityEngine.Object.Destroy(this);
		}
		else if (WaveVR.Instance.Initialized)
		{
			WVR_Log.Log.i("WaveVR_Init", "Initialized");
		}
	}

	private void CheckStatesWhenNoEvent()
	{
		if (toCheckStatesWhenNoEvent)
		{
			WVR_Log.Log.d("WaveVR_Init", "CheckStatesWhenNoEvent() UpdateAllConnection.");
			WaveVR.Instance.UpdateAllConnection();
			toCheckStatesWhenNoEvent = false;
		}
	}

	private void Update()
	{
		if (Interop.WVR_PollEventQueue(ref vrevent))
		{
			processVREvent(vrevent);
		}
		else
		{
			CheckStatesWhenNoEvent();
		}
	}

	private void OnApplicationPause(bool pauseStatus)
	{
		PrintDebugLog("OnApplicationPause() pauseStatus: " + pauseStatus);
		if (!pauseStatus && WaveVR.Instance.Initialized)
		{
			WaveVR.Instance.UpdateAllConnection();
			if (WaveVR.Instance.SetLeftHandedMode())
			{
				WaveVR_Utils.Event.Send(WaveVR_Utils.Event.DEVICE_ROLE_CHANGED);
				WaveVR.Instance.ResetAllButtonStates();
			}
			else
			{
				WaveVR.Instance.UpdateButtonEvents();
			}
		}
	}

	private void processVREvent(WVR_Event_t vrEvent)
	{
		WVR_DeviceType type = vrEvent.device.type;
		WVR_InputId inputId = vrEvent.input.inputId;
		switch (vrEvent.common.type)
		{
		case WVR_EventType.WVR_EventType_IpdChanged:
			WaveVR_Utils.Event.Send(WaveVR_Utils.Event.IPD_CHANGED);
			if (WaveVR_Render.Instance != null)
			{
				WaveVR_Render.Expand(WaveVR_Render.Instance);
			}
			break;
		case WVR_EventType.WVR_EventType_DeviceStatusUpdate:
			WaveVR_Utils.Event.Send(WaveVR_Utils.Event.DEVICE_STATUS_UPDATE, vrEvent.device.common.type);
			break;
		case WVR_EventType.WVR_EventType_BatteryStatusUpdate:
			WaveVR_Utils.Event.Send(WaveVR_Utils.Event.BATTERY_STATUS_UPDATE);
			break;
		case WVR_EventType.WVR_EventType_LeftToRightSwipe:
		case WVR_EventType.WVR_EventType_RightToLeftSwipe:
		case WVR_EventType.WVR_EventType_DownToUpSwipe:
		case WVR_EventType.WVR_EventType_UpToDownSwipe:
			PrintDebugLog("processVREvent() Swipe event: " + vrEvent.common.type);
			WaveVR_Utils.Event.Send(WaveVR_Utils.Event.SWIPE_EVENT, vrEvent.common.type, type);
			break;
		case WVR_EventType.WVR_EventType_DeviceRoleChanged:
			if (WaveVR.Instance.SetLeftHandedMode())
			{
				PrintDebugLog(string.Concat("processVREvent() WVR_EventType_DeviceRoleChanged: ", type, ", ", inputId, ", Resend connection notification after switching hand."));
				WaveVR_Utils.Event.Send(WaveVR_Utils.Event.DEVICE_ROLE_CHANGED);
				WaveVR.Instance.ResetAllButtonStates();
				WaveVR.Instance.UpdateAllConnection();
			}
			break;
		case WVR_EventType.WVR_EventType_ButtonPressed:
			PrintDebugLog(string.Concat("processVREvent() WVR_EventType_ButtonPressed: ", type, ", ", inputId, ", left-handed? ", WaveVR_Controller.IsLeftHanded.ToString()));
			if (type != 0 && WaveVR.Instance.Initialized)
			{
				type = WaveVR.Instance.getDeviceByType(type).type;
			}
			WaveVR_Controller.Input(type).SetEventState_Press(inputId, down: true);
			break;
		case WVR_EventType.WVR_EventType_ButtonUnpressed:
			PrintDebugLog(string.Concat("processVREvent() WVR_EventType_ButtonUnpressed: ", type, ", ", inputId, ", left-handed? ", WaveVR_Controller.IsLeftHanded.ToString()));
			if (type != 0 && WaveVR.Instance.Initialized)
			{
				type = WaveVR.Instance.getDeviceByType(type).type;
			}
			WaveVR_Controller.Input(type).SetEventState_Press(inputId, down: false);
			break;
		case WVR_EventType.WVR_EventType_TouchTapped:
			PrintDebugLog(string.Concat("processVREvent() WVR_EventType_TouchTapped: ", type, ", ", inputId, ", left-handed? ", WaveVR_Controller.IsLeftHanded.ToString()));
			if (type != 0 && WaveVR.Instance.Initialized)
			{
				type = WaveVR.Instance.getDeviceByType(type).type;
			}
			WaveVR_Controller.Input(type).SetEventState_Touch(inputId, down: true);
			break;
		case WVR_EventType.WVR_EventType_TouchUntapped:
			PrintDebugLog(string.Concat("processVREvent() WVR_EventType_TouchUntapped: ", type, ", ", inputId, ", left-handed? ", WaveVR_Controller.IsLeftHanded.ToString()));
			if (type != 0 && WaveVR.Instance.Initialized)
			{
				type = WaveVR.Instance.getDeviceByType(type).type;
			}
			WaveVR_Controller.Input(type).SetEventState_Touch(inputId, down: false);
			break;
		case WVR_EventType.WVR_EventType_DeviceConnected:
			PrintDebugLog(string.Concat("processVREvent() WVR_EventType_DeviceConnected: ", type, ", left-handed? ", WaveVR_Controller.IsLeftHanded.ToString()));
			toCheckStatesWhenNoEvent = true;
			break;
		case WVR_EventType.WVR_EventType_DeviceDisconnected:
			PrintDebugLog(string.Concat("processVREvent() WVR_EventType_DeviceDisconnected: ", type, ", left-handed? ", WaveVR_Controller.IsLeftHanded.ToString()));
			toCheckStatesWhenNoEvent = true;
			if (type != 0)
			{
				type = WaveVR_Controller.Input(type).DeviceType;
				WaveVR_Controller.Input(type).ResetButtonEvents();
			}
			break;
		}
		WaveVR_Utils.Event.Send(WaveVR_Utils.Event.ALL_VREVENT, vrEvent);
		WaveVR_Utils.Event.Send(vrEvent.common.type.ToString(), vrEvent);
	}

	private void OnDestroy()
	{
		if (_instance == this)
		{
			_instance = null;
		}
	}
}
public class WaveVR_PermissionManager
{
	public class RequestResult
	{
		private string mPermission;

		private bool mGranted;

		public string PermissionName => mPermission;

		public bool Granted => mGranted;

		public RequestResult(string name, bool granted)
		{
			mPermission = name;
			mGranted = granted;
		}
	}

	public delegate void requestCompleteCallback(List<RequestResult> results);

	public delegate void requestUsbCompleteCallback(bool result);

	private static string LOG_TAG = "WaveVR_PermissionManager";

	private static WaveVR_PermissionManager mInstance = null;

	private static requestCompleteCallback mCallback = null;

	private static requestUsbCompleteCallback mUsbCallback = null;

	public static WaveVR_PermissionManager instance
	{
		get
		{
			if (mInstance == null)
			{
				mInstance = new WaveVR_PermissionManager();
			}
			return mInstance;
		}
	}

	public static void requestDoneCallback(List<WVR_RequestResult> results)
	{
		WVR_Log.Log.d(LOG_TAG, "requestDoneCallback, result count = " + results.Count);
		List<RequestResult> list = new List<RequestResult>();
		for (int i = 0; i < results.Count; i++)
		{
			list.Add(new RequestResult(results[i].mPermission, results[i].mGranted));
		}
		mCallback(list);
	}

	public static void requestUsbDoneCallback(bool result)
	{
		WVR_Log.Log.d(LOG_TAG, "requestUsbDoneCallback, result=" + result);
		mUsbCallback(result);
	}

	public bool isInitialized()
	{
		bool result = Interop.WVR_IsPermissionInitialed();
		WVR_Log.Log.d(LOG_TAG, "isInitialized: " + result);
		return result;
	}

	public void requestPermissions(string[] permissions, requestCompleteCallback cb)
	{
		WVR_Log.Log.d(LOG_TAG, "requestPermission");
		mCallback = cb;
		Interop.WVR_RequestPermissions(permissions, requestDoneCallback);
	}

	public void requestUsbPermission(requestUsbCompleteCallback cb)
	{
		WVR_Log.Log.d(LOG_TAG, "requestUsbPermission");
		mUsbCallback = cb;
		Interop.WVR_RequestUsbPermission(requestUsbDoneCallback);
	}

	public bool isPermissionGranted(string permission)
	{
		bool result = Interop.WVR_IsPermissionGranted(permission);
		WVR_Log.Log.d(LOG_TAG, "isPermissionGranted: permission = " + permission + " : " + result);
		return result;
	}

	public bool shouldGrantPermission(string permission)
	{
		bool result = Interop.WVR_ShouldGrantPermission(permission);
		WVR_Log.Log.d(LOG_TAG, "shouldGrantPermission: permission = " + permission + " : " + result);
		return result;
	}

	public bool showDialogOnScene()
	{
		bool result = Interop.WVR_ShowDialogOnScene();
		WVR_Log.Log.d(LOG_TAG, "showDialogOnScene: " + result);
		return result;
	}
}
public class WaveVR_PointerCameraTracker : MonoBehaviour
{
	private const string LOG_TAG = "WaveVR_PointerCameraTracker";

	public GameObject reticleObject;

	public WaveVR_Controller.EDeviceType type;

	private WaveVR_ControllerPointer reticle;

	private Vector3 pointer_location;

	private void PrintDebugLog(string msg)
	{
		WVR_Log.Log.d("WaveVR_PointerCameraTracker", msg);
	}

	private void Start()
	{
		if (reticleObject != null)
		{
			reticle = reticleObject.GetComponent<WaveVR_ControllerPointer>();
		}
	}

	private void Update()
	{
		if (reticleObject != null && reticle == null)
		{
			reticle = reticleObject.GetComponent<WaveVR_ControllerPointer>();
		}
		if (reticleObject != null && reticle != null)
		{
			pointer_location = reticleObject.transform.position + reticleObject.transform.forward * reticle.PointerDistanceInMeters;
			base.transform.rotation = Quaternion.LookRotation(pointer_location - base.transform.position);
		}
	}

	public void setDeviceType(WaveVR_Controller.EDeviceType value)
	{
		type = value;
	}
}
public class WaveVR_Render : MonoBehaviour
{
	public enum StereoRenderingPath
	{
		MultiPass = 0,
		SinglePass = 1,
		Auto = 1,
		Instancing = 2
	}

	public delegate void RenderCallback(WaveVR_Render render);

	public delegate void RenderCallbackWithEye(WaveVR_Render render, WVR_Eye eye);

	public delegate void RenderCallbackWithEyeAndCamera(WaveVR_Render render, WVR_Eye eye, WaveVR_Camera wvrCamera);

	public class RenderThreadSynchronizer
	{
		private RenderTexture mutable = new RenderTexture(1, 1, 0);

		public RenderThreadSynchronizer()
		{
			mutable.useMipMap = false;
			mutable.Create();
		}

		public void sync()
		{
			StackTraceLogType stackTraceLogType = UnityEngine.Application.GetStackTraceLogType(LogType.Error);
			UnityEngine.Application.SetStackTraceLogType(LogType.Error, StackTraceLogType.None);
			mutable.GetNativeTexturePtr();
			WVR_Log.Log.e(TAG, "If the libEGL and Unity errors appeared above, don't panic or report a bug.  They are safe and will not crash your game.");
			UnityEngine.Application.SetStackTraceLogType(LogType.Error, stackTraceLogType);
		}
	}

	private class RenderThreadContext : wvr.render.utils.Message
	{
		public WVR_Eye eye;

		public int textureCount;

		public WVR_TextureParams_t[] textureParam = new WVR_TextureParams_t[2];

		public int foveationCount;

		public WVR_RenderFoveationParams[] foveationParams = new WVR_RenderFoveationParams[2];

		public int poseCount;

		public WVR_PoseState_t[] pose = new WVR_PoseState_t[1];

		public WVR_SubmitExtend flag;

		public int renderEvent = -1;

		public WVR_RenderInitParams_t renderInitParams;

		public static void IssueRenderEvent(RenderThreadSyncObject syncObj, int renderEvent, WVR_RenderInitParams_t renderInitParams)
		{
			PreAllocatedQueue queue = syncObj.Queue;
			lock (queue)
			{
				RenderThreadContext renderThreadContext = queue.Obtain<RenderThreadContext>();
				renderThreadContext.renderEvent = renderEvent;
				renderThreadContext.renderInitParams = renderInitParams;
				queue.Enqueue(renderThreadContext);
			}
			syncObj.IssueEvent();
		}

		public static void ReceiveRenderEvent(PreAllocatedQueue queue)
		{
			lock (queue)
			{
				RenderThreadContext renderThreadContext = (RenderThreadContext)queue.Dequeue();
				renderThreadContext.CopyTo(contextRTOnly);
				queue.Release(renderThreadContext);
			}
			if (contextRTOnly.renderEvent == 0)
			{
				Interop.WVR_RenderInit(ref contextRTOnly.renderInitParams);
			}
			contextRTOnly.renderEvent = -1;
		}

		public static void IssueBefore(RenderThreadSyncObject syncObj, WVR_Eye eye, int textureCount, WVR_TextureParams_t textureParam0, WVR_TextureParams_t textureParam1, int foveationCount, WVR_RenderFoveationParams foveationParams0, WVR_RenderFoveationParams foveationParams1)
		{
			PreAllocatedQueue queue = syncObj.Queue;
			lock (queue)
			{
				RenderThreadContext renderThreadContext = queue.Obtain<RenderThreadContext>();
				renderThreadContext.eye = eye;
				renderThreadContext.textureCount = textureCount;
				renderThreadContext.textureParam[0] = textureParam0;
				renderThreadContext.textureParam[1] = textureParam1;
				renderThreadContext.foveationCount = foveationCount;
				renderThreadContext.foveationParams[0] = foveationParams0;
				renderThreadContext.foveationParams[1] = foveationParams1;
				queue.Enqueue(renderThreadContext);
			}
			syncObj.IssueEvent();
		}

		public static void IssueAfter(RenderThreadSyncObject syncObj, WVR_Eye eye, int textureCount, WVR_TextureParams_t textureParam0, WVR_TextureParams_t textureParam1, int poseCount, WVR_PoseState_t pose0, WVR_SubmitExtend flag)
		{
			PreAllocatedQueue queue = syncObj.Queue;
			lock (queue)
			{
				RenderThreadContext renderThreadContext = queue.Obtain<RenderThreadContext>();
				renderThreadContext.eye = eye;
				renderThreadContext.textureCount = textureCount;
				renderThreadContext.textureParam[0] = textureParam0;
				renderThreadContext.textureParam[1] = textureParam1;
				renderThreadContext.poseCount = poseCount;
				renderThreadContext.pose[0] = pose0;
				renderThreadContext.flag = flag;
				queue.Enqueue(renderThreadContext);
			}
			syncObj.IssueEvent();
		}

		public static void ReceiveBefore(PreAllocatedQueue queue)
		{
			lock (queue)
			{
				RenderThreadContext renderThreadContext = (RenderThreadContext)queue.Dequeue();
				renderThreadContext.CopyTo(contextRTOnly);
				queue.Release(renderThreadContext);
			}
			if (contextRTOnly.eye == WVR_Eye.WVR_Eye_Both)
			{
				contextRTOnly.eye = WVR_Eye.WVR_Eye_Left;
			}
			if (isDuringFirstFrame)
			{
				WVR_Log.Log.d(TAG, "FirstFrame : call WVR_PreRenderEye +++");
			}
			Interop.WVR_PreRenderEye(contextRTOnly.eye, (contextRTOnly.textureCount == 0) ? null : contextRTOnly.textureParam, (contextRTOnly.foveationCount == 0) ? null : contextRTOnly.foveationParams);
			if (isDuringFirstFrame)
			{
				WVR_Log.Log.d(TAG, "FirstFrame : call WVR_PreRenderEye ---");
			}
		}

		public static void ReceiveAfter(PreAllocatedQueue queue)
		{
			lock (queue)
			{
				RenderThreadContext renderThreadContext = (RenderThreadContext)queue.Dequeue();
				renderThreadContext.CopyTo(contextRTOnly);
				queue.Release(renderThreadContext);
			}
			if (contextRTOnly.eye == WVR_Eye.WVR_Eye_Both)
			{
				contextRTOnly.eye = WVR_Eye.WVR_Eye_Left;
			}
			if (isDuringFirstFrame)
			{
				WVR_Log.Log.d(TAG, "FirstFrame : call WVR_SubmitFrame +++");
			}
			Interop.WVR_SubmitFrame(contextRTOnly.eye, (contextRTOnly.textureCount == 0) ? null : contextRTOnly.textureParam, (contextRTOnly.poseCount == 0) ? null : contextRTOnly.pose, contextRTOnly.flag);
			if (isDuringFirstFrame)
			{
				WVR_Log.Log.d(TAG, "FirstFrame : call WVR_SubmitFrame ---");
			}
		}

		public void CopyTo(RenderThreadContext dest)
		{
			dest.eye = eye;
			dest.textureCount = textureCount;
			dest.textureParam[0] = textureParam[0];
			dest.textureParam[1] = textureParam[1];
			dest.foveationCount = foveationCount;
			dest.foveationParams[0] = foveationParams[0];
			dest.foveationParams[1] = foveationParams[1];
			dest.poseCount = poseCount;
			dest.pose[0] = pose[0];
			dest.flag = flag;
			dest.renderEvent = renderEvent;
			dest.renderInitParams = renderInitParams;
		}
	}

	private static readonly string TAG = "WVR_Render";

	private static WaveVR_Render instance = null;

	[Tooltip("Only used on editor.")]
	public float ipd = 0.063f;

	private int targetFPS = -1;

	private static bool surfaceChanged = false;

	private static bool isNeedTimeout = false;

	private static bool isGraphicInitialized = false;

	private static bool isDuringFirstFrame = false;

	private static bool isSetActiveSceneChangedCB = false;

	public float[] projRawL = new float[4] { -1f, 1f, 1f, -1f };

	public float[] projRawR = new float[4] { -1f, 1f, 1f, -1f };

	private WaveVR_Utils.RigidTransform[] _eyes = new WaveVR_Utils.RigidTransform[2]
	{
		new WaveVR_Utils.RigidTransform(new Vector3(-0.0315f, 0.15f, 0.12f), Quaternion.identity),
		new WaveVR_Utils.RigidTransform(new Vector3(0.0315f, 0.15f, 0.12f), Quaternion.identity)
	};

	[Tooltip("You can trigger a configuration change on editor by checking this.  Help to test related delegate.")]
	public bool configurationChanged;

	[Tooltip("SinglePass is an experimental feature.  Use it at your own risk.\n\nChoose a preferred stereo rendering path setting according to your scene.  The actural rendering path will still depend on your project PlayerSettings and VR device.  It will fallback to multi-pass if not qualified.  Changing in runtime will take no effect.  Default is Auto (SinglePass).")]
	[SerializeField]
	private StereoRenderingPath PreferredStereoRenderingPath = StereoRenderingPath.SinglePass;

	public RenderCallback beforeRenderExpand;

	public RenderCallbackWithEye beforeEyeExpand;

	public RenderCallbackWithEyeAndCamera afterEyeExpand;

	public RenderCallback afterRenderExpand;

	public RenderCallback onConfigurationChanged;

	public RenderCallback onSDKGraphicReady;

	public RenderCallback onFirstFrame;

	public RenderCallbackWithEyeAndCamera beforeRenderEye;

	public RenderCallbackWithEyeAndCamera afterRenderEye;

	private RenderThreadSynchronizer synchronizer;

	private const string OBJ_NAME_EYE_CENTER = "Eye Center";

	private const string OBJ_NAME_LEFT_EYE = "Eye Left";

	private const string OBJ_NAME_RIGHT_EYE = "Eye Right";

	private const string OBJ_NAME_BOTH_EYES = "Eye Both";

	private const string OBJ_NAME_EAR = "Ear";

	private const string OBJ_NAME_DISTORTION = "Distortion";

	private const string OBJ_NAME_RETICLE = "Reticle";

	private const string OBJ_NAME_LOADING = "Loading";

	public WaveVR_Camera centerWVRCamera;

	public WaveVR_Camera lefteye;

	public WaveVR_Camera righteye;

	public WaveVR_Camera botheyes;

	public WaveVR_Distortion distortion;

	public GameObject loadingCanvas;

	public GameObject ear;

	[SerializeField]
	[Tooltip("Function of loading canvas will be replaced by GL.Clear(). You can still use loading canvas by this check. However if using it, you will get a warning from Unity about screen space canvas should not be used in VR support.\nFor LoadingCanvas already expanded/existed, Render will choose to apply it unless developer delete it from hierarchy.")]
	private bool useLoadingCanvas;

	[SerializeField]
	[Tooltip("The VR render system can not take action while game is loading or resuming. For a short period, the VR system is not ready, and a clean color will be appliedto help clean the snowy screen.\nThis color will also effect the LoadingCanvas if useLoadingCanvas is checked.")]
	private Color loadingBlockerColor = Color.black;

	private static TextureManager _textureManager = null;

	public static int globalOrigin = -1;

	public static int globalPreferredStereoRenderingPath = -1;

	public WVR_PoseOriginModel _origin = WVR_PoseOriginModel.WVR_PoseOriginModel_OriginOnGround;

	private const string WVRSinglePassDeviceName = "mockhmd";

	private Coroutine renderLooperCoroutine;

	private WaitForEndOfFrame cachedWaitForEndOfFrame;

	private bool isPartialTexture;

	[SerializeField]
	[Range(0.1f, 2f)]
	[Tooltip("The value is a scale to the recommended RenderTarget width and height. It will change the render texture size.  Use a smaller value to improve performance. Or use a larger value to improve quality.")]
	private float pixelDensity = 1f;

	[Range(1f, 2f)]
	[Tooltip("Let the rendering FOV larger than original size, but only show the original size.  Help to reduce the showing of black peripheral area when ATW triggered.  It will scale up the render texture size.  Therefore,the pixel quality is keeped.\nWARNING: This setting will impact the performance.")]
	private float overDraw = 1f;

	private float resolutionScale = 1f;

	private readonly Rect fullViewport = Rect.MinMaxRect(0f, 0f, 1f, 1f);

	private Rect drawViewport = Rect.MinMaxRect(0f, 0f, 1f, 1f);

	private WVR_TextureParams_t[] textureParams = new WVR_TextureParams_t[2]
	{
		new WVR_TextureParams_t
		{
			layout = new WVR_TextureLayout_t
			{
				leftLowUVs = new WVR_Vector2f_t
				{
					v0 = 0f,
					v1 = 0f
				},
				rightUpUVs = new WVR_Vector2f_t
				{
					v0 = 1f,
					v1 = 1f
				}
			}
		},
		new WVR_TextureParams_t
		{
			layout = new WVR_TextureLayout_t
			{
				leftLowUVs = new WVR_Vector2f_t
				{
					v0 = 0f,
					v1 = 0f
				},
				rightUpUVs = new WVR_Vector2f_t
				{
					v0 = 1f,
					v1 = 1f
				}
			}
		}
	};

	private bool previousInputFocus = true;

	[Tooltip("Allow render to set Time.timeScale = 0 if input focus in gone.")]
	public bool needTimeControl;

	private static readonly WVR_RenderFoveationParams[] foveationParams = new WVR_RenderFoveationParams[2];

	private static RenderThreadContext contextRTOnly = new RenderThreadContext();

	private static readonly RenderThreadSyncObject RenderCommandRenderEvent = new RenderThreadSyncObject(RenderThreadContext.ReceiveRenderEvent);

	private static readonly RenderThreadSyncObject RenderCommandBeforeEyeTemplate = new RenderThreadSyncObject(RenderThreadContext.ReceiveBefore);

	private static readonly RenderThreadSyncObject RenderCommandAfterEyeTemplate = new RenderThreadSyncObject(RenderThreadContext.ReceiveAfter);

	private static readonly RenderThreadSyncObject[] RenderCommandBeforeEye = new RenderThreadSyncObject[3] { RenderCommandBeforeEyeTemplate, RenderCommandBeforeEyeTemplate, RenderCommandBeforeEyeTemplate };

	private static readonly RenderThreadSyncObject[] RenderCommandAfterEye = new RenderThreadSyncObject[3] { RenderCommandAfterEyeTemplate, RenderCommandAfterEyeTemplate, RenderCommandAfterEyeTemplate };

	private static WVR_PoseState_t poseUsedOnSubmit = new WVR_PoseState_t
	{
		IsValidPose = false
	};

	private static WVR_SubmitExtend submitExtendFlag = WVR_SubmitExtend.WVR_SubmitExtend_Default;

	public static WaveVR_Render Instance => instance;

	public bool IsGraphicReady => isGraphicInitialized;

	public uint recommendedWidth { get; private set; }

	public uint recommendedHeight { get; private set; }

	public float sceneWidth { get; private set; }

	public float sceneHeight { get; private set; }

	public WaveVR_Utils.RigidTransform[] eyes
	{
		get
		{
			return _eyes;
		}
		private set
		{
			_eyes = value;
		}
	}

	public StereoRenderingPath acturalStereoRenderingPath
	{
		get
		{
			if (!IsSinglePass)
			{
				return StereoRenderingPath.MultiPass;
			}
			return StereoRenderingPath.SinglePass;
		}
	}

	public bool IsSinglePass { get; private set; }

	public bool isExpanded
	{
		get
		{
			if (centerWVRCamera == null)
			{
				centerWVRCamera = GetComponentFromChildren<WaveVR_Camera>("Eye Center");
			}
			if (lefteye == null)
			{
				lefteye = GetComponentFromChildren<WaveVR_Camera>("Eye Left");
			}
			if (righteye == null)
			{
				righteye = GetComponentFromChildren<WaveVR_Camera>("Eye Right");
			}
			if (botheyes == null)
			{
				botheyes = GetComponentFromChildren<WaveVR_Camera>("Eye Both");
			}
			if (!(centerWVRCamera == null) && !(lefteye == null) && !(righteye == null))
			{
				return !(botheyes == null);
			}
			return false;
		}
	}

	public Camera centerCamera
	{
		get
		{
			if (!(centerWVRCamera == null))
			{
				return centerWVRCamera.GetCamera();
			}
			return null;
		}
	}

	public TextureManager textureManager
	{
		get
		{
			return _textureManager;
		}
		private set
		{
			_textureManager = value;
		}
	}

	[HideInInspector]
	public ColorSpace QSColorSpace { get; private set; }

	public WVR_PoseOriginModel origin
	{
		get
		{
			return _origin;
		}
		set
		{
			_origin = value;
			OnIpdChanged(null);
		}
	}

	public float PixelDensity => pixelDensity;

	public float OverDraw => overDraw;

	public float ResolutionScale => resolutionScale;

	public T GetComponentFromChildren<T>(string name)
	{
		Transform transform = base.transform.Find(name);
		if (transform != null)
		{
			return transform.GetComponent<T>();
		}
		return default(T);
	}

	public static void InitializeGraphic(RenderThreadSynchronizer synchronizer = null)
	{
		WVR_Log.Log.i(TAG, "Color space is " + QualitySettings.activeColorSpace);
		WVR_RenderConfig wVR_RenderConfig = WVR_RenderConfig.WVR_RenderConfig_Default;
		if (QualitySettings.activeColorSpace == ColorSpace.Linear)
		{
			wVR_RenderConfig |= WVR_RenderConfig.WVR_RenderConfig_sRGB;
		}
		WVR_RenderInitParams_t wVR_RenderInitParams_t = default(WVR_RenderInitParams_t);
		wVR_RenderInitParams_t.graphicsApi = WVR_GraphicsApiType.WVR_GraphicsApiType_OpenGL;
		wVR_RenderInitParams_t.renderConfig = (ulong)wVR_RenderConfig;
		WVR_RenderInitParams_t renderInitParams = wVR_RenderInitParams_t;
		RenderThreadContext.IssueRenderEvent(RenderCommandRenderEvent, 0, renderInitParams);
		synchronizer?.sync();
	}

	public void OnIpdChanged(params object[] args)
	{
		WVR_Log.Log.d(TAG, "OnIpdChanged");
		WVR_NumDoF dof = ((WaveVR.Instance.is6DoFTracking() != 3 && origin != WVR_PoseOriginModel.WVR_PoseOriginModel_OriginOnHead_3DoF) ? WVR_NumDoF.WVR_NumDoF_6DoF : WVR_NumDoF.WVR_NumDoF_3DoF);
		WVR_Matrix4f_t pose = Interop.WVR_GetTransformFromEyeToHead(WVR_Eye.WVR_Eye_Left, dof);
		WVR_Matrix4f_t pose2 = Interop.WVR_GetTransformFromEyeToHead(WVR_Eye.WVR_Eye_Right, dof);
		eyes = new WaveVR_Utils.RigidTransform[2]
		{
			new WaveVR_Utils.RigidTransform(pose),
			new WaveVR_Utils.RigidTransform(pose2)
		};
		ipd = Vector3.Distance(eyes[1].pos, eyes[0].pos);
		Interop.WVR_GetClippingPlaneBoundary(WVR_Eye.WVR_Eye_Left, ref projRawL[0], ref projRawL[1], ref projRawL[2], ref projRawL[3]);
		Interop.WVR_GetClippingPlaneBoundary(WVR_Eye.WVR_Eye_Right, ref projRawR[0], ref projRawR[1], ref projRawR[2], ref projRawR[3]);
		UpdateViewports();
		WVR_Log.Log.d(TAG, "targetFPS=" + targetFPS + " sceneWidth=" + sceneWidth + " sceneHeight=" + sceneHeight + "\nprojRawL[0]=" + projRawL[0] + " projRawL[1]=" + projRawL[1] + " projRawL[2]=" + projRawL[2] + " projRawL[3]=" + projRawL[3] + "\nprojRawR[0]=" + projRawR[0] + " projRawR[1]=" + projRawR[1] + " projRawR[2]=" + projRawR[2] + " projRawR[3]=" + projRawR[3] + "\neyes[L]=" + eyes[0].pos.x + "," + eyes[0].pos.y + "," + eyes[0].pos.z + "\neyes[R]=" + eyes[1].pos.x + "," + eyes[1].pos.y + "," + eyes[1].pos.z + "\nPixelDensity=" + pixelDensity + ", OverDraw=" + overDraw);
		configurationChanged = true;
	}

	public static bool IsVRSinglePassBuildTimeSupported()
	{
		return false;
	}

	private bool checkVRSinglePassSupport()
	{
		string[] supportedDevices = XRSettings.supportedDevices;
		string text = "";
		string[] array = supportedDevices;
		foreach (string text2 in array)
		{
			if (text2.ToLower().Contains("mockhmd"))
			{
				text = text2;
				break;
			}
		}
		bool flag = false;
		if (!string.IsNullOrEmpty(text))
		{
			flag = XRSettings.isDeviceActive;
		}
		int num = 0;
		num = WaveVR_Utils.IsSinglePassSupported();
		WVR_Log.Log.d(TAG, "sdkNativeSupport = " + num);
		bool flag2 = false;
		if (globalPreferredStereoRenderingPath > -1 && PreferredStereoRenderingPath == StereoRenderingPath.SinglePass)
		{
			flag2 = globalPreferredStereoRenderingPath == 0;
		}
		bool result = !(PreferredStereoRenderingPath != StereoRenderingPath.SinglePass || flag2) && num > 0 && flag && IsVRSinglePassBuildTimeSupported();
		string message = string.Concat("VRSupport: deviceName ", text, ", Graphic support ", num, ", XRSettings.isDeviceActive ", flag.ToString(), ", BuildTimeSupport ", IsVRSinglePassBuildTimeSupported().ToString(), ", preferred ", PreferredStereoRenderingPath, ", global ", globalPreferredStereoRenderingPath, ", IsSinglePass ", result.ToString());
		WVR_Log.Log.d(TAG, message, logInEditor: true);
		return result;
	}

	private void SwitchDeviceView(bool enableSinglepass)
	{
		if (enableSinglepass)
		{
			if (false)
			{
				XRSettings.gameViewRenderMode = GameViewRenderMode.BothEyes;
			}
			XRSettings.showDeviceView = false;
		}
		else
		{
			XRSettings.gameViewRenderMode = GameViewRenderMode.BothEyes;
		}
	}

	private void SwitchKeyword(bool enable)
	{
		if (enable)
		{
			Shader.EnableKeyword("STEREO_MULTIVIEW_ON");
			Shader.EnableKeyword("UNITY_SINGLE_PASS_STEREO");
		}
		else
		{
			Shader.DisableKeyword("STEREO_MULTIVIEW_ON");
			Shader.DisableKeyword("UNITY_SINGLE_PASS_STEREO");
		}
	}

	private void Awake()
	{
		WVR_Log.Log.d(TAG, "Awake()+");
		WVR_Log.Log.d(TAG, "Version of the runtime: " + UnityEngine.Application.unityVersion);
		if (instance == null)
		{
			instance = this;
		}
		else
		{
			WVR_Log.Log.w(TAG, "Render already Awaked");
		}
		QualitySettings.SetQualityLevel(QualitySettings.GetQualityLevel(), applyExpensiveChanges: true);
		synchronizer = new RenderThreadSynchronizer();
		if (globalOrigin >= 0 && globalOrigin <= 3)
		{
			origin = (WVR_PoseOriginModel)globalOrigin;
			WVR_Log.Log.d(TAG, "Has global tracking space " + origin);
		}
		if (WaveVR_Init.Instance == null || !WaveVR.Instance.Initialized)
		{
			WVR_Log.Log.e(TAG, "Fail to initialize");
		}
		IsSinglePass = checkVRSinglePassSupport();
		uint width = 0u;
		uint height = 0u;
		Interop.WVR_GetRenderTargetSize(ref width, ref height);
		recommendedWidth = width;
		recommendedHeight = height;
		UpdateViewports();
		WVR_RenderProps_t props = default(WVR_RenderProps_t);
		Interop.WVR_GetRenderProps(ref props);
		targetFPS = (int)props.refreshRate;
		OnIpdChanged(null);
		WVR_Log.Log.d(TAG, "Actural StereoRenderingPath is " + acturalStereoRenderingPath);
		WaveVR_Utils.IssueEngineEvent(WaveVR_Utils.EngineEventID.HMD_INITIAILZED);
		Screen.sleepTimeout = -1;
		UnityEngine.Application.targetFrameRate = targetFPS;
		WVR_Log.Log.d(TAG, "Awake()-");
	}

	private void enableRenderLoop(bool start)
	{
		if (start && base.enabled)
		{
			if (renderLooperCoroutine == null)
			{
				IEnumerator routine = RenderLoop();
				renderLooperCoroutine = StartCoroutine(routine);
			}
		}
		else
		{
			if (renderLooperCoroutine != null)
			{
				StopCoroutine(renderLooperCoroutine);
			}
			renderLooperCoroutine = null;
		}
	}

	private void OnEnable()
	{
		WVR_Log.Log.d(TAG, "OnEnable()+");
		WaveVR_Utils.Event.Listen(WaveVR_Utils.Event.IPD_CHANGED, OnIpdChanged);
		enableRenderLoop(start: true);
		setLoadingCanvas(enabled: true);
		WaveVR_Utils.IssueEngineEvent(WaveVR_Utils.EngineEventID.UNITY_ENABLE);
		if (!isSetActiveSceneChangedCB)
		{
			WVR_Log.Log.d(TAG, "Added scene loaded callback");
			SceneManager.sceneLoaded += OnSceneLoaded;
			isSetActiveSceneChangedCB = true;
		}
		WVR_Log.Log.d(TAG, "OnEnable()-");
	}

	private void Start()
	{
		WVR_Log.Log.d(TAG, "Start()+");
		Expand(this);
		if (Camera.main == null)
		{
			centerCamera.tag = "MainCamera";
		}
		centerCamera.enabled = false;
		botheyes.GetCamera().enabled = false;
		lefteye.GetCamera().enabled = false;
		righteye.GetCamera().enabled = false;
		WVR_Log.Log.d(TAG, "onConfigurationChanged+");
		WaveVR_Utils.Event.Send(WaveVR_Utils.Event.RENDER_CONFIGURATION_CHANGED);
		WaveVR_Utils.SafeExecuteAllDelegate(onConfigurationChanged, delegate(RenderCallback a)
		{
			a(this);
		});
		configurationChanged = false;
		WVR_Log.Log.d(TAG, "onConfigurationChanged-");
		WVR_Log.Log.d(TAG, "Start()-");
	}

	private static void OnSceneLoaded(Scene scene, LoadSceneMode mode)
	{
		WVR_Log.Log.d(TAG, "OnSceneLoaded Scene name: " + scene.name + ", mode: " + mode);
		try
		{
			WVR_Log.Log.d(TAG, "OnSceneLoaded Set TrackingSpaceOrigin: " + instance.origin);
			WVR_Log.Log.d(TAG, "OnSceneLoaded WVR_GetDegreeOfFreedom(HMD): " + Interop.WVR_GetDegreeOfFreedom(WVR_DeviceType.WVR_DeviceType_HMD));
			WVR_Log.Log.d(TAG, "OnSceneLoaded HMD Pose DOF: " + (WaveVR.Instance.hmd.pose.pose.Is6DoFPose ? "6DoF" : "3DoF"));
			WVR_Log.Log.d(TAG, "OnSceneLoaded Left-hand mode: " + WaveVR_Controller.IsLeftHanded);
			WaveVR.Device deviceByType = WaveVR.Instance.getDeviceByType(WVR_DeviceType.WVR_DeviceType_Controller_Right);
			if (deviceByType != null && deviceByType.connected)
			{
				WVR_Log.Log.d(TAG, "OnSceneLoaded WVR_GetDegreeOfFreedom(Controller_Right): " + Interop.WVR_GetDegreeOfFreedom(WVR_DeviceType.WVR_DeviceType_Controller_Right));
				WVR_Log.Log.d(TAG, "OnSceneLoaded Right Controller Pose DOF: " + (deviceByType.pose.pose.Is6DoFPose ? "6DoF" : "3DoF"));
			}
			WaveVR.Device deviceByType2 = WaveVR.Instance.getDeviceByType(WVR_DeviceType.WVR_DeviceType_Controller_Left);
			if (deviceByType != null && deviceByType2.connected)
			{
				WVR_Log.Log.d(TAG, "OnSceneLoaded WVR_GetDegreeOfFreedom(Controller_Left): " + Interop.WVR_GetDegreeOfFreedom(WVR_DeviceType.WVR_DeviceType_Controller_Left));
				WVR_Log.Log.d(TAG, "OnSceneLoaded Left Controller Pose DOF: " + (deviceByType2.pose.pose.Is6DoFPose ? "6DoF" : "3DoF"));
			}
			if (WaveVR_InputModuleManager.Instance != null)
			{
				WVR_Log.Log.d(TAG, "OnSceneLoaded enable Input module: " + WaveVR_InputModuleManager.Instance.EnableInputModule.ToString() + ", Interaction mode: " + WaveVR_InputModuleManager.Instance.GetInteractionMode());
				WVR_Log.Log.d(TAG, "OnSceneLoaded override system settings: " + WaveVR_InputModuleManager.Instance.OverrideSystemSettings.ToString() + ", custom input module: " + WaveVR_InputModuleManager.Instance.CustomInputModule);
				WVR_Log.Log.d(TAG, "OnSceneLoaded TimeToGaze: " + WaveVR_InputModuleManager.Instance.Gaze.TimeToGaze + ", Gaze trigger type: " + WaveVR_InputModuleManager.Instance.GetUserGazeTriggerType());
				WVR_Log.Log.d(TAG, "OnSceneLoaded Controller Raycast Mode: " + WaveVR_InputModuleManager.Instance.Controller.RaycastMode);
			}
		}
		catch (Exception ex)
		{
			WVR_Log.Log.e(TAG, "Error during OnSceneLoaded\n" + ex.ToString());
		}
	}

	public static void signalSurfaceState(string msg)
	{
		WVR_Log.Log.d(TAG, "signalSurfaceState[ " + msg + " ]");
		if (string.Equals(msg, "CHANGED"))
		{
			surfaceChanged = false;
		}
		else if (string.Equals(msg, "CHANGED_WRONG"))
		{
			surfaceChanged = false;
			isNeedTimeout = true;
		}
		else if (string.Equals(msg, "CHANGED_RIGHT"))
		{
			surfaceChanged = true;
		}
		else if (string.Equals(msg, "DESTROYED"))
		{
			surfaceChanged = false;
			WVR_Log.Log.d(TAG, "surfaceDestroyed");
		}
	}

	private static bool checkSurfaceChanged()
	{
		bool result = false;
		try
		{
			result = new AndroidJavaClass("com.htc.vr.unity.WVRUnityVRActivity").GetStatic<bool>("mSurfaceChanged");
		}
		catch (Exception ex)
		{
			WVR_Log.Log.e(TAG, ex.Message, logInEditor: true);
		}
		return result;
	}

	private void OnApplicationPause(bool pauseStatus)
	{
		WVR_Log.Log.d(TAG, "Pause(" + pauseStatus + ")");
		if (pauseStatus)
		{
			WaveVR_Utils.IssueEngineEvent(WaveVR_Utils.EngineEventID.UNITY_APPLICATION_PAUSE);
			if (synchronizer != null)
			{
				synchronizer.sync();
			}
			if (lefteye != null)
			{
				lefteye.GetCamera().targetTexture = null;
			}
			if (righteye != null)
			{
				righteye.GetCamera().targetTexture = null;
			}
			if (botheyes != null)
			{
				botheyes.GetCamera().targetTexture = null;
			}
			if (textureManager != null)
			{
				textureManager.ReleaseTexturePools();
			}
		}
		else
		{
			WaveVR_Utils.IssueEngineEvent(WaveVR_Utils.EngineEventID.UNITY_APPLICATION_RESUME);
		}
		if (IsSinglePass)
		{
			SwitchDeviceView(enableSinglepass: false);
		}
		setLoadingCanvas(enabled: true);
		enableRenderLoop(!pauseStatus);
	}

	public int SetQualityLevel(int level, bool applyExpensiveChanges = true)
	{
		if (level < 0)
		{
			return -1;
		}
		string[] names = QualitySettings.names;
		if (level >= names.Length)
		{
			return -1;
		}
		int qualityLevel = QualitySettings.GetQualityLevel();
		if (qualityLevel != level)
		{
			QualitySettings.SetQualityLevel(level, applyExpensiveChanges: false);
			if (applyExpensiveChanges)
			{
				SceneManager.LoadScene(SceneManager.GetActiveScene().name);
			}
			qualityLevel = QualitySettings.GetQualityLevel();
		}
		return qualityLevel;
	}

	private void LateUpdate()
	{
		WVR_Log.Log.gpl.check();
	}

	private void OnApplicationQuit()
	{
		WaveVR_Utils.IssueEngineEvent(WaveVR_Utils.EngineEventID.UNITY_APPLICATION_QUIT);
		if (synchronizer != null)
		{
			synchronizer.sync();
		}
		WaveVR.SafeDispose();
	}

	private void OnDisable()
	{
		using (WVR_Log.Log.ee(TAG, "OnDisable()+", "OnDisable()-"))
		{
			enableRenderLoop(start: false);
			WaveVR_Utils.IssueEngineEvent(WaveVR_Utils.EngineEventID.UNITY_DISABLE);
			if (synchronizer != null)
			{
				synchronizer.sync();
			}
			WaveVR_Utils.Event.Remove(WaveVR_Utils.Event.IPD_CHANGED, OnIpdChanged);
			setLoadingCanvas(enabled: false);
			if (lefteye != null)
			{
				lefteye.GetCamera().targetTexture = null;
			}
			if (righteye != null)
			{
				righteye.GetCamera().targetTexture = null;
			}
			if (botheyes != null)
			{
				botheyes.GetCamera().targetTexture = null;
			}
			if (isSetActiveSceneChangedCB)
			{
				WVR_Log.Log.d(TAG, "Removed scene loaded callback");
				SceneManager.sceneLoaded -= OnSceneLoaded;
				isSetActiveSceneChangedCB = false;
			}
		}
	}

	private void OnDestroy()
	{
		using (WVR_Log.Log.ee(TAG, "OnDestroy()+", "OnDestroy()-"))
		{
			instance = null;
			WaveVR_Utils.IssueEngineEvent(WaveVR_Utils.EngineEventID.UNITY_DESTROY);
		}
	}

	private IEnumerator RenderLoop()
	{
		WVR_Log.Log.d(TAG, "RenderLoop() is started");
		if (cachedWaitForEndOfFrame == null)
		{
			cachedWaitForEndOfFrame = new WaitForEndOfFrame();
		}
		yield return cachedWaitForEndOfFrame;
		yield return cachedWaitForEndOfFrame;
		if (!isGraphicInitialized)
		{
			InitializeGraphic(synchronizer);
			isGraphicInitialized = true;
		}
		while (!isExpanded)
		{
			yield return cachedWaitForEndOfFrame;
		}
		textureManager = new TextureManager(allowAntiAliasing: (!IsSinglePass) ? (lefteye.GetCamera().allowMSAA && lefteye.GetCamera().allowMSAA) : botheyes.GetCamera().allowMSAA, oldTextureManager: textureManager, isSinglePass: IsSinglePass, pixelDensity: pixelDensity);
		WaveVR_Utils.SafeExecuteAllDelegate(onSDKGraphicReady, delegate(RenderCallback a)
		{
			a(this);
		});
		float tim = Time.realtimeSinceStartup;
		while (!WaveVR_Utils.WVR_IsATWActive())
		{
			yield return cachedWaitForEndOfFrame;
			if ((surfaceChanged && !isNeedTimeout) || (checkSurfaceChanged() && !isNeedTimeout))
			{
				break;
			}
			if (Time.realtimeSinceStartup - tim > 1f)
			{
				WVR_Log.Log.w(TAG, "Waiting for surface change is timeout.");
				break;
			}
		}
		isNeedTimeout = false;
		if (textureManager != null && !textureManager.validate())
		{
			textureManager.reset();
		}
		setLoadingCanvas(enabled: false);
		if (IsSinglePass)
		{
			SwitchDeviceView(IsSinglePass);
		}
		WVR_Log.Log.d(TAG, "RenderLoop() is running");
		WVR_Log.Log.d(TAG, "First frame");
		isDuringFirstFrame = true;
		WaveVR_Utils.IssueEngineEvent(WaveVR_Utils.EngineEventID.FIRST_FRAME);
		WaveVR_Utils.SafeExecuteAllDelegate(onFirstFrame, delegate(RenderCallback a)
		{
			a(this);
		});
		RenderCycle();
		yield return cachedWaitForEndOfFrame;
		isDuringFirstFrame = false;
		while (true)
		{
			WVR_Log.Log.gpl.d(TAG, "RenderLoop() is still running");
			RenderCycle();
			yield return cachedWaitForEndOfFrame;
		}
	}

	private void RenderCycle()
	{
		WaveVR_Utils.Trace.BeginSection("RenderLoop", inRenderThread: false);
		WaveVR.Instance.UpdateEachFrame(origin);
		if (textureManager != null)
		{
			textureManager.Next();
		}
		if (configurationChanged)
		{
			Expand(this);
			WVR_Log.Log.d(TAG, "onConfigurationChanged+");
			WaveVR_Utils.Event.Send(WaveVR_Utils.Event.RENDER_CONFIGURATION_CHANGED);
			WaveVR_Utils.SafeExecuteAllDelegate(onConfigurationChanged, delegate(RenderCallback a)
			{
				a(this);
			});
			configurationChanged = false;
			WVR_Log.Log.d(TAG, "onConfigurationChanged-");
		}
		if (IsSinglePass)
		{
			RenderEyeBoth(botheyes);
		}
		else
		{
			botheyes.GetCamera().enabled = false;
			RenderEye(lefteye, WVR_Eye.WVR_Eye_Left);
			RenderEye(righteye, WVR_Eye.WVR_Eye_Right);
		}
		WaveVR_Utils.Trace.EndSection(inRenderThread: false);
		TimeControl();
		WVR_Log.Log.gpl.d(TAG, "End of frame");
	}

	private void GetSubmitTextureParams(WVR_Eye eye, IntPtr texture, [Out] WVR_TextureParams_t[] textureParams, ref WVR_SubmitExtend flag)
	{
		if (isPartialTexture)
		{
			flag = WVR_SubmitExtend.WVR_SubmitExtend_PartialTexture;
		}
		else
		{
			flag = WVR_SubmitExtend.WVR_SubmitExtend_Default;
		}
		if (textureParams != null)
		{
			textureParams[0].id = texture;
			textureParams[0].target = ((eye == WVR_Eye.WVR_Eye_Both) ? WVR_TextureTarget.WVR_TextureTarget_2D_ARRAY : WVR_TextureTarget.WVR_TextureTarget_2D);
			textureParams[0].layout.leftLowUVs.v0 = drawViewport.xMin;
			textureParams[0].layout.leftLowUVs.v1 = drawViewport.yMin;
			textureParams[0].layout.rightUpUVs.v0 = drawViewport.xMax;
			textureParams[0].layout.rightUpUVs.v1 = drawViewport.yMax;
		}
	}

	private void UpdateViewports()
	{
		overDraw = Mathf.Clamp(overDraw, 1f, 2f);
		pixelDensity = Mathf.Clamp(pixelDensity, 0.1f, 2f);
		sceneWidth = (float)recommendedWidth * pixelDensity;
		sceneHeight = (float)recommendedHeight * pixelDensity;
		if (textureManager != null)
		{
			textureManager.Resize(resolutionScale);
		}
		drawViewport = fullViewport;
		isPartialTexture = false;
	}

	public void SetResolutionScale(float scale)
	{
		resolutionScale = Mathf.Clamp(scale, 0.1f, 1f);
		UpdateViewports();
	}

	private void RenderEyeBoth(WaveVR_Camera wvrCamera)
	{
		Camera camera = wvrCamera.GetCamera();
		RenderTexture currentRt = textureManager.both.currentRt;
		WVR_Eye wVR_Eye = WVR_Eye.WVR_Eye_Both;
		WaveVR_Utils.Trace.BeginSection("Render_WVR_Eye_Both");
		WVR_Log.Log.gpl.d(TAG, "Render_WVR_Eye_Both");
		if (isDuringFirstFrame)
		{
			WVR_Log.Log.d(TAG, "FirstFrame : " + wVR_Eye);
		}
		WVR_SubmitExtend flag = WVR_SubmitExtend.WVR_SubmitExtend_Default;
		GetSubmitTextureParams(wVR_Eye, (IntPtr)textureManager.both.currentPtr, textureParams, ref flag);
		if (isDuringFirstFrame)
		{
			WVR_Log.Log.d(TAG, "FirstFrame : PreRenderEye +++");
		}
		RenderThreadContext.IssueBefore(RenderCommandBeforeEye[(int)wVR_Eye], wVR_Eye, 1, textureParams[0], textureParams[1], 2, foveationParams[0], foveationParams[1]);
		if (isDuringFirstFrame)
		{
			WVR_Log.Log.d(TAG, "FirstFrame : PreRenderEye ---");
		}
		camera.enabled = true;
		camera.targetTexture = currentRt;
		camera.forceIntoRenderTexture = true;
		camera.rect = drawViewport;
		SwitchKeyword(enable: true);
		if (isDuringFirstFrame)
		{
			WVR_Log.Log.d(TAG, "FirstFrame : beforeRenderEye Callback +++");
		}
		SafeExecuteRenderEyeCallback(beforeRenderEye, wVR_Eye, wvrCamera);
		if (isDuringFirstFrame)
		{
			WVR_Log.Log.d(TAG, "FirstFrame : beforeRenderEye Callback ---");
		}
		camera.Render();
		if (isDuringFirstFrame)
		{
			WVR_Log.Log.d(TAG, "FirstFrame : afterRenderEye Callback +++");
		}
		SafeExecuteRenderEyeCallback(afterRenderEye, wVR_Eye, wvrCamera);
		if (isDuringFirstFrame)
		{
			WVR_Log.Log.d(TAG, "FirstFrame : afterRenderEye Callback ---");
		}
		SwitchKeyword(enable: false);
		camera.enabled = false;
		currentRt.DiscardContents(discardColor: false, discardDepth: true);
		if (isDuringFirstFrame)
		{
			WVR_Log.Log.d(TAG, "FirstFrame : SubmitFrame +++");
		}
		RenderThreadContext.IssueAfter(RenderCommandAfterEye[(int)wVR_Eye], wVR_Eye, 1, textureParams[0], textureParams[1], poseUsedOnSubmit.IsValidPose ? 1 : 0, poseUsedOnSubmit, flag | submitExtendFlag);
		if (isDuringFirstFrame)
		{
			WVR_Log.Log.d(TAG, "FirstFrame : SubmitFrame ---");
		}
		WaveVR_Utils.Trace.EndSection();
	}

	private void RenderEye(WaveVR_Camera wvrCamera, WVR_Eye eye)
	{
		Camera camera = wvrCamera.GetCamera();
		WaveVR_Utils.Trace.BeginSection((eye == WVR_Eye.WVR_Eye_Left) ? "Render_WVR_Eye_Left" : "Render_WVR_Eye_Right");
		WVR_Log.Log.gpl.d(TAG, (eye == WVR_Eye.WVR_Eye_Left) ? "Render_WVR_Eye_Left" : "Render_WVR_Eye_Right");
		if (isDuringFirstFrame)
		{
			WVR_Log.Log.d(TAG, "FirstFrame : " + eye);
		}
		bool flag = eye == WVR_Eye.WVR_Eye_Left;
		RenderTexture renderTextureLR = textureManager.GetRenderTextureLR(flag);
		WVR_SubmitExtend flag2 = WVR_SubmitExtend.WVR_SubmitExtend_Default;
		GetSubmitTextureParams(eye, (IntPtr)textureManager.GetNativePtrLR(flag), textureParams, ref flag2);
		WVR_RenderFoveationParams wVR_RenderFoveationParams = (flag ? foveationParams[0] : foveationParams[1]);
		if (isDuringFirstFrame)
		{
			WVR_Log.Log.d(TAG, "FirstFrame : PreRenderEye +++");
		}
		RenderThreadContext.IssueBefore(RenderCommandBeforeEye[(int)eye], eye, 1, textureParams[0], textureParams[1], 2, wVR_RenderFoveationParams, wVR_RenderFoveationParams);
		if (isDuringFirstFrame)
		{
			WVR_Log.Log.d(TAG, "FirstFrame : PreRenderEye ---");
		}
		camera.enabled = true;
		camera.targetTexture = renderTextureLR;
		camera.rect = drawViewport;
		if (isDuringFirstFrame)
		{
			WVR_Log.Log.d(TAG, "FirstFrame : beforeRenderEye Callback +++");
		}
		SafeExecuteRenderEyeCallback(beforeRenderEye, eye, wvrCamera);
		if (isDuringFirstFrame)
		{
			WVR_Log.Log.d(TAG, "FirstFrame : beforeRenderEye Callback ---");
		}
		camera.Render();
		if (isDuringFirstFrame)
		{
			WVR_Log.Log.d(TAG, "FirstFrame : afterRenderEye Callback +++");
		}
		SafeExecuteRenderEyeCallback(afterRenderEye, eye, wvrCamera);
		if (isDuringFirstFrame)
		{
			WVR_Log.Log.d(TAG, "FirstFrame : afterRenderEye Callback ---");
		}
		camera.rect = Rect.MinMaxRect(0f, 0f, 1f, 1f);
		camera.enabled = false;
		renderTextureLR.DiscardContents(discardColor: false, discardDepth: true);
		if (isDuringFirstFrame)
		{
			WVR_Log.Log.d(TAG, "FirstFrame : SubmitFrame +++");
		}
		RenderThreadContext.IssueAfter(RenderCommandAfterEye[(int)eye], eye, 1, textureParams[0], textureParams[1], poseUsedOnSubmit.IsValidPose ? 1 : 0, poseUsedOnSubmit, flag2 | submitExtendFlag);
		if (isDuringFirstFrame)
		{
			WVR_Log.Log.d(TAG, "FirstFrame : SubmitFrame ---");
		}
		WaveVR_Utils.Trace.EndSection();
	}

	private static void AddRaycaster(GameObject obj)
	{
		PhysicsRaycaster physicsRaycaster = obj.GetComponent<PhysicsRaycaster>();
		if (physicsRaycaster == null)
		{
			physicsRaycaster = obj.AddComponent<PhysicsRaycaster>();
		}
		LayerMask eventMask = -1;
		eventMask.value = LayerMask.GetMask("Default", "TransparentFX", "Water");
		physicsRaycaster.eventMask = eventMask;
	}

	private WaveVR_Camera CreateCenterCamera()
	{
		WVR_Log.Log.d(TAG, "CreateEye(None)+");
		if (beforeEyeExpand != null)
		{
			WaveVR_Utils.SafeExecuteAllDelegate(beforeEyeExpand, delegate(RenderCallbackWithEye a)
			{
				a(this, WVR_Eye.WVR_Eye_None);
			});
			WVR_Log.Log.d(TAG, "CreateEye(None)+custom");
		}
		WaveVR_Camera vrcamera = centerWVRCamera;
		Camera component;
		if (vrcamera == null)
		{
			GameObject gameObject = new GameObject("Eye Center", typeof(Camera), typeof(WaveVR_Camera));
			gameObject.transform.SetParent(base.transform, worldPositionStays: false);
			gameObject.transform.localPosition = (eyes[0].pos + eyes[1].pos) / 2f;
			component = gameObject.GetComponent<Camera>();
			vrcamera = gameObject.GetComponent<WaveVR_Camera>();
			Camera component2 = GetComponent<Camera>();
			if (component2 != null)
			{
				component.CopyFrom(component2);
				component2.enabled = false;
			}
			else
			{
				component.stereoConvergence = 0f;
				component.stereoTargetEye = StereoTargetEyeMask.None;
				component.nearClipPlane = 0.01f;
				component.farClipPlane = 1000f;
				component.renderingPath = RenderingPath.Forward;
				component.allowMSAA = false;
				component.fieldOfView = 100f;
			}
		}
		component = vrcamera.GetCamera();
		component.allowHDR = false;
		component.allowDynamicResolution = false;
		component.stereoConvergence = 0f;
		component.stereoTargetEye = StereoTargetEyeMask.None;
		vrcamera.transform.localPosition = (eyes[0].pos + eyes[1].pos) / 2f;
		if (afterEyeExpand != null)
		{
			WVR_Log.Log.d(TAG, "CreateEye(None)-custom");
			WaveVR_Utils.SafeExecuteAllDelegate(afterEyeExpand, delegate(RenderCallbackWithEyeAndCamera a)
			{
				a(this, WVR_Eye.WVR_Eye_None, vrcamera);
			});
		}
		WVR_Log.Log.d(TAG, "CreateEye(None)-");
		return vrcamera;
	}

	private WaveVR_Camera CreateEyeBoth()
	{
		WVR_Log.Log.d(TAG, "CreateEye(Both)+");
		if (beforeEyeExpand != null)
		{
			WaveVR_Utils.SafeExecuteAllDelegate(beforeEyeExpand, delegate(RenderCallbackWithEye a)
			{
				a(this, WVR_Eye.WVR_Eye_Both);
			});
			WVR_Log.Log.d(TAG, "CreateEye(Both)+custom");
		}
		WaveVR_Camera vrcamera = botheyes;
		Camera camera;
		if (vrcamera == null)
		{
			GameObject gameObject = new GameObject("Eye Both", typeof(Camera), typeof(FlareLayer), typeof(WaveVR_Camera));
			gameObject.transform.SetParent(base.transform, worldPositionStays: false);
			camera = gameObject.GetComponent<Camera>();
			camera.CopyFrom(centerCamera);
			vrcamera = gameObject.GetComponent<WaveVR_Camera>();
		}
		else
		{
			camera = vrcamera.GetCamera();
		}
		vrcamera.eye = WVR_Eye.WVR_Eye_Both;
		if (Camera.main == null)
		{
			vrcamera.tag = "MainCamera";
		}
		else if (Camera.main == centerCamera)
		{
			centerCamera.tag = "Untagged";
			vrcamera.tag = "MainCamera";
		}
		camera.stereoTargetEye = StereoTargetEyeMask.Both;
		camera.stereoSeparation = ipd;
		camera.stereoConvergence = 0f;
		camera.allowHDR = false;
		camera.allowDynamicResolution = false;
		Matrix4x4 projection = GetProjection(projRawL, camera.nearClipPlane, camera.farClipPlane);
		Matrix4x4 projection2 = GetProjection(projRawR, camera.nearClipPlane, camera.farClipPlane);
		Vector3 pos = eyes[0].pos;
		Vector3 pos2 = eyes[1].pos;
		Vector3 vector = (pos + pos2) / 2f;
		vrcamera.transform.localPosition = vector;
		vrcamera.transform.localRotation = Quaternion.identity;
		vrcamera.SetEyesPosition(pos - vector, pos2 - vector);
		Matrix4x4 cull = MakeCullingProjectionMatrix(projRawL, projRawR, camera.nearClipPlane, camera.farClipPlane, pos, pos2);
		vrcamera.SetStereoProjectionMatrix(projection, projection2, cull);
		if (afterEyeExpand != null)
		{
			WVR_Log.Log.d(TAG, "CreateEye(Both)-custom");
			WaveVR_Utils.SafeExecuteAllDelegate(afterEyeExpand, delegate(RenderCallbackWithEyeAndCamera a)
			{
				a(this, WVR_Eye.WVR_Eye_Both, vrcamera);
			});
		}
		WVR_Log.Log.d(TAG, "CreateEye(Both)-");
		return vrcamera;
	}

	private WaveVR_Camera CreateEye(WVR_Eye eye)
	{
		WVR_Log.Log.d(TAG, string.Concat("CreateEye(", eye, ")+"));
		if (beforeEyeExpand != null)
		{
			WaveVR_Utils.SafeExecuteAllDelegate(beforeEyeExpand, delegate(RenderCallbackWithEye a)
			{
				a(this, eye);
			});
			WVR_Log.Log.d(TAG, string.Concat("CreateEye(", eye, ")+custom"));
		}
		bool flag = eye == WVR_Eye.WVR_Eye_Left;
		WaveVR_Camera vrcamera = (flag ? lefteye : righteye);
		Camera component;
		if (vrcamera == null)
		{
			GameObject gameObject = new GameObject(flag ? "Eye Left" : "Eye Right", typeof(Camera), typeof(FlareLayer), typeof(WaveVR_Camera));
			gameObject.transform.SetParent(base.transform, worldPositionStays: false);
			component = gameObject.GetComponent<Camera>();
			component.CopyFrom(centerCamera);
			vrcamera = gameObject.GetComponent<WaveVR_Camera>();
		}
		else
		{
			component = vrcamera.GetComponent<Camera>();
		}
		vrcamera.eye = eye;
		component.stereoTargetEye = StereoTargetEyeMask.None;
		component.stereoSeparation = ipd;
		component.stereoConvergence = 0f;
		component.enabled = false;
		component.transform.localPosition = eyes[(!flag) ? 1u : 0u].pos;
		component.allowHDR = false;
		component.allowDynamicResolution = false;
		float[] projRaw = (flag ? projRawL : projRawR);
		component.projectionMatrix = GetProjection(projRaw, component.nearClipPlane, component.farClipPlane);
		component.fieldOfView = GetFieldOfView(projRaw);
		if (afterEyeExpand != null)
		{
			WVR_Log.Log.d(TAG, string.Concat("CreateEye(", eye, ")-custom"));
			WaveVR_Utils.SafeExecuteAllDelegate(afterEyeExpand, delegate(RenderCallbackWithEyeAndCamera a)
			{
				a(this, eye, vrcamera);
			});
		}
		WVR_Log.Log.d(TAG, string.Concat("CreateEye(", eye, ")-"));
		return vrcamera;
	}

	private void createLoadingBlack()
	{
		if (GetComponentFromChildren<Canvas>("Loading") == null && useLoadingCanvas)
		{
			loadingCanvas = new GameObject("Loading");
			Canvas canvas = loadingCanvas.AddComponent<Canvas>();
			loadingCanvas.AddComponent<CanvasScaler>();
			canvas.renderMode = RenderMode.ScreenSpaceOverlay;
			GameObject obj = new GameObject("Loading Image");
			obj.transform.SetParent(loadingCanvas.transform, worldPositionStays: false);
			obj.AddComponent<CanvasRenderer>();
			Image image = obj.AddComponent<Image>();
			image.material = null;
			image.color = loadingBlockerColor;
			image.raycastTarget = false;
			image.rectTransform.anchoredPosition = new Vector2(0.5f, 0.5f);
			image.rectTransform.anchorMin = new Vector2(0f, 0f);
			image.rectTransform.anchorMax = new Vector2(1f, 1f);
			image.rectTransform.offsetMin = new Vector2(0f, 0f);
			image.rectTransform.offsetMax = new Vector2(0f, 0f);
			canvas.enabled = true;
			loadingCanvas.transform.SetParent(base.transform, worldPositionStays: true);
		}
	}

	private void setLoadingCanvas(bool enabled)
	{
		if ((bool)loadingCanvas)
		{
			loadingCanvas.SetActive(enabled);
		}
		else
		{
			GL.Clear(clearDepth: true, clearColor: true, loadingBlockerColor);
		}
	}

	public static void Expand(WaveVR_Render head)
	{
		WVR_Log.Log.d(TAG, "Expand()+");
		if (head.beforeRenderExpand != null)
		{
			WaveVR_Utils.SafeExecuteAllDelegate(head.beforeRenderExpand, delegate(RenderCallback a)
			{
				a(head);
			});
			WVR_Log.Log.d(TAG, "Expand()+custom");
		}
		_ = head.isExpanded;
		head.centerWVRCamera = head.CreateCenterCamera();
		head.botheyes = head.CreateEyeBoth();
		head.righteye = head.CreateEye(WVR_Eye.WVR_Eye_Right);
		head.lefteye = head.CreateEye(WVR_Eye.WVR_Eye_Left);
		if (head.GetComponentFromChildren<AudioListener>("Ear") == null)
		{
			GameObject gameObject = new GameObject("Ear");
			gameObject.transform.SetParent(head.transform, worldPositionStays: false);
			gameObject.transform.localPosition = new Vector3(0f, 0f, -0.01f);
			gameObject.AddComponent<AudioListener>();
			head.ear = gameObject;
		}
		AddRaycaster(head.centerCamera.gameObject);
		head.createLoadingBlack();
		if (head.afterRenderExpand != null)
		{
			WVR_Log.Log.d(TAG, "Expand()-custom");
			WaveVR_Utils.SafeExecuteAllDelegate(head.afterRenderExpand, delegate(RenderCallback a)
			{
				a(head);
			});
		}
		WVR_Log.Log.d(TAG, "Expand()-");
	}

	public static void Collapse(WaveVR_Render head)
	{
		if (head.lefteye != null)
		{
			UnityEngine.Object.DestroyImmediate(head.lefteye.gameObject);
		}
		head.lefteye = null;
		if (head.righteye != null)
		{
			UnityEngine.Object.DestroyImmediate(head.righteye.gameObject);
		}
		head.righteye = null;
		if (head.distortion != null)
		{
			UnityEngine.Object.DestroyImmediate(head.distortion.gameObject);
		}
		head.distortion = null;
		if (head.botheyes != null)
		{
			UnityEngine.Object.DestroyImmediate(head.botheyes.gameObject);
		}
		head.botheyes = null;
		if (head.centerWVRCamera != null)
		{
			UnityEngine.Object.DestroyImmediate(head.centerWVRCamera.gameObject);
		}
		head.centerWVRCamera = null;
		PhysicsRaycaster component = head.GetComponent<PhysicsRaycaster>();
		if (component != null)
		{
			UnityEngine.Object.DestroyImmediate(component);
		}
		component = null;
		if (head.loadingCanvas != null)
		{
			GameObject obj = head.loadingCanvas.gameObject;
			head.loadingCanvas = null;
			UnityEngine.Object.DestroyImmediate(obj);
		}
	}

	private float GetFieldOfView(float[] projRaw)
	{
		float num = 0f;
		for (int i = 0; i < projRaw.Length; i++)
		{
			num = Mathf.Max(Mathf.Abs(projRaw[i]), num);
		}
		return Mathf.Atan2(num, 1f) * 57.29578f * 2f;
	}

	private static float[] GetEditorProjectionRaw(float fov, float width, float height)
	{
		if (fov < 1f)
		{
			fov = 1f;
		}
		if (fov > 179f)
		{
			fov = 179f;
		}
		_ = Matrix4x4.identity;
		float num;
		float num2;
		if (height > width)
		{
			num = Mathf.Tan(fov / 2f * ((float)Math.PI / 180f));
			num2 = num / height * width;
		}
		else
		{
			num2 = Mathf.Tan(fov / 2f * ((float)Math.PI / 180f));
			num = num2 / width * height;
		}
		float num3 = 0f - num2;
		float num4 = num2;
		float num5 = num;
		float num6 = 0f - num;
		return new float[4] { num3, num4, num5, num6 };
	}

	public static void debugLogMatrix(Matrix4x4 m, string name)
	{
		WVR_Log.Log.d(TAG, name + ":\n/ " + m.m00 + " " + m.m01 + " " + m.m02 + " " + m.m03 + " \\\n| " + m.m10 + " " + m.m11 + " " + m.m12 + " " + m.m13 + " |\n| " + m.m20 + " " + m.m21 + " " + m.m22 + " " + m.m23 + " |\n\\ " + m.m30 + " " + m.m31 + " " + m.m32 + " " + m.m33 + " /");
	}

	private static Matrix4x4 MakeCullingProjectionMatrix(float[] projRawL, float[] projRawR, float near, float far, Vector3 leftEyePosition, Vector3 rightEyePosition, bool lrtbWithNear1 = false)
	{
		if (near < 0.01f)
		{
			near = 0.01f;
		}
		if (far < 0.02f)
		{
			far = 0.02f;
		}
		if (lrtbWithNear1)
		{
			for (int i = 0; i < 4; i++)
			{
				projRawL[i] *= near;
				projRawR[i] *= near;
			}
		}
		_ = Matrix4x4.identity;
		Vector3[] array = new Vector3[4]
		{
			new Vector3(projRawL[0], 0f, near),
			new Vector3(projRawL[1], 0f, near),
			new Vector3(0f, projRawL[2], near),
			new Vector3(0f, projRawL[3], near)
		};
		Vector3[] array2 = new Vector3[4]
		{
			new Vector3(projRawR[0], 0f, near),
			new Vector3(projRawR[1], 0f, near),
			new Vector3(0f, projRawR[2], near),
			new Vector3(0f, projRawR[3], near)
		};
		Vector3[] array3 = new Vector3[4]
		{
			new Vector3(-1f, 0f, 0f),
			new Vector3(1f, 0f, 0f),
			new Vector3(0f, 1f, 0f),
			new Vector3(0f, -1f, 0f)
		};
		float[] array4 = new float[4] { 1f, 1f, 1f, 1f };
		float[] array5 = new float[4] { near, near, near, near };
		float[] array6 = new float[4];
		for (int j = 0; j < 4; j++)
		{
			float a = Mathf.Abs(Vector3.Dot(array[j], array3[j])) / array[j].z;
			Vector3 vector = array[j] + Vector3.Dot(leftEyePosition, array3[j]) * array3[j];
			float num = Vector3.Distance(vector, new Vector3(0f, 0f, vector.z));
			float b = Mathf.Abs(Vector3.Dot(array2[j], array3[j])) / array2[j].z;
			Vector3 vector2 = array2[j] + Vector3.Dot(rightEyePosition, array3[j]) * array3[j];
			float num2 = Vector3.Distance(vector2, new Vector3(0f, 0f, vector2.z));
			array4[j] = Mathf.Max(a, b);
			array5[j] = Mathf.Max(num, num2);
			array6[j] = ((num > num2) ? vector : vector2).z - array5[j] / array4[j];
		}
		float num3 = 0f;
		for (int k = 0; k < 4; k++)
		{
			num3 = Mathf.Min(array6[k], num3);
		}
		Matrix4x4 matrix4x = MakeProjection((0f - array4[0]) / 2f, array4[1] / 2f, array4[2], 0f - array4[3], 0f - num3, far, lrtbWithNear1: true);
		Matrix4x4 matrix4x2 = Matrix4x4.TRS(new Vector3(0f, 0f, -3f), Quaternion.identity, Vector3.one);
		return matrix4x * matrix4x2;
	}

	private static Matrix4x4 GetProjection(float[] projRaw, float near, float far)
	{
		WVR_Log.Log.d(TAG, "GetProjection()");
		if (near < 0.01f)
		{
			near = 0.01f;
		}
		if (far < 0.02f)
		{
			far = 0.02f;
		}
		_ = Matrix4x4.identity;
		return MakeProjection(projRaw[0], projRaw[1], projRaw[2], projRaw[3], near, far, lrtbWithNear1: true);
	}

	public static Matrix4x4 MakeProjection(float l, float r, float t, float b, float n, float f, bool lrtbWithNear1 = false)
	{
		float num = (lrtbWithNear1 ? 1f : n);
		Matrix4x4 zero = Matrix4x4.zero;
		zero[0, 0] = 2f * num / (r - l);
		zero[1, 1] = 2f * num / (t - b);
		zero[0, 2] = (r + l) / (r - l);
		zero[1, 2] = (t + b) / (t - b);
		zero[2, 2] = (0f - (f + n)) / (f - n);
		zero[2, 3] = -2f * f * n / (f - n);
		zero[3, 2] = -1f;
		return zero;
	}

	private void TimeControl()
	{
		if (needTimeControl)
		{
			bool flag = !WaveVR.Instance.FocusCapturedBySystem;
			if (!previousInputFocus || !flag)
			{
				previousInputFocus = flag;
				Time.timeScale = (flag ? 1 : 0);
				WVR_Log.Log.d(TAG, "InputFocus " + flag.ToString() + "Time.timeScale " + Time.timeScale);
			}
		}
	}

	public void SafeExecuteRenderEyeCallback(RenderCallbackWithEyeAndCamera multi, WVR_Eye eye, WaveVR_Camera wvrCamera)
	{
		if (multi == null)
		{
			return;
		}
		try
		{
			multi(this, eye, wvrCamera);
		}
		catch (Exception ex)
		{
			WVR_Log.Log.e(TAG, ex.ToString(), logInEditor: true);
		}
	}

	public static void SetFoveatedRenderingParameter(WVR_Eye eye, float ndcFocalPointX, float ndcFocalPointY, float clearVisionFOV, WVR_PeripheralQuality peripheralQuality)
	{
		int num = ((eye != 0) ? 1 : 0);
		foveationParams[num].focalX = ndcFocalPointX;
		foveationParams[num].focalY = ndcFocalPointY;
		foveationParams[num].fovealFov = clearVisionFOV;
		foveationParams[num].periQuality = peripheralQuality;
	}

	public static void SetPoseUsedOnSubmit(WVR_PoseState_t pose)
	{
		poseUsedOnSubmit = pose;
	}

	public static void ResetPoseUsedOnSubmit()
	{
		poseUsedOnSubmit.IsValidPose = false;
	}

	public static void SetSubmitExtendedFlag(WVR_SubmitExtend flag)
	{
		submitExtendFlag = flag;
	}
}
public class WaveVR_RenderMask : MonoBehaviour
{
	private class Data
	{
		public WVR_Eye eye;

		public Camera camera;

		public WaveVR_Camera wvrCamera;

		public CommandBuffer cmdBuf;

		public Mesh mesh;

		public Data()
		{
			eye = WVR_Eye.WVR_Eye_Left;
			camera = null;
			wvrCamera = null;
			cmdBuf = null;
			mesh = null;
		}
	}

	public delegate void BeforeCreateMaskCommandBuffer(WaveVR_RenderMask renderMask);

	private static string TAG = "RenderMask";

	private List<Data> data = new List<Data>();

	private bool isGraphicReady;

	private bool isCameraReady;

	public Shader renderMaskShader;

	public Material renderMaskMaterial;

	public Mesh renderMaskMeshLeft;

	public Mesh renderMaskMeshRight;

	public Mesh renderMaskMeshBoth;

	private Color32 color = Color.black;

	public BeforeCreateMaskCommandBuffer beforeCreateMaskCommandBuffer;

	private bool CheckCameras()
	{
		if (data == null)
		{
			return false;
		}
		foreach (Data datum in data)
		{
			if (datum == null || datum.camera == null || datum.wvrCamera == null)
			{
				return false;
			}
		}
		return true;
	}

	private bool CheckCommandBuffers()
	{
		if (data == null)
		{
			return false;
		}
		foreach (Data datum in data)
		{
			if (datum == null || datum.cmdBuf == null)
			{
				return false;
			}
		}
		return true;
	}

	private void PrepareCameras(WaveVR_Render render)
	{
		if (isCameraReady)
		{
			return;
		}
		this.data.Clear();
		if (render.IsSinglePass)
		{
			if (render.botheyes == null)
			{
				return;
			}
			Data data = new Data();
			data.wvrCamera = WaveVR_Render.Instance.botheyes;
			data.eye = WVR_Eye.WVR_Eye_Both;
			data.camera = data.wvrCamera.GetCamera();
			this.data.Add(data);
		}
		else
		{
			if (render.lefteye == null || render.righteye == null)
			{
				return;
			}
			Data data2 = new Data();
			data2.wvrCamera = WaveVR_Render.Instance.lefteye;
			data2.eye = WVR_Eye.WVR_Eye_Left;
			data2.camera = data2.wvrCamera.GetCamera();
			this.data.Add(data2);
			data2 = new Data();
			data2.eye = WVR_Eye.WVR_Eye_Right;
			data2.wvrCamera = WaveVR_Render.Instance.righteye;
			data2.camera = data2.wvrCamera.GetCamera();
			this.data.Add(data2);
		}
		isCameraReady = true;
	}

	private void MyPreCull(Camera cam)
	{
		if (!CheckCommandBuffers())
		{
			createMaskCommandBuffer();
		}
	}

	private void MyPreRender(Camera cam)
	{
		if (!CheckCameras() || !CheckCommandBuffers())
		{
			return;
		}
		foreach (Data datum in data)
		{
			if (!(datum.camera != cam))
			{
				removeRenderMaskCommandBuffer(datum);
				addRenderMaskCommandBuffer(datum);
			}
		}
	}

	private void OnConfigurationChanged(WaveVR_Render render)
	{
		PrepareCameras(render);
	}

	private void OnEnable()
	{
		if ((bool)renderMaskShader || (bool)renderMaskMaterial || (bool)renderMaskMeshLeft || (bool)renderMaskMeshRight || (bool)renderMaskMeshBoth)
		{
			WVR_Log.Log.w(TAG, "Customized RenderMask. Non-Official.", logInEditor: true);
		}
		StartCoroutine("Initialization");
	}

	private void OnDisable()
	{
		StopCoroutine("Initialization");
		Camera.onPreCull = (Camera.CameraCallback)Delegate.Remove(Camera.onPreCull, new Camera.CameraCallback(MyPreCull));
		Camera.onPreRender = (Camera.CameraCallback)Delegate.Remove(Camera.onPreRender, new Camera.CameraCallback(MyPreRender));
		try
		{
			foreach (Data datum in data)
			{
				removeRenderMaskCommandBuffer(datum);
			}
			WaveVR_Render instance = WaveVR_Render.Instance;
			instance.onConfigurationChanged = (WaveVR_Render.RenderCallback)Delegate.Remove(instance.onConfigurationChanged, new WaveVR_Render.RenderCallback(OnConfigurationChanged));
		}
		catch (NullReferenceException)
		{
		}
		cleanData();
	}

	private IEnumerator Initialization()
	{
		WaveVR_Render render = null;
		while (!isCameraReady || !isGraphicReady)
		{
			render = WaveVR_Render.Instance;
			if (render == null)
			{
				yield return null;
				continue;
			}
			PrepareCameras(render);
			isGraphicReady = render.IsGraphicReady;
			if (!isCameraReady || !isGraphicReady)
			{
				yield return null;
			}
		}
		Camera.onPreCull = (Camera.CameraCallback)Delegate.Combine(Camera.onPreCull, new Camera.CameraCallback(MyPreCull));
		Camera.onPreRender = (Camera.CameraCallback)Delegate.Combine(Camera.onPreRender, new Camera.CameraCallback(MyPreRender));
		WaveVR_Render waveVR_Render = render;
		waveVR_Render.onConfigurationChanged = (WaveVR_Render.RenderCallback)Delegate.Combine(waveVR_Render.onConfigurationChanged, new WaveVR_Render.RenderCallback(OnConfigurationChanged));
		WVR_Log.Log.d(TAG, "RenderMask initialization finished");
	}

	public void SetMaskColor(Color32 c)
	{
		WVR_Log.Log.w(TAG, "Customized RenderMask. Non-Official color " + color, logInEditor: true);
		color = c;
	}

	private Mesh GetStencilMesh(WVR_Eye eye)
	{
		float[] array = null;
		int[] array2 = null;
		uint vertexCount = 0u;
		uint triangleCount = 0u;
		try
		{
			WaveVR_Utils.WVR_GetStencilMesh(eye, ref vertexCount, ref triangleCount, 0u, null, 0u, null);
			WVR_Log.Log.d(TAG, "vertexCount " + vertexCount + " triangleCount " + triangleCount);
			if (vertexCount == 0 || vertexCount > 255 || triangleCount == 0 || triangleCount > 255)
			{
				return null;
			}
			array = new float[vertexCount * 3];
			array2 = new int[triangleCount * 3];
			WaveVR_Utils.WVR_GetStencilMesh(eye, ref vertexCount, ref triangleCount, vertexCount * 3, array, triangleCount * 3, array2);
		}
		catch (EntryPointNotFoundException ex)
		{
			WVR_Log.Log.e(TAG, "API doesn't exist:\n" + ex.Message);
			return null;
		}
		int num = (int)(triangleCount * 3);
		if (array2 == null || array == null)
		{
			WVR_Log.Log.e(TAG, "Out of memory");
			return null;
		}
		float num2 = 0f;
		num2 = ((SystemInfo.graphicsDeviceType == GraphicsDeviceType.OpenGLES3 || SystemInfo.graphicsDeviceType == GraphicsDeviceType.OpenGLES2 || SystemInfo.graphicsDeviceType == GraphicsDeviceType.OpenGLCore) ? (-1f) : ((!SystemInfo.usesReversedZBuffer) ? 0f : 1f));
		Vector3[] array3 = new Vector3[vertexCount];
		int[] array4 = new int[num];
		for (int i = 0; i < vertexCount; i++)
		{
			array3[i] = new Vector3(array[3 * i], array[3 * i + 1], num2);
		}
		for (int j = 0; j < triangleCount; j++)
		{
			int num3 = j * 3;
			array4[num3] = array2[num3];
			array4[num3 + 1] = array2[num3 + 2];
			array4[num3 + 2] = array2[num3 + 1];
		}
		Mesh mesh = new Mesh();
		mesh.name = "RenderMask";
		mesh.vertices = array3;
		mesh.SetIndices(array4, MeshTopology.Triangles, 0);
		WVR_Log.Log.d(TAG, string.Concat("RenderMask ", eye, " is loaded"));
		return mesh;
	}

	private Mesh GetEyeBothMesh(Mesh l, Mesh r)
	{
		float num = Mathf.Max(Mathf.Abs(l.bounds.max.x), Mathf.Abs(r.bounds.min.x));
		Mesh mesh = new Mesh();
		mesh.name = "WaveVR_RenderMask_Both";
		CombineInstance combineInstance = default(CombineInstance);
		combineInstance.mesh = l;
		Matrix4x4 identity = Matrix4x4.identity;
		identity.SetTRS(Vector3.left * num, Quaternion.identity, Vector3.one);
		combineInstance.transform = identity;
		CombineInstance combineInstance2 = default(CombineInstance);
		combineInstance2.mesh = r;
		Matrix4x4 identity2 = Matrix4x4.identity;
		identity2.SetTRS(Vector3.right * num, Quaternion.identity, Vector3.one);
		combineInstance2.transform = identity2;
		CombineInstance[] combine = new CombineInstance[2] { combineInstance, combineInstance2 };
		mesh.CombineMeshes(combine);
		return mesh;
	}

	private void createMaskCommandBuffer()
	{
		WaveVR_Utils.SafeExecuteAllDelegate(beforeCreateMaskCommandBuffer, delegate(BeforeCreateMaskCommandBuffer a)
		{
			a(this);
		});
		if (renderMaskShader == null)
		{
			renderMaskShader = Shader.Find("Hidden/WaveVR/RenderMask");
		}
		if (renderMaskMaterial == null && renderMaskShader != null)
		{
			renderMaskMaterial = new Material(renderMaskShader);
			renderMaskMaterial.SetColor("_Color", color);
		}
		if (renderMaskMaterial == null)
		{
			WVR_Log.Log.e(TAG, "RenderMask Shader not found");
			return;
		}
		if (renderMaskMeshLeft == null || renderMaskMeshRight == null)
		{
			renderMaskMeshLeft = GetStencilMesh(WVR_Eye.WVR_Eye_Left);
			renderMaskMeshRight = GetStencilMesh(WVR_Eye.WVR_Eye_Right);
		}
		if (renderMaskMeshLeft == null || renderMaskMeshRight == null)
		{
			WVR_Log.Log.w(TAG, "RenderMask resource not exist. Disable RenderMask.");
			base.enabled = false;
			return;
		}
		if (renderMaskMeshBoth == null)
		{
			renderMaskMeshBoth = GetEyeBothMesh(renderMaskMeshLeft, renderMaskMeshRight);
			float value = Mathf.Max(Mathf.Abs(renderMaskMeshLeft.bounds.max.x), Mathf.Abs(renderMaskMeshRight.bounds.min.x));
			renderMaskMaterial.SetFloat("MeshXOffset", value);
		}
		foreach (Data datum in data)
		{
			if (datum.eye == WVR_Eye.WVR_Eye_Left)
			{
				CommandBuffer commandBuffer = new CommandBuffer();
				commandBuffer.name = "WVRMaskLeft";
				commandBuffer.DrawMesh(renderMaskMeshLeft, Matrix4x4.identity, renderMaskMaterial, 0, 0);
				datum.cmdBuf = commandBuffer;
			}
			else if (datum.eye == WVR_Eye.WVR_Eye_Right)
			{
				CommandBuffer commandBuffer2 = new CommandBuffer();
				commandBuffer2.name = "WVRMaskRight";
				commandBuffer2.DrawMesh(renderMaskMeshRight, Matrix4x4.identity, renderMaskMaterial, 0, 0);
				datum.cmdBuf = commandBuffer2;
			}
			else if (datum.eye == WVR_Eye.WVR_Eye_Both)
			{
				CommandBuffer commandBuffer3 = new CommandBuffer();
				commandBuffer3.name = "WVRMaskBoth";
				commandBuffer3.DrawMesh(renderMaskMeshBoth, Matrix4x4.identity, renderMaskMaterial, 0, 1);
				datum.cmdBuf = commandBuffer3;
			}
		}
	}

	private void addRenderMaskCommandBuffer(Data d)
	{
		d.camera.AddCommandBuffer(CameraEvent.BeforeForwardOpaque, d.cmdBuf);
	}

	private void removeRenderMaskCommandBuffer(Data d)
	{
		try
		{
			d.camera.RemoveCommandBuffer(CameraEvent.BeforeForwardOpaque, d.cmdBuf);
		}
		catch (MissingReferenceException ex)
		{
			WVR_Log.Log.e(TAG, ex.ToString());
			cleanData();
		}
	}

	private void cleanData()
	{
		data.Clear();
		renderMaskMeshLeft = null;
		renderMaskMeshRight = null;
		renderMaskMeshBoth = null;
		renderMaskShader = null;
		renderMaskMaterial = null;
		isGraphicReady = false;
		isCameraReady = false;
	}
}
[RequireComponent(typeof(Renderer))]
public class WaveVR_Reticle : MonoBehaviour
{
	public bool ListenToDevice;

	private const string LOG_TAG = "WaveVR_Reticle";

	public WaveVR_Controller.EDeviceType device;

	public int reticleSegments = 20;

	public float reticleGrowthSpeed = 8f;

	public Color reticleColor = Color.white;

	public bool colorFlickerPerSecond;

	public bool deepeningColorRotation;

	public int rotationSpeed = 6;

	public float reticleInnerDiameter;

	public float reticleOuterDiameter = 0.005236002f;

	public float interactObjInnerDiameter = 0.02094472f;

	public float interactObjOuterDiameter = 0.02618144f;

	public float kReticleDistanceMax = 10f;

	private Material materialComp;

	private Mesh mesh;

	private float reticleDistanceInMeters = 10f;

	private const float kReticleDistanceMin = 1f;

	private float reticleInnerAngle;

	private float reticleOuterAngle = 0.3f;

	private float kReticleMinInnerAngle;

	private float kReticleMinOuterAngle = 0.3f;

	private float kReticleGrowthInnerAngle = 1.2f;

	private float kReticleGrowthOuterAngle = 1.2f;

	private Color colorFactor = Color.black;

	private float colorFlickerTime;

	private float progressTime;

	private bool isTriggerProgress;

	private int rotSpeedLimit = 36;

	private bool enabledReticle = true;

	private bool meshIsCreated;

	private int internalRotationSpeed;

	private int colorIter;

	private float[] colorRotation;

	private int[] rotSpeedBound;

	private MaterialPropertyBlock materialProperty;

	private const float reticleInnerDiameterMin = 0f;

	private const float reticleInnerDiameterMax = 0.0002f;

	private const float reticleOuterDiameterMin = 0.005f;

	private const float reticleOuterDiameterMax = 0.01f;

	private const float interactObjInnerDiameterMin = 0.015f;

	private const float interactObjInnerDiameterMax = 0.022f;

	private const float interactObjOuterDiameterMin = 0.026f;

	private const float interactObjOuterDiameterMax = 0.035f;

	private const float kReticleDistanceValidateMax = 10f;

	private void DEBUG(string msg)
	{
		if (WVR_Log.Log.EnableDebugLog)
		{
			WVR_Log.Log.d("WaveVR_Reticle", msg, logInEditor: true);
		}
	}

	private void Start()
	{
		ReadJsonValues();
		Validate();
		if (enabledReticle)
		{
			if (!meshIsCreated)
			{
				initialReticle();
			}
		}
		else if (meshIsCreated)
		{
			removeReticle();
		}
	}

	private void setReticleAngle()
	{
		reticleInnerAngle = Mathf.Atan(reticleInnerDiameter) * 180f / (float)Math.PI;
		kReticleMinInnerAngle = reticleInnerAngle;
		reticleOuterAngle = Mathf.Atan(reticleOuterDiameter) * 180f / (float)Math.PI;
		kReticleMinOuterAngle = reticleOuterAngle;
		float num = Mathf.Atan(interactObjInnerDiameter) * 180f / (float)Math.PI;
		float num2 = Mathf.Atan(interactObjOuterDiameter) * 180f / (float)Math.PI;
		kReticleGrowthInnerAngle = num - kReticleMinInnerAngle;
		kReticleGrowthOuterAngle = num2 - kReticleMinOuterAngle;
	}

	private void Update()
	{
		if (ListenToDevice)
		{
			enabledReticle = WaveVR_Controller.Input(device).connected;
		}
		if (enabledReticle)
		{
			if (!meshIsCreated)
			{
				initialReticle();
			}
			reticleDistanceInMeters = Mathf.Clamp(reticleDistanceInMeters, 1f, kReticleDistanceMax);
			if (reticleInnerAngle < kReticleMinInnerAngle)
			{
				reticleInnerAngle = kReticleMinInnerAngle;
			}
			if (reticleOuterAngle < kReticleMinOuterAngle)
			{
				reticleOuterAngle = kReticleMinOuterAngle;
			}
			float f = (float)Math.PI / 180f * reticleInnerAngle * 0.5f;
			float f2 = (float)Math.PI / 180f * reticleOuterAngle * 0.5f;
			float b = 2f * Mathf.Tan(f);
			float b2 = 2f * Mathf.Tan(f2);
			if (rotationSpeed < 1)
			{
				rotationSpeed = 1;
			}
			if (internalRotationSpeed != rotationSpeed * 4)
			{
				UpdateRotSpeedBound(rotationSpeed * 4);
			}
			if (colorFlickerPerSecond)
			{
				if (Time.unscaledTime - colorFlickerTime >= 1f)
				{
					colorFlickerTime = Time.unscaledTime;
					if (isTriggerProgress)
					{
						colorFactor = (deepeningColorRotation ? Color.Lerp(Color.white, (reticleColor == Color.white) ? Color.black : reticleColor, progressTime / 100f) : reticleColor);
					}
					else if (reticleColor != Color.white)
					{
						colorFactor = Color.white;
					}
					else
					{
						colorFactor = Color.black;
					}
				}
				else if (isTriggerProgress)
				{
					colorFactor = (deepeningColorRotation ? Color.Lerp(Color.white, (reticleColor == Color.white) ? Color.black : reticleColor, progressTime / 100f) : reticleColor);
				}
				else
				{
					colorFactor = reticleColor;
				}
			}
			else if (isTriggerProgress)
			{
				colorFactor = (deepeningColorRotation ? Color.Lerp(Color.white, (reticleColor == Color.white) ? Color.black : reticleColor, progressTime / 100f) : reticleColor);
			}
			else
			{
				colorFactor = reticleColor;
			}
			int num = colorIter % internalRotationSpeed;
			if (num >= rotSpeedBound[0] && num <= rotSpeedBound[1])
			{
				colorRotation[0] = 1f;
				colorRotation[1] = 0f;
				colorRotation[2] = 0f;
				colorRotation[3] = 0f;
			}
			else if (num >= rotSpeedBound[2] && num <= rotSpeedBound[3])
			{
				colorRotation[0] = 0f;
				colorRotation[1] = 1f;
				colorRotation[2] = 0f;
				colorRotation[3] = 0f;
			}
			else if (num >= rotSpeedBound[4] && num <= rotSpeedBound[5])
			{
				colorRotation[0] = 0f;
				colorRotation[1] = 0f;
				colorRotation[2] = 1f;
				colorRotation[3] = 0f;
			}
			else if (num >= rotSpeedBound[6] && num <= rotSpeedBound[7])
			{
				colorRotation[0] = 0f;
				colorRotation[1] = 0f;
				colorRotation[2] = 0f;
				colorRotation[3] = 1f;
			}
			if (materialProperty == null)
			{
				materialProperty = new MaterialPropertyBlock();
			}
			materialProperty.SetFloatArray("colorRotFactor", colorRotation);
			base.gameObject.GetComponent<Renderer>().SetPropertyBlock(materialProperty);
			materialComp.SetColor("_Color", colorFactor);
			colorIter = (colorIter + 1) % internalRotationSpeed;
			reticleInnerDiameter = Mathf.Lerp(reticleInnerDiameter, b, Time.deltaTime * reticleGrowthSpeed);
			reticleOuterDiameter = Mathf.Lerp(reticleOuterDiameter, b2, Time.deltaTime * reticleGrowthSpeed);
			materialComp.SetFloat("_InnerDiameter", reticleInnerDiameter * reticleDistanceInMeters);
			materialComp.SetFloat("_OuterDiameter", reticleOuterDiameter * reticleDistanceInMeters);
			materialComp.SetFloat("_DistanceInMeters", reticleDistanceInMeters);
		}
		else if (meshIsCreated)
		{
			removeReticle();
		}
	}

	private void initialReticle()
	{
		CreateGazePointer();
		setReticleAngle();
		colorFlickerTime = Time.unscaledTime;
		materialComp = base.gameObject.GetComponent<Renderer>().material;
		UpdateRotSpeedBound(rotationSpeed * 4);
		meshIsCreated = true;
	}

	private void removeReticle()
	{
		mesh.Clear();
		meshIsCreated = false;
	}

	private void CreateGazePointer()
	{
		Vector3[] array = new Vector3[(reticleSegments + 1) * 2];
		int num = 0;
		for (int i = 0; i <= reticleSegments; i++)
		{
			float f = (float)i / (float)reticleSegments * (float)Math.PI * 2f;
			float x = Mathf.Sin(f);
			float y = Mathf.Cos(f);
			array[num++] = new Vector3(x, y, 0f);
			array[num++] = new Vector3(x, y, 1f);
		}
		int[] array2 = new int[(reticleSegments + 1) * 6];
		int num2 = 0;
		int num3 = 0;
		for (int j = 0; j < reticleSegments; j++)
		{
			array2[num3++] = num2 + 1;
			array2[num3++] = num2;
			array2[num3++] = num2 + 2;
			array2[num3++] = num2 + 1;
			array2[num3++] = num2 + 2;
			array2[num3++] = num2 + 3;
			num2 += 2;
		}
		mesh = new Mesh();
		base.gameObject.AddComponent<MeshFilter>();
		GetComponent<MeshFilter>().mesh = mesh;
		mesh.vertices = array;
		mesh.triangles = array2;
		mesh.RecalculateBounds();
	}

	private void UpdateRotSpeedBound(int speedSetting)
	{
		internalRotationSpeed = ((speedSetting <= rotSpeedLimit) ? speedSetting : rotSpeedLimit);
		colorRotation = new float[4];
		rotSpeedBound = new int[8];
		rotSpeedBound[0] = 0;
		rotSpeedBound[1] = internalRotationSpeed / 4 - 1;
		rotSpeedBound[2] = internalRotationSpeed / 4;
		rotSpeedBound[3] = internalRotationSpeed / 2 - 1;
		rotSpeedBound[4] = internalRotationSpeed / 2;
		rotSpeedBound[5] = internalRotationSpeed / 4 * 3 - 1;
		rotSpeedBound[6] = internalRotationSpeed / 4 * 3;
		rotSpeedBound[7] = internalRotationSpeed - 1;
	}

	public void ShowReticle()
	{
		enabledReticle = true;
	}

	public void RemoveReticle()
	{
		enabledReticle = false;
	}

	public void SetColorFlicker(bool switchOn)
	{
		colorFlickerPerSecond = switchOn;
	}

	public bool GetColorFlicker()
	{
		return colorFlickerPerSecond;
	}

	public void OnGazeEnter(Camera camera, GameObject target, Vector3 intersectionPosition, bool isInteractive)
	{
		SetGazeTarget(intersectionPosition, isInteractive);
	}

	public void OnGazeStay(Camera camera, GameObject target, Vector3 intersectionPosition, bool isInteractive)
	{
		SetGazeTarget(intersectionPosition, isInteractive);
	}

	public void OnGazeExit(Camera camera, GameObject target)
	{
		reticleDistanceInMeters = kReticleDistanceMax;
		reticleInnerAngle = kReticleMinInnerAngle;
		reticleOuterAngle = kReticleMinOuterAngle;
	}

	public void OnGazeTriggerStart(Camera camera)
	{
	}

	public void OnGazeTriggerEnd(Camera camera)
	{
	}

	public void GetPointerRadius(out float innerRadius, out float outerRadius)
	{
		float f = (float)Math.PI / 180f * kReticleMinInnerAngle;
		float f2 = (float)Math.PI / 180f * (kReticleMinInnerAngle + kReticleGrowthInnerAngle);
		innerRadius = 2f * Mathf.Tan(f);
		outerRadius = 2f * Mathf.Tan(f2);
	}

	public void setProgressBarTime(float time)
	{
		progressTime = time;
	}

	public float getReticleCurrentDistance()
	{
		return reticleDistanceInMeters;
	}

	public void triggerProgressBar(bool switchOn)
	{
		isTriggerProgress = switchOn;
		if (enabledReticle)
		{
			materialComp.SetFloat("_TriggerProgress", isTriggerProgress ? 1f : 0f);
		}
	}

	private void SetGazeTarget(Vector3 target, bool interactive)
	{
		reticleDistanceInMeters = Mathf.Clamp(base.transform.InverseTransformPoint(target).z, 1f, kReticleDistanceMax);
		if (interactive)
		{
			reticleInnerAngle = kReticleMinInnerAngle + kReticleGrowthInnerAngle;
			reticleOuterAngle = kReticleMinOuterAngle + kReticleGrowthOuterAngle;
		}
		else
		{
			reticleInnerAngle = kReticleMinInnerAngle;
			reticleOuterAngle = kReticleMinOuterAngle;
		}
	}

	public void SetReticleColor(Color reticle_color)
	{
		reticleColor = reticle_color;
	}

	private void ReadJsonValues()
	{
		DEBUG("reticleInnerDiameter: " + reticleInnerDiameter + ", reticleOuterDiameter: " + reticleOuterDiameter + ", interactObjInnerDiameter: " + interactObjInnerDiameter + ", interactObjOuterDiameter: " + interactObjOuterDiameter + ", kReticleDistanceMax: " + kReticleDistanceMax + ", reticleSegments: " + reticleSegments + ", reticleColor: " + reticleColor.ToString() + ", rotationSpeed: " + rotationSpeed + ", colorFlickerPerSecond: " + colorFlickerPerSecond.ToString() + ", deepeningColorRotation: " + deepeningColorRotation.ToString());
		string controllerConfig = WaveVR_Utils.OEMConfig.getControllerConfig();
		if (controllerConfig.Equals(""))
		{
			return;
		}
		try
		{
			JSONNode jSONNode = JSONNode.Parse(controllerConfig);
			string text = "";
			text = jSONNode["reticle"]["inner_diameter"].Value;
			if (!text.Equals("") && IsFloat(text))
			{
				reticleInnerDiameter = float.Parse(text);
			}
			text = jSONNode["reticle"]["outer_diameter"].Value;
			if (!text.Equals("") && IsFloat(text))
			{
				reticleOuterDiameter = float.Parse(text);
			}
			text = jSONNode["reticle"]["interact_object_inner_diameter"].Value;
			if (!text.Equals("") && IsFloat(text))
			{
				interactObjInnerDiameter = float.Parse(text);
			}
			text = jSONNode["reticle"]["interact_object_outer_diameter"].Value;
			if (!text.Equals("") && IsFloat(text))
			{
				interactObjOuterDiameter = float.Parse(text);
			}
			text = jSONNode["reticle"]["distance"].Value;
			if (!text.Equals("") && IsFloat(text))
			{
				kReticleDistanceMax = float.Parse(text);
			}
			text = jSONNode["reticle"]["segment"].Value;
			if (!text.Equals("") && IsNumeric(text))
			{
				reticleSegments = int.Parse(text);
			}
			text = jSONNode["reticle"]["color"].Value;
			if (!text.Equals(""))
			{
				reticleColor = StringToColor32(text);
			}
			text = jSONNode["reticle"]["rotation_speed"].Value;
			if (!text.Equals("") && IsNumeric(text))
			{
				rotationSpeed = int.Parse(text);
			}
			text = jSONNode["reticle"]["colorFlicker"].Value;
			if (!text.Equals("") && IsBoolean(text))
			{
				colorFlickerPerSecond = bool.Parse(text);
			}
			text = jSONNode["reticle"]["deepening_color_rotation"].Value;
			if (!text.Equals("") && IsBoolean(text))
			{
				deepeningColorRotation = bool.Parse(text);
			}
			DEBUG("reticleInnerDiameter: " + reticleInnerDiameter + ", reticleOuterDiameter: " + reticleOuterDiameter + ", interactObjInnerDiameter: " + interactObjInnerDiameter + ", interactObjOuterDiameter: " + interactObjOuterDiameter + ", kReticleDistanceMax: " + kReticleDistanceMax + ", reticleSegments: " + reticleSegments + ", reticleColor: " + reticleColor.ToString() + ", rotationSpeed: " + rotationSpeed + ", colorFlickerPerSecond: " + colorFlickerPerSecond.ToString() + ", deepeningColorRotation: " + deepeningColorRotation.ToString());
		}
		catch (Exception ex)
		{
			WVR_Log.Log.e("WaveVR_Reticle", "JsonParse failed: " + ex.ToString());
		}
	}

	private bool IsBoolean(string value)
	{
		try
		{
			DEBUG(value + " Convert to bool success: " + Convert.ToBoolean(value));
			return true;
		}
		catch (Exception ex)
		{
			WVR_Log.Log.e("WaveVR_Reticle", value + " Convert to bool failed: " + ex.ToString());
			return false;
		}
	}

	private bool IsFloat(string value)
	{
		try
		{
			DEBUG(value + " Convert to float success: " + Convert.ToSingle(value));
			return true;
		}
		catch (Exception ex)
		{
			WVR_Log.Log.e("WaveVR_Reticle", value + " Convert to float failed: " + ex.ToString());
			return false;
		}
	}

	private bool IsNumeric(string value)
	{
		try
		{
			DEBUG(value + " Convert to int success: " + Convert.ToInt32(value));
			return true;
		}
		catch (Exception ex)
		{
			WVR_Log.Log.e("WaveVR_Reticle", value + " Convert to Int failed: " + ex.StackTrace.ToString());
			return false;
		}
	}

	private void Validate()
	{
		if (reticleInnerDiameter < 0f)
		{
			reticleInnerDiameter = 0f;
		}
		if (reticleInnerDiameter > 0.0002f)
		{
			reticleInnerDiameter = 0.0002f;
		}
		if (reticleOuterDiameter < 0.005f)
		{
			reticleOuterDiameter = 0.005f;
		}
		if (reticleOuterDiameter > 0.01f)
		{
			reticleOuterDiameter = 0.01f;
		}
		if (interactObjInnerDiameter < 0.015f)
		{
			interactObjInnerDiameter = 0.015f;
		}
		if (interactObjInnerDiameter > 0.022f)
		{
			interactObjInnerDiameter = 0.022f;
		}
		if (interactObjOuterDiameter < 0.026f)
		{
			interactObjOuterDiameter = 0.026f;
		}
		if (interactObjOuterDiameter > 0.035f)
		{
			interactObjOuterDiameter = 0.035f;
		}
		if (kReticleDistanceMax > 10f)
		{
			kReticleDistanceMax = 10f;
		}
	}

	private Color32 StringToColor32(string color_string)
	{
		try
		{
			byte[] bytes = BitConverter.GetBytes(Convert.ToInt32(color_string.Substring(1, 2), 16));
			byte[] bytes2 = BitConverter.GetBytes(Convert.ToInt32(color_string.Substring(3, 2), 16));
			byte[] bytes3 = BitConverter.GetBytes(Convert.ToInt32(color_string.Substring(5, 2), 16));
			return new Color32(a: BitConverter.GetBytes(Convert.ToInt32(color_string.Substring(7, 2), 16))[0], r: bytes[0], g: bytes2[0], b: bytes3[0]);
		}
		catch (Exception ex)
		{
			WVR_Log.Log.e("WaveVR_Reticle", "StringToColor32: " + ex.ToString());
			return Color.white;
		}
	}
}
public class WaveVR_Screenshot
{
	private static string LOG_TAG = "WaveVR_Screenshot";

	private static void PrintDebugLog(string msg)
	{
		WVR_Log.Log.d(LOG_TAG, msg);
	}

	public static bool requestScreenshot(WVR_ScreenshotMode mode, string filename)
	{
		uint width = 0u;
		uint height = 0u;
		IntPtr filename2 = Marshal.StringToHGlobalAnsi(filename);
		Interop.WVR_GetRenderTargetSize(ref width, ref height);
		PrintDebugLog(string.Concat("Width = ", width, ", Height = ", height, ", Mode = ", mode, ", File name = ", filename));
		return Interop.WVR_RequestScreenshot(width, height, mode, filename2);
	}
}
[Obsolete("WaveVR_TrackedButtons is deprecated. Please use WaveVR_Controller or WaveVRPlayer instead.")]
public class WaveVR_TrackedButtons : MonoBehaviour
{
	public struct ClickedEventArgs
	{
		public WVR_DeviceType device;

		public uint flags;

		public Vector2 axis;
	}

	public delegate void ClickedEventHandler(object sender, ClickedEventArgs e);

	public const string LOG_TAG = "WaveVR_TrackedButtons";

	public static ulong Input_Mask_Menu = 2uL;

	public static ulong Input_Mask_Grip = 4uL;

	public static ulong Input_Mask_DPad_Left = 8uL;

	public static ulong Input_Mask_DPad_Up = 16uL;

	public static ulong Input_Mask_DPad_Right = 32uL;

	public static ulong Input_Mask_DPad_Down = 64uL;

	public static ulong Input_Mask_Volume_Up = 128uL;

	public static ulong Input_Mask_Volume_Down = 256uL;

	public static ulong Input_Mask_Hmd_Enter = 32768uL;

	public static ulong Input_Mask_Touchpad = 65536uL;

	public static ulong Input_Mask_Trigger = 131072uL;

	public static ulong Input_Mask_DigitalTrigger = 512uL;

	public WaveVR_Controller.EDeviceType device;

	private bool triggerPressed;

	private bool menuPressed;

	private bool padPressed;

	private bool gripPressed;

	private bool padTouched;

	private bool hmdEnterPressed;

	private uint inputMask = 7u;

	public event ClickedEventHandler MenuButtonClicked;

	public event ClickedEventHandler MenuButtonUnclicked;

	public event ClickedEventHandler TriggerClicked;

	public event ClickedEventHandler TriggerUnclicked;

	public event ClickedEventHandler PadClicked;

	public event ClickedEventHandler PadUnclicked;

	public event ClickedEventHandler PadTouched;

	public event ClickedEventHandler PadUntouched;

	public event ClickedEventHandler Gripped;

	public event ClickedEventHandler Ungripped;

	public event ClickedEventHandler HmdEnterClicked;

	public event ClickedEventHandler HmdEnterUnclicked;

	public virtual void OnTriggerClicked(ClickedEventArgs e)
	{
		WVR_Log.Log.i("WaveVR_TrackedButtons", "OnTriggerClicked!");
		if (this.TriggerClicked != null)
		{
			this.TriggerClicked(this, e);
		}
	}

	public virtual void OnTriggerUnclicked(ClickedEventArgs e)
	{
		WVR_Log.Log.i("WaveVR_TrackedButtons", "OnTriggerUnclicked!");
		if (this.TriggerUnclicked != null)
		{
			this.TriggerUnclicked(this, e);
		}
	}

	public virtual void OnMenuClicked(ClickedEventArgs e)
	{
		WVR_Log.Log.i("WaveVR_TrackedButtons", "OnMenuClicked!");
		if (this.MenuButtonClicked != null)
		{
			this.MenuButtonClicked(this, e);
		}
	}

	public virtual void OnMenuUnclicked(ClickedEventArgs e)
	{
		WVR_Log.Log.i("WaveVR_TrackedButtons", "OnMenuUnclicked!");
		if (this.MenuButtonUnclicked != null)
		{
			this.MenuButtonUnclicked(this, e);
		}
	}

	public virtual void OnPadClicked(ClickedEventArgs e)
	{
		WVR_Log.Log.i("WaveVR_TrackedButtons", "OnPadClicked!");
		if (this.PadClicked != null)
		{
			this.PadClicked(this, e);
		}
	}

	public virtual void OnPadUnclicked(ClickedEventArgs e)
	{
		WVR_Log.Log.i("WaveVR_TrackedButtons", "OnPadUnclicked!");
		if (this.PadUnclicked != null)
		{
			this.PadUnclicked(this, e);
		}
	}

	public virtual void OnPadTouched(ClickedEventArgs e)
	{
		WVR_Log.Log.i("WaveVR_TrackedButtons", "OnPadTouched!");
		if (this.PadTouched != null)
		{
			this.PadTouched(this, e);
		}
	}

	public virtual void OnPadUntouched(ClickedEventArgs e)
	{
		WVR_Log.Log.i("WaveVR_TrackedButtons", "OnPadUntouched!");
		if (this.PadUntouched != null)
		{
			this.PadUntouched(this, e);
		}
	}

	public virtual void OnGripped(ClickedEventArgs e)
	{
		WVR_Log.Log.i("WaveVR_TrackedButtons", "OnGripped!");
		if (this.Gripped != null)
		{
			this.Gripped(this, e);
		}
	}

	public virtual void OnUngripped(ClickedEventArgs e)
	{
		WVR_Log.Log.i("WaveVR_TrackedButtons", "OnUngripped!");
		if (this.Ungripped != null)
		{
			this.Ungripped(this, e);
		}
	}

	public virtual void OnHmdEnterClicked(ClickedEventArgs e)
	{
		WVR_Log.Log.i("WaveVR_TrackedButtons", "OnHmdEnterClicked!");
		if (this.HmdEnterClicked != null)
		{
			this.HmdEnterClicked(this, e);
		}
	}

	public virtual void OnHmdEnterUnclicked(ClickedEventArgs e)
	{
		WVR_Log.Log.i("WaveVR_TrackedButtons", "OnHmdEnterUnclicked!");
		if (this.HmdEnterUnclicked != null)
		{
			this.HmdEnterUnclicked(this, e);
		}
	}

	private Vector2 GetAxis(WVR_AnalogState_t[] analogArray, WVR_InputId _id, WVR_AnalogType aType, int _count)
	{
		Vector2 zero = Vector2.zero;
		if (_count > 0)
		{
			for (int i = 0; i < _count; i++)
			{
				if (analogArray[i].id == _id && analogArray[i].type == aType)
				{
					zero.x = analogArray[i].axis.x;
					zero.y = ((_id == WVR_InputId.WVR_InputId_17) ? 0f : analogArray[i].axis.y);
					break;
				}
				WVR_Log.Log.e("WaveVR_TrackedButtons", string.Concat("GetAxis() states unsynchronized! device: ", device, ", analogArray[", i, "].id: ", analogArray[i].id, ", analogArray[", i, "].type]: ", analogArray[i].type));
			}
		}
		else
		{
			WVR_Log.Log.e("WaveVR_TrackedButtons", "GetAxis() no axis!!");
		}
		return zero;
	}

	private void Update()
	{
		if (!WaveVR.Instance.Initialized || WaveVR.Instance.FocusCapturedBySystem || !WaveVR_Controller.Input(device).connected)
		{
			return;
		}
		WVR_DeviceType deviceType = WaveVR_Controller.Input(device).DeviceType;
		uint buttons = 0u;
		uint touches = 0u;
		uint num = (uint)Interop.WVR_GetInputTypeCount(deviceType, WVR_InputType.WVR_InputType_Analog);
		WVR_AnalogState_t[] analogArray = new WVR_AnalogState_t[num];
		if (Interop.WVR_GetInputDeviceState(deviceType, inputMask, ref buttons, ref touches, analogArray, num))
		{
			ClickedEventArgs e = default(ClickedEventArgs);
			e.device = deviceType;
			e.flags = buttons;
			e.axis = Vector2.zero;
			if (buttons != 0)
			{
				long num2 = buttons;
				if (((ulong)num2 & Input_Mask_Trigger) != 0L && !triggerPressed)
				{
					triggerPressed = true;
					e.axis = GetAxis(analogArray, WVR_InputId.WVR_InputId_17, WVR_AnalogType.WVR_AnalogType_1D, (int)num);
					OnTriggerClicked(e);
				}
				if (((ulong)num2 & Input_Mask_Grip) != 0L && !gripPressed)
				{
					gripPressed = true;
					OnGripped(e);
				}
				if (((ulong)num2 & Input_Mask_Touchpad) != 0L && !padPressed)
				{
					e.axis = GetAxis(analogArray, WVR_InputId.WVR_InputId_16, WVR_AnalogType.WVR_AnalogType_2D, (int)num);
					padPressed = true;
					OnPadClicked(e);
				}
				if (((ulong)num2 & Input_Mask_Menu) != 0L && !menuPressed)
				{
					menuPressed = true;
					OnMenuClicked(e);
				}
				if (((ulong)num2 & Input_Mask_Hmd_Enter) != 0L && !hmdEnterPressed)
				{
					hmdEnterPressed = true;
					OnHmdEnterClicked(e);
				}
			}
			else
			{
				if (triggerPressed)
				{
					triggerPressed = false;
					OnTriggerUnclicked(e);
				}
				if (gripPressed)
				{
					gripPressed = false;
					OnUngripped(e);
				}
				if (padPressed)
				{
					padPressed = false;
					OnPadUnclicked(e);
				}
				if (menuPressed)
				{
					menuPressed = false;
					OnMenuUnclicked(e);
				}
				if (hmdEnterPressed)
				{
					hmdEnterPressed = false;
					OnHmdEnterUnclicked(e);
				}
			}
			e.flags = touches;
			if (touches != 0)
			{
				if ((touches & Input_Mask_Touchpad) != 0L && !padTouched)
				{
					padTouched = true;
					e.axis = GetAxis(analogArray, WVR_InputId.WVR_InputId_16, WVR_AnalogType.WVR_AnalogType_2D, (int)num);
					OnPadTouched(e);
				}
			}
			else if (padTouched)
			{
				padTouched = false;
				OnPadUntouched(e);
			}
		}
		else
		{
			WVR_Log.Log.e("WaveVR_TrackedButtons", string.Concat("_type: ", deviceType, " WVR_GetInputDeviceState failed!"));
		}
	}
}
public static class WaveVR_Utils
{
	public enum DegreeField
	{
		DOF3,
		DOF6
	}

	public enum WVR_PerfLevel
	{
		System,
		Minimum,
		Medium,
		Maximum
	}

	public struct WVR_ButtonState_t
	{
		public ulong BtnPressed;

		public ulong BtnTouched;
	}

	public class OEMConfig
	{
		private static bool isSetCallback;

		public static void OEMConfig_Changed()
		{
			WVR_Log.Log.i("OEMConfig", "onConfigChanged callback");
			Event.Send(Event.OEM_CONFIG_CHANGED);
		}

		public static void initOEMConfig()
		{
			if (!isSetCallback)
			{
				WVR_Log.Log.i("OEMConfig", "initOEMConfig");
				Interop.WVR_SetOEMConfigChangedCallback(OEMConfig_Changed);
				isSetCallback = true;
			}
		}

		public static string getControllerConfig()
		{
			initOEMConfig();
			return Interop.WVR_GetOEMConfigByKey("controller_property");
		}

		public static string getBatteryConfig()
		{
			initOEMConfig();
			return Interop.WVR_GetOEMConfigByKey("battery_indicator");
		}

		public static string getSingleBeamEnableConfig()
		{
			initOEMConfig();
			return Interop.WVR_GetOEMConfigByKey("controller_singleBeam");
		}
	}

	public class Event
	{
		public delegate void Handler(params object[] args);

		public static string DEVICE_CONNECTED = "device_connected";

		public static string NEW_POSES = "new_poses";

		public static string AFTER_NEW_POSES = "after_new_poses";

		public static string ALL_VREVENT = "all_vrevent";

		public static string BATTERY_STATUS_UPDATE = "BatteryStatusUpdate";

		public static string CONTROLLER_MODEL_LOADED = "controller_model_loaded";

		public static string CONTROLLER_MODEL_UNLOADED = "controller_model_unloaded";

		public static string PRE_CULL_LEFT = "PreCull_left";

		public static string PRE_CULL_RIGHT = "PreCull_right";

		public static string SWIPE_EVENT = "SWIPE_EVENT";

		public static string SYSTEMFOCUS_CHANGED = "SYSTEMFOCUS_CHANGED";

		public static string INTERACTION_MODE_CHANGED = "INTERACTION_MODE_CHANGED";

		public static string ADAPTIVE_CONTROLLER_READY = "adaptive_controller_ready";

		public static string RENDER_CONFIGURATION_CHANGED = "RenderConfigChanged";

		[Obsolete]
		public static string DEVICE_ROLE_CHANGED = "device_role_changed";

		public static string DS_ASSETS_NOT_FOUND = "FBXorPNG_Not_Found";

		public static string OEM_CONFIG_CHANGED = "OEM_CONFIG_CHANGED";

		public static string DEVICE_STATUS_UPDATE = "TrackedDeviceUpdated";

		public static string IPD_CHANGED = "IpdChanged";

		public static string HAND_STATIC_GESTURE_LEFT = "HAND_STATIC_GESTURE_LEFT";

		public static string HAND_STATIC_GESTURE_RIGHT = "HAND_STATIC_GESTURE_RIGHT";

		public static string HAND_DYNAMIC_GESTURE_LEFT = "HAND_DYNAMIC_GESTURE_LEFT";

		public static string HAND_DYNAMIC_GESTURE_RIGHT = "HAND_DYNAMIC_GESTURE_RIGHT";

		public static string HAND_GESTURE_STATUS = "HAND_GESTURE_STATUS";

		public static string HAND_TRACKING_STATUS = "HAND_TRACKING_STATUS";

		private static Dictionary<string, List<Handler>> listeners = new Dictionary<string, List<Handler>>();

		public static void Listen(string message, Handler action)
		{
			List<Handler> value = null;
			listeners.TryGetValue(message, out value);
			if (value == null)
			{
				value = new List<Handler>();
				listeners[message] = value;
			}
			else if (value.Contains(action))
			{
				WVR_Log.Log.w(LOG_TAG, WVR_Log.Log.CSB.AppendLine("Skip a duplicated listener from here:").Append(new StackTrace(fNeedFileInfo: false).ToString()).ToString());
				return;
			}
			value.Add(action);
		}

		public static void Remove(string message, Handler action)
		{
			List<Handler> value = null;
			listeners.TryGetValue(message, out value);
			if (value != null && value.Contains(action))
			{
				value.Remove(action);
			}
		}

		public static void Send(string message, params object[] args)
		{
			List<Handler> value = null;
			listeners.TryGetValue(message, out value);
			if (value == null)
			{
				return;
			}
			for (int num = value.Count - 1; num >= 0; num--)
			{
				Handler handler = value[num];
				try
				{
					handler(args);
				}
				catch (Exception ex)
				{
					WVR_Log.Log.e(LOG_TAG, ex.ToString(), logInEditor: true);
					value.Remove(handler);
					WVR_Log.Log.e(LOG_TAG, "A listener is removed due to exception.", logInEditor: true);
				}
			}
		}
	}

	[Serializable]
	public struct RigidTransform
	{
		public Vector3 pos;

		public Quaternion rot;

		public static RigidTransform identity => new RigidTransform(Vector3.zero, Quaternion.identity);

		public RigidTransform(Vector3 pos, Quaternion rot)
		{
			this.pos = pos;
			this.rot = rot;
		}

		public RigidTransform(Transform t)
		{
			pos = t.position;
			rot = t.rotation;
		}

		public RigidTransform(WVR_Matrix4f_t pose)
		{
			Matrix4x4 matrix = toMatrix44(pose);
			pos = matrix.GetPosition();
			rot = GetRotation(matrix);
		}

		public static Matrix4x4 toMatrix44(WVR_Matrix4f_t pose, bool glToUnity = true)
		{
			Matrix4x4 result = Matrix4x4.identity;
			int num = ((!glToUnity) ? 1 : (-1));
			result[0, 0] = pose.m0;
			result[0, 1] = pose.m1;
			result[0, 2] = pose.m2 * (float)num;
			result[0, 3] = pose.m3;
			result[1, 0] = pose.m4;
			result[1, 1] = pose.m5;
			result[1, 2] = pose.m6 * (float)num;
			result[1, 3] = pose.m7;
			result[2, 0] = pose.m8 * (float)num;
			result[2, 1] = pose.m9 * (float)num;
			result[2, 2] = pose.m10;
			result[2, 3] = pose.m11 * (float)num;
			result[3, 0] = pose.m12;
			result[3, 1] = pose.m13;
			result[3, 2] = pose.m14;
			result[3, 3] = pose.m15;
			return result;
		}

		public static WVR_Matrix4f_t ToWVRMatrix(Matrix4x4 m, bool unityToGL = true)
		{
			int num = ((!unityToGL) ? 1 : (-1));
			WVR_Matrix4f_t result = default(WVR_Matrix4f_t);
			result.m0 = m[0, 0];
			result.m1 = m[0, 1];
			result.m2 = m[0, 2] * (float)num;
			result.m3 = m[0, 3];
			result.m4 = m[1, 0];
			result.m5 = m[1, 1];
			result.m6 = m[1, 2] * (float)num;
			result.m7 = m[1, 3];
			result.m8 = m[2, 0] * (float)num;
			result.m9 = m[2, 1] * (float)num;
			result.m10 = m[2, 2];
			result.m11 = m[2, 3] * (float)num;
			result.m12 = m[3, 0];
			result.m13 = m[3, 1];
			result.m14 = m[3, 2];
			result.m15 = m[3, 3];
			return result;
		}

		public static Vector3 ToUnityPos(Vector3 glPos)
		{
			glPos.z *= -1f;
			return glPos;
		}

		public void update(WVR_Matrix4f_t pose)
		{
			Matrix4x4 matrix = toMatrix44(pose);
			pos = matrix.GetPosition();
			rot = GetRotation(matrix);
		}

		public void update(Vector3 position, Quaternion orientation)
		{
			pos = position;
			rot = orientation;
		}

		public override bool Equals(object o)
		{
			if (o is RigidTransform rigidTransform)
			{
				if (pos == rigidTransform.pos)
				{
					return rot == rigidTransform.rot;
				}
				return false;
			}
			return false;
		}

		public override int GetHashCode()
		{
			return pos.GetHashCode() ^ rot.GetHashCode();
		}

		public static bool operator ==(RigidTransform a, RigidTransform b)
		{
			if (a.pos == b.pos)
			{
				return a.rot == b.rot;
			}
			return false;
		}

		public static bool operator !=(RigidTransform a, RigidTransform b)
		{
			if (!(a.pos != b.pos))
			{
				return a.rot != b.rot;
			}
			return true;
		}

		public static RigidTransform operator *(RigidTransform a, RigidTransform b)
		{
			RigidTransform result = default(RigidTransform);
			result.rot = a.rot * b.rot;
			result.pos = a.pos + a.rot * b.pos;
			return result;
		}

		public void Inverse()
		{
			rot = Quaternion.Inverse(rot);
			pos = -(rot * pos);
		}

		public RigidTransform GetInverse()
		{
			RigidTransform result = new RigidTransform(pos, rot);
			result.Inverse();
			return result;
		}

		public Vector3 TransformPoint(Vector3 point)
		{
			return pos + rot * point;
		}

		public static Vector3 operator *(RigidTransform t, Vector3 v)
		{
			return t.TransformPoint(v);
		}
	}

	public class Trace
	{
		public static void BeginSection(string sectionName, bool inRenderThread = true)
		{
			if (inRenderThread)
			{
				lock (TraceSessionNameQueue)
				{
					TraceSessionNameQueue.Enqueue(sectionName);
				}
				SendRenderEvent(4);
			}
			else
			{
				TraceBeginSection(sectionName);
			}
		}

		public static void EndSection(bool inRenderThread = true)
		{
			if (inRenderThread)
			{
				SendRenderEvent(5);
			}
			else
			{
				TraceEndSection();
			}
		}
	}

	private delegate void RenderEventDelegate(int e);

	public delegate void CustomRenderThreadFunc();

	public enum EngineThreadID
	{
		JAVA_THREAD,
		GAME_THREAD,
		RENDER_THREAD,
		WORKER1_THREAD,
		WORKER2_THREAD
	}

	public enum EngineEventID
	{
		ENGINE_EVENT_ID_BEGIN = 40960,
		HMD_CREATE,
		HMD_INITIAILZED,
		HMD_RESUME,
		HMD_PAUSE,
		HMD_TERMINATED,
		FIRST_FRAME,
		FRAME_START,
		FRAME_END,
		UNITY_AWAKE,
		UNITY_ENABLE,
		UNITY_DISABLE,
		UNITY_START,
		UNITY_DESTROY,
		UNITY_APPLICATION_RESUME,
		UNITY_APPLICATION_PAUSE,
		UNITY_APPLICATION_QUIT,
		ENGINE_EVENT_ID_END
	}

	public delegate void HandGestureResultDelegate(object sender, bool result);

	public enum HandGestureStatus
	{
		NOT_START,
		START_FAILURE,
		STARTING,
		STOPING,
		AVAILABLE,
		UNSUPPORT
	}

	public delegate void HandTrackingResultDelegate(object sender, bool result);

	public enum HandTrackingStatus
	{
		NOT_START,
		START_FAILURE,
		STARTING,
		STOPING,
		AVAILABLE,
		UNSUPPORT
	}

	public static string LOG_TAG = "WVR_Utils";

	public static Queue TraceSessionNameQueue = new Queue(5);

	public const int k_nRenderEventID_SubmitL = 1;

	public const int k_nRenderEventID_SubmitR = 2;

	public const int k_nRenderEventID_SubmitBoth = 3;

	public const int k_nRenderEventID_GraphicInitial = 8;

	public const int k_nRenderEventID_GraphicShutdown = 9;

	public const int k_nRenderEventID_RenderEyeL = 256;

	public const int k_nRenderEventID_RenderEyeR = 257;

	public const int k_nRenderEventID_RenderEyeEndL = 258;

	public const int k_nRenderEventID_RenderEyeEndR = 259;

	public const int k_nRenderEventID_RenderEyeBoth = 273;

	public const int k_nRenderEventID_RenderEyeEndBoth = 274;

	public const int RENDEREVENTID_INIT_GRAPHIC = 0;

	public const int RENDEREVENTID_SHUTDOWN_GRAPHIC = 1;

	public const int RENDEREVENTID_Systrace_BeginSession = 4;

	public const int RENDEREVENTID_Systrace_EndSession = 5;

	public const int RENDEREVENTID_StartCamera = 21;

	public const int RENDEREVENTID_StopCamera = 22;

	public const int RENDEREVENTID_UpdateCamera = 23;

	public const int RENDEREVENTID_DrawTextureWithBuffer = 24;

	public const int RENDEREVENTID_ReleaseTexture = 25;

	public const int RENDEREVENTID_RenderMaskLeft = 30;

	public const int RENDEREVENTID_RenderMaskRight = 31;

	public const int RENDEREVENTID_SinglePassPrepare = 90;

	public const int RENDEREVENTID_SinglePassPrepareWithAntiAliasing2x = 92;

	public const int RENDEREVENTID_SinglePassPrepareWithAntiAliasing4x = 94;

	public const int RENDEREVENTID_SinglePassPrepareWithAntiAliasing8x = 98;

	public const int RENDEREVENTID_SinglePassBeforeForwardOpaque = 86;

	public const int RENDEREVENTID_SinglePassPostRender = 87;

	public const int RENDEREVENTID_ExecuteCustomFunction = 45;

	public const int RENDEREVENTID_EditorEmptyOperation = 65536;

	public const int RENDEREVENTID_SubmitL = 1001;

	public const int RENDEREVENTID_SubmitR = 1002;

	public const uint RENDEREVENTID_SubmitL_Index_Min = 1100u;

	public const uint RENDEREVENTID_SubmitR_Index_Min = 1200u;

	public const uint RENDEREVENTID_Wait_Get_Poses = 2000u;

	private static RenderEventDelegate RenderEventHandle = RenderEvent;

	private static IntPtr RenderEventHandlePtr = GetFunctionPointerForDelegate(RenderEventHandle);

	public static CustomRenderThreadFunc mCustomRenderThreadFunc = null;

	public static void SafeExecuteAllDelegate<T>(Delegate multi, Action<T> invoker, bool throws = false)
	{
		if ((object)multi == null)
		{
			return;
		}
		Delegate[] invocationList = multi.GetInvocationList();
		for (int num = invocationList.Length - 1; num >= 0; num--)
		{
			T val = (T)(object)invocationList[num];
			try
			{
				if (val != null)
				{
					invoker(val);
				}
			}
			catch (Exception ex)
			{
				WVR_Log.Log.e(LOG_TAG, ex.ToString(), logInEditor: true);
			}
		}
	}

	private static float _copysign(float sizeval, float signval)
	{
		if (Mathf.Sign(signval) != 1f)
		{
			return 0f - Mathf.Abs(sizeval);
		}
		return Mathf.Abs(sizeval);
	}

	public static Quaternion GetRotation(Matrix4x4 matrix)
	{
		float num = matrix.m00 + matrix.m11 + matrix.m22;
		float w;
		float x;
		float y;
		float z;
		if (num > 0f)
		{
			float num2 = Mathf.Sqrt(num + 1f) * 2f;
			w = 0.25f * num2;
			x = (matrix.m21 - matrix.m12) / num2;
			y = (matrix.m02 - matrix.m20) / num2;
			z = (matrix.m10 - matrix.m01) / num2;
		}
		else if ((matrix.m00 > matrix.m11) & (matrix.m00 > matrix.m22))
		{
			float num3 = Mathf.Sqrt(1f + matrix.m00 - matrix.m11 - matrix.m22) * 2f;
			w = (matrix.m21 - matrix.m12) / num3;
			x = 0.25f * num3;
			y = (matrix.m01 + matrix.m10) / num3;
			z = (matrix.m02 + matrix.m20) / num3;
		}
		else if (matrix.m11 > matrix.m22)
		{
			float num4 = Mathf.Sqrt(1f + matrix.m11 - matrix.m00 - matrix.m22) * 2f;
			w = (matrix.m02 - matrix.m20) / num4;
			x = (matrix.m01 + matrix.m10) / num4;
			y = 0.25f * num4;
			z = (matrix.m12 + matrix.m21) / num4;
		}
		else
		{
			float num5 = Mathf.Sqrt(1f + matrix.m22 - matrix.m00 - matrix.m11) * 2f;
			w = (matrix.m10 - matrix.m01) / num5;
			x = (matrix.m02 + matrix.m20) / num5;
			y = (matrix.m12 + matrix.m21) / num5;
			z = 0.25f * num5;
		}
		return new Quaternion(x, y, z, w).normalized;
	}

	public static Quaternion GetRotation(WVR_Quatf_t glQuat)
	{
		return new Quaternion(glQuat.x, glQuat.y, 0f - glQuat.z, 0f - glQuat.w);
	}

	public static Vector3 GetPosition(this Matrix4x4 matrix)
	{
		float m = matrix.m03;
		float m2 = matrix.m13;
		float m3 = matrix.m23;
		return new Vector3(m, m2, m3);
	}

	public static Vector3 GetPosition(WVR_Vector3f_t glVector)
	{
		return new Vector3(glVector.v0, glVector.v1, 0f - glVector.v2);
	}

	public static void GetVectorFromGL(WVR_Vector3f_t gl_vec, out Vector3 unity_vec)
	{
		unity_vec.x = gl_vec.v0;
		unity_vec.y = gl_vec.v1;
		unity_vec.z = 0f - gl_vec.v2;
	}

	public static Vector3 GetScale(this Matrix4x4 matrix)
	{
		Vector3 result = default(Vector3);
		result.x = new Vector4(matrix.m00, matrix.m10, matrix.m20, matrix.m30).magnitude;
		result.y = new Vector4(matrix.m01, matrix.m11, matrix.m21, matrix.m31).magnitude;
		result.z = new Vector4(matrix.m02, matrix.m12, matrix.m22, matrix.m32).magnitude;
		return result;
	}

	public static string GetControllerName(WaveVR_Controller.EDeviceType type)
	{
		string text = "";
		if (type == WaveVR_Controller.EDeviceType.Head)
		{
			WVR_Log.Log.w(LOG_TAG, "EDeviceType is Head");
			return text;
		}
		WVR_DeviceType deviceType = WaveVR_Controller.Input(type).DeviceType;
		if (WaveVR_Controller.Input(type).connected)
		{
			uint unBufferSize = 128u;
			IntPtr pchValue = Marshal.StringToHGlobalAnsi("GetRenderModelName");
			IntPtr intPtr = Marshal.AllocHGlobal(128);
			if (Interop.WVR_GetParameters(deviceType, pchValue, intPtr, unBufferSize) != 0)
			{
				text = Marshal.PtrToStringAnsi(intPtr);
			}
			else
			{
				WVR_Log.Log.w(LOG_TAG, "WVR_GetParameters returns empty");
			}
		}
		else
		{
			WVR_Log.Log.w(LOG_TAG, string.Concat(type, " controller is disconnect"));
		}
		WVR_Log.Log.i(LOG_TAG, "GetControllerName returns " + text);
		return text;
	}

	public static void notifyActivityUnityStarted()
	{
		new AndroidJavaClass("com.htc.vr.unity.WVRUnityVRActivity").CallStatic<AndroidJavaObject>("getInstance", Array.Empty<object>()).Call("onUnityStarted");
	}

	[DllImport("wvrunity", CallingConvention = CallingConvention.Cdecl)]
	public static extern void NativeRenderEvent(int eventID);

	[DllImport("wvrunity", CallingConvention = CallingConvention.Cdecl)]
	public static extern void SetColorSpace(int colorspace);

	[DllImport("wvrunity", CallingConvention = CallingConvention.Cdecl)]
	public static extern void SetSubmitOptionalArgument([Out] WVR_PoseState_t[] poses, int submit_extend_flag);

	[DllImport("wvrunity", CallingConvention = CallingConvention.Cdecl, EntryPoint = "nativeProcessEngineEvent")]
	public static extern void NativeProcessEngineEvent(uint tID, uint eventID);

	[DllImport("wvrunity", CallingConvention = CallingConvention.Cdecl)]
	public static extern int IsSinglePassSupported();

	[DllImport("wvrunity", CallingConvention = CallingConvention.Cdecl)]
	public static extern IntPtr PrepareSinglePassTexture(int antiAliasing, int width, int height);

	[DllImport("wvrunity", CallingConvention = CallingConvention.Cdecl)]
	public static extern void SinglePassBeforeForwardOpaque();

	[DllImport("wvrunity", CallingConvention = CallingConvention.Cdecl)]
	public static extern void SinglePassPostRender();

	[DllImport("wvrunity", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
	private static extern void TraceBeginSection(string name);

	[DllImport("wvrunity", CallingConvention = CallingConvention.Cdecl)]
	private static extern void TraceEndSection();

	[DllImport("wvr_api", CallingConvention = CallingConvention.Cdecl)]
	public static extern bool WVR_IsATWActive();

	[DllImport("wvr_api", CallingConvention = CallingConvention.Cdecl)]
	public static extern int WVR_GetNumberOfTextures();

	[DllImport("wvr_api", CallingConvention = CallingConvention.Cdecl)]
	public static extern IntPtr WVR_StoreRenderTextures(int[] texturesIDs, int size, bool eEye, WVR_TextureTarget target);

	[DllImport("wvr_api", CallingConvention = CallingConvention.Cdecl)]
	public static extern IntPtr WVR_ReplaceCurrentTextureID(IntPtr queue, IntPtr imageHandle);

	[DllImport("wvr_api", CallingConvention = CallingConvention.Cdecl)]
	public static extern uint WVR_GetAvailableTextureID(IntPtr queue);

	[DllImport("wvr_api", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WVR_IsPresentedOnExternalD")]
	public static extern bool WVR_IsPresentedOnExternal();

	[DllImport("wvr_api", CallingConvention = CallingConvention.Cdecl)]
	public static extern int WVR_LoadCriteriaData(string criteriaData);

	[DllImport("wvr_api", CallingConvention = CallingConvention.Cdecl)]
	public static extern int WVR_StartPerformanceTest(string sceneID);

	[DllImport("wvr_api", CallingConvention = CallingConvention.Cdecl)]
	public static extern int WVR_EndPerformanceTest(StringBuilder pReport, uint ReportSize);

	[DllImport("wvr_api", CallingConvention = CallingConvention.Cdecl)]
	public static extern uint WVR_GetPerformanceReportSize();

	[DllImport("wvr_api", CallingConvention = CallingConvention.Cdecl)]
	public static extern bool WVR_SetPerformanceLevels(WVR_PerfLevel cpuLevel, WVR_PerfLevel gpuLevel);

	[DllImport("wvr_api", CallingConvention = CallingConvention.Cdecl)]
	public static extern void WVR_GetStencilMesh(WVR_Eye eEye, ref uint vertexCount, ref uint triangleCount, uint floatArrayCount, [In][Out] float[] vertexData, uint intArrayCount, [In][Out] int[] indexData);

	[MonoPInvokeCallback(typeof(RenderEventDelegate))]
	private static void RenderEvent(int eventId)
	{
		if ((eventId & 0xA000) == 40960)
		{
			NativeProcessEngineEvent(2u, (uint)eventId);
			return;
		}
		if (eventId <= 45)
		{
			switch (eventId)
			{
			case 1:
				NativeRenderEvent(9);
				break;
			case 4:
			{
				string name;
				lock (TraceSessionNameQueue)
				{
					try
					{
						name = (string)TraceSessionNameQueue.Dequeue();
					}
					catch (InvalidOperationException)
					{
						name = "Empty";
					}
				}
				TraceBeginSection(name);
				break;
			}
			case 5:
				TraceEndSection();
				break;
			case 21:
			{
				WVR_CameraInfo_t info = default(WVR_CameraInfo_t);
				bool flag3 = Interop.WVR_StartCamera(ref info);
				Event.Send("StartCameraCompleted", flag3, info);
				break;
			}
			case 22:
				Interop.WVR_StopCamera();
				break;
			case 23:
			{
				bool flag2 = Interop.WVR_UpdateTexture(WaveVR_CameraTexture.instance.getNativeTextureId());
				Event.Send("UpdateCameraCompleted", flag2);
				break;
			}
			case 24:
			{
				IntPtr nativeTextureId = WaveVR_CameraTexture.instance.getNativeTextureId();
				uint imageSize = WaveVR_CameraTexture.instance.getImageSize();
				IntPtr nativeFrameBuffer = WaveVR_CameraTexture.instance.getNativeFrameBuffer();
				uint imageWidth = WaveVR_CameraTexture.instance.getImageWidth();
				uint imageHeight = WaveVR_CameraTexture.instance.getImageHeight();
				WVR_CameraImageFormat imageFormat = WaveVR_CameraTexture.instance.getImageFormat();
				bool flag = Interop.WVR_DrawTextureWithBuffer(nativeTextureId, imageFormat, nativeFrameBuffer, imageSize, imageWidth, imageHeight);
				Event.Send("DrawCameraCompleted", flag);
				break;
			}
			case 25:
				Interop.WVR_ReleaseCameraTexture();
				break;
			case 30:
				Interop.WVR_RenderMask(WVR_Eye.WVR_Eye_Left);
				break;
			case 31:
				Interop.WVR_RenderMask(WVR_Eye.WVR_Eye_Right);
				break;
			case 45:
				if (mCustomRenderThreadFunc != null)
				{
					mCustomRenderThreadFunc();
				}
				mCustomRenderThreadFunc = null;
				break;
			}
			return;
		}
		switch (eventId)
		{
		default:
			_ = 65536;
			break;
		case 90:
		case 92:
		case 94:
		case 98:
		{
			WaveVR_Render instance = WaveVR_Render.Instance;
			if (!(instance == null))
			{
				PrepareSinglePassTexture(eventId - 90, (int)instance.sceneWidth, (int)instance.sceneHeight);
			}
			break;
		}
		case 86:
			SinglePassBeforeForwardOpaque();
			break;
		case 87:
			SinglePassPostRender();
			break;
		case 88:
		case 89:
		case 91:
		case 93:
			break;
		}
	}

	private static IntPtr GetFunctionPointerForDelegate(Delegate del)
	{
		return Marshal.GetFunctionPointerForDelegate(del);
	}

	public static void SendRenderEvent(int eventId)
	{
		GL.IssuePluginEvent(RenderEventHandlePtr, eventId);
	}

	public static void IssueEngineEvent(EngineEventID eventID)
	{
		IssueEngineEvent(EngineThreadID.GAME_THREAD, eventID);
		IssueEngineEvent(EngineThreadID.RENDER_THREAD, eventID);
	}

	public static void IssueEngineEvent(EngineThreadID tID, EngineEventID eventID)
	{
		if (tID == EngineThreadID.RENDER_THREAD)
		{
			SendRenderEvent((int)eventID);
		}
		else
		{
			NativeProcessEngineEvent((uint)tID, (uint)eventID);
		}
	}
}
namespace WaveVR_Log
{
	[Obsolete("namespace WaveVR_Log obsolete, use namespace WVR_Log instead.")]
	public class Log
	{
		public class EnterAndExit : IDisposable
		{
			private string tag;

			private string message;

			private string enter;

			private string exit;

			private bool logInEditor;

			public EnterAndExit(string tag, string message, string postfixEnter, string postfixExit, bool logInEditor = false)
			{
				this.tag = tag;
				this.message = message;
				exit = postfixExit;
				this.logInEditor = logInEditor;
				d(tag, message + postfixEnter, logInEditor);
			}

			public void Dispose()
			{
				d(tag, message + exit, logInEditor);
			}
		}

		public class PeriodLog
		{
			public delegate string StringProcessDelegate();

			public float interval = 3f;

			private float lastTime;

			private bool print = true;

			public PeriodLog()
			{
				lastTime = Time.realtimeSinceStartup;
			}

			public void check()
			{
				float realtimeSinceStartup = Time.realtimeSinceStartup;
				print = false;
				if (realtimeSinceStartup > lastTime + interval)
				{
					lastTime = realtimeSinceStartup;
					print = true;
				}
			}

			public void d(string tag, string message, bool logInEditor = false)
			{
				if (print)
				{
					Log.d(tag, message, logInEditor);
				}
			}

			public void d(string tag, StringProcessDelegate strDelegate, bool logInEditor = false)
			{
				if (print)
				{
					Log.d(tag, strDelegate(), logInEditor);
				}
			}
		}

		private const int ANDROID_LOG_VERBOSE = 2;

		private const int ANDROID_LOG_DEBUG = 3;

		private const int ANDROID_LOG_INFO = 4;

		private const int ANDROID_LOG_WARN = 5;

		private const int ANDROID_LOG_ERROR = 6;

		public static PeriodLog gpl = new PeriodLog();

		[DllImport("log", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
		internal static extern int __android_log_print(int prio, string tag, string fmt, IntPtr ptr);

		public static void d(string tag, string message, bool logInEditor = false)
		{
			__android_log_print(3, tag, message, IntPtr.Zero);
		}

		public static void i(string tag, string message, bool logInEditor = false)
		{
			__android_log_print(4, tag, message, IntPtr.Zero);
		}

		public static void w(string tag, string message, bool logInEditor = false)
		{
			__android_log_print(5, tag, message, IntPtr.Zero);
		}

		public static void e(string tag, string message, bool logInEditor = false)
		{
			__android_log_print(6, tag, message, IntPtr.Zero);
		}

		public static EnterAndExit ee(string message, bool logInEditor = false)
		{
			return new EnterAndExit("Unity", message, "+", "-", logInEditor);
		}

		public static EnterAndExit ee(string tag, string message, bool logInEditor = false)
		{
			return new EnterAndExit(tag, message, "+", "-", logInEditor);
		}

		public static EnterAndExit ee(string tag, string postfixEnter, string postfixExit, bool logInEditor = false)
		{
			return new EnterAndExit(tag, "", postfixEnter, postfixExit, logInEditor);
		}

		public static EnterAndExit ee(string tag, string message, string postfixEnter, string postfixExit, bool logInEditor = false)
		{
			return new EnterAndExit(tag, message, postfixEnter, postfixExit, logInEditor);
		}
	}
}
namespace WVR_Log
{
	public class Log
	{
		public class EnterAndExit : IDisposable
		{
			private string tag;

			private string message;

			private string enter;

			private string exit;

			private bool logInEditor;

			public EnterAndExit(string tag, string message, string postfixEnter, string postfixExit, bool logInEditor = false)
			{
				this.tag = tag;
				this.message = message;
				exit = postfixExit;
				this.logInEditor = logInEditor;
				d(tag, message + postfixEnter, logInEditor);
			}

			public void Dispose()
			{
				d(tag, message + exit, logInEditor);
			}
		}

		public class PeriodLog
		{
			public delegate string StringProcessDelegate();

			public float interval = 3f;

			private float lastTime;

			public bool Print { get; private set; }

			public PeriodLog()
			{
				lastTime = Time.realtimeSinceStartup;
			}

			public void check()
			{
				float realtimeSinceStartup = Time.realtimeSinceStartup;
				Print = false;
				if (realtimeSinceStartup > lastTime + interval)
				{
					lastTime = realtimeSinceStartup;
					Print = true;
				}
			}

			public void d(string tag, string message, bool logInEditor = false)
			{
				if (Print)
				{
					Log.d(tag, message, logInEditor: false);
				}
			}

			[Obsolete("The delegate still use GC.Alloc to remember your variable.")]
			public void d(string tag, StringProcessDelegate strDelegate, bool logInEditor = false)
			{
				if (Print)
				{
					Log.d(tag, strDelegate(), logInEditor);
				}
			}
		}

		public static bool EnableDebugLog = true;

		private const int LOG_VERBOSE = 2;

		private const int LOG_DEBUG = 3;

		private const int LOG_INFO = 4;

		private const int LOG_WARN = 5;

		private const int LOG_ERROR = 6;

		private static readonly int SBLength = 511;

		public static readonly StringBuilder SB = new StringBuilder(SBLength, SBLength);

		public static PeriodLog gpl = new PeriodLog();

		public static StringBuilder CSB => SB.Clear();

		[DllImport("log", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi, EntryPoint = "__android_log_print")]
		internal static extern int __log_print(int prio, string tag, string fmt, IntPtr ptr);

		public static void v(string tag, string message, bool logInEditor = false)
		{
			__log_print(2, tag, message, IntPtr.Zero);
		}

		public static void d(string tag, string message, bool logInEditor = false)
		{
			__log_print(3, tag, message, IntPtr.Zero);
		}

		public static void i(string tag, string message, bool logInEditor = false)
		{
			__log_print(4, tag, message, IntPtr.Zero);
		}

		public static void w(string tag, string message, bool logInEditor = false)
		{
			__log_print(5, tag, message, IntPtr.Zero);
		}

		public static void e(string tag, string message, bool logInEditor = false)
		{
			__log_print(6, tag, message, IntPtr.Zero);
		}

		public static EnterAndExit ee(string message)
		{
			return new EnterAndExit("Unity", message, "+", "-");
		}

		public static EnterAndExit ee(string tag, string message)
		{
			return new EnterAndExit(tag, message, "+", "-");
		}

		public static EnterAndExit ee(string tag, string postfixEnter, string postfixExit)
		{
			return new EnterAndExit(tag, "", postfixEnter, postfixExit);
		}

		public static EnterAndExit ee(string tag, string message, string postfixEnter, string postfixExit)
		{
			return new EnterAndExit(tag, message, postfixEnter, postfixExit);
		}
	}
}
namespace wvr
{
	public enum WVR_AppType
	{
		WVR_AppType_VRContent = 1,
		WVR_AppType_NonVRContent
	}
	public enum WVR_InitError
	{
		WVR_InitError_None,
		WVR_InitError_Unknown,
		WVR_InitError_NotInitialized
	}
	public enum WVR_EventType
	{
		WVR_EventType_Quit = 1000,
		WVR_EventType_SystemInteractionModeChanged = 1001,
		WVR_EventType_SystemGazeTriggerTypeChanged = 1002,
		WVR_EventType_TrackingModeChanged = 1003,
		WVR_EventType_RecommendedQuality_Lower = 1004,
		WVR_EventType_RecommendedQuality_Higher = 1005,
		WVR_EventType_HandGesture_Changed = 1006,
		WVR_EventType_HandGesture_Abnormal = 1007,
		WVR_EventType_HandTracking_Abnormal = 1008,
		WVR_EventType_DeviceConnected = 2000,
		WVR_EventType_DeviceDisconnected = 2001,
		WVR_EventType_DeviceStatusUpdate = 2002,
		WVR_EventType_DeviceSuspend = 2003,
		WVR_EventType_DeviceResume = 2004,
		WVR_EventType_IpdChanged = 2005,
		WVR_EventType_DeviceRoleChanged = 2006,
		WVR_EventType_BatteryStatusUpdate = 2007,
		WVR_EventType_ChargeStatusUpdate = 2008,
		WVR_EventType_DeviceErrorStatusUpdate = 2009,
		WVR_EventType_BatteryTemperatureStatusUpdate = 2010,
		WVR_EventType_RecenterSuccess = 2011,
		WVR_EventType_RecenterFail = 2012,
		WVR_EventType_RecenterSuccess3DoF = 2013,
		WVR_EventType_RecenterFail3DoF = 2014,
		WVR_EventType_PassThroughOverlayShownBySystem = 2100,
		WVR_EventType_PassThroughOverlayHiddenBySystem = 2101,
		WVR_EventType_ButtonPressed = 3000,
		WVR_EventType_ButtonUnpressed = 3001,
		WVR_EventType_TouchTapped = 3002,
		WVR_EventType_TouchUntapped = 3003,
		WVR_EventType_LeftToRightSwipe = 3004,
		WVR_EventType_RightToLeftSwipe = 3005,
		WVR_EventType_DownToUpSwipe = 3006,
		WVR_EventType_UpToDownSwipe = 3007
	}
	public enum WVR_PeripheralQuality
	{
		Low,
		Middle,
		High
	}
	public enum WVR_DeviceType
	{
		WVR_DeviceType_Invalid,
		WVR_DeviceType_HMD,
		WVR_DeviceType_Controller_Right,
		WVR_DeviceType_Controller_Left
	}
	public enum WVR_RecenterType
	{
		WVR_RecenterType_Disabled,
		WVR_RecenterType_YawOnly,
		WVR_RecenterType_YawAndPosition,
		WVR_RecenterType_RotationAndPosition
	}
	public enum WVR_InputType
	{
		WVR_InputType_Button = 1,
		WVR_InputType_Touch = 2,
		WVR_InputType_Analog = 4
	}
	public enum WVR_BatteryStatus
	{
		WVR_BatteryStatus_Unknown,
		WVR_BatteryStatus_Normal,
		WVR_BatteryStatus_Low,
		WVR_BatteryStatus_UltraLow
	}
	public enum WVR_ChargeStatus
	{
		WVR_ChargeStatus_Unknown,
		WVR_ChargeStatus_Discharging,
		WVR_ChargeStatus_Charging,
		WVR_ChargeStatus_Full
	}
	public enum WVR_BatteryTemperatureStatus
	{
		WVR_BatteryTemperature_Unknown,
		WVR_BatteryTemperature_Normal,
		WVR_BatteryTemperature_Overheat,
		WVR_BatteryTemperature_UltraOverheat
	}
	public enum WVR_DeviceErrorStatus
	{
		WVR_DeviceErrorStatus_None = 0,
		WVR_DeviceErrorStatus_BatteryOverheat = 1,
		WVR_DeviceErrorStatus_BatteryOverheatRestore = 2,
		WVR_DeviceErrorStatus_BatteryOvervoltage = 4,
		WVR_DeviceErrorStatus_BatteryOvervoltageRestore = 8,
		WVR_DeviceErrorStatus_DeviceConnectFail = 0x10,
		WVR_DeviceErrorStatus_DeviceConnectRestore = 0x20,
		WVR_DeviceErrorStatus_DeviceLostTracking = 0x40,
		WVR_DeviceErrorStatus_DeviceLostTrackingRestore = 0x80,
		WVR_DeviceErrorStatus_ChargeFail = 0x100,
		WVR_DeviceErrorStatus_ChargeRestore = 0x200
	}
	public enum WVR_DeviceErrorState
	{
		WVR_DeviceErrorState_None,
		WVR_DeviceErrorState_BatteryOverheat,
		WVR_DeviceErrorState_BatteryOvervoltage,
		WVR_DeviceErrorState_DeviceConnectFail,
		WVR_DeviceErrorState_DeviceLostTracking,
		WVR_DeviceErrorState_ChargeFail
	}
	public enum WVR_InputId
	{
		WVR_InputId_0 = 0,
		WVR_InputId_1 = 1,
		WVR_InputId_2 = 2,
		WVR_InputId_3 = 3,
		WVR_InputId_4 = 4,
		WVR_InputId_5 = 5,
		WVR_InputId_6 = 6,
		WVR_InputId_7 = 7,
		WVR_InputId_8 = 8,
		WVR_InputId_9 = 9,
		WVR_InputId_14 = 14,
		WVR_InputId_15 = 15,
		WVR_InputId_16 = 16,
		WVR_InputId_17 = 17,
		WVR_InputId_18 = 18,
		WVR_InputId_Alias1_System = 0,
		WVR_InputId_Alias1_Menu = 1,
		WVR_InputId_Alias1_Grip = 2,
		WVR_InputId_Alias1_DPad_Left = 3,
		WVR_InputId_Alias1_DPad_Up = 4,
		WVR_InputId_Alias1_DPad_Right = 5,
		WVR_InputId_Alias1_DPad_Down = 6,
		WVR_InputId_Alias1_Volume_Up = 7,
		WVR_InputId_Alias1_Volume_Down = 8,
		WVR_InputId_Alias1_Digital_Trigger = 9,
		WVR_InputId_Alias1_Back = 14,
		WVR_InputId_Alias1_Enter = 15,
		WVR_InputId_Alias1_Touchpad = 16,
		WVR_InputId_Alias1_Trigger = 17,
		WVR_InputId_Alias1_Thumbstick = 18,
		WVR_InputId_Max = 32
	}
	public enum WVR_AnalogType
	{
		WVR_AnalogType_None,
		WVR_AnalogType_2D,
		WVR_AnalogType_1D
	}
	public enum WVR_Intensity
	{
		WVR_Intensity_Weak = 1,
		WVR_Intensity_Light,
		WVR_Intensity_Normal,
		WVR_Intensity_Strong,
		WVR_Intensity_Severe
	}
	public enum WVR_PoseOriginModel
	{
		WVR_PoseOriginModel_OriginOnHead,
		WVR_PoseOriginModel_OriginOnGround,
		WVR_PoseOriginModel_OriginOnTrackingObserver,
		WVR_PoseOriginModel_OriginOnHead_3DoF
	}
	public enum WVR_ArenaVisible
	{
		WVR_ArenaVisible_Auto,
		WVR_ArenaVisible_ForceOn,
		WVR_ArenaVisible_ForceOff
	}
	public enum WVR_GraphicsApiType
	{
		WVR_GraphicsApiType_OpenGL = 1
	}
	public enum WVR_ScreenshotMode
	{
		WVR_ScreenshotMode_Default,
		WVR_ScreenshotMode_Raw,
		WVR_ScreenshotMode_Distorted
	}
	public enum WVR_SubmitError
	{
		WVR_SubmitError_None = 0,
		WVR_SubmitError_InvalidTexture = 400,
		WVR_SubmitError_ThreadStop = 401,
		WVR_SubmitError_BufferSubmitFailed = 402,
		WVR_SubmitError_Max = 65535
	}
	public enum WVR_SubmitExtend
	{
		WVR_SubmitExtend_Default = 0,
		WVR_SubmitExtend_DisableDistortion = 1,
		WVR_SubmitExtend_PartialTexture = 0x10
	}
	public enum WVR_Eye
	{
		WVR_Eye_Left,
		WVR_Eye_Right,
		WVR_Eye_Both,
		WVR_Eye_None
	}
	public enum WVR_TextureTarget
	{
		WVR_TextureTarget_2D,
		WVR_TextureTarget_2D_ARRAY
	}
	public enum WVR_TextureFormat
	{
		WVR_TextureFormat_RGBA
	}
	public enum WVR_TextureType
	{
		WVR_TextureType_UnsignedByte
	}
	public enum WVR_RenderError
	{
		WVR_RenderError_None = 0,
		WVR_RenderError_RuntimeInitFailed = 410,
		WVR_RenderError_ContextSetupFailed = 411,
		WVR_RenderError_DisplaySetupFailed = 412,
		WVR_RenderError_LibNotSupported = 413,
		WVR_RenderError_NullPtr = 414,
		WVR_RenderError_Max = 65535
	}
	public enum WVR_RenderConfig
	{
		WVR_RenderConfig_Default = 0,
		WVR_RenderConfig_Disable_SingleBuffer = 1,
		WVR_RenderConfig_Disable_Reprojection = 2,
		WVR_RenderConfig_sRGB = 4
	}
	public enum WVR_CameraImageType
	{
		WVR_CameraImageType_Invalid,
		WVR_CameraImageType_SingleEye,
		WVR_CameraImageType_DualEye
	}
	public enum WVR_CameraImageFormat
	{
		WVR_CameraImageFormat_Invalid,
		WVR_CameraImageFormat_YUV_420,
		WVR_CameraImageFormat_Grayscale
	}
	public enum WVR_CameraPosition
	{
		WVR_CameraPosition_Invalid,
		WVR_CameraPosition_left,
		WVR_CameraPosition_Right
	}
	public enum WVR_OverlayError
	{
		WVR_OverlayError_None = 0,
		WVR_OverlayError_UnknownOverlay = 10,
		WVR_OverlayError_OverlayUnavailable = 11,
		WVR_OverlayError_InvalidParameter = 20
	}
	public enum WVR_OverlayTransformType
	{
		WVR_OverlayTransformType_None,
		WVR_OverlayTransformType_Absolute,
		WVR_OverlayTransformType_Fixed
	}
	public enum WVR_NumDoF
	{
		WVR_NumDoF_3DoF,
		WVR_NumDoF_6DoF
	}
	public enum WVR_ArenaShape
	{
		WVR_ArenaShape_None,
		WVR_ArenaShape_Rectangle,
		WVR_ArenaShape_Round
	}
	public enum WVR_InteractionMode
	{
		WVR_InteractionMode_SystemDefault = 1,
		WVR_InteractionMode_Gaze,
		WVR_InteractionMode_Controller
	}
	public enum WVR_GazeTriggerType
	{
		WVR_GazeTriggerType_Timeout = 1,
		WVR_GazeTriggerType_Button,
		WVR_GazeTriggerType_TimeoutButton
	}
	public enum WVR_PerfLevel
	{
		WVR_PerfLevel_System,
		WVR_PerfLevel_Minimum,
		WVR_PerfLevel_Medium,
		WVR_PerfLevel_Maximum,
		WVR_PerfLevel_NumPerfLevels
	}
	public enum WVR_RenderQuality
	{
		WVR_RenderQuality_Low = 1,
		WVR_RenderQuality_Medium,
		WVR_RenderQuality_High,
		WVR_RenderQuality_NumRenderQuality
	}
	public enum WVR_SimulationType
	{
		WVR_SimulationType_Auto,
		WVR_SimulationType_ForceOn,
		WVR_SimulationType_ForceOff
	}
	public enum WVR_EyePoseStatus
	{
		WVR_GazePointValid = 1,
		WVR_GazeVectorValid = 2,
		WVR_EyeOpennessValid = 4,
		WVR_EyePupilDilationValid = 8,
		WVR_EyePositionGuideValid = 0x10
	}
	public struct WVR_RenderInitParams_t
	{
		public WVR_GraphicsApiType graphicsApi;

		public ulong renderConfig;
	}
	public struct WVR_Matrix4f_t
	{
		public float m0;

		public float m1;

		public float m2;

		public float m3;

		public float m4;

		public float m5;

		public float m6;

		public float m7;

		public float m8;

		public float m9;

		public float m10;

		public float m11;

		public float m12;

		public float m13;

		public float m14;

		public float m15;
	}
	public struct WVR_Vector2f_t
	{
		public float v0;

		public float v1;
	}
	public struct WVR_Vector3f_t
	{
		public float v0;

		public float v1;

		public float v2;
	}
	public struct WVR_CameraIntrinsic_t
	{
		public WVR_Vector2f_t focalLength;

		public WVR_Vector2f_t principalPoint;
	}
	public struct WVR_CameraInfo_t
	{
		public WVR_CameraImageType imgType;

		public WVR_CameraImageFormat imgFormat;

		public uint width;

		public uint height;

		public uint size;
	}
	public struct WVR_Quatf_t
	{
		public float w;

		public float x;

		public float y;

		public float z;
	}
	[StructLayout(LayoutKind.Explicit)]
	public struct WVR_PoseState_t
	{
		[FieldOffset(0)]
		public bool IsValidPose;

		[FieldOffset(4)]
		public WVR_Matrix4f_t PoseMatrix;

		[FieldOffset(68)]
		public WVR_Vector3f_t Velocity;

		[FieldOffset(80)]
		public WVR_Vector3f_t AngularVelocity;

		[FieldOffset(92)]
		public bool Is6DoFPose;

		[FieldOffset(96)]
		public long PoseTimestamp_ns;

		[FieldOffset(104)]
		public WVR_Vector3f_t Acceleration;

		[FieldOffset(116)]
		public WVR_Vector3f_t AngularAcceleration;

		[FieldOffset(128)]
		public float PredictedMilliSec;

		[FieldOffset(132)]
		public WVR_PoseOriginModel OriginModel;

		[FieldOffset(136)]
		public WVR_Pose_t RawPose;
	}
	[StructLayout(LayoutKind.Explicit)]
	public struct WVR_DevicePosePair_t
	{
		[FieldOffset(0)]
		public WVR_DeviceType type;

		[FieldOffset(8)]
		public WVR_PoseState_t pose;
	}
	[StructLayout(LayoutKind.Explicit)]
	public struct WVR_TextureLayout_t
	{
		[FieldOffset(0)]
		public WVR_Vector2f_t leftLowUVs;

		[FieldOffset(8)]
		public WVR_Vector2f_t rightUpUVs;
	}
	[StructLayout(LayoutKind.Explicit)]
	public struct WVR_TextureBound_t
	{
		[FieldOffset(0)]
		public float uMin;

		[FieldOffset(4)]
		public float vMin;

		[FieldOffset(8)]
		public float uMax;

		[FieldOffset(12)]
		public float vMax;
	}
	public struct WVR_TextureParams_t
	{
		public IntPtr id;

		public WVR_TextureTarget target;

		public WVR_TextureLayout_t layout;
	}
	public struct WVR_RenderProps_t
	{
		public float refreshRate;

		public bool hasExternal;

		public float ipdMeter;
	}
	public struct WVR_CommonEvent_t
	{
		public WVR_EventType type;

		public long timestamp;
	}
	public struct WVR_DeviceEvent_t
	{
		public WVR_CommonEvent_t common;

		public WVR_DeviceType type;
	}
	public struct WVR_InputEvent_t
	{
		public WVR_DeviceEvent_t device;

		public WVR_InputId inputId;
	}
	[StructLayout(LayoutKind.Explicit)]
	public struct WVR_Event_t
	{
		[FieldOffset(0)]
		public WVR_CommonEvent_t common;

		[FieldOffset(0)]
		public WVR_DeviceEvent_t device;

		[FieldOffset(0)]
		public WVR_InputEvent_t input;
	}
	public struct WVR_Axis_t
	{
		public float x;

		public float y;
	}
	[StructLayout(LayoutKind.Explicit)]
	public struct WVR_AnalogState_t
	{
		[FieldOffset(0)]
		public WVR_InputId id;

		[FieldOffset(4)]
		public WVR_AnalogType type;

		[FieldOffset(8)]
		public WVR_Axis_t axis;
	}
	public struct WVR_InputAttribute_t
	{
		public WVR_InputId id;

		public uint capability;

		public WVR_AnalogType axis_type;
	}
	public struct WVR_InputMappingPair_t
	{
		public WVR_InputAttribute_t destination;

		public WVR_InputAttribute_t source;
	}
	[StructLayout(LayoutKind.Explicit)]
	public struct WVR_Pose_t
	{
		[FieldOffset(0)]
		public WVR_Vector3f_t position;

		[FieldOffset(12)]
		public WVR_Quatf_t rotation;
	}
	public struct WVR_OverlayPosition_t
	{
		public float x;

		public float y;

		public float z;
	}
	public struct WVR_OverlayBlendColor_t
	{
		public float r;

		public float g;

		public float b;
	}
	public struct WVR_OverlayTexture_t
	{
		public uint textureId;

		public uint width;

		public uint height;
	}
	public struct WVR_ArenaRectangle_t
	{
		public float width;

		public float length;
	}
	public struct WVR_ArenaRound_t
	{
		public float diameter;
	}
	[StructLayout(LayoutKind.Explicit)]
	public struct WVR_ArenaArea_t
	{
		[FieldOffset(0)]
		public WVR_ArenaRectangle_t rectangle;

		[FieldOffset(0)]
		public WVR_ArenaRound_t round;
	}
	public struct WVR_Arena_t
	{
		public WVR_ArenaShape shape;

		public WVR_ArenaArea_t area;
	}
	public delegate void WVR_OverlayInputEventCallback(int overlayId, WVR_EventType type, WVR_InputId inputId);
	public struct WVR_OverlayInputEvent_t
	{
		public int overlayId;

		public IntPtr callback;
	}
	public struct WVR_RenderFoveationParams
	{
		public float focalX;

		public float focalY;

		public float fovealFov;

		public WVR_PeripheralQuality periQuality;
	}
	public struct FBXInfo_t
	{
		public WVR_Matrix4f_t matrix;

		public uint verticeCount;

		public uint normalCount;

		public uint uvCount;

		public uint indiceCount;

		public IntPtr meshName;
	}
	public struct MeshInfo_t
	{
		public Vector3[] _vectice;

		public Vector3[] _normal;

		public Vector2[] _uv;

		public int[] _indice;

		public bool _active;
	}
	public struct StencilMesh_t
	{
		public uint vertCount;

		public IntPtr vertData;

		public uint triCount;

		public IntPtr indexData;
	}
	public struct WVR_RequestResult
	{
		public string mPermission;

		public bool mGranted;
	}
	public struct WVR_EyeData_t
	{
		public int leftEyeDataStatus;

		public int rightEyeDataStatus;

		public int combinedEyeDataStatus;

		public WVR_Vector3f_t leftEyeGazePoint;

		public WVR_Vector3f_t rightEyeGazePoint;

		public WVR_Vector3f_t combinedEyeGazePoint;

		public WVR_Vector3f_t leftEyeGazeVector;

		public WVR_Vector3f_t rightEyeGazeVector;

		public WVR_Vector3f_t combinedEyeGazeVector;

		public float leftEyeOpenness;

		public float rightEyeOpenness;

		public float leftEyePupilDilation;

		public float rightEyePupilDilation;

		public WVR_Vector3f_t leftEyePositionGuide;

		public WVR_Vector3f_t rightEyePositionGuide;

		public long timestamp;
	}
	public enum WVR_EyeDataStatus
	{
		WVR_GazePointValid = 1,
		WVR_GazeVectorValid = 2,
		WVR_EyeOpennessValid = 4,
		WVR_EyePupilDilationValid = 8,
		WVR_EyePositionGuideValid = 0x10
	}
	public enum WVR_QualityStrategy
	{
		WVR_QualityStrategy_Default = 1,
		WVR_QualityStrategy_SendQualityEvent = 2,
		WVR_QualityStrategy_AutoFoveation = 4,
		WVR_QualityStrategy_Reserved = 0x40000000
	}
	public enum WVR_Result
	{
		WVR_Success,
		WVR_Error_SystemInvalid,
		WVR_Error_InvalidArgument,
		WVR_Error_OutOfMemory,
		WVR_Error_FeatureNotSupport,
		WVR_Error_RuntimeVersionNotSupport
	}
	public enum WVR_HandGestureType
	{
		WVR_HandGestureType_Invalid,
		WVR_HandGestureType_Unknown,
		WVR_HandGestureType_Fist,
		WVR_HandGestureType_Five,
		WVR_HandGestureType_OK,
		WVR_HandGestureType_ThumbUp,
		WVR_HandGestureType_IndexUp,
		WVR_HandGestureType_Pinch
	}
	public struct WVR_HandGestureData_t
	{
		public long timestamp;

		public WVR_HandGestureType right;

		public WVR_HandGestureType left;
	}
	public struct WVR_SingleFinger_t
	{
		public WVR_Vector3f_t joint1;

		public WVR_Vector3f_t joint2;

		public WVR_Vector3f_t joint3;

		public WVR_Vector3f_t tip;
	}
	public struct WVR_Fingers_t
	{
		public WVR_SingleFinger_t thumb;

		public WVR_SingleFinger_t index;

		public WVR_SingleFinger_t middle;

		public WVR_SingleFinger_t ring;

		public WVR_SingleFinger_t pinky;
	}
	public struct WVR_HandTrackingData_t
	{
		public WVR_PoseState_t right;

		public WVR_Fingers_t rightFinger;

		public WVR_PoseState_t left;

		public WVR_Fingers_t leftFinger;
	}
	public enum WVR_SupportedFeature
	{
		WVR_SupportedFeature_PassthroughImage = 1,
		WVR_SupportedFeature_PassthroughOverlay = 2,
		WVR_SupportedFeature_HandTracking = 0x10,
		WVR_SupportedFeature_HandGesture = 0x20
	}
	public delegate void WVR_RequestCompleteCallback(List<WVR_RequestResult> results);
	public delegate void WVR_RequestUsbCompleteCallback(bool result);
	public delegate void WVR_OnOEMConfigChanged();
	public class Interop
	{
		public class WVR_Base
		{
			private static WVR_Base instance;

			public static WVR_Base Instance
			{
				get
				{
					if (instance == null)
					{
						instance = new WVR_Android();
					}
					return instance;
				}
			}

			public virtual bool PollEventQueue(ref WVR_Event_t e)
			{
				return false;
			}

			public virtual int GetInputDeviceCapability(WVR_DeviceType type, WVR_InputType inputType)
			{
				return 0;
			}

			public virtual WVR_AnalogType GetInputDeviceAnalogType(WVR_DeviceType type, WVR_InputId id)
			{
				return WVR_AnalogType.WVR_AnalogType_None;
			}

			public virtual bool GetInputDeviceState(WVR_DeviceType type, uint inputMask, ref uint buttons, ref uint touches, [In][Out] WVR_AnalogState_t[] analogArray, uint analogArrayCount)
			{
				return false;
			}

			public virtual int GetInputTypeCount(WVR_DeviceType type, WVR_InputType inputType)
			{
				return 0;
			}

			public virtual bool GetInputButtonState(WVR_DeviceType type, WVR_InputId id)
			{
				return false;
			}

			public virtual bool GetInputTouchState(WVR_DeviceType type, WVR_InputId id)
			{
				return false;
			}

			public virtual WVR_Axis_t GetInputAnalogAxis(WVR_DeviceType type, WVR_InputId id)
			{
				WVR_Axis_t result = default(WVR_Axis_t);
				result.x = 0f;
				result.y = 0f;
				return result;
			}

			public virtual void SetTextureBounds([In][Out] WVR_TextureBound_t[] textureBounds)
			{
			}

			public virtual void GetPoseState(WVR_DeviceType type, WVR_PoseOriginModel originModel, uint predictedMilliSec, ref WVR_PoseState_t poseState)
			{
			}

			public virtual void GetLastPoseIndex(WVR_PoseOriginModel originModel, [In][Out] WVR_DevicePosePair_t[] poseArray, uint pairArrayCount, ref uint frameIndex)
			{
			}

			public virtual void WaitGetPoseIndex(WVR_PoseOriginModel originModel, [In][Out] WVR_DevicePosePair_t[] poseArray, uint pairArrayCount, ref uint frameIndex)
			{
			}

			public virtual IntPtr StoreRenderTextures(IntPtr[] texturesIDs, int size, bool eEye, WVR_TextureTarget target)
			{
				return IntPtr.Zero;
			}

			public virtual void GetSyncPose(WVR_PoseOriginModel originModel, [In][Out] WVR_DevicePosePair_t[] poseArray, uint pairArrayCount)
			{
			}

			public virtual bool IsDeviceConnected(WVR_DeviceType type)
			{
				return false;
			}

			public virtual void TriggerVibration(WVR_DeviceType type, WVR_InputId id, uint durationMicroSec, uint frequency, WVR_Intensity intensity)
			{
			}

			public virtual void InAppRecenter(WVR_RecenterType recenterType)
			{
			}

			public virtual void SetNeckModelEnabled(bool enabled)
			{
			}

			public virtual void SetNeckModel(WVR_SimulationType simulationType)
			{
			}

			public virtual void SetArmModel(WVR_SimulationType simulationType)
			{
			}

			public virtual void SetArmSticky(bool stickyArm)
			{
			}

			public virtual bool SetInputRequest(WVR_DeviceType type, WVR_InputAttribute_t[] request, uint size)
			{
				return false;
			}

			public virtual bool GetInputMappingPair(WVR_DeviceType type, WVR_InputId destination, ref WVR_InputMappingPair_t pair)
			{
				return false;
			}

			public virtual uint GetInputMappingTable(WVR_DeviceType type, [In][Out] WVR_InputMappingPair_t[] table, uint size)
			{
				return 0u;
			}

			public virtual WVR_Arena_t GetArena()
			{
				return default(WVR_Arena_t);
			}

			public virtual bool SetArena(ref WVR_Arena_t arena)
			{
				return false;
			}

			public virtual WVR_ArenaVisible GetArenaVisible()
			{
				return WVR_ArenaVisible.WVR_ArenaVisible_Auto;
			}

			public virtual void SetArenaVisible(WVR_ArenaVisible config)
			{
			}

			public virtual bool IsOverArenaRange()
			{
				return false;
			}

			public virtual float GetDeviceBatteryPercentage(WVR_DeviceType type)
			{
				return 1f;
			}

			public virtual WVR_BatteryStatus GetBatteryStatus(WVR_DeviceType type)
			{
				return WVR_BatteryStatus.WVR_BatteryStatus_Normal;
			}

			public virtual WVR_ChargeStatus GetChargeStatus(WVR_DeviceType type)
			{
				return WVR_ChargeStatus.WVR_ChargeStatus_Full;
			}

			public virtual WVR_BatteryTemperatureStatus GetBatteryTemperatureStatus(WVR_DeviceType type)
			{
				return WVR_BatteryTemperatureStatus.WVR_BatteryTemperature_Normal;
			}

			public virtual float GetBatteryTemperature(WVR_DeviceType type)
			{
				return 0f;
			}

			public virtual WVR_Result StartHandGesture()
			{
				return WVR_Result.WVR_Error_FeatureNotSupport;
			}

			public virtual void StopHandGesture()
			{
			}

			public virtual WVR_Result GetHandGestureData(ref WVR_HandGestureData_t data)
			{
				data.timestamp = 0L;
				data.right = WVR_HandGestureType.WVR_HandGestureType_Invalid;
				data.left = WVR_HandGestureType.WVR_HandGestureType_Invalid;
				return WVR_Result.WVR_Error_FeatureNotSupport;
			}

			public virtual WVR_Result StartHandTracking()
			{
				return WVR_Result.WVR_Error_FeatureNotSupport;
			}

			public virtual void StopHandTracking()
			{
			}

			public virtual WVR_Result GetHandTrackingData(ref WVR_HandTrackingData_t data, WVR_PoseOriginModel originModel, uint predictedMilliSec)
			{
				return WVR_Result.WVR_Error_FeatureNotSupport;
			}

			public virtual ulong GetSupportedFeatures()
			{
				return 51uL;
			}

			public virtual WVR_InitError Init(WVR_AppType eType)
			{
				return WVR_InitError.WVR_InitError_None;
			}

			public virtual void PostInit()
			{
			}

			public virtual void Quit()
			{
			}

			public virtual IntPtr GetInitErrorString(WVR_InitError error)
			{
				return (IntPtr)0;
			}

			public virtual uint GetWaveRuntimeVersion()
			{
				return 1u;
			}

			public virtual uint GetWaveSDKVersion()
			{
				return 1u;
			}

			public virtual bool IsInputFocusCapturedBySystem()
			{
				return false;
			}

			internal virtual WVR_RenderError RenderInit(ref WVR_RenderInitParams_t param)
			{
				return WVR_RenderError.WVR_RenderError_None;
			}

			internal virtual bool SetPerformanceLevels(WVR_PerfLevel cpuLevel, WVR_PerfLevel gpuLevel)
			{
				return true;
			}

			internal virtual bool EnableAdaptiveQuality(bool enable, uint flags)
			{
				return true;
			}

			internal virtual bool IsAdaptiveQualityEnabled()
			{
				return false;
			}

			public virtual bool StartCamera(ref WVR_CameraInfo_t info)
			{
				return false;
			}

			public virtual void StopCamera()
			{
			}

			public virtual bool UpdateTexture(IntPtr textureid)
			{
				return false;
			}

			public virtual bool GetCameraIntrinsic(WVR_CameraPosition position, ref WVR_CameraIntrinsic_t intrinsic)
			{
				return true;
			}

			public virtual bool GetCameraFrameBuffer(IntPtr pFramebuffer, uint frameBufferSize)
			{
				return false;
			}

			public virtual bool GetFrameBufferWithPoseState(IntPtr frameBuffer, uint frameBufferSize, WVR_PoseOriginModel origin, uint predictInMs, ref WVR_PoseState_t poseState)
			{
				return false;
			}

			public virtual bool DrawTextureWithBuffer(IntPtr textureId, WVR_CameraImageFormat imgFormat, IntPtr frameBuffer, uint size, uint width, uint height)
			{
				return false;
			}

			public virtual void ReleaseCameraTexture()
			{
			}

			public virtual bool IsDeviceSuspend(WVR_DeviceType type)
			{
				return false;
			}

			public virtual void ConvertMatrixQuaternion(ref WVR_Matrix4f_t mat, ref WVR_Quatf_t quat, bool m2q)
			{
			}

			public virtual WVR_NumDoF GetDegreeOfFreedom(WVR_DeviceType type)
			{
				return WVR_NumDoF.WVR_NumDoF_3DoF;
			}

			public virtual void SetParameters(WVR_DeviceType type, IntPtr pchValue)
			{
			}

			public virtual uint GetParameters(WVR_DeviceType type, IntPtr pchValue, IntPtr retValue, uint unBufferSize)
			{
				return 0u;
			}

			public virtual WVR_DeviceType GetDefaultControllerRole()
			{
				return WVR_DeviceType.WVR_DeviceType_Invalid;
			}

			public virtual bool SetInteractionMode(WVR_InteractionMode mode)
			{
				return true;
			}

			public virtual WVR_InteractionMode GetInteractionMode()
			{
				return WVR_InteractionMode.WVR_InteractionMode_Controller;
			}

			public virtual bool SetGazeTriggerType(WVR_GazeTriggerType type)
			{
				return true;
			}

			public virtual WVR_GazeTriggerType GetGazeTriggerType()
			{
				return WVR_GazeTriggerType.WVR_GazeTriggerType_TimeoutButton;
			}

			public virtual bool GetDeviceErrorState(WVR_DeviceType dev_type, WVR_DeviceErrorState error_state)
			{
				return false;
			}

			public virtual void GetRenderTargetSize(ref uint width, ref uint height)
			{
			}

			public virtual WVR_Matrix4f_t GetProjection(WVR_Eye eye, float near, float far)
			{
				return default(WVR_Matrix4f_t);
			}

			public virtual void GetClippingPlaneBoundary(WVR_Eye eye, ref float left, ref float right, ref float top, ref float bottom)
			{
			}

			public virtual void SetOverfillRatio(float ratioX, float ratioY)
			{
			}

			public virtual WVR_Matrix4f_t GetTransformFromEyeToHead(WVR_Eye eye, WVR_NumDoF dof)
			{
				return default(WVR_Matrix4f_t);
			}

			public virtual WVR_SubmitError SubmitFrame(WVR_Eye eye, [In][Out] WVR_TextureParams_t[] param, [In][Out] WVR_PoseState_t[] pose, WVR_SubmitExtend extendMethod)
			{
				return WVR_SubmitError.WVR_SubmitError_None;
			}

			public virtual void SetSubmitParams(WVR_Eye eye, [In][Out] WVR_TextureParams_t[] param, [In][Out] WVR_PoseState_t[] pose, WVR_SubmitExtend extendMethod)
			{
			}

			public virtual void PreRenderEye(WVR_Eye eye, [Out] WVR_TextureParams_t[] param, [Out] WVR_RenderFoveationParams[] foveationParams)
			{
			}

			public virtual bool RequestScreenshot(uint width, uint height, WVR_ScreenshotMode mode, IntPtr filename)
			{
				return true;
			}

			public virtual void RenderMask(WVR_Eye eye)
			{
			}

			public virtual bool GetRenderProps(ref WVR_RenderProps_t props)
			{
				return true;
			}

			public virtual IntPtr ObtainTextureQueue(WVR_TextureTarget target, WVR_TextureFormat format, WVR_TextureType type, uint width, uint height, int level)
			{
				return (IntPtr)0;
			}

			public virtual uint GetTextureQueueLength(IntPtr handle)
			{
				return 0u;
			}

			public virtual WVR_TextureParams_t GetTexture(IntPtr handle, int index)
			{
				return default(WVR_TextureParams_t);
			}

			public virtual int GetAvailableTextureIndex(IntPtr handle)
			{
				return -1;
			}

			public virtual void ReleaseTextureQueue(IntPtr handle)
			{
			}

			public virtual bool IsRenderFoveationSupport()
			{
				return false;
			}

			public virtual void RenderFoveation(bool enable)
			{
			}

			public virtual void SetPosePredictEnabled(WVR_DeviceType type, bool enabled_position_predict, bool enable_rotation_predict)
			{
			}

			public virtual bool ShowPassthroughOverlay(bool show)
			{
				return false;
			}

			public virtual void EnableAutoPassthrough(bool enable)
			{
			}

			public virtual bool IsPassthroughOverlayVisible()
			{
				return false;
			}

			public virtual string DeployRenderModelAssets(int deviceIndex, string renderModelName)
			{
				return "";
			}

			public virtual void SetFocusedController(WVR_DeviceType focusController)
			{
			}

			public virtual WVR_DeviceType GetFocusedController()
			{
				return WVR_DeviceType.WVR_DeviceType_Controller_Right;
			}

			public virtual bool OpenMesh(string filename, ref uint sessiionid, IntPtr errorCode, bool merge)
			{
				return false;
			}

			public virtual bool GetSectionCount(uint sessionid, ref uint sectionCount)
			{
				return false;
			}

			public virtual bool GetMeshData(uint sessionid, [In][Out] FBXInfo_t[] infoArray)
			{
				return false;
			}

			public virtual bool GetSectionData(uint sessionid, uint sectionIndiceIndex, [In][Out] Vector3[] vecticeArray, [In][Out] Vector3[] normalArray, [In][Out] Vector2[] uvArray, [In][Out] int[] indiceArray, ref bool active)
			{
				return false;
			}

			public virtual void ReleaseMesh(uint sessionid)
			{
			}

			public virtual bool IsPermissionInitialed()
			{
				return true;
			}

			public virtual bool ShowDialogOnScene()
			{
				return true;
			}

			public virtual bool IsPermissionGranted(string permission)
			{
				return true;
			}

			public virtual bool ShouldGrantPermission(string permission)
			{
				return false;
			}

			public virtual void RequestPermissions(string[] permissions, WVR_RequestCompleteCallback cb)
			{
				List<WVR_RequestResult> list = new List<WVR_RequestResult>();
				if (permissions != null)
				{
					WVR_RequestResult item = default(WVR_RequestResult);
					for (int i = 0; i < permissions.Length; i++)
					{
						item.mPermission = permissions[i];
						item.mGranted = true;
						list.Add(item);
					}
				}
				cb(list);
			}

			public virtual void RequestUsbPermission(WVR_RequestUsbCompleteCallback cb)
			{
				cb(result: true);
			}

			public virtual string GetStringBySystemLanguage(string stringName)
			{
				return stringName;
			}

			public virtual string GetStringByLanguage(string stringName, string lang, string country)
			{
				return stringName;
			}

			public virtual string GetSystemLanguage()
			{
				return "";
			}

			public virtual string GetSystemCountry()
			{
				return "";
			}

			public virtual string GetOEMConfigByKey(string key)
			{
				return "";
			}

			public virtual void SetOEMConfigChangedCallback(WVR_OnOEMConfigChanged cb)
			{
			}
		}

		public static bool WVR_PollEventQueue(ref WVR_Event_t e)
		{
			return WVR_Base.Instance.PollEventQueue(ref e);
		}

		public static int WVR_GetInputDeviceCapability(WVR_DeviceType type, WVR_InputType inputType)
		{
			return WVR_Base.Instance.GetInputDeviceCapability(type, inputType);
		}

		public static WVR_AnalogType WVR_GetInputDeviceAnalogType(WVR_DeviceType type, WVR_InputId id)
		{
			return WVR_Base.Instance.GetInputDeviceAnalogType(type, id);
		}

		public static bool WVR_GetInputDeviceState(WVR_DeviceType type, uint inputMask, ref uint buttons, ref uint touches, [In][Out] WVR_AnalogState_t[] analogArray, uint analogArrayCount)
		{
			return WVR_Base.Instance.GetInputDeviceState(type, inputMask, ref buttons, ref touches, analogArray, analogArrayCount);
		}

		public static int WVR_GetInputTypeCount(WVR_DeviceType type, WVR_InputType inputType)
		{
			return WVR_Base.Instance.GetInputTypeCount(type, inputType);
		}

		public static bool WVR_GetInputButtonState(WVR_DeviceType type, WVR_InputId id)
		{
			return WVR_Base.Instance.GetInputButtonState(type, id);
		}

		public static bool WVR_GetInputTouchState(WVR_DeviceType type, WVR_InputId id)
		{
			return WVR_Base.Instance.GetInputTouchState(type, id);
		}

		public static WVR_Axis_t WVR_GetInputAnalogAxis(WVR_DeviceType type, WVR_InputId id)
		{
			return WVR_Base.Instance.GetInputAnalogAxis(type, id);
		}

		public static void WVR_GetPoseState(WVR_DeviceType type, WVR_PoseOriginModel originModel, uint predictedMilliSec, ref WVR_PoseState_t poseState)
		{
			WVR_Base.Instance.GetPoseState(type, originModel, predictedMilliSec, ref poseState);
		}

		public static void WVR_SetTextureBounds([In][Out] WVR_TextureBound_t[] textureBounds)
		{
			WVR_Base.Instance.SetTextureBounds(textureBounds);
		}

		public static void WVR_GetLastPoseIndex(WVR_PoseOriginModel originModel, [In][Out] WVR_DevicePosePair_t[] poseArray, uint pairArrayCount, ref uint frameIndex)
		{
			WVR_Base.Instance.GetLastPoseIndex(originModel, poseArray, pairArrayCount, ref frameIndex);
		}

		public static void WVR_WaitGetPoseIndex(WVR_PoseOriginModel originModel, [In][Out] WVR_DevicePosePair_t[] poseArray, uint pairArrayCount, ref uint frameIndex)
		{
			WVR_Base.Instance.WaitGetPoseIndex(originModel, poseArray, pairArrayCount, ref frameIndex);
		}

		public static IntPtr WVR_StoreRenderTextures(IntPtr[] texturesIDs, int size, bool eEye, WVR_TextureTarget target)
		{
			return WVR_Base.Instance.StoreRenderTextures(texturesIDs, size, eEye, target);
		}

		public static void WVR_GetSyncPose(WVR_PoseOriginModel originModel, [In][Out] WVR_DevicePosePair_t[] poseArray, uint pairArrayCount)
		{
			WVR_Base.Instance.GetSyncPose(originModel, poseArray, pairArrayCount);
		}

		public static bool WVR_IsDeviceConnected(WVR_DeviceType type)
		{
			return WVR_Base.Instance.IsDeviceConnected(type);
		}

		public static void WVR_TriggerVibration(WVR_DeviceType type, WVR_InputId id, uint durationMicroSec, uint frequency, WVR_Intensity intensity)
		{
			WVR_Base.Instance.TriggerVibration(type, id, durationMicroSec, frequency, intensity);
		}

		public static void WVR_InAppRecenter(WVR_RecenterType recenterType)
		{
			WVR_Base.Instance.InAppRecenter(recenterType);
		}

		public static void WVR_SetNeckModelEnabled(bool enabled)
		{
			WVR_Base.Instance.SetNeckModelEnabled(enabled);
		}

		public static void WVR_SetNeckModel(WVR_SimulationType simulationType)
		{
			WVR_Base.Instance.SetNeckModel(simulationType);
		}

		public static void WVR_SetArmModel(WVR_SimulationType simulationType)
		{
			WVR_Base.Instance.SetArmModel(simulationType);
		}

		public static void WVR_SetArmSticky(bool stickyArm)
		{
			WVR_Base.Instance.SetArmSticky(stickyArm);
		}

		public static bool WVR_SetInputRequest(WVR_DeviceType type, WVR_InputAttribute_t[] request, uint size)
		{
			return WVR_Base.Instance.SetInputRequest(type, request, size);
		}

		public static bool WVR_GetInputMappingPair(WVR_DeviceType type, WVR_InputId destination, ref WVR_InputMappingPair_t pair)
		{
			return WVR_Base.Instance.GetInputMappingPair(type, destination, ref pair);
		}

		public static uint WVR_GetInputMappingTable(WVR_DeviceType type, [In][Out] WVR_InputMappingPair_t[] table, uint size)
		{
			return WVR_Base.Instance.GetInputMappingTable(type, table, size);
		}

		public static WVR_Arena_t WVR_GetArena()
		{
			return WVR_Base.Instance.GetArena();
		}

		public static bool WVR_SetArena(ref WVR_Arena_t arena)
		{
			return WVR_Base.Instance.SetArena(ref arena);
		}

		public static WVR_ArenaVisible WVR_GetArenaVisible()
		{
			return WVR_Base.Instance.GetArenaVisible();
		}

		public static void WVR_SetArenaVisible(WVR_ArenaVisible config)
		{
			WVR_Base.Instance.SetArenaVisible(config);
		}

		public static bool WVR_IsOverArenaRange()
		{
			return WVR_Base.Instance.IsOverArenaRange();
		}

		public static float WVR_GetDeviceBatteryPercentage(WVR_DeviceType type)
		{
			return WVR_Base.Instance.GetDeviceBatteryPercentage(type);
		}

		public static WVR_BatteryStatus WVR_GetBatteryStatus(WVR_DeviceType type)
		{
			return WVR_Base.Instance.GetBatteryStatus(type);
		}

		public static WVR_ChargeStatus WVR_GetChargeStatus(WVR_DeviceType type)
		{
			return WVR_Base.Instance.GetChargeStatus(type);
		}

		public static WVR_BatteryTemperatureStatus WVR_GetBatteryTemperatureStatus(WVR_DeviceType type)
		{
			return WVR_Base.Instance.GetBatteryTemperatureStatus(type);
		}

		public static float WVR_GetBatteryTemperature(WVR_DeviceType type)
		{
			return WVR_Base.Instance.GetBatteryTemperature(type);
		}

		public static WVR_Result WVR_StartHandGesture()
		{
			return WVR_Base.Instance.StartHandGesture();
		}

		public static void WVR_StopHandGesture()
		{
			WVR_Base.Instance.StopHandGesture();
		}

		public static WVR_Result WVR_GetHandGestureData(ref WVR_HandGestureData_t data)
		{
			return WVR_Base.Instance.GetHandGestureData(ref data);
		}

		public static WVR_Result WVR_StartHandTracking()
		{
			return WVR_Base.Instance.StartHandTracking();
		}

		public static void WVR_StopHandTracking()
		{
			WVR_Base.Instance.StopHandTracking();
		}

		public static WVR_Result WVR_GetHandTrackingData(ref WVR_HandTrackingData_t data, WVR_PoseOriginModel originModel, uint predictedMilliSec)
		{
			return WVR_Base.Instance.GetHandTrackingData(ref data, originModel, predictedMilliSec);
		}

		public static ulong WVR_GetSupportedFeatures()
		{
			return WVR_Base.Instance.GetSupportedFeatures();
		}

		public static WVR_InitError WVR_Init(WVR_AppType eType)
		{
			return WVR_Base.Instance.Init(eType);
		}

		public static void WVR_PostInit()
		{
			WVR_Base.Instance.PostInit();
		}

		public static void WVR_Quit()
		{
			WVR_Base.Instance.Quit();
		}

		public static IntPtr WVR_GetInitErrorString(WVR_InitError error)
		{
			return WVR_Base.Instance.GetInitErrorString(error);
		}

		public static uint WVR_GetWaveRuntimeVersion()
		{
			return WVR_Base.Instance.GetWaveRuntimeVersion();
		}

		public static uint WVR_GetWaveSDKVersion()
		{
			return WVR_Base.Instance.GetWaveSDKVersion();
		}

		public static bool WVR_IsInputFocusCapturedBySystem()
		{
			return WVR_Base.Instance.IsInputFocusCapturedBySystem();
		}

		internal static WVR_RenderError WVR_RenderInit(ref WVR_RenderInitParams_t param)
		{
			return WVR_Base.Instance.RenderInit(ref param);
		}

		public static bool WVR_SetPerformanceLevels(WVR_PerfLevel cpuLevel, WVR_PerfLevel gpuLevel)
		{
			return WVR_Base.Instance.SetPerformanceLevels(cpuLevel, gpuLevel);
		}

		public static bool WVR_EnableAdaptiveQuality(bool enable, uint flags)
		{
			return WVR_Base.Instance.EnableAdaptiveQuality(enable, flags);
		}

		public static bool WVR_IsAdaptiveQualityEnabled()
		{
			return WVR_Base.Instance.IsAdaptiveQualityEnabled();
		}

		public static bool WVR_StartCamera(ref WVR_CameraInfo_t info)
		{
			return WVR_Base.Instance.StartCamera(ref info);
		}

		public static void WVR_StopCamera()
		{
			WVR_Base.Instance.StopCamera();
		}

		public static bool WVR_UpdateTexture(IntPtr textureid)
		{
			return WVR_Base.Instance.UpdateTexture(textureid);
		}

		public static bool WVR_GetCameraIntrinsic(WVR_CameraPosition position, ref WVR_CameraIntrinsic_t intrinsic)
		{
			return WVR_Base.Instance.GetCameraIntrinsic(position, ref intrinsic);
		}

		public static bool WVR_GetCameraFrameBuffer(IntPtr pFramebuffer, uint frameBufferSize)
		{
			return WVR_Base.Instance.GetCameraFrameBuffer(pFramebuffer, frameBufferSize);
		}

		public static bool WVR_GetFrameBufferWithPoseState(IntPtr frameBuffer, uint frameBufferSize, WVR_PoseOriginModel origin, uint predictInMs, ref WVR_PoseState_t poseState)
		{
			return WVR_Base.Instance.GetFrameBufferWithPoseState(frameBuffer, frameBufferSize, origin, predictInMs, ref poseState);
		}

		public static bool WVR_DrawTextureWithBuffer(IntPtr textureId, WVR_CameraImageFormat imgFormat, IntPtr frameBuffer, uint size, uint width, uint height)
		{
			return WVR_Base.Instance.DrawTextureWithBuffer(textureId, imgFormat, frameBuffer, size, width, height);
		}

		public static void WVR_ReleaseCameraTexture()
		{
			WVR_Base.Instance.ReleaseCameraTexture();
		}

		public static bool WVR_IsDeviceSuspend(WVR_DeviceType type)
		{
			return WVR_Base.Instance.IsDeviceSuspend(type);
		}

		public static void WVR_ConvertMatrixQuaternion(ref WVR_Matrix4f_t mat, ref WVR_Quatf_t quat, bool m2q)
		{
			WVR_Base.Instance.ConvertMatrixQuaternion(ref mat, ref quat, m2q);
		}

		public static WVR_NumDoF WVR_GetDegreeOfFreedom(WVR_DeviceType type)
		{
			return WVR_Base.Instance.GetDegreeOfFreedom(type);
		}

		public static void WVR_SetParameters(WVR_DeviceType type, IntPtr pchValue)
		{
			WVR_Base.Instance.SetParameters(type, pchValue);
		}

		public static uint WVR_GetParameters(WVR_DeviceType type, IntPtr pchValue, IntPtr retValue, uint unBufferSize)
		{
			return WVR_Base.Instance.GetParameters(type, pchValue, retValue, unBufferSize);
		}

		public static WVR_DeviceType WVR_GetDefaultControllerRole()
		{
			return WVR_Base.Instance.GetDefaultControllerRole();
		}

		public static bool WVR_SetInteractionMode(WVR_InteractionMode mode)
		{
			return WVR_Base.Instance.SetInteractionMode(mode);
		}

		public static WVR_InteractionMode WVR_GetInteractionMode()
		{
			return WVR_Base.Instance.GetInteractionMode();
		}

		public static bool WVR_SetGazeTriggerType(WVR_GazeTriggerType type)
		{
			return WVR_Base.Instance.SetGazeTriggerType(type);
		}

		public static WVR_GazeTriggerType WVR_GetGazeTriggerType()
		{
			return WVR_Base.Instance.GetGazeTriggerType();
		}

		public static bool WVR_GetDeviceErrorState(WVR_DeviceType dev_type, WVR_DeviceErrorState error_state)
		{
			return WVR_Base.Instance.GetDeviceErrorState(dev_type, error_state);
		}

		public static void WVR_GetRenderTargetSize(ref uint width, ref uint height)
		{
			WVR_Base.Instance.GetRenderTargetSize(ref width, ref height);
		}

		public static WVR_Matrix4f_t WVR_GetProjection(WVR_Eye eye, float near, float far)
		{
			return WVR_Base.Instance.GetProjection(eye, near, far);
		}

		public static void WVR_GetClippingPlaneBoundary(WVR_Eye eye, ref float left, ref float right, ref float top, ref float bottom)
		{
			WVR_Base.Instance.GetClippingPlaneBoundary(eye, ref left, ref right, ref top, ref bottom);
		}

		public static void WVR_SetOverfillRatio(float ratioX, float ratioY)
		{
			WVR_Base.Instance.SetOverfillRatio(ratioX, ratioY);
		}

		public static WVR_Matrix4f_t WVR_GetTransformFromEyeToHead(WVR_Eye eye, WVR_NumDoF dof)
		{
			return WVR_Base.Instance.GetTransformFromEyeToHead(eye, dof);
		}

		public static WVR_SubmitError WVR_SubmitFrame(WVR_Eye eye, [In][Out] WVR_TextureParams_t[] param, [In][Out] WVR_PoseState_t[] pose, WVR_SubmitExtend extendMethod)
		{
			return WVR_Base.Instance.SubmitFrame(eye, param, pose, extendMethod);
		}

		public static void WVR_SetSubmitParams(WVR_Eye eye, [In][Out] WVR_TextureParams_t[] param, [In][Out] WVR_PoseState_t[] pose, WVR_SubmitExtend extendMethod)
		{
			WVR_Base.Instance.SetSubmitParams(eye, param, pose, extendMethod);
		}

		public static void WVR_PreRenderEye(WVR_Eye eye, [In][Out] WVR_TextureParams_t[] param, [In][Out] WVR_RenderFoveationParams[] foveationParams)
		{
			WVR_Base.Instance.PreRenderEye(eye, param, foveationParams);
		}

		public static bool WVR_RequestScreenshot(uint width, uint height, WVR_ScreenshotMode mode, IntPtr filename)
		{
			return WVR_Base.Instance.RequestScreenshot(width, height, mode, filename);
		}

		public static void WVR_RenderMask(WVR_Eye eye)
		{
			WVR_Base.Instance.RenderMask(eye);
		}

		public static bool WVR_GetRenderProps(ref WVR_RenderProps_t props)
		{
			return WVR_Base.Instance.GetRenderProps(ref props);
		}

		public static IntPtr WVR_ObtainTextureQueue(WVR_TextureTarget target, WVR_TextureFormat format, WVR_TextureType type, uint width, uint height, int level)
		{
			return WVR_Base.Instance.ObtainTextureQueue(target, format, type, width, height, level);
		}

		public static uint WVR_GetTextureQueueLength(IntPtr handle)
		{
			return WVR_Base.Instance.GetTextureQueueLength(handle);
		}

		public static WVR_TextureParams_t WVR_GetTexture(IntPtr handle, int index)
		{
			return WVR_Base.Instance.GetTexture(handle, index);
		}

		public static int WVR_GetAvailableTextureIndex(IntPtr handle)
		{
			return WVR_Base.Instance.GetAvailableTextureIndex(handle);
		}

		public static void WVR_ReleaseTextureQueue(IntPtr handle)
		{
			WVR_Base.Instance.ReleaseTextureQueue(handle);
		}

		public static bool WVR_IsRenderFoveationSupport()
		{
			return WVR_Base.Instance.IsRenderFoveationSupport();
		}

		public static void WVR_RenderFoveation(bool enable)
		{
			WVR_Base.Instance.RenderFoveation(enable);
		}

		public static bool WVR_IsPermissionInitialed()
		{
			return WVR_Base.Instance.IsPermissionInitialed();
		}

		public static bool WVR_ShowDialogOnScene()
		{
			return WVR_Base.Instance.ShowDialogOnScene();
		}

		public static bool WVR_IsPermissionGranted(string permission)
		{
			return WVR_Base.Instance.IsPermissionGranted(permission);
		}

		public static bool WVR_ShouldGrantPermission(string permission)
		{
			return WVR_Base.Instance.ShouldGrantPermission(permission);
		}

		public static void WVR_RequestPermissions(string[] permissions, WVR_RequestCompleteCallback cb)
		{
			WVR_Base.Instance.RequestPermissions(permissions, cb);
		}

		public static void WVR_RequestUsbPermission(WVR_RequestUsbCompleteCallback cb)
		{
			WVR_Base.Instance.RequestUsbPermission(cb);
		}

		public static string WVR_GetStringBySystemLanguage(string stringName)
		{
			return WVR_Base.Instance.GetStringBySystemLanguage(stringName);
		}

		public static string WVR_GetStringByLanguage(string stringName, string lang, string country)
		{
			return WVR_Base.Instance.GetStringByLanguage(stringName, lang, country);
		}

		public static string WVR_GetSystemLanguage()
		{
			return WVR_Base.Instance.GetSystemLanguage();
		}

		public static string WVR_GetSystemCountry()
		{
			return WVR_Base.Instance.GetSystemCountry();
		}

		public static void WVR_SetPosePredictEnabled(WVR_DeviceType type, bool enabled_position_predict, bool enable_rotation_predict)
		{
			WVR_Base.Instance.SetPosePredictEnabled(type, enabled_position_predict, enable_rotation_predict);
		}

		public static bool WVR_ShowPassthroughOverlay(bool show)
		{
			return WVR_Base.Instance.ShowPassthroughOverlay(show);
		}

		public static void WVR_EnableAutoPassthrough(bool enable)
		{
			WVR_Base.Instance.EnableAutoPassthrough(enable);
		}

		public static bool WVR_IsPassthroughOverlayVisible()
		{
			return WVR_Base.Instance.IsPassthroughOverlayVisible();
		}

		public static string WVR_DeployRenderModelAssets(int deviceIndex, string renderModelName)
		{
			return WVR_Base.Instance.DeployRenderModelAssets(deviceIndex, renderModelName);
		}

		public static void WVR_SetFocusedController(WVR_DeviceType focusController)
		{
			WVR_Base.Instance.SetFocusedController(focusController);
		}

		public static WVR_DeviceType WVR_GetFocusedController()
		{
			return WVR_Base.Instance.GetFocusedController();
		}

		public static bool WVR_OpenMesh(string filename, ref uint sessionid, IntPtr errorCode, bool merge)
		{
			return WVR_Base.Instance.OpenMesh(filename, ref sessionid, errorCode, merge);
		}

		public static bool WVR_GetSectionCount(uint sessionid, ref uint sectionCount)
		{
			return WVR_Base.Instance.GetSectionCount(sessionid, ref sectionCount);
		}

		public static bool WVR_GetMeshData(uint sessionid, [In][Out] FBXInfo_t[] infoArray)
		{
			return WVR_Base.Instance.GetMeshData(sessionid, infoArray);
		}

		public static bool WVR_GetSectionData(uint sessionid, uint sectionIndiceIndex, [In][Out] Vector3[] vecticeArray, [In][Out] Vector3[] normalArray, [In][Out] Vector2[] uvArray, [In][Out] int[] indiceArray, ref bool active)
		{
			return WVR_Base.Instance.GetSectionData(sessionid, sectionIndiceIndex, vecticeArray, normalArray, uvArray, indiceArray, ref active);
		}

		public static void WVR_ReleaseMesh(uint sessiionid)
		{
			WVR_Base.Instance.ReleaseMesh(sessiionid);
		}

		public static string WVR_GetOEMConfigByKey(string key)
		{
			return WVR_Base.Instance.GetOEMConfigByKey(key);
		}

		public static void WVR_SetOEMConfigChangedCallback(WVR_OnOEMConfigChanged cb)
		{
			WVR_Base.Instance.SetOEMConfigChangedCallback(cb);
		}
	}
	public class WaveVR_AdaptiveQuality : MonoBehaviour
	{
		[Serializable]
		public class AQSerializableClass
		{
			[Tooltip("Allow set quality strategy is send quality event. SendQualityEvent = false if quality strategy use default.")]
			public bool SendQualityEvent = true;

			[Tooltip("Allow set auto foveation quality strategy. AutoFoveation = false if quality strategy disable foveation.")]
			public bool AutoFoveation;
		}

		private const string TAG = "WVRAQ";

		private static bool isEnabled;

		[Tooltip("The Rendering Performance Improve Strategy for send quality event and handle.")]
		public AQSerializableClass m_RenderingPerformanceImproveStrategy;

		private IEnumerator RunEnableAQ()
		{
			while (!WaveVR_Render.Instance || !WaveVR_Render.Instance.IsGraphicReady)
			{
				yield return new WaitForSeconds(1f);
			}
			WVR_Log.Log.i("WVRAQ", "Enable AQ");
			WVR_QualityStrategy wVR_QualityStrategy = ((!m_RenderingPerformanceImproveStrategy.SendQualityEvent) ? WVR_QualityStrategy.WVR_QualityStrategy_Default : WVR_QualityStrategy.WVR_QualityStrategy_SendQualityEvent);
			WVR_QualityStrategy wVR_QualityStrategy2 = ((!m_RenderingPerformanceImproveStrategy.AutoFoveation) ? WVR_QualityStrategy.WVR_QualityStrategy_Default : WVR_QualityStrategy.WVR_QualityStrategy_AutoFoveation);
			isEnabled = Interop.WVR_EnableAdaptiveQuality(enable: true, (uint)(wVR_QualityStrategy | wVR_QualityStrategy2));
			if (isEnabled)
			{
				WVR_Log.Log.i("WVRAQ", "Enabled");
			}
		}

		private void OnEnable()
		{
			StartCoroutine("RunEnableAQ");
		}

		private void OnDisable()
		{
			StopCoroutine("RunEnableAQ");
			WVR_Log.Log.i("WVRAQ", "Disable AQ");
			isEnabled = Interop.WVR_EnableAdaptiveQuality(enable: false, 1u);
			if (!isEnabled)
			{
				WVR_Log.Log.i("WVRAQ", "Disabled");
				GetComponent<WaveVR_DynamicResolution>().Reset();
			}
			WVR_Log.Log.i("WVRAQ", "SetPerformaceLevels all max");
			Interop.WVR_SetPerformanceLevels(WVR_PerfLevel.WVR_PerfLevel_Maximum, WVR_PerfLevel.WVR_PerfLevel_Maximum);
		}
	}
}
namespace wvr.TypeExtensions
{
	public static class ClassExtensions
	{
	}
	public static class EnumExtensions
	{
		public static string Name(this WVR_DeviceType e)
		{
			return e switch
			{
				WVR_DeviceType.WVR_DeviceType_Controller_Left => "controller left", 
				WVR_DeviceType.WVR_DeviceType_Controller_Right => "controller right", 
				WVR_DeviceType.WVR_DeviceType_HMD => "HMD", 
				_ => "Invalidate", 
			};
		}

		public static string Name(this WVR_InputId e)
		{
			return e switch
			{
				WVR_InputId.WVR_InputId_0 => "Syste", 
				WVR_InputId.WVR_InputId_1 => "Menu", 
				WVR_InputId.WVR_InputId_2 => "Grip", 
				WVR_InputId.WVR_InputId_3 => "DPad_Left", 
				WVR_InputId.WVR_InputId_4 => "DPad_Up", 
				WVR_InputId.WVR_InputId_5 => "DPad_Right", 
				WVR_InputId.WVR_InputId_6 => "DPad_Down", 
				WVR_InputId.WVR_InputId_7 => "Volume_Up", 
				WVR_InputId.WVR_InputId_8 => "Volume_Down", 
				WVR_InputId.WVR_InputId_9 => "Digital_Trigger", 
				WVR_InputId.WVR_InputId_14 => "Back", 
				WVR_InputId.WVR_InputId_15 => "Enter", 
				WVR_InputId.WVR_InputId_16 => "Touchpad", 
				WVR_InputId.WVR_InputId_17 => "Trigger", 
				WVR_InputId.WVR_InputId_18 => "Thumbstick", 
				_ => e.ToString(), 
			};
		}
	}
}
namespace wvr.render
{
	public class WaveVR_DynamicResolution : MonoBehaviour
	{
		public enum AQEvent
		{
			None,
			ManualHigher,
			ManualLower,
			Higher,
			Lower
		}

		[Tooltip("The ResolutionScale help set a scaled resolution to be lower than the default.  An index will go higher or lower according to the AdaptiveQuality's event.  You can choose one of resolution scale from this list as a default resolution scale by setting the default index.")]
		[SerializeField]
		private List<float> resolutionScaleList = new List<float>();

		[Tooltip("You can choose one of resolution scale from this list as a default resolution scale by setting the default index.")]
		[SerializeField]
		private int defaultIndex;

		private int index;

		[Tooltip("The unit used for measuring text size here is dmm (Distance-Independent Millimeter). The method of conversion from Unity text size into dmm can be found in the documentation of the SDK.")]
		[SerializeField]
		[Range(20f, 40f)]
		private int textSize = 20;

		private float currentLowerBound = 0.1f;

		private bool isInitialized;

		private const string LOG_TAG = "WVRDynRes";

		public float CurrentScale => resolutionScaleList[index];

		public AQEvent CurrentAQEvent { get; private set; }

		private void OnEnable()
		{
			if (resolutionScaleList.Count < 2)
			{
				WVR_Log.Log.e("WVRDynRes", "Not to enable because the list is empty.");
				return;
			}
			WaveVR_Utils.Event.Listen(WVR_EventType.WVR_EventType_RecommendedQuality_Higher.ToString(), HigherHandler);
			WaveVR_Utils.Event.Listen(WVR_EventType.WVR_EventType_RecommendedQuality_Lower.ToString(), LowerHandler);
			index = defaultIndex;
			CurrentAQEvent = AQEvent.None;
			WaveVR_Render.Instance.onFirstFrame = InitDynamicResolution;
		}

		private void OnDisable()
		{
			WaveVR_Utils.Event.Remove(WVR_EventType.WVR_EventType_RecommendedQuality_Higher.ToString(), HigherHandler);
			WaveVR_Utils.Event.Remove(WVR_EventType.WVR_EventType_RecommendedQuality_Lower.ToString(), LowerHandler);
			index = defaultIndex;
			WaveVR_Render.Instance.SetResolutionScale(1f);
		}

		public void Higher()
		{
			HigherHandler();
			CurrentAQEvent = AQEvent.ManualHigher;
		}

		private void HigherHandler(params object[] args)
		{
			if (isInitialized)
			{
				if (--index < 0)
				{
					index = 0;
				}
				WaveVR_Render.Instance.SetResolutionScale(resolutionScaleList[index]);
				CurrentAQEvent = AQEvent.Higher;
				WVR_Log.Log.d("WVRDynRes", "Event Higher: [" + index + "]=" + resolutionScaleList[index]);
			}
		}

		public void Lower()
		{
			LowerHandler();
			CurrentAQEvent = AQEvent.ManualLower;
		}

		private void LowerHandler(params object[] args)
		{
			if (isInitialized)
			{
				if (++index >= resolutionScaleList.Count)
				{
					index = resolutionScaleList.Count - 1;
				}
				WaveVR_Render.Instance.SetResolutionScale(resolutionScaleList[index]);
				CurrentAQEvent = AQEvent.Lower;
				WVR_Log.Log.d("WVRDynRes", "Event Lower: [" + index + "]=" + resolutionScaleList[index]);
			}
		}

		public void Reset()
		{
			CurrentAQEvent = AQEvent.None;
			if (base.enabled)
			{
				index = defaultIndex;
				WaveVR_Render.Instance.SetResolutionScale(resolutionScaleList[index]);
				WVR_Log.Log.d("WVRDynRes", "Event Reset: [" + index + "]=" + resolutionScaleList[index]);
			}
		}

		private void InitDynamicResolution(WaveVR_Render waveVR_Render)
		{
			DefineLowerBound();
			SetListLowerBound();
			isInitialized = true;
		}

		private void SetListLowerBound()
		{
			int num = resolutionScaleList.Count - 1;
			while (resolutionScaleList[num] < currentLowerBound)
			{
				resolutionScaleList.RemoveAt(num);
				num--;
			}
			resolutionScaleList.Add(currentLowerBound);
			FormatResolutionScaleList();
			if (index > num)
			{
				index = (defaultIndex = num);
			}
			WVR_Log.Log.d("WVRDynRes", "Finalilzed Resolution Scale List: " + resolutionScaleList.ToString());
			WaveVR_Render.Instance.SetResolutionScale(resolutionScaleList[index]);
		}

		private float GetResScaleFromDMM()
		{
			float num = 178.15f * (float)(textSize * textSize) - 14419f * (float)textSize + 356704f;
			WVR_Log.Log.d("WVRDynRes", "Get P60D from DMM: " + num);
			float num2 = WaveVR_Render.Instance.sceneWidth / 2f;
			float num3 = WaveVR_Render.Instance.sceneHeight / 2f;
			float[] projRawL = WaveVR_Render.Instance.projRawL;
			float f = Mathf.Tan((float)Math.PI / 6f);
			float num4 = Mathf.Sqrt(num / (Mathf.Pow(f, 2f) * num3 * num2 * (1f / Mathf.Abs(projRawL[0]) + 1f / Mathf.Abs(projRawL[1])) * (1f / Mathf.Abs(projRawL[2]) + 1f / Mathf.Abs(projRawL[3]))));
			WVR_Log.Log.d("WVRDynRes", "Eye Buffer Width: " + num2 + " Eye Buffer Height: " + num3);
			WVR_Log.Log.d("WVRDynRes", "Projection: " + string.Join(", ", projRawL.Select((float p) => p.ToString()).ToArray()));
			WVR_Log.Log.d("WVRDynRes", "Get Resolution Scale from P60D: " + num4);
			return num4;
		}

		private void DefineLowerBound()
		{
			FormatResolutionScaleList();
			currentLowerBound = Mathf.Max(GetResScaleFromDMM(), resolutionScaleList[resolutionScaleList.Count - 1]);
		}

		private void FormatResolutionScaleList()
		{
			FloatComparer comparer = new FloatComparer();
			resolutionScaleList.Sort(comparer);
			resolutionScaleList = resolutionScaleList.Distinct().ToList();
		}

		private void OnValidate()
		{
			while (resolutionScaleList.Count < 2)
			{
				resolutionScaleList.Add(1f);
			}
			if (defaultIndex < 0 || defaultIndex >= resolutionScaleList.Count)
			{
				defaultIndex = 0;
			}
		}
	}
	internal class FloatComparer : IComparer<float>
	{
		public int Compare(float x, float y)
		{
			return y.CompareTo(x);
		}
	}
	public class WaveVR_FoveatedRendering : MonoBehaviour
	{
		public static string TAG = "WVR_Foveated";

		public static string StaticTrackedObjectName = "StaticFoveatedTrackedObject";

		private static bool useValuesInInspector = true;

		[Tooltip("The the central region around left eye's focal point.  We guarantee the resolution here will be 100%.  The FOV value is diameter.")]
		[Range(1f, 179f)]
		[SerializeField]
		private float leftClearVisionFOV = 38f;

		[Tooltip("The the central region around right eye's focal point.  We guarantee the resolution here will be 100%.  The FOV value is diameter.")]
		[Range(1f, 179f)]
		[SerializeField]
		private float rightClearVisionFOV = 38f;

		[Tooltip("The peripheral is the region around the left eye's clear vision FOV.  Its resolution will depend on this quality setting.")]
		[SerializeField]
		private WVR_PeripheralQuality leftPeripheralQuality = WVR_PeripheralQuality.High;

		[Tooltip("The peripheral is the region around the right eye's clear vision FOV.  Itsresolution will depend on this quality setting.")]
		[SerializeField]
		private WVR_PeripheralQuality rightPeripheralQuality = WVR_PeripheralQuality.High;

		[Tooltip("A Focal Point for static foveated rendering without eye tracking.  Both eye will focus on this point.  Therefore the both lines linked from focal point to two eyes will not be parallel.  We will calculate the focal point on screen for you.\nThe default focal point will generate a tracked object in front of the eye center.  Assign a custom tracked object will ignore this setting.")]
		[SerializeField]
		private Vector3 staticFocalPoint = new Vector3(0f, 0f, 10f);

		private static bool isEnabled = false;

		[Tooltip("The focal point will always on the tracked object.")]
		[SerializeField]
		private GameObject trackedObject;

		private GameObject staticTrackedObject;

		private bool isDirty = true;

		public static WaveVR_FoveatedRendering Instance { get; private set; }

		public float LeftClearVisionFOV
		{
			get
			{
				return leftClearVisionFOV;
			}
			set
			{
				leftClearVisionFOV = Mathf.Clamp(value, 1f, 179f);
				isDirty = true;
			}
		}

		public float RightClearVisionFOV
		{
			get
			{
				return rightClearVisionFOV;
			}
			set
			{
				rightClearVisionFOV = Mathf.Clamp(value, 1f, 179f);
				isDirty = true;
			}
		}

		public WVR_PeripheralQuality LeftPeripheralQuality
		{
			get
			{
				return leftPeripheralQuality;
			}
			set
			{
				leftPeripheralQuality = value;
				isDirty = true;
			}
		}

		public WVR_PeripheralQuality RightPeripheralQuality
		{
			get
			{
				return rightPeripheralQuality;
			}
			set
			{
				rightPeripheralQuality = value;
				isDirty = true;
			}
		}

		public Vector3 StaticFocalPoint
		{
			get
			{
				return staticFocalPoint;
			}
			set
			{
				staticFocalPoint = value;
				isDirty = true;
			}
		}

		public GameObject TrackedObject
		{
			get
			{
				return trackedObject;
			}
			set
			{
				trackedObject = value;
				isDirty = true;
			}
		}

		public Vector2 LeftNDCSpace { get; private set; }

		public Vector2 RightNDCSpace { get; private set; }

		public void Apply()
		{
			useValuesInInspector = true;
			doUpdate();
		}

		private void ValidateFOV(float fov)
		{
			if (fov < 1f || fov > 179f)
			{
				throw new ArgumentOutOfRangeException("FOV should be in the range of [1, 179] degrees.");
			}
		}

		private void ValidateQuality(WVR_PeripheralQuality quality)
		{
			if (quality < WVR_PeripheralQuality.Low || quality > WVR_PeripheralQuality.High)
			{
				throw new ArgumentOutOfRangeException("Quality should be one of the WVR_PeripheralQuality.");
			}
		}

		public void Validate()
		{
			ValidateFOV(leftClearVisionFOV);
			ValidateFOV(rightClearVisionFOV);
			ValidateQuality(leftPeripheralQuality);
			ValidateQuality(rightPeripheralQuality);
		}

		public void Set(WVR_Eye eye, float clearVisionFOV, WVR_PeripheralQuality quality)
		{
			ValidateFOV(clearVisionFOV);
			ValidateQuality(quality);
			switch (eye)
			{
			case WVR_Eye.WVR_Eye_Left:
				leftClearVisionFOV = clearVisionFOV;
				leftPeripheralQuality = quality;
				break;
			case WVR_Eye.WVR_Eye_Right:
				rightClearVisionFOV = clearVisionFOV;
				rightPeripheralQuality = quality;
				break;
			default:
				throw new ArgumentException(string.Concat("Eye (", eye, ") should be WVR_Eye_Left or WVR_Eye_Right."));
			}
			isDirty = true;
		}

		public void Set(float clearVisionFOV, WVR_PeripheralQuality quality)
		{
			ValidateFOV(clearVisionFOV);
			ValidateQuality(quality);
			leftClearVisionFOV = (rightClearVisionFOV = clearVisionFOV);
			leftPeripheralQuality = (rightPeripheralQuality = quality);
			isDirty = true;
		}

		private IEnumerator SetEnableCoroutine()
		{
			while (base.enabled && !isEnabled)
			{
				WaveVR_Render instance = WaveVR_Render.Instance;
				if (instance != null && instance.IsGraphicReady)
				{
					if (Interop.WVR_IsRenderFoveationSupport())
					{
						Interop.WVR_RenderFoveation(enable: true);
						Instance = this;
						isEnabled = true;
						WVR_Log.Log.d(TAG, "Foveated rendering is enabled.", logInEditor: true);
					}
					else
					{
						WVR_Log.Log.d(TAG, "Foveated rendering is not supported.");
					}
				}
				yield return null;
				WVR_Log.Log.gpl.d(TAG, "Waiting for graphic ready to enable foveated rendering.", logInEditor: true);
			}
		}

		private void OnEnable()
		{
			if (!isEnabled)
			{
				StartCoroutine("SetEnableCoroutine");
			}
		}

		private void OnDisable()
		{
			if (isEnabled && Instance == this)
			{
				Instance = null;
				StopCoroutine("SetEnableCoroutine");
				Interop.WVR_RenderFoveation(enable: false);
				isEnabled = false;
			}
		}

		private void CreateTrackedObject(WaveVR_Render render)
		{
			Transform transform = ((!(staticTrackedObject != null)) ? render.centerWVRCamera.transform.Find(StaticTrackedObjectName) : staticTrackedObject.transform);
			if (transform == null)
			{
				transform = new GameObject(StaticTrackedObjectName).transform;
				transform.localPosition = staticFocalPoint;
				transform.SetParent(render.centerWVRCamera.transform, worldPositionStays: false);
			}
			trackedObject = transform.gameObject;
		}

		private void LateUpdate()
		{
			if (isDirty)
			{
				doUpdate();
			}
		}

		private void doUpdate()
		{
			if (!isEnabled || !useValuesInInspector || Instance != this)
			{
				WVR_Log.Log.gpl.d(TAG, "LateUpdate: !isEnabled || !useValuesInInspector || Instance != this");
				return;
			}
			WaveVR_Render instance = WaveVR_Render.Instance;
			if (instance == null || !instance.isExpanded)
			{
				WVR_Log.Log.gpl.d(TAG, "LateUpdate: render == null || !render.isExpanded");
				return;
			}
			if (trackedObject == null)
			{
				CreateTrackedObject(instance);
			}
			Vector3 position = trackedObject.transform.position;
			LeftNDCSpace = WorldToNDC_GL(instance.lefteye.GetCamera(), position);
			if (LeftNDCSpace.sqrMagnitude > 1f)
			{
				LeftNDCSpace = LeftNDCSpace.normalized;
			}
			SetFoveatedRenderingParameterCheck(WVR_Eye.WVR_Eye_Left, LeftNDCSpace.x, LeftNDCSpace.y, leftClearVisionFOV, leftPeripheralQuality);
			RightNDCSpace = WorldToNDC_GL(instance.righteye.GetCamera(), position);
			if (RightNDCSpace.sqrMagnitude > 1f)
			{
				RightNDCSpace = RightNDCSpace.normalized;
			}
			SetFoveatedRenderingParameterCheck(WVR_Eye.WVR_Eye_Right, RightNDCSpace.x, RightNDCSpace.y, rightClearVisionFOV, rightPeripheralQuality);
			if (trackedObject == staticTrackedObject)
			{
				isDirty = false;
			}
		}

		public static Vector2 WorldToNDC_GL(Camera camera, Vector3 worldPoint)
		{
			Vector4 vector = camera.projectionMatrix * camera.worldToCameraMatrix * new Vector4(worldPoint.x, worldPoint.y, worldPoint.z, 1f);
			return new Vector2(vector.x, vector.y) / vector.w;
		}

		private static void SetFoveatedRenderingParameterCheck(WVR_Eye eye, float ndcFocalPointX, float ndcFocalPointY, float clearVisionFOV, WVR_PeripheralQuality quality)
		{
			if (eye == WVR_Eye.WVR_Eye_Both || eye == WVR_Eye.WVR_Eye_None)
			{
				throw new ArgumentException(string.Concat("Invalid argument: eye (", eye, ") should be WVR_Eye_Left or WVR_Eye_Right."));
			}
			if (quality < WVR_PeripheralQuality.Low || quality > WVR_PeripheralQuality.High)
			{
				throw new ArgumentException(string.Concat("Invalid argument: level (", quality, ") should be in WVR_PeripheralQuality range."));
			}
			WaveVR_Render.SetFoveatedRenderingParameter(eye, ndcFocalPointX, ndcFocalPointY, clearVisionFOV, quality);
		}

		public static void SetFoveatedRenderingParameter(WVR_Eye eye, float ndcFocalPointX, float ndcFocalPointY, float clearVisionFOV, WVR_PeripheralQuality quality)
		{
			useValuesInInspector = true;
			SetFoveatedRenderingParameterCheck(eye, ndcFocalPointX, ndcFocalPointY, clearVisionFOV, quality);
		}

		public static void SetFoveatedRenderingParameter(WVR_Eye eye, Vector2 ndcSpace, float clearVisionFOV, WVR_PeripheralQuality quality)
		{
			useValuesInInspector = true;
			ndcSpace = ndcSpace.normalized;
			SetFoveatedRenderingParameterCheck(eye, ndcSpace.x, ndcSpace.y, clearVisionFOV, quality);
		}
	}
	public struct TextureConfig
	{
		public int w;

		public int h;

		public int depth;

		public RenderTextureFormat format;

		public bool useMipMap;

		public int anisoLevel;

		public FilterMode filterMode;

		public TextureWrapMode wrapMode;

		public int antiAliasing;

		public override bool Equals(object a)
		{
			TextureConfig textureConfig = (TextureConfig)a;
			return this == textureConfig;
		}

		public override int GetHashCode()
		{
			return 0;
		}

		public static bool operator ==(TextureConfig a, TextureConfig b)
		{
			if (a.w == b.w && a.h == b.h)
			{
				return a.antiAliasing == b.antiAliasing;
			}
			return false;
		}

		public static bool operator !=(TextureConfig a, TextureConfig b)
		{
			if (a.w == b.w && a.h == b.h)
			{
				return a.antiAliasing != b.antiAliasing;
			}
			return true;
		}
	}
	public class EyeConfig
	{
		public bool isBoth { get; protected set; }

		public bool isLeft { get; protected set; }

		public bool isRight { get; protected set; }

		public EyeConfig(WVR_Eye eye)
		{
			if (eye == WVR_Eye.WVR_Eye_Both)
			{
				isLeft = false;
				isRight = false;
				isBoth = true;
			}
			else
			{
				isLeft = eye == WVR_Eye.WVR_Eye_Left;
				isRight = !isLeft;
			}
		}
	}
	public abstract class TexturePool<T> : EyeConfig where T : class
	{
		private IntPtr queue;

		private List<T> rts = new List<T>();

		private Dictionary<int, T> textures = new Dictionary<int, T>();

		private Dictionary<int, int> depthes = new Dictionary<int, int>();

		private Dictionary<int, TextureConfig> cfgs = new Dictionary<int, TextureConfig>();

		protected TextureConfig cfg;

		private int[] keyArray;

		public TextureConfig Config
		{
			get
			{
				return cfg;
			}
			set
			{
				cfg = value;
			}
		}

		public int size { get; private set; }

		public T currentRt { get; private set; }

		public int currentPtr { get; private set; }

		public int currentDepthPtr { get; private set; }

		public bool isReleased { get; private set; }

		public bool isTextureChanged { get; private set; }

		protected abstract T CreateTexture(TextureConfig cfg);

		protected abstract int GetNativePtr(T rt);

		protected abstract int GetNativeDepthBufferPtr(T rt);

		protected abstract void ReleaseTexture(T rt);

		public TexturePool(TextureConfig cfg, int size, WVR_Eye eye)
			: base(eye)
		{
			this.cfg = cfg;
			using (WVR_Log.Log.ee(TextureManager.TAG, "TexturePool+", "TexturePool-"))
			{
				isReleased = false;
				base.isLeft = base.isLeft;
				this.size = size;
				StackTraceLogType stackTraceLogType = UnityEngine.Application.GetStackTraceLogType(LogType.Error);
				UnityEngine.Application.SetStackTraceLogType(LogType.Error, StackTraceLogType.None);
				for (int i = 0; i < size; i++)
				{
					rts.Add(CreateTexture(cfg));
				}
				for (int j = 0; j < size; j++)
				{
					T val = rts[j];
					currentPtr = GetNativePtr(val);
					currentDepthPtr = GetNativeDepthBufferPtr(val);
					textures.Add(currentPtr, val);
					depthes.Add(currentPtr, currentDepthPtr);
					cfgs.Add(currentPtr, cfg);
					WVR_Log.Log.i(TextureManager.TAG, "Gen rt" + currentPtr + " dp" + currentDepthPtr);
				}
				WVR_Log.Log.e(TextureManager.TAG, "Don't worry about the libEGL and Unity error showing above.  They are safe and will not crash your game.");
				UnityEngine.Application.SetStackTraceLogType(LogType.Error, stackTraceLogType);
				keyArray = new int[textures.Count];
				textures.Keys.CopyTo(keyArray, 0);
				if (eye == WVR_Eye.WVR_Eye_Both)
				{
					queue = WaveVR_Utils.WVR_StoreRenderTextures(keyArray, size, base.isBoth || base.isLeft, WVR_TextureTarget.WVR_TextureTarget_2D_ARRAY);
				}
				else
				{
					queue = WaveVR_Utils.WVR_StoreRenderTextures(keyArray, size, base.isBoth || base.isLeft, WVR_TextureTarget.WVR_TextureTarget_2D);
				}
			}
		}

		~TexturePool()
		{
			keyArray = null;
			if (depthes != null)
			{
				depthes.Clear();
			}
			if (cfgs != null)
			{
				cfgs.Clear();
			}
			if (rts != null)
			{
				foreach (T rt in rts)
				{
					ReleaseTexture(rt);
				}
				rts.Clear();
			}
			if (textures != null)
			{
				textures.Clear();
			}
			if (queue != IntPtr.Zero)
			{
				Interop.WVR_ReleaseTextureQueue(queue);
			}
			queue = IntPtr.Zero;
		}

		private T GetRenderTextureByPtr(int ptr)
		{
			T value = null;
			if (!textures.TryGetValue(ptr, out value))
			{
				WVR_Log.Log.e(TextureManager.TAG, "Unknown RenderTexture ID" + ptr);
			}
			return value;
		}

		private int GetDepthByPtr(int ptr)
		{
			int value = 0;
			if (!depthes.TryGetValue(ptr, out value))
			{
				WVR_Log.Log.e(TextureManager.TAG, "Unknown RenderTexture ID" + ptr);
			}
			return value;
		}

		public void next()
		{
			if (!isReleased)
			{
				bool flag = false;
				if (isTextureChanged)
				{
					isTextureChanged = false;
					flag = true;
				}
				WVR_Log.Log.gpl.d(TextureManager.TAG, "Get texture from queue");
				currentPtr = (int)WaveVR_Utils.WVR_GetAvailableTextureID(queue);
				currentRt = GetRenderTextureByPtr(currentPtr);
				currentDepthPtr = GetDepthByPtr(currentPtr);
				if (!flag && !CfgValidate(currentPtr))
				{
					isTextureChanged = true;
					ReplaceCurrentWithNewTexture();
				}
			}
		}

		private bool CfgValidate(int nativePtr)
		{
			if (cfgs.TryGetValue(nativePtr, out var value))
			{
				return !(value != cfg);
			}
			return false;
		}

		private void ReplaceCurrentWithNewTexture()
		{
			StackTraceLogType stackTraceLogType = UnityEngine.Application.GetStackTraceLogType(LogType.Error);
			UnityEngine.Application.SetStackTraceLogType(LogType.Error, StackTraceLogType.None);
			textures.Remove(currentPtr);
			depthes.Remove(currentPtr);
			cfgs.Remove(currentPtr);
			rts.Remove(currentRt);
			ReleaseTexture(currentRt);
			T val = CreateTexture(cfg);
			rts.Add(val);
			int nativePtr = GetNativePtr(val);
			int nativeDepthBufferPtr = GetNativeDepthBufferPtr(val);
			textures.Add(nativePtr, val);
			depthes.Add(nativePtr, nativeDepthBufferPtr);
			cfgs.Add(nativePtr, cfg);
			WVR_Log.Log.i(TextureManager.TAG, WVR_Log.Log.CSB.Append("Rm  rt=").Append(currentPtr).Append(" dp=")
				.Append(currentDepthPtr)
				.Append(" ")
				.Append("Gen rt=")
				.Append(nativePtr)
				.Append(" dp=")
				.Append(nativeDepthBufferPtr)
				.ToString());
			WVR_Log.Log.e(TextureManager.TAG, "If the libEGL and Unity errors appeared above, don't panic or report a bug.  They are safe and will not crash your game.");
			UnityEngine.Application.SetStackTraceLogType(LogType.Error, stackTraceLogType);
			if (keyArray.Length != textures.Count)
			{
				keyArray = new int[textures.Count];
			}
			textures.Keys.CopyTo(keyArray, 0);
			WaveVR_Utils.WVR_ReplaceCurrentTextureID(queue, new IntPtr(nativePtr));
			currentRt = val;
			currentPtr = nativePtr;
			currentDepthPtr = nativeDepthBufferPtr;
		}

		public void Release()
		{
			using (WVR_Log.Log.ee(TextureManager.TAG, "TexturePool<" + typeof(T).Name + "> Release()+", "TexturePool Release()-"))
			{
				if (isReleased)
				{
					return;
				}
				isReleased = true;
				keyArray = null;
				if (rts != null)
				{
					StackTraceLogType stackTraceLogType = UnityEngine.Application.GetStackTraceLogType(LogType.Error);
					UnityEngine.Application.SetStackTraceLogType(LogType.Error, StackTraceLogType.None);
					foreach (T rt in rts)
					{
						ReleaseTexture(rt);
					}
					UnityEngine.Application.SetStackTraceLogType(LogType.Error, stackTraceLogType);
					rts.Clear();
				}
				if (textures != null)
				{
					textures.Clear();
				}
				if (depthes != null)
				{
					depthes.Clear();
				}
				if (cfgs != null)
				{
					cfgs.Clear();
				}
				if (queue != IntPtr.Zero)
				{
					Interop.WVR_ReleaseTextureQueue(queue);
				}
				queue = IntPtr.Zero;
				size = 0;
				currentPtr = 0;
				currentDepthPtr = 0;
				currentRt = null;
			}
		}
	}
	public class TexturePool2DArray : TexturePool<Texture2DArray>
	{
		public TexturePool2DArray(TextureConfig cfg, int size)
			: base(cfg, size, WVR_Eye.WVR_Eye_Both)
		{
		}

		protected override Texture2DArray CreateTexture(TextureConfig cfg)
		{
			return new Texture2DArray(cfg.w, cfg.h, 2, TextureFormat.ARGB32, cfg.useMipMap, linear: false)
			{
				wrapMode = cfg.wrapMode,
				anisoLevel = cfg.anisoLevel
			};
		}

		protected override int GetNativePtr(Texture2DArray rt)
		{
			if (!(rt == null))
			{
				return (int)rt.GetNativeTexturePtr();
			}
			return 0;
		}

		protected override int GetNativeDepthBufferPtr(Texture2DArray rt)
		{
			return 0;
		}

		protected override void ReleaseTexture(Texture2DArray rt)
		{
		}
	}
	public class TexturePoolRenderTexture2DArray : TexturePool<RenderTexture>
	{
		public TexturePoolRenderTexture2DArray(TextureConfig cfg, int size)
			: base(cfg, size, WVR_Eye.WVR_Eye_Both)
		{
		}

		protected override RenderTexture CreateTexture(TextureConfig cfg)
		{
			RenderTexture renderTexture = new RenderTexture(cfg.w, cfg.h, cfg.depth, cfg.format, RenderTextureReadWrite.Default);
			renderTexture.useMipMap = cfg.useMipMap;
			renderTexture.wrapMode = cfg.wrapMode;
			renderTexture.filterMode = cfg.filterMode;
			renderTexture.anisoLevel = cfg.anisoLevel;
			renderTexture.antiAliasing = cfg.antiAliasing;
			renderTexture.dimension = TextureDimension.Tex2DArray;
			renderTexture.volumeDepth = 2;
			renderTexture.vrUsage = VRTextureUsage.TwoEyes;
			renderTexture.Create();
			return renderTexture;
		}

		protected override int GetNativePtr(RenderTexture rt)
		{
			if (!(rt == null))
			{
				return (int)rt.GetNativeTexturePtr();
			}
			return 0;
		}

		protected override int GetNativeDepthBufferPtr(RenderTexture rt)
		{
			if (!(rt == null))
			{
				return (int)rt.GetNativeDepthBufferPtr();
			}
			return 0;
		}

		protected override void ReleaseTexture(RenderTexture rt)
		{
			if (rt != null)
			{
				rt.Release();
				UnityEngine.Object.Destroy(rt);
			}
		}
	}
	public class TexturePoolRenderTexture : TexturePool<RenderTexture>
	{
		public TexturePoolRenderTexture(TextureConfig cfg, int size, WVR_Eye eye)
			: base(cfg, size, eye)
		{
		}

		protected override RenderTexture CreateTexture(TextureConfig cfg)
		{
			RenderTexture renderTexture = new RenderTexture(cfg.w, cfg.h, cfg.depth, cfg.format, RenderTextureReadWrite.Default);
			renderTexture.useMipMap = cfg.useMipMap;
			renderTexture.wrapMode = cfg.wrapMode;
			renderTexture.filterMode = cfg.filterMode;
			renderTexture.anisoLevel = cfg.anisoLevel;
			renderTexture.antiAliasing = cfg.antiAliasing;
			renderTexture.Create();
			return renderTexture;
		}

		protected override int GetNativePtr(RenderTexture rt)
		{
			if (!(rt == null))
			{
				return (int)rt.GetNativeTexturePtr();
			}
			return 0;
		}

		protected override int GetNativeDepthBufferPtr(RenderTexture rt)
		{
			if (!(rt == null))
			{
				return (int)rt.GetNativeDepthBufferPtr();
			}
			return 0;
		}

		protected override void ReleaseTexture(RenderTexture rt)
		{
			if (rt != null)
			{
				rt.Release();
				UnityEngine.Object.Destroy(rt);
			}
		}
	}
	public class TextureManager
	{
		public static readonly string TAG = "WVR_TexMngr";

		private int poolSize = 3;

		private int screenWidth = 1024;

		private int screenHeight = 1024;

		private readonly float pixelDensity = 1f;

		private float resolutionScale = 1f;

		public bool IsSinglePass { get; private set; }

		public bool AllowAntiAliasing { get; private set; }

		public TexturePoolRenderTexture left { get; private set; }

		public TexturePoolRenderTexture right { get; private set; }

		public TexturePoolRenderTexture2DArray both { get; private set; }

		public float PixelDensity => pixelDensity;

		public float ResolutionScale => resolutionScale;

		public float FinalScale => pixelDensity * resolutionScale;

		public bool isTextureChanged { get; private set; }

		public TextureManager(TextureManager oldTextureManager, bool isSinglePass, bool allowAntiAliasing, float pixelDensity = 1f, float resolutionScale = 1f)
		{
			using (WVR_Log.Log.ee(TAG, "TextureManager(singlepass=" + isSinglePass + " allowAntiAliasing=" + allowAntiAliasing + ") +", "TextureManager()-"))
			{
				left = null;
				right = null;
				both = null;
				this.pixelDensity = pixelDensity;
				this.resolutionScale = resolutionScale;
				IsSinglePass = isSinglePass;
				AllowAntiAliasing = allowAntiAliasing;
				if (oldTextureManager != null)
				{
					left = oldTextureManager.left;
					oldTextureManager.left = null;
					right = oldTextureManager.right;
					oldTextureManager.right = null;
					both = oldTextureManager.both;
					oldTextureManager.both = null;
				}
				oldTextureManager = null;
				GC.Collect();
				reset();
			}
		}

		public void ReleaseTexturePools()
		{
			using (WVR_Log.Log.ee(TAG, "ReleaseTexturePools"))
			{
				if (left != null)
				{
					left.Release();
				}
				if (right != null)
				{
					right.Release();
				}
				if (both != null)
				{
					both.Release();
				}
			}
		}

		private float GetPreviewImageRatio()
		{
			return 1f;
		}

		private static int ToMultipleOfTwo(int value)
		{
			if (value % 2 == 0)
			{
				return value;
			}
			return value + 1;
		}

		public void reset()
		{
			using (WVR_Log.Log.ee(TAG, "reset"))
			{
				poolSize = WaveVR_Utils.WVR_GetNumberOfTextures();
				uint width;
				uint height = (width = (uint)Mathf.Max(Screen.width / 2, Screen.height));
				Interop.WVR_GetRenderTargetSize(ref width, ref height);
				screenWidth = (int)width;
				screenHeight = (int)height;
				float previewImageRatio = GetPreviewImageRatio();
				int num = ToMultipleOfTwo((int)((float)screenWidth * FinalScale * previewImageRatio));
				int num2 = ToMultipleOfTwo((int)((float)screenHeight * FinalScale * previewImageRatio));
				int num3 = (AllowAntiAliasing ? QualitySettings.antiAliasing : 0);
				if (num3 == 0)
				{
					num3 = 1;
				}
				WVR_Log.Log.d(TAG, "Texture width=" + num + " height=" + num2 + " antiAliasing=" + num3);
				TextureConfig textureConfig = default(TextureConfig);
				textureConfig.w = num;
				textureConfig.h = num2;
				textureConfig.depth = 24;
				textureConfig.format = RenderTextureFormat.ARGB32;
				textureConfig.useMipMap = false;
				textureConfig.wrapMode = TextureWrapMode.Clamp;
				textureConfig.filterMode = FilterMode.Bilinear;
				textureConfig.anisoLevel = 1;
				textureConfig.antiAliasing = num3;
				if (!validate())
				{
					ReleaseTexturePools();
					left = null;
					right = null;
					both = null;
				}
				if (IsSinglePass)
				{
					if (both == null)
					{
						both = new TexturePoolRenderTexture2DArray(textureConfig, poolSize);
					}
					else
					{
						both.Config = textureConfig;
					}
					return;
				}
				if (left == null)
				{
					left = new TexturePoolRenderTexture(textureConfig, poolSize, WVR_Eye.WVR_Eye_Left);
				}
				else
				{
					left.Config = textureConfig;
				}
				if (right == null)
				{
					right = new TexturePoolRenderTexture(textureConfig, poolSize, WVR_Eye.WVR_Eye_Right);
				}
				else
				{
					right.Config = textureConfig;
				}
			}
		}

		public bool validate()
		{
			if (IsSinglePass)
			{
				if (both != null)
				{
					return !both.isReleased;
				}
				return false;
			}
			if (left != null && right != null && !left.isReleased)
			{
				return !right.isReleased;
			}
			return false;
		}

		public void Resize(float resolutionScale = 1f)
		{
			resolutionScale = Mathf.Clamp(resolutionScale, 0.1f, 1f);
			if (resolutionScale < 1f && Mathf.Abs(this.resolutionScale - resolutionScale) < 0.0001f)
			{
				WVR_Log.Log.d(TAG, "Skip similar resize change.");
				return;
			}
			this.resolutionScale = resolutionScale;
			float previewImageRatio = GetPreviewImageRatio();
			int num = ToMultipleOfTwo((int)((float)screenWidth * FinalScale * previewImageRatio));
			int num2 = ToMultipleOfTwo((int)((float)screenHeight * FinalScale * previewImageRatio));
			WVR_Log.Log.d(TAG, WVR_Log.Log.CSB.Append("Resized texture width=").Append(num).Append(", height=")
				.Append(num2)
				.ToString());
			if (IsSinglePass)
			{
				TextureConfig config = both.Config;
				config.w = num;
				config.h = num2;
				both.Config = config;
				return;
			}
			TextureConfig config2 = left.Config;
			config2.w = num;
			config2.h = num2;
			left.Config = config2;
			config2 = right.Config;
			config2.w = num;
			config2.h = num2;
			right.Config = config2;
		}

		public void Next()
		{
			if (!validate())
			{
				reset();
			}
			isTextureChanged = false;
			if (IsSinglePass)
			{
				both.next();
				isTextureChanged = both.isTextureChanged;
			}
			else
			{
				left.next();
				right.next();
				isTextureChanged = left.isTextureChanged;
			}
		}

		public int GetNativePtr(WVR_Eye eye)
		{
			return eye switch
			{
				WVR_Eye.WVR_Eye_Both => both.currentPtr, 
				WVR_Eye.WVR_Eye_Left => left.currentPtr, 
				WVR_Eye.WVR_Eye_Right => right.currentPtr, 
				_ => 0, 
			};
		}

		public int GetNativePtrLR(bool isLeftEye)
		{
			if (!isLeftEye)
			{
				return right.currentPtr;
			}
			return left.currentPtr;
		}

		public int GetNativePtrBoth()
		{
			return both.currentPtr;
		}

		public Texture GetRenderTexture(WVR_Eye eye)
		{
			return eye switch
			{
				WVR_Eye.WVR_Eye_Both => both.currentRt, 
				WVR_Eye.WVR_Eye_Left => left.currentRt, 
				WVR_Eye.WVR_Eye_Right => right.currentRt, 
				_ => null, 
			};
		}

		public RenderTexture GetRenderTextureBoth()
		{
			return both.currentRt;
		}

		public RenderTexture GetRenderTextureLR(bool isLeftEye)
		{
			if (!isLeftEye)
			{
				return right.currentRt;
			}
			return left.currentRt;
		}
	}
}
namespace wvr.render.gl
{
	public static class UGL
	{
		public enum GLenum2
		{
			GL_DEPTH_BUFFER_BIT = 256,
			GL_STENCIL_BUFFER_BIT = 1024,
			GL_COLOR_BUFFER_BIT = 16384,
			GL_FALSE = 0,
			GL_TRUE = 1,
			GL_POINTS = 0,
			GL_LINES = 1,
			GL_LINE_LOOP = 2,
			GL_LINE_STRIP = 3,
			GL_TRIANGLES = 4,
			GL_TRIANGLE_STRIP = 5,
			GL_TRIANGLE_FAN = 6,
			GL_ZERO = 0,
			GL_ONE = 1,
			GL_SRC_COLOR = 768,
			GL_ONE_MINUS_SRC_COLOR = 769,
			GL_SRC_ALPHA = 770,
			GL_ONE_MINUS_SRC_ALPHA = 771,
			GL_DST_ALPHA = 772,
			GL_ONE_MINUS_DST_ALPHA = 773,
			GL_DST_COLOR = 774,
			GL_ONE_MINUS_DST_COLOR = 775,
			GL_SRC_ALPHA_SATURATE = 776,
			GL_FUNC_ADD = 32774,
			GL_BLEND_EQUATION = 32777,
			GL_BLEND_EQUATION_RGB = 32777,
			GL_BLEND_EQUATION_ALPHA = 34877,
			GL_FUNC_SUBTRACT = 32778,
			GL_FUNC_REVERSE_SUBTRACT = 32779,
			GL_BLEND_DST_RGB = 32968,
			GL_BLEND_SRC_RGB = 32969,
			GL_BLEND_DST_ALPHA = 32970,
			GL_BLEND_SRC_ALPHA = 32971,
			GL_CONSTANT_COLOR = 32769,
			GL_ONE_MINUS_CONSTANT_COLOR = 32770,
			GL_CONSTANT_ALPHA = 32771,
			GL_ONE_MINUS_CONSTANT_ALPHA = 32772,
			GL_BLEND_COLOR = 32773,
			GL_ARRAY_BUFFER = 34962,
			GL_ELEMENT_ARRAY_BUFFER = 34963,
			GL_ARRAY_BUFFER_BINDING = 34964,
			GL_ELEMENT_ARRAY_BUFFER_BINDING = 34965,
			GL_STREAM_DRAW = 35040,
			GL_STATIC_DRAW = 35044,
			GL_DYNAMIC_DRAW = 35048,
			GL_BUFFER_SIZE = 34660,
			GL_BUFFER_USAGE = 34661,
			GL_CURRENT_VERTEX_ATTRIB = 34342,
			GL_FRONT = 1028,
			GL_BACK = 1029,
			GL_FRONT_AND_BACK = 1032,
			GL_TEXTURE_2D = 3553,
			GL_CULL_FACE = 2884,
			GL_BLEND = 3042,
			GL_DITHER = 3024,
			GL_STENCIL_TEST = 2960,
			GL_DEPTH_TEST = 2929,
			GL_SCISSOR_TEST = 3089,
			GL_POLYGON_OFFSET_FILL = 32823,
			GL_SAMPLE_ALPHA_TO_COVERAGE = 32926,
			GL_SAMPLE_COVERAGE = 32928,
			GL_NO_ERROR = 0,
			GL_INVALID_ENUM = 1280,
			GL_INVALID_VALUE = 1281,
			GL_INVALID_OPERATION = 1282,
			GL_OUT_OF_MEMORY = 1285,
			GL_CW = 2304,
			GL_CCW = 2305,
			GL_LINE_WIDTH = 2849,
			GL_ALIASED_POINT_SIZE_RANGE = 33901,
			GL_ALIASED_LINE_WIDTH_RANGE = 33902,
			GL_CULL_FACE_MODE = 2885,
			GL_FRONT_FACE = 2886,
			GL_DEPTH_RANGE = 2928,
			GL_DEPTH_WRITEMASK = 2930,
			GL_DEPTH_CLEAR_VALUE = 2931,
			GL_DEPTH_FUNC = 2932,
			GL_STENCIL_CLEAR_VALUE = 2961,
			GL_STENCIL_FUNC = 2962,
			GL_STENCIL_FAIL = 2964,
			GL_STENCIL_PASS_DEPTH_FAIL = 2965,
			GL_STENCIL_PASS_DEPTH_PASS = 2966,
			GL_STENCIL_REF = 2967,
			GL_STENCIL_VALUE_MASK = 2963,
			GL_STENCIL_WRITEMASK = 2968,
			GL_STENCIL_BACK_FUNC = 34816,
			GL_STENCIL_BACK_FAIL = 34817,
			GL_STENCIL_BACK_PASS_DEPTH_FAIL = 34818,
			GL_STENCIL_BACK_PASS_DEPTH_PASS = 34819,
			GL_STENCIL_BACK_REF = 36003,
			GL_STENCIL_BACK_VALUE_MASK = 36004,
			GL_STENCIL_BACK_WRITEMASK = 36005,
			GL_VIEWPORT = 2978,
			GL_SCISSOR_BOX = 3088,
			GL_COLOR_CLEAR_VALUE = 3106,
			GL_COLOR_WRITEMASK = 3107,
			GL_UNPACK_ALIGNMENT = 3317,
			GL_PACK_ALIGNMENT = 3333,
			GL_MAX_TEXTURE_SIZE = 3379,
			GL_MAX_VIEWPORT_DIMS = 3386,
			GL_SUBPIXEL_BITS = 3408,
			GL_RED_BITS = 3410,
			GL_GREEN_BITS = 3411,
			GL_BLUE_BITS = 3412,
			GL_ALPHA_BITS = 3413,
			GL_DEPTH_BITS = 3414,
			GL_STENCIL_BITS = 3415,
			GL_POLYGON_OFFSET_UNITS = 10752,
			GL_POLYGON_OFFSET_FACTOR = 32824,
			GL_TEXTURE_BINDING_2D = 32873,
			GL_SAMPLE_BUFFERS = 32936,
			GL_SAMPLES = 32937,
			GL_SAMPLE_COVERAGE_VALUE = 32938,
			GL_SAMPLE_COVERAGE_INVERT = 32939,
			GL_NUM_COMPRESSED_TEXTURE_FORMATS = 34466,
			GL_COMPRESSED_TEXTURE_FORMATS = 34467,
			GL_DONT_CARE = 4352,
			GL_FASTEST = 4353,
			GL_NICEST = 4354,
			GL_GENERATE_MIPMAP_HINT = 33170,
			GL_BYTE = 5120,
			GL_UNSIGNED_BYTE = 5121,
			GL_SHORT = 5122,
			GL_UNSIGNED_SHORT = 5123,
			GL_INT = 5124,
			GL_UNSIGNED_INT = 5125,
			GL_FLOAT = 5126,
			GL_FIXED = 5132,
			GL_DEPTH_COMPONENT = 6402,
			GL_ALPHA = 6406,
			GL_RGB = 6407,
			GL_RGBA = 6408,
			GL_LUMINANCE = 6409,
			GL_LUMINANCE_ALPHA = 6410,
			GL_UNSIGNED_SHORT_4_4_4_4 = 32819,
			GL_UNSIGNED_SHORT_5_5_5_1 = 32820,
			GL_UNSIGNED_SHORT_5_6_5 = 33635,
			GL_FRAGMENT_SHADER = 35632,
			GL_VERTEX_SHADER = 35633,
			GL_MAX_VERTEX_ATTRIBS = 34921,
			GL_MAX_VERTEX_UNIFORM_VECTORS = 36347,
			GL_MAX_VARYING_VECTORS = 36348,
			GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS = 35661,
			GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS = 35660,
			GL_MAX_TEXTURE_IMAGE_UNITS = 34930,
			GL_MAX_FRAGMENT_UNIFORM_VECTORS = 36349,
			GL_SHADER_TYPE = 35663,
			GL_DELETE_STATUS = 35712,
			GL_LINK_STATUS = 35714,
			GL_VALIDATE_STATUS = 35715,
			GL_ATTACHED_SHADERS = 35717,
			GL_ACTIVE_UNIFORMS = 35718,
			GL_ACTIVE_UNIFORM_MAX_LENGTH = 35719,
			GL_ACTIVE_ATTRIBUTES = 35721,
			GL_ACTIVE_ATTRIBUTE_MAX_LENGTH = 35722,
			GL_SHADING_LANGUAGE_VERSION = 35724,
			GL_CURRENT_PROGRAM = 35725,
			GL_NEVER = 512,
			GL_LESS = 513,
			GL_EQUAL = 514,
			GL_LEQUAL = 515,
			GL_GREATER = 516,
			GL_NOTEQUAL = 517,
			GL_GEQUAL = 518,
			GL_ALWAYS = 519,
			GL_KEEP = 7680,
			GL_REPLACE = 7681,
			GL_INCR = 7682,
			GL_DECR = 7683,
			GL_INVERT = 5386,
			GL_INCR_WRAP = 34055,
			GL_DECR_WRAP = 34056,
			GL_VENDOR = 7936,
			GL_RENDERER = 7937,
			GL_VERSION = 7938,
			GL_EXTENSIONS = 7939,
			GL_NEAREST = 9728,
			GL_LINEAR = 9729,
			GL_NEAREST_MIPMAP_NEAREST = 9984,
			GL_LINEAR_MIPMAP_NEAREST = 9985,
			GL_NEAREST_MIPMAP_LINEAR = 9986,
			GL_LINEAR_MIPMAP_LINEAR = 9987,
			GL_TEXTURE_MAG_FILTER = 10240,
			GL_TEXTURE_MIN_FILTER = 10241,
			GL_TEXTURE_WRAP_S = 10242,
			GL_TEXTURE_WRAP_T = 10243,
			GL_TEXTURE = 5890,
			GL_TEXTURE_CUBE_MAP = 34067,
			GL_TEXTURE_BINDING_CUBE_MAP = 34068,
			GL_TEXTURE_CUBE_MAP_POSITIVE_X = 34069,
			GL_TEXTURE_CUBE_MAP_NEGATIVE_X = 34070,
			GL_TEXTURE_CUBE_MAP_POSITIVE_Y = 34071,
			GL_TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072,
			GL_TEXTURE_CUBE_MAP_POSITIVE_Z = 34073,
			GL_TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074,
			GL_MAX_CUBE_MAP_TEXTURE_SIZE = 34076,
			GL_TEXTURE0 = 33984,
			GL_TEXTURE1 = 33985,
			GL_TEXTURE2 = 33986,
			GL_TEXTURE3 = 33987,
			GL_TEXTURE4 = 33988,
			GL_TEXTURE5 = 33989,
			GL_TEXTURE6 = 33990,
			GL_TEXTURE7 = 33991,
			GL_TEXTURE8 = 33992,
			GL_TEXTURE9 = 33993,
			GL_TEXTURE10 = 33994,
			GL_TEXTURE11 = 33995,
			GL_TEXTURE12 = 33996,
			GL_TEXTURE13 = 33997,
			GL_TEXTURE14 = 33998,
			GL_TEXTURE15 = 33999,
			GL_TEXTURE16 = 34000,
			GL_TEXTURE17 = 34001,
			GL_TEXTURE18 = 34002,
			GL_TEXTURE19 = 34003,
			GL_TEXTURE20 = 34004,
			GL_TEXTURE21 = 34005,
			GL_TEXTURE22 = 34006,
			GL_TEXTURE23 = 34007,
			GL_TEXTURE24 = 34008,
			GL_TEXTURE25 = 34009,
			GL_TEXTURE26 = 34010,
			GL_TEXTURE27 = 34011,
			GL_TEXTURE28 = 34012,
			GL_TEXTURE29 = 34013,
			GL_TEXTURE30 = 34014,
			GL_TEXTURE31 = 34015,
			GL_ACTIVE_TEXTURE = 34016,
			GL_REPEAT = 10497,
			GL_CLAMP_TO_EDGE = 33071,
			GL_MIRRORED_REPEAT = 33648,
			GL_FLOAT_VEC2 = 35664,
			GL_FLOAT_VEC3 = 35665,
			GL_FLOAT_VEC4 = 35666,
			GL_INT_VEC2 = 35667,
			GL_INT_VEC3 = 35668,
			GL_INT_VEC4 = 35669,
			GL_BOOL = 35670,
			GL_BOOL_VEC2 = 35671,
			GL_BOOL_VEC3 = 35672,
			GL_BOOL_VEC4 = 35673,
			GL_FLOAT_MAT2 = 35674,
			GL_FLOAT_MAT3 = 35675,
			GL_FLOAT_MAT4 = 35676,
			GL_SAMPLER_2D = 35678,
			GL_SAMPLER_CUBE = 35680,
			GL_VERTEX_ATTRIB_ARRAY_ENABLED = 34338,
			GL_VERTEX_ATTRIB_ARRAY_SIZE = 34339,
			GL_VERTEX_ATTRIB_ARRAY_STRIDE = 34340,
			GL_VERTEX_ATTRIB_ARRAY_TYPE = 34341,
			GL_VERTEX_ATTRIB_ARRAY_NORMALIZED = 34922,
			GL_VERTEX_ATTRIB_ARRAY_POINTER = 34373,
			GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING = 34975,
			GL_IMPLEMENTATION_COLOR_READ_TYPE = 35738,
			GL_IMPLEMENTATION_COLOR_READ_FORMAT = 35739,
			GL_COMPILE_STATUS = 35713,
			GL_INFO_LOG_LENGTH = 35716,
			GL_SHADER_SOURCE_LENGTH = 35720,
			GL_SHADER_COMPILER = 36346,
			GL_SHADER_BINARY_FORMATS = 36344,
			GL_NUM_SHADER_BINARY_FORMATS = 36345,
			GL_LOW_FLOAT = 36336,
			GL_MEDIUM_FLOAT = 36337,
			GL_HIGH_FLOAT = 36338,
			GL_LOW_INT = 36339,
			GL_MEDIUM_INT = 36340,
			GL_HIGH_INT = 36341,
			GL_FRAMEBUFFER = 36160,
			GL_RENDERBUFFER = 36161,
			GL_RGBA4 = 32854,
			GL_RGB5_A1 = 32855,
			GL_RGB565 = 36194,
			GL_DEPTH_COMPONENT16 = 33189,
			GL_STENCIL_INDEX8 = 36168,
			GL_RENDERBUFFER_WIDTH = 36162,
			GL_RENDERBUFFER_HEIGHT = 36163,
			GL_RENDERBUFFER_INTERNAL_FORMAT = 36164,
			GL_RENDERBUFFER_RED_SIZE = 36176,
			GL_RENDERBUFFER_GREEN_SIZE = 36177,
			GL_RENDERBUFFER_BLUE_SIZE = 36178,
			GL_RENDERBUFFER_ALPHA_SIZE = 36179,
			GL_RENDERBUFFER_DEPTH_SIZE = 36180,
			GL_RENDERBUFFER_STENCIL_SIZE = 36181,
			GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE = 36048,
			GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME = 36049,
			GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL = 36050,
			GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE = 36051,
			GL_COLOR_ATTACHMENT0 = 36064,
			GL_DEPTH_ATTACHMENT = 36096,
			GL_STENCIL_ATTACHMENT = 36128,
			GL_NONE = 0,
			GL_FRAMEBUFFER_COMPLETE = 36053,
			GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT = 36054,
			GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = 36055,
			GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS = 36057,
			GL_FRAMEBUFFER_UNSUPPORTED = 36061,
			GL_FRAMEBUFFER_BINDING = 36006,
			GL_RENDERBUFFER_BINDING = 36007,
			GL_MAX_RENDERBUFFER_SIZE = 34024,
			GL_INVALID_FRAMEBUFFER_OPERATION = 1286
		}

		public enum GLenum3
		{
			GL_READ_BUFFER = 3074,
			GL_UNPACK_ROW_LENGTH = 3314,
			GL_UNPACK_SKIP_ROWS = 3315,
			GL_UNPACK_SKIP_PIXELS = 3316,
			GL_PACK_ROW_LENGTH = 3330,
			GL_PACK_SKIP_ROWS = 3331,
			GL_PACK_SKIP_PIXELS = 3332,
			GL_COLOR = 6144,
			GL_DEPTH = 6145,
			GL_STENCIL = 6146,
			GL_RED = 6403,
			GL_RGB8 = 32849,
			GL_RGBA8 = 32856,
			GL_RGB10_A2 = 32857,
			GL_TEXTURE_BINDING_3D = 32874,
			GL_UNPACK_SKIP_IMAGES = 32877,
			GL_UNPACK_IMAGE_HEIGHT = 32878,
			GL_TEXTURE_3D = 32879,
			GL_TEXTURE_WRAP_R = 32882,
			GL_MAX_3D_TEXTURE_SIZE = 32883,
			GL_UNSIGNED_INT_2_10_10_10_REV = 33640,
			GL_MAX_ELEMENTS_VERTICES = 33000,
			GL_MAX_ELEMENTS_INDICES = 33001,
			GL_TEXTURE_MIN_LOD = 33082,
			GL_TEXTURE_MAX_LOD = 33083,
			GL_TEXTURE_BASE_LEVEL = 33084,
			GL_TEXTURE_MAX_LEVEL = 33085,
			GL_MIN = 32775,
			GL_MAX = 32776,
			GL_DEPTH_COMPONENT24 = 33190,
			GL_MAX_TEXTURE_LOD_BIAS = 34045,
			GL_TEXTURE_COMPARE_MODE = 34892,
			GL_TEXTURE_COMPARE_FUNC = 34893,
			GL_CURRENT_QUERY = 34917,
			GL_QUERY_RESULT = 34918,
			GL_QUERY_RESULT_AVAILABLE = 34919,
			GL_BUFFER_MAPPED = 35004,
			GL_BUFFER_MAP_POINTER = 35005,
			GL_STREAM_READ = 35041,
			GL_STREAM_COPY = 35042,
			GL_STATIC_READ = 35045,
			GL_STATIC_COPY = 35046,
			GL_DYNAMIC_READ = 35049,
			GL_DYNAMIC_COPY = 35050,
			GL_MAX_DRAW_BUFFERS = 34852,
			GL_DRAW_BUFFER0 = 34853,
			GL_DRAW_BUFFER1 = 34854,
			GL_DRAW_BUFFER2 = 34855,
			GL_DRAW_BUFFER3 = 34856,
			GL_DRAW_BUFFER4 = 34857,
			GL_DRAW_BUFFER5 = 34858,
			GL_DRAW_BUFFER6 = 34859,
			GL_DRAW_BUFFER7 = 34860,
			GL_DRAW_BUFFER8 = 34861,
			GL_DRAW_BUFFER9 = 34862,
			GL_DRAW_BUFFER10 = 34863,
			GL_DRAW_BUFFER11 = 34864,
			GL_DRAW_BUFFER12 = 34865,
			GL_DRAW_BUFFER13 = 34866,
			GL_DRAW_BUFFER14 = 34867,
			GL_DRAW_BUFFER15 = 34868,
			GL_MAX_FRAGMENT_UNIFORM_COMPONENTS = 35657,
			GL_MAX_VERTEX_UNIFORM_COMPONENTS = 35658,
			GL_SAMPLER_3D = 35679,
			GL_SAMPLER_2D_SHADOW = 35682,
			GL_FRAGMENT_SHADER_DERIVATIVE_HINT = 35723,
			GL_PIXEL_PACK_BUFFER = 35051,
			GL_PIXEL_UNPACK_BUFFER = 35052,
			GL_PIXEL_PACK_BUFFER_BINDING = 35053,
			GL_PIXEL_UNPACK_BUFFER_BINDING = 35055,
			GL_FLOAT_MAT2x3 = 35685,
			GL_FLOAT_MAT2x4 = 35686,
			GL_FLOAT_MAT3x2 = 35687,
			GL_FLOAT_MAT3x4 = 35688,
			GL_FLOAT_MAT4x2 = 35689,
			GL_FLOAT_MAT4x3 = 35690,
			GL_SRGB = 35904,
			GL_SRGB8 = 35905,
			GL_SRGB8_ALPHA8 = 35907,
			GL_COMPARE_REF_TO_TEXTURE = 34894,
			GL_MAJOR_VERSION = 33307,
			GL_MINOR_VERSION = 33308,
			GL_NUM_EXTENSIONS = 33309,
			GL_RGBA32F = 34836,
			GL_RGB32F = 34837,
			GL_RGBA16F = 34842,
			GL_RGB16F = 34843,
			GL_VERTEX_ATTRIB_ARRAY_INTEGER = 35069,
			GL_MAX_ARRAY_TEXTURE_LAYERS = 35071,
			GL_MIN_PROGRAM_TEXEL_OFFSET = 35076,
			GL_MAX_PROGRAM_TEXEL_OFFSET = 35077,
			GL_MAX_VARYING_COMPONENTS = 35659,
			GL_TEXTURE_2D_ARRAY = 35866,
			GL_TEXTURE_BINDING_2D_ARRAY = 35869,
			GL_R11F_G11F_B10F = 35898,
			GL_UNSIGNED_INT_10F_11F_11F_REV = 35899,
			GL_RGB9_E5 = 35901,
			GL_UNSIGNED_INT_5_9_9_9_REV = 35902,
			GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH = 35958,
			GL_TRANSFORM_FEEDBACK_BUFFER_MODE = 35967,
			GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS = 35968,
			GL_TRANSFORM_FEEDBACK_VARYINGS = 35971,
			GL_TRANSFORM_FEEDBACK_BUFFER_START = 35972,
			GL_TRANSFORM_FEEDBACK_BUFFER_SIZE = 35973,
			GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN = 35976,
			GL_RASTERIZER_DISCARD = 35977,
			GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS = 35978,
			GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS = 35979,
			GL_INTERLEAVED_ATTRIBS = 35980,
			GL_SEPARATE_ATTRIBS = 35981,
			GL_TRANSFORM_FEEDBACK_BUFFER = 35982,
			GL_TRANSFORM_FEEDBACK_BUFFER_BINDING = 35983,
			GL_RGBA32UI = 36208,
			GL_RGB32UI = 36209,
			GL_RGBA16UI = 36214,
			GL_RGB16UI = 36215,
			GL_RGBA8UI = 36220,
			GL_RGB8UI = 36221,
			GL_RGBA32I = 36226,
			GL_RGB32I = 36227,
			GL_RGBA16I = 36232,
			GL_RGB16I = 36233,
			GL_RGBA8I = 36238,
			GL_RGB8I = 36239,
			GL_RED_INTEGER = 36244,
			GL_RGB_INTEGER = 36248,
			GL_RGBA_INTEGER = 36249,
			GL_SAMPLER_2D_ARRAY = 36289,
			GL_SAMPLER_2D_ARRAY_SHADOW = 36292,
			GL_SAMPLER_CUBE_SHADOW = 36293,
			GL_UNSIGNED_INT_VEC2 = 36294,
			GL_UNSIGNED_INT_VEC3 = 36295,
			GL_UNSIGNED_INT_VEC4 = 36296,
			GL_INT_SAMPLER_2D = 36298,
			GL_INT_SAMPLER_3D = 36299,
			GL_INT_SAMPLER_CUBE = 36300,
			GL_INT_SAMPLER_2D_ARRAY = 36303,
			GL_UNSIGNED_INT_SAMPLER_2D = 36306,
			GL_UNSIGNED_INT_SAMPLER_3D = 36307,
			GL_UNSIGNED_INT_SAMPLER_CUBE = 36308,
			GL_UNSIGNED_INT_SAMPLER_2D_ARRAY = 36311,
			GL_BUFFER_ACCESS_FLAGS = 37151,
			GL_BUFFER_MAP_LENGTH = 37152,
			GL_BUFFER_MAP_OFFSET = 37153,
			GL_DEPTH_COMPONENT32F = 36012,
			GL_DEPTH32F_STENCIL8 = 36013,
			GL_FLOAT_32_UNSIGNED_INT_24_8_REV = 36269,
			GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING = 33296,
			GL_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE = 33297,
			GL_FRAMEBUFFER_ATTACHMENT_RED_SIZE = 33298,
			GL_FRAMEBUFFER_ATTACHMENT_GREEN_SIZE = 33299,
			GL_FRAMEBUFFER_ATTACHMENT_BLUE_SIZE = 33300,
			GL_FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE = 33301,
			GL_FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE = 33302,
			GL_FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE = 33303,
			GL_FRAMEBUFFER_DEFAULT = 33304,
			GL_FRAMEBUFFER_UNDEFINED = 33305,
			GL_DEPTH_STENCIL_ATTACHMENT = 33306,
			GL_DEPTH_STENCIL = 34041,
			GL_UNSIGNED_INT_24_8 = 34042,
			GL_DEPTH24_STENCIL8 = 35056,
			GL_UNSIGNED_NORMALIZED = 35863,
			GL_DRAW_FRAMEBUFFER_BINDING = 36006,
			GL_READ_FRAMEBUFFER = 36008,
			GL_DRAW_FRAMEBUFFER = 36009,
			GL_READ_FRAMEBUFFER_BINDING = 36010,
			GL_RENDERBUFFER_SAMPLES = 36011,
			GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER = 36052,
			GL_MAX_COLOR_ATTACHMENTS = 36063,
			GL_COLOR_ATTACHMENT1 = 36065,
			GL_COLOR_ATTACHMENT2 = 36066,
			GL_COLOR_ATTACHMENT3 = 36067,
			GL_COLOR_ATTACHMENT4 = 36068,
			GL_COLOR_ATTACHMENT5 = 36069,
			GL_COLOR_ATTACHMENT6 = 36070,
			GL_COLOR_ATTACHMENT7 = 36071,
			GL_COLOR_ATTACHMENT8 = 36072,
			GL_COLOR_ATTACHMENT9 = 36073,
			GL_COLOR_ATTACHMENT10 = 36074,
			GL_COLOR_ATTACHMENT11 = 36075,
			GL_COLOR_ATTACHMENT12 = 36076,
			GL_COLOR_ATTACHMENT13 = 36077,
			GL_COLOR_ATTACHMENT14 = 36078,
			GL_COLOR_ATTACHMENT15 = 36079,
			GL_COLOR_ATTACHMENT16 = 36080,
			GL_COLOR_ATTACHMENT17 = 36081,
			GL_COLOR_ATTACHMENT18 = 36082,
			GL_COLOR_ATTACHMENT19 = 36083,
			GL_COLOR_ATTACHMENT20 = 36084,
			GL_COLOR_ATTACHMENT21 = 36085,
			GL_COLOR_ATTACHMENT22 = 36086,
			GL_COLOR_ATTACHMENT23 = 36087,
			GL_COLOR_ATTACHMENT24 = 36088,
			GL_COLOR_ATTACHMENT25 = 36089,
			GL_COLOR_ATTACHMENT26 = 36090,
			GL_COLOR_ATTACHMENT27 = 36091,
			GL_COLOR_ATTACHMENT28 = 36092,
			GL_COLOR_ATTACHMENT29 = 36093,
			GL_COLOR_ATTACHMENT30 = 36094,
			GL_COLOR_ATTACHMENT31 = 36095,
			GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE = 36182,
			GL_MAX_SAMPLES = 36183,
			GL_HALF_FLOAT = 5131,
			GL_MAP_READ_BIT = 1,
			GL_MAP_WRITE_BIT = 2,
			GL_MAP_INVALIDATE_RANGE_BIT = 4,
			GL_MAP_INVALIDATE_BUFFER_BIT = 8,
			GL_MAP_FLUSH_EXPLICIT_BIT = 16,
			GL_MAP_UNSYNCHRONIZED_BIT = 32,
			GL_RG = 33319,
			GL_RG_INTEGER = 33320,
			GL_R8 = 33321,
			GL_RG8 = 33323,
			GL_R16F = 33325,
			GL_R32F = 33326,
			GL_RG16F = 33327,
			GL_RG32F = 33328,
			GL_R8I = 33329,
			GL_R8UI = 33330,
			GL_R16I = 33331,
			GL_R16UI = 33332,
			GL_R32I = 33333,
			GL_R32UI = 33334,
			GL_RG8I = 33335,
			GL_RG8UI = 33336,
			GL_RG16I = 33337,
			GL_RG16UI = 33338,
			GL_RG32I = 33339,
			GL_RG32UI = 33340,
			GL_VERTEX_ARRAY_BINDING = 34229,
			GL_R8_SNORM = 36756,
			GL_RG8_SNORM = 36757,
			GL_RGB8_SNORM = 36758,
			GL_RGBA8_SNORM = 36759,
			GL_SIGNED_NORMALIZED = 36764,
			GL_PRIMITIVE_RESTART_FIXED_INDEX = 36201,
			GL_COPY_READ_BUFFER = 36662,
			GL_COPY_WRITE_BUFFER = 36663,
			GL_COPY_READ_BUFFER_BINDING = 36662,
			GL_COPY_WRITE_BUFFER_BINDING = 36663,
			GL_UNIFORM_BUFFER = 35345,
			GL_UNIFORM_BUFFER_BINDING = 35368,
			GL_UNIFORM_BUFFER_START = 35369,
			GL_UNIFORM_BUFFER_SIZE = 35370,
			GL_MAX_VERTEX_UNIFORM_BLOCKS = 35371,
			GL_MAX_FRAGMENT_UNIFORM_BLOCKS = 35373,
			GL_MAX_COMBINED_UNIFORM_BLOCKS = 35374,
			GL_MAX_UNIFORM_BUFFER_BINDINGS = 35375,
			GL_MAX_UNIFORM_BLOCK_SIZE = 35376,
			GL_MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS = 35377,
			GL_MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS = 35379,
			GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT = 35380,
			GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH = 35381,
			GL_ACTIVE_UNIFORM_BLOCKS = 35382,
			GL_UNIFORM_TYPE = 35383,
			GL_UNIFORM_SIZE = 35384,
			GL_UNIFORM_NAME_LENGTH = 35385,
			GL_UNIFORM_BLOCK_INDEX = 35386,
			GL_UNIFORM_OFFSET = 35387,
			GL_UNIFORM_ARRAY_STRIDE = 35388,
			GL_UNIFORM_MATRIX_STRIDE = 35389,
			GL_UNIFORM_IS_ROW_MAJOR = 35390,
			GL_UNIFORM_BLOCK_BINDING = 35391,
			GL_UNIFORM_BLOCK_DATA_SIZE = 35392,
			GL_UNIFORM_BLOCK_NAME_LENGTH = 35393,
			GL_UNIFORM_BLOCK_ACTIVE_UNIFORMS = 35394,
			GL_UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES = 35395,
			GL_UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER = 35396,
			GL_UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER = 35398,
			GL_MAX_VERTEX_OUTPUT_COMPONENTS = 37154,
			GL_MAX_FRAGMENT_INPUT_COMPONENTS = 37157,
			GL_MAX_SERVER_WAIT_TIMEOUT = 37137,
			GL_OBJECT_TYPE = 37138,
			GL_SYNC_CONDITION = 37139,
			GL_SYNC_STATUS = 37140,
			GL_SYNC_FLAGS = 37141,
			GL_SYNC_FENCE = 37142,
			GL_SYNC_GPU_COMMANDS_COMPLETE = 37143,
			GL_UNSIGNALED = 37144,
			GL_SIGNALED = 37145,
			GL_ALREADY_SIGNALED = 37146,
			GL_TIMEOUT_EXPIRED = 37147,
			GL_CONDITION_SATISFIED = 37148,
			GL_WAIT_FAILED = 37149,
			GL_SYNC_FLUSH_COMMANDS_BIT = 1,
			GL_VERTEX_ATTRIB_ARRAY_DIVISOR = 35070,
			GL_ANY_SAMPLES_PASSED = 35887,
			GL_ANY_SAMPLES_PASSED_CONSERVATIVE = 36202,
			GL_SAMPLER_BINDING = 35097,
			GL_RGB10_A2UI = 36975,
			GL_TEXTURE_SWIZZLE_R = 36418,
			GL_TEXTURE_SWIZZLE_G = 36419,
			GL_TEXTURE_SWIZZLE_B = 36420,
			GL_TEXTURE_SWIZZLE_A = 36421,
			GL_GREEN = 6404,
			GL_BLUE = 6405,
			GL_INT_2_10_10_10_REV = 36255,
			GL_TRANSFORM_FEEDBACK = 36386,
			GL_TRANSFORM_FEEDBACK_PAUSED = 36387,
			GL_TRANSFORM_FEEDBACK_ACTIVE = 36388,
			GL_TRANSFORM_FEEDBACK_BINDING = 36389,
			GL_PROGRAM_BINARY_RETRIEVABLE_HINT = 33367,
			GL_PROGRAM_BINARY_LENGTH = 34625,
			GL_NUM_PROGRAM_BINARY_FORMATS = 34814,
			GL_PROGRAM_BINARY_FORMATS = 34815,
			GL_COMPRESSED_R11_EAC = 37488,
			GL_COMPRESSED_SIGNED_R11_EAC = 37489,
			GL_COMPRESSED_RG11_EAC = 37490,
			GL_COMPRESSED_SIGNED_RG11_EAC = 37491,
			GL_COMPRESSED_RGB8_ETC2 = 37492,
			GL_COMPRESSED_SRGB8_ETC2 = 37493,
			GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37494,
			GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37495,
			GL_COMPRESSED_RGBA8_ETC2_EAC = 37496,
			GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = 37497,
			GL_TEXTURE_IMMUTABLE_FORMAT = 37167,
			GL_MAX_ELEMENT_INDEX = 36203,
			GL_NUM_SAMPLE_COUNTS = 37760,
			GL_TEXTURE_IMMUTABLE_LEVELS = 33503
		}

		[DllImport("wvrugl", CallingConvention = CallingConvention.Cdecl, EntryPoint = "wvruglGenTextures")]
		public static extern void GenTextures(int n, [Out] uint[] textures);

		[DllImport("wvrugl", CallingConvention = CallingConvention.Cdecl, EntryPoint = "wvruglBindTexture")]
		public static extern void BindTexture(int target, uint texture);

		[DllImport("wvrugl", CallingConvention = CallingConvention.Cdecl, EntryPoint = "wvruglDeleteTextures")]
		public static extern void DeleteTextures(int n, [Out] uint[] textures);

		[DllImport("wvrugl", CallingConvention = CallingConvention.Cdecl, EntryPoint = "wvruglTexStorage3D")]
		public static extern void TexStorage3D(int target, int levels, int internalformat, int width, int height, int depth);

		[DllImport("wvrugl", CallingConvention = CallingConvention.Cdecl, EntryPoint = "wvruglGetTexParameteriv")]
		public static extern void GetTexParameteriv(int target, uint pname, ref int params_k);

		[DllImport("wvrugl", CallingConvention = CallingConvention.Cdecl, EntryPoint = "wvruglFramebufferTexture2D")]
		public static extern void FramebufferTexture2D(int target, int attachment, int textarget, uint texture, int level);

		[DllImport("wvrugl", CallingConvention = CallingConvention.Cdecl, EntryPoint = "wvruglFramebufferRenderbuffer")]
		public static extern void FramebufferRenderbuffer(int target, int attachment, int renderbuffertarget, uint renderbuffer);

		[DllImport("wvrugl", CallingConvention = CallingConvention.Cdecl, EntryPoint = "wvruglFramebufferTextureMultisampleMultiviewOVR")]
		public static extern void FramebufferTextureMultisampleMultiviewOVR(int target, int attachment, uint texture, int level, int samples, int baseViewIndex, int numViews);

		[DllImport("wvrugl", CallingConvention = CallingConvention.Cdecl, EntryPoint = "wvruglFramebufferTextureMultiviewOVR")]
		public static extern void FramebufferTextureMultiviewOVR(int target, int attachment, uint texture, int level, int baseViewIndex, int numViews);

		[DllImport("wvrugl", CallingConvention = CallingConvention.Cdecl, EntryPoint = "wvruglClear")]
		public static extern void Clear(uint mask);

		[DllImport("wvrugl", CallingConvention = CallingConvention.Cdecl, EntryPoint = "wvruglTexParameteri")]
		public static extern void TexParameteri(uint texture, int pname, int param);
	}
}
namespace wvr.render.thread
{
	public class RenderThreadSyncObject
	{
		public delegate void RenderEventDelegate(int e);

		public delegate void Receiver(PreAllocatedQueue dataQueue);

		private static readonly RenderEventDelegate handle = RunSyncObjectInRenderThread;

		private static readonly IntPtr handlePtr = GetFunctionPointerForDelegate(handle);

		private static List<RenderThreadSyncObject> CommandList = new List<RenderThreadSyncObject>();

		private readonly PreAllocatedQueue queue = new PreAllocatedQueue();

		private readonly Receiver receiver;

		private readonly int id;

		public PreAllocatedQueue Queue => queue;

		private static IntPtr GetFunctionPointerForDelegate(Delegate del)
		{
			return Marshal.GetFunctionPointerForDelegate(del);
		}

		public RenderThreadSyncObject(Receiver render)
		{
			receiver = render;
			if (receiver == null)
			{
				throw new ArgumentNullException("receiver should not be null");
			}
			CommandList.Add(this);
			id = CommandList.IndexOf(this);
		}

		~RenderThreadSyncObject()
		{
			CommandList.RemoveAt(id);
		}

		private void IssuePluginEvent(IntPtr callback, int eventID)
		{
			GL.IssuePluginEvent(callback, eventID);
		}

		private void IssuePluginEvent(CommandBuffer cmdBuf, IntPtr callback, int eventID)
		{
			cmdBuf.IssuePluginEvent(callback, eventID);
		}

		public void IssueEvent()
		{
			IssuePluginEvent(handlePtr, id);
		}

		public void IssueInCommandBuffer(CommandBuffer cmdBuf)
		{
			IssuePluginEvent(cmdBuf, handlePtr, id);
		}

		private void Receive()
		{
			receiver(queue);
		}

		[MonoPInvokeCallback(typeof(RenderEventDelegate))]
		private static void RunSyncObjectInRenderThread(int id)
		{
			CommandList[id].Receive();
		}
	}
	public class WaveVR_RenderThreadExample
	{
		public class TestMessage : wvr.render.utils.Message
		{
			public int textureId;
		}

		private static void Example1()
		{
			RenderThreadSyncObject renderThreadSyncObject = new RenderThreadSyncObject(delegate(PreAllocatedQueue queue)
			{
				lock (queue)
				{
					TestMessage msg = (TestMessage)queue.Dequeue();
					queue.Release(msg);
				}
			});
			int textureId = 1;
			PreAllocatedQueue queue2 = renderThreadSyncObject.Queue;
			lock (queue2)
			{
				TestMessage testMessage = queue2.Obtain<TestMessage>();
				testMessage.textureId = textureId;
				queue2.Enqueue(testMessage);
			}
			renderThreadSyncObject.IssueEvent();
		}
	}
}
namespace wvr.render.utils
{
	public class Message
	{
		public bool isFree = true;
	}
	public class MessagePool
	{
		private readonly List<Message> pool = new List<Message>(2);

		private int index;

		private int Next(int value)
		{
			if (++value >= pool.Count)
			{
				value = 0;
			}
			return value;
		}

		public T Obtain<T>() where T : Message, new()
		{
			int count = pool.Count;
			int num = index;
			for (int i = 0; i < count; i++)
			{
				if (num >= count)
				{
					num = 0;
				}
				if (pool[num].isFree)
				{
					index = num;
					return (T)pool[num];
				}
				num++;
			}
			index = Next(num);
			T val = new T
			{
				isFree = true
			};
			pool.Insert(index, val);
			return val;
		}

		public void Lock(Message msg)
		{
			msg.isFree = false;
		}

		public void Release(Message msg)
		{
			msg.isFree = true;
		}
	}
	public class PreAllocatedQueue : MessagePool
	{
		private readonly List<Message> list = new List<Message>(2) { null, null };

		private int queueBegin;

		private int queueEnd;

		private int Next(int value)
		{
			if (++value >= list.Count)
			{
				value = 0;
			}
			return value;
		}

		public void Enqueue(Message msg)
		{
			Lock(msg);
			queueEnd = Next(queueEnd);
			if (queueEnd == queueBegin)
			{
				list.Insert(queueEnd, msg);
				queueBegin++;
			}
			else
			{
				list[queueEnd] = msg;
			}
		}

		public Message Dequeue()
		{
			queueBegin = Next(queueBegin);
			return list[queueBegin];
		}
	}
}
namespace SimpleJSON
{
	public enum JSONNodeType
	{
		Array = 1,
		Object = 2,
		String = 3,
		Number = 4,
		NullValue = 5,
		Boolean = 6,
		None = 7,
		Custom = 255
	}
	public enum JSONTextMode
	{
		Compact,
		Indent
	}
	public abstract class JSONNode
	{
		public struct Enumerator
		{
			private enum Type
			{
				None,
				Array,
				Object
			}

			private Type type;

			private Dictionary<string, JSONNode>.Enumerator m_Object;

			private List<JSONNode>.Enumerator m_Array;

			public bool IsValid => type != Type.None;

			public KeyValuePair<string, JSONNode> Current
			{
				get
				{
					if (type == Type.Array)
					{
						return new KeyValuePair<string, JSONNode>(string.Empty, m_Array.Current);
					}
					if (type == Type.Object)
					{
						return m_Object.Current;
					}
					return new KeyValuePair<string, JSONNode>(string.Empty, null);
				}
			}

			public Enumerator(List<JSONNode>.Enumerator aArrayEnum)
			{
				type = Type.Array;
				m_Object = default(Dictionary<string, JSONNode>.Enumerator);
				m_Array = aArrayEnum;
			}

			public Enumerator(Dictionary<string, JSONNode>.Enumerator aDictEnum)
			{
				type = Type.Object;
				m_Object = aDictEnum;
				m_Array = default(List<JSONNode>.Enumerator);
			}

			public bool MoveNext()
			{
				if (type == Type.Array)
				{
					return m_Array.MoveNext();
				}
				if (type == Type.Object)
				{
					return m_Object.MoveNext();
				}
				return false;
			}
		}

		public struct ValueEnumerator
		{
			private Enumerator m_Enumerator;

			public JSONNode Current => m_Enumerator.Current.Value;

			public ValueEnumerator(List<JSONNode>.Enumerator aArrayEnum)
				: this(new Enumerator(aArrayEnum))
			{
			}

			public ValueEnumerator(Dictionary<string, JSONNode>.Enumerator aDictEnum)
				: this(new Enumerator(aDictEnum))
			{
			}

			public ValueEnumerator(Enumerator aEnumerator)
			{
				m_Enumerator = aEnumerator;
			}

			public bool MoveNext()
			{
				return m_Enumerator.MoveNext();
			}

			public ValueEnumerator GetEnumerator()
			{
				return this;
			}
		}

		public struct KeyEnumerator
		{
			private Enumerator m_Enumerator;

			public JSONNode Current => m_Enumerator.Current.Key;

			public KeyEnumerator(List<JSONNode>.Enumerator aArrayEnum)
				: this(new Enumerator(aArrayEnum))
			{
			}

			public KeyEnumerator(Dictionary<string, JSONNode>.Enumerator aDictEnum)
				: this(new Enumerator(aDictEnum))
			{
			}

			public KeyEnumerator(Enumerator aEnumerator)
			{
				m_Enumerator = aEnumerator;
			}

			public bool MoveNext()
			{
				return m_Enumerator.MoveNext();
			}

			public KeyEnumerator GetEnumerator()
			{
				return this;
			}
		}

		public class LinqEnumerator : IEnumerator<KeyValuePair<string, JSONNode>>, IEnumerator, IDisposable, IEnumerable<KeyValuePair<string, JSONNode>>, IEnumerable
		{
			private JSONNode m_Node;

			private Enumerator m_Enumerator;

			public KeyValuePair<string, JSONNode> Current => m_Enumerator.Current;

			object IEnumerator.Current => m_Enumerator.Current;

			internal LinqEnumerator(JSONNode aNode)
			{
				m_Node = aNode;
				if (m_Node != null)
				{
					m_Enumerator = m_Node.GetEnumerator();
				}
			}

			public bool MoveNext()
			{
				return m_Enumerator.MoveNext();
			}

			public void Dispose()
			{
				m_Node = null;
				m_Enumerator = default(Enumerator);
			}

			public IEnumerator<KeyValuePair<string, JSONNode>> GetEnumerator()
			{
				return new LinqEnumerator(m_Node);
			}

			public void Reset()
			{
				if (m_Node != null)
				{
					m_Enumerator = m_Node.GetEnumerator();
				}
			}

			IEnumerator IEnumerable.GetEnumerator()
			{
				return new LinqEnumerator(m_Node);
			}
		}

		public static bool forceASCII;

		[ThreadStatic]
		private static StringBuilder m_EscapeBuilder;

		public abstract JSONNodeType Tag { get; }

		public virtual JSONNode this[int aIndex]
		{
			get
			{
				return null;
			}
			set
			{
			}
		}

		public virtual JSONNode this[string aKey]
		{
			get
			{
				return null;
			}
			set
			{
			}
		}

		public virtual string Value
		{
			get
			{
				return "";
			}
			set
			{
			}
		}

		public virtual int Count => 0;

		public virtual bool IsNumber => false;

		public virtual bool IsString => false;

		public virtual bool IsBoolean => false;

		public virtual bool IsNull => false;

		public virtual bool IsArray => false;

		public virtual bool IsObject => false;

		public virtual bool Inline
		{
			get
			{
				return false;
			}
			set
			{
			}
		}

		public virtual IEnumerable<JSONNode> Children
		{
			get
			{
				yield break;
			}
		}

		public IEnumerable<JSONNode> DeepChildren
		{
			get
			{
				foreach (JSONNode child in Children)
				{
					foreach (JSONNode deepChild in child.DeepChildren)
					{
						yield return deepChild;
					}
				}
			}
		}

		public IEnumerable<KeyValuePair<string, JSONNode>> Linq => new LinqEnumerator(this);

		public KeyEnumerator Keys => new KeyEnumerator(GetEnumerator());

		public ValueEnumerator Values => new ValueEnumerator(GetEnumerator());

		public virtual double AsDouble
		{
			get
			{
				double result = 0.0;
				if (double.TryParse(Value, out result))
				{
					return result;
				}
				return 0.0;
			}
			set
			{
				Value = value.ToString();
			}
		}

		public virtual int AsInt
		{
			get
			{
				return (int)AsDouble;
			}
			set
			{
				AsDouble = value;
			}
		}

		public virtual float AsFloat
		{
			get
			{
				return (float)AsDouble;
			}
			set
			{
				AsDouble = value;
			}
		}

		public virtual bool AsBool
		{
			get
			{
				bool result = false;
				if (bool.TryParse(Value, out result))
				{
					return result;
				}
				return !string.IsNullOrEmpty(Value);
			}
			set
			{
				Value = (value ? "true" : "false");
			}
		}

		public virtual JSONArray AsArray => this as JSONArray;

		public virtual JSONObject AsObject => this as JSONObject;

		internal static StringBuilder EscapeBuilder
		{
			get
			{
				if (m_EscapeBuilder == null)
				{
					m_EscapeBuilder = new StringBuilder();
				}
				return m_EscapeBuilder;
			}
		}

		public virtual void Add(string aKey, JSONNode aItem)
		{
		}

		public virtual void Add(JSONNode aItem)
		{
			Add("", aItem);
		}

		public virtual JSONNode Remove(string aKey)
		{
			return null;
		}

		public virtual JSONNode Remove(int aIndex)
		{
			return null;
		}

		public virtual JSONNode Remove(JSONNode aNode)
		{
			return aNode;
		}

		public override string ToString()
		{
			StringBuilder stringBuilder = new StringBuilder();
			WriteToStringBuilder(stringBuilder, 0, 0, JSONTextMode.Compact);
			return stringBuilder.ToString();
		}

		public virtual string ToString(int aIndent)
		{
			StringBuilder stringBuilder = new StringBuilder();
			WriteToStringBuilder(stringBuilder, 0, aIndent, JSONTextMode.Indent);
			return stringBuilder.ToString();
		}

		internal abstract void WriteToStringBuilder(StringBuilder aSB, int aIndent, int aIndentInc, JSONTextMode aMode);

		public abstract Enumerator GetEnumerator();

		public static implicit operator JSONNode(string s)
		{
			return new JSONString(s);
		}

		public static implicit operator string(JSONNode d)
		{
			if (!(d == null))
			{
				return d.Value;
			}
			return null;
		}

		public static implicit operator JSONNode(double n)
		{
			return new JSONNumber(n);
		}

		public static implicit operator double(JSONNode d)
		{
			if (!(d == null))
			{
				return d.AsDouble;
			}
			return 0.0;
		}

		public static implicit operator JSONNode(float n)
		{
			return new JSONNumber(n);
		}

		public static implicit operator float(JSONNode d)
		{
			if (!(d == null))
			{
				return d.AsFloat;
			}
			return 0f;
		}

		public static implicit operator JSONNode(int n)
		{
			return new JSONNumber(n);
		}

		public static implicit operator int(JSONNode d)
		{
			if (!(d == null))
			{
				return d.AsInt;
			}
			return 0;
		}

		public static implicit operator JSONNode(bool b)
		{
			return new JSONBool(b);
		}

		public static implicit operator bool(JSONNode d)
		{
			if (!(d == null))
			{
				return d.AsBool;
			}
			return false;
		}

		public static implicit operator JSONNode(KeyValuePair<string, JSONNode> aKeyValue)
		{
			return aKeyValue.Value;
		}

		public static bool operator ==(JSONNode a, object b)
		{
			if ((object)a == b)
			{
				return true;
			}
			bool flag = a is JSONNull || (object)a == null || a is JSONLazyCreator;
			bool flag2 = b is JSONNull || b == null || b is JSONLazyCreator;
			if (flag && flag2)
			{
				return true;
			}
			if (!flag)
			{
				return a.Equals(b);
			}
			return false;
		}

		public static bool operator !=(JSONNode a, object b)
		{
			return !(a == b);
		}

		public override bool Equals(object obj)
		{
			return (object)this == obj;
		}

		public override int GetHashCode()
		{
			return base.GetHashCode();
		}

		internal static string Escape(string aText)
		{
			StringBuilder escapeBuilder = EscapeBuilder;
			escapeBuilder.Length = 0;
			if (escapeBuilder.Capacity < aText.Length + aText.Length / 10)
			{
				escapeBuilder.Capacity = aText.Length + aText.Length / 10;
			}
			foreach (char c in aText)
			{
				switch (c)
				{
				case '\\':
					escapeBuilder.Append("\\\\");
					continue;
				case '"':
					escapeBuilder.Append("\\\"");
					continue;
				case '\n':
					escapeBuilder.Append("\\n");
					continue;
				case '\r':
					escapeBuilder.Append("\\r");
					continue;
				case '\t':
					escapeBuilder.Append("\\t");
					continue;
				case '\b':
					escapeBuilder.Append("\\b");
					continue;
				case '\f':
					escapeBuilder.Append("\\f");
					continue;
				}
				if (c < ' ' || (forceASCII && c > '\u007f'))
				{
					ushort num = c;
					escapeBuilder.Append("\\u").Append(num.ToString("X4"));
				}
				else
				{
					escapeBuilder.Append(c);
				}
			}
			string result = escapeBuilder.ToString();
			escapeBuilder.Length = 0;
			return result;
		}

		private static void ParseElement(JSONNode ctx, string token, string tokenName, bool quoted)
		{
			if (quoted)
			{
				ctx.Add(tokenName, token);
				return;
			}
			string text = token.ToLower();
			switch (text)
			{
			case "false":
			case "true":
				ctx.Add(tokenName, text == "true");
				return;
			case "null":
				ctx.Add(tokenName, null);
				return;
			}
			if (double.TryParse(token, out var result))
			{
				ctx.Add(tokenName, result);
			}
			else
			{
				ctx.Add(tokenName, token);
			}
		}

		public static JSONNode Parse(string aJSON)
		{
			Stack<JSONNode> stack = new Stack<JSONNode>();
			JSONNode jSONNode = null;
			int i = 0;
			StringBuilder stringBuilder = new StringBuilder();
			string text = "";
			bool flag = false;
			bool flag2 = false;
			for (; i < aJSON.Length; i++)
			{
				switch (aJSON[i])
				{
				case '{':
					if (flag)
					{
						stringBuilder.Append(aJSON[i]);
						break;
					}
					stack.Push(new JSONObject());
					if (jSONNode != null)
					{
						jSONNode.Add(text, stack.Peek());
					}
					text = "";
					stringBuilder.Length = 0;
					jSONNode = stack.Peek();
					break;
				case '[':
					if (flag)
					{
						stringBuilder.Append(aJSON[i]);
						break;
					}
					stack.Push(new JSONArray());
					if (jSONNode != null)
					{
						jSONNode.Add(text, stack.Peek());
					}
					text = "";
					stringBuilder.Length = 0;
					jSONNode = stack.Peek();
					break;
				case ']':
				case '}':
					if (flag)
					{
						stringBuilder.Append(aJSON[i]);
						break;
					}
					if (stack.Count == 0)
					{
						throw new Exception("JSON Parse: Too many closing brackets");
					}
					stack.Pop();
					if (stringBuilder.Length > 0 || flag2)
					{
						ParseElement(jSONNode, stringBuilder.ToString(), text, flag2);
						flag2 = false;
					}
					text = "";
					stringBuilder.Length = 0;
					if (stack.Count > 0)
					{
						jSONNode = stack.Peek();
					}
					break;
				case ':':
					if (flag)
					{
						stringBuilder.Append(aJSON[i]);
						break;
					}
					text = stringBuilder.ToString();
					stringBuilder.Length = 0;
					flag2 = false;
					break;
				case '"':
					flag = !flag;
					flag2 = flag2 || flag;
					break;
				case ',':
					if (flag)
					{
						stringBuilder.Append(aJSON[i]);
						break;
					}
					if (stringBuilder.Length > 0 || flag2)
					{
						ParseElement(jSONNode, stringBuilder.ToString(), text, flag2);
						flag2 = false;
					}
					text = "";
					stringBuilder.Length = 0;
					flag2 = false;
					break;
				case '\t':
				case ' ':
					if (flag)
					{
						stringBuilder.Append(aJSON[i]);
					}
					break;
				case '\\':
					i++;
					if (flag)
					{
						char c = aJSON[i];
						switch (c)
						{
						case 't':
							stringBuilder.Append('\t');
							break;
						case 'r':
							stringBuilder.Append('\r');
							break;
						case 'n':
							stringBuilder.Append('\n');
							break;
						case 'b':
							stringBuilder.Append('\b');
							break;
						case 'f':
							stringBuilder.Append('\f');
							break;
						case 'u':
						{
							string s = aJSON.Substring(i + 1, 4);
							stringBuilder.Append((char)int.Parse(s, NumberStyles.AllowHexSpecifier));
							i += 4;
							break;
						}
						default:
							stringBuilder.Append(c);
							break;
						}
					}
					break;
				default:
					stringBuilder.Append(aJSON[i]);
					break;
				case '\n':
				case '\r':
					break;
				}
			}
			if (flag)
			{
				throw new Exception("JSON Parse: Quotation marks seems to be messed up.");
			}
			return jSONNode;
		}
	}
	public class JSONArray : JSONNode
	{
		private List<JSONNode> m_List = new List<JSONNode>();

		private bool inline;

		public override bool Inline
		{
			get
			{
				return inline;
			}
			set
			{
				inline = value;
			}
		}

		public override JSONNodeType Tag => JSONNodeType.Array;

		public override bool IsArray => true;

		public override JSONNode this[int aIndex]
		{
			get
			{
				if (aIndex < 0 || aIndex >= m_List.Count)
				{
					return new JSONLazyCreator(this);
				}
				return m_List[aIndex];
			}
			set
			{
				if (value == null)
				{
					value = JSONNull.CreateOrGet();
				}
				if (aIndex < 0 || aIndex >= m_List.Count)
				{
					m_List.Add(value);
				}
				else
				{
					m_List[aIndex] = value;
				}
			}
		}

		public override JSONNode this[string aKey]
		{
			get
			{
				return new JSONLazyCreator(this);
			}
			set
			{
				if (value == null)
				{
					value = JSONNull.CreateOrGet();
				}
				m_List.Add(value);
			}
		}

		public override int Count => m_List.Count;

		public override IEnumerable<JSONNode> Children
		{
			get
			{
				foreach (JSONNode item in m_List)
				{
					yield return item;
				}
			}
		}

		public override Enumerator GetEnumerator()
		{
			return new Enumerator(m_List.GetEnumerator());
		}

		public override void Add(string aKey, JSONNode aItem)
		{
			if (aItem == null)
			{
				aItem = JSONNull.CreateOrGet();
			}
			m_List.Add(aItem);
		}

		public override JSONNode Remove(int aIndex)
		{
			if (aIndex < 0 || aIndex >= m_List.Count)
			{
				return null;
			}
			JSONNode result = m_List[aIndex];
			m_List.RemoveAt(aIndex);
			return result;
		}

		public override JSONNode Remove(JSONNode aNode)
		{
			m_List.Remove(aNode);
			return aNode;
		}

		internal override void WriteToStringBuilder(StringBuilder aSB, int aIndent, int aIndentInc, JSONTextMode aMode)
		{
			aSB.Append('[');
			int count = m_List.Count;
			if (inline)
			{
				aMode = JSONTextMode.Compact;
			}
			for (int i = 0; i < count; i++)
			{
				if (i > 0)
				{
					aSB.Append(',');
				}
				if (aMode == JSONTextMode.Indent)
				{
					aSB.AppendLine();
				}
				if (aMode == JSONTextMode.Indent)
				{
					aSB.Append(' ', aIndent + aIndentInc);
				}
				m_List[i].WriteToStringBuilder(aSB, aIndent + aIndentInc, aIndentInc, aMode);
			}
			if (aMode == JSONTextMode.Indent)
			{
				aSB.AppendLine().Append(' ', aIndent);
			}
			aSB.Append(']');
		}
	}
	public class JSONObject : JSONNode
	{
		private Dictionary<string, JSONNode> m_Dict = new Dictionary<string, JSONNode>();

		private bool inline;

		public override bool Inline
		{
			get
			{
				return inline;
			}
			set
			{
				inline = value;
			}
		}

		public override JSONNodeType Tag => JSONNodeType.Object;

		public override bool IsObject => true;

		public override JSONNode this[string aKey]
		{
			get
			{
				if (m_Dict.ContainsKey(aKey))
				{
					return m_Dict[aKey];
				}
				return new JSONLazyCreator(this, aKey);
			}
			set
			{
				if (value == null)
				{
					value = JSONNull.CreateOrGet();
				}
				if (m_Dict.ContainsKey(aKey))
				{
					m_Dict[aKey] = value;
				}
				else
				{
					m_Dict.Add(aKey, value);
				}
			}
		}

		public override JSONNode this[int aIndex]
		{
			get
			{
				if (aIndex < 0 || aIndex >= m_Dict.Count)
				{
					return null;
				}
				return m_Dict.ElementAt(aIndex).Value;
			}
			set
			{
				if (value == null)
				{
					value = JSONNull.CreateOrGet();
				}
				if (aIndex >= 0 && aIndex < m_Dict.Count)
				{
					string key = m_Dict.ElementAt(aIndex).Key;
					m_Dict[key] = value;
				}
			}
		}

		public override int Count => m_Dict.Count;

		public override IEnumerable<JSONNode> Children
		{
			get
			{
				foreach (KeyValuePair<string, JSONNode> item in m_Dict)
				{
					yield return item.Value;
				}
			}
		}

		public override Enumerator GetEnumerator()
		{
			return new Enumerator(m_Dict.GetEnumerator());
		}

		public override void Add(string aKey, JSONNode aItem)
		{
			if (aItem == null)
			{
				aItem = JSONNull.CreateOrGet();
			}
			if (!string.IsNullOrEmpty(aKey))
			{
				if (m_Dict.ContainsKey(aKey))
				{
					m_Dict[aKey] = aItem;
				}
				else
				{
					m_Dict.Add(aKey, aItem);
				}
			}
			else
			{
				m_Dict.Add(Guid.NewGuid().ToString(), aItem);
			}
		}

		public override JSONNode Remove(string aKey)
		{
			if (!m_Dict.ContainsKey(aKey))
			{
				return null;
			}
			JSONNode result = m_Dict[aKey];
			m_Dict.Remove(aKey);
			return result;
		}

		public override JSONNode Remove(int aIndex)
		{
			if (aIndex < 0 || aIndex >= m_Dict.Count)
			{
				return null;
			}
			KeyValuePair<string, JSONNode> keyValuePair = m_Dict.ElementAt(aIndex);
			m_Dict.Remove(keyValuePair.Key);
			return keyValuePair.Value;
		}

		public override JSONNode Remove(JSONNode aNode)
		{
			try
			{
				KeyValuePair<string, JSONNode> keyValuePair = m_Dict.Where((KeyValuePair<string, JSONNode> k) => k.Value == aNode).First();
				m_Dict.Remove(keyValuePair.Key);
				return aNode;
			}
			catch
			{
				return null;
			}
		}

		internal override void WriteToStringBuilder(StringBuilder aSB, int aIndent, int aIndentInc, JSONTextMode aMode)
		{
			aSB.Append('{');
			bool flag = true;
			if (inline)
			{
				aMode = JSONTextMode.Compact;
			}
			foreach (KeyValuePair<string, JSONNode> item in m_Dict)
			{
				if (!flag)
				{
					aSB.Append(',');
				}
				flag = false;
				if (aMode == JSONTextMode.Indent)
				{
					aSB.AppendLine();
				}
				if (aMode == JSONTextMode.Indent)
				{
					aSB.Append(' ', aIndent + aIndentInc);
				}
				aSB.Append('"').Append(JSONNode.Escape(item.Key)).Append('"');
				if (aMode == JSONTextMode.Compact)
				{
					aSB.Append(':');
				}
				else
				{
					aSB.Append(" : ");
				}
				item.Value.WriteToStringBuilder(aSB, aIndent + aIndentInc, aIndentInc, aMode);
			}
			if (aMode == JSONTextMode.Indent)
			{
				aSB.AppendLine().Append(' ', aIndent);
			}
			aSB.Append('}');
		}
	}
	public class JSONString : JSONNode
	{
		private string m_Data;

		public override JSONNodeType Tag => JSONNodeType.String;

		public override bool IsString => true;

		public override string Value
		{
			get
			{
				return m_Data;
			}
			set
			{
				m_Data = value;
			}
		}

		public override Enumerator GetEnumerator()
		{
			return default(Enumerator);
		}

		public JSONString(string aData)
		{
			m_Data = aData;
		}

		internal override void WriteToStringBuilder(StringBuilder aSB, int aIndent, int aIndentInc, JSONTextMode aMode)
		{
			aSB.Append('"').Append(JSONNode.Escape(m_Data)).Append('"');
		}

		public override bool Equals(object obj)
		{
			if (base.Equals(obj))
			{
				return true;
			}
			if (obj is string text)
			{
				return m_Data == text;
			}
			JSONString jSONString = obj as JSONString;
			if (jSONString != null)
			{
				return m_Data == jSONString.m_Data;
			}
			return false;
		}

		public override int GetHashCode()
		{
			return m_Data.GetHashCode();
		}
	}
	public class JSONNumber : JSONNode
	{
		private double m_Data;

		public override JSONNodeType Tag => JSONNodeType.Number;

		public override bool IsNumber => true;

		public override string Value
		{
			get
			{
				return m_Data.ToString();
			}
			set
			{
				if (double.TryParse(value, out var result))
				{
					m_Data = result;
				}
			}
		}

		public override double AsDouble
		{
			get
			{
				return m_Data;
			}
			set
			{
				m_Data = value;
			}
		}

		public override Enumerator GetEnumerator()
		{
			return default(Enumerator);
		}

		public JSONNumber(double aData)
		{
			m_Data = aData;
		}

		public JSONNumber(string aData)
		{
			Value = aData;
		}

		internal override void WriteToStringBuilder(StringBuilder aSB, int aIndent, int aIndentInc, JSONTextMode aMode)
		{
			aSB.Append(m_Data);
		}

		private static bool IsNumeric(object value)
		{
			if (!(value is int) && !(value is uint) && !(value is float) && !(value is double) && !(value is decimal) && !(value is long) && !(value is ulong) && !(value is short) && !(value is ushort) && !(value is sbyte))
			{
				return value is byte;
			}
			return true;
		}

		public override bool Equals(object obj)
		{
			if (obj == null)
			{
				return false;
			}
			if (base.Equals(obj))
			{
				return true;
			}
			JSONNumber jSONNumber = obj as JSONNumber;
			if (jSONNumber != null)
			{
				return m_Data == jSONNumber.m_Data;
			}
			if (IsNumeric(obj))
			{
				return Convert.ToDouble(obj) == m_Data;
			}
			return false;
		}

		public override int GetHashCode()
		{
			return m_Data.GetHashCode();
		}
	}
	public class JSONBool : JSONNode
	{
		private bool m_Data;

		public override JSONNodeType Tag => JSONNodeType.Boolean;

		public override bool IsBoolean => true;

		public override string Value
		{
			get
			{
				return m_Data.ToString();
			}
			set
			{
				if (bool.TryParse(value, out var result))
				{
					m_Data = result;
				}
			}
		}

		public override bool AsBool
		{
			get
			{
				return m_Data;
			}
			set
			{
				m_Data = value;
			}
		}

		public override Enumerator GetEnumerator()
		{
			return default(Enumerator);
		}

		public JSONBool(bool aData)
		{
			m_Data = aData;
		}

		public JSONBool(string aData)
		{
			Value = aData;
		}

		internal override void WriteToStringBuilder(StringBuilder aSB, int aIndent, int aIndentInc, JSONTextMode aMode)
		{
			aSB.Append(m_Data ? "true" : "false");
		}

		public override bool Equals(object obj)
		{
			if (obj == null)
			{
				return false;
			}
			if (obj is bool)
			{
				return m_Data == (bool)obj;
			}
			return false;
		}

		public override int GetHashCode()
		{
			return m_Data.GetHashCode();
		}
	}
	public class JSONNull : JSONNode
	{
		private static JSONNull m_StaticInstance = new JSONNull();

		public static bool reuseSameInstance = true;

		public override JSONNodeType Tag => JSONNodeType.NullValue;

		public override bool IsNull => true;

		public override string Value
		{
			get
			{
				return "null";
			}
			set
			{
			}
		}

		public override bool AsBool
		{
			get
			{
				return false;
			}
			set
			{
			}
		}

		public static JSONNull CreateOrGet()
		{
			if (reuseSameInstance)
			{
				return m_StaticInstance;
			}
			return new JSONNull();
		}

		private JSONNull()
		{
		}

		public override Enumerator GetEnumerator()
		{
			return default(Enumerator);
		}

		public override bool Equals(object obj)
		{
			if ((object)this == obj)
			{
				return true;
			}
			return obj is JSONNull;
		}

		public override int GetHashCode()
		{
			return 0;
		}

		internal override void WriteToStringBuilder(StringBuilder aSB, int aIndent, int aIndentInc, JSONTextMode aMode)
		{
			aSB.Append("null");
		}
	}
	internal class JSONLazyCreator : JSONNode
	{
		private JSONNode m_Node;

		private string m_Key;

		public override JSONNodeType Tag => JSONNodeType.None;

		public override JSONNode this[int aIndex]
		{
			get
			{
				return new JSONLazyCreator(this);
			}
			set
			{
				JSONArray jSONArray = new JSONArray();
				jSONArray.Add(value);
				Set(jSONArray);
			}
		}

		public override JSONNode this[string aKey]
		{
			get
			{
				return new JSONLazyCreator(this, aKey);
			}
			set
			{
				JSONObject jSONObject = new JSONObject();
				jSONObject.Add(aKey, value);
				Set(jSONObject);
			}
		}

		public override int AsInt
		{
			get
			{
				JSONNumber aVal = new JSONNumber(0.0);
				Set(aVal);
				return 0;
			}
			set
			{
				JSONNumber aVal = new JSONNumber(value);
				Set(aVal);
			}
		}

		public override float AsFloat
		{
			get
			{
				JSONNumber aVal = new JSONNumber(0.0);
				Set(aVal);
				return 0f;
			}
			set
			{
				JSONNumber aVal = new JSONNumber(value);
				Set(aVal);
			}
		}

		public override double AsDouble
		{
			get
			{
				JSONNumber aVal = new JSONNumber(0.0);
				Set(aVal);
				return 0.0;
			}
			set
			{
				JSONNumber aVal = new JSONNumber(value);
				Set(aVal);
			}
		}

		public override bool AsBool
		{
			get
			{
				JSONBool aVal = new JSONBool(aData: false);
				Set(aVal);
				return false;
			}
			set
			{
				JSONBool aVal = new JSONBool(value);
				Set(aVal);
			}
		}

		public override JSONArray AsArray
		{
			get
			{
				JSONArray jSONArray = new JSONArray();
				Set(jSONArray);
				return jSONArray;
			}
		}

		public override JSONObject AsObject
		{
			get
			{
				JSONObject jSONObject = new JSONObject();
				Set(jSONObject);
				return jSONObject;
			}
		}

		public override Enumerator GetEnumerator()
		{
			return default(Enumerator);
		}

		public JSONLazyCreator(JSONNode aNode)
		{
			m_Node = aNode;
			m_Key = null;
		}

		public JSONLazyCreator(JSONNode aNode, string aKey)
		{
			m_Node = aNode;
			m_Key = aKey;
		}

		private void Set(JSONNode aVal)
		{
			if (m_Key == null)
			{
				m_Node.Add(aVal);
			}
			else
			{
				m_Node.Add(m_Key, aVal);
			}
			m_Node = null;
		}

		public override void Add(JSONNode aItem)
		{
			JSONArray jSONArray = new JSONArray();
			jSONArray.Add(aItem);
			Set(jSONArray);
		}

		public override void Add(string aKey, JSONNode aItem)
		{
			JSONObject jSONObject = new JSONObject();
			jSONObject.Add(aKey, aItem);
			Set(jSONObject);
		}

		public static bool operator ==(JSONLazyCreator a, object b)
		{
			if (b == null)
			{
				return true;
			}
			return (object)a == b;
		}

		public static bool operator !=(JSONLazyCreator a, object b)
		{
			return !(a == b);
		}

		public override bool Equals(object obj)
		{
			if (obj == null)
			{
				return true;
			}
			return (object)this == obj;
		}

		public override int GetHashCode()
		{
			return 0;
		}

		internal override void WriteToStringBuilder(StringBuilder aSB, int aIndent, int aIndentInc, JSONTextMode aMode)
		{
			aSB.Append("null");
		}
	}
	public static class JSON
	{
		public static JSONNode Parse(string aJSON)
		{
			return JSONNode.Parse(aJSON);
		}
	}
}
namespace PublicKeyConvert
{
	public class PEMKeyLoader
	{
		private static byte[] SeqOID = new byte[15]
		{
			48, 13, 6, 9, 42, 134, 72, 134, 247, 13,
			1, 1, 1, 5, 0
		};

		private static bool CompareBytearrays(byte[] a, byte[] b)
		{
			if (a.Length != b.Length)
			{
				return false;
			}
			int num = 0;
			for (int i = 0; i < a.Length; i++)
			{
				if (a[i] != b[num])
				{
					return false;
				}
				num++;
			}
			return true;
		}

		public static RSACryptoServiceProvider CryptoServiceProviderFromPublicKeyInfo(byte[] x509key)
		{
			_ = new byte[15];
			if (x509key == null || x509key.Length == 0)
			{
				return null;
			}
			BinaryReader binaryReader = new BinaryReader(new MemoryStream(x509key));
			ushort num = 0;
			try
			{
				switch (binaryReader.ReadUInt16())
				{
				case 33072:
					binaryReader.ReadByte();
					break;
				case 33328:
					binaryReader.ReadInt16();
					break;
				default:
					return null;
				}
				if (!CompareBytearrays(binaryReader.ReadBytes(15), SeqOID))
				{
					return null;
				}
				switch (binaryReader.ReadUInt16())
				{
				case 33027:
					binaryReader.ReadByte();
					break;
				case 33283:
					binaryReader.ReadInt16();
					break;
				default:
					return null;
				}
				if (binaryReader.ReadByte() != 0)
				{
					return null;
				}
				switch (binaryReader.ReadUInt16())
				{
				case 33072:
					binaryReader.ReadByte();
					break;
				case 33328:
					binaryReader.ReadInt16();
					break;
				default:
					return null;
				}
				num = binaryReader.ReadUInt16();
				byte b = 0;
				byte b2 = 0;
				switch (num)
				{
				case 33026:
					b = binaryReader.ReadByte();
					break;
				case 33282:
					b2 = binaryReader.ReadByte();
					b = binaryReader.ReadByte();
					break;
				default:
					return null;
				}
				int num2 = BitConverter.ToInt32(new byte[4] { b, b2, 0, 0 }, 0);
				if (binaryReader.PeekChar() == 0)
				{
					binaryReader.ReadByte();
					num2--;
				}
				byte[] modulus = binaryReader.ReadBytes(num2);
				if (binaryReader.ReadByte() != 2)
				{
					return null;
				}
				int count = binaryReader.ReadByte();
				byte[] exponent = binaryReader.ReadBytes(count);
				RSACryptoServiceProvider rSACryptoServiceProvider = new RSACryptoServiceProvider();
				rSACryptoServiceProvider.ImportParameters(new RSAParameters
				{
					Modulus = modulus,
					Exponent = exponent
				});
				return rSACryptoServiceProvider;
			}
			finally
			{
				binaryReader.Close();
			}
		}

		public static RSACryptoServiceProvider CryptoServiceProviderFromPublicKeyInfo(string base64EncodedKey)
		{
			try
			{
				return CryptoServiceProviderFromPublicKeyInfo(Convert.FromBase64String(base64EncodedKey));
			}
			catch (FormatException)
			{
			}
			return null;
		}
	}
}
namespace Viveport
{
	public class MainThreadDispatcher : MonoBehaviour
	{
		private static readonly Queue<Action> actions = new Queue<Action>();

		private static MainThreadDispatcher instance = null;

		private void Awake()
		{
			if (instance == null)
			{
				instance = this;
				UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
			}
		}

		public void Update()
		{
			lock (actions)
			{
				while (actions.Count > 0)
				{
					actions.Dequeue()();
				}
			}
		}

		public static MainThreadDispatcher Instance()
		{
			if (instance == null)
			{
				throw new Exception("Could not find the MainThreadDispatcher GameObject. Please ensure you have added this script to an empty GameObject in your scene.");
			}
			return instance;
		}

		private void OnDestroy()
		{
			instance = null;
		}

		public void Enqueue(IEnumerator action)
		{
			lock (actions)
			{
				actions.Enqueue(delegate
				{
					StartCoroutine(action);
				});
			}
		}

		public void Enqueue(Action action)
		{
			Enqueue(ActionWrapper(action));
		}

		public void Enqueue<T1>(Action<T1> action, T1 param1)
		{
			Enqueue(ActionWrapper(action, param1));
		}

		public void Enqueue<T1, T2>(Action<T1, T2> action, T1 param1, T2 param2)
		{
			Enqueue(ActionWrapper(action, param1, param2));
		}

		public void Enqueue<T1, T2, T3>(Action<T1, T2, T3> action, T1 param1, T2 param2, T3 param3)
		{
			Enqueue(ActionWrapper(action, param1, param2, param3));
		}

		public void Enqueue<T1, T2, T3, T4>(Action<T1, T2, T3, T4> action, T1 param1, T2 param2, T3 param3, T4 param4)
		{
			Enqueue(ActionWrapper(action, param1, param2, param3, param4));
		}

		private IEnumerator ActionWrapper(Action action)
		{
			action();
			yield return null;
		}

		private IEnumerator ActionWrapper<T1>(Action<T1> action, T1 param1)
		{
			action(param1);
			yield return null;
		}

		private IEnumerator ActionWrapper<T1, T2>(Action<T1, T2> action, T1 param1, T2 param2)
		{
			action(param1, param2);
			yield return null;
		}

		private IEnumerator ActionWrapper<T1, T2, T3>(Action<T1, T2, T3> action, T1 param1, T2 param2, T3 param3)
		{
			action(param1, param2, param3);
			yield return null;
		}

		private IEnumerator ActionWrapper<T1, T2, T3, T4>(Action<T1, T2, T3, T4> action, T1 param1, T2 param2, T3 param3, T4 param4)
		{
			action(param1, param2, param3, param4);
			yield return null;
		}
	}
	public enum Locale
	{
		US,
		DE,
		JP,
		KR,
		RU,
		CN,
		TW,
		FR
	}
	public delegate void StatusCallback(int nResult);
	public delegate void StatusCallback2(int nResult, string message);
	public delegate void QueryRuntimeModeCallback(int nResult, int emu);
	public class Leaderboard
	{
		public int Rank { get; set; }

		public int Score { get; set; }

		public string UserName { get; set; }
	}
	public class SubscriptionStatus
	{
		public enum Platform
		{
			Windows,
			Android
		}

		public enum TransactionType
		{
			Unknown,
			Paid,
			Redeem,
			FreeTrial
		}

		public List<Platform> Platforms { get; set; }

		public TransactionType Type { get; set; }

		public SubscriptionStatus()
		{
			Platforms = new List<Platform>();
			Type = TransactionType.Unknown;
		}
	}
	public class Api
	{
		public abstract class LicenseChecker
		{
			public abstract void OnSuccess(long issueTime, long expirationTime, int latestVersion, bool updateRequired);

			public abstract void OnFailure(int errorCode, string errorMessage);
		}

		internal static readonly List<GetLicenseCallback> InternalGetLicenseCallbacks = new List<GetLicenseCallback>();

		internal static readonly List<Viveport.Internal.StatusCallback> InternalStatusCallbacks = new List<Viveport.Internal.StatusCallback>();

		internal static readonly List<Viveport.Internal.QueryRuntimeModeCallback> InternalQueryRunTimeCallbacks = new List<Viveport.Internal.QueryRuntimeModeCallback>();

		internal static readonly List<Viveport.Internal.StatusCallback2> InternalStatusCallback2s = new List<Viveport.Internal.StatusCallback2>();

		internal static readonly List<LicenseChecker> InternalLicenseCheckers = new List<LicenseChecker>();

		private static Viveport.Internal.StatusCallback initIl2cppCallback;

		private static Viveport.Internal.StatusCallback shutdownIl2cppCallback;

		private static Viveport.Internal.QueryRuntimeModeCallback queryRuntimeModeIl2cppCallback;

		private static readonly string VERSION = "1.7.2.15";

		private static string _appId = "";

		private static string _appKey = "";

		public static void GetLicense(LicenseChecker checker, string appId, string appKey)
		{
			if (checker == null || string.IsNullOrEmpty(appId) || string.IsNullOrEmpty(appKey))
			{
				throw new InvalidOperationException("checker == null || string.IsNullOrEmpty(appId) || string.IsNullOrEmpty(appKey)");
			}
			_appId = appId;
			_appKey = appKey;
			Viveport.Internal.Api.GetLicense(checker, _appId, _appKey);
		}

		[MonoPInvokeCallback(typeof(Viveport.Internal.StatusCallback))]
		private static void InitIl2cppCallback(int errorCode)
		{
			initIl2cppCallback(errorCode);
		}

		public static int Init(StatusCallback callback, string appId)
		{
			if (callback == null || string.IsNullOrEmpty(appId))
			{
				throw new InvalidOperationException("callback == null || string.IsNullOrEmpty(appId)");
			}
			initIl2cppCallback = callback.Invoke;
			InternalStatusCallbacks.Add(InitIl2cppCallback);
			return Viveport.Internal.Api.Init(InitIl2cppCallback, appId);
		}

		[MonoPInvokeCallback(typeof(Viveport.Internal.StatusCallback))]
		private static void ShutdownIl2cppCallback(int errorCode)
		{
			shutdownIl2cppCallback(errorCode);
		}

		public static int Shutdown(StatusCallback callback)
		{
			if (callback == null)
			{
				throw new InvalidOperationException("callback == null");
			}
			shutdownIl2cppCallback = callback.Invoke;
			InternalStatusCallbacks.Add(ShutdownIl2cppCallback);
			return Viveport.Internal.Api.Shutdown(ShutdownIl2cppCallback);
		}

		public static string Version()
		{
			string text = "";
			text = Viveport.Internal.Api.Version();
			return "C# version: " + VERSION + ", Native version: " + text;
		}
	}
	public class User
	{
		private static Viveport.Internal.StatusCallback isReadyIl2cppCallback;

		[MonoPInvokeCallback(typeof(Viveport.Internal.StatusCallback))]
		private static void IsReadyIl2cppCallback(int errorCode)
		{
			isReadyIl2cppCallback(errorCode);
		}

		public static int IsReady(StatusCallback callback)
		{
			if (callback == null)
			{
				throw new InvalidOperationException("callback == null");
			}
			isReadyIl2cppCallback = callback.Invoke;
			Api.InternalStatusCallbacks.Add(IsReadyIl2cppCallback);
			return Viveport.Internal.User.IsReady(IsReadyIl2cppCallback);
		}

		public static string GetUserId()
		{
			return Viveport.Internal.User.GetUserId().ToString();
		}

		public static string GetUserName()
		{
			return Viveport.Internal.User.GetUserName().ToString();
		}

		public static string GetUserAvatarUrl()
		{
			return Viveport.Internal.User.GetUserAvatarUrl().ToString();
		}
	}
	public class UserStats
	{
		public enum LeaderBoardRequestType
		{
			GlobalData,
			GlobalDataAroundUser,
			LocalData,
			LocalDataAroundUser
		}

		public enum LeaderBoardTimeRange
		{
			AllTime,
			Daily,
			Weekly,
			Monthly
		}

		public enum LeaderBoardSortMethod
		{
			None,
			Ascending,
			Descending
		}

		public enum LeaderBoardDiaplayType
		{
			None,
			Numeric,
			TimeSeconds,
			TimeMilliSeconds
		}

		public enum LeaderBoardScoreMethod
		{
			None,
			KeepBest,
			ForceUpdate
		}

		public enum AchievementDisplayAttribute
		{
			Name,
			Desc,
			Hidden
		}

		private static Viveport.Internal.StatusCallback isReadyIl2cppCallback;

		private static Viveport.Internal.StatusCallback downloadStatsIl2cppCallback;

		private static Viveport.Internal.StatusCallback uploadStatsIl2cppCallback;

		private static Viveport.Internal.StatusCallback downloadLeaderboardScoresIl2cppCallback;

		private static Viveport.Internal.StatusCallback uploadLeaderboardScoreIl2cppCallback;

		[MonoPInvokeCallback(typeof(Viveport.Internal.StatusCallback))]
		private static void IsReadyIl2cppCallback(int errorCode)
		{
			isReadyIl2cppCallback(errorCode);
		}

		public static int IsReady(StatusCallback callback)
		{
			if (callback == null)
			{
				throw new InvalidOperationException("callback == null");
			}
			isReadyIl2cppCallback = callback.Invoke;
			Api.InternalStatusCallbacks.Add(IsReadyIl2cppCallback);
			return Viveport.Internal.UserStats.IsReady(IsReadyIl2cppCallback);
		}

		[MonoPInvokeCallback(typeof(Viveport.Internal.StatusCallback))]
		private static void DownloadStatsIl2cppCallback(int errorCode)
		{
			downloadStatsIl2cppCallback(errorCode);
		}

		public static int DownloadStats(StatusCallback callback)
		{
			if (callback == null)
			{
				throw new InvalidOperationException("callback == null");
			}
			downloadStatsIl2cppCallback = callback.Invoke;
			Api.InternalStatusCallbacks.Add(DownloadStatsIl2cppCallback);
			return Viveport.Internal.UserStats.DownloadStats(DownloadStatsIl2cppCallback);
		}

		public static int GetStat(string name, int defaultValue)
		{
			return Viveport.Internal.UserStats.GetStat(name, defaultValue);
		}

		public static float GetStat(string name, float defaultValue)
		{
			return Viveport.Internal.UserStats.GetStat(name, defaultValue);
		}

		public static void SetStat(string name, int value)
		{
			Viveport.Internal.UserStats.SetStat(name, value);
		}

		public static void SetStat(string name, float value)
		{
			Viveport.Internal.UserStats.SetStat(name, value);
		}

		[MonoPInvokeCallback(typeof(Viveport.Internal.StatusCallback))]
		private static void UploadStatsIl2cppCallback(int errorCode)
		{
			uploadStatsIl2cppCallback(errorCode);
		}

		public static int UploadStats(StatusCallback callback)
		{
			if (callback == null)
			{
				throw new InvalidOperationException("callback == null");
			}
			uploadStatsIl2cppCallback = callback.Invoke;
			Api.InternalStatusCallbacks.Add(UploadStatsIl2cppCallback);
			return Viveport.Internal.UserStats.UploadStats(UploadStatsIl2cppCallback);
		}

		public static bool GetAchievement(string pchName)
		{
			return Viveport.Internal.UserStats.GetAchievement(pchName);
		}

		public static int GetAchievementUnlockTime(string pchName)
		{
			return Viveport.Internal.UserStats.GetAchievementUnlockTime(pchName);
		}

		public static string GetAchievementIcon(string pchName)
		{
			return Viveport.Internal.UserStats.GetAchievementIcon(pchName);
		}

		public static string GetAchievementDisplayAttribute(string pchName, AchievementDisplayAttribute attr)
		{
			return Viveport.Internal.UserStats.GetAchievementDisplayAttribute(pchName, (EAchievementDisplayAttribute)attr);
		}

		public static string GetAchievementDisplayAttribute(string pchName, AchievementDisplayAttribute attr, Locale locale)
		{
			return Viveport.Internal.UserStats.GetAchievementDisplayAttribute(pchName, (EAchievementDisplayAttribute)attr, (ELocale)locale);
		}

		public static int SetAchievement(string pchName)
		{
			return Viveport.Internal.UserStats.SetAchievement(pchName);
		}

		public static int ClearAchievement(string pchName)
		{
			return Viveport.Internal.UserStats.ClearAchievement(pchName);
		}

		[MonoPInvokeCallback(typeof(Viveport.Internal.StatusCallback))]
		private static void DownloadLeaderboardScoresIl2cppCallback(int errorCode)
		{
			downloadLeaderboardScoresIl2cppCallback(errorCode);
		}

		public static int DownloadLeaderboardScores(StatusCallback callback, string pchLeaderboardName, LeaderBoardRequestType eLeaderboardDataRequest, LeaderBoardTimeRange eLeaderboardDataTimeRange, int nRangeStart, int nRangeEnd)
		{
			if (callback == null)
			{
				throw new InvalidOperationException("callback == null");
			}
			downloadLeaderboardScoresIl2cppCallback = callback.Invoke;
			Api.InternalStatusCallbacks.Add(DownloadLeaderboardScoresIl2cppCallback);
			return Viveport.Internal.UserStats.DownloadLeaderboardScores(DownloadLeaderboardScoresIl2cppCallback, pchLeaderboardName, (ELeaderboardDataRequest)eLeaderboardDataRequest, (ELeaderboardDataTimeRange)eLeaderboardDataTimeRange, nRangeStart, nRangeEnd);
		}

		[MonoPInvokeCallback(typeof(Viveport.Internal.StatusCallback))]
		private static void UploadLeaderboardScoreIl2cppCallback(int errorCode)
		{
			uploadLeaderboardScoreIl2cppCallback(errorCode);
		}

		public static int UploadLeaderboardScore(StatusCallback callback, string pchLeaderboardName, int nScore)
		{
			if (callback == null)
			{
				throw new InvalidOperationException("callback == null");
			}
			uploadLeaderboardScoreIl2cppCallback = callback.Invoke;
			Api.InternalStatusCallbacks.Add(UploadLeaderboardScoreIl2cppCallback);
			return Viveport.Internal.UserStats.UploadLeaderboardScore(UploadLeaderboardScoreIl2cppCallback, pchLeaderboardName, nScore);
		}

		public static Leaderboard GetLeaderboardScore(int index)
		{
			return Viveport.Internal.UserStats.GetLeaderboardScore(index);
		}

		public static int GetLeaderboardScoreCount()
		{
			return Viveport.Internal.UserStats.GetLeaderboardScoreCount();
		}

		public static LeaderBoardSortMethod GetLeaderboardSortMethod()
		{
			return (LeaderBoardSortMethod)Viveport.Internal.UserStats.GetLeaderboardSortMethod();
		}

		public static LeaderBoardDiaplayType GetLeaderboardDisplayType()
		{
			return (LeaderBoardDiaplayType)Viveport.Internal.UserStats.GetLeaderboardDisplayType();
		}
	}
	public class ArcadeLeaderboard
	{
	}
	public class IAPurchase
	{
		private class IAPHandler : BaseHandler
		{
			private static IAPurchaseListener listener;

			public IAPHandler(IAPurchaseListener cb)
			{
				listener = cb;
			}

			public IAPurchaseCallback getIsReadyHandler()
			{
				return IsReadyHandler;
			}

			protected override void IsReadyHandler(int code, [MarshalAs(UnmanagedType.LPStr)] string message)
			{
				Viveport.Core.Logger.Log("[IsReadyHandler] message=" + message);
				JsonData jsonData = JsonMapper.ToObject(message);
				int num = -1;
				string text = "";
				string text2 = "";
				if (code == 0)
				{
					try
					{
						num = (int)jsonData["statusCode"];
						text2 = (string)jsonData["message"];
					}
					catch (Exception ex)
					{
						Viveport.Core.Logger.Log("[IsReadyHandler] statusCode, message ex=" + ex);
					}
					Viveport.Core.Logger.Log("[IsReadyHandler] statusCode =" + num + ",errMessage=" + text2);
					if (num == 0)
					{
						try
						{
							text = (string)jsonData["currencyName"];
						}
						catch (Exception ex2)
						{
							Viveport.Core.Logger.Log("[IsReadyHandler] currencyName ex=" + ex2);
						}
						Viveport.Core.Logger.Log("[IsReadyHandler] currencyName=" + text);
					}
				}
				if (listener == null)
				{
					return;
				}
				if (code == 0)
				{
					if (num == 0)
					{
						listener.OnSuccess(text);
					}
					else
					{
						listener.OnFailure(num, text2);
					}
				}
				else
				{
					listener.OnFailure(code, message);
				}
			}

			public IAPurchaseCallback getRequestHandler()
			{
				return RequestHandler;
			}

			protected override void RequestHandler(int code, [MarshalAs(UnmanagedType.LPStr)] string message)
			{
				Viveport.Core.Logger.Log("[RequestHandler] message=" + message);
				JsonData jsonData = JsonMapper.ToObject(message);
				int num = -1;
				string text = "";
				string text2 = "";
				if (code == 0)
				{
					try
					{
						num = (int)jsonData["statusCode"];
						text2 = (string)jsonData["message"];
					}
					catch (Exception ex)
					{
						Viveport.Core.Logger.Log("[RequestHandler] statusCode, message ex=" + ex);
					}
					Viveport.Core.Logger.Log("[RequestHandler] statusCode =" + num + ",errMessage=" + text2);
					if (num == 0)
					{
						try
						{
							text = (string)jsonData["purchase_id"];
						}
						catch (Exception ex2)
						{
							Viveport.Core.Logger.Log("[RequestHandler] purchase_id ex=" + ex2);
						}
						Viveport.Core.Logger.Log("[RequestHandler] purchaseId =" + text);
					}
				}
				if (listener == null)
				{
					return;
				}
				if (code == 0)
				{
					if (num == 0)
					{
						listener.OnRequestSuccess(text);
					}
					else
					{
						listener.OnFailure(num, text2);
					}
				}
				else
				{
					listener.OnFailure(code, message);
				}
			}

			public IAPurchaseCallback getPurchaseHandler()
			{
				return PurchaseHandler;
			}

			protected override void PurchaseHandler(int code, [MarshalAs(UnmanagedType.LPStr)] string message)
			{
				Viveport.Core.Logger.Log("[PurchaseHandler] message=" + message);
				JsonData jsonData = JsonMapper.ToObject(message);
				int num = -1;
				string text = "";
				string text2 = "";
				long num2 = 0L;
				if (code == 0)
				{
					try
					{
						num = (int)jsonData["statusCode"];
						text2 = (string)jsonData["message"];
					}
					catch (Exception ex)
					{
						Viveport.Core.Logger.Log("[PurchaseHandler] statusCode, message ex=" + ex);
					}
					Viveport.Core.Logger.Log("[PurchaseHandler] statusCode =" + num + ",errMessage=" + text2);
					if (num == 0)
					{
						try
						{
							text = (string)jsonData["purchase_id"];
							num2 = (long)jsonData["paid_timestamp"];
						}
						catch (Exception ex2)
						{
							Viveport.Core.Logger.Log("[PurchaseHandler] purchase_id,paid_timestamp ex=" + ex2);
						}
						Viveport.Core.Logger.Log("[PurchaseHandler] purchaseId =" + text + ",paid_timestamp=" + num2);
					}
				}
				if (listener == null)
				{
					return;
				}
				if (code == 0)
				{
					if (num == 0)
					{
						listener.OnPurchaseSuccess(text);
					}
					else
					{
						listener.OnFailure(num, text2);
					}
				}
				else
				{
					listener.OnFailure(code, message);
				}
			}

			public IAPurchaseCallback getQueryHandler()
			{
				return QueryHandler;
			}

			protected override void QueryHandler(int code, [MarshalAs(UnmanagedType.LPStr)] string message)
			{
				Viveport.Core.Logger.Log("[QueryHandler] message=" + message);
				JsonData jsonData = JsonMapper.ToObject(message);
				int num = -1;
				string text = "";
				string text2 = "";
				string text3 = "";
				string text4 = "";
				string text5 = "";
				string text6 = "";
				long num2 = 0L;
				if (code == 0)
				{
					try
					{
						num = (int)jsonData["statusCode"];
						text2 = (string)jsonData["message"];
					}
					catch (Exception ex)
					{
						Viveport.Core.Logger.Log("[QueryHandler] statusCode, message ex=" + ex);
					}
					Viveport.Core.Logger.Log("[QueryHandler] statusCode =" + num + ",errMessage=" + text2);
					if (num == 0)
					{
						try
						{
							text = (string)jsonData["purchase_id"];
							text3 = (string)jsonData["order_id"];
							text4 = (string)jsonData["status"];
							text5 = (string)jsonData["price"];
							text6 = (string)jsonData["currency"];
							num2 = (long)jsonData["paid_timestamp"];
						}
						catch (Exception ex2)
						{
							Viveport.Core.Logger.Log("[QueryHandler] purchase_id, order_id ex=" + ex2);
						}
						Viveport.Core.Logger.Log("[QueryHandler] status =" + text4 + ",price=" + text5 + ",currency=" + text6);
						Viveport.Core.Logger.Log("[QueryHandler] purchaseId =" + text + ",order_id=" + text3 + ",paid_timestamp=" + num2);
					}
				}
				if (listener == null)
				{
					return;
				}
				if (code == 0)
				{
					if (num == 0)
					{
						QueryResponse queryResponse = new QueryResponse();
						queryResponse.purchase_id = text;
						queryResponse.order_id = text3;
						queryResponse.price = text5;
						queryResponse.currency = text6;
						queryResponse.paid_timestamp = num2;
						queryResponse.status = text4;
						listener.OnQuerySuccess(queryResponse);
					}
					else
					{
						listener.OnFailure(num, text2);
					}
				}
				else
				{
					listener.OnFailure(code, message);
				}
			}

			public IAPurchaseCallback getQueryListHandler()
			{
				return QueryListHandler;
			}

			protected override void QueryListHandler(int code, [MarshalAs(UnmanagedType.LPStr)] string message)
			{
				Viveport.Core.Logger.Log("[QueryListHandler] message=" + message);
				JsonData jsonData = JsonMapper.ToObject(message);
				int num = -1;
				int total = 0;
				int from = 0;
				int to = 0;
				List<QueryResponse2> list = new List<QueryResponse2>();
				string text = "";
				if (code == 0)
				{
					try
					{
						num = (int)jsonData["statusCode"];
						text = (string)jsonData["message"];
					}
					catch (Exception ex)
					{
						Viveport.Core.Logger.Log("[QueryListHandler] statusCode, message ex=" + ex);
					}
					Viveport.Core.Logger.Log("[QueryListHandler] statusCode =" + num + ",errMessage=" + text);
					if (num == 0)
					{
						try
						{
							JsonData jsonData2 = JsonMapper.ToObject(text);
							total = (int)jsonData2["total"];
							from = (int)jsonData2["from"];
							to = (int)jsonData2["to"];
							JsonData jsonData3 = jsonData2["purchases"];
							_ = jsonData3.IsArray;
							foreach (JsonData item in (IEnumerable)jsonData3)
							{
								QueryResponse2 queryResponse = new QueryResponse2();
								IDictionary dictionary = item;
								queryResponse.app_id = (dictionary.Contains("app_id") ? ((string)item["app_id"]) : "");
								queryResponse.currency = (dictionary.Contains("currency") ? ((string)item["currency"]) : "");
								queryResponse.purchase_id = (dictionary.Contains("purchase_id") ? ((string)item["purchase_id"]) : "");
								queryResponse.order_id = (dictionary.Contains("order_id") ? ((string)item["order_id"]) : "");
								queryResponse.price = (dictionary.Contains("price") ? ((string)item["price"]) : "");
								queryResponse.user_data = (dictionary.Contains("user_data") ? ((string)item["user_data"]) : "");
								if (dictionary.Contains("paid_timestamp"))
								{
									if (item["paid_timestamp"].IsLong)
									{
										queryResponse.paid_timestamp = (long)item["paid_timestamp"];
									}
									else if (item["paid_timestamp"].IsInt)
									{
										queryResponse.paid_timestamp = (int)item["paid_timestamp"];
									}
								}
								list.Add(queryResponse);
							}
						}
						catch (Exception ex2)
						{
							Viveport.Core.Logger.Log("[QueryListHandler] purchase_id, order_id ex=" + ex2);
						}
					}
				}
				if (listener == null)
				{
					return;
				}
				if (code == 0)
				{
					if (num == 0)
					{
						QueryListResponse queryListResponse = new QueryListResponse();
						queryListResponse.total = total;
						queryListResponse.from = from;
						queryListResponse.to = to;
						queryListResponse.purchaseList = list;
						listener.OnQuerySuccess(queryListResponse);
					}
					else
					{
						listener.OnFailure(num, text);
					}
				}
				else
				{
					listener.OnFailure(code, message);
				}
			}

			public IAPurchaseCallback getBalanceHandler()
			{
				return BalanceHandler;
			}

			protected override void BalanceHandler(int code, [MarshalAs(UnmanagedType.LPStr)] string message)
			{
				Viveport.Core.Logger.Log("[BalanceHandler] code=" + code + ",message= " + message);
				JsonData jsonData = JsonMapper.ToObject(message);
				int num = -1;
				string text = "";
				string text2 = "";
				string text3 = "";
				if (code == 0)
				{
					try
					{
						num = (int)jsonData["statusCode"];
						text3 = (string)jsonData["message"];
					}
					catch (Exception ex)
					{
						Viveport.Core.Logger.Log("[BalanceHandler] statusCode, message ex=" + ex);
					}
					Viveport.Core.Logger.Log("[BalanceHandler] statusCode =" + num + ",errMessage=" + text3);
					if (num == 0)
					{
						try
						{
							text = (string)jsonData["currencyName"];
							text2 = (string)jsonData["balance"];
						}
						catch (Exception ex2)
						{
							Viveport.Core.Logger.Log("[BalanceHandler] currencyName, balance ex=" + ex2);
						}
						Viveport.Core.Logger.Log("[BalanceHandler] currencyName=" + text + ",balance=" + text2);
					}
				}
				if (listener == null)
				{
					return;
				}
				if (code == 0)
				{
					if (num == 0)
					{
						listener.OnBalanceSuccess(text2);
					}
					else
					{
						listener.OnFailure(num, text3);
					}
				}
				else
				{
					listener.OnFailure(code, message);
				}
			}

			public IAPurchaseCallback getRequestSubscriptionHandler()
			{
				return RequestSubscriptionHandler;
			}

			protected override void RequestSubscriptionHandler(int code, [MarshalAs(UnmanagedType.LPStr)] string message)
			{
				Viveport.Core.Logger.Log("[RequestSubscriptionHandler] message=" + message);
				JsonData jsonData = JsonMapper.ToObject(message);
				int num = -1;
				string text = "";
				string text2 = "";
				try
				{
					num = (int)jsonData["statusCode"];
					text2 = (string)jsonData["message"];
				}
				catch (Exception ex)
				{
					Viveport.Core.Logger.Log("[RequestSubscriptionHandler] statusCode, message ex=" + ex);
				}
				Viveport.Core.Logger.Log("[RequestSubscriptionHandler] statusCode =" + num + ",errMessage=" + text2);
				if (num == 0)
				{
					try
					{
						text = (string)jsonData["subscription_id"];
					}
					catch (Exception ex2)
					{
						Viveport.Core.Logger.Log("[RequestSubscriptionHandler] subscription_id ex=" + ex2);
					}
					Viveport.Core.Logger.Log("[RequestSubscriptionHandler] subscription_id =" + text);
				}
				if (listener == null)
				{
					return;
				}
				if (code == 0)
				{
					if (num == 0)
					{
						listener.OnRequestSubscriptionSuccess(text);
					}
					else
					{
						listener.OnFailure(num, text2);
					}
				}
				else
				{
					listener.OnFailure(code, message);
				}
			}

			public IAPurchaseCallback getRequestSubscriptionWithPlanIDHandler()
			{
				return RequestSubscriptionWithPlanIDHandler;
			}

			protected override void RequestSubscriptionWithPlanIDHandler(int code, [MarshalAs(UnmanagedType.LPStr)] string message)
			{
				Viveport.Core.Logger.Log("[RequestSubscriptionWithPlanIDHandler] message=" + message);
				JsonData jsonData = JsonMapper.ToObject(message);
				int num = -1;
				string text = "";
				string text2 = "";
				try
				{
					num = (int)jsonData["statusCode"];
					text2 = (string)jsonData["message"];
				}
				catch (Exception ex)
				{
					Viveport.Core.Logger.Log("[RequestSubscriptionWithPlanIDHandler] statusCode, message ex=" + ex);
				}
				Viveport.Core.Logger.Log("[RequestSubscriptionWithPlanIDHandler] statusCode =" + num + ",errMessage=" + text2);
				if (num == 0)
				{
					try
					{
						text = (string)jsonData["subscription_id"];
					}
					catch (Exception ex2)
					{
						Viveport.Core.Logger.Log("[RequestSubscriptionWithPlanIDHandler] subscription_id ex=" + ex2);
					}
					Viveport.Core.Logger.Log("[RequestSubscriptionWithPlanIDHandler] subscription_id =" + text);
				}
				if (listener == null)
				{
					return;
				}
				if (code == 0)
				{
					if (num == 0)
					{
						listener.OnRequestSubscriptionWithPlanIDSuccess(text);
					}
					else
					{
						listener.OnFailure(num, text2);
					}
				}
				else
				{
					listener.OnFailure(code, message);
				}
			}

			public IAPurchaseCallback getSubscribeHandler()
			{
				return SubscribeHandler;
			}

			protected override void SubscribeHandler(int code, [MarshalAs(UnmanagedType.LPStr)] string message)
			{
				Viveport.Core.Logger.Log("[SubscribeHandler] message=" + message);
				JsonData jsonData = JsonMapper.ToObject(message);
				int num = -1;
				string text = "";
				string text2 = "";
				string text3 = "";
				long num2 = 0L;
				try
				{
					num = (int)jsonData["statusCode"];
					text2 = (string)jsonData["message"];
				}
				catch (Exception ex)
				{
					Viveport.Core.Logger.Log("[SubscribeHandler] statusCode, message ex=" + ex);
				}
				Viveport.Core.Logger.Log("[SubscribeHandler] statusCode =" + num + ",errMessage=" + text2);
				if (num == 0)
				{
					try
					{
						text = (string)jsonData["subscription_id"];
						text3 = (string)jsonData["plan_id"];
						num2 = (long)jsonData["subscribed_timestamp"];
					}
					catch (Exception ex2)
					{
						Viveport.Core.Logger.Log("[SubscribeHandler] subscription_id, plan_id ex=" + ex2);
					}
					Viveport.Core.Logger.Log("[SubscribeHandler] subscription_id =" + text + ", plan_id=" + text3 + ", timestamp=" + num2);
				}
				if (listener == null)
				{
					return;
				}
				if (code == 0)
				{
					if (num == 0)
					{
						listener.OnSubscribeSuccess(text);
					}
					else
					{
						listener.OnFailure(num, text2);
					}
				}
				else
				{
					listener.OnFailure(code, message);
				}
			}

			public IAPurchaseCallback getQuerySubscriptionHandler()
			{
				return QuerySubscriptionHandler;
			}

			protected override void QuerySubscriptionHandler(int code, [MarshalAs(UnmanagedType.LPStr)] string message)
			{
				Viveport.Core.Logger.Log("[QuerySubscriptionHandler] message=" + message);
				JsonData jsonData = JsonMapper.ToObject(message);
				int num = -1;
				string text = "";
				List<Subscription> list = null;
				if (code == 0)
				{
					try
					{
						num = (int)jsonData["statusCode"];
						text = (string)jsonData["message"];
					}
					catch (Exception ex)
					{
						Viveport.Core.Logger.Log("[QuerySubscriptionHandler] statusCode, message ex=" + ex);
					}
					Viveport.Core.Logger.Log("[QuerySubscriptionHandler] statusCode =" + num + ",errMessage=" + text);
					if (num == 0)
					{
						try
						{
							list = JsonMapper.ToObject<QuerySubscritionResponse>(message).subscriptions;
						}
						catch (Exception ex2)
						{
							Viveport.Core.Logger.Log("[QuerySubscriptionHandler] ex =" + ex2);
						}
					}
				}
				if (listener == null)
				{
					return;
				}
				if (code == 0)
				{
					if (num == 0 && list != null && list.Count > 0)
					{
						listener.OnQuerySubscriptionSuccess(list.ToArray());
					}
					else
					{
						listener.OnFailure(num, text);
					}
				}
				else
				{
					listener.OnFailure(code, message);
				}
			}

			public IAPurchaseCallback getQuerySubscriptionListHandler()
			{
				return QuerySubscriptionListHandler;
			}

			protected override void QuerySubscriptionListHandler(int code, [MarshalAs(UnmanagedType.LPStr)] string message)
			{
				Viveport.Core.Logger.Log("[QuerySubscriptionListHandler] message=" + message);
				JsonData jsonData = JsonMapper.ToObject(message);
				int num = -1;
				string text = "";
				List<Subscription> list = null;
				if (code == 0)
				{
					try
					{
						num = (int)jsonData["statusCode"];
						text = (string)jsonData["message"];
					}
					catch (Exception ex)
					{
						Viveport.Core.Logger.Log("[QuerySubscriptionListHandler] statusCode, message ex=" + ex);
					}
					Viveport.Core.Logger.Log("[QuerySubscriptionListHandler] statusCode =" + num + ",errMessage=" + text);
					if (num == 0)
					{
						try
						{
							list = JsonMapper.ToObject<QuerySubscritionResponse>(message).subscriptions;
						}
						catch (Exception ex2)
						{
							Viveport.Core.Logger.Log("[QuerySubscriptionListHandler] ex =" + ex2);
						}
					}
				}
				if (listener == null)
				{
					return;
				}
				if (code == 0)
				{
					if (num == 0 && list != null && list.Count > 0)
					{
						listener.OnQuerySubscriptionListSuccess(list.ToArray());
					}
					else
					{
						listener.OnFailure(num, text);
					}
				}
				else
				{
					listener.OnFailure(code, message);
				}
			}

			public IAPurchaseCallback getCancelSubscriptionHandler()
			{
				return CancelSubscriptionHandler;
			}

			protected override void CancelSubscriptionHandler(int code, [MarshalAs(UnmanagedType.LPStr)] string message)
			{
				Viveport.Core.Logger.Log("[CancelSubscriptionHandler] message=" + message);
				JsonData jsonData = JsonMapper.ToObject(message);
				int num = -1;
				bool bCanceled = false;
				string text = "";
				if (code == 0)
				{
					try
					{
						num = (int)jsonData["statusCode"];
						text = (string)jsonData["message"];
					}
					catch (Exception ex)
					{
						Viveport.Core.Logger.Log("[CancelSubscriptionHandler] statusCode, message ex=" + ex);
					}
					Viveport.Core.Logger.Log("[CancelSubscriptionHandler] statusCode =" + num + ",errMessage=" + text);
					if (num == 0)
					{
						bCanceled = true;
						Viveport.Core.Logger.Log("[CancelSubscriptionHandler] isCanceled = " + bCanceled);
					}
				}
				if (listener == null)
				{
					return;
				}
				if (code == 0)
				{
					if (num == 0)
					{
						listener.OnCancelSubscriptionSuccess(bCanceled);
					}
					else
					{
						listener.OnFailure(num, text);
					}
				}
				else
				{
					listener.OnFailure(code, message);
				}
			}
		}

		private abstract class BaseHandler
		{
			protected abstract void IsReadyHandler(int code, [MarshalAs(UnmanagedType.LPStr)] string message);

			protected abstract void RequestHandler(int code, [MarshalAs(UnmanagedType.LPStr)] string message);

			protected abstract void PurchaseHandler(int code, [MarshalAs(UnmanagedType.LPStr)] string message);

			protected abstract void QueryHandler(int code, [MarshalAs(UnmanagedType.LPStr)] string message);

			protected abstract void QueryListHandler(int code, [MarshalAs(UnmanagedType.LPStr)] string message);

			protected abstract void BalanceHandler(int code, [MarshalAs(UnmanagedType.LPStr)] string message);

			protected abstract void RequestSubscriptionHandler(int code, [MarshalAs(UnmanagedType.LPStr)] string message);

			protected abstract void RequestSubscriptionWithPlanIDHandler(int code, [MarshalAs(UnmanagedType.LPStr)] string message);

			protected abstract void SubscribeHandler(int code, [MarshalAs(UnmanagedType.LPStr)] string message);

			protected abstract void QuerySubscriptionHandler(int code, [MarshalAs(UnmanagedType.LPStr)] string message);

			protected abstract void QuerySubscriptionListHandler(int code, [MarshalAs(UnmanagedType.LPStr)] string message);

			protected abstract void CancelSubscriptionHandler(int code, [MarshalAs(UnmanagedType.LPStr)] string message);
		}

		public class IAPurchaseListener
		{
			public virtual void OnSuccess(string pchCurrencyName)
			{
			}

			public virtual void OnRequestSuccess(string pchPurchaseId)
			{
			}

			public virtual void OnPurchaseSuccess(string pchPurchaseId)
			{
			}

			public virtual void OnQuerySuccess(QueryResponse response)
			{
			}

			public virtual void OnQuerySuccess(QueryListResponse response)
			{
			}

			public virtual void OnBalanceSuccess(string pchBalance)
			{
			}

			public virtual void OnFailure(int nCode, string pchMessage)
			{
			}

			public virtual void OnRequestSubscriptionSuccess(string pchSubscriptionId)
			{
			}

			public virtual void OnRequestSubscriptionWithPlanIDSuccess(string pchSubscriptionId)
			{
			}

			public virtual void OnSubscribeSuccess(string pchSubscriptionId)
			{
			}

			public virtual void OnQuerySubscriptionSuccess(Subscription[] subscriptionlist)
			{
			}

			public virtual void OnQuerySubscriptionListSuccess(Subscription[] subscriptionlist)
			{
			}

			public virtual void OnCancelSubscriptionSuccess(bool bCanceled)
			{
			}
		}

		public class QueryResponse
		{
			public string order_id { get; set; }

			public string purchase_id { get; set; }

			public string status { get; set; }

			public string price { get; set; }

			public string currency { get; set; }

			public long paid_timestamp { get; set; }
		}

		public class QueryResponse2
		{
			public string order_id { get; set; }

			public string app_id { get; set; }

			public string purchase_id { get; set; }

			public string user_data { get; set; }

			public string price { get; set; }

			public string currency { get; set; }

			public long paid_timestamp { get; set; }
		}

		public class QueryListResponse
		{
			public List<QueryResponse2> purchaseList;

			public int total { get; set; }

			public int from { get; set; }

			public int to { get; set; }
		}

		public class StatusDetailTransaction
		{
			public long create_time { get; set; }

			public string payment_method { get; set; }

			public string status { get; set; }
		}

		public class StatusDetail
		{
			public long date_next_charge { get; set; }

			public StatusDetailTransaction[] transactions { get; set; }

			public string cancel_reason { get; set; }
		}

		public class TimePeriod
		{
			public string time_type { get; set; }

			public int value { get; set; }
		}

		public class Subscription
		{
			public string app_id { get; set; }

			public string order_id { get; set; }

			public string subscription_id { get; set; }

			public string price { get; set; }

			public string currency { get; set; }

			public long subscribed_timestamp { get; set; }

			public TimePeriod free_trial_period { get; set; }

			public TimePeriod charge_period { get; set; }

			public int number_of_charge_period { get; set; }

			public string plan_id { get; set; }

			public string plan_name { get; set; }

			public string status { get; set; }

			public StatusDetail status_detail { get; set; }
		}

		public class QuerySubscritionResponse
		{
			public int statusCode { get; set; }

			public string message { get; set; }

			public List<Subscription> subscriptions { get; set; }
		}

		private static IAPurchaseCallback isReadyIl2cppCallback;

		private static IAPurchaseCallback request01Il2cppCallback;

		private static IAPurchaseCallback request02Il2cppCallback;

		private static IAPurchaseCallback purchaseIl2cppCallback;

		private static IAPurchaseCallback query01Il2cppCallback;

		private static IAPurchaseCallback query02Il2cppCallback;

		private static IAPurchaseCallback getBalanceIl2cppCallback;

		private static IAPurchaseCallback requestSubscriptionIl2cppCallback;

		private static IAPurchaseCallback requestSubscriptionWithPlanIDIl2cppCallback;

		private static IAPurchaseCallback subscribeIl2cppCallback;

		private static IAPurchaseCallback querySubscriptionIl2cppCallback;

		private static IAPurchaseCallback querySubscriptionListIl2cppCallback;

		private static IAPurchaseCallback cancelSubscriptionIl2cppCallback;

		[MonoPInvokeCallback(typeof(IAPurchaseCallback))]
		private static void IsReadyIl2cppCallback(int errorCode, string message)
		{
			isReadyIl2cppCallback(errorCode, message);
		}

		public static void IsReady(IAPurchaseListener listener, string pchAppKey)
		{
			isReadyIl2cppCallback = new IAPHandler(listener).getIsReadyHandler();
			Viveport.Internal.IAPurchase.IsReady(IsReadyIl2cppCallback, pchAppKey);
		}

		[MonoPInvokeCallback(typeof(IAPurchaseCallback))]
		private static void Request01Il2cppCallback(int errorCode, string message)
		{
			request01Il2cppCallback(errorCode, message);
		}

		public static void Request(IAPurchaseListener listener, string pchPrice)
		{
			request01Il2cppCallback = new IAPHandler(listener).getRequestHandler();
			Viveport.Internal.IAPurchase.Request(Request01Il2cppCallback, pchPrice);
		}

		[MonoPInvokeCallback(typeof(IAPurchaseCallback))]
		private static void Request02Il2cppCallback(int errorCode, string message)
		{
			request02Il2cppCallback(errorCode, message);
		}

		public static void Request(IAPurchaseListener listener, string pchPrice, string pchUserData)
		{
			request02Il2cppCallback = new IAPHandler(listener).getRequestHandler();
			Viveport.Internal.IAPurchase.Request(Request02Il2cppCallback, pchPrice, pchUserData);
		}

		[MonoPInvokeCallback(typeof(IAPurchaseCallback))]
		private static void PurchaseIl2cppCallback(int errorCode, string message)
		{
			purchaseIl2cppCallback(errorCode, message);
		}

		public static void Purchase(IAPurchaseListener listener, string pchPurchaseId)
		{
			purchaseIl2cppCallback = new IAPHandler(listener).getPurchaseHandler();
			Viveport.Internal.IAPurchase.Purchase(PurchaseIl2cppCallback, pchPurchaseId);
		}

		[MonoPInvokeCallback(typeof(IAPurchaseCallback))]
		private static void Query01Il2cppCallback(int errorCode, string message)
		{
			query01Il2cppCallback(errorCode, message);
		}

		public static void Query(IAPurchaseListener listener, string pchPurchaseId)
		{
			query01Il2cppCallback = new IAPHandler(listener).getQueryHandler();
			Viveport.Internal.IAPurchase.Query(Query01Il2cppCallback, pchPurchaseId);
		}

		[MonoPInvokeCallback(typeof(IAPurchaseCallback))]
		private static void Query02Il2cppCallback(int errorCode, string message)
		{
			query02Il2cppCallback(errorCode, message);
		}

		public static void Query(IAPurchaseListener listener)
		{
			query02Il2cppCallback = new IAPHandler(listener).getQueryListHandler();
			Viveport.Internal.IAPurchase.Query(Query02Il2cppCallback);
		}

		[MonoPInvokeCallback(typeof(IAPurchaseCallback))]
		private static void GetBalanceIl2cppCallback(int errorCode, string message)
		{
			getBalanceIl2cppCallback(errorCode, message);
		}

		public static void GetBalance(IAPurchaseListener listener)
		{
			getBalanceIl2cppCallback = new IAPHandler(listener).getBalanceHandler();
			Viveport.Internal.IAPurchase.GetBalance(GetBalanceIl2cppCallback);
		}

		[MonoPInvokeCallback(typeof(IAPurchaseCallback))]
		private static void RequestSubscriptionIl2cppCallback(int errorCode, string message)
		{
			requestSubscriptionIl2cppCallback(errorCode, message);
		}

		public static void RequestSubscription(IAPurchaseListener listener, string pchPrice, string pchFreeTrialType, int nFreeTrialValue, string pchChargePeriodType, int nChargePeriodValue, int nNumberOfChargePeriod, string pchPlanId)
		{
			requestSubscriptionIl2cppCallback = new IAPHandler(listener).getRequestSubscriptionHandler();
			Viveport.Internal.IAPurchase.RequestSubscription(RequestSubscriptionIl2cppCallback, pchPrice, pchFreeTrialType, nFreeTrialValue, pchChargePeriodType, nChargePeriodValue, nNumberOfChargePeriod, pchPlanId);
		}

		[MonoPInvokeCallback(typeof(IAPurchaseCallback))]
		private static void RequestSubscriptionWithPlanIDIl2cppCallback(int errorCode, string message)
		{
			requestSubscriptionWithPlanIDIl2cppCallback(errorCode, message);
		}

		public static void RequestSubscriptionWithPlanID(IAPurchaseListener listener, string pchPlanId)
		{
			requestSubscriptionWithPlanIDIl2cppCallback = new IAPHandler(listener).getRequestSubscriptionWithPlanIDHandler();
			Viveport.Internal.IAPurchase.RequestSubscriptionWithPlanID(RequestSubscriptionWithPlanIDIl2cppCallback, pchPlanId);
		}

		[MonoPInvokeCallback(typeof(IAPurchaseCallback))]
		private static void SubscribeIl2cppCallback(int errorCode, string message)
		{
			subscribeIl2cppCallback(errorCode, message);
		}

		public static void Subscribe(IAPurchaseListener listener, string pchSubscriptionId)
		{
			subscribeIl2cppCallback = new IAPHandler(listener).getSubscribeHandler();
			Viveport.Internal.IAPurchase.Subscribe(SubscribeIl2cppCallback, pchSubscriptionId);
		}

		[MonoPInvokeCallback(typeof(IAPurchaseCallback))]
		private static void QuerySubscriptionIl2cppCallback(int errorCode, string message)
		{
			querySubscriptionIl2cppCallback(errorCode, message);
		}

		public static void QuerySubscription(IAPurchaseListener listener, string pchSubscriptionId)
		{
			querySubscriptionIl2cppCallback = new IAPHandler(listener).getQuerySubscriptionHandler();
			Viveport.Internal.IAPurchase.QuerySubscription(QuerySubscriptionIl2cppCallback, pchSubscriptionId);
		}

		[MonoPInvokeCallback(typeof(IAPurchaseCallback))]
		private static void QuerySubscriptionListIl2cppCallback(int errorCode, string message)
		{
			querySubscriptionListIl2cppCallback(errorCode, message);
		}

		public static void QuerySubscriptionList(IAPurchaseListener listener)
		{
			querySubscriptionListIl2cppCallback = new IAPHandler(listener).getQuerySubscriptionListHandler();
			Viveport.Internal.IAPurchase.QuerySubscriptionList(QuerySubscriptionListIl2cppCallback);
		}

		[MonoPInvokeCallback(typeof(IAPurchaseCallback))]
		private static void CancelSubscriptionIl2cppCallback(int errorCode, string message)
		{
			cancelSubscriptionIl2cppCallback(errorCode, message);
		}

		public static void CancelSubscription(IAPurchaseListener listener, string pchSubscriptionId)
		{
			cancelSubscriptionIl2cppCallback = new IAPHandler(listener).getCancelSubscriptionHandler();
			Viveport.Internal.IAPurchase.CancelSubscription(CancelSubscriptionIl2cppCallback, pchSubscriptionId);
		}
	}
	public class DLC
	{
	}
	public class Subscription
	{
		private static Viveport.Internal.StatusCallback2 isReadyIl2cppCallback;

		[MonoPInvokeCallback(typeof(Viveport.Internal.StatusCallback2))]
		private static void IsReadyIl2cppCallback(int errorCode, string message)
		{
			isReadyIl2cppCallback(errorCode, message);
		}

		public static void IsReady(StatusCallback2 callback)
		{
			if (callback == null)
			{
				throw new InvalidOperationException("callback == null");
			}
			isReadyIl2cppCallback = callback.Invoke;
			Api.InternalStatusCallback2s.Add(IsReadyIl2cppCallback);
			Viveport.Internal.Subscription.IsReady(IsReadyIl2cppCallback);
		}

		public static SubscriptionStatus GetUserStatus()
		{
			SubscriptionStatus subscriptionStatus = new SubscriptionStatus();
			if (Viveport.Internal.Subscription.IsWindowsSubscriber())
			{
				subscriptionStatus.Platforms.Add(SubscriptionStatus.Platform.Windows);
			}
			if (Viveport.Internal.Subscription.IsAndroidSubscriber())
			{
				subscriptionStatus.Platforms.Add(SubscriptionStatus.Platform.Android);
			}
			switch (Viveport.Internal.Subscription.GetTransactionType())
			{
			case ESubscriptionTransactionType.UNKNOWN:
				subscriptionStatus.Type = SubscriptionStatus.TransactionType.Unknown;
				break;
			case ESubscriptionTransactionType.PAID:
				subscriptionStatus.Type = SubscriptionStatus.TransactionType.Paid;
				break;
			case ESubscriptionTransactionType.REDEEM:
				subscriptionStatus.Type = SubscriptionStatus.TransactionType.Redeem;
				break;
			case ESubscriptionTransactionType.FREEE_TRIAL:
				subscriptionStatus.Type = SubscriptionStatus.TransactionType.FreeTrial;
				break;
			default:
				subscriptionStatus.Type = SubscriptionStatus.TransactionType.Unknown;
				break;
			}
			return subscriptionStatus;
		}
	}
	public class Deeplink
	{
		public abstract class DeeplinkChecker
		{
			public abstract void OnSuccess();

			public abstract void OnFailure(int errorCode, string errorMessage);
		}

		public static void GoToApp(DeeplinkChecker checker, string appId, string launchData)
		{
			if (checker == null || string.IsNullOrEmpty(appId) || string.IsNullOrEmpty(launchData))
			{
				throw new InvalidOperationException("checker == null || string.IsNullOrEmpty(appId) || string.IsNullOrEmpty(launchData)");
			}
			Viveport.Internal.Deeplink.GoToApp(checker, appId, launchData);
		}

		public static void GoToStore(DeeplinkChecker checker, string appId)
		{
			if (checker == null || string.IsNullOrEmpty(appId))
			{
				throw new InvalidOperationException("checker == null || string.IsNullOrEmpty(appId)");
			}
			Viveport.Internal.Deeplink.GoToStore(checker, appId);
		}

		public static void GoToAppOrGoToStore(DeeplinkChecker checker, string appId, string launchData)
		{
			if (checker == null || string.IsNullOrEmpty(appId) || string.IsNullOrEmpty(launchData))
			{
				throw new InvalidOperationException("checker == null || string.IsNullOrEmpty(appId) || string.IsNullOrEmpty(launchData)");
			}
			Viveport.Internal.Deeplink.GoToAppOrGoToStore(checker, appId, launchData);
		}

		public static string GetAppLaunchData()
		{
			return Viveport.Internal.Deeplink.GetAppLaunchData();
		}
	}
	internal class Token
	{
	}
}
namespace Viveport.Internal
{
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	internal delegate void GetLicenseCallback([MarshalAs(UnmanagedType.LPStr)] string message, [MarshalAs(UnmanagedType.LPStr)] string signature);
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	internal delegate void StatusCallback(int nResult);
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	internal delegate void StatusCallback2(int nResult, [MarshalAs(UnmanagedType.LPStr)] string message);
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	internal delegate void QueryRuntimeModeCallback(int nResult, int nMode);
	internal enum ELeaderboardDataRequest
	{
		k_ELeaderboardDataRequestGlobal,
		k_ELeaderboardDataRequestGlobalAroundUser,
		k_ELeaderboardDataRequestLocal,
		k_ELeaderboardDataRequestLocaleAroundUser
	}
	internal enum ELeaderboardDataTimeRange
	{
		k_ELeaderboardDataScropeAllTime,
		k_ELeaderboardDataScropeDaily,
		k_ELeaderboardDataScropeWeekly,
		k_ELeaderboardDataScropeMonthly
	}
	internal enum ELeaderboardSortMethod
	{
		k_ELeaderboardSortMethodNone,
		k_ELeaderboardSortMethodAscending,
		k_ELeaderboardSortMethodDescending
	}
	internal enum ELeaderboardDisplayType
	{
		k_ELeaderboardDisplayTypeNone,
		k_ELeaderboardDisplayTypeNumeric,
		k_ELeaderboardDisplayTypeTimeSeconds,
		k_ELeaderboardDisplayTypeTimeMilliSeconds
	}
	internal enum ELeaderboardUploadScoreMethod
	{
		k_ELeaderboardUploadScoreMethodNone,
		k_ELeaderboardUploadScoreMethodKeepBest,
		k_ELeaderboardUploadScoreMethodForceUpdate
	}
	internal enum ESubscriptionTransactionType
	{
		UNKNOWN,
		PAID,
		REDEEM,
		FREEE_TRIAL
	}
	internal enum ELocale
	{
		k_ELocaleUS,
		k_ELocaleDE,
		k_ELocaleJP,
		k_ELocaleKR,
		k_ELocaleRU,
		k_ELocaleCN,
		k_ELocaleTW,
		k_ELocaleFR
	}
	internal enum EAchievementDisplayAttribute
	{
		k_EAchievementDisplayAttributeName,
		k_EAchievementDisplayAttributeDesc,
		k_EAchievementDisplayAttributeHidden
	}
	internal struct LeaderboardEntry_t
	{
		internal int m_nGlobalRank;

		internal int m_nScore;

		[MarshalAs(UnmanagedType.ByValTStr, SizeConst = 64)]
		internal string m_pUserName;
	}
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	internal delegate void IAPurchaseCallback(int code, [MarshalAs(UnmanagedType.LPStr)] string message);
	internal struct IAPCurrency_t
	{
		[MarshalAs(UnmanagedType.ByValTStr, SizeConst = 16)]
		internal string m_pName;

		[MarshalAs(UnmanagedType.ByValTStr, SizeConst = 16)]
		internal string m_pSymbol;
	}
	internal class Api
	{
		internal class AndroidLicenseChecker : AndroidJavaProxy
		{
			private Viveport.Api.LicenseChecker checker;

			internal AndroidLicenseChecker(Viveport.Api.LicenseChecker checker)
				: base("com.htc.viveport.Api$LicenseChecker")
			{
				this.checker = checker;
			}

			internal void onSuccess(long issueTime, long expirationTime, int latestVersion, bool updateRequired)
			{
				Viveport.Core.Logger.Log("AndroidLicenseChecker onSuccess: " + latestVersion + ":" + updateRequired.ToString());
				if (checker != null)
				{
					checker.OnSuccess(issueTime, expirationTime, latestVersion, updateRequired);
				}
			}

			internal void onFailure(int errorCode, string errorMessage)
			{
				Viveport.Core.Logger.Log("AndroidLicenseChecker onFailure: " + errorCode + ":" + errorMessage);
				if (checker != null)
				{
					checker.OnFailure(errorCode, errorMessage);
				}
			}
		}

		internal static int Init(StatusCallback callback, string pchAppKey)
		{
			return Android.GetJavaAPI().CallStatic<int>("init", new object[3]
			{
				Android.CurrentContext,
				new AndroidPluginCallback(callback),
				pchAppKey
			});
		}

		internal static int Shutdown(StatusCallback callback)
		{
			return Android.GetJavaAPI().CallStatic<int>("shutdown", new object[1]
			{
				new AndroidPluginCallback(callback)
			});
		}

		internal static string Version()
		{
			return Android.GetJavaAPI().CallStatic<string>("version", Array.Empty<object>());
		}

		internal static void GetLicense(Viveport.Api.LicenseChecker checker, string appId, string appKey)
		{
			Android.GetJavaAPI().CallStatic("getLicense", Android.CurrentContext, new AndroidLicenseChecker(checker), appId, appKey);
		}
	}
	internal class User
	{
		internal static int IsReady(StatusCallback callback)
		{
			return Android.GetJavaUser().CallStatic<int>("isReady", new object[2]
			{
				Android.CurrentContext,
				new AndroidPluginCallback(callback)
			});
		}

		internal static string GetUserId()
		{
			return Android.GetJavaUser().CallStatic<string>("getUserID", new object[1] { Android.CurrentContext });
		}

		internal static string GetUserName()
		{
			return Android.GetJavaUser().CallStatic<string>("getUserName", new object[1] { Android.CurrentContext });
		}

		internal static string GetUserAvatarUrl()
		{
			return Android.GetJavaUser().CallStatic<string>("getUserAvatar", new object[1] { Android.CurrentContext });
		}
	}
	internal class UserStats
	{
		internal static int IsReady(StatusCallback callback)
		{
			return Android.GetJavaUserStats().CallStatic<int>("isReady", new object[2]
			{
				Android.CurrentContext,
				new AndroidPluginCallback(callback)
			});
		}

		internal static int DownloadStats(StatusCallback callback)
		{
			return Android.GetJavaUserStats().CallStatic<int>("downloadStats", new object[2]
			{
				Android.CurrentContext,
				new AndroidPluginCallback(callback)
			});
		}

		internal static int UploadStats(StatusCallback callback)
		{
			return Android.GetJavaUserStats().CallStatic<int>("uploadStats", new object[2]
			{
				Android.CurrentContext,
				new AndroidPluginCallback(callback)
			});
		}

		internal static int SetStat(string pchName, int nData)
		{
			return Android.GetJavaUserStats().CallStatic<int>("setStats", new object[2] { pchName, nData });
		}

		internal static int SetStat(string pchName, float fData)
		{
			return Android.GetJavaUserStats().CallStatic<int>("setStats", new object[2] { pchName, fData });
		}

		internal static int GetStat(string pchName, int nData)
		{
			return Android.GetJavaUserStats().CallStatic<int>("getStats", new object[2] { pchName, nData });
		}

		internal static float GetStat(string pchName, float fData)
		{
			return Android.GetJavaUserStats().CallStatic<float>("getStats", new object[2] { pchName, fData });
		}

		internal static bool GetAchievement(string pchName)
		{
			return Android.GetJavaUserStats().CallStatic<bool>("getAchievement", new object[1] { pchName });
		}

		internal static int GetAchievementUnlockTime(string pchName)
		{
			return Android.GetJavaUserStats().CallStatic<int>("getAchievementUnlockTime", new object[1] { pchName });
		}

		internal static int SetAchievement(string pchName)
		{
			return Android.GetJavaUserStats().CallStatic<int>("setAchievement", new object[1] { pchName });
		}

		internal static int ClearAchievement(string pchName)
		{
			return Android.GetJavaUserStats().CallStatic<int>("clearAchievement", new object[1] { pchName });
		}

		internal static string GetAchievementDisplayAttribute(string pchName, EAchievementDisplayAttribute attr)
		{
			return Android.GetJavaUserStats().CallStatic<string>("getAchievementDisplayAttribute", new object[2]
			{
				pchName,
				(int)attr
			});
		}

		internal static string GetAchievementDisplayAttribute(string pchName, EAchievementDisplayAttribute attr, ELocale locale)
		{
			return Android.GetJavaUserStats().CallStatic<string>("getAchievementDisplayAttribute", new object[3]
			{
				pchName,
				(int)attr,
				(int)locale
			});
		}

		internal static string GetAchievementIcon(string pchName)
		{
			return Android.GetJavaUserStats().CallStatic<string>("getAchievementIcon", new object[1] { pchName });
		}

		internal static int DownloadLeaderboardScores(StatusCallback callback, string pchLeaderboardName, ELeaderboardDataRequest nDataRequest, ELeaderboardDataTimeRange nTimeRange, int nRangeStart, int nRangeEnd)
		{
			return Android.GetJavaUserStats().CallStatic<int>("getLeaderboard", new object[7]
			{
				Android.CurrentContext,
				new AndroidPluginCallback(callback),
				pchLeaderboardName,
				nRangeStart,
				nRangeEnd,
				(int)nTimeRange,
				(int)nDataRequest
			});
		}

		internal static int UploadLeaderboardScore(StatusCallback callback, string pchLeaderboardName, int nScores)
		{
			return Android.GetJavaUserStats().CallStatic<int>("setLeaderboard", new object[4]
			{
				Android.CurrentContext,
				new AndroidPluginCallback(callback),
				pchLeaderboardName,
				nScores
			});
		}

		internal static Leaderboard GetLeaderboardScore(int nIndex)
		{
			Leaderboard leaderboard = new Leaderboard();
			leaderboard.UserName = Android.GetJavaUserStats().CallStatic<string>("getLeaderboardNameData", new object[1] { nIndex });
			leaderboard.Rank = Android.GetJavaUserStats().CallStatic<int>("getLeaderboardRankData", new object[1] { nIndex });
			leaderboard.Score = Android.GetJavaUserStats().CallStatic<int>("getLeaderboardScoreData", new object[1] { nIndex });
			return leaderboard;
		}

		internal static int GetLeaderboardScoreCount()
		{
			return Android.GetJavaUserStats().CallStatic<int>("getLeaderboardScoreCount", Array.Empty<object>());
		}

		internal static ELeaderboardSortMethod GetLeaderboardSortMethod()
		{
			return (ELeaderboardSortMethod)Android.GetJavaUserStats().CallStatic<int>("getLeaderboardSortType", Array.Empty<object>());
		}

		internal static ELeaderboardDisplayType GetLeaderboardDisplayType()
		{
			return (ELeaderboardDisplayType)Android.GetJavaUserStats().CallStatic<int>("getLeaderboardDisplayType", Array.Empty<object>());
		}
	}
	internal class Deeplink
	{
		internal class AndroidDeeplinkChecker : AndroidJavaProxy
		{
			private Viveport.Deeplink.DeeplinkChecker checker;

			internal AndroidDeeplinkChecker(Viveport.Deeplink.DeeplinkChecker checker)
				: base("com.htc.viveport.Api$StatusCallback2")
			{
				this.checker = checker;
			}

			internal void onSuccess()
			{
				Viveport.Core.Logger.Log("AndroidDeeplinkChecker onSuccess");
				if (checker != null)
				{
					checker.OnSuccess();
				}
			}

			internal void onFailure(int errorCode, string errorMessage)
			{
				Viveport.Core.Logger.Log("AndroidDeeplinkChecker onFailure: " + errorCode + ":" + errorMessage);
				if (checker != null)
				{
					checker.OnFailure(errorCode, errorMessage);
				}
			}
		}

		internal static void GoToApp(Viveport.Deeplink.DeeplinkChecker checker, string appId, string launchData)
		{
			Android.GetDeeplink().CallStatic("GoToApp", Android.CurrentContext, new AndroidDeeplinkChecker(checker), appId, launchData);
		}

		internal static void GoToStore(Viveport.Deeplink.DeeplinkChecker checker, string appId)
		{
			Android.GetDeeplink().CallStatic("GoToStore", Android.CurrentContext, new AndroidDeeplinkChecker(checker), appId);
		}

		internal static void GoToAppOrGoToStore(Viveport.Deeplink.DeeplinkChecker checker, string appId, string launchData)
		{
			Android.GetDeeplink().CallStatic("GoToAppOrGoToStore", Android.CurrentContext, new AndroidDeeplinkChecker(checker), appId, launchData);
		}

		internal static string GetAppLaunchData()
		{
			return Android.GetDeeplink().CallStatic<string>("GetAppLaunchData", new object[1] { Android.CurrentContext });
		}
	}
	internal class IAPurchase
	{
		internal static void IsReady(IAPurchaseCallback callback, string pchAppKey)
		{
			Android.GetJavaIAPurchase().CallStatic("isReady", Android.CurrentContext, new AndroidPluginCallback(callback), pchAppKey);
		}

		internal static void Request(IAPurchaseCallback callback, string pchPrice)
		{
			Android.GetJavaIAPurchase().CallStatic("request", Android.CurrentContext, new AndroidPluginCallback(callback), pchPrice);
		}

		internal static void Request(IAPurchaseCallback callback, string pchPrice, string pchUserData)
		{
			Android.GetJavaIAPurchase().CallStatic("request", Android.CurrentContext, new AndroidPluginCallback(callback), pchPrice, pchUserData);
		}

		internal static void Purchase(IAPurchaseCallback callback, string pchPurchaseId)
		{
			Android.GetJavaIAPurchase().CallStatic("makePurchase", Android.CurrentContext, new AndroidPluginCallback(callback), pchPurchaseId);
		}

		internal static void Query(IAPurchaseCallback callback, string pchPurchaseId)
		{
			Android.GetJavaIAPurchase().CallStatic("query", Android.CurrentContext, new AndroidPluginCallback(callback), pchPurchaseId);
		}

		internal static void Query(IAPurchaseCallback callback)
		{
			Android.GetJavaIAPurchase().CallStatic("query", Android.CurrentContext, new AndroidPluginCallback(callback));
		}

		internal static void GetBalance(IAPurchaseCallback callback)
		{
			Android.GetJavaIAPurchase().CallStatic("getBalance", Android.CurrentContext, new AndroidPluginCallback(callback));
		}

		internal static void RequestSubscription(IAPurchaseCallback callback, string pchPrice, string pchFreeTrialType, int nFreeTrialValue, string pchChargePeriodType, int nChargePeriodValue, int nNumberOfChargePeriod, string pchPlanId)
		{
			Android.GetJavaIAPurchase().CallStatic("requestSubscription", Android.CurrentContext, new AndroidPluginCallback(callback), pchPrice, pchFreeTrialType, nFreeTrialValue, pchChargePeriodType, nChargePeriodValue, nNumberOfChargePeriod, pchPlanId);
		}

		internal static void RequestSubscriptionWithPlanID(IAPurchaseCallback callback, string pchPlanId)
		{
			Android.GetJavaIAPurchase().CallStatic("requestSubscriptionWithPlanId", Android.CurrentContext, new AndroidPluginCallback(callback), pchPlanId);
		}

		internal static void Subscribe(IAPurchaseCallback callback, string pchSubscriptionId)
		{
			Android.GetJavaIAPurchase().CallStatic("subscribe", Android.CurrentContext, new AndroidPluginCallback(callback), pchSubscriptionId);
		}

		internal static void QuerySubscription(IAPurchaseCallback callback, string pchSubscriptionId)
		{
			Android.GetJavaIAPurchase().CallStatic("querySubscription", Android.CurrentContext, new AndroidPluginCallback(callback), pchSubscriptionId);
		}

		internal static void QuerySubscriptionList(IAPurchaseCallback callback)
		{
			Android.GetJavaIAPurchase().CallStatic("querySubscriptionList", Android.CurrentContext, new AndroidPluginCallback(callback));
		}

		internal static void CancelSubscription(IAPurchaseCallback callback, string pchSubscriptionId)
		{
			Android.GetJavaIAPurchase().CallStatic("cancelSubscription", Android.CurrentContext, new AndroidPluginCallback(callback), pchSubscriptionId);
		}
	}
	internal class Subscription
	{
		internal static int IsReady(StatusCallback2 callback)
		{
			Android.GetJavaSubscription().CallStatic("isReady", Android.CurrentContext, new AndroidPluginCallback(callback));
			return 0;
		}

		internal static bool IsWindowsSubscriber()
		{
			return Android.GetJavaSubscription().CallStatic<bool>("isWindowsSubscriber", Array.Empty<object>());
		}

		internal static bool IsAndroidSubscriber()
		{
			return Android.GetJavaSubscription().CallStatic<bool>("isAndroidSubscriber", Array.Empty<object>());
		}

		internal static ESubscriptionTransactionType GetTransactionType()
		{
			int num = Android.GetJavaSubscription().CallStatic<AndroidJavaObject>("getTransactionType", Array.Empty<object>()).Call<int>("getValue", Array.Empty<object>());
			ESubscriptionTransactionType result = ESubscriptionTransactionType.UNKNOWN;
			switch (num)
			{
			case 0:
				result = ESubscriptionTransactionType.UNKNOWN;
				break;
			case 1:
				result = ESubscriptionTransactionType.PAID;
				break;
			case 2:
				result = ESubscriptionTransactionType.REDEEM;
				break;
			case 3:
				result = ESubscriptionTransactionType.FREEE_TRIAL;
				break;
			}
			return result;
		}
	}
	internal class Android
	{
		private static AndroidJavaObject _api;

		private static AndroidJavaObject _iAPurchase;

		private static AndroidJavaClass _unityPlayer;

		private static AndroidJavaObject _user;

		private static AndroidJavaObject _userStats;

		private static AndroidJavaObject _subscription;

		private static AndroidJavaObject _deeplink;

		internal static AndroidJavaClass UnityPlayer
		{
			get
			{
				if (_unityPlayer == null)
				{
					_unityPlayer = new AndroidJavaClass("com.unity3d.player.UnityPlayer");
				}
				return _unityPlayer;
			}
		}

		internal static AndroidJavaObject CurrentActivity => UnityPlayer.GetStatic<AndroidJavaObject>("currentActivity");

		internal static AndroidJavaObject CurrentContext => CurrentActivity;

		internal static AndroidJavaObject GetJavaAPI()
		{
			if (_api == null)
			{
				_api = new AndroidJavaObject("com.htc.viveport.Api");
			}
			return _api;
		}

		internal static AndroidJavaObject GetJavaUser()
		{
			if (_user == null)
			{
				_user = new AndroidJavaObject("com.htc.viveport.User");
			}
			return _user;
		}

		internal static AndroidJavaObject GetJavaUserStats()
		{
			if (_userStats == null)
			{
				_userStats = new AndroidJavaObject("com.htc.viveport.UserStats");
			}
			return _userStats;
		}

		internal static AndroidJavaObject GetJavaIAPurchase()
		{
			if (_iAPurchase == null)
			{
				_iAPurchase = new AndroidJavaObject("com.htc.viveport.IAPurchase");
			}
			return _iAPurchase;
		}

		internal static AndroidJavaObject GetJavaSubscription()
		{
			if (_subscription == null)
			{
				_subscription = new AndroidJavaObject("com.htc.viveport.Subscription");
			}
			return _subscription;
		}

		internal static AndroidJavaObject GetDeeplink()
		{
			if (_deeplink == null)
			{
				_deeplink = new AndroidJavaObject("com.htc.viveport.Deeplink");
			}
			return _deeplink;
		}
	}
	internal class AndroidPluginCallback : AndroidJavaProxy
	{
		private IAPurchaseCallback callback;

		private StatusCallback statusCallback;

		private StatusCallback2 statusCallback2;

		internal AndroidPluginCallback(IAPurchaseCallback callback)
			: base("com.htc.viveport.Api$StatusCallback")
		{
			this.callback = callback;
		}

		internal AndroidPluginCallback(StatusCallback callback)
			: base("com.htc.viveport.Api$StatusCallback")
		{
			statusCallback = callback;
		}

		internal AndroidPluginCallback(StatusCallback2 callback)
			: base("com.htc.viveport.Api$StatusCallback")
		{
			statusCallback2 = callback;
		}

		internal void onResult(int statusCode, string result)
		{
			Viveport.Core.Logger.Log("ENTER callback onSuccess: " + statusCode + ":" + result);
			if (callback != null)
			{
				callback(statusCode, result);
			}
			if (statusCallback != null)
			{
				statusCallback(statusCode);
			}
			if (statusCallback2 != null)
			{
				statusCallback2(statusCode, result);
			}
		}
	}
}
namespace Viveport.Arcade
{
	internal class Session
	{
	}
}
namespace Viveport.Core
{
	public class Logger
	{
		private const string LoggerTypeNameUnity = "UnityEngine.Debug";

		private static bool _hasDetected;

		private static bool _usingUnityLog = true;

		private static Type _unityLogType;

		public static void Log(string message)
		{
			if (!_hasDetected || _usingUnityLog)
			{
				UnityLog(message);
			}
			else
			{
				ConsoleLog(message);
			}
		}

		private static void ConsoleLog(string message)
		{
			Console.WriteLine(message);
			_hasDetected = true;
		}

		private static void UnityLog(string message)
		{
			try
			{
				if (_unityLogType == null)
				{
					_unityLogType = GetType("UnityEngine.Debug");
				}
				_unityLogType.GetMethod("Log", new Type[1] { typeof(string) }).Invoke(null, new object[1] { message });
				_usingUnityLog = true;
			}
			catch (Exception)
			{
				ConsoleLog(message);
				_usingUnityLog = false;
			}
			_hasDetected = true;
		}

		private static Type GetType(string typeName)
		{
			Type type = Type.GetType(typeName);
			if (type != null)
			{
				return type;
			}
			Assembly[] assemblies = AppDomain.CurrentDomain.GetAssemblies();
			for (int i = 0; i < assemblies.Length; i++)
			{
				type = assemblies[i].GetType(typeName);
				if (type != null)
				{
					return type;
				}
			}
			return null;
		}
	}
}
namespace LitJson
{
	public enum JsonType
	{
		None,
		Object,
		Array,
		String,
		Int,
		Long,
		Double,
		Boolean
	}
	public interface IJsonWrapper : IList, ICollection, IEnumerable, IOrderedDictionary, IDictionary
	{
		bool IsArray { get; }

		bool IsBoolean { get; }

		bool IsDouble { get; }

		bool IsInt { get; }

		bool IsLong { get; }

		bool IsObject { get; }

		bool IsString { get; }

		bool GetBoolean();

		double GetDouble();

		int GetInt();

		JsonType GetJsonType();

		long GetLong();

		string GetString();

		void SetBoolean(bool val);

		void SetDouble(double val);

		void SetInt(int val);

		void SetJsonType(JsonType type);

		void SetLong(long val);

		void SetString(string val);

		string ToJson();

		void ToJson(JsonWriter writer);
	}
	public class JsonData : IJsonWrapper, IList, ICollection, IEnumerable, IOrderedDictionary, IDictionary, IEquatable<JsonData>
	{
		private IList<JsonData> inst_array;

		private bool inst_boolean;

		private double inst_double;

		private int inst_int;

		private long inst_long;

		private IDictionary<string, JsonData> inst_object;

		private string inst_string;

		private string json;

		private JsonType type;

		private IList<KeyValuePair<string, JsonData>> object_list;

		public int Count => EnsureCollection().Count;

		public bool IsArray => type == JsonType.Array;

		public bool IsBoolean => type == JsonType.Boolean;

		public bool IsDouble => type == JsonType.Double;

		public bool IsInt => type == JsonType.Int;

		public bool IsLong => type == JsonType.Long;

		public bool IsObject => type == JsonType.Object;

		public bool IsString => type == JsonType.String;

		int ICollection.Count => Count;

		bool ICollection.IsSynchronized => EnsureCollection().IsSynchronized;

		object ICollection.SyncRoot => EnsureCollection().SyncRoot;

		bool IDictionary.IsFixedSize => EnsureDictionary().IsFixedSize;

		bool IDictionary.IsReadOnly => EnsureDictionary().IsReadOnly;

		ICollection IDictionary.Keys
		{
			get
			{
				EnsureDictionary();
				IList<string> list = new List<string>();
				foreach (KeyValuePair<string, JsonData> item in object_list)
				{
					list.Add(item.Key);
				}
				return (ICollection)list;
			}
		}

		ICollection IDictionary.Values
		{
			get
			{
				EnsureDictionary();
				IList<JsonData> list = new List<JsonData>();
				foreach (KeyValuePair<string, JsonData> item in object_list)
				{
					list.Add(item.Value);
				}
				return (ICollection)list;
			}
		}

		bool IJsonWrapper.IsArray => IsArray;

		bool IJsonWrapper.IsBoolean => IsBoolean;

		bool IJsonWrapper.IsDouble => IsDouble;

		bool IJsonWrapper.IsInt => IsInt;

		bool IJsonWrapper.IsLong => IsLong;

		bool IJsonWrapper.IsObject => IsObject;

		bool IJsonWrapper.IsString => IsString;

		bool IList.IsFixedSize => EnsureList().IsFixedSize;

		bool IList.IsReadOnly => EnsureList().IsReadOnly;

		object IDictionary.this[object key]
		{
			get
			{
				return EnsureDictionary()[key];
			}
			set
			{
				if (!(key is string))
				{
					throw new ArgumentException("The key has to be a string");
				}
				JsonData value2 = ToJsonData(value);
				this[(string)key] = value2;
			}
		}

		object IOrderedDictionary.this[int idx]
		{
			get
			{
				EnsureDictionary();
				return object_list[idx].Value;
			}
			set
			{
				EnsureDictionary();
				JsonData value2 = ToJsonData(value);
				KeyValuePair<string, JsonData> keyValuePair = object_list[idx];
				inst_object[keyValuePair.Key] = value2;
				KeyValuePair<string, JsonData> value3 = new KeyValuePair<string, JsonData>(keyValuePair.Key, value2);
				object_list[idx] = value3;
			}
		}

		object IList.this[int index]
		{
			get
			{
				return EnsureList()[index];
			}
			set
			{
				EnsureList();
				JsonData value2 = ToJsonData(value);
				this[index] = value2;
			}
		}

		public JsonData this[string prop_name]
		{
			get
			{
				EnsureDictionary();
				return inst_object[prop_name];
			}
			set
			{
				EnsureDictionary();
				KeyValuePair<string, JsonData> keyValuePair = new KeyValuePair<string, JsonData>(prop_name, value);
				if (inst_object.ContainsKey(prop_name))
				{
					for (int i = 0; i < object_list.Count; i++)
					{
						if (object_list[i].Key == prop_name)
						{
							object_list[i] = keyValuePair;
							break;
						}
					}
				}
				else
				{
					object_list.Add(keyValuePair);
				}
				inst_object[prop_name] = value;
				json = null;
			}
		}

		public JsonData this[int index]
		{
			get
			{
				EnsureCollection();
				if (type == JsonType.Array)
				{
					return inst_array[index];
				}
				return object_list[index].Value;
			}
			set
			{
				EnsureCollection();
				if (type == JsonType.Array)
				{
					inst_array[index] = value;
				}
				else
				{
					KeyValuePair<string, JsonData> keyValuePair = object_list[index];
					KeyValuePair<string, JsonData> value2 = new KeyValuePair<string, JsonData>(keyValuePair.Key, value);
					object_list[index] = value2;
					inst_object[keyValuePair.Key] = value;
				}
				json = null;
			}
		}

		public JsonData()
		{
		}

		public JsonData(bool boolean)
		{
			type = JsonType.Boolean;
			inst_boolean = boolean;
		}

		public JsonData(double number)
		{
			type = JsonType.Double;
			inst_double = number;
		}

		public JsonData(int number)
		{
			type = JsonType.Int;
			inst_int = number;
		}

		public JsonData(long number)
		{
			type = JsonType.Long;
			inst_long = number;
		}

		public JsonData(object obj)
		{
			if (obj is bool)
			{
				type = JsonType.Boolean;
				inst_boolean = (bool)obj;
				return;
			}
			if (obj is double)
			{
				type = JsonType.Double;
				inst_double = (double)obj;
				return;
			}
			if (obj is int)
			{
				type = JsonType.Int;
				inst_int = (int)obj;
				return;
			}
			if (obj is long)
			{
				type = JsonType.Long;
				inst_long = (long)obj;
				return;
			}
			if (obj is string)
			{
				type = JsonType.String;
				inst_string = (string)obj;
				return;
			}
			throw new ArgumentException("Unable to wrap the given object with JsonData");
		}

		public JsonData(string str)
		{
			type = JsonType.String;
			inst_string = str;
		}

		public static implicit operator JsonData(bool data)
		{
			return new JsonData(data);
		}

		public static implicit operator JsonData(double data)
		{
			return new JsonData(data);
		}

		public static implicit operator JsonData(int data)
		{
			return new JsonData(data);
		}

		public static implicit operator JsonData(long data)
		{
			return new JsonData(data);
		}

		public static implicit operator JsonData(string data)
		{
			return new JsonData(data);
		}

		public static explicit operator bool(JsonData data)
		{
			if (data.type != JsonType.Boolean)
			{
				throw new InvalidCastException("Instance of JsonData doesn't hold a double");
			}
			return data.inst_boolean;
		}

		public static explicit operator double(JsonData data)
		{
			if (data.type != JsonType.Double)
			{
				throw new InvalidCastException("Instance of JsonData doesn't hold a double");
			}
			return data.inst_double;
		}

		public static explicit operator int(JsonData data)
		{
			if (data.type != JsonType.Int)
			{
				throw new InvalidCastException("Instance of JsonData doesn't hold an int");
			}
			return data.inst_int;
		}

		public static explicit operator long(JsonData data)
		{
			if (data.type != JsonType.Long)
			{
				throw new InvalidCastException("Instance of JsonData doesn't hold an int");
			}
			return data.inst_long;
		}

		public static explicit operator string(JsonData data)
		{
			if (data.type != JsonType.String)
			{
				throw new InvalidCastException("Instance of JsonData doesn't hold a string");
			}
			return data.inst_string;
		}

		void ICollection.CopyTo(Array array, int index)
		{
			EnsureCollection().CopyTo(array, index);
		}

		void IDictionary.Add(object key, object value)
		{
			JsonData value2 = ToJsonData(value);
			EnsureDictionary().Add(key, value2);
			KeyValuePair<string, JsonData> item = new KeyValuePair<string, JsonData>((string)key, value2);
			object_list.Add(item);
			json = null;
		}

		void IDictionary.Clear()
		{
			EnsureDictionary().Clear();
			object_list.Clear();
			json = null;
		}

		bool IDictionary.Contains(object key)
		{
			return EnsureDictionary().Contains(key);
		}

		IDictionaryEnumerator IDictionary.GetEnumerator()
		{
			return ((IOrderedDictionary)this).GetEnumerator();
		}

		void IDictionary.Remove(object key)
		{
			EnsureDictionary().Remove(key);
			for (int i = 0; i < object_list.Count; i++)
			{
				if (object_list[i].Key == (string)key)
				{
					object_list.RemoveAt(i);
					break;
				}
			}
			json = null;
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return EnsureCollection().GetEnumerator();
		}

		bool IJsonWrapper.GetBoolean()
		{
			if (type != JsonType.Boolean)
			{
				throw new InvalidOperationException("JsonData instance doesn't hold a boolean");
			}
			return inst_boolean;
		}

		double IJsonWrapper.GetDouble()
		{
			if (type != JsonType.Double)
			{
				throw new InvalidOperationException("JsonData instance doesn't hold a double");
			}
			return inst_double;
		}

		int IJsonWrapper.GetInt()
		{
			if (type != JsonType.Int)
			{
				throw new InvalidOperationException("JsonData instance doesn't hold an int");
			}
			return inst_int;
		}

		long IJsonWrapper.GetLong()
		{
			if (type != JsonType.Long)
			{
				throw new InvalidOperationException("JsonData instance doesn't hold a long");
			}
			return inst_long;
		}

		string IJsonWrapper.GetString()
		{
			if (type != JsonType.String)
			{
				throw new InvalidOperationException("JsonData instance doesn't hold a string");
			}
			return inst_string;
		}

		void IJsonWrapper.SetBoolean(bool val)
		{
			type = JsonType.Boolean;
			inst_boolean = val;
			json = null;
		}

		void IJsonWrapper.SetDouble(double val)
		{
			type = JsonType.Double;
			inst_double = val;
			json = null;
		}

		void IJsonWrapper.SetInt(int val)
		{
			type = JsonType.Int;
			inst_int = val;
			json = null;
		}

		void IJsonWrapper.SetLong(long val)
		{
			type = JsonType.Long;
			inst_long = val;
			json = null;
		}

		void IJsonWrapper.SetString(string val)
		{
			type = JsonType.String;
			inst_string = val;
			json = null;
		}

		string IJsonWrapper.ToJson()
		{
			return ToJson();
		}

		void IJsonWrapper.ToJson(JsonWriter writer)
		{
			ToJson(writer);
		}

		int IList.Add(object value)
		{
			return Add(value);
		}

		void IList.Clear()
		{
			EnsureList().Clear();
			json = null;
		}

		bool IList.Contains(object value)
		{
			return EnsureList().Contains(value);
		}

		int IList.IndexOf(object value)
		{
			return EnsureList().IndexOf(value);
		}

		void IList.Insert(int index, object value)
		{
			EnsureList().Insert(index, value);
			json = null;
		}

		void IList.Remove(object value)
		{
			EnsureList().Remove(value);
			json = null;
		}

		void IList.RemoveAt(int index)
		{
			EnsureList().RemoveAt(index);
			json = null;
		}

		IDictionaryEnumerator IOrderedDictionary.GetEnumerator()
		{
			EnsureDictionary();
			return new OrderedDictionaryEnumerator(object_list.GetEnumerator());
		}

		void IOrderedDictionary.Insert(int idx, object key, object value)
		{
			string text = (string)key;
			JsonData value2 = (this[text] = ToJsonData(value));
			KeyValuePair<string, JsonData> item = new KeyValuePair<string, JsonData>(text, value2);
			object_list.Insert(idx, item);
		}

		void IOrderedDictionary.RemoveAt(int idx)
		{
			EnsureDictionary();
			inst_object.Remove(object_list[idx].Key);
			object_list.RemoveAt(idx);
		}

		private ICollection EnsureCollection()
		{
			if (type == JsonType.Array)
			{
				return (ICollection)inst_array;
			}
			if (type == JsonType.Object)
			{
				return (ICollection)inst_object;
			}
			throw new InvalidOperationException("The JsonData instance has to be initialized first");
		}

		private IDictionary EnsureDictionary()
		{
			if (type == JsonType.Object)
			{
				return (IDictionary)inst_object;
			}
			if (type != 0)
			{
				throw new InvalidOperationException("Instance of JsonData is not a dictionary");
			}
			type = JsonType.Object;
			inst_object = new Dictionary<string, JsonData>();
			object_list = new List<KeyValuePair<string, JsonData>>();
			return (IDictionary)inst_object;
		}

		private IList EnsureList()
		{
			if (type == JsonType.Array)
			{
				return (IList)inst_array;
			}
			if (type != 0)
			{
				throw new InvalidOperationException("Instance of JsonData is not a list");
			}
			type = JsonType.Array;
			inst_array = new List<JsonData>();
			return (IList)inst_array;
		}

		private JsonData ToJsonData(object obj)
		{
			if (obj == null)
			{
				return null;
			}
			if (obj is JsonData)
			{
				return (JsonData)obj;
			}
			return new JsonData(obj);
		}

		private static void WriteJson(IJsonWrapper obj, JsonWriter writer)
		{
			if (obj.IsString)
			{
				writer.Write(obj.GetString());
			}
			else if (obj.IsBoolean)
			{
				writer.Write(obj.GetBoolean());
			}
			else if (obj.IsDouble)
			{
				writer.Write(obj.GetDouble());
			}
			else if (obj.IsInt)
			{
				writer.Write(obj.GetInt());
			}
			else if (obj.IsLong)
			{
				writer.Write(obj.GetLong());
			}
			else if (obj.IsArray)
			{
				writer.WriteArrayStart();
				foreach (JsonData item in (IEnumerable)obj)
				{
					WriteJson(item, writer);
				}
				writer.WriteArrayEnd();
			}
			else
			{
				if (!obj.IsObject)
				{
					return;
				}
				writer.WriteObjectStart();
				foreach (DictionaryEntry item2 in (IDictionary)obj)
				{
					writer.WritePropertyName((string)item2.Key);
					WriteJson((JsonData)item2.Value, writer);
				}
				writer.WriteObjectEnd();
			}
		}

		public int Add(object value)
		{
			JsonData value2 = ToJsonData(value);
			json = null;
			return EnsureList().Add(value2);
		}

		public void Clear()
		{
			if (IsObject)
			{
				((IDictionary)this).Clear();
			}
			else if (IsArray)
			{
				((IList)this).Clear();
			}
		}

		public bool Equals(JsonData x)
		{
			if (x == null)
			{
				return false;
			}
			if (x.type != type)
			{
				return false;
			}
			return type switch
			{
				JsonType.None => true, 
				JsonType.Object => inst_object.Equals(x.inst_object), 
				JsonType.Array => inst_array.Equals(x.inst_array), 
				JsonType.String => inst_string.Equals(x.inst_string), 
				JsonType.Int => inst_int.Equals(x.inst_int), 
				JsonType.Long => inst_long.Equals(x.inst_long), 
				JsonType.Double => inst_double.Equals(x.inst_double), 
				JsonType.Boolean => inst_boolean.Equals(x.inst_boolean), 
				_ => false, 
			};
		}

		public JsonType GetJsonType()
		{
			return type;
		}

		public void SetJsonType(JsonType type)
		{
			if (this.type != type)
			{
				switch (type)
				{
				case JsonType.Object:
					inst_object = new Dictionary<string, JsonData>();
					object_list = new List<KeyValuePair<string, JsonData>>();
					break;
				case JsonType.Array:
					inst_array = new List<JsonData>();
					break;
				case JsonType.String:
					inst_string = null;
					break;
				case JsonType.Int:
					inst_int = 0;
					break;
				case JsonType.Long:
					inst_long = 0L;
					break;
				case JsonType.Double:
					inst_double = 0.0;
					break;
				case JsonType.Boolean:
					inst_boolean = false;
					break;
				}
				this.type = type;
			}
		}

		public string ToJson()
		{
			if (json != null)
			{
				return json;
			}
			StringWriter stringWriter = new StringWriter();
			JsonWriter jsonWriter = new JsonWriter(stringWriter);
			jsonWriter.Validate = false;
			WriteJson(this, jsonWriter);
			json = stringWriter.ToString();
			return json;
		}

		public void ToJson(JsonWriter writer)
		{
			bool validate = writer.Validate;
			writer.Validate = false;
			WriteJson(this, writer);
			writer.Validate = validate;
		}

		public override string ToString()
		{
			return type switch
			{
				JsonType.Array => "JsonData array", 
				JsonType.Boolean => inst_boolean.ToString(), 
				JsonType.Double => inst_double.ToString(), 
				JsonType.Int => inst_int.ToString(), 
				JsonType.Long => inst_long.ToString(), 
				JsonType.Object => "JsonData object", 
				JsonType.String => inst_string, 
				_ => "Uninitialized JsonData", 
			};
		}
	}
	internal class OrderedDictionaryEnumerator : IDictionaryEnumerator, IEnumerator
	{
		private IEnumerator<KeyValuePair<string, JsonData>> list_enumerator;

		public object Current => Entry;

		public DictionaryEntry Entry
		{
			get
			{
				KeyValuePair<string, JsonData> current = list_enumerator.Current;
				return new DictionaryEntry(current.Key, current.Value);
			}
		}

		public object Key => list_enumerator.Current.Key;

		public object Value => list_enumerator.Current.Value;

		public OrderedDictionaryEnumerator(IEnumerator<KeyValuePair<string, JsonData>> enumerator)
		{
			list_enumerator = enumerator;
		}

		public bool MoveNext()
		{
			return list_enumerator.MoveNext();
		}

		public void Reset()
		{
			list_enumerator.Reset();
		}
	}
	public class JsonException : ApplicationException
	{
		public JsonException()
		{
		}

		internal JsonException(ParserToken token)
			: base($"Invalid token '{token}' in input string")
		{
		}

		internal JsonException(ParserToken token, Exception inner_exception)
			: base($"Invalid token '{token}' in input string", inner_exception)
		{
		}

		internal JsonException(int c)
			: base($"Invalid character '{(char)c}' in input string")
		{
		}

		internal JsonException(int c, Exception inner_exception)
			: base($"Invalid character '{(char)c}' in input string", inner_exception)
		{
		}

		public JsonException(string message)
			: base(message)
		{
		}

		public JsonException(string message, Exception inner_exception)
			: base(message, inner_exception)
		{
		}
	}
	internal struct PropertyMetadata
	{
		public MemberInfo Info;

		public bool IsField;

		public Type Type;
	}
	internal struct ArrayMetadata
	{
		private Type element_type;

		private bool is_array;

		private bool is_list;

		public Type ElementType
		{
			get
			{
				if (element_type == null)
				{
					return typeof(JsonData);
				}
				return element_type;
			}
			set
			{
				element_type = value;
			}
		}

		public bool IsArray
		{
			get
			{
				return is_array;
			}
			set
			{
				is_array = value;
			}
		}

		public bool IsList
		{
			get
			{
				return is_list;
			}
			set
			{
				is_list = value;
			}
		}
	}
	internal struct ObjectMetadata
	{
		private Type element_type;

		private bool is_dictionary;

		private IDictionary<string, PropertyMetadata> properties;

		public Type ElementType
		{
			get
			{
				if (element_type == null)
				{
					return typeof(JsonData);
				}
				return element_type;
			}
			set
			{
				element_type = value;
			}
		}

		public bool IsDictionary
		{
			get
			{
				return is_dictionary;
			}
			set
			{
				is_dictionary = value;
			}
		}

		public IDictionary<string, PropertyMetadata> Properties
		{
			get
			{
				return properties;
			}
			set
			{
				properties = value;
			}
		}
	}
	internal delegate void ExporterFunc(object obj, JsonWriter writer);
	public delegate void ExporterFunc<T>(T obj, JsonWriter writer);
	internal delegate object ImporterFunc(object input);
	public delegate TValue ImporterFunc<TJson, TValue>(TJson input);
	public delegate IJsonWrapper WrapperFactory();
	public class JsonMapper
	{
		private static int max_nesting_depth;

		private static IFormatProvider datetime_format;

		private static IDictionary<Type, ExporterFunc> base_exporters_table;

		private static IDictionary<Type, ExporterFunc> custom_exporters_table;

		private static IDictionary<Type, IDictionary<Type, ImporterFunc>> base_importers_table;

		private static IDictionary<Type, IDictionary<Type, ImporterFunc>> custom_importers_table;

		private static IDictionary<Type, ArrayMetadata> array_metadata;

		private static readonly object array_metadata_lock;

		private static IDictionary<Type, IDictionary<Type, MethodInfo>> conv_ops;

		private static readonly object conv_ops_lock;

		private static IDictionary<Type, ObjectMetadata> object_metadata;

		private static readonly object object_metadata_lock;

		private static IDictionary<Type, IList<PropertyMetadata>> type_properties;

		private static readonly object type_properties_lock;

		private static JsonWriter static_writer;

		private static readonly object static_writer_lock;

		static JsonMapper()
		{
			array_metadata_lock = new object();
			conv_ops_lock = new object();
			object_metadata_lock = new object();
			type_properties_lock = new object();
			static_writer_lock = new object();
			max_nesting_depth = 100;
			array_metadata = new Dictionary<Type, ArrayMetadata>();
			conv_ops = new Dictionary<Type, IDictionary<Type, MethodInfo>>();
			object_metadata = new Dictionary<Type, ObjectMetadata>();
			type_properties = new Dictionary<Type, IList<PropertyMetadata>>();
			static_writer = new JsonWriter();
			datetime_format = DateTimeFormatInfo.InvariantInfo;
			base_exporters_table = new Dictionary<Type, ExporterFunc>();
			custom_exporters_table = new Dictionary<Type, ExporterFunc>();
			base_importers_table = new Dictionary<Type, IDictionary<Type, ImporterFunc>>();
			custom_importers_table = new Dictionary<Type, IDictionary<Type, ImporterFunc>>();
			RegisterBaseExporters();
			RegisterBaseImporters();
		}

		private static void AddArrayMetadata(Type type)
		{
			if (array_metadata.ContainsKey(type))
			{
				return;
			}
			ArrayMetadata value = default(ArrayMetadata);
			value.IsArray = type.IsArray;
			if (type.GetInterface("System.Collections.IList") != null)
			{
				value.IsList = true;
			}
			PropertyInfo[] properties = type.GetProperties();
			foreach (PropertyInfo propertyInfo in properties)
			{
				if (!(propertyInfo.Name != "Item"))
				{
					ParameterInfo[] indexParameters = propertyInfo.GetIndexParameters();
					if (indexParameters.Length == 1 && indexParameters[0].ParameterType == typeof(int))
					{
						value.ElementType = propertyInfo.PropertyType;
					}
				}
			}
			lock (array_metadata_lock)
			{
				try
				{
					array_metadata.Add(type, value);
				}
				catch (ArgumentException)
				{
				}
			}
		}

		private static void AddObjectMetadata(Type type)
		{
			if (object_metadata.ContainsKey(type))
			{
				return;
			}
			ObjectMetadata value = default(ObjectMetadata);
			if (type.GetInterface("System.Collections.IDictionary") != null)
			{
				value.IsDictionary = true;
			}
			value.Properties = new Dictionary<string, PropertyMetadata>();
			PropertyInfo[] properties = type.GetProperties();
			foreach (PropertyInfo propertyInfo in properties)
			{
				if (propertyInfo.Name == "Item")
				{
					ParameterInfo[] indexParameters = propertyInfo.GetIndexParameters();
					if (indexParameters.Length == 1 && indexParameters[0].ParameterType == typeof(string))
					{
						value.ElementType = propertyInfo.PropertyType;
					}
				}
				else
				{
					PropertyMetadata value2 = default(PropertyMetadata);
					value2.Info = propertyInfo;
					value2.Type = propertyInfo.PropertyType;
					value.Properties.Add(propertyInfo.Name, value2);
				}
			}
			FieldInfo[] fields = type.GetFields();
			foreach (FieldInfo fieldInfo in fields)
			{
				PropertyMetadata value3 = default(PropertyMetadata);
				value3.Info = fieldInfo;
				value3.IsField = true;
				value3.Type = fieldInfo.FieldType;
				value.Properties.Add(fieldInfo.Name, value3);
			}
			lock (object_metadata_lock)
			{
				try
				{
					object_metadata.Add(type, value);
				}
				catch (ArgumentException)
				{
				}
			}
		}

		private static void AddTypeProperties(Type type)
		{
			if (type_properties.ContainsKey(type))
			{
				return;
			}
			IList<PropertyMetadata> list = new List<PropertyMetadata>();
			PropertyInfo[] properties = type.GetProperties();
			foreach (PropertyInfo propertyInfo in properties)
			{
				if (!(propertyInfo.Name == "Item"))
				{
					PropertyMetadata item = default(PropertyMetadata);
					item.Info = propertyInfo;
					item.IsField = false;
					list.Add(item);
				}
			}
			FieldInfo[] fields = type.GetFields();
			foreach (FieldInfo info in fields)
			{
				PropertyMetadata item2 = default(PropertyMetadata);
				item2.Info = info;
				item2.IsField = true;
				list.Add(item2);
			}
			lock (type_properties_lock)
			{
				try
				{
					type_properties.Add(type, list);
				}
				catch (ArgumentException)
				{
				}
			}
		}

		private static MethodInfo GetConvOp(Type t1, Type t2)
		{
			lock (conv_ops_lock)
			{
				if (!conv_ops.ContainsKey(t1))
				{
					conv_ops.Add(t1, new Dictionary<Type, MethodInfo>());
				}
			}
			if (conv_ops[t1].ContainsKey(t2))
			{
				return conv_ops[t1][t2];
			}
			MethodInfo method = t1.GetMethod("op_Implicit", new Type[1] { t2 });
			lock (conv_ops_lock)
			{
				try
				{
					conv_ops[t1].Add(t2, method);
					return method;
				}
				catch (ArgumentException)
				{
					return conv_ops[t1][t2];
				}
			}
		}

		private static object ReadValue(Type inst_type, JsonReader reader)
		{
			reader.Read();
			if (reader.Token == JsonToken.ArrayEnd)
			{
				return null;
			}
			if (reader.Token == JsonToken.Null)
			{
				if (!inst_type.IsClass)
				{
					throw new JsonException($"Can't assign null to an instance of type {inst_type}");
				}
				return null;
			}
			if (reader.Token == JsonToken.Double || reader.Token == JsonToken.Int || reader.Token == JsonToken.Long || reader.Token == JsonToken.String || reader.Token == JsonToken.Boolean)
			{
				Type type = reader.Value.GetType();
				if (inst_type.IsAssignableFrom(type))
				{
					return reader.Value;
				}
				if (custom_importers_table.ContainsKey(type) && custom_importers_table[type].ContainsKey(inst_type))
				{
					return custom_importers_table[type][inst_type](reader.Value);
				}
				if (base_importers_table.ContainsKey(type) && base_importers_table[type].ContainsKey(inst_type))
				{
					return base_importers_table[type][inst_type](reader.Value);
				}
				if (inst_type.IsEnum)
				{
					return Enum.ToObject(inst_type, reader.Value);
				}
				MethodInfo convOp = GetConvOp(inst_type, type);
				if (convOp != null)
				{
					return convOp.Invoke(null, new object[1] { reader.Value });
				}
				throw new JsonException($"Can't assign value '{reader.Value}' (type {type}) to type {inst_type}");
			}
			object obj = null;
			if (reader.Token == JsonToken.ArrayStart)
			{
				AddArrayMetadata(inst_type);
				ArrayMetadata arrayMetadata = array_metadata[inst_type];
				if (!arrayMetadata.IsArray && !arrayMetadata.IsList)
				{
					throw new JsonException($"Type {inst_type} can't act as an array");
				}
				IList list;
				Type elementType;
				if (!arrayMetadata.IsArray)
				{
					list = (IList)Activator.CreateInstance(inst_type);
					elementType = arrayMetadata.ElementType;
				}
				else
				{
					list = new ArrayList();
					elementType = inst_type.GetElementType();
				}
				while (true)
				{
					object value = ReadValue(elementType, reader);
					if (reader.Token == JsonToken.ArrayEnd)
					{
						break;
					}
					list.Add(value);
				}
				if (arrayMetadata.IsArray)
				{
					int count = list.Count;
					obj = Array.CreateInstance(elementType, count);
					for (int i = 0; i < count; i++)
					{
						((Array)obj).SetValue(list[i], i);
					}
				}
				else
				{
					obj = list;
				}
			}
			else if (reader.Token == JsonToken.ObjectStart)
			{
				AddObjectMetadata(inst_type);
				ObjectMetadata objectMetadata = object_metadata[inst_type];
				obj = Activator.CreateInstance(inst_type);
				while (true)
				{
					reader.Read();
					if (reader.Token == JsonToken.ObjectEnd)
					{
						break;
					}
					string text = (string)reader.Value;
					if (objectMetadata.Properties.ContainsKey(text))
					{
						PropertyMetadata propertyMetadata = objectMetadata.Properties[text];
						if (propertyMetadata.IsField)
						{
							((FieldInfo)propertyMetadata.Info).SetValue(obj, ReadValue(propertyMetadata.Type, reader));
							continue;
						}
						PropertyInfo propertyInfo = (PropertyInfo)propertyMetadata.Info;
						if (propertyInfo.CanWrite)
						{
							propertyInfo.SetValue(obj, ReadValue(propertyMetadata.Type, reader), null);
						}
						else
						{
							ReadValue(propertyMetadata.Type, reader);
						}
					}
					else
					{
						if (!objectMetadata.IsDictionary)
						{
							throw new JsonException($"The type {inst_type} doesn't have the property '{text}'");
						}
						((IDictionary)obj).Add(text, ReadValue(objectMetadata.ElementType, reader));
					}
				}
			}
			return obj;
		}

		private static IJsonWrapper ReadValue(WrapperFactory factory, JsonReader reader)
		{
			reader.Read();
			if (reader.Token == JsonToken.ArrayEnd || reader.Token == JsonToken.Null)
			{
				return null;
			}
			IJsonWrapper jsonWrapper = factory();
			if (reader.Token == JsonToken.String)
			{
				jsonWrapper.SetString((string)reader.Value);
				return jsonWrapper;
			}
			if (reader.Token == JsonToken.Double)
			{
				jsonWrapper.SetDouble((double)reader.Value);
				return jsonWrapper;
			}
			if (reader.Token == JsonToken.Int)
			{
				jsonWrapper.SetInt((int)reader.Value);
				return jsonWrapper;
			}
			if (reader.Token == JsonToken.Long)
			{
				jsonWrapper.SetLong((long)reader.Value);
				return jsonWrapper;
			}
			if (reader.Token == JsonToken.Boolean)
			{
				jsonWrapper.SetBoolean((bool)reader.Value);
				return jsonWrapper;
			}
			if (reader.Token == JsonToken.ArrayStart)
			{
				jsonWrapper.SetJsonType(JsonType.Array);
				while (true)
				{
					IJsonWrapper value = ReadValue(factory, reader);
					if (reader.Token == JsonToken.ArrayEnd)
					{
						break;
					}
					jsonWrapper.Add(value);
				}
			}
			else if (reader.Token == JsonToken.ObjectStart)
			{
				jsonWrapper.SetJsonType(JsonType.Object);
				while (true)
				{
					reader.Read();
					if (reader.Token == JsonToken.ObjectEnd)
					{
						break;
					}
					string key = (string)reader.Value;
					jsonWrapper[key] = ReadValue(factory, reader);
				}
			}
			return jsonWrapper;
		}

		private static void RegisterBaseExporters()
		{
			base_exporters_table[typeof(byte)] = delegate(object obj, JsonWriter writer)
			{
				writer.Write(Convert.ToInt32((byte)obj));
			};
			base_exporters_table[typeof(char)] = delegate(object obj, JsonWriter writer)
			{
				writer.Write(Convert.ToString((char)obj));
			};
			base_exporters_table[typeof(DateTime)] = delegate(object obj, JsonWriter writer)
			{
				writer.Write(Convert.ToString((DateTime)obj, datetime_format));
			};
			base_exporters_table[typeof(decimal)] = delegate(object obj, JsonWriter writer)
			{
				writer.Write((decimal)obj);
			};
			base_exporters_table[typeof(sbyte)] = delegate(object obj, JsonWriter writer)
			{
				writer.Write(Convert.ToInt32((sbyte)obj));
			};
			base_exporters_table[typeof(short)] = delegate(object obj, JsonWriter writer)
			{
				writer.Write(Convert.ToInt32((short)obj));
			};
			base_exporters_table[typeof(ushort)] = delegate(object obj, JsonWriter writer)
			{
				writer.Write(Convert.ToInt32((ushort)obj));
			};
			base_exporters_table[typeof(uint)] = delegate(object obj, JsonWriter writer)
			{
				writer.Write(Convert.ToUInt64((uint)obj));
			};
			base_exporters_table[typeof(ulong)] = delegate(object obj, JsonWriter writer)
			{
				writer.Write((ulong)obj);
			};
			base_exporters_table[typeof(float)] = delegate(object obj, JsonWriter writer)
			{
				writer.Write((float)obj);
			};
		}

		private static void RegisterBaseImporters()
		{
			ImporterFunc importer = (object input) => Convert.ToByte((int)input);
			RegisterImporter(base_importers_table, typeof(int), typeof(byte), importer);
			importer = (object input) => Convert.ToUInt64((int)input);
			RegisterImporter(base_importers_table, typeof(int), typeof(ulong), importer);
			importer = (object input) => Convert.ToSByte((int)input);
			RegisterImporter(base_importers_table, typeof(int), typeof(sbyte), importer);
			importer = (object input) => Convert.ToInt16((int)input);
			RegisterImporter(base_importers_table, typeof(int), typeof(short), importer);
			importer = (object input) => Convert.ToUInt16((int)input);
			RegisterImporter(base_importers_table, typeof(int), typeof(ushort), importer);
			importer = (object input) => Convert.ToUInt32((int)input);
			RegisterImporter(base_importers_table, typeof(int), typeof(uint), importer);
			importer = (object input) => Convert.ToSingle((int)input);
			RegisterImporter(base_importers_table, typeof(int), typeof(float), importer);
			importer = (object input) => Convert.ToSingle((float)(double)input);
			RegisterImporter(base_importers_table, typeof(double), typeof(float), importer);
			importer = (object input) => Convert.ToDouble((int)input);
			RegisterImporter(base_importers_table, typeof(int), typeof(double), importer);
			importer = (object input) => Convert.ToDecimal((double)input);
			RegisterImporter(base_importers_table, typeof(double), typeof(decimal), importer);
			importer = (object input) => Convert.ToUInt32((long)input);
			RegisterImporter(base_importers_table, typeof(long), typeof(uint), importer);
			importer = (object input) => Convert.ToChar((string)input);
			RegisterImporter(base_importers_table, typeof(string), typeof(char), importer);
			importer = (object input) => Convert.ToDateTime((string)input, datetime_format);
			RegisterImporter(base_importers_table, typeof(string), typeof(DateTime), importer);
		}

		private static void RegisterImporter(IDictionary<Type, IDictionary<Type, ImporterFunc>> table, Type json_type, Type value_type, ImporterFunc importer)
		{
			if (!table.ContainsKey(json_type))
			{
				table.Add(json_type, new Dictionary<Type, ImporterFunc>());
			}
			table[json_type][value_type] = importer;
		}

		private static void WriteValue(object obj, JsonWriter writer, bool writer_is_private, int depth)
		{
			if (depth > max_nesting_depth)
			{
				throw new JsonException($"Max allowed object depth reached while trying to export from type {obj.GetType()}");
			}
			if (obj == null)
			{
				writer.Write(null);
				return;
			}
			if (obj is IJsonWrapper)
			{
				if (writer_is_private)
				{
					writer.TextWriter.Write(((IJsonWrapper)obj).ToJson());
				}
				else
				{
					((IJsonWrapper)obj).ToJson(writer);
				}
				return;
			}
			if (obj is string)
			{
				writer.Write((string)obj);
				return;
			}
			if (obj is double)
			{
				writer.Write((double)obj);
				return;
			}
			if (obj is int)
			{
				writer.Write((int)obj);
				return;
			}
			if (obj is bool)
			{
				writer.Write((bool)obj);
				return;
			}
			if (obj is long)
			{
				writer.Write((long)obj);
				return;
			}
			if (obj is Array)
			{
				writer.WriteArrayStart();
				foreach (object item in (Array)obj)
				{
					WriteValue(item, writer, writer_is_private, depth + 1);
				}
				writer.WriteArrayEnd();
				return;
			}
			if (obj is IList)
			{
				writer.WriteArrayStart();
				foreach (object item2 in (IList)obj)
				{
					WriteValue(item2, writer, writer_is_private, depth + 1);
				}
				writer.WriteArrayEnd();
				return;
			}
			if (obj is IDictionary)
			{
				writer.WriteObjectStart();
				foreach (DictionaryEntry item3 in (IDictionary)obj)
				{
					writer.WritePropertyName((string)item3.Key);
					WriteValue(item3.Value, writer, writer_is_private, depth + 1);
				}
				writer.WriteObjectEnd();
				return;
			}
			Type type = obj.GetType();
			if (custom_exporters_table.ContainsKey(type))
			{
				custom_exporters_table[type](obj, writer);
				return;
			}
			if (base_exporters_table.ContainsKey(type))
			{
				base_exporters_table[type](obj, writer);
				return;
			}
			if (obj is Enum)
			{
				Type underlyingType = Enum.GetUnderlyingType(type);
				if (underlyingType == typeof(long) || underlyingType == typeof(uint) || underlyingType == typeof(ulong))
				{
					writer.Write((ulong)obj);
				}
				else
				{
					writer.Write((int)obj);
				}
				return;
			}
			AddTypeProperties(type);
			IList<PropertyMetadata> list = type_properties[type];
			writer.WriteObjectStart();
			foreach (PropertyMetadata item4 in list)
			{
				if (item4.IsField)
				{
					writer.WritePropertyName(item4.Info.Name);
					WriteValue(((FieldInfo)item4.Info).GetValue(obj), writer, writer_is_private, depth + 1);
					continue;
				}
				PropertyInfo propertyInfo = (PropertyInfo)item4.Info;
				if (propertyInfo.CanRead)
				{
					writer.WritePropertyName(item4.Info.Name);
					WriteValue(propertyInfo.GetValue(obj, null), writer, writer_is_private, depth + 1);
				}
			}
			writer.WriteObjectEnd();
		}

		public static string ToJson(object obj)
		{
			lock (static_writer_lock)
			{
				static_writer.Reset();
				WriteValue(obj, static_writer, writer_is_private: true, 0);
				return static_writer.ToString();
			}
		}

		public static void ToJson(object obj, JsonWriter writer)
		{
			WriteValue(obj, writer, writer_is_private: false, 0);
		}

		public static JsonData ToObject(JsonReader reader)
		{
			return (JsonData)ToWrapper(() => new JsonData(), reader);
		}

		public static JsonData ToObject(TextReader reader)
		{
			JsonReader reader2 = new JsonReader(reader);
			return (JsonData)ToWrapper(() => new JsonData(), reader2);
		}

		public static JsonData ToObject(string json)
		{
			return (JsonData)ToWrapper(() => new JsonData(), json);
		}

		public static T ToObject<T>(JsonReader reader)
		{
			return (T)ReadValue(typeof(T), reader);
		}

		public static T ToObject<T>(TextReader reader)
		{
			JsonReader reader2 = new JsonReader(reader);
			return (T)ReadValue(typeof(T), reader2);
		}

		public static T ToObject<T>(string json)
		{
			JsonReader reader = new JsonReader(json);
			return (T)ReadValue(typeof(T), reader);
		}

		public static IJsonWrapper ToWrapper(WrapperFactory factory, JsonReader reader)
		{
			return ReadValue(factory, reader);
		}

		public static IJsonWrapper ToWrapper(WrapperFactory factory, string json)
		{
			JsonReader reader = new JsonReader(json);
			return ReadValue(factory, reader);
		}

		public static void RegisterExporter<T>(ExporterFunc<T> exporter)
		{
			ExporterFunc value = delegate(object obj, JsonWriter writer)
			{
				exporter((T)obj, writer);
			};
			custom_exporters_table[typeof(T)] = value;
		}

		public static void RegisterImporter<TJson, TValue>(ImporterFunc<TJson, TValue> importer)
		{
			ImporterFunc importer2 = (object input) => importer((TJson)input);
			RegisterImporter(custom_importers_table, typeof(TJson), typeof(TValue), importer2);
		}

		public static void UnregisterExporters()
		{
			custom_exporters_table.Clear();
		}

		public static void UnregisterImporters()
		{
			custom_importers_table.Clear();
		}
	}
	public enum JsonToken
	{
		None,
		ObjectStart,
		PropertyName,
		ObjectEnd,
		ArrayStart,
		ArrayEnd,
		Int,
		Long,
		Double,
		String,
		Boolean,
		Null
	}
	public class JsonReader
	{
		private static IDictionary<int, IDictionary<int, int[]>> parse_table;

		private Stack<int> automaton_stack;

		private int current_input;

		private int current_symbol;

		private bool end_of_json;

		private bool end_of_input;

		private Lexer lexer;

		private bool parser_in_string;

		private bool parser_return;

		private bool read_started;

		private TextReader reader;

		private bool reader_is_owned;

		private object token_value;

		private JsonToken token;

		public bool AllowComments
		{
			get
			{
				return lexer.AllowComments;
			}
			set
			{
				lexer.AllowComments = value;
			}
		}

		public bool AllowSingleQuotedStrings
		{
			get
			{
				return lexer.AllowSingleQuotedStrings;
			}
			set
			{
				lexer.AllowSingleQuotedStrings = value;
			}
		}

		public bool EndOfInput => end_of_input;

		public bool EndOfJson => end_of_json;

		public JsonToken Token => token;

		public object Value => token_value;

		static JsonReader()
		{
			PopulateParseTable();
		}

		public JsonReader(string json_text)
			: this(new StringReader(json_text), owned: true)
		{
		}

		public JsonReader(TextReader reader)
			: this(reader, owned: false)
		{
		}

		private JsonReader(TextReader reader, bool owned)
		{
			if (reader == null)
			{
				throw new ArgumentNullException("reader");
			}
			parser_in_string = false;
			parser_return = false;
			read_started = false;
			automaton_stack = new Stack<int>();
			automaton_stack.Push(65553);
			automaton_stack.Push(65543);
			lexer = new Lexer(reader);
			end_of_input = false;
			end_of_json = false;
			this.reader = reader;
			reader_is_owned = owned;
		}

		private static void PopulateParseTable()
		{
			parse_table = new Dictionary<int, IDictionary<int, int[]>>();
			TableAddRow(ParserToken.Array);
			TableAddCol(ParserToken.Array, 91, 91, 65549);
			TableAddRow(ParserToken.ArrayPrime);
			TableAddCol(ParserToken.ArrayPrime, 34, 65550, 65551, 93);
			TableAddCol(ParserToken.ArrayPrime, 91, 65550, 65551, 93);
			TableAddCol(ParserToken.ArrayPrime, 93, 93);
			TableAddCol(ParserToken.ArrayPrime, 123, 65550, 65551, 93);
			TableAddCol(ParserToken.ArrayPrime, 65537, 65550, 65551, 93);
			TableAddCol(ParserToken.ArrayPrime, 65538, 65550, 65551, 93);
			TableAddCol(ParserToken.ArrayPrime, 65539, 65550, 65551, 93);
			TableAddCol(ParserToken.ArrayPrime, 65540, 65550, 65551, 93);
			TableAddRow(ParserToken.Object);
			TableAddCol(ParserToken.Object, 123, 123, 65545);
			TableAddRow(ParserToken.ObjectPrime);
			TableAddCol(ParserToken.ObjectPrime, 34, 65546, 65547, 125);
			TableAddCol(ParserToken.ObjectPrime, 125, 125);
			TableAddRow(ParserToken.Pair);
			TableAddCol(ParserToken.Pair, 34, 65552, 58, 65550);
			TableAddRow(ParserToken.PairRest);
			TableAddCol(ParserToken.PairRest, 44, 44, 65546, 65547);
			TableAddCol(ParserToken.PairRest, 125, 65554);
			TableAddRow(ParserToken.String);
			TableAddCol(ParserToken.String, 34, 34, 65541, 34);
			TableAddRow(ParserToken.Text);
			TableAddCol(ParserToken.Text, 91, 65548);
			TableAddCol(ParserToken.Text, 123, 65544);
			TableAddRow(ParserToken.Value);
			TableAddCol(ParserToken.Value, 34, 65552);
			TableAddCol(ParserToken.Value, 91, 65548);
			TableAddCol(ParserToken.Value, 123, 65544);
			TableAddCol(ParserToken.Value, 65537, 65537);
			TableAddCol(ParserToken.Value, 65538, 65538);
			TableAddCol(ParserToken.Value, 65539, 65539);
			TableAddCol(ParserToken.Value, 65540, 65540);
			TableAddRow(ParserToken.ValueRest);
			TableAddCol(ParserToken.ValueRest, 44, 44, 65550, 65551);
			TableAddCol(ParserToken.ValueRest, 93, 65554);
		}

		private static void TableAddCol(ParserToken row, int col, params int[] symbols)
		{
			parse_table[(int)row].Add(col, symbols);
		}

		private static void TableAddRow(ParserToken rule)
		{
			parse_table.Add((int)rule, new Dictionary<int, int[]>());
		}

		private void ProcessNumber(string number)
		{
			int result2;
			long result3;
			if ((number.IndexOf('.') != -1 || number.IndexOf('e') != -1 || number.IndexOf('E') != -1) && double.TryParse(number, out var result))
			{
				token = JsonToken.Double;
				token_value = result;
			}
			else if (int.TryParse(number, out result2))
			{
				token = JsonToken.Int;
				token_value = result2;
			}
			else if (long.TryParse(number, out result3))
			{
				token = JsonToken.Long;
				token_value = result3;
			}
			else
			{
				token = JsonToken.Int;
				token_value = 0;
			}
		}

		private void ProcessSymbol()
		{
			if (current_symbol == 91)
			{
				token = JsonToken.ArrayStart;
				parser_return = true;
			}
			else if (current_symbol == 93)
			{
				token = JsonToken.ArrayEnd;
				parser_return = true;
			}
			else if (current_symbol == 123)
			{
				token = JsonToken.ObjectStart;
				parser_return = true;
			}
			else if (current_symbol == 125)
			{
				token = JsonToken.ObjectEnd;
				parser_return = true;
			}
			else if (current_symbol == 34)
			{
				if (parser_in_string)
				{
					parser_in_string = false;
					parser_return = true;
					return;
				}
				if (token == JsonToken.None)
				{
					token = JsonToken.String;
				}
				parser_in_string = true;
			}
			else if (current_symbol == 65541)
			{
				token_value = lexer.StringValue;
			}
			else if (current_symbol == 65539)
			{
				token = JsonToken.Boolean;
				token_value = false;
				parser_return = true;
			}
			else if (current_symbol == 65540)
			{
				token = JsonToken.Null;
				parser_return = true;
			}
			else if (current_symbol == 65537)
			{
				ProcessNumber(lexer.StringValue);
				parser_return = true;
			}
			else if (current_symbol == 65546)
			{
				token = JsonToken.PropertyName;
			}
			else if (current_symbol == 65538)
			{
				token = JsonToken.Boolean;
				token_value = true;
				parser_return = true;
			}
		}

		private bool ReadToken()
		{
			if (end_of_input)
			{
				return false;
			}
			lexer.NextToken();
			if (lexer.EndOfInput)
			{
				Close();
				return false;
			}
			current_input = lexer.Token;
			return true;
		}

		public void Close()
		{
			if (!end_of_input)
			{
				end_of_input = true;
				end_of_json = true;
				if (reader_is_owned)
				{
					reader.Close();
				}
				reader = null;
			}
		}

		public bool Read()
		{
			if (end_of_input)
			{
				return false;
			}
			if (end_of_json)
			{
				end_of_json = false;
				automaton_stack.Clear();
				automaton_stack.Push(65553);
				automaton_stack.Push(65543);
			}
			parser_in_string = false;
			parser_return = false;
			token = JsonToken.None;
			token_value = null;
			if (!read_started)
			{
				read_started = true;
				if (!ReadToken())
				{
					return false;
				}
			}
			while (true)
			{
				if (parser_return)
				{
					if (automaton_stack.Peek() == 65553)
					{
						end_of_json = true;
					}
					return true;
				}
				current_symbol = automaton_stack.Pop();
				ProcessSymbol();
				if (current_symbol == current_input)
				{
					if (!ReadToken())
					{
						break;
					}
					continue;
				}
				int[] array;
				try
				{
					array = parse_table[current_symbol][current_input];
				}
				catch (KeyNotFoundException inner_exception)
				{
					throw new JsonException((ParserToken)current_input, inner_exception);
				}
				if (array[0] != 65554)
				{
					for (int num = array.Length - 1; num >= 0; num--)
					{
						automaton_stack.Push(array[num]);
					}
				}
			}
			if (automaton_stack.Peek() != 65553)
			{
				throw new JsonException("Input doesn't evaluate to proper JSON text");
			}
			if (parser_return)
			{
				return true;
			}
			return false;
		}
	}
	internal enum Condition
	{
		InArray,
		InObject,
		NotAProperty,
		Property,
		Value
	}
	internal class WriterContext
	{
		public int Count;

		public bool InArray;

		public bool InObject;

		public bool ExpectingValue;

		public int Padding;
	}
	public class JsonWriter
	{
		private static NumberFormatInfo number_format;

		private WriterContext context;

		private Stack<WriterContext> ctx_stack;

		private bool has_reached_end;

		private char[] hex_seq;

		private int indentation;

		private int indent_value;

		private StringBuilder inst_string_builder;

		private bool pretty_print;

		private bool validate;

		private TextWriter writer;

		public int IndentValue
		{
			get
			{
				return indent_value;
			}
			set
			{
				indentation = indentation / indent_value * value;
				indent_value = value;
			}
		}

		public bool PrettyPrint
		{
			get
			{
				return pretty_print;
			}
			set
			{
				pretty_print = value;
			}
		}

		public TextWriter TextWriter => writer;

		public bool Validate
		{
			get
			{
				return validate;
			}
			set
			{
				validate = value;
			}
		}

		static JsonWriter()
		{
			number_format = NumberFormatInfo.InvariantInfo;
		}

		public JsonWriter()
		{
			inst_string_builder = new StringBuilder();
			writer = new StringWriter(inst_string_builder);
			Init();
		}

		public JsonWriter(StringBuilder sb)
			: this(new StringWriter(sb))
		{
		}

		public JsonWriter(TextWriter writer)
		{
			if (writer == null)
			{
				throw new ArgumentNullException("writer");
			}
			this.writer = writer;
			Init();
		}

		private void DoValidation(Condition cond)
		{
			if (!context.ExpectingValue)
			{
				context.Count++;
			}
			if (!validate)
			{
				return;
			}
			if (has_reached_end)
			{
				throw new JsonException("A complete JSON symbol has already been written");
			}
			switch (cond)
			{
			case Condition.InArray:
				if (!context.InArray)
				{
					throw new JsonException("Can't close an array here");
				}
				break;
			case Condition.InObject:
				if (!context.InObject || context.ExpectingValue)
				{
					throw new JsonException("Can't close an object here");
				}
				break;
			case Condition.NotAProperty:
				if (context.InObject && !context.ExpectingValue)
				{
					throw new JsonException("Expected a property");
				}
				break;
			case Condition.Property:
				if (!context.InObject || context.ExpectingValue)
				{
					throw new JsonException("Can't add a property here");
				}
				break;
			case Condition.Value:
				if (!context.InArray && (!context.InObject || !context.ExpectingValue))
				{
					throw new JsonException("Can't add a value here");
				}
				break;
			}
		}

		private void Init()
		{
			has_reached_end = false;
			hex_seq = new char[4];
			indentation = 0;
			indent_value = 4;
			pretty_print = false;
			validate = true;
			ctx_stack = new Stack<WriterContext>();
			context = new WriterContext();
			ctx_stack.Push(context);
		}

		private static void IntToHex(int n, char[] hex)
		{
			for (int i = 0; i < 4; i++)
			{
				int num = n % 16;
				if (num < 10)
				{
					hex[3 - i] = (char)(48 + num);
				}
				else
				{
					hex[3 - i] = (char)(65 + (num - 10));
				}
				n >>= 4;
			}
		}

		private void Indent()
		{
			if (pretty_print)
			{
				indentation += indent_value;
			}
		}

		private void Put(string str)
		{
			if (pretty_print && !context.ExpectingValue)
			{
				for (int i = 0; i < indentation; i++)
				{
					writer.Write(' ');
				}
			}
			writer.Write(str);
		}

		private void PutNewline()
		{
			PutNewline(add_comma: true);
		}

		private void PutNewline(bool add_comma)
		{
			if (add_comma && !context.ExpectingValue && context.Count > 1)
			{
				writer.Write(',');
			}
			if (pretty_print && !context.ExpectingValue)
			{
				writer.Write('\n');
			}
		}

		private void PutString(string str)
		{
			Put(string.Empty);
			writer.Write('"');
			int length = str.Length;
			for (int i = 0; i < length; i++)
			{
				switch (str[i])
				{
				case '\n':
					writer.Write("\\n");
					continue;
				case '\r':
					writer.Write("\\r");
					continue;
				case '\t':
					writer.Write("\\t");
					continue;
				case '"':
				case '\\':
					writer.Write('\\');
					writer.Write(str[i]);
					continue;
				case '\f':
					writer.Write("\\f");
					continue;
				case '\b':
					writer.Write("\\b");
					continue;
				}
				if (str[i] >= ' ' && str[i] <= '~')
				{
					writer.Write(str[i]);
					continue;
				}
				IntToHex(str[i], hex_seq);
				writer.Write("\\u");
				writer.Write(hex_seq);
			}
			writer.Write('"');
		}

		private void Unindent()
		{
			if (pretty_print)
			{
				indentation -= indent_value;
			}
		}

		public override string ToString()
		{
			if (inst_string_builder == null)
			{
				return string.Empty;
			}
			return inst_string_builder.ToString();
		}

		public void Reset()
		{
			has_reached_end = false;
			ctx_stack.Clear();
			context = new WriterContext();
			ctx_stack.Push(context);
			if (inst_string_builder != null)
			{
				inst_string_builder.Remove(0, inst_string_builder.Length);
			}
		}

		public void Write(bool boolean)
		{
			DoValidation(Condition.Value);
			PutNewline();
			Put(boolean ? "true" : "false");
			context.ExpectingValue = false;
		}

		public void Write(decimal number)
		{
			DoValidation(Condition.Value);
			PutNewline();
			Put(Convert.ToString(number, number_format));
			context.ExpectingValue = false;
		}

		public void Write(double number)
		{
			DoValidation(Condition.Value);
			PutNewline();
			string text = Convert.ToString(number, number_format);
			Put(text);
			if (text.IndexOf('.') == -1 && text.IndexOf('E') == -1)
			{
				writer.Write(".0");
			}
			context.ExpectingValue = false;
		}

		public void Write(int number)
		{
			DoValidation(Condition.Value);
			PutNewline();
			Put(Convert.ToString(number, number_format));
			context.ExpectingValue = false;
		}

		public void Write(long number)
		{
			DoValidation(Condition.Value);
			PutNewline();
			Put(Convert.ToString(number, number_format));
			context.ExpectingValue = false;
		}

		public void Write(string str)
		{
			DoValidation(Condition.Value);
			PutNewline();
			if (str == null)
			{
				Put("null");
			}
			else
			{
				PutString(str);
			}
			context.ExpectingValue = false;
		}

		public void Write(ulong number)
		{
			DoValidation(Condition.Value);
			PutNewline();
			Put(Convert.ToString(number, number_format));
			context.ExpectingValue = false;
		}

		public void WriteArrayEnd()
		{
			DoValidation(Condition.InArray);
			PutNewline(add_comma: false);
			ctx_stack.Pop();
			if (ctx_stack.Count == 1)
			{
				has_reached_end = true;
			}
			else
			{
				context = ctx_stack.Peek();
				context.ExpectingValue = false;
			}
			Unindent();
			Put("]");
		}

		public void WriteArrayStart()
		{
			DoValidation(Condition.NotAProperty);
			PutNewline();
			Put("[");
			context = new WriterContext();
			context.InArray = true;
			ctx_stack.Push(context);
			Indent();
		}

		public void WriteObjectEnd()
		{
			DoValidation(Condition.InObject);
			PutNewline(add_comma: false);
			ctx_stack.Pop();
			if (ctx_stack.Count == 1)
			{
				has_reached_end = true;
			}
			else
			{
				context = ctx_stack.Peek();
				context.ExpectingValue = false;
			}
			Unindent();
			Put("}");
		}

		public void WriteObjectStart()
		{
			DoValidation(Condition.NotAProperty);
			PutNewline();
			Put("{");
			context = new WriterContext();
			context.InObject = true;
			ctx_stack.Push(context);
			Indent();
		}

		public void WritePropertyName(string property_name)
		{
			DoValidation(Condition.Property);
			PutNewline();
			PutString(property_name);
			if (pretty_print)
			{
				if (property_name.Length > context.Padding)
				{
					context.Padding = property_name.Length;
				}
				for (int num = context.Padding - property_name.Length; num >= 0; num--)
				{
					writer.Write(' ');
				}
				writer.Write(": ");
			}
			else
			{
				writer.Write(':');
			}
			context.ExpectingValue = true;
		}
	}
	internal class FsmContext
	{
		public bool Return;

		public int NextState;

		public Lexer L;

		public int StateStack;
	}
	internal class Lexer
	{
		private delegate bool StateHandler(FsmContext ctx);

		private static int[] fsm_return_table;

		private static StateHandler[] fsm_handler_table;

		private bool allow_comments;

		private bool allow_single_quoted_strings;

		private bool end_of_input;

		private FsmContext fsm_context;

		private int input_buffer;

		private int input_char;

		private TextReader reader;

		private int state;

		private StringBuilder string_buffer;

		private string string_value;

		private int token;

		private int unichar;

		public bool AllowComments
		{
			get
			{
				return allow_comments;
			}
			set
			{
				allow_comments = value;
			}
		}

		public bool AllowSingleQuotedStrings
		{
			get
			{
				return allow_single_quoted_strings;
			}
			set
			{
				allow_single_quoted_strings = value;
			}
		}

		public bool EndOfInput => end_of_input;

		public int Token => token;

		public string StringValue => string_value;

		static Lexer()
		{
			PopulateFsmTables();
		}

		public Lexer(TextReader reader)
		{
			allow_comments = true;
			allow_single_quoted_strings = true;
			input_buffer = 0;
			string_buffer = new StringBuilder(128);
			state = 1;
			end_of_input = false;
			this.reader = reader;
			fsm_context = new FsmContext();
			fsm_context.L = this;
		}

		private static int HexValue(int digit)
		{
			switch (digit)
			{
			case 65:
			case 97:
				return 10;
			case 66:
			case 98:
				return 11;
			case 67:
			case 99:
				return 12;
			case 68:
			case 100:
				return 13;
			case 69:
			case 101:
				return 14;
			case 70:
			case 102:
				return 15;
			default:
				return digit - 48;
			}
		}

		private static void PopulateFsmTables()
		{
			fsm_handler_table = new StateHandler[28]
			{
				State1, State2, State3, State4, State5, State6, State7, State8, State9, State10,
				State11, State12, State13, State14, State15, State16, State17, State18, State19, State20,
				State21, State22, State23, State24, State25, State26, State27, State28
			};
			fsm_return_table = new int[28]
			{
				65542, 0, 65537, 65537, 0, 65537, 0, 65537, 0, 0,
				65538, 0, 0, 0, 65539, 0, 0, 65540, 65541, 65542,
				0, 0, 65541, 65542, 0, 0, 0, 0
			};
		}

		private static char ProcessEscChar(int esc_char)
		{
			switch (esc_char)
			{
			case 34:
			case 39:
			case 47:
			case 92:
				return Convert.ToChar(esc_char);
			case 110:
				return '\n';
			case 116:
				return '\t';
			case 114:
				return '\r';
			case 98:
				return '\b';
			case 102:
				return '\f';
			default:
				return '?';
			}
		}

		private static bool State1(FsmContext ctx)
		{
			while (ctx.L.GetChar())
			{
				if (ctx.L.input_char == 32 || (ctx.L.input_char >= 9 && ctx.L.input_char <= 13))
				{
					continue;
				}
				if (ctx.L.input_char >= 49 && ctx.L.input_char <= 57)
				{
					ctx.L.string_buffer.Append((char)ctx.L.input_char);
					ctx.NextState = 3;
					return true;
				}
				switch (ctx.L.input_char)
				{
				case 34:
					ctx.NextState = 19;
					ctx.Return = true;
					return true;
				case 44:
				case 58:
				case 91:
				case 93:
				case 123:
				case 125:
					ctx.NextState = 1;
					ctx.Return = true;
					return true;
				case 45:
					ctx.L.string_buffer.Append((char)ctx.L.input_char);
					ctx.NextState = 2;
					return true;
				case 48:
					ctx.L.string_buffer.Append((char)ctx.L.input_char);
					ctx.NextState = 4;
					return true;
				case 102:
					ctx.NextState = 12;
					return true;
				case 110:
					ctx.NextState = 16;
					return true;
				case 116:
					ctx.NextState = 9;
					return true;
				case 39:
					if (!ctx.L.allow_single_quoted_strings)
					{
						return false;
					}
					ctx.L.input_char = 34;
					ctx.NextState = 23;
					ctx.Return = true;
					return true;
				case 47:
					if (!ctx.L.allow_comments)
					{
						return false;
					}
					ctx.NextState = 25;
					return true;
				default:
					return false;
				}
			}
			return true;
		}

		private static bool State2(FsmContext ctx)
		{
			ctx.L.GetChar();
			if (ctx.L.input_char >= 49 && ctx.L.input_char <= 57)
			{
				ctx.L.string_buffer.Append((char)ctx.L.input_char);
				ctx.NextState = 3;
				return true;
			}
			int num = ctx.L.input_char;
			if (num == 48)
			{
				ctx.L.string_buffer.Append((char)ctx.L.input_char);
				ctx.NextState = 4;
				return true;
			}
			return false;
		}

		private static bool State3(FsmContext ctx)
		{
			while (ctx.L.GetChar())
			{
				if (ctx.L.input_char >= 48 && ctx.L.input_char <= 57)
				{
					ctx.L.string_buffer.Append((char)ctx.L.input_char);
					continue;
				}
				if (ctx.L.input_char == 32 || (ctx.L.input_char >= 9 && ctx.L.input_char <= 13))
				{
					ctx.Return = true;
					ctx.NextState = 1;
					return true;
				}
				switch (ctx.L.input_char)
				{
				case 44:
				case 93:
				case 125:
					ctx.L.UngetChar();
					ctx.Return = true;
					ctx.NextState = 1;
					return true;
				case 46:
					ctx.L.string_buffer.Append((char)ctx.L.input_char);
					ctx.NextState = 5;
					return true;
				case 69:
				case 101:
					ctx.L.string_buffer.Append((char)ctx.L.input_char);
					ctx.NextState = 7;
					return true;
				default:
					return false;
				}
			}
			return true;
		}

		private static bool State4(FsmContext ctx)
		{
			ctx.L.GetChar();
			if (ctx.L.input_char == 32 || (ctx.L.input_char >= 9 && ctx.L.input_char <= 13))
			{
				ctx.Return = true;
				ctx.NextState = 1;
				return true;
			}
			switch (ctx.L.input_char)
			{
			case 44:
			case 93:
			case 125:
				ctx.L.UngetChar();
				ctx.Return = true;
				ctx.NextState = 1;
				return true;
			case 46:
				ctx.L.string_buffer.Append((char)ctx.L.input_char);
				ctx.NextState = 5;
				return true;
			case 69:
			case 101:
				ctx.L.string_buffer.Append((char)ctx.L.input_char);
				ctx.NextState = 7;
				return true;
			default:
				return false;
			}
		}

		private static bool State5(FsmContext ctx)
		{
			ctx.L.GetChar();
			if (ctx.L.input_char >= 48 && ctx.L.input_char <= 57)
			{
				ctx.L.string_buffer.Append((char)ctx.L.input_char);
				ctx.NextState = 6;
				return true;
			}
			return false;
		}

		private static bool State6(FsmContext ctx)
		{
			while (ctx.L.GetChar())
			{
				if (ctx.L.input_char >= 48 && ctx.L.input_char <= 57)
				{
					ctx.L.string_buffer.Append((char)ctx.L.input_char);
					continue;
				}
				if (ctx.L.input_char == 32 || (ctx.L.input_char >= 9 && ctx.L.input_char <= 13))
				{
					ctx.Return = true;
					ctx.NextState = 1;
					return true;
				}
				switch (ctx.L.input_char)
				{
				case 44:
				case 93:
				case 125:
					ctx.L.UngetChar();
					ctx.Return = true;
					ctx.NextState = 1;
					return true;
				case 69:
				case 101:
					ctx.L.string_buffer.Append((char)ctx.L.input_char);
					ctx.NextState = 7;
					return true;
				default:
					return false;
				}
			}
			return true;
		}

		private static bool State7(FsmContext ctx)
		{
			ctx.L.GetChar();
			if (ctx.L.input_char >= 48 && ctx.L.input_char <= 57)
			{
				ctx.L.string_buffer.Append((char)ctx.L.input_char);
				ctx.NextState = 8;
				return true;
			}
			int num = ctx.L.input_char;
			if (num == 43 || num == 45)
			{
				ctx.L.string_buffer.Append((char)ctx.L.input_char);
				ctx.NextState = 8;
				return true;
			}
			return false;
		}

		private static bool State8(FsmContext ctx)
		{
			while (ctx.L.GetChar())
			{
				if (ctx.L.input_char >= 48 && ctx.L.input_char <= 57)
				{
					ctx.L.string_buffer.Append((char)ctx.L.input_char);
					continue;
				}
				if (ctx.L.input_char == 32 || (ctx.L.input_char >= 9 && ctx.L.input_char <= 13))
				{
					ctx.Return = true;
					ctx.NextState = 1;
					return true;
				}
				int num = ctx.L.input_char;
				if (num == 44 || num == 93 || num == 125)
				{
					ctx.L.UngetChar();
					ctx.Return = true;
					ctx.NextState = 1;
					return true;
				}
				return false;
			}
			return true;
		}

		private static bool State9(FsmContext ctx)
		{
			ctx.L.GetChar();
			int num = ctx.L.input_char;
			if (num == 114)
			{
				ctx.NextState = 10;
				return true;
			}
			return false;
		}

		private static bool State10(FsmContext ctx)
		{
			ctx.L.GetChar();
			int num = ctx.L.input_char;
			if (num == 117)
			{
				ctx.NextState = 11;
				return true;
			}
			return false;
		}

		private static bool State11(FsmContext ctx)
		{
			ctx.L.GetChar();
			int num = ctx.L.input_char;
			if (num == 101)
			{
				ctx.Return = true;
				ctx.NextState = 1;
				return true;
			}
			return false;
		}

		private static bool State12(FsmContext ctx)
		{
			ctx.L.GetChar();
			int num = ctx.L.input_char;
			if (num == 97)
			{
				ctx.NextState = 13;
				return true;
			}
			return false;
		}

		private static bool State13(FsmContext ctx)
		{
			ctx.L.GetChar();
			int num = ctx.L.input_char;
			if (num == 108)
			{
				ctx.NextState = 14;
				return true;
			}
			return false;
		}

		private static bool State14(FsmContext ctx)
		{
			ctx.L.GetChar();
			int num = ctx.L.input_char;
			if (num == 115)
			{
				ctx.NextState = 15;
				return true;
			}
			return false;
		}

		private static bool State15(FsmContext ctx)
		{
			ctx.L.GetChar();
			int num = ctx.L.input_char;
			if (num == 101)
			{
				ctx.Return = true;
				ctx.NextState = 1;
				return true;
			}
			return false;
		}

		private static bool State16(FsmContext ctx)
		{
			ctx.L.GetChar();
			int num = ctx.L.input_char;
			if (num == 117)
			{
				ctx.NextState = 17;
				return true;
			}
			return false;
		}

		private static bool State17(FsmContext ctx)
		{
			ctx.L.GetChar();
			int num = ctx.L.input_char;
			if (num == 108)
			{
				ctx.NextState = 18;
				return true;
			}
			return false;
		}

		private static bool State18(FsmContext ctx)
		{
			ctx.L.GetChar();
			int num = ctx.L.input_char;
			if (num == 108)
			{
				ctx.Return = true;
				ctx.NextState = 1;
				return true;
			}
			return false;
		}

		private static bool State19(FsmContext ctx)
		{
			while (ctx.L.GetChar())
			{
				switch (ctx.L.input_char)
				{
				case 34:
					ctx.L.UngetChar();
					ctx.Return = true;
					ctx.NextState = 20;
					return true;
				case 92:
					ctx.StateStack = 19;
					ctx.NextState = 21;
					return true;
				}
				ctx.L.string_buffer.Append((char)ctx.L.input_char);
			}
			return true;
		}

		private static bool State20(FsmContext ctx)
		{
			ctx.L.GetChar();
			int num = ctx.L.input_char;
			if (num == 34)
			{
				ctx.Return = true;
				ctx.NextState = 1;
				return true;
			}
			return false;
		}

		private static bool State21(FsmContext ctx)
		{
			ctx.L.GetChar();
			switch (ctx.L.input_char)
			{
			case 117:
				ctx.NextState = 22;
				return true;
			case 34:
			case 39:
			case 47:
			case 92:
			case 98:
			case 102:
			case 110:
			case 114:
			case 116:
				ctx.L.string_buffer.Append(ProcessEscChar(ctx.L.input_char));
				ctx.NextState = ctx.StateStack;
				return true;
			default:
				return false;
			}
		}

		private static bool State22(FsmContext ctx)
		{
			int num = 0;
			int num2 = 4096;
			ctx.L.unichar = 0;
			while (ctx.L.GetChar())
			{
				if ((ctx.L.input_char >= 48 && ctx.L.input_char <= 57) || (ctx.L.input_char >= 65 && ctx.L.input_char <= 70) || (ctx.L.input_char >= 97 && ctx.L.input_char <= 102))
				{
					ctx.L.unichar += HexValue(ctx.L.input_char) * num2;
					num++;
					num2 /= 16;
					if (num == 4)
					{
						ctx.L.string_buffer.Append(Convert.ToChar(ctx.L.unichar));
						ctx.NextState = ctx.StateStack;
						return true;
					}
					continue;
				}
				return false;
			}
			return true;
		}

		private static bool State23(FsmContext ctx)
		{
			while (ctx.L.GetChar())
			{
				switch (ctx.L.input_char)
				{
				case 39:
					ctx.L.UngetChar();
					ctx.Return = true;
					ctx.NextState = 24;
					return true;
				case 92:
					ctx.StateStack = 23;
					ctx.NextState = 21;
					return true;
				}
				ctx.L.string_buffer.Append((char)ctx.L.input_char);
			}
			return true;
		}

		private static bool State24(FsmContext ctx)
		{
			ctx.L.GetChar();
			int num = ctx.L.input_char;
			if (num == 39)
			{
				ctx.L.input_char = 34;
				ctx.Return = true;
				ctx.NextState = 1;
				return true;
			}
			return false;
		}

		private static bool State25(FsmContext ctx)
		{
			ctx.L.GetChar();
			switch (ctx.L.input_char)
			{
			case 42:
				ctx.NextState = 27;
				return true;
			case 47:
				ctx.NextState = 26;
				return true;
			default:
				return false;
			}
		}

		private static bool State26(FsmContext ctx)
		{
			while (ctx.L.GetChar())
			{
				if (ctx.L.input_char == 10)
				{
					ctx.NextState = 1;
					return true;
				}
			}
			return true;
		}

		private static bool State27(FsmContext ctx)
		{
			while (ctx.L.GetChar())
			{
				if (ctx.L.input_char == 42)
				{
					ctx.NextState = 28;
					return true;
				}
			}
			return true;
		}

		private static bool State28(FsmContext ctx)
		{
			while (ctx.L.GetChar())
			{
				if (ctx.L.input_char != 42)
				{
					if (ctx.L.input_char == 47)
					{
						ctx.NextState = 1;
						return true;
					}
					ctx.NextState = 27;
					return true;
				}
			}
			return true;
		}

		private bool GetChar()
		{
			if ((input_char = NextChar()) != -1)
			{
				return true;
			}
			end_of_input = true;
			return false;
		}

		private int NextChar()
		{
			if (input_buffer != 0)
			{
				int result = input_buffer;
				input_buffer = 0;
				return result;
			}
			return reader.Read();
		}

		public bool NextToken()
		{
			fsm_context.Return = false;
			while (true)
			{
				if (!fsm_handler_table[state - 1](fsm_context))
				{
					throw new JsonException(input_char);
				}
				if (end_of_input)
				{
					return false;
				}
				if (fsm_context.Return)
				{
					break;
				}
				state = fsm_context.NextState;
			}
			string_value = string_buffer.ToString();
			string_buffer.Remove(0, string_buffer.Length);
			token = fsm_return_table[state - 1];
			if (token == 65542)
			{
				token = input_char;
			}
			state = fsm_context.NextState;
			return true;
		}

		private void UngetChar()
		{
			input_buffer = input_char;
		}
	}
	internal enum ParserToken
	{
		None = 65536,
		Number,
		True,
		False,
		Null,
		CharSeq,
		Char,
		Text,
		Object,
		ObjectPrime,
		Pair,
		PairRest,
		Array,
		ArrayPrime,
		Value,
		ValueRest,
		String,
		End,
		Epsilon
	}
}
namespace DeerCat
{
	public class AdvertManager : MonoBehaviour
	{
		public delegate void RewardedAdCompleted(bool success);

		public static bool AdvertsEnabled => false;

		public static void ShowAd()
		{
			UnityEngine.Debug.LogError("Attempt to play advert but UnityAds is not enabled. See docs for how to enable ads");
		}

		public static void ShowRewardedAd(RewardedAdCompleted callback)
		{
			UnityEngine.Debug.LogError("Attempt to play advert but UnityAds is not enabled. See docs for how to enable ads");
		}
	}
	public class ChildRotator : MonoBehaviour
	{
		[Tooltip("Rotation Speed in degrees per second")]
		public float speed = 100f;

		[Tooltip("Axis to rotate about")]
		public Vector3 axis = Vector3.forward;

		public Transform targetT;

		public float RndMin = 1f;

		public float RndMax = 1.5f;

		private float multiPlier = 1f;

		private void Start()
		{
			multiPlier = UnityEngine.Random.Range(RndMin, RndMax);
		}

		private void Update()
		{
			targetT.Rotate(multiPlier * axis * speed * Time.deltaTime);
		}
	}
	[RequireComponent(typeof(ParticleSystem))]
	[ExecuteInEditMode]
	public class ParticleTurbulence : MonoBehaviour
	{
		[Tooltip("Frequency of the turbulence field")]
		public float frequency = 0.5f;

		[Tooltip("Amount particles are affected by turbulence")]
		public float amplitude = 10f;

		[Tooltip("Speed at which the turbulence field changes over time")]
		public float evolutionSpeed = 1f;

		private ParticleSystem system;

		private ParticleSystem.Particle[] particles;

		private void Start()
		{
			system = GetComponent<ParticleSystem>();
			particles = new ParticleSystem.Particle[system.maxParticles];
		}

		private void Update()
		{
			if (system == null)
			{
				system = GetComponent<ParticleSystem>();
			}
			if (particles == null || system.maxParticles != particles.Length)
			{
				particles = new ParticleSystem.Particle[system.maxParticles];
			}
			if (system.isPlaying)
			{
				int num = system.GetParticles(particles);
				UpdateParticles(particles, num);
				system.SetParticles(particles, num);
			}
		}

		protected virtual void UpdateParticles(ParticleSystem.Particle[] particles, int particleCount)
		{
			float deltaTime = Time.deltaTime;
			float time = Time.time;
			Vector3 vector = evolutionSpeed * time * Vector3.one;
			float num = amplitude * deltaTime;
			for (int i = 0; i < particleCount; i++)
			{
				ParticleSystem.Particle particle = particles[i];
				Vector3 position = particle.position;
				Vector3 vector2 = (position + vector) * frequency;
				position.x += num * (Mathf.PerlinNoise(vector2.y, vector2.z) - 0.5f);
				position.y += num * (Mathf.PerlinNoise(vector2.z, vector2.x) - 0.5f);
				position.z += num * (Mathf.PerlinNoise(vector2.x, vector2.y) - 0.5f);
				particles[i].position = position;
			}
		}
	}
	public class Rotator : MonoBehaviour
	{
		[Tooltip("Rotation Speed in degrees per second")]
		public float speed = 100f;

		[Tooltip("Axis to rotate about")]
		public Vector3 axis = Vector3.forward;

		private void Update()
		{
			base.transform.Rotate(axis * speed * Time.deltaTime);
		}
	}
	public class SoundManager : MonoBehaviour
	{
		public AudioClip[] sounds;

		public AudioClip[] BGMmusic;

		public AudioClip[] PlayMusic;

		public AudioClip TutorialClip;

		public static SoundManager soundMan;

		private AudioSource sfxAudio;

		private AudioSource TutorialASS;

		private AudioSource musicPoolAudio;

		private AudioSource musicAudio;

		public bool CheckFinish;

		private int lastIndex;

		private float MusicStopTimer;

		private static bool NeedCheck;

		private static Coroutine PauseCor;

		private static Tweener UnPauseTween;

		private void Awake()
		{
			if (soundMan != null)
			{
				UnityEngine.Debug.LogError("More than one SoundManager found in the scene");
				return;
			}
			soundMan = this;
			TutorialASS = base.gameObject.AddComponent<AudioSource>();
			sfxAudio = base.gameObject.AddComponent<AudioSource>();
			musicAudio = base.gameObject.AddComponent<AudioSource>();
			musicPoolAudio = base.gameObject.AddComponent<AudioSource>();
			sfxAudio.playOnAwake = false;
			musicPoolAudio.playOnAwake = false;
			musicPoolAudio.loop = true;
			musicAudio.playOnAwake = false;
			musicAudio.loop = false;
			TutorialASS.playOnAwake = false;
			TutorialASS.loop = true;
			sfxAudio.volume = 1f * ((float)csPlayerData.SoundFXVolume / 10f);
			musicPoolAudio.volume = 1f * ((float)csPlayerData.MusicVolume / 10f);
			musicAudio.volume = 1f * ((float)csPlayerData.MusicVolume / 10f);
			TutorialASS.volume = 1f * ((float)csPlayerData.MusicVolume / 10f);
			csPlayerData.VolumeChangeAct = (UnityAction)Delegate.Combine(csPlayerData.VolumeChangeAct, new UnityAction(OnAudioVolChange));
		}

		private void OnDestroy()
		{
			csPlayerData.VolumeChangeAct = (UnityAction)Delegate.Remove(csPlayerData.VolumeChangeAct, new UnityAction(OnAudioVolChange));
		}

		public void OnAudioVolChange()
		{
			sfxAudio.volume = 1f * ((float)csPlayerData.SoundFXVolume / 10f);
			musicPoolAudio.volume = 1f * ((float)csPlayerData.MusicVolume / 10f);
			musicAudio.volume = 1f * ((float)csPlayerData.MusicVolume / 10f);
			TutorialASS.volume = 1f * ((float)csPlayerData.MusicVolume / 10f);
		}

		public static void PlaySfx(string sfxName)
		{
			if (soundMan == null)
			{
				UnityEngine.Debug.LogWarning("Attempt to play a sound with no SoundManager in the scene");
				return;
			}
			soundMan.sfxAudio.pitch = 1f;
			soundMan.PlaySound(sfxName, soundMan.sounds, soundMan.sfxAudio);
		}

		public static void PlaySfxAtPos(string sfxName, Vector3 pos)
		{
			if (soundMan == null)
			{
				UnityEngine.Debug.LogWarning("Attempt to play a sound with no SoundManager in the scene");
				return;
			}
			soundMan.sfxAudio.pitch = 1f;
			AudioClip[] array = soundMan.sounds;
			foreach (AudioClip audioClip in array)
			{
				if (audioClip.name == sfxName)
				{
					AudioSource.PlayClipAtPoint(audioClip, pos, 1f * ((float)csPlayerData.SoundFXVolume / 10f));
					break;
				}
			}
		}

		public static void PlaySfx(string sfxName, int pitchStrength)
		{
			if (soundMan == null)
			{
				UnityEngine.Debug.LogWarning("Attempt to play a sound with no SoundManager in the scene");
				return;
			}
			soundMan.sfxAudio.pitch = 1f + (float)pitchStrength * 0.1f;
			soundMan.PlaySound(sfxName, soundMan.sounds, soundMan.sfxAudio);
		}

		public static void PlaySfx(AudioClip clip)
		{
			soundMan.sfxAudio.pitch = 1f;
			soundMan.PlaySound(clip, soundMan.sfxAudio);
		}

		public static void PlayMusicPool(string trackName)
		{
			if (soundMan == null)
			{
				UnityEngine.Debug.LogWarning("Attempt to play a sound with no SoundManager in the scene");
				return;
			}
			soundMan.musicPoolAudio.time = 0f;
			soundMan.musicPoolAudio.volume = 1f * ((float)csPlayerData.MusicVolume / 10f);
			soundMan.PlaySoundBKG(trackName, soundMan.PlayMusic, soundMan.musicPoolAudio);
		}

		public static void PlayerTutorial(bool isPlay)
		{
			if (soundMan == null)
			{
				UnityEngine.Debug.LogWarning("Attempt to play a sound with no SoundManager in the scene");
				return;
			}
			soundMan.TutorialASS.clip = soundMan.TutorialClip;
			soundMan.TutorialASS.volume = 1f * ((float)csPlayerData.MusicVolume / 10f);
			if (isPlay)
			{
				soundMan.musicPoolAudio.Stop();
				if (Beats.instance != null && Beats.instance.music == null)
				{
					Beats.instance.music = soundMan.TutorialASS;
				}
				soundMan.TutorialASS.Play();
			}
			else
			{
				soundMan.TutorialASS.DOFade(0f * ((float)csPlayerData.MusicVolume / 10f), 1f).OnComplete(delegate
				{
					soundMan.TutorialASS.Stop();
				});
			}
		}

		public static void PlayMusicIndex(int index, bool isFirst)
		{
			if (soundMan == null)
			{
				UnityEngine.Debug.LogWarning("Attempt to play a sound with no SoundManager in the scene");
				return;
			}
			soundMan.musicPoolAudio.Stop();
			if (Beats.instance != null && Beats.instance.music == null)
			{
				Beats.instance.music = soundMan.musicAudio;
			}
			soundMan.PlaySound(index, soundMan.BGMmusic, soundMan.musicAudio, isFirst);
		}

		public static void PlayLevelMusic(AudioClip ac)
		{
			if (soundMan == null)
			{
				UnityEngine.Debug.LogWarning("Attempt to play a sound with no SoundManager in the scene");
				return;
			}
			soundMan.musicPoolAudio.Stop();
			if (Beats.instance != null && Beats.instance.music == null)
			{
				Beats.instance.music = soundMan.musicAudio;
			}
			soundMan.PlayLevelSound(ac, soundMan.musicAudio, isFirst: true);
		}

		private void PlayLevelSound(AudioClip ac, AudioSource audioOut, bool isFirst)
		{
			if (isFirst)
			{
				audioOut.clip = ac;
				audioOut.Play();
				audioOut.volume = 0f;
				audioOut.DOFade(1f * ((float)csPlayerData.MusicVolume / 10f), 1f);
				CheckFinish = true;
			}
		}

		private void Update()
		{
			if (!CheckFinish || musicAudio.clip == null)
			{
				return;
			}
			if (musicAudio.time == 0f)
			{
				MusicStopTimer += Time.deltaTime;
			}
			else
			{
				MusicStopTimer = 0f;
			}
			if (MusicStopTimer > 3f || musicAudio.time >= musicAudio.clip.length)
			{
				MusicStopTimer = 0f;
				int num;
				for (num = UnityEngine.Random.Range(0, BGMmusic.Length); num == lastIndex; num = UnityEngine.Random.Range(0, BGMmusic.Length))
				{
				}
				lastIndex = num;
				PlayMusicIndex(num, isFirst: false);
			}
		}

		public static void PauseMusic(float fadeTime, bool GameOverPause)
		{
			if (fadeTime > 0f)
			{
				PauseCor = soundMan.StartCoroutine(soundMan.FadeMusicOut(fadeTime));
			}
			else
			{
				soundMan.musicAudio.Pause();
			}
			if (UnPauseTween != null && !UnPauseTween.IsComplete())
			{
				UnPauseTween.Kill();
			}
			NeedCheck = soundMan.CheckFinish && !GameOverPause;
		}

		public static void UnpauseMusic()
		{
			if (UnPauseTween != null && !UnPauseTween.IsComplete())
			{
				UnPauseTween.Kill();
			}
			UnPauseTween = soundMan.musicAudio.DOFade(1f * ((float)csPlayerData.MusicVolume / 10f), 3f);
			soundMan.musicAudio.Play();
			if (PauseCor != null)
			{
				soundMan.StopCoroutine(PauseCor);
			}
		}

		public static void RewindMusic()
		{
			soundMan.musicAudio.time = 0f;
		}

		private void PlaySound(string soundName, AudioClip[] pool, AudioSource audioOut)
		{
			foreach (AudioClip audioClip in pool)
			{
				if (audioClip.name == soundName)
				{
					PlaySound(audioClip, audioOut);
					return;
				}
			}
			UnityEngine.Debug.LogWarning("No sound clip found with name " + soundName);
		}

		private void PlaySoundBKG(string soundName, AudioClip[] pool, AudioSource audioOut)
		{
			foreach (AudioClip audioClip in pool)
			{
				if (audioClip.name == soundName)
				{
					PlaySoundBKG(audioClip, audioOut);
					return;
				}
			}
			UnityEngine.Debug.LogWarning("No sound clip found with name " + soundName);
		}

		private void PlaySound(int i, AudioClip[] pool, AudioSource audioOut, bool isFirst)
		{
			if (isFirst)
			{
				audioOut.clip = pool[i];
				audioOut.Play();
				audioOut.volume = 0f;
				audioOut.DOFade(1f * ((float)csPlayerData.MusicVolume / 10f), 1f);
				CheckFinish = true;
			}
			else
			{
				audioOut.clip = pool[i];
				audioOut.time = 0f;
				audioOut.volume = 1f * ((float)csPlayerData.MusicVolume / 10f);
				audioOut.Play();
				CheckFinish = true;
			}
		}

		private void PlaySoundBKG(AudioClip clip, AudioSource audioOut)
		{
			audioOut.clip = clip;
			audioOut.volume = 1f * ((float)csPlayerData.MusicVolume / 10f);
			audioOut.Play();
		}

		private void PlaySound(AudioClip clip, AudioSource audioOut)
		{
			audioOut.clip = clip;
			audioOut.volume = 1f * ((float)csPlayerData.SoundFXVolume / 10f);
			audioOut.Play();
		}

		private IEnumerator FadeMusicOut(float time)
		{
			float startVol = musicAudio.volume;
			float startTime = Time.realtimeSinceStartup;
			while (true)
			{
				float num = (Time.realtimeSinceStartup - startTime) / time;
				if (!(num < 1f))
				{
					break;
				}
				musicAudio.volume = (1f - num) * startVol;
				yield return 0;
			}
			PauseCor = null;
			PauseCor = null;
			musicAudio.Pause();
		}
	}
}
namespace DeerCat.SimpleTween
{
	public delegate void Callback();
	public delegate T Getter<T>();
	public delegate void Setter<T>(T val);
	public enum Easing
	{
		EaseLinear,
		EaseIn,
		EaseOut,
		EaseInOut,
		EaseInBack,
		EaseOutBack,
		EaseKick
	}
	public abstract class Tween
	{
		private float duration = 1f;

		private float delay;

		private float t;

		private Easing ease = Easing.EaseOut;

		private Callback callback;

		private bool useRealTime;

		public bool IsComplete => t >= 1f;

		public Callback Callback => callback;

		public Tween()
		{
		}

		public Tween(float dur)
		{
			duration = Mathf.Max(0.01f, dur);
		}

		protected abstract void SetValue(float blend);

		public void Update(float dT)
		{
			if (useRealTime)
			{
				dT = Time.unscaledDeltaTime;
			}
			if (delay > 0f)
			{
				delay -= dT;
				return;
			}
			t = Mathf.Clamp01(t + dT / duration);
			float value = CalcEase(t);
			SetValue(value);
		}

		public Tween OnCompleted(Callback cb)
		{
			callback = cb;
			return this;
		}

		public Tween Delay(float d)
		{
			delay = d;
			return this;
		}

		public Tween Ease(Easing e)
		{
			ease = e;
			return this;
		}

		public Tween UseRealTime(bool b)
		{
			useRealTime = b;
			return this;
		}

		private float CalcEase(float t)
		{
			switch (ease)
			{
			case Easing.EaseLinear:
				return t;
			case Easing.EaseIn:
				return t * t * t;
			case Easing.EaseOut:
				t = 1f - t;
				return 1f - t * t * t;
			case Easing.EaseInOut:
				return 3f * t * t - 2f * t * t * t;
			case Easing.EaseInBack:
				return t * t * (2.7f * t - 1.7f);
			case Easing.EaseOutBack:
				t -= 1f;
				return t * t * (2.7f * t + 1.7f) + 1f;
			case Easing.EaseKick:
				if (t < 0.3f)
				{
					t = 1f - t / 0.3f;
					return 1f - t * t * t;
				}
				t = (t - 0.3f) / 0.7f;
				return 1f - (3f * t * t - 2f * t * t * t);
			default:
				return t;
			}
		}
	}
	public class TweenFloat : Tween
	{
		protected Setter<float> setter;

		protected float startVal;

		protected float endVal;

		public TweenFloat()
		{
		}

		public TweenFloat(Setter<float> set, float start, float end, float duration)
			: base(duration)
		{
			setter = set;
			startVal = start;
			endVal = end;
			setter(start);
		}

		protected override void SetValue(float blend)
		{
			setter(startVal * (1f - blend) + endVal * blend);
		}
	}
	public class TweenInt : Tween
	{
		protected Setter<int> setter;

		protected float startVal;

		protected float endVal;

		public TweenInt()
		{
		}

		public TweenInt(Setter<int> set, int start, int end, float duration)
			: base(duration)
		{
			setter = set;
			startVal = start;
			endVal = end;
			setter(start);
		}

		protected override void SetValue(float blend)
		{
			setter((int)(startVal * (1f - blend) + endVal * blend));
		}
	}
	public class TweenVector2 : Tween
	{
		protected Setter<Vector2> setter;

		protected Vector2 startVal;

		protected Vector2 endVal;

		public TweenVector2()
		{
		}

		public TweenVector2(Setter<Vector2> set, Vector2 start, Vector2 end, float duration)
			: base(duration)
		{
			setter = set;
			startVal = start;
			endVal = end;
			setter(start);
		}

		protected override void SetValue(float blend)
		{
			setter(startVal * (1f - blend) + endVal * blend);
		}
	}
	public class TweenVector3 : Tween
	{
		protected Setter<Vector3> setter;

		protected Vector3 startVal;

		protected Vector3 endVal;

		public TweenVector3()
		{
		}

		public TweenVector3(Setter<Vector3> set, Vector3 start, Vector3 end, float duration)
			: base(duration)
		{
			setter = set;
			startVal = start;
			endVal = end;
			setter(start);
		}

		protected override void SetValue(float blend)
		{
			setter(startVal * (1f - blend) + endVal * blend);
		}
	}
	public class TweenColor : Tween
	{
		protected Setter<Color> setter;

		protected Color startVal;

		protected Color endVal;

		public TweenColor()
		{
		}

		public TweenColor(Setter<Color> set, Color start, Color end, float duration)
			: base(duration)
		{
			setter = set;
			startVal = start;
			endVal = end;
			setter(start);
		}

		protected override void SetValue(float blend)
		{
			setter(startVal * (1f - blend) + endVal * blend);
		}
	}
	public class SimpleTweener : MonoBehaviour
	{
		public int activeTweens;

		private List<Tween> tweens = new List<Tween>();

		private static SimpleTweener instance;

		private void Update()
		{
			float deltaTime = Time.deltaTime;
			int num = 0;
			while (num < tweens.Count)
			{
				Tween tween = tweens[num];
				tween.Update(deltaTime);
				if (tween.IsComplete)
				{
					if (tween.Callback != null)
					{
						tween.Callback();
					}
					tweens.RemoveAt(num);
				}
				else
				{
					num++;
				}
			}
			activeTweens = tweens.Count;
		}

		public static Tween AddTween<T>(Getter<T> getter, Setter<T> setter, T end, float duration)
		{
			if (instance == null)
			{
				instance = new GameObject("TweenHandler").AddComponent<SimpleTweener>();
			}
			Tween tween = null;
			if (typeof(T) == typeof(float))
			{
				tween = new TweenFloat((Setter<float>)(object)setter, (float)(object)getter(), (float)(object)end, duration);
				instance.tweens.Add(tween);
			}
			else if (typeof(T) == typeof(int))
			{
				tween = new TweenInt((Setter<int>)(object)setter, (int)(object)getter(), (int)(object)end, duration);
				instance.tweens.Add(tween);
			}
			else if (typeof(T) == typeof(Vector2))
			{
				tween = new TweenVector2((Setter<Vector2>)(object)setter, (Vector2)(object)getter(), (Vector2)(object)end, duration);
				instance.tweens.Add(tween);
			}
			else if (typeof(T) == typeof(Vector3))
			{
				tween = new TweenVector3((Setter<Vector3>)(object)setter, (Vector3)(object)getter(), (Vector3)(object)end, duration);
				instance.tweens.Add(tween);
			}
			else if (typeof(T) == typeof(Color))
			{
				tween = new TweenColor((Setter<Color>)(object)setter, (Color)(object)getter(), (Color)(object)end, duration);
				instance.tweens.Add(tween);
			}
			else
			{
				UnityEngine.Debug.LogError("Tween type not supported " + typeof(T));
			}
			return tween;
		}

		public static void RemoveTween(Tween tween)
		{
			if (!(instance == null))
			{
				instance.tweens.Remove(tween);
			}
		}
	}
}
namespace DeerCat.TunnelRush
{
	public class CameraLookAhead : MonoBehaviour
	{
		[Tooltip("Distance ahead to focus on")]
		public float lookatDist = 20f;

		private bool insideTunnel = true;

		public bool InsideTunnel
		{
			get
			{
				return insideTunnel;
			}
			set
			{
				insideTunnel = value;
			}
		}

		private void Update()
		{
			Vector3 vector = base.transform.position + lookatDist * Vector3.forward;
			vector = vector + GameManager.LevelManager.CalcOffset(vector.z) - GameManager.LevelManager.CameraOffset;
			Vector3 up = GameManager.Player.root.up;
			base.transform.LookAt(vector, up);
		}
	}
	public class CameraLookAheadNPC : MonoBehaviour
	{
		[Tooltip("Distance ahead to focus on")]
		public float lookatDist = 20f;

		public Transform CenterPosT;

		private bool insideTunnel = true;

		public bool InsideTunnel
		{
			get
			{
				return insideTunnel;
			}
			set
			{
				insideTunnel = value;
			}
		}

		private void Update()
		{
			Vector3 vector = base.transform.position - CenterPosT.position + (lookatDist + base.transform.position.z) * Vector3.forward;
			vector = vector + GameManager.LevelManager.CalcOffset(vector.z) - GameManager.LevelManager.CameraOffset;
			Vector3 vector2 = (base.transform.position - CenterPosT.position).normalized;
			if (insideTunnel)
			{
				vector2 = -vector2;
			}
			base.transform.LookAt(vector, vector2);
		}
	}
	public class CameraShake : MonoBehaviour
	{
		private float shakeAmount;

		private float shakeDecay = 2f;

		private Transform thisT;

		private void Awake()
		{
			thisT = base.transform;
		}

		private void Update()
		{
			if (Time.deltaTime > 0f)
			{
				thisT.localPosition = UnityEngine.Random.insideUnitSphere * shakeAmount;
				shakeAmount = Mathf.Lerp(shakeAmount, 0f, shakeDecay * Time.deltaTime);
			}
		}

		public void Shake(float amount)
		{
			shakeAmount = amount;
		}
	}
	public enum AdvertMode
	{
		Disabled,
		Simple,
		WatchToContinue
	}
	public class GameManager : MonoBehaviour
	{
		public enum GameState
		{
			InMenus,
			Playing,
			Paused,
			Dead
		}

		[Tooltip("What type of adverts to display - see TunnelRush.pdf for details on setting up adverts")]
		public AdvertMode advertMode;

		[Tooltip("How frequently should an advert be displayed - when Advert Mode is 'Simple'")]
		public int numRunsBetweenAdverts = 2;

		public static Action LevelUpAction;

		public int Level = 1;

		public csHMDIniter PlayerHMDiniter;

		public GameObject gameCompleteTunnel;

		private int runCount;

		private GameState state;

		private PlayerControl player;

		private LevelManager levelManager;

		private MenuSystem menuSystem;

		private MenuScreen mainMenu;

		private MenuScreen pauseMenu;

		[HideInInspector]
		public CountDownScreen countdownMenu;

		private MenuScreen restartMenu;

		private MenuScreen handChooseMenu;

		private MenuScreen tutorialChooseMenu;

		private MenuScreen tutorialHintMenu;

		private MenuScreen SettingMenu;

		public csPopHint popHintM;

		public TutorialHint TutorialHintCanvas;

		private MenuScreen controllerHintMenu;

		public ControllerPosHint ControllerHintCanvas;

		private InfoPopup infoPopup;

		private CanvasGroup screenFade;

		private DeerCat.SimpleTween.Tween fadeTween;

		private float targetDistance;

		private bool brokenRecord;

		public static GameManager instance;

		public int ScoreHintIndex;

		private bool isPCMode;

		public GameObject RigObject;

		public GameObject PCCam;

		public NpcPlayer[] npcPlayers;

		public csHorseIniter PlayerHorseIniter;

		public GameObject ropeGroup;

		public int RestReviveTimes = 3;

		public int SpecialDeadTime;

		public int DeadTimes;

		public const int MaxReviveTimes = 3;

		public Transform CanvasInGameT;

		public csInGameMissionData m_InGameMissionData;

		public GameObject InsideDropCheck;

		public bool HasCompeletLevel;

		public List<AchievementType> TempAchievementList = new List<AchievementType>();

		public float GameTime;

		public int ScetionPassed;

		public static NpcPlayer[] NpcPlayers
		{
			get
			{
				if (!instance)
				{
					return null;
				}
				return instance.npcPlayers;
			}
		}

		public static PlayerControl Player
		{
			get
			{
				if (!instance)
				{
					return null;
				}
				return instance.player;
			}
		}

		public static LevelManager LevelManager
		{
			get
			{
				if (!instance)
				{
					return null;
				}
				return instance.levelManager;
			}
		}

		public static MenuSystem MenuSystem
		{
			get
			{
				if (!instance)
				{
					return null;
				}
				return instance.menuSystem;
			}
		}

		public static bool ISPCmode
		{
			get
			{
				if (!instance)
				{
					return false;
				}
				return instance.isPCMode;
			}
		}

		public static GameState CurrentState => instance.state;

		public static AdvertMode AdvertMode => instance.advertMode;

		public static float RecordDistance
		{
			get
			{
				return PlayerPrefs.GetFloat("RecordDistance", 0f);
			}
			set
			{
				PlayerPrefs.SetFloat("RecordDistance", value);
			}
		}

		private void Awake()
		{
			if (instance == null)
			{
				instance = this;
			}
			if (!csGameSettings.isFromMainScene)
			{
				csGameSettings.Init();
			}
			player = UnityEngine.Object.FindObjectOfType<PlayerControl>();
			levelManager = UnityEngine.Object.FindObjectOfType<LevelManager>();
			ropeGroup = GameObject.Find("RopeGroup");
			npcPlayers = UnityEngine.Object.FindObjectsOfType<NpcPlayer>();
		}

		private void Start()
		{
			menuSystem = UnityEngine.Object.FindObjectOfType<MenuSystem>();
			handChooseMenu = menuSystem.GetScreen("HandChoose");
			tutorialChooseMenu = menuSystem.GetScreen("TutorialChoose");
			tutorialHintMenu = menuSystem.GetScreen("TutorialHint");
			TutorialHintCanvas = tutorialHintMenu.GetComponent<TutorialHint>();
			controllerHintMenu = menuSystem.GetScreen("TutorialControllerHint");
			ControllerHintCanvas = controllerHintMenu.GetComponent<ControllerPosHint>();
			mainMenu = menuSystem.GetScreen("MainMenu");
			pauseMenu = menuSystem.GetScreen("PauseMenu");
			countdownMenu = CanvasInGameT.Find("CountDownMenu").GetComponent<CountDownScreen>();
			restartMenu = menuSystem.GetScreen("RestartMenu");
			SettingMenu = menuSystem.GetScreen("SettingMenu");
			screenFade = GameObject.Find("ScreenFade").GetComponent<CanvasGroup>();
			infoPopup = UnityEngine.Object.FindObjectOfType<InfoPopup>();
			if (!AdvertManager.AdvertsEnabled && advertMode != 0)
			{
				UnityEngine.Debug.LogError("Unity Adverts set up is not complete, no adverts will be shown\nSee TunnelRush.pdf for details on setting up adverts");
				advertMode = AdvertMode.Disabled;
			}
			if (csGameSettings.isFromMainScene)
			{
				menuSystem.ExitAll();
			}
			player.curHorse.HorseModelController = PlayerHorseIniter.InitHorse(csGameSettings.PlayerHorseType);
			player.BindHorse();
			OnEnterStateMenus();
			if (csGameSettings.Channel == ChannelType.OculusGO || csGameSettings.Channel == ChannelType.OculusQuest)
			{
				OVRManager.VrFocusLost += PauseGame;
			}
		}

		public void SetCanvasOffset(float YOffset)
		{
			CanvasInGameT.localPosition = new Vector3(0f, YOffset, 1.5f);
		}

		private void OnEnterStateMenus()
		{
			if (!csGameSettings.isFromMainScene)
			{
				menuSystem.ShowScreen(mainMenu);
			}
			levelManager.Reset();
			state = GameState.InMenus;
			player.SpeedLineObject.SetActive(value: false);
			player.PlayHorse();
			SoundManager.PlayMusicPool("IntroLoop");
		}

		private void OnEnterStateGame(bool withTutorial)
		{
			LaserPointerInputModule.instance.EnableLaserUI(isEnable: false);
			GameTime = 0f;
			RestReviveTimes = 3;
			DeadTimes = 0;
			SpecialDeadTime = 0;
			Level = 1;
			ScetionPassed = 0;
			m_InGameMissionData.ResetMission();
			HasCompeletLevel = false;
			if (!withTutorial)
			{
				LevelUpAction?.Invoke();
			}
			menuSystem.HUD.ClearHint();
			menuSystem.HUD.Show();
			csGameSettings.CurEndParticleIndexInner = 0;
			csGameSettings.CurEndParticleIndexOut = 0;
			player.Reset();
			if (withTutorial)
			{
				csGameSettings.IsSkillTeached = false;
				csTutorialManager.instance.PlayTutorial(player);
			}
			targetDistance = RecordDistance;
			brokenRecord = false;
			if (targetDistance == 0f)
			{
				brokenRecord = true;
			}
			levelManager.StartGame(withTutorial, csGameSettings.SkipEndlessLevel);
			player.CheckDropEnabled = false;
			state = GameState.Playing;
			player.SpeedLineObject.SetActive(value: true);
			player.PlayHorse();
			player.ASSHorse.Play();
			if (csGameSettings.CurrentGameMode == GameMode.LevelMode)
			{
				SoundManager.PlayLevelMusic(LevelManager.GetChanllengeLevelClip());
			}
			else if (withTutorial)
			{
				SoundManager.PlayerTutorial(isPlay: true);
			}
			else
			{
				SoundManager.PlayMusicIndex(0, isFirst: true);
			}
			Player.PlayerCamFade.SetFadeAlpha(1f);
			Player.PlayerCamFade.FadeIn(delegate
			{
				player.CheckDropEnabled = true;
			}, 0.4f);
		}

		private void ShowAdvert()
		{
			runCount++;
			if (advertMode == AdvertMode.Simple && runCount % Mathf.Max(1, numRunsBetweenAdverts) == 0)
			{
				AdvertManager.ShowAd();
			}
		}

		public void ContinueWithAdvert()
		{
			if (advertMode != AdvertMode.WatchToContinue)
			{
				return;
			}
			AdvertManager.ShowRewardedAd(delegate(bool success)
			{
				if (success)
				{
					ContinueGame();
				}
			});
		}

		public void ContinueGame()
		{
			RestReviveTimes--;
			player.Revive();
			menuSystem.HUD.ClearHint();
			player.ropeManager.ShowRope();
			menuSystem.ExitAll();
			state = GameState.Playing;
		}

		private void OnEnterStateDeath()
		{
			if (advertMode == AdvertMode.Simple)
			{
				ShowAdvert();
			}
			UnityEngine.Debug.Log("Show Restart");
			LevelManager.CoinGetTotal = (int)(player.hd.BasicData.GoldMultiplier * player.moneyBuffVal * (float)LevelManager.CoinGetThisRun);
			csPlayerData.PlayerCoin += LevelManager.CoinGetTotal;
			LaserPointerInputModule.instance.EnableLaserUI(isEnable: true);
			menuSystem.ShowScreen(restartMenu);
		}

		public void SaveData()
		{
			int num = (int)(LevelManager.TotalDistance * Player.hd.BasicData.ScoreMultiplier * Player.scoreBuffVal);
			float gameTime = GameTime;
			csPlayerData.AddAchievementSchedule_Coin(LevelManager.CoinGetThisRun, save: false);
			csPlayerData.AddAchievementSchedule_Dis(num, save: false);
			csPlayerData.AddAchievementSchedule_Skill(m_InGameMissionData.SkillUsedCount, save: false);
			csPlayerData.AddAchievementSchedule_HitWall(m_InGameMissionData.HitTimes, save: false);
			csPlayerData.AddAchievementSchedule_CrashWall(m_InGameMissionData.CrashWallTimes, save: false);
			csPlayerData.AddAchievementSchedule_DropDown(m_InGameMissionData.DropTimes, save: false);
			csPlayerData.AddAchievementSchedule_Prop(m_InGameMissionData.PropUsedCount, save: false);
			if (csGameSettings.CurrentGameMode == GameMode.EndlessMode)
			{
				csPlayerData.PlayerCoin += (int)(player.hd.BasicData.GoldMultiplier * player.moneyBuffVal * ((float)csGameSettings.GetCoinByEndlessLevel(Level - 1) - (float)csGameSettings.GetCoinByEndlessLevel(LevelManager.StartLevel - 1)));
				csPlayerData.SetAchievementSchedule_MaxEndlessLevel(Level - 1, save: false);
				csPlayerData.LastEndlessLevel = Level - 1;
				if (csPlayerData.HighestEndlessLevel < Level - 1)
				{
					csPlayerData.HighestEndlessLevel = Level - 1;
				}
				csPlayerData.LastEndlessScore = num;
				if (csPlayerData.BestEndlessScore < num)
				{
					csPlayerData.BestEndlessScore = num;
					csPlayerData.SetAchievementSchedule_MaxScore(num);
				}
				csPlayerData.LastEndlessTime = gameTime;
				if (csPlayerData.BestEndlessTime < gameTime || csPlayerData.BestEndlessTime == 0f)
				{
					csPlayerData.BestEndlessTime = gameTime;
				}
			}
			if (csGameSettings.CurrentGameMode != 0)
			{
				return;
			}
			csPlayerData.PlayerLevelDataDic[csGameSettings.CurrentSelectedLevel].LastScore = num;
			if (csPlayerData.PlayerLevelDataDic[csGameSettings.CurrentSelectedLevel].BestScore < num)
			{
				csPlayerData.PlayerLevelDataDic[csGameSettings.CurrentSelectedLevel].BestScore = num;
			}
			if (HasCompeletLevel)
			{
				if (csPlayerData.PlayerLevelDataDic[csGameSettings.CurrentSelectedLevel].BestTime == 0f)
				{
					csPlayerData.AwardUnlockList[csGameSettings.CurrentSelectedLevel - 1] = true;
					csPlayerData.SaveAwardUnlockData();
					csPlayerData.WriteBuffData(csPlayerData.BuffDataDic);
				}
				csPlayerData.PlayerLevelDataDic[csGameSettings.CurrentSelectedLevel].LastTime = gameTime;
				if (csPlayerData.PlayerLevelDataDic[csGameSettings.CurrentSelectedLevel].BestTime > gameTime || csPlayerData.PlayerLevelDataDic[csGameSettings.CurrentSelectedLevel].BestTime == 0f)
				{
					csPlayerData.PlayerLevelDataDic[csGameSettings.CurrentSelectedLevel].BestTime = gameTime;
				}
			}
			int num2 = 0;
			for (int i = 0; i < m_InGameMissionData.InGameMissionDataList.Count; i++)
			{
				if (m_InGameMissionData.InGameMissionDataList[i].isComplet)
				{
					num2++;
				}
			}
			if (csPlayerData.PlayerLevelDataDic[csGameSettings.CurrentSelectedLevel].StarsNum < num2)
			{
				csPlayerData.PlayerLevelDataDic[csGameSettings.CurrentSelectedLevel].StarsNum = num2;
			}
			if (csGameSettings.CurrentSelectedLevel < 15 && HasCompeletLevel)
			{
				int num3 = csGameSettings.CurrentSelectedLevel + 1;
				LevelInfo levelInfo = csLevelData.instance.m_LevelInfoList.m_LevelInfoList[num3 - 1];
				if (levelInfo.m_UnLockType == ExtraUnLockType.None)
				{
					csPlayerData.PlayerLevelDataDic[num3].isUnLock = true;
				}
				else if (levelInfo.m_UnLockType == ExtraUnLockType.StarNum)
				{
					if (csPlayerData.GetStarsNum() >= levelInfo.UnLockParameter)
					{
						csPlayerData.PlayerLevelDataDic[num3].isUnLock = true;
					}
				}
				else if (levelInfo.m_UnLockType == ExtraUnLockType.MaxEndlessLevel && csPlayerData.HighestEndlessLevel >= levelInfo.UnLockParameter)
				{
					csPlayerData.PlayerLevelDataDic[num3].isUnLock = true;
				}
			}
			csPlayerData.SavePlayerLevelDataDic();
			csPlayerData.SetAchievementSchedule_Stars(csPlayerData.GetStarsNum());
		}

		public void ShowTutorialScreenMenu()
		{
			menuSystem.HUD.Hide();
			menuSystem.ShowScreen(tutorialHintMenu);
		}

		public void HideTutorialScreenMenu()
		{
			menuSystem.HUD.Show();
			menuSystem.ExitAll();
		}

		public void ShowControllerHintScreenMenu()
		{
			controllerHintMenu.Show(0.5f);
		}

		public void HideControllerHintScreenMenu()
		{
			controllerHintMenu.Hide(0.5f);
		}

		public void LevelReset()
		{
			SoundManager.PlayerTutorial(isPlay: false);
			SoundManager.PlayMusicIndex(0, isFirst: true);
			Level = 1;
			levelManager.ResetAfterTutorial(csGameSettings.SkipEndlessLevel);
			LevelUpAction?.Invoke();
			Player.root.localEulerAngles = Vector3.zero;
		}

		public void OnShowMainMenu()
		{
			SoundManager.PlaySfx("ButtonPress");
			menuSystem.ExitAll();
			ScreenFaderFadeIn(0.8f, delegate
			{
				OnEnterStateMenus();
			});
		}

		public void OnStartGamePressed(bool isPC = false)
		{
			SoundManager.PlaySfx("ButtonPress");
			menuSystem.ExitAll();
			if (csGameSettings.Channel == ChannelType.OculusGO)
			{
				StartCoroutine(IEOnStart());
				return;
			}
			menuSystem.ShowScreen(handChooseMenu);
			Player.ResetHandRnds();
		}

		private IEnumerator IEOnStart()
		{
			yield return new WaitForSeconds(1f);
			Player.ResetHandRnds();
			Player.SetRopeHand(OVRInput.GetDominantHand() == OVRInput.Handedness.LeftHanded, withFade: true);
			OnHandChosen(OVRInput.GetDominantHand() == OVRInput.Handedness.LeftHanded);
		}

		public void OnHandChange(bool isL)
		{
			Player.SetRopeHand(isL, withFade: true);
			csHMDIniter.instance.CurrentSetter.SetControllerHand(isL);
		}

		public void OnHandChosen(bool isLeft)
		{
			SoundManager.PlaySfx("ButtonPress");
			TutorialHintCanvas.SetHandSprite(isLeft);
			menuSystem.ExitAll();
			csHMDIniter.instance.CurrentSetter.SetControllerHand(isLeft);
			if (csGameSettings.CurrentGameMode == GameMode.LevelMode && csGameSettings.CurrentSelectedLevel > 1)
			{
				OnTutorialChosenAndStart(withTutorial: false);
			}
			else
			{
				menuSystem.ShowScreen(tutorialChooseMenu);
			}
			csGameSettings.IsLeftMove = isLeft;
		}

		public void SetControllerHintState(int state)
		{
			ControllerHintCanvas.SetUIState(state);
		}

		public void UpdateControllerPos(float posPercent)
		{
			ControllerHintCanvas.SetHandPos(posPercent);
		}

		public void OnTutorialChosenAndStart(bool withTutorial, bool isPC = false)
		{
			SoundManager.PlaySfx("ButtonPress");
			menuSystem.ExitAll();
			Player.PlayerCamFade.SetFadeAlpha(0f);
			player.PlayerCamFade.FadeOut(delegate
			{
				OnEnterStateGame(withTutorial);
			}, 0.8f);
			if (isPC)
			{
				isPCMode = true;
				PCCam.SetActive(value: true);
				RigObject.SetActive(value: false);
				ropeGroup.SetActive(value: false);
			}
		}

		public void RestartGameBtn()
		{
			player.ropeManager.ShowRope();
			SoundManager.PlayerTutorial(isPlay: false);
			player.PlayHorse();
			Player.SetIsFocus(isF: true);
			pauseMenu.Hide(0.3f);
			SoundManager.PlaySfx("ButtonPress");
			menuSystem.ExitAll();
			Player.PlayerCamFade.SetFadeAlpha(0f);
			player.PlayerCamFade.FadeOut(delegate
			{
				Time.timeScale = 1f;
				OnEnterStateGame(withTutorial: false);
			}, 0.8f);
			if (gameCompleteTunnel.activeSelf)
			{
				gameCompleteTunnel.SetActive(value: false);
				levelManager.gameObject.SetActive(value: true);
			}
			TempAchievementList = new List<AchievementType>();
		}

		public void BackToMainBtn()
		{
			SoundManager.PlaySfx("ButtonPress");
			menuSystem.ExitAll();
			Player.PlayerCamFade.SetFadeAlpha(0f);
			player.PlayerCamFade.FadeOut(delegate
			{
				csGameSettings.IsLoadToGame = false;
				SceneManager.LoadScene("LoadingScene");
				Time.timeScale = 1f;
			}, 0.8f);
		}

		public void GameOver(float duration = 1.5f)
		{
			if (csGameSettings.CurrentGameMode == GameMode.LevelMode)
			{
				m_InGameMissionData.JudgeDataOnGameEnd();
			}
			if (levelManager.TotalDistance * Player.hd.BasicData.ScoreMultiplier * Player.scoreBuffVal > RecordDistance)
			{
				RecordDistance = levelManager.TotalDistance * Player.hd.BasicData.ScoreMultiplier * Player.scoreBuffVal;
			}
			state = GameState.Dead;
			player.ASSSelfLoop.Stop();
			player.SpeedLineObject.SetActive(value: false);
			player.ropeManager.HideRope();
			player.PauseHorse();
			menuSystem.HUD.Hide();
			SoundManager.PauseMusic(0.2f, GameOverPause: true);
			Invoke("OnEnterStateDeath", duration);
		}

		public void PauseGame()
		{
			if (state == GameState.Playing)
			{
				LaserPointerInputModule.instance.EnableLaserUI(isEnable: true);
				Time.timeScale = 0f;
				player.ASSSelfLoop.volume = 0f;
				state = GameState.Paused;
				player.ropeManager.HideRope();
				player.SpeedLineObject.SetActive(value: false);
				player.PauseHorse();
				menuSystem.HUD.Hide();
				SoundManager.PlaySfx("Pause");
				SoundManager.PauseMusic(0.5f, GameOverPause: false);
				pauseMenu.Show(0.3f);
			}
		}

		public void ResumeGame()
		{
			LaserPointerInputModule.instance.EnableLaserUI(isEnable: false);
			countdownMenu.Show(0.3f);
			pauseMenu.Hide(0.3f);
			countdownMenu.DOCountDown(3, delegate
			{
				player.BanSkill = true;
				Time.timeScale = 1f;
				player.ASSSelfLoop.volume = 1f * ((float)csPlayerData.SoundFXVolume / 10f);
				player.ropeManager.ShowRope();
				state = GameState.Playing;
				player.SpeedLineObject.SetActive(value: true);
				player.PlayHorse();
				Player.SetIsFocus(isF: true);
				if (csTutorialManager.instance.CurTStep != TutorialStep.WaitForTurnL && csTutorialManager.instance.CurTStep != TutorialStep.WaitForTurnR)
				{
					menuSystem.HUD.Show();
				}
				SoundManager.PlaySfx("Pause");
				SoundManager.UnpauseMusic();
			});
		}

		public void GotoSetting()
		{
			pauseMenu.Hide(0f);
			SettingMenu.Show(0f);
		}

		public void BackFromSetting()
		{
			SettingMenu.Hide(0f);
			pauseMenu.Show(0f);
		}

		public static void OnGameOver()
		{
			instance.GameOver();
		}

		public static void ShowInfo(string msg)
		{
			if (csGameSettings.CurrentGameMode != 0)
			{
				instance.infoPopup.ShowMessage(msg, 2f, 0.3f);
			}
		}

		private void ScreenFaderFadeIn(float time, DeerCat.SimpleTween.Callback onCompletedCB)
		{
			if (fadeTween != null)
			{
				SimpleTweener.RemoveTween(fadeTween);
			}
			screenFade.gameObject.SetActive(value: true);
			screenFade.alpha = 0f;
			fadeTween = SimpleTweener.AddTween(() => screenFade.alpha, delegate(float x)
			{
				screenFade.alpha = x;
			}, 1f, time).OnCompleted(onCompletedCB);
		}

		private void ScreenFaderFadeOut(float time)
		{
			if (screenFade.gameObject.activeSelf)
			{
				fadeTween = SimpleTweener.AddTween(() => screenFade.alpha, delegate(float x)
				{
					screenFade.alpha = x;
				}, 0f, time).OnCompleted(delegate
				{
					screenFade.gameObject.SetActive(value: false);
				});
			}
		}

		public static void FlashScreen(float fadeTime = 0.5f)
		{
			Player.PlayerCamFade.SetFadeAlpha(1f);
			Player.PlayerCamFade.FadeIn(null, fadeTime);
		}

		private void Update()
		{
			if (state != GameState.Playing)
			{
				return;
			}
			GameTime += Time.deltaTime;
			if (levelManager.TotalDistance * Player.hd.BasicData.ScoreMultiplier * Player.scoreBuffVal > targetDistance)
			{
				if (!brokenRecord)
				{
					ShowInfo("NEW RECORD!");
					menuSystem.HUD.OnNewRecord();
					brokenRecord = true;
				}
				RecordDistance = levelManager.TotalDistance * Player.hd.BasicData.ScoreMultiplier * Player.scoreBuffVal;
			}
		}

		public void AddSectionPass()
		{
			ScetionPassed++;
		}

		public void LevelUp()
		{
			Level++;
			LevelUpAction?.Invoke();
			Player.OnLevelUp();
			Player.root.localEulerAngles = Vector3.zero;
			if (csGameSettings.CurrentGameMode == GameMode.LevelMode)
			{
				RestReviveTimes = 0;
				m_InGameMissionData.SetMissionComplet(csMissionType.Task_01);
				HasCompeletLevel = true;
				gameCompleteTunnel.SetActive(value: true);
				levelManager.gameObject.SetActive(value: false);
				Player.PlayerCamFade.SetFadeAlpha(1f);
				Player.PlayerCamFade.FadeIn();
				Color fogColor = (Player.cam.backgroundColor = new Color(0.113f, 0.113f, 0.113f, 1f));
				RenderSettings.fogColor = fogColor;
				player.LevelEndGameover();
			}
		}
	}
	public class PlayerControl : MonoBehaviour
	{
		public enum MobileInputMode
		{
			Touch,
			Accelerometer
		}

		[Header("是否强制玩家技能")]
		public bool ForceSkill;

		[Header("强制技能类型")]
		public HorseSkill ForceSkillType;

		[Header("强制技能持续时间")]
		public float ForceSkillTime;

		[Header("强制技能CD时间")]
		public float ForceSkillCD;

		[Tooltip("Starting speed of the player")]
		public float baseSpeed = 60f;

		[Tooltip("Max speed of the player")]
		public float maxSpeed = 100f;

		[Tooltip("addingSpeed of the player")]
		public float addingSpeed;

		[Tooltip("inscreaseSpeed of the player")]
		public float inscreaseSpeed = 3f;

		[Tooltip("decreasingSpeed of the player")]
		public float decreasingSpeed = 3f;

		public int HP = 3;

		public float baseSteerSpeed = 80f;

		public float accelTime = 5f;

		public Transform CameraRig;

		[Header("Collision")]
		public float collisionRadius = 0.5f;

		public float ItemcollisionRadius = 1f;

		public bool isInvincible;

		[Header("Mobile Options")]
		[Tooltip("What input method to use on mobile devices")]
		public MobileInputMode inputMode = MobileInputMode.Accelerometer;

		[Tooltip("How sensitive the turning is to changes in the device orientation")]
		[Range(1f, 15f)]
		public float accelerometerSensitivity = 8f;

		private int interactLayer;

		public Transform root;

		private float acceleration = 1f;

		private float speedMultiplier = 1f;

		private float steerMultiplier = 1f;

		private bool crashed;

		private float invincibleTimer;

		public Transform ParticleParentT;

		public GameObject SheildObject;

		public GameObject RushPowerObject;

		public GameObject MagPowerObject;

		public GameObject SpeedLineObject;

		public GameObject BellowObj;

		private int numSheilds;

		public float currentSteer;

		public HorseController curHorse;

		private bool insideTunnel = true;

		private CameraShake cameraShake;

		public Animator HandAnimL;

		public Animator HandAnimR;

		public csFadeManager PlayerCamFade;

		public Transform[] LHandEndTs;

		public Transform[] RHandEndTs;

		public Transform[] RopeEnds;

		public Transform[] RopeStarts;

		public Renderer LHandMR;

		public Renderer RHandMR;

		public Renderer HandMRTransparent;

		public Renderer HandMRNormal;

		public AudioSource ASSSelf;

		public AudioSource ASSSelfLoop;

		public AudioSource ASSHorse;

		public ParticleSystem MovingParticle;

		public AudioClip SpeedUpAC_Loop;

		public AudioClip ShiledAC_Loop;

		public AudioClip MagnetAC_Loop;

		public AudioClip PropEndAC;

		public csRope ropeManager;

		public Transform thisT;

		public bool UseTrackingT;

		public Transform TrackingT;

		public bool UseCenterRotate;

		public Transform CenterRotateT;

		private Dictionary<HorseSkill, bool> HorseSkillDic = new Dictionary<HorseSkill, bool>();

		private Dictionary<HorseSkill, bool> SkillIsReadyDic = new Dictionary<HorseSkill, bool>();

		public AudioClip ShoeClip_Horse;

		public AudioClip ShoeClip_WoodenHorse;

		public AudioClip ShoeClip_Dragon;

		public AudioClip ShoeClip_Croco;

		public AudioClip ShoeClip_Elephant;

		public AudioClip ShoeClip_Rhino;

		public AudioClip Strike_Once;

		public AudioClip Invince_Loop;

		public AudioClip Jump_Once;

		public AudioClip Roar_Once;

		public AudioClip Fly_Loop;

		public csWeaponHand RightWeaponHand;

		public Dictionary<HorseType, AudioClip> TypeToShoeClip = new Dictionary<HorseType, AudioClip>();

		private float oriStartSpeed = -2f;

		private float oriStartLiftTime = 0.1f;

		private float oriEmitRate = 200f;

		private int CurGoldGetIndex;

		private float GoldCoolDown = 3f;

		private float GoldCDTimer;

		private float addSpeedRate;

		private int AddHeartNum;

		public float moneyBuffVal = 1f;

		public float scoreBuffVal = 1f;

		private bool ISLeftMove;

		private bool isReving;

		private Quaternion qua;

		public float moveDis;

		public float MoveDisMax;

		public Transform LHandT;

		public Transform RHandT;

		public Transform RidingHandT;

		public Transform camT;

		public Camera cam;

		public Transform horseRootT;

		public csControllerForSteamVR LhandController;

		public csControllerForSteamVR RhandController;

		public csHeadSetForSteamVR headController;

		private bool isFocus = true;

		[Header("手柄震动开始距离")]
		public float HanpicStartDist = 0.2f;

		[Header("每次震动持续时间")]
		public float HanpicDuration = 0.005f;

		[Header("开始震动时频率 0 - 320 ")]
		public float HanpicFreqOnStart = 100f;

		[Header("开始震动时强度")]
		public float HanpicAmpOnStart = 0.3f;

		[Header("开始震动间隔时间 越远该时间越短")]
		public float HapticStdDurationStart = 0.6f;

		[Header("最远时震动间隔时间")]
		public float HapticStdDurationMax = 0.1f;

		public Transform HandRotWithOutX;

		private float HapticStdTimer = 1f;

		public bool BanSkill;

		private float RushSkillTime;

		private float RushSkillCD = 99f;

		private float InvinceAbleTime;

		private float InvinceAbleCD = 99f;

		private bool InvicibleState;

		private float SlowTime;

		private float SlowCD = 99f;

		private bool SlowState;

		private float SlowPercent = 0.7f;

		private float SlowMultiPlier = 1f;

		private float JumpTime;

		private float JumpCD = 99f;

		private bool JumpState;

		private float RoarCD = 99f;

		private float FlyTime;

		private float FlyCD = 99f;

		private float FlyHeight = 5f;

		private bool FlyState;

		private bool FlyShield;

		private float StrikeTime;

		private float StrikeCD = 99f;

		private float AnticolTime;

		private float AnticolCD = 99f;

		public bool CheckDropEnabled;

		private bool isHorseDrop;

		private Coroutine JumpCor;

		private bool isJumping;

		private bool BreakJump;

		private float CurrentTunnelPosY = -8f;

		private csTunnelSpreader CurrentSpreader;

		private bool InSmallTunnel;

		private float FlyHeightMultiplier = 1f;

		public bool RoadCheck;

		private float DropRadius = 2f;

		public bool LBlocked;

		public bool RBlocked;

		private Collider RecordC;

		[Header("发出快速通过音效的最小速度")]
		public float PassSpeed = 50f;

		private bool InSheildState;

		private float stimer;

		private bool InRushState;

		private float RushTime = 10f;

		private float IncreasePercent = 1.2f;

		private float Rtimer;

		private bool InMagState;

		private float MagTime = 20f;

		private float MagTriggerDistance = 15f;

		private float Mtimer;

		public float SheildTime;

		public HorseDataInGame hd;

		private HorseData CurHorseData;

		private int horseBasicLevel;

		private int horseSpecLevel;

		public bool InTutorial;

		private bool CantMoveByTutorial;

		private float tutorialrotateSpeed;

		private float forceTurnSpeed;

		private bool GetTSpeed;

		public bool InsideTunnel
		{
			get
			{
				return insideTunnel;
			}
			set
			{
				insideTunnel = value;
			}
		}

		public float Speed
		{
			get
			{
				if (crashed)
				{
					return 0f;
				}
				float value = acceleration * (speedMultiplier * (baseSpeed + (isHorseDrop ? 0f : addingSpeed)));
				value = Mathf.Clamp(value, speedMultiplier * 30f, maxSpeed);
				if (InRushState)
				{
					value *= IncreasePercent;
				}
				if (SlowState)
				{
					value *= SlowMultiPlier;
				}
				float num = 2f * speedMultiplier * Mathf.PerlinNoise(Time.time, 0f) - 1f * speedMultiplier;
				return value + 2f * num;
			}
		}

		public float SteerSpeed
		{
			get
			{
				if (crashed)
				{
					return 0f;
				}
				return steerMultiplier * acceleration * (1f + addingSpeed / baseSpeed) * baseSteerSpeed * hd.BasicData.SteerSpeed * ((float)csPlayerData.Sensitivity * 0.02f + 0.8f);
			}
		}

		public float SpeedMultiplier
		{
			get
			{
				return speedMultiplier;
			}
			set
			{
				speedMultiplier = Mathf.Min(2f, value);
			}
		}

		private void Awake()
		{
			cameraShake = GameObject.Find("CameraRoot").GetComponent<CameraShake>();
			ropeManager = GameObject.Find("RopeGroup").GetComponent<csRope>();
			oriStartSpeed = MovingParticle.startSpeed;
			oriStartLiftTime = MovingParticle.startLifetime;
			RopeStarts = ropeManager.targetStartsT;
			RopeEnds = ropeManager.targetEndsT;
			thisT = base.transform;
			foreach (HorseSkill value in Enum.GetValues(typeof(HorseSkill)))
			{
				HorseSkillDic.Add(value, value: false);
				SkillIsReadyDic.Add(value, value: true);
			}
			TypeToShoeClip.Add(HorseType.Horse_Default, ShoeClip_Horse);
			TypeToShoeClip.Add(HorseType.Horse_1, ShoeClip_Horse);
			TypeToShoeClip.Add(HorseType.Horse_2, ShoeClip_Horse);
			TypeToShoeClip.Add(HorseType.Horse_3, ShoeClip_Horse);
			TypeToShoeClip.Add(HorseType.Horse_4, ShoeClip_Horse);
			TypeToShoeClip.Add(HorseType.Horse_5, ShoeClip_WoodenHorse);
			TypeToShoeClip.Add(HorseType.Horse_6, ShoeClip_WoodenHorse);
			TypeToShoeClip.Add(HorseType.Rhino_1, ShoeClip_Rhino);
			TypeToShoeClip.Add(HorseType.Crocodile, ShoeClip_Croco);
			TypeToShoeClip.Add(HorseType.Elephant, ShoeClip_Elephant);
			TypeToShoeClip.Add(HorseType.DragonBoss, ShoeClip_Dragon);
		}

		private IEnumerator Start()
		{
			ASSHorse = GameObject.Find("HorseRoot").GetComponent<AudioSource>();
			ASSHorse.clip = TypeToShoeClip[csGameSettings.PlayerHorseType];
			ASSSelf = base.gameObject.AddComponent<AudioSource>();
			ASSSelf.playOnAwake = false;
			ASSSelf.spatialBlend = 0f;
			ASSSelfLoop = base.gameObject.AddComponent<AudioSource>();
			ASSSelfLoop.playOnAwake = false;
			ASSSelfLoop.spatialBlend = 0f;
			ASSSelfLoop.loop = true;
			ASSSelf.volume = 1f * ((float)csPlayerData.SoundFXVolume / 10f);
			ASSSelfLoop.volume = 1f * ((float)csPlayerData.SoundFXVolume / 10f);
			ASSHorse.volume = 1f * ((float)csPlayerData.SoundFXVolume / 10f);
			root = base.transform.parent;
			interactLayer = LayerMask.NameToLayer("Interactable");
			while (!GameManager.instance.PlayerHMDiniter.initDone)
			{
				yield return null;
			}
			if (csGameSettings.isFromMainScene)
			{
				PlayerCamFade.FadeIn(delegate
				{
					GameManager.instance.OnStartGamePressed();
				});
			}
			else
			{
				PlayerCamFade.FadeIn();
			}
			SetRopeHand(isL: false, withFade: false);
			for (int i = 0; i < 2; i++)
			{
				RopeEnds[i].SetParent(RHandEndTs[i]);
				Transform obj = RopeEnds[i];
				Vector3 localPosition = (RopeEnds[i].localEulerAngles = Vector3.zero);
				obj.localPosition = localPosition;
			}
			cam = camT.GetComponent<Camera>();
		}

		public void SetSpeedEffect(float value)
		{
			curHorse.HorseModelController.SetSpeed(value);
			MovingParticle.startSpeed = oriStartSpeed * value;
			MovingParticle.startLifetime = oriStartLiftTime * 1f / value;
			MovingParticle.emissionRate = oriEmitRate * value;
			ASSHorse.pitch = value;
		}

		public void OnLevelUp()
		{
			if (HP > hd.BasicData.LifeMax)
			{
				HP = hd.BasicData.LifeMax;
			}
		}

		public void PlayGoldGet()
		{
			SoundManager.PlaySfx("Coin", CurGoldGetIndex);
			CurGoldGetIndex++;
			GoldCDTimer = GoldCoolDown;
			if (CurGoldGetIndex >= 21)
			{
				CurGoldGetIndex = 21;
			}
		}

		public void SetPlayerSpeedBySection(float mins, float maxs, float addt)
		{
			addingSpeed = 0f;
			baseSpeed = mins;
			maxSpeed = maxs;
			addSpeedRate = (maxs - mins) / addt;
			GameManager.LevelManager.ResetViewObj();
		}

		public void TryApplyAheadBuff()
		{
			string text = "";
			GameManager.MenuSystem.HUD.RefreshSkillHint();
			for (int i = 0; i < csPlayerData.LevelBuffList.Count; i++)
			{
				text = text + csPlayerData.LevelBuffList[i].ToString() + " ";
			}
			for (int j = 0; j < csPlayerData.LevelBuffList.Count; j++)
			{
				switch (csPlayerData.LevelBuffList[j])
				{
				case AheadBuff.RushS:
				case AheadBuff.RushM:
				case AheadBuff.RushB:
					DoRushBuff(csPlayerData.GetAheadBuffValue(csPlayerData.LevelBuffList[j]));
					break;
				case AheadBuff.ShieldS:
				case AheadBuff.ShieldM:
				case AheadBuff.ShieldB:
					DoSheildBuff(csPlayerData.GetAheadBuffValue(csPlayerData.LevelBuffList[j]));
					break;
				case AheadBuff.GoldBuffS:
				case AheadBuff.GoldBuffM:
				case AheadBuff.GoldBuffB:
					DoAddMoneyBuff(csPlayerData.GetAheadBuffValue(csPlayerData.LevelBuffList[j]));
					break;
				case AheadBuff.ScoreBuffS:
				case AheadBuff.ScoreBuffM:
				case AheadBuff.ScoreBuffB:
					DoAddScoreBuff(csPlayerData.GetAheadBuffValue(csPlayerData.LevelBuffList[j]));
					break;
				}
			}
			csPlayerData.ClearLevelBuff();
		}

		private void DoRushBuff(float BuffTime)
		{
			RushPowerObject.SetActive(value: true);
			GameManager.MenuSystem.HUD.AddBuffHint(PreObjectType.RushPower, BuffTime);
			if (!InRushState)
			{
				InRushState = true;
				StartCoroutine(RushTimer(BuffTime));
			}
			else
			{
				Rtimer += BuffTime;
			}
			GameManager.instance.m_InGameMissionData.AddPreObjectTimes(PreObjectType.RushPower);
		}

		private void DoSheildBuff(float BuffTime)
		{
			SheildObject.SetActive(value: true);
			numSheilds = 1;
			GameManager.MenuSystem.HUD.AddBuffHint(PreObjectType.Sheild, BuffTime);
			if (!InSheildState)
			{
				InSheildState = true;
				StartCoroutine(SheildTimer());
			}
			else
			{
				stimer = BuffTime;
			}
			GameManager.instance.m_InGameMissionData.AddPreObjectTimes(PreObjectType.Sheild);
		}

		private void DoAddLifeBuff(int add)
		{
			AddHeartNum = add;
		}

		private void DoAddMoneyBuff(float add)
		{
			moneyBuffVal = add;
		}

		private void DoAddScoreBuff(float add)
		{
			scoreBuffVal = add;
		}

		public void OnSpeedAdd(float addPer)
		{
		}

		public void OnHPAdd(int hpNum)
		{
			HP += hpNum;
			if (HP > hd.BasicData.LifeMax)
			{
				HP = hd.BasicData.LifeMax;
			}
			GameManager.MenuSystem.HUD.SetHPNum(HP);
		}

		public void PlayHorse()
		{
			ASSHorse.volume = 1f * ((float)csPlayerData.SoundFXVolume / 10f);
			if (!ASSHorse.isPlaying)
			{
				ASSHorse.Play();
			}
		}

		public void PauseHorse()
		{
			if (ASSHorse.isPlaying)
			{
				ASSHorse.Pause();
			}
		}

		public void Reset()
		{
			ClearSkillState();
			StopAllCoroutines();
			isJumping = false;
			RoadCheck = false;
			ISLeftMove = csGameSettings.IsLeftMove;
			InSmallTunnel = false;
			if (HorseSkillDic[HorseSkill.Fly])
			{
				GameManager.MenuSystem.HUD.OnSkillSilence(HorseSkill.Fly, isSilence: false);
			}
			FlyHeightMultiplier = 1f;
			GoldCDTimer = 0f;
			CurGoldGetIndex = 0;
			csTutorialManager.instance.Reset();
			addingSpeed = 0f;
			AddHeartNum = 0;
			scoreBuffVal = 1f;
			moneyBuffVal = 1f;
			for (int i = 0; i < csPlayerData.LevelBuffList.Count; i++)
			{
				AheadBuff aheadBuff = csPlayerData.LevelBuffList[i];
				if (aheadBuff == AheadBuff.AddLifeS)
				{
					DoAddLifeBuff((int)csPlayerData.GetAheadBuffValue(AheadBuff.AddLifeS));
				}
			}
			HP = hd.BasicData.LifeMax + AddHeartNum;
			GameManager.MenuSystem.HUD.InitHeartNum(HP);
			GameManager.MenuSystem.HUD.SetHPNum(HP);
			curHorse.DoHorseReset();
			SoundManager.RewindMusic();
			CantMoveByTutorial = false;
			InTutorial = false;
			CurGoldGetIndex = 1;
			numSheilds = 0;
			InSheildState = false;
			InMagState = false;
			SheildObject.SetActive(value: false);
			RushPowerObject.SetActive(value: false);
			MagPowerObject.SetActive(value: false);
			curHorse.HorseModelController.SetRun(isRun: true);
			crashed = false;
			acceleration = 0.5f;
			speedMultiplier = 1f;
			steerMultiplier = 1f;
			isHorseDrop = false;
			insideTunnel = true;
			root.rotation = Quaternion.identity;
			ASSSelfLoop.volume = 1f * ((float)csPlayerData.SoundFXVolume / 10f);
		}

		public void Revive()
		{
			ClearSkillState();
			StopAllCoroutines();
			isReving = true;
			isJumping = false;
			GoldCDTimer = 0f;
			CurGoldGetIndex = 1;
			HP = hd.BasicData.LifeMax + AddHeartNum;
			GameManager.MenuSystem.HUD.SetHPNum(HP);
			curHorse.DoHorseReset();
			steerMultiplier = 0f;
			crashed = false;
			isInvincible = true;
			acceleration = 0.6f;
			invincibleTimer = 10f;
			InSheildState = false;
			InMagState = false;
			SheildObject.SetActive(value: false);
			RushPowerObject.SetActive(value: false);
			MagPowerObject.SetActive(value: false);
			if (isHorseDrop)
			{
				PlayerCamFade.FadeOut(delegate
				{
					Vector3 zero = Vector3.zero;
					for (int i = 0; i < 8; i++)
					{
						if (Physics.Raycast(zero, Quaternion.Euler(0f, 0f, 45 * i) * -Vector3.up, out var hitInfo, 20f) && hitInfo.collider.gameObject.layer != 10)
						{
							root.rotation = Quaternion.LookRotation(Vector3.forward, Quaternion.Euler(0f, 0f, ((!insideTunnel) ? 180 : 0) + 45 * i) * Vector3.up);
							UnityEngine.Debug.Log("Collider:" + hitInfo.collider.gameObject.name + " outPut Angle:" + 45 * i);
							break;
						}
					}
					PlayerCamFade.FadeIn(delegate
					{
						GameManager.instance.countdownMenu.Show(0.3f);
						GameManager.instance.countdownMenu.DOCountDown(3, delegate
						{
							ASSHorse.volume = 1f * ((float)csPlayerData.SoundFXVolume / 10f);
							GameManager.MenuSystem.HUD.Show();
							steerMultiplier = 1f;
							speedMultiplier = 1f;
							isInvincible = false;
							invincibleTimer = 2f;
							isHorseDrop = false;
							isReving = false;
							SpeedLineObject.SetActive(value: true);
							curHorse.HorseModelController.SetRun(isRun: true);
							PlayHorse();
							SoundManager.UnpauseMusic();
						});
					});
				});
				return;
			}
			PlayerCamFade.FadeOut(delegate
			{
				PlayerCamFade.FadeIn(delegate
				{
					GameManager.instance.countdownMenu.Show(0.3f);
					GameManager.instance.countdownMenu.DOCountDown(3, delegate
					{
						ASSHorse.volume = 1f * ((float)csPlayerData.SoundFXVolume / 10f);
						GameManager.MenuSystem.HUD.Show();
						isInvincible = false;
						SpeedLineObject.SetActive(value: true);
						steerMultiplier = 1f;
						speedMultiplier = 1f;
						invincibleTimer = 2f;
						steerMultiplier = 1f;
						isReving = false;
						curHorse.HorseModelController.SetRun(isRun: true);
						PlayHorse();
						SoundManager.UnpauseMusic();
					});
				});
			});
		}

		private float GetSteerInput()
		{
			if (!UnityEngine.Application.isMobilePlatform)
			{
				return Input.GetAxis("Horizontal");
			}
			if (inputMode == MobileInputMode.Touch)
			{
				if (Input.touchCount > 0)
				{
					if (!(Input.GetTouch(0).position.x < 0.5f * (float)Screen.width))
					{
						return 1f;
					}
					return -1f;
				}
				return 0f;
			}
			return accelerometerSensitivity * Input.acceleration.x;
		}

		public void SetIsFocus(bool isF)
		{
			isFocus = isF;
			if (!isF && GameManager.CurrentState == GameManager.GameState.Playing)
			{
				GameManager.instance.PauseGame();
			}
		}

		private void VRControl()
		{
			if ((csControllerForSteamVR.GetPressDown_MenuOC(isLeft: true) || csControllerForSteamVR.GetPressDown_MenuOC(isLeft: false)) && GameManager.CurrentState == GameManager.GameState.Playing)
			{
				GameManager.instance.PauseGame();
			}
			SkillOpreate();
			if (isFocus)
			{
				if (UseTrackingT)
				{
					if (UseCenterRotate)
					{
						moveDis = accelerometerSensitivity * (TrackingT.InverseTransformPoint(RidingHandT.position).x - TrackingT.InverseTransformPoint(CenterRotateT.position).x);
					}
					else
					{
						moveDis = accelerometerSensitivity * (TrackingT.InverseTransformPoint(RidingHandT.position).x - camT.localPosition.x);
					}
				}
				else
				{
					moveDis = accelerometerSensitivity * (RidingHandT.localPosition.x - camT.localPosition.x);
				}
				if (csGameSettings.WeaponMode && GameManager.CurrentState == GameManager.GameState.Playing && (bool)RightWeaponHand)
				{
					if (RightWeaponHand.showWeapon)
					{
						moveDis = 0f;
						if (ropeManager.isShow)
						{
							ropeManager.HideRope();
						}
					}
					else if (!ropeManager.isShow)
					{
						ropeManager.ShowRope();
					}
				}
			}
			else
			{
				moveDis = 0f;
			}
			if (Mathf.Abs(moveDis) > MoveDisMax)
			{
				moveDis = Mathf.Clamp(moveDis, 0f - MoveDisMax, MoveDisMax);
			}
			if ((bool)curHorse.HorseModelController)
			{
				curHorse.SetHorseLook(moveDis < 0f, moveDis, MoveDisMax);
			}
			if (GameManager.CurrentState == GameManager.GameState.Playing)
			{
				float num = Mathf.Abs(moveDis);
				if (num > HanpicStartDist * accelerometerSensitivity)
				{
					HapticStdTimer += Time.deltaTime;
					if (HapticStdTimer >= Mathf.Lerp(HapticStdDurationStart, HapticStdDurationMax, num / MoveDisMax))
					{
						if (csPlayerData.VibrationSwitch)
						{
							csControllerForSteamVR.TriggerHapticPulse_OC(ISLeftMove, (int)(num * 500f));
						}
						HapticStdTimer = 0f;
					}
				}
				else
				{
					HapticStdTimer = 0f;
				}
			}
			if (csTutorialManager.instance.CurTStep == TutorialStep.WaitForTurnL && moveDis < -0.3f)
			{
				csTutorialManager.instance.SetTutorialState(TutorialStep.TurningL);
			}
			if (csTutorialManager.instance.CurTStep == TutorialStep.WaitForTurnR && moveDis > 0.3f)
			{
				csTutorialManager.instance.SetTutorialState(TutorialStep.TurningR);
			}
			if (InTutorial)
			{
				GameManager.instance.UpdateControllerPos(moveDis / 0.6f);
			}
			if (CantMoveByTutorial)
			{
				moveDis = 0f;
			}
			else
			{
				if (!InTutorial)
				{
					return;
				}
				if (csTutorialManager.instance.CurTStep == TutorialStep.TurningL)
				{
					if (!GetTSpeed)
					{
						tutorialrotateSpeed -= Time.deltaTime;
						if (tutorialrotateSpeed <= forceTurnSpeed)
						{
							GetTSpeed = true;
						}
					}
					else
					{
						tutorialrotateSpeed += Time.deltaTime;
						if (tutorialrotateSpeed >= 0f)
						{
							csTutorialManager.instance.SetTutorialState(TutorialStep.StraightRun);
						}
					}
					moveDis = tutorialrotateSpeed;
				}
				if (csTutorialManager.instance.CurTStep != TutorialStep.TurningR)
				{
					return;
				}
				if (!GetTSpeed)
				{
					tutorialrotateSpeed += Time.deltaTime;
					if (tutorialrotateSpeed >= forceTurnSpeed)
					{
						GetTSpeed = true;
					}
				}
				else
				{
					tutorialrotateSpeed -= Time.deltaTime;
					if (tutorialrotateSpeed <= 0f)
					{
						csTutorialManager.instance.SetTutorialState(TutorialStep.StraightRun);
					}
				}
				moveDis = tutorialrotateSpeed;
			}
		}

		private void SkillOpreate()
		{
			if (BanSkill)
			{
				BanSkill = false;
			}
			else
			{
				if (GameManager.CurrentState != GameManager.GameState.Playing || isHorseDrop || isReving)
				{
					return;
				}
				if (HorseSkillDic[HorseSkill.Sprint] && SkillIsReadyDic[HorseSkill.Sprint] && (csControllerForSteamVR.GetPressDown_TriggerOC(isLeft: true) || csControllerForSteamVR.GetPressDown_TriggerOC(isLeft: false)))
				{
					DoRushSkill();
				}
				if (HorseSkillDic[HorseSkill.Invincible] && SkillIsReadyDic[HorseSkill.Invincible] && (csControllerForSteamVR.GetPressDown_TriggerOC(isLeft: true) || csControllerForSteamVR.GetPressDown_TriggerOC(isLeft: false)))
				{
					DoInvincibleSkill();
				}
				if (HorseSkillDic[HorseSkill.Slow] && SkillIsReadyDic[HorseSkill.Slow] && (csControllerForSteamVR.GetPressDown_TriggerOC(isLeft: true) || csControllerForSteamVR.GetPressDown_TriggerOC(isLeft: false)))
				{
					DoSlowSkill();
				}
				if (HorseSkillDic[HorseSkill.Jump] && SkillIsReadyDic[HorseSkill.Jump] && (csControllerForSteamVR.GetPressDown_TriggerOC(isLeft: true) || csControllerForSteamVR.GetPressDown_TriggerOC(isLeft: false)))
				{
					DoJumpSkill();
				}
				if (HorseSkillDic[HorseSkill.Roar] && SkillIsReadyDic[HorseSkill.Roar] && (csControllerForSteamVR.GetPressDown_TriggerOC(isLeft: true) || csControllerForSteamVR.GetPressDown_TriggerOC(isLeft: false)))
				{
					DoRoarSkill();
				}
				if (HorseSkillDic[HorseSkill.Fly] && SkillIsReadyDic[HorseSkill.Fly] && (csControllerForSteamVR.GetPressDown_TriggerOC(isLeft: true) || csControllerForSteamVR.GetPressDown_TriggerOC(isLeft: false)))
				{
					if (InSmallTunnel)
					{
						SoundManager.PlaySfx("GetFailed");
					}
					else
					{
						DoFlySkill();
					}
				}
			}
		}

		private void ClearSkillState()
		{
			foreach (HorseSkill value in Enum.GetValues(typeof(HorseSkill)))
			{
				SkillIsReadyDic[value] = true;
			}
			InRushState = false;
			InvicibleState = false;
			curHorse.HorseModelController.SetInvincible(isinvince: false);
			SlowState = false;
			SlowMultiPlier = 1f;
			JumpState = false;
			FlyState = false;
			FlyShield = false;
			curHorse.HorseModelController.SetFly(isFly: false);
			ASSSelfLoop.Stop();
		}

		private void DoRushSkill()
		{
			UnityEngine.Debug.Log("DoRush SKill");
			if (InRushState)
			{
				return;
			}
			SkillIsReadyDic[HorseSkill.Sprint] = false;
			RushPowerObject.SetActive(value: true);
			GameManager.MenuSystem.HUD.OnSkillUse(HorseSkill.Sprint);
			if (!InRushState)
			{
				InRushState = true;
				StartCoroutine(RushTimer(RushSkillTime));
				StartCoroutine(SkillCDStarter(HorseSkill.Sprint, RushSkillTime, RushSkillCD));
				return;
			}
			if (RushSkillTime > Rtimer)
			{
				Rtimer = RushTime;
			}
			StartCoroutine(SkillCDStarter(HorseSkill.Sprint, RushSkillTime, RushSkillCD));
		}

		private void DoInvincibleSkill()
		{
			UnityEngine.Debug.Log("DoInvincible SKill");
			SkillIsReadyDic[HorseSkill.Invincible] = false;
			ASSSelfLoop.clip = Invince_Loop;
			ASSSelfLoop.Play();
			GameManager.MenuSystem.HUD.OnSkillUse(HorseSkill.Invincible);
			if (!InvicibleState)
			{
				StartCoroutine(InvincibleTimer(InvinceAbleTime));
				StartCoroutine(SkillCDStarter(HorseSkill.Invincible, InvinceAbleTime, InvinceAbleCD));
			}
		}

		private IEnumerator InvincibleTimer(float time)
		{
			InvicibleState = true;
			curHorse.HorseModelController.SetInvincible(isinvince: true);
			isInvincible = true;
			float SkillTime = time;
			while (InvicibleState && SkillTime > 0f)
			{
				SkillTime -= Time.deltaTime;
				yield return new WaitForEndOfFrame();
			}
			ASSSelfLoop.Stop();
			isInvincible = false;
			InvicibleState = false;
			curHorse.HorseModelController.SetInvincible(isinvince: false);
		}

		private void DoSlowSkill()
		{
			UnityEngine.Debug.Log("Do Slow SKill");
			SkillIsReadyDic[HorseSkill.Slow] = false;
			GameManager.MenuSystem.HUD.OnSkillUse(HorseSkill.Slow);
			if (!SlowState)
			{
				StartCoroutine(SlowTimer(SlowTime));
				StartCoroutine(SkillCDStarter(HorseSkill.Slow, SlowTime, SlowCD));
			}
		}

		private IEnumerator SlowTimer(float time)
		{
			SlowState = true;
			float SkillTime = time;
			SlowMultiPlier = 0.7f;
			while (SlowState && SkillTime > 0f)
			{
				SkillTime -= Time.deltaTime;
				SlowMultiPlier = Mathf.Lerp(1f, 0.7f, SkillTime / time);
				yield return new WaitForEndOfFrame();
			}
			SlowMultiPlier = 1f;
			SlowState = false;
		}

		private void DoJumpSkill()
		{
			UnityEngine.Debug.Log("Do Jump SKill");
			SkillIsReadyDic[HorseSkill.Jump] = false;
			GameManager.MenuSystem.HUD.OnSkillUse(HorseSkill.Jump);
			DoJump(JumpTime);
			StartCoroutine(JumpTimer(HorseSkill.Jump, JumpCD));
		}

		private IEnumerator JumpTimer(HorseSkill skType, float cd)
		{
			JumpState = true;
			curHorse.HorseModelController.SetJump(isJump: true);
			curHorse.HorseModelController.SetRun(isRun: false);
			while (JumpState && isJumping)
			{
				yield return new WaitForFixedUpdate();
			}
			curHorse.HorseModelController.SetJump(isJump: false);
			curHorse.HorseModelController.SetRun(isRun: true);
			JumpState = false;
			GameManager.MenuSystem.HUD.OnSkillStartCD(skType);
			yield return new WaitForSeconds(cd);
			SkillIsReadyDic[skType] = true;
		}

		private void DoRoarSkill()
		{
			SkillIsReadyDic[HorseSkill.Roar] = false;
			BellowObj.SetActive(value: true);
			GameManager.MenuSystem.HUD.OnSkillUse(HorseSkill.Roar);
			ASSSelf.PlayOneShot(Roar_Once);
			for (int i = 0; i < GameManager.LevelManager.allBlockMR.Count; i++)
			{
				if (GameManager.LevelManager.allBlockMR[i].type == SCENEOBJTYPE.OBSTACLE || GameManager.LevelManager.allBlockMR[i].type == SCENEOBJTYPE.ROLLCUBE)
				{
					GameManager.LevelManager.allBlockMR[i].gameObject.SetActive(value: false);
				}
			}
			StartCoroutine(SkillCDStarter(HorseSkill.Roar, 0f, RoarCD));
		}

		private void DoFlySkill()
		{
			UnityEngine.Debug.Log("Do Fly SKill");
			SkillIsReadyDic[HorseSkill.Fly] = false;
			ASSSelfLoop.clip = Fly_Loop;
			ASSSelfLoop.Play();
			GameManager.MenuSystem.HUD.OnSkillUse(HorseSkill.Fly);
			if (JumpCor != null)
			{
				StopCoroutine(JumpCor);
			}
			curHorse.HorseModelController.SetJump(isJump: false);
			if (!FlyState)
			{
				StartCoroutine(FlyTimer(FlyTime));
			}
		}

		private IEnumerator FlyTimer(float time)
		{
			FlyState = true;
			ASSHorse.Stop();
			curHorse.HorseModelController.SetFly(isFly: true);
			float SkillTime2 = time;
			GameManager.MenuSystem.HUD.OnSkillEffecting(HorseSkill.Fly, SkillTime2);
			SkillTime2 -= 2f;
			Vector3 startPos = thisT.localPosition;
			float timer2 = 1f;
			float fh = FlyHeight;
			if (InSmallTunnel)
			{
				fh = FlyHeight * FlyHeightMultiplier;
			}
			float g = 2f * fh;
			FlyShield = true;
			isInvincible = true;
			float OriPosY3 = CurrentTunnelPosY;
			while (FlyShield && FlyState && timer2 > 0f)
			{
				timer2 -= Time.deltaTime;
				thisT.localPosition = startPos + Vector3.up * (g * (1f - (1f - timer2)) + g * 1f) / 2f * (1f - timer2) + Vector3.up * (CurrentTunnelPosY - OriPosY3);
				yield return new WaitForEndOfFrame();
			}
			float DownTime = 1f;
			if (!FlyShield)
			{
				DownTime = 1f - timer2;
			}
			Vector3 endPos = startPos + Vector3.up * fh;
			thisT.localPosition = endPos;
			OriPosY3 = CurrentTunnelPosY;
			while (FlyShield && FlyState && SkillTime2 > 0f)
			{
				SkillTime2 -= Time.deltaTime;
				thisT.localPosition = endPos + Vector3.up * 2f * Mathf.Sin(Mathf.Lerp(0f, (float)Math.PI * 4f, SkillTime2 / (time - 2f))) + Vector3.up * (CurrentTunnelPosY - OriPosY3);
				yield return new WaitForEndOfFrame();
			}
			thisT.localPosition = endPos;
			timer2 = 1f;
			if (!FlyShield)
			{
				timer2 = DownTime;
			}
			isInvincible = true;
			float h = thisT.localPosition.y - CurrentTunnelPosY;
			OriPosY3 = CurrentTunnelPosY;
			while (FlyState && timer2 > 0f)
			{
				timer2 -= Time.deltaTime;
				thisT.localPosition = endPos - Vector3.up * 2f * h * (1f - timer2) / 2f * (1f - timer2) + Vector3.up * (CurrentTunnelPosY - OriPosY3);
				yield return new WaitForEndOfFrame();
			}
			curHorse.HorseModelController.SetFly(isFly: false);
			isInvincible = false;
			thisT.localPosition = new Vector3(0f, CurrentTunnelPosY, 0f);
			FlyShield = false;
			FlyState = false;
			isInvincible = false;
			GameManager.MenuSystem.HUD.OnSkillStartCD(HorseSkill.Fly);
			ASSSelfLoop.Stop();
			ASSHorse.Play();
			yield return new WaitForSeconds(FlyCD);
			SkillIsReadyDic[HorseSkill.Fly] = true;
		}

		private void DoStrikeSkill(Vector3 hitPoint, csTunnelColorChild TunnelChild)
		{
			ASSSelf.PlayOneShot(Strike_Once);
			SoundManager.PlaySfx("Hit");
			PlayGoldGet();
			invincibleTimer = 2f;
			cameraShake.Shake(0.2f);
			Multi_csObjectPool.Instance.GetObjectByType(PreObjectType.Particle_HitWall, camT.position + Vector3.forward, Vector3.forward).transform.SetParent(camT);
			if ((bool)TunnelChild && TunnelChild.gameObject.layer != 11)
			{
				TunnelChild.mr.enabled = false;
			}
			SkillIsReadyDic[HorseSkill.Strike] = false;
			GameManager.MenuSystem.HUD.OnSkillUse(HorseSkill.Strike);
			StartCoroutine(SkillCDStarter(HorseSkill.Strike, 0f, StrikeCD));
		}

		private void DoAnticolSkill(Vector3 hitPoint, csTunnelColorChild TunnelChild)
		{
			SoundManager.PlaySfx("Hit");
			invincibleTimer = 2f;
			cameraShake.Shake(0.2f);
			Multi_csObjectPool.Instance.GetObjectByType(PreObjectType.Particle_HitRollCube, camT.position + Vector3.forward, Vector3.forward).transform.SetParent(camT);
			TunnelChild.mr.enabled = false;
			SkillIsReadyDic[HorseSkill.Anticol] = false;
			GameManager.MenuSystem.HUD.OnSkillUse(HorseSkill.Anticol);
			StartCoroutine(SkillCDStarter(HorseSkill.Anticol, 0f, AnticolCD));
		}

		private IEnumerator SkillCDStarter(HorseSkill skType, float afTime, float cd)
		{
			if (afTime > 0f)
			{
				GameManager.MenuSystem.HUD.OnSkillEffecting(skType, afTime);
			}
			yield return new WaitForSeconds(afTime);
			if (GameManager.CurrentState == GameManager.GameState.Playing)
			{
				GameManager.MenuSystem.HUD.OnSkillStartCD(skType);
			}
			yield return new WaitForSeconds(cd);
			SkillIsReadyDic[skType] = true;
		}

		public void ResetHandRnds()
		{
			RHandMR.enabled = true;
			LHandMR.enabled = true;
			LHandMR.material.SetColor("_Color", Color.white);
			RHandMR.material.SetColor("_Color", Color.white);
		}

		public void SetRopeHand(bool isL, bool withFade)
		{
			if (isL)
			{
				for (int i = 0; i < 2; i++)
				{
					RopeEnds[i].SetParent(LHandEndTs[i]);
					Transform obj = RopeEnds[i];
					Vector3 localPosition = (RopeEnds[i].localEulerAngles = Vector3.zero);
					obj.localPosition = localPosition;
				}
				RidingHandT = LHandT;
				HandAnimL.SetInteger("AnimationState", 2);
				HandAnimR.SetInteger("AnimationState", 0);
				if (withFade)
				{
					LHandMR.material = HandMRNormal.material;
					RHandMR.material = HandMRTransparent.material;
					RHandMR.material.DOFade(0f, 3f).onComplete = delegate
					{
						RHandMR.enabled = false;
					};
				}
				return;
			}
			for (int j = 0; j < 2; j++)
			{
				RopeEnds[j].SetParent(RHandEndTs[j]);
				Transform obj2 = RopeEnds[j];
				Vector3 localPosition = (RopeEnds[j].localEulerAngles = Vector3.zero);
				obj2.localPosition = localPosition;
			}
			RidingHandT = RHandT;
			if (csGameSettings.WeaponMode)
			{
				HandAnimL.SetInteger("AnimationState", 2);
			}
			else
			{
				HandAnimL.SetInteger("AnimationState", 0);
			}
			HandAnimR.SetInteger("AnimationState", 2);
			if (!withFade)
			{
				return;
			}
			if (csGameSettings.WeaponMode)
			{
				LHandMR.material = HandMRNormal.material;
				RHandMR.material = HandMRNormal.material;
				return;
			}
			LHandMR.material = HandMRTransparent.material;
			RHandMR.material = HandMRNormal.material;
			LHandMR.material.DOFade(0f, 3f).onComplete = delegate
			{
				LHandMR.enabled = false;
			};
		}

		public void OnIntactObstacle(SceneObstacleType obsType, float Value = 2f, float Dist = 0f)
		{
			switch (obsType)
			{
			case SceneObstacleType.Jumper:
				DoJump(Value, Dist);
				break;
			case SceneObstacleType.SpeedBurster:
				OnSpeedAdd(10f);
				break;
			}
		}

		public void DoDrop()
		{
			if (!isHorseDrop && GameManager.CurrentState == GameManager.GameState.Playing)
			{
				isHorseDrop = true;
				speedMultiplier = 0f;
				steerMultiplier = 0f;
				curHorse.DoHorseDrop(HorseDropGameOver);
				ropeManager.Rope1MR.enabled = false;
				ropeManager.Rope2MR.enabled = false;
				SpeedLineObject.SetActive(value: false);
				PauseHorse();
				GameManager.instance.m_InGameMissionData.DropTimes++;
				GameManager.instance.m_InGameMissionData.LostHP += HP;
				GameManager.MenuSystem.HUD.Hide();
				SoundManager.PauseMusic(0.2f, GameOverPause: true);
			}
		}

		private void HorseDropGameOver()
		{
			crashed = true;
			curHorse.HorseModelController.SetRun(isRun: false);
			curHorse.HorseModelController.SetShow(isShow: false);
			cameraShake.Shake(0.15f);
			GameManager.OnGameOver();
		}

		public void LevelEndGameover()
		{
			speedMultiplier = 0f;
			steerMultiplier = 0f;
			addingSpeed = 0f;
			ropeManager.Rope1MR.enabled = false;
			ropeManager.Rope2MR.enabled = false;
			SpeedLineObject.SetActive(value: false);
			LevelEndCloseEffect();
			GameManager.MenuSystem.HUD.Hide();
			SoundManager.PauseMusic(0.2f, GameOverPause: true);
			crashed = true;
			curHorse.HorseModelController.SetRun(isRun: false);
			GameManager.OnGameOver();
		}

		public void DoJump(float jumpHeight, float dist = 0f)
		{
			if (!FlyState)
			{
				ASSSelf.PlayOneShot(Jump_Once);
				if (JumpCor != null)
				{
					StopCoroutine(JumpCor);
				}
				JumpCor = StartCoroutine(PlayerJump(jumpHeight, dist));
			}
		}

		public void StopJump()
		{
			BreakJump = true;
		}

		public void SetLocalPos(float PosY, bool inside)
		{
			insideTunnel = inside;
			CurrentTunnelPosY = PosY * (insideTunnel ? (-1f) : 1f);
			thisT.localPosition = Mathf.Abs(CurrentTunnelPosY) * (insideTunnel ? Vector3.down : Vector3.up);
			BreakJump = true;
			FlyState = false;
			FlyShield = false;
		}

		public void OnEnableRoadCheck(bool isEnable, csTunnelSpreader spreader)
		{
			RoadCheck = isEnable;
			CurrentSpreader = spreader;
			if (isEnable)
			{
				SetSpreadLocalPos(CurrentSpreader.StartRadius);
			}
			else
			{
				SetSpreadLocalPos(CurrentSpreader.EndRadus);
			}
		}

		public void OnEnterSmallTunnel(bool isEnable, float heightMul)
		{
			InSmallTunnel = isEnable;
			if (HorseSkillDic[HorseSkill.Fly])
			{
				GameManager.MenuSystem.HUD.OnSkillSilence(HorseSkill.Fly, isEnable);
			}
			FlyHeightMultiplier = heightMul;
		}

		public void SetSpreadLocalPos(float PosY)
		{
			CurrentTunnelPosY = PosY * (insideTunnel ? (-1f) : 1f);
			if (!isJumping && !FlyState)
			{
				thisT.localPosition = Mathf.Abs(CurrentTunnelPosY) * (insideTunnel ? Vector3.down : Vector3.up);
			}
		}

		private void UpdateLocalPos()
		{
			if (CurrentSpreader == null)
			{
				RoadCheck = false;
				return;
			}
			float num = Mathf.Lerp(CurrentSpreader.StartRadius, CurrentSpreader.EndRadus, (thisT.position.z - CurrentSpreader.StartT.position.z) / CurrentSpreader.Length);
			CurrentTunnelPosY = num * (insideTunnel ? (-1f) : 1f);
			if (!isJumping && !FlyState)
			{
				thisT.localPosition = Mathf.Abs(CurrentTunnelPosY) * (insideTunnel ? Vector3.down : Vector3.up);
			}
		}

		private IEnumerator PlayerJump(float jumpHeight, float JumpDist = 0f)
		{
			BreakJump = false;
			isJumping = true;
			float jumpgravity2 = csGameSettings.Jumpgravity;
			float jumpTime2 = Mathf.Sqrt(2f * jumpHeight / jumpgravity2) + Mathf.Sqrt(2f * (jumpHeight + (thisT.localPosition.y - CurrentTunnelPosY)) / jumpgravity2);
			curHorse.HorseModelController.SetJump(isJump: true);
			float OriPosY = CurrentTunnelPosY;
			ASSHorse.Stop();
			if (JumpDist > 0f)
			{
				jumpTime2 = JumpDist * 2f / Speed;
				Vector3 startPos = thisT.localPosition;
				float VelY = (CurrentTunnelPosY - thisT.localPosition.y) / jumpTime2;
				float t = 0f;
				jumpgravity2 = 2f * jumpHeight / jumpTime2 / jumpTime2 * 4f;
				while (t < jumpTime2 && !BreakJump)
				{
					t += Time.deltaTime;
					thisT.localPosition = startPos + Vector3.up * VelY * t + Vector3.up * (jumpgravity2 * jumpTime2 - t * jumpgravity2) / 2f * t + Vector3.up * (CurrentTunnelPosY - OriPosY);
					yield return new WaitForFixedUpdate();
				}
			}
			else
			{
				Vector3 startPos = thisT.localPosition;
				float t = (0f - (thisT.localPosition.y - CurrentTunnelPosY)) / jumpTime2;
				float VelY = 0f;
				while (VelY < jumpTime2 && !BreakJump)
				{
					VelY += Time.deltaTime;
					thisT.localPosition = startPos + Vector3.up * t * VelY + Vector3.up * (0f - jumpgravity2) * VelY * (VelY - jumpTime2) * 0.5f + Vector3.up * (CurrentTunnelPosY - OriPosY);
					yield return new WaitForFixedUpdate();
				}
			}
			ASSHorse.Play();
			curHorse.HorseModelController.SetJump(isJump: false);
			isJumping = false;
			thisT.localPosition = new Vector3(0f, CurrentTunnelPosY, 0f);
		}

		public void OnWallHit(Vector3 hitPoint, csTunnelColorChild TunnelChild)
		{
			if (HorseSkillDic[HorseSkill.Strike] && SkillIsReadyDic[HorseSkill.Strike])
			{
				DoStrikeSkill(hitPoint, TunnelChild);
				GameManager.instance.m_InGameMissionData.CrashWallTimes++;
				GameManager.LevelManager.OnCoinGet(csGameSettings.SmashGold);
				return;
			}
			if (HorseSkillDic[HorseSkill.Anticol] && SkillIsReadyDic[HorseSkill.Anticol] && TunnelChild.type == SCENEOBJTYPE.ROLLCUBE)
			{
				DoAnticolSkill(hitPoint, TunnelChild);
				return;
			}
			HP--;
			GameManager.instance.m_InGameMissionData.LostHP++;
			GameManager.MenuSystem.HUD.SetHPNum(HP);
			GameManager.MenuSystem.HUD.DoHeartShake();
			GameManager.instance.m_InGameMissionData.HitTimes++;
			if (HP > 0)
			{
				acceleration = 0.3f;
				GameManager.LevelManager.OnHitChange();
				SoundManager.PlaySfx("Hit");
				invincibleTimer = 2f;
				cameraShake.Shake(0.2f);
				GameManager.FlashScreen();
			}
			else
			{
				SoundManager.PlaySfx("Explosion");
				HP = 0;
				crashed = true;
				curHorse.HorseModelController.SetRun(isRun: false);
				cameraShake.Shake(0.15f);
				GameManager.FlashScreen(2f);
				speedMultiplier = 0f;
				ASSSelfLoop.Stop();
				GameManager.OnGameOver();
			}
		}

		public void ForceHPDrop()
		{
			if (FlyShield)
			{
				FlyShield = false;
				SoundManager.PlaySfx("Hit");
				invincibleTimer = 2f;
				cameraShake.Shake(0.2f);
				GameManager.FlashScreen();
			}
			else if (InSheildState && numSheilds > 0)
			{
				acceleration = 0.3f;
				numSheilds--;
				SoundManager.PlaySfx("Hit");
				invincibleTimer = 2f;
				cameraShake.Shake(0.2f);
				GameManager.FlashScreen();
			}
			else if (!isInvincible)
			{
				HP--;
				GameManager.instance.m_InGameMissionData.LostHP++;
				GameManager.MenuSystem.HUD.SetHPNum(HP);
				GameManager.MenuSystem.HUD.DoHeartShake();
				GameManager.instance.m_InGameMissionData.HitTimes++;
				if (HP > 0)
				{
					acceleration = 0.3f;
					GameManager.LevelManager.OnHitChange();
					SoundManager.PlaySfx("Hit");
					invincibleTimer = 2f;
					cameraShake.Shake(0.2f);
					GameManager.FlashScreen();
				}
				else
				{
					SoundManager.PlaySfx("Explosion");
					HP = 0;
					crashed = true;
					curHorse.HorseModelController.SetRun(isRun: false);
					cameraShake.Shake(0.15f);
					GameManager.FlashScreen(2f);
					speedMultiplier = 0f;
					ASSSelfLoop.Stop();
					GameManager.OnGameOver();
				}
			}
		}

		private void FixedUpdate()
		{
		}

		private void Update()
		{
			FixedUpdate2();
			if (GoldCDTimer >= 0f)
			{
				GoldCDTimer -= Time.deltaTime;
			}
			else
			{
				GoldCDTimer = 0f;
				CurGoldGetIndex = 1;
			}
			if (GameManager.CurrentState == GameManager.GameState.Playing)
			{
				addingSpeed += addSpeedRate * Time.deltaTime;
			}
			VRControl();
			currentSteer = GetSteerInput();
		}

		private void OnDrawGizmos()
		{
			Gizmos.DrawSphere(base.transform.position - collisionRadius * Vector3.forward, collisionRadius);
		}

		public void TryPlayFlash(Collider newC, Vector3 hitPos)
		{
			if (!(newC != RecordC))
			{
				return;
			}
			RecordC = newC;
			if (!(Speed >= PassSpeed))
			{
				return;
			}
			csTunnelColorChild component = RecordC.GetComponent<csTunnelColorChild>();
			if ((bool)component)
			{
				if (component.type != 0)
				{
					SoundManager.PlaySfxAtPos("FlashBy", hitPos);
				}
			}
			else
			{
				SoundManager.PlaySfxAtPos("FlashBy", hitPos);
			}
		}

		private void FixedUpdate2()
		{
			if (crashed || GameManager.CurrentState == GameManager.GameState.InMenus)
			{
				return;
			}
			acceleration = Mathf.Min(1f, acceleration + Time.deltaTime / accelTime);
			if (invincibleTimer > 0f)
			{
				invincibleTimer -= Time.deltaTime;
			}
			float num = moveDis * Time.deltaTime;
			if (!insideTunnel)
			{
				num = 0f - num;
			}
			if (insideTunnel)
			{
				if ((!(num > 0f) || !RBlocked) && (!(num < 0f) || !LBlocked))
				{
					root.Rotate(Vector3.forward, num * SteerSpeed, Space.Self);
				}
			}
			else if ((!(num > 0f) || !LBlocked) && (!(num < 0f) || !RBlocked))
			{
				root.Rotate(Vector3.forward, num * SteerSpeed, Space.Self);
			}
			if (RoadCheck)
			{
				UpdateLocalPos();
			}
			float num2 = 1.25f * Speed * Time.deltaTime;
			if (Physics.BoxCast(base.transform.position - base.transform.right * 0.5f, new Vector3(0.6f, 1f, 0.6f), base.transform.right, out var hitInfo, base.transform.rotation, 1.5f, 1))
			{
				TryPlayFlash(hitInfo.collider, hitInfo.point);
			}
			if (Physics.BoxCast(base.transform.position + base.transform.right * 0.5f, new Vector3(0.6f, 1f, 0.6f), -base.transform.right, out hitInfo, base.transform.rotation, 1.5f, 1))
			{
				TryPlayFlash(hitInfo.collider, hitInfo.point);
			}
			if (Physics.BoxCast(base.transform.position - base.transform.up * 1.44f - base.transform.right * 0.7f, new Vector3(0.6f, 0.1f, 0.6f), base.transform.right, base.transform.rotation, 1.5f, 2048))
			{
				RBlocked = true;
				while (Physics.BoxCast(base.transform.position - base.transform.up * 1.44f - base.transform.right * 0.7f, new Vector3(0.6f, 0.1f, 0.6f), base.transform.right, base.transform.rotation, 1.3f, 2048))
				{
					root.Rotate(Vector3.forward, -1f, Space.Self);
				}
			}
			else
			{
				RBlocked = false;
			}
			if (Physics.BoxCast(base.transform.position - base.transform.up * 1.44f + base.transform.right * 0.7f, new Vector3(0.6f, 0.1f, 0.6f), -base.transform.right, base.transform.rotation, 1.5f, 2048))
			{
				LBlocked = true;
				while (Physics.BoxCast(base.transform.position - base.transform.up * 1.44f + base.transform.right * 0.7f, new Vector3(0.6f, 0.1f, 0.6f), -base.transform.right, base.transform.rotation, 1.3f, 2048))
				{
					root.Rotate(Vector3.forward, 1f, Space.Self);
				}
			}
			else
			{
				LBlocked = false;
			}
			if (CheckDropEnabled && !isJumping && !isInvincible && !FlyState)
			{
				if (InsideTunnel)
				{
					if (Physics.SphereCast(base.transform.position + base.transform.up * DropRadius, DropRadius, -base.transform.up, out hitInfo, 20f))
					{
						UnityEngine.Debug.DrawLine(base.transform.position, hitInfo.point);
					}
					if (Physics.SphereCast(base.transform.position + base.transform.up * DropRadius, DropRadius, -base.transform.up, out hitInfo, 20f) && hitInfo.collider.gameObject.layer == 10)
					{
						DoDrop();
					}
				}
				else
				{
					if (Physics.SphereCast(Vector3.zero, DropRadius, base.transform.up, out hitInfo, 30f))
					{
						UnityEngine.Debug.DrawLine(Vector3.zero, hitInfo.point);
					}
					if (Physics.SphereCast(Vector3.zero, DropRadius, base.transform.up, out hitInfo, 30f) && hitInfo.collider.gameObject.layer == 10)
					{
						DoDrop();
					}
				}
			}
			if (Physics.BoxCast(base.transform.position - ItemcollisionRadius * Vector3.forward, new Vector3(ItemcollisionRadius, 3f, ItemcollisionRadius), base.transform.forward, out hitInfo, base.transform.rotation, num2 + 2f * ItemcollisionRadius, 512) && hitInfo.collider.gameObject.layer == interactLayer)
			{
				Interactable componentInParent = hitInfo.collider.gameObject.GetComponentInParent<Interactable>();
				if (componentInParent != null)
				{
					componentInParent.OnCollected();
					if (csPlayerData.VibrationSwitch)
					{
						csControllerForSteamVR.TriggerHapticPulse_OC(ISLeftMove, 1500);
					}
				}
			}
			if (!Physics.SphereCast(base.transform.position - collisionRadius * Vector3.forward, collisionRadius, Vector3.forward, out hitInfo, num2 + 2f * collisionRadius) || hitInfo.collider.gameObject.layer == interactLayer || hitInfo.collider.gameObject.layer == 11 || hitInfo.collider.gameObject.layer == 12 || hitInfo.collider.gameObject.layer == 13)
			{
				return;
			}
			if (hitInfo.collider.gameObject.layer == 4)
			{
				csTutorialTrigger componentInParent2 = hitInfo.collider.gameObject.GetComponentInParent<csTutorialTrigger>();
				if ((bool)componentInParent2 && !componentInParent2.IsUsed)
				{
					componentInParent2.IsUsed = true;
					csTutorialManager.instance.SetTutorialState(componentInParent2.TriggerState);
				}
			}
			else if (!(invincibleTimer > 0f) && !InvicibleState)
			{
				if (InRushState)
				{
					SoundManager.PlaySfx("Hit");
					cameraShake.Shake(0.1f);
					GameManager.FlashScreen();
				}
				else if (InSheildState && numSheilds > 0)
				{
					acceleration = 0.3f;
					numSheilds--;
					SoundManager.PlaySfx("Hit");
					invincibleTimer = 2f;
					cameraShake.Shake(0.2f);
					GameManager.FlashScreen();
				}
				else if (!isInvincible)
				{
					OnWallHit(hitInfo.point, hitInfo.collider.GetComponent<csTunnelColorChild>());
				}
			}
		}

		public void SetSheildOn()
		{
			SheildObject.SetActive(value: true);
			numSheilds = 1;
			GameManager.MenuSystem.HUD.AddBuffHint(PreObjectType.Sheild, SheildTime);
			if (!InSheildState)
			{
				InSheildState = true;
				StartCoroutine(SheildTimer());
			}
			else if (SheildTime > stimer)
			{
				stimer = SheildTime;
			}
			GameManager.instance.m_InGameMissionData.AddPreObjectTimes(PreObjectType.Sheild);
		}

		private IEnumerator SheildTimer()
		{
			ASSSelfLoop.clip = ShiledAC_Loop;
			ASSSelfLoop.Play();
			stimer = SheildTime;
			while (stimer > 0f && numSheilds > 0)
			{
				stimer -= Time.deltaTime;
				yield return new WaitForEndOfFrame();
			}
			GameManager.MenuSystem.HUD.OnBuffEnd(PreObjectType.Sheild);
			numSheilds = 0;
			InSheildState = false;
			SheildObject.SetActive(value: false);
			if (!InRushState && !InMagState && !InSheildState)
			{
				ASSSelfLoop.Stop();
			}
			ASSSelf.PlayOneShot(PropEndAC);
		}

		public void SetRushOn()
		{
			RushPowerObject.SetActive(value: true);
			GameManager.MenuSystem.HUD.AddBuffHint(PreObjectType.RushPower, RushTime);
			if (!InRushState)
			{
				InRushState = true;
				StartCoroutine(RushTimer(RushTime));
			}
			else if (RushTime > Rtimer)
			{
				Rtimer = RushTime;
			}
			GameManager.instance.m_InGameMissionData.AddPreObjectTimes(PreObjectType.RushPower);
		}

		private IEnumerator RushTimer(float rt)
		{
			ASSSelfLoop.clip = SpeedUpAC_Loop;
			ASSSelfLoop.Play();
			Rtimer = rt;
			while (Rtimer > 0f && InRushState)
			{
				Rtimer -= Time.deltaTime;
				yield return new WaitForEndOfFrame();
			}
			RushPowerObject.SetActive(value: false);
			InRushState = false;
			if (!InRushState && !InMagState && !InSheildState)
			{
				ASSSelfLoop.Stop();
			}
			ASSSelf.PlayOneShot(PropEndAC);
		}

		public void SetMagOn()
		{
			MagPowerObject.SetActive(value: true);
			GameManager.MenuSystem.HUD.AddBuffHint(PreObjectType.Magnet, MagTime);
			if (!InMagState)
			{
				InMagState = true;
				StartCoroutine(MagTimer());
			}
			else
			{
				Mtimer = MagTime;
			}
			GameManager.instance.m_InGameMissionData.AddPreObjectTimes(PreObjectType.Magnet);
		}

		private IEnumerator MagTimer()
		{
			ASSSelfLoop.clip = MagnetAC_Loop;
			ASSSelfLoop.Play();
			Mtimer = MagTime;
			while (InMagState && Mtimer > 0f)
			{
				yield return new WaitForSeconds(0.1f);
				Mtimer -= 0.1f;
				foreach (LevelBlock item in GameManager.LevelManager.GetCurBlock())
				{
					foreach (csGoldCoin coinTrans in item.CoinTransList)
					{
						if (Vector3.Distance(coinTrans.thisT.position, base.transform.position) < MagTriggerDistance)
						{
							coinTrans.TriggerMag();
						}
					}
				}
			}
			InMagState = false;
			if (!InRushState && !InMagState && !InSheildState)
			{
				ASSSelfLoop.Stop();
			}
			ASSSelf.PlayOneShot(PropEndAC);
			MagPowerObject.SetActive(value: false);
		}

		public void LevelEndCloseEffect()
		{
			SheildObject.SetActive(value: false);
			RushPowerObject.SetActive(value: false);
			MagPowerObject.SetActive(value: false);
			ASSSelfLoop.Stop();
		}

		public void BindHorse()
		{
			SetHorseBasic();
			curHorse.LookAtTarget = curHorse.HorseModelController.LookTarget;
			RopeStarts[0].SetParent(curHorse.HorseModelController.RopeStartTL);
			RopeStarts[1].SetParent(curHorse.HorseModelController.RopeStartTR);
			Transform obj = RopeStarts[0];
			Vector3 localPosition = (RopeStarts[1].localPosition = Vector3.zero);
			obj.localPosition = localPosition;
			Transform obj2 = RopeStarts[0];
			localPosition = (RopeStarts[1].localEulerAngles = Vector3.zero);
			obj2.localEulerAngles = localPosition;
			GameManager.MenuSystem.HUD.InitHeartNum(hd.BasicData.LifeMax + AddHeartNum);
			curHorse.HorseModelController.SetRun(isRun: true);
			GameManager.instance.PlayerHMDiniter.SetOffset(curHorse.HorseModelController.CamYOffset);
			GameManager.instance.SetCanvasOffset(curHorse.HorseModelController.CamYOffset);
			ParticleParentT.localPosition = new Vector3(0f, curHorse.HorseModelController.CamYOffset, 0f);
			InitSkillData();
		}

		private void InitSkillData()
		{
			SheildTime = csGameSettings.SheildTime;
			MagTime = csGameSettings.MagTime;
			RushTime = csGameSettings.RushTime;
			if (ForceSkill)
			{
				HorseSkillDic[ForceSkillType] = true;
				if (ForceSkillType == HorseSkill.Sprint)
				{
					RushSkillTime = ForceSkillTime;
					RushSkillCD = ForceSkillCD;
				}
				if (ForceSkillType == HorseSkill.Invincible)
				{
					InvinceAbleTime = ForceSkillTime;
					InvinceAbleCD = ForceSkillCD;
				}
				if (ForceSkillType == HorseSkill.Slow)
				{
					SlowTime = ForceSkillTime;
					SlowCD = ForceSkillCD;
				}
				if (ForceSkillType == HorseSkill.Jump)
				{
					JumpTime = ForceSkillTime;
					JumpCD = ForceSkillCD;
				}
				if (ForceSkillType == HorseSkill.Strike)
				{
					StrikeTime = ForceSkillTime;
					StrikeCD = ForceSkillCD;
				}
				if (ForceSkillType == HorseSkill.Anticol)
				{
					AnticolTime = ForceSkillTime;
					AnticolCD = ForceSkillCD;
				}
				if (ForceSkillType == HorseSkill.ShieldBuff)
				{
					SheildTime *= 1f + ForceSkillTime;
				}
				if (ForceSkillType == HorseSkill.Fly)
				{
					FlyTime = ForceSkillTime;
					FlyCD = ForceSkillCD;
				}
				List<HorseSkill> list = new List<HorseSkill>();
				list.Add(ForceSkillType);
				List<float> list2 = new List<float>();
				list2.Add(ForceSkillCD);
				GameManager.MenuSystem.HUD.SetSkillHint(list, list2);
				return;
			}
			foreach (HorseSkill effectSkillID in hd.SkillData.EffectSkillIDList)
			{
				HorseSkillDic[effectSkillID] = true;
			}
			List<float> list3 = new List<float>();
			if (hd.SkillData.EffectSkillIDList.Contains(HorseSkill.Sprint))
			{
				RushSkillTime = hd.SkillData.SkillTimeFactor * csGameData.Instance.SkillTypeToDataDic[HorseSkill.Sprint].LevelData[horseSpecLevel].EffectTime;
				RushSkillCD = hd.SkillData.SkillCDFactor * csGameData.Instance.SkillTypeToDataDic[HorseSkill.Sprint].LevelData[horseSpecLevel].CDTime;
				list3.Add(RushSkillCD);
			}
			if (hd.SkillData.EffectSkillIDList.Contains(HorseSkill.Invincible))
			{
				InvinceAbleTime = hd.SkillData.SkillTimeFactor * csGameData.Instance.SkillTypeToDataDic[HorseSkill.Invincible].LevelData[horseSpecLevel].EffectTime;
				InvinceAbleCD = hd.SkillData.SkillCDFactor * csGameData.Instance.SkillTypeToDataDic[HorseSkill.Invincible].LevelData[horseSpecLevel].CDTime;
				list3.Add(InvinceAbleCD);
			}
			if (hd.SkillData.EffectSkillIDList.Contains(HorseSkill.Slow))
			{
				SlowTime = hd.SkillData.SkillTimeFactor * csGameData.Instance.SkillTypeToDataDic[HorseSkill.Slow].LevelData[horseSpecLevel].EffectTime;
				SlowCD = hd.SkillData.SkillCDFactor * csGameData.Instance.SkillTypeToDataDic[HorseSkill.Slow].LevelData[horseSpecLevel].CDTime;
				list3.Add(SlowCD);
			}
			if (hd.SkillData.EffectSkillIDList.Contains(HorseSkill.Jump))
			{
				JumpTime = hd.SkillData.SkillTimeFactor * csGameData.Instance.SkillTypeToDataDic[HorseSkill.Jump].LevelData[horseSpecLevel].EffectTime;
				JumpCD = hd.SkillData.SkillCDFactor * csGameData.Instance.SkillTypeToDataDic[HorseSkill.Jump].LevelData[horseSpecLevel].CDTime;
				list3.Add(JumpCD);
			}
			if (hd.SkillData.EffectSkillIDList.Contains(HorseSkill.Strike))
			{
				StrikeTime = hd.SkillData.SkillTimeFactor * csGameData.Instance.SkillTypeToDataDic[HorseSkill.Strike].LevelData[horseSpecLevel].EffectTime;
				StrikeCD = hd.SkillData.SkillCDFactor * csGameData.Instance.SkillTypeToDataDic[HorseSkill.Strike].LevelData[horseSpecLevel].CDTime;
				list3.Add(StrikeCD);
			}
			if (hd.SkillData.EffectSkillIDList.Contains(HorseSkill.Anticol))
			{
				AnticolTime = hd.SkillData.SkillTimeFactor * csGameData.Instance.SkillTypeToDataDic[HorseSkill.Anticol].LevelData[horseSpecLevel].EffectTime;
				AnticolCD = hd.SkillData.SkillCDFactor * csGameData.Instance.SkillTypeToDataDic[HorseSkill.Anticol].LevelData[horseSpecLevel].CDTime;
				list3.Add(AnticolCD);
			}
			if (hd.SkillData.EffectSkillIDList.Contains(HorseSkill.ShieldBuff))
			{
				SheildTime = csGameSettings.SheildTime * (1f + hd.SkillData.SkillTimeFactor * csGameData.Instance.SkillTypeToDataDic[HorseSkill.ShieldBuff].LevelData[horseSpecLevel].EffectTime);
				list3.Add(99f);
			}
			if (hd.SkillData.EffectSkillIDList.Contains(HorseSkill.Roar))
			{
				RoarCD = hd.SkillData.SkillCDFactor * csGameData.Instance.SkillTypeToDataDic[HorseSkill.Roar].LevelData[horseSpecLevel].CDTime;
				list3.Add(99f);
			}
			if (hd.SkillData.EffectSkillIDList.Contains(HorseSkill.Fly))
			{
				FlyTime = hd.SkillData.SkillTimeFactor * csGameData.Instance.SkillTypeToDataDic[HorseSkill.Fly].LevelData[horseSpecLevel].EffectTime;
				FlyCD = hd.SkillData.SkillCDFactor * csGameData.Instance.SkillTypeToDataDic[HorseSkill.Fly].LevelData[horseSpecLevel].CDTime;
				list3.Add(FlyCD);
			}
			if (hd.SkillData.EffectItemIDList.Contains(PreObjectType.Sheild))
			{
				SheildTime *= hd.SkillData.ItemTimeFactor;
			}
			if (hd.SkillData.EffectItemIDList.Contains(PreObjectType.RushPower))
			{
				RushTime *= hd.SkillData.ItemTimeFactor;
			}
			if (hd.SkillData.EffectItemIDList.Contains(PreObjectType.Magnet))
			{
				MagTime *= hd.SkillData.ItemTimeFactor;
			}
			for (int i = 0; i < hd.SkillData.EffectSkillIDList.Count; i++)
			{
				UnityEngine.Debug.Log(hd.SkillData.EffectSkillIDList[i]);
			}
			GameManager.MenuSystem.HUD.SetSkillHint(hd.SkillData.EffectSkillIDList, list3);
		}

		private void SetHorseBasic()
		{
			CurHorseData = csGameData.Instance.HorseTypeToDataDic[csGameSettings.PlayerHorseType];
			horseBasicLevel = csPlayerData.GetHorseBasicLevelInPlayerPrefs(csGameSettings.PlayerHorseType);
			horseSpecLevel = csPlayerData.GetHorseSpecialLevelInPlayerPrefs(csGameSettings.PlayerHorseType);
			hd = new HorseDataInGame(CurHorseData.HosrseType, CurHorseData.HorseNameID, CurHorseData.Price, CurHorseData.BasicDataByLevel[horseBasicLevel], CurHorseData.SkillDataByLevel[horseSpecLevel]);
			baseSpeed = 50f;
			decreasingSpeed = 0f;
			maxSpeed = 100f;
			inscreaseSpeed = 0f;
			for (int i = 0; i < csPlayerData.LevelBuffList.Count; i++)
			{
				AheadBuff aheadBuff = csPlayerData.LevelBuffList[i];
				if (aheadBuff == AheadBuff.AddLifeS)
				{
					DoAddLifeBuff((int)csPlayerData.GetAheadBuffValue(AheadBuff.AddLifeS));
				}
			}
			HP = hd.BasicData.LifeMax + AddHeartNum;
			GameManager.MenuSystem.HUD.SetHPNum(HP);
		}

		public void SetTutorialState(int State)
		{
			switch (State)
			{
			case 0:
				InTutorial = true;
				CantMoveByTutorial = true;
				break;
			case 1:
				CantMoveByTutorial = true;
				forceTurnSpeed = 0f;
				speedMultiplier = 0f;
				break;
			case 2:
				CantMoveByTutorial = false;
				GetTSpeed = false;
				forceTurnSpeed = -0.5f;
				tutorialrotateSpeed = 0f;
				speedMultiplier = 1f;
				break;
			case 3:
				CantMoveByTutorial = false;
				GetTSpeed = false;
				forceTurnSpeed = 0.5f;
				tutorialrotateSpeed = 0f;
				speedMultiplier = 1f;
				break;
			case 5:
				CantMoveByTutorial = false;
				break;
			case 4:
				speedMultiplier = 1f;
				CantMoveByTutorial = false;
				InTutorial = false;
				break;
			}
		}
	}
	public abstract class Interactable : MonoBehaviour
	{
		public virtual void OnCollected()
		{
			Apply();
			UnityEngine.Object.Destroy(this);
		}

		protected abstract void Apply();
	}
	public class LevelBlock : MonoBehaviour
	{
		public bool RandomRotate = true;

		[SerializeField]
		[HideInInspector]
		private float length = 50f;

		public csTunnelColorChild[] mrs;

		public int blockIndex;

		public int blockMax;

		public int CurSection;

		public GameObject[] ActiveAfterObjs;

		public List<GameObject> PropsObjList = new List<GameObject>();

		public List<csGoldCoin> CoinTransList = new List<csGoldCoin>();

		private bool Cleared;

		public float BlockLength => length;

		private void AddMRToList()
		{
			for (int i = 0; i < mrs.Length; i++)
			{
				LevelManager.Instance.allBlockMR.Add(mrs[i]);
			}
		}

		public void RemoveMRFromList()
		{
			for (int i = 0; i < mrs.Length; i++)
			{
				LevelManager.Instance.allBlockMR.Remove(mrs[i]);
			}
		}

		public void SetTunnelRot(int rotIndex)
		{
			if (rotIndex % 2 == 0)
			{
				return;
			}
			for (int i = 0; i < mrs.Length; i++)
			{
				if (mrs[i].gameObject.name.Contains("Tunnel") || mrs[i].gameObject.name.Contains("Outside"))
				{
					mrs[i].mr.material.SetTextureOffset("_MainTex", new Vector2((float)rotIndex * 0.125f, 0f));
					mrs[i].mr.material.SetTextureOffset("_EmissionTex", new Vector2((float)rotIndex * 0.125f, 0f));
				}
			}
		}

		private void OnDisable()
		{
			RemoveMRFromList();
		}

		private void OnEnable()
		{
			AddMRToList();
		}

		public void DestroyPropShowCase()
		{
			csPropIniter[] componentsInChildren = GetComponentsInChildren<csPropIniter>();
			for (int i = 0; i < componentsInChildren.Length; i++)
			{
				componentsInChildren[i].DestroyShowCase();
			}
		}

		public void InitProps()
		{
			csPropIniter[] componentsInChildren = GetComponentsInChildren<csPropIniter>();
			foreach (csPropIniter csPropIniter in componentsInChildren)
			{
				if (csPropIniter.PropObjType == PreObjectType.GoldCoin || UnityEngine.Random.Range(0, 100) <= 50)
				{
					GameObject objectByType = Multi_csObjectPool.Instance.GetObjectByType(csPropIniter.PropObjType, csPropIniter.transform.position, csPropIniter.transform.forward);
					objectByType.transform.SetParent(csPropIniter.thisT);
					PropsObjList.Add(objectByType);
					if (csPropIniter.PropObjType == PreObjectType.GoldCoin)
					{
						CoinTransList.Add(Multi_csObjectPool.Instance.GoldScriptByObj(objectByType));
					}
				}
			}
		}

		private void OnDestroy()
		{
			ClearNoUseProps();
		}

		public void ClearNoUseProps()
		{
			if (Cleared)
			{
				return;
			}
			Cleared = true;
			foreach (GameObject propsObj in PropsObjList)
			{
				Multi_csObjectPool.Instance.ReturnGameObjectIntoPool(propsObj, delay: false);
			}
		}

		public void CalcBounds()
		{
			mrs = GetComponentsInChildren<csTunnelColorChild>();
			MeshFilter[] componentsInChildren = GetComponentsInChildren<MeshFilter>();
			float num = float.MaxValue;
			float num2 = float.MinValue;
			foreach (MeshFilter obj in componentsInChildren)
			{
				Bounds bounds = obj.sharedMesh.bounds;
				Vector3 vector = obj.transform.TransformPoint(bounds.min);
				Vector3 vector2 = obj.transform.TransformPoint(bounds.max);
				num = Mathf.Min(num, Mathf.Min(vector.z, vector2.z));
				num2 = Mathf.Max(num2, Mathf.Max(vector.z, vector2.z));
			}
			length = num2 - num;
			GameObject[] activeAfterObjs = ActiveAfterObjs;
			for (int j = 0; j < activeAfterObjs.Length; j++)
			{
				activeAfterObjs[j].SetActive(value: true);
			}
		}
	}
	public class LevelManager : MonoBehaviour
	{
		[Tooltip("Visible length of the tunnel")]
		public float tunnelLength = 500f;

		[Tooltip("How 'bendy' is the tunnel")]
		public float bendFreq = 0.1f;

		public int LastGoUpState;

		public int TunnelGoUpState;

		public float ZPosStart;

		[Tooltip("How large are the bends in the tunnel")]
		public float bendAmp = 10f;

		private int rndSectionCount;

		private LevelSection[] sections;

		[HideInInspector]
		public List<LevelSection> sectionsChallengeLevel = new List<LevelSection>();

		private Dictionary<int, int> ChallengeLToSectionId = new Dictionary<int, int>();

		private List<LevelBlock> activeBlocks;

		private int currentSectionIdx;

		private float currentZ;

		private float zOffset;

		private float ScoreThisRun;

		private Vector3 cameraOffset;

		private bool enableGeneration = true;

		private PlayerControl player;

		private static LevelManager instance;

		public static LevelManager Instance;

		public Color sceneColor;

		public int fogColorIndex;

		[Tooltip("节奏高于该值时才取来变色")]
		public float beatStartPoint = 0.015f;

		public Color[] fogColorList;

		public List<csTunnelColorChild> allBlockMR = new List<csTunnelColorChild>();

		[Tooltip("是否强制进入某一关卡")]
		[Header("是否强制进入某一关卡")]
		public bool ForceLevel;

		[Tooltip("强制进入关卡Index,例：Section1,填入1")]
		[Header("强制进入关卡Index,例：Section1,填入1")]
		public int ForceSectionIndex = 10;

		[Header("强制进入关卡速度,负数为按实际速度来,正数,将人物初始速度设为该速度")]
		public float ForceSpeed = -1f;

		[Header("速度特效基础速度")]
		public float SpeedEffectBaseSpeed = 60f;

		[Header("速度特效基础乘数")]
		public float SpeedEMultiplier = 1f;

		public Transform FarSceneT;

		[HideInInspector]
		public bool SyncFarScenePos;

		[HideInInspector]
		public bool FarSceneMoveEnabled = true;

		public float FarSceneSpeed = 5f;

		[Header("远景生成列表")]
		public List<GameObject> TunnelYJ;

		[Header("远景生成最小间隔时间")]
		public float MinYJGap = 5f;

		[Header("远景生成最大间隔时间")]
		public float MaxYJGap = 10f;

		private float thisYJInitTime;

		private float thisYJGapTime;

		private float duration = 5f;

		private float smoothness = 0.02f;

		[HideInInspector]
		public int CoinGetThisRun;

		public int CoinGetTotal;

		public float GoldScoreAddMultipliter = 1f;

		public int StartLevel = 1;

		public float HitScoreAddMultipliter = 1f;

		public float HitPercent = 0.05f;

		private float XOffsetRec;

		private float YOffsetRec;

		private int TunnelYJIndex;

		[Header("每x米生成道具")]
		public float PropInitDistance = 200f;

		[Header("道具生成时里玩家的距离")]
		public Vector3 PropPos = new Vector3(0f, 0f, 200f);

		private float CurPorpDist;

		[Header("每x米生成怪物")]
		private float MonsterInitDistance = 20f;

		private float CurMonsterDist;

		[Header("道具权重列表")]
		public List<PropObjRight> PropRightL = new List<PropObjRight>();

		private int maxValue;

		public GameObject[] ViewObjs;

		public float RealDistance => zOffset;

		public float TotalDistance => ScoreThisRun;

		public float BendAmplitude => bendAmp;

		public float TunnelLength => tunnelLength;

		public Vector3 CameraOffset => cameraOffset;

		public bool EnableGeneration
		{
			get
			{
				return enableGeneration;
			}
			set
			{
				instance.enableGeneration = value;
			}
		}

		private void Awake()
		{
			if (Instance == null)
			{
				Instance = this;
			}
			PorpAwake();
			RndYJTime();
		}

		private IEnumerator LerpColor()
		{
			float progress = 0f;
			float increment = smoothness / duration;
			while (progress < 1f)
			{
				if (GameManager.Player.cam != null)
				{
					Color fogColor = (GameManager.Player.cam.backgroundColor = Color.Lerp(GameManager.Player.cam.backgroundColor, fogColorList[fogColorIndex], progress));
					RenderSettings.fogColor = fogColor;
					if (csGameSettings.Channel == ChannelType.OculusGO)
					{
						Camera waveLCam = csHMDIniter.instance.CurrentSetter.WaveLCam;
						fogColor = (csHMDIniter.instance.CurrentSetter.WaveRCam.backgroundColor = RenderSettings.fogColor);
						waveLCam.backgroundColor = fogColor;
					}
				}
				for (int i = 0; i < allBlockMR.Count; i++)
				{
					if (allBlockMR[i].IsActive())
					{
						if (allBlockMR[i].mr.sharedMaterial.HasProperty("_EmissionColor"))
						{
							allBlockMR[i].mr.sharedMaterial.SetColor("_EmissionColor", Color.Lerp(allBlockMR[i].mr.sharedMaterial.GetColor("_EmissionColor"), fogColorList[fogColorIndex], progress));
						}
					}
					else
					{
						UnityEngine.Debug.Log("Remove Block" + i);
						allBlockMR.RemoveAt(i);
					}
				}
				progress += increment;
				yield return new WaitForSeconds(smoothness);
			}
			duration = 5f;
			fogColorIndex = UnityEngine.Random.Range(0, fogColorList.Length);
			StartCoroutine(LerpColor());
		}

		private void Start()
		{
			instance = this;
			sections = GetComponentsInChildren<LevelSection>();
			player = UnityEngine.Object.FindObjectOfType<PlayerControl>();
			activeBlocks = new List<LevelBlock>();
			if (csGameSettings.CurrentGameMode == GameMode.LevelMode)
			{
				for (int i = 0; i < sections.Length; i++)
				{
					if (sections[i].isRndLevel)
					{
						rndSectionCount++;
						if (sections[i].isDefaultSection)
						{
							sections[i].Initialise();
						}
						continue;
					}
					sectionsChallengeLevel.Add(sections[i]);
					ChallengeLToSectionId.Add(sectionsChallengeLevel.Count, i);
					if (csGameSettings.CurrentSelectedLevel - 1 == sectionsChallengeLevel.Count - 1)
					{
						sections[i].Initialise();
					}
				}
			}
			else
			{
				for (int j = 0; j < sections.Length; j++)
				{
					if (sections[j].isRndLevel)
					{
						rndSectionCount++;
						sections[j].Initialise();
					}
					else
					{
						sectionsChallengeLevel.Add(sections[j]);
					}
				}
			}
			StartCoroutine("LerpColor");
			RenderSettings.fogStartDistance = 50f;
			RenderSettings.fogEndDistance = 200f;
			RenderSettings.fog = true;
			enableGeneration = true;
		}

		private void OnDestroy()
		{
			Shader.SetGlobalFloat("_ZOffset", 0f);
			Shader.SetGlobalFloat("_Bend", 0f);
			Shader.SetGlobalFloat("_BendFreq", 1f);
			Shader.SetGlobalVector("_CameraOffset", Vector3.zero);
		}

		public void OnCoinGet(int num = 1)
		{
			CoinGetThisRun += num;
			GameManager.MenuSystem.HUD.OnCoinGet();
			int num2 = 0;
			num2 = ((CoinGetThisRun < 100) ? ((int)(20f * GoldScoreAddMultipliter)) : ((CoinGetThisRun < 200) ? ((int)(40f * GoldScoreAddMultipliter)) : ((CoinGetThisRun < 300) ? ((int)(60f * GoldScoreAddMultipliter)) : ((CoinGetThisRun >= 400) ? ((int)(100f * GoldScoreAddMultipliter)) : ((int)(80f * GoldScoreAddMultipliter))))));
			ScoreThisRun += num2;
			GameManager.MenuSystem.HUD.OnAddScore(num2);
			GameManager.MenuSystem.HUD.UpdateCoinNum();
		}

		public void OnCoinGetOnlyCoin(int num = 1)
		{
			CoinGetThisRun += num;
			GameManager.MenuSystem.HUD.OnCoinGet();
			GameManager.MenuSystem.HUD.UpdateCoinNum();
		}

		public void OnScoreGet(int num)
		{
			ScoreThisRun += num;
			if (ScoreThisRun < 0f)
			{
				ScoreThisRun = 0f;
			}
			if (num > 0)
			{
				GameManager.MenuSystem.HUD.OnAddScore(num);
			}
			else
			{
				GameManager.MenuSystem.HUD.OnMinusScore(Mathf.Abs(num));
			}
		}

		public void OnHitChange()
		{
			int num = (int)(ScoreThisRun * HitPercent);
			ScoreThisRun -= num;
			GameManager.MenuSystem.HUD.OnMinusScore(num);
		}

		public void ResetAfterTutorial(bool skipLevel)
		{
			CoinGetThisRun = 0;
			zOffset = 0f;
			if (skipLevel)
			{
				currentSectionIdx = 2 + csPlayerData.HighestEndlessLevel % 60 / 10 * 10;
				GameManager.instance.Level = csPlayerData.HighestEndlessLevel / 10 * 10 + 1;
				StartLevel = GameManager.instance.Level;
			}
		}

		public void Reset()
		{
			GameManager.MenuSystem.HUD.SetProgressValue(0f, isReset: true);
			CoinGetThisRun = 0;
			GameManager.MenuSystem.HUD.UpdateCoinNum();
			currentZ = 0f;
			zOffset = 0f;
			ScoreThisRun = 0f;
			currentSectionIdx = 0;
			enableGeneration = true;
			for (int i = 0; i < sections.Length; i++)
			{
				sections[i].Reset();
			}
			for (int j = 0; j < activeBlocks.Count; j++)
			{
				activeBlocks[j].RemoveMRFromList();
				UnityEngine.Object.Destroy(activeBlocks[j].gameObject);
			}
			activeBlocks.Clear();
		}

		public void StartGame(bool withTutorial, bool skipLevel)
		{
			Reset();
			GameManager.MenuSystem.HUD.SetProgressValue(0f, isReset: true);
			if (withTutorial)
			{
				currentSectionIdx = 1;
				sections[currentSectionIdx].StartSection();
				return;
			}
			if (csGameSettings.CurrentGameMode == GameMode.LevelMode)
			{
				currentSectionIdx = ChallengeLToSectionId[csGameSettings.CurrentSelectedLevel];
				sections[currentSectionIdx].StartSection();
				return;
			}
			if (skipLevel)
			{
				currentSectionIdx = 2 + csPlayerData.HighestEndlessLevel % 60 / 10 * 10;
				GameManager.instance.Level = csPlayerData.HighestEndlessLevel / 10 * 10 + 1;
				StartLevel = GameManager.instance.Level;
			}
			else
			{
				currentSectionIdx = 2;
				StartLevel = 1;
			}
			sections[currentSectionIdx].StartSection();
		}

		public Vector3 CalcOffset(float zPos)
		{
			float num = 0.01f * bendFreq * (zPos + zOffset);
			float num2 = Mathf.Sin(num);
			float num3 = Mathf.Sin(num * 1.77f);
			float num4 = Mathf.Sin(num * 0.57f);
			float num5 = Mathf.Sin(num * 0.31f);
			float x = 1f + num4 * (num2 * num3) - num2 * num4 + num5 + XOffsetRec;
			float y = num4 * num3 - num2 * num5 + YOffsetRec;
			return bendAmp * new Vector3(x, y, 0f);
		}

		public Vector3 CalcOffsetFar(float zPos)
		{
			float num = 0.01f * bendFreq * (zPos + zOffset);
			float num2 = Mathf.Sin(num);
			float num3 = Mathf.Sin(num * 1.77f);
			float num4 = Mathf.Sin(num * 0.57f);
			float num5 = Mathf.Sin(num * 0.31f);
			float x;
			float y;
			if (TunnelGoUpState == 0)
			{
				x = 1f + num4 * (num2 * num3) - num2 * num4 + num5;
				y = num4 * num3 - num2 * num5;
			}
			else if (TunnelGoUpState == 1)
			{
				x = 0f;
				y = num * bendFreq;
			}
			else if (TunnelGoUpState == 2)
			{
				x = 0f;
				y = 0f;
			}
			else
			{
				x = 0f;
				y = num * (0f - bendFreq);
			}
			return new Vector3(x, y, 0f);
		}

		public void SetNewGoUpStateOld(int state)
		{
			Vector3 vector = CalcOffsetFar(400f);
			XOffsetRec = vector.x;
			YOffsetRec = vector.y;
			LastGoUpState = TunnelGoUpState;
			TunnelGoUpState = state;
			ZPosStart = 400f;
			Shader.SetGlobalInt("_GoUp", TunnelGoUpState);
			Shader.SetGlobalInt("_LastGoUp", LastGoUpState);
			Shader.SetGlobalFloat("_zPosStart", ZPosStart);
			Shader.SetGlobalFloat("_xOffsetRecord", XOffsetRec);
			Shader.SetGlobalFloat("_yOffsetRecord", YOffsetRec);
		}

		public void SetNewGoUpState(int state)
		{
		}

		public List<LevelBlock> GetCurBlock()
		{
			List<LevelBlock> list = new List<LevelBlock>();
			if (activeBlocks.Count >= 3)
			{
				list.Add(activeBlocks[0]);
				list.Add(activeBlocks[1]);
				list.Add(activeBlocks[2]);
			}
			else if (activeBlocks.Count == 2)
			{
				list.Add(activeBlocks[0]);
				list.Add(activeBlocks[1]);
			}
			else if (activeBlocks.Count == 1)
			{
				list.Add(activeBlocks[0]);
			}
			return list;
		}

		private void Update()
		{
			if (Input.GetKeyDown(KeyCode.DownArrow))
			{
				SetNewGoUpState(3);
			}
			if (Input.GetKeyDown(KeyCode.UpArrow))
			{
				SetNewGoUpState(1);
			}
			if (Input.GetKeyDown(KeyCode.LeftArrow))
			{
				SetNewGoUpState(2);
			}
			if (Input.GetKeyDown(KeyCode.RightArrow))
			{
				SetNewGoUpState(0);
			}
			float num = player.Speed;
			player.SetSpeedEffect(SpeedEMultiplier * ((Mathf.Clamp(num, 30f, 120f) - 30f) / 90f * 45f + 40f) / SpeedEffectBaseSpeed);
			if (GameManager.CurrentState == GameManager.GameState.InMenus)
			{
				num = 20f;
			}
			float num2 = num * Time.deltaTime;
			currentZ -= num2;
			if (FarSceneMoveEnabled)
			{
				thisYJInitTime += Time.deltaTime;
				if (thisYJInitTime > thisYJGapTime)
				{
					TryInitYJ();
				}
				if (SyncFarScenePos)
				{
					FarSceneT.Translate(num2 * Vector3.back);
				}
				else
				{
					FarSceneT.Translate(Time.deltaTime * FarSceneSpeed * Vector3.back);
				}
			}
			for (int i = 0; i < activeBlocks.Count; i++)
			{
				LevelBlock levelBlock = activeBlocks[i];
				Transform obj = levelBlock.transform;
				obj.Translate(num2 * Vector3.back);
				if (obj.position.z + 10f < 0f - levelBlock.BlockLength)
				{
					activeBlocks.Remove(levelBlock);
					levelBlock.RemoveMRFromList();
					activeBlocks.Remove(levelBlock);
					levelBlock.ClearNoUseProps();
					if (levelBlock.CurSection == GameManager.instance.ScetionPassed)
					{
						GameManager.MenuSystem.HUD.SetProgressValue((float)(levelBlock.blockIndex + 1) / (float)levelBlock.blockMax);
					}
					UnityEngine.Object.Destroy(levelBlock.gameObject);
					i--;
				}
			}
			while (enableGeneration && currentZ < tunnelLength)
			{
				if (csGameSettings.CurrentGameMode == GameMode.LevelMode)
				{
					if (currentSectionIdx < 2)
					{
						LevelBlock levelBlock2 = sections[currentSectionIdx].GenerateBlock(currentZ);
						activeBlocks.Add(levelBlock2);
						currentZ += levelBlock2.BlockLength;
						if (!sections[currentSectionIdx].IsSectionCompleted())
						{
							continue;
						}
						currentSectionIdx++;
						if (csGameSettings.CurrentGameMode == GameMode.LevelMode)
						{
							sectionsChallengeLevel[csGameSettings.CurrentSelectedLevel - 1].StartSection();
							continue;
						}
						if (currentSectionIdx >= rndSectionCount)
						{
							currentSectionIdx = 2;
						}
						sections[currentSectionIdx].StartSection();
					}
					else
					{
						LevelBlock levelBlock3 = sectionsChallengeLevel[csGameSettings.CurrentSelectedLevel - 1].GenerateBlock(currentZ);
						activeBlocks.Add(levelBlock3);
						currentZ += levelBlock3.BlockLength;
						if (sections[currentSectionIdx].IsSectionCompleted())
						{
							currentSectionIdx++;
							sectionsChallengeLevel[csGameSettings.CurrentSelectedLevel - 1].StartSection();
						}
					}
					continue;
				}
				LevelBlock levelBlock4 = sections[currentSectionIdx].GenerateBlock(currentZ);
				activeBlocks.Add(levelBlock4);
				currentZ += levelBlock4.BlockLength;
				if (!sections[currentSectionIdx].IsSectionCompleted())
				{
					continue;
				}
				currentSectionIdx++;
				if (csGameSettings.CurrentGameMode == GameMode.LevelMode)
				{
					sectionsChallengeLevel[csGameSettings.CurrentSelectedLevel - 1].StartSection();
					continue;
				}
				if (currentSectionIdx >= rndSectionCount)
				{
					currentSectionIdx = 2;
				}
				sections[currentSectionIdx].StartSection();
			}
			zOffset += num2;
			ScoreThisRun += num2;
			CurPorpDist += num2;
			CurMonsterDist += num2;
			if (CurPorpDist > PropInitDistance)
			{
				TryInitPorp();
				CurPorpDist = 0f;
			}
			if (csGameSettings.WeaponMode && CurMonsterDist > MonsterInitDistance)
			{
				TryInitMonster();
				CurMonsterDist = 0f;
			}
			cameraOffset = CalcOffset(0f);
			Shader.SetGlobalFloat("_ZOffset", zOffset);
			Shader.SetGlobalFloat("_Bend", bendAmp);
			Shader.SetGlobalFloat("_BendFreq", bendFreq);
			if (ZPosStart > 0f)
			{
				ZPosStart -= num2;
			}
			else
			{
				ZPosStart = 0f;
			}
			Shader.SetGlobalVector("_CameraOffset", cameraOffset);
		}

		public void TryInitYJ()
		{
			GameObject obj = UnityEngine.Object.Instantiate(TunnelYJ[TunnelYJIndex]);
			obj.transform.localEulerAngles = Vector3.zero;
			obj.transform.position = new Vector3(0f, 0f, 500f);
			obj.transform.SetParent(FarSceneT);
			TunnelYJIndex++;
			if (TunnelYJIndex >= TunnelYJ.Count)
			{
				TunnelYJIndex = 0;
			}
			RndYJTime();
		}

		public void SetYjSpeed(float s)
		{
			FarSceneSpeed = s;
		}

		public void SetYjSynced(bool isSync)
		{
			SyncFarScenePos = isSync;
		}

		public void SetYjEnabled(bool isEnable)
		{
			FarSceneMoveEnabled = isEnable;
		}

		private void RndYJTime()
		{
			thisYJInitTime = 0f;
			thisYJGapTime = UnityEngine.Random.Range(MinYJGap, MaxYJGap);
		}

		public void PorpAwake()
		{
			for (int i = 0; i < PropRightL.Count; i++)
			{
				maxValue += PropRightL[i].Right;
			}
		}

		public AudioClip GetChanllengeLevelClip()
		{
			return sectionsChallengeLevel[csGameSettings.CurrentSelectedLevel - 1].LevelClip;
		}

		public void TryInitPorp()
		{
			Vector3 postion = Vector3.zero;
			Vector3 upwards = Vector3.zero;
			bool flag = false;
			csTunnelColorChild csTunnelColorChild = null;
			RaycastHit hitInfo;
			if (player.InsideTunnel)
			{
				int num = UnityEngine.Random.Range(0, 8);
				for (int i = 0; i < 8; i++)
				{
					if (Physics.Raycast(PropPos, Quaternion.Euler(0f, 0f, 45 * (i + num)) * -Vector3.up, out hitInfo, 20f))
					{
						csTunnelColorChild = hitInfo.collider.GetComponent<csTunnelColorChild>();
						if ((bool)csTunnelColorChild && csTunnelColorChild.type == SCENEOBJTYPE.WALL)
						{
							postion = hitInfo.point + hitInfo.normal * 1.5f;
							flag = true;
							upwards = hitInfo.normal;
							break;
						}
					}
				}
			}
			else
			{
				int num2 = UnityEngine.Random.Range(0, 8);
				for (int j = 0; j < 8; j++)
				{
					if (Physics.Raycast(PropPos + Quaternion.Euler(0f, 0f, 45 * (j + num2)) * Vector3.up * 20f, Quaternion.Euler(0f, 0f, 45 * (j + num2)) * -Vector3.up, out hitInfo, 20f))
					{
						csTunnelColorChild = hitInfo.collider.GetComponent<csTunnelColorChild>();
						if ((bool)csTunnelColorChild && csTunnelColorChild.type == SCENEOBJTYPE.WALL)
						{
							postion = hitInfo.point + hitInfo.normal * 1.5f;
							flag = true;
							upwards = hitInfo.normal;
							break;
						}
					}
				}
			}
			if (!flag)
			{
				return;
			}
			LevelBlock componentInParent = csTunnelColorChild.GetComponentInParent<LevelBlock>();
			if (!componentInParent)
			{
				return;
			}
			int num3 = UnityEngine.Random.Range(0, maxValue * 100);
			int index = 0;
			for (int k = 0; k < PropRightL.Count; k++)
			{
				if (num3 < PropRightL[k].Right * 100)
				{
					index = k;
					break;
				}
				num3 -= PropRightL[k].Right * 100;
			}
			GameObject objectByType = Multi_csObjectPool.Instance.GetObjectByType(PropRightL[index].ItemType, postion, Vector3.forward);
			objectByType.transform.rotation = Quaternion.LookRotation(Vector3.forward, upwards);
			objectByType.transform.SetParent(componentInParent.transform);
			componentInParent.PropsObjList.Add(objectByType);
		}

		public void TryInitMonster()
		{
			Vector3 postion = Vector3.zero;
			Vector3 upwards = Vector3.zero;
			bool flag = false;
			csTunnelColorChild csTunnelColorChild = null;
			RaycastHit hitInfo;
			if (player.InsideTunnel)
			{
				int num = UnityEngine.Random.Range(0, 8);
				for (int i = 0; i < 8; i++)
				{
					if (Physics.Raycast(PropPos, Quaternion.Euler(0f, 0f, 45 * (i + num)) * -Vector3.up, out hitInfo, 20f))
					{
						csTunnelColorChild = hitInfo.collider.GetComponent<csTunnelColorChild>();
						if ((bool)csTunnelColorChild && csTunnelColorChild.type == SCENEOBJTYPE.WALL)
						{
							postion = hitInfo.point + hitInfo.normal * 1.5f;
							flag = true;
							upwards = hitInfo.normal;
							break;
						}
					}
				}
			}
			else
			{
				int num2 = UnityEngine.Random.Range(0, 8);
				for (int j = 0; j < 8; j++)
				{
					if (Physics.Raycast(PropPos + Quaternion.Euler(0f, 0f, 45 * (j + num2)) * Vector3.up * 20f, Quaternion.Euler(0f, 0f, 45 * (j + num2)) * -Vector3.up, out hitInfo, 20f))
					{
						csTunnelColorChild = hitInfo.collider.GetComponent<csTunnelColorChild>();
						if ((bool)csTunnelColorChild && csTunnelColorChild.type == SCENEOBJTYPE.WALL)
						{
							postion = hitInfo.point + hitInfo.normal * 1.5f;
							flag = true;
							upwards = hitInfo.normal;
							break;
						}
					}
				}
			}
			if (flag)
			{
				LevelBlock componentInParent = csTunnelColorChild.GetComponentInParent<LevelBlock>();
				if ((bool)componentInParent)
				{
					GameObject objectByType = Multi_csObjectPool.Instance.GetObjectByType(PreObjectType.Monster_1, postion, Vector3.forward);
					objectByType.transform.rotation = Quaternion.LookRotation(Vector3.forward, upwards);
					objectByType.transform.SetParent(componentInParent.transform);
					componentInParent.PropsObjList.Add(objectByType);
				}
			}
		}

		public void ResetViewObj()
		{
			GameObject[] viewObjs = ViewObjs;
			for (int i = 0; i < viewObjs.Length; i++)
			{
				viewObjs[i].SetActive(value: false);
			}
			ViewObjs[UnityEngine.Random.Range(0, ViewObjs.Length)].SetActive(value: true);
		}
	}
	public class LevelSection : MonoBehaviour
	{
		public bool isRndLevel = true;

		public bool isDefaultSection;

		public bool ForceInit;

		[Header("当前管道最低速度")]
		public float MinSpeed = 50f;

		[Header("当前管道最高速度")]
		public float MaxSpeed = 60f;

		[Header("加速总时间")]
		public float AddTime = 10f;

		[Header("是否需要远景移动")]
		public bool needVisionMove = true;

		[Header("关卡模式音乐")]
		public AudioClip LevelClip;

		public bool isLevelSection = true;

		private int forceInitId;

		private bool InitAdded;

		[Tooltip("Total number of blocks to generate in this section")]
		public float sectionLength = 10f;

		[Tooltip("Should the z-rotation of the blocks be randomised?")]
		public bool randomiseRotation = true;

		[Tooltip("Optional texture to override on the main tunnel material")]
		public Texture2D overrrideTunnelTexture;

		public Texture2D overrideTunnelEmission;

		[Tooltip("Optional LevelBlock that will always appear first in the section")]
		public LevelBlock firstBlock;

		[Tooltip("Optional LevelBlock that will always appear last in the section")]
		public LevelBlock lastBlock;

		[Tooltip("Array of LevelBlocks to build the section from")]
		public LevelBlock[] blocks;

		[Header("远景生成列表")]
		public List<GameObject> TunnelYJ;

		[Header("远景生成最小间隔管道数")]
		public int MinYJGap = 5;

		[Header("远景生成最大间隔管道数")]
		public int MaxYJGap = 10;

		private int NextGapYJPos = 5;

		private int TunnelYJIndex;

		private Transform activeBlocks;

		private Transform blockPool;

		private int blockCount;

		private string defaultTunnelTextureName = "Grid";

		private int sectionBlockIndex;

		public void Initialise()
		{
			if (blocks.Length == 0)
			{
				UnityEngine.Debug.LogError("No LevelBlock objects found in section " + base.gameObject.name);
				return;
			}
			activeBlocks = new GameObject("ActiveBlocks").transform;
			activeBlocks.SetParent(base.transform);
			blockPool = new GameObject("BlockPool").transform;
			blockPool.gameObject.SetActive(value: false);
			blockPool.SetParent(base.transform);
			if (firstBlock != null)
			{
				InitBlock(firstBlock, isFirst: true);
				sectionLength += 1f;
			}
			if (lastBlock != null)
			{
				InitBlock(lastBlock);
				sectionLength += 1f;
			}
			for (int i = 0; i < blocks.Length; i++)
			{
				InitBlock(blocks[i]);
			}
		}

		private void InitBlock(LevelBlock blockPrefab, bool isFirst = false)
		{
			LevelBlock levelBlock = UnityEngine.Object.Instantiate(blockPrefab);
			levelBlock.DestroyPropShowCase();
			levelBlock.CalcBounds();
			levelBlock.blockMax = (int)sectionLength;
			if (isFirst && (bool)levelBlock.GetComponent<SwitchInsideOutside>())
			{
				levelBlock.GetComponent<SwitchInsideOutside>().LevelSectionS = this;
			}
			MeshFilter[] componentsInChildren = levelBlock.GetComponentsInChildren<MeshFilter>();
			_ = GameManager.LevelManager.BendAmplitude;
			Dictionary<Mesh, Material> dictionary = new Dictionary<Mesh, Material>();
			for (int i = 0; i < componentsInChildren.Length; i++)
			{
				if (!(overrrideTunnelTexture != null) || !(componentsInChildren[i].GetComponent<csTunnelColorChild>() != null))
				{
					continue;
				}
				if (!dictionary.ContainsKey(componentsInChildren[i].sharedMesh))
				{
					Material material = new Material(componentsInChildren[i].GetComponent<Renderer>().sharedMaterial);
					if (material.mainTexture.name == defaultTunnelTextureName)
					{
						material.mainTexture = overrrideTunnelTexture;
						if (overrideTunnelEmission != null)
						{
							material.SetTexture("_EmissionTex", overrideTunnelEmission);
						}
						else
						{
							material.SetTexture("_EmissionTex", overrrideTunnelTexture);
						}
					}
					componentsInChildren[i].GetComponent<Renderer>().sharedMaterial = material;
					dictionary.Add(componentsInChildren[i].sharedMesh, material);
				}
				else
				{
					componentsInChildren[i].GetComponent<Renderer>().sharedMaterial = dictionary[componentsInChildren[i].sharedMesh];
				}
			}
			levelBlock.transform.SetParent(blockPool);
		}

		public void Reset()
		{
			blockCount = 0;
			forceInitId = 0;
			InitAdded = false;
			sectionBlockIndex = 0;
			TunnelYJIndex = 0;
		}

		public void StartSection()
		{
			Reset();
			RandomNextSceneGap();
		}

		private void RandomNextSceneGap()
		{
			NextGapYJPos = UnityEngine.Random.Range(MinYJGap, MaxYJGap + 1);
		}

		public LevelBlock GenerateBlock(float zPos)
		{
			int index;
			if (ForceInit)
			{
				if (blockCount == 0 && firstBlock != null)
				{
					index = 0;
				}
				else if ((float)blockCount == sectionLength - 1f && lastBlock != null)
				{
					index = ((firstBlock != null) ? 1 : 0);
				}
				else
				{
					if (!InitAdded)
					{
						if (firstBlock != null)
						{
							forceInitId++;
						}
						if (lastBlock != null)
						{
							forceInitId++;
						}
						InitAdded = true;
					}
					index = forceInitId;
					forceInitId++;
				}
			}
			else if (blockCount == 0 && firstBlock != null)
			{
				index = 0;
			}
			else if ((float)blockCount == sectionLength - 1f && lastBlock != null)
			{
				index = ((firstBlock != null) ? 1 : 0);
			}
			else
			{
				int num = 0;
				if (firstBlock != null)
				{
					num++;
				}
				if (lastBlock != null)
				{
					num++;
				}
				index = UnityEngine.Random.Range(num, blockPool.childCount);
			}
			Transform transform = UnityEngine.Object.Instantiate(blockPool.GetChild(index));
			transform.SetParent(activeBlocks);
			transform.position = Vector3.forward * zPos;
			LevelBlock component = transform.GetComponent<LevelBlock>();
			sectionBlockIndex++;
			component.blockIndex = sectionBlockIndex;
			component.CurSection = GameManager.instance.ScetionPassed;
			int num2 = 0;
			if (component.RandomRotate && randomiseRotation && !ForceInit)
			{
				num2 = UnityEngine.Random.Range(0, 8);
				transform.localEulerAngles = (float)num2 * 45f * Vector3.forward;
			}
			if (TunnelYJ.Count > 0 && sectionBlockIndex > 0 && sectionBlockIndex % NextGapYJPos == 0)
			{
				RandomNextSceneGap();
				GameObject obj = UnityEngine.Object.Instantiate(TunnelYJ[TunnelYJIndex]);
				obj.transform.SetParent(component.transform);
				obj.transform.localEulerAngles = Vector3.zero;
				obj.transform.localPosition = new Vector3(0f, 0f, -130f);
				TunnelYJIndex++;
				if (TunnelYJIndex >= TunnelYJ.Count)
				{
					TunnelYJIndex = 0;
				}
			}
			component.InitProps();
			if (num2 != 0)
			{
				component.SetTunnelRot(num2);
			}
			if (isLevelSection)
			{
				blockCount++;
			}
			return component;
		}

		public bool IsSectionCompleted()
		{
			return (float)blockCount >= sectionLength;
		}
	}
	public class PositionInTunnel : MonoBehaviour
	{
		private Vector3 startOffset;

		private void Awake()
		{
			startOffset = base.transform.localPosition;
			startOffset.z = 0f;
		}

		private void Update()
		{
			float z = base.transform.position.z;
			Vector3 position = startOffset + GameManager.LevelManager.CalcOffset(z) - GameManager.LevelManager.CameraOffset;
			position.z = z;
			base.transform.position = position;
		}
	}
	public class SectionBreak : Interactable
	{
		[Tooltip("Optional factor to increase the speed by")]
		public float increaseFactor = 1f;

		[Tooltip("Message to display")]
		public string message = "";

		public bool isTutorialEnd;

		public GameObject[] PCParticle;

		public GameObject[] MobileParticle;

		public bool isInner = true;

		private bool EndIsOpen;

		private void Awake()
		{
			if (GameManager.CurrentState == GameManager.GameState.Playing)
			{
				GameManager.LevelManager.EnableGeneration = false;
			}
			GameObject[] pCParticle = PCParticle;
			for (int i = 0; i < pCParticle.Length; i++)
			{
				pCParticle[i].SetActive(value: false);
			}
		}

		private void Update()
		{
			if (EndIsOpen || !(base.transform.position.z < RenderSettings.fogStartDistance + 50f))
			{
				return;
			}
			EndIsOpen = true;
			if (isInner)
			{
				if (csGameSettings.Channel == ChannelType.PC)
				{
					PCParticle[csGameSettings.CurEndParticleIndexInner].SetActive(value: true);
				}
				else
				{
					MobileParticle[csGameSettings.CurEndParticleIndexInner].SetActive(value: true);
				}
				csGameSettings.CurEndParticleIndexInner++;
				if (csGameSettings.CurEndParticleIndexInner >= 5)
				{
					csGameSettings.CurEndParticleIndexInner = 0;
				}
			}
			else
			{
				if (csGameSettings.Channel == ChannelType.PC)
				{
					PCParticle[csGameSettings.CurEndParticleIndexOut].SetActive(value: true);
				}
				else
				{
					MobileParticle[csGameSettings.CurEndParticleIndexOut].SetActive(value: true);
				}
				csGameSettings.CurEndParticleIndexOut++;
				if (csGameSettings.CurEndParticleIndexOut >= 4)
				{
					csGameSettings.CurEndParticleIndexOut = 0;
				}
			}
		}

		protected override void Apply()
		{
			GameManager.MenuSystem.HUD.SetProgressValue(0f, isReset: true);
			GameManager.instance.AddSectionPass();
			GameManager.LevelManager.EnableGeneration = true;
			SoundManager.PlaySfx("LevelPassed");
			if (!isTutorialEnd)
			{
				GameManager.instance.LevelUp();
				base.transform.GetChild(0).gameObject.SetActive(value: false);
				if (message != "")
				{
					GameManager.ShowInfo(message);
				}
			}
			else
			{
				GameManager.instance.LevelReset();
			}
		}
	}
	public class SwitchInsideOutside : MonoBehaviour
	{
		[Tooltip("should we be inside or outside the tunnel from this point?")]
		public bool insideTunnel = true;

		[Tooltip("Distance the player should be from the centre of the tunnel")]
		public float playerRadius = 8f;

		public LevelSection LevelSectionS;

		public bool isTutorialSwitch;

		private void Awake()
		{
			CameraLookAhead component = GameObject.Find("CameraRoot").GetComponent<CameraLookAhead>();
			if (component != null)
			{
				component.InsideTunnel = insideTunnel;
			}
			if (GameManager.NpcPlayers != null)
			{
				NpcPlayer[] npcPlayers = GameManager.NpcPlayers;
				for (int i = 0; i < npcPlayers.Length; i++)
				{
					npcPlayers[i].CamLookAhead.InsideTunnel = insideTunnel;
				}
			}
			PlayerControl player = GameManager.Player;
			if (player != null)
			{
				player.SetLocalPos(playerRadius, insideTunnel);
				player.transform.localPosition = playerRadius * (insideTunnel ? Vector3.down : Vector3.up);
				player.InsideTunnel = insideTunnel;
				if ((bool)LevelSectionS)
				{
					GameManager.LevelManager.SetYjEnabled(LevelSectionS.needVisionMove);
					player.SetPlayerSpeedBySection(LevelSectionS.MinSpeed, LevelSectionS.MaxSpeed, LevelSectionS.AddTime);
					if (!isTutorialSwitch)
					{
						GameManager.Player.TryApplyAheadBuff();
					}
				}
			}
			if (GameManager.NpcPlayers != null)
			{
				NpcPlayer[] npcPlayers = GameManager.NpcPlayers;
				for (int i = 0; i < npcPlayers.Length; i++)
				{
					npcPlayers[i].HorsPosT.localPosition = playerRadius * (insideTunnel ? Vector3.down : Vector3.up);
				}
			}
		}
	}
	public class HUD : MonoBehaviour
	{
		[Tooltip("Time in seconds to show the Arrow images for at the start")]
		public float showArrowsTime = 2f;

		private CanvasGroup canvasGroup;

		private TextMeshProUGUI distanceText;

		private TextMeshProUGUI speedText;

		private TextMeshProUGUI TimeText;

		public GameObject levelTextGameobject;

		private TextMeshProUGUI LevelText;

		private TextMeshProUGUI TempLevelText;

		private TextMeshProUGUI TempGoldCoinText;

		private RectTransform TempGoldCoinT;

		private RectTransform distancePanel;

		private RectTransform speedPanel;

		private RectTransform leftArrow;

		private RectTransform rightArrow;

		public Transform[] HintParntT;

		public Transform[] SkillHintParentT;

		public csHUDSkillHint HintSkill_Sprint;

		public csHUDSkillHint HintSkill_Invince;

		public csHUDSkillHint HintSkill_Slow;

		public csHUDSkillHint HintSkill_Strike;

		public csHUDSkillHint HintSkill_AntiCol;

		public csHUDSkillHint HintSkill_Jump;

		public csHUDSkillHint HintSkill_ShieldBuff;

		public csHUDSkillHint HintSkill_Roar;

		public csHUDSkillHint HintSkill_Fly;

		public csHUDBuffHint HintShield;

		public csHUDBuffHint HintMag;

		public csHUDBuffHint HintRush;

		public List<csHUDBuffHint> CurShowHintList = new List<csHUDBuffHint>();

		public TextMeshProUGUI HeartNumTxt;

		public Image HeartIconImg;

		private Dictionary<HorseSkill, csHUDSkillHint> CurSKillHintDic = new Dictionary<HorseSkill, csHUDSkillHint>();

		public Transform ScoreHintT;

		public List<csUIHintObject> m_UIHintObjectPrefabs = new List<csUIHintObject>();

		private Dictionary<UIHintType, Queue<csScoreHint>> m_HintByType = new Dictionary<UIHintType, Queue<csScoreHint>>();

		private Dictionary<GameObject, csUIHintObject> m_HintObjectByGO = new Dictionary<GameObject, csUIHintObject>();

		private float speedPanelScale;

		public Image LvProgressValue;

		public float MinProgressWid = 358f;

		public float MaxProgressWid = 2048f;

		private Tweener HTweener1;

		private Tweener HTweener2;

		private float AimProgressWid;

		private static DG.Tweening.Tween TTweener;

		public float duration = 1f;

		public float Shackduration = 0.5f;

		private void Awake()
		{
			for (int i = 0; i < m_UIHintObjectPrefabs.Count; i++)
			{
				Queue<csScoreHint> queue = new Queue<csScoreHint>();
				for (int j = 0; j < m_UIHintObjectPrefabs[i].m_MaxSize; j++)
				{
					GameObject gameObject = UnityEngine.Object.Instantiate(m_UIHintObjectPrefabs[i].m_Object);
					gameObject.transform.SetParent(base.transform);
					queue.Enqueue(gameObject.GetComponent<csScoreHint>());
					m_HintObjectByGO[gameObject] = m_UIHintObjectPrefabs[i];
					gameObject.SetActive(value: false);
				}
				m_HintByType[m_UIHintObjectPrefabs[i].m_Type] = queue;
			}
			canvasGroup = GetComponent<CanvasGroup>();
			distancePanel = base.transform.Find("DistancePanel").GetComponent<RectTransform>();
			speedPanel = base.transform.Find("SpeedPanel").GetComponent<RectTransform>();
			speedPanelScale = speedPanel.localScale.x;
			distanceText = distancePanel.Find("BG/Distance").GetComponent<TextMeshProUGUI>();
			speedText = speedPanel.Find("BG/Speed").GetComponent<TextMeshProUGUI>();
			leftArrow = base.transform.Find("LeftArrow").GetComponent<RectTransform>();
			rightArrow = base.transform.Find("RightArrow").GetComponent<RectTransform>();
			LevelText = base.transform.Find("RoadProgressBar/LV/LevelText").GetComponent<TextMeshProUGUI>();
			TempLevelText = speedPanel.Find("BG/TempLevelText").GetComponent<TextMeshProUGUI>();
			TimeText = speedPanel.Find("BG/TimeText").GetComponent<TextMeshProUGUI>();
			TempGoldCoinText = distancePanel.Find("BG/GoldText").GetComponent<TextMeshProUGUI>();
			TempGoldCoinT = TempGoldCoinText.rectTransform;
			canvasGroup.alpha = 0f;
		}

		public csScoreHint GetHintByType(UIHintType type, Vector3 postion)
		{
			if (m_HintByType[type].Count == 0)
			{
				return null;
			}
			csScoreHint csScoreHint = m_HintByType[type].Dequeue();
			if (csScoreHint != null)
			{
				GameObject obj = csScoreHint.gameObject;
				obj.transform.position = postion;
				obj.SetActive(value: true);
			}
			return csScoreHint;
		}

		public void ReturnHintObjectIntoPool(csScoreHint go, bool delay)
		{
			if (delay)
			{
				go.gameObject.SetActive(value: false);
				if (m_HintObjectByGO.ContainsKey(go.gameObject))
				{
					csLocalizationManager.Instance.StartCoroutine(DelayToReset_HG(go));
				}
			}
			else if (m_HintObjectByGO.ContainsKey(go.gameObject))
			{
				m_HintByType[m_HintObjectByGO[go.gameObject].m_Type].Enqueue(go);
				go.gameObject.SetActive(value: false);
			}
		}

		private IEnumerator DelayToReset_HG(csScoreHint go)
		{
			yield return new WaitForSeconds(5f);
			if ((bool)go)
			{
				go.gameObject.SetActive(value: false);
				m_HintByType[m_HintObjectByGO[go.gameObject].m_Type].Enqueue(go);
			}
		}

		private void Start()
		{
			if (csGameSettings.CurrentGameMode == GameMode.LevelMode)
			{
				LevelText.gameObject.SetActive(value: false);
				TempLevelText.gameObject.SetActive(value: false);
				levelTextGameobject.SetActive(value: false);
			}
		}

		public void InitHeartNum(int maxHP)
		{
			HeartNumTxt.text = "x" + maxHP;
		}

		public void DoHeartShake()
		{
			if (HTweener1 != null && !HTweener1.IsComplete())
			{
				HTweener1.Kill();
			}
			if (HTweener2 != null && !HTweener2.IsComplete())
			{
				HTweener2.Kill();
			}
			HeartNumTxt.transform.localScale = Vector3.one;
			HeartIconImg.transform.localScale = Vector3.one;
			HTweener1 = HeartNumTxt.transform.DOPunchScale(Vector3.one * 1.1f, 0.2f, 1, 0f);
			HTweener2 = HeartIconImg.transform.DOPunchScale(Vector3.one * 1.1f, 0.2f, 1, 0f);
		}

		public void SetHPNum(int CurNum)
		{
			HeartNumTxt.text = "x" + CurNum;
		}

		public void SetProgressValue(float percent, bool isReset = false)
		{
			if (percent > 1f)
			{
				percent = 1f;
			}
			AimProgressWid = Mathf.Lerp(MinProgressWid, MaxProgressWid, percent);
			if (isReset)
			{
				LvProgressValue.rectTransform.sizeDelta = new Vector2(AimProgressWid, 19.42f);
			}
		}

		private void OnEnable()
		{
			GameManager.LevelUpAction = (Action)Delegate.Combine(GameManager.LevelUpAction, new Action(RefeshLevel));
		}

		private void OnDisable()
		{
			GameManager.LevelUpAction = (Action)Delegate.Remove(GameManager.LevelUpAction, new Action(RefeshLevel));
		}

		private void Update()
		{
			distanceText.text = $"{GameManager.LevelManager.TotalDistance:N0}";
			speedText.text = $"{GameManager.Player.Speed:0.0}m/s";
			if (GameManager.instance.GameTime < 3600f)
			{
				TimeText.text = FormatFloatTimeToStr(full: false, GameManager.instance.GameTime);
			}
			else
			{
				TimeText.text = FormatFloatTimeToStr(full: true, GameManager.instance.GameTime);
			}
			if (LvProgressValue.rectTransform.sizeDelta.x < AimProgressWid)
			{
				LvProgressValue.rectTransform.sizeDelta = new Vector3(LvProgressValue.rectTransform.sizeDelta.x + Time.deltaTime * GameManager.Player.Speed / 60f * (MaxProgressWid - MinProgressWid) * 0.1f, 19.42f);
			}
		}

		public void UpdateCoinNum()
		{
			TempGoldCoinText.text = GameManager.LevelManager.CoinGetThisRun.ToString();
		}

		public void OnCoinGet()
		{
			if (TTweener != null && !TTweener.IsComplete())
			{
				TTweener.Kill();
			}
			TempGoldCoinT.localScale = Vector3.one;
			TTweener = TempGoldCoinT.DOPunchScale(Vector3.one * 1.2f, 0.2f, 1, 0f);
		}

		public void OnAddScore(int score)
		{
			csScoreHint hintByType = GetHintByType(UIHintType.ScoreHint, ScoreHintT.position);
			hintByType.thisT.SetParent(ScoreHintT);
			hintByType.thisT.localScale = Vector3.one;
			hintByType.thisT.localEulerAngles = Vector3.zero;
			hintByType.SetContent(isAdd: true, score);
			hintByType.DoAnimate(delegate
			{
			});
		}

		public void OnMinusScore(int score)
		{
			csScoreHint hintByType = GetHintByType(UIHintType.ScoreHint, ScoreHintT.position);
			hintByType.thisT.SetParent(ScoreHintT);
			hintByType.thisT.localScale = Vector3.one;
			hintByType.thisT.localEulerAngles = Vector3.zero;
			hintByType.SetContent(isAdd: false, score);
			hintByType.DoAnimate(delegate
			{
			});
		}

		public void Show()
		{
			TempLevelText.gameObject.SetActive(value: false);
			RectTransform distRect = distancePanel.GetComponent<RectTransform>();
			RectTransform spdRect = speedPanel.GetComponent<RectTransform>();
			SimpleTweener.AddTween(() => new Vector2(-80f, 0f), delegate(Vector2 x)
			{
				distRect.anchoredPosition = x;
			}, Vector2.zero, 0.5f);
			SimpleTweener.AddTween(() => new Vector2(80f, 0f), delegate(Vector2 x)
			{
				spdRect.anchoredPosition = x;
			}, Vector2.zero, 0.5f);
			SimpleTweener.AddTween(() => canvasGroup.alpha, delegate(float x)
			{
				canvasGroup.alpha = x;
			}, 1f, 0.5f);
			if (UnityEngine.Application.isMobilePlatform && GameManager.Player.inputMode == PlayerControl.MobileInputMode.Touch)
			{
				SimpleTweener.AddTween(() => new Vector2(0f, 180f), delegate(Vector2 x)
				{
					leftArrow.anchoredPosition = x;
				}, new Vector2(150f, 180f), 0.5f).Delay(0.3f);
				SimpleTweener.AddTween(() => new Vector2(0f, 180f), delegate(Vector2 x)
				{
					rightArrow.anchoredPosition = x;
				}, new Vector2(-150f, 180f), 0.5f).Delay(0.3f);
				Image leftArrowImage = leftArrow.GetComponent<Image>();
				Image rightArrowImage = rightArrow.GetComponent<Image>();
				leftArrowImage.color = Color.white;
				rightArrowImage.color = Color.white;
				SimpleTweener.AddTween(() => Vector3.one, delegate(Vector3 x)
				{
					leftArrow.localScale = x;
				}, 2f * Vector3.one, 0.6f).Delay(showArrowsTime);
				SimpleTweener.AddTween(() => Vector3.one, delegate(Vector3 x)
				{
					rightArrow.localScale = x;
				}, 2f * Vector3.one, 0.6f).Delay(showArrowsTime);
				SimpleTweener.AddTween(() => leftArrowImage.color, delegate(Color x)
				{
					leftArrowImage.color = x;
				}, Color.clear, 0.6f).Delay(showArrowsTime);
				SimpleTweener.AddTween(() => rightArrowImage.color, delegate(Color x)
				{
					rightArrowImage.color = x;
				}, Color.clear, 0.6f).Delay(showArrowsTime);
			}
			else
			{
				leftArrow.gameObject.SetActive(value: false);
				rightArrow.gameObject.SetActive(value: false);
			}
			base.gameObject.SetActive(value: true);
		}

		public void Hide()
		{
			RectTransform distRect = distancePanel.GetComponent<RectTransform>();
			RectTransform spdRect = speedPanel.GetComponent<RectTransform>();
			SimpleTweener.AddTween(() => Vector2.zero, delegate(Vector2 x)
			{
				distRect.anchoredPosition = x;
			}, new Vector2(-80f, 0f), 0.5f).Ease(Easing.EaseIn);
			SimpleTweener.AddTween(() => Vector2.zero, delegate(Vector2 x)
			{
				spdRect.anchoredPosition = x;
			}, new Vector2(80f, 0f), 0.5f).Ease(Easing.EaseIn);
			SimpleTweener.AddTween(() => canvasGroup.alpha, delegate(float x)
			{
				canvasGroup.alpha = x;
			}, 0f, 0.5f).Ease(Easing.EaseIn);
			base.gameObject.SetActive(value: false);
		}

		public void OnNewRecord()
		{
			RectTransform distRect = distanceText.GetComponent<RectTransform>();
			SimpleTweener.AddTween(() => distRect.localScale, delegate(Vector3 x)
			{
				distRect.localScale = x;
			}, 1.5f * Vector3.one, 0.5f).Ease(Easing.EaseKick);
		}

		public void RefeshLevel()
		{
			if (csGameSettings.CurrentGameMode == GameMode.EndlessMode)
			{
				csLocalizationManager.Instance.StartCoroutine(IERefreshLevel());
			}
		}

		private IEnumerator IERefreshLevel()
		{
			LevelText.gameObject.SetActive(value: false);
			TempLevelText.transform.localScale = Vector3.one * 4f;
			TempLevelText.text = GameManager.instance.Level.ToString();
			TempLevelText.gameObject.SetActive(value: true);
			TempLevelText.transform.DOScale(1f, duration).SetEase(Ease.InExpo);
			yield return new WaitForSeconds(duration);
			TempLevelText.gameObject.SetActive(value: false);
			LevelText.gameObject.SetActive(value: true);
			levelTextGameobject.SetActive(value: true);
			LevelText.text = $"lv.{GameManager.instance.Level.ToString()}";
			speedPanel.DOScale(speedPanelScale * 1.5f, Shackduration);
			yield return new WaitForSeconds(Shackduration);
			speedPanel.DOScale(speedPanelScale, Shackduration);
		}

		public void AddBuffHint(PreObjectType buffType, float cdTime, bool withBnous = false)
		{
			switch (buffType)
			{
			case PreObjectType.Sheild:
				if (HintShield.BuffIsOn)
				{
					HintShield.SetBuffOn(isOn: true, cdTime, withBnous);
					break;
				}
				CurShowHintList.Add(HintShield);
				HintShield.SetBuffOn(isOn: true, cdTime, withBnous);
				break;
			case PreObjectType.RushPower:
				if (HintRush.BuffIsOn)
				{
					HintRush.SetBuffOn(isOn: true, cdTime, withBnous);
					break;
				}
				CurShowHintList.Add(HintRush);
				HintRush.SetBuffOn(isOn: true, cdTime, withBnous);
				break;
			case PreObjectType.Magnet:
				if (HintMag.BuffIsOn)
				{
					HintMag.SetBuffOn(isOn: true, cdTime, withBnous);
					break;
				}
				CurShowHintList.Add(HintMag);
				HintMag.SetBuffOn(isOn: true, cdTime, withBnous);
				break;
			}
			RefreshPos();
		}

		private void RefreshPos()
		{
			for (int i = 0; i < CurShowHintList.Count; i++)
			{
				CurShowHintList[i].SetBuffParent(HintParntT[i]);
			}
		}

		public void OnBuffEnd(PreObjectType buffType)
		{
			switch (buffType)
			{
			case PreObjectType.Sheild:
				HintShield.BuffIsOn = false;
				HintShield.thisG.SetActive(value: false);
				CurShowHintList.Remove(HintShield);
				break;
			case PreObjectType.RushPower:
				HintRush.BuffIsOn = false;
				HintRush.thisG.SetActive(value: false);
				CurShowHintList.Remove(HintRush);
				break;
			case PreObjectType.Magnet:
				HintMag.BuffIsOn = false;
				HintMag.thisG.SetActive(value: false);
				CurShowHintList.Remove(HintMag);
				break;
			}
			RefreshPos();
		}

		public void ClearHint()
		{
			for (int i = 0; i < CurShowHintList.Count; i++)
			{
				CurShowHintList[i].ClearBuff();
			}
			CurShowHintList.Clear();
			for (int j = 0; j < CurSKillHintDic.Count; j++)
			{
				CurSKillHintDic.Values.ToArray()[j].ClearSkill();
			}
		}

		public void SetSkillHint(List<HorseSkill> PlayerHSkill, List<float> SkillCDList)
		{
			for (int i = 0; i < PlayerHSkill.Count; i++)
			{
				csHUDSkillHint csHUDSkillHint = HintSkill_Sprint;
				switch (PlayerHSkill[i])
				{
				case HorseSkill.Sprint:
					csHUDSkillHint = HintSkill_Sprint;
					break;
				case HorseSkill.Invincible:
					csHUDSkillHint = HintSkill_Invince;
					break;
				case HorseSkill.Slow:
					csHUDSkillHint = HintSkill_Slow;
					break;
				case HorseSkill.Strike:
					csHUDSkillHint = HintSkill_Strike;
					break;
				case HorseSkill.Anticol:
					csHUDSkillHint = HintSkill_AntiCol;
					break;
				case HorseSkill.Jump:
					csHUDSkillHint = HintSkill_Jump;
					break;
				case HorseSkill.ShieldBuff:
					csHUDSkillHint = HintSkill_ShieldBuff;
					break;
				case HorseSkill.Roar:
					csHUDSkillHint = HintSkill_Roar;
					break;
				case HorseSkill.Fly:
					csHUDSkillHint = HintSkill_Fly;
					break;
				}
				csHUDSkillHint.SetSkillHintPos(SkillHintParentT[i], SkillCDList[i], ShowHint: false);
				CurSKillHintDic.Add(PlayerHSkill[i], csHUDSkillHint);
			}
		}

		public void RefreshSkillHint()
		{
			for (int i = 0; i < CurSKillHintDic.Count; i++)
			{
				bool showHint = false;
				switch (CurSKillHintDic.Values.ToArray()[i].skillType)
				{
				case HorseSkill.Sprint:
					showHint = true;
					break;
				case HorseSkill.Invincible:
					showHint = true;
					break;
				case HorseSkill.Slow:
					showHint = true;
					break;
				case HorseSkill.Jump:
					showHint = true;
					break;
				case HorseSkill.Roar:
					showHint = true;
					break;
				case HorseSkill.Fly:
					showHint = true;
					break;
				}
				CurSKillHintDic.Values.ToArray()[i].RefreshSkillHint(showHint);
			}
		}

		public void OnSkillUse(HorseSkill skilltype)
		{
			CurSKillHintDic[skilltype].SetSkillOff();
			GameManager.instance.m_InGameMissionData.AddHorseSkillTimes(skilltype);
		}

		public void OnSkillSilence(HorseSkill skilltype, bool isSilence)
		{
			CurSKillHintDic[skilltype].DoSilenceSkill(isSilence);
		}

		public void OnSilenceSkillTrigger(HorseSkill skilltype)
		{
			CurSKillHintDic[skilltype].OnSilenceSkillCall();
		}

		public void OnSkillStartCD(HorseSkill skilltype)
		{
			CurSKillHintDic[skilltype].StartSkillCD();
		}

		public void OnSkillEffecting(HorseSkill skilltype, float time)
		{
			CurSKillHintDic[skilltype].StartSkillEffecting(time);
		}

		public static string FormatFloatTimeToStr(bool full, float value)
		{
			string text = "00:00:00";
			if (full)
			{
				return TimeSpan.FromSeconds(Mathf.FloorToInt(value)).ToString();
			}
			int num = (int)(value % 1f * 100f);
			return TimeSpan.FromSeconds(Mathf.FloorToInt(value)).ToString().Substring(3) + "." + ((num < 10) ? ("0" + num) : num.ToString());
		}
	}
	public class InfoPopup : MonoBehaviour
	{
		private CanvasGroup canvasGroup;

		private TextMeshProUGUI text;

		private DeerCat.SimpleTween.Tween alphaTween;

		private DeerCat.SimpleTween.Tween rotationTween;

		private DeerCat.SimpleTween.Tween countdownTween;

		private bool isShowing;

		private void Start()
		{
			canvasGroup = GetComponent<CanvasGroup>();
			text = GetComponentInChildren<TextMeshProUGUI>();
			canvasGroup.alpha = 0f;
		}

		private void ShowInfoPopup(float duration, float fadeTime)
		{
			if (isShowing)
			{
				SimpleTweener.RemoveTween(alphaTween);
				SimpleTweener.RemoveTween(rotationTween);
			}
			isShowing = true;
			alphaTween = SimpleTweener.AddTween(() => canvasGroup.alpha, delegate(float x)
			{
				canvasGroup.alpha = x;
			}, 1f, fadeTime).OnCompleted(delegate
			{
				alphaTween = SimpleTweener.AddTween(() => canvasGroup.alpha, delegate(float x)
				{
					canvasGroup.alpha = x;
				}, 0f, fadeTime).Delay(duration).OnCompleted(delegate
				{
					isShowing = false;
				});
			});
			RectTransform rect = GetComponent<RectTransform>();
			rotationTween = SimpleTweener.AddTween(() => -90f, delegate(float x)
			{
				rect.localEulerAngles = new Vector3(x, 0f, 0f);
			}, 0f, fadeTime).Ease(Easing.EaseLinear).OnCompleted(delegate
			{
				rotationTween = SimpleTweener.AddTween(() => rect.localEulerAngles.x, delegate(float x)
				{
					rect.localEulerAngles = new Vector3(x, 0f, 0f);
				}, -90f, fadeTime).Ease(Easing.EaseLinear).Delay(duration);
			});
		}

		public void ShowMessage(string message, float duration, float fadeTime)
		{
			text.text = message;
			ShowInfoPopup(duration, fadeTime);
		}
	}
	[RequireComponent(typeof(CanvasGroup))]
	public class MenuScreen : MonoBehaviour
	{
		public enum TransitionDirection
		{
			Forward,
			Back
		}

		[Tooltip("this item (if not null) will be set as the focused ui item when this menu screen opens")]
		public GameObject defaultUIItem;

		protected CanvasGroup canvasGroup;

		private Transform panelXfm;

		private DeerCat.SimpleTween.Tween alphaTween;

		private DeerCat.SimpleTween.Tween rotationTween;

		protected bool isBtnInteractable;

		public CanvasGroup CanvasGroup => canvasGroup;

		protected virtual void Awake()
		{
			canvasGroup = GetComponent<CanvasGroup>();
			panelXfm = base.transform.Find("Panel");
			canvasGroup.alpha = 0f;
		}

		public virtual void Show(float fade, TransitionDirection direction = TransitionDirection.Forward, DeerCat.SimpleTween.Callback callback = null)
		{
			base.gameObject.SetActive(value: true);
			SimpleTweener.RemoveTween(alphaTween);
			SimpleTweener.RemoveTween(rotationTween);
			isBtnInteractable = false;
			if (fade == 0f)
			{
				canvasGroup.alpha = 1f;
				if (callback != null)
				{
					callback();
				}
				isBtnInteractable = true;
			}
			else
			{
				alphaTween = SimpleTweener.AddTween(() => CanvasGroup.alpha, delegate(float x)
				{
					CanvasGroup.alpha = x;
				}, 1f, fade).OnCompleted(delegate
				{
					callback?.Invoke();
					isBtnInteractable = true;
				}).UseRealTime(b: true);
				if (panelXfm != null)
				{
					rotationTween = SimpleTweener.AddTween(() => new Vector3(90f, 0f, 0f), delegate(Vector3 x)
					{
						panelXfm.localEulerAngles = x;
					}, Vector3.zero, fade).UseRealTime(b: true);
				}
			}
			EventSystem.current.SetSelectedGameObject(defaultUIItem);
		}

		public virtual void Hide(float fade, TransitionDirection direction = TransitionDirection.Back, DeerCat.SimpleTween.Callback callback = null)
		{
			SimpleTweener.RemoveTween(alphaTween);
			SimpleTweener.RemoveTween(rotationTween);
			if (fade == 0f)
			{
				canvasGroup.alpha = 0f;
				base.gameObject.SetActive(value: false);
				if (callback != null)
				{
					callback();
				}
				return;
			}
			alphaTween = SimpleTweener.AddTween(() => CanvasGroup.alpha, delegate(float x)
			{
				CanvasGroup.alpha = x;
			}, 0f, fade).UseRealTime(b: true).OnCompleted(delegate
			{
				base.gameObject.SetActive(value: false);
				if (callback != null)
				{
					callback();
				}
			});
			if (panelXfm != null)
			{
				rotationTween = SimpleTweener.AddTween(() => Vector3.zero, delegate(Vector3 x)
				{
					panelXfm.localEulerAngles = x;
				}, new Vector3(90f, 0f, 0f), fade).UseRealTime(b: true);
			}
		}
	}
	public class MenuSystem : MonoBehaviour
	{
		private Dictionary<string, MenuScreen> screens = new Dictionary<string, MenuScreen>();

		private Stack<MenuScreen> screenHistory = new Stack<MenuScreen>();

		private HUD hud;

		public MenuScreen CurrentScreen
		{
			get
			{
				if (screenHistory.Count != 0)
				{
					return screenHistory.Peek();
				}
				return null;
			}
		}

		public HUD HUD => hud;

		private void Awake()
		{
			MenuScreen[] array = UnityEngine.Object.FindObjectsOfType<MenuScreen>();
			foreach (MenuScreen menuScreen in array)
			{
				screens[menuScreen.name] = menuScreen;
			}
			hud = UnityEngine.Object.FindObjectOfType<HUD>();
		}

		private void Start()
		{
			MenuScreen[] array = UnityEngine.Object.FindObjectsOfType<MenuScreen>();
			MenuScreen currentScreen = CurrentScreen;
			foreach (MenuScreen menuScreen in array)
			{
				if (menuScreen != currentScreen)
				{
					menuScreen.gameObject.SetActive(value: false);
				}
			}
		}

		public MenuScreen GetScreen(string name)
		{
			return screens[name];
		}

		public void ShowScreen(MenuScreen screen, float fade = 0.5f, DeerCat.SimpleTween.Callback callback = null)
		{
			if (screen == null)
			{
				UnityEngine.Debug.LogWarning("Attempting to show null Menu Screen");
				return;
			}
			MenuScreen currentScreen = CurrentScreen;
			screenHistory.Push(screen);
			if (currentScreen != null)
			{
				currentScreen.Hide(fade, MenuScreen.TransitionDirection.Forward, delegate
				{
					screen.Show(fade, MenuScreen.TransitionDirection.Forward, callback);
				});
			}
			else
			{
				screen.Show(fade, MenuScreen.TransitionDirection.Forward, callback);
			}
		}

		public void ShowScreenAdd(MenuScreen screen, float fade = 0.5f, DeerCat.SimpleTween.Callback callback = null)
		{
			if (screen == null)
			{
				UnityEngine.Debug.LogWarning("Attempting to show null Menu Screen");
				return;
			}
			_ = CurrentScreen;
			screenHistory.Push(screen);
			screen.Show(fade, MenuScreen.TransitionDirection.Forward, callback);
		}

		public void GoBack(float fade = 0.5f, DeerCat.SimpleTween.Callback callback = null)
		{
			if (screenHistory.Count == 0)
			{
				return;
			}
			MenuScreen menuScreen = screenHistory.Pop();
			MenuScreen prevScreen = ((screenHistory.Count == 0) ? null : screenHistory.Peek());
			if (prevScreen != null)
			{
				menuScreen.Hide(fade, MenuScreen.TransitionDirection.Back, delegate
				{
					prevScreen.Show(fade, MenuScreen.TransitionDirection.Back, callback);
				});
			}
			else
			{
				menuScreen.Hide(fade, MenuScreen.TransitionDirection.Back, callback);
			}
		}

		public void ExitAll(float fade = 0.5f, DeerCat.SimpleTween.Callback callback = null)
		{
			if (screenHistory.Count != 0)
			{
				screenHistory.Pop().Hide(fade, MenuScreen.TransitionDirection.Back, callback);
				screenHistory.Clear();
			}
		}
	}
	public class RestartMenu : MenuScreen
	{
		private GameObject ResultObj;

		private GameObject ReviveObj;

		private TextMeshProUGUI TimeText;

		private TextMeshProUGUI LevelText;

		private TextMeshProUGUI distanceText;

		private TextMeshProUGUI ScoreText;

		private TextMeshProUGUI oldRecordText;

		private GameObject NewRecordObj;

		public DOTweenAnimation tweener;

		private CanvasGroup RecoreCG;

		private TextMeshProUGUI ReviveCountText;

		private TextMeshProUGUI CoinText;

		private TextMeshProUGUI InGameCoins;

		private Image ReviveTimeSlider;

		private Transform ReviveBtnT;

		public AudioSource ASSPlayer;

		public AudioClip ClipLoopAdd;

		public AudioClip ClipMoney;

		public Sprite StarSprite;

		public Sprite StarSprite_empty;

		private TextMeshProUGUI CurrentLevelText;

		private Image TopStar1;

		private Image TopStar2;

		private Image TopStar3;

		private Image MissionStar1;

		private Image MissionStar2;

		private Image MissionStar3;

		private Transform Mission1BoardT;

		private Transform Mission2BoardT;

		private Transform Mission3BoardT;

		private Transform EndPos1;

		private Transform EndPos2;

		private Transform EndPos3;

		private RectTransform FlyStar1T;

		private RectTransform FlyStar2T;

		private RectTransform FlyStar3T;

		private Vector3 FlyStar1TLPos;

		private Vector3 FlyStar2TLPos;

		private Vector3 FlyStar3TLPos;

		private TextMeshProUGUI MissionText1;

		private TextMeshProUGUI MissionText2;

		private TextMeshProUGUI MissionText3;

		private GameObject NextLevelBtn;

		public Sprite S_Currency_Coin;

		public Sprite S_Currency_Gem;

		public Sprite S_Currency_Money;

		public Image ReviveMoneyImg;

		public TextMeshProUGUI ReviveMoneyTxt;

		public TextMeshProUGUI GemText;

		public TextMeshProUGUI[] ReviveTimeTxt;

		public Transform FlyStartPosT;

		public Transform FlyEndPosT;

		public Queue<Image> FlyQue = new Queue<Image>();

		public List<Image> FlyImgList = new List<Image>();

		public AudioClip[] ResultClips;

		private GameObject LevelCompelet;

		private GameObject LevelDefeat;

		public GameObject IngameAchievementItemPrefab;

		public RectTransform IngameAchievementParent;

		public GridLayoutGroup m_GridLayoutGroup;

		private Vector3 InitAchievementParentPos;

		public GameObject Achievement;

		public csResultBoxAward ResultBoxPanel;

		private int reviveMoney;

		private Coroutine TimerCoroutine;

		public float scaleTime = 0.5f;

		public float intervalTime = 0.5f;

		private float StarFlyTime = 0.6f;

		public GameObject CompleteTitle;

		public GameObject FailedTitle;

		private float moveTime = 1f;

		private List<GameObject> AchievementItemList = new List<GameObject>();

		protected override void Awake()
		{
			base.Awake();
			string text = "Result";
			if (csGameSettings.CurrentGameMode == GameMode.LevelMode)
			{
				text = "LevelResult";
			}
			if (FlyQue.Count == 0)
			{
				for (int i = 0; i < FlyImgList.Count; i++)
				{
					FlyQue.Enqueue(FlyImgList[i]);
				}
			}
			ResultObj = base.transform.Find(text).gameObject;
			ReviveObj = base.transform.Find("Revive").gameObject;
			TimeText = base.transform.Find(text + "/Panel/Top/TimeText").GetComponent<TextMeshProUGUI>();
			distanceText = base.transform.Find(text + "/Panel/Top/DisText").GetComponent<TextMeshProUGUI>();
			ScoreText = base.transform.Find(text + "/Panel/NormalScreen/ScoreText").GetComponent<TextMeshProUGUI>();
			oldRecordText = base.transform.Find(text + "/Panel/NormalScreen/RecordScore").GetComponent<TextMeshProUGUI>();
			NewRecordObj = base.transform.Find(text + "/Panel/NewRecord").gameObject;
			ReviveCountText = base.transform.Find("Revive/Panel/Top/ReviveCountText").GetComponent<TextMeshProUGUI>();
			CoinText = base.transform.Find("Revive/Panel/Top/coinText").GetComponent<TextMeshProUGUI>();
			ReviveTimeSlider = base.transform.Find("Revive/Panel/Mid/ReviveBtn/ReviveTimeSlider").GetComponent<Image>();
			ReviveBtnT = base.transform.Find("Revive/Panel/Mid/ReviveBtn");
			InGameCoins = base.transform.Find(text + "/Panel/Top/CoinText").GetComponent<TextMeshProUGUI>();
			ASSPlayer.clip = ClipLoopAdd;
			tweener = NewRecordObj.GetComponent<DOTweenAnimation>();
			NewRecordObj.SetActive(value: false);
			RecoreCG = NewRecordObj.GetComponent<CanvasGroup>();
			if (csGameSettings.CurrentGameMode == GameMode.LevelMode)
			{
				CurrentLevelText = base.transform.Find(text + "/Panel/Level/LevelText").GetComponent<TextMeshProUGUI>();
				TopStar1 = base.transform.Find(text + "/Panel/Level/Star1").GetComponent<Image>();
				TopStar2 = base.transform.Find(text + "/Panel/Level/Star2").GetComponent<Image>();
				TopStar3 = base.transform.Find(text + "/Panel/Level/Star3").GetComponent<Image>();
				EndPos1 = base.transform.Find(text + "/Panel/Level/EndPos1");
				EndPos2 = base.transform.Find(text + "/Panel/Level/EndPos2");
				EndPos3 = base.transform.Find(text + "/Panel/Level/EndPos3");
				MissionStar1 = base.transform.Find(text + "/Panel/Level/Mission/Mission1/Star").GetComponent<Image>();
				MissionStar2 = base.transform.Find(text + "/Panel/Level/Mission/Mission2/Star").GetComponent<Image>();
				MissionStar3 = base.transform.Find(text + "/Panel/Level/Mission/Mission3/Star").GetComponent<Image>();
				MissionStar1.enabled = false;
				MissionStar2.enabled = false;
				MissionStar3.enabled = false;
				Mission1BoardT = base.transform.Find(text + "/Panel/Level/Mission/Mission1/WhiteBG");
				Mission2BoardT = base.transform.Find(text + "/Panel/Level/Mission/Mission2/WhiteBG");
				Mission3BoardT = base.transform.Find(text + "/Panel/Level/Mission/Mission3/WhiteBG");
				FlyStar1T = base.transform.Find(text + "/Panel/Level/Fly1").GetComponent<RectTransform>();
				FlyStar2T = base.transform.Find(text + "/Panel/Level/Fly2").GetComponent<RectTransform>();
				FlyStar3T = base.transform.Find(text + "/Panel/Level/Fly3").GetComponent<RectTransform>();
				FlyStar1TLPos = FlyStar1T.localPosition;
				FlyStar2TLPos = FlyStar2T.localPosition;
				FlyStar3TLPos = FlyStar3T.localPosition;
				FlyStar1T.gameObject.SetActive(value: false);
				FlyStar2T.gameObject.SetActive(value: false);
				FlyStar3T.gameObject.SetActive(value: false);
				MissionText1 = base.transform.Find(text + "/Panel/Level/Mission/Mission1/WhiteBG/MissionText").GetComponent<TextMeshProUGUI>();
				MissionText2 = base.transform.Find(text + "/Panel/Level/Mission/Mission2/WhiteBG/MissionText").GetComponent<TextMeshProUGUI>();
				MissionText3 = base.transform.Find(text + "/Panel/Level/Mission/Mission3/WhiteBG/MissionText").GetComponent<TextMeshProUGUI>();
				NextLevelBtn = base.transform.Find(text + "/Panel/NextButton").gameObject;
				LevelCompelet = base.transform.Find(text + "/Panel/NormalScreen/Win").gameObject;
				LevelDefeat = base.transform.Find(text + "/Panel/NormalScreen/Lost").gameObject;
			}
			InitAchievementParentPos = IngameAchievementParent.anchoredPosition;
		}

		public override void Show(float fade, TransitionDirection direction, DeerCat.SimpleTween.Callback callback)
		{
			base.Show(fade, direction, callback);
			ResultBoxPanel.Hide();
			ASSPlayer.volume = (float)csPlayerData.SoundFXVolume / 10f;
			SoundManager.PlaySfx("Result");
			if (direction != 0)
			{
				return;
			}
			if (GameManager.instance.RestReviveTimes > 0)
			{
				ResultObj.SetActive(value: false);
				ReviveObj.SetActive(value: true);
				CoinText.text = csPlayerData.PlayerCoin.ToString();
				GemText.text = csPlayerData.PlayerDiamond.ToString();
				ReviveCountText.text = GameManager.instance.RestReviveTimes + "/" + 3;
				if (csGameSettings.PlayerHorseType == HorseType.Crocodile)
				{
					if (GameManager.instance.SpecialDeadTime == 0)
					{
						GameManager.instance.SpecialDeadTime++;
						GameManager.instance.RestReviveTimes++;
						reviveMoney = 0;
						ReviveCountText.text = 4 + "/" + 4;
					}
					else
					{
						ReviveCountText.text = GameManager.instance.RestReviveTimes + "/" + 4.ToString();
						GameManager.instance.DeadTimes++;
						reviveMoney = csGameSettings.GetMoneyByDeadTime(GameManager.instance.DeadTimes);
					}
				}
				else
				{
					GameManager.instance.DeadTimes++;
					reviveMoney = csGameSettings.GetMoneyByDeadTime(GameManager.instance.DeadTimes);
				}
				if (reviveMoney > 0 && csPlayerData.PlayerCoin < reviveMoney)
				{
					reviveMoney = csGameSettings.GetGemByDeadTime(GameManager.instance.DeadTimes);
				}
				ReviveMoneyImg.overrideSprite = ((reviveMoney >= 0) ? S_Currency_Coin : S_Currency_Gem);
				ReviveMoneyTxt.text = Mathf.Abs(reviveMoney).ToString();
				TimerCoroutine = StartCoroutine(Timer(5f));
				ReviveBtnT.localScale = Vector3.one;
			}
			else
			{
				ShowResult();
			}
			Achievement.gameObject.SetActive(value: false);
		}

		public Image TryGetCoinImg()
		{
			if (FlyQue.Count > 0)
			{
				return FlyQue.Dequeue();
			}
			return null;
		}

		public void ReturnCoin(Image retImg)
		{
			FlyQue.Enqueue(retImg);
		}

		private IEnumerator Timer(float duration)
		{
			ReviveTimeSlider.fillAmount = 1f;
			TextMeshProUGUI[] reviveTimeTxt = ReviveTimeTxt;
			for (int i = 0; i < reviveTimeTxt.Length; i++)
			{
				reviveTimeTxt[i].text = ((int)duration).ToString();
			}
			float timer = 0f;
			bool Bounced = false;
			while (timer < duration)
			{
				timer += Time.deltaTime;
				yield return new WaitForEndOfFrame();
				reviveTimeTxt = ReviveTimeTxt;
				for (int i = 0; i < reviveTimeTxt.Length; i++)
				{
					reviveTimeTxt[i].text = ((int)(duration - timer)).ToString();
				}
				ReviveTimeSlider.fillAmount = (duration - timer) / duration;
				if (!Bounced && timer > 0.1f)
				{
					Bounced = true;
					ReviveBtnT.DOPunchScale(Vector3.one * 1.02f, 0.4f, 1, 0f);
				}
			}
			ShowResult();
		}

		private void KickItem(Transform item, float amount, float time)
		{
			SimpleTweener.AddTween(() => item.localScale, delegate(Vector3 x)
			{
				item.localScale = x;
			}, amount * item.localScale, time).Ease(Easing.EaseKick);
		}

		public void Revive()
		{
			if (reviveMoney >= 0 && csPlayerData.PlayerCoin > reviveMoney)
			{
				SoundManager.PlaySfx("ButtonPress");
				GameManager.instance.ContinueGame();
				if (TimerCoroutine != null)
				{
					StopCoroutine(TimerCoroutine);
				}
				csPlayerData.PlayerCoin -= reviveMoney;
			}
			else if (reviveMoney < 0 && csPlayerData.PlayerDiamond > -reviveMoney)
			{
				SoundManager.PlaySfx("ButtonPress");
				GameManager.instance.ContinueGame();
				if (TimerCoroutine != null)
				{
					StopCoroutine(TimerCoroutine);
				}
				csPlayerData.PlayerDiamond += reviveMoney;
			}
			else if (reviveMoney > 0)
			{
				GameManager.instance.popHintM.ShowHint(csLocalizationManager.Instance.GetLocalText("PopHint01"));
			}
			else
			{
				GameManager.instance.popHintM.ShowHint(csLocalizationManager.Instance.GetLocalText("PopHint05"));
			}
		}

		private void ShowResult()
		{
			GameManager.instance.SaveData();
			ResultBoxPanel.Hide();
			ResultObj.SetActive(value: true);
			ReviveObj.SetActive(value: false);
			SoundManager.PlayMusicPool("gameend");
			TimeText.text = "";
			distanceText.text = "";
			InGameCoins.text = "";
			ScoreText.text = "";
			if ((bool)LevelText)
			{
				LevelText.text = "Lv." + GameManager.LevelManager.StartLevel;
			}
			if (csGameSettings.CurrentGameMode == GameMode.LevelMode)
			{
				StartCoroutine(LevelAfterEffect(ShowAcievemntAnim));
			}
			else
			{
				StartCoroutine(EndlessAfterEffect(ShowAcievemntAnim));
			}
			int time = (int)GameManager.instance.GameTime;
			float num = GameManager.LevelManager.TotalDistance * GameManager.Player.hd.BasicData.ScoreMultiplier * GameManager.Player.scoreBuffVal;
			if (csGameSettings.CurrentGameMode == GameMode.EndlessMode)
			{
				if (csLeaderboard.instance == null)
				{
					return;
				}
				csLeaderboard.instance.SavePlayerScore((int)num, time, csPlayerData.PlayerCountry);
				if (csPlayerData.HasLogin)
				{
					csLeaderboard.instance.SavePlayerScore_Playfab((int)num);
				}
			}
			if (csGameSettings.CurrentGameMode == GameMode.LevelMode)
			{
				CurrentLevelText.text = "Lv." + csGameSettings.CurrentSelectedLevel;
			}
		}

		public void DoAnim(Transform t, float time, bool doanim)
		{
			if (doanim)
			{
				t.gameObject.SetActive(value: false);
				t.localScale = Vector3.one * 2.5f;
				StartCoroutine(ScaleAnim(t, time));
			}
			else
			{
				t.gameObject.SetActive(value: false);
			}
		}

		public IEnumerator ScaleAnim(Transform t, float time)
		{
			yield return new WaitForSeconds(time);
			t.gameObject.SetActive(value: true);
			t.DOScale(1f, scaleTime);
		}

		public override void Hide(float fade, TransitionDirection direction = TransitionDirection.Back, DeerCat.SimpleTween.Callback callback = null)
		{
			ASSPlayer.Stop();
			base.Hide(fade, direction, callback);
		}

		private string TimeToString(int _s)
		{
			int num = _s / 60;
			int num2 = _s % 60;
			return $"{num:D2}" + ":" + $"{num2:D2}";
		}

		public void NextLevel()
		{
			csGameSettings.CurrentSelectedLevel = csPlayerData.GetHighestUnLockLevel;
			csGameSettings.ShowLevelPanel = true;
			csGameSettings.IsLoadToGame = false;
			SceneManager.LoadScene("LoadingScene");
		}

		public IEnumerator EndlessAfterEffect(Action callback, bool isFake = false)
		{
			TimeText.text = TimeToString((int)GameManager.instance.GameTime);
			KickItem(TimeText.transform, 1.5f, 0.2f);
			ASSPlayer.PlayOneShot(ResultClips[0]);
			yield return new WaitForSeconds(0.2f);
			distanceText.text = ((int)GameManager.LevelManager.RealDistance).ToString();
			KickItem(distanceText.transform, 1.5f, 0.2f);
			ASSPlayer.PlayOneShot(ResultClips[0]);
			yield return new WaitForSeconds(0.2f);
			InGameCoins.text = GameManager.LevelManager.CoinGetThisRun.ToString();
			KickItem(InGameCoins.transform, 1.5f, 0.2f);
			ASSPlayer.PlayOneShot(ResultClips[0]);
			yield return new WaitForSeconds(0.2f);
			float distance = (isFake ? 5000f : (GameManager.LevelManager.TotalDistance * GameManager.Player.hd.BasicData.ScoreMultiplier * GameManager.Player.scoreBuffVal));
			float record = 0f;
			record = ((!isFake) ? csPlayerData.BestEndlessScore : 0);
			ASSPlayer.Play();
			SimpleTweener.AddTween(() => 0, delegate(int x)
			{
				ScoreText.text = Mathf.CeilToInt(x).ToString();
			}, (int)distance, 0.5f).Delay(0.2f).OnCompleted(delegate
			{
				KickItem(ScoreText.transform, 1.5f, 0.3f);
				oldRecordText.text = record.ToString();
				KickItem(oldRecordText.transform, 1.5f, 0.3f);
				ASSPlayer.Stop();
				ASSPlayer.PlayOneShot(ResultClips[6]);
				if (distance >= record || isFake)
				{
					NewRecordObj.SetActive(value: true);
					ASSPlayer.PlayOneShot(ResultClips[7]);
					tweener.DOPlay();
				}
				else
				{
					NewRecordObj.SetActive(value: false);
				}
			});
			yield return new WaitForSeconds(1f);
			int levelPassed = GameManager.instance.Level;
			int tempStartLevel = GameManager.LevelManager.StartLevel;
			int coinTemp = GameManager.LevelManager.CoinGetThisRun;
			float num = 3f;
			float GapTime = num / (float)(levelPassed - tempStartLevel);
			float longestGap = 0.5f;
			for (int i = tempStartLevel; i < levelPassed; i++)
			{
				if ((bool)LevelText)
				{
					LevelText.text = "Lv." + (i + 1);
				}
				Image CoinImg = TryGetCoinImg();
				if ((bool)CoinImg)
				{
					CoinImg.gameObject.SetActive(value: true);
					CoinImg.transform.localScale = Vector3.zero;
					CoinImg.transform.position = FlyStartPosT.position;
					CoinImg.transform.DOScale(Vector3.one, 0.1f);
					CoinImg.transform.DOMove(FlyEndPosT.position, 0.1f);
				}
				yield return new WaitForSeconds(0.1f);
				ASSPlayer.PlayOneShot(ClipMoney);
				coinTemp += csGameSettings.GetCoinForOneLevel(i);
				InGameCoins.text = coinTemp.ToString();
				if ((bool)CoinImg)
				{
					CoinImg.gameObject.SetActive(value: false);
					ReturnCoin(CoinImg);
				}
				float num2 = 1.5f * GapTime - (float)(i - tempStartLevel) * (GapTime / (float)(levelPassed - tempStartLevel));
				KickItem(InGameCoins.transform, 1.5f, (num2 > 0.25f) ? 0.25f : num2);
				yield return new WaitForSeconds((num2 > longestGap) ? longestGap : num2);
			}
			InGameCoins.transform.localScale = Vector3.one;
			yield return new WaitForSeconds(0.15f);
			int num3 = (int)((float)GameManager.LevelManager.CoinGetThisRun * GameManager.Player.hd.BasicData.GoldMultiplier * GameManager.Player.moneyBuffVal) + (int)(GameManager.Player.hd.BasicData.GoldMultiplier * GameManager.Player.moneyBuffVal * ((float)csGameSettings.GetCoinByEndlessLevel(levelPassed - 1) - (float)csGameSettings.GetCoinByEndlessLevel(tempStartLevel - 1)));
			InGameCoins.text = num3.ToString();
			if (num3 > coinTemp)
			{
				KickItem(InGameCoins.transform, 1.5f, 0.15f);
			}
			ASSPlayer.PlayOneShot(ResultClips[0]);
			yield return null;
			StartCoroutine(TryGetEndlessBox());
		}

		public IEnumerator TryGetEndlessBox()
		{
			if ((float)UnityEngine.Random.Range(0, 100) < 100f * csGameData.Instance.GetEndlessBoxRate(GameManager.instance.GameTime))
			{
				List<ResultAwardData> list = new List<ResultAwardData>();
				int rndBoxItemNum = csGameData.Instance.GetRndBoxItemNum();
				List<AwardItemType> list2 = new List<AwardItemType>();
				for (int i = 0; i < rndBoxItemNum; i++)
				{
					AwardItemType rndItemType = csGameData.Instance.GetRndItemType();
					while (list2.Contains(rndItemType))
					{
						rndItemType = csGameData.Instance.GetRndItemType();
					}
					list2.Add(rndItemType);
					switch (rndItemType)
					{
					case AwardItemType.Coin:
					{
						ResultAwardData item3 = new ResultAwardData(csGameData.Instance.GetRndCoinItemNum(), 0, AheadBuff.RushS, 0);
						list.Add(item3);
						break;
					}
					case AwardItemType.Gem:
					{
						ResultAwardData item2 = new ResultAwardData(0, csGameData.Instance.GetRndGemItemNum(), AheadBuff.RushS, 0);
						list.Add(item2);
						break;
					}
					case AwardItemType.Prop:
					{
						BuffAwardRightData rndBuffItem = csGameData.Instance.GetRndBuffItem();
						ResultAwardData item = new ResultAwardData(0, 0, rndBuffItem.BuffType, rndBuffItem.BuffNum);
						list.Add(item);
						break;
					}
					}
				}
				ResultBoxPanel.SetAwards(list, isStarAward: false);
				ResultBoxPanel.Show(withStar: false, isStarBox: false);
			}
			yield return null;
		}

		public IEnumerator LevelAfterEffect(Action callback, bool isFake = false)
		{
			csLocalizationManager.Instance.CheckTextFontType(MissionText1);
			csLocalizationManager.Instance.CheckTextFontType(MissionText2);
			csLocalizationManager.Instance.CheckTextFontType(MissionText3);
			MissionText1.text = csLevelData.instance.GetDescriptionByMission(GameManager.instance.m_InGameMissionData.InGameMissionDataList[0]);
			MissionText2.text = csLevelData.instance.GetDescriptionByMission(GameManager.instance.m_InGameMissionData.InGameMissionDataList[1]);
			MissionText3.text = csLevelData.instance.GetDescriptionByMission(GameManager.instance.m_InGameMissionData.InGameMissionDataList[2]);
			NextLevelBtn.SetActive(csGameSettings.CurrentSelectedLevel < 15 && csPlayerData.PlayerLevelDataDic[csGameSettings.CurrentSelectedLevel + 1].isUnLock);
			CompleteTitle.SetActive(value: false);
			FailedTitle.SetActive(value: false);
			MissionStar1.enabled = false;
			MissionStar2.enabled = false;
			MissionStar3.enabled = false;
			FlyStar1T.gameObject.SetActive(value: false);
			FlyStar2T.gameObject.SetActive(value: false);
			FlyStar3T.gameObject.SetActive(value: false);
			NewRecordObj.SetActive(value: false);
			if (GameManager.instance.HasCompeletLevel)
			{
				CompleteTitle.SetActive(value: true);
			}
			else
			{
				FailedTitle.SetActive(value: true);
			}
			LevelCompelet.SetActive(GameManager.instance.HasCompeletLevel);
			LevelDefeat.SetActive(!GameManager.instance.HasCompeletLevel);
			yield return new WaitForSeconds(1f);
			TimeText.text = TimeToString((int)GameManager.instance.GameTime);
			KickItem(TimeText.transform, 1.5f, 0.2f);
			ASSPlayer.PlayOneShot(ResultClips[0]);
			yield return new WaitForSeconds(0.2f);
			distanceText.text = (isFake ? "1500" : ((int)GameManager.LevelManager.RealDistance).ToString());
			KickItem(distanceText.transform, 1.5f, 0.2f);
			ASSPlayer.PlayOneShot(ResultClips[0]);
			yield return new WaitForSeconds(0.2f);
			InGameCoins.text = (isFake ? "800" : GameManager.LevelManager.CoinGetThisRun.ToString());
			KickItem(InGameCoins.transform, 1.5f, 0.2f);
			ASSPlayer.PlayOneShot(ResultClips[0]);
			yield return new WaitForSeconds(0.2f);
			int starcount = 0;
			if (GameManager.instance.m_InGameMissionData.InGameMissionDataList[0].isComplet)
			{
				Mission1BoardT.DOPunchScale(Vector3.one * 1.03f, 0.2f);
				ASSPlayer.PlayOneShot(ResultClips[1]);
				yield return new WaitForSeconds(0.2f);
				MissionStar1.enabled = true;
				ASSPlayer.PlayOneShot(ResultClips[2]);
				ASSPlayer.PlayOneShot(ResultClips[3]);
				FlyStar1T.gameObject.SetActive(value: true);
				FlyStar1T.localPosition = FlyStar1TLPos;
				starcount++;
				switch (starcount)
				{
				case 1:
					FlyStar1T.DOLocalMoveX(UnityEngine.Random.Range(-600, -500), StarFlyTime / 2f).SetEase(Ease.OutQuad).OnComplete(delegate
					{
						FlyStar1T.DOLocalMoveX(EndPos1.localPosition.x, StarFlyTime / 2f).SetEase(Ease.InQuad);
					});
					FlyStar1T.DOLocalMoveY(EndPos1.localPosition.y, StarFlyTime);
					FlyStar1T.DOSizeDelta(new Vector2(226.8f, 226.8f), StarFlyTime);
					break;
				case 2:
					FlyStar1T.DOLocalMoveX(UnityEngine.Random.Range(250, 450), StarFlyTime / 2f).SetEase(Ease.OutQuad).OnComplete(delegate
					{
						FlyStar1T.DOLocalMoveX(EndPos1.localPosition.x, StarFlyTime / 2f).SetEase(Ease.InQuad);
					});
					FlyStar1T.DOLocalMoveY(EndPos1.localPosition.y, StarFlyTime);
					FlyStar1T.DOSizeDelta(new Vector2(226.8f, 226.8f), StarFlyTime);
					break;
				case 3:
					FlyStar1T.DOLocalMoveX(UnityEngine.Random.Range(450, 550), StarFlyTime / 2f).SetEase(Ease.OutQuad).OnComplete(delegate
					{
						FlyStar1T.DOLocalMoveX(EndPos1.localPosition.x, StarFlyTime / 2f).SetEase(Ease.InQuad);
					});
					FlyStar1T.DOLocalMoveY(EndPos1.localPosition.y, StarFlyTime);
					FlyStar1T.DOSizeDelta(new Vector2(226.8f, 226.8f), StarFlyTime);
					break;
				}
				yield return new WaitForSeconds(StarFlyTime);
				ASSPlayer.PlayOneShot(ResultClips[4]);
			}
			if (GameManager.instance.m_InGameMissionData.InGameMissionDataList[1].isComplet)
			{
				Mission2BoardT.DOPunchScale(Vector3.one * 1.03f, 0.2f);
				ASSPlayer.PlayOneShot(ResultClips[1]);
				yield return new WaitForSeconds(0.2f);
				MissionStar2.enabled = true;
				ASSPlayer.PlayOneShot(ResultClips[2]);
				ASSPlayer.PlayOneShot(ResultClips[3]);
				FlyStar2T.gameObject.SetActive(value: true);
				FlyStar2T.localPosition = FlyStar2TLPos;
				starcount++;
				switch (starcount)
				{
				case 1:
					FlyStar2T.DOLocalMoveX(UnityEngine.Random.Range(-600, -500), StarFlyTime / 2f).SetEase(Ease.OutQuad).OnComplete(delegate
					{
						FlyStar2T.DOLocalMoveX(EndPos2.localPosition.x, StarFlyTime / 2f).SetEase(Ease.InQuad);
					});
					FlyStar2T.DOLocalMoveY(EndPos2.localPosition.y, StarFlyTime);
					FlyStar2T.DOSizeDelta(new Vector2(226.8f, 226.8f), StarFlyTime);
					break;
				case 2:
					FlyStar2T.DOLocalMoveX(UnityEngine.Random.Range(250, 450), StarFlyTime / 2f).SetEase(Ease.OutQuad).OnComplete(delegate
					{
						FlyStar2T.DOLocalMoveX(EndPos2.localPosition.x, StarFlyTime / 2f).SetEase(Ease.InQuad);
					});
					FlyStar2T.DOLocalMoveY(EndPos2.localPosition.y, StarFlyTime);
					FlyStar2T.DOSizeDelta(new Vector2(226.8f, 226.8f), StarFlyTime);
					break;
				case 3:
					FlyStar2T.DOLocalMoveX(UnityEngine.Random.Range(450, 550), StarFlyTime / 2f).SetEase(Ease.OutQuad).OnComplete(delegate
					{
						FlyStar2T.DOLocalMoveX(EndPos2.localPosition.x, StarFlyTime / 2f).SetEase(Ease.InQuad);
					});
					FlyStar2T.DOLocalMoveY(EndPos2.localPosition.y, StarFlyTime);
					FlyStar2T.DOSizeDelta(new Vector2(226.8f, 226.8f), StarFlyTime);
					break;
				}
				yield return new WaitForSeconds(StarFlyTime);
				ASSPlayer.PlayOneShot(ResultClips[4]);
			}
			if (GameManager.instance.m_InGameMissionData.InGameMissionDataList[2].isComplet)
			{
				Mission3BoardT.DOPunchScale(Vector3.one * 1.03f, 0.2f);
				ASSPlayer.PlayOneShot(ResultClips[1]);
				yield return new WaitForSeconds(0.2f);
				ASSPlayer.PlayOneShot(ResultClips[2]);
				ASSPlayer.PlayOneShot(ResultClips[3]);
				MissionStar3.enabled = true;
				FlyStar3T.gameObject.SetActive(value: true);
				FlyStar3T.localPosition = FlyStar3TLPos;
				switch (starcount)
				{
				case 0:
					FlyStar3T.DOLocalMoveX(UnityEngine.Random.Range(-600, -500), StarFlyTime / 2f).SetEase(Ease.OutQuad).OnComplete(delegate
					{
						FlyStar3T.DOLocalMoveX(EndPos3.localPosition.x, StarFlyTime / 2f).SetEase(Ease.InQuad);
					});
					FlyStar3T.DOLocalMoveY(EndPos3.localPosition.y, StarFlyTime);
					FlyStar3T.DOSizeDelta(new Vector2(226.8f, 226.8f), StarFlyTime);
					break;
				case 1:
					FlyStar3T.DOLocalMoveX(UnityEngine.Random.Range(250, 450), StarFlyTime / 2f).SetEase(Ease.OutQuad).OnComplete(delegate
					{
						FlyStar3T.DOLocalMoveX(EndPos3.localPosition.x, StarFlyTime / 2f).SetEase(Ease.InQuad);
					});
					FlyStar3T.DOLocalMoveY(EndPos3.localPosition.y, StarFlyTime);
					FlyStar3T.DOSizeDelta(new Vector2(226.8f, 226.8f), StarFlyTime);
					break;
				case 2:
					FlyStar3T.DOLocalMoveX(UnityEngine.Random.Range(450, 550), StarFlyTime / 2f).SetEase(Ease.OutQuad).OnComplete(delegate
					{
						FlyStar3T.DOLocalMoveX(EndPos3.localPosition.x, StarFlyTime / 2f).SetEase(Ease.InQuad);
					});
					FlyStar3T.DOLocalMoveY(EndPos3.localPosition.y, StarFlyTime);
					FlyStar3T.DOSizeDelta(new Vector2(226.8f, 226.8f), StarFlyTime);
					break;
				}
				yield return new WaitForSeconds(StarFlyTime);
				ASSPlayer.PlayOneShot(ResultClips[4]);
			}
			float distance = (isFake ? 5000f : (GameManager.LevelManager.TotalDistance * GameManager.Player.hd.BasicData.ScoreMultiplier * GameManager.Player.scoreBuffVal));
			float record = 0f;
			record = ((!isFake) ? csPlayerData.PlayerLevelDataDic[csGameSettings.CurrentSelectedLevel].BestScore : 0);
			ASSPlayer.Play();
			SimpleTweener.AddTween(() => 0, delegate(int x)
			{
				ScoreText.text = Mathf.CeilToInt(x).ToString();
			}, (int)distance, 0.5f).Delay(0.2f).OnCompleted(delegate
			{
				KickItem(ScoreText.transform, 1.5f, 0.3f);
				oldRecordText.text = record.ToString();
				KickItem(oldRecordText.transform, 1.5f, 0.3f);
				ASSPlayer.Stop();
				ASSPlayer.PlayOneShot(ResultClips[6]);
				StartCoroutine(TryGetLevelBox());
				if (distance >= record || isFake)
				{
					NewRecordObj.SetActive(value: true);
					tweener.DOPlay();
					ASSPlayer.PlayOneShot(ResultClips[7]);
				}
				else
				{
					NewRecordObj.SetActive(value: false);
				}
			});
		}

		public IEnumerator TryGetLevelBox()
		{
			ResultBoxPanel.LevelStarP.SetStarProgress(csPlayerData.GetStarsNum());
			ResultBoxPanel.HideMain();
			bool isStarBox = false;
			if (csGameData.Instance.GetClosestStarAwardStarNum(csPlayerData.GetStarsNum()) > csPlayerData.GetCurAwardStarNum())
			{
				List<ResultAwardData> list = new List<ResultAwardData>();
				LevelAwardData closestStarAwardData = csGameData.Instance.GetClosestStarAwardData(csPlayerData.GetStarsNum());
				if (closestStarAwardData.CoinNum > 0)
				{
					list.Add(new ResultAwardData(closestStarAwardData.CoinNum, 0, AheadBuff.RushS, 0));
				}
				if (closestStarAwardData.GemNum > 0)
				{
					list.Add(new ResultAwardData(0, closestStarAwardData.GemNum, AheadBuff.RushS, 0));
				}
				if (closestStarAwardData.LevelAward.Count > 0)
				{
					for (int i = 0; i < closestStarAwardData.LevelAward.Count; i++)
					{
						list.Add(new ResultAwardData(0, 0, closestStarAwardData.LevelAward[i].AwardBuff, closestStarAwardData.LevelAward[i].AwardNum));
					}
				}
				ResultBoxPanel.SetAwards(list, isStarAward: true);
				ResultBoxPanel.ShowMain();
				isStarBox = true;
			}
			else if ((float)UnityEngine.Random.Range(0, 100) < 100f * csGameData.Instance.GetLevelBoxRate(csGameSettings.CurrentSelectedLevel))
			{
				List<ResultAwardData> list2 = new List<ResultAwardData>();
				int rndBoxItemNum = csGameData.Instance.GetRndBoxItemNum();
				List<AwardItemType> list3 = new List<AwardItemType>();
				for (int j = 0; j < rndBoxItemNum; j++)
				{
					AwardItemType rndItemType = csGameData.Instance.GetRndItemType();
					while (list3.Contains(rndItemType))
					{
						rndItemType = csGameData.Instance.GetRndItemType();
					}
					list3.Add(rndItemType);
					switch (rndItemType)
					{
					case AwardItemType.Coin:
					{
						ResultAwardData item3 = new ResultAwardData(csGameData.Instance.GetRndCoinItemNum(), 0, AheadBuff.RushS, 0);
						list2.Add(item3);
						break;
					}
					case AwardItemType.Gem:
					{
						ResultAwardData item2 = new ResultAwardData(0, csGameData.Instance.GetRndGemItemNum(), AheadBuff.RushS, 0);
						list2.Add(item2);
						break;
					}
					case AwardItemType.Prop:
					{
						BuffAwardRightData rndBuffItem = csGameData.Instance.GetRndBuffItem();
						ResultAwardData item = new ResultAwardData(0, 0, rndBuffItem.BuffType, rndBuffItem.BuffNum);
						list2.Add(item);
						break;
					}
					}
				}
				ResultBoxPanel.SetAwards(list2, isStarAward: false);
				ResultBoxPanel.ShowMain();
			}
			ResultBoxPanel.Show(withStar: true, isStarBox);
			yield return null;
		}

		private void ShowAcievemntAnim()
		{
			if (AchievementItemList.Count > 0)
			{
				for (int i = 0; i < AchievementItemList.Count; i++)
				{
					UnityEngine.Object.Destroy(AchievementItemList[i].gameObject);
				}
				AchievementItemList = new List<GameObject>();
			}
			if (GameManager.instance.TempAchievementList.Count == 0)
			{
				Achievement.gameObject.SetActive(value: false);
				return;
			}
			Achievement.gameObject.SetActive(value: true);
			StartCoroutine(AchievementAnim(GameManager.instance.TempAchievementList));
		}

		private IEnumerator AchievementAnim(List<AchievementType> list)
		{
			IngameAchievementParent.anchoredPosition = InitAchievementParentPos;
			for (int i = 0; i < list.Count; i++)
			{
				CreateAchievementItem(list[i]);
				yield return new WaitForSeconds(moveTime);
				float y = IngameAchievementParent.anchoredPosition.y;
				y += m_GridLayoutGroup.cellSize.y;
				IngameAchievementParent.DOAnchorPosY(y, moveTime);
			}
		}

		private void CreateAchievementItem(AchievementType type)
		{
			GameObject gameObject = UnityEngine.Object.Instantiate(IngameAchievementItemPrefab, IngameAchievementParent);
			gameObject.transform.localScale = Vector3.one;
			gameObject.transform.localPosition = Vector3.zero;
			gameObject.transform.localRotation = Quaternion.identity;
			gameObject.GetComponent<csIngameAchievementItem>().Init(type);
			AchievementItemList.Add(gameObject);
		}
	}
}
namespace Forge3D
{
	[ExecuteInEditMode]
	public class F3DParticleScale : MonoBehaviour
	{
		[Range(0f, 20f)]
		public float ParticleScale = 1f;

		public bool ScaleGameobject = true;

		private float prevScale;

		private void Start()
		{
			prevScale = ParticleScale;
		}

		private void ScaleShurikenSystems(float scaleFactor)
		{
		}

		private void ScaleTrailRenderers(float scaleFactor)
		{
			TrailRenderer[] componentsInChildren = GetComponentsInChildren<TrailRenderer>();
			foreach (TrailRenderer obj in componentsInChildren)
			{
				obj.startWidth *= scaleFactor;
				obj.endWidth *= scaleFactor;
			}
		}

		private void Update()
		{
		}
	}
}
namespace UnityEngine.UI
{
	[AddComponentMenu("UI/Raycast Filters/Ignore Raycast Filter")]
	public class UIIgnoreRaycast : MonoBehaviour, ICanvasRaycastFilter
	{
		public bool IsRaycastLocationValid(Vector2 sp, Camera eventCamera)
		{
			return false;
		}
	}
}
namespace Wacki
{
	public abstract class IUILaserPointer : MonoBehaviour
	{
		public float laserThickness = 0.002f;

		public float laserHitScale = 0.02f;

		public bool laserAlwaysOn;

		public Color color;

		private GameObject hitPoint;

		private GameObject pointer;

		private float _distanceLimit;

		private void Start()
		{
			pointer = GameObject.CreatePrimitive(PrimitiveType.Cube);
			pointer.transform.SetParent(base.transform, worldPositionStays: false);
			pointer.transform.localScale = new Vector3(laserThickness, laserThickness, 100f);
			pointer.transform.localPosition = new Vector3(0f, 0f, 50f);
			hitPoint = GameObject.CreatePrimitive(PrimitiveType.Sphere);
			hitPoint.transform.SetParent(base.transform, worldPositionStays: false);
			hitPoint.transform.localScale = new Vector3(laserHitScale, laserHitScale, laserHitScale);
			hitPoint.transform.localPosition = new Vector3(0f, 0f, 100f);
			hitPoint.SetActive(value: false);
			UnityEngine.Object.DestroyImmediate(hitPoint.GetComponent<SphereCollider>());
			UnityEngine.Object.DestroyImmediate(pointer.GetComponent<BoxCollider>());
			Material material = new Material(Shader.Find("UI/OptionalZTest"));
			material.renderQueue = 3005;
			material.SetColor("_Color", color);
			pointer.GetComponent<MeshRenderer>().material = material;
			hitPoint.GetComponent<MeshRenderer>().material = material;
			Initialize();
			if (LaserPointerInputModule.instance == null)
			{
				new GameObject().AddComponent<LaserPointerInputModule>();
			}
			LaserPointerInputModule.instance.AddController(this);
		}

		private void OnDisable()
		{
			if ((bool)hitPoint)
			{
				hitPoint.SetActive(value: false);
			}
			if ((bool)pointer)
			{
				pointer.SetActive(value: false);
			}
		}

		private void OnDestroy()
		{
			if (LaserPointerInputModule.instance != null)
			{
				LaserPointerInputModule.instance.RemoveController(this);
			}
		}

		protected virtual void Initialize()
		{
		}

		public virtual void OnEnterControl(GameObject control)
		{
		}

		public virtual void OnExitControl(GameObject control)
		{
		}

		public abstract bool ButtonDown();

		public abstract bool ButtonUp();

		protected virtual void Update()
		{
			RaycastHit hitInfo;
			bool flag = Physics.Raycast(new Ray(base.transform.position, base.transform.forward), out hitInfo, 10f, 8388608);
			float num = 5f;
			if (flag)
			{
				num = hitInfo.distance;
			}
			if (_distanceLimit > 0f)
			{
				num = Mathf.Min(num, _distanceLimit);
				flag = true;
			}
			pointer.transform.localScale = new Vector3(laserThickness, laserThickness, num);
			pointer.transform.localPosition = new Vector3(0f, 0f, num * 0.5f);
			if (flag)
			{
				pointer.SetActive(value: true);
				hitPoint.SetActive(value: true);
				hitPoint.transform.localPosition = new Vector3(0f, 0f, num);
				if (csEffectManager.instance != null)
				{
					csEffectManager.instance.hitPosition = hitPoint.transform.position;
				}
			}
			else
			{
				hitPoint.SetActive(value: false);
				if (!laserAlwaysOn)
				{
					pointer.SetActive(value: false);
				}
			}
			_distanceLimit = -1f;
		}

		public virtual void LimitLaserDistance(float distance)
		{
			if (!(distance < 0f))
			{
				if (_distanceLimit < 0f)
				{
					_distanceLimit = distance;
				}
				else
				{
					_distanceLimit = Mathf.Min(_distanceLimit, distance);
				}
			}
		}
	}
	public class LaserPointerEventData : PointerEventData
	{
		public GameObject current;

		public IUILaserPointer controller;

		public LaserPointerEventData(EventSystem e)
			: base(e)
		{
		}

		public override void Reset()
		{
			current = null;
			controller = null;
			base.Reset();
		}
	}
	public class LaserPointerInputModule : BaseInputModule
	{
		private class ControllerData
		{
			public LaserPointerEventData pointerEvent;

			public GameObject currentPoint;

			public GameObject currentPressed;

			public GameObject currentDragging;
		}

		private static LaserPointerInputModule _instance;

		public LayerMask layerMask;

		private Camera UICamera;

		private PhysicsRaycaster raycaster;

		private HashSet<IUILaserPointer> _controllers;

		private Dictionary<IUILaserPointer, ControllerData> _controllerData = new Dictionary<IUILaserPointer, ControllerData>();

		public static LaserPointerInputModule instance => _instance;

		protected override void Awake()
		{
			base.Awake();
			if (_instance != null)
			{
				UnityEngine.Debug.LogWarning("Trying to instantiate multiple LaserPointerInputModule.");
				UnityEngine.Object.DestroyImmediate(base.gameObject);
			}
			_instance = this;
		}

		public void EnableLaserUI(bool isEnable)
		{
			base.enabled = isEnable;
			for (int i = 0; i < _controllerData.Count; i++)
			{
				if (csGameSettings.Channel == ChannelType.OculusGO || csGameSettings.Channel == ChannelType.WaveVR_3Dof)
				{
					_controllerData.Keys.ToArray()[i].enabled = isEnable;
				}
				else if (isEnable)
				{
					if (_controllerData.Keys.ToArray()[i].GetComponent<ViveUILaserPointer>().isLeft && csGameSettings.IsLeftMove)
					{
						_controllerData.Keys.ToArray()[i].enabled = isEnable;
					}
					else if (!_controllerData.Keys.ToArray()[i].GetComponent<ViveUILaserPointer>().isLeft && !csGameSettings.IsLeftMove)
					{
						_controllerData.Keys.ToArray()[i].enabled = isEnable;
					}
				}
				else
				{
					_controllerData.Keys.ToArray()[i].enabled = isEnable;
				}
			}
		}

		protected override void Start()
		{
			base.Start();
			UICamera = new GameObject("UI Camera").AddComponent<Camera>();
			raycaster = UICamera.gameObject.AddComponent<PhysicsRaycaster>();
			UICamera.clearFlags = CameraClearFlags.Nothing;
			UICamera.stereoTargetEye = StereoTargetEyeMask.None;
			UICamera.enabled = false;
			UICamera.fieldOfView = 5f;
			UICamera.nearClipPlane = 0.01f;
			Canvas[] array = Resources.FindObjectsOfTypeAll<Canvas>();
			for (int i = 0; i < array.Length; i++)
			{
				array[i].worldCamera = UICamera;
			}
		}

		public void ResetCanvas()
		{
			Start();
		}

		public void AddController(IUILaserPointer controller)
		{
			_controllerData.Add(controller, new ControllerData());
		}

		public void RemoveController(IUILaserPointer controller)
		{
			_controllerData.Remove(controller);
		}

		protected void UpdateCameraPosition(IUILaserPointer controller)
		{
			UICamera.transform.position = controller.transform.position;
			UICamera.transform.rotation = controller.transform.rotation;
		}

		public void ClearSelection()
		{
			if ((bool)base.eventSystem.currentSelectedGameObject)
			{
				base.eventSystem.SetSelectedGameObject(null);
			}
		}

		private void Select(GameObject go)
		{
			ClearSelection();
			if ((bool)ExecuteEvents.GetEventHandler<ISelectHandler>(go))
			{
				base.eventSystem.SetSelectedGameObject(go);
			}
		}

		public override void Process()
		{
			raycaster.eventMask = layerMask;
			foreach (KeyValuePair<IUILaserPointer, ControllerData> controllerDatum in _controllerData)
			{
				if (!controllerDatum.Key.enabled)
				{
					continue;
				}
				IUILaserPointer key = controllerDatum.Key;
				ControllerData value = controllerDatum.Value;
				UpdateCameraPosition(key);
				if (value.pointerEvent == null)
				{
					value.pointerEvent = new LaserPointerEventData(base.eventSystem);
				}
				else
				{
					value.pointerEvent.Reset();
				}
				value.pointerEvent.controller = key;
				value.pointerEvent.delta = Vector2.zero;
				value.pointerEvent.position = new Vector2((float)UICamera.pixelWidth * 0.5f, (float)UICamera.pixelHeight * 0.5f);
				base.eventSystem.RaycastAll(value.pointerEvent, m_RaycastResultCache);
				value.pointerEvent.pointerCurrentRaycast = BaseInputModule.FindFirstRaycast(m_RaycastResultCache);
				m_RaycastResultCache.Clear();
				if (controllerDatum.Value.pointerEvent.pointerCurrentRaycast.gameObject == null || (layerMask.value & (int)Mathf.Pow(2f, controllerDatum.Value.pointerEvent.pointerCurrentRaycast.gameObject.layer)) != (int)Mathf.Pow(2f, controllerDatum.Value.pointerEvent.pointerCurrentRaycast.gameObject.layer) || (csGameSettings.HintUIOnly && controllerDatum.Value.pointerEvent.pointerCurrentRaycast.gameObject.layer == 5))
				{
					continue;
				}
				if (value.pointerEvent.pointerCurrentRaycast.distance > 0f)
				{
					key.LimitLaserDistance(value.pointerEvent.pointerCurrentRaycast.distance + 0.01f);
				}
				GameObject gameObject = value.pointerEvent.pointerCurrentRaycast.gameObject;
				if (value.currentPoint != gameObject)
				{
					if (value.currentPoint != null)
					{
						key.OnExitControl(value.currentPoint);
					}
					if (gameObject != null)
					{
						key.OnEnterControl(gameObject);
					}
				}
				value.currentPoint = gameObject;
				HandlePointerExitAndEnter(value.pointerEvent, value.currentPoint);
				if (key.ButtonDown() && !csGameSettings.IsLoading)
				{
					ClearSelection();
					value.pointerEvent.pressPosition = value.pointerEvent.position;
					value.pointerEvent.pointerPressRaycast = value.pointerEvent.pointerCurrentRaycast;
					value.pointerEvent.pointerPress = null;
					if (value.currentPoint != null)
					{
						value.currentPressed = value.currentPoint;
						value.pointerEvent.current = value.currentPressed;
						GameObject gameObject2 = ExecuteEvents.ExecuteHierarchy(value.currentPressed, value.pointerEvent, ExecuteEvents.pointerDownHandler);
						ExecuteEvents.Execute(key.gameObject, value.pointerEvent, ExecuteEvents.pointerDownHandler);
						if (gameObject2 == null)
						{
							gameObject2 = ExecuteEvents.ExecuteHierarchy(value.currentPressed, value.pointerEvent, ExecuteEvents.pointerClickHandler);
							ExecuteEvents.Execute(key.gameObject, value.pointerEvent, ExecuteEvents.pointerClickHandler);
							if (gameObject2 != null)
							{
								value.currentPressed = gameObject2;
							}
						}
						else
						{
							value.currentPressed = gameObject2;
							ExecuteEvents.Execute(gameObject2, value.pointerEvent, ExecuteEvents.pointerClickHandler);
							ExecuteEvents.Execute(key.gameObject, value.pointerEvent, ExecuteEvents.pointerClickHandler);
						}
						if (gameObject2 != null)
						{
							value.pointerEvent.pointerPress = gameObject2;
							value.currentPressed = gameObject2;
							Select(value.currentPressed);
						}
						ExecuteEvents.Execute(value.currentPressed, value.pointerEvent, ExecuteEvents.beginDragHandler);
						ExecuteEvents.Execute(key.gameObject, value.pointerEvent, ExecuteEvents.beginDragHandler);
						value.pointerEvent.pointerDrag = value.currentPressed;
						value.currentDragging = value.currentPressed;
					}
					if ((bool)csEffectManager.instance)
					{
						csEffectManager.instance.PlayClickEffect();
					}
				}
				if (key.ButtonUp() && !csGameSettings.IsLoading)
				{
					if (value.currentDragging != null)
					{
						value.pointerEvent.current = value.currentDragging;
						ExecuteEvents.Execute(value.currentDragging, value.pointerEvent, ExecuteEvents.endDragHandler);
						ExecuteEvents.Execute(key.gameObject, value.pointerEvent, ExecuteEvents.endDragHandler);
						if (value.currentPoint != null)
						{
							ExecuteEvents.ExecuteHierarchy(value.currentPoint, value.pointerEvent, ExecuteEvents.dropHandler);
						}
						value.pointerEvent.pointerDrag = null;
						value.currentDragging = null;
					}
					if ((bool)value.currentPressed)
					{
						value.pointerEvent.current = value.currentPressed;
						ExecuteEvents.Execute(value.currentPressed, value.pointerEvent, ExecuteEvents.pointerUpHandler);
						ExecuteEvents.Execute(key.gameObject, value.pointerEvent, ExecuteEvents.pointerUpHandler);
						value.pointerEvent.rawPointerPress = null;
						value.pointerEvent.pointerPress = null;
						value.currentPressed = null;
					}
				}
				if (value.currentDragging != null)
				{
					value.pointerEvent.current = value.currentPressed;
					ExecuteEvents.Execute(value.currentDragging, value.pointerEvent, ExecuteEvents.dragHandler);
					ExecuteEvents.Execute(key.gameObject, value.pointerEvent, ExecuteEvents.dragHandler);
				}
				if (base.eventSystem.currentSelectedGameObject != null)
				{
					value.pointerEvent.current = base.eventSystem.currentSelectedGameObject;
					ExecuteEvents.Execute(base.eventSystem.currentSelectedGameObject, GetBaseEventData(), ExecuteEvents.updateSelectedHandler);
				}
			}
		}
	}
	public class ViveUILaserPointer : IUILaserPointer
	{
		private bool _connected;

		public csControllerForSteamVR RayHand;

		public bool isLeft;

		protected override void Initialize()
		{
			base.Initialize();
			if ((bool)RayHand)
			{
				_connected = true;
			}
			_connected = true;
		}

		public override bool ButtonDown()
		{
			if (!_connected)
			{
				return false;
			}
			return csControllerForSteamVR.GetPressDown_TriggerOC(isLeft);
		}

		public override bool ButtonUp()
		{
			if (!_connected)
			{
				return false;
			}
			csControllerForSteamVR.GetPressUp_TriggerOC(isLeft);
			return false;
		}

		public override void OnEnterControl(GameObject control)
		{
			if (_connected && csPlayerData.VibrationSwitch)
			{
				csControllerForSteamVR.TriggerHapticPulse_OC(isLeft, 800);
			}
		}

		public override void OnExitControl(GameObject control)
		{
			_ = _connected;
		}
	}
}
namespace Ionic.Zlib
{
	internal enum BlockState
	{
		NeedMore,
		BlockDone,
		FinishStarted,
		FinishDone
	}
	internal enum DeflateFlavor
	{
		Store,
		Fast,
		Slow
	}
	internal sealed class DeflateManager
	{
		internal delegate BlockState CompressFunc(FlushType flush);

		internal class Config
		{
			internal int GoodLength;

			internal int MaxLazy;

			internal int NiceLength;

			internal int MaxChainLength;

			internal DeflateFlavor Flavor;

			private static readonly Config[] Table;

			private Config(int goodLength, int maxLazy, int niceLength, int maxChainLength, DeflateFlavor flavor)
			{
				GoodLength = goodLength;
				MaxLazy = maxLazy;
				NiceLength = niceLength;
				MaxChainLength = maxChainLength;
				Flavor = flavor;
			}

			public static Config Lookup(CompressionLevel level)
			{
				return Table[(int)level];
			}

			static Config()
			{
				Table = new Config[10]
				{
					new Config(0, 0, 0, 0, DeflateFlavor.Store),
					new Config(4, 4, 8, 4, DeflateFlavor.Fast),
					new Config(4, 5, 16, 8, DeflateFlavor.Fast),
					new Config(4, 6, 32, 32, DeflateFlavor.Fast),
					new Config(4, 4, 16, 16, DeflateFlavor.Slow),
					new Config(8, 16, 32, 32, DeflateFlavor.Slow),
					new Config(8, 16, 128, 128, DeflateFlavor.Slow),
					new Config(8, 32, 128, 256, DeflateFlavor.Slow),
					new Config(32, 128, 258, 1024, DeflateFlavor.Slow),
					new Config(32, 258, 258, 4096, DeflateFlavor.Slow)
				};
			}
		}

		private static readonly int MEM_LEVEL_MAX = 9;

		private static readonly int MEM_LEVEL_DEFAULT = 8;

		private CompressFunc DeflateFunction;

		private static readonly string[] _ErrorMessage = new string[10] { "need dictionary", "stream end", "", "file error", "stream error", "data error", "insufficient memory", "buffer error", "incompatible version", "" };

		private static readonly int PRESET_DICT = 32;

		private static readonly int INIT_STATE = 42;

		private static readonly int BUSY_STATE = 113;

		private static readonly int FINISH_STATE = 666;

		private static readonly int Z_DEFLATED = 8;

		private static readonly int STORED_BLOCK = 0;

		private static readonly int STATIC_TREES = 1;

		private static readonly int DYN_TREES = 2;

		private static readonly int Z_BINARY = 0;

		private static readonly int Z_ASCII = 1;

		private static readonly int Z_UNKNOWN = 2;

		private static readonly int Buf_size = 16;

		private static readonly int MIN_MATCH = 3;

		private static readonly int MAX_MATCH = 258;

		private static readonly int MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;

		private static readonly int HEAP_SIZE = 2 * InternalConstants.L_CODES + 1;

		private static readonly int END_BLOCK = 256;

		internal ZlibCodec _codec;

		internal int status;

		internal byte[] pending;

		internal int nextPending;

		internal int pendingCount;

		internal sbyte data_type;

		internal int last_flush;

		internal int w_size;

		internal int w_bits;

		internal int w_mask;

		internal byte[] window;

		internal int window_size;

		internal short[] prev;

		internal short[] head;

		internal int ins_h;

		internal int hash_size;

		internal int hash_bits;

		internal int hash_mask;

		internal int hash_shift;

		internal int block_start;

		private Config config;

		internal int match_length;

		internal int prev_match;

		internal int match_available;

		internal int strstart;

		internal int match_start;

		internal int lookahead;

		internal int prev_length;

		internal CompressionLevel compressionLevel;

		internal CompressionStrategy compressionStrategy;

		internal short[] dyn_ltree;

		internal short[] dyn_dtree;

		internal short[] bl_tree;

		internal ZTree treeLiterals = new ZTree();

		internal ZTree treeDistances = new ZTree();

		internal ZTree treeBitLengths = new ZTree();

		internal short[] bl_count = new short[InternalConstants.MAX_BITS + 1];

		internal int[] heap = new int[2 * InternalConstants.L_CODES + 1];

		internal int heap_len;

		internal int heap_max;

		internal sbyte[] depth = new sbyte[2 * InternalConstants.L_CODES + 1];

		internal int _lengthOffset;

		internal int lit_bufsize;

		internal int last_lit;

		internal int _distanceOffset;

		internal int opt_len;

		internal int static_len;

		internal int matches;

		internal int last_eob_len;

		internal short bi_buf;

		internal int bi_valid;

		private bool Rfc1950BytesEmitted;

		private bool _WantRfc1950HeaderBytes = true;

		internal bool WantRfc1950HeaderBytes
		{
			get
			{
				return _WantRfc1950HeaderBytes;
			}
			set
			{
				_WantRfc1950HeaderBytes = value;
			}
		}

		internal DeflateManager()
		{
			dyn_ltree = new short[HEAP_SIZE * 2];
			dyn_dtree = new short[(2 * InternalConstants.D_CODES + 1) * 2];
			bl_tree = new short[(2 * InternalConstants.BL_CODES + 1) * 2];
		}

		private void _InitializeLazyMatch()
		{
			window_size = 2 * w_size;
			Array.Clear(head, 0, hash_size);
			config = Config.Lookup(compressionLevel);
			SetDeflater();
			strstart = 0;
			block_start = 0;
			lookahead = 0;
			match_length = (prev_length = MIN_MATCH - 1);
			match_available = 0;
			ins_h = 0;
		}

		private void _InitializeTreeData()
		{
			treeLiterals.dyn_tree = dyn_ltree;
			treeLiterals.staticTree = StaticTree.Literals;
			treeDistances.dyn_tree = dyn_dtree;
			treeDistances.staticTree = StaticTree.Distances;
			treeBitLengths.dyn_tree = bl_tree;
			treeBitLengths.staticTree = StaticTree.BitLengths;
			bi_buf = 0;
			bi_valid = 0;
			last_eob_len = 8;
			_InitializeBlocks();
		}

		internal void _InitializeBlocks()
		{
			for (int i = 0; i < InternalConstants.L_CODES; i++)
			{
				dyn_ltree[i * 2] = 0;
			}
			for (int j = 0; j < InternalConstants.D_CODES; j++)
			{
				dyn_dtree[j * 2] = 0;
			}
			for (int k = 0; k < InternalConstants.BL_CODES; k++)
			{
				bl_tree[k * 2] = 0;
			}
			dyn_ltree[END_BLOCK * 2] = 1;
			opt_len = (static_len = 0);
			last_lit = (matches = 0);
		}

		internal void pqdownheap(short[] tree, int k)
		{
			int num = heap[k];
			for (int num2 = k << 1; num2 <= heap_len; num2 <<= 1)
			{
				if (num2 < heap_len && _IsSmaller(tree, heap[num2 + 1], heap[num2], depth))
				{
					num2++;
				}
				if (_IsSmaller(tree, num, heap[num2], depth))
				{
					break;
				}
				heap[k] = heap[num2];
				k = num2;
			}
			heap[k] = num;
		}

		internal static bool _IsSmaller(short[] tree, int n, int m, sbyte[] depth)
		{
			short num = tree[n * 2];
			short num2 = tree[m * 2];
			if (num >= num2)
			{
				if (num == num2)
				{
					return depth[n] <= depth[m];
				}
				return false;
			}
			return true;
		}

		internal void scan_tree(short[] tree, int max_code)
		{
			int num = -1;
			int num2 = tree[1];
			int num3 = 0;
			int num4 = 7;
			int num5 = 4;
			if (num2 == 0)
			{
				num4 = 138;
				num5 = 3;
			}
			tree[(max_code + 1) * 2 + 1] = short.MaxValue;
			for (int i = 0; i <= max_code; i++)
			{
				int num6 = num2;
				num2 = tree[(i + 1) * 2 + 1];
				if (++num3 < num4 && num6 == num2)
				{
					continue;
				}
				if (num3 < num5)
				{
					bl_tree[num6 * 2] = (short)(bl_tree[num6 * 2] + num3);
				}
				else if (num6 != 0)
				{
					if (num6 != num)
					{
						bl_tree[num6 * 2]++;
					}
					bl_tree[InternalConstants.REP_3_6 * 2]++;
				}
				else if (num3 <= 10)
				{
					bl_tree[InternalConstants.REPZ_3_10 * 2]++;
				}
				else
				{
					bl_tree[InternalConstants.REPZ_11_138 * 2]++;
				}
				num3 = 0;
				num = num6;
				if (num2 == 0)
				{
					num4 = 138;
					num5 = 3;
				}
				else if (num6 == num2)
				{
					num4 = 6;
					num5 = 3;
				}
				else
				{
					num4 = 7;
					num5 = 4;
				}
			}
		}

		internal int build_bl_tree()
		{
			scan_tree(dyn_ltree, treeLiterals.max_code);
			scan_tree(dyn_dtree, treeDistances.max_code);
			treeBitLengths.build_tree(this);
			int num = InternalConstants.BL_CODES - 1;
			while (num >= 3 && bl_tree[ZTree.bl_order[num] * 2 + 1] == 0)
			{
				num--;
			}
			opt_len += 3 * (num + 1) + 5 + 5 + 4;
			return num;
		}

		internal void send_all_trees(int lcodes, int dcodes, int blcodes)
		{
			send_bits(lcodes - 257, 5);
			send_bits(dcodes - 1, 5);
			send_bits(blcodes - 4, 4);
			for (int i = 0; i < blcodes; i++)
			{
				send_bits(bl_tree[ZTree.bl_order[i] * 2 + 1], 3);
			}
			send_tree(dyn_ltree, lcodes - 1);
			send_tree(dyn_dtree, dcodes - 1);
		}

		internal void send_tree(short[] tree, int max_code)
		{
			int num = -1;
			int num2 = tree[1];
			int num3 = 0;
			int num4 = 7;
			int num5 = 4;
			if (num2 == 0)
			{
				num4 = 138;
				num5 = 3;
			}
			for (int i = 0; i <= max_code; i++)
			{
				int num6 = num2;
				num2 = tree[(i + 1) * 2 + 1];
				if (++num3 < num4 && num6 == num2)
				{
					continue;
				}
				if (num3 < num5)
				{
					do
					{
						send_code(num6, bl_tree);
					}
					while (--num3 != 0);
				}
				else if (num6 != 0)
				{
					if (num6 != num)
					{
						send_code(num6, bl_tree);
						num3--;
					}
					send_code(InternalConstants.REP_3_6, bl_tree);
					send_bits(num3 - 3, 2);
				}
				else if (num3 <= 10)
				{
					send_code(InternalConstants.REPZ_3_10, bl_tree);
					send_bits(num3 - 3, 3);
				}
				else
				{
					send_code(InternalConstants.REPZ_11_138, bl_tree);
					send_bits(num3 - 11, 7);
				}
				num3 = 0;
				num = num6;
				if (num2 == 0)
				{
					num4 = 138;
					num5 = 3;
				}
				else if (num6 == num2)
				{
					num4 = 6;
					num5 = 3;
				}
				else
				{
					num4 = 7;
					num5 = 4;
				}
			}
		}

		private void put_bytes(byte[] p, int start, int len)
		{
			Array.Copy(p, start, pending, pendingCount, len);
			pendingCount += len;
		}

		internal void send_code(int c, short[] tree)
		{
			int num = c * 2;
			send_bits(tree[num] & 0xFFFF, tree[num + 1] & 0xFFFF);
		}

		internal void send_bits(int value, int length)
		{
			if (bi_valid > Buf_size - length)
			{
				bi_buf |= (short)((value << bi_valid) & 0xFFFF);
				pending[pendingCount++] = (byte)bi_buf;
				pending[pendingCount++] = (byte)(bi_buf >> 8);
				bi_buf = (short)(value >>> Buf_size - bi_valid);
				bi_valid += length - Buf_size;
			}
			else
			{
				bi_buf |= (short)((value << bi_valid) & 0xFFFF);
				bi_valid += length;
			}
		}

		internal void _tr_align()
		{
			send_bits(STATIC_TREES << 1, 3);
			send_code(END_BLOCK, StaticTree.lengthAndLiteralsTreeCodes);
			bi_flush();
			if (1 + last_eob_len + 10 - bi_valid < 9)
			{
				send_bits(STATIC_TREES << 1, 3);
				send_code(END_BLOCK, StaticTree.lengthAndLiteralsTreeCodes);
				bi_flush();
			}
			last_eob_len = 7;
		}

		internal bool _tr_tally(int dist, int lc)
		{
			pending[_distanceOffset + last_lit * 2] = (byte)((uint)dist >> 8);
			pending[_distanceOffset + last_lit * 2 + 1] = (byte)dist;
			pending[_lengthOffset + last_lit] = (byte)lc;
			last_lit++;
			if (dist == 0)
			{
				dyn_ltree[lc * 2]++;
			}
			else
			{
				matches++;
				dist--;
				dyn_ltree[(ZTree.LengthCode[lc] + InternalConstants.LITERALS + 1) * 2]++;
				dyn_dtree[ZTree.DistanceCode(dist) * 2]++;
			}
			if ((last_lit & 0x1FFF) == 0 && compressionLevel > CompressionLevel.Level2)
			{
				int num = last_lit << 3;
				int num2 = strstart - block_start;
				for (int i = 0; i < InternalConstants.D_CODES; i++)
				{
					num = (int)(num + dyn_dtree[i * 2] * (5L + (long)ZTree.ExtraDistanceBits[i]));
				}
				num >>= 3;
				if (matches < last_lit / 2 && num < num2 / 2)
				{
					return true;
				}
			}
			if (last_lit != lit_bufsize - 1)
			{
				return last_lit == lit_bufsize;
			}
			return true;
		}

		internal void send_compressed_block(short[] ltree, short[] dtree)
		{
			int num = 0;
			if (last_lit != 0)
			{
				do
				{
					int num2 = _distanceOffset + num * 2;
					int num3 = ((pending[num2] << 8) & 0xFF00) | (pending[num2 + 1] & 0xFF);
					int num4 = pending[_lengthOffset + num] & 0xFF;
					num++;
					if (num3 == 0)
					{
						send_code(num4, ltree);
						continue;
					}
					int num5 = ZTree.LengthCode[num4];
					send_code(num5 + InternalConstants.LITERALS + 1, ltree);
					int num6 = ZTree.ExtraLengthBits[num5];
					if (num6 != 0)
					{
						num4 -= ZTree.LengthBase[num5];
						send_bits(num4, num6);
					}
					num3--;
					num5 = ZTree.DistanceCode(num3);
					send_code(num5, dtree);
					num6 = ZTree.ExtraDistanceBits[num5];
					if (num6 != 0)
					{
						num3 -= ZTree.DistanceBase[num5];
						send_bits(num3, num6);
					}
				}
				while (num < last_lit);
			}
			send_code(END_BLOCK, ltree);
			last_eob_len = ltree[END_BLOCK * 2 + 1];
		}

		internal void set_data_type()
		{
			int i = 0;
			int num = 0;
			int num2 = 0;
			for (; i < 7; i++)
			{
				num2 += dyn_ltree[i * 2];
			}
			for (; i < 128; i++)
			{
				num += dyn_ltree[i * 2];
			}
			for (; i < InternalConstants.LITERALS; i++)
			{
				num2 += dyn_ltree[i * 2];
			}
			data_type = (sbyte)((num2 > num >> 2) ? Z_BINARY : Z_ASCII);
		}

		internal void bi_flush()
		{
			if (bi_valid == 16)
			{
				pending[pendingCount++] = (byte)bi_buf;
				pending[pendingCount++] = (byte)(bi_buf >> 8);
				bi_buf = 0;
				bi_valid = 0;
			}
			else if (bi_valid >= 8)
			{
				pending[pendingCount++] = (byte)bi_buf;
				bi_buf >>= 8;
				bi_valid -= 8;
			}
		}

		internal void bi_windup()
		{
			if (bi_valid > 8)
			{
				pending[pendingCount++] = (byte)bi_buf;
				pending[pendingCount++] = (byte)(bi_buf >> 8);
			}
			else if (bi_valid > 0)
			{
				pending[pendingCount++] = (byte)bi_buf;
			}
			bi_buf = 0;
			bi_valid = 0;
		}

		internal void copy_block(int buf, int len, bool header)
		{
			bi_windup();
			last_eob_len = 8;
			if (header)
			{
				pending[pendingCount++] = (byte)len;
				pending[pendingCount++] = (byte)(len >> 8);
				pending[pendingCount++] = (byte)(~len);
				pending[pendingCount++] = (byte)(~len >> 8);
			}
			put_bytes(window, buf, len);
		}

		internal void flush_block_only(bool eof)
		{
			_tr_flush_block((block_start >= 0) ? block_start : (-1), strstart - block_start, eof);
			block_start = strstart;
			_codec.flush_pending();
		}

		internal BlockState DeflateNone(FlushType flush)
		{
			int num = 65535;
			if (num > pending.Length - 5)
			{
				num = pending.Length - 5;
			}
			while (true)
			{
				if (lookahead <= 1)
				{
					_fillWindow();
					if (lookahead == 0 && flush == FlushType.None)
					{
						return BlockState.NeedMore;
					}
					if (lookahead == 0)
					{
						break;
					}
				}
				strstart += lookahead;
				lookahead = 0;
				int num2 = block_start + num;
				if (strstart == 0 || strstart >= num2)
				{
					lookahead = strstart - num2;
					strstart = num2;
					flush_block_only(eof: false);
					if (_codec.AvailableBytesOut == 0)
					{
						return BlockState.NeedMore;
					}
				}
				if (strstart - block_start >= w_size - MIN_LOOKAHEAD)
				{
					flush_block_only(eof: false);
					if (_codec.AvailableBytesOut == 0)
					{
						return BlockState.NeedMore;
					}
				}
			}
			flush_block_only(flush == FlushType.Finish);
			if (_codec.AvailableBytesOut == 0)
			{
				if (flush != FlushType.Finish)
				{
					return BlockState.NeedMore;
				}
				return BlockState.FinishStarted;
			}
			if (flush != FlushType.Finish)
			{
				return BlockState.BlockDone;
			}
			return BlockState.FinishDone;
		}

		internal void _tr_stored_block(int buf, int stored_len, bool eof)
		{
			send_bits((STORED_BLOCK << 1) + (eof ? 1 : 0), 3);
			copy_block(buf, stored_len, header: true);
		}

		internal void _tr_flush_block(int buf, int stored_len, bool eof)
		{
			int num = 0;
			int num2;
			int num3;
			if (compressionLevel > CompressionLevel.None)
			{
				if (data_type == Z_UNKNOWN)
				{
					set_data_type();
				}
				treeLiterals.build_tree(this);
				treeDistances.build_tree(this);
				num = build_bl_tree();
				num2 = opt_len + 3 + 7 >> 3;
				num3 = static_len + 3 + 7 >> 3;
				if (num3 <= num2)
				{
					num2 = num3;
				}
			}
			else
			{
				num2 = (num3 = stored_len + 5);
			}
			if (stored_len + 4 <= num2 && buf != -1)
			{
				_tr_stored_block(buf, stored_len, eof);
			}
			else if (num3 == num2)
			{
				send_bits((STATIC_TREES << 1) + (eof ? 1 : 0), 3);
				send_compressed_block(StaticTree.lengthAndLiteralsTreeCodes, StaticTree.distTreeCodes);
			}
			else
			{
				send_bits((DYN_TREES << 1) + (eof ? 1 : 0), 3);
				send_all_trees(treeLiterals.max_code + 1, treeDistances.max_code + 1, num + 1);
				send_compressed_block(dyn_ltree, dyn_dtree);
			}
			_InitializeBlocks();
			if (eof)
			{
				bi_windup();
			}
		}

		private void _fillWindow()
		{
			do
			{
				int num = window_size - lookahead - strstart;
				int num2;
				if (num == 0 && strstart == 0 && lookahead == 0)
				{
					num = w_size;
				}
				else if (num == -1)
				{
					num--;
				}
				else if (strstart >= w_size + w_size - MIN_LOOKAHEAD)
				{
					Array.Copy(window, w_size, window, 0, w_size);
					match_start -= w_size;
					strstart -= w_size;
					block_start -= w_size;
					num2 = hash_size;
					int num3 = num2;
					do
					{
						int num4 = head[--num3] & 0xFFFF;
						head[num3] = (short)((num4 >= w_size) ? (num4 - w_size) : 0);
					}
					while (--num2 != 0);
					num2 = w_size;
					num3 = num2;
					do
					{
						int num4 = prev[--num3] & 0xFFFF;
						prev[num3] = (short)((num4 >= w_size) ? (num4 - w_size) : 0);
					}
					while (--num2 != 0);
					num += w_size;
				}
				if (_codec.AvailableBytesIn == 0)
				{
					break;
				}
				num2 = _codec.read_buf(window, strstart + lookahead, num);
				lookahead += num2;
				if (lookahead >= MIN_MATCH)
				{
					ins_h = window[strstart] & 0xFF;
					ins_h = ((ins_h << hash_shift) ^ (window[strstart + 1] & 0xFF)) & hash_mask;
				}
			}
			while (lookahead < MIN_LOOKAHEAD && _codec.AvailableBytesIn != 0);
		}

		internal BlockState DeflateFast(FlushType flush)
		{
			int num = 0;
			while (true)
			{
				if (lookahead < MIN_LOOKAHEAD)
				{
					_fillWindow();
					if (lookahead < MIN_LOOKAHEAD && flush == FlushType.None)
					{
						return BlockState.NeedMore;
					}
					if (lookahead == 0)
					{
						break;
					}
				}
				if (lookahead >= MIN_MATCH)
				{
					ins_h = ((ins_h << hash_shift) ^ (window[strstart + (MIN_MATCH - 1)] & 0xFF)) & hash_mask;
					num = head[ins_h] & 0xFFFF;
					prev[strstart & w_mask] = head[ins_h];
					head[ins_h] = (short)strstart;
				}
				if (num != 0L && ((strstart - num) & 0xFFFF) <= w_size - MIN_LOOKAHEAD && compressionStrategy != CompressionStrategy.HuffmanOnly)
				{
					match_length = longest_match(num);
				}
				bool flag;
				if (match_length >= MIN_MATCH)
				{
					flag = _tr_tally(strstart - match_start, match_length - MIN_MATCH);
					lookahead -= match_length;
					if (match_length <= config.MaxLazy && lookahead >= MIN_MATCH)
					{
						match_length--;
						do
						{
							strstart++;
							ins_h = ((ins_h << hash_shift) ^ (window[strstart + (MIN_MATCH - 1)] & 0xFF)) & hash_mask;
							num = head[ins_h] & 0xFFFF;
							prev[strstart & w_mask] = head[ins_h];
							head[ins_h] = (short)strstart;
						}
						while (--match_length != 0);
						strstart++;
					}
					else
					{
						strstart += match_length;
						match_length = 0;
						ins_h = window[strstart] & 0xFF;
						ins_h = ((ins_h << hash_shift) ^ (window[strstart + 1] & 0xFF)) & hash_mask;
					}
				}
				else
				{
					flag = _tr_tally(0, window[strstart] & 0xFF);
					lookahead--;
					strstart++;
				}
				if (flag)
				{
					flush_block_only(eof: false);
					if (_codec.AvailableBytesOut == 0)
					{
						return BlockState.NeedMore;
					}
				}
			}
			flush_block_only(flush == FlushType.Finish);
			if (_codec.AvailableBytesOut == 0)
			{
				if (flush == FlushType.Finish)
				{
					return BlockState.FinishStarted;
				}
				return BlockState.NeedMore;
			}
			if (flush != FlushType.Finish)
			{
				return BlockState.BlockDone;
			}
			return BlockState.FinishDone;
		}

		internal BlockState DeflateSlow(FlushType flush)
		{
			int num = 0;
			while (true)
			{
				if (lookahead < MIN_LOOKAHEAD)
				{
					_fillWindow();
					if (lookahead < MIN_LOOKAHEAD && flush == FlushType.None)
					{
						return BlockState.NeedMore;
					}
					if (lookahead == 0)
					{
						break;
					}
				}
				if (lookahead >= MIN_MATCH)
				{
					ins_h = ((ins_h << hash_shift) ^ (window[strstart + (MIN_MATCH - 1)] & 0xFF)) & hash_mask;
					num = head[ins_h] & 0xFFFF;
					prev[strstart & w_mask] = head[ins_h];
					head[ins_h] = (short)strstart;
				}
				prev_length = match_length;
				prev_match = match_start;
				match_length = MIN_MATCH - 1;
				if (num != 0 && prev_length < config.MaxLazy && ((strstart - num) & 0xFFFF) <= w_size - MIN_LOOKAHEAD)
				{
					if (compressionStrategy != CompressionStrategy.HuffmanOnly)
					{
						match_length = longest_match(num);
					}
					if (match_length <= 5 && (compressionStrategy == CompressionStrategy.Filtered || (match_length == MIN_MATCH && strstart - match_start > 4096)))
					{
						match_length = MIN_MATCH - 1;
					}
				}
				if (prev_length >= MIN_MATCH && match_length <= prev_length)
				{
					int num2 = strstart + lookahead - MIN_MATCH;
					bool flag = _tr_tally(strstart - 1 - prev_match, prev_length - MIN_MATCH);
					lookahead -= prev_length - 1;
					prev_length -= 2;
					do
					{
						if (++strstart <= num2)
						{
							ins_h = ((ins_h << hash_shift) ^ (window[strstart + (MIN_MATCH - 1)] & 0xFF)) & hash_mask;
							num = head[ins_h] & 0xFFFF;
							prev[strstart & w_mask] = head[ins_h];
							head[ins_h] = (short)strstart;
						}
					}
					while (--prev_length != 0);
					match_available = 0;
					match_length = MIN_MATCH - 1;
					strstart++;
					if (flag)
					{
						flush_block_only(eof: false);
						if (_codec.AvailableBytesOut == 0)
						{
							return BlockState.NeedMore;
						}
					}
				}
				else if (match_available != 0)
				{
					if (_tr_tally(0, window[strstart - 1] & 0xFF))
					{
						flush_block_only(eof: false);
					}
					strstart++;
					lookahead--;
					if (_codec.AvailableBytesOut == 0)
					{
						return BlockState.NeedMore;
					}
				}
				else
				{
					match_available = 1;
					strstart++;
					lookahead--;
				}
			}
			if (match_available != 0)
			{
				bool flag = _tr_tally(0, window[strstart - 1] & 0xFF);
				match_available = 0;
			}
			flush_block_only(flush == FlushType.Finish);
			if (_codec.AvailableBytesOut == 0)
			{
				if (flush == FlushType.Finish)
				{
					return BlockState.FinishStarted;
				}
				return BlockState.NeedMore;
			}
			if (flush != FlushType.Finish)
			{
				return BlockState.BlockDone;
			}
			return BlockState.FinishDone;
		}

		internal int longest_match(int cur_match)
		{
			int num = config.MaxChainLength;
			int num2 = strstart;
			int num3 = prev_length;
			int num4 = ((strstart > w_size - MIN_LOOKAHEAD) ? (strstart - (w_size - MIN_LOOKAHEAD)) : 0);
			int niceLength = config.NiceLength;
			int num5 = w_mask;
			int num6 = strstart + MAX_MATCH;
			byte b = window[num2 + num3 - 1];
			byte b2 = window[num2 + num3];
			if (prev_length >= config.GoodLength)
			{
				num >>= 2;
			}
			if (niceLength > lookahead)
			{
				niceLength = lookahead;
			}
			do
			{
				int num7 = cur_match;
				if (window[num7 + num3] != b2 || window[num7 + num3 - 1] != b || window[num7] != window[num2] || window[++num7] != window[num2 + 1])
				{
					continue;
				}
				num2 += 2;
				num7++;
				while (window[++num2] == window[++num7] && window[++num2] == window[++num7] && window[++num2] == window[++num7] && window[++num2] == window[++num7] && window[++num2] == window[++num7] && window[++num2] == window[++num7] && window[++num2] == window[++num7] && window[++num2] == window[++num7] && num2 < num6)
				{
				}
				int num8 = MAX_MATCH - (num6 - num2);
				num2 = num6 - MAX_MATCH;
				if (num8 > num3)
				{
					match_start = cur_match;
					num3 = num8;
					if (num8 >= niceLength)
					{
						break;
					}
					b = window[num2 + num3 - 1];
					b2 = window[num2 + num3];
				}
			}
			while ((cur_match = prev[cur_match & num5] & 0xFFFF) > num4 && --num != 0);
			if (num3 <= lookahead)
			{
				return num3;
			}
			return lookahead;
		}

		internal int Initialize(ZlibCodec codec, CompressionLevel level)
		{
			return Initialize(codec, level, 15);
		}

		internal int Initialize(ZlibCodec codec, CompressionLevel level, int bits)
		{
			return Initialize(codec, level, bits, MEM_LEVEL_DEFAULT, CompressionStrategy.Default);
		}

		internal int Initialize(ZlibCodec codec, CompressionLevel level, int bits, CompressionStrategy compressionStrategy)
		{
			return Initialize(codec, level, bits, MEM_LEVEL_DEFAULT, compressionStrategy);
		}

		internal int Initialize(ZlibCodec codec, CompressionLevel level, int windowBits, int memLevel, CompressionStrategy strategy)
		{
			_codec = codec;
			_codec.Message = null;
			if (windowBits < 9 || windowBits > 15)
			{
				throw new ZlibException("windowBits must be in the range 9..15.");
			}
			if (memLevel < 1 || memLevel > MEM_LEVEL_MAX)
			{
				throw new ZlibException($"memLevel must be in the range 1.. {MEM_LEVEL_MAX}");
			}
			_codec.dstate = this;
			w_bits = windowBits;
			w_size = 1 << w_bits;
			w_mask = w_size - 1;
			hash_bits = memLevel + 7;
			hash_size = 1 << hash_bits;
			hash_mask = hash_size - 1;
			hash_shift = (hash_bits + MIN_MATCH - 1) / MIN_MATCH;
			window = new byte[w_size * 2];
			prev = new short[w_size];
			head = new short[hash_size];
			lit_bufsize = 1 << memLevel + 6;
			pending = new byte[lit_bufsize * 4];
			_distanceOffset = lit_bufsize;
			_lengthOffset = 3 * lit_bufsize;
			compressionLevel = level;
			compressionStrategy = strategy;
			Reset();
			return 0;
		}

		internal void Reset()
		{
			_codec.TotalBytesIn = (_codec.TotalBytesOut = 0L);
			_codec.Message = null;
			pendingCount = 0;
			nextPending = 0;
			Rfc1950BytesEmitted = false;
			status = (WantRfc1950HeaderBytes ? INIT_STATE : BUSY_STATE);
			_codec._Adler32 = Adler.Adler32(0u, null, 0, 0);
			last_flush = 0;
			_InitializeTreeData();
			_InitializeLazyMatch();
		}

		internal int End()
		{
			if (status != INIT_STATE && status != BUSY_STATE && status != FINISH_STATE)
			{
				return -2;
			}
			pending = null;
			head = null;
			prev = null;
			window = null;
			if (status != BUSY_STATE)
			{
				return 0;
			}
			return -3;
		}

		private void SetDeflater()
		{
			switch (config.Flavor)
			{
			case DeflateFlavor.Store:
				DeflateFunction = DeflateNone;
				break;
			case DeflateFlavor.Fast:
				DeflateFunction = DeflateFast;
				break;
			case DeflateFlavor.Slow:
				DeflateFunction = DeflateSlow;
				break;
			}
		}

		internal int SetParams(CompressionLevel level, CompressionStrategy strategy)
		{
			int result = 0;
			if (compressionLevel != level)
			{
				Config config = Config.Lookup(level);
				if (config.Flavor != this.config.Flavor && _codec.TotalBytesIn != 0L)
				{
					result = _codec.Deflate(FlushType.Partial);
				}
				compressionLevel = level;
				this.config = config;
				SetDeflater();
			}
			compressionStrategy = strategy;
			return result;
		}

		internal int SetDictionary(byte[] dictionary)
		{
			int num = dictionary.Length;
			int sourceIndex = 0;
			if (dictionary == null || status != INIT_STATE)
			{
				throw new ZlibException("Stream error.");
			}
			_codec._Adler32 = Adler.Adler32(_codec._Adler32, dictionary, 0, dictionary.Length);
			if (num < MIN_MATCH)
			{
				return 0;
			}
			if (num > w_size - MIN_LOOKAHEAD)
			{
				num = w_size - MIN_LOOKAHEAD;
				sourceIndex = dictionary.Length - num;
			}
			Array.Copy(dictionary, sourceIndex, window, 0, num);
			strstart = num;
			block_start = num;
			ins_h = window[0] & 0xFF;
			ins_h = ((ins_h << hash_shift) ^ (window[1] & 0xFF)) & hash_mask;
			for (int i = 0; i <= num - MIN_MATCH; i++)
			{
				ins_h = ((ins_h << hash_shift) ^ (window[i + (MIN_MATCH - 1)] & 0xFF)) & hash_mask;
				prev[i & w_mask] = head[ins_h];
				head[ins_h] = (short)i;
			}
			return 0;
		}

		internal int Deflate(FlushType flush)
		{
			if (_codec.OutputBuffer == null || (_codec.InputBuffer == null && _codec.AvailableBytesIn != 0) || (status == FINISH_STATE && flush != FlushType.Finish))
			{
				_codec.Message = _ErrorMessage[4];
				throw new ZlibException($"Something is fishy. [{_codec.Message}]");
			}
			if (_codec.AvailableBytesOut == 0)
			{
				_codec.Message = _ErrorMessage[7];
				throw new ZlibException("OutputBuffer is full (AvailableBytesOut == 0)");
			}
			int num = last_flush;
			last_flush = (int)flush;
			if (status == INIT_STATE)
			{
				int num2 = Z_DEFLATED + (w_bits - 8 << 4) << 8;
				int num3 = (int)((compressionLevel - 1) & (CompressionLevel)255) >> 1;
				if (num3 > 3)
				{
					num3 = 3;
				}
				num2 |= num3 << 6;
				if (strstart != 0)
				{
					num2 |= PRESET_DICT;
				}
				num2 += 31 - num2 % 31;
				status = BUSY_STATE;
				pending[pendingCount++] = (byte)(num2 >> 8);
				pending[pendingCount++] = (byte)num2;
				if (strstart != 0)
				{
					pending[pendingCount++] = (byte)((_codec._Adler32 & 0xFF000000u) >> 24);
					pending[pendingCount++] = (byte)((_codec._Adler32 & 0xFF0000) >> 16);
					pending[pendingCount++] = (byte)((_codec._Adler32 & 0xFF00) >> 8);
					pending[pendingCount++] = (byte)(_codec._Adler32 & 0xFFu);
				}
				_codec._Adler32 = Adler.Adler32(0u, null, 0, 0);
			}
			if (pendingCount != 0)
			{
				_codec.flush_pending();
				if (_codec.AvailableBytesOut == 0)
				{
					last_flush = -1;
					return 0;
				}
			}
			else if (_codec.AvailableBytesIn == 0 && (int)flush <= num && flush != FlushType.Finish)
			{
				return 0;
			}
			if (status == FINISH_STATE && _codec.AvailableBytesIn != 0)
			{
				_codec.Message = _ErrorMessage[7];
				throw new ZlibException("status == FINISH_STATE && _codec.AvailableBytesIn != 0");
			}
			if (_codec.AvailableBytesIn != 0 || lookahead != 0 || (flush != 0 && status != FINISH_STATE))
			{
				BlockState blockState = DeflateFunction(flush);
				if (blockState == BlockState.FinishStarted || blockState == BlockState.FinishDone)
				{
					status = FINISH_STATE;
				}
				switch (blockState)
				{
				case BlockState.NeedMore:
				case BlockState.FinishStarted:
					if (_codec.AvailableBytesOut == 0)
					{
						last_flush = -1;
					}
					return 0;
				case BlockState.BlockDone:
					if (flush == FlushType.Partial)
					{
						_tr_align();
					}
					else
					{
						_tr_stored_block(0, 0, eof: false);
						if (flush == FlushType.Full)
						{
							for (int i = 0; i < hash_size; i++)
							{
								head[i] = 0;
							}
						}
					}
					_codec.flush_pending();
					if (_codec.AvailableBytesOut == 0)
					{
						last_flush = -1;
						return 0;
					}
					break;
				}
			}
			if (flush != FlushType.Finish)
			{
				return 0;
			}
			if (!WantRfc1950HeaderBytes || Rfc1950BytesEmitted)
			{
				return 1;
			}
			pending[pendingCount++] = (byte)((_codec._Adler32 & 0xFF000000u) >> 24);
			pending[pendingCount++] = (byte)((_codec._Adler32 & 0xFF0000) >> 16);
			pending[pendingCount++] = (byte)((_codec._Adler32 & 0xFF00) >> 8);
			pending[pendingCount++] = (byte)(_codec._Adler32 & 0xFFu);
			_codec.flush_pending();
			Rfc1950BytesEmitted = true;
			if (pendingCount == 0)
			{
				return 1;
			}
			return 0;
		}
	}
	public class DeflateStream : Stream
	{
		internal ZlibBaseStream _baseStream;

		internal Stream _innerStream;

		private bool _disposed;

		public virtual FlushType FlushMode
		{
			get
			{
				return _baseStream._flushMode;
			}
			set
			{
				if (_disposed)
				{
					throw new ObjectDisposedException("DeflateStream");
				}
				_baseStream._flushMode = value;
			}
		}

		public int BufferSize
		{
			get
			{
				return _baseStream._bufferSize;
			}
			set
			{
				if (_disposed)
				{
					throw new ObjectDisposedException("DeflateStream");
				}
				if (_baseStream._workingBuffer != null)
				{
					throw new ZlibException("The working buffer is already set.");
				}
				if (value < 1024)
				{
					throw new ZlibException($"Don't be silly. {value} bytes?? Use a bigger buffer, at least {1024}.");
				}
				_baseStream._bufferSize = value;
			}
		}

		public CompressionStrategy Strategy
		{
			get
			{
				return _baseStream.Strategy;
			}
			set
			{
				if (_disposed)
				{
					throw new ObjectDisposedException("DeflateStream");
				}
				_baseStream.Strategy = value;
			}
		}

		public virtual long TotalIn => _baseStream._z.TotalBytesIn;

		public virtual long TotalOut => _baseStream._z.TotalBytesOut;

		public override bool CanRead
		{
			get
			{
				if (_disposed)
				{
					throw new ObjectDisposedException("DeflateStream");
				}
				return _baseStream._stream.CanRead;
			}
		}

		public override bool CanSeek => false;

		public override bool CanWrite
		{
			get
			{
				if (_disposed)
				{
					throw new ObjectDisposedException("DeflateStream");
				}
				return _baseStream._stream.CanWrite;
			}
		}

		public override long Length
		{
			get
			{
				throw new NotImplementedException();
			}
		}

		public override long Position
		{
			get
			{
				if (_baseStream._streamMode == ZlibBaseStream.StreamMode.Writer)
				{
					return _baseStream._z.TotalBytesOut;
				}
				if (_baseStream._streamMode == ZlibBaseStream.StreamMode.Reader)
				{
					return _baseStream._z.TotalBytesIn;
				}
				return 0L;
			}
			set
			{
				throw new NotImplementedException();
			}
		}

		public DeflateStream(Stream stream, CompressionMode mode)
			: this(stream, mode, CompressionLevel.Default, leaveOpen: false)
		{
		}

		public DeflateStream(Stream stream, CompressionMode mode, CompressionLevel level)
			: this(stream, mode, level, leaveOpen: false)
		{
		}

		public DeflateStream(Stream stream, CompressionMode mode, bool leaveOpen)
			: this(stream, mode, CompressionLevel.Default, leaveOpen)
		{
		}

		public DeflateStream(Stream stream, CompressionMode mode, CompressionLevel level, bool leaveOpen)
		{
			_innerStream = stream;
			_baseStream = new ZlibBaseStream(stream, mode, level, ZlibStreamFlavor.DEFLATE, leaveOpen);
		}

		protected override void Dispose(bool disposing)
		{
			try
			{
				if (!_disposed)
				{
					if (disposing && _baseStream != null)
					{
						_baseStream.Close();
					}
					_disposed = true;
				}
			}
			finally
			{
				base.Dispose(disposing);
			}
		}

		public override void Flush()
		{
			if (_disposed)
			{
				throw new ObjectDisposedException("DeflateStream");
			}
			_baseStream.Flush();
		}

		public override int Read(byte[] buffer, int offset, int count)
		{
			if (_disposed)
			{
				throw new ObjectDisposedException("DeflateStream");
			}
			return _baseStream.Read(buffer, offset, count);
		}

		public override long Seek(long offset, SeekOrigin origin)
		{
			throw new NotImplementedException();
		}

		public override void SetLength(long value)
		{
			throw new NotImplementedException();
		}

		public override void Write(byte[] buffer, int offset, int count)
		{
			if (_disposed)
			{
				throw new ObjectDisposedException("DeflateStream");
			}
			_baseStream.Write(buffer, offset, count);
		}

		public static byte[] CompressString(string s)
		{
			using MemoryStream memoryStream = new MemoryStream();
			Stream compressor = new DeflateStream(memoryStream, CompressionMode.Compress, CompressionLevel.BestCompression);
			ZlibBaseStream.CompressString(s, compressor);
			return memoryStream.ToArray();
		}

		public static byte[] CompressBuffer(byte[] b)
		{
			using MemoryStream memoryStream = new MemoryStream();
			Stream compressor = new DeflateStream(memoryStream, CompressionMode.Compress, CompressionLevel.BestCompression);
			ZlibBaseStream.CompressBuffer(b, compressor);
			return memoryStream.ToArray();
		}

		public static string UncompressString(byte[] compressed)
		{
			using MemoryStream stream = new MemoryStream(compressed);
			Stream decompressor = new DeflateStream(stream, CompressionMode.Decompress);
			return ZlibBaseStream.UncompressString(compressed, decompressor);
		}

		public static byte[] UncompressBuffer(byte[] compressed)
		{
			using MemoryStream stream = new MemoryStream(compressed);
			Stream decompressor = new DeflateStream(stream, CompressionMode.Decompress);
			return ZlibBaseStream.UncompressBuffer(compressed, decompressor);
		}
	}
	public class GZipStream : Stream
	{
		public DateTime? LastModified;

		private int _headerByteCount;

		internal ZlibBaseStream _baseStream;

		private bool _disposed;

		private bool _firstReadDone;

		private string _FileName;

		private string _Comment;

		private int _Crc32;

		internal static readonly DateTime _unixEpoch = new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc);

		internal static readonly Encoding iso8859dash1 = Encoding.GetEncoding("iso-8859-1");

		public string Comment
		{
			get
			{
				return _Comment;
			}
			set
			{
				if (_disposed)
				{
					throw new ObjectDisposedException("GZipStream");
				}
				_Comment = value;
			}
		}

		public string FileName
		{
			get
			{
				return _FileName;
			}
			set
			{
				if (_disposed)
				{
					throw new ObjectDisposedException("GZipStream");
				}
				_FileName = value;
				if (_FileName != null)
				{
					if (_FileName.IndexOf("/") != -1)
					{
						_FileName = _FileName.Replace("/", "\\");
					}
					if (_FileName.EndsWith("\\"))
					{
						throw new Exception("Illegal filename");
					}
					if (_FileName.IndexOf("\\") != -1)
					{
						_FileName = Path.GetFileName(_FileName);
					}
				}
			}
		}

		public int Crc32 => _Crc32;

		public virtual FlushType FlushMode
		{
			get
			{
				return _baseStream._flushMode;
			}
			set
			{
				if (_disposed)
				{
					throw new ObjectDisposedException("GZipStream");
				}
				_baseStream._flushMode = value;
			}
		}

		public int BufferSize
		{
			get
			{
				return _baseStream._bufferSize;
			}
			set
			{
				if (_disposed)
				{
					throw new ObjectDisposedException("GZipStream");
				}
				if (_baseStream._workingBuffer != null)
				{
					throw new ZlibException("The working buffer is already set.");
				}
				if (value < 1024)
				{
					throw new ZlibException($"Don't be silly. {value} bytes?? Use a bigger buffer, at least {1024}.");
				}
				_baseStream._bufferSize = value;
			}
		}

		public virtual long TotalIn => _baseStream._z.TotalBytesIn;

		public virtual long TotalOut => _baseStream._z.TotalBytesOut;

		public override bool CanRead
		{
			get
			{
				if (_disposed)
				{
					throw new ObjectDisposedException("GZipStream");
				}
				return _baseStream._stream.CanRead;
			}
		}

		public override bool CanSeek => false;

		public override bool CanWrite
		{
			get
			{
				if (_disposed)
				{
					throw new ObjectDisposedException("GZipStream");
				}
				return _baseStream._stream.CanWrite;
			}
		}

		public override long Length
		{
			get
			{
				throw new NotImplementedException();
			}
		}

		public override long Position
		{
			get
			{
				if (_baseStream._streamMode == ZlibBaseStream.StreamMode.Writer)
				{
					return _baseStream._z.TotalBytesOut + _headerByteCount;
				}
				if (_baseStream._streamMode == ZlibBaseStream.StreamMode.Reader)
				{
					return _baseStream._z.TotalBytesIn + _baseStream._gzipHeaderByteCount;
				}
				return 0L;
			}
			set
			{
				throw new NotImplementedException();
			}
		}

		public GZipStream(Stream stream, CompressionMode mode)
			: this(stream, mode, CompressionLevel.Default, leaveOpen: false)
		{
		}

		public GZipStream(Stream stream, CompressionMode mode, CompressionLevel level)
			: this(stream, mode, level, leaveOpen: false)
		{
		}

		public GZipStream(Stream stream, CompressionMode mode, bool leaveOpen)
			: this(stream, mode, CompressionLevel.Default, leaveOpen)
		{
		}

		public GZipStream(Stream stream, CompressionMode mode, CompressionLevel level, bool leaveOpen)
		{
			_baseStream = new ZlibBaseStream(stream, mode, level, ZlibStreamFlavor.GZIP, leaveOpen);
		}

		protected override void Dispose(bool disposing)
		{
			try
			{
				if (!_disposed)
				{
					if (disposing && _baseStream != null)
					{
						_baseStream.Close();
						_Crc32 = _baseStream.Crc32;
					}
					_disposed = true;
				}
			}
			finally
			{
				base.Dispose(disposing);
			}
		}

		public override void Flush()
		{
			if (_disposed)
			{
				throw new ObjectDisposedException("GZipStream");
			}
			_baseStream.Flush();
		}

		public override int Read(byte[] buffer, int offset, int count)
		{
			if (_disposed)
			{
				throw new ObjectDisposedException("GZipStream");
			}
			int result = _baseStream.Read(buffer, offset, count);
			if (!_firstReadDone)
			{
				_firstReadDone = true;
				FileName = _baseStream._GzipFileName;
				Comment = _baseStream._GzipComment;
			}
			return result;
		}

		public override long Seek(long offset, SeekOrigin origin)
		{
			throw new NotImplementedException();
		}

		public override void SetLength(long value)
		{
			throw new NotImplementedException();
		}

		public override void Write(byte[] buffer, int offset, int count)
		{
			if (_disposed)
			{
				throw new ObjectDisposedException("GZipStream");
			}
			if (_baseStream._streamMode == ZlibBaseStream.StreamMode.Undefined)
			{
				if (!_baseStream._wantCompress)
				{
					throw new InvalidOperationException();
				}
				_headerByteCount = EmitHeader();
			}
			_baseStream.Write(buffer, offset, count);
		}

		private int EmitHeader()
		{
			byte[] array = ((Comment == null) ? null : iso8859dash1.GetBytes(Comment));
			byte[] array2 = ((FileName == null) ? null : iso8859dash1.GetBytes(FileName));
			int num = ((Comment != null) ? (array.Length + 1) : 0);
			int num2 = ((FileName != null) ? (array2.Length + 1) : 0);
			byte[] array3 = new byte[10 + num + num2];
			int num3 = 0;
			array3[num3++] = 31;
			array3[num3++] = 139;
			array3[num3++] = 8;
			byte b = 0;
			if (Comment != null)
			{
				b = (byte)(b ^ 0x10u);
			}
			if (FileName != null)
			{
				b = (byte)(b ^ 8u);
			}
			array3[num3++] = b;
			if (!LastModified.HasValue)
			{
				LastModified = DateTime.Now;
			}
			Array.Copy(BitConverter.GetBytes((int)(LastModified.Value - _unixEpoch).TotalSeconds), 0, array3, num3, 4);
			num3 += 4;
			array3[num3++] = 0;
			array3[num3++] = byte.MaxValue;
			if (num2 != 0)
			{
				Array.Copy(array2, 0, array3, num3, num2 - 1);
				num3 += num2 - 1;
				array3[num3++] = 0;
			}
			if (num != 0)
			{
				Array.Copy(array, 0, array3, num3, num - 1);
				num3 += num - 1;
				array3[num3++] = 0;
			}
			_baseStream._stream.Write(array3, 0, array3.Length);
			return array3.Length;
		}

		public static byte[] CompressString(string s)
		{
			using MemoryStream memoryStream = new MemoryStream();
			Stream compressor = new GZipStream(memoryStream, CompressionMode.Compress, CompressionLevel.BestCompression);
			ZlibBaseStream.CompressString(s, compressor);
			return memoryStream.ToArray();
		}

		public static byte[] CompressBuffer(byte[] b)
		{
			using MemoryStream memoryStream = new MemoryStream();
			Stream compressor = new GZipStream(memoryStream, CompressionMode.Compress, CompressionLevel.BestCompression);
			ZlibBaseStream.CompressBuffer(b, compressor);
			return memoryStream.ToArray();
		}

		public static string UncompressString(byte[] compressed)
		{
			using MemoryStream stream = new MemoryStream(compressed);
			Stream decompressor = new GZipStream(stream, CompressionMode.Decompress);
			return ZlibBaseStream.UncompressString(compressed, decompressor);
		}

		public static byte[] UncompressBuffer(byte[] compressed)
		{
			using MemoryStream stream = new MemoryStream(compressed);
			Stream decompressor = new GZipStream(stream, CompressionMode.Decompress);
			return ZlibBaseStream.UncompressBuffer(compressed, decompressor);
		}
	}
	internal sealed class InflateBlocks
	{
		private enum InflateBlockMode
		{
			TYPE,
			LENS,
			STORED,
			TABLE,
			BTREE,
			DTREE,
			CODES,
			DRY,
			DONE,
			BAD
		}

		private const int MANY = 1440;

		internal static readonly int[] border = new int[19]
		{
			16, 17, 18, 0, 8, 7, 9, 6, 10, 5,
			11, 4, 12, 3, 13, 2, 14, 1, 15
		};

		private InflateBlockMode mode;

		internal int left;

		internal int table;

		internal int index;

		internal int[] blens;

		internal int[] bb = new int[1];

		internal int[] tb = new int[1];

		internal InflateCodes codes = new InflateCodes();

		internal int last;

		internal ZlibCodec _codec;

		internal int bitk;

		internal int bitb;

		internal int[] hufts;

		internal byte[] window;

		internal int end;

		internal int readAt;

		internal int writeAt;

		internal object checkfn;

		internal uint check;

		internal InfTree inftree = new InfTree();

		internal InflateBlocks(ZlibCodec codec, object checkfn, int w)
		{
			_codec = codec;
			hufts = new int[4320];
			window = new byte[w];
			end = w;
			this.checkfn = checkfn;
			mode = InflateBlockMode.TYPE;
			Reset();
		}

		internal uint Reset()
		{
			uint result = check;
			mode = InflateBlockMode.TYPE;
			bitk = 0;
			bitb = 0;
			readAt = (writeAt = 0);
			if (checkfn != null)
			{
				_codec._Adler32 = (check = Adler.Adler32(0u, null, 0, 0));
			}
			return result;
		}

		internal int Process(int r)
		{
			int num = _codec.NextIn;
			int num2 = _codec.AvailableBytesIn;
			int num3 = bitb;
			int i = bitk;
			int num4 = writeAt;
			int num5 = ((num4 < readAt) ? (readAt - num4 - 1) : (end - num4));
			while (true)
			{
				switch (mode)
				{
				case InflateBlockMode.TYPE:
				{
					for (; i < 3; i += 8)
					{
						if (num2 != 0)
						{
							r = 0;
							num2--;
							num3 |= (_codec.InputBuffer[num++] & 0xFF) << i;
							continue;
						}
						bitb = num3;
						bitk = i;
						_codec.AvailableBytesIn = num2;
						_codec.TotalBytesIn += num - _codec.NextIn;
						_codec.NextIn = num;
						writeAt = num4;
						return Flush(r);
					}
					int num6 = num3 & 7;
					last = num6 & 1;
					switch ((uint)(num6 >>> 1))
					{
					case 0u:
						num3 >>= 3;
						i -= 3;
						num6 = i & 7;
						num3 >>= num6;
						i -= num6;
						mode = InflateBlockMode.LENS;
						break;
					case 1u:
					{
						int[] array = new int[1];
						int[] array2 = new int[1];
						int[][] array3 = new int[1][];
						int[][] array4 = new int[1][];
						InfTree.inflate_trees_fixed(array, array2, array3, array4, _codec);
						codes.Init(array[0], array2[0], array3[0], 0, array4[0], 0);
						num3 >>= 3;
						i -= 3;
						mode = InflateBlockMode.CODES;
						break;
					}
					case 2u:
						num3 >>= 3;
						i -= 3;
						mode = InflateBlockMode.TABLE;
						break;
					case 3u:
						num3 >>= 3;
						i -= 3;
						mode = InflateBlockMode.BAD;
						_codec.Message = "invalid block type";
						r = -3;
						bitb = num3;
						bitk = i;
						_codec.AvailableBytesIn = num2;
						_codec.TotalBytesIn += num - _codec.NextIn;
						_codec.NextIn = num;
						writeAt = num4;
						return Flush(r);
					}
					break;
				}
				case InflateBlockMode.LENS:
					for (; i < 32; i += 8)
					{
						if (num2 != 0)
						{
							r = 0;
							num2--;
							num3 |= (_codec.InputBuffer[num++] & 0xFF) << i;
							continue;
						}
						bitb = num3;
						bitk = i;
						_codec.AvailableBytesIn = num2;
						_codec.TotalBytesIn += num - _codec.NextIn;
						_codec.NextIn = num;
						writeAt = num4;
						return Flush(r);
					}
					if (((~num3 >> 16) & 0xFFFF) != (num3 & 0xFFFF))
					{
						mode = InflateBlockMode.BAD;
						_codec.Message = "invalid stored block lengths";
						r = -3;
						bitb = num3;
						bitk = i;
						_codec.AvailableBytesIn = num2;
						_codec.TotalBytesIn += num - _codec.NextIn;
						_codec.NextIn = num;
						writeAt = num4;
						return Flush(r);
					}
					left = num3 & 0xFFFF;
					num3 = (i = 0);
					mode = ((left != 0) ? InflateBlockMode.STORED : ((last != 0) ? InflateBlockMode.DRY : InflateBlockMode.TYPE));
					break;
				case InflateBlockMode.STORED:
				{
					if (num2 == 0)
					{
						bitb = num3;
						bitk = i;
						_codec.AvailableBytesIn = num2;
						_codec.TotalBytesIn += num - _codec.NextIn;
						_codec.NextIn = num;
						writeAt = num4;
						return Flush(r);
					}
					if (num5 == 0)
					{
						if (num4 == end && readAt != 0)
						{
							num4 = 0;
							num5 = ((num4 < readAt) ? (readAt - num4 - 1) : (end - num4));
						}
						if (num5 == 0)
						{
							writeAt = num4;
							r = Flush(r);
							num4 = writeAt;
							num5 = ((num4 < readAt) ? (readAt - num4 - 1) : (end - num4));
							if (num4 == end && readAt != 0)
							{
								num4 = 0;
								num5 = ((num4 < readAt) ? (readAt - num4 - 1) : (end - num4));
							}
							if (num5 == 0)
							{
								bitb = num3;
								bitk = i;
								_codec.AvailableBytesIn = num2;
								_codec.TotalBytesIn += num - _codec.NextIn;
								_codec.NextIn = num;
								writeAt = num4;
								return Flush(r);
							}
						}
					}
					r = 0;
					int num6 = left;
					if (num6 > num2)
					{
						num6 = num2;
					}
					if (num6 > num5)
					{
						num6 = num5;
					}
					Array.Copy(_codec.InputBuffer, num, window, num4, num6);
					num += num6;
					num2 -= num6;
					num4 += num6;
					num5 -= num6;
					if ((left -= num6) == 0)
					{
						mode = ((last != 0) ? InflateBlockMode.DRY : InflateBlockMode.TYPE);
					}
					break;
				}
				case InflateBlockMode.TABLE:
				{
					for (; i < 14; i += 8)
					{
						if (num2 != 0)
						{
							r = 0;
							num2--;
							num3 |= (_codec.InputBuffer[num++] & 0xFF) << i;
							continue;
						}
						bitb = num3;
						bitk = i;
						_codec.AvailableBytesIn = num2;
						_codec.TotalBytesIn += num - _codec.NextIn;
						_codec.NextIn = num;
						writeAt = num4;
						return Flush(r);
					}
					int num6 = (table = num3 & 0x3FFF);
					if ((num6 & 0x1F) > 29 || ((num6 >> 5) & 0x1F) > 29)
					{
						mode = InflateBlockMode.BAD;
						_codec.Message = "too many length or distance symbols";
						r = -3;
						bitb = num3;
						bitk = i;
						_codec.AvailableBytesIn = num2;
						_codec.TotalBytesIn += num - _codec.NextIn;
						_codec.NextIn = num;
						writeAt = num4;
						return Flush(r);
					}
					num6 = 258 + (num6 & 0x1F) + ((num6 >> 5) & 0x1F);
					if (blens == null || blens.Length < num6)
					{
						blens = new int[num6];
					}
					else
					{
						Array.Clear(blens, 0, num6);
					}
					num3 >>= 14;
					i -= 14;
					index = 0;
					mode = InflateBlockMode.BTREE;
					goto case InflateBlockMode.BTREE;
				}
				case InflateBlockMode.BTREE:
				{
					while (index < 4 + (table >> 10))
					{
						for (; i < 3; i += 8)
						{
							if (num2 != 0)
							{
								r = 0;
								num2--;
								num3 |= (_codec.InputBuffer[num++] & 0xFF) << i;
								continue;
							}
							bitb = num3;
							bitk = i;
							_codec.AvailableBytesIn = num2;
							_codec.TotalBytesIn += num - _codec.NextIn;
							_codec.NextIn = num;
							writeAt = num4;
							return Flush(r);
						}
						blens[border[index++]] = num3 & 7;
						num3 >>= 3;
						i -= 3;
					}
					while (index < 19)
					{
						blens[border[index++]] = 0;
					}
					bb[0] = 7;
					int num6 = inftree.inflate_trees_bits(blens, bb, tb, hufts, _codec);
					if (num6 != 0)
					{
						r = num6;
						if (r == -3)
						{
							blens = null;
							mode = InflateBlockMode.BAD;
						}
						bitb = num3;
						bitk = i;
						_codec.AvailableBytesIn = num2;
						_codec.TotalBytesIn += num - _codec.NextIn;
						_codec.NextIn = num;
						writeAt = num4;
						return Flush(r);
					}
					index = 0;
					mode = InflateBlockMode.DTREE;
					goto case InflateBlockMode.DTREE;
				}
				case InflateBlockMode.DTREE:
				{
					int num6;
					while (true)
					{
						num6 = table;
						if (index >= 258 + (num6 & 0x1F) + ((num6 >> 5) & 0x1F))
						{
							break;
						}
						for (num6 = bb[0]; i < num6; i += 8)
						{
							if (num2 != 0)
							{
								r = 0;
								num2--;
								num3 |= (_codec.InputBuffer[num++] & 0xFF) << i;
								continue;
							}
							bitb = num3;
							bitk = i;
							_codec.AvailableBytesIn = num2;
							_codec.TotalBytesIn += num - _codec.NextIn;
							_codec.NextIn = num;
							writeAt = num4;
							return Flush(r);
						}
						num6 = hufts[(tb[0] + (num3 & InternalInflateConstants.InflateMask[num6])) * 3 + 1];
						int num7 = hufts[(tb[0] + (num3 & InternalInflateConstants.InflateMask[num6])) * 3 + 2];
						if (num7 < 16)
						{
							num3 >>= num6;
							i -= num6;
							blens[index++] = num7;
							continue;
						}
						int num8 = ((num7 == 18) ? 7 : (num7 - 14));
						int num9 = ((num7 == 18) ? 11 : 3);
						for (; i < num6 + num8; i += 8)
						{
							if (num2 != 0)
							{
								r = 0;
								num2--;
								num3 |= (_codec.InputBuffer[num++] & 0xFF) << i;
								continue;
							}
							bitb = num3;
							bitk = i;
							_codec.AvailableBytesIn = num2;
							_codec.TotalBytesIn += num - _codec.NextIn;
							_codec.NextIn = num;
							writeAt = num4;
							return Flush(r);
						}
						num3 >>= num6;
						i -= num6;
						num9 += num3 & InternalInflateConstants.InflateMask[num8];
						num3 >>= num8;
						i -= num8;
						num8 = index;
						num6 = table;
						if (num8 + num9 > 258 + (num6 & 0x1F) + ((num6 >> 5) & 0x1F) || (num7 == 16 && num8 < 1))
						{
							blens = null;
							mode = InflateBlockMode.BAD;
							_codec.Message = "invalid bit length repeat";
							r = -3;
							bitb = num3;
							bitk = i;
							_codec.AvailableBytesIn = num2;
							_codec.TotalBytesIn += num - _codec.NextIn;
							_codec.NextIn = num;
							writeAt = num4;
							return Flush(r);
						}
						num7 = ((num7 == 16) ? blens[num8 - 1] : 0);
						do
						{
							blens[num8++] = num7;
						}
						while (--num9 != 0);
						index = num8;
					}
					tb[0] = -1;
					int[] array5 = new int[1] { 9 };
					int[] array6 = new int[1] { 6 };
					int[] array7 = new int[1];
					int[] array8 = new int[1];
					num6 = table;
					num6 = inftree.inflate_trees_dynamic(257 + (num6 & 0x1F), 1 + ((num6 >> 5) & 0x1F), blens, array5, array6, array7, array8, hufts, _codec);
					if (num6 != 0)
					{
						if (num6 == -3)
						{
							blens = null;
							mode = InflateBlockMode.BAD;
						}
						r = num6;
						bitb = num3;
						bitk = i;
						_codec.AvailableBytesIn = num2;
						_codec.TotalBytesIn += num - _codec.NextIn;
						_codec.NextIn = num;
						writeAt = num4;
						return Flush(r);
					}
					codes.Init(array5[0], array6[0], hufts, array7[0], hufts, array8[0]);
					mode = InflateBlockMode.CODES;
					goto case InflateBlockMode.CODES;
				}
				case InflateBlockMode.CODES:
					bitb = num3;
					bitk = i;
					_codec.AvailableBytesIn = num2;
					_codec.TotalBytesIn += num - _codec.NextIn;
					_codec.NextIn = num;
					writeAt = num4;
					r = codes.Process(this, r);
					if (r != 1)
					{
						return Flush(r);
					}
					r = 0;
					num = _codec.NextIn;
					num2 = _codec.AvailableBytesIn;
					num3 = bitb;
					i = bitk;
					num4 = writeAt;
					num5 = ((num4 < readAt) ? (readAt - num4 - 1) : (end - num4));
					if (last == 0)
					{
						mode = InflateBlockMode.TYPE;
						break;
					}
					mode = InflateBlockMode.DRY;
					goto case InflateBlockMode.DRY;
				case InflateBlockMode.DRY:
					writeAt = num4;
					r = Flush(r);
					num4 = writeAt;
					num5 = ((num4 < readAt) ? (readAt - num4 - 1) : (end - num4));
					if (readAt != writeAt)
					{
						bitb = num3;
						bitk = i;
						_codec.AvailableBytesIn = num2;
						_codec.TotalBytesIn += num - _codec.NextIn;
						_codec.NextIn = num;
						writeAt = num4;
						return Flush(r);
					}
					mode = InflateBlockMode.DONE;
					goto case InflateBlockMode.DONE;
				case InflateBlockMode.DONE:
					r = 1;
					bitb = num3;
					bitk = i;
					_codec.AvailableBytesIn = num2;
					_codec.TotalBytesIn += num - _codec.NextIn;
					_codec.NextIn = num;
					writeAt = num4;
					return Flush(r);
				case InflateBlockMode.BAD:
					r = -3;
					bitb = num3;
					bitk = i;
					_codec.AvailableBytesIn = num2;
					_codec.TotalBytesIn += num - _codec.NextIn;
					_codec.NextIn = num;
					writeAt = num4;
					return Flush(r);
				default:
					r = -2;
					bitb = num3;
					bitk = i;
					_codec.AvailableBytesIn = num2;
					_codec.TotalBytesIn += num - _codec.NextIn;
					_codec.NextIn = num;
					writeAt = num4;
					return Flush(r);
				}
			}
		}

		internal void Free()
		{
			Reset();
			window = null;
			hufts = null;
		}

		internal void SetDictionary(byte[] d, int start, int n)
		{
			Array.Copy(d, start, window, 0, n);
			readAt = (writeAt = n);
		}

		internal int SyncPoint()
		{
			if (mode != InflateBlockMode.LENS)
			{
				return 0;
			}
			return 1;
		}

		internal int Flush(int r)
		{
			for (int i = 0; i < 2; i++)
			{
				int num = ((i != 0) ? (writeAt - readAt) : (((readAt <= writeAt) ? writeAt : end) - readAt));
				if (num == 0)
				{
					if (r == -5)
					{
						r = 0;
					}
					return r;
				}
				if (num > _codec.AvailableBytesOut)
				{
					num = _codec.AvailableBytesOut;
				}
				if (num != 0 && r == -5)
				{
					r = 0;
				}
				_codec.AvailableBytesOut -= num;
				_codec.TotalBytesOut += num;
				if (checkfn != null)
				{
					_codec._Adler32 = (check = Adler.Adler32(check, window, readAt, num));
				}
				Array.Copy(window, readAt, _codec.OutputBuffer, _codec.NextOut, num);
				_codec.NextOut += num;
				readAt += num;
				if (readAt == end && i == 0)
				{
					readAt = 0;
					if (writeAt == end)
					{
						writeAt = 0;
					}
				}
				else
				{
					i++;
				}
			}
			return r;
		}
	}
	internal static class InternalInflateConstants
	{
		internal static readonly int[] InflateMask = new int[17]
		{
			0, 1, 3, 7, 15, 31, 63, 127, 255, 511,
			1023, 2047, 4095, 8191, 16383, 32767, 65535
		};
	}
	internal sealed class InflateCodes
	{
		private const int START = 0;

		private const int LEN = 1;

		private const int LENEXT = 2;

		private const int DIST = 3;

		private const int DISTEXT = 4;

		private const int COPY = 5;

		private const int LIT = 6;

		private const int WASH = 7;

		private const int END = 8;

		private const int BADCODE = 9;

		internal int mode;

		internal int len;

		internal int[] tree;

		internal int tree_index;

		internal int need;

		internal int lit;

		internal int bitsToGet;

		internal int dist;

		internal byte lbits;

		internal byte dbits;

		internal int[] ltree;

		internal int ltree_index;

		internal int[] dtree;

		internal int dtree_index;

		internal InflateCodes()
		{
		}

		internal void Init(int bl, int bd, int[] tl, int tl_index, int[] td, int td_index)
		{
			mode = 0;
			lbits = (byte)bl;
			dbits = (byte)bd;
			ltree = tl;
			ltree_index = tl_index;
			dtree = td;
			dtree_index = td_index;
			tree = null;
		}

		internal int Process(InflateBlocks blocks, int r)
		{
			int num = 0;
			int num2 = 0;
			int num3 = 0;
			ZlibCodec codec = blocks._codec;
			num3 = codec.NextIn;
			int num4 = codec.AvailableBytesIn;
			num = blocks.bitb;
			num2 = blocks.bitk;
			int num5 = blocks.writeAt;
			int num6 = ((num5 < blocks.readAt) ? (blocks.readAt - num5 - 1) : (blocks.end - num5));
			while (true)
			{
				switch (mode)
				{
				case 0:
					if (num6 >= 258 && num4 >= 10)
					{
						blocks.bitb = num;
						blocks.bitk = num2;
						codec.AvailableBytesIn = num4;
						codec.TotalBytesIn += num3 - codec.NextIn;
						codec.NextIn = num3;
						blocks.writeAt = num5;
						r = InflateFast(lbits, dbits, ltree, ltree_index, dtree, dtree_index, blocks, codec);
						num3 = codec.NextIn;
						num4 = codec.AvailableBytesIn;
						num = blocks.bitb;
						num2 = blocks.bitk;
						num5 = blocks.writeAt;
						num6 = ((num5 < blocks.readAt) ? (blocks.readAt - num5 - 1) : (blocks.end - num5));
						if (r != 0)
						{
							mode = ((r == 1) ? 7 : 9);
							break;
						}
					}
					need = lbits;
					tree = ltree;
					tree_index = ltree_index;
					mode = 1;
					goto case 1;
				case 1:
				{
					int num7;
					for (num7 = need; num2 < num7; num2 += 8)
					{
						if (num4 != 0)
						{
							r = 0;
							num4--;
							num |= (codec.InputBuffer[num3++] & 0xFF) << num2;
							continue;
						}
						blocks.bitb = num;
						blocks.bitk = num2;
						codec.AvailableBytesIn = num4;
						codec.TotalBytesIn += num3 - codec.NextIn;
						codec.NextIn = num3;
						blocks.writeAt = num5;
						return blocks.Flush(r);
					}
					int num8 = (tree_index + (num & InternalInflateConstants.InflateMask[num7])) * 3;
					num >>= tree[num8 + 1];
					num2 -= tree[num8 + 1];
					int num9 = tree[num8];
					if (num9 == 0)
					{
						lit = tree[num8 + 2];
						mode = 6;
						break;
					}
					if (((uint)num9 & 0x10u) != 0)
					{
						bitsToGet = num9 & 0xF;
						len = tree[num8 + 2];
						mode = 2;
						break;
					}
					if ((num9 & 0x40) == 0)
					{
						need = num9;
						tree_index = num8 / 3 + tree[num8 + 2];
						break;
					}
					if (((uint)num9 & 0x20u) != 0)
					{
						mode = 7;
						break;
					}
					mode = 9;
					codec.Message = "invalid literal/length code";
					r = -3;
					blocks.bitb = num;
					blocks.bitk = num2;
					codec.AvailableBytesIn = num4;
					codec.TotalBytesIn += num3 - codec.NextIn;
					codec.NextIn = num3;
					blocks.writeAt = num5;
					return blocks.Flush(r);
				}
				case 2:
				{
					int num7;
					for (num7 = bitsToGet; num2 < num7; num2 += 8)
					{
						if (num4 != 0)
						{
							r = 0;
							num4--;
							num |= (codec.InputBuffer[num3++] & 0xFF) << num2;
							continue;
						}
						blocks.bitb = num;
						blocks.bitk = num2;
						codec.AvailableBytesIn = num4;
						codec.TotalBytesIn += num3 - codec.NextIn;
						codec.NextIn = num3;
						blocks.writeAt = num5;
						return blocks.Flush(r);
					}
					len += num & InternalInflateConstants.InflateMask[num7];
					num >>= num7;
					num2 -= num7;
					need = dbits;
					tree = dtree;
					tree_index = dtree_index;
					mode = 3;
					goto case 3;
				}
				case 3:
				{
					int num7;
					for (num7 = need; num2 < num7; num2 += 8)
					{
						if (num4 != 0)
						{
							r = 0;
							num4--;
							num |= (codec.InputBuffer[num3++] & 0xFF) << num2;
							continue;
						}
						blocks.bitb = num;
						blocks.bitk = num2;
						codec.AvailableBytesIn = num4;
						codec.TotalBytesIn += num3 - codec.NextIn;
						codec.NextIn = num3;
						blocks.writeAt = num5;
						return blocks.Flush(r);
					}
					int num8 = (tree_index + (num & InternalInflateConstants.InflateMask[num7])) * 3;
					num >>= tree[num8 + 1];
					num2 -= tree[num8 + 1];
					int num9 = tree[num8];
					if (((uint)num9 & 0x10u) != 0)
					{
						bitsToGet = num9 & 0xF;
						dist = tree[num8 + 2];
						mode = 4;
						break;
					}
					if ((num9 & 0x40) == 0)
					{
						need = num9;
						tree_index = num8 / 3 + tree[num8 + 2];
						break;
					}
					mode = 9;
					codec.Message = "invalid distance code";
					r = -3;
					blocks.bitb = num;
					blocks.bitk = num2;
					codec.AvailableBytesIn = num4;
					codec.TotalBytesIn += num3 - codec.NextIn;
					codec.NextIn = num3;
					blocks.writeAt = num5;
					return blocks.Flush(r);
				}
				case 4:
				{
					int num7;
					for (num7 = bitsToGet; num2 < num7; num2 += 8)
					{
						if (num4 != 0)
						{
							r = 0;
							num4--;
							num |= (codec.InputBuffer[num3++] & 0xFF) << num2;
							continue;
						}
						blocks.bitb = num;
						blocks.bitk = num2;
						codec.AvailableBytesIn = num4;
						codec.TotalBytesIn += num3 - codec.NextIn;
						codec.NextIn = num3;
						blocks.writeAt = num5;
						return blocks.Flush(r);
					}
					dist += num & InternalInflateConstants.InflateMask[num7];
					num >>= num7;
					num2 -= num7;
					mode = 5;
					goto case 5;
				}
				case 5:
				{
					int i;
					for (i = num5 - dist; i < 0; i += blocks.end)
					{
					}
					while (len != 0)
					{
						if (num6 == 0)
						{
							if (num5 == blocks.end && blocks.readAt != 0)
							{
								num5 = 0;
								num6 = ((num5 < blocks.readAt) ? (blocks.readAt - num5 - 1) : (blocks.end - num5));
							}
							if (num6 == 0)
							{
								blocks.writeAt = num5;
								r = blocks.Flush(r);
								num5 = blocks.writeAt;
								num6 = ((num5 < blocks.readAt) ? (blocks.readAt - num5 - 1) : (blocks.end - num5));
								if (num5 == blocks.end && blocks.readAt != 0)
								{
									num5 = 0;
									num6 = ((num5 < blocks.readAt) ? (blocks.readAt - num5 - 1) : (blocks.end - num5));
								}
								if (num6 == 0)
								{
									blocks.bitb = num;
									blocks.bitk = num2;
									codec.AvailableBytesIn = num4;
									codec.TotalBytesIn += num3 - codec.NextIn;
									codec.NextIn = num3;
									blocks.writeAt = num5;
									return blocks.Flush(r);
								}
							}
						}
						blocks.window[num5++] = blocks.window[i++];
						num6--;
						if (i == blocks.end)
						{
							i = 0;
						}
						len--;
					}
					mode = 0;
					break;
				}
				case 6:
					if (num6 == 0)
					{
						if (num5 == blocks.end && blocks.readAt != 0)
						{
							num5 = 0;
							num6 = ((num5 < blocks.readAt) ? (blocks.readAt - num5 - 1) : (blocks.end - num5));
						}
						if (num6 == 0)
						{
							blocks.writeAt = num5;
							r = blocks.Flush(r);
							num5 = blocks.writeAt;
							num6 = ((num5 < blocks.readAt) ? (blocks.readAt - num5 - 1) : (blocks.end - num5));
							if (num5 == blocks.end && blocks.readAt != 0)
							{
								num5 = 0;
								num6 = ((num5 < blocks.readAt) ? (blocks.readAt - num5 - 1) : (blocks.end - num5));
							}
							if (num6 == 0)
							{
								blocks.bitb = num;
								blocks.bitk = num2;
								codec.AvailableBytesIn = num4;
								codec.TotalBytesIn += num3 - codec.NextIn;
								codec.NextIn = num3;
								blocks.writeAt = num5;
								return blocks.Flush(r);
							}
						}
					}
					r = 0;
					blocks.window[num5++] = (byte)lit;
					num6--;
					mode = 0;
					break;
				case 7:
					if (num2 > 7)
					{
						num2 -= 8;
						num4++;
						num3--;
					}
					blocks.writeAt = num5;
					r = blocks.Flush(r);
					num5 = blocks.writeAt;
					num6 = ((num5 < blocks.readAt) ? (blocks.readAt - num5 - 1) : (blocks.end - num5));
					if (blocks.readAt != blocks.writeAt)
					{
						blocks.bitb = num;
						blocks.bitk = num2;
						codec.AvailableBytesIn = num4;
						codec.TotalBytesIn += num3 - codec.NextIn;
						codec.NextIn = num3;
						blocks.writeAt = num5;
						return blocks.Flush(r);
					}
					mode = 8;
					goto case 8;
				case 8:
					r = 1;
					blocks.bitb = num;
					blocks.bitk = num2;
					codec.AvailableBytesIn = num4;
					codec.TotalBytesIn += num3 - codec.NextIn;
					codec.NextIn = num3;
					blocks.writeAt = num5;
					return blocks.Flush(r);
				case 9:
					r = -3;
					blocks.bitb = num;
					blocks.bitk = num2;
					codec.AvailableBytesIn = num4;
					codec.TotalBytesIn += num3 - codec.NextIn;
					codec.NextIn = num3;
					blocks.writeAt = num5;
					return blocks.Flush(r);
				default:
					r = -2;
					blocks.bitb = num;
					blocks.bitk = num2;
					codec.AvailableBytesIn = num4;
					codec.TotalBytesIn += num3 - codec.NextIn;
					codec.NextIn = num3;
					blocks.writeAt = num5;
					return blocks.Flush(r);
				}
			}
		}

		internal int InflateFast(int bl, int bd, int[] tl, int tl_index, int[] td, int td_index, InflateBlocks s, ZlibCodec z)
		{
			int nextIn = z.NextIn;
			int num = z.AvailableBytesIn;
			int num2 = s.bitb;
			int num3 = s.bitk;
			int num4 = s.writeAt;
			int num5 = ((num4 < s.readAt) ? (s.readAt - num4 - 1) : (s.end - num4));
			int num6 = InternalInflateConstants.InflateMask[bl];
			int num7 = InternalInflateConstants.InflateMask[bd];
			int num12;
			while (true)
			{
				if (num3 < 20)
				{
					num--;
					num2 |= (z.InputBuffer[nextIn++] & 0xFF) << num3;
					num3 += 8;
					continue;
				}
				int num8 = num2 & num6;
				int[] array = tl;
				int num9 = tl_index;
				int num10 = (num9 + num8) * 3;
				int num11;
				if ((num11 = array[num10]) == 0)
				{
					num2 >>= array[num10 + 1];
					num3 -= array[num10 + 1];
					s.window[num4++] = (byte)array[num10 + 2];
					num5--;
				}
				else
				{
					while (true)
					{
						num2 >>= array[num10 + 1];
						num3 -= array[num10 + 1];
						if (((uint)num11 & 0x10u) != 0)
						{
							num11 &= 0xF;
							num12 = array[num10 + 2] + (num2 & InternalInflateConstants.InflateMask[num11]);
							num2 >>= num11;
							for (num3 -= num11; num3 < 15; num3 += 8)
							{
								num--;
								num2 |= (z.InputBuffer[nextIn++] & 0xFF) << num3;
							}
							num8 = num2 & num7;
							array = td;
							num9 = td_index;
							num10 = (num9 + num8) * 3;
							num11 = array[num10];
							while (true)
							{
								num2 >>= array[num10 + 1];
								num3 -= array[num10 + 1];
								if (((uint)num11 & 0x10u) != 0)
								{
									break;
								}
								if ((num11 & 0x40) == 0)
								{
									num8 += array[num10 + 2];
									num8 += num2 & InternalInflateConstants.InflateMask[num11];
									num10 = (num9 + num8) * 3;
									num11 = array[num10];
									continue;
								}
								z.Message = "invalid distance code";
								num12 = z.AvailableBytesIn - num;
								num12 = ((num3 >> 3 < num12) ? (num3 >> 3) : num12);
								num += num12;
								nextIn -= num12;
								num3 -= num12 << 3;
								s.bitb = num2;
								s.bitk = num3;
								z.AvailableBytesIn = num;
								z.TotalBytesIn += nextIn - z.NextIn;
								z.NextIn = nextIn;
								s.writeAt = num4;
								return -3;
							}
							for (num11 &= 0xF; num3 < num11; num3 += 8)
							{
								num--;
								num2 |= (z.InputBuffer[nextIn++] & 0xFF) << num3;
							}
							int num13 = array[num10 + 2] + (num2 & InternalInflateConstants.InflateMask[num11]);
							num2 >>= num11;
							num3 -= num11;
							num5 -= num12;
							int num14;
							if (num4 >= num13)
							{
								num14 = num4 - num13;
								if (num4 - num14 > 0 && 2 > num4 - num14)
								{
									s.window[num4++] = s.window[num14++];
									s.window[num4++] = s.window[num14++];
									num12 -= 2;
								}
								else
								{
									Array.Copy(s.window, num14, s.window, num4, 2);
									num4 += 2;
									num14 += 2;
									num12 -= 2;
								}
							}
							else
							{
								num14 = num4 - num13;
								do
								{
									num14 += s.end;
								}
								while (num14 < 0);
								num11 = s.end - num14;
								if (num12 > num11)
								{
									num12 -= num11;
									if (num4 - num14 > 0 && num11 > num4 - num14)
									{
										do
										{
											s.window[num4++] = s.window[num14++];
										}
										while (--num11 != 0);
									}
									else
									{
										Array.Copy(s.window, num14, s.window, num4, num11);
										num4 += num11;
										num14 += num11;
										num11 = 0;
									}
									num14 = 0;
								}
							}
							if (num4 - num14 > 0 && num12 > num4 - num14)
							{
								do
								{
									s.window[num4++] = s.window[num14++];
								}
								while (--num12 != 0);
								break;
							}
							Array.Copy(s.window, num14, s.window, num4, num12);
							num4 += num12;
							num14 += num12;
							num12 = 0;
							break;
						}
						if ((num11 & 0x40) == 0)
						{
							num8 += array[num10 + 2];
							num8 += num2 & InternalInflateConstants.InflateMask[num11];
							num10 = (num9 + num8) * 3;
							if ((num11 = array[num10]) == 0)
							{
								num2 >>= array[num10 + 1];
								num3 -= array[num10 + 1];
								s.window[num4++] = (byte)array[num10 + 2];
								num5--;
								break;
							}
							continue;
						}
						if (((uint)num11 & 0x20u) != 0)
						{
							num12 = z.AvailableBytesIn - num;
							num12 = ((num3 >> 3 < num12) ? (num3 >> 3) : num12);
							num += num12;
							nextIn -= num12;
							num3 -= num12 << 3;
							s.bitb = num2;
							s.bitk = num3;
							z.AvailableBytesIn = num;
							z.TotalBytesIn += nextIn - z.NextIn;
							z.NextIn = nextIn;
							s.writeAt = num4;
							return 1;
						}
						z.Message = "invalid literal/length code";
						num12 = z.AvailableBytesIn - num;
						num12 = ((num3 >> 3 < num12) ? (num3 >> 3) : num12);
						num += num12;
						nextIn -= num12;
						num3 -= num12 << 3;
						s.bitb = num2;
						s.bitk = num3;
						z.AvailableBytesIn = num;
						z.TotalBytesIn += nextIn - z.NextIn;
						z.NextIn = nextIn;
						s.writeAt = num4;
						return -3;
					}
				}
				if (num5 < 258 || num < 10)
				{
					break;
				}
			}
			num12 = z.AvailableBytesIn - num;
			num12 = ((num3 >> 3 < num12) ? (num3 >> 3) : num12);
			num += num12;
			nextIn -= num12;
			num3 -= num12 << 3;
			s.bitb = num2;
			s.bitk = num3;
			z.AvailableBytesIn = num;
			z.TotalBytesIn += nextIn - z.NextIn;
			z.NextIn = nextIn;
			s.writeAt = num4;
			return 0;
		}
	}
	internal sealed class InflateManager
	{
		private enum InflateManagerMode
		{
			METHOD,
			FLAG,
			DICT4,
			DICT3,
			DICT2,
			DICT1,
			DICT0,
			BLOCKS,
			CHECK4,
			CHECK3,
			CHECK2,
			CHECK1,
			DONE,
			BAD
		}

		private const int PRESET_DICT = 32;

		private const int Z_DEFLATED = 8;

		private InflateManagerMode mode;

		internal ZlibCodec _codec;

		internal int method;

		internal uint computedCheck;

		internal uint expectedCheck;

		internal int marker;

		private bool _handleRfc1950HeaderBytes = true;

		internal int wbits;

		internal InflateBlocks blocks;

		private static readonly byte[] mark = new byte[4] { 0, 0, 255, 255 };

		internal bool HandleRfc1950HeaderBytes
		{
			get
			{
				return _handleRfc1950HeaderBytes;
			}
			set
			{
				_handleRfc1950HeaderBytes = value;
			}
		}

		public InflateManager()
		{
		}

		public InflateManager(bool expectRfc1950HeaderBytes)
		{
			_handleRfc1950HeaderBytes = expectRfc1950HeaderBytes;
		}

		internal int Reset()
		{
			_codec.TotalBytesIn = (_codec.TotalBytesOut = 0L);
			_codec.Message = null;
			mode = ((!HandleRfc1950HeaderBytes) ? InflateManagerMode.BLOCKS : InflateManagerMode.METHOD);
			blocks.Reset();
			return 0;
		}

		internal int End()
		{
			if (blocks != null)
			{
				blocks.Free();
			}
			blocks = null;
			return 0;
		}

		internal int Initialize(ZlibCodec codec, int w)
		{
			_codec = codec;
			_codec.Message = null;
			blocks = null;
			if (w < 8 || w > 15)
			{
				End();
				throw new ZlibException("Bad window size.");
			}
			wbits = w;
			blocks = new InflateBlocks(codec, HandleRfc1950HeaderBytes ? this : null, 1 << w);
			Reset();
			return 0;
		}

		internal int Inflate(FlushType flush)
		{
			if (_codec.InputBuffer == null)
			{
				throw new ZlibException("InputBuffer is null. ");
			}
			int num = 0;
			int num2 = -5;
			while (true)
			{
				switch (mode)
				{
				case InflateManagerMode.METHOD:
					if (_codec.AvailableBytesIn == 0)
					{
						return num2;
					}
					num2 = num;
					_codec.AvailableBytesIn--;
					_codec.TotalBytesIn++;
					if (((method = _codec.InputBuffer[_codec.NextIn++]) & 0xF) != 8)
					{
						mode = InflateManagerMode.BAD;
						_codec.Message = $"unknown compression method (0x{method:X2})";
						marker = 5;
					}
					else if ((method >> 4) + 8 > wbits)
					{
						mode = InflateManagerMode.BAD;
						_codec.Message = $"invalid window size ({(method >> 4) + 8})";
						marker = 5;
					}
					else
					{
						mode = InflateManagerMode.FLAG;
					}
					break;
				case InflateManagerMode.FLAG:
				{
					if (_codec.AvailableBytesIn == 0)
					{
						return num2;
					}
					num2 = num;
					_codec.AvailableBytesIn--;
					_codec.TotalBytesIn++;
					int num3 = _codec.InputBuffer[_codec.NextIn++] & 0xFF;
					if (((method << 8) + num3) % 31 != 0)
					{
						mode = InflateManagerMode.BAD;
						_codec.Message = "incorrect header check";
						marker = 5;
					}
					else
					{
						mode = (((num3 & 0x20) == 0) ? InflateManagerMode.BLOCKS : InflateManagerMode.DICT4);
					}
					break;
				}
				case InflateManagerMode.DICT4:
					if (_codec.AvailableBytesIn == 0)
					{
						return num2;
					}
					num2 = num;
					_codec.AvailableBytesIn--;
					_codec.TotalBytesIn++;
					expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xFF000000u);
					mode = InflateManagerMode.DICT3;
					break;
				case InflateManagerMode.DICT3:
					if (_codec.AvailableBytesIn == 0)
					{
						return num2;
					}
					num2 = num;
					_codec.AvailableBytesIn--;
					_codec.TotalBytesIn++;
					expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0xFF0000);
					mode = InflateManagerMode.DICT2;
					break;
				case InflateManagerMode.DICT2:
					if (_codec.AvailableBytesIn == 0)
					{
						return num2;
					}
					num2 = num;
					_codec.AvailableBytesIn--;
					_codec.TotalBytesIn++;
					expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0xFF00);
					mode = InflateManagerMode.DICT1;
					break;
				case InflateManagerMode.DICT1:
					if (_codec.AvailableBytesIn == 0)
					{
						return num2;
					}
					num2 = num;
					_codec.AvailableBytesIn--;
					_codec.TotalBytesIn++;
					expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0xFF);
					_codec._Adler32 = expectedCheck;
					mode = InflateManagerMode.DICT0;
					return 2;
				case InflateManagerMode.DICT0:
					mode = InflateManagerMode.BAD;
					_codec.Message = "need dictionary";
					marker = 0;
					return -2;
				case InflateManagerMode.BLOCKS:
					num2 = blocks.Process(num2);
					switch (num2)
					{
					case -3:
						mode = InflateManagerMode.BAD;
						marker = 0;
						goto end_IL_0025;
					case 0:
						num2 = num;
						break;
					}
					if (num2 != 1)
					{
						return num2;
					}
					num2 = num;
					computedCheck = blocks.Reset();
					if (!HandleRfc1950HeaderBytes)
					{
						mode = InflateManagerMode.DONE;
						return 1;
					}
					mode = InflateManagerMode.CHECK4;
					break;
				case InflateManagerMode.CHECK4:
					if (_codec.AvailableBytesIn == 0)
					{
						return num2;
					}
					num2 = num;
					_codec.AvailableBytesIn--;
					_codec.TotalBytesIn++;
					expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xFF000000u);
					mode = InflateManagerMode.CHECK3;
					break;
				case InflateManagerMode.CHECK3:
					if (_codec.AvailableBytesIn == 0)
					{
						return num2;
					}
					num2 = num;
					_codec.AvailableBytesIn--;
					_codec.TotalBytesIn++;
					expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0xFF0000);
					mode = InflateManagerMode.CHECK2;
					break;
				case InflateManagerMode.CHECK2:
					if (_codec.AvailableBytesIn == 0)
					{
						return num2;
					}
					num2 = num;
					_codec.AvailableBytesIn--;
					_codec.TotalBytesIn++;
					expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0xFF00);
					mode = InflateManagerMode.CHECK1;
					break;
				case InflateManagerMode.CHECK1:
					if (_codec.AvailableBytesIn == 0)
					{
						return num2;
					}
					num2 = num;
					_codec.AvailableBytesIn--;
					_codec.TotalBytesIn++;
					expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0xFF);
					if (computedCheck != expectedCheck)
					{
						mode = InflateManagerMode.BAD;
						_codec.Message = "incorrect data check";
						marker = 5;
						break;
					}
					mode = InflateManagerMode.DONE;
					return 1;
				case InflateManagerMode.DONE:
					return 1;
				case InflateManagerMode.BAD:
					throw new ZlibException($"Bad state ({_codec.Message})");
				default:
					{
						throw new ZlibException("Stream error.");
					}
					end_IL_0025:
					break;
				}
			}
		}

		internal int SetDictionary(byte[] dictionary)
		{
			int start = 0;
			int num = dictionary.Length;
			if (mode != InflateManagerMode.DICT0)
			{
				throw new ZlibException("Stream error.");
			}
			if (Adler.Adler32(1u, dictionary, 0, dictionary.Length) != _codec._Adler32)
			{
				return -3;
			}
			_codec._Adler32 = Adler.Adler32(0u, null, 0, 0);
			if (num >= 1 << wbits)
			{
				num = (1 << wbits) - 1;
				start = dictionary.Length - num;
			}
			blocks.SetDictionary(dictionary, start, num);
			mode = InflateManagerMode.BLOCKS;
			return 0;
		}

		internal int Sync()
		{
			if (mode != InflateManagerMode.BAD)
			{
				mode = InflateManagerMode.BAD;
				marker = 0;
			}
			int num;
			if ((num = _codec.AvailableBytesIn) == 0)
			{
				return -5;
			}
			int num2 = _codec.NextIn;
			int num3 = marker;
			while (num != 0 && num3 < 4)
			{
				num3 = ((_codec.InputBuffer[num2] != mark[num3]) ? ((_codec.InputBuffer[num2] == 0) ? (4 - num3) : 0) : (num3 + 1));
				num2++;
				num--;
			}
			_codec.TotalBytesIn += num2 - _codec.NextIn;
			_codec.NextIn = num2;
			_codec.AvailableBytesIn = num;
			marker = num3;
			if (num3 != 4)
			{
				return -3;
			}
			long totalBytesIn = _codec.TotalBytesIn;
			long totalBytesOut = _codec.TotalBytesOut;
			Reset();
			_codec.TotalBytesIn = totalBytesIn;
			_codec.TotalBytesOut = totalBytesOut;
			mode = InflateManagerMode.BLOCKS;
			return 0;
		}

		internal int SyncPoint(ZlibCodec z)
		{
			return blocks.SyncPoint();
		}
	}
	internal sealed class InfTree
	{
		private const int MANY = 1440;

		private const int Z_OK = 0;

		private const int Z_STREAM_END = 1;

		private const int Z_NEED_DICT = 2;

		private const int Z_ERRNO = -1;

		private const int Z_STREAM_ERROR = -2;

		private const int Z_DATA_ERROR = -3;

		private const int Z_MEM_ERROR = -4;

		private const int Z_BUF_ERROR = -5;

		private const int Z_VERSION_ERROR = -6;

		internal const int fixed_bl = 9;

		internal const int fixed_bd = 5;

		internal static readonly int[] fixed_tl = new int[1536]
		{
			96, 7, 256, 0, 8, 80, 0, 8, 16, 84,
			8, 115, 82, 7, 31, 0, 8, 112, 0, 8,
			48, 0, 9, 192, 80, 7, 10, 0, 8, 96,
			0, 8, 32, 0, 9, 160, 0, 8, 0, 0,
			8, 128, 0, 8, 64, 0, 9, 224, 80, 7,
			6, 0, 8, 88, 0, 8, 24, 0, 9, 144,
			83, 7, 59, 0, 8, 120, 0, 8, 56, 0,
			9, 208, 81, 7, 17, 0, 8, 104, 0, 8,
			40, 0, 9, 176, 0, 8, 8, 0, 8, 136,
			0, 8, 72, 0, 9, 240, 80, 7, 4, 0,
			8, 84, 0, 8, 20, 85, 8, 227, 83, 7,
			43, 0, 8, 116, 0, 8, 52, 0, 9, 200,
			81, 7, 13, 0, 8, 100, 0, 8, 36, 0,
			9, 168, 0, 8, 4, 0, 8, 132, 0, 8,
			68, 0, 9, 232, 80, 7, 8, 0, 8, 92,
			0, 8, 28, 0, 9, 152, 84, 7, 83, 0,
			8, 124, 0, 8, 60, 0, 9, 216, 82, 7,
			23, 0, 8, 108, 0, 8, 44, 0, 9, 184,
			0, 8, 12, 0, 8, 140, 0, 8, 76, 0,
			9, 248, 80, 7, 3, 0, 8, 82, 0, 8,
			18, 85, 8, 163, 83, 7, 35, 0, 8, 114,
			0, 8, 50, 0, 9, 196, 81, 7, 11, 0,
			8, 98, 0, 8, 34, 0, 9, 164, 0, 8,
			2, 0, 8, 130, 0, 8, 66, 0, 9, 228,
			80, 7, 7, 0, 8, 90, 0, 8, 26, 0,
			9, 148, 84, 7, 67, 0, 8, 122, 0, 8,
			58, 0, 9, 212, 82, 7, 19, 0, 8, 106,
			0, 8, 42, 0, 9, 180, 0, 8, 10, 0,
			8, 138, 0, 8, 74, 0, 9, 244, 80, 7,
			5, 0, 8, 86, 0, 8, 22, 192, 8, 0,
			83, 7, 51, 0, 8, 118, 0, 8, 54, 0,
			9, 204, 81, 7, 15, 0, 8, 102, 0, 8,
			38, 0, 9, 172, 0, 8, 6, 0, 8, 134,
			0, 8, 70, 0, 9, 236, 80, 7, 9, 0,
			8, 94, 0, 8, 30, 0, 9, 156, 84, 7,
			99, 0, 8, 126, 0, 8, 62, 0, 9, 220,
			82, 7, 27, 0, 8, 110, 0, 8, 46, 0,
			9, 188, 0, 8, 14, 0, 8, 142, 0, 8,
			78, 0, 9, 252, 96, 7, 256, 0, 8, 81,
			0, 8, 17, 85, 8, 131, 82, 7, 31, 0,
			8, 113, 0, 8, 49, 0, 9, 194, 80, 7,
			10, 0, 8, 97, 0, 8, 33, 0, 9, 162,
			0, 8, 1, 0, 8, 129, 0, 8, 65, 0,
			9, 226, 80, 7, 6, 0, 8, 89, 0, 8,
			25, 0, 9, 146, 83, 7, 59, 0, 8, 121,
			0, 8, 57, 0, 9, 210, 81, 7, 17, 0,
			8, 105, 0, 8, 41, 0, 9, 178, 0, 8,
			9, 0, 8, 137, 0, 8, 73, 0, 9, 242,
			80, 7, 4, 0, 8, 85, 0, 8, 21, 80,
			8, 258, 83, 7, 43, 0, 8, 117, 0, 8,
			53, 0, 9, 202, 81, 7, 13, 0, 8, 101,
			0, 8, 37, 0, 9, 170, 0, 8, 5, 0,
			8, 133, 0, 8, 69, 0, 9, 234, 80, 7,
			8, 0, 8, 93, 0, 8, 29, 0, 9, 154,
			84, 7, 83, 0, 8, 125, 0, 8, 61, 0,
			9, 218, 82, 7, 23, 0, 8, 109, 0, 8,
			45, 0, 9, 186, 0, 8, 13, 0, 8, 141,
			0, 8, 77, 0, 9, 250, 80, 7, 3, 0,
			8, 83, 0, 8, 19, 85, 8, 195, 83, 7,
			35, 0, 8, 115, 0, 8, 51, 0, 9, 198,
			81, 7, 11, 0, 8, 99, 0, 8, 35, 0,
			9, 166, 0, 8, 3, 0, 8, 131, 0, 8,
			67, 0, 9, 230, 80, 7, 7, 0, 8, 91,
			0, 8, 27, 0, 9, 150, 84, 7, 67, 0,
			8, 123, 0, 8, 59, 0, 9, 214, 82, 7,
			19, 0, 8, 107, 0, 8, 43, 0, 9, 182,
			0, 8, 11, 0, 8, 139, 0, 8, 75, 0,
			9, 246, 80, 7, 5, 0, 8, 87, 0, 8,
			23, 192, 8, 0, 83, 7, 51, 0, 8, 119,
			0, 8, 55, 0, 9, 206, 81, 7, 15, 0,
			8, 103, 0, 8, 39, 0, 9, 174, 0, 8,
			7, 0, 8, 135, 0, 8, 71, 0, 9, 238,
			80, 7, 9, 0, 8, 95, 0, 8, 31, 0,
			9, 158, 84, 7, 99, 0, 8, 127, 0, 8,
			63, 0, 9, 222, 82, 7, 27, 0, 8, 111,
			0, 8, 47, 0, 9, 190, 0, 8, 15, 0,
			8, 143, 0, 8, 79, 0, 9, 254, 96, 7,
			256, 0, 8, 80, 0, 8, 16, 84, 8, 115,
			82, 7, 31, 0, 8, 112, 0, 8, 48, 0,
			9, 193, 80, 7, 10, 0, 8, 96, 0, 8,
			32, 0, 9, 161, 0, 8, 0, 0, 8, 128,
			0, 8, 64, 0, 9, 225, 80, 7, 6, 0,
			8, 88, 0, 8, 24, 0, 9, 145, 83, 7,
			59, 0, 8, 120, 0, 8, 56, 0, 9, 209,
			81, 7, 17, 0, 8, 104, 0, 8, 40, 0,
			9, 177, 0, 8, 8, 0, 8, 136, 0, 8,
			72, 0, 9, 241, 80, 7, 4, 0, 8, 84,
			0, 8, 20, 85, 8, 227, 83, 7, 43, 0,
			8, 116, 0, 8, 52, 0, 9, 201, 81, 7,
			13, 0, 8, 100, 0, 8, 36, 0, 9, 169,
			0, 8, 4, 0, 8, 132, 0, 8, 68, 0,
			9, 233, 80, 7, 8, 0, 8, 92, 0, 8,
			28, 0, 9, 153, 84, 7, 83, 0, 8, 124,
			0, 8, 60, 0, 9, 217, 82, 7, 23, 0,
			8, 108, 0, 8, 44, 0, 9, 185, 0, 8,
			12, 0, 8, 140, 0, 8, 76, 0, 9, 249,
			80, 7, 3, 0, 8, 82, 0, 8, 18, 85,
			8, 163, 83, 7, 35, 0, 8, 114, 0, 8,
			50, 0, 9, 197, 81, 7, 11, 0, 8, 98,
			0, 8, 34, 0, 9, 165, 0, 8, 2, 0,
			8, 130, 0, 8, 66, 0, 9, 229, 80, 7,
			7, 0, 8, 90, 0, 8, 26, 0, 9, 149,
			84, 7, 67, 0, 8, 122, 0, 8, 58, 0,
			9, 213, 82, 7, 19, 0, 8, 106, 0, 8,
			42, 0, 9, 181, 0, 8, 10, 0, 8, 138,
			0, 8, 74, 0, 9, 245, 80, 7, 5, 0,
			8, 86, 0, 8, 22, 192, 8, 0, 83, 7,
			51, 0, 8, 118, 0, 8, 54, 0, 9, 205,
			81, 7, 15, 0, 8, 102, 0, 8, 38, 0,
			9, 173, 0, 8, 6, 0, 8, 134, 0, 8,
			70, 0, 9, 237, 80, 7, 9, 0, 8, 94,
			0, 8, 30, 0, 9, 157, 84, 7, 99, 0,
			8, 126, 0, 8, 62, 0, 9, 221, 82, 7,
			27, 0, 8, 110, 0, 8, 46, 0, 9, 189,
			0, 8, 14, 0, 8, 142, 0, 8, 78, 0,
			9, 253, 96, 7, 256, 0, 8, 81, 0, 8,
			17, 85, 8, 131, 82, 7, 31, 0, 8, 113,
			0, 8, 49, 0, 9, 195, 80, 7, 10, 0,
			8, 97, 0, 8, 33, 0, 9, 163, 0, 8,
			1, 0, 8, 129, 0, 8, 65, 0, 9, 227,
			80, 7, 6, 0, 8, 89, 0, 8, 25, 0,
			9, 147, 83, 7, 59, 0, 8, 121, 0, 8,
			57, 0, 9, 211, 81, 7, 17, 0, 8, 105,
			0, 8, 41, 0, 9, 179, 0, 8, 9, 0,
			8, 137, 0, 8, 73, 0, 9, 243, 80, 7,
			4, 0, 8, 85, 0, 8, 21, 80, 8, 258,
			83, 7, 43, 0, 8, 117, 0, 8, 53, 0,
			9, 203, 81, 7, 13, 0, 8, 101, 0, 8,
			37, 0, 9, 171, 0, 8, 5, 0, 8, 133,
			0, 8, 69, 0, 9, 235, 80, 7, 8, 0,
			8, 93, 0, 8, 29, 0, 9, 155, 84, 7,
			83, 0, 8, 125, 0, 8, 61, 0, 9, 219,
			82, 7, 23, 0, 8, 109, 0, 8, 45, 0,
			9, 187, 0, 8, 13, 0, 8, 141, 0, 8,
			77, 0, 9, 251, 80, 7, 3, 0, 8, 83,
			0, 8, 19, 85, 8, 195, 83, 7, 35, 0,
			8, 115, 0, 8, 51, 0, 9, 199, 81, 7,
			11, 0, 8, 99, 0, 8, 35, 0, 9, 167,
			0, 8, 3, 0, 8, 131, 0, 8, 67, 0,
			9, 231, 80, 7, 7, 0, 8, 91, 0, 8,
			27, 0, 9, 151, 84, 7, 67, 0, 8, 123,
			0, 8, 59, 0, 9, 215, 82, 7, 19, 0,
			8, 107, 0, 8, 43, 0, 9, 183, 0, 8,
			11, 0, 8, 139, 0, 8, 75, 0, 9, 247,
			80, 7, 5, 0, 8, 87, 0, 8, 23, 192,
			8, 0, 83, 7, 51, 0, 8, 119, 0, 8,
			55, 0, 9, 207, 81, 7, 15, 0, 8, 103,
			0, 8, 39, 0, 9, 175, 0, 8, 7, 0,
			8, 135, 0, 8, 71, 0, 9, 239, 80, 7,
			9, 0, 8, 95, 0, 8, 31, 0, 9, 159,
			84, 7, 99, 0, 8, 127, 0, 8, 63, 0,
			9, 223, 82, 7, 27, 0, 8, 111, 0, 8,
			47, 0, 9, 191, 0, 8, 15, 0, 8, 143,
			0, 8, 79, 0, 9, 255
		};

		internal static readonly int[] fixed_td = new int[96]
		{
			80, 5, 1, 87, 5, 257, 83, 5, 17, 91,
			5, 4097, 81, 5, 5, 89, 5, 1025, 85, 5,
			65, 93, 5, 16385, 80, 5, 3, 88, 5, 513,
			84, 5, 33, 92, 5, 8193, 82, 5, 9, 90,
			5, 2049, 86, 5, 129, 192, 5, 24577, 80, 5,
			2, 87, 5, 385, 83, 5, 25, 91, 5, 6145,
			81, 5, 7, 89, 5, 1537, 85, 5, 97, 93,
			5, 24577, 80, 5, 4, 88, 5, 769, 84, 5,
			49, 92, 5, 12289, 82, 5, 13, 90, 5, 3073,
			86, 5, 193, 192, 5, 24577
		};

		internal static readonly int[] cplens = new int[31]
		{
			3, 4, 5, 6, 7, 8, 9, 10, 11, 13,
			15, 17, 19, 23, 27, 31, 35, 43, 51, 59,
			67, 83, 99, 115, 131, 163, 195, 227, 258, 0,
			0
		};

		internal static readonly int[] cplext = new int[31]
		{
			0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
			1, 1, 2, 2, 2, 2, 3, 3, 3, 3,
			4, 4, 4, 4, 5, 5, 5, 5, 0, 112,
			112
		};

		internal static readonly int[] cpdist = new int[30]
		{
			1, 2, 3, 4, 5, 7, 9, 13, 17, 25,
			33, 49, 65, 97, 129, 193, 257, 385, 513, 769,
			1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577
		};

		internal static readonly int[] cpdext = new int[30]
		{
			0, 0, 0, 0, 1, 1, 2, 2, 3, 3,
			4, 4, 5, 5, 6, 6, 7, 7, 8, 8,
			9, 9, 10, 10, 11, 11, 12, 12, 13, 13
		};

		internal const int BMAX = 15;

		internal int[] hn;

		internal int[] v;

		internal int[] c;

		internal int[] r;

		internal int[] u;

		internal int[] x;

		private int huft_build(int[] b, int bindex, int n, int s, int[] d, int[] e, int[] t, int[] m, int[] hp, int[] hn, int[] v)
		{
			int num = 0;
			int num2 = n;
			do
			{
				c[b[bindex + num]]++;
				num++;
				num2--;
			}
			while (num2 != 0);
			if (c[0] == n)
			{
				t[0] = -1;
				m[0] = 0;
				return 0;
			}
			int num3 = m[0];
			int i;
			for (i = 1; i <= 15 && c[i] == 0; i++)
			{
			}
			int j = i;
			if (num3 < i)
			{
				num3 = i;
			}
			num2 = 15;
			while (num2 != 0 && c[num2] == 0)
			{
				num2--;
			}
			int num4 = num2;
			if (num3 > num2)
			{
				num3 = num2;
			}
			m[0] = num3;
			int num5 = 1 << i;
			while (i < num2)
			{
				if ((num5 -= c[i]) < 0)
				{
					return -3;
				}
				i++;
				num5 <<= 1;
			}
			if ((num5 -= c[num2]) < 0)
			{
				return -3;
			}
			c[num2] += num5;
			i = (x[1] = 0);
			num = 1;
			int num6 = 2;
			while (--num2 != 0)
			{
				i = (x[num6] = i + c[num]);
				num6++;
				num++;
			}
			num2 = 0;
			num = 0;
			do
			{
				if ((i = b[bindex + num]) != 0)
				{
					v[x[i]++] = num2;
				}
				num++;
			}
			while (++num2 < n);
			n = x[num4];
			num2 = (x[0] = 0);
			num = 0;
			int num7 = -1;
			int num8 = -num3;
			u[0] = 0;
			int num9 = 0;
			int num10 = 0;
			for (; j <= num4; j++)
			{
				int num11 = c[j];
				while (num11-- != 0)
				{
					int num12;
					while (j > num8 + num3)
					{
						num7++;
						num8 += num3;
						num10 = num4 - num8;
						num10 = ((num10 > num3) ? num3 : num10);
						if ((num12 = 1 << (i = j - num8)) > num11 + 1)
						{
							num12 -= num11 + 1;
							num6 = j;
							if (i < num10)
							{
								while (++i < num10 && (num12 <<= 1) > c[++num6])
								{
									num12 -= c[num6];
								}
							}
						}
						num10 = 1 << i;
						if (hn[0] + num10 > 1440)
						{
							return -3;
						}
						num9 = (u[num7] = hn[0]);
						hn[0] += num10;
						if (num7 != 0)
						{
							x[num7] = num2;
							r[0] = (sbyte)i;
							r[1] = (sbyte)num3;
							i = SharedUtils.URShift(num2, num8 - num3);
							r[2] = num9 - u[num7 - 1] - i;
							Array.Copy(r, 0, hp, (u[num7 - 1] + i) * 3, 3);
						}
						else
						{
							t[0] = num9;
						}
					}
					r[1] = (sbyte)(j - num8);
					if (num >= n)
					{
						r[0] = 192;
					}
					else if (v[num] < s)
					{
						r[0] = (sbyte)((v[num] >= 256) ? 96 : 0);
						r[2] = v[num++];
					}
					else
					{
						r[0] = (sbyte)(e[v[num] - s] + 16 + 64);
						r[2] = d[v[num++] - s];
					}
					num12 = 1 << j - num8;
					for (i = SharedUtils.URShift(num2, num8); i < num10; i += num12)
					{
						Array.Copy(r, 0, hp, (num9 + i) * 3, 3);
					}
					i = 1 << j - 1;
					while ((num2 & i) != 0)
					{
						num2 ^= i;
						i = SharedUtils.URShift(i, 1);
					}
					num2 ^= i;
					int num13 = (1 << num8) - 1;
					while ((num2 & num13) != x[num7])
					{
						num7--;
						num8 -= num3;
						num13 = (1 << num8) - 1;
					}
				}
			}
			if (num5 == 0 || num4 == 1)
			{
				return 0;
			}
			return -5;
		}

		internal int inflate_trees_bits(int[] c, int[] bb, int[] tb, int[] hp, ZlibCodec z)
		{
			initWorkArea(19);
			hn[0] = 0;
			int num = huft_build(c, 0, 19, 19, null, null, tb, bb, hp, hn, v);
			if (num == -3)
			{
				z.Message = "oversubscribed dynamic bit lengths tree";
			}
			else if (num == -5 || bb[0] == 0)
			{
				z.Message = "incomplete dynamic bit lengths tree";
				num = -3;
			}
			return num;
		}

		internal int inflate_trees_dynamic(int nl, int nd, int[] c, int[] bl, int[] bd, int[] tl, int[] td, int[] hp, ZlibCodec z)
		{
			initWorkArea(288);
			hn[0] = 0;
			int num = huft_build(c, 0, nl, 257, cplens, cplext, tl, bl, hp, hn, v);
			if (num != 0 || bl[0] == 0)
			{
				switch (num)
				{
				case -3:
					z.Message = "oversubscribed literal/length tree";
					break;
				default:
					z.Message = "incomplete literal/length tree";
					num = -3;
					break;
				case -4:
					break;
				}
				return num;
			}
			initWorkArea(288);
			num = huft_build(c, nl, nd, 0, cpdist, cpdext, td, bd, hp, hn, v);
			if (num != 0 || (bd[0] == 0 && nl > 257))
			{
				switch (num)
				{
				case -3:
					z.Message = "oversubscribed distance tree";
					break;
				case -5:
					z.Message = "incomplete distance tree";
					num = -3;
					break;
				default:
					z.Message = "empty distance tree with lengths";
					num = -3;
					break;
				case -4:
					break;
				}
				return num;
			}
			return 0;
		}

		internal static int inflate_trees_fixed(int[] bl, int[] bd, int[][] tl, int[][] td, ZlibCodec z)
		{
			bl[0] = 9;
			bd[0] = 5;
			tl[0] = fixed_tl;
			td[0] = fixed_td;
			return 0;
		}

		private void initWorkArea(int vsize)
		{
			if (hn == null)
			{
				hn = new int[1];
				v = new int[vsize];
				c = new int[16];
				r = new int[3];
				u = new int[15];
				x = new int[16];
				return;
			}
			if (v.Length < vsize)
			{
				v = new int[vsize];
			}
			Array.Clear(v, 0, vsize);
			Array.Clear(c, 0, 16);
			r[0] = 0;
			r[1] = 0;
			r[2] = 0;
			Array.Clear(u, 0, 15);
			Array.Clear(x, 0, 16);
		}
	}
	internal class WorkItem
	{
		public byte[] buffer;

		public byte[] compressed;

		public int crc;

		public int index;

		public int ordinal;

		public int inputBytesAvailable;

		public int compressedBytesAvailable;

		public ZlibCodec compressor;

		public WorkItem(int size, CompressionLevel compressLevel, CompressionStrategy strategy, int ix)
		{
			buffer = new byte[size];
			int num = size + (size / 32768 + 1) * 5 * 2;
			compressed = new byte[num];
			compressor = new ZlibCodec();
			compressor.InitializeDeflate(compressLevel, wantRfc1950Header: false);
			compressor.OutputBuffer = compressed;
			compressor.InputBuffer = buffer;
			index = ix;
		}
	}
	public class ParallelDeflateOutputStream : Stream
	{
		[Flags]
		private enum TraceBits : uint
		{
			None = 0u,
			NotUsed1 = 1u,
			EmitLock = 2u,
			EmitEnter = 4u,
			EmitBegin = 8u,
			EmitDone = 0x10u,
			EmitSkip = 0x20u,
			EmitAll = 0x3Au,
			Flush = 0x40u,
			Lifecycle = 0x80u,
			Session = 0x100u,
			Synch = 0x200u,
			Instance = 0x400u,
			Compress = 0x800u,
			Write = 0x1000u,
			WriteEnter = 0x2000u,
			WriteTake = 0x4000u,
			All = uint.MaxValue
		}

		private static readonly int IO_BUFFER_SIZE_DEFAULT = 65536;

		private static readonly int BufferPairsPerCore = 4;

		private List<WorkItem> _pool;

		private bool _leaveOpen;

		private bool emitting;

		private Stream _outStream;

		private int _maxBufferPairs;

		private int _bufferSize = IO_BUFFER_SIZE_DEFAULT;

		private AutoResetEvent _newlyCompressedBlob;

		private object _outputLock = new object();

		private bool _isClosed;

		private bool _firstWriteDone;

		private int _currentlyFilling;

		private int _lastFilled;

		private int _lastWritten;

		private int _latestCompressed;

		private int _Crc32;

		private CRC32 _runningCrc;

		private object _latestLock = new object();

		private Queue<int> _toWrite;

		private Queue<int> _toFill;

		private long _totalBytesProcessed;

		private CompressionLevel _compressLevel;

		private volatile Exception _pendingException;

		private bool _handlingException;

		private object _eLock = new object();

		private TraceBits _DesiredTrace = TraceBits.EmitAll | TraceBits.EmitEnter | TraceBits.Session | TraceBits.Compress | TraceBits.WriteEnter | TraceBits.WriteTake;

		public CompressionStrategy Strategy { get; private set; }

		public int MaxBufferPairs
		{
			get
			{
				return _maxBufferPairs;
			}
			set
			{
				if (value < 4)
				{
					throw new ArgumentException("MaxBufferPairs", "Value must be 4 or greater.");
				}
				_maxBufferPairs = value;
			}
		}

		public int BufferSize
		{
			get
			{
				return _bufferSize;
			}
			set
			{
				if (value < 1024)
				{
					throw new ArgumentOutOfRangeException("BufferSize", "BufferSize must be greater than 1024 bytes");
				}
				_bufferSize = value;
			}
		}

		public int Crc32 => _Crc32;

		public long BytesProcessed => _totalBytesProcessed;

		public override bool CanSeek => false;

		public override bool CanRead => false;

		public override bool CanWrite => _outStream.CanWrite;

		public override long Length
		{
			get
			{
				throw new NotSupportedException();
			}
		}

		public override long Position
		{
			get
			{
				return _outStream.Position;
			}
			set
			{
				throw new NotSupportedException();
			}
		}

		public ParallelDeflateOutputStream(Stream stream)
			: this(stream, CompressionLevel.Default, CompressionStrategy.Default, leaveOpen: false)
		{
		}

		public ParallelDeflateOutputStream(Stream stream, CompressionLevel level)
			: this(stream, level, CompressionStrategy.Default, leaveOpen: false)
		{
		}

		public ParallelDeflateOutputStream(Stream stream, bool leaveOpen)
			: this(stream, CompressionLevel.Default, CompressionStrategy.Default, leaveOpen)
		{
		}

		public ParallelDeflateOutputStream(Stream stream, CompressionLevel level, bool leaveOpen)
			: this(stream, CompressionLevel.Default, CompressionStrategy.Default, leaveOpen)
		{
		}

		public ParallelDeflateOutputStream(Stream stream, CompressionLevel level, CompressionStrategy strategy, bool leaveOpen)
		{
			_outStream = stream;
			_compressLevel = level;
			Strategy = strategy;
			_leaveOpen = leaveOpen;
			MaxBufferPairs = 16;
		}

		private void _InitializePoolOfWorkItems()
		{
			_toWrite = new Queue<int>();
			_toFill = new Queue<int>();
			_pool = new List<WorkItem>();
			int val = BufferPairsPerCore * Environment.ProcessorCount;
			val = Math.Min(val, _maxBufferPairs);
			for (int i = 0; i < val; i++)
			{
				_pool.Add(new WorkItem(_bufferSize, _compressLevel, Strategy, i));
				_toFill.Enqueue(i);
			}
			_newlyCompressedBlob = new AutoResetEvent(initialState: false);
			_runningCrc = new CRC32();
			_currentlyFilling = -1;
			_lastFilled = -1;
			_lastWritten = -1;
			_latestCompressed = -1;
		}

		public override void Write(byte[] buffer, int offset, int count)
		{
			bool mustWait = false;
			if (_isClosed)
			{
				throw new InvalidOperationException();
			}
			if (_pendingException != null)
			{
				_handlingException = true;
				Exception pendingException = _pendingException;
				_pendingException = null;
				throw pendingException;
			}
			if (count == 0)
			{
				return;
			}
			if (!_firstWriteDone)
			{
				_InitializePoolOfWorkItems();
				_firstWriteDone = true;
			}
			do
			{
				EmitPendingBuffers(doAll: false, mustWait);
				mustWait = false;
				int num = -1;
				if (_currentlyFilling >= 0)
				{
					num = _currentlyFilling;
				}
				else
				{
					if (_toFill.Count == 0)
					{
						mustWait = true;
						continue;
					}
					num = _toFill.Dequeue();
					_lastFilled++;
				}
				WorkItem workItem = _pool[num];
				int num2 = ((workItem.buffer.Length - workItem.inputBytesAvailable > count) ? count : (workItem.buffer.Length - workItem.inputBytesAvailable));
				workItem.ordinal = _lastFilled;
				Buffer.BlockCopy(buffer, offset, workItem.buffer, workItem.inputBytesAvailable, num2);
				count -= num2;
				offset += num2;
				workItem.inputBytesAvailable += num2;
				if (workItem.inputBytesAvailable == workItem.buffer.Length)
				{
					if (!ThreadPool.QueueUserWorkItem(_DeflateOne, workItem))
					{
						throw new Exception("Cannot enqueue workitem");
					}
					_currentlyFilling = -1;
				}
				else
				{
					_currentlyFilling = num;
				}
				_ = 0;
			}
			while (count > 0);
		}

		private void _FlushFinish()
		{
			byte[] array = new byte[128];
			ZlibCodec zlibCodec = new ZlibCodec();
			int num = zlibCodec.InitializeDeflate(_compressLevel, wantRfc1950Header: false);
			zlibCodec.InputBuffer = null;
			zlibCodec.NextIn = 0;
			zlibCodec.AvailableBytesIn = 0;
			zlibCodec.OutputBuffer = array;
			zlibCodec.NextOut = 0;
			zlibCodec.AvailableBytesOut = array.Length;
			num = zlibCodec.Deflate(FlushType.Finish);
			if (num != 1 && num != 0)
			{
				throw new Exception("deflating: " + zlibCodec.Message);
			}
			if (array.Length - zlibCodec.AvailableBytesOut > 0)
			{
				_outStream.Write(array, 0, array.Length - zlibCodec.AvailableBytesOut);
			}
			zlibCodec.EndDeflate();
			_Crc32 = _runningCrc.Crc32Result;
		}

		private void _Flush(bool lastInput)
		{
			if (_isClosed)
			{
				throw new InvalidOperationException();
			}
			if (!emitting)
			{
				if (_currentlyFilling >= 0)
				{
					WorkItem wi = _pool[_currentlyFilling];
					_DeflateOne(wi);
					_currentlyFilling = -1;
				}
				if (lastInput)
				{
					EmitPendingBuffers(doAll: true, mustWait: false);
					_FlushFinish();
				}
				else
				{
					EmitPendingBuffers(doAll: false, mustWait: false);
				}
			}
		}

		public override void Flush()
		{
			if (_pendingException != null)
			{
				_handlingException = true;
				Exception pendingException = _pendingException;
				_pendingException = null;
				throw pendingException;
			}
			if (!_handlingException)
			{
				_Flush(lastInput: false);
			}
		}

		public override void Close()
		{
			if (_pendingException != null)
			{
				_handlingException = true;
				Exception pendingException = _pendingException;
				_pendingException = null;
				throw pendingException;
			}
			if (!_handlingException && !_isClosed)
			{
				_Flush(lastInput: true);
				if (!_leaveOpen)
				{
					_outStream.Close();
				}
				_isClosed = true;
			}
		}

		public new void Dispose()
		{
			Close();
			_pool = null;
			Dispose(disposing: true);
		}

		protected override void Dispose(bool disposing)
		{
			base.Dispose(disposing);
		}

		public void Reset(Stream stream)
		{
			if (!_firstWriteDone)
			{
				return;
			}
			_toWrite.Clear();
			_toFill.Clear();
			foreach (WorkItem item in _pool)
			{
				_toFill.Enqueue(item.index);
				item.ordinal = -1;
			}
			_firstWriteDone = false;
			_totalBytesProcessed = 0L;
			_runningCrc = new CRC32();
			_isClosed = false;
			_currentlyFilling = -1;
			_lastFilled = -1;
			_lastWritten = -1;
			_latestCompressed = -1;
			_outStream = stream;
		}

		private void EmitPendingBuffers(bool doAll, bool mustWait)
		{
			if (emitting)
			{
				return;
			}
			emitting = true;
			if (doAll || mustWait)
			{
				_newlyCompressedBlob.WaitOne();
			}
			do
			{
				int num = -1;
				int num2 = (doAll ? 200 : (mustWait ? (-1) : 0));
				int num3 = -1;
				do
				{
					if (Monitor.TryEnter(_toWrite, num2))
					{
						num3 = -1;
						try
						{
							if (_toWrite.Count > 0)
							{
								num3 = _toWrite.Dequeue();
							}
						}
						finally
						{
							Monitor.Exit(_toWrite);
						}
						if (num3 < 0)
						{
							continue;
						}
						WorkItem workItem = _pool[num3];
						if (workItem.ordinal != _lastWritten + 1)
						{
							lock (_toWrite)
							{
								_toWrite.Enqueue(num3);
							}
							if (num == num3)
							{
								_newlyCompressedBlob.WaitOne();
								num = -1;
							}
							else if (num == -1)
							{
								num = num3;
							}
							continue;
						}
						num = -1;
						_outStream.Write(workItem.compressed, 0, workItem.compressedBytesAvailable);
						_runningCrc.Combine(workItem.crc, workItem.inputBytesAvailable);
						_totalBytesProcessed += workItem.inputBytesAvailable;
						workItem.inputBytesAvailable = 0;
						_lastWritten = workItem.ordinal;
						_toFill.Enqueue(workItem.index);
						if (num2 == -1)
						{
							num2 = 0;
						}
					}
					else
					{
						num3 = -1;
					}
				}
				while (num3 >= 0);
			}
			while (doAll && _lastWritten != _latestCompressed);
			emitting = false;
		}

		private void _DeflateOne(object wi)
		{
			WorkItem workItem = (WorkItem)wi;
			try
			{
				CRC32 cRC = new CRC32();
				cRC.SlurpBlock(workItem.buffer, 0, workItem.inputBytesAvailable);
				DeflateOneSegment(workItem);
				workItem.crc = cRC.Crc32Result;
				lock (_latestLock)
				{
					if (workItem.ordinal > _latestCompressed)
					{
						_latestCompressed = workItem.ordinal;
					}
				}
				lock (_toWrite)
				{
					_toWrite.Enqueue(workItem.index);
				}
				_newlyCompressedBlob.Set();
			}
			catch (Exception pendingException)
			{
				lock (_eLock)
				{
					if (_pendingException != null)
					{
						_pendingException = pendingException;
					}
				}
			}
		}

		private bool DeflateOneSegment(WorkItem workitem)
		{
			ZlibCodec compressor = workitem.compressor;
			compressor.ResetDeflate();
			compressor.NextIn = 0;
			compressor.AvailableBytesIn = workitem.inputBytesAvailable;
			compressor.NextOut = 0;
			compressor.AvailableBytesOut = workitem.compressed.Length;
			do
			{
				compressor.Deflate(FlushType.None);
			}
			while (compressor.AvailableBytesIn > 0 || compressor.AvailableBytesOut == 0);
			compressor.Deflate(FlushType.Sync);
			workitem.compressedBytesAvailable = (int)compressor.TotalBytesOut;
			return true;
		}

		[Conditional("Trace")]
		private void TraceOutput(TraceBits bits, string format, params object[] varParams)
		{
			if ((bits & _DesiredTrace) != 0)
			{
				lock (_outputLock)
				{
					int hashCode = Thread.CurrentThread.GetHashCode();
					Console.Write("{0:000} PDOS ", hashCode);
					Console.WriteLine(format, varParams);
				}
			}
		}

		public override int Read(byte[] buffer, int offset, int count)
		{
			throw new NotSupportedException();
		}

		public override long Seek(long offset, SeekOrigin origin)
		{
			throw new NotSupportedException();
		}

		public override void SetLength(long value)
		{
			throw new NotSupportedException();
		}
	}
	public enum FlushType
	{
		None,
		Partial,
		Sync,
		Full,
		Finish
	}
	public enum CompressionLevel
	{
		None = 0,
		Level0 = 0,
		BestSpeed = 1,
		Level1 = 1,
		Level2 = 2,
		Level3 = 3,
		Level4 = 4,
		Level5 = 5,
		Default = 6,
		Level6 = 6,
		Level7 = 7,
		Level8 = 8,
		BestCompression = 9,
		Level9 = 9
	}
	public enum CompressionStrategy
	{
		Default,
		Filtered,
		HuffmanOnly
	}
	public enum CompressionMode
	{
		Compress,
		Decompress
	}
	[Guid("ebc25cf6-9120-4283-b972-0e5520d0000E")]
	public class ZlibException : Exception
	{
		public ZlibException()
		{
		}

		public ZlibException(string s)
			: base(s)
		{
		}
	}
	internal class SharedUtils
	{
		public static int URShift(int number, int bits)
		{
			return number >>> bits;
		}

		public static int ReadInput(TextReader sourceTextReader, byte[] target, int start, int count)
		{
			if (target.Length == 0)
			{
				return 0;
			}
			char[] array = new char[target.Length];
			int num = sourceTextReader.Read(array, start, count);
			if (num == 0)
			{
				return -1;
			}
			for (int i = start; i < start + num; i++)
			{
				target[i] = (byte)array[i];
			}
			return num;
		}

		internal static byte[] ToByteArray(string sourceString)
		{
			return Encoding.UTF8.GetBytes(sourceString);
		}

		internal static char[] ToCharArray(byte[] byteArray)
		{
			return Encoding.UTF8.GetChars(byteArray);
		}
	}
	internal static class InternalConstants
	{
		internal static readonly int MAX_BITS = 15;

		internal static readonly int BL_CODES = 19;

		internal static readonly int D_CODES = 30;

		internal static readonly int LITERALS = 256;

		internal static readonly int LENGTH_CODES = 29;

		internal static readonly int L_CODES = LITERALS + 1 + LENGTH_CODES;

		internal static readonly int MAX_BL_BITS = 7;

		internal static readonly int REP_3_6 = 16;

		internal static readonly int REPZ_3_10 = 17;

		internal static readonly int REPZ_11_138 = 18;
	}
	internal sealed class StaticTree
	{
		internal static readonly short[] lengthAndLiteralsTreeCodes;

		internal static readonly short[] distTreeCodes;

		internal static readonly StaticTree Literals;

		internal static readonly StaticTree Distances;

		internal static readonly StaticTree BitLengths;

		internal short[] treeCodes;

		internal int[] extraBits;

		internal int extraBase;

		internal int elems;

		internal int maxLength;

		private StaticTree(short[] treeCodes, int[] extraBits, int extraBase, int elems, int maxLength)
		{
			this.treeCodes = treeCodes;
			this.extraBits = extraBits;
			this.extraBase = extraBase;
			this.elems = elems;
			this.maxLength = maxLength;
		}

		static StaticTree()
		{
			lengthAndLiteralsTreeCodes = new short[576]
			{
				12, 8, 140, 8, 76, 8, 204, 8, 44, 8,
				172, 8, 108, 8, 236, 8, 28, 8, 156, 8,
				92, 8, 220, 8, 60, 8, 188, 8, 124, 8,
				252, 8, 2, 8, 130, 8, 66, 8, 194, 8,
				34, 8, 162, 8, 98, 8, 226, 8, 18, 8,
				146, 8, 82, 8, 210, 8, 50, 8, 178, 8,
				114, 8, 242, 8, 10, 8, 138, 8, 74, 8,
				202, 8, 42, 8, 170, 8, 106, 8, 234, 8,
				26, 8, 154, 8, 90, 8, 218, 8, 58, 8,
				186, 8, 122, 8, 250, 8, 6, 8, 134, 8,
				70, 8, 198, 8, 38, 8, 166, 8, 102, 8,
				230, 8, 22, 8, 150, 8, 86, 8, 214, 8,
				54, 8, 182, 8, 118, 8, 246, 8, 14, 8,
				142, 8, 78, 8, 206, 8, 46, 8, 174, 8,
				110, 8, 238, 8, 30, 8, 158, 8, 94, 8,
				222, 8, 62, 8, 190, 8, 126, 8, 254, 8,
				1, 8, 129, 8, 65, 8, 193, 8, 33, 8,
				161, 8, 97, 8, 225, 8, 17, 8, 145, 8,
				81, 8, 209, 8, 49, 8, 177, 8, 113, 8,
				241, 8, 9, 8, 137, 8, 73, 8, 201, 8,
				41, 8, 169, 8, 105, 8, 233, 8, 25, 8,
				153, 8, 89, 8, 217, 8, 57, 8, 185, 8,
				121, 8, 249, 8, 5, 8, 133, 8, 69, 8,
				197, 8, 37, 8, 165, 8, 101, 8, 229, 8,
				21, 8, 149, 8, 85, 8, 213, 8, 53, 8,
				181, 8, 117, 8, 245, 8, 13, 8, 141, 8,
				77, 8, 205, 8, 45, 8, 173, 8, 109, 8,
				237, 8, 29, 8, 157, 8, 93, 8, 221, 8,
				61, 8, 189, 8, 125, 8, 253, 8, 19, 9,
				275, 9, 147, 9, 403, 9, 83, 9, 339, 9,
				211, 9, 467, 9, 51, 9, 307, 9, 179, 9,
				435, 9, 115, 9, 371, 9, 243, 9, 499, 9,
				11, 9, 267, 9, 139, 9, 395, 9, 75, 9,
				331, 9, 203, 9, 459, 9, 43, 9, 299, 9,
				171, 9, 427, 9, 107, 9, 363, 9, 235, 9,
				491, 9, 27, 9, 283, 9, 155, 9, 411, 9,
				91, 9, 347, 9, 219, 9, 475, 9, 59, 9,
				315, 9, 187, 9, 443, 9, 123, 9, 379, 9,
				251, 9, 507, 9, 7, 9, 263, 9, 135, 9,
				391, 9, 71, 9, 327, 9, 199, 9, 455, 9,
				39, 9, 295, 9, 167, 9, 423, 9, 103, 9,
				359, 9, 231, 9, 487, 9, 23, 9, 279, 9,
				151, 9, 407, 9, 87, 9, 343, 9, 215, 9,
				471, 9, 55, 9, 311, 9, 183, 9, 439, 9,
				119, 9, 375, 9, 247, 9, 503, 9, 15, 9,
				271, 9, 143, 9, 399, 9, 79, 9, 335, 9,
				207, 9, 463, 9, 47, 9, 303, 9, 175, 9,
				431, 9, 111, 9, 367, 9, 239, 9, 495, 9,
				31, 9, 287, 9, 159, 9, 415, 9, 95, 9,
				351, 9, 223, 9, 479, 9, 63, 9, 319, 9,
				191, 9, 447, 9, 127, 9, 383, 9, 255, 9,
				511, 9, 0, 7, 64, 7, 32, 7, 96, 7,
				16, 7, 80, 7, 48, 7, 112, 7, 8, 7,
				72, 7, 40, 7, 104, 7, 24, 7, 88, 7,
				56, 7, 120, 7, 4, 7, 68, 7, 36, 7,
				100, 7, 20, 7, 84, 7, 52, 7, 116, 7,
				3, 8, 131, 8, 67, 8, 195, 8, 35, 8,
				163, 8, 99, 8, 227, 8
			};
			distTreeCodes = new short[60]
			{
				0, 5, 16, 5, 8, 5, 24, 5, 4, 5,
				20, 5, 12, 5, 28, 5, 2, 5, 18, 5,
				10, 5, 26, 5, 6, 5, 22, 5, 14, 5,
				30, 5, 1, 5, 17, 5, 9, 5, 25, 5,
				5, 5, 21, 5, 13, 5, 29, 5, 3, 5,
				19, 5, 11, 5, 27, 5, 7, 5, 23, 5
			};
			Literals = new StaticTree(lengthAndLiteralsTreeCodes, ZTree.ExtraLengthBits, InternalConstants.LITERALS + 1, InternalConstants.L_CODES, InternalConstants.MAX_BITS);
			Distances = new StaticTree(distTreeCodes, ZTree.ExtraDistanceBits, 0, InternalConstants.D_CODES, InternalConstants.MAX_BITS);
			BitLengths = new StaticTree(null, ZTree.extra_blbits, 0, InternalConstants.BL_CODES, InternalConstants.MAX_BL_BITS);
		}
	}
	public sealed class Adler
	{
		private static readonly uint BASE = 65521u;

		private static readonly int NMAX = 5552;

		public static uint Adler32(uint adler, byte[] buf, int index, int len)
		{
			if (buf == null)
			{
				return 1u;
			}
			uint num = adler & 0xFFFFu;
			uint num2 = (adler >> 16) & 0xFFFFu;
			while (len > 0)
			{
				int num3 = ((len < NMAX) ? len : NMAX);
				len -= num3;
				while (num3 >= 16)
				{
					num += buf[index++];
					num2 += num;
					num += buf[index++];
					num2 += num;
					num += buf[index++];
					num2 += num;
					num += buf[index++];
					num2 += num;
					num += buf[index++];
					num2 += num;
					num += buf[index++];
					num2 += num;
					num += buf[index++];
					num2 += num;
					num += buf[index++];
					num2 += num;
					num += buf[index++];
					num2 += num;
					num += buf[index++];
					num2 += num;
					num += buf[index++];
					num2 += num;
					num += buf[index++];
					num2 += num;
					num += buf[index++];
					num2 += num;
					num += buf[index++];
					num2 += num;
					num += buf[index++];
					num2 += num;
					num += buf[index++];
					num2 += num;
					num3 -= 16;
				}
				if (num3 != 0)
				{
					do
					{
						num += buf[index++];
						num2 += num;
					}
					while (--num3 != 0);
				}
				num %= BASE;
				num2 %= BASE;
			}
			return (num2 << 16) | num;
		}
	}
	internal enum ZlibStreamFlavor
	{
		ZLIB = 1950,
		DEFLATE,
		GZIP
	}
	internal class ZlibBaseStream : Stream
	{
		internal enum StreamMode
		{
			Writer,
			Reader,
			Undefined
		}

		protected internal ZlibCodec _z;

		protected internal StreamMode _streamMode = StreamMode.Undefined;

		protected internal FlushType _flushMode;

		protected internal ZlibStreamFlavor _flavor;

		protected internal CompressionMode _compressionMode;

		protected internal CompressionLevel _level;

		protected internal bool _leaveOpen;

		protected internal byte[] _workingBuffer;

		protected internal int _bufferSize = 16384;

		protected internal byte[] _buf1 = new byte[1];

		protected internal Stream _stream;

		protected internal CompressionStrategy Strategy;

		private CRC32 crc;

		protected internal string _GzipFileName;

		protected internal string _GzipComment;

		protected internal DateTime _GzipMtime;

		protected internal int _gzipHeaderByteCount;

		private bool nomoreinput;

		internal int Crc32
		{
			get
			{
				if (crc == null)
				{
					return 0;
				}
				return crc.Crc32Result;
			}
		}

		protected internal bool _wantCompress => _compressionMode == CompressionMode.Compress;

		private ZlibCodec z
		{
			get
			{
				if (_z == null)
				{
					bool flag = _flavor == ZlibStreamFlavor.ZLIB;
					_z = new ZlibCodec();
					if (_compressionMode == CompressionMode.Decompress)
					{
						_z.InitializeInflate(flag);
					}
					else
					{
						_z.Strategy = Strategy;
						_z.InitializeDeflate(_level, flag);
					}
				}
				return _z;
			}
		}

		private byte[] workingBuffer
		{
			get
			{
				if (_workingBuffer == null)
				{
					_workingBuffer = new byte[_bufferSize];
				}
				return _workingBuffer;
			}
		}

		public override bool CanRead => _stream.CanRead;

		public override bool CanSeek => _stream.CanSeek;

		public override bool CanWrite => _stream.CanWrite;

		public override long Length => _stream.Length;

		public override long Position
		{
			get
			{
				throw new NotImplementedException();
			}
			set
			{
				throw new NotImplementedException();
			}
		}

		public ZlibBaseStream(Stream stream, CompressionMode compressionMode, CompressionLevel level, ZlibStreamFlavor flavor, bool leaveOpen)
		{
			_flushMode = FlushType.None;
			_stream = stream;
			_leaveOpen = leaveOpen;
			_compressionMode = compressionMode;
			_flavor = flavor;
			_level = level;
			if (flavor == ZlibStreamFlavor.GZIP)
			{
				crc = new CRC32();
			}
		}

		public override void Write(byte[] buffer, int offset, int count)
		{
			if (crc != null)
			{
				crc.SlurpBlock(buffer, offset, count);
			}
			if (_streamMode == StreamMode.Undefined)
			{
				_streamMode = StreamMode.Writer;
			}
			else if (_streamMode != 0)
			{
				throw new ZlibException("Cannot Write after Reading.");
			}
			if (count == 0)
			{
				return;
			}
			z.InputBuffer = buffer;
			_z.NextIn = offset;
			_z.AvailableBytesIn = count;
			bool flag = false;
			do
			{
				_z.OutputBuffer = workingBuffer;
				_z.NextOut = 0;
				_z.AvailableBytesOut = _workingBuffer.Length;
				int num = (_wantCompress ? _z.Deflate(_flushMode) : _z.Inflate(_flushMode));
				if (num != 0 && num != 1)
				{
					throw new ZlibException((_wantCompress ? "de" : "in") + "flating: " + _z.Message);
				}
				_stream.Write(_workingBuffer, 0, _workingBuffer.Length - _z.AvailableBytesOut);
				flag = _z.AvailableBytesIn == 0 && _z.AvailableBytesOut != 0;
				if (_flavor == ZlibStreamFlavor.GZIP && !_wantCompress)
				{
					flag = _z.AvailableBytesIn == 8 && _z.AvailableBytesOut != 0;
				}
			}
			while (!flag);
		}

		private void finish()
		{
			if (_z == null)
			{
				return;
			}
			if (_streamMode == StreamMode.Writer)
			{
				bool flag = false;
				do
				{
					_z.OutputBuffer = workingBuffer;
					_z.NextOut = 0;
					_z.AvailableBytesOut = _workingBuffer.Length;
					int num = (_wantCompress ? _z.Deflate(FlushType.Finish) : _z.Inflate(FlushType.Finish));
					if (num != 1 && num != 0)
					{
						string text = (_wantCompress ? "de" : "in") + "flating";
						if (_z.Message == null)
						{
							throw new ZlibException($"{text}: (rc = {num})");
						}
						throw new ZlibException(text + ": " + _z.Message);
					}
					if (_workingBuffer.Length - _z.AvailableBytesOut > 0)
					{
						_stream.Write(_workingBuffer, 0, _workingBuffer.Length - _z.AvailableBytesOut);
					}
					flag = _z.AvailableBytesIn == 0 && _z.AvailableBytesOut != 0;
					if (_flavor == ZlibStreamFlavor.GZIP && !_wantCompress)
					{
						flag = _z.AvailableBytesIn == 8 && _z.AvailableBytesOut != 0;
					}
				}
				while (!flag);
				Flush();
				if (_flavor == ZlibStreamFlavor.GZIP)
				{
					if (!_wantCompress)
					{
						throw new ZlibException("Writing with decompression is not supported.");
					}
					int crc32Result = crc.Crc32Result;
					_stream.Write(BitConverter.GetBytes(crc32Result), 0, 4);
					int value = (int)(crc.TotalBytesRead & 0xFFFFFFFFu);
					_stream.Write(BitConverter.GetBytes(value), 0, 4);
				}
			}
			else
			{
				if (_streamMode != StreamMode.Reader || _flavor != ZlibStreamFlavor.GZIP)
				{
					return;
				}
				if (_wantCompress)
				{
					throw new ZlibException("Reading with compression is not supported.");
				}
				if (_z.TotalBytesOut == 0L)
				{
					return;
				}
				byte[] array = new byte[8];
				if (_z.AvailableBytesIn < 8)
				{
					Array.Copy(_z.InputBuffer, _z.NextIn, array, 0, _z.AvailableBytesIn);
					int num2 = 8 - _z.AvailableBytesIn;
					int num3 = _stream.Read(array, _z.AvailableBytesIn, num2);
					if (num2 != num3)
					{
						throw new ZlibException($"Missing or incomplete GZIP trailer. Expected 8 bytes, got {_z.AvailableBytesIn + num3}.");
					}
				}
				else
				{
					Array.Copy(_z.InputBuffer, _z.NextIn, array, 0, array.Length);
				}
				int num4 = BitConverter.ToInt32(array, 0);
				int crc32Result2 = crc.Crc32Result;
				int num5 = BitConverter.ToInt32(array, 4);
				int num6 = (int)(_z.TotalBytesOut & 0xFFFFFFFFu);
				if (crc32Result2 != num4)
				{
					throw new ZlibException($"Bad CRC32 in GZIP trailer. (actual({crc32Result2:X8})!=expected({num4:X8}))");
				}
				if (num6 != num5)
				{
					throw new ZlibException($"Bad size in GZIP trailer. (actual({num6})!=expected({num5}))");
				}
			}
		}

		private void end()
		{
			if (z != null)
			{
				if (_wantCompress)
				{
					_z.EndDeflate();
				}
				else
				{
					_z.EndInflate();
				}
				_z = null;
			}
		}

		public override void Close()
		{
			if (_stream == null)
			{
				return;
			}
			try
			{
				finish();
			}
			finally
			{
				end();
				if (!_leaveOpen)
				{
					_stream.Close();
				}
				_stream = null;
			}
		}

		public override void Flush()
		{
			_stream.Flush();
		}

		public override long Seek(long offset, SeekOrigin origin)
		{
			throw new NotImplementedException();
		}

		public override void SetLength(long value)
		{
			_stream.SetLength(value);
		}

		private string ReadZeroTerminatedString()
		{
			List<byte> list = new List<byte>();
			bool flag = false;
			do
			{
				if (_stream.Read(_buf1, 0, 1) != 1)
				{
					throw new ZlibException("Unexpected EOF reading GZIP header.");
				}
				if (_buf1[0] == 0)
				{
					flag = true;
				}
				else
				{
					list.Add(_buf1[0]);
				}
			}
			while (!flag);
			byte[] array = list.ToArray();
			return GZipStream.iso8859dash1.GetString(array, 0, array.Length);
		}

		private int _ReadAndValidateGzipHeader()
		{
			int num = 0;
			byte[] array = new byte[10];
			int num2 = _stream.Read(array, 0, array.Length);
			switch (num2)
			{
			case 0:
				return 0;
			default:
				throw new ZlibException("Not a valid GZIP stream.");
			case 10:
			{
				if (array[0] != 31 || array[1] != 139 || array[2] != 8)
				{
					throw new ZlibException("Bad GZIP header.");
				}
				int num3 = BitConverter.ToInt32(array, 4);
				_GzipMtime = GZipStream._unixEpoch.AddSeconds(num3);
				num += num2;
				if ((array[3] & 4) == 4)
				{
					num2 = _stream.Read(array, 0, 2);
					num += num2;
					short num4 = (short)(array[0] + array[1] * 256);
					byte[] array2 = new byte[num4];
					num2 = _stream.Read(array2, 0, array2.Length);
					if (num2 != num4)
					{
						throw new ZlibException("Unexpected end-of-file reading GZIP header.");
					}
					num += num2;
				}
				if ((array[3] & 8) == 8)
				{
					_GzipFileName = ReadZeroTerminatedString();
				}
				if ((array[3] & 0x10) == 16)
				{
					_GzipComment = ReadZeroTerminatedString();
				}
				if ((array[3] & 2) == 2)
				{
					Read(_buf1, 0, 1);
				}
				return num;
			}
			}
		}

		public override int Read(byte[] buffer, int offset, int count)
		{
			if (_streamMode == StreamMode.Undefined)
			{
				if (!_stream.CanRead)
				{
					throw new ZlibException("The stream is not readable.");
				}
				_streamMode = StreamMode.Reader;
				z.AvailableBytesIn = 0;
				if (_flavor == ZlibStreamFlavor.GZIP)
				{
					_gzipHeaderByteCount = _ReadAndValidateGzipHeader();
					if (_gzipHeaderByteCount == 0)
					{
						return 0;
					}
				}
			}
			if (_streamMode != StreamMode.Reader)
			{
				throw new ZlibException("Cannot Read after Writing.");
			}
			if (count == 0)
			{
				return 0;
			}
			if (nomoreinput && _wantCompress)
			{
				return 0;
			}
			if (buffer == null)
			{
				throw new ArgumentNullException("buffer");
			}
			if (count < 0)
			{
				throw new ArgumentOutOfRangeException("count");
			}
			if (offset < buffer.GetLowerBound(0))
			{
				throw new ArgumentOutOfRangeException("offset");
			}
			if (offset + count > buffer.GetLength(0))
			{
				throw new ArgumentOutOfRangeException("count");
			}
			int num = 0;
			_z.OutputBuffer = buffer;
			_z.NextOut = offset;
			_z.AvailableBytesOut = count;
			_z.InputBuffer = workingBuffer;
			do
			{
				if (_z.AvailableBytesIn == 0 && !nomoreinput)
				{
					_z.NextIn = 0;
					_z.AvailableBytesIn = _stream.Read(_workingBuffer, 0, _workingBuffer.Length);
					if (_z.AvailableBytesIn == 0)
					{
						nomoreinput = true;
					}
				}
				num = (_wantCompress ? _z.Deflate(_flushMode) : _z.Inflate(_flushMode));
				if (nomoreinput && num == -5)
				{
					return 0;
				}
				if (num != 0 && num != 1)
				{
					throw new ZlibException(string.Format("{0}flating:  rc={1}  msg={2}", _wantCompress ? "de" : "in", num, _z.Message));
				}
			}
			while (((!nomoreinput && num != 1) || _z.AvailableBytesOut != count) && _z.AvailableBytesOut > 0 && !nomoreinput && num == 0);
			if (_z.AvailableBytesOut > 0)
			{
				if (num == 0)
				{
					_ = _z.AvailableBytesIn;
				}
				if (nomoreinput && _wantCompress)
				{
					num = _z.Deflate(FlushType.Finish);
					if (num != 0 && num != 1)
					{
						throw new ZlibException($"Deflating:  rc={num}  msg={_z.Message}");
					}
				}
			}
			num = count - _z.AvailableBytesOut;
			if (crc != null)
			{
				crc.SlurpBlock(buffer, offset, num);
			}
			return num;
		}

		public static void CompressString(string s, Stream compressor)
		{
			byte[] bytes = Encoding.UTF8.GetBytes(s);
			using (compressor)
			{
				compressor.Write(bytes, 0, bytes.Length);
			}
		}

		public static void CompressBuffer(byte[] b, Stream compressor)
		{
			using (compressor)
			{
				compressor.Write(b, 0, b.Length);
			}
		}

		public static string UncompressString(byte[] compressed, Stream decompressor)
		{
			byte[] array = new byte[1024];
			Encoding uTF = Encoding.UTF8;
			using MemoryStream memoryStream = new MemoryStream();
			using (decompressor)
			{
				int count;
				while ((count = decompressor.Read(array, 0, array.Length)) != 0)
				{
					memoryStream.Write(array, 0, count);
				}
			}
			memoryStream.Seek(0L, SeekOrigin.Begin);
			return new StreamReader(memoryStream, uTF).ReadToEnd();
		}

		public static byte[] UncompressBuffer(byte[] compressed, Stream decompressor)
		{
			byte[] array = new byte[1024];
			using MemoryStream memoryStream = new MemoryStream();
			using (decompressor)
			{
				int count;
				while ((count = decompressor.Read(array, 0, array.Length)) != 0)
				{
					memoryStream.Write(array, 0, count);
				}
			}
			return memoryStream.ToArray();
		}
	}
	[Guid("ebc25cf6-9120-4283-b972-0e5520d0000D")]
	[ComVisible(true)]
	[ClassInterface(ClassInterfaceType.AutoDispatch)]
	public sealed class ZlibCodec
	{
		public byte[] InputBuffer;

		public int NextIn;

		public int AvailableBytesIn;

		public long TotalBytesIn;

		public byte[] OutputBuffer;

		public int NextOut;

		public int AvailableBytesOut;

		public long TotalBytesOut;

		public string Message;

		internal DeflateManager dstate;

		internal InflateManager istate;

		internal uint _Adler32;

		public CompressionLevel CompressLevel = CompressionLevel.Default;

		public int WindowBits = 15;

		public CompressionStrategy Strategy;

		public int Adler32 => (int)_Adler32;

		public ZlibCodec()
		{
		}

		public ZlibCodec(CompressionMode mode)
		{
			switch (mode)
			{
			case CompressionMode.Compress:
				if (InitializeDeflate() != 0)
				{
					throw new ZlibException("Cannot initialize for deflate.");
				}
				break;
			case CompressionMode.Decompress:
				if (InitializeInflate() != 0)
				{
					throw new ZlibException("Cannot initialize for inflate.");
				}
				break;
			default:
				throw new ZlibException("Invalid ZlibStreamFlavor.");
			}
		}

		public int InitializeInflate()
		{
			return InitializeInflate(WindowBits);
		}

		public int InitializeInflate(bool expectRfc1950Header)
		{
			return InitializeInflate(WindowBits, expectRfc1950Header);
		}

		public int InitializeInflate(int windowBits)
		{
			WindowBits = windowBits;
			return InitializeInflate(windowBits, expectRfc1950Header: true);
		}

		public int InitializeInflate(int windowBits, bool expectRfc1950Header)
		{
			WindowBits = windowBits;
			if (dstate != null)
			{
				throw new ZlibException("You may not call InitializeInflate() after calling InitializeDeflate().");
			}
			istate = new InflateManager(expectRfc1950Header);
			return istate.Initialize(this, windowBits);
		}

		public int Inflate(FlushType flush)
		{
			if (istate == null)
			{
				throw new ZlibException("No Inflate State!");
			}
			return istate.Inflate(flush);
		}

		public int EndInflate()
		{
			if (istate == null)
			{
				throw new ZlibException("No Inflate State!");
			}
			int result = istate.End();
			istate = null;
			return result;
		}

		public int SyncInflate()
		{
			if (istate == null)
			{
				throw new ZlibException("No Inflate State!");
			}
			return istate.Sync();
		}

		public int InitializeDeflate()
		{
			return _InternalInitializeDeflate(wantRfc1950Header: true);
		}

		public int InitializeDeflate(CompressionLevel level)
		{
			CompressLevel = level;
			return _InternalInitializeDeflate(wantRfc1950Header: true);
		}

		public int InitializeDeflate(CompressionLevel level, bool wantRfc1950Header)
		{
			CompressLevel = level;
			return _InternalInitializeDeflate(wantRfc1950Header);
		}

		public int InitializeDeflate(CompressionLevel level, int bits)
		{
			CompressLevel = level;
			WindowBits = bits;
			return _InternalInitializeDeflate(wantRfc1950Header: true);
		}

		public int InitializeDeflate(CompressionLevel level, int bits, bool wantRfc1950Header)
		{
			CompressLevel = level;
			WindowBits = bits;
			return _InternalInitializeDeflate(wantRfc1950Header);
		}

		private int _InternalInitializeDeflate(bool wantRfc1950Header)
		{
			if (istate != null)
			{
				throw new ZlibException("You may not call InitializeDeflate() after calling InitializeInflate().");
			}
			dstate = new DeflateManager();
			dstate.WantRfc1950HeaderBytes = wantRfc1950Header;
			return dstate.Initialize(this, CompressLevel, WindowBits, Strategy);
		}

		public int Deflate(FlushType flush)
		{
			if (dstate == null)
			{
				throw new ZlibException("No Deflate State!");
			}
			return dstate.Deflate(flush);
		}

		public int EndDeflate()
		{
			if (dstate == null)
			{
				throw new ZlibException("No Deflate State!");
			}
			dstate = null;
			return 0;
		}

		public void ResetDeflate()
		{
			if (dstate == null)
			{
				throw new ZlibException("No Deflate State!");
			}
			dstate.Reset();
		}

		public int SetDeflateParams(CompressionLevel level, CompressionStrategy strategy)
		{
			if (dstate == null)
			{
				throw new ZlibException("No Deflate State!");
			}
			return dstate.SetParams(level, strategy);
		}

		public int SetDictionary(byte[] dictionary)
		{
			if (istate != null)
			{
				return istate.SetDictionary(dictionary);
			}
			if (dstate != null)
			{
				return dstate.SetDictionary(dictionary);
			}
			throw new ZlibException("No Inflate or Deflate state!");
		}

		internal void flush_pending()
		{
			int num = dstate.pendingCount;
			if (num > AvailableBytesOut)
			{
				num = AvailableBytesOut;
			}
			if (num != 0)
			{
				if (dstate.pending.Length <= dstate.nextPending || OutputBuffer.Length <= NextOut || dstate.pending.Length < dstate.nextPending + num || OutputBuffer.Length < NextOut + num)
				{
					throw new ZlibException($"Invalid State. (pending.Length={dstate.pending.Length}, pendingCount={dstate.pendingCount})");
				}
				Array.Copy(dstate.pending, dstate.nextPending, OutputBuffer, NextOut, num);
				NextOut += num;
				dstate.nextPending += num;
				TotalBytesOut += num;
				AvailableBytesOut -= num;
				dstate.pendingCount -= num;
				if (dstate.pendingCount == 0)
				{
					dstate.nextPending = 0;
				}
			}
		}

		internal int read_buf(byte[] buf, int start, int size)
		{
			int num = AvailableBytesIn;
			if (num > size)
			{
				num = size;
			}
			if (num == 0)
			{
				return 0;
			}
			AvailableBytesIn -= num;
			if (dstate.WantRfc1950HeaderBytes)
			{
				_Adler32 = Adler.Adler32(_Adler32, InputBuffer, NextIn, num);
			}
			Array.Copy(InputBuffer, NextIn, buf, start, num);
			NextIn += num;
			TotalBytesIn += num;
			return num;
		}
	}
	public static class ZlibConstants
	{
		public const int WindowBitsMax = 15;

		public const int WindowBitsDefault = 15;

		public const int Z_OK = 0;

		public const int Z_STREAM_END = 1;

		public const int Z_NEED_DICT = 2;

		public const int Z_STREAM_ERROR = -2;

		public const int Z_DATA_ERROR = -3;

		public const int Z_BUF_ERROR = -5;

		public const int WorkingBufferSizeDefault = 16384;

		public const int WorkingBufferSizeMin = 1024;
	}
	public class ZlibStream : Stream
	{
		internal ZlibBaseStream _baseStream;

		private bool _disposed;

		public virtual FlushType FlushMode
		{
			get
			{
				return _baseStream._flushMode;
			}
			set
			{
				if (_disposed)
				{
					throw new ObjectDisposedException("ZlibStream");
				}
				_baseStream._flushMode = value;
			}
		}

		public int BufferSize
		{
			get
			{
				return _baseStream._bufferSize;
			}
			set
			{
				if (_disposed)
				{
					throw new ObjectDisposedException("ZlibStream");
				}
				if (_baseStream._workingBuffer != null)
				{
					throw new ZlibException("The working buffer is already set.");
				}
				if (value < 1024)
				{
					throw new ZlibException($"Don't be silly. {value} bytes?? Use a bigger buffer, at least {1024}.");
				}
				_baseStream._bufferSize = value;
			}
		}

		public virtual long TotalIn => _baseStream._z.TotalBytesIn;

		public virtual long TotalOut => _baseStream._z.TotalBytesOut;

		public override bool CanRead
		{
			get
			{
				if (_disposed)
				{
					throw new ObjectDisposedException("ZlibStream");
				}
				return _baseStream._stream.CanRead;
			}
		}

		public override bool CanSeek => false;

		public override bool CanWrite
		{
			get
			{
				if (_disposed)
				{
					throw new ObjectDisposedException("ZlibStream");
				}
				return _baseStream._stream.CanWrite;
			}
		}

		public override long Length
		{
			get
			{
				throw new NotSupportedException();
			}
		}

		public override long Position
		{
			get
			{
				if (_baseStream._streamMode == ZlibBaseStream.StreamMode.Writer)
				{
					return _baseStream._z.TotalBytesOut;
				}
				if (_baseStream._streamMode == ZlibBaseStream.StreamMode.Reader)
				{
					return _baseStream._z.TotalBytesIn;
				}
				return 0L;
			}
			set
			{
				throw new NotSupportedException();
			}
		}

		public ZlibStream(Stream stream, CompressionMode mode)
			: this(stream, mode, CompressionLevel.Default, leaveOpen: false)
		{
		}

		public ZlibStream(Stream stream, CompressionMode mode, CompressionLevel level)
			: this(stream, mode, level, leaveOpen: false)
		{
		}

		public ZlibStream(Stream stream, CompressionMode mode, bool leaveOpen)
			: this(stream, mode, CompressionLevel.Default, leaveOpen)
		{
		}

		public ZlibStream(Stream stream, CompressionMode mode, CompressionLevel level, bool leaveOpen)
		{
			_baseStream = new ZlibBaseStream(stream, mode, level, ZlibStreamFlavor.ZLIB, leaveOpen);
		}

		protected override void Dispose(bool disposing)
		{
			try
			{
				if (!_disposed)
				{
					if (disposing && _baseStream != null)
					{
						_baseStream.Close();
					}
					_disposed = true;
				}
			}
			finally
			{
				base.Dispose(disposing);
			}
		}

		public override void Flush()
		{
			if (_disposed)
			{
				throw new ObjectDisposedException("ZlibStream");
			}
			_baseStream.Flush();
		}

		public override int Read(byte[] buffer, int offset, int count)
		{
			if (_disposed)
			{
				throw new ObjectDisposedException("ZlibStream");
			}
			return _baseStream.Read(buffer, offset, count);
		}

		public override long Seek(long offset, SeekOrigin origin)
		{
			throw new NotSupportedException();
		}

		public override void SetLength(long value)
		{
			throw new NotSupportedException();
		}

		public override void Write(byte[] buffer, int offset, int count)
		{
			if (_disposed)
			{
				throw new ObjectDisposedException("ZlibStream");
			}
			_baseStream.Write(buffer, offset, count);
		}

		public static byte[] CompressString(string s)
		{
			using MemoryStream memoryStream = new MemoryStream();
			Stream compressor = new ZlibStream(memoryStream, CompressionMode.Compress, CompressionLevel.BestCompression);
			ZlibBaseStream.CompressString(s, compressor);
			return memoryStream.ToArray();
		}

		public static byte[] CompressBuffer(byte[] b)
		{
			using MemoryStream memoryStream = new MemoryStream();
			Stream compressor = new ZlibStream(memoryStream, CompressionMode.Compress, CompressionLevel.BestCompression);
			ZlibBaseStream.CompressBuffer(b, compressor);
			return memoryStream.ToArray();
		}

		public static string UncompressString(byte[] compressed)
		{
			using MemoryStream stream = new MemoryStream(compressed);
			Stream decompressor = new ZlibStream(stream, CompressionMode.Decompress);
			return ZlibBaseStream.UncompressString(compressed, decompressor);
		}

		public static byte[] UncompressBuffer(byte[] compressed)
		{
			using MemoryStream stream = new MemoryStream(compressed);
			Stream decompressor = new ZlibStream(stream, CompressionMode.Decompress);
			return ZlibBaseStream.UncompressBuffer(compressed, decompressor);
		}
	}
	internal sealed class ZTree
	{
		private static readonly int HEAP_SIZE = 2 * InternalConstants.L_CODES + 1;

		internal static readonly int[] ExtraLengthBits = new int[29]
		{
			0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
			1, 1, 2, 2, 2, 2, 3, 3, 3, 3,
			4, 4, 4, 4, 5, 5, 5, 5, 0
		};

		internal static readonly int[] ExtraDistanceBits = new int[30]
		{
			0, 0, 0, 0, 1, 1, 2, 2, 3, 3,
			4, 4, 5, 5, 6, 6, 7, 7, 8, 8,
			9, 9, 10, 10, 11, 11, 12, 12, 13, 13
		};

		internal static readonly int[] extra_blbits = new int[19]
		{
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 2, 3, 7
		};

		internal static readonly sbyte[] bl_order = new sbyte[19]
		{
			16, 17, 18, 0, 8, 7, 9, 6, 10, 5,
			11, 4, 12, 3, 13, 2, 14, 1, 15
		};

		internal const int Buf_size = 16;

		private static readonly sbyte[] _dist_code = new sbyte[512]
		{
			0, 1, 2, 3, 4, 4, 5, 5, 6, 6,
			6, 6, 7, 7, 7, 7, 8, 8, 8, 8,
			8, 8, 8, 8, 9, 9, 9, 9, 9, 9,
			9, 9, 10, 10, 10, 10, 10, 10, 10, 10,
			10, 10, 10, 10, 10, 10, 10, 10, 11, 11,
			11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
			11, 11, 11, 11, 12, 12, 12, 12, 12, 12,
			12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
			12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
			12, 12, 12, 12, 12, 12, 13, 13, 13, 13,
			13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
			13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
			13, 13, 13, 13, 13, 13, 13, 13, 14, 14,
			14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
			14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
			14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
			14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
			14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
			14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
			14, 14, 15, 15, 15, 15, 15, 15, 15, 15,
			15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
			15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
			15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
			15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
			15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
			15, 15, 15, 15, 15, 15, 0, 0, 16, 17,
			18, 18, 19, 19, 20, 20, 20, 20, 21, 21,
			21, 21, 22, 22, 22, 22, 22, 22, 22, 22,
			23, 23, 23, 23, 23, 23, 23, 23, 24, 24,
			24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
			24, 24, 24, 24, 25, 25, 25, 25, 25, 25,
			25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
			26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
			26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
			26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
			26, 26, 27, 27, 27, 27, 27, 27, 27, 27,
			27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
			27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
			27, 27, 27, 27, 28, 28, 28, 28, 28, 28,
			28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
			28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
			28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
			28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
			28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
			28, 28, 28, 28, 28, 28, 28, 28, 29, 29,
			29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
			29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
			29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
			29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
			29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
			29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
			29, 29
		};

		internal static readonly sbyte[] LengthCode = new sbyte[256]
		{
			0, 1, 2, 3, 4, 5, 6, 7, 8, 8,
			9, 9, 10, 10, 11, 11, 12, 12, 12, 12,
			13, 13, 13, 13, 14, 14, 14, 14, 15, 15,
			15, 15, 16, 16, 16, 16, 16, 16, 16, 16,
			17, 17, 17, 17, 17, 17, 17, 17, 18, 18,
			18, 18, 18, 18, 18, 18, 19, 19, 19, 19,
			19, 19, 19, 19, 20, 20, 20, 20, 20, 20,
			20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
			21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
			21, 21, 21, 21, 21, 21, 22, 22, 22, 22,
			22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
			22, 22, 23, 23, 23, 23, 23, 23, 23, 23,
			23, 23, 23, 23, 23, 23, 23, 23, 24, 24,
			24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
			24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
			24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
			25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
			25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
			25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
			25, 25, 26, 26, 26, 26, 26, 26, 26, 26,
			26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
			26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
			26, 26, 26, 26, 27, 27, 27, 27, 27, 27,
			27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
			27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
			27, 27, 27, 27, 27, 28
		};

		internal static readonly int[] LengthBase = new int[29]
		{
			0, 1, 2, 3, 4, 5, 6, 7, 8, 10,
			12, 14, 16, 20, 24, 28, 32, 40, 48, 56,
			64, 80, 96, 112, 128, 160, 192, 224, 0
		};

		internal static readonly int[] DistanceBase = new int[30]
		{
			0, 1, 2, 3, 4, 6, 8, 12, 16, 24,
			32, 48, 64, 96, 128, 192, 256, 384, 512, 768,
			1024, 1536, 2048, 3072, 4096, 6144, 8192, 12288, 16384, 24576
		};

		internal short[] dyn_tree;

		internal int max_code;

		internal StaticTree staticTree;

		internal static int DistanceCode(int dist)
		{
			if (dist >= 256)
			{
				return _dist_code[256 + SharedUtils.URShift(dist, 7)];
			}
			return _dist_code[dist];
		}

		internal void gen_bitlen(DeflateManager s)
		{
			short[] array = dyn_tree;
			short[] treeCodes = staticTree.treeCodes;
			int[] extraBits = staticTree.extraBits;
			int extraBase = staticTree.extraBase;
			int maxLength = staticTree.maxLength;
			int num = 0;
			for (int i = 0; i <= InternalConstants.MAX_BITS; i++)
			{
				s.bl_count[i] = 0;
			}
			array[s.heap[s.heap_max] * 2 + 1] = 0;
			int j;
			for (j = s.heap_max + 1; j < HEAP_SIZE; j++)
			{
				int num2 = s.heap[j];
				int i = array[array[num2 * 2 + 1] * 2 + 1] + 1;
				if (i > maxLength)
				{
					i = maxLength;
					num++;
				}
				array[num2 * 2 + 1] = (short)i;
				if (num2 <= max_code)
				{
					s.bl_count[i]++;
					int num3 = 0;
					if (num2 >= extraBase)
					{
						num3 = extraBits[num2 - extraBase];
					}
					short num4 = array[num2 * 2];
					s.opt_len += num4 * (i + num3);
					if (treeCodes != null)
					{
						s.static_len += num4 * (treeCodes[num2 * 2 + 1] + num3);
					}
				}
			}
			if (num == 0)
			{
				return;
			}
			do
			{
				int i = maxLength - 1;
				while (s.bl_count[i] == 0)
				{
					i--;
				}
				s.bl_count[i]--;
				s.bl_count[i + 1] = (short)(s.bl_count[i + 1] + 2);
				s.bl_count[maxLength]--;
				num -= 2;
			}
			while (num > 0);
			for (int i = maxLength; i != 0; i--)
			{
				int num2 = s.bl_count[i];
				while (num2 != 0)
				{
					int num5 = s.heap[--j];
					if (num5 <= max_code)
					{
						if (array[num5 * 2 + 1] != i)
						{
							s.opt_len = (int)(s.opt_len + ((long)i - (long)array[num5 * 2 + 1]) * array[num5 * 2]);
							array[num5 * 2 + 1] = (short)i;
						}
						num2--;
					}
				}
			}
		}

		internal void build_tree(DeflateManager s)
		{
			short[] array = dyn_tree;
			short[] treeCodes = staticTree.treeCodes;
			int elems = staticTree.elems;
			int num = -1;
			s.heap_len = 0;
			s.heap_max = HEAP_SIZE;
			for (int i = 0; i < elems; i++)
			{
				if (array[i * 2] != 0)
				{
					num = (s.heap[++s.heap_len] = i);
					s.depth[i] = 0;
				}
				else
				{
					array[i * 2 + 1] = 0;
				}
			}
			int num2;
			while (s.heap_len < 2)
			{
				num2 = (s.heap[++s.heap_len] = ((num < 2) ? (++num) : 0));
				array[num2 * 2] = 1;
				s.depth[num2] = 0;
				s.opt_len--;
				if (treeCodes != null)
				{
					s.static_len -= treeCodes[num2 * 2 + 1];
				}
			}
			max_code = num;
			for (int i = s.heap_len / 2; i >= 1; i--)
			{
				s.pqdownheap(array, i);
			}
			num2 = elems;
			do
			{
				int i = s.heap[1];
				s.heap[1] = s.heap[s.heap_len--];
				s.pqdownheap(array, 1);
				int num3 = s.heap[1];
				s.heap[--s.heap_max] = i;
				s.heap[--s.heap_max] = num3;
				array[num2 * 2] = (short)(array[i * 2] + array[num3 * 2]);
				s.depth[num2] = (sbyte)(Math.Max((byte)s.depth[i], (byte)s.depth[num3]) + 1);
				array[i * 2 + 1] = (array[num3 * 2 + 1] = (short)num2);
				s.heap[1] = num2++;
				s.pqdownheap(array, 1);
			}
			while (s.heap_len >= 2);
			s.heap[--s.heap_max] = s.heap[1];
			gen_bitlen(s);
			gen_codes(array, num, s.bl_count);
		}

		internal static void gen_codes(short[] tree, int max_code, short[] bl_count)
		{
			short[] array = new short[InternalConstants.MAX_BITS + 1];
			short num = 0;
			for (int i = 1; i <= InternalConstants.MAX_BITS; i++)
			{
				num = (array[i] = (short)(num + bl_count[i - 1] << 1));
			}
			for (int j = 0; j <= max_code; j++)
			{
				int num2 = tree[j * 2 + 1];
				if (num2 != 0)
				{
					tree[j * 2] = (short)bi_reverse(array[num2]++, num2);
				}
			}
		}

		internal static int bi_reverse(int code, int len)
		{
			int num = 0;
			do
			{
				num |= code & 1;
				code >>= 1;
				num <<= 1;
			}
			while (--len > 0);
			return num >> 1;
		}
	}
}
namespace Ionic.Crc
{
	[Guid("ebc25cf6-9120-4283-b972-0e5520d0000C")]
	[ComVisible(true)]
	[ClassInterface(ClassInterfaceType.AutoDispatch)]
	public class CRC32
	{
		private uint dwPolynomial;

		private long _TotalBytesRead;

		private bool reverseBits;

		private uint[] crc32Table;

		private const int BUFFER_SIZE = 8192;

		private uint _register = uint.MaxValue;

		public long TotalBytesRead => _TotalBytesRead;

		public int Crc32Result => (int)(~_register);

		public int GetCrc32(Stream input)
		{
			return GetCrc32AndCopy(input, null);
		}

		public int GetCrc32AndCopy(Stream input, Stream output)
		{
			if (input == null)
			{
				throw new Exception("The input stream must not be null.");
			}
			byte[] array = new byte[8192];
			int count = 8192;
			_TotalBytesRead = 0L;
			int num = input.Read(array, 0, count);
			output?.Write(array, 0, num);
			_TotalBytesRead += num;
			while (num > 0)
			{
				SlurpBlock(array, 0, num);
				num = input.Read(array, 0, count);
				output?.Write(array, 0, num);
				_TotalBytesRead += num;
			}
			return (int)(~_register);
		}

		public int ComputeCrc32(int W, byte B)
		{
			return _InternalComputeCrc32((uint)W, B);
		}

		internal int _InternalComputeCrc32(uint W, byte B)
		{
			return (int)(crc32Table[(W ^ B) & 0xFF] ^ (W >> 8));
		}

		public void SlurpBlock(byte[] block, int offset, int count)
		{
			if (block == null)
			{
				throw new Exception("The data buffer must not be null.");
			}
			for (int i = 0; i < count; i++)
			{
				int num = offset + i;
				byte b = block[num];
				if (reverseBits)
				{
					uint num2 = (_register >> 24) ^ b;
					_register = (_register << 8) ^ crc32Table[num2];
				}
				else
				{
					uint num3 = (_register & 0xFFu) ^ b;
					_register = (_register >> 8) ^ crc32Table[num3];
				}
			}
			_TotalBytesRead += count;
		}

		public void UpdateCRC(byte b)
		{
			if (reverseBits)
			{
				uint num = (_register >> 24) ^ b;
				_register = (_register << 8) ^ crc32Table[num];
			}
			else
			{
				uint num2 = (_register & 0xFFu) ^ b;
				_register = (_register >> 8) ^ crc32Table[num2];
			}
		}

		public void UpdateCRC(byte b, int n)
		{
			while (n-- > 0)
			{
				if (reverseBits)
				{
					uint num = (_register >> 24) ^ b;
					_register = (_register << 8) ^ crc32Table[(num >= 0) ? num : (num + 256)];
				}
				else
				{
					uint num2 = (_register & 0xFFu) ^ b;
					_register = (_register >> 8) ^ crc32Table[(num2 >= 0) ? num2 : (num2 + 256)];
				}
			}
		}

		private static uint ReverseBits(uint data)
		{
			uint num = data;
			num = ((num & 0x55555555) << 1) | ((num >> 1) & 0x55555555u);
			num = ((num & 0x33333333) << 2) | ((num >> 2) & 0x33333333u);
			num = ((num & 0xF0F0F0F) << 4) | ((num >> 4) & 0xF0F0F0Fu);
			return (num << 24) | ((num & 0xFF00) << 8) | ((num >> 8) & 0xFF00u) | (num >> 24);
		}

		private static byte ReverseBits(byte data)
		{
			int num = data * 131586;
			uint num2 = 17055760u;
			uint num3 = (uint)num & num2;
			uint num4 = (uint)(num << 2) & (num2 << 1);
			return (byte)(16781313 * (num3 + num4) >> 24);
		}

		private void GenerateLookupTable()
		{
			crc32Table = new uint[256];
			byte b = 0;
			do
			{
				uint num = b;
				for (byte b2 = 8; b2 > 0; b2--)
				{
					num = (((num & 1) != 1) ? (num >> 1) : ((num >> 1) ^ dwPolynomial));
				}
				if (reverseBits)
				{
					crc32Table[ReverseBits(b)] = ReverseBits(num);
				}
				else
				{
					crc32Table[b] = num;
				}
				b++;
			}
			while (b != 0);
		}

		private uint gf2_matrix_times(uint[] matrix, uint vec)
		{
			uint num = 0u;
			int num2 = 0;
			while (vec != 0)
			{
				if ((vec & 1) == 1)
				{
					num ^= matrix[num2];
				}
				vec >>= 1;
				num2++;
			}
			return num;
		}

		private void gf2_matrix_square(uint[] square, uint[] mat)
		{
			for (int i = 0; i < 32; i++)
			{
				square[i] = gf2_matrix_times(mat, mat[i]);
			}
		}

		public void Combine(int crc, int length)
		{
			uint[] array = new uint[32];
			uint[] array2 = new uint[32];
			if (length == 0)
			{
				return;
			}
			uint num = ~_register;
			array2[0] = dwPolynomial;
			uint num2 = 1u;
			for (int i = 1; i < 32; i++)
			{
				array2[i] = num2;
				num2 <<= 1;
			}
			gf2_matrix_square(array, array2);
			gf2_matrix_square(array2, array);
			uint num3 = (uint)length;
			do
			{
				gf2_matrix_square(array, array2);
				if ((num3 & 1) == 1)
				{
					num = gf2_matrix_times(array, num);
				}
				num3 >>= 1;
				if (num3 == 0)
				{
					break;
				}
				gf2_matrix_square(array2, array);
				if ((num3 & 1) == 1)
				{
					num = gf2_matrix_times(array2, num);
				}
				num3 >>= 1;
			}
			while (num3 != 0);
			num ^= (uint)crc;
			_register = ~num;
		}

		public CRC32()
			: this(reverseBits: false)
		{
		}

		public CRC32(bool reverseBits)
			: this(-306674912, reverseBits)
		{
		}

		public CRC32(int polynomial, bool reverseBits)
		{
			this.reverseBits = reverseBits;
			dwPolynomial = (uint)polynomial;
			GenerateLookupTable();
		}

		public void Reset()
		{
			_register = uint.MaxValue;
		}
	}
	public class CrcCalculatorStream : Stream, IDisposable
	{
		private static readonly long UnsetLengthLimit = -99L;

		internal Stream _innerStream;

		private CRC32 _Crc32;

		private long _lengthLimit = -99L;

		private bool _leaveOpen;

		public long TotalBytesSlurped => _Crc32.TotalBytesRead;

		public int Crc => _Crc32.Crc32Result;

		public bool LeaveOpen
		{
			get
			{
				return _leaveOpen;
			}
			set
			{
				_leaveOpen = value;
			}
		}

		public override bool CanRead => _innerStream.CanRead;

		public override bool CanSeek => false;

		public override bool CanWrite => _innerStream.CanWrite;

		public override long Length
		{
			get
			{
				if (_lengthLimit == UnsetLengthLimit)
				{
					return _innerStream.Length;
				}
				return _lengthLimit;
			}
		}

		public override long Position
		{
			get
			{
				return _Crc32.TotalBytesRead;
			}
			set
			{
				throw new NotSupportedException();
			}
		}

		public CrcCalculatorStream(Stream stream)
			: this(leaveOpen: true, UnsetLengthLimit, stream, null)
		{
		}

		public CrcCalculatorStream(Stream stream, bool leaveOpen)
			: this(leaveOpen, UnsetLengthLimit, stream, null)
		{
		}

		public CrcCalculatorStream(Stream stream, long length)
			: this(leaveOpen: true, length, stream, null)
		{
			if (length < 0)
			{
				throw new ArgumentException("length");
			}
		}

		public CrcCalculatorStream(Stream stream, long length, bool leaveOpen)
			: this(leaveOpen, length, stream, null)
		{
			if (length < 0)
			{
				throw new ArgumentException("length");
			}
		}

		public CrcCalculatorStream(Stream stream, long length, bool leaveOpen, CRC32 crc32)
			: this(leaveOpen, length, stream, crc32)
		{
			if (length < 0)
			{
				throw new ArgumentException("length");
			}
		}

		private CrcCalculatorStream(bool leaveOpen, long length, Stream stream, CRC32 crc32)
		{
			_innerStream = stream;
			_Crc32 = crc32 ?? new CRC32();
			_lengthLimit = length;
			_leaveOpen = leaveOpen;
		}

		public override int Read(byte[] buffer, int offset, int count)
		{
			int count2 = count;
			if (_lengthLimit != UnsetLengthLimit)
			{
				if (_Crc32.TotalBytesRead >= _lengthLimit)
				{
					return 0;
				}
				long num = _lengthLimit - _Crc32.TotalBytesRead;
				if (num < count)
				{
					count2 = (int)num;
				}
			}
			int num2 = _innerStream.Read(buffer, offset, count2);
			if (num2 > 0)
			{
				_Crc32.SlurpBlock(buffer, offset, num2);
			}
			return num2;
		}

		public override void Write(byte[] buffer, int offset, int count)
		{
			if (count > 0)
			{
				_Crc32.SlurpBlock(buffer, offset, count);
			}
			_innerStream.Write(buffer, offset, count);
		}

		public override void Flush()
		{
			_innerStream.Flush();
		}

		public override long Seek(long offset, SeekOrigin origin)
		{
			throw new NotSupportedException();
		}

		public override void SetLength(long value)
		{
			throw new NotSupportedException();
		}

		void IDisposable.Dispose()
		{
			Close();
		}

		public override void Close()
		{
			base.Close();
			if (!_leaveOpen)
			{
				_innerStream.Close();
			}
		}
	}
}
namespace Microsoft.Applications.Events
{
	internal static class BondHelper
	{
		public static void Serialize(CsEvent objToSerialize, MemoryStream outStream)
		{
			try
			{
				CompactBinaryProtocolWriter compactBinaryProtocolWriter = new CompactBinaryProtocolWriter();
				MiniBond.Serialize(compactBinaryProtocolWriter, objToSerialize, isBase: false);
				outStream.Write(compactBinaryProtocolWriter.Data.ToArray(), 0, compactBinaryProtocolWriter.Data.Count);
			}
			catch
			{
				UnityEngine.Debug.LogError("Failed to serialize");
			}
		}
	}
	internal enum BondDataType
	{
		BT_STOP = 0,
		BT_STOP_BASE = 1,
		BT_BOOL = 2,
		BT_UINT8 = 3,
		BT_UINT16 = 4,
		BT_UINT32 = 5,
		BT_UINT64 = 6,
		BT_FLOAT = 7,
		BT_DOUBLE = 8,
		BT_STRING = 9,
		BT_STRUCT = 10,
		BT_LIST = 11,
		BT_SET = 12,
		BT_MAP = 13,
		BT_INT8 = 14,
		BT_INT16 = 15,
		BT_INT32 = 16,
		BT_INT64 = 17,
		BT_WSTRING = 18,
		BT_UNAVAILABLE = 127
	}
	internal enum ProtocolType
	{
		MARSHALED_PROTOCOL = 0,
		FAST_PROTOCOL = 17997,
		COMPACT_PROTOCOL = 16963,
		SIMPLE_JSON_PROTOCOL = 19027,
		SIMPLE_PROTOCOL = 20563
	}
	internal class CompactBinaryProtocolWriter
	{
		private List<byte> _output;

		public List<byte> Data => _output;

		public CompactBinaryProtocolWriter()
		{
			_output = new List<byte>();
		}

		public CompactBinaryProtocolWriter(List<byte> output)
		{
			_output = output;
		}

		public void WriteStructBegin(object nullptr, bool isBase)
		{
		}

		public void writeVarint(ushort value)
		{
			while (value > 127)
			{
				_output.Add((byte)((value & 0x7Fu) | 0x80u));
				value >>= 7;
			}
			_output.Add((byte)(value & 0x7Fu));
		}

		public void writeVarint(short value)
		{
			while (value > 127)
			{
				_output.Add((byte)(((uint)value & 0x7Fu) | 0x80u));
				value >>= 7;
			}
			_output.Add((byte)((uint)value & 0x7Fu));
		}

		public void writeVarint(int value)
		{
			while (value > 127)
			{
				_output.Add((byte)(((uint)value & 0x7Fu) | 0x80u));
				value >>= 7;
			}
			_output.Add((byte)((uint)value & 0x7Fu));
		}

		public void writeVarint(uint value)
		{
			while (value > 127)
			{
				_output.Add((byte)((value & 0x7Fu) | 0x80u));
				value >>= 7;
			}
			_output.Add((byte)(value & 0x7Fu));
		}

		public void writeVarint(long value)
		{
			while (value > 127)
			{
				_output.Add((byte)((value & 0x7F) | 0x80));
				value >>= 7;
			}
			_output.Add((byte)(value & 0x7F));
		}

		public void writeVarint(ulong value)
		{
			while (value > 127)
			{
				_output.Add((byte)((value & 0x7F) | 0x80));
				value >>= 7;
			}
			_output.Add((byte)(value & 0x7F));
		}

		public void WriteBlob(List<byte> data, int size)
		{
			_output.AddRange(data);
		}

		public void WriteBlob(byte[] data, int size)
		{
			_output.AddRange(data);
		}

		public void WriteBool(bool value)
		{
			_output.Add((byte)(value ? 1u : 0u));
		}

		public void WriteUInt8(byte value)
		{
			_output.Add(value);
		}

		public void WriteUInt16(ushort value)
		{
			writeVarint(value);
		}

		public void WriteUInt32(uint value)
		{
			writeVarint(value);
		}

		public void WriteUInt64(ulong value)
		{
			writeVarint(value);
		}

		public void WriteInt8(sbyte value)
		{
			byte value2 = (byte)value;
			WriteUInt8(value2);
		}

		public void WriteInt16(short value)
		{
			ushort value2 = (ushort)((value << 1) ^ (value >> 15));
			WriteUInt16(value2);
		}

		public void WriteInt32(int value)
		{
			uint value2 = (uint)((value << 1) ^ (value >> 31));
			WriteUInt32(value2);
		}

		public void WriteInt64(long value)
		{
			ulong value2 = (ulong)((value << 1) ^ (value >> 63));
			WriteUInt64(value2);
		}

		public void WriteDouble(double value)
		{
			WriteBlob(BitConverter.GetBytes(value), 8);
		}

		public void WriteString(string value)
		{
			if (string.IsNullOrEmpty(value))
			{
				WriteUInt32(0u);
				return;
			}
			byte[] bytes = Encoding.UTF8.GetBytes(value);
			WriteUInt32((uint)bytes.Length);
			WriteBlob(bytes, bytes.Length);
		}

		public void WriteWString(string value)
		{
			if (string.IsNullOrEmpty(value))
			{
				WriteUInt32(0u);
				return;
			}
			byte[] bytes = Encoding.UTF8.GetBytes(value);
			WriteUInt32((uint)bytes.Length);
			WriteBlob(bytes, bytes.Length);
		}

		public void WriteContainerBegin(ushort size, byte elementType)
		{
			WriteUInt8(elementType);
			WriteUInt32(size);
		}

		public void WriteMapContainerBegin(ushort size, byte keyType, byte valueType)
		{
			WriteUInt8(keyType);
			WriteUInt8(valueType);
			WriteUInt32(size);
		}

		public void WriteContainerEnd()
		{
		}

		public void WriteFieldBegin(byte type, ushort id)
		{
			if (id <= 5)
			{
				_output.Add((byte)(type | ((byte)id << 5)));
			}
			else if (id <= 255)
			{
				_output.Add((byte)(type | 0xC0u));
				_output.Add((byte)(id & 0xFFu));
			}
			else
			{
				_output.Add((byte)(type | 0xE0u));
				_output.Add((byte)(id & 0xFFu));
				_output.Add((byte)(id >> 8));
			}
		}

		public void WriteFieldEnd()
		{
		}

		public void WriteStructEnd(bool isBase)
		{
			WriteUInt8((byte)(isBase ? 1u : 0u));
		}

		internal void WriteFieldOmitted(byte bT_STRING, int v)
		{
		}
	}
	internal static class MiniBond
	{
		public static void Serialize(CompactBinaryProtocolWriter writer, Ingest value, bool isBase)
		{
			writer.WriteStructBegin(null, isBase);
			if (value.time != 0L)
			{
				writer.WriteFieldBegin(17, 1);
				writer.WriteInt64(value.time);
				writer.WriteFieldEnd();
			}
			if (!string.IsNullOrEmpty(value.clientIp))
			{
				writer.WriteFieldBegin(9, 2);
				writer.WriteString(value.clientIp);
				writer.WriteFieldEnd();
			}
			if (value.auth != 0L)
			{
				writer.WriteFieldBegin(17, 3);
				writer.WriteInt64(value.auth);
				writer.WriteFieldEnd();
			}
			if (value.quality != 0L)
			{
				writer.WriteFieldBegin(17, 4);
				writer.WriteInt64(value.quality);
				writer.WriteFieldEnd();
			}
			if (value.uploadTime != 0L)
			{
				writer.WriteFieldBegin(17, 5);
				writer.WriteInt64(value.uploadTime);
				writer.WriteFieldEnd();
			}
			if (!string.IsNullOrEmpty(value.userAgent))
			{
				writer.WriteFieldBegin(9, 6);
				writer.WriteString(value.userAgent);
				writer.WriteFieldEnd();
			}
			if (!string.IsNullOrEmpty(value.client))
			{
				writer.WriteFieldBegin(9, 7);
				writer.WriteString(value.client);
				writer.WriteFieldEnd();
			}
			writer.WriteStructEnd(isBase);
		}

		public static void Serialize(CompactBinaryProtocolWriter writer, Microsoft.Applications.Events.DataModels.User value, bool isBase)
		{
			if (!string.IsNullOrEmpty(value.id))
			{
				writer.WriteFieldBegin(9, 1);
				writer.WriteString(value.id);
				writer.WriteFieldEnd();
			}
			if (!string.IsNullOrEmpty(value.localId))
			{
				writer.WriteFieldBegin(9, 2);
				writer.WriteString(value.localId);
				writer.WriteFieldEnd();
			}
			if (!string.IsNullOrEmpty(value.authId))
			{
				writer.WriteFieldBegin(9, 3);
				writer.WriteString(value.authId);
				writer.WriteFieldEnd();
			}
			if (!string.IsNullOrEmpty(value.locale))
			{
				writer.WriteFieldBegin(9, 4);
				writer.WriteString(value.locale);
				writer.WriteFieldEnd();
			}
			writer.WriteStructEnd(isBase);
		}

		public static void Serialize(CompactBinaryProtocolWriter writer, Device value, bool isBase)
		{
			if (!string.IsNullOrEmpty(value.id))
			{
				writer.WriteFieldBegin(9, 1);
				writer.WriteString(value.id);
				writer.WriteFieldEnd();
			}
			if (!string.IsNullOrEmpty(value.localId))
			{
				writer.WriteFieldBegin(9, 2);
				writer.WriteString(value.localId);
				writer.WriteFieldEnd();
			}
			if (!string.IsNullOrEmpty(value.authId))
			{
				writer.WriteFieldBegin(9, 3);
				writer.WriteString(value.authId);
				writer.WriteFieldEnd();
			}
			if (!string.IsNullOrEmpty(value.authSecId))
			{
				writer.WriteFieldBegin(9, 4);
				writer.WriteString(value.authSecId);
				writer.WriteFieldEnd();
			}
			if (!string.IsNullOrEmpty(value.deviceClass))
			{
				writer.WriteFieldBegin(9, 5);
				writer.WriteString(value.deviceClass);
				writer.WriteFieldEnd();
			}
			if (!string.IsNullOrEmpty(value.orgId))
			{
				writer.WriteFieldBegin(9, 6);
				writer.WriteString(value.orgId);
				writer.WriteFieldEnd();
			}
			if (!string.IsNullOrEmpty(value.orgAuthId))
			{
				writer.WriteFieldBegin(9, 7);
				writer.WriteString(value.orgAuthId);
				writer.WriteFieldEnd();
			}
			if (!string.IsNullOrEmpty(value.make))
			{
				writer.WriteFieldBegin(9, 8);
				writer.WriteString(value.make);
				writer.WriteFieldEnd();
			}
			if (!string.IsNullOrEmpty(value.model))
			{
				writer.WriteFieldBegin(9, 9);
				writer.WriteString(value.model);
				writer.WriteFieldEnd();
			}
			writer.WriteStructEnd(isBase);
		}

		public static void Serialize(CompactBinaryProtocolWriter writer, Os value, bool isBase)
		{
			if (!string.IsNullOrEmpty(value.locale))
			{
				writer.WriteFieldBegin(9, 1);
				writer.WriteString(value.locale);
				writer.WriteFieldEnd();
			}
			if (!string.IsNullOrEmpty(value.expId))
			{
				writer.WriteFieldBegin(9, 2);
				writer.WriteString(value.expId);
				writer.WriteFieldEnd();
			}
			if (value.bootId != 0)
			{
				writer.WriteFieldBegin(16, 3);
				writer.WriteInt32(value.bootId);
				writer.WriteFieldEnd();
			}
			if (!string.IsNullOrEmpty(value.name))
			{
				writer.WriteFieldBegin(9, 4);
				writer.WriteString(value.name);
				writer.WriteFieldEnd();
			}
			if (!string.IsNullOrEmpty(value.ver))
			{
				writer.WriteFieldBegin(9, 5);
				writer.WriteString(value.ver);
				writer.WriteFieldEnd();
			}
			writer.WriteStructEnd(isBase);
		}

		public static void Serialize(CompactBinaryProtocolWriter writer, App value, bool isBase)
		{
			if (!string.IsNullOrEmpty(value.expId))
			{
				writer.WriteFieldBegin(9, 1);
				writer.WriteString(value.expId);
				writer.WriteFieldEnd();
			}
			if (!string.IsNullOrEmpty(value.userId))
			{
				writer.WriteFieldBegin(9, 2);
				writer.WriteString(value.userId);
				writer.WriteFieldEnd();
			}
			if (!string.IsNullOrEmpty(value.env))
			{
				writer.WriteFieldBegin(9, 3);
				writer.WriteString(value.env);
				writer.WriteFieldEnd();
			}
			if (value.asId != 0)
			{
				writer.WriteFieldBegin(16, 4);
				writer.WriteInt32(value.asId);
				writer.WriteFieldEnd();
			}
			if (!string.IsNullOrEmpty(value.id))
			{
				writer.WriteFieldBegin(9, 5);
				writer.WriteString(value.id);
				writer.WriteFieldEnd();
			}
			if (!string.IsNullOrEmpty(value.ver))
			{
				writer.WriteFieldBegin(9, 6);
				writer.WriteString(value.ver);
				writer.WriteFieldEnd();
			}
			if (!string.IsNullOrEmpty(value.locale))
			{
				writer.WriteFieldBegin(9, 7);
				writer.WriteString(value.locale);
				writer.WriteFieldEnd();
			}
			if (!string.IsNullOrEmpty(value.name))
			{
				writer.WriteFieldBegin(9, 8);
				writer.WriteString(value.name);
				writer.WriteFieldEnd();
			}
			writer.WriteStructEnd(isBase);
		}

		public static void Serialize(CompactBinaryProtocolWriter writer, Utc value, bool isBase)
		{
			if (!string.IsNullOrEmpty(value.stId))
			{
				writer.WriteFieldBegin(9, 1);
				writer.WriteString(value.stId);
				writer.WriteFieldEnd();
			}
			if (!string.IsNullOrEmpty(value.aId))
			{
				writer.WriteFieldBegin(9, 2);
				writer.WriteString(value.aId);
				writer.WriteFieldEnd();
			}
			if (!string.IsNullOrEmpty(value.raId))
			{
				writer.WriteFieldBegin(9, 3);
				writer.WriteString(value.raId);
				writer.WriteFieldEnd();
			}
			if (!string.IsNullOrEmpty(value.op))
			{
				writer.WriteFieldBegin(9, 4);
				writer.WriteString(value.op);
				writer.WriteFieldEnd();
			}
			if (value.cat != 0L)
			{
				writer.WriteFieldBegin(17, 5);
				writer.WriteInt64(value.cat);
				writer.WriteFieldEnd();
			}
			if (value.flags != 0L)
			{
				writer.WriteFieldBegin(17, 6);
				writer.WriteInt64(value.flags);
				writer.WriteFieldEnd();
			}
			if (!string.IsNullOrEmpty(value.sqmId))
			{
				writer.WriteFieldBegin(9, 7);
				writer.WriteString(value.sqmId);
				writer.WriteFieldEnd();
			}
			if (!string.IsNullOrEmpty(value.mon))
			{
				writer.WriteFieldBegin(9, 9);
				writer.WriteString(value.mon);
				writer.WriteFieldEnd();
			}
			if (value.cpId != 0)
			{
				writer.WriteFieldBegin(16, 10);
				writer.WriteInt32(value.cpId);
				writer.WriteFieldEnd();
			}
			if (!string.IsNullOrEmpty(value.bSeq))
			{
				writer.WriteFieldBegin(9, 11);
				writer.WriteString(value.bSeq);
				writer.WriteFieldEnd();
			}
			if (!string.IsNullOrEmpty(value.epoch))
			{
				writer.WriteFieldBegin(9, 12);
				writer.WriteString(value.epoch);
				writer.WriteFieldEnd();
			}
			if (value.seq != 0L)
			{
				writer.WriteFieldBegin(17, 13);
				writer.WriteInt64(value.seq);
				writer.WriteFieldEnd();
			}
			writer.WriteStructEnd(isBase);
		}

		public static void Serialize(CompactBinaryProtocolWriter writer, Xbl value, bool isBase)
		{
			if (value.claims != null && value.claims.Count != 0)
			{
				writer.WriteFieldBegin(13, 5);
				writer.WriteMapContainerBegin((ushort)value.claims.Count, 9, 9);
				foreach (KeyValuePair<string, string> claim in value.claims)
				{
					writer.WriteString(claim.Key);
					writer.WriteString(claim.Value);
				}
				writer.WriteContainerEnd();
				writer.WriteFieldEnd();
			}
			if (!string.IsNullOrEmpty(value.nbf))
			{
				writer.WriteFieldBegin(9, 10);
				writer.WriteString(value.nbf);
				writer.WriteFieldEnd();
			}
			if (!string.IsNullOrEmpty(value.exp))
			{
				writer.WriteFieldBegin(9, 20);
				writer.WriteString(value.exp);
				writer.WriteFieldEnd();
			}
			if (!string.IsNullOrEmpty(value.sbx))
			{
				writer.WriteFieldBegin(9, 30);
				writer.WriteString(value.sbx);
				writer.WriteFieldEnd();
			}
			if (!string.IsNullOrEmpty(value.dty))
			{
				writer.WriteFieldBegin(9, 40);
				writer.WriteString(value.dty);
				writer.WriteFieldEnd();
			}
			if (!string.IsNullOrEmpty(value.did))
			{
				writer.WriteFieldBegin(9, 50);
				writer.WriteString(value.did);
				writer.WriteFieldEnd();
			}
			if (!string.IsNullOrEmpty(value.xid))
			{
				writer.WriteFieldBegin(9, 60);
				writer.WriteString(value.xid);
				writer.WriteFieldEnd();
			}
			if (value.uts != 0L)
			{
				writer.WriteFieldBegin(6, 70);
				writer.WriteUInt64(value.uts);
				writer.WriteFieldEnd();
			}
			if (!string.IsNullOrEmpty(value.pid))
			{
				writer.WriteFieldBegin(9, 80);
				writer.WriteString(value.pid);
				writer.WriteFieldEnd();
			}
			if (!string.IsNullOrEmpty(value.dvr))
			{
				writer.WriteFieldBegin(9, 90);
				writer.WriteString(value.dvr);
				writer.WriteFieldEnd();
			}
			if (value.tid != 0)
			{
				writer.WriteFieldBegin(5, 100);
				writer.WriteUInt32(value.tid);
				writer.WriteFieldEnd();
			}
			if (!string.IsNullOrEmpty(value.tvr))
			{
				writer.WriteFieldBegin(9, 110);
				writer.WriteString(value.tvr);
				writer.WriteFieldEnd();
			}
			if (!string.IsNullOrEmpty(value.sty))
			{
				writer.WriteFieldBegin(9, 120);
				writer.WriteString(value.sty);
				writer.WriteFieldEnd();
			}
			if (!string.IsNullOrEmpty(value.sid))
			{
				writer.WriteFieldBegin(9, 130);
				writer.WriteString(value.sid);
				writer.WriteFieldEnd();
			}
			if (value.eid != 0)
			{
				writer.WriteFieldBegin(17, 140);
				writer.WriteInt64(value.eid.Value);
				writer.WriteFieldEnd();
			}
			if (!string.IsNullOrEmpty(value.ip))
			{
				writer.WriteFieldBegin(9, 150);
				writer.WriteString(value.ip);
				writer.WriteFieldEnd();
			}
			writer.WriteStructEnd(isBase);
		}

		public static void Serialize(CompactBinaryProtocolWriter writer, Javascript value, bool isBase)
		{
			if (!string.IsNullOrEmpty(value.libVer))
			{
				writer.WriteFieldBegin(9, 10);
				writer.WriteString(value.libVer);
				writer.WriteFieldEnd();
			}
			if (!string.IsNullOrEmpty(value.osName))
			{
				writer.WriteFieldBegin(9, 15);
				writer.WriteString(value.osName);
				writer.WriteFieldEnd();
			}
			if (!string.IsNullOrEmpty(value.browser))
			{
				writer.WriteFieldBegin(9, 20);
				writer.WriteString(value.browser);
				writer.WriteFieldEnd();
			}
			if (!string.IsNullOrEmpty(value.browserVersion))
			{
				writer.WriteFieldBegin(9, 21);
				writer.WriteString(value.browserVersion);
				writer.WriteFieldEnd();
			}
			if (!string.IsNullOrEmpty(value.platform))
			{
				writer.WriteFieldBegin(9, 25);
				writer.WriteString(value.platform);
				writer.WriteFieldEnd();
			}
			if (!string.IsNullOrEmpty(value.make))
			{
				writer.WriteFieldBegin(9, 30);
				writer.WriteString(value.make);
				writer.WriteFieldEnd();
			}
			if (!string.IsNullOrEmpty(value.model))
			{
				writer.WriteFieldBegin(9, 35);
				writer.WriteString(value.model);
				writer.WriteFieldEnd();
			}
			if (!string.IsNullOrEmpty(value.screenSize))
			{
				writer.WriteFieldBegin(9, 40);
				writer.WriteString(value.screenSize);
				writer.WriteFieldEnd();
			}
			if (!string.IsNullOrEmpty(value.mc1Id))
			{
				writer.WriteFieldBegin(9, 50);
				writer.WriteString(value.mc1Id);
				writer.WriteFieldEnd();
			}
			if (value.mc1Lu != 0L)
			{
				writer.WriteFieldBegin(6, 60);
				writer.WriteUInt64(value.mc1Lu);
				writer.WriteFieldEnd();
			}
			if (value.isMc1New)
			{
				writer.WriteFieldBegin(2, 70);
				writer.WriteBool(value.isMc1New);
				writer.WriteFieldEnd();
			}
			if (!string.IsNullOrEmpty(value.ms0))
			{
				writer.WriteFieldBegin(9, 80);
				writer.WriteString(value.ms0);
				writer.WriteFieldEnd();
			}
			if (!string.IsNullOrEmpty(value.anid))
			{
				writer.WriteFieldBegin(9, 90);
				writer.WriteString(value.anid);
				writer.WriteFieldEnd();
			}
			if (!string.IsNullOrEmpty(value.a))
			{
				writer.WriteFieldBegin(9, 100);
				writer.WriteString(value.a);
				writer.WriteFieldEnd();
			}
			if (!string.IsNullOrEmpty(value.msResearch))
			{
				writer.WriteFieldBegin(9, 110);
				writer.WriteString(value.msResearch);
				writer.WriteFieldEnd();
			}
			if (!string.IsNullOrEmpty(value.csrvc))
			{
				writer.WriteFieldBegin(9, 120);
				writer.WriteString(value.csrvc);
				writer.WriteFieldEnd();
			}
			if (!string.IsNullOrEmpty(value.rtCell))
			{
				writer.WriteFieldBegin(9, 130);
				writer.WriteString(value.rtCell);
				writer.WriteFieldEnd();
			}
			if (!string.IsNullOrEmpty(value.rtEndAction))
			{
				writer.WriteFieldBegin(9, 140);
				writer.WriteString(value.rtEndAction);
				writer.WriteFieldEnd();
			}
			if (!string.IsNullOrEmpty(value.rtPermId))
			{
				writer.WriteFieldBegin(9, 150);
				writer.WriteString(value.rtPermId);
				writer.WriteFieldEnd();
			}
			if (!string.IsNullOrEmpty(value.r))
			{
				writer.WriteFieldBegin(9, 160);
				writer.WriteString(value.r);
				writer.WriteFieldEnd();
			}
			if (!string.IsNullOrEmpty(value.wtFpc))
			{
				writer.WriteFieldBegin(9, 170);
				writer.WriteString(value.wtFpc);
				writer.WriteFieldEnd();
			}
			if (!string.IsNullOrEmpty(value.omniId))
			{
				writer.WriteFieldBegin(9, 180);
				writer.WriteString(value.omniId);
				writer.WriteFieldEnd();
			}
			if (!string.IsNullOrEmpty(value.gsfxSession))
			{
				writer.WriteFieldBegin(9, 190);
				writer.WriteString(value.gsfxSession);
				writer.WriteFieldEnd();
			}
			if (!string.IsNullOrEmpty(value.domain))
			{
				writer.WriteFieldBegin(9, 200);
				writer.WriteString(value.domain);
				writer.WriteFieldEnd();
			}
			if (!string.IsNullOrEmpty(value.dnt))
			{
				writer.WriteFieldBegin(9, 999);
				writer.WriteString(value.dnt);
				writer.WriteFieldEnd();
			}
			else
			{
				writer.WriteFieldOmitted(9, 999);
			}
			writer.WriteStructEnd(isBase);
		}

		public static void Serialize(CompactBinaryProtocolWriter writer, Protocol value, bool isBase)
		{
			if (value.metadataCrc != 0)
			{
				writer.WriteFieldBegin(16, 1);
				writer.WriteInt32(value.metadataCrc);
				writer.WriteFieldEnd();
			}
			else
			{
				writer.WriteFieldOmitted(16, 1);
			}
			if (value.ticketKeys != null && value.ticketKeys.Count != 0)
			{
				writer.WriteFieldBegin(11, 2);
				writer.WriteContainerBegin((ushort)value.ticketKeys.Count, 11);
				foreach (List<string> ticketKey in value.ticketKeys)
				{
					writer.WriteContainerBegin((ushort)ticketKey.Count, 9);
					foreach (string item in ticketKey)
					{
						writer.WriteString(item);
					}
					writer.WriteContainerEnd();
				}
				writer.WriteContainerEnd();
				writer.WriteFieldEnd();
			}
			else
			{
				writer.WriteFieldOmitted(11, 2);
			}
			writer.WriteStructEnd(isBase);
		}

		public static void Serialize(CompactBinaryProtocolWriter writer, Receipts value, bool isBase)
		{
			if (value.originalTime != 0L)
			{
				writer.WriteFieldBegin(17, 1);
				writer.WriteInt64(value.originalTime);
				writer.WriteFieldEnd();
			}
			else
			{
				writer.WriteFieldOmitted(17, 1);
			}
			if (value.uploadTime != 0L)
			{
				writer.WriteFieldBegin(17, 2);
				writer.WriteInt64(value.uploadTime);
				writer.WriteFieldEnd();
			}
			else
			{
				writer.WriteFieldOmitted(17, 2);
			}
			writer.WriteStructEnd(isBase);
		}

		public static void Serialize(CompactBinaryProtocolWriter writer, Microsoft.Applications.Events.DataModels.Net value, bool isBase)
		{
			if (!string.IsNullOrEmpty(value.provider))
			{
				writer.WriteFieldBegin(9, 1);
				writer.WriteString(value.provider);
				writer.WriteFieldEnd();
			}
			else
			{
				writer.WriteFieldOmitted(9, 1);
			}
			if (!string.IsNullOrEmpty(value.cost))
			{
				writer.WriteFieldBegin(9, 2);
				writer.WriteString(value.cost);
				writer.WriteFieldEnd();
			}
			else
			{
				writer.WriteFieldOmitted(9, 2);
			}
			if (!string.IsNullOrEmpty(value.type))
			{
				writer.WriteFieldBegin(9, 3);
				writer.WriteString(value.type);
				writer.WriteFieldEnd();
			}
			else
			{
				writer.WriteFieldOmitted(9, 3);
			}
			writer.WriteStructEnd(isBase);
		}

		public static void Serialize(CompactBinaryProtocolWriter writer, Loc value, bool isBase)
		{
			if (!string.IsNullOrEmpty(value.id))
			{
				writer.WriteFieldBegin(9, 1);
				writer.WriteString(value.id);
				writer.WriteFieldEnd();
			}
			else
			{
				writer.WriteFieldOmitted(9, 1);
			}
			if (!string.IsNullOrEmpty(value.country))
			{
				writer.WriteFieldBegin(9, 2);
				writer.WriteString(value.country);
				writer.WriteFieldEnd();
			}
			else
			{
				writer.WriteFieldOmitted(9, 2);
			}
			if (!string.IsNullOrEmpty(value.timezone))
			{
				writer.WriteFieldBegin(9, 3);
				writer.WriteString(value.timezone);
				writer.WriteFieldEnd();
			}
			else
			{
				writer.WriteFieldOmitted(9, 3);
			}
			writer.WriteStructEnd(isBase);
		}

		public static void Serialize(CompactBinaryProtocolWriter writer, Sdk value, bool isBase)
		{
			if (!string.IsNullOrEmpty(value.libVer))
			{
				writer.WriteFieldBegin(9, 1);
				writer.WriteString(value.libVer);
				writer.WriteFieldEnd();
			}
			else
			{
				writer.WriteFieldOmitted(9, 1);
			}
			if (!string.IsNullOrEmpty(value.epoch))
			{
				writer.WriteFieldBegin(9, 2);
				writer.WriteString(value.epoch);
				writer.WriteFieldEnd();
			}
			else
			{
				writer.WriteFieldOmitted(9, 2);
			}
			if (value.seq != 0L)
			{
				writer.WriteFieldBegin(17, 3);
				writer.WriteInt64(value.seq);
				writer.WriteFieldEnd();
			}
			else
			{
				writer.WriteFieldOmitted(9, 3);
			}
			if (!string.IsNullOrEmpty(value.installId))
			{
				writer.WriteFieldBegin(9, 4);
				writer.WriteString(value.installId);
				writer.WriteFieldEnd();
			}
			else
			{
				writer.WriteFieldOmitted(9, 4);
			}
			writer.WriteStructEnd(isBase);
		}

		public static void Serialize(CompactBinaryProtocolWriter writer, PII value, bool isBase)
		{
			if (value.Kind != 0)
			{
				writer.WriteFieldBegin(16, 1);
				writer.WriteInt32((int)value.Kind);
				writer.WriteFieldEnd();
			}
			else
			{
				writer.WriteFieldOmitted(16, 1);
			}
			writer.WriteStructEnd(isBase);
		}

		public static void Serialize(CompactBinaryProtocolWriter writer, CustomerContent value, bool isBase)
		{
			if (value.Kind != 0)
			{
				writer.WriteFieldBegin(16, 1);
				writer.WriteInt32((int)value.Kind);
				writer.WriteFieldEnd();
			}
			else
			{
				writer.WriteFieldOmitted(16, 1);
			}
			writer.WriteStructEnd(isBase);
		}

		public static void Serialize(CompactBinaryProtocolWriter writer, Attributes value, bool isBase)
		{
			if (value.pii != null)
			{
				writer.WriteFieldBegin(11, 1);
				writer.WriteContainerBegin((ushort)value.pii.Count, 10);
				foreach (PII item in value.pii)
				{
					Serialize(writer, item, isBase: false);
				}
				writer.WriteContainerEnd();
				writer.WriteFieldEnd();
			}
			else
			{
				writer.WriteFieldOmitted(11, 1);
			}
			if (value.customerContent != null)
			{
				writer.WriteFieldBegin(11, 2);
				writer.WriteContainerBegin((ushort)value.customerContent.Count, 10);
				foreach (CustomerContent item2 in value.customerContent)
				{
					Serialize(writer, item2, isBase: false);
				}
				writer.WriteContainerEnd();
				writer.WriteFieldEnd();
			}
			else
			{
				writer.WriteFieldOmitted(11, 2);
			}
			writer.WriteStructEnd(isBase);
		}

		public static void Serialize(CompactBinaryProtocolWriter writer, Value value, bool isBase)
		{
			if (value.type != ValueKind.ValueString)
			{
				writer.WriteFieldBegin(16, 1);
				writer.WriteInt32((int)value.type);
				writer.WriteFieldEnd();
			}
			else
			{
				writer.WriteFieldOmitted(16, 1);
			}
			if (value.attributes != null)
			{
				writer.WriteFieldBegin(11, 2);
				writer.WriteContainerBegin((ushort)value.attributes.Count, 10);
				foreach (Attributes attribute in value.attributes)
				{
					Serialize(writer, attribute, isBase: false);
				}
				writer.WriteContainerEnd();
				writer.WriteFieldEnd();
			}
			else
			{
				writer.WriteFieldOmitted(11, 2);
			}
			if (!string.IsNullOrEmpty(value.stringValue))
			{
				writer.WriteFieldBegin(9, 3);
				writer.WriteString(value.stringValue);
				writer.WriteFieldEnd();
			}
			else
			{
				writer.WriteFieldOmitted(9, 3);
			}
			if (value.longValue != 0L)
			{
				writer.WriteFieldBegin(17, 4);
				writer.WriteInt64(value.longValue);
				writer.WriteFieldEnd();
			}
			else
			{
				writer.WriteFieldOmitted(17, 4);
			}
			if (value.doubleValue != 0.0)
			{
				writer.WriteFieldBegin(8, 5);
				writer.WriteDouble(value.doubleValue);
				writer.WriteFieldEnd();
			}
			else
			{
				writer.WriteFieldOmitted(8, 5);
			}
			if (value.guidValue != null && value.guidValue.Count != 0)
			{
				writer.WriteFieldBegin(11, 6);
				writer.WriteContainerBegin((ushort)value.guidValue.Count, 11);
				foreach (List<byte> item in value.guidValue)
				{
					writer.WriteContainerBegin((ushort)item.Count, 3);
					foreach (byte item2 in item)
					{
						writer.WriteUInt8(item2);
					}
					writer.WriteContainerEnd();
				}
				writer.WriteContainerEnd();
				writer.WriteFieldEnd();
			}
			else
			{
				writer.WriteFieldOmitted(11, 6);
			}
			if (value.stringArray != null && value.stringArray.Count != 0)
			{
				writer.WriteFieldBegin(11, 10);
				writer.WriteContainerBegin((ushort)value.stringArray.Count, 11);
				foreach (List<string> item3 in value.stringArray)
				{
					writer.WriteContainerBegin((ushort)item3.Count, 9);
					foreach (string item4 in item3)
					{
						writer.WriteString(item4);
					}
					writer.WriteContainerEnd();
				}
				writer.WriteContainerEnd();
				writer.WriteFieldEnd();
			}
			else
			{
				writer.WriteFieldOmitted(11, 10);
			}
			if (value.longArray != null && value.longArray.Count != 0)
			{
				writer.WriteFieldBegin(11, 11);
				writer.WriteContainerBegin((ushort)value.longArray.Count, 11);
				foreach (List<long> item5 in value.longArray)
				{
					writer.WriteContainerBegin((ushort)item5.Count, 17);
					foreach (long item6 in item5)
					{
						writer.WriteInt64(item6);
					}
					writer.WriteContainerEnd();
				}
				writer.WriteContainerEnd();
				writer.WriteFieldEnd();
			}
			else
			{
				writer.WriteFieldOmitted(11, 11);
			}
			if (value.doubleArray != null && value.doubleArray.Count != 0)
			{
				writer.WriteFieldBegin(11, 12);
				writer.WriteContainerBegin((ushort)value.doubleArray.Count, 11);
				foreach (List<double> item7 in value.doubleArray)
				{
					writer.WriteContainerBegin((ushort)item7.Count, 8);
					foreach (double item8 in item7)
					{
						writer.WriteDouble(item8);
					}
					writer.WriteContainerEnd();
				}
				writer.WriteContainerEnd();
				writer.WriteFieldEnd();
			}
			else
			{
				writer.WriteFieldOmitted(11, 12);
			}
			if (value.guidArray != null && value.guidArray.Count != 0)
			{
				writer.WriteFieldBegin(11, 13);
				writer.WriteContainerBegin((ushort)value.guidArray.Count, 11);
				foreach (List<List<long>> item9 in value.guidArray)
				{
					writer.WriteContainerBegin((ushort)item9.Count, 11);
					foreach (List<long> item10 in item9)
					{
						writer.WriteContainerBegin((ushort)item10.Count, 17);
						foreach (long item11 in item10)
						{
							writer.WriteInt64(item11);
						}
						writer.WriteContainerEnd();
					}
					writer.WriteContainerEnd();
				}
				writer.WriteContainerEnd();
				writer.WriteFieldEnd();
			}
			else
			{
				writer.WriteFieldOmitted(11, 13);
			}
			writer.WriteStructEnd(isBase);
		}

		public static void Serialize(CompactBinaryProtocolWriter writer, Data value, bool isBase)
		{
			if (value.properties != null && value.properties.Count != 0)
			{
				writer.WriteFieldBegin(13, 1);
				writer.WriteMapContainerBegin((ushort)value.properties.Count, 9, 10);
				foreach (KeyValuePair<string, Value> property in value.properties)
				{
					writer.WriteString(property.Key);
					Serialize(writer, property.Value, isBase: false);
				}
				writer.WriteContainerEnd();
				writer.WriteFieldEnd();
			}
			else
			{
				writer.WriteFieldOmitted(13, 1);
			}
			writer.WriteStructEnd(isBase);
		}

		public static void Serialize(CompactBinaryProtocolWriter writer, CsEvent value, bool isBase)
		{
			if (!string.IsNullOrEmpty(value.ver))
			{
				writer.WriteFieldBegin(9, 1);
				writer.WriteString(value.ver);
				writer.WriteFieldEnd();
			}
			else
			{
				writer.WriteFieldOmitted(9, 1);
			}
			if (!string.IsNullOrEmpty(value.name))
			{
				writer.WriteFieldBegin(9, 2);
				writer.WriteString(value.name);
				writer.WriteFieldEnd();
			}
			else
			{
				writer.WriteFieldOmitted(9, 2);
			}
			if (value.time != 0L)
			{
				writer.WriteFieldBegin(17, 3);
				writer.WriteInt64(value.time);
				writer.WriteFieldEnd();
			}
			else
			{
				writer.WriteFieldOmitted(17, 3);
			}
			if (value.popSample != 100.0)
			{
				writer.WriteFieldBegin(8, 4);
				writer.WriteDouble(value.popSample);
				writer.WriteFieldEnd();
			}
			else
			{
				writer.WriteFieldOmitted(8, 4);
			}
			if (!string.IsNullOrEmpty(value.iKey))
			{
				writer.WriteFieldBegin(9, 5);
				writer.WriteString(value.iKey);
				writer.WriteFieldEnd();
			}
			else
			{
				writer.WriteFieldOmitted(9, 5);
			}
			if (value.flags != 0L)
			{
				writer.WriteFieldBegin(17, 6);
				writer.WriteInt64(value.flags);
				writer.WriteFieldEnd();
			}
			else
			{
				writer.WriteFieldOmitted(17, 6);
			}
			if (!string.IsNullOrEmpty(value.cV))
			{
				writer.WriteFieldBegin(9, 7);
				writer.WriteString(value.cV);
				writer.WriteFieldEnd();
			}
			else
			{
				writer.WriteFieldOmitted(9, 7);
			}
			if (value.extIngest != null && value.extIngest.Count != 0)
			{
				writer.WriteFieldBegin(11, 20);
				writer.WriteContainerBegin((ushort)value.extIngest.Count, 10);
				foreach (Ingest item in value.extIngest)
				{
					Serialize(writer, item, isBase: false);
				}
				writer.WriteContainerEnd();
				writer.WriteFieldEnd();
			}
			else
			{
				writer.WriteFieldOmitted(11, 20);
			}
			if (value.extProtocol != null)
			{
				writer.WriteFieldBegin(11, 21);
				writer.WriteContainerBegin((ushort)value.extProtocol.Count, 10);
				foreach (Protocol item2 in value.extProtocol)
				{
					Serialize(writer, item2, isBase: false);
				}
				writer.WriteContainerEnd();
				writer.WriteFieldEnd();
			}
			else
			{
				writer.WriteFieldOmitted(11, 21);
			}
			if (value.extUser != null && value.extUser.Count != 0)
			{
				writer.WriteFieldBegin(11, 22);
				writer.WriteContainerBegin((ushort)value.extUser.Count, 10);
				foreach (Microsoft.Applications.Events.DataModels.User item3 in value.extUser)
				{
					Serialize(writer, item3, isBase: false);
				}
				writer.WriteContainerEnd();
				writer.WriteFieldEnd();
			}
			else
			{
				writer.WriteFieldOmitted(11, 22);
			}
			if (value.extDevice != null && value.extDevice.Count != 0)
			{
				writer.WriteFieldBegin(11, 23);
				writer.WriteContainerBegin((ushort)value.extDevice.Count, 10);
				foreach (Device item4 in value.extDevice)
				{
					Serialize(writer, item4, isBase: false);
				}
				writer.WriteContainerEnd();
				writer.WriteFieldEnd();
			}
			else
			{
				writer.WriteFieldOmitted(11, 23);
			}
			if (value.extOs != null && value.extOs.Count != 0)
			{
				writer.WriteFieldBegin(11, 24);
				writer.WriteContainerBegin((ushort)value.extOs.Count, 10);
				foreach (Os extO in value.extOs)
				{
					Serialize(writer, extO, isBase: false);
				}
				writer.WriteContainerEnd();
				writer.WriteFieldEnd();
			}
			else
			{
				writer.WriteFieldOmitted(11, 24);
			}
			if (value.extApp != null && value.extApp.Count != 0)
			{
				writer.WriteFieldBegin(11, 25);
				writer.WriteContainerBegin((ushort)value.extApp.Count, 10);
				foreach (App item5 in value.extApp)
				{
					Serialize(writer, item5, isBase: false);
				}
				writer.WriteContainerEnd();
				writer.WriteFieldEnd();
			}
			else
			{
				writer.WriteFieldOmitted(11, 25);
			}
			if (value.extUtc != null && value.extUtc.Count != 0)
			{
				writer.WriteFieldBegin(11, 26);
				writer.WriteContainerBegin((ushort)value.extUtc.Count, 10);
				foreach (Utc item6 in value.extUtc)
				{
					Serialize(writer, item6, isBase: false);
				}
				writer.WriteContainerEnd();
				writer.WriteFieldEnd();
			}
			else
			{
				writer.WriteFieldOmitted(11, 26);
			}
			if (value.extXbl != null && value.extXbl.Count != 0)
			{
				writer.WriteFieldBegin(11, 27);
				writer.WriteContainerBegin((ushort)value.extXbl.Count, 10);
				foreach (Xbl item7 in value.extXbl)
				{
					Serialize(writer, item7, isBase: false);
				}
				writer.WriteContainerEnd();
				writer.WriteFieldEnd();
			}
			else
			{
				writer.WriteFieldOmitted(11, 27);
			}
			if (value.extJavascript != null && value.extJavascript.Count != 0)
			{
				writer.WriteFieldBegin(11, 28);
				writer.WriteContainerBegin((ushort)value.extJavascript.Count, 10);
				foreach (Javascript item8 in value.extJavascript)
				{
					Serialize(writer, item8, isBase: false);
				}
				writer.WriteContainerEnd();
				writer.WriteFieldEnd();
			}
			else
			{
				writer.WriteFieldOmitted(11, 28);
			}
			if (value.extReceipts != null && value.extReceipts.Count != 0)
			{
				writer.WriteFieldBegin(11, 29);
				writer.WriteContainerBegin((ushort)value.extReceipts.Count, 10);
				foreach (Receipts extReceipt in value.extReceipts)
				{
					Serialize(writer, extReceipt, isBase: false);
				}
				writer.WriteContainerEnd();
				writer.WriteFieldEnd();
			}
			else
			{
				writer.WriteFieldOmitted(11, 29);
			}
			if (value.extNet != null && value.extNet.Count != 0)
			{
				writer.WriteFieldBegin(11, 31);
				writer.WriteContainerBegin((ushort)value.extNet.Count, 10);
				foreach (Microsoft.Applications.Events.DataModels.Net item9 in value.extNet)
				{
					Serialize(writer, item9, isBase: false);
				}
				writer.WriteContainerEnd();
				writer.WriteFieldEnd();
			}
			else
			{
				writer.WriteFieldOmitted(11, 31);
			}
			if (value.extSdk != null && value.extSdk.Count != 0)
			{
				writer.WriteFieldBegin(11, 32);
				writer.WriteContainerBegin((ushort)value.extSdk.Count, 10);
				foreach (Sdk item10 in value.extSdk)
				{
					Serialize(writer, item10, isBase: false);
				}
				writer.WriteContainerEnd();
				writer.WriteFieldEnd();
			}
			else
			{
				writer.WriteFieldOmitted(11, 32);
			}
			if (value.extLoc != null && value.extLoc.Count != 0)
			{
				writer.WriteFieldBegin(11, 33);
				writer.WriteContainerBegin((ushort)value.extLoc.Count, 10);
				foreach (Loc item11 in value.extLoc)
				{
					Serialize(writer, item11, isBase: false);
				}
				writer.WriteContainerEnd();
				writer.WriteFieldEnd();
			}
			else
			{
				writer.WriteFieldOmitted(11, 33);
			}
			if (value.ext != null && value.ext.Count != 0)
			{
				writer.WriteFieldBegin(11, 41);
				writer.WriteContainerBegin((ushort)value.ext.Count, 10);
				foreach (Data item12 in value.ext)
				{
					Serialize(writer, item12, isBase: false);
				}
				writer.WriteContainerEnd();
				writer.WriteFieldEnd();
			}
			else
			{
				writer.WriteFieldOmitted(11, 41);
			}
			if (value.tags != null && value.tags.Count != 0)
			{
				writer.WriteFieldBegin(13, 51);
				writer.WriteMapContainerBegin((ushort)value.tags.Count, 9, 9);
				foreach (KeyValuePair<string, string> tag in value.tags)
				{
					writer.WriteString(tag.Key);
					writer.WriteString(tag.Value);
				}
				writer.WriteContainerEnd();
				writer.WriteFieldEnd();
			}
			else
			{
				writer.WriteFieldOmitted(13, 51);
			}
			if (!string.IsNullOrEmpty(value.baseType))
			{
				writer.WriteFieldBegin(9, 60);
				writer.WriteString(value.baseType);
				writer.WriteFieldEnd();
			}
			else
			{
				writer.WriteFieldOmitted(9, 60);
			}
			if (value.baseData != null && value.baseData.Count != 0)
			{
				writer.WriteFieldBegin(11, 61);
				writer.WriteContainerBegin((ushort)value.baseData.Count, 10);
				foreach (Data baseDatum in value.baseData)
				{
					Serialize(writer, baseDatum, isBase: false);
				}
				writer.WriteContainerEnd();
				writer.WriteFieldEnd();
			}
			else
			{
				writer.WriteFieldOmitted(11, 61);
			}
			if (value.data != null && value.data.Count != 0)
			{
				writer.WriteFieldBegin(11, 70);
				writer.WriteContainerBegin((ushort)value.data.Count, 10);
				foreach (Data datum in value.data)
				{
					Serialize(writer, datum, isBase: false);
				}
				writer.WriteContainerEnd();
				writer.WriteFieldEnd();
			}
			else
			{
				writer.WriteFieldOmitted(11, 70);
			}
			writer.WriteStructEnd(isBase);
		}
	}
	internal class Utils
	{
		private static readonly long TICKS_AT_1970 = new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc).Ticks;

		public static long MsFrom1970()
		{
			return (DateTime.UtcNow.Ticks - TICKS_AT_1970) / 10000;
		}

		public static long TimestampNowTicks()
		{
			return DateTime.UtcNow.Ticks;
		}

		public static string TenantID(string tenant)
		{
			try
			{
				int num = tenant.IndexOf("-", StringComparison.Ordinal);
				if (num > 0)
				{
					return tenant.Substring(0, num);
				}
			}
			catch
			{
				UnityEngine.Debug.LogError("Failed to convert tenantId");
			}
			return string.Empty;
		}
	}
}
namespace Microsoft.Applications.Events.DataModels
{
	[GeneratedCode("gbc", "0.10.0.0")]
	internal class Ingest
	{
		public long time { get; set; }

		public string clientIp { get; set; }

		public long auth { get; set; }

		public long quality { get; set; }

		public long uploadTime { get; set; }

		public string userAgent { get; set; }

		public string client { get; set; }

		public Ingest()
			: this("Microsoft.Applications.Events.DataModels.Bond.Ingest", "Ingest")
		{
		}

		protected Ingest(string fullName, string name)
		{
			clientIp = "";
		}
	}
	[GeneratedCode("gbc", "0.10.0.0")]
	internal class User
	{
		public string id { get; set; }

		public string localId { get; set; }

		public string authId { get; set; }

		public string locale { get; set; }

		public User()
			: this("Microsoft.Applications.Events.DataModels.Bond.User", "User")
		{
		}

		protected User(string fullName, string name)
		{
		}
	}
	[GeneratedCode("gbc", "0.10.0.0")]
	internal class Device
	{
		public string id { get; set; }

		public string localId { get; set; }

		public string authId { get; set; }

		public string authSecId { get; set; }

		public string deviceClass { get; set; }

		public string orgId { get; set; }

		public string make { get; set; }

		public string orgAuthId { get; set; }

		public string model { get; set; }

		public Device()
			: this("Microsoft.Applications.Events.DataModels.Bond.Device", "Device")
		{
		}

		protected Device(string fullName, string name)
		{
		}
	}
	[GeneratedCode("gbc", "0.10.0.0")]
	internal class Os
	{
		public string locale { get; set; }

		public string expId { get; set; }

		public int bootId { get; set; }

		public string name { get; set; }

		public string ver { get; set; }

		public Os()
			: this("Microsoft.Applications.Events.DataModels.Bond.Os", "Os")
		{
		}

		protected Os(string fullName, string name)
		{
		}
	}
	[GeneratedCode("gbc", "0.10.0.0")]
	internal class App
	{
		public string expId { get; set; }

		public string userId { get; set; }

		public string env { get; set; }

		public int asId { get; set; }

		public string id { get; set; }

		public string ver { get; set; }

		public string locale { get; set; }

		public string name { get; set; }

		public App()
			: this("Microsoft.Applications.Events.DataModels.Bond.App", "App")
		{
		}

		protected App(string fullName, string name)
		{
		}
	}
	[GeneratedCode("gbc", "0.10.0.0")]
	internal class Utc
	{
		public string stId { get; set; }

		public string aId { get; set; }

		public string raId { get; set; }

		public string op { get; set; }

		public long cat { get; set; }

		public long flags { get; set; }

		public string sqmId { get; set; }

		public string mon { get; set; }

		public int cpId { get; set; }

		public string bSeq { get; set; }

		public string epoch { get; set; }

		public long seq { get; set; }

		public Utc()
			: this("Microsoft.Applications.Events.DataModels.Bond.Utc", "Utc")
		{
		}

		protected Utc(string fullName, string name)
		{
		}
	}
	[GeneratedCode("gbc", "0.10.0.0")]
	internal class Xbl
	{
		public Dictionary<string, string> claims { get; set; }

		public string nbf { get; set; }

		public string exp { get; set; }

		public string sbx { get; set; }

		public string dty { get; set; }

		public string did { get; set; }

		public string xid { get; set; }

		public ulong uts { get; set; }

		public string pid { get; set; }

		public string dvr { get; set; }

		public uint tid { get; set; }

		public string tvr { get; set; }

		public string sty { get; set; }

		public string sid { get; set; }

		public long? eid { get; set; }

		public string ip { get; set; }

		public Xbl()
			: this("Microsoft.Applications.Events.DataModels.Bond.Xbl", "Xbl")
		{
		}

		protected Xbl(string fullName, string name)
		{
		}
	}
	[GeneratedCode("gbc", "0.10.0.0")]
	internal class Javascript
	{
		public string libVer { get; set; }

		public string osName { get; set; }

		public string browser { get; set; }

		public string browserVersion { get; set; }

		public string platform { get; set; }

		public string make { get; set; }

		public string model { get; set; }

		public string screenSize { get; set; }

		public string mc1Id { get; set; }

		public ulong mc1Lu { get; set; }

		public bool isMc1New { get; set; }

		public string ms0 { get; set; }

		public string anid { get; set; }

		public string a { get; set; }

		public string msResearch { get; set; }

		public string csrvc { get; set; }

		public string rtCell { get; set; }

		public string rtEndAction { get; set; }

		public string rtPermId { get; set; }

		public string r { get; set; }

		public string wtFpc { get; set; }

		public string omniId { get; set; }

		public string gsfxSession { get; set; }

		public string domain { get; set; }

		public string dnt { get; set; }

		public Javascript()
			: this("Microsoft.Applications.Events.DataModels.Bond.Javascript", "Javascript")
		{
		}

		protected Javascript(string fullName, string name)
		{
			libVer = "";
			osName = "";
			browser = "";
			browserVersion = "";
			platform = "";
			make = "";
			model = "";
			screenSize = "";
			mc1Id = "";
			ms0 = "";
			anid = "";
			a = "";
			msResearch = "";
			csrvc = "";
			rtCell = "";
			rtEndAction = "";
			rtPermId = "";
			r = "";
			wtFpc = "";
			omniId = "";
			gsfxSession = "";
			domain = "";
			dnt = "";
		}
	}
	[GeneratedCode("gbc", "0.10.0.0")]
	internal class Protocol
	{
		public int metadataCrc { get; set; }

		public List<List<string>> ticketKeys { get; set; }

		public Protocol()
			: this("Microsoft.Applications.Events.DataModels.Bond.Protocol", "Protocol")
		{
		}

		protected Protocol(string fullName, string name)
		{
		}
	}
	[GeneratedCode("gbc", "0.10.0.0")]
	internal class Receipts
	{
		public long originalTime { get; set; }

		public long uploadTime { get; set; }

		public Receipts()
			: this("Microsoft.Applications.Events.DataModels.Bond.Receipts", "Receipts")
		{
		}

		protected Receipts(string fullName, string name)
		{
		}
	}
	[GeneratedCode("gbc", "0.10.0.0")]
	internal enum ValueKind
	{
		ValueInt64,
		ValueUInt64,
		ValueInt32,
		ValueUInt32,
		ValueDouble,
		ValueString,
		ValueBool,
		ValueDateTime,
		ValueGuid,
		ValueArrayInt64,
		ValueArrayUInt64,
		ValueArrayInt32,
		ValueArrayUInt32,
		ValueArrayDouble,
		ValueArrayString,
		ValueArrayBool,
		ValueArrayDateTime,
		ValueArrayGuid
	}
	[GeneratedCode("gbc", "0.10.0.0")]
	internal enum PIIKind
	{
		NotSet,
		DistinguishedName,
		GenericData,
		IPV4Address,
		IPv6Address,
		MailSubject,
		PhoneNumber,
		QueryString,
		SipAddress,
		SmtpAddress,
		Identity,
		Uri,
		Fqdn,
		IPV4AddressLegacy
	}
	[GeneratedCode("gbc", "0.10.0.0")]
	internal class PII
	{
		public PIIKind Kind { get; set; }

		public PII()
			: this("Microsoft.Applications.Events.DataModels.Bond.PII", "PII")
		{
		}

		protected PII(string fullName, string name)
		{
			Kind = PIIKind.NotSet;
		}

		public static implicit operator List<object>(PII v)
		{
			throw new NotImplementedException();
		}
	}
	[GeneratedCode("gbc", "0.10.0.0")]
	internal enum CustomerContentKind
	{
		NotSet,
		GenericContent
	}
	[GeneratedCode("gbc", "0.10.0.0")]
	internal class CustomerContent
	{
		public CustomerContentKind Kind { get; set; }

		public CustomerContent()
			: this("Microsoft.Applications.Events.DataModels.Bond.CustomerContent", "CustomerContent")
		{
		}

		protected CustomerContent(string fullName, string name)
		{
			Kind = CustomerContentKind.NotSet;
		}
	}
	[GeneratedCode("gbc", "0.10.0.0")]
	internal class Attributes
	{
		public List<PII> pii { get; set; }

		public List<CustomerContent> customerContent { get; set; }

		public Attributes()
			: this("Microsoft.Applications.Events.DataModels.Bond.Attributes", "Attributes")
		{
		}

		protected Attributes(string fullName, string name)
		{
		}

		internal void Release()
		{
			customerContent = null;
		}
	}
	[GeneratedCode("gbc", "0.10.0.0")]
	internal class Value
	{
		public ValueKind type { get; set; }

		public List<Attributes> attributes { get; set; }

		public string stringValue { get; set; }

		public long longValue { get; set; }

		public double doubleValue { get; set; }

		public List<List<byte>> guidValue { get; set; }

		public List<List<string>> stringArray { get; set; }

		public List<List<long>> longArray { get; set; }

		public List<List<double>> doubleArray { get; set; }

		public List<List<List<long>>> guidArray { get; set; }

		public Value()
			: this("Microsoft.Applications.Events.DataModels.Bond.Value", "Value")
		{
		}

		protected Value(string fullName, string name)
		{
			type = ValueKind.ValueString;
		}

		internal void Release()
		{
			if (attributes != null)
			{
				foreach (Attributes attribute in attributes)
				{
					attribute.Release();
				}
			}
			attributes = null;
			guidValue = null;
			stringArray = null;
			longArray = null;
			doubleArray = null;
			guidArray = null;
		}
	}
	[GeneratedCode("gbc", "0.10.0.0")]
	internal class Data
	{
		public Dictionary<string, Value> properties { get; set; }

		public Data()
			: this("Microsoft.Applications.Events.DataModels.Data", "Data")
		{
		}

		protected Data(string fullName, string name)
		{
			properties = new Dictionary<string, Value>();
		}

		internal void Release()
		{
			if (properties != null)
			{
				foreach (KeyValuePair<string, Value> property in properties)
				{
					property.Value.Release();
				}
			}
			if (properties != null)
			{
				properties.Clear();
			}
			properties = null;
		}
	}
	[GeneratedCode("gbc", "0.10.0.0")]
	internal class Loc
	{
		public string id { get; set; }

		public string country { get; set; }

		public string timezone { get; set; }
	}
	[GeneratedCode("gbc", "0.10.0.0")]
	internal class Net
	{
		public string provider { get; set; }

		public string cost { get; set; }

		public string type { get; set; }
	}
	[GeneratedCode("gbc", "0.10.0.0")]
	internal class Sdk
	{
		public string libVer { get; set; }

		public string epoch { get; set; }

		public long seq { get; set; }

		public string installId { get; set; }
	}
	[GeneratedCode("gbc", "0.10.0.0")]
	internal class Cloud
	{
		public string fullEnvName { get; set; }

		public string location { get; set; }

		public string environment { get; set; }

		public string deploymentUnit { get; set; }

		public string name { get; set; }

		public string roleInstance { get; set; }

		public string role { get; set; }
	}
	[GeneratedCode("gbc", "0.10.0.0")]
	internal class CsEvent
	{
		public string ver { get; set; }

		public string name { get; set; }

		public long time { get; set; }

		public double popSample { get; set; }

		public string iKey { get; set; }

		public long flags { get; set; }

		public string cV { get; set; }

		public List<Ingest> extIngest { get; set; }

		public List<Protocol> extProtocol { get; set; }

		public List<User> extUser { get; set; }

		public List<Device> extDevice { get; set; }

		public List<Os> extOs { get; set; }

		public List<App> extApp { get; set; }

		public List<Utc> extUtc { get; set; }

		public List<Xbl> extXbl { get; set; }

		public List<Javascript> extJavascript { get; set; }

		public List<Receipts> extReceipts { get; set; }

		public List<Net> extNet { get; set; }

		public List<Sdk> extSdk { get; set; }

		public List<Loc> extLoc { get; set; }

		public List<Cloud> extCloud { get; set; }

		public List<Data> ext { get; set; }

		public Dictionary<string, string> tags { get; set; }

		public string baseType { get; set; }

		public List<Data> baseData { get; set; }

		public List<Data> data { get; set; }

		public CsEvent()
			: this("Microsoft.Applications.Events.DataModels.CsEvent", "CsEvent")
		{
		}

		protected CsEvent(string fullName, string name)
		{
			ver = "";
			this.name = "";
			popSample = 100.0;
			tags = new Dictionary<string, string>();
		}

		internal void Reset()
		{
			if (ext != null)
			{
				foreach (Data item in ext)
				{
					item.Release();
				}
			}
			if (data != null)
			{
				foreach (Data datum in data)
				{
					datum.Release();
				}
			}
			if (baseData != null)
			{
				foreach (Data baseDatum in baseData)
				{
					baseDatum.Release();
				}
			}
			ver = string.Empty;
			name = string.Empty;
			time = 0L;
			popSample = 0.0;
			iKey = string.Empty;
			flags = 0L;
			cV = string.Empty;
			SafeClear(ext);
			SafeClear(extIngest);
			SafeClear(extProtocol);
			SafeClear(extUser);
			SafeClear(extDevice);
			SafeClear(extOs);
			SafeClear(extApp);
			SafeClear(extUtc);
			SafeClear(extNet);
			SafeClear(extDevice);
			SafeClear(extCloud);
			SafeClear(extLoc);
			SafeClear(extXbl);
			SafeClear(extSdk);
			SafeClear(extJavascript);
			SafeClear(extReceipts);
			SafeClear(ext);
			if (tags != null)
			{
				tags.Clear();
			}
			if (baseType != null)
			{
				baseType = string.Empty;
			}
			SafeClear(baseData);
			SafeClear(data);
			ext = null;
			extIngest = null;
			extProtocol = null;
			extUser = null;
			extDevice = null;
			extOs = null;
			extApp = null;
			extUtc = null;
			extNet = null;
			extDevice = null;
			extCloud = null;
			extLoc = null;
			extXbl = null;
			extSdk = null;
			extJavascript = null;
			extReceipts = null;
			ext = null;
			tags = null;
			baseType = string.Empty;
			baseData = null;
			data = null;
		}

		private static void SafeClear(IList list)
		{
			list?.Clear();
		}
	}
}
namespace PlayFab
{
	public static class PlayFabAuthenticationAPI
	{
		static PlayFabAuthenticationAPI()
		{
		}

		public static bool IsEntityLoggedIn()
		{
			return PlayFabSettings.staticPlayer.IsEntityLoggedIn();
		}

		public static void ForgetAllCredentials()
		{
			PlayFabSettings.staticPlayer.ForgetAllCredentials();
		}

		public static void GetEntityToken(GetEntityTokenRequest request, Action<GetEntityTokenResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			AuthType authType = AuthType.None;
			if (playFabAuthenticationContext.ClientSessionTicket != null)
			{
				authType = AuthType.LoginSession;
			}
			if (playFabAuthenticationContext.EntityToken != null)
			{
				authType = AuthType.EntityToken;
			}
			PlayFabHttp.MakeApiCall("/Authentication/GetEntityToken", request, authType, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext);
		}

		public static void ValidateEntityToken(ValidateEntityTokenRequest request, Action<ValidateEntityTokenResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			PlayFabHttp.MakeApiCall("/Authentication/ValidateEntityToken", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}
	}
	public class PlayFabAuthenticationInstanceAPI : IPlayFabInstanceApi
	{
		public readonly PlayFabApiSettings apiSettings;

		public readonly PlayFabAuthenticationContext authenticationContext;

		public PlayFabAuthenticationInstanceAPI()
		{
			authenticationContext = new PlayFabAuthenticationContext();
		}

		public PlayFabAuthenticationInstanceAPI(PlayFabApiSettings settings)
		{
			apiSettings = settings;
			authenticationContext = new PlayFabAuthenticationContext();
		}

		public PlayFabAuthenticationInstanceAPI(PlayFabAuthenticationContext context)
		{
			authenticationContext = context ?? new PlayFabAuthenticationContext();
		}

		public PlayFabAuthenticationInstanceAPI(PlayFabApiSettings settings, PlayFabAuthenticationContext context)
		{
			apiSettings = settings;
			authenticationContext = context ?? new PlayFabAuthenticationContext();
		}

		public bool IsEntityLoggedIn()
		{
			if (authenticationContext != null)
			{
				return authenticationContext.IsEntityLoggedIn();
			}
			return false;
		}

		public void ForgetAllCredentials()
		{
			if (authenticationContext != null)
			{
				authenticationContext.ForgetAllCredentials();
			}
		}

		public void GetEntityToken(GetEntityTokenRequest request, Action<GetEntityTokenResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			AuthType authType = AuthType.None;
			if (playFabAuthenticationContext.ClientSessionTicket != null)
			{
				authType = AuthType.LoginSession;
			}
			if (playFabAuthenticationContext.EntityToken != null)
			{
				authType = AuthType.EntityToken;
			}
			PlayFabHttp.MakeApiCall("/Authentication/GetEntityToken", request, authType, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void ValidateEntityToken(ValidateEntityTokenRequest request, Action<ValidateEntityTokenResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			PlayFabHttp.MakeApiCall("/Authentication/ValidateEntityToken", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}
	}
	public static class PlayFabClientAPI
	{
		static PlayFabClientAPI()
		{
		}

		public static bool IsClientLoggedIn()
		{
			return PlayFabSettings.staticPlayer.IsClientLoggedIn();
		}

		public static void ForgetAllCredentials()
		{
			PlayFabSettings.staticPlayer.ForgetAllCredentials();
		}

		public static void AcceptTrade(AcceptTradeRequest request, Action<AcceptTradeResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/AcceptTrade", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void AddFriend(AddFriendRequest request, Action<AddFriendResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/AddFriend", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void AddGenericID(AddGenericIDRequest request, Action<AddGenericIDResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/AddGenericID", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void AddOrUpdateContactEmail(AddOrUpdateContactEmailRequest request, Action<AddOrUpdateContactEmailResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/AddOrUpdateContactEmail", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void AddSharedGroupMembers(AddSharedGroupMembersRequest request, Action<AddSharedGroupMembersResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/AddSharedGroupMembers", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void AddUsernamePassword(AddUsernamePasswordRequest request, Action<AddUsernamePasswordResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/AddUsernamePassword", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void AddUserVirtualCurrency(AddUserVirtualCurrencyRequest request, Action<ModifyUserVirtualCurrencyResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/AddUserVirtualCurrency", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void AndroidDevicePushNotificationRegistration(AndroidDevicePushNotificationRegistrationRequest request, Action<AndroidDevicePushNotificationRegistrationResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/AndroidDevicePushNotificationRegistration", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void AttributeInstall(AttributeInstallRequest request, Action<AttributeInstallResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/AttributeInstall", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void CancelTrade(CancelTradeRequest request, Action<CancelTradeResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/CancelTrade", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void ConfirmPurchase(ConfirmPurchaseRequest request, Action<ConfirmPurchaseResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/ConfirmPurchase", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void ConsumeItem(ConsumeItemRequest request, Action<ConsumeItemResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/ConsumeItem", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void ConsumePSNEntitlements(ConsumePSNEntitlementsRequest request, Action<ConsumePSNEntitlementsResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/ConsumePSNEntitlements", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void ConsumeXboxEntitlements(ConsumeXboxEntitlementsRequest request, Action<ConsumeXboxEntitlementsResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/ConsumeXboxEntitlements", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void CreateSharedGroup(CreateSharedGroupRequest request, Action<CreateSharedGroupResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/CreateSharedGroup", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void ExecuteCloudScript(ExecuteCloudScriptRequest request, Action<PlayFab.ClientModels.ExecuteCloudScriptResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/ExecuteCloudScript", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void ExecuteCloudScript<TOut>(ExecuteCloudScriptRequest request, Action<PlayFab.ClientModels.ExecuteCloudScriptResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			Action<PlayFab.ClientModels.ExecuteCloudScriptResult> resultCallback2 = delegate(PlayFab.ClientModels.ExecuteCloudScriptResult wrappedResult)
			{
				ISerializerPlugin plugin = PluginManager.GetPlugin<ISerializerPlugin>(PluginContract.PlayFab_Serializer);
				string text = plugin.SerializeObject(wrappedResult.FunctionResult);
				try
				{
					wrappedResult.FunctionResult = plugin.DeserializeObject<TOut>(text);
				}
				catch (Exception)
				{
					wrappedResult.FunctionResult = text;
					wrappedResult.Logs.Add(new PlayFab.ClientModels.LogStatement
					{
						Level = "Warning",
						Data = text,
						Message = "Sdk Message: Could not deserialize result as: " + typeof(TOut).Name
					});
				}
				resultCallback(wrappedResult);
			};
			PlayFabHttp.MakeApiCall("/Client/ExecuteCloudScript", request, AuthType.LoginSession, resultCallback2, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void GetAccountInfo(GetAccountInfoRequest request, Action<GetAccountInfoResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetAccountInfo", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void GetAllUsersCharacters(ListUsersCharactersRequest request, Action<ListUsersCharactersResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetAllUsersCharacters", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void GetCatalogItems(GetCatalogItemsRequest request, Action<GetCatalogItemsResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetCatalogItems", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void GetCharacterData(GetCharacterDataRequest request, Action<GetCharacterDataResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetCharacterData", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void GetCharacterInventory(GetCharacterInventoryRequest request, Action<GetCharacterInventoryResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetCharacterInventory", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void GetCharacterLeaderboard(GetCharacterLeaderboardRequest request, Action<GetCharacterLeaderboardResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetCharacterLeaderboard", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void GetCharacterReadOnlyData(GetCharacterDataRequest request, Action<GetCharacterDataResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetCharacterReadOnlyData", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void GetCharacterStatistics(GetCharacterStatisticsRequest request, Action<GetCharacterStatisticsResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetCharacterStatistics", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void GetContentDownloadUrl(GetContentDownloadUrlRequest request, Action<GetContentDownloadUrlResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetContentDownloadUrl", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void GetCurrentGames(CurrentGamesRequest request, Action<CurrentGamesResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetCurrentGames", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void GetFriendLeaderboard(GetFriendLeaderboardRequest request, Action<GetLeaderboardResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetFriendLeaderboard", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void GetFriendLeaderboardAroundPlayer(GetFriendLeaderboardAroundPlayerRequest request, Action<GetFriendLeaderboardAroundPlayerResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetFriendLeaderboardAroundPlayer", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void GetFriendsList(GetFriendsListRequest request, Action<GetFriendsListResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetFriendsList", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void GetGameServerRegions(GameServerRegionsRequest request, Action<GameServerRegionsResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetGameServerRegions", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void GetLeaderboard(GetLeaderboardRequest request, Action<GetLeaderboardResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetLeaderboard", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void GetLeaderboardAroundCharacter(GetLeaderboardAroundCharacterRequest request, Action<GetLeaderboardAroundCharacterResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetLeaderboardAroundCharacter", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void GetLeaderboardAroundPlayer(GetLeaderboardAroundPlayerRequest request, Action<GetLeaderboardAroundPlayerResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetLeaderboardAroundPlayer", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void GetLeaderboardForUserCharacters(GetLeaderboardForUsersCharactersRequest request, Action<GetLeaderboardForUsersCharactersResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetLeaderboardForUserCharacters", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void GetPaymentToken(GetPaymentTokenRequest request, Action<GetPaymentTokenResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetPaymentToken", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void GetPhotonAuthenticationToken(GetPhotonAuthenticationTokenRequest request, Action<GetPhotonAuthenticationTokenResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetPhotonAuthenticationToken", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void GetPlayerCombinedInfo(GetPlayerCombinedInfoRequest request, Action<GetPlayerCombinedInfoResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetPlayerCombinedInfo", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void GetPlayerProfile(GetPlayerProfileRequest request, Action<GetPlayerProfileResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetPlayerProfile", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void GetPlayerSegments(GetPlayerSegmentsRequest request, Action<GetPlayerSegmentsResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetPlayerSegments", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void GetPlayerStatistics(GetPlayerStatisticsRequest request, Action<GetPlayerStatisticsResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetPlayerStatistics", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void GetPlayerStatisticVersions(GetPlayerStatisticVersionsRequest request, Action<GetPlayerStatisticVersionsResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetPlayerStatisticVersions", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void GetPlayerTags(GetPlayerTagsRequest request, Action<GetPlayerTagsResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetPlayerTags", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void GetPlayerTrades(GetPlayerTradesRequest request, Action<GetPlayerTradesResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetPlayerTrades", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void GetPlayFabIDsFromFacebookIDs(GetPlayFabIDsFromFacebookIDsRequest request, Action<GetPlayFabIDsFromFacebookIDsResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetPlayFabIDsFromFacebookIDs", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void GetPlayFabIDsFromFacebookInstantGamesIds(GetPlayFabIDsFromFacebookInstantGamesIdsRequest request, Action<GetPlayFabIDsFromFacebookInstantGamesIdsResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetPlayFabIDsFromFacebookInstantGamesIds", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void GetPlayFabIDsFromGameCenterIDs(GetPlayFabIDsFromGameCenterIDsRequest request, Action<GetPlayFabIDsFromGameCenterIDsResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetPlayFabIDsFromGameCenterIDs", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void GetPlayFabIDsFromGenericIDs(GetPlayFabIDsFromGenericIDsRequest request, Action<GetPlayFabIDsFromGenericIDsResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetPlayFabIDsFromGenericIDs", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void GetPlayFabIDsFromGoogleIDs(GetPlayFabIDsFromGoogleIDsRequest request, Action<GetPlayFabIDsFromGoogleIDsResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetPlayFabIDsFromGoogleIDs", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void GetPlayFabIDsFromKongregateIDs(GetPlayFabIDsFromKongregateIDsRequest request, Action<GetPlayFabIDsFromKongregateIDsResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetPlayFabIDsFromKongregateIDs", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void GetPlayFabIDsFromNintendoSwitchDeviceIds(GetPlayFabIDsFromNintendoSwitchDeviceIdsRequest request, Action<GetPlayFabIDsFromNintendoSwitchDeviceIdsResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetPlayFabIDsFromNintendoSwitchDeviceIds", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void GetPlayFabIDsFromPSNAccountIDs(GetPlayFabIDsFromPSNAccountIDsRequest request, Action<GetPlayFabIDsFromPSNAccountIDsResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetPlayFabIDsFromPSNAccountIDs", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void GetPlayFabIDsFromSteamIDs(GetPlayFabIDsFromSteamIDsRequest request, Action<GetPlayFabIDsFromSteamIDsResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetPlayFabIDsFromSteamIDs", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void GetPlayFabIDsFromTwitchIDs(GetPlayFabIDsFromTwitchIDsRequest request, Action<GetPlayFabIDsFromTwitchIDsResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetPlayFabIDsFromTwitchIDs", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void GetPlayFabIDsFromXboxLiveIDs(GetPlayFabIDsFromXboxLiveIDsRequest request, Action<GetPlayFabIDsFromXboxLiveIDsResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetPlayFabIDsFromXboxLiveIDs", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void GetPublisherData(GetPublisherDataRequest request, Action<GetPublisherDataResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetPublisherData", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void GetPurchase(GetPurchaseRequest request, Action<GetPurchaseResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetPurchase", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void GetSharedGroupData(GetSharedGroupDataRequest request, Action<GetSharedGroupDataResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetSharedGroupData", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void GetStoreItems(GetStoreItemsRequest request, Action<GetStoreItemsResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetStoreItems", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void GetTime(GetTimeRequest request, Action<GetTimeResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetTime", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void GetTitleData(GetTitleDataRequest request, Action<GetTitleDataResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetTitleData", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void GetTitleNews(GetTitleNewsRequest request, Action<GetTitleNewsResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetTitleNews", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void GetTitlePublicKey(GetTitlePublicKeyRequest request, Action<GetTitlePublicKeyResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			PlayFabHttp.MakeApiCall("/Client/GetTitlePublicKey", request, AuthType.None, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void GetTradeStatus(GetTradeStatusRequest request, Action<GetTradeStatusResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetTradeStatus", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void GetUserData(GetUserDataRequest request, Action<GetUserDataResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetUserData", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void GetUserInventory(GetUserInventoryRequest request, Action<GetUserInventoryResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetUserInventory", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void GetUserPublisherData(GetUserDataRequest request, Action<GetUserDataResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetUserPublisherData", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void GetUserPublisherReadOnlyData(GetUserDataRequest request, Action<GetUserDataResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetUserPublisherReadOnlyData", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void GetUserReadOnlyData(GetUserDataRequest request, Action<GetUserDataResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetUserReadOnlyData", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void GetWindowsHelloChallenge(GetWindowsHelloChallengeRequest request, Action<GetWindowsHelloChallengeResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			PlayFabHttp.MakeApiCall("/Client/GetWindowsHelloChallenge", request, AuthType.None, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void GrantCharacterToUser(GrantCharacterToUserRequest request, Action<GrantCharacterToUserResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GrantCharacterToUser", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void LinkAndroidDeviceID(LinkAndroidDeviceIDRequest request, Action<LinkAndroidDeviceIDResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/LinkAndroidDeviceID", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void LinkCustomID(LinkCustomIDRequest request, Action<LinkCustomIDResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/LinkCustomID", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void LinkFacebookAccount(LinkFacebookAccountRequest request, Action<LinkFacebookAccountResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/LinkFacebookAccount", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void LinkFacebookInstantGamesId(LinkFacebookInstantGamesIdRequest request, Action<LinkFacebookInstantGamesIdResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/LinkFacebookInstantGamesId", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void LinkGameCenterAccount(LinkGameCenterAccountRequest request, Action<LinkGameCenterAccountResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/LinkGameCenterAccount", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void LinkGoogleAccount(LinkGoogleAccountRequest request, Action<LinkGoogleAccountResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/LinkGoogleAccount", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void LinkIOSDeviceID(LinkIOSDeviceIDRequest request, Action<LinkIOSDeviceIDResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/LinkIOSDeviceID", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void LinkKongregate(LinkKongregateAccountRequest request, Action<LinkKongregateAccountResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/LinkKongregate", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void LinkNintendoSwitchDeviceId(LinkNintendoSwitchDeviceIdRequest request, Action<LinkNintendoSwitchDeviceIdResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/LinkNintendoSwitchDeviceId", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void LinkOpenIdConnect(LinkOpenIdConnectRequest request, Action<EmptyResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/LinkOpenIdConnect", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void LinkPSNAccount(LinkPSNAccountRequest request, Action<LinkPSNAccountResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/LinkPSNAccount", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void LinkSteamAccount(LinkSteamAccountRequest request, Action<LinkSteamAccountResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/LinkSteamAccount", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void LinkTwitch(LinkTwitchAccountRequest request, Action<LinkTwitchAccountResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/LinkTwitch", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void LinkWindowsHello(LinkWindowsHelloAccountRequest request, Action<LinkWindowsHelloAccountResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/LinkWindowsHello", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void LinkXboxAccount(LinkXboxAccountRequest request, Action<LinkXboxAccountResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/LinkXboxAccount", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void LoginWithAndroidDeviceID(LoginWithAndroidDeviceIDRequest request, Action<LoginResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			request.TitleId = request.TitleId ?? PlayFabSettings.TitleId;
			PlayFabHttp.MakeApiCall("/Client/LoginWithAndroidDeviceID", request, AuthType.None, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void LoginWithCustomID(LoginWithCustomIDRequest request, Action<LoginResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			request.TitleId = request.TitleId ?? PlayFabSettings.TitleId;
			PlayFabHttp.MakeApiCall("/Client/LoginWithCustomID", request, AuthType.None, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void LoginWithEmailAddress(LoginWithEmailAddressRequest request, Action<LoginResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			request.TitleId = request.TitleId ?? PlayFabSettings.TitleId;
			PlayFabHttp.MakeApiCall("/Client/LoginWithEmailAddress", request, AuthType.None, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void LoginWithFacebook(LoginWithFacebookRequest request, Action<LoginResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			request.TitleId = request.TitleId ?? PlayFabSettings.TitleId;
			PlayFabHttp.MakeApiCall("/Client/LoginWithFacebook", request, AuthType.None, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void LoginWithFacebookInstantGamesId(LoginWithFacebookInstantGamesIdRequest request, Action<LoginResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			request.TitleId = request.TitleId ?? PlayFabSettings.TitleId;
			PlayFabHttp.MakeApiCall("/Client/LoginWithFacebookInstantGamesId", request, AuthType.None, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void LoginWithGameCenter(LoginWithGameCenterRequest request, Action<LoginResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			request.TitleId = request.TitleId ?? PlayFabSettings.TitleId;
			PlayFabHttp.MakeApiCall("/Client/LoginWithGameCenter", request, AuthType.None, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void LoginWithGoogleAccount(LoginWithGoogleAccountRequest request, Action<LoginResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			request.TitleId = request.TitleId ?? PlayFabSettings.TitleId;
			PlayFabHttp.MakeApiCall("/Client/LoginWithGoogleAccount", request, AuthType.None, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void LoginWithIOSDeviceID(LoginWithIOSDeviceIDRequest request, Action<LoginResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			request.TitleId = request.TitleId ?? PlayFabSettings.TitleId;
			PlayFabHttp.MakeApiCall("/Client/LoginWithIOSDeviceID", request, AuthType.None, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void LoginWithKongregate(LoginWithKongregateRequest request, Action<LoginResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			request.TitleId = request.TitleId ?? PlayFabSettings.TitleId;
			PlayFabHttp.MakeApiCall("/Client/LoginWithKongregate", request, AuthType.None, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void LoginWithNintendoSwitchDeviceId(LoginWithNintendoSwitchDeviceIdRequest request, Action<LoginResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			request.TitleId = request.TitleId ?? PlayFabSettings.TitleId;
			PlayFabHttp.MakeApiCall("/Client/LoginWithNintendoSwitchDeviceId", request, AuthType.None, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void LoginWithOpenIdConnect(LoginWithOpenIdConnectRequest request, Action<LoginResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			request.TitleId = request.TitleId ?? PlayFabSettings.TitleId;
			PlayFabHttp.MakeApiCall("/Client/LoginWithOpenIdConnect", request, AuthType.None, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void LoginWithPlayFab(LoginWithPlayFabRequest request, Action<LoginResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			request.TitleId = request.TitleId ?? PlayFabSettings.TitleId;
			PlayFabHttp.MakeApiCall("/Client/LoginWithPlayFab", request, AuthType.None, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void LoginWithPSN(LoginWithPSNRequest request, Action<LoginResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			request.TitleId = request.TitleId ?? PlayFabSettings.TitleId;
			PlayFabHttp.MakeApiCall("/Client/LoginWithPSN", request, AuthType.None, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void LoginWithSteam(LoginWithSteamRequest request, Action<LoginResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			request.TitleId = request.TitleId ?? PlayFabSettings.TitleId;
			PlayFabHttp.MakeApiCall("/Client/LoginWithSteam", request, AuthType.None, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void LoginWithTwitch(LoginWithTwitchRequest request, Action<LoginResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			request.TitleId = request.TitleId ?? PlayFabSettings.TitleId;
			PlayFabHttp.MakeApiCall("/Client/LoginWithTwitch", request, AuthType.None, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void LoginWithWindowsHello(LoginWithWindowsHelloRequest request, Action<LoginResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			request.TitleId = request.TitleId ?? PlayFabSettings.TitleId;
			PlayFabHttp.MakeApiCall("/Client/LoginWithWindowsHello", request, AuthType.None, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void LoginWithXbox(LoginWithXboxRequest request, Action<LoginResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			request.TitleId = request.TitleId ?? PlayFabSettings.TitleId;
			PlayFabHttp.MakeApiCall("/Client/LoginWithXbox", request, AuthType.None, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void Matchmake(MatchmakeRequest request, Action<MatchmakeResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/Matchmake", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void OpenTrade(OpenTradeRequest request, Action<OpenTradeResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/OpenTrade", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void PayForPurchase(PayForPurchaseRequest request, Action<PayForPurchaseResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/PayForPurchase", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void PurchaseItem(PurchaseItemRequest request, Action<PurchaseItemResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/PurchaseItem", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void RedeemCoupon(RedeemCouponRequest request, Action<RedeemCouponResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/RedeemCoupon", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void RefreshPSNAuthToken(RefreshPSNAuthTokenRequest request, Action<PlayFab.ClientModels.EmptyResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/RefreshPSNAuthToken", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void RegisterForIOSPushNotification(RegisterForIOSPushNotificationRequest request, Action<RegisterForIOSPushNotificationResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/RegisterForIOSPushNotification", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void RegisterPlayFabUser(RegisterPlayFabUserRequest request, Action<RegisterPlayFabUserResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			request.TitleId = request.TitleId ?? PlayFabSettings.TitleId;
			PlayFabHttp.MakeApiCall("/Client/RegisterPlayFabUser", request, AuthType.None, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void RegisterWithWindowsHello(RegisterWithWindowsHelloRequest request, Action<LoginResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			request.TitleId = request.TitleId ?? PlayFabSettings.TitleId;
			PlayFabHttp.MakeApiCall("/Client/RegisterWithWindowsHello", request, AuthType.None, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void RemoveContactEmail(RemoveContactEmailRequest request, Action<RemoveContactEmailResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/RemoveContactEmail", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void RemoveFriend(RemoveFriendRequest request, Action<RemoveFriendResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/RemoveFriend", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void RemoveGenericID(RemoveGenericIDRequest request, Action<RemoveGenericIDResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/RemoveGenericID", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void RemoveSharedGroupMembers(RemoveSharedGroupMembersRequest request, Action<RemoveSharedGroupMembersResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/RemoveSharedGroupMembers", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void ReportDeviceInfo(DeviceInfoRequest request, Action<PlayFab.ClientModels.EmptyResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/ReportDeviceInfo", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void ReportPlayer(ReportPlayerClientRequest request, Action<ReportPlayerClientResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/ReportPlayer", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void RestoreIOSPurchases(RestoreIOSPurchasesRequest request, Action<RestoreIOSPurchasesResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/RestoreIOSPurchases", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void SendAccountRecoveryEmail(SendAccountRecoveryEmailRequest request, Action<SendAccountRecoveryEmailResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			PlayFabHttp.MakeApiCall("/Client/SendAccountRecoveryEmail", request, AuthType.None, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void SetFriendTags(SetFriendTagsRequest request, Action<SetFriendTagsResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/SetFriendTags", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void SetPlayerSecret(SetPlayerSecretRequest request, Action<SetPlayerSecretResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/SetPlayerSecret", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void StartGame(StartGameRequest request, Action<StartGameResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/StartGame", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void StartPurchase(StartPurchaseRequest request, Action<StartPurchaseResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/StartPurchase", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void SubtractUserVirtualCurrency(SubtractUserVirtualCurrencyRequest request, Action<ModifyUserVirtualCurrencyResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/SubtractUserVirtualCurrency", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void UnlinkAndroidDeviceID(UnlinkAndroidDeviceIDRequest request, Action<UnlinkAndroidDeviceIDResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/UnlinkAndroidDeviceID", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void UnlinkCustomID(UnlinkCustomIDRequest request, Action<UnlinkCustomIDResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/UnlinkCustomID", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void UnlinkFacebookAccount(UnlinkFacebookAccountRequest request, Action<UnlinkFacebookAccountResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/UnlinkFacebookAccount", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void UnlinkFacebookInstantGamesId(UnlinkFacebookInstantGamesIdRequest request, Action<UnlinkFacebookInstantGamesIdResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/UnlinkFacebookInstantGamesId", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void UnlinkGameCenterAccount(UnlinkGameCenterAccountRequest request, Action<UnlinkGameCenterAccountResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/UnlinkGameCenterAccount", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void UnlinkGoogleAccount(UnlinkGoogleAccountRequest request, Action<UnlinkGoogleAccountResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/UnlinkGoogleAccount", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void UnlinkIOSDeviceID(UnlinkIOSDeviceIDRequest request, Action<UnlinkIOSDeviceIDResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/UnlinkIOSDeviceID", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void UnlinkKongregate(UnlinkKongregateAccountRequest request, Action<UnlinkKongregateAccountResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/UnlinkKongregate", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void UnlinkNintendoSwitchDeviceId(UnlinkNintendoSwitchDeviceIdRequest request, Action<UnlinkNintendoSwitchDeviceIdResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/UnlinkNintendoSwitchDeviceId", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void UnlinkOpenIdConnect(UninkOpenIdConnectRequest request, Action<PlayFab.ClientModels.EmptyResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/UnlinkOpenIdConnect", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void UnlinkPSNAccount(UnlinkPSNAccountRequest request, Action<UnlinkPSNAccountResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/UnlinkPSNAccount", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void UnlinkSteamAccount(UnlinkSteamAccountRequest request, Action<UnlinkSteamAccountResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/UnlinkSteamAccount", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void UnlinkTwitch(UnlinkTwitchAccountRequest request, Action<UnlinkTwitchAccountResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/UnlinkTwitch", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void UnlinkWindowsHello(UnlinkWindowsHelloAccountRequest request, Action<UnlinkWindowsHelloAccountResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/UnlinkWindowsHello", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void UnlinkXboxAccount(UnlinkXboxAccountRequest request, Action<UnlinkXboxAccountResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/UnlinkXboxAccount", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void UnlockContainerInstance(UnlockContainerInstanceRequest request, Action<UnlockContainerItemResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/UnlockContainerInstance", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void UnlockContainerItem(UnlockContainerItemRequest request, Action<UnlockContainerItemResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/UnlockContainerItem", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void UpdateAvatarUrl(UpdateAvatarUrlRequest request, Action<PlayFab.ClientModels.EmptyResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/UpdateAvatarUrl", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void UpdateCharacterData(UpdateCharacterDataRequest request, Action<UpdateCharacterDataResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/UpdateCharacterData", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void UpdateCharacterStatistics(UpdateCharacterStatisticsRequest request, Action<UpdateCharacterStatisticsResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/UpdateCharacterStatistics", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void UpdatePlayerStatistics(UpdatePlayerStatisticsRequest request, Action<UpdatePlayerStatisticsResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/UpdatePlayerStatistics", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void UpdateSharedGroupData(UpdateSharedGroupDataRequest request, Action<UpdateSharedGroupDataResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/UpdateSharedGroupData", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void UpdateUserData(UpdateUserDataRequest request, Action<UpdateUserDataResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/UpdateUserData", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void UpdateUserPublisherData(UpdateUserDataRequest request, Action<UpdateUserDataResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/UpdateUserPublisherData", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void UpdateUserTitleDisplayName(UpdateUserTitleDisplayNameRequest request, Action<UpdateUserTitleDisplayNameResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/UpdateUserTitleDisplayName", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void ValidateAmazonIAPReceipt(ValidateAmazonReceiptRequest request, Action<ValidateAmazonReceiptResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/ValidateAmazonIAPReceipt", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void ValidateGooglePlayPurchase(ValidateGooglePlayPurchaseRequest request, Action<ValidateGooglePlayPurchaseResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/ValidateGooglePlayPurchase", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void ValidateIOSReceipt(ValidateIOSReceiptRequest request, Action<ValidateIOSReceiptResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/ValidateIOSReceipt", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void ValidateWindowsStoreReceipt(ValidateWindowsReceiptRequest request, Action<ValidateWindowsReceiptResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/ValidateWindowsStoreReceipt", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void WriteCharacterEvent(WriteClientCharacterEventRequest request, Action<WriteEventResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/WriteCharacterEvent", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void WritePlayerEvent(WriteClientPlayerEventRequest request, Action<WriteEventResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/WritePlayerEvent", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void WriteTitleEvent(WriteTitleEventRequest request, Action<WriteEventResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/WriteTitleEvent", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}
	}
	public class PlayFabClientInstanceAPI : IPlayFabInstanceApi
	{
		public readonly PlayFabApiSettings apiSettings;

		public readonly PlayFabAuthenticationContext authenticationContext;

		public PlayFabClientInstanceAPI()
		{
			authenticationContext = new PlayFabAuthenticationContext();
		}

		public PlayFabClientInstanceAPI(PlayFabApiSettings settings)
		{
			apiSettings = settings;
			authenticationContext = new PlayFabAuthenticationContext();
		}

		public PlayFabClientInstanceAPI(PlayFabAuthenticationContext context)
		{
			authenticationContext = context ?? new PlayFabAuthenticationContext();
		}

		public PlayFabClientInstanceAPI(PlayFabApiSettings settings, PlayFabAuthenticationContext context)
		{
			apiSettings = settings;
			authenticationContext = context ?? new PlayFabAuthenticationContext();
		}

		public bool IsClientLoggedIn()
		{
			if (authenticationContext != null)
			{
				return authenticationContext.IsClientLoggedIn();
			}
			return false;
		}

		public void ForgetAllCredentials()
		{
			if (authenticationContext != null)
			{
				authenticationContext.ForgetAllCredentials();
			}
		}

		public void AcceptTrade(AcceptTradeRequest request, Action<AcceptTradeResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/AcceptTrade", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void AddFriend(AddFriendRequest request, Action<AddFriendResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/AddFriend", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void AddGenericID(AddGenericIDRequest request, Action<AddGenericIDResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/AddGenericID", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void AddOrUpdateContactEmail(AddOrUpdateContactEmailRequest request, Action<AddOrUpdateContactEmailResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/AddOrUpdateContactEmail", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void AddSharedGroupMembers(AddSharedGroupMembersRequest request, Action<AddSharedGroupMembersResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/AddSharedGroupMembers", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void AddUsernamePassword(AddUsernamePasswordRequest request, Action<AddUsernamePasswordResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/AddUsernamePassword", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void AddUserVirtualCurrency(AddUserVirtualCurrencyRequest request, Action<ModifyUserVirtualCurrencyResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/AddUserVirtualCurrency", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void AndroidDevicePushNotificationRegistration(AndroidDevicePushNotificationRegistrationRequest request, Action<AndroidDevicePushNotificationRegistrationResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/AndroidDevicePushNotificationRegistration", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void AttributeInstall(AttributeInstallRequest request, Action<AttributeInstallResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/AttributeInstall", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void CancelTrade(CancelTradeRequest request, Action<CancelTradeResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/CancelTrade", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void ConfirmPurchase(ConfirmPurchaseRequest request, Action<ConfirmPurchaseResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/ConfirmPurchase", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void ConsumeItem(ConsumeItemRequest request, Action<ConsumeItemResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/ConsumeItem", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void ConsumePSNEntitlements(ConsumePSNEntitlementsRequest request, Action<ConsumePSNEntitlementsResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/ConsumePSNEntitlements", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void ConsumeXboxEntitlements(ConsumeXboxEntitlementsRequest request, Action<ConsumeXboxEntitlementsResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/ConsumeXboxEntitlements", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void CreateSharedGroup(CreateSharedGroupRequest request, Action<CreateSharedGroupResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/CreateSharedGroup", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void ExecuteCloudScript(ExecuteCloudScriptRequest request, Action<PlayFab.ClientModels.ExecuteCloudScriptResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/ExecuteCloudScript", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void ExecuteCloudScript<TOut>(ExecuteCloudScriptRequest request, Action<PlayFab.ClientModels.ExecuteCloudScriptResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			if (!IsClientLoggedIn())
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			Action<PlayFab.ClientModels.ExecuteCloudScriptResult> resultCallback2 = delegate(PlayFab.ClientModels.ExecuteCloudScriptResult wrappedResult)
			{
				ISerializerPlugin plugin = PluginManager.GetPlugin<ISerializerPlugin>(PluginContract.PlayFab_Serializer);
				string text = plugin.SerializeObject(wrappedResult.FunctionResult);
				try
				{
					wrappedResult.FunctionResult = plugin.DeserializeObject<TOut>(text);
				}
				catch (Exception)
				{
					wrappedResult.FunctionResult = text;
					wrappedResult.Logs.Add(new PlayFab.ClientModels.LogStatement
					{
						Level = "Warning",
						Data = text,
						Message = "Sdk Message: Could not deserialize result as: " + typeof(TOut).Name
					});
				}
				resultCallback(wrappedResult);
			};
			PlayFabHttp.MakeApiCall("/Client/ExecuteCloudScript", request, AuthType.LoginSession, resultCallback2, errorCallback, customData, extraHeaders, playFabAuthenticationContext, apiSettings, this);
		}

		public void GetAccountInfo(GetAccountInfoRequest request, Action<GetAccountInfoResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetAccountInfo", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void GetAllUsersCharacters(ListUsersCharactersRequest request, Action<ListUsersCharactersResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetAllUsersCharacters", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void GetCatalogItems(GetCatalogItemsRequest request, Action<GetCatalogItemsResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetCatalogItems", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void GetCharacterData(GetCharacterDataRequest request, Action<GetCharacterDataResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetCharacterData", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void GetCharacterInventory(GetCharacterInventoryRequest request, Action<GetCharacterInventoryResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetCharacterInventory", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void GetCharacterLeaderboard(GetCharacterLeaderboardRequest request, Action<GetCharacterLeaderboardResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetCharacterLeaderboard", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void GetCharacterReadOnlyData(GetCharacterDataRequest request, Action<GetCharacterDataResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetCharacterReadOnlyData", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void GetCharacterStatistics(GetCharacterStatisticsRequest request, Action<GetCharacterStatisticsResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetCharacterStatistics", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void GetContentDownloadUrl(GetContentDownloadUrlRequest request, Action<GetContentDownloadUrlResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetContentDownloadUrl", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void GetCurrentGames(CurrentGamesRequest request, Action<CurrentGamesResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetCurrentGames", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void GetFriendLeaderboard(GetFriendLeaderboardRequest request, Action<GetLeaderboardResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetFriendLeaderboard", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void GetFriendLeaderboardAroundPlayer(GetFriendLeaderboardAroundPlayerRequest request, Action<GetFriendLeaderboardAroundPlayerResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetFriendLeaderboardAroundPlayer", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void GetFriendsList(GetFriendsListRequest request, Action<GetFriendsListResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetFriendsList", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void GetGameServerRegions(GameServerRegionsRequest request, Action<GameServerRegionsResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetGameServerRegions", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void GetLeaderboard(GetLeaderboardRequest request, Action<GetLeaderboardResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetLeaderboard", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void GetLeaderboardAroundCharacter(GetLeaderboardAroundCharacterRequest request, Action<GetLeaderboardAroundCharacterResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetLeaderboardAroundCharacter", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void GetLeaderboardAroundPlayer(GetLeaderboardAroundPlayerRequest request, Action<GetLeaderboardAroundPlayerResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetLeaderboardAroundPlayer", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void GetLeaderboardForUserCharacters(GetLeaderboardForUsersCharactersRequest request, Action<GetLeaderboardForUsersCharactersResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetLeaderboardForUserCharacters", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void GetPaymentToken(GetPaymentTokenRequest request, Action<GetPaymentTokenResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetPaymentToken", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void GetPhotonAuthenticationToken(GetPhotonAuthenticationTokenRequest request, Action<GetPhotonAuthenticationTokenResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetPhotonAuthenticationToken", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void GetPlayerCombinedInfo(GetPlayerCombinedInfoRequest request, Action<GetPlayerCombinedInfoResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetPlayerCombinedInfo", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void GetPlayerProfile(GetPlayerProfileRequest request, Action<GetPlayerProfileResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetPlayerProfile", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void GetPlayerSegments(GetPlayerSegmentsRequest request, Action<GetPlayerSegmentsResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetPlayerSegments", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void GetPlayerStatistics(GetPlayerStatisticsRequest request, Action<GetPlayerStatisticsResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetPlayerStatistics", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void GetPlayerStatisticVersions(GetPlayerStatisticVersionsRequest request, Action<GetPlayerStatisticVersionsResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetPlayerStatisticVersions", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void GetPlayerTags(GetPlayerTagsRequest request, Action<GetPlayerTagsResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetPlayerTags", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void GetPlayerTrades(GetPlayerTradesRequest request, Action<GetPlayerTradesResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetPlayerTrades", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void GetPlayFabIDsFromFacebookIDs(GetPlayFabIDsFromFacebookIDsRequest request, Action<GetPlayFabIDsFromFacebookIDsResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetPlayFabIDsFromFacebookIDs", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void GetPlayFabIDsFromFacebookInstantGamesIds(GetPlayFabIDsFromFacebookInstantGamesIdsRequest request, Action<GetPlayFabIDsFromFacebookInstantGamesIdsResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetPlayFabIDsFromFacebookInstantGamesIds", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void GetPlayFabIDsFromGameCenterIDs(GetPlayFabIDsFromGameCenterIDsRequest request, Action<GetPlayFabIDsFromGameCenterIDsResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetPlayFabIDsFromGameCenterIDs", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void GetPlayFabIDsFromGenericIDs(GetPlayFabIDsFromGenericIDsRequest request, Action<GetPlayFabIDsFromGenericIDsResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetPlayFabIDsFromGenericIDs", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void GetPlayFabIDsFromGoogleIDs(GetPlayFabIDsFromGoogleIDsRequest request, Action<GetPlayFabIDsFromGoogleIDsResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetPlayFabIDsFromGoogleIDs", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void GetPlayFabIDsFromKongregateIDs(GetPlayFabIDsFromKongregateIDsRequest request, Action<GetPlayFabIDsFromKongregateIDsResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetPlayFabIDsFromKongregateIDs", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void GetPlayFabIDsFromNintendoSwitchDeviceIds(GetPlayFabIDsFromNintendoSwitchDeviceIdsRequest request, Action<GetPlayFabIDsFromNintendoSwitchDeviceIdsResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetPlayFabIDsFromNintendoSwitchDeviceIds", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void GetPlayFabIDsFromPSNAccountIDs(GetPlayFabIDsFromPSNAccountIDsRequest request, Action<GetPlayFabIDsFromPSNAccountIDsResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetPlayFabIDsFromPSNAccountIDs", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void GetPlayFabIDsFromSteamIDs(GetPlayFabIDsFromSteamIDsRequest request, Action<GetPlayFabIDsFromSteamIDsResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetPlayFabIDsFromSteamIDs", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void GetPlayFabIDsFromTwitchIDs(GetPlayFabIDsFromTwitchIDsRequest request, Action<GetPlayFabIDsFromTwitchIDsResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetPlayFabIDsFromTwitchIDs", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void GetPlayFabIDsFromXboxLiveIDs(GetPlayFabIDsFromXboxLiveIDsRequest request, Action<GetPlayFabIDsFromXboxLiveIDsResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetPlayFabIDsFromXboxLiveIDs", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void GetPublisherData(GetPublisherDataRequest request, Action<GetPublisherDataResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetPublisherData", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void GetPurchase(GetPurchaseRequest request, Action<GetPurchaseResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetPurchase", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void GetSharedGroupData(GetSharedGroupDataRequest request, Action<GetSharedGroupDataResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetSharedGroupData", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void GetStoreItems(GetStoreItemsRequest request, Action<GetStoreItemsResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetStoreItems", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void GetTime(GetTimeRequest request, Action<GetTimeResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetTime", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void GetTitleData(GetTitleDataRequest request, Action<GetTitleDataResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetTitleData", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void GetTitleNews(GetTitleNewsRequest request, Action<GetTitleNewsResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetTitleNews", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void GetTitlePublicKey(GetTitlePublicKeyRequest request, Action<GetTitlePublicKeyResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			PlayFabHttp.MakeApiCall("/Client/GetTitlePublicKey", request, AuthType.None, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void GetTradeStatus(GetTradeStatusRequest request, Action<GetTradeStatusResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetTradeStatus", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void GetUserData(GetUserDataRequest request, Action<GetUserDataResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetUserData", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void GetUserInventory(GetUserInventoryRequest request, Action<GetUserInventoryResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetUserInventory", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void GetUserPublisherData(GetUserDataRequest request, Action<GetUserDataResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetUserPublisherData", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void GetUserPublisherReadOnlyData(GetUserDataRequest request, Action<GetUserDataResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetUserPublisherReadOnlyData", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void GetUserReadOnlyData(GetUserDataRequest request, Action<GetUserDataResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GetUserReadOnlyData", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void GetWindowsHelloChallenge(GetWindowsHelloChallengeRequest request, Action<GetWindowsHelloChallengeResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			PlayFabHttp.MakeApiCall("/Client/GetWindowsHelloChallenge", request, AuthType.None, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void GrantCharacterToUser(GrantCharacterToUserRequest request, Action<GrantCharacterToUserResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/GrantCharacterToUser", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void LinkAndroidDeviceID(LinkAndroidDeviceIDRequest request, Action<LinkAndroidDeviceIDResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/LinkAndroidDeviceID", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void LinkCustomID(LinkCustomIDRequest request, Action<LinkCustomIDResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/LinkCustomID", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void LinkFacebookAccount(LinkFacebookAccountRequest request, Action<LinkFacebookAccountResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/LinkFacebookAccount", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void LinkFacebookInstantGamesId(LinkFacebookInstantGamesIdRequest request, Action<LinkFacebookInstantGamesIdResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/LinkFacebookInstantGamesId", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void LinkGameCenterAccount(LinkGameCenterAccountRequest request, Action<LinkGameCenterAccountResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/LinkGameCenterAccount", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void LinkGoogleAccount(LinkGoogleAccountRequest request, Action<LinkGoogleAccountResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/LinkGoogleAccount", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void LinkIOSDeviceID(LinkIOSDeviceIDRequest request, Action<LinkIOSDeviceIDResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/LinkIOSDeviceID", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void LinkKongregate(LinkKongregateAccountRequest request, Action<LinkKongregateAccountResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/LinkKongregate", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void LinkNintendoSwitchDeviceId(LinkNintendoSwitchDeviceIdRequest request, Action<LinkNintendoSwitchDeviceIdResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/LinkNintendoSwitchDeviceId", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void LinkOpenIdConnect(LinkOpenIdConnectRequest request, Action<EmptyResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/LinkOpenIdConnect", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void LinkPSNAccount(LinkPSNAccountRequest request, Action<LinkPSNAccountResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/LinkPSNAccount", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void LinkSteamAccount(LinkSteamAccountRequest request, Action<LinkSteamAccountResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/LinkSteamAccount", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void LinkTwitch(LinkTwitchAccountRequest request, Action<LinkTwitchAccountResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/LinkTwitch", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void LinkWindowsHello(LinkWindowsHelloAccountRequest request, Action<LinkWindowsHelloAccountResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/LinkWindowsHello", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void LinkXboxAccount(LinkXboxAccountRequest request, Action<LinkXboxAccountResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/LinkXboxAccount", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void LoginWithAndroidDeviceID(LoginWithAndroidDeviceIDRequest request, Action<LoginResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			request.TitleId = request.TitleId ?? playFabApiSettings.TitleId;
			PlayFabHttp.MakeApiCall("/Client/LoginWithAndroidDeviceID", request, AuthType.None, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void LoginWithCustomID(LoginWithCustomIDRequest request, Action<LoginResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			request.TitleId = request.TitleId ?? playFabApiSettings.TitleId;
			PlayFabHttp.MakeApiCall("/Client/LoginWithCustomID", request, AuthType.None, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void LoginWithEmailAddress(LoginWithEmailAddressRequest request, Action<LoginResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			request.TitleId = request.TitleId ?? playFabApiSettings.TitleId;
			PlayFabHttp.MakeApiCall("/Client/LoginWithEmailAddress", request, AuthType.None, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void LoginWithFacebook(LoginWithFacebookRequest request, Action<LoginResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			request.TitleId = request.TitleId ?? playFabApiSettings.TitleId;
			PlayFabHttp.MakeApiCall("/Client/LoginWithFacebook", request, AuthType.None, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void LoginWithFacebookInstantGamesId(LoginWithFacebookInstantGamesIdRequest request, Action<LoginResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			request.TitleId = request.TitleId ?? playFabApiSettings.TitleId;
			PlayFabHttp.MakeApiCall("/Client/LoginWithFacebookInstantGamesId", request, AuthType.None, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void LoginWithGameCenter(LoginWithGameCenterRequest request, Action<LoginResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			request.TitleId = request.TitleId ?? playFabApiSettings.TitleId;
			PlayFabHttp.MakeApiCall("/Client/LoginWithGameCenter", request, AuthType.None, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void LoginWithGoogleAccount(LoginWithGoogleAccountRequest request, Action<LoginResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			request.TitleId = request.TitleId ?? playFabApiSettings.TitleId;
			PlayFabHttp.MakeApiCall("/Client/LoginWithGoogleAccount", request, AuthType.None, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void LoginWithIOSDeviceID(LoginWithIOSDeviceIDRequest request, Action<LoginResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			request.TitleId = request.TitleId ?? playFabApiSettings.TitleId;
			PlayFabHttp.MakeApiCall("/Client/LoginWithIOSDeviceID", request, AuthType.None, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void LoginWithKongregate(LoginWithKongregateRequest request, Action<LoginResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			request.TitleId = request.TitleId ?? playFabApiSettings.TitleId;
			PlayFabHttp.MakeApiCall("/Client/LoginWithKongregate", request, AuthType.None, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void LoginWithNintendoSwitchDeviceId(LoginWithNintendoSwitchDeviceIdRequest request, Action<LoginResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			request.TitleId = request.TitleId ?? playFabApiSettings.TitleId;
			PlayFabHttp.MakeApiCall("/Client/LoginWithNintendoSwitchDeviceId", request, AuthType.None, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void LoginWithOpenIdConnect(LoginWithOpenIdConnectRequest request, Action<LoginResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			request.TitleId = request.TitleId ?? playFabApiSettings.TitleId;
			PlayFabHttp.MakeApiCall("/Client/LoginWithOpenIdConnect", request, AuthType.None, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void LoginWithPlayFab(LoginWithPlayFabRequest request, Action<LoginResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			request.TitleId = request.TitleId ?? playFabApiSettings.TitleId;
			PlayFabHttp.MakeApiCall("/Client/LoginWithPlayFab", request, AuthType.None, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void LoginWithPSN(LoginWithPSNRequest request, Action<LoginResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			request.TitleId = request.TitleId ?? playFabApiSettings.TitleId;
			PlayFabHttp.MakeApiCall("/Client/LoginWithPSN", request, AuthType.None, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void LoginWithSteam(LoginWithSteamRequest request, Action<LoginResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			request.TitleId = request.TitleId ?? playFabApiSettings.TitleId;
			PlayFabHttp.MakeApiCall("/Client/LoginWithSteam", request, AuthType.None, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void LoginWithTwitch(LoginWithTwitchRequest request, Action<LoginResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			request.TitleId = request.TitleId ?? playFabApiSettings.TitleId;
			PlayFabHttp.MakeApiCall("/Client/LoginWithTwitch", request, AuthType.None, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void LoginWithWindowsHello(LoginWithWindowsHelloRequest request, Action<LoginResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			request.TitleId = request.TitleId ?? playFabApiSettings.TitleId;
			PlayFabHttp.MakeApiCall("/Client/LoginWithWindowsHello", request, AuthType.None, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void LoginWithXbox(LoginWithXboxRequest request, Action<LoginResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			request.TitleId = request.TitleId ?? playFabApiSettings.TitleId;
			PlayFabHttp.MakeApiCall("/Client/LoginWithXbox", request, AuthType.None, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void Matchmake(MatchmakeRequest request, Action<MatchmakeResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/Matchmake", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void OpenTrade(OpenTradeRequest request, Action<OpenTradeResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/OpenTrade", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void PayForPurchase(PayForPurchaseRequest request, Action<PayForPurchaseResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/PayForPurchase", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void PurchaseItem(PurchaseItemRequest request, Action<PurchaseItemResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/PurchaseItem", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void RedeemCoupon(RedeemCouponRequest request, Action<RedeemCouponResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/RedeemCoupon", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void RefreshPSNAuthToken(RefreshPSNAuthTokenRequest request, Action<PlayFab.ClientModels.EmptyResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/RefreshPSNAuthToken", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void RegisterForIOSPushNotification(RegisterForIOSPushNotificationRequest request, Action<RegisterForIOSPushNotificationResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/RegisterForIOSPushNotification", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void RegisterPlayFabUser(RegisterPlayFabUserRequest request, Action<RegisterPlayFabUserResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			request.TitleId = request.TitleId ?? playFabApiSettings.TitleId;
			PlayFabHttp.MakeApiCall("/Client/RegisterPlayFabUser", request, AuthType.None, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void RegisterWithWindowsHello(RegisterWithWindowsHelloRequest request, Action<LoginResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			request.TitleId = request.TitleId ?? playFabApiSettings.TitleId;
			PlayFabHttp.MakeApiCall("/Client/RegisterWithWindowsHello", request, AuthType.None, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void RemoveContactEmail(RemoveContactEmailRequest request, Action<RemoveContactEmailResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/RemoveContactEmail", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void RemoveFriend(RemoveFriendRequest request, Action<RemoveFriendResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/RemoveFriend", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void RemoveGenericID(RemoveGenericIDRequest request, Action<RemoveGenericIDResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/RemoveGenericID", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void RemoveSharedGroupMembers(RemoveSharedGroupMembersRequest request, Action<RemoveSharedGroupMembersResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/RemoveSharedGroupMembers", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void ReportDeviceInfo(DeviceInfoRequest request, Action<PlayFab.ClientModels.EmptyResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/ReportDeviceInfo", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void ReportPlayer(ReportPlayerClientRequest request, Action<ReportPlayerClientResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/ReportPlayer", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void RestoreIOSPurchases(RestoreIOSPurchasesRequest request, Action<RestoreIOSPurchasesResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/RestoreIOSPurchases", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void SendAccountRecoveryEmail(SendAccountRecoveryEmailRequest request, Action<SendAccountRecoveryEmailResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			PlayFabHttp.MakeApiCall("/Client/SendAccountRecoveryEmail", request, AuthType.None, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void SetFriendTags(SetFriendTagsRequest request, Action<SetFriendTagsResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/SetFriendTags", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void SetPlayerSecret(SetPlayerSecretRequest request, Action<SetPlayerSecretResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/SetPlayerSecret", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void StartGame(StartGameRequest request, Action<StartGameResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/StartGame", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void StartPurchase(StartPurchaseRequest request, Action<StartPurchaseResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/StartPurchase", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void SubtractUserVirtualCurrency(SubtractUserVirtualCurrencyRequest request, Action<ModifyUserVirtualCurrencyResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/SubtractUserVirtualCurrency", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void UnlinkAndroidDeviceID(UnlinkAndroidDeviceIDRequest request, Action<UnlinkAndroidDeviceIDResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/UnlinkAndroidDeviceID", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void UnlinkCustomID(UnlinkCustomIDRequest request, Action<UnlinkCustomIDResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/UnlinkCustomID", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void UnlinkFacebookAccount(UnlinkFacebookAccountRequest request, Action<UnlinkFacebookAccountResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/UnlinkFacebookAccount", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void UnlinkFacebookInstantGamesId(UnlinkFacebookInstantGamesIdRequest request, Action<UnlinkFacebookInstantGamesIdResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/UnlinkFacebookInstantGamesId", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void UnlinkGameCenterAccount(UnlinkGameCenterAccountRequest request, Action<UnlinkGameCenterAccountResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/UnlinkGameCenterAccount", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void UnlinkGoogleAccount(UnlinkGoogleAccountRequest request, Action<UnlinkGoogleAccountResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/UnlinkGoogleAccount", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void UnlinkIOSDeviceID(UnlinkIOSDeviceIDRequest request, Action<UnlinkIOSDeviceIDResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/UnlinkIOSDeviceID", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void UnlinkKongregate(UnlinkKongregateAccountRequest request, Action<UnlinkKongregateAccountResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/UnlinkKongregate", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void UnlinkNintendoSwitchDeviceId(UnlinkNintendoSwitchDeviceIdRequest request, Action<UnlinkNintendoSwitchDeviceIdResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/UnlinkNintendoSwitchDeviceId", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void UnlinkOpenIdConnect(UninkOpenIdConnectRequest request, Action<PlayFab.ClientModels.EmptyResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/UnlinkOpenIdConnect", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void UnlinkPSNAccount(UnlinkPSNAccountRequest request, Action<UnlinkPSNAccountResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/UnlinkPSNAccount", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void UnlinkSteamAccount(UnlinkSteamAccountRequest request, Action<UnlinkSteamAccountResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/UnlinkSteamAccount", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void UnlinkTwitch(UnlinkTwitchAccountRequest request, Action<UnlinkTwitchAccountResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/UnlinkTwitch", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void UnlinkWindowsHello(UnlinkWindowsHelloAccountRequest request, Action<UnlinkWindowsHelloAccountResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/UnlinkWindowsHello", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void UnlinkXboxAccount(UnlinkXboxAccountRequest request, Action<UnlinkXboxAccountResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/UnlinkXboxAccount", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void UnlockContainerInstance(UnlockContainerInstanceRequest request, Action<UnlockContainerItemResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/UnlockContainerInstance", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void UnlockContainerItem(UnlockContainerItemRequest request, Action<UnlockContainerItemResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/UnlockContainerItem", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void UpdateAvatarUrl(UpdateAvatarUrlRequest request, Action<PlayFab.ClientModels.EmptyResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/UpdateAvatarUrl", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void UpdateCharacterData(UpdateCharacterDataRequest request, Action<UpdateCharacterDataResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/UpdateCharacterData", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void UpdateCharacterStatistics(UpdateCharacterStatisticsRequest request, Action<UpdateCharacterStatisticsResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/UpdateCharacterStatistics", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void UpdatePlayerStatistics(UpdatePlayerStatisticsRequest request, Action<UpdatePlayerStatisticsResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/UpdatePlayerStatistics", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void UpdateSharedGroupData(UpdateSharedGroupDataRequest request, Action<UpdateSharedGroupDataResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/UpdateSharedGroupData", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void UpdateUserData(UpdateUserDataRequest request, Action<UpdateUserDataResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/UpdateUserData", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void UpdateUserPublisherData(UpdateUserDataRequest request, Action<UpdateUserDataResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/UpdateUserPublisherData", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void UpdateUserTitleDisplayName(UpdateUserTitleDisplayNameRequest request, Action<UpdateUserTitleDisplayNameResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/UpdateUserTitleDisplayName", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void ValidateAmazonIAPReceipt(ValidateAmazonReceiptRequest request, Action<ValidateAmazonReceiptResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/ValidateAmazonIAPReceipt", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void ValidateGooglePlayPurchase(ValidateGooglePlayPurchaseRequest request, Action<ValidateGooglePlayPurchaseResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/ValidateGooglePlayPurchase", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void ValidateIOSReceipt(ValidateIOSReceiptRequest request, Action<ValidateIOSReceiptResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/ValidateIOSReceipt", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void ValidateWindowsStoreReceipt(ValidateWindowsReceiptRequest request, Action<ValidateWindowsReceiptResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/ValidateWindowsStoreReceipt", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void WriteCharacterEvent(WriteClientCharacterEventRequest request, Action<WriteEventResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/WriteCharacterEvent", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void WritePlayerEvent(WriteClientPlayerEventRequest request, Action<WriteEventResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/WritePlayerEvent", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void WriteTitleEvent(WriteTitleEventRequest request, Action<WriteEventResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			if (string.IsNullOrEmpty(playFabAuthenticationContext.ClientSessionTicket))
			{
				throw new PlayFabException(PlayFabExceptionCode.NotLoggedIn, "Must be logged in to call this method");
			}
			PlayFabHttp.MakeApiCall("/Client/WriteTitleEvent", request, AuthType.LoginSession, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}
	}
	public static class PlayFabCloudScriptAPI
	{
		static PlayFabCloudScriptAPI()
		{
		}

		public static bool IsEntityLoggedIn()
		{
			return PlayFabSettings.staticPlayer.IsEntityLoggedIn();
		}

		public static void ForgetAllCredentials()
		{
			PlayFabSettings.staticPlayer.ForgetAllCredentials();
		}

		public static void ExecuteEntityCloudScript(ExecuteEntityCloudScriptRequest request, Action<PlayFab.CloudScriptModels.ExecuteCloudScriptResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			PlayFabHttp.MakeApiCall("/CloudScript/ExecuteEntityCloudScript", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}
	}
	public class PlayFabCloudScriptInstanceAPI : IPlayFabInstanceApi
	{
		public readonly PlayFabApiSettings apiSettings;

		public readonly PlayFabAuthenticationContext authenticationContext;

		public PlayFabCloudScriptInstanceAPI(PlayFabAuthenticationContext context)
		{
			if (context == null)
			{
				throw new PlayFabException(PlayFabExceptionCode.AuthContextRequired, "Context cannot be null, create a PlayFabAuthenticationContext for each player in advance, or call <PlayFabClientInstanceAPI>.GetAuthenticationContext()");
			}
			authenticationContext = context;
		}

		public PlayFabCloudScriptInstanceAPI(PlayFabApiSettings settings, PlayFabAuthenticationContext context)
		{
			if (context == null)
			{
				throw new PlayFabException(PlayFabExceptionCode.AuthContextRequired, "Context cannot be null, create a PlayFabAuthenticationContext for each player in advance, or call <PlayFabClientInstanceAPI>.GetAuthenticationContext()");
			}
			apiSettings = settings;
			authenticationContext = context;
		}

		public bool IsEntityLoggedIn()
		{
			if (authenticationContext != null)
			{
				return authenticationContext.IsEntityLoggedIn();
			}
			return false;
		}

		public void ForgetAllCredentials()
		{
			if (authenticationContext != null)
			{
				authenticationContext.ForgetAllCredentials();
			}
		}

		public void ExecuteEntityCloudScript(ExecuteEntityCloudScriptRequest request, Action<PlayFab.CloudScriptModels.ExecuteCloudScriptResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			PlayFabHttp.MakeApiCall("/CloudScript/ExecuteEntityCloudScript", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}
	}
	public static class PlayFabDataAPI
	{
		static PlayFabDataAPI()
		{
		}

		public static bool IsEntityLoggedIn()
		{
			return PlayFabSettings.staticPlayer.IsEntityLoggedIn();
		}

		public static void ForgetAllCredentials()
		{
			PlayFabSettings.staticPlayer.ForgetAllCredentials();
		}

		public static void AbortFileUploads(AbortFileUploadsRequest request, Action<AbortFileUploadsResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			PlayFabHttp.MakeApiCall("/File/AbortFileUploads", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void DeleteFiles(DeleteFilesRequest request, Action<DeleteFilesResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			PlayFabHttp.MakeApiCall("/File/DeleteFiles", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void FinalizeFileUploads(FinalizeFileUploadsRequest request, Action<FinalizeFileUploadsResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			PlayFabHttp.MakeApiCall("/File/FinalizeFileUploads", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void GetFiles(GetFilesRequest request, Action<GetFilesResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			PlayFabHttp.MakeApiCall("/File/GetFiles", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void GetObjects(GetObjectsRequest request, Action<GetObjectsResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			PlayFabHttp.MakeApiCall("/Object/GetObjects", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void InitiateFileUploads(InitiateFileUploadsRequest request, Action<InitiateFileUploadsResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			PlayFabHttp.MakeApiCall("/File/InitiateFileUploads", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void SetObjects(SetObjectsRequest request, Action<SetObjectsResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			PlayFabHttp.MakeApiCall("/Object/SetObjects", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}
	}
	public class PlayFabDataInstanceAPI : IPlayFabInstanceApi
	{
		public readonly PlayFabApiSettings apiSettings;

		public readonly PlayFabAuthenticationContext authenticationContext;

		public PlayFabDataInstanceAPI(PlayFabAuthenticationContext context)
		{
			if (context == null)
			{
				throw new PlayFabException(PlayFabExceptionCode.AuthContextRequired, "Context cannot be null, create a PlayFabAuthenticationContext for each player in advance, or call <PlayFabClientInstanceAPI>.GetAuthenticationContext()");
			}
			authenticationContext = context;
		}

		public PlayFabDataInstanceAPI(PlayFabApiSettings settings, PlayFabAuthenticationContext context)
		{
			if (context == null)
			{
				throw new PlayFabException(PlayFabExceptionCode.AuthContextRequired, "Context cannot be null, create a PlayFabAuthenticationContext for each player in advance, or call <PlayFabClientInstanceAPI>.GetAuthenticationContext()");
			}
			apiSettings = settings;
			authenticationContext = context;
		}

		public bool IsEntityLoggedIn()
		{
			if (authenticationContext != null)
			{
				return authenticationContext.IsEntityLoggedIn();
			}
			return false;
		}

		public void ForgetAllCredentials()
		{
			if (authenticationContext != null)
			{
				authenticationContext.ForgetAllCredentials();
			}
		}

		public void AbortFileUploads(AbortFileUploadsRequest request, Action<AbortFileUploadsResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			PlayFabHttp.MakeApiCall("/File/AbortFileUploads", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void DeleteFiles(DeleteFilesRequest request, Action<DeleteFilesResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			PlayFabHttp.MakeApiCall("/File/DeleteFiles", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void FinalizeFileUploads(FinalizeFileUploadsRequest request, Action<FinalizeFileUploadsResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			PlayFabHttp.MakeApiCall("/File/FinalizeFileUploads", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void GetFiles(GetFilesRequest request, Action<GetFilesResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			PlayFabHttp.MakeApiCall("/File/GetFiles", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void GetObjects(GetObjectsRequest request, Action<GetObjectsResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			PlayFabHttp.MakeApiCall("/Object/GetObjects", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void InitiateFileUploads(InitiateFileUploadsRequest request, Action<InitiateFileUploadsResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			PlayFabHttp.MakeApiCall("/File/InitiateFileUploads", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void SetObjects(SetObjectsRequest request, Action<SetObjectsResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			PlayFabHttp.MakeApiCall("/Object/SetObjects", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}
	}
	public static class PlayFabEventsAPI
	{
		static PlayFabEventsAPI()
		{
		}

		public static bool IsEntityLoggedIn()
		{
			return PlayFabSettings.staticPlayer.IsEntityLoggedIn();
		}

		public static void ForgetAllCredentials()
		{
			PlayFabSettings.staticPlayer.ForgetAllCredentials();
		}

		public static void WriteEvents(WriteEventsRequest request, Action<WriteEventsResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			PlayFabHttp.MakeApiCall("/Event/WriteEvents", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void WriteTelemetryEvents(WriteEventsRequest request, Action<WriteEventsResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			PlayFabHttp.MakeApiCall("/Event/WriteTelemetryEvents", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}
	}
	public class PlayFabEventsInstanceAPI : IPlayFabInstanceApi
	{
		public readonly PlayFabApiSettings apiSettings;

		public readonly PlayFabAuthenticationContext authenticationContext;

		public PlayFabEventsInstanceAPI(PlayFabAuthenticationContext context)
		{
			if (context == null)
			{
				throw new PlayFabException(PlayFabExceptionCode.AuthContextRequired, "Context cannot be null, create a PlayFabAuthenticationContext for each player in advance, or call <PlayFabClientInstanceAPI>.GetAuthenticationContext()");
			}
			authenticationContext = context;
		}

		public PlayFabEventsInstanceAPI(PlayFabApiSettings settings, PlayFabAuthenticationContext context)
		{
			if (context == null)
			{
				throw new PlayFabException(PlayFabExceptionCode.AuthContextRequired, "Context cannot be null, create a PlayFabAuthenticationContext for each player in advance, or call <PlayFabClientInstanceAPI>.GetAuthenticationContext()");
			}
			apiSettings = settings;
			authenticationContext = context;
		}

		public bool IsEntityLoggedIn()
		{
			if (authenticationContext != null)
			{
				return authenticationContext.IsEntityLoggedIn();
			}
			return false;
		}

		public void ForgetAllCredentials()
		{
			if (authenticationContext != null)
			{
				authenticationContext.ForgetAllCredentials();
			}
		}

		public void WriteEvents(WriteEventsRequest request, Action<WriteEventsResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			PlayFabHttp.MakeApiCall("/Event/WriteEvents", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void WriteTelemetryEvents(WriteEventsRequest request, Action<WriteEventsResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			PlayFabHttp.MakeApiCall("/Event/WriteTelemetryEvents", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}
	}
	public static class PlayFabGroupsAPI
	{
		static PlayFabGroupsAPI()
		{
		}

		public static bool IsEntityLoggedIn()
		{
			return PlayFabSettings.staticPlayer.IsEntityLoggedIn();
		}

		public static void ForgetAllCredentials()
		{
			PlayFabSettings.staticPlayer.ForgetAllCredentials();
		}

		public static void AcceptGroupApplication(AcceptGroupApplicationRequest request, Action<PlayFab.GroupsModels.EmptyResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			PlayFabHttp.MakeApiCall("/Group/AcceptGroupApplication", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void AcceptGroupInvitation(AcceptGroupInvitationRequest request, Action<PlayFab.GroupsModels.EmptyResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			PlayFabHttp.MakeApiCall("/Group/AcceptGroupInvitation", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void AddMembers(AddMembersRequest request, Action<PlayFab.GroupsModels.EmptyResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			PlayFabHttp.MakeApiCall("/Group/AddMembers", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void ApplyToGroup(ApplyToGroupRequest request, Action<ApplyToGroupResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			PlayFabHttp.MakeApiCall("/Group/ApplyToGroup", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void BlockEntity(BlockEntityRequest request, Action<PlayFab.GroupsModels.EmptyResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			PlayFabHttp.MakeApiCall("/Group/BlockEntity", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void ChangeMemberRole(ChangeMemberRoleRequest request, Action<PlayFab.GroupsModels.EmptyResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			PlayFabHttp.MakeApiCall("/Group/ChangeMemberRole", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void CreateGroup(CreateGroupRequest request, Action<CreateGroupResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			PlayFabHttp.MakeApiCall("/Group/CreateGroup", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void CreateRole(CreateGroupRoleRequest request, Action<CreateGroupRoleResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			PlayFabHttp.MakeApiCall("/Group/CreateRole", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void DeleteGroup(DeleteGroupRequest request, Action<PlayFab.GroupsModels.EmptyResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			PlayFabHttp.MakeApiCall("/Group/DeleteGroup", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void DeleteRole(DeleteRoleRequest request, Action<PlayFab.GroupsModels.EmptyResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			PlayFabHttp.MakeApiCall("/Group/DeleteRole", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void GetGroup(GetGroupRequest request, Action<GetGroupResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			PlayFabHttp.MakeApiCall("/Group/GetGroup", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void InviteToGroup(InviteToGroupRequest request, Action<InviteToGroupResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			PlayFabHttp.MakeApiCall("/Group/InviteToGroup", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void IsMember(IsMemberRequest request, Action<IsMemberResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			PlayFabHttp.MakeApiCall("/Group/IsMember", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void ListGroupApplications(ListGroupApplicationsRequest request, Action<ListGroupApplicationsResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			PlayFabHttp.MakeApiCall("/Group/ListGroupApplications", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void ListGroupBlocks(ListGroupBlocksRequest request, Action<ListGroupBlocksResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			PlayFabHttp.MakeApiCall("/Group/ListGroupBlocks", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void ListGroupInvitations(ListGroupInvitationsRequest request, Action<ListGroupInvitationsResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			PlayFabHttp.MakeApiCall("/Group/ListGroupInvitations", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void ListGroupMembers(ListGroupMembersRequest request, Action<ListGroupMembersResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			PlayFabHttp.MakeApiCall("/Group/ListGroupMembers", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void ListMembership(ListMembershipRequest request, Action<ListMembershipResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			PlayFabHttp.MakeApiCall("/Group/ListMembership", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void ListMembershipOpportunities(ListMembershipOpportunitiesRequest request, Action<ListMembershipOpportunitiesResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			PlayFabHttp.MakeApiCall("/Group/ListMembershipOpportunities", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void RemoveGroupApplication(RemoveGroupApplicationRequest request, Action<PlayFab.GroupsModels.EmptyResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			PlayFabHttp.MakeApiCall("/Group/RemoveGroupApplication", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void RemoveGroupInvitation(RemoveGroupInvitationRequest request, Action<PlayFab.GroupsModels.EmptyResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			PlayFabHttp.MakeApiCall("/Group/RemoveGroupInvitation", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void RemoveMembers(RemoveMembersRequest request, Action<PlayFab.GroupsModels.EmptyResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			PlayFabHttp.MakeApiCall("/Group/RemoveMembers", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void UnblockEntity(UnblockEntityRequest request, Action<PlayFab.GroupsModels.EmptyResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			PlayFabHttp.MakeApiCall("/Group/UnblockEntity", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void UpdateGroup(UpdateGroupRequest request, Action<UpdateGroupResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			PlayFabHttp.MakeApiCall("/Group/UpdateGroup", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void UpdateRole(UpdateGroupRoleRequest request, Action<UpdateGroupRoleResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			PlayFabHttp.MakeApiCall("/Group/UpdateRole", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}
	}
	public class PlayFabGroupsInstanceAPI : IPlayFabInstanceApi
	{
		public readonly PlayFabApiSettings apiSettings;

		public readonly PlayFabAuthenticationContext authenticationContext;

		public PlayFabGroupsInstanceAPI(PlayFabAuthenticationContext context)
		{
			if (context == null)
			{
				throw new PlayFabException(PlayFabExceptionCode.AuthContextRequired, "Context cannot be null, create a PlayFabAuthenticationContext for each player in advance, or call <PlayFabClientInstanceAPI>.GetAuthenticationContext()");
			}
			authenticationContext = context;
		}

		public PlayFabGroupsInstanceAPI(PlayFabApiSettings settings, PlayFabAuthenticationContext context)
		{
			if (context == null)
			{
				throw new PlayFabException(PlayFabExceptionCode.AuthContextRequired, "Context cannot be null, create a PlayFabAuthenticationContext for each player in advance, or call <PlayFabClientInstanceAPI>.GetAuthenticationContext()");
			}
			apiSettings = settings;
			authenticationContext = context;
		}

		public bool IsEntityLoggedIn()
		{
			if (authenticationContext != null)
			{
				return authenticationContext.IsEntityLoggedIn();
			}
			return false;
		}

		public void ForgetAllCredentials()
		{
			if (authenticationContext != null)
			{
				authenticationContext.ForgetAllCredentials();
			}
		}

		public void AcceptGroupApplication(AcceptGroupApplicationRequest request, Action<PlayFab.GroupsModels.EmptyResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			PlayFabHttp.MakeApiCall("/Group/AcceptGroupApplication", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void AcceptGroupInvitation(AcceptGroupInvitationRequest request, Action<PlayFab.GroupsModels.EmptyResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			PlayFabHttp.MakeApiCall("/Group/AcceptGroupInvitation", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void AddMembers(AddMembersRequest request, Action<PlayFab.GroupsModels.EmptyResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			PlayFabHttp.MakeApiCall("/Group/AddMembers", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void ApplyToGroup(ApplyToGroupRequest request, Action<ApplyToGroupResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			PlayFabHttp.MakeApiCall("/Group/ApplyToGroup", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void BlockEntity(BlockEntityRequest request, Action<PlayFab.GroupsModels.EmptyResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			PlayFabHttp.MakeApiCall("/Group/BlockEntity", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void ChangeMemberRole(ChangeMemberRoleRequest request, Action<PlayFab.GroupsModels.EmptyResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			PlayFabHttp.MakeApiCall("/Group/ChangeMemberRole", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void CreateGroup(CreateGroupRequest request, Action<CreateGroupResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			PlayFabHttp.MakeApiCall("/Group/CreateGroup", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void CreateRole(CreateGroupRoleRequest request, Action<CreateGroupRoleResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			PlayFabHttp.MakeApiCall("/Group/CreateRole", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void DeleteGroup(DeleteGroupRequest request, Action<PlayFab.GroupsModels.EmptyResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			PlayFabHttp.MakeApiCall("/Group/DeleteGroup", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void DeleteRole(DeleteRoleRequest request, Action<PlayFab.GroupsModels.EmptyResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			PlayFabHttp.MakeApiCall("/Group/DeleteRole", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void GetGroup(GetGroupRequest request, Action<GetGroupResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			PlayFabHttp.MakeApiCall("/Group/GetGroup", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void InviteToGroup(InviteToGroupRequest request, Action<InviteToGroupResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			PlayFabHttp.MakeApiCall("/Group/InviteToGroup", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void IsMember(IsMemberRequest request, Action<IsMemberResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			PlayFabHttp.MakeApiCall("/Group/IsMember", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void ListGroupApplications(ListGroupApplicationsRequest request, Action<ListGroupApplicationsResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			PlayFabHttp.MakeApiCall("/Group/ListGroupApplications", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void ListGroupBlocks(ListGroupBlocksRequest request, Action<ListGroupBlocksResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			PlayFabHttp.MakeApiCall("/Group/ListGroupBlocks", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void ListGroupInvitations(ListGroupInvitationsRequest request, Action<ListGroupInvitationsResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			PlayFabHttp.MakeApiCall("/Group/ListGroupInvitations", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void ListGroupMembers(ListGroupMembersRequest request, Action<ListGroupMembersResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			PlayFabHttp.MakeApiCall("/Group/ListGroupMembers", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void ListMembership(ListMembershipRequest request, Action<ListMembershipResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			PlayFabHttp.MakeApiCall("/Group/ListMembership", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void ListMembershipOpportunities(ListMembershipOpportunitiesRequest request, Action<ListMembershipOpportunitiesResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			PlayFabHttp.MakeApiCall("/Group/ListMembershipOpportunities", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void RemoveGroupApplication(RemoveGroupApplicationRequest request, Action<PlayFab.GroupsModels.EmptyResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			PlayFabHttp.MakeApiCall("/Group/RemoveGroupApplication", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void RemoveGroupInvitation(RemoveGroupInvitationRequest request, Action<PlayFab.GroupsModels.EmptyResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			PlayFabHttp.MakeApiCall("/Group/RemoveGroupInvitation", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void RemoveMembers(RemoveMembersRequest request, Action<PlayFab.GroupsModels.EmptyResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			PlayFabHttp.MakeApiCall("/Group/RemoveMembers", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void UnblockEntity(UnblockEntityRequest request, Action<PlayFab.GroupsModels.EmptyResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			PlayFabHttp.MakeApiCall("/Group/UnblockEntity", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void UpdateGroup(UpdateGroupRequest request, Action<UpdateGroupResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			PlayFabHttp.MakeApiCall("/Group/UpdateGroup", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void UpdateRole(UpdateGroupRoleRequest request, Action<UpdateGroupRoleResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			PlayFabHttp.MakeApiCall("/Group/UpdateRole", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}
	}
	public static class PlayFabLocalizationAPI
	{
		static PlayFabLocalizationAPI()
		{
		}

		public static bool IsEntityLoggedIn()
		{
			return PlayFabSettings.staticPlayer.IsEntityLoggedIn();
		}

		public static void ForgetAllCredentials()
		{
			PlayFabSettings.staticPlayer.ForgetAllCredentials();
		}

		public static void GetLanguageList(GetLanguageListRequest request, Action<GetLanguageListResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			PlayFabHttp.MakeApiCall("/Locale/GetLanguageList", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}
	}
	public class PlayFabLocalizationInstanceAPI : IPlayFabInstanceApi
	{
		public readonly PlayFabApiSettings apiSettings;

		public readonly PlayFabAuthenticationContext authenticationContext;

		public PlayFabLocalizationInstanceAPI(PlayFabAuthenticationContext context)
		{
			if (context == null)
			{
				throw new PlayFabException(PlayFabExceptionCode.AuthContextRequired, "Context cannot be null, create a PlayFabAuthenticationContext for each player in advance, or call <PlayFabClientInstanceAPI>.GetAuthenticationContext()");
			}
			authenticationContext = context;
		}

		public PlayFabLocalizationInstanceAPI(PlayFabApiSettings settings, PlayFabAuthenticationContext context)
		{
			if (context == null)
			{
				throw new PlayFabException(PlayFabExceptionCode.AuthContextRequired, "Context cannot be null, create a PlayFabAuthenticationContext for each player in advance, or call <PlayFabClientInstanceAPI>.GetAuthenticationContext()");
			}
			apiSettings = settings;
			authenticationContext = context;
		}

		public bool IsEntityLoggedIn()
		{
			if (authenticationContext != null)
			{
				return authenticationContext.IsEntityLoggedIn();
			}
			return false;
		}

		public void ForgetAllCredentials()
		{
			if (authenticationContext != null)
			{
				authenticationContext.ForgetAllCredentials();
			}
		}

		public void GetLanguageList(GetLanguageListRequest request, Action<GetLanguageListResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			PlayFabHttp.MakeApiCall("/Locale/GetLanguageList", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}
	}
	public static class PlayFabMultiplayerAPI
	{
		static PlayFabMultiplayerAPI()
		{
		}

		public static bool IsEntityLoggedIn()
		{
			return PlayFabSettings.staticPlayer.IsEntityLoggedIn();
		}

		public static void ForgetAllCredentials()
		{
			PlayFabSettings.staticPlayer.ForgetAllCredentials();
		}

		public static void CancelAllMatchmakingTicketsForPlayer(CancelAllMatchmakingTicketsForPlayerRequest request, Action<CancelAllMatchmakingTicketsForPlayerResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			PlayFabHttp.MakeApiCall("/Match/CancelAllMatchmakingTicketsForPlayer", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void CancelMatchmakingTicket(CancelMatchmakingTicketRequest request, Action<CancelMatchmakingTicketResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			PlayFabHttp.MakeApiCall("/Match/CancelMatchmakingTicket", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void CreateBuildWithCustomContainer(CreateBuildWithCustomContainerRequest request, Action<CreateBuildWithCustomContainerResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			PlayFabHttp.MakeApiCall("/MultiplayerServer/CreateBuildWithCustomContainer", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void CreateBuildWithManagedContainer(CreateBuildWithManagedContainerRequest request, Action<CreateBuildWithManagedContainerResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			PlayFabHttp.MakeApiCall("/MultiplayerServer/CreateBuildWithManagedContainer", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void CreateMatchmakingTicket(CreateMatchmakingTicketRequest request, Action<CreateMatchmakingTicketResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			PlayFabHttp.MakeApiCall("/Match/CreateMatchmakingTicket", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void CreateRemoteUser(CreateRemoteUserRequest request, Action<CreateRemoteUserResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			PlayFabHttp.MakeApiCall("/MultiplayerServer/CreateRemoteUser", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void CreateServerMatchmakingTicket(CreateServerMatchmakingTicketRequest request, Action<CreateMatchmakingTicketResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			PlayFabHttp.MakeApiCall("/Match/CreateServerMatchmakingTicket", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void DeleteAsset(DeleteAssetRequest request, Action<PlayFab.MultiplayerModels.EmptyResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			PlayFabHttp.MakeApiCall("/MultiplayerServer/DeleteAsset", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void DeleteBuild(DeleteBuildRequest request, Action<PlayFab.MultiplayerModels.EmptyResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			PlayFabHttp.MakeApiCall("/MultiplayerServer/DeleteBuild", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void DeleteCertificate(DeleteCertificateRequest request, Action<PlayFab.MultiplayerModels.EmptyResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			PlayFabHttp.MakeApiCall("/MultiplayerServer/DeleteCertificate", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void DeleteRemoteUser(DeleteRemoteUserRequest request, Action<PlayFab.MultiplayerModels.EmptyResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			PlayFabHttp.MakeApiCall("/MultiplayerServer/DeleteRemoteUser", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void EnableMultiplayerServersForTitle(EnableMultiplayerServersForTitleRequest request, Action<EnableMultiplayerServersForTitleResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			PlayFabHttp.MakeApiCall("/MultiplayerServer/EnableMultiplayerServersForTitle", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void GetAssetUploadUrl(GetAssetUploadUrlRequest request, Action<GetAssetUploadUrlResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			PlayFabHttp.MakeApiCall("/MultiplayerServer/GetAssetUploadUrl", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void GetBuild(GetBuildRequest request, Action<GetBuildResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			PlayFabHttp.MakeApiCall("/MultiplayerServer/GetBuild", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void GetContainerRegistryCredentials(GetContainerRegistryCredentialsRequest request, Action<GetContainerRegistryCredentialsResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			PlayFabHttp.MakeApiCall("/MultiplayerServer/GetContainerRegistryCredentials", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void GetMatch(GetMatchRequest request, Action<GetMatchResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			PlayFabHttp.MakeApiCall("/Match/GetMatch", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void GetMatchmakingTicket(GetMatchmakingTicketRequest request, Action<GetMatchmakingTicketResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			PlayFabHttp.MakeApiCall("/Match/GetMatchmakingTicket", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void GetMultiplayerServerDetails(GetMultiplayerServerDetailsRequest request, Action<GetMultiplayerServerDetailsResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			PlayFabHttp.MakeApiCall("/MultiplayerServer/GetMultiplayerServerDetails", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void GetQueueStatistics(GetQueueStatisticsRequest request, Action<GetQueueStatisticsResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			PlayFabHttp.MakeApiCall("/Match/GetQueueStatistics", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void GetRemoteLoginEndpoint(GetRemoteLoginEndpointRequest request, Action<GetRemoteLoginEndpointResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			PlayFabHttp.MakeApiCall("/MultiplayerServer/GetRemoteLoginEndpoint", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void GetTitleEnabledForMultiplayerServersStatus(GetTitleEnabledForMultiplayerServersStatusRequest request, Action<GetTitleEnabledForMultiplayerServersStatusResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			PlayFabHttp.MakeApiCall("/MultiplayerServer/GetTitleEnabledForMultiplayerServersStatus", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void GetTitleMultiplayerServersQuotas(GetTitleMultiplayerServersQuotasRequest request, Action<GetTitleMultiplayerServersQuotasResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			PlayFabHttp.MakeApiCall("/MultiplayerServer/GetTitleMultiplayerServersQuotas", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void JoinMatchmakingTicket(JoinMatchmakingTicketRequest request, Action<JoinMatchmakingTicketResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			PlayFabHttp.MakeApiCall("/Match/JoinMatchmakingTicket", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void ListArchivedMultiplayerServers(ListMultiplayerServersRequest request, Action<ListMultiplayerServersResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			PlayFabHttp.MakeApiCall("/MultiplayerServer/ListArchivedMultiplayerServers", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void ListAssetSummaries(ListAssetSummariesRequest request, Action<ListAssetSummariesResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			PlayFabHttp.MakeApiCall("/MultiplayerServer/ListAssetSummaries", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void ListBuildSummaries(ListBuildSummariesRequest request, Action<ListBuildSummariesResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			PlayFabHttp.MakeApiCall("/MultiplayerServer/ListBuildSummaries", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void ListCertificateSummaries(ListCertificateSummariesRequest request, Action<ListCertificateSummariesResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			PlayFabHttp.MakeApiCall("/MultiplayerServer/ListCertificateSummaries", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void ListContainerImages(ListContainerImagesRequest request, Action<ListContainerImagesResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			PlayFabHttp.MakeApiCall("/MultiplayerServer/ListContainerImages", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void ListContainerImageTags(ListContainerImageTagsRequest request, Action<ListContainerImageTagsResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			PlayFabHttp.MakeApiCall("/MultiplayerServer/ListContainerImageTags", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void ListMatchmakingTicketsForPlayer(ListMatchmakingTicketsForPlayerRequest request, Action<ListMatchmakingTicketsForPlayerResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			PlayFabHttp.MakeApiCall("/Match/ListMatchmakingTicketsForPlayer", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void ListMultiplayerServers(ListMultiplayerServersRequest request, Action<ListMultiplayerServersResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			PlayFabHttp.MakeApiCall("/MultiplayerServer/ListMultiplayerServers", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void ListPartyQosServers(ListPartyQosServersRequest request, Action<ListPartyQosServersResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			PlayFabHttp.MakeApiCall("/MultiplayerServer/ListPartyQosServers", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void ListQosServers(ListQosServersRequest request, Action<ListQosServersResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			PlayFabHttp.MakeApiCall("/MultiplayerServer/ListQosServers", request, AuthType.None, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void ListQosServersForTitle(ListQosServersForTitleRequest request, Action<ListQosServersForTitleResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			PlayFabHttp.MakeApiCall("/MultiplayerServer/ListQosServersForTitle", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void ListVirtualMachineSummaries(ListVirtualMachineSummariesRequest request, Action<ListVirtualMachineSummariesResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			PlayFabHttp.MakeApiCall("/MultiplayerServer/ListVirtualMachineSummaries", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void RequestMultiplayerServer(RequestMultiplayerServerRequest request, Action<RequestMultiplayerServerResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			PlayFabHttp.MakeApiCall("/MultiplayerServer/RequestMultiplayerServer", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void RolloverContainerRegistryCredentials(RolloverContainerRegistryCredentialsRequest request, Action<RolloverContainerRegistryCredentialsResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			PlayFabHttp.MakeApiCall("/MultiplayerServer/RolloverContainerRegistryCredentials", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void ShutdownMultiplayerServer(ShutdownMultiplayerServerRequest request, Action<PlayFab.MultiplayerModels.EmptyResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			PlayFabHttp.MakeApiCall("/MultiplayerServer/ShutdownMultiplayerServer", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void UpdateBuildRegions(UpdateBuildRegionsRequest request, Action<PlayFab.MultiplayerModels.EmptyResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			PlayFabHttp.MakeApiCall("/MultiplayerServer/UpdateBuildRegions", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void UploadCertificate(UploadCertificateRequest request, Action<PlayFab.MultiplayerModels.EmptyResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			PlayFabHttp.MakeApiCall("/MultiplayerServer/UploadCertificate", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}
	}
	public class PlayFabMultiplayerInstanceAPI : IPlayFabInstanceApi
	{
		public readonly PlayFabApiSettings apiSettings;

		public readonly PlayFabAuthenticationContext authenticationContext;

		public PlayFabMultiplayerInstanceAPI(PlayFabAuthenticationContext context)
		{
			if (context == null)
			{
				throw new PlayFabException(PlayFabExceptionCode.AuthContextRequired, "Context cannot be null, create a PlayFabAuthenticationContext for each player in advance, or call <PlayFabClientInstanceAPI>.GetAuthenticationContext()");
			}
			authenticationContext = context;
		}

		public PlayFabMultiplayerInstanceAPI(PlayFabApiSettings settings, PlayFabAuthenticationContext context)
		{
			if (context == null)
			{
				throw new PlayFabException(PlayFabExceptionCode.AuthContextRequired, "Context cannot be null, create a PlayFabAuthenticationContext for each player in advance, or call <PlayFabClientInstanceAPI>.GetAuthenticationContext()");
			}
			apiSettings = settings;
			authenticationContext = context;
		}

		public bool IsEntityLoggedIn()
		{
			if (authenticationContext != null)
			{
				return authenticationContext.IsEntityLoggedIn();
			}
			return false;
		}

		public void ForgetAllCredentials()
		{
			if (authenticationContext != null)
			{
				authenticationContext.ForgetAllCredentials();
			}
		}

		public void CancelAllMatchmakingTicketsForPlayer(CancelAllMatchmakingTicketsForPlayerRequest request, Action<CancelAllMatchmakingTicketsForPlayerResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			PlayFabHttp.MakeApiCall("/Match/CancelAllMatchmakingTicketsForPlayer", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void CancelMatchmakingTicket(CancelMatchmakingTicketRequest request, Action<CancelMatchmakingTicketResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			PlayFabHttp.MakeApiCall("/Match/CancelMatchmakingTicket", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void CreateBuildWithCustomContainer(CreateBuildWithCustomContainerRequest request, Action<CreateBuildWithCustomContainerResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			PlayFabHttp.MakeApiCall("/MultiplayerServer/CreateBuildWithCustomContainer", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void CreateBuildWithManagedContainer(CreateBuildWithManagedContainerRequest request, Action<CreateBuildWithManagedContainerResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			PlayFabHttp.MakeApiCall("/MultiplayerServer/CreateBuildWithManagedContainer", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void CreateMatchmakingTicket(CreateMatchmakingTicketRequest request, Action<CreateMatchmakingTicketResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			PlayFabHttp.MakeApiCall("/Match/CreateMatchmakingTicket", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void CreateRemoteUser(CreateRemoteUserRequest request, Action<CreateRemoteUserResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			PlayFabHttp.MakeApiCall("/MultiplayerServer/CreateRemoteUser", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void CreateServerMatchmakingTicket(CreateServerMatchmakingTicketRequest request, Action<CreateMatchmakingTicketResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			PlayFabHttp.MakeApiCall("/Match/CreateServerMatchmakingTicket", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void DeleteAsset(DeleteAssetRequest request, Action<PlayFab.MultiplayerModels.EmptyResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			PlayFabHttp.MakeApiCall("/MultiplayerServer/DeleteAsset", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void DeleteBuild(DeleteBuildRequest request, Action<PlayFab.MultiplayerModels.EmptyResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			PlayFabHttp.MakeApiCall("/MultiplayerServer/DeleteBuild", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void DeleteCertificate(DeleteCertificateRequest request, Action<PlayFab.MultiplayerModels.EmptyResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			PlayFabHttp.MakeApiCall("/MultiplayerServer/DeleteCertificate", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void DeleteRemoteUser(DeleteRemoteUserRequest request, Action<PlayFab.MultiplayerModels.EmptyResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			PlayFabHttp.MakeApiCall("/MultiplayerServer/DeleteRemoteUser", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void EnableMultiplayerServersForTitle(EnableMultiplayerServersForTitleRequest request, Action<EnableMultiplayerServersForTitleResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			PlayFabHttp.MakeApiCall("/MultiplayerServer/EnableMultiplayerServersForTitle", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void GetAssetUploadUrl(GetAssetUploadUrlRequest request, Action<GetAssetUploadUrlResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			PlayFabHttp.MakeApiCall("/MultiplayerServer/GetAssetUploadUrl", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void GetBuild(GetBuildRequest request, Action<GetBuildResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			PlayFabHttp.MakeApiCall("/MultiplayerServer/GetBuild", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void GetContainerRegistryCredentials(GetContainerRegistryCredentialsRequest request, Action<GetContainerRegistryCredentialsResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			PlayFabHttp.MakeApiCall("/MultiplayerServer/GetContainerRegistryCredentials", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void GetMatch(GetMatchRequest request, Action<GetMatchResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			PlayFabHttp.MakeApiCall("/Match/GetMatch", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void GetMatchmakingTicket(GetMatchmakingTicketRequest request, Action<GetMatchmakingTicketResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			PlayFabHttp.MakeApiCall("/Match/GetMatchmakingTicket", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void GetMultiplayerServerDetails(GetMultiplayerServerDetailsRequest request, Action<GetMultiplayerServerDetailsResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			PlayFabHttp.MakeApiCall("/MultiplayerServer/GetMultiplayerServerDetails", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void GetQueueStatistics(GetQueueStatisticsRequest request, Action<GetQueueStatisticsResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			PlayFabHttp.MakeApiCall("/Match/GetQueueStatistics", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void GetRemoteLoginEndpoint(GetRemoteLoginEndpointRequest request, Action<GetRemoteLoginEndpointResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			PlayFabHttp.MakeApiCall("/MultiplayerServer/GetRemoteLoginEndpoint", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void GetTitleEnabledForMultiplayerServersStatus(GetTitleEnabledForMultiplayerServersStatusRequest request, Action<GetTitleEnabledForMultiplayerServersStatusResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			PlayFabHttp.MakeApiCall("/MultiplayerServer/GetTitleEnabledForMultiplayerServersStatus", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void GetTitleMultiplayerServersQuotas(GetTitleMultiplayerServersQuotasRequest request, Action<GetTitleMultiplayerServersQuotasResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			PlayFabHttp.MakeApiCall("/MultiplayerServer/GetTitleMultiplayerServersQuotas", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void JoinMatchmakingTicket(JoinMatchmakingTicketRequest request, Action<JoinMatchmakingTicketResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			PlayFabHttp.MakeApiCall("/Match/JoinMatchmakingTicket", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void ListArchivedMultiplayerServers(ListMultiplayerServersRequest request, Action<ListMultiplayerServersResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			PlayFabHttp.MakeApiCall("/MultiplayerServer/ListArchivedMultiplayerServers", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void ListAssetSummaries(ListAssetSummariesRequest request, Action<ListAssetSummariesResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			PlayFabHttp.MakeApiCall("/MultiplayerServer/ListAssetSummaries", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void ListBuildSummaries(ListBuildSummariesRequest request, Action<ListBuildSummariesResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			PlayFabHttp.MakeApiCall("/MultiplayerServer/ListBuildSummaries", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void ListCertificateSummaries(ListCertificateSummariesRequest request, Action<ListCertificateSummariesResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			PlayFabHttp.MakeApiCall("/MultiplayerServer/ListCertificateSummaries", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void ListContainerImages(ListContainerImagesRequest request, Action<ListContainerImagesResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			PlayFabHttp.MakeApiCall("/MultiplayerServer/ListContainerImages", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void ListContainerImageTags(ListContainerImageTagsRequest request, Action<ListContainerImageTagsResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			PlayFabHttp.MakeApiCall("/MultiplayerServer/ListContainerImageTags", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void ListMatchmakingTicketsForPlayer(ListMatchmakingTicketsForPlayerRequest request, Action<ListMatchmakingTicketsForPlayerResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			PlayFabHttp.MakeApiCall("/Match/ListMatchmakingTicketsForPlayer", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void ListMultiplayerServers(ListMultiplayerServersRequest request, Action<ListMultiplayerServersResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			PlayFabHttp.MakeApiCall("/MultiplayerServer/ListMultiplayerServers", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void ListPartyQosServers(ListPartyQosServersRequest request, Action<ListPartyQosServersResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			PlayFabHttp.MakeApiCall("/MultiplayerServer/ListPartyQosServers", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void ListQosServers(ListQosServersRequest request, Action<ListQosServersResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			PlayFabHttp.MakeApiCall("/MultiplayerServer/ListQosServers", request, AuthType.None, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void ListQosServersForTitle(ListQosServersForTitleRequest request, Action<ListQosServersForTitleResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			PlayFabHttp.MakeApiCall("/MultiplayerServer/ListQosServersForTitle", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void ListVirtualMachineSummaries(ListVirtualMachineSummariesRequest request, Action<ListVirtualMachineSummariesResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			PlayFabHttp.MakeApiCall("/MultiplayerServer/ListVirtualMachineSummaries", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void RequestMultiplayerServer(RequestMultiplayerServerRequest request, Action<RequestMultiplayerServerResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			PlayFabHttp.MakeApiCall("/MultiplayerServer/RequestMultiplayerServer", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void RolloverContainerRegistryCredentials(RolloverContainerRegistryCredentialsRequest request, Action<RolloverContainerRegistryCredentialsResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			PlayFabHttp.MakeApiCall("/MultiplayerServer/RolloverContainerRegistryCredentials", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void ShutdownMultiplayerServer(ShutdownMultiplayerServerRequest request, Action<PlayFab.MultiplayerModels.EmptyResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			PlayFabHttp.MakeApiCall("/MultiplayerServer/ShutdownMultiplayerServer", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void UpdateBuildRegions(UpdateBuildRegionsRequest request, Action<PlayFab.MultiplayerModels.EmptyResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			PlayFabHttp.MakeApiCall("/MultiplayerServer/UpdateBuildRegions", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void UploadCertificate(UploadCertificateRequest request, Action<PlayFab.MultiplayerModels.EmptyResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			PlayFabHttp.MakeApiCall("/MultiplayerServer/UploadCertificate", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}
	}
	public static class PlayFabProfilesAPI
	{
		static PlayFabProfilesAPI()
		{
		}

		public static bool IsEntityLoggedIn()
		{
			return PlayFabSettings.staticPlayer.IsEntityLoggedIn();
		}

		public static void ForgetAllCredentials()
		{
			PlayFabSettings.staticPlayer.ForgetAllCredentials();
		}

		public static void GetGlobalPolicy(GetGlobalPolicyRequest request, Action<GetGlobalPolicyResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			PlayFabHttp.MakeApiCall("/Profile/GetGlobalPolicy", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void GetProfile(GetEntityProfileRequest request, Action<GetEntityProfileResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			PlayFabHttp.MakeApiCall("/Profile/GetProfile", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void GetProfiles(GetEntityProfilesRequest request, Action<GetEntityProfilesResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			PlayFabHttp.MakeApiCall("/Profile/GetProfiles", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void GetTitlePlayersFromMasterPlayerAccountIds(GetTitlePlayersFromMasterPlayerAccountIdsRequest request, Action<GetTitlePlayersFromMasterPlayerAccountIdsResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			PlayFabHttp.MakeApiCall("/Profile/GetTitlePlayersFromMasterPlayerAccountIds", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void SetGlobalPolicy(SetGlobalPolicyRequest request, Action<SetGlobalPolicyResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			PlayFabHttp.MakeApiCall("/Profile/SetGlobalPolicy", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void SetProfileLanguage(SetProfileLanguageRequest request, Action<SetProfileLanguageResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			PlayFabHttp.MakeApiCall("/Profile/SetProfileLanguage", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}

		public static void SetProfilePolicy(SetEntityProfilePolicyRequest request, Action<SetEntityProfilePolicyResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext authenticationContext = request?.AuthenticationContext ?? PlayFabSettings.staticPlayer;
			PlayFabHttp.MakeApiCall("/Profile/SetProfilePolicy", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, authenticationContext);
		}
	}
	public class PlayFabProfilesInstanceAPI : IPlayFabInstanceApi
	{
		public readonly PlayFabApiSettings apiSettings;

		public readonly PlayFabAuthenticationContext authenticationContext;

		public PlayFabProfilesInstanceAPI(PlayFabAuthenticationContext context)
		{
			if (context == null)
			{
				throw new PlayFabException(PlayFabExceptionCode.AuthContextRequired, "Context cannot be null, create a PlayFabAuthenticationContext for each player in advance, or call <PlayFabClientInstanceAPI>.GetAuthenticationContext()");
			}
			authenticationContext = context;
		}

		public PlayFabProfilesInstanceAPI(PlayFabApiSettings settings, PlayFabAuthenticationContext context)
		{
			if (context == null)
			{
				throw new PlayFabException(PlayFabExceptionCode.AuthContextRequired, "Context cannot be null, create a PlayFabAuthenticationContext for each player in advance, or call <PlayFabClientInstanceAPI>.GetAuthenticationContext()");
			}
			apiSettings = settings;
			authenticationContext = context;
		}

		public bool IsEntityLoggedIn()
		{
			if (authenticationContext != null)
			{
				return authenticationContext.IsEntityLoggedIn();
			}
			return false;
		}

		public void ForgetAllCredentials()
		{
			if (authenticationContext != null)
			{
				authenticationContext.ForgetAllCredentials();
			}
		}

		public void GetGlobalPolicy(GetGlobalPolicyRequest request, Action<GetGlobalPolicyResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			PlayFabHttp.MakeApiCall("/Profile/GetGlobalPolicy", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void GetProfile(GetEntityProfileRequest request, Action<GetEntityProfileResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			PlayFabHttp.MakeApiCall("/Profile/GetProfile", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void GetProfiles(GetEntityProfilesRequest request, Action<GetEntityProfilesResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			PlayFabHttp.MakeApiCall("/Profile/GetProfiles", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void GetTitlePlayersFromMasterPlayerAccountIds(GetTitlePlayersFromMasterPlayerAccountIdsRequest request, Action<GetTitlePlayersFromMasterPlayerAccountIdsResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			PlayFabHttp.MakeApiCall("/Profile/GetTitlePlayersFromMasterPlayerAccountIds", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void SetGlobalPolicy(SetGlobalPolicyRequest request, Action<SetGlobalPolicyResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			PlayFabHttp.MakeApiCall("/Profile/SetGlobalPolicy", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void SetProfileLanguage(SetProfileLanguageRequest request, Action<SetProfileLanguageResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			PlayFabHttp.MakeApiCall("/Profile/SetProfileLanguage", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}

		public void SetProfilePolicy(SetEntityProfilePolicyRequest request, Action<SetEntityProfilePolicyResponse> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null)
		{
			PlayFabAuthenticationContext playFabAuthenticationContext = request?.AuthenticationContext ?? authenticationContext;
			PlayFabApiSettings playFabApiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			PlayFabHttp.MakeApiCall("/Profile/SetProfilePolicy", request, AuthType.EntityToken, resultCallback, errorCallback, customData, extraHeaders, playFabAuthenticationContext, playFabApiSettings, this);
		}
	}
	public enum PlayFabErrorCode
	{
		Unknown = 1,
		ConnectionError = 2,
		JsonParseError = 3,
		Success = 0,
		UnkownError = 500,
		InvalidParams = 1000,
		AccountNotFound = 1001,
		AccountBanned = 1002,
		InvalidUsernameOrPassword = 1003,
		InvalidTitleId = 1004,
		InvalidEmailAddress = 1005,
		EmailAddressNotAvailable = 1006,
		InvalidUsername = 1007,
		InvalidPassword = 1008,
		UsernameNotAvailable = 1009,
		InvalidSteamTicket = 1010,
		AccountAlreadyLinked = 1011,
		LinkedAccountAlreadyClaimed = 1012,
		InvalidFacebookToken = 1013,
		AccountNotLinked = 1014,
		FailedByPaymentProvider = 1015,
		CouponCodeNotFound = 1016,
		InvalidContainerItem = 1017,
		ContainerNotOwned = 1018,
		KeyNotOwned = 1019,
		InvalidItemIdInTable = 1020,
		InvalidReceipt = 1021,
		ReceiptAlreadyUsed = 1022,
		ReceiptCancelled = 1023,
		GameNotFound = 1024,
		GameModeNotFound = 1025,
		InvalidGoogleToken = 1026,
		UserIsNotPartOfDeveloper = 1027,
		InvalidTitleForDeveloper = 1028,
		TitleNameConflicts = 1029,
		UserisNotValid = 1030,
		ValueAlreadyExists = 1031,
		BuildNotFound = 1032,
		PlayerNotInGame = 1033,
		InvalidTicket = 1034,
		InvalidDeveloper = 1035,
		InvalidOrderInfo = 1036,
		RegistrationIncomplete = 1037,
		InvalidPlatform = 1038,
		UnknownError = 1039,
		SteamApplicationNotOwned = 1040,
		WrongSteamAccount = 1041,
		TitleNotActivated = 1042,
		RegistrationSessionNotFound = 1043,
		NoSuchMod = 1044,
		FileNotFound = 1045,
		DuplicateEmail = 1046,
		ItemNotFound = 1047,
		ItemNotOwned = 1048,
		ItemNotRecycleable = 1049,
		ItemNotAffordable = 1050,
		InvalidVirtualCurrency = 1051,
		WrongVirtualCurrency = 1052,
		WrongPrice = 1053,
		NonPositiveValue = 1054,
		InvalidRegion = 1055,
		RegionAtCapacity = 1056,
		ServerFailedToStart = 1057,
		NameNotAvailable = 1058,
		InsufficientFunds = 1059,
		InvalidDeviceID = 1060,
		InvalidPushNotificationToken = 1061,
		NoRemainingUses = 1062,
		InvalidPaymentProvider = 1063,
		PurchaseInitializationFailure = 1064,
		DuplicateUsername = 1065,
		InvalidBuyerInfo = 1066,
		NoGameModeParamsSet = 1067,
		BodyTooLarge = 1068,
		ReservedWordInBody = 1069,
		InvalidTypeInBody = 1070,
		InvalidRequest = 1071,
		ReservedEventName = 1072,
		InvalidUserStatistics = 1073,
		NotAuthenticated = 1074,
		StreamAlreadyExists = 1075,
		ErrorCreatingStream = 1076,
		StreamNotFound = 1077,
		InvalidAccount = 1078,
		PurchaseDoesNotExist = 1080,
		InvalidPurchaseTransactionStatus = 1081,
		APINotEnabledForGameClientAccess = 1082,
		NoPushNotificationARNForTitle = 1083,
		BuildAlreadyExists = 1084,
		BuildPackageDoesNotExist = 1085,
		CustomAnalyticsEventsNotEnabledForTitle = 1087,
		InvalidSharedGroupId = 1088,
		NotAuthorized = 1089,
		MissingTitleGoogleProperties = 1090,
		InvalidItemProperties = 1091,
		InvalidPSNAuthCode = 1092,
		InvalidItemId = 1093,
		PushNotEnabledForAccount = 1094,
		PushServiceError = 1095,
		ReceiptDoesNotContainInAppItems = 1096,
		ReceiptContainsMultipleInAppItems = 1097,
		InvalidBundleID = 1098,
		JavascriptException = 1099,
		InvalidSessionTicket = 1100,
		UnableToConnectToDatabase = 1101,
		InternalServerError = 1110,
		InvalidReportDate = 1111,
		ReportNotAvailable = 1112,
		DatabaseThroughputExceeded = 1113,
		InvalidGameTicket = 1115,
		ExpiredGameTicket = 1116,
		GameTicketDoesNotMatchLobby = 1117,
		LinkedDeviceAlreadyClaimed = 1118,
		DeviceAlreadyLinked = 1119,
		DeviceNotLinked = 1120,
		PartialFailure = 1121,
		PublisherNotSet = 1122,
		ServiceUnavailable = 1123,
		VersionNotFound = 1124,
		RevisionNotFound = 1125,
		InvalidPublisherId = 1126,
		DownstreamServiceUnavailable = 1127,
		APINotIncludedInTitleUsageTier = 1128,
		DAULimitExceeded = 1129,
		APIRequestLimitExceeded = 1130,
		InvalidAPIEndpoint = 1131,
		BuildNotAvailable = 1132,
		ConcurrentEditError = 1133,
		ContentNotFound = 1134,
		CharacterNotFound = 1135,
		CloudScriptNotFound = 1136,
		ContentQuotaExceeded = 1137,
		InvalidCharacterStatistics = 1138,
		PhotonNotEnabledForTitle = 1139,
		PhotonApplicationNotFound = 1140,
		PhotonApplicationNotAssociatedWithTitle = 1141,
		InvalidEmailOrPassword = 1142,
		FacebookAPIError = 1143,
		InvalidContentType = 1144,
		KeyLengthExceeded = 1145,
		DataLengthExceeded = 1146,
		TooManyKeys = 1147,
		FreeTierCannotHaveVirtualCurrency = 1148,
		MissingAmazonSharedKey = 1149,
		AmazonValidationError = 1150,
		InvalidPSNIssuerId = 1151,
		PSNInaccessible = 1152,
		ExpiredAuthToken = 1153,
		FailedToGetEntitlements = 1154,
		FailedToConsumeEntitlement = 1155,
		TradeAcceptingUserNotAllowed = 1156,
		TradeInventoryItemIsAssignedToCharacter = 1157,
		TradeInventoryItemIsBundle = 1158,
		TradeStatusNotValidForCancelling = 1159,
		TradeStatusNotValidForAccepting = 1160,
		TradeDoesNotExist = 1161,
		TradeCancelled = 1162,
		TradeAlreadyFilled = 1163,
		TradeWaitForStatusTimeout = 1164,
		TradeInventoryItemExpired = 1165,
		TradeMissingOfferedAndAcceptedItems = 1166,
		TradeAcceptedItemIsBundle = 1167,
		TradeAcceptedItemIsStackable = 1168,
		TradeInventoryItemInvalidStatus = 1169,
		TradeAcceptedCatalogItemInvalid = 1170,
		TradeAllowedUsersInvalid = 1171,
		TradeInventoryItemDoesNotExist = 1172,
		TradeInventoryItemIsConsumed = 1173,
		TradeInventoryItemIsStackable = 1174,
		TradeAcceptedItemsMismatch = 1175,
		InvalidKongregateToken = 1176,
		FeatureNotConfiguredForTitle = 1177,
		NoMatchingCatalogItemForReceipt = 1178,
		InvalidCurrencyCode = 1179,
		NoRealMoneyPriceForCatalogItem = 1180,
		TradeInventoryItemIsNotTradable = 1181,
		TradeAcceptedCatalogItemIsNotTradable = 1182,
		UsersAlreadyFriends = 1183,
		LinkedIdentifierAlreadyClaimed = 1184,
		CustomIdNotLinked = 1185,
		TotalDataSizeExceeded = 1186,
		DeleteKeyConflict = 1187,
		InvalidXboxLiveToken = 1188,
		ExpiredXboxLiveToken = 1189,
		ResettableStatisticVersionRequired = 1190,
		NotAuthorizedByTitle = 1191,
		NoPartnerEnabled = 1192,
		InvalidPartnerResponse = 1193,
		APINotEnabledForGameServerAccess = 1194,
		StatisticNotFound = 1195,
		StatisticNameConflict = 1196,
		StatisticVersionClosedForWrites = 1197,
		StatisticVersionInvalid = 1198,
		APIClientRequestRateLimitExceeded = 1199,
		InvalidJSONContent = 1200,
		InvalidDropTable = 1201,
		StatisticVersionAlreadyIncrementedForScheduledInterval = 1202,
		StatisticCountLimitExceeded = 1203,
		StatisticVersionIncrementRateExceeded = 1204,
		ContainerKeyInvalid = 1205,
		CloudScriptExecutionTimeLimitExceeded = 1206,
		NoWritePermissionsForEvent = 1207,
		CloudScriptFunctionArgumentSizeExceeded = 1208,
		CloudScriptAPIRequestCountExceeded = 1209,
		CloudScriptAPIRequestError = 1210,
		CloudScriptHTTPRequestError = 1211,
		InsufficientGuildRole = 1212,
		GuildNotFound = 1213,
		OverLimit = 1214,
		EventNotFound = 1215,
		InvalidEventField = 1216,
		InvalidEventName = 1217,
		CatalogNotConfigured = 1218,
		OperationNotSupportedForPlatform = 1219,
		SegmentNotFound = 1220,
		StoreNotFound = 1221,
		InvalidStatisticName = 1222,
		TitleNotQualifiedForLimit = 1223,
		InvalidServiceLimitLevel = 1224,
		ServiceLimitLevelInTransition = 1225,
		CouponAlreadyRedeemed = 1226,
		GameServerBuildSizeLimitExceeded = 1227,
		GameServerBuildCountLimitExceeded = 1228,
		VirtualCurrencyCountLimitExceeded = 1229,
		VirtualCurrencyCodeExists = 1230,
		TitleNewsItemCountLimitExceeded = 1231,
		InvalidTwitchToken = 1232,
		TwitchResponseError = 1233,
		ProfaneDisplayName = 1234,
		UserAlreadyAdded = 1235,
		InvalidVirtualCurrencyCode = 1236,
		VirtualCurrencyCannotBeDeleted = 1237,
		IdentifierAlreadyClaimed = 1238,
		IdentifierNotLinked = 1239,
		InvalidContinuationToken = 1240,
		ExpiredContinuationToken = 1241,
		InvalidSegment = 1242,
		InvalidSessionId = 1243,
		SessionLogNotFound = 1244,
		InvalidSearchTerm = 1245,
		TwoFactorAuthenticationTokenRequired = 1246,
		GameServerHostCountLimitExceeded = 1247,
		PlayerTagCountLimitExceeded = 1248,
		RequestAlreadyRunning = 1249,
		ActionGroupNotFound = 1250,
		MaximumSegmentBulkActionJobsRunning = 1251,
		NoActionsOnPlayersInSegmentJob = 1252,
		DuplicateStatisticName = 1253,
		ScheduledTaskNameConflict = 1254,
		ScheduledTaskCreateConflict = 1255,
		InvalidScheduledTaskName = 1256,
		InvalidTaskSchedule = 1257,
		SteamNotEnabledForTitle = 1258,
		LimitNotAnUpgradeOption = 1259,
		NoSecretKeyEnabledForCloudScript = 1260,
		TaskNotFound = 1261,
		TaskInstanceNotFound = 1262,
		InvalidIdentityProviderId = 1263,
		MisconfiguredIdentityProvider = 1264,
		InvalidScheduledTaskType = 1265,
		BillingInformationRequired = 1266,
		LimitedEditionItemUnavailable = 1267,
		InvalidAdPlacementAndReward = 1268,
		AllAdPlacementViewsAlreadyConsumed = 1269,
		GoogleOAuthNotConfiguredForTitle = 1270,
		GoogleOAuthError = 1271,
		UserNotFriend = 1272,
		InvalidSignature = 1273,
		InvalidPublicKey = 1274,
		GoogleOAuthNoIdTokenIncludedInResponse = 1275,
		StatisticUpdateInProgress = 1276,
		LeaderboardVersionNotAvailable = 1277,
		StatisticAlreadyHasPrizeTable = 1279,
		PrizeTableHasOverlappingRanks = 1280,
		PrizeTableHasMissingRanks = 1281,
		PrizeTableRankStartsAtZero = 1282,
		InvalidStatistic = 1283,
		ExpressionParseFailure = 1284,
		ExpressionInvokeFailure = 1285,
		ExpressionTooLong = 1286,
		DataUpdateRateExceeded = 1287,
		RestrictedEmailDomain = 1288,
		EncryptionKeyDisabled = 1289,
		EncryptionKeyMissing = 1290,
		EncryptionKeyBroken = 1291,
		NoSharedSecretKeyConfigured = 1292,
		SecretKeyNotFound = 1293,
		PlayerSecretAlreadyConfigured = 1294,
		APIRequestsDisabledForTitle = 1295,
		InvalidSharedSecretKey = 1296,
		PrizeTableHasNoRanks = 1297,
		ProfileDoesNotExist = 1298,
		ContentS3OriginBucketNotConfigured = 1299,
		InvalidEnvironmentForReceipt = 1300,
		EncryptedRequestNotAllowed = 1301,
		SignedRequestNotAllowed = 1302,
		RequestViewConstraintParamsNotAllowed = 1303,
		BadPartnerConfiguration = 1304,
		XboxBPCertificateFailure = 1305,
		XboxXASSExchangeFailure = 1306,
		InvalidEntityId = 1307,
		StatisticValueAggregationOverflow = 1308,
		EmailMessageFromAddressIsMissing = 1309,
		EmailMessageToAddressIsMissing = 1310,
		SmtpServerAuthenticationError = 1311,
		SmtpServerLimitExceeded = 1312,
		SmtpServerInsufficientStorage = 1313,
		SmtpServerCommunicationError = 1314,
		SmtpServerGeneralFailure = 1315,
		EmailClientTimeout = 1316,
		EmailClientCanceledTask = 1317,
		EmailTemplateMissing = 1318,
		InvalidHostForTitleId = 1319,
		EmailConfirmationTokenDoesNotExist = 1320,
		EmailConfirmationTokenExpired = 1321,
		AccountDeleted = 1322,
		PlayerSecretNotConfigured = 1323,
		InvalidSignatureTime = 1324,
		NoContactEmailAddressFound = 1325,
		InvalidAuthToken = 1326,
		AuthTokenDoesNotExist = 1327,
		AuthTokenExpired = 1328,
		AuthTokenAlreadyUsedToResetPassword = 1329,
		MembershipNameTooLong = 1330,
		MembershipNotFound = 1331,
		GoogleServiceAccountInvalid = 1332,
		GoogleServiceAccountParseFailure = 1333,
		EntityTokenMissing = 1334,
		EntityTokenInvalid = 1335,
		EntityTokenExpired = 1336,
		EntityTokenRevoked = 1337,
		InvalidProductForSubscription = 1338,
		XboxInaccessible = 1339,
		SubscriptionAlreadyTaken = 1340,
		SmtpAddonNotEnabled = 1341,
		APIConcurrentRequestLimitExceeded = 1342,
		XboxRejectedXSTSExchangeRequest = 1343,
		VariableNotDefined = 1344,
		TemplateVersionNotDefined = 1345,
		FileTooLarge = 1346,
		TitleDeleted = 1347,
		TitleContainsUserAccounts = 1348,
		TitleDeletionPlayerCleanupFailure = 1349,
		EntityFileOperationPending = 1350,
		NoEntityFileOperationPending = 1351,
		EntityProfileVersionMismatch = 1352,
		TemplateVersionTooOld = 1353,
		MembershipDefinitionInUse = 1354,
		PaymentPageNotConfigured = 1355,
		FailedLoginAttemptRateLimitExceeded = 1356,
		EntityBlockedByGroup = 1357,
		RoleDoesNotExist = 1358,
		EntityIsAlreadyMember = 1359,
		DuplicateRoleId = 1360,
		GroupInvitationNotFound = 1361,
		GroupApplicationNotFound = 1362,
		OutstandingInvitationAcceptedInstead = 1363,
		OutstandingApplicationAcceptedInstead = 1364,
		RoleIsGroupDefaultMember = 1365,
		RoleIsGroupAdmin = 1366,
		RoleNameNotAvailable = 1367,
		GroupNameNotAvailable = 1368,
		EmailReportAlreadySent = 1369,
		EmailReportRecipientBlacklisted = 1370,
		EventNamespaceNotAllowed = 1371,
		EventEntityNotAllowed = 1372,
		InvalidEntityType = 1373,
		NullTokenResultFromAad = 1374,
		InvalidTokenResultFromAad = 1375,
		NoValidCertificateForAad = 1376,
		InvalidCertificateForAad = 1377,
		DuplicateDropTableId = 1378,
		MultiplayerServerError = 1379,
		MultiplayerServerTooManyRequests = 1380,
		MultiplayerServerNoContent = 1381,
		MultiplayerServerBadRequest = 1382,
		MultiplayerServerUnauthorized = 1383,
		MultiplayerServerForbidden = 1384,
		MultiplayerServerNotFound = 1385,
		MultiplayerServerConflict = 1386,
		MultiplayerServerInternalServerError = 1387,
		MultiplayerServerUnavailable = 1388,
		ExplicitContentDetected = 1389,
		PIIContentDetected = 1390,
		InvalidScheduledTaskParameter = 1391,
		PerEntityEventRateLimitExceeded = 1392,
		TitleDefaultLanguageNotSet = 1393,
		EmailTemplateMissingDefaultVersion = 1394,
		FacebookInstantGamesIdNotLinked = 1395,
		InvalidFacebookInstantGamesSignature = 1396,
		FacebookInstantGamesAuthNotConfiguredForTitle = 1397,
		EntityProfileConstraintValidationFailed = 1398,
		TelemetryIngestionKeyPending = 1399,
		TelemetryIngestionKeyNotFound = 1400,
		StatisticChildNameInvalid = 1402,
		DataIntegrityError = 1403,
		VirtualCurrencyCannotBeSetToOlderVersion = 1404,
		VirtualCurrencyMustBeWithinIntegerRange = 1405,
		EmailTemplateInvalidSyntax = 1406,
		EmailTemplateMissingCallback = 1407,
		PushNotificationTemplateInvalidPayload = 1408,
		InvalidLocalizedPushNotificationLanguage = 1409,
		MissingLocalizedPushNotificationMessage = 1410,
		PushNotificationTemplateMissingPlatformPayload = 1411,
		PushNotificationTemplatePayloadContainsInvalidJson = 1412,
		PushNotificationTemplateContainsInvalidIosPayload = 1413,
		PushNotificationTemplateContainsInvalidAndroidPayload = 1414,
		PushNotificationTemplateIosPayloadMissingNotificationBody = 1415,
		PushNotificationTemplateAndroidPayloadMissingNotificationBody = 1416,
		PushNotificationTemplateNotFound = 1417,
		PushNotificationTemplateMissingDefaultVersion = 1418,
		PushNotificationTemplateInvalidSyntax = 1419,
		PushNotificationTemplateNoCustomPayloadForV1 = 1420,
		NoLeaderboardForStatistic = 1421,
		TitleNewsMissingDefaultLanguage = 1422,
		TitleNewsNotFound = 1423,
		TitleNewsDuplicateLanguage = 1424,
		TitleNewsMissingTitleOrBody = 1425,
		TitleNewsInvalidLanguage = 1426,
		EmailRecipientBlacklisted = 1427,
		InvalidGameCenterAuthRequest = 1428,
		GameCenterAuthenticationFailed = 1429,
		CannotEnablePartiesForTitle = 1430,
		PartyError = 1431,
		PartyRequests = 1432,
		PartyNoContent = 1433,
		PartyBadRequest = 1434,
		PartyUnauthorized = 1435,
		PartyForbidden = 1436,
		PartyNotFound = 1437,
		PartyConflict = 1438,
		PartyInternalServerError = 1439,
		PartyUnavailable = 1440,
		PartyTooManyRequests = 1441,
		PushNotificationTemplateMissingName = 1442,
		CannotEnableMultiplayerServersForTitle = 1443,
		WriteAttemptedDuringExport = 1444,
		MultiplayerServerTitleQuotaCoresExceeded = 1445,
		AutomationRuleNotFound = 1446,
		EntityAPIKeyLimitExceeded = 1447,
		EntityAPIKeyNotFound = 1448,
		EntityAPIKeyOrSecretInvalid = 1449,
		EconomyServiceUnavailable = 1450,
		EconomyServiceInternalError = 1451,
		QueryRateLimitExceeded = 1452,
		EntityAPIKeyCreationDisabledForEntity = 1453,
		ForbiddenByEntityPolicy = 1454,
		UpdateInventoryRateLimitExceeded = 1455,
		StudioCreationRateLimited = 1456,
		StudioCreationInProgress = 1457,
		DuplicateStudioName = 1458,
		StudioNotFound = 1459,
		StudioDeleted = 1460,
		StudioDeactivated = 1461,
		StudioActivated = 1462,
		TitleCreationRateLimited = 1463,
		TitleCreationInProgress = 1464,
		DuplicateTitleName = 1465,
		TitleActivationRateLimited = 1466,
		TitleActivationInProgress = 1467,
		TitleDeactivated = 1468,
		TitleActivated = 1469,
		CloudScriptAzureFunctionsExecutionTimeLimitExceeded = 1470,
		CloudScriptAzureFunctionsArgumentSizeExceeded = 1471,
		CloudScriptAzureFunctionsReturnSizeExceeded = 1472,
		CloudScriptAzureFunctionsHTTPRequestError = 1473,
		VirtualCurrencyBetaGetError = 1474,
		VirtualCurrencyBetaCreateError = 1475,
		VirtualCurrencyBetaInitialDepositSaveError = 1476,
		VirtualCurrencyBetaSaveError = 1477,
		VirtualCurrencyBetaDeleteError = 1478,
		VirtualCurrencyBetaRestoreError = 1479,
		VirtualCurrencyBetaSaveConflict = 1480,
		VirtualCurrencyBetaUpdateError = 1481,
		InsightsManagementDatabaseNotFound = 1482,
		InsightsManagementOperationNotFound = 1483,
		InsightsManagementErrorPendingOperationExists = 1484,
		InsightsManagementSetPerformanceLevelInvalidParameter = 1485,
		InsightsManagementSetStorageRetentionInvalidParameter = 1486,
		InsightsManagementGetStorageUsageInvalidParameter = 1487,
		InsightsManagementGetOperationStatusInvalidParameter = 1488,
		MatchmakingEntityInvalid = 2001,
		MatchmakingPlayerAttributesInvalid = 2002,
		MatchmakingQueueNotFound = 2016,
		MatchmakingMatchNotFound = 2017,
		MatchmakingTicketNotFound = 2018,
		MatchmakingAlreadyJoinedTicket = 2028,
		MatchmakingTicketAlreadyCompleted = 2029,
		MatchmakingQueueConfigInvalid = 2031,
		MatchmakingMemberProfileInvalid = 2032,
		NintendoSwitchDeviceIdNotLinked = 2034,
		MatchmakingNotEnabled = 2035,
		MatchmakingPlayerAttributesTooLarge = 2043,
		MatchmakingNumberOfPlayersInTicketTooLarge = 2044,
		MatchmakingAttributeInvalid = 2046,
		MatchmakingPlayerHasNotJoinedTicket = 2053,
		MatchmakingRateLimitExceeded = 2054,
		MatchmakingTicketMembershipLimitExceeded = 2055,
		MatchmakingUnauthorized = 2056,
		MatchmakingQueueLimitExceeded = 2057,
		MatchmakingRequestTypeMismatch = 2058,
		MatchmakingBadRequest = 2059,
		TitleConfigNotFound = 3001,
		TitleConfigUpdateConflict = 3002,
		TitleConfigSerializationError = 3003,
		CatalogEntityInvalid = 4001,
		CatalogTitleIdMissing = 4002,
		CatalogPlayerIdMissing = 4003,
		CatalogClientIdentityInvalid = 4004,
		CatalogOneOrMoreFilesInvalid = 4005,
		CatalogItemMetadataInvalid = 4006,
		CatalogItemIdInvalid = 4007,
		CatalogSearchParameterInvalid = 4008,
		CatalogFeatureDisabled = 4009,
		CatalogConfigInvalid = 4010,
		CatalogUnauthorized = 4011,
		CatalogItemTypeInvalid = 4012,
		ExportInvalidStatusUpdate = 5000,
		ExportInvalidPrefix = 5001,
		ExportBlobContainerDoesNotExist = 5002,
		ExportNotFound = 5004,
		ExportCouldNotUpdate = 5005,
		ExportInvalidStorageType = 5006,
		ExportAmazonBucketDoesNotExist = 5007,
		ExportInvalidBlobStorage = 5008,
		ExportKustoException = 5009,
		ExportKustoConnectionFailed = 5012,
		ExportUnknownError = 5013,
		ExportCantEditPendingExport = 5014,
		ExportLimitExports = 5015,
		ExportLimitEvents = 5016,
		TitleNotEnabledForParty = 6000,
		PartyVersionNotFound = 6001,
		MultiplayerServerBuildReferencedByMatchmakingQueue = 6002,
		ExperimentationExperimentStopped = 7000,
		ExperimentationExperimentRunning = 7001,
		ExperimentationExperimentNotFound = 7002,
		ExperimentationExperimentNeverStarted = 7003,
		ExperimentationExperimentDeleted = 7004,
		ExperimentationClientTimeout = 7005,
		ExperimentationExceededVariantNameLength = 7006,
		ExperimentationExceededMaxVariantLength = 7007,
		ExperimentInvalidId = 7008,
		MaxActionDepthExceeded = 8000,
		SnapshotNotFound = 11000
	}
	public class PlayFabError
	{
		public string ApiEndpoint;

		public int HttpCode;

		public string HttpStatus;

		public PlayFabErrorCode Error;

		public string ErrorMessage;

		public Dictionary<string, List<string>> ErrorDetails;

		public object CustomData;

		[ThreadStatic]
		private static StringBuilder _tempSb;

		public override string ToString()
		{
			StringBuilder stringBuilder = new StringBuilder();
			if (ErrorDetails != null)
			{
				foreach (KeyValuePair<string, List<string>> errorDetail in ErrorDetails)
				{
					stringBuilder.Append(errorDetail.Key);
					stringBuilder.Append(": ");
					stringBuilder.Append(string.Join(", ", errorDetail.Value.ToArray()));
					stringBuilder.Append(" | ");
				}
			}
			return $"{ApiEndpoint} PlayFabError({Error}, {ErrorMessage}, {HttpCode} {HttpStatus}" + ((stringBuilder.Length > 0) ? (" - Details: " + stringBuilder.ToString() + ")") : ")");
		}

		public string GenerateErrorReport()
		{
			if (_tempSb == null)
			{
				_tempSb = new StringBuilder();
			}
			_tempSb.Length = 0;
			if (string.IsNullOrEmpty(ErrorMessage))
			{
				_tempSb.Append(ApiEndpoint).Append(": ").Append("Http Code: ")
					.Append(HttpCode.ToString())
					.Append("\nHttp Status: ")
					.Append(HttpStatus)
					.Append("\nError: ")
					.Append(Error.ToString())
					.Append("\n");
			}
			else
			{
				_tempSb.Append(ApiEndpoint).Append(": ").Append(ErrorMessage);
			}
			if (ErrorDetails != null)
			{
				foreach (KeyValuePair<string, List<string>> errorDetail in ErrorDetails)
				{
					foreach (string item in errorDetail.Value)
					{
						_tempSb.Append("\n").Append(errorDetail.Key).Append(": ")
							.Append(item);
					}
				}
			}
			return _tempSb.ToString();
		}
	}
	public class PlayFabException : Exception
	{
		public readonly PlayFabExceptionCode Code;

		public PlayFabException(PlayFabExceptionCode code, string message)
			: base(message)
		{
			Code = code;
		}
	}
	public enum PlayFabExceptionCode
	{
		AuthContextRequired,
		BuildError,
		DeveloperKeyNotSet,
		EntityTokenNotSet,
		NotLoggedIn,
		TitleNotSet
	}
	public static class WsaReflectionExtensions
	{
		public static Delegate CreateDelegate(this MethodInfo methodInfo, Type delegateType, object instance)
		{
			return Delegate.CreateDelegate(delegateType, instance, methodInfo);
		}

		public static Type GetTypeInfo(this Type type)
		{
			return type;
		}

		public static Type AsType(this Type type)
		{
			return type;
		}

		public static string GetDelegateName(this Delegate delegateInstance)
		{
			return delegateInstance.Method.Name;
		}
	}
	public interface IPlayFabPlugin
	{
	}
	public interface ISerializerPlugin : IPlayFabPlugin
	{
		T DeserializeObject<T>(string serialized);

		T DeserializeObject<T>(string serialized, object serializerStrategy);

		object DeserializeObject(string serialized);

		string SerializeObject(object obj);

		string SerializeObject(object obj, object serializerStrategy);
	}
	public interface ITransportPlugin : IPlayFabPlugin
	{
		bool IsInitialized { get; }

		void Initialize();

		void Update();

		void OnDestroy();

		void SimpleGetCall(string fullUrl, Action<byte[]> successCallback, Action<string> errorCallback);

		void SimplePutCall(string fullUrl, byte[] payload, Action<byte[]> successCallback, Action<string> errorCallback);

		void SimplePostCall(string fullUrl, byte[] payload, Action<byte[]> successCallback, Action<string> errorCallback);

		void MakeApiCall(object reqContainer);

		int GetPendingMessages();
	}
	public class PlayFabApiSettings
	{
		private string _ProductionEnvironmentUrl = "playfabapi.com";

		public readonly Dictionary<string, string> _requestGetParams = new Dictionary<string, string> { { "sdk", "UnitySDK-2.74.190916" } };

		public virtual Dictionary<string, string> RequestGetParams => _requestGetParams;

		public virtual string ProductionEnvironmentUrl
		{
			get
			{
				return _ProductionEnvironmentUrl;
			}
			set
			{
				_ProductionEnvironmentUrl = value;
			}
		}

		public virtual string TitleId { get; set; }

		internal virtual string VerticalName { get; set; }

		public virtual string AdvertisingIdType { get; set; }

		public virtual string AdvertisingIdValue { get; set; }

		public virtual bool DisableAdvertising { get; set; }

		public virtual bool DisableDeviceInfo { get; set; }

		public virtual bool DisableFocusTimeCollection { get; set; }

		public virtual string GetFullUrl(string apiCall, Dictionary<string, string> getParams)
		{
			return PlayFabSettings.GetFullUrl(apiCall, getParams, this);
		}
	}
	internal class PlayFabSettingsRedirect : PlayFabApiSettings
	{
		private readonly Func<PlayFabSharedSettings> GetSO;

		public override string ProductionEnvironmentUrl
		{
			get
			{
				PlayFabSharedSettings playFabSharedSettings = GetSO();
				if (!(playFabSharedSettings == null))
				{
					return playFabSharedSettings.ProductionEnvironmentUrl;
				}
				return base.ProductionEnvironmentUrl;
			}
			set
			{
				PlayFabSharedSettings playFabSharedSettings = GetSO();
				if (playFabSharedSettings != null)
				{
					playFabSharedSettings.ProductionEnvironmentUrl = value;
				}
				base.ProductionEnvironmentUrl = value;
			}
		}

		internal override string VerticalName
		{
			get
			{
				PlayFabSharedSettings playFabSharedSettings = GetSO();
				if (!(playFabSharedSettings == null))
				{
					return playFabSharedSettings.VerticalName;
				}
				return base.VerticalName;
			}
			set
			{
				PlayFabSharedSettings playFabSharedSettings = GetSO();
				if (playFabSharedSettings != null)
				{
					playFabSharedSettings.VerticalName = value;
				}
				base.VerticalName = value;
			}
		}

		public override string TitleId
		{
			get
			{
				PlayFabSharedSettings playFabSharedSettings = GetSO();
				if (!(playFabSharedSettings == null))
				{
					return playFabSharedSettings.TitleId;
				}
				return base.TitleId;
			}
			set
			{
				PlayFabSharedSettings playFabSharedSettings = GetSO();
				if (playFabSharedSettings != null)
				{
					playFabSharedSettings.TitleId = value;
				}
				base.TitleId = value;
			}
		}

		public override string AdvertisingIdType
		{
			get
			{
				PlayFabSharedSettings playFabSharedSettings = GetSO();
				if (!(playFabSharedSettings == null))
				{
					return playFabSharedSettings.AdvertisingIdType;
				}
				return base.AdvertisingIdType;
			}
			set
			{
				PlayFabSharedSettings playFabSharedSettings = GetSO();
				if (playFabSharedSettings != null)
				{
					playFabSharedSettings.AdvertisingIdType = value;
				}
				base.AdvertisingIdType = value;
			}
		}

		public override string AdvertisingIdValue
		{
			get
			{
				PlayFabSharedSettings playFabSharedSettings = GetSO();
				if (!(playFabSharedSettings == null))
				{
					return playFabSharedSettings.AdvertisingIdValue;
				}
				return base.AdvertisingIdValue;
			}
			set
			{
				PlayFabSharedSettings playFabSharedSettings = GetSO();
				if (playFabSharedSettings != null)
				{
					playFabSharedSettings.AdvertisingIdValue = value;
				}
				base.AdvertisingIdValue = value;
			}
		}

		public override bool DisableAdvertising
		{
			get
			{
				PlayFabSharedSettings playFabSharedSettings = GetSO();
				if (!(playFabSharedSettings == null))
				{
					return playFabSharedSettings.DisableAdvertising;
				}
				return base.DisableAdvertising;
			}
			set
			{
				PlayFabSharedSettings playFabSharedSettings = GetSO();
				if (playFabSharedSettings != null)
				{
					playFabSharedSettings.DisableAdvertising = value;
				}
				base.DisableAdvertising = value;
			}
		}

		public override bool DisableDeviceInfo
		{
			get
			{
				PlayFabSharedSettings playFabSharedSettings = GetSO();
				if (!(playFabSharedSettings == null))
				{
					return playFabSharedSettings.DisableDeviceInfo;
				}
				return base.DisableDeviceInfo;
			}
			set
			{
				PlayFabSharedSettings playFabSharedSettings = GetSO();
				if (playFabSharedSettings != null)
				{
					playFabSharedSettings.DisableDeviceInfo = value;
				}
				base.DisableDeviceInfo = value;
			}
		}

		public override bool DisableFocusTimeCollection
		{
			get
			{
				PlayFabSharedSettings playFabSharedSettings = GetSO();
				if (!(playFabSharedSettings == null))
				{
					return playFabSharedSettings.DisableFocusTimeCollection;
				}
				return base.DisableFocusTimeCollection;
			}
			set
			{
				PlayFabSharedSettings playFabSharedSettings = GetSO();
				if (playFabSharedSettings != null)
				{
					playFabSharedSettings.DisableFocusTimeCollection = value;
				}
				base.DisableFocusTimeCollection = value;
			}
		}

		public PlayFabSettingsRedirect(Func<PlayFabSharedSettings> getSO)
		{
			GetSO = getSO;
		}
	}
	public sealed class PlayFabAuthenticationContext
	{
		public string ClientSessionTicket;

		public string PlayFabId;

		public string EntityToken;

		public string EntityId;

		public string EntityType;

		public PlayFabAuthenticationContext()
		{
		}

		public PlayFabAuthenticationContext(string clientSessionTicket, string entityToken, string playFabId, string entityId, string entityType)
			: this()
		{
			ClientSessionTicket = clientSessionTicket;
			PlayFabId = playFabId;
			EntityToken = entityToken;
			EntityId = entityId;
			EntityType = entityType;
		}

		public void CopyFrom(PlayFabAuthenticationContext other)
		{
			ClientSessionTicket = other.ClientSessionTicket;
			PlayFabId = other.PlayFabId;
			EntityToken = other.EntityToken;
			EntityId = other.EntityId;
			EntityType = other.EntityType;
		}

		public bool IsClientLoggedIn()
		{
			return !string.IsNullOrEmpty(ClientSessionTicket);
		}

		public bool IsEntityLoggedIn()
		{
			return !string.IsNullOrEmpty(EntityToken);
		}

		public void ForgetAllCredentials()
		{
			PlayFabId = null;
			ClientSessionTicket = null;
			EntityToken = null;
			EntityId = null;
			EntityType = null;
		}
	}
	public class PlayFabDataGatherer
	{
		public string ProductName;

		public string ProductBundle;

		public string Version;

		public string Company;

		public RuntimePlatform Platform;

		public bool GraphicsMultiThreaded;

		public GraphicsDeviceType GraphicsType;

		public string DataPath;

		public string PersistentDataPath;

		public string StreamingAssetsPath;

		public int TargetFrameRate;

		public string UnityVersion;

		public bool RunInBackground;

		public string DeviceModel;

		public DeviceType DeviceType;

		public string DeviceUniqueId;

		public string OperatingSystem;

		public int GraphicsDeviceId;

		public string GraphicsDeviceName;

		public int GraphicsMemorySize;

		public int GraphicsShaderLevel;

		public int SystemMemorySize;

		public int ProcessorCount;

		public int ProcessorFrequency;

		public string ProcessorType;

		public bool SupportsAccelerometer;

		public bool SupportsGyroscope;

		public bool SupportsLocationService;

		public PlayFabDataGatherer()
		{
			ProductName = UnityEngine.Application.productName;
			Version = UnityEngine.Application.version;
			Company = UnityEngine.Application.companyName;
			Platform = UnityEngine.Application.platform;
			GraphicsMultiThreaded = SystemInfo.graphicsMultiThreaded;
			GraphicsType = SystemInfo.graphicsDeviceType;
			ProductBundle = UnityEngine.Application.identifier;
			DataPath = UnityEngine.Application.dataPath;
			PersistentDataPath = UnityEngine.Application.persistentDataPath;
			StreamingAssetsPath = UnityEngine.Application.streamingAssetsPath;
			TargetFrameRate = UnityEngine.Application.targetFrameRate;
			UnityVersion = UnityEngine.Application.unityVersion;
			RunInBackground = UnityEngine.Application.runInBackground;
			DeviceModel = SystemInfo.deviceModel;
			DeviceType = SystemInfo.deviceType;
			DeviceUniqueId = PlayFabSettings.DeviceUniqueIdentifier;
			OperatingSystem = SystemInfo.operatingSystem;
			GraphicsDeviceId = SystemInfo.graphicsDeviceID;
			GraphicsDeviceName = SystemInfo.graphicsDeviceName;
			GraphicsMemorySize = SystemInfo.graphicsMemorySize;
			GraphicsShaderLevel = SystemInfo.graphicsShaderLevel;
			SystemMemorySize = SystemInfo.systemMemorySize;
			ProcessorCount = SystemInfo.processorCount;
			ProcessorFrequency = SystemInfo.processorFrequency;
			ProcessorType = SystemInfo.processorType;
			SupportsAccelerometer = SystemInfo.supportsAccelerometer;
			SupportsGyroscope = SystemInfo.supportsGyroscope;
			SupportsLocationService = SystemInfo.supportsLocationService;
		}

		public string GenerateReport()
		{
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.Append("Logging System Info: ========================================\n");
			FieldInfo[] fields = GetType().GetTypeInfo().GetFields();
			foreach (FieldInfo fieldInfo in fields)
			{
				string arg = fieldInfo.GetValue(this).ToString();
				stringBuilder.AppendFormat("System Info - {0}: {1}\n", fieldInfo.Name, arg);
			}
			return stringBuilder.ToString();
		}
	}
	public enum WebRequestType
	{
		UnityWebRequest,
		HttpWebRequest,
		CustomHttp
	}
	[Flags]
	public enum PlayFabLogLevel
	{
		None = 0,
		Debug = 1,
		Info = 2,
		Warning = 4,
		Error = 8,
		All = 0xF
	}
	public static class PlayFabSettings
	{
		private static PlayFabSharedSettings _playFabShared;

		internal static readonly PlayFabApiSettings staticSettings;

		internal static readonly PlayFabAuthenticationContext staticPlayer;

		public const string SdkVersion = "2.74.190916";

		public const string BuildIdentifier = "jbuild_unitysdk__sdk-unity-3-slave_0";

		public const string VersionString = "UnitySDK-2.74.190916";

		public const string AD_TYPE_IDFA = "Idfa";

		public const string AD_TYPE_ANDROID_ID = "Adid";

		internal const string DefaultPlayFabApiUrl = "playfabapi.com";

		private static string _localApiServer;

		private static PlayFabSharedSettings PlayFabSharedPrivate
		{
			get
			{
				if (_playFabShared == null)
				{
					_playFabShared = GetSharedSettingsObjectPrivate();
				}
				return _playFabShared;
			}
		}

		public static string DeviceUniqueIdentifier
		{
			get
			{
				AndroidJavaObject androidJavaObject = new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity").Call<AndroidJavaObject>("getContentResolver", Array.Empty<object>());
				return new AndroidJavaClass("android.provider.Settings$Secure").CallStatic<string>("getString", new object[2] { androidJavaObject, "android_id" });
			}
		}

		public static string TitleId
		{
			get
			{
				return staticSettings.TitleId;
			}
			set
			{
				staticSettings.TitleId = value;
			}
		}

		internal static string VerticalName
		{
			get
			{
				return staticSettings.VerticalName;
			}
			set
			{
				staticSettings.VerticalName = value;
			}
		}

		public static bool DisableAdvertising
		{
			get
			{
				return staticSettings.DisableAdvertising;
			}
			set
			{
				staticSettings.DisableAdvertising = value;
			}
		}

		public static bool DisableDeviceInfo
		{
			get
			{
				return staticSettings.DisableDeviceInfo;
			}
			set
			{
				staticSettings.DisableDeviceInfo = value;
			}
		}

		public static bool DisableFocusTimeCollection
		{
			get
			{
				return staticSettings.DisableFocusTimeCollection;
			}
			set
			{
				staticSettings.DisableFocusTimeCollection = value;
			}
		}

		[Obsolete("LogLevel has been deprecated, please use UnityEngine.Debug.Log for your logging needs.")]
		public static PlayFabLogLevel LogLevel
		{
			get
			{
				return PlayFabSharedPrivate.LogLevel;
			}
			set
			{
				PlayFabSharedPrivate.LogLevel = value;
			}
		}

		public static WebRequestType RequestType
		{
			get
			{
				return PlayFabSharedPrivate.RequestType;
			}
			set
			{
				PlayFabSharedPrivate.RequestType = value;
			}
		}

		public static int RequestTimeout
		{
			get
			{
				return PlayFabSharedPrivate.RequestTimeout;
			}
			set
			{
				PlayFabSharedPrivate.RequestTimeout = value;
			}
		}

		public static bool RequestKeepAlive
		{
			get
			{
				return PlayFabSharedPrivate.RequestKeepAlive;
			}
			set
			{
				PlayFabSharedPrivate.RequestKeepAlive = value;
			}
		}

		public static bool CompressApiData
		{
			get
			{
				return PlayFabSharedPrivate.CompressApiData;
			}
			set
			{
				PlayFabSharedPrivate.CompressApiData = value;
			}
		}

		public static string LoggerHost
		{
			get
			{
				return PlayFabSharedPrivate.LoggerHost;
			}
			set
			{
				PlayFabSharedPrivate.LoggerHost = value;
			}
		}

		public static int LoggerPort
		{
			get
			{
				return PlayFabSharedPrivate.LoggerPort;
			}
			set
			{
				PlayFabSharedPrivate.LoggerPort = value;
			}
		}

		public static bool EnableRealTimeLogging
		{
			get
			{
				return PlayFabSharedPrivate.EnableRealTimeLogging;
			}
			set
			{
				PlayFabSharedPrivate.EnableRealTimeLogging = value;
			}
		}

		public static int LogCapLimit
		{
			get
			{
				return PlayFabSharedPrivate.LogCapLimit;
			}
			set
			{
				PlayFabSharedPrivate.LogCapLimit = value;
			}
		}

		public static string LocalApiServer
		{
			get
			{
				return _localApiServer ?? PlayFabUtil.GetLocalSettingsFileProperty("LocalApiServer");
			}
			set
			{
				_localApiServer = value;
			}
		}

		static PlayFabSettings()
		{
			_playFabShared = null;
			staticSettings = new PlayFabSettingsRedirect(() => PlayFabSharedPrivate);
			staticPlayer = new PlayFabAuthenticationContext();
		}

		private static PlayFabSharedSettings GetSharedSettingsObjectPrivate()
		{
			PlayFabSharedSettings[] array = Resources.LoadAll<PlayFabSharedSettings>("PlayFabSharedSettings");
			if (array.Length != 1)
			{
				throw new Exception("The number of PlayFabSharedSettings objects should be 1: " + array.Length);
			}
			return array[0];
		}

		public static string GetFullUrl(string apiCall, Dictionary<string, string> getParams, PlayFabApiSettings apiSettings = null)
		{
			StringBuilder stringBuilder = new StringBuilder(1000);
			string text = null;
			string text2 = null;
			string text3 = null;
			if (apiSettings != null)
			{
				if (!string.IsNullOrEmpty(apiSettings.ProductionEnvironmentUrl))
				{
					text = apiSettings.ProductionEnvironmentUrl;
				}
				if (!string.IsNullOrEmpty(apiSettings.VerticalName))
				{
					text2 = apiSettings.VerticalName;
				}
				if (!string.IsNullOrEmpty(apiSettings.TitleId))
				{
					text3 = apiSettings.TitleId;
				}
			}
			if (text == null)
			{
				text = ((!string.IsNullOrEmpty(PlayFabSharedPrivate.ProductionEnvironmentUrl)) ? PlayFabSharedPrivate.ProductionEnvironmentUrl : "playfabapi.com");
			}
			if (text2 == null && apiSettings != null && !string.IsNullOrEmpty(apiSettings.VerticalName))
			{
				text2 = apiSettings.VerticalName;
			}
			if (text3 == null)
			{
				text3 = PlayFabSharedPrivate.TitleId;
			}
			string text4 = text;
			if (!text4.StartsWith("http"))
			{
				stringBuilder.Append("https://");
				if (!string.IsNullOrEmpty(text3))
				{
					stringBuilder.Append(text3).Append(".");
				}
				if (!string.IsNullOrEmpty(text2))
				{
					stringBuilder.Append(text2).Append(".");
				}
			}
			stringBuilder.Append(text4).Append(apiCall);
			if (getParams != null)
			{
				bool flag = true;
				foreach (KeyValuePair<string, string> getParam in getParams)
				{
					if (flag)
					{
						stringBuilder.Append("?");
						flag = false;
					}
					else
					{
						stringBuilder.Append("&");
					}
					stringBuilder.Append(getParam.Key).Append("=").Append(getParam.Value);
				}
			}
			return stringBuilder.ToString();
		}
	}
	public enum PluginContract
	{
		PlayFab_Serializer,
		PlayFab_Transport
	}
	public struct PluginContractKey
	{
		public PluginContract _pluginContract;

		public string _pluginName;
	}
	public class PluginContractKeyComparator : EqualityComparer<PluginContractKey>
	{
		public override bool Equals(PluginContractKey x, PluginContractKey y)
		{
			if (x._pluginContract == y._pluginContract)
			{
				return x._pluginName.Equals(y._pluginName);
			}
			return false;
		}

		public override int GetHashCode(PluginContractKey obj)
		{
			return (int)(obj._pluginContract + obj._pluginName.GetHashCode());
		}
	}
	public class PluginManager
	{
		private Dictionary<PluginContractKey, IPlayFabPlugin> plugins = new Dictionary<PluginContractKey, IPlayFabPlugin>(new PluginContractKeyComparator());

		private static readonly PluginManager Instance = new PluginManager();

		private PluginManager()
		{
		}

		public static T GetPlugin<T>(PluginContract contract, string instanceName = "") where T : IPlayFabPlugin
		{
			return (T)Instance.GetPluginInternal(contract, instanceName);
		}

		public static void SetPlugin(IPlayFabPlugin plugin, PluginContract contract, string instanceName = "")
		{
			Instance.SetPluginInternal(plugin, contract, instanceName);
		}

		private IPlayFabPlugin GetPluginInternal(PluginContract contract, string instanceName)
		{
			PluginContractKey pluginContractKey = default(PluginContractKey);
			pluginContractKey._pluginContract = contract;
			pluginContractKey._pluginName = instanceName;
			PluginContractKey key = pluginContractKey;
			if (!plugins.TryGetValue(key, out var value))
			{
				value = contract switch
				{
					PluginContract.PlayFab_Serializer => CreatePlugin<SimpleJsonInstance>(), 
					PluginContract.PlayFab_Transport => CreatePlayFabTransportPlugin(), 
					_ => throw new ArgumentException("This contract is not supported", "contract"), 
				};
				plugins[key] = value;
			}
			return value;
		}

		private void SetPluginInternal(IPlayFabPlugin plugin, PluginContract contract, string instanceName)
		{
			if (plugin == null)
			{
				throw new ArgumentNullException("plugin", "Plugin instance cannot be null");
			}
			PluginContractKey pluginContractKey = default(PluginContractKey);
			pluginContractKey._pluginContract = contract;
			pluginContractKey._pluginName = instanceName;
			PluginContractKey key = pluginContractKey;
			plugins[key] = plugin;
		}

		private IPlayFabPlugin CreatePlugin<T>() where T : IPlayFabPlugin, new()
		{
			return (IPlayFabPlugin)Activator.CreateInstance(typeof(T));
		}

		private ITransportPlugin CreatePlayFabTransportPlugin()
		{
			ITransportPlugin transportPlugin = null;
			if (PlayFabSettings.RequestType == WebRequestType.HttpWebRequest)
			{
				transportPlugin = new PlayFabWebRequest();
			}
			if (transportPlugin == null)
			{
				transportPlugin = new PlayFabUnityHttp();
			}
			return transportPlugin;
		}
	}
}
namespace PlayFab.SharedModels
{
	public class HttpResponseObject
	{
		public int code;

		public string status;

		public object data;
	}
	public class PlayFabBaseModel
	{
		public string ToJson()
		{
			return PluginManager.GetPlugin<ISerializerPlugin>(PluginContract.PlayFab_Serializer).SerializeObject(this);
		}
	}
	public interface IPlayFabInstanceApi
	{
	}
	public class PlayFabRequestCommon : PlayFabBaseModel
	{
		public PlayFabAuthenticationContext AuthenticationContext;
	}
	public class PlayFabResultCommon : PlayFabBaseModel
	{
		public PlayFabRequestCommon Request;

		public object CustomData;
	}
	public class PlayFabLoginResultCommon : PlayFabResultCommon
	{
		public PlayFabAuthenticationContext AuthenticationContext;
	}
	public class PlayFabResult<TResult> where TResult : PlayFabResultCommon
	{
		public TResult Result;

		public object CustomData;
	}
}
namespace PlayFab.Json
{
	public class SimpleJsonInstance : ISerializerPlugin, IPlayFabPlugin
	{
		public class PlayFabSimpleJsonCuztomization : PocoJsonSerializerStrategy
		{
			public override object DeserializeObject(object value, Type type)
			{
				if (!(value is string text))
				{
					return base.DeserializeObject(value, type);
				}
				Type underlyingType = Nullable.GetUnderlyingType(type);
				if (underlyingType != null)
				{
					return DeserializeObject(value, underlyingType);
				}
				if (type.GetTypeInfo().IsEnum)
				{
					return Enum.Parse(type, (string)value, ignoreCase: true);
				}
				double result3;
				if (type == typeof(DateTime))
				{
					if (DateTime.TryParseExact(text, PlayFabUtil._defaultDateTimeFormats, CultureInfo.InvariantCulture, PlayFabUtil.DateTimeStyles, out var result))
					{
						return result;
					}
				}
				else if (type == typeof(DateTimeOffset))
				{
					if (DateTimeOffset.TryParseExact(text, PlayFabUtil._defaultDateTimeFormats, CultureInfo.InvariantCulture, PlayFabUtil.DateTimeStyles, out var result2))
					{
						return result2;
					}
				}
				else if (type == typeof(TimeSpan) && double.TryParse(text, out result3))
				{
					return TimeSpan.FromSeconds(result3);
				}
				return base.DeserializeObject(value, type);
			}

			protected override bool TrySerializeKnownTypes(object input, out object output)
			{
				if (input.GetType().GetTypeInfo().IsEnum)
				{
					output = input.ToString();
					return true;
				}
				if (input is DateTime)
				{
					output = ((DateTime)input).ToString(PlayFabUtil._defaultDateTimeFormats[2], CultureInfo.InvariantCulture);
					return true;
				}
				if (input is DateTimeOffset)
				{
					output = ((DateTimeOffset)input).ToString(PlayFabUtil._defaultDateTimeFormats[2], CultureInfo.InvariantCulture);
					return true;
				}
				if (input is TimeSpan)
				{
					output = ((TimeSpan)input).TotalSeconds;
					return true;
				}
				return base.TrySerializeKnownTypes(input, out output);
			}
		}

		public static PlayFabSimpleJsonCuztomization ApiSerializerStrategy = new PlayFabSimpleJsonCuztomization();

		public T DeserializeObject<T>(string json)
		{
			return PlayFabSimpleJson.DeserializeObject<T>(json, ApiSerializerStrategy);
		}

		public T DeserializeObject<T>(string json, object jsonSerializerStrategy)
		{
			return PlayFabSimpleJson.DeserializeObject<T>(json, (IJsonSerializerStrategy)jsonSerializerStrategy);
		}

		public object DeserializeObject(string json)
		{
			return PlayFabSimpleJson.DeserializeObject(json, typeof(object), ApiSerializerStrategy);
		}

		public string SerializeObject(object json)
		{
			return PlayFabSimpleJson.SerializeObject(json, ApiSerializerStrategy);
		}

		public string SerializeObject(object json, object jsonSerializerStrategy)
		{
			return PlayFabSimpleJson.SerializeObject(json, (IJsonSerializerStrategy)jsonSerializerStrategy);
		}
	}
	public enum NullValueHandling
	{
		Include,
		Ignore
	}
	[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field)]
	public class JsonProperty : Attribute
	{
		public string PropertyName;

		public NullValueHandling NullValueHandling;
	}
	[GeneratedCode("simple-json", "1.0.0")]
	[EditorBrowsable(EditorBrowsableState.Never)]
	public class JsonArray : List<object>
	{
		public JsonArray()
		{
		}

		public JsonArray(int capacity)
			: base(capacity)
		{
		}

		public override string ToString()
		{
			return PlayFabSimpleJson.SerializeObject(this) ?? string.Empty;
		}
	}
	[GeneratedCode("simple-json", "1.0.0")]
	[EditorBrowsable(EditorBrowsableState.Never)]
	public class JsonObject : IDictionary<string, object>, ICollection<KeyValuePair<string, object>>, IEnumerable<KeyValuePair<string, object>>, IEnumerable
	{
		private const int DICTIONARY_DEFAULT_SIZE = 16;

		private readonly Dictionary<string, object> _members;

		public object this[int index] => GetAtIndex(_members, index);

		public ICollection<string> Keys => _members.Keys;

		public ICollection<object> Values => _members.Values;

		public object this[string key]
		{
			get
			{
				return _members[key];
			}
			set
			{
				_members[key] = value;
			}
		}

		public int Count => _members.Count;

		public bool IsReadOnly => false;

		public JsonObject()
		{
			_members = new Dictionary<string, object>(16);
		}

		public JsonObject(IEqualityComparer<string> comparer)
		{
			_members = new Dictionary<string, object>(comparer);
		}

		internal static object GetAtIndex(IDictionary<string, object> obj, int index)
		{
			if (obj == null)
			{
				throw new ArgumentNullException("obj");
			}
			if (index >= obj.Count)
			{
				throw new ArgumentOutOfRangeException("index");
			}
			int num = 0;
			foreach (KeyValuePair<string, object> item in obj)
			{
				if (num++ == index)
				{
					return item.Value;
				}
			}
			return null;
		}

		public void Add(string key, object value)
		{
			_members.Add(key, value);
		}

		public bool ContainsKey(string key)
		{
			return _members.ContainsKey(key);
		}

		public bool Remove(string key)
		{
			return _members.Remove(key);
		}

		public bool TryGetValue(string key, out object value)
		{
			return _members.TryGetValue(key, out value);
		}

		public void Add(KeyValuePair<string, object> item)
		{
			_members.Add(item.Key, item.Value);
		}

		public void Clear()
		{
			_members.Clear();
		}

		public bool Contains(KeyValuePair<string, object> item)
		{
			if (_members.TryGetValue(item.Key, out var value))
			{
				return value == item.Value;
			}
			return false;
		}

		public void CopyTo(KeyValuePair<string, object>[] array, int arrayIndex)
		{
			if (array == null)
			{
				throw new ArgumentNullException("array");
			}
			int num = Count;
			foreach (KeyValuePair<string, object> member in _members)
			{
				array[arrayIndex++] = member;
				if (--num <= 0)
				{
					break;
				}
			}
		}

		public bool Remove(KeyValuePair<string, object> item)
		{
			return _members.Remove(item.Key);
		}

		public IEnumerator<KeyValuePair<string, object>> GetEnumerator()
		{
			return _members.GetEnumerator();
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return _members.GetEnumerator();
		}

		public override string ToString()
		{
			return PlayFabSimpleJson.SerializeObject(_members);
		}
	}
	[GeneratedCode("simple-json", "1.0.0")]
	public static class PlayFabSimpleJson
	{
		private enum TokenType : byte
		{
			NONE,
			CURLY_OPEN,
			CURLY_CLOSE,
			SQUARED_OPEN,
			SQUARED_CLOSE,
			COLON,
			COMMA,
			STRING,
			NUMBER,
			TRUE,
			FALSE,
			NULL
		}

		private const int BUILDER_INIT = 2000;

		private static readonly char[] EscapeTable;

		private static readonly char[] EscapeCharacters;

		internal static readonly List<Type> NumberTypes;

		[ThreadStatic]
		private static StringBuilder _serializeObjectBuilder;

		[ThreadStatic]
		private static StringBuilder _parseStringBuilder;

		private static IJsonSerializerStrategy _currentJsonSerializerStrategy;

		private static PocoJsonSerializerStrategy _pocoJsonSerializerStrategy;

		public static IJsonSerializerStrategy CurrentJsonSerializerStrategy
		{
			get
			{
				return _currentJsonSerializerStrategy ?? (_currentJsonSerializerStrategy = PocoJsonSerializerStrategy);
			}
			set
			{
				_currentJsonSerializerStrategy = value;
			}
		}

		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public static PocoJsonSerializerStrategy PocoJsonSerializerStrategy => _pocoJsonSerializerStrategy ?? (_pocoJsonSerializerStrategy = new PocoJsonSerializerStrategy());

		static PlayFabSimpleJson()
		{
			EscapeCharacters = new char[7] { '"', '\\', '\b', '\f', '\n', '\r', '\t' };
			NumberTypes = new List<Type>
			{
				typeof(bool),
				typeof(byte),
				typeof(ushort),
				typeof(uint),
				typeof(ulong),
				typeof(sbyte),
				typeof(short),
				typeof(int),
				typeof(long),
				typeof(double),
				typeof(float),
				typeof(decimal)
			};
			EscapeTable = new char[93];
			EscapeTable[34] = '"';
			EscapeTable[92] = '\\';
			EscapeTable[8] = 'b';
			EscapeTable[12] = 'f';
			EscapeTable[10] = 'n';
			EscapeTable[13] = 'r';
			EscapeTable[9] = 't';
		}

		public static object DeserializeObject(string json)
		{
			if (TryDeserializeObject(json, out var obj))
			{
				return obj;
			}
			throw new SerializationException("Invalid JSON string");
		}

		public static bool TryDeserializeObject(string json, out object obj)
		{
			bool success = true;
			if (json != null)
			{
				int index = 0;
				obj = ParseValue(json, ref index, ref success);
			}
			else
			{
				obj = null;
			}
			return success;
		}

		public static object DeserializeObject(string json, Type type, IJsonSerializerStrategy jsonSerializerStrategy = null)
		{
			object obj = DeserializeObject(json);
			if (type == null || (obj != null && ReflectionUtils.IsAssignableFrom(obj.GetType(), type)))
			{
				return obj;
			}
			return (jsonSerializerStrategy ?? CurrentJsonSerializerStrategy).DeserializeObject(obj, type);
		}

		public static T DeserializeObject<T>(string json, IJsonSerializerStrategy jsonSerializerStrategy = null)
		{
			return (T)DeserializeObject(json, typeof(T), jsonSerializerStrategy);
		}

		public static string SerializeObject(object json, IJsonSerializerStrategy jsonSerializerStrategy = null)
		{
			if (_serializeObjectBuilder == null)
			{
				_serializeObjectBuilder = new StringBuilder(2000);
			}
			_serializeObjectBuilder.Length = 0;
			if (jsonSerializerStrategy == null)
			{
				jsonSerializerStrategy = CurrentJsonSerializerStrategy;
			}
			if (!SerializeValue(jsonSerializerStrategy, json, _serializeObjectBuilder))
			{
				return null;
			}
			return _serializeObjectBuilder.ToString();
		}

		public static string EscapeToJavascriptString(string jsonString)
		{
			if (string.IsNullOrEmpty(jsonString))
			{
				return jsonString;
			}
			StringBuilder stringBuilder = new StringBuilder();
			int num = 0;
			while (num < jsonString.Length)
			{
				char c = jsonString[num++];
				if (c == '\\')
				{
					if (jsonString.Length - num >= 2)
					{
						switch (jsonString[num])
						{
						case '\\':
							stringBuilder.Append('\\');
							num++;
							break;
						case '"':
							stringBuilder.Append("\"");
							num++;
							break;
						case 't':
							stringBuilder.Append('\t');
							num++;
							break;
						case 'b':
							stringBuilder.Append('\b');
							num++;
							break;
						case 'n':
							stringBuilder.Append('\n');
							num++;
							break;
						case 'r':
							stringBuilder.Append('\r');
							num++;
							break;
						}
					}
				}
				else
				{
					stringBuilder.Append(c);
				}
			}
			return stringBuilder.ToString();
		}

		private static IDictionary<string, object> ParseObject(string json, ref int index, ref bool success)
		{
			IDictionary<string, object> dictionary = new JsonObject();
			NextToken(json, ref index);
			bool flag = false;
			while (!flag)
			{
				switch (LookAhead(json, index))
				{
				case TokenType.NONE:
					success = false;
					return null;
				case TokenType.COMMA:
					NextToken(json, ref index);
					continue;
				case TokenType.CURLY_CLOSE:
					NextToken(json, ref index);
					return dictionary;
				}
				string key = ParseString(json, ref index, ref success);
				if (!success)
				{
					success = false;
					return null;
				}
				TokenType tokenType = NextToken(json, ref index);
				if (tokenType != TokenType.COLON)
				{
					success = false;
					return null;
				}
				object value = ParseValue(json, ref index, ref success);
				if (!success)
				{
					success = false;
					return null;
				}
				dictionary[key] = value;
			}
			return dictionary;
		}

		private static JsonArray ParseArray(string json, ref int index, ref bool success)
		{
			JsonArray jsonArray = new JsonArray();
			NextToken(json, ref index);
			bool flag = false;
			while (!flag)
			{
				switch (LookAhead(json, index))
				{
				case TokenType.NONE:
					success = false;
					return null;
				case TokenType.COMMA:
					NextToken(json, ref index);
					continue;
				case TokenType.SQUARED_CLOSE:
					break;
				default:
				{
					object item = ParseValue(json, ref index, ref success);
					if (!success)
					{
						return null;
					}
					jsonArray.Add(item);
					continue;
				}
				}
				NextToken(json, ref index);
				break;
			}
			return jsonArray;
		}

		private static object ParseValue(string json, ref int index, ref bool success)
		{
			switch (LookAhead(json, index))
			{
			case TokenType.STRING:
				return ParseString(json, ref index, ref success);
			case TokenType.NUMBER:
				return ParseNumber(json, ref index, ref success);
			case TokenType.CURLY_OPEN:
				return ParseObject(json, ref index, ref success);
			case TokenType.SQUARED_OPEN:
				return ParseArray(json, ref index, ref success);
			case TokenType.TRUE:
				NextToken(json, ref index);
				return true;
			case TokenType.FALSE:
				NextToken(json, ref index);
				return false;
			case TokenType.NULL:
				NextToken(json, ref index);
				return null;
			default:
				success = false;
				return null;
			}
		}

		private static string ParseString(string json, ref int index, ref bool success)
		{
			if (_parseStringBuilder == null)
			{
				_parseStringBuilder = new StringBuilder(2000);
			}
			_parseStringBuilder.Length = 0;
			EatWhitespace(json, ref index);
			char c = json[index++];
			bool flag = false;
			while (!flag && index != json.Length)
			{
				c = json[index++];
				switch (c)
				{
				case '"':
					flag = true;
					break;
				case '\\':
				{
					if (index == json.Length)
					{
						break;
					}
					switch (json[index++])
					{
					case '"':
						_parseStringBuilder.Append('"');
						continue;
					case '\\':
						_parseStringBuilder.Append('\\');
						continue;
					case '/':
						_parseStringBuilder.Append('/');
						continue;
					case 'b':
						_parseStringBuilder.Append('\b');
						continue;
					case 'f':
						_parseStringBuilder.Append('\f');
						continue;
					case 'n':
						_parseStringBuilder.Append('\n');
						continue;
					case 'r':
						_parseStringBuilder.Append('\r');
						continue;
					case 't':
						_parseStringBuilder.Append('\t');
						continue;
					case 'u':
						break;
					default:
						continue;
					}
					if (json.Length - index < 4)
					{
						break;
					}
					if (!(success = uint.TryParse(json.Substring(index, 4), NumberStyles.HexNumber, CultureInfo.InvariantCulture, out var result)))
					{
						return "";
					}
					if (55296 <= result && result <= 56319)
					{
						index += 4;
						if (json.Length - index < 6 || !(json.Substring(index, 2) == "\\u") || !uint.TryParse(json.Substring(index + 2, 4), NumberStyles.HexNumber, CultureInfo.InvariantCulture, out var result2) || 56320 > result2 || result2 > 57343)
						{
							success = false;
							return "";
						}
						_parseStringBuilder.Append((char)result);
						_parseStringBuilder.Append((char)result2);
						index += 6;
					}
					else
					{
						_parseStringBuilder.Append(ConvertFromUtf32((int)result));
						index += 4;
					}
					continue;
				}
				default:
					_parseStringBuilder.Append(c);
					continue;
				}
				break;
			}
			if (!flag)
			{
				success = false;
				return null;
			}
			return _parseStringBuilder.ToString();
		}

		private static string ConvertFromUtf32(int utf32)
		{
			if (utf32 < 0 || utf32 > 1114111)
			{
				throw new ArgumentOutOfRangeException("utf32", "The argument must be from 0 to 0x10FFFF.");
			}
			if (55296 <= utf32 && utf32 <= 57343)
			{
				throw new ArgumentOutOfRangeException("utf32", "The argument must not be in surrogate pair range.");
			}
			if (utf32 < 65536)
			{
				return new string((char)utf32, 1);
			}
			utf32 -= 65536;
			return new string(new char[2]
			{
				(char)((utf32 >> 10) + 55296),
				(char)(utf32 % 1024 + 56320)
			});
		}

		private static object ParseNumber(string json, ref int index, ref bool success)
		{
			EatWhitespace(json, ref index);
			int lastIndexOfNumber = GetLastIndexOfNumber(json, index);
			int length = lastIndexOfNumber - index + 1;
			string text = json.Substring(index, length);
			object result2;
			if (text.IndexOf(".", StringComparison.OrdinalIgnoreCase) != -1 || text.IndexOf("e", StringComparison.OrdinalIgnoreCase) != -1)
			{
				success = double.TryParse(json.Substring(index, length), NumberStyles.Any, CultureInfo.InvariantCulture, out var result);
				result2 = result;
			}
			else if (text.IndexOf("-", StringComparison.OrdinalIgnoreCase) == -1)
			{
				success = ulong.TryParse(json.Substring(index, length), NumberStyles.Any, CultureInfo.InvariantCulture, out var result3);
				result2 = result3;
			}
			else
			{
				success = long.TryParse(json.Substring(index, length), NumberStyles.Any, CultureInfo.InvariantCulture, out var result4);
				result2 = result4;
			}
			index = lastIndexOfNumber + 1;
			return result2;
		}

		private static int GetLastIndexOfNumber(string json, int index)
		{
			int i;
			for (i = index; i < json.Length && "0123456789+-.eE".IndexOf(json[i]) != -1; i++)
			{
			}
			return i - 1;
		}

		private static void EatWhitespace(string json, ref int index)
		{
			while (index < json.Length && " \t\n\r\b\f".IndexOf(json[index]) != -1)
			{
				index++;
			}
		}

		private static TokenType LookAhead(string json, int index)
		{
			int index2 = index;
			return NextToken(json, ref index2);
		}

		private static TokenType NextToken(string json, ref int index)
		{
			EatWhitespace(json, ref index);
			if (index == json.Length)
			{
				return TokenType.NONE;
			}
			char c = json[index];
			index++;
			switch (c)
			{
			case '{':
				return TokenType.CURLY_OPEN;
			case '}':
				return TokenType.CURLY_CLOSE;
			case '[':
				return TokenType.SQUARED_OPEN;
			case ']':
				return TokenType.SQUARED_CLOSE;
			case ',':
				return TokenType.COMMA;
			case '"':
				return TokenType.STRING;
			case '-':
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
				return TokenType.NUMBER;
			case ':':
				return TokenType.COLON;
			default:
			{
				index--;
				int num = json.Length - index;
				if (num >= 5 && json[index] == 'f' && json[index + 1] == 'a' && json[index + 2] == 'l' && json[index + 3] == 's' && json[index + 4] == 'e')
				{
					index += 5;
					return TokenType.FALSE;
				}
				if (num >= 4 && json[index] == 't' && json[index + 1] == 'r' && json[index + 2] == 'u' && json[index + 3] == 'e')
				{
					index += 4;
					return TokenType.TRUE;
				}
				if (num >= 4 && json[index] == 'n' && json[index + 1] == 'u' && json[index + 2] == 'l' && json[index + 3] == 'l')
				{
					index += 4;
					return TokenType.NULL;
				}
				return TokenType.NONE;
			}
			}
		}

		private static bool SerializeValue(IJsonSerializerStrategy jsonSerializerStrategy, object value, StringBuilder builder)
		{
			bool flag = true;
			string text = value as string;
			if (value == null)
			{
				builder.Append("null");
			}
			else if (text != null)
			{
				flag = SerializeString(text, builder);
			}
			else
			{
				IDictionary<string, object> dictionary = value as IDictionary<string, object>;
				Type type = value.GetType();
				Type[] genericTypeArguments = ReflectionUtils.GetGenericTypeArguments(type);
				if (type.GetTypeInfo().IsGenericType && type.GetGenericTypeDefinition() == typeof(Dictionary<, >) && genericTypeArguments[0] == typeof(string))
				{
					IDictionary dictionary2 = value as IDictionary;
					flag = SerializeObject(jsonSerializerStrategy, dictionary2.Keys, dictionary2.Values, builder);
				}
				else if (dictionary != null)
				{
					flag = SerializeObject(jsonSerializerStrategy, dictionary.Keys, dictionary.Values, builder);
				}
				else if (value is IDictionary<string, string> dictionary3)
				{
					flag = SerializeObject(jsonSerializerStrategy, dictionary3.Keys, dictionary3.Values, builder);
				}
				else if (value is IEnumerable anArray)
				{
					flag = SerializeArray(jsonSerializerStrategy, anArray, builder);
				}
				else if (IsNumeric(value))
				{
					flag = SerializeNumber(value, builder);
				}
				else if (value is bool)
				{
					builder.Append(((bool)value) ? "true" : "false");
				}
				else
				{
					flag = jsonSerializerStrategy.TrySerializeNonPrimitiveObject(value, out var output);
					if (flag)
					{
						SerializeValue(jsonSerializerStrategy, output, builder);
					}
				}
			}
			return flag;
		}

		private static bool SerializeObject(IJsonSerializerStrategy jsonSerializerStrategy, IEnumerable keys, IEnumerable values, StringBuilder builder)
		{
			builder.Append("{");
			IEnumerator enumerator = keys.GetEnumerator();
			IEnumerator enumerator2 = values.GetEnumerator();
			bool flag = true;
			while (enumerator.MoveNext() && enumerator2.MoveNext())
			{
				object current = enumerator.Current;
				object current2 = enumerator2.Current;
				if (!flag)
				{
					builder.Append(",");
				}
				if (current is string aString)
				{
					SerializeString(aString, builder);
				}
				else if (!SerializeValue(jsonSerializerStrategy, current2, builder))
				{
					return false;
				}
				builder.Append(":");
				if (!SerializeValue(jsonSerializerStrategy, current2, builder))
				{
					return false;
				}
				flag = false;
			}
			builder.Append("}");
			return true;
		}

		private static bool SerializeArray(IJsonSerializerStrategy jsonSerializerStrategy, IEnumerable anArray, StringBuilder builder)
		{
			builder.Append("[");
			bool flag = true;
			foreach (object item in anArray)
			{
				if (!flag)
				{
					builder.Append(",");
				}
				if (!SerializeValue(jsonSerializerStrategy, item, builder))
				{
					return false;
				}
				flag = false;
			}
			builder.Append("]");
			return true;
		}

		private static bool SerializeString(string aString, StringBuilder builder)
		{
			if (aString.IndexOfAny(EscapeCharacters) == -1)
			{
				builder.Append('"');
				builder.Append(aString);
				builder.Append('"');
				return true;
			}
			builder.Append('"');
			int num = 0;
			char[] array = aString.ToCharArray();
			for (int i = 0; i < array.Length; i++)
			{
				char c = array[i];
				if (c >= EscapeTable.Length || EscapeTable[(uint)c] == '\0')
				{
					num++;
					continue;
				}
				if (num > 0)
				{
					builder.Append(array, i - num, num);
					num = 0;
				}
				builder.Append('\\');
				builder.Append(EscapeTable[(uint)c]);
			}
			if (num > 0)
			{
				builder.Append(array, array.Length - num, num);
			}
			builder.Append('"');
			return true;
		}

		private static bool SerializeNumber(object number, StringBuilder builder)
		{
			if (number is decimal)
			{
				builder.Append(((decimal)number).ToString("R", CultureInfo.InvariantCulture));
			}
			else if (number is double)
			{
				builder.Append(((double)number).ToString("R", CultureInfo.InvariantCulture));
			}
			else if (number is float)
			{
				builder.Append(((float)number).ToString("R", CultureInfo.InvariantCulture));
			}
			else if (NumberTypes.IndexOf(number.GetType()) != -1)
			{
				builder.Append(number);
			}
			return true;
		}

		private static bool IsNumeric(object value)
		{
			if (value is sbyte)
			{
				return true;
			}
			if (value is byte)
			{
				return true;
			}
			if (value is short)
			{
				return true;
			}
			if (value is ushort)
			{
				return true;
			}
			if (value is int)
			{
				return true;
			}
			if (value is uint)
			{
				return true;
			}
			if (value is long)
			{
				return true;
			}
			if (value is ulong)
			{
				return true;
			}
			if (value is float)
			{
				return true;
			}
			if (value is double)
			{
				return true;
			}
			if (value is decimal)
			{
				return true;
			}
			return false;
		}
	}
	[GeneratedCode("simple-json", "1.0.0")]
	public interface IJsonSerializerStrategy
	{
		bool TrySerializeNonPrimitiveObject(object input, out object output);

		object DeserializeObject(object value, Type type);
	}
	[GeneratedCode("simple-json", "1.0.0")]
	public class PocoJsonSerializerStrategy : IJsonSerializerStrategy
	{
		internal IDictionary<Type, ReflectionUtils.ConstructorDelegate> ConstructorCache;

		internal IDictionary<Type, IDictionary<MemberInfo, ReflectionUtils.GetDelegate>> GetCache;

		internal IDictionary<Type, IDictionary<string, KeyValuePair<Type, ReflectionUtils.SetDelegate>>> SetCache;

		internal static readonly Type[] EmptyTypes = new Type[0];

		internal static readonly Type[] ArrayConstructorParameterTypes = new Type[1] { typeof(int) };

		private static readonly string[] Iso8601Format = new string[3] { "yyyy-MM-dd\\THH:mm:ss.FFFFFFF\\Z", "yyyy-MM-dd\\THH:mm:ss\\Z", "yyyy-MM-dd\\THH:mm:ssK" };

		public PocoJsonSerializerStrategy()
		{
			ConstructorCache = new ReflectionUtils.ThreadSafeDictionary<Type, ReflectionUtils.ConstructorDelegate>(ContructorDelegateFactory);
			GetCache = new ReflectionUtils.ThreadSafeDictionary<Type, IDictionary<MemberInfo, ReflectionUtils.GetDelegate>>(GetterValueFactory);
			SetCache = new ReflectionUtils.ThreadSafeDictionary<Type, IDictionary<string, KeyValuePair<Type, ReflectionUtils.SetDelegate>>>(SetterValueFactory);
		}

		protected virtual string MapClrMemberNameToJsonFieldName(MemberInfo memberInfo)
		{
			object[] customAttributes = memberInfo.GetCustomAttributes(typeof(JsonProperty), inherit: true);
			for (int i = 0; i < customAttributes.Length; i++)
			{
				JsonProperty jsonProperty = (JsonProperty)customAttributes[i];
				if (!string.IsNullOrEmpty(jsonProperty.PropertyName))
				{
					return jsonProperty.PropertyName;
				}
			}
			return memberInfo.Name;
		}

		protected virtual void MapClrMemberNameToJsonFieldName(MemberInfo memberInfo, out string jsonName, out JsonProperty jsonProp)
		{
			jsonName = memberInfo.Name;
			jsonProp = null;
			object[] customAttributes = memberInfo.GetCustomAttributes(typeof(JsonProperty), inherit: true);
			for (int i = 0; i < customAttributes.Length; i++)
			{
				JsonProperty jsonProperty = (jsonProp = (JsonProperty)customAttributes[i]);
				if (!string.IsNullOrEmpty(jsonProperty.PropertyName))
				{
					jsonName = jsonProperty.PropertyName;
				}
			}
		}

		internal virtual ReflectionUtils.ConstructorDelegate ContructorDelegateFactory(Type key)
		{
			return ReflectionUtils.GetContructor(key, key.IsArray ? ArrayConstructorParameterTypes : EmptyTypes);
		}

		internal virtual IDictionary<MemberInfo, ReflectionUtils.GetDelegate> GetterValueFactory(Type type)
		{
			IDictionary<MemberInfo, ReflectionUtils.GetDelegate> dictionary = new Dictionary<MemberInfo, ReflectionUtils.GetDelegate>();
			foreach (PropertyInfo property in ReflectionUtils.GetProperties(type))
			{
				if (property.CanRead)
				{
					MethodInfo getterMethodInfo = ReflectionUtils.GetGetterMethodInfo(property);
					if (!getterMethodInfo.IsStatic && getterMethodInfo.IsPublic)
					{
						dictionary[property] = ReflectionUtils.GetGetMethod(property);
					}
				}
			}
			foreach (FieldInfo field in ReflectionUtils.GetFields(type))
			{
				if (!field.IsStatic && field.IsPublic)
				{
					dictionary[field] = ReflectionUtils.GetGetMethod(field);
				}
			}
			return dictionary;
		}

		internal virtual IDictionary<string, KeyValuePair<Type, ReflectionUtils.SetDelegate>> SetterValueFactory(Type type)
		{
			IDictionary<string, KeyValuePair<Type, ReflectionUtils.SetDelegate>> dictionary = new Dictionary<string, KeyValuePair<Type, ReflectionUtils.SetDelegate>>();
			foreach (PropertyInfo property in ReflectionUtils.GetProperties(type))
			{
				if (property.CanWrite)
				{
					MethodInfo setterMethodInfo = ReflectionUtils.GetSetterMethodInfo(property);
					if (!setterMethodInfo.IsStatic && setterMethodInfo.IsPublic)
					{
						dictionary[MapClrMemberNameToJsonFieldName(property)] = new KeyValuePair<Type, ReflectionUtils.SetDelegate>(property.PropertyType, ReflectionUtils.GetSetMethod(property));
					}
				}
			}
			foreach (FieldInfo field in ReflectionUtils.GetFields(type))
			{
				if (!field.IsInitOnly && !field.IsStatic && field.IsPublic)
				{
					dictionary[MapClrMemberNameToJsonFieldName(field)] = new KeyValuePair<Type, ReflectionUtils.SetDelegate>(field.FieldType, ReflectionUtils.GetSetMethod(field));
				}
			}
			return dictionary;
		}

		public virtual bool TrySerializeNonPrimitiveObject(object input, out object output)
		{
			if (!TrySerializeKnownTypes(input, out output))
			{
				return TrySerializeUnknownTypes(input, out output);
			}
			return true;
		}

		public virtual object DeserializeObject(object value, Type type)
		{
			if (type == null)
			{
				throw new ArgumentNullException("type");
			}
			if (value != null && type.IsInstanceOfType(value))
			{
				return value;
			}
			string text = value as string;
			if (type == typeof(Guid) && string.IsNullOrEmpty(text))
			{
				return default(Guid);
			}
			if (value == null)
			{
				return null;
			}
			object result = null;
			if (text != null)
			{
				if (text.Length != 0)
				{
					if (type == typeof(DateTime) || (ReflectionUtils.IsNullableType(type) && Nullable.GetUnderlyingType(type) == typeof(DateTime)))
					{
						return DateTime.ParseExact(text, Iso8601Format, CultureInfo.InvariantCulture, DateTimeStyles.AdjustToUniversal | DateTimeStyles.AssumeUniversal);
					}
					if (type == typeof(DateTimeOffset) || (ReflectionUtils.IsNullableType(type) && Nullable.GetUnderlyingType(type) == typeof(DateTimeOffset)))
					{
						return DateTimeOffset.ParseExact(text, Iso8601Format, CultureInfo.InvariantCulture, DateTimeStyles.AdjustToUniversal | DateTimeStyles.AssumeUniversal);
					}
					if (type == typeof(Guid) || (ReflectionUtils.IsNullableType(type) && Nullable.GetUnderlyingType(type) == typeof(Guid)))
					{
						return new Guid(text);
					}
					if (type == typeof(Uri))
					{
						if (Uri.IsWellFormedUriString(text, UriKind.RelativeOrAbsolute) && Uri.TryCreate(text, UriKind.RelativeOrAbsolute, out var result2))
						{
							return result2;
						}
						return null;
					}
					if (type == typeof(string))
					{
						return text;
					}
					return Convert.ChangeType(text, type, CultureInfo.InvariantCulture);
				}
				result = ((type == typeof(Guid)) ? ((object)default(Guid)) : ((!ReflectionUtils.IsNullableType(type) || !(Nullable.GetUnderlyingType(type) == typeof(Guid))) ? text : null));
				if (!ReflectionUtils.IsNullableType(type) && Nullable.GetUnderlyingType(type) == typeof(Guid))
				{
					return text;
				}
			}
			else if (value is bool)
			{
				return value;
			}
			bool flag = value is long;
			bool flag2 = value is ulong;
			bool flag3 = value is double;
			Type underlyingType = Nullable.GetUnderlyingType(type);
			if (underlyingType != null && PlayFabSimpleJson.NumberTypes.IndexOf(underlyingType) != -1)
			{
				type = underlyingType;
			}
			bool flag4 = PlayFabSimpleJson.NumberTypes.IndexOf(type) != -1;
			bool isEnum = type.GetTypeInfo().IsEnum;
			if ((flag && type == typeof(long)) || (flag2 && type == typeof(ulong)) || (flag3 && type == typeof(double)))
			{
				return value;
			}
			if ((flag || flag2 || flag3) && isEnum)
			{
				return Enum.ToObject(type, Convert.ChangeType(value, Enum.GetUnderlyingType(type), CultureInfo.InvariantCulture));
			}
			if ((flag || flag2 || flag3) && flag4)
			{
				return Convert.ChangeType(value, type, CultureInfo.InvariantCulture);
			}
			if (value is IDictionary<string, object> dictionary)
			{
				IDictionary<string, object> dictionary2 = dictionary;
				if (ReflectionUtils.IsTypeDictionary(type))
				{
					Type[] genericTypeArguments = ReflectionUtils.GetGenericTypeArguments(type);
					Type type2 = genericTypeArguments[0];
					Type type3 = genericTypeArguments[1];
					Type key = typeof(Dictionary<, >).MakeGenericType(type2, type3);
					IDictionary dictionary3 = (IDictionary)ConstructorCache[key]();
					foreach (KeyValuePair<string, object> item in dictionary2)
					{
						dictionary3.Add(item.Key, DeserializeObject(item.Value, type3));
					}
					result = dictionary3;
				}
				else if (type == typeof(object))
				{
					result = value;
				}
				else
				{
					result = ConstructorCache[type]();
					foreach (KeyValuePair<string, KeyValuePair<Type, ReflectionUtils.SetDelegate>> item2 in SetCache[type])
					{
						if (dictionary2.TryGetValue(item2.Key, out var value2))
						{
							value2 = DeserializeObject(value2, item2.Value.Key);
							item2.Value.Value(result, value2);
						}
					}
				}
				if (ReflectionUtils.IsNullableType(type))
				{
					return ReflectionUtils.ToNullableType(result, type);
				}
				return result;
			}
			if (value is IList<object> list)
			{
				IList<object> list2 = list;
				IList list3 = null;
				if (type.IsArray)
				{
					list3 = (IList)ConstructorCache[type](list2.Count);
					int num = 0;
					foreach (object item3 in list2)
					{
						list3[num++] = DeserializeObject(item3, type.GetElementType());
					}
				}
				else if (ReflectionUtils.IsTypeGenericeCollectionInterface(type) || ReflectionUtils.IsAssignableFrom(typeof(IList), type) || type == typeof(object))
				{
					Type genericListElementType = ReflectionUtils.GetGenericListElementType(type);
					ReflectionUtils.ConstructorDelegate constructorDelegate = null;
					if (type != typeof(object))
					{
						constructorDelegate = ConstructorCache[type];
					}
					if (constructorDelegate == null)
					{
						constructorDelegate = ConstructorCache[typeof(List<>).MakeGenericType(genericListElementType)];
					}
					list3 = (IList)constructorDelegate();
					foreach (object item4 in list2)
					{
						list3.Add(DeserializeObject(item4, genericListElementType));
					}
				}
				result = list3;
			}
			return result;
		}

		protected virtual object SerializeEnum(Enum p)
		{
			return Convert.ToDouble(p, CultureInfo.InvariantCulture);
		}

		protected virtual bool TrySerializeKnownTypes(object input, out object output)
		{
			bool result = true;
			if (input is DateTime)
			{
				output = ((DateTime)input).ToUniversalTime().ToString(Iso8601Format[0], CultureInfo.InvariantCulture);
			}
			else if (input is DateTimeOffset)
			{
				output = ((DateTimeOffset)input).ToUniversalTime().ToString(Iso8601Format[0], CultureInfo.InvariantCulture);
			}
			else if (input is Guid)
			{
				output = ((Guid)input).ToString("D");
			}
			else if (input is Uri)
			{
				output = input.ToString();
			}
			else if (input is Enum p)
			{
				output = SerializeEnum(p);
			}
			else
			{
				result = false;
				output = null;
			}
			return result;
		}

		protected virtual bool TrySerializeUnknownTypes(object input, out object output)
		{
			if (input == null)
			{
				throw new ArgumentNullException("input");
			}
			output = null;
			Type type = input.GetType();
			if (type.FullName == null)
			{
				return false;
			}
			IDictionary<string, object> dictionary = new JsonObject();
			foreach (KeyValuePair<MemberInfo, ReflectionUtils.GetDelegate> item in GetCache[type])
			{
				if (item.Value != null)
				{
					MapClrMemberNameToJsonFieldName(item.Key, out var jsonName, out var jsonProp);
					if (dictionary.ContainsKey(jsonName))
					{
						throw new Exception("The given key is defined multiple times in the same type: " + input.GetType().Name + "." + jsonName);
					}
					object obj = item.Value(input);
					if (jsonProp == null || jsonProp.NullValueHandling == NullValueHandling.Include || obj != null)
					{
						dictionary.Add(jsonName, obj);
					}
				}
			}
			output = dictionary;
			return true;
		}
	}
	[GeneratedCode("reflection-utils", "1.0.0")]
	internal class ReflectionUtils
	{
		public delegate object GetDelegate(object source);

		public delegate void SetDelegate(object source, object value);

		public delegate object ConstructorDelegate(params object[] args);

		public delegate TValue ThreadSafeDictionaryValueFactory<TKey, TValue>(TKey key);

		public sealed class ThreadSafeDictionary<TKey, TValue> : IDictionary<TKey, TValue>, ICollection<KeyValuePair<TKey, TValue>>, IEnumerable<KeyValuePair<TKey, TValue>>, IEnumerable
		{
			private readonly object _lock = new object();

			private readonly ThreadSafeDictionaryValueFactory<TKey, TValue> _valueFactory;

			private Dictionary<TKey, TValue> _dictionary;

			public ICollection<TKey> Keys => _dictionary.Keys;

			public ICollection<TValue> Values => _dictionary.Values;

			public TValue this[TKey key]
			{
				get
				{
					return Get(key);
				}
				set
				{
					throw new NotImplementedException();
				}
			}

			public int Count => _dictionary.Count;

			public bool IsReadOnly
			{
				get
				{
					throw new NotImplementedException();
				}
			}

			public ThreadSafeDictionary(ThreadSafeDictionaryValueFactory<TKey, TValue> valueFactory)
			{
				_valueFactory = valueFactory;
			}

			private TValue Get(TKey key)
			{
				if (_dictionary == null)
				{
					return AddValue(key);
				}
				if (!_dictionary.TryGetValue(key, out var value))
				{
					return AddValue(key);
				}
				return value;
			}

			private TValue AddValue(TKey key)
			{
				TValue val = _valueFactory(key);
				lock (_lock)
				{
					if (_dictionary == null)
					{
						_dictionary = new Dictionary<TKey, TValue>();
						_dictionary[key] = val;
					}
					else
					{
						if (_dictionary.TryGetValue(key, out var value))
						{
							return value;
						}
						Dictionary<TKey, TValue> dictionary = new Dictionary<TKey, TValue>(_dictionary);
						dictionary[key] = val;
						_dictionary = dictionary;
					}
				}
				return val;
			}

			public void Add(TKey key, TValue value)
			{
				throw new NotImplementedException();
			}

			public bool ContainsKey(TKey key)
			{
				return _dictionary.ContainsKey(key);
			}

			public bool Remove(TKey key)
			{
				throw new NotImplementedException();
			}

			public bool TryGetValue(TKey key, out TValue value)
			{
				value = this[key];
				return true;
			}

			public void Add(KeyValuePair<TKey, TValue> item)
			{
				throw new NotImplementedException();
			}

			public void Clear()
			{
				throw new NotImplementedException();
			}

			public bool Contains(KeyValuePair<TKey, TValue> item)
			{
				throw new NotImplementedException();
			}

			public void CopyTo(KeyValuePair<TKey, TValue>[] array, int arrayIndex)
			{
				throw new NotImplementedException();
			}

			public bool Remove(KeyValuePair<TKey, TValue> item)
			{
				throw new NotImplementedException();
			}

			public IEnumerator<KeyValuePair<TKey, TValue>> GetEnumerator()
			{
				return _dictionary.GetEnumerator();
			}

			IEnumerator IEnumerable.GetEnumerator()
			{
				return _dictionary.GetEnumerator();
			}
		}

		private static readonly object[] EmptyObjects = new object[0];

		[ThreadStatic]
		private static object[] _1ObjArray;

		public static Type GetTypeInfo(Type type)
		{
			return type;
		}

		public static Attribute GetAttribute(MemberInfo info, Type type)
		{
			if (info == null || type == null || !Attribute.IsDefined(info, type))
			{
				return null;
			}
			return Attribute.GetCustomAttribute(info, type);
		}

		public static Type GetGenericListElementType(Type type)
		{
			if (type == typeof(object))
			{
				return type;
			}
			foreach (Type item in (IEnumerable<Type>)type.GetInterfaces())
			{
				if (IsTypeGeneric(item) && item.GetGenericTypeDefinition() == typeof(IList<>))
				{
					return GetGenericTypeArguments(item)[0];
				}
			}
			return GetGenericTypeArguments(type)[0];
		}

		public static Attribute GetAttribute(Type objectType, Type attributeType)
		{
			if (objectType == null || attributeType == null || !Attribute.IsDefined(objectType, attributeType))
			{
				return null;
			}
			return Attribute.GetCustomAttribute(objectType, attributeType);
		}

		public static Type[] GetGenericTypeArguments(Type type)
		{
			return type.GetGenericArguments();
		}

		public static bool IsTypeGeneric(Type type)
		{
			return GetTypeInfo(type).IsGenericType;
		}

		public static bool IsTypeGenericeCollectionInterface(Type type)
		{
			if (!IsTypeGeneric(type))
			{
				return false;
			}
			Type genericTypeDefinition = type.GetGenericTypeDefinition();
			if (!(genericTypeDefinition == typeof(IList<>)) && !(genericTypeDefinition == typeof(ICollection<>)))
			{
				return genericTypeDefinition == typeof(IEnumerable<>);
			}
			return true;
		}

		public static bool IsAssignableFrom(Type type1, Type type2)
		{
			return GetTypeInfo(type1).IsAssignableFrom(GetTypeInfo(type2));
		}

		public static bool IsTypeDictionary(Type type)
		{
			if (typeof(IDictionary).IsAssignableFrom(type))
			{
				return true;
			}
			if (!GetTypeInfo(type).IsGenericType)
			{
				return false;
			}
			Type genericTypeDefinition = type.GetGenericTypeDefinition();
			if (!(genericTypeDefinition == typeof(IDictionary<, >)))
			{
				return genericTypeDefinition == typeof(Dictionary<, >);
			}
			return true;
		}

		public static bool IsNullableType(Type type)
		{
			if (GetTypeInfo(type).IsGenericType)
			{
				return type.GetGenericTypeDefinition() == typeof(Nullable<>);
			}
			return false;
		}

		public static object ToNullableType(object obj, Type nullableType)
		{
			if (obj != null)
			{
				return Convert.ChangeType(obj, Nullable.GetUnderlyingType(nullableType), CultureInfo.InvariantCulture);
			}
			return null;
		}

		public static bool IsValueType(Type type)
		{
			return GetTypeInfo(type).IsValueType;
		}

		public static IEnumerable<ConstructorInfo> GetConstructors(Type type)
		{
			return type.GetConstructors();
		}

		public static ConstructorInfo GetConstructorInfo(Type type, params Type[] argsType)
		{
			foreach (ConstructorInfo constructor in GetConstructors(type))
			{
				ParameterInfo[] parameters = constructor.GetParameters();
				if (argsType.Length != parameters.Length)
				{
					continue;
				}
				int num = 0;
				bool flag = true;
				ParameterInfo[] parameters2 = constructor.GetParameters();
				for (int i = 0; i < parameters2.Length; i++)
				{
					if (parameters2[i].ParameterType != argsType[num])
					{
						flag = false;
						break;
					}
				}
				if (flag)
				{
					return constructor;
				}
			}
			return null;
		}

		public static IEnumerable<PropertyInfo> GetProperties(Type type)
		{
			return type.GetProperties(BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		}

		public static IEnumerable<FieldInfo> GetFields(Type type)
		{
			return type.GetFields(BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		}

		public static MethodInfo GetGetterMethodInfo(PropertyInfo propertyInfo)
		{
			return propertyInfo.GetGetMethod(nonPublic: true);
		}

		public static MethodInfo GetSetterMethodInfo(PropertyInfo propertyInfo)
		{
			return propertyInfo.GetSetMethod(nonPublic: true);
		}

		public static ConstructorDelegate GetContructor(ConstructorInfo constructorInfo)
		{
			return GetConstructorByReflection(constructorInfo);
		}

		public static ConstructorDelegate GetContructor(Type type, params Type[] argsType)
		{
			return GetConstructorByReflection(type, argsType);
		}

		public static ConstructorDelegate GetConstructorByReflection(ConstructorInfo constructorInfo)
		{
			return (object[] args) => constructorInfo.Invoke(args);
		}

		public static ConstructorDelegate GetConstructorByReflection(Type type, params Type[] argsType)
		{
			ConstructorInfo constructorInfo = GetConstructorInfo(type, argsType);
			if (!(constructorInfo == null))
			{
				return GetConstructorByReflection(constructorInfo);
			}
			return null;
		}

		public static GetDelegate GetGetMethod(PropertyInfo propertyInfo)
		{
			return GetGetMethodByReflection(propertyInfo);
		}

		public static GetDelegate GetGetMethod(FieldInfo fieldInfo)
		{
			return GetGetMethodByReflection(fieldInfo);
		}

		public static GetDelegate GetGetMethodByReflection(PropertyInfo propertyInfo)
		{
			MethodInfo methodInfo = GetGetterMethodInfo(propertyInfo);
			return (object source) => methodInfo.Invoke(source, EmptyObjects);
		}

		public static GetDelegate GetGetMethodByReflection(FieldInfo fieldInfo)
		{
			return (object source) => fieldInfo.GetValue(source);
		}

		public static SetDelegate GetSetMethod(PropertyInfo propertyInfo)
		{
			return GetSetMethodByReflection(propertyInfo);
		}

		public static SetDelegate GetSetMethod(FieldInfo fieldInfo)
		{
			return GetSetMethodByReflection(fieldInfo);
		}

		public static SetDelegate GetSetMethodByReflection(PropertyInfo propertyInfo)
		{
			MethodInfo methodInfo = GetSetterMethodInfo(propertyInfo);
			return delegate(object source, object value)
			{
				if (_1ObjArray == null)
				{
					_1ObjArray = new object[1];
				}
				_1ObjArray[0] = value;
				methodInfo.Invoke(source, _1ObjArray);
			};
		}

		public static SetDelegate GetSetMethodByReflection(FieldInfo fieldInfo)
		{
			return delegate(object source, object value)
			{
				fieldInfo.SetValue(source, value);
			};
		}
	}
}
namespace PlayFab.ProfilesModels
{
	public enum EffectType
	{
		Allow,
		Deny
	}
	[Serializable]
	public class EntityDataObject : PlayFabBaseModel
	{
		public object DataObject;

		public string EscapedDataObject;

		public string ObjectName;
	}
	[Serializable]
	public class EntityKey : PlayFabBaseModel
	{
		public string Id;

		public string Type;
	}
	[Serializable]
	public class EntityLineage : PlayFabBaseModel
	{
		public string CharacterId;

		public string GroupId;

		public string MasterPlayerAccountId;

		public string NamespaceId;

		public string TitleId;

		public string TitlePlayerAccountId;
	}
	[Serializable]
	public class EntityPermissionStatement : PlayFabBaseModel
	{
		public string Action;

		public string Comment;

		public object Condition;

		public EffectType Effect;

		public object Principal;

		public string Resource;
	}
	[Serializable]
	public class EntityProfileBody : PlayFabBaseModel
	{
		public string AvatarUrl;

		public DateTime Created;

		public string DisplayName;

		public EntityKey Entity;

		public string EntityChain;

		public Dictionary<string, EntityProfileFileMetadata> Files;

		public string Language;

		public string LeaderboardMetadata;

		public EntityLineage Lineage;

		public Dictionary<string, EntityDataObject> Objects;

		public List<EntityPermissionStatement> Permissions;

		public Dictionary<string, EntityStatisticValue> Statistics;

		public int VersionNumber;
	}
	[Serializable]
	public class EntityProfileFileMetadata : PlayFabBaseModel
	{
		public string Checksum;

		public string FileName;

		public DateTime LastModified;

		public int Size;
	}
	[Serializable]
	public class EntityStatisticChildValue : PlayFabBaseModel
	{
		public string ChildName;

		public string Metadata;

		public int Value;
	}
	[Serializable]
	public class EntityStatisticValue : PlayFabBaseModel
	{
		public Dictionary<string, EntityStatisticChildValue> ChildStatistics;

		public string Metadata;

		public string Name;

		public int? Value;

		public int Version;
	}
	[Serializable]
	public class GetEntityProfileRequest : PlayFabRequestCommon
	{
		public bool? DataAsObject;

		public EntityKey Entity;
	}
	[Serializable]
	public class GetEntityProfileResponse : PlayFabResultCommon
	{
		public EntityProfileBody Profile;
	}
	[Serializable]
	public class GetEntityProfilesRequest : PlayFabRequestCommon
	{
		public bool? DataAsObject;

		public List<EntityKey> Entities;
	}
	[Serializable]
	public class GetEntityProfilesResponse : PlayFabResultCommon
	{
		public List<EntityProfileBody> Profiles;
	}
	[Serializable]
	public class GetGlobalPolicyRequest : PlayFabRequestCommon
	{
	}
	[Serializable]
	public class GetGlobalPolicyResponse : PlayFabResultCommon
	{
		public List<EntityPermissionStatement> Permissions;
	}
	[Serializable]
	public class GetTitlePlayersFromMasterPlayerAccountIdsRequest : PlayFabRequestCommon
	{
		public List<string> MasterPlayerAccountIds;

		public string TitleId;
	}
	[Serializable]
	public class GetTitlePlayersFromMasterPlayerAccountIdsResponse : PlayFabResultCommon
	{
		public Dictionary<string, EntityKey> TitlePlayerAccounts;
	}
	public enum OperationTypes
	{
		Created,
		Updated,
		Deleted,
		None
	}
	[Serializable]
	public class SetEntityProfilePolicyRequest : PlayFabRequestCommon
	{
		public EntityKey Entity;

		public List<EntityPermissionStatement> Statements;
	}
	[Serializable]
	public class SetEntityProfilePolicyResponse : PlayFabResultCommon
	{
		public List<EntityPermissionStatement> Permissions;
	}
	[Serializable]
	public class SetGlobalPolicyRequest : PlayFabRequestCommon
	{
		public List<EntityPermissionStatement> Permissions;
	}
	[Serializable]
	public class SetGlobalPolicyResponse : PlayFabResultCommon
	{
	}
	[Serializable]
	public class SetProfileLanguageRequest : PlayFabRequestCommon
	{
		public EntityKey Entity;

		public int? ExpectedVersion;

		public string Language;
	}
	[Serializable]
	public class SetProfileLanguageResponse : PlayFabResultCommon
	{
		public OperationTypes? OperationResult;

		public int? VersionNumber;
	}
}
namespace PlayFab.MultiplayerModels
{
	[Serializable]
	public class AssetReference : PlayFabBaseModel
	{
		public string FileName;

		public string MountPath;
	}
	[Serializable]
	public class AssetReferenceParams : PlayFabBaseModel
	{
		public string FileName;

		public string MountPath;
	}
	[Serializable]
	public class AssetSummary : PlayFabBaseModel
	{
		public string FileName;

		public Dictionary<string, string> Metadata;
	}
	public enum AzureRegion
	{
		AustraliaEast,
		AustraliaSoutheast,
		BrazilSouth,
		CentralUs,
		EastAsia,
		EastUs,
		EastUs2,
		JapanEast,
		JapanWest,
		NorthCentralUs,
		NorthEurope,
		SouthCentralUs,
		SoutheastAsia,
		WestEurope,
		WestUs,
		ChinaEast2,
		ChinaNorth2,
		SouthAfricaNorth
	}
	public enum AzureVmFamily
	{
		A,
		Av2,
		Dv2,
		F,
		Fsv2
	}
	public enum AzureVmSize
	{
		Standard_D1_v2,
		Standard_D2_v2,
		Standard_D3_v2,
		Standard_D4_v2,
		Standard_D5_v2,
		Standard_A1_v2,
		Standard_A2_v2,
		Standard_A4_v2,
		Standard_A8_v2,
		Standard_F1,
		Standard_F2,
		Standard_F4,
		Standard_F8,
		Standard_F16,
		Standard_F2s_v2,
		Standard_F4s_v2,
		Standard_F8s_v2,
		Standard_F16s_v2,
		Standard_A1,
		Standard_A2,
		Standard_A3,
		Standard_A4
	}
	[Serializable]
	public class BuildRegion : PlayFabBaseModel
	{
		public CurrentServerStats CurrentServerStats;

		public int MaxServers;

		public string Region;

		public int StandbyServers;

		public string Status;
	}
	[Serializable]
	public class BuildRegionParams : PlayFabBaseModel
	{
		public int MaxServers;

		public string Region;

		public int StandbyServers;
	}
	[Serializable]
	public class BuildSummary : PlayFabBaseModel
	{
		public string BuildId;

		public string BuildName;

		public DateTime? CreationTime;

		public Dictionary<string, string> Metadata;

		public List<BuildRegion> RegionConfigurations;
	}
	[Serializable]
	public class CancelAllMatchmakingTicketsForPlayerRequest : PlayFabRequestCommon
	{
		public EntityKey Entity;

		public string QueueName;
	}
	[Serializable]
	public class CancelAllMatchmakingTicketsForPlayerResult : PlayFabResultCommon
	{
	}
	public enum CancellationReason
	{
		Requested,
		Internal,
		Timeout
	}
	[Serializable]
	public class CancelMatchmakingTicketRequest : PlayFabRequestCommon
	{
		public string QueueName;

		public string TicketId;
	}
	[Serializable]
	public class CancelMatchmakingTicketResult : PlayFabResultCommon
	{
	}
	[Serializable]
	public class Certificate : PlayFabBaseModel
	{
		public string Base64EncodedValue;

		public string Name;

		public string Password;
	}
	[Serializable]
	public class CertificateSummary : PlayFabBaseModel
	{
		public string Name;

		public string Thumbprint;
	}
	[Serializable]
	public class ConnectedPlayer : PlayFabBaseModel
	{
		public string PlayerId;
	}
	public enum ContainerFlavor
	{
		ManagedWindowsServerCore,
		CustomLinux,
		ManagedWindowsServerCorePreview
	}
	[Serializable]
	public class ContainerImageReference : PlayFabBaseModel
	{
		public string ImageName;

		public string Tag;
	}
	[Serializable]
	public class CoreCapacity : PlayFabBaseModel
	{
		public int Available;

		public string Region;

		public int Total;

		public AzureVmFamily? VmFamily;
	}
	[Serializable]
	public class CreateBuildWithCustomContainerRequest : PlayFabRequestCommon
	{
		public string BuildName;

		public ContainerFlavor? ContainerFlavor;

		public ContainerImageReference ContainerImageReference;

		public string ContainerRunCommand;

		public List<AssetReferenceParams> GameAssetReferences;

		public List<GameCertificateReferenceParams> GameCertificateReferences;

		public Dictionary<string, string> Metadata;

		public int MultiplayerServerCountPerVm;

		public List<Port> Ports;

		public List<BuildRegionParams> RegionConfigurations;

		public AzureVmSize? VmSize;
	}
	[Serializable]
	public class CreateBuildWithCustomContainerResponse : PlayFabResultCommon
	{
		public string BuildId;

		public string BuildName;

		public ContainerFlavor? ContainerFlavor;

		public string ContainerRunCommand;

		public DateTime? CreationTime;

		public ContainerImageReference CustomGameContainerImage;

		public List<AssetReference> GameAssetReferences;

		public List<GameCertificateReference> GameCertificateReferences;

		public Dictionary<string, string> Metadata;

		public int MultiplayerServerCountPerVm;

		public List<Port> Ports;

		public List<BuildRegion> RegionConfigurations;

		public AzureVmSize? VmSize;
	}
	[Serializable]
	public class CreateBuildWithManagedContainerRequest : PlayFabRequestCommon
	{
		public string BuildName;

		public ContainerFlavor? ContainerFlavor;

		public List<AssetReferenceParams> GameAssetReferences;

		public List<GameCertificateReferenceParams> GameCertificateReferences;

		public InstrumentationConfiguration InstrumentationConfiguration;

		public Dictionary<string, string> Metadata;

		public int MultiplayerServerCountPerVm;

		public List<Port> Ports;

		public List<BuildRegionParams> RegionConfigurations;

		public string StartMultiplayerServerCommand;

		public AzureVmSize? VmSize;
	}
	[Serializable]
	public class CreateBuildWithManagedContainerResponse : PlayFabResultCommon
	{
		public string BuildId;

		public string BuildName;

		public ContainerFlavor? ContainerFlavor;

		public DateTime? CreationTime;

		public List<AssetReference> GameAssetReferences;

		public List<GameCertificateReference> GameCertificateReferences;

		public InstrumentationConfiguration InstrumentationConfiguration;

		public Dictionary<string, string> Metadata;

		public int MultiplayerServerCountPerVm;

		public List<Port> Ports;

		public List<BuildRegion> RegionConfigurations;

		public string StartMultiplayerServerCommand;

		public AzureVmSize? VmSize;
	}
	[Serializable]
	public class CreateMatchmakingTicketRequest : PlayFabRequestCommon
	{
		public MatchmakingPlayer Creator;

		public int GiveUpAfterSeconds;

		public List<EntityKey> MembersToMatchWith;

		public string QueueName;
	}
	[Serializable]
	public class CreateMatchmakingTicketResult : PlayFabResultCommon
	{
		public string TicketId;
	}
	[Serializable]
	public class CreateRemoteUserRequest : PlayFabRequestCommon
	{
		public string BuildId;

		public DateTime? ExpirationTime;

		public string Region;

		public string Username;

		public string VmId;
	}
	[Serializable]
	public class CreateRemoteUserResponse : PlayFabResultCommon
	{
		public DateTime? ExpirationTime;

		public string Password;

		public string Username;
	}
	[Serializable]
	public class CreateServerMatchmakingTicketRequest : PlayFabRequestCommon
	{
		public int GiveUpAfterSeconds;

		public List<MatchmakingPlayer> Members;

		public string QueueName;
	}
	[Serializable]
	public class CurrentServerStats : PlayFabBaseModel
	{
		public int Active;

		public int Propping;

		public int StandingBy;

		public int Total;
	}
	[Serializable]
	public class DeleteAssetRequest : PlayFabRequestCommon
	{
		public string FileName;
	}
	[Serializable]
	public class DeleteBuildRequest : PlayFabRequestCommon
	{
		public string BuildId;
	}
	[Serializable]
	public class DeleteCertificateRequest : PlayFabRequestCommon
	{
		public string Name;
	}
	[Serializable]
	public class DeleteRemoteUserRequest : PlayFabRequestCommon
	{
		public string BuildId;

		public string Region;

		public string Username;

		public string VmId;
	}
	[Serializable]
	public class EmptyResponse : PlayFabResultCommon
	{
	}
	[Serializable]
	public class EnableMultiplayerServersForTitleRequest : PlayFabRequestCommon
	{
	}
	[Serializable]
	public class EnableMultiplayerServersForTitleResponse : PlayFabResultCommon
	{
		public TitleMultiplayerServerEnabledStatus? Status;
	}
	[Serializable]
	public class EntityKey : PlayFabBaseModel
	{
		public string Id;

		public string Type;
	}
	[Serializable]
	public class GameCertificateReference : PlayFabBaseModel
	{
		public string GsdkAlias;

		public string Name;
	}
	[Serializable]
	public class GameCertificateReferenceParams : PlayFabBaseModel
	{
		public string GsdkAlias;

		public string Name;
	}
	[Serializable]
	public class GetAssetUploadUrlRequest : PlayFabRequestCommon
	{
		public string FileName;
	}
	[Serializable]
	public class GetAssetUploadUrlResponse : PlayFabResultCommon
	{
		public string AssetUploadUrl;

		public string FileName;
	}
	[Serializable]
	public class GetBuildRequest : PlayFabRequestCommon
	{
		public string BuildId;
	}
	[Serializable]
	public class GetBuildResponse : PlayFabResultCommon
	{
		public string BuildId;

		public string BuildName;

		public string BuildStatus;

		public ContainerFlavor? ContainerFlavor;

		public string ContainerRunCommand;

		public DateTime? CreationTime;

		public ContainerImageReference CustomGameContainerImage;

		public List<AssetReference> GameAssetReferences;

		public List<GameCertificateReference> GameCertificateReferences;

		public InstrumentationConfiguration InstrumentationConfiguration;

		public Dictionary<string, string> Metadata;

		public int MultiplayerServerCountPerVm;

		public List<Port> Ports;

		public List<BuildRegion> RegionConfigurations;

		public string StartMultiplayerServerCommand;

		public AzureVmSize? VmSize;
	}
	[Serializable]
	public class GetContainerRegistryCredentialsRequest : PlayFabRequestCommon
	{
	}
	[Serializable]
	public class GetContainerRegistryCredentialsResponse : PlayFabResultCommon
	{
		public string DnsName;

		public string Password;

		public string Username;
	}
	[Serializable]
	public class GetMatchmakingTicketRequest : PlayFabRequestCommon
	{
		public bool EscapeObject;

		public string QueueName;

		public string TicketId;
	}
	[Serializable]
	public class GetMatchmakingTicketResult : PlayFabResultCommon
	{
		[Obsolete("Use 'CancellationReasonString' instead", false)]
		public CancellationReason? CancellationReason;

		public string CancellationReasonString;

		public DateTime Created;

		public EntityKey Creator;

		public int GiveUpAfterSeconds;

		public string MatchId;

		public List<MatchmakingPlayer> Members;

		public List<EntityKey> MembersToMatchWith;

		public string QueueName;

		public string Status;

		public string TicketId;
	}
	[Serializable]
	public class GetMatchRequest : PlayFabRequestCommon
	{
		public bool EscapeObject;

		public string MatchId;

		public string QueueName;

		public bool ReturnMemberAttributes;
	}
	[Serializable]
	public class GetMatchResult : PlayFabResultCommon
	{
		public string MatchId;

		public List<MatchmakingPlayerWithTeamAssignment> Members;

		public List<string> RegionPreferences;

		public ServerDetails ServerDetails;
	}
	[Serializable]
	public class GetMultiplayerServerDetailsRequest : PlayFabRequestCommon
	{
		public string BuildId;

		public string Region;

		public string SessionId;
	}
	[Serializable]
	public class GetMultiplayerServerDetailsResponse : PlayFabResultCommon
	{
		public List<ConnectedPlayer> ConnectedPlayers;

		public string FQDN;

		public string IPV4Address;

		public DateTime? LastStateTransitionTime;

		public List<Port> Ports;

		public string Region;

		public string ServerId;

		public string SessionId;

		public string State;

		public string VmId;
	}
	[Serializable]
	public class GetQueueStatisticsRequest : PlayFabRequestCommon
	{
		public string QueueName;
	}
	[Serializable]
	public class GetQueueStatisticsResult : PlayFabResultCommon
	{
		public uint? NumberOfPlayersMatching;

		public Statistics TimeToMatchStatisticsInSeconds;
	}
	[Serializable]
	public class GetRemoteLoginEndpointRequest : PlayFabRequestCommon
	{
		public string BuildId;

		public string Region;

		public string VmId;
	}
	[Serializable]
	public class GetRemoteLoginEndpointResponse : PlayFabResultCommon
	{
		public string IPV4Address;

		public int Port;
	}
	[Serializable]
	public class GetTitleEnabledForMultiplayerServersStatusRequest : PlayFabRequestCommon
	{
	}
	[Serializable]
	public class GetTitleEnabledForMultiplayerServersStatusResponse : PlayFabResultCommon
	{
		public TitleMultiplayerServerEnabledStatus? Status;
	}
	[Serializable]
	public class GetTitleMultiplayerServersQuotasRequest : PlayFabRequestCommon
	{
	}
	[Serializable]
	public class GetTitleMultiplayerServersQuotasResponse : PlayFabResultCommon
	{
		public TitleMultiplayerServersQuotas Quotas;
	}
	[Serializable]
	public class InstrumentationConfiguration : PlayFabBaseModel
	{
		public List<string> ProcessesToMonitor;
	}
	[Serializable]
	public class JoinMatchmakingTicketRequest : PlayFabRequestCommon
	{
		public MatchmakingPlayer Member;

		public string QueueName;

		public string TicketId;
	}
	[Serializable]
	public class JoinMatchmakingTicketResult : PlayFabResultCommon
	{
	}
	[Serializable]
	public class ListAssetSummariesRequest : PlayFabRequestCommon
	{
		public int? PageSize;

		public string SkipToken;
	}
	[Serializable]
	public class ListAssetSummariesResponse : PlayFabResultCommon
	{
		public List<AssetSummary> AssetSummaries;

		public int PageSize;

		public string SkipToken;
	}
	[Serializable]
	public class ListBuildSummariesRequest : PlayFabRequestCommon
	{
		public int? PageSize;

		public string SkipToken;
	}
	[Serializable]
	public class ListBuildSummariesResponse : PlayFabResultCommon
	{
		public List<BuildSummary> BuildSummaries;

		public int PageSize;

		public string SkipToken;
	}
	[Serializable]
	public class ListCertificateSummariesRequest : PlayFabRequestCommon
	{
		public int? PageSize;

		public string SkipToken;
	}
	[Serializable]
	public class ListCertificateSummariesResponse : PlayFabResultCommon
	{
		public List<CertificateSummary> CertificateSummaries;

		public int PageSize;

		public string SkipToken;
	}
	[Serializable]
	public class ListContainerImagesRequest : PlayFabRequestCommon
	{
		public int? PageSize;

		public string SkipToken;
	}
	[Serializable]
	public class ListContainerImagesResponse : PlayFabResultCommon
	{
		public List<string> Images;

		public int PageSize;

		public string SkipToken;
	}
	[Serializable]
	public class ListContainerImageTagsRequest : PlayFabRequestCommon
	{
		public string ImageName;
	}
	[Serializable]
	public class ListContainerImageTagsResponse : PlayFabResultCommon
	{
		public List<string> Tags;
	}
	[Serializable]
	public class ListMatchmakingTicketsForPlayerRequest : PlayFabRequestCommon
	{
		public EntityKey Entity;

		public string QueueName;
	}
	[Serializable]
	public class ListMatchmakingTicketsForPlayerResult : PlayFabResultCommon
	{
		public List<string> TicketIds;
	}
	[Serializable]
	public class ListMultiplayerServersRequest : PlayFabRequestCommon
	{
		public string BuildId;

		public int? PageSize;

		public string Region;

		public string SkipToken;
	}
	[Serializable]
	public class ListMultiplayerServersResponse : PlayFabResultCommon
	{
		public List<MultiplayerServerSummary> MultiplayerServerSummaries;

		public int PageSize;

		public string SkipToken;
	}
	[Serializable]
	public class ListPartyQosServersRequest : PlayFabRequestCommon
	{
		public string Version;
	}
	[Serializable]
	public class ListPartyQosServersResponse : PlayFabResultCommon
	{
		public int PageSize;

		public List<QosServer> QosServers;

		public string SkipToken;
	}
	[Serializable]
	public class ListQosServersForTitleRequest : PlayFabRequestCommon
	{
	}
	[Serializable]
	public class ListQosServersForTitleResponse : PlayFabResultCommon
	{
		public int PageSize;

		public List<QosServer> QosServers;

		public string SkipToken;
	}
	[Serializable]
	public class ListQosServersRequest : PlayFabRequestCommon
	{
	}
	[Serializable]
	public class ListQosServersResponse : PlayFabResultCommon
	{
		public int PageSize;

		public List<QosServer> QosServers;

		public string SkipToken;
	}
	[Serializable]
	public class ListVirtualMachineSummariesRequest : PlayFabRequestCommon
	{
		public string BuildId;

		public int? PageSize;

		public string Region;

		public string SkipToken;
	}
	[Serializable]
	public class ListVirtualMachineSummariesResponse : PlayFabResultCommon
	{
		public int PageSize;

		public string SkipToken;

		public List<VirtualMachineSummary> VirtualMachines;
	}
	[Serializable]
	public class MatchmakingPlayer : PlayFabBaseModel
	{
		public MatchmakingPlayerAttributes Attributes;

		public EntityKey Entity;
	}
	[Serializable]
	public class MatchmakingPlayerAttributes : PlayFabBaseModel
	{
		public object DataObject;

		public string EscapedDataObject;
	}
	[Serializable]
	public class MatchmakingPlayerWithTeamAssignment : PlayFabBaseModel
	{
		public MatchmakingPlayerAttributes Attributes;

		public EntityKey Entity;

		public string TeamId;
	}
	[Serializable]
	public class MultiplayerServerSummary : PlayFabBaseModel
	{
		public List<ConnectedPlayer> ConnectedPlayers;

		public DateTime? LastStateTransitionTime;

		public string Region;

		public string ServerId;

		public string SessionId;

		public string State;

		public string VmId;
	}
	[Serializable]
	public class Port : PlayFabBaseModel
	{
		public string Name;

		public int Num;

		public ProtocolType Protocol;
	}
	public enum ProtocolType
	{
		TCP,
		UDP
	}
	[Serializable]
	public class QosServer : PlayFabBaseModel
	{
		public string Region;

		public string ServerUrl;
	}
	[Serializable]
	public class RequestMultiplayerServerRequest : PlayFabRequestCommon
	{
		public string BuildId;

		public List<string> InitialPlayers;

		public List<string> PreferredRegions;

		public string SessionCookie;

		public string SessionId;
	}
	[Serializable]
	public class RequestMultiplayerServerResponse : PlayFabResultCommon
	{
		public List<ConnectedPlayer> ConnectedPlayers;

		public string FQDN;

		public string IPV4Address;

		public DateTime? LastStateTransitionTime;

		public List<Port> Ports;

		public string Region;

		public string ServerId;

		public string SessionId;

		public string State;

		public string VmId;
	}
	[Serializable]
	public class RolloverContainerRegistryCredentialsRequest : PlayFabRequestCommon
	{
	}
	[Serializable]
	public class RolloverContainerRegistryCredentialsResponse : PlayFabResultCommon
	{
		public string DnsName;

		public string Password;

		public string Username;
	}
	[Serializable]
	public class ServerDetails : PlayFabBaseModel
	{
		public string IPV4Address;

		public List<Port> Ports;

		public string Region;
	}
	[Serializable]
	public class ShutdownMultiplayerServerRequest : PlayFabRequestCommon
	{
		public string BuildId;

		public string Region;

		public string SessionId;
	}
	[Serializable]
	public class Statistics : PlayFabBaseModel
	{
		public double Average;

		public double Percentile50;

		public double Percentile90;

		public double Percentile99;
	}
	public enum TitleMultiplayerServerEnabledStatus
	{
		Initializing,
		Enabled,
		Disabled
	}
	[Serializable]
	public class TitleMultiplayerServersQuotas : PlayFabBaseModel
	{
		public List<CoreCapacity> CoreCapacities;
	}
	[Serializable]
	public class UpdateBuildRegionsRequest : PlayFabRequestCommon
	{
		public string BuildId;

		public List<BuildRegionParams> BuildRegions;
	}
	[Serializable]
	public class UploadCertificateRequest : PlayFabRequestCommon
	{
		public Certificate GameCertificate;
	}
	[Serializable]
	public class VirtualMachineSummary : PlayFabBaseModel
	{
		public string HealthStatus;

		public string State;

		public string VmId;
	}
}
namespace PlayFab.LocalizationModels
{
	[Serializable]
	public class GetLanguageListRequest : PlayFabRequestCommon
	{
	}
	[Serializable]
	public class GetLanguageListResponse : PlayFabResultCommon
	{
		public List<string> LanguageList;
	}
}
namespace PlayFab.GroupsModels
{
	[Serializable]
	public class AcceptGroupApplicationRequest : PlayFabRequestCommon
	{
		public EntityKey Entity;

		public EntityKey Group;
	}
	[Serializable]
	public class AcceptGroupInvitationRequest : PlayFabRequestCommon
	{
		public EntityKey Entity;

		public EntityKey Group;
	}
	[Serializable]
	public class AddMembersRequest : PlayFabRequestCommon
	{
		public EntityKey Group;

		public List<EntityKey> Members;

		public string RoleId;
	}
	[Serializable]
	public class ApplyToGroupRequest : PlayFabRequestCommon
	{
		public bool? AutoAcceptOutstandingInvite;

		public EntityKey Entity;

		public EntityKey Group;
	}
	[Serializable]
	public class ApplyToGroupResponse : PlayFabResultCommon
	{
		public EntityWithLineage Entity;

		public DateTime Expires;

		public EntityKey Group;
	}
	[Serializable]
	public class BlockEntityRequest : PlayFabRequestCommon
	{
		public EntityKey Entity;

		public EntityKey Group;
	}
	[Serializable]
	public class ChangeMemberRoleRequest : PlayFabRequestCommon
	{
		public string DestinationRoleId;

		public EntityKey Group;

		public List<EntityKey> Members;

		public string OriginRoleId;
	}
	[Serializable]
	public class CreateGroupRequest : PlayFabRequestCommon
	{
		public EntityKey Entity;

		public string GroupName;
	}
	[Serializable]
	public class CreateGroupResponse : PlayFabResultCommon
	{
		public string AdminRoleId;

		public DateTime Created;

		public EntityKey Group;

		public string GroupName;

		public string MemberRoleId;

		public int ProfileVersion;

		public Dictionary<string, string> Roles;
	}
	[Serializable]
	public class CreateGroupRoleRequest : PlayFabRequestCommon
	{
		public EntityKey Group;

		public string RoleId;

		public string RoleName;
	}
	[Serializable]
	public class CreateGroupRoleResponse : PlayFabResultCommon
	{
		public int ProfileVersion;

		public string RoleId;

		public string RoleName;
	}
	[Serializable]
	public class DeleteGroupRequest : PlayFabRequestCommon
	{
		public EntityKey Group;
	}
	[Serializable]
	public class DeleteRoleRequest : PlayFabRequestCommon
	{
		public EntityKey Group;

		public string RoleId;
	}
	[Serializable]
	public class EmptyResponse : PlayFabResultCommon
	{
	}
	[Serializable]
	public class EntityKey : PlayFabBaseModel
	{
		public string Id;

		public string Type;
	}
	[Serializable]
	public class EntityMemberRole : PlayFabBaseModel
	{
		public List<EntityWithLineage> Members;

		public string RoleId;

		public string RoleName;
	}
	[Serializable]
	public class EntityWithLineage : PlayFabBaseModel
	{
		public EntityKey Key;

		public Dictionary<string, EntityKey> Lineage;
	}
	[Serializable]
	public class GetGroupRequest : PlayFabRequestCommon
	{
		public EntityKey Group;

		public string GroupName;
	}
	[Serializable]
	public class GetGroupResponse : PlayFabResultCommon
	{
		public string AdminRoleId;

		public DateTime Created;

		public EntityKey Group;

		public string GroupName;

		public string MemberRoleId;

		public int ProfileVersion;

		public Dictionary<string, string> Roles;
	}
	[Serializable]
	public class GroupApplication : PlayFabBaseModel
	{
		public EntityWithLineage Entity;

		public DateTime Expires;

		public EntityKey Group;
	}
	[Serializable]
	public class GroupBlock : PlayFabBaseModel
	{
		public EntityWithLineage Entity;

		public EntityKey Group;
	}
	[Serializable]
	public class GroupInvitation : PlayFabBaseModel
	{
		public DateTime Expires;

		public EntityKey Group;

		public EntityWithLineage InvitedByEntity;

		public EntityWithLineage InvitedEntity;

		public string RoleId;
	}
	[Serializable]
	public class GroupRole : PlayFabBaseModel
	{
		public string RoleId;

		public string RoleName;
	}
	[Serializable]
	public class GroupWithRoles : PlayFabBaseModel
	{
		public EntityKey Group;

		public string GroupName;

		public int ProfileVersion;

		public List<GroupRole> Roles;
	}
	[Serializable]
	public class InviteToGroupRequest : PlayFabRequestCommon
	{
		public bool? AutoAcceptOutstandingApplication;

		public EntityKey Entity;

		public EntityKey Group;

		public string RoleId;
	}
	[Serializable]
	public class InviteToGroupResponse : PlayFabResultCommon
	{
		public DateTime Expires;

		public EntityKey Group;

		public EntityWithLineage InvitedByEntity;

		public EntityWithLineage InvitedEntity;

		public string RoleId;
	}
	[Serializable]
	public class IsMemberRequest : PlayFabRequestCommon
	{
		public EntityKey Entity;

		public EntityKey Group;

		public string RoleId;
	}
	[Serializable]
	public class IsMemberResponse : PlayFabResultCommon
	{
		public bool IsMember;
	}
	[Serializable]
	public class ListGroupApplicationsRequest : PlayFabRequestCommon
	{
		public EntityKey Group;
	}
	[Serializable]
	public class ListGroupApplicationsResponse : PlayFabResultCommon
	{
		public List<GroupApplication> Applications;
	}
	[Serializable]
	public class ListGroupBlocksRequest : PlayFabRequestCommon
	{
		public EntityKey Group;
	}
	[Serializable]
	public class ListGroupBlocksResponse : PlayFabResultCommon
	{
		public List<GroupBlock> BlockedEntities;
	}
	[Serializable]
	public class ListGroupInvitationsRequest : PlayFabRequestCommon
	{
		public EntityKey Group;
	}
	[Serializable]
	public class ListGroupInvitationsResponse : PlayFabResultCommon
	{
		public List<GroupInvitation> Invitations;
	}
	[Serializable]
	public class ListGroupMembersRequest : PlayFabRequestCommon
	{
		public EntityKey Group;
	}
	[Serializable]
	public class ListGroupMembersResponse : PlayFabResultCommon
	{
		public List<EntityMemberRole> Members;
	}
	[Serializable]
	public class ListMembershipOpportunitiesRequest : PlayFabRequestCommon
	{
		public EntityKey Entity;
	}
	[Serializable]
	public class ListMembershipOpportunitiesResponse : PlayFabResultCommon
	{
		public List<GroupApplication> Applications;

		public List<GroupInvitation> Invitations;
	}
	[Serializable]
	public class ListMembershipRequest : PlayFabRequestCommon
	{
		public EntityKey Entity;
	}
	[Serializable]
	public class ListMembershipResponse : PlayFabResultCommon
	{
		public List<GroupWithRoles> Groups;
	}
	public enum OperationTypes
	{
		Created,
		Updated,
		Deleted,
		None
	}
	[Serializable]
	public class RemoveGroupApplicationRequest : PlayFabRequestCommon
	{
		public EntityKey Entity;

		public EntityKey Group;
	}
	[Serializable]
	public class RemoveGroupInvitationRequest : PlayFabRequestCommon
	{
		public EntityKey Entity;

		public EntityKey Group;
	}
	[Serializable]
	public class RemoveMembersRequest : PlayFabRequestCommon
	{
		public EntityKey Group;

		public List<EntityKey> Members;

		public string RoleId;
	}
	[Serializable]
	public class UnblockEntityRequest : PlayFabRequestCommon
	{
		public EntityKey Entity;

		public EntityKey Group;
	}
	[Serializable]
	public class UpdateGroupRequest : PlayFabRequestCommon
	{
		public string AdminRoleId;

		public int? ExpectedProfileVersion;

		public EntityKey Group;

		public string GroupName;

		public string MemberRoleId;
	}
	[Serializable]
	public class UpdateGroupResponse : PlayFabResultCommon
	{
		public string OperationReason;

		public int ProfileVersion;

		public OperationTypes? SetResult;
	}
	[Serializable]
	public class UpdateGroupRoleRequest : PlayFabRequestCommon
	{
		public int? ExpectedProfileVersion;

		public EntityKey Group;

		public string RoleId;

		public string RoleName;
	}
	[Serializable]
	public class UpdateGroupRoleResponse : PlayFabResultCommon
	{
		public string OperationReason;

		public int ProfileVersion;

		public OperationTypes? SetResult;
	}
}
namespace PlayFab.EventsModels
{
	[Serializable]
	public class EntityKey : PlayFabBaseModel
	{
		public string Id;

		public string Type;
	}
	[Serializable]
	public class EventContents : PlayFabBaseModel
	{
		public EntityKey Entity;

		public string EventNamespace;

		public string Name;

		public string OriginalId;

		public DateTime? OriginalTimestamp;

		public object Payload;

		public string PayloadJSON;
	}
	[Serializable]
	public class WriteEventsRequest : PlayFabRequestCommon
	{
		public List<EventContents> Events;
	}
	[Serializable]
	public class WriteEventsResponse : PlayFabResultCommon
	{
		public List<string> AssignedEventIds;
	}
}
namespace PlayFab.Public
{
	public interface IScreenTimeTracker
	{
		void OnEnable();

		void OnDisable();

		void OnDestroy();

		void OnApplicationQuit();

		void OnApplicationFocus(bool isFocused);

		void ClientSessionStart(string entityId, string entityType, string playFabUserId);

		void Send();
	}
	public class ScreenTimeTracker : IScreenTimeTracker
	{
		private Guid focusId;

		private Guid gameSessionID;

		private bool initialFocus = true;

		private bool isSending;

		private DateTime focusOffDateTime = DateTime.UtcNow;

		private DateTime focusOnDateTime = DateTime.UtcNow;

		private Queue<EventContents> eventsRequests = new Queue<EventContents>();

		private PlayFab.EventsModels.EntityKey entityKey = new PlayFab.EventsModels.EntityKey();

		private const string eventNamespace = "com.playfab.events.sessions";

		private const int maxBatchSizeInEvents = 10;

		public void ClientSessionStart(string entityId, string entityType, string playFabUserId)
		{
			gameSessionID = Guid.NewGuid();
			entityKey.Id = entityId;
			entityKey.Type = entityType;
			EventContents eventContents = new EventContents();
			eventContents.Name = "client_session_start";
			eventContents.EventNamespace = "com.playfab.events.sessions";
			eventContents.Entity = entityKey;
			eventContents.OriginalTimestamp = DateTime.UtcNow;
			Dictionary<string, object> payload = new Dictionary<string, object>
			{
				{ "UserID", playFabUserId },
				{
					"DeviceType",
					SystemInfo.deviceType
				},
				{
					"DeviceModel",
					SystemInfo.deviceModel
				},
				{
					"OS",
					SystemInfo.operatingSystem
				},
				{ "ClientSessionID", gameSessionID }
			};
			eventContents.Payload = payload;
			eventsRequests.Enqueue(eventContents);
			OnApplicationFocus(isFocused: true);
		}

		public void OnApplicationFocus(bool isFocused)
		{
			EventContents eventContents = new EventContents();
			DateTime utcNow = DateTime.UtcNow;
			eventContents.Name = "client_focus_change";
			eventContents.EventNamespace = "com.playfab.events.sessions";
			eventContents.Entity = entityKey;
			double num = 0.0;
			if (initialFocus)
			{
				focusId = Guid.NewGuid();
			}
			if (isFocused)
			{
				focusOnDateTime = utcNow;
				focusId = Guid.NewGuid();
				if (!initialFocus)
				{
					num = (utcNow - focusOffDateTime).TotalSeconds;
					if (num < 0.0)
					{
						num = 0.0;
					}
				}
			}
			else
			{
				num = (utcNow - focusOnDateTime).TotalSeconds;
				if (num < 0.0)
				{
					num = 0.0;
				}
				focusOffDateTime = utcNow;
			}
			Dictionary<string, object> payload = new Dictionary<string, object>
			{
				{ "FocusID", focusId },
				{ "FocusState", isFocused },
				{ "FocusStateDuration", num },
				{ "EventTimestamp", utcNow },
				{ "ClientSessionID", gameSessionID }
			};
			eventContents.OriginalTimestamp = utcNow;
			eventContents.Payload = payload;
			eventsRequests.Enqueue(eventContents);
			initialFocus = false;
			if (!isFocused)
			{
				Send();
			}
		}

		public void Send()
		{
			if (PlayFabClientAPI.IsClientLoggedIn() && !isSending)
			{
				isSending = true;
				WriteEventsRequest writeEventsRequest = new WriteEventsRequest();
				writeEventsRequest.Events = new List<EventContents>();
				while (eventsRequests.Count > 0 && writeEventsRequest.Events.Count < 10)
				{
					EventContents item = eventsRequests.Dequeue();
					writeEventsRequest.Events.Add(item);
				}
				if (writeEventsRequest.Events.Count > 0)
				{
					PlayFabEventsAPI.WriteEvents(writeEventsRequest, EventSentSuccessfulCallback, EventSentErrorCallback);
				}
				isSending = false;
			}
		}

		private void EventSentSuccessfulCallback(WriteEventsResponse response)
		{
		}

		private void EventSentErrorCallback(PlayFabError response)
		{
			UnityEngine.Debug.LogWarning("Failed to send session data. Error: " + response.GenerateErrorReport());
		}

		public void OnEnable()
		{
		}

		public void OnDisable()
		{
		}

		public void OnDestroy()
		{
		}

		public void OnApplicationQuit()
		{
			Send();
		}
	}
	public interface IPlayFabLogger
	{
		IPAddress ip { get; set; }

		int port { get; set; }

		string url { get; set; }

		void OnEnable();

		void OnDisable();

		void OnDestroy();
	}
	public abstract class PlayFabLoggerBase : IPlayFabLogger
	{
		private static readonly StringBuilder Sb = new StringBuilder();

		private readonly Queue<string> LogMessageQueue = new Queue<string>();

		private const int LOG_CACHE_INTERVAL_MS = 10000;

		private Thread _writeLogThread;

		private readonly object _threadLock = new object();

		private static readonly TimeSpan _threadKillTimeout = TimeSpan.FromSeconds(60.0);

		private DateTime _threadKillTime = DateTime.UtcNow + _threadKillTimeout;

		private bool _isApplicationPlaying = true;

		private int _pendingLogsCount;

		public IPAddress ip { get; set; }

		public int port { get; set; }

		public string url { get; set; }

		protected PlayFabLoggerBase()
		{
			string item = new PlayFabDataGatherer().GenerateReport();
			lock (LogMessageQueue)
			{
				LogMessageQueue.Enqueue(item);
			}
		}

		public virtual void OnEnable()
		{
			SingletonMonoBehaviour<PlayFabHttp>.instance.StartCoroutine(RegisterLogger());
		}

		private IEnumerator RegisterLogger()
		{
			yield return new WaitForEndOfFrame();
			if (!string.IsNullOrEmpty(PlayFabSettings.LoggerHost))
			{
				UnityEngine.Application.logMessageReceivedThreaded += HandleUnityLog;
			}
		}

		public virtual void OnDisable()
		{
			if (!string.IsNullOrEmpty(PlayFabSettings.LoggerHost))
			{
				UnityEngine.Application.logMessageReceivedThreaded -= HandleUnityLog;
			}
		}

		public virtual void OnDestroy()
		{
			_isApplicationPlaying = false;
		}

		protected abstract void BeginUploadLog();

		protected abstract void UploadLog(string message);

		protected abstract void EndUploadLog();

		private void HandleUnityLog(string message, string stacktrace, LogType type)
		{
			if (!PlayFabSettings.EnableRealTimeLogging)
			{
				return;
			}
			Sb.Length = 0;
			switch (type)
			{
			case LogType.Warning:
			case LogType.Log:
				Sb.Append(type).Append(": ").Append(message);
				message = Sb.ToString();
				lock (LogMessageQueue)
				{
					LogMessageQueue.Enqueue(message);
				}
				break;
			case LogType.Error:
			case LogType.Exception:
				Sb.Append(type).Append(": ").Append(message)
					.Append("\n")
					.Append(stacktrace)
					.Append(StackTraceUtility.ExtractStackTrace());
				message = Sb.ToString();
				lock (LogMessageQueue)
				{
					LogMessageQueue.Enqueue(message);
				}
				break;
			}
			ActivateThreadWorker();
		}

		private void ActivateThreadWorker()
		{
			lock (_threadLock)
			{
				if (_writeLogThread == null)
				{
					_writeLogThread = new Thread(WriteLogThreadWorker);
					_writeLogThread.Start();
				}
			}
		}

		private void WriteLogThreadWorker()
		{
			try
			{
				lock (_threadLock)
				{
					_threadKillTime = DateTime.UtcNow + _threadKillTimeout;
				}
				Queue<string> queue = new Queue<string>();
				bool flag;
				do
				{
					lock (LogMessageQueue)
					{
						_pendingLogsCount = LogMessageQueue.Count;
						while (LogMessageQueue.Count > 0)
						{
							queue.Enqueue(LogMessageQueue.Dequeue());
						}
					}
					BeginUploadLog();
					while (queue.Count > 0)
					{
						UploadLog(queue.Dequeue());
					}
					EndUploadLog();
					lock (_threadLock)
					{
						DateTime utcNow = DateTime.UtcNow;
						if (_pendingLogsCount > 0 && _isApplicationPlaying)
						{
							_threadKillTime = utcNow + _threadKillTimeout;
						}
						flag = utcNow <= _threadKillTime;
						if (!flag)
						{
							_writeLogThread = null;
						}
					}
					Thread.Sleep(10000);
				}
				while (flag);
			}
			catch (Exception exception)
			{
				UnityEngine.Debug.LogException(exception);
				_writeLogThread = null;
			}
		}
	}
	public class PlayFabLogger : PlayFabLoggerBase
	{
		protected override void BeginUploadLog()
		{
		}

		protected override void UploadLog(string message)
		{
		}

		protected override void EndUploadLog()
		{
		}
	}
}
namespace PlayFab.DataModels
{
	[Serializable]
	public class AbortFileUploadsRequest : PlayFabRequestCommon
	{
		public EntityKey Entity;

		public List<string> FileNames;

		public int? ProfileVersion;
	}
	[Serializable]
	public class AbortFileUploadsResponse : PlayFabResultCommon
	{
		public EntityKey Entity;

		public int ProfileVersion;
	}
	[Serializable]
	public class DeleteFilesRequest : PlayFabRequestCommon
	{
		public EntityKey Entity;

		public List<string> FileNames;

		public int? ProfileVersion;
	}
	[Serializable]
	public class DeleteFilesResponse : PlayFabResultCommon
	{
		public EntityKey Entity;

		public int ProfileVersion;
	}
	[Serializable]
	public class EntityKey : PlayFabBaseModel
	{
		public string Id;

		public string Type;
	}
	[Serializable]
	public class FinalizeFileUploadsRequest : PlayFabRequestCommon
	{
		public EntityKey Entity;

		public List<string> FileNames;
	}
	[Serializable]
	public class FinalizeFileUploadsResponse : PlayFabResultCommon
	{
		public EntityKey Entity;

		public Dictionary<string, GetFileMetadata> Metadata;

		public int ProfileVersion;
	}
	[Serializable]
	public class GetFileMetadata : PlayFabBaseModel
	{
		public string Checksum;

		public string DownloadUrl;

		public string FileName;

		public DateTime LastModified;

		public int Size;
	}
	[Serializable]
	public class GetFilesRequest : PlayFabRequestCommon
	{
		public EntityKey Entity;
	}
	[Serializable]
	public class GetFilesResponse : PlayFabResultCommon
	{
		public EntityKey Entity;

		public Dictionary<string, GetFileMetadata> Metadata;

		public int ProfileVersion;
	}
	[Serializable]
	public class GetObjectsRequest : PlayFabRequestCommon
	{
		public EntityKey Entity;

		public bool? EscapeObject;
	}
	[Serializable]
	public class GetObjectsResponse : PlayFabResultCommon
	{
		public EntityKey Entity;

		public Dictionary<string, ObjectResult> Objects;

		public int ProfileVersion;
	}
	[Serializable]
	public class InitiateFileUploadMetadata : PlayFabBaseModel
	{
		public string FileName;

		public string UploadUrl;
	}
	[Serializable]
	public class InitiateFileUploadsRequest : PlayFabRequestCommon
	{
		public EntityKey Entity;

		public List<string> FileNames;

		public int? ProfileVersion;
	}
	[Serializable]
	public class InitiateFileUploadsResponse : PlayFabResultCommon
	{
		public EntityKey Entity;

		public int ProfileVersion;

		public List<InitiateFileUploadMetadata> UploadDetails;
	}
	[Serializable]
	public class ObjectResult : PlayFabBaseModel
	{
		public object DataObject;

		public string EscapedDataObject;

		public string ObjectName;
	}
	public enum OperationTypes
	{
		Created,
		Updated,
		Deleted,
		None
	}
	[Serializable]
	public class SetObject : PlayFabBaseModel
	{
		public object DataObject;

		public bool? DeleteObject;

		public string EscapedDataObject;

		public string ObjectName;
	}
	[Serializable]
	public class SetObjectInfo : PlayFabBaseModel
	{
		public string ObjectName;

		public string OperationReason;

		public OperationTypes? SetResult;
	}
	[Serializable]
	public class SetObjectsRequest : PlayFabRequestCommon
	{
		public EntityKey Entity;

		public int? ExpectedProfileVersion;

		public List<SetObject> Objects;
	}
	[Serializable]
	public class SetObjectsResponse : PlayFabResultCommon
	{
		public int ProfileVersion;

		public List<SetObjectInfo> SetResults;
	}
}
namespace PlayFab.CloudScriptModels
{
	public enum CloudScriptRevisionOption
	{
		Live,
		Latest,
		Specific
	}
	[Serializable]
	public class EntityKey : PlayFabBaseModel
	{
		public string Id;

		public string Type;
	}
	[Serializable]
	public class ExecuteCloudScriptResult : PlayFabResultCommon
	{
		public int APIRequestsIssued;

		public ScriptExecutionError Error;

		public double ExecutionTimeSeconds;

		public string FunctionName;

		public object FunctionResult;

		public bool? FunctionResultTooLarge;

		public int HttpRequestsIssued;

		public List<LogStatement> Logs;

		public bool? LogsTooLarge;

		public uint MemoryConsumedBytes;

		public double ProcessorTimeSeconds;

		public int Revision;
	}
	[Serializable]
	public class ExecuteEntityCloudScriptRequest : PlayFabRequestCommon
	{
		public EntityKey Entity;

		public string FunctionName;

		public object FunctionParameter;

		public bool? GeneratePlayStreamEvent;

		public CloudScriptRevisionOption? RevisionSelection;

		public int? SpecificRevision;
	}
	[Serializable]
	public class LogStatement : PlayFabBaseModel
	{
		public object Data;

		public string Level;

		public string Message;
	}
	[Serializable]
	public class ScriptExecutionError : PlayFabBaseModel
	{
		public string Error;

		public string Message;

		public string StackTrace;
	}
}
namespace PlayFab.Internal
{
	public static class PlayFabDeviceUtil
	{
		private static bool _needsAttribution;

		private static bool _gatherDeviceInfo;

		private static bool _gatherScreenTime;

		private static void DoAttributeInstall(PlayFabApiSettings settings, IPlayFabInstanceApi instanceApi)
		{
			if (!_needsAttribution || settings.DisableAdvertising)
			{
				return;
			}
			AttributeInstallRequest attributeInstallRequest = new AttributeInstallRequest();
			string advertisingIdType = settings.AdvertisingIdType;
			if (!(advertisingIdType == "Adid"))
			{
				if (advertisingIdType == "Idfa")
				{
					attributeInstallRequest.Idfa = settings.AdvertisingIdValue;
				}
			}
			else
			{
				attributeInstallRequest.Adid = settings.AdvertisingIdValue;
			}
			if (instanceApi is PlayFabClientInstanceAPI playFabClientInstanceAPI)
			{
				playFabClientInstanceAPI.AttributeInstall(attributeInstallRequest, OnAttributeInstall, null, settings);
			}
			else
			{
				PlayFabClientAPI.AttributeInstall(attributeInstallRequest, OnAttributeInstall, null, settings);
			}
		}

		private static void OnAttributeInstall(AttributeInstallResult result)
		{
			((PlayFabApiSettings)result.CustomData).AdvertisingIdType += "_Successful";
		}

		private static void SendDeviceInfoToPlayFab(PlayFabApiSettings settings, IPlayFabInstanceApi instanceApi)
		{
			if (!settings.DisableDeviceInfo && _gatherDeviceInfo)
			{
				ISerializerPlugin plugin = PluginManager.GetPlugin<ISerializerPlugin>(PluginContract.PlayFab_Serializer);
				DeviceInfoRequest request = new DeviceInfoRequest
				{
					Info = plugin.DeserializeObject<Dictionary<string, object>>(plugin.SerializeObject(new PlayFabDataGatherer()))
				};
				if (instanceApi is PlayFabClientInstanceAPI playFabClientInstanceAPI)
				{
					playFabClientInstanceAPI.ReportDeviceInfo(request, null, OnGatherFail, settings);
				}
				else
				{
					PlayFabClientAPI.ReportDeviceInfo(request, null, OnGatherFail, settings);
				}
			}
		}

		private static void OnGatherFail(PlayFabError error)
		{
			UnityEngine.Debug.Log("OnGatherFail: " + error.GenerateErrorReport());
		}

		public static void OnPlayFabLogin(PlayFabResultCommon result, PlayFabApiSettings settings, IPlayFabInstanceApi instanceApi)
		{
			LoginResult loginResult = result as LoginResult;
			RegisterPlayFabUserResult registerPlayFabUserResult = result as RegisterPlayFabUserResult;
			if (loginResult == null && registerPlayFabUserResult == null)
			{
				return;
			}
			UserSettings settingsForUser = null;
			string playFabId = null;
			string entityId = null;
			string entityType = null;
			if (loginResult != null)
			{
				settingsForUser = loginResult.SettingsForUser;
				playFabId = loginResult.PlayFabId;
				if (loginResult.EntityToken != null)
				{
					entityId = loginResult.EntityToken.Entity.Id;
					entityType = loginResult.EntityToken.Entity.Type;
				}
			}
			else if (registerPlayFabUserResult != null)
			{
				settingsForUser = registerPlayFabUserResult.SettingsForUser;
				playFabId = registerPlayFabUserResult.PlayFabId;
				if (registerPlayFabUserResult.EntityToken != null)
				{
					entityId = registerPlayFabUserResult.EntityToken.Entity.Id;
					entityType = registerPlayFabUserResult.EntityToken.Entity.Type;
				}
			}
			_OnPlayFabLogin(settingsForUser, playFabId, entityId, entityType, settings, instanceApi);
		}

		private static void _OnPlayFabLogin(UserSettings settingsForUser, string playFabId, string entityId, string entityType, PlayFabApiSettings settings, IPlayFabInstanceApi instanceApi)
		{
			_needsAttribution = (_gatherDeviceInfo = (_gatherScreenTime = false));
			if (settingsForUser != null)
			{
				_needsAttribution = settingsForUser.NeedsAttribution;
				_gatherDeviceInfo = settingsForUser.GatherDeviceInfo;
				_gatherScreenTime = settingsForUser.GatherFocusInfo;
			}
			if (settings.AdvertisingIdType != null && settings.AdvertisingIdValue != null)
			{
				DoAttributeInstall(settings, instanceApi);
			}
			else
			{
				GetAdvertIdFromUnity(settings, instanceApi);
			}
			SendDeviceInfoToPlayFab(settings, instanceApi);
			if (!string.IsNullOrEmpty(entityId) && !string.IsNullOrEmpty(entityType) && _gatherScreenTime)
			{
				PlayFabHttp.InitializeScreenTimeTracker(entityId, entityType, playFabId);
			}
			else
			{
				settings.DisableFocusTimeCollection = true;
			}
		}

		private static void GetAdvertIdFromUnity(PlayFabApiSettings settings, IPlayFabInstanceApi instanceApi)
		{
			UnityEngine.Application.RequestAdvertisingIdentifierAsync(delegate(string advertisingId, bool trackingEnabled, string error)
			{
				settings.DisableAdvertising = !trackingEnabled;
				if (trackingEnabled)
				{
					settings.AdvertisingIdType = "Adid";
					settings.AdvertisingIdValue = advertisingId;
					DoAttributeInstall(settings, instanceApi);
				}
			});
		}
	}
	[Obsolete("This logging utility has been deprecated. Use UnityEngine.Debug.Log")]
	public static class Log
	{
		[Obsolete("Debug is deprecated.")]
		public static void Debug(string text, params object[] args)
		{
			if ((PlayFabSettings.LogLevel & PlayFabLogLevel.Debug) != 0)
			{
				UnityEngine.Debug.Log(PlayFabUtil.timeStamp + " DEBUG: " + PlayFabUtil.Format(text, args));
			}
		}

		[Obsolete("Info is deprecated.")]
		public static void Info(string text, params object[] args)
		{
			if ((PlayFabSettings.LogLevel & PlayFabLogLevel.Info) != 0)
			{
				UnityEngine.Debug.Log(PlayFabUtil.timeStamp + " INFO: " + PlayFabUtil.Format(text, args));
			}
		}

		[Obsolete("Warning is deprecated.")]
		public static void Warning(string text, params object[] args)
		{
			if ((PlayFabSettings.LogLevel & PlayFabLogLevel.Warning) != 0)
			{
				UnityEngine.Debug.LogWarning(PlayFabUtil.timeStamp + " WARNING: " + PlayFabUtil.Format(text, args));
			}
		}

		[Obsolete("Error is deprecated.")]
		public static void Error(string text, params object[] args)
		{
			if ((PlayFabSettings.LogLevel & PlayFabLogLevel.Error) != 0)
			{
				UnityEngine.Debug.LogError(PlayFabUtil.timeStamp + " ERROR: " + PlayFabUtil.Format(text, args));
			}
		}
	}
	public enum AuthType
	{
		None,
		PreLoginSession,
		LoginSession,
		DevSecretKey,
		EntityToken
	}
	public enum HttpRequestState
	{
		Sent,
		Received,
		Idle,
		Error
	}
	public class CallRequestContainer
	{
		public HttpRequestState HttpState = HttpRequestState.Idle;

		public HttpWebRequest HttpRequest;

		public string ApiEndpoint;

		public string FullUrl;

		public byte[] Payload;

		public string JsonResponse;

		public PlayFabRequestCommon ApiRequest;

		public Dictionary<string, string> RequestHeaders;

		public PlayFabResultCommon ApiResult;

		public PlayFabError Error;

		public Action DeserializeResultJson;

		public Action InvokeSuccessCallback;

		public Action<PlayFabError> ErrorCallback;

		public object CustomData;

		public PlayFabApiSettings settings;

		public PlayFabAuthenticationContext context;

		public IPlayFabInstanceApi instanceApi;
	}
	public class PlayFabHttp : SingletonMonoBehaviour<PlayFabHttp>
	{
		public delegate void ApiProcessingEvent<in TEventArgs>(TEventArgs e);

		public delegate void ApiProcessErrorEvent(PlayFabRequestCommon request, PlayFabError error);

		private static List<CallRequestContainer> _apiCallQueue = new List<CallRequestContainer>();

		public static readonly Dictionary<string, string> GlobalHeaderInjection = new Dictionary<string, string>();

		private static IPlayFabLogger _logger;

		private static IScreenTimeTracker screenTimeTracker = new ScreenTimeTracker();

		private const float delayBetweenBatches = 5f;

		private readonly Queue<IEnumerator> _injectedCoroutines = new Queue<IEnumerator>();

		private readonly Queue<Action> _injectedAction = new Queue<Action>();

		public static event ApiProcessingEvent<ApiProcessingEventArgs> ApiProcessingEventHandler;

		public static event ApiProcessErrorEvent ApiProcessingErrorEventHandler;

		public static int GetPendingMessages()
		{
			ITransportPlugin plugin = PluginManager.GetPlugin<ITransportPlugin>(PluginContract.PlayFab_Transport);
			if (!plugin.IsInitialized)
			{
				return 0;
			}
			return plugin.GetPendingMessages();
		}

		public static void InitializeHttp()
		{
			if (string.IsNullOrEmpty(PlayFabSettings.TitleId))
			{
				throw new PlayFabException(PlayFabExceptionCode.TitleNotSet, "You must set PlayFabSettings.TitleId before making API Calls.");
			}
			ITransportPlugin plugin = PluginManager.GetPlugin<ITransportPlugin>(PluginContract.PlayFab_Transport);
			if (!plugin.IsInitialized)
			{
				UnityEngine.Application.runInBackground = true;
				plugin.Initialize();
				SingletonMonoBehaviour<PlayFabHttp>.CreateInstance();
			}
		}

		public static void InitializeLogger(IPlayFabLogger setLogger = null)
		{
			if (_logger != null)
			{
				throw new InvalidOperationException("Once initialized, the logger cannot be reset.");
			}
			if (setLogger == null)
			{
				setLogger = new PlayFabLogger();
			}
			_logger = setLogger;
		}

		public static void InitializeScreenTimeTracker(string entityId, string entityType, string playFabUserId)
		{
			screenTimeTracker.ClientSessionStart(entityId, entityType, playFabUserId);
			SingletonMonoBehaviour<PlayFabHttp>.instance.StartCoroutine(SendScreenTimeEvents(5f));
		}

		private static IEnumerator SendScreenTimeEvents(float secondsBetweenBatches)
		{
			WaitForSeconds delay = new WaitForSeconds(secondsBetweenBatches);
			while (!PlayFabSettings.DisableFocusTimeCollection)
			{
				screenTimeTracker.Send();
				yield return delay;
			}
		}

		public static void SimpleGetCall(string fullUrl, Action<byte[]> successCallback, Action<string> errorCallback)
		{
			InitializeHttp();
			PluginManager.GetPlugin<ITransportPlugin>(PluginContract.PlayFab_Transport).SimpleGetCall(fullUrl, successCallback, errorCallback);
		}

		public static void SimplePutCall(string fullUrl, byte[] payload, Action<byte[]> successCallback, Action<string> errorCallback)
		{
			InitializeHttp();
			PluginManager.GetPlugin<ITransportPlugin>(PluginContract.PlayFab_Transport).SimplePutCall(fullUrl, payload, successCallback, errorCallback);
		}

		public static void SimplePostCall(string fullUrl, byte[] payload, Action<byte[]> successCallback, Action<string> errorCallback)
		{
			InitializeHttp();
			PluginManager.GetPlugin<ITransportPlugin>(PluginContract.PlayFab_Transport).SimplePostCall(fullUrl, payload, successCallback, errorCallback);
		}

		protected internal static void MakeApiCall<TResult>(string apiEndpoint, PlayFabRequestCommon request, AuthType authType, Action<TResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null, PlayFabAuthenticationContext authenticationContext = null, PlayFabApiSettings apiSettings = null, IPlayFabInstanceApi instanceApi = null) where TResult : PlayFabResultCommon
		{
			apiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			string fullUrl = apiSettings.GetFullUrl(apiEndpoint, apiSettings.RequestGetParams);
			_MakeApiCall(apiEndpoint, fullUrl, request, authType, resultCallback, errorCallback, customData, extraHeaders, allowQueueing: false, authenticationContext, apiSettings, instanceApi);
		}

		protected internal static void MakeApiCallWithFullUri<TResult>(string fullUri, PlayFabRequestCommon request, AuthType authType, Action<TResult> resultCallback, Action<PlayFabError> errorCallback, object customData = null, Dictionary<string, string> extraHeaders = null, PlayFabAuthenticationContext authenticationContext = null, PlayFabApiSettings apiSettings = null, IPlayFabInstanceApi instanceApi = null) where TResult : PlayFabResultCommon
		{
			apiSettings = apiSettings ?? PlayFabSettings.staticSettings;
			_MakeApiCall(null, fullUri, request, authType, resultCallback, errorCallback, customData, extraHeaders, allowQueueing: false, authenticationContext, apiSettings, instanceApi);
		}

		private static void _MakeApiCall<TResult>(string apiEndpoint, string fullUrl, PlayFabRequestCommon request, AuthType authType, Action<TResult> resultCallback, Action<PlayFabError> errorCallback, object customData, Dictionary<string, string> extraHeaders, bool allowQueueing, PlayFabAuthenticationContext authenticationContext, PlayFabApiSettings apiSettings, IPlayFabInstanceApi instanceApi) where TResult : PlayFabResultCommon
		{
			InitializeHttp();
			SendEvent(apiEndpoint, request, null, ApiProcessingEventType.Pre);
			ISerializerPlugin serializer = PluginManager.GetPlugin<ISerializerPlugin>(PluginContract.PlayFab_Serializer);
			CallRequestContainer reqContainer = new CallRequestContainer
			{
				ApiEndpoint = apiEndpoint,
				FullUrl = fullUrl,
				settings = apiSettings,
				context = authenticationContext,
				CustomData = customData,
				Payload = Encoding.UTF8.GetBytes(serializer.SerializeObject(request)),
				ApiRequest = request,
				ErrorCallback = errorCallback,
				RequestHeaders = (extraHeaders ?? new Dictionary<string, string>()),
				instanceApi = instanceApi
			};
			foreach (KeyValuePair<string, string> item in GlobalHeaderInjection)
			{
				if (!reqContainer.RequestHeaders.ContainsKey(item.Key))
				{
					reqContainer.RequestHeaders[item.Key] = item.Value;
				}
			}
			ITransportPlugin plugin = PluginManager.GetPlugin<ITransportPlugin>(PluginContract.PlayFab_Transport);
			reqContainer.RequestHeaders["X-ReportErrorAsSuccess"] = "true";
			reqContainer.RequestHeaders["X-PlayFabSDK"] = "UnitySDK-2.74.190916";
			switch (authType)
			{
			case AuthType.LoginSession:
				if (authenticationContext != null)
				{
					reqContainer.RequestHeaders["X-Authorization"] = authenticationContext.ClientSessionTicket;
				}
				break;
			case AuthType.EntityToken:
				if (authenticationContext != null)
				{
					reqContainer.RequestHeaders["X-EntityToken"] = authenticationContext.EntityToken;
				}
				break;
			}
			reqContainer.DeserializeResultJson = delegate
			{
				reqContainer.ApiResult = serializer.DeserializeObject<TResult>(reqContainer.JsonResponse);
			};
			reqContainer.InvokeSuccessCallback = delegate
			{
				if (resultCallback != null)
				{
					resultCallback((TResult)reqContainer.ApiResult);
				}
			};
			if (allowQueueing && _apiCallQueue != null)
			{
				for (int num = _apiCallQueue.Count - 1; num >= 0; num--)
				{
					if (_apiCallQueue[num].ApiEndpoint == apiEndpoint)
					{
						_apiCallQueue.RemoveAt(num);
					}
				}
				_apiCallQueue.Add(reqContainer);
			}
			else
			{
				plugin.MakeApiCall(reqContainer);
			}
		}

		internal void OnPlayFabApiResult(CallRequestContainer reqContainer)
		{
			PlayFabResultCommon apiResult = reqContainer.ApiResult;
			if (apiResult is GetEntityTokenResponse getEntityTokenResponse)
			{
				PlayFabSettings.staticPlayer.EntityToken = getEntityTokenResponse.EntityToken;
			}
			LoginResult loginResult = apiResult as LoginResult;
			RegisterPlayFabUserResult registerPlayFabUserResult = apiResult as RegisterPlayFabUserResult;
			if (loginResult != null)
			{
				loginResult.AuthenticationContext = new PlayFabAuthenticationContext(loginResult.SessionTicket, loginResult.EntityToken.EntityToken, loginResult.PlayFabId, loginResult.EntityToken.Entity.Id, loginResult.EntityToken.Entity.Type);
				if (reqContainer.context != null)
				{
					reqContainer.context.CopyFrom(loginResult.AuthenticationContext);
				}
			}
			else if (registerPlayFabUserResult != null)
			{
				registerPlayFabUserResult.AuthenticationContext = new PlayFabAuthenticationContext(registerPlayFabUserResult.SessionTicket, registerPlayFabUserResult.EntityToken.EntityToken, registerPlayFabUserResult.PlayFabId, registerPlayFabUserResult.EntityToken.Entity.Id, registerPlayFabUserResult.EntityToken.Entity.Type);
				if (reqContainer.context != null)
				{
					reqContainer.context.CopyFrom(registerPlayFabUserResult.AuthenticationContext);
				}
			}
		}

		private void OnEnable()
		{
			if (_logger != null)
			{
				_logger.OnEnable();
			}
			if (screenTimeTracker != null && !PlayFabSettings.DisableFocusTimeCollection)
			{
				screenTimeTracker.OnEnable();
			}
		}

		private void OnDisable()
		{
			if (_logger != null)
			{
				_logger.OnDisable();
			}
			if (screenTimeTracker != null && !PlayFabSettings.DisableFocusTimeCollection)
			{
				screenTimeTracker.OnDisable();
			}
		}

		private void OnDestroy()
		{
			ITransportPlugin plugin = PluginManager.GetPlugin<ITransportPlugin>(PluginContract.PlayFab_Transport);
			if (plugin.IsInitialized)
			{
				plugin.OnDestroy();
			}
			if (_logger != null)
			{
				_logger.OnDestroy();
			}
			if (screenTimeTracker != null && !PlayFabSettings.DisableFocusTimeCollection)
			{
				screenTimeTracker.OnDestroy();
			}
		}

		public void OnApplicationFocus(bool isFocused)
		{
			if (screenTimeTracker != null && !PlayFabSettings.DisableFocusTimeCollection)
			{
				screenTimeTracker.OnApplicationFocus(isFocused);
			}
		}

		public void OnApplicationQuit()
		{
			if (screenTimeTracker != null && !PlayFabSettings.DisableFocusTimeCollection)
			{
				screenTimeTracker.OnApplicationQuit();
			}
		}

		private void Update()
		{
			ITransportPlugin plugin = PluginManager.GetPlugin<ITransportPlugin>(PluginContract.PlayFab_Transport);
			if (plugin.IsInitialized)
			{
				if (_apiCallQueue != null)
				{
					foreach (CallRequestContainer item in _apiCallQueue)
					{
						plugin.MakeApiCall(item);
					}
					_apiCallQueue = null;
				}
				plugin.Update();
			}
			while (_injectedCoroutines.Count > 0)
			{
				StartCoroutine(_injectedCoroutines.Dequeue());
			}
			while (_injectedAction.Count > 0)
			{
				_injectedAction.Dequeue()?.Invoke();
			}
		}

		protected internal static PlayFabError GeneratePlayFabError(string apiEndpoint, string json, object customData)
		{
			JsonObject jsonObject = null;
			Dictionary<string, List<string>> errorDetails = null;
			ISerializerPlugin plugin = PluginManager.GetPlugin<ISerializerPlugin>(PluginContract.PlayFab_Serializer);
			try
			{
				jsonObject = plugin.DeserializeObject<JsonObject>(json);
			}
			catch (Exception)
			{
			}
			try
			{
				if (jsonObject != null && jsonObject.TryGetValue("errorDetails", out var value))
				{
					errorDetails = plugin.DeserializeObject<Dictionary<string, List<string>>>(value.ToString());
				}
			}
			catch (Exception)
			{
			}
			return new PlayFabError
			{
				ApiEndpoint = apiEndpoint,
				HttpCode = ((jsonObject != null && jsonObject.ContainsKey("code")) ? Convert.ToInt32(jsonObject["code"]) : 400),
				HttpStatus = ((jsonObject != null && jsonObject.ContainsKey("status")) ? ((string)jsonObject["status"]) : "BadRequest"),
				Error = ((jsonObject != null && jsonObject.ContainsKey("errorCode")) ? ((PlayFabErrorCode)Convert.ToInt32(jsonObject["errorCode"])) : PlayFabErrorCode.ServiceUnavailable),
				ErrorMessage = ((jsonObject != null && jsonObject.ContainsKey("errorMessage")) ? ((string)jsonObject["errorMessage"]) : json),
				ErrorDetails = errorDetails,
				CustomData = customData
			};
		}

		protected internal static void SendErrorEvent(PlayFabRequestCommon request, PlayFabError error)
		{
			if (PlayFabHttp.ApiProcessingErrorEventHandler == null)
			{
				return;
			}
			try
			{
				PlayFabHttp.ApiProcessingErrorEventHandler(request, error);
			}
			catch (Exception exception)
			{
				UnityEngine.Debug.LogException(exception);
			}
		}

		protected internal static void SendEvent(string apiEndpoint, PlayFabRequestCommon request, PlayFabResultCommon result, ApiProcessingEventType eventType)
		{
			if (PlayFabHttp.ApiProcessingEventHandler == null)
			{
				return;
			}
			try
			{
				PlayFabHttp.ApiProcessingEventHandler(new ApiProcessingEventArgs
				{
					ApiEndpoint = apiEndpoint,
					EventType = eventType,
					Request = request,
					Result = result
				});
			}
			catch (Exception exception)
			{
				UnityEngine.Debug.LogException(exception);
			}
		}

		protected internal static void ClearAllEvents()
		{
			PlayFabHttp.ApiProcessingEventHandler = null;
			PlayFabHttp.ApiProcessingErrorEventHandler = null;
		}

		public void InjectInUnityThread(IEnumerator x)
		{
			_injectedCoroutines.Enqueue(x);
		}

		public void InjectInUnityThread(Action action)
		{
			_injectedAction.Enqueue(action);
		}
	}
	public enum ApiProcessingEventType
	{
		Pre,
		Post
	}
	public class ApiProcessingEventArgs
	{
		public string ApiEndpoint;

		public ApiProcessingEventType EventType;

		public PlayFabRequestCommon Request;

		public PlayFabResultCommon Result;

		public TRequest GetRequest<TRequest>() where TRequest : PlayFabRequestCommon
		{
			return Request as TRequest;
		}
	}
	public class PlayFabUnityHttp : ITransportPlugin, IPlayFabPlugin
	{
		private bool _isInitialized;

		private readonly int _pendingWwwMessages;

		public bool IsInitialized => _isInitialized;

		public void Initialize()
		{
			_isInitialized = true;
		}

		public void Update()
		{
		}

		public void OnDestroy()
		{
		}

		public void SimpleGetCall(string fullUrl, Action<byte[]> successCallback, Action<string> errorCallback)
		{
			SingletonMonoBehaviour<PlayFabHttp>.instance.StartCoroutine(SimpleCallCoroutine("get", fullUrl, null, successCallback, errorCallback));
		}

		public void SimplePutCall(string fullUrl, byte[] payload, Action<byte[]> successCallback, Action<string> errorCallback)
		{
			SingletonMonoBehaviour<PlayFabHttp>.instance.StartCoroutine(SimpleCallCoroutine("put", fullUrl, payload, successCallback, errorCallback));
		}

		public void SimplePostCall(string fullUrl, byte[] payload, Action<byte[]> successCallback, Action<string> errorCallback)
		{
			SingletonMonoBehaviour<PlayFabHttp>.instance.StartCoroutine(SimpleCallCoroutine("post", fullUrl, payload, successCallback, errorCallback));
		}

		private static IEnumerator SimpleCallCoroutine(string method, string fullUrl, byte[] payload, Action<byte[]> successCallback, Action<string> errorCallback)
		{
			if (payload == null)
			{
				using (UnityWebRequest www = UnityWebRequest.Get(fullUrl))
				{
					yield return www.SendWebRequest();
					if (!string.IsNullOrEmpty(www.error))
					{
						errorCallback(www.error);
					}
					else
					{
						successCallback(www.downloadHandler.data);
					}
				}
				yield break;
			}
			UnityWebRequest www2;
			if (method == "put")
			{
				www2 = UnityWebRequest.Put(fullUrl, payload);
			}
			else
			{
				www2 = new UnityWebRequest(fullUrl, "POST");
				www2.uploadHandler = new UploadHandlerRaw(payload);
				www2.downloadHandler = new DownloadHandlerBuffer();
				www2.SetRequestHeader("Content-Type", "application/json");
			}
			www2.chunkedTransfer = false;
			yield return www2.SendWebRequest();
			if (www2.isNetworkError || www2.isHttpError)
			{
				errorCallback(www2.error);
			}
			else
			{
				successCallback(www2.downloadHandler.data);
			}
		}

		public void MakeApiCall(object reqContainerObj)
		{
			CallRequestContainer callRequestContainer = (CallRequestContainer)reqContainerObj;
			callRequestContainer.RequestHeaders["Content-Type"] = "application/json";
			if (PlayFabSettings.CompressApiData)
			{
				callRequestContainer.RequestHeaders["Content-Encoding"] = "GZIP";
				callRequestContainer.RequestHeaders["Accept-Encoding"] = "GZIP";
				using MemoryStream memoryStream = new MemoryStream();
				using (GZipStream gZipStream = new GZipStream(memoryStream, CompressionMode.Compress, Ionic.Zlib.CompressionLevel.BestCompression))
				{
					gZipStream.Write(callRequestContainer.Payload, 0, callRequestContainer.Payload.Length);
				}
				callRequestContainer.Payload = memoryStream.ToArray();
			}
			SingletonMonoBehaviour<PlayFabHttp>.instance.StartCoroutine(Post(callRequestContainer));
		}

		private IEnumerator Post(CallRequestContainer reqContainer)
		{
			UnityWebRequest www = new UnityWebRequest(reqContainer.FullUrl)
			{
				uploadHandler = new UploadHandlerRaw(reqContainer.Payload),
				downloadHandler = new DownloadHandlerBuffer(),
				method = "POST"
			};
			foreach (KeyValuePair<string, string> requestHeader in reqContainer.RequestHeaders)
			{
				if (!string.IsNullOrEmpty(requestHeader.Key) && !string.IsNullOrEmpty(requestHeader.Value))
				{
					www.SetRequestHeader(requestHeader.Key, requestHeader.Value);
				}
				else
				{
					UnityEngine.Debug.LogWarning("Null header: " + requestHeader.Key + " = " + requestHeader.Value);
				}
			}
			yield return www.SendWebRequest();
			if (!string.IsNullOrEmpty(www.error))
			{
				OnError(www.error, reqContainer);
			}
			else
			{
				try
				{
					byte[] data = www.downloadHandler.data;
					bool num = data != null && data[0] == 31 && data[1] == 139;
					string response = "Unexpected error: cannot decompress GZIP stream.";
					if (!num && data != null)
					{
						response = Encoding.UTF8.GetString(data, 0, data.Length);
					}
					if (num)
					{
						using GZipStream gZipStream = new GZipStream(new MemoryStream(data), CompressionMode.Decompress, leaveOpen: false);
						byte[] array = new byte[4096];
						using MemoryStream memoryStream = new MemoryStream();
						int count;
						while ((count = gZipStream.Read(array, 0, array.Length)) > 0)
						{
							memoryStream.Write(array, 0, count);
						}
						memoryStream.Seek(0L, SeekOrigin.Begin);
						string response2 = new StreamReader(memoryStream).ReadToEnd();
						OnResponse(response2, reqContainer);
					}
					else
					{
						OnResponse(response, reqContainer);
					}
				}
				catch (Exception ex)
				{
					OnError("Unhandled error in PlayFabUnityHttp: " + ex, reqContainer);
				}
			}
			www.Dispose();
		}

		public int GetPendingMessages()
		{
			return _pendingWwwMessages;
		}

		public void OnResponse(string response, CallRequestContainer reqContainer)
		{
			try
			{
				ISerializerPlugin plugin = PluginManager.GetPlugin<ISerializerPlugin>(PluginContract.PlayFab_Serializer);
				HttpResponseObject httpResponseObject = plugin.DeserializeObject<HttpResponseObject>(response);
				if (httpResponseObject.code == 200)
				{
					reqContainer.JsonResponse = plugin.SerializeObject(httpResponseObject.data);
					reqContainer.DeserializeResultJson();
					reqContainer.ApiResult.Request = reqContainer.ApiRequest;
					reqContainer.ApiResult.CustomData = reqContainer.CustomData;
					SingletonMonoBehaviour<PlayFabHttp>.instance.OnPlayFabApiResult(reqContainer);
					PlayFabDeviceUtil.OnPlayFabLogin(reqContainer.ApiResult, reqContainer.settings, reqContainer.instanceApi);
					try
					{
						PlayFabHttp.SendEvent(reqContainer.ApiEndpoint, reqContainer.ApiRequest, reqContainer.ApiResult, ApiProcessingEventType.Post);
					}
					catch (Exception exception)
					{
						UnityEngine.Debug.LogException(exception);
					}
					try
					{
						reqContainer.InvokeSuccessCallback();
						return;
					}
					catch (Exception exception2)
					{
						UnityEngine.Debug.LogException(exception2);
						return;
					}
				}
				if (reqContainer.ErrorCallback != null)
				{
					reqContainer.Error = PlayFabHttp.GeneratePlayFabError(reqContainer.ApiEndpoint, response, reqContainer.CustomData);
					PlayFabHttp.SendErrorEvent(reqContainer.ApiRequest, reqContainer.Error);
					reqContainer.ErrorCallback(reqContainer.Error);
				}
			}
			catch (Exception exception3)
			{
				UnityEngine.Debug.LogException(exception3);
			}
		}

		public void OnError(string error, CallRequestContainer reqContainer)
		{
			reqContainer.JsonResponse = error;
			if (reqContainer.ErrorCallback != null)
			{
				reqContainer.Error = PlayFabHttp.GeneratePlayFabError(reqContainer.ApiEndpoint, reqContainer.JsonResponse, reqContainer.CustomData);
				PlayFabHttp.SendErrorEvent(reqContainer.ApiRequest, reqContainer.Error);
				reqContainer.ErrorCallback(reqContainer.Error);
			}
		}
	}
	public class PlayFabWebRequest : ITransportPlugin, IPlayFabPlugin
	{
		private static readonly Queue<Action> ResultQueueTransferThread = new Queue<Action>();

		private static readonly Queue<Action> ResultQueueMainThread = new Queue<Action>();

		private static readonly List<CallRequestContainer> ActiveRequests = new List<CallRequestContainer>();

		private static bool certValidationSet = false;

		private static Thread _requestQueueThread;

		private static readonly object _ThreadLock = new object();

		private static readonly TimeSpan ThreadKillTimeout = TimeSpan.FromSeconds(60.0);

		private static DateTime _threadKillTime = DateTime.UtcNow + ThreadKillTimeout;

		private static bool _isApplicationPlaying;

		private static int _activeCallCount;

		private static string _unityVersion;

		private bool _isInitialized;

		public static RemoteCertificateValidationCallback CustomCertValidationHook
		{
			set
			{
				ServicePointManager.ServerCertificateValidationCallback = value;
				certValidationSet = true;
			}
		}

		public bool IsInitialized => _isInitialized;

		public static void SkipCertificateValidation()
		{
			ServicePointManager.ServerCertificateValidationCallback = AcceptAllCertifications;
			certValidationSet = true;
		}

		public void Initialize()
		{
			SetupCertificates();
			_isApplicationPlaying = true;
			_unityVersion = UnityEngine.Application.unityVersion;
			_isInitialized = true;
		}

		public void OnDestroy()
		{
			_isApplicationPlaying = false;
			lock (ResultQueueTransferThread)
			{
				ResultQueueTransferThread.Clear();
			}
			lock (ActiveRequests)
			{
				ActiveRequests.Clear();
			}
			lock (_ThreadLock)
			{
				_requestQueueThread = null;
			}
		}

		private void SetupCertificates()
		{
			ServicePointManager.DefaultConnectionLimit = 10;
			ServicePointManager.Expect100Continue = false;
			if (!certValidationSet)
			{
				UnityEngine.Debug.LogWarning("PlayFab API calls will likely fail because you have not set up a HttpWebRequest certificate validation mechanism");
				UnityEngine.Debug.LogWarning("Please set a validation callback into PlayFab.Internal.PlayFabWebRequest.CustomCertValidationHook, or set PlayFab.Internal.PlayFabWebRequest.SkipCertificateValidation()");
			}
		}

		private static bool AcceptAllCertifications(object sender, X509Certificate certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors)
		{
			return true;
		}

		public void SimpleGetCall(string fullUrl, Action<byte[]> successCallback, Action<string> errorCallback)
		{
			new Thread((ThreadStart)delegate
			{
				SimpleHttpsWorker("GET", fullUrl, null, successCallback, errorCallback);
			}).Start();
		}

		public void SimplePutCall(string fullUrl, byte[] payload, Action<byte[]> successCallback, Action<string> errorCallback)
		{
			new Thread((ThreadStart)delegate
			{
				SimpleHttpsWorker("PUT", fullUrl, payload, successCallback, errorCallback);
			}).Start();
		}

		public void SimplePostCall(string fullUrl, byte[] payload, Action<byte[]> successCallback, Action<string> errorCallback)
		{
			new Thread((ThreadStart)delegate
			{
				SimpleHttpsWorker("POST", fullUrl, payload, successCallback, errorCallback);
			}).Start();
		}

		private void SimpleHttpsWorker(string httpMethod, string fullUrl, byte[] payload, Action<byte[]> successCallback, Action<string> errorCallback)
		{
			HttpWebRequest httpWebRequest = (HttpWebRequest)WebRequest.Create(fullUrl);
			httpWebRequest.UserAgent = "UnityEngine-Unity; Version: " + _unityVersion;
			httpWebRequest.Method = httpMethod;
			httpWebRequest.KeepAlive = PlayFabSettings.RequestKeepAlive;
			httpWebRequest.Timeout = PlayFabSettings.RequestTimeout;
			httpWebRequest.AllowWriteStreamBuffering = false;
			httpWebRequest.ReadWriteTimeout = PlayFabSettings.RequestTimeout;
			if (payload != null)
			{
				httpWebRequest.ContentLength = payload.LongLength;
				using Stream stream = httpWebRequest.GetRequestStream();
				stream.Write(payload, 0, payload.Length);
			}
			try
			{
				WebResponse response = httpWebRequest.GetResponse();
				byte[] array = null;
				using (Stream stream2 = response.GetResponseStream())
				{
					if (stream2 != null)
					{
						array = new byte[response.ContentLength];
						stream2.Read(array, 0, array.Length);
					}
				}
				successCallback(array);
			}
			catch (WebException ex)
			{
				try
				{
					using Stream stream3 = ex.Response.GetResponseStream();
					if (stream3 != null)
					{
						using (StreamReader streamReader = new StreamReader(stream3))
						{
							errorCallback(streamReader.ReadToEnd());
							return;
						}
					}
				}
				catch (Exception exception)
				{
					UnityEngine.Debug.LogException(exception);
				}
			}
			catch (Exception exception2)
			{
				UnityEngine.Debug.LogException(exception2);
			}
		}

		public void MakeApiCall(object reqContainerObj)
		{
			CallRequestContainer callRequestContainer = (CallRequestContainer)reqContainerObj;
			callRequestContainer.HttpState = HttpRequestState.Idle;
			lock (ActiveRequests)
			{
				ActiveRequests.Insert(0, callRequestContainer);
			}
			ActivateThreadWorker();
		}

		private static void ActivateThreadWorker()
		{
			lock (_ThreadLock)
			{
				if (_requestQueueThread == null)
				{
					_requestQueueThread = new Thread(WorkerThreadMainLoop);
					_requestQueueThread.Start();
				}
			}
		}

		private static void WorkerThreadMainLoop()
		{
			try
			{
				lock (_ThreadLock)
				{
					_threadKillTime = DateTime.UtcNow + ThreadKillTimeout;
				}
				List<CallRequestContainer> list = new List<CallRequestContainer>();
				bool flag;
				do
				{
					lock (ActiveRequests)
					{
						list.AddRange(ActiveRequests);
						ActiveRequests.Clear();
						_activeCallCount = list.Count;
					}
					int count = list.Count;
					for (int num = count - 1; num >= 0; num--)
					{
						switch (list[num].HttpState)
						{
						case HttpRequestState.Error:
							list.RemoveAt(num);
							break;
						case HttpRequestState.Idle:
							Post(list[num]);
							break;
						case HttpRequestState.Sent:
							if (list[num].HttpRequest.HaveResponse)
							{
								ProcessHttpResponse(list[num]);
							}
							break;
						case HttpRequestState.Received:
							ProcessJsonResponse(list[num]);
							list.RemoveAt(num);
							break;
						}
					}
					lock (_ThreadLock)
					{
						DateTime utcNow = DateTime.UtcNow;
						if (count > 0 && _isApplicationPlaying)
						{
							_threadKillTime = utcNow + ThreadKillTimeout;
						}
						flag = utcNow <= _threadKillTime;
						if (!flag)
						{
							_requestQueueThread = null;
						}
					}
					Thread.Sleep(1);
				}
				while (flag);
			}
			catch (Exception exception)
			{
				UnityEngine.Debug.LogException(exception);
				_requestQueueThread = null;
			}
		}

		private static void Post(CallRequestContainer reqContainer)
		{
			try
			{
				reqContainer.HttpRequest = (HttpWebRequest)WebRequest.Create(reqContainer.FullUrl);
				reqContainer.HttpRequest.UserAgent = "UnityEngine-Unity; Version: " + _unityVersion;
				reqContainer.HttpRequest.SendChunked = false;
				reqContainer.HttpRequest.Proxy = null;
				foreach (KeyValuePair<string, string> requestHeader in reqContainer.RequestHeaders)
				{
					reqContainer.HttpRequest.Headers.Add(requestHeader.Key, requestHeader.Value);
				}
				reqContainer.HttpRequest.ContentType = "application/json";
				reqContainer.HttpRequest.Method = "POST";
				reqContainer.HttpRequest.KeepAlive = PlayFabSettings.RequestKeepAlive;
				reqContainer.HttpRequest.Timeout = PlayFabSettings.RequestTimeout;
				reqContainer.HttpRequest.AllowWriteStreamBuffering = false;
				reqContainer.HttpRequest.Proxy = null;
				reqContainer.HttpRequest.ContentLength = reqContainer.Payload.LongLength;
				reqContainer.HttpRequest.ReadWriteTimeout = PlayFabSettings.RequestTimeout;
				using (Stream stream = reqContainer.HttpRequest.GetRequestStream())
				{
					stream.Write(reqContainer.Payload, 0, reqContainer.Payload.Length);
				}
				reqContainer.HttpState = HttpRequestState.Sent;
			}
			catch (WebException ex)
			{
				reqContainer.JsonResponse = ResponseToString(ex.Response) ?? string.Concat(ex.Status, ": WebException making http request to: ", reqContainer.FullUrl);
				UnityEngine.Debug.LogException(new WebException(reqContainer.JsonResponse, ex));
				QueueRequestError(reqContainer);
			}
			catch (Exception innerException)
			{
				reqContainer.JsonResponse = "Unhandled exception in Post : " + reqContainer.FullUrl;
				UnityEngine.Debug.LogException(new Exception(reqContainer.JsonResponse, innerException));
				QueueRequestError(reqContainer);
			}
		}

		private static void ProcessHttpResponse(CallRequestContainer reqContainer)
		{
			try
			{
				HttpWebResponse httpWebResponse = (HttpWebResponse)reqContainer.HttpRequest.GetResponse();
				if (httpWebResponse.StatusCode == HttpStatusCode.OK)
				{
					reqContainer.JsonResponse = ResponseToString(httpWebResponse);
				}
				if (httpWebResponse.StatusCode != HttpStatusCode.OK || string.IsNullOrEmpty(reqContainer.JsonResponse))
				{
					reqContainer.JsonResponse = reqContainer.JsonResponse ?? "No response from server";
					QueueRequestError(reqContainer);
				}
				else
				{
					reqContainer.HttpState = HttpRequestState.Received;
				}
			}
			catch (Exception innerException)
			{
				string text = "Unhandled exception in ProcessHttpResponse : " + reqContainer.FullUrl;
				reqContainer.JsonResponse = reqContainer.JsonResponse ?? text;
				UnityEngine.Debug.LogException(new Exception(text, innerException));
				QueueRequestError(reqContainer);
			}
		}

		private static void QueueRequestError(CallRequestContainer reqContainer)
		{
			reqContainer.Error = PlayFabHttp.GeneratePlayFabError(reqContainer.ApiEndpoint, reqContainer.JsonResponse, reqContainer.CustomData);
			reqContainer.HttpState = HttpRequestState.Error;
			lock (ResultQueueTransferThread)
			{
				ResultQueueTransferThread.Enqueue(delegate
				{
					PlayFabHttp.SendErrorEvent(reqContainer.ApiRequest, reqContainer.Error);
					if (reqContainer.ErrorCallback != null)
					{
						reqContainer.ErrorCallback(reqContainer.Error);
					}
				});
			}
		}

		private static void ProcessJsonResponse(CallRequestContainer reqContainer)
		{
			try
			{
				ISerializerPlugin plugin = PluginManager.GetPlugin<ISerializerPlugin>(PluginContract.PlayFab_Serializer);
				HttpResponseObject httpResponseObject = plugin.DeserializeObject<HttpResponseObject>(reqContainer.JsonResponse);
				if (httpResponseObject == null || httpResponseObject.code != 200)
				{
					QueueRequestError(reqContainer);
					return;
				}
				reqContainer.JsonResponse = plugin.SerializeObject(httpResponseObject.data);
				reqContainer.DeserializeResultJson();
				reqContainer.ApiResult.Request = reqContainer.ApiRequest;
				reqContainer.ApiResult.CustomData = reqContainer.CustomData;
				SingletonMonoBehaviour<PlayFabHttp>.instance.OnPlayFabApiResult(reqContainer);
				lock (ResultQueueTransferThread)
				{
					ResultQueueTransferThread.Enqueue(delegate
					{
						PlayFabDeviceUtil.OnPlayFabLogin(reqContainer.ApiResult, reqContainer.settings, reqContainer.instanceApi);
					});
				}
				lock (ResultQueueTransferThread)
				{
					ResultQueueTransferThread.Enqueue(delegate
					{
						try
						{
							PlayFabHttp.SendEvent(reqContainer.ApiEndpoint, reqContainer.ApiRequest, reqContainer.ApiResult, ApiProcessingEventType.Post);
							reqContainer.InvokeSuccessCallback();
						}
						catch (Exception exception)
						{
							UnityEngine.Debug.LogException(exception);
						}
					});
				}
			}
			catch (Exception innerException)
			{
				string text = "Unhandled exception in ProcessJsonResponse : " + reqContainer.FullUrl;
				reqContainer.JsonResponse = reqContainer.JsonResponse ?? text;
				UnityEngine.Debug.LogException(new Exception(text, innerException));
				QueueRequestError(reqContainer);
			}
		}

		public void Update()
		{
			lock (ResultQueueTransferThread)
			{
				while (ResultQueueTransferThread.Count > 0)
				{
					Action item = ResultQueueTransferThread.Dequeue();
					ResultQueueMainThread.Enqueue(item);
				}
			}
			while (ResultQueueMainThread.Count > 0)
			{
				ResultQueueMainThread.Dequeue()();
			}
		}

		private static string ResponseToString(WebResponse webResponse)
		{
			if (webResponse == null)
			{
				return null;
			}
			try
			{
				using Stream stream = webResponse.GetResponseStream();
				if (stream == null)
				{
					return null;
				}
				using StreamReader streamReader = new StreamReader(stream);
				return streamReader.ReadToEnd();
			}
			catch (WebException ex)
			{
				try
				{
					using Stream stream2 = ex.Response.GetResponseStream();
					if (stream2 == null)
					{
						return null;
					}
					using StreamReader streamReader2 = new StreamReader(stream2);
					return streamReader2.ReadToEnd();
				}
				catch (Exception exception)
				{
					UnityEngine.Debug.LogException(exception);
					return null;
				}
			}
			catch (Exception exception2)
			{
				UnityEngine.Debug.LogException(exception2);
				return null;
			}
		}

		public int GetPendingMessages()
		{
			int num = 0;
			lock (ActiveRequests)
			{
				num += ActiveRequests.Count + _activeCallCount;
			}
			lock (ResultQueueTransferThread)
			{
				return num + ResultQueueTransferThread.Count;
			}
		}
	}
	public class SingletonMonoBehaviour<T> : MonoBehaviour where T : SingletonMonoBehaviour<T>
	{
		private static T _instance;

		protected bool initialized;

		public static T instance
		{
			get
			{
				CreateInstance();
				return _instance;
			}
		}

		public static void CreateInstance()
		{
			if (_instance == null)
			{
				_instance = UnityEngine.Object.FindObjectOfType<T>();
				if (_instance == null)
				{
					_instance = new GameObject(typeof(T).Name).AddComponent<T>();
				}
				if (!_instance.initialized)
				{
					_instance.Initialize();
					_instance.initialized = true;
				}
			}
		}

		public virtual void Awake()
		{
			if (UnityEngine.Application.isPlaying)
			{
				UnityEngine.Object.DontDestroyOnLoad(this);
			}
			if (_instance != null)
			{
				UnityEngine.Object.DestroyImmediate(base.gameObject);
			}
		}

		protected virtual void Initialize()
		{
		}
	}
	internal static class PlayFabUtil
	{
		private static string _localSettingsFileName;

		public static readonly string[] _defaultDateTimeFormats;

		public const int DEFAULT_UTC_OUTPUT_INDEX = 2;

		public const int DEFAULT_LOCAL_OUTPUT_INDEX = 9;

		public static DateTimeStyles DateTimeStyles;

		[ThreadStatic]
		private static StringBuilder _sb;

		public static string timeStamp => DateTime.Now.ToString(_defaultDateTimeFormats[9]);

		public static string utcTimeStamp => DateTime.UtcNow.ToString(_defaultDateTimeFormats[2]);

		static PlayFabUtil()
		{
			_localSettingsFileName = "playfab.local.settings.json";
			_defaultDateTimeFormats = new string[15]
			{
				"yyyy-MM-ddTHH:mm:ss.FFFFFFZ", "yyyy-MM-ddTHH:mm:ss.FFFFZ", "yyyy-MM-ddTHH:mm:ss.FFFZ", "yyyy-MM-ddTHH:mm:ss.FFZ", "yyyy-MM-ddTHH:mm:ssZ", "yyyy-MM-dd HH:mm:ssZ", "yyyy-MM-dd HH:mm:ss.FFFFFF", "yyyy-MM-dd HH:mm:ss.FFFF", "yyyy-MM-dd HH:mm:ss.FFF", "yyyy-MM-dd HH:mm:ss.FF",
				"yyyy-MM-dd HH:mm:ss", "yyyy-MM-dd HH:mm.ss.FFFF", "yyyy-MM-dd HH:mm.ss.FFF", "yyyy-MM-dd HH:mm.ss.FF", "yyyy-MM-dd HH:mm.ss"
			};
			DateTimeStyles = DateTimeStyles.RoundtripKind;
		}

		public static string Format(string text, params object[] args)
		{
			if (args.Length == 0)
			{
				return text;
			}
			return string.Format(text, args);
		}

		public static string ReadAllFileText(string filename)
		{
			if (!File.Exists(filename))
			{
				return string.Empty;
			}
			if (_sb == null)
			{
				_sb = new StringBuilder();
			}
			_sb.Length = 0;
			using (FileStream input = new FileStream(filename, FileMode.Open))
			{
				using BinaryReader binaryReader = new BinaryReader(input);
				while (binaryReader.BaseStream.Position != binaryReader.BaseStream.Length)
				{
					_sb.Append(binaryReader.ReadChar());
				}
			}
			return _sb.ToString();
		}

		public static T TryEnumParse<T>(string value, T defaultValue)
		{
			try
			{
				return (T)Enum.Parse(typeof(T), value);
			}
			catch (InvalidCastException)
			{
				return defaultValue;
			}
			catch (Exception ex2)
			{
				UnityEngine.Debug.LogError("Enum cast failed with unknown error: " + ex2.Message);
				return defaultValue;
			}
		}

		internal static string GetLocalSettingsFileProperty(string propertyKey)
		{
			string text = null;
			string text2 = Path.Combine(Directory.GetCurrentDirectory(), _localSettingsFileName);
			if (File.Exists(text2))
			{
				text = ReadAllFileText(text2);
			}
			else
			{
				string text3 = Path.Combine(Path.GetTempPath(), _localSettingsFileName);
				if (File.Exists(text3))
				{
					text = ReadAllFileText(text3);
				}
			}
			if (!string.IsNullOrEmpty(text))
			{
				JsonObject jsonObject = PlayFabSimpleJson.DeserializeObject<JsonObject>(text);
				try
				{
					if (jsonObject.TryGetValue(propertyKey, out var value))
					{
						return value?.ToString();
					}
					return null;
				}
				catch (KeyNotFoundException)
				{
					return string.Empty;
				}
			}
			return string.Empty;
		}
	}
}
namespace PlayFab.ClientModels
{
	[Serializable]
	public class AcceptTradeRequest : PlayFabRequestCommon
	{
		public List<string> AcceptedInventoryInstanceIds;

		public string OfferingPlayerId;

		public string TradeId;
	}
	[Serializable]
	public class AcceptTradeResponse : PlayFabResultCommon
	{
		public TradeInfo Trade;
	}
	[Serializable]
	public class AdCampaignAttributionModel : PlayFabBaseModel
	{
		public DateTime AttributedAt;

		public string CampaignId;

		public string Platform;
	}
	[Serializable]
	public class AddFriendRequest : PlayFabRequestCommon
	{
		public string FriendEmail;

		public string FriendPlayFabId;

		public string FriendTitleDisplayName;

		public string FriendUsername;
	}
	[Serializable]
	public class AddFriendResult : PlayFabResultCommon
	{
		public bool Created;
	}
	[Serializable]
	public class AddGenericIDRequest : PlayFabRequestCommon
	{
		public GenericServiceId GenericId;
	}
	[Serializable]
	public class AddGenericIDResult : PlayFabResultCommon
	{
	}
	[Serializable]
	public class AddOrUpdateContactEmailRequest : PlayFabRequestCommon
	{
		public string EmailAddress;
	}
	[Serializable]
	public class AddOrUpdateContactEmailResult : PlayFabResultCommon
	{
	}
	[Serializable]
	public class AddSharedGroupMembersRequest : PlayFabRequestCommon
	{
		public List<string> PlayFabIds;

		public string SharedGroupId;
	}
	[Serializable]
	public class AddSharedGroupMembersResult : PlayFabResultCommon
	{
	}
	[Serializable]
	public class AddUsernamePasswordRequest : PlayFabRequestCommon
	{
		public string Email;

		public string Password;

		public string Username;
	}
	[Serializable]
	public class AddUsernamePasswordResult : PlayFabResultCommon
	{
		public string Username;
	}
	[Serializable]
	public class AddUserVirtualCurrencyRequest : PlayFabRequestCommon
	{
		public int Amount;

		public string VirtualCurrency;
	}
	[Serializable]
	public class AndroidDevicePushNotificationRegistrationRequest : PlayFabRequestCommon
	{
		public string ConfirmationMessage;

		public string DeviceToken;

		public bool? SendPushNotificationConfirmation;
	}
	[Serializable]
	public class AndroidDevicePushNotificationRegistrationResult : PlayFabResultCommon
	{
	}
	[Serializable]
	public class AttributeInstallRequest : PlayFabRequestCommon
	{
		public string Adid;

		public string Idfa;
	}
	[Serializable]
	public class AttributeInstallResult : PlayFabResultCommon
	{
	}
	[Serializable]
	public class CancelTradeRequest : PlayFabRequestCommon
	{
		public string TradeId;
	}
	[Serializable]
	public class CancelTradeResponse : PlayFabResultCommon
	{
		public TradeInfo Trade;
	}
	[Serializable]
	public class CartItem : PlayFabBaseModel
	{
		public string Description;

		public string DisplayName;

		public string ItemClass;

		public string ItemId;

		public string ItemInstanceId;

		public Dictionary<string, uint> RealCurrencyPrices;

		public Dictionary<string, uint> VCAmount;

		public Dictionary<string, uint> VirtualCurrencyPrices;
	}
	[Serializable]
	public class CatalogItem : PlayFabBaseModel
	{
		public CatalogItemBundleInfo Bundle;

		public bool CanBecomeCharacter;

		public string CatalogVersion;

		public CatalogItemConsumableInfo Consumable;

		public CatalogItemContainerInfo Container;

		public string CustomData;

		public string Description;

		public string DisplayName;

		public int InitialLimitedEditionCount;

		public bool IsLimitedEdition;

		public bool IsStackable;

		public bool IsTradable;

		public string ItemClass;

		public string ItemId;

		public string ItemImageUrl;

		public Dictionary<string, uint> RealCurrencyPrices;

		public List<string> Tags;

		public Dictionary<string, uint> VirtualCurrencyPrices;
	}
	[Serializable]
	public class CatalogItemBundleInfo : PlayFabBaseModel
	{
		public List<string> BundledItems;

		public List<string> BundledResultTables;

		public Dictionary<string, uint> BundledVirtualCurrencies;
	}
	[Serializable]
	public class CatalogItemConsumableInfo : PlayFabBaseModel
	{
		public uint? UsageCount;

		public uint? UsagePeriod;

		public string UsagePeriodGroup;
	}
	[Serializable]
	public class CatalogItemContainerInfo : PlayFabBaseModel
	{
		public List<string> ItemContents;

		public string KeyItemId;

		public List<string> ResultTableContents;

		public Dictionary<string, uint> VirtualCurrencyContents;
	}
	[Serializable]
	public class CharacterInventory : PlayFabBaseModel
	{
		public string CharacterId;

		public List<ItemInstance> Inventory;
	}
	[Serializable]
	public class CharacterLeaderboardEntry : PlayFabBaseModel
	{
		public string CharacterId;

		public string CharacterName;

		public string CharacterType;

		public string DisplayName;

		public string PlayFabId;

		public int Position;

		public int StatValue;
	}
	[Serializable]
	public class CharacterResult : PlayFabBaseModel
	{
		public string CharacterId;

		public string CharacterName;

		public string CharacterType;
	}
	public enum CloudScriptRevisionOption
	{
		Live,
		Latest,
		Specific
	}
	[Serializable]
	public class CollectionFilter : PlayFabBaseModel
	{
		public List<Container_Dictionary_String_String> Excludes;

		public List<Container_Dictionary_String_String> Includes;
	}
	[Serializable]
	public class ConfirmPurchaseRequest : PlayFabRequestCommon
	{
		public string OrderId;
	}
	[Serializable]
	public class ConfirmPurchaseResult : PlayFabResultCommon
	{
		public List<ItemInstance> Items;

		public string OrderId;

		public DateTime PurchaseDate;
	}
	[Serializable]
	public class ConsumeItemRequest : PlayFabRequestCommon
	{
		public string CharacterId;

		public int ConsumeCount;

		public string ItemInstanceId;
	}
	[Serializable]
	public class ConsumeItemResult : PlayFabResultCommon
	{
		public string ItemInstanceId;

		public int RemainingUses;
	}
	[Serializable]
	public class ConsumePSNEntitlementsRequest : PlayFabRequestCommon
	{
		public string CatalogVersion;

		public int ServiceLabel;
	}
	[Serializable]
	public class ConsumePSNEntitlementsResult : PlayFabResultCommon
	{
		public List<ItemInstance> ItemsGranted;
	}
	[Serializable]
	public class ConsumeXboxEntitlementsRequest : PlayFabRequestCommon
	{
		public string CatalogVersion;

		public string XboxToken;
	}
	[Serializable]
	public class ConsumeXboxEntitlementsResult : PlayFabResultCommon
	{
		public List<ItemInstance> Items;
	}
	[Serializable]
	public class ContactEmailInfoModel : PlayFabBaseModel
	{
		public string EmailAddress;

		public string Name;

		public EmailVerificationStatus? VerificationStatus;
	}
	[Serializable]
	public class Container_Dictionary_String_String : PlayFabBaseModel
	{
		public Dictionary<string, string> Data;
	}
	public enum ContinentCode
	{
		AF,
		AN,
		AS,
		EU,
		NA,
		OC,
		SA
	}
	public enum CountryCode
	{
		AF,
		AX,
		AL,
		DZ,
		AS,
		AD,
		AO,
		AI,
		AQ,
		AG,
		AR,
		AM,
		AW,
		AU,
		AT,
		AZ,
		BS,
		BH,
		BD,
		BB,
		BY,
		BE,
		BZ,
		BJ,
		BM,
		BT,
		BO,
		BQ,
		BA,
		BW,
		BV,
		BR,
		IO,
		BN,
		BG,
		BF,
		BI,
		KH,
		CM,
		CA,
		CV,
		KY,
		CF,
		TD,
		CL,
		CN,
		CX,
		CC,
		CO,
		KM,
		CG,
		CD,
		CK,
		CR,
		CI,
		HR,
		CU,
		CW,
		CY,
		CZ,
		DK,
		DJ,
		DM,
		DO,
		EC,
		EG,
		SV,
		GQ,
		ER,
		EE,
		ET,
		FK,
		FO,
		FJ,
		FI,
		FR,
		GF,
		PF,
		TF,
		GA,
		GM,
		GE,
		DE,
		GH,
		GI,
		GR,
		GL,
		GD,
		GP,
		GU,
		GT,
		GG,
		GN,
		GW,
		GY,
		HT,
		HM,
		VA,
		HN,
		HK,
		HU,
		IS,
		IN,
		ID,
		IR,
		IQ,
		IE,
		IM,
		IL,
		IT,
		JM,
		JP,
		JE,
		JO,
		KZ,
		KE,
		KI,
		KP,
		KR,
		KW,
		KG,
		LA,
		LV,
		LB,
		LS,
		LR,
		LY,
		LI,
		LT,
		LU,
		MO,
		MK,
		MG,
		MW,
		MY,
		MV,
		ML,
		MT,
		MH,
		MQ,
		MR,
		MU,
		YT,
		MX,
		FM,
		MD,
		MC,
		MN,
		ME,
		MS,
		MA,
		MZ,
		MM,
		NA,
		NR,
		NP,
		NL,
		NC,
		NZ,
		NI,
		NE,
		NG,
		NU,
		NF,
		MP,
		NO,
		OM,
		PK,
		PW,
		PS,
		PA,
		PG,
		PY,
		PE,
		PH,
		PN,
		PL,
		PT,
		PR,
		QA,
		RE,
		RO,
		RU,
		RW,
		BL,
		SH,
		KN,
		LC,
		MF,
		PM,
		VC,
		WS,
		SM,
		ST,
		SA,
		SN,
		RS,
		SC,
		SL,
		SG,
		SX,
		SK,
		SI,
		SB,
		SO,
		ZA,
		GS,
		SS,
		ES,
		LK,
		SD,
		SR,
		SJ,
		SZ,
		SE,
		CH,
		SY,
		TW,
		TJ,
		TZ,
		TH,
		TL,
		TG,
		TK,
		TO,
		TT,
		TN,
		TR,
		TM,
		TC,
		TV,
		UG,
		UA,
		AE,
		GB,
		US,
		UM,
		UY,
		UZ,
		VU,
		VE,
		VN,
		VG,
		VI,
		WF,
		EH,
		YE,
		ZM,
		ZW
	}
	[Serializable]
	public class CreateSharedGroupRequest : PlayFabRequestCommon
	{
		public string SharedGroupId;
	}
	[Serializable]
	public class CreateSharedGroupResult : PlayFabResultCommon
	{
		public string SharedGroupId;
	}
	public enum Currency
	{
		AED,
		AFN,
		ALL,
		AMD,
		ANG,
		AOA,
		ARS,
		AUD,
		AWG,
		AZN,
		BAM,
		BBD,
		BDT,
		BGN,
		BHD,
		BIF,
		BMD,
		BND,
		BOB,
		BRL,
		BSD,
		BTN,
		BWP,
		BYR,
		BZD,
		CAD,
		CDF,
		CHF,
		CLP,
		CNY,
		COP,
		CRC,
		CUC,
		CUP,
		CVE,
		CZK,
		DJF,
		DKK,
		DOP,
		DZD,
		EGP,
		ERN,
		ETB,
		EUR,
		FJD,
		FKP,
		GBP,
		GEL,
		GGP,
		GHS,
		GIP,
		GMD,
		GNF,
		GTQ,
		GYD,
		HKD,
		HNL,
		HRK,
		HTG,
		HUF,
		IDR,
		ILS,
		IMP,
		INR,
		IQD,
		IRR,
		ISK,
		JEP,
		JMD,
		JOD,
		JPY,
		KES,
		KGS,
		KHR,
		KMF,
		KPW,
		KRW,
		KWD,
		KYD,
		KZT,
		LAK,
		LBP,
		LKR,
		LRD,
		LSL,
		LYD,
		MAD,
		MDL,
		MGA,
		MKD,
		MMK,
		MNT,
		MOP,
		MRO,
		MUR,
		MVR,
		MWK,
		MXN,
		MYR,
		MZN,
		NAD,
		NGN,
		NIO,
		NOK,
		NPR,
		NZD,
		OMR,
		PAB,
		PEN,
		PGK,
		PHP,
		PKR,
		PLN,
		PYG,
		QAR,
		RON,
		RSD,
		RUB,
		RWF,
		SAR,
		SBD,
		SCR,
		SDG,
		SEK,
		SGD,
		SHP,
		SLL,
		SOS,
		SPL,
		SRD,
		STD,
		SVC,
		SYP,
		SZL,
		THB,
		TJS,
		TMT,
		TND,
		TOP,
		TRY,
		TTD,
		TVD,
		TWD,
		TZS,
		UAH,
		UGX,
		USD,
		UYU,
		UZS,
		VEF,
		VND,
		VUV,
		WST,
		XAF,
		XCD,
		XDR,
		XOF,
		XPF,
		YER,
		ZAR,
		ZMW,
		ZWD
	}
	[Serializable]
	public class CurrentGamesRequest : PlayFabRequestCommon
	{
		public string BuildVersion;

		public string GameMode;

		public Region? Region;

		public string StatisticName;

		public CollectionFilter TagFilter;
	}
	[Serializable]
	public class CurrentGamesResult : PlayFabResultCommon
	{
		public int GameCount;

		public List<GameInfo> Games;

		public int PlayerCount;
	}
	[Serializable]
	public class DeviceInfoRequest : PlayFabRequestCommon
	{
		public Dictionary<string, object> Info;
	}
	public enum EmailVerificationStatus
	{
		Unverified,
		Pending,
		Confirmed
	}
	[Serializable]
	public class EmptyResponse : PlayFabResultCommon
	{
	}
	[Serializable]
	public class EmptyResult : PlayFabResultCommon
	{
	}
	[Serializable]
	public class EntityKey : PlayFabBaseModel
	{
		public string Id;

		public string Type;
	}
	[Serializable]
	public class EntityTokenResponse : PlayFabBaseModel
	{
		public EntityKey Entity;

		public string EntityToken;

		public DateTime? TokenExpiration;
	}
	[Serializable]
	public class ExecuteCloudScriptRequest : PlayFabRequestCommon
	{
		public string FunctionName;

		public object FunctionParameter;

		public bool? GeneratePlayStreamEvent;

		public CloudScriptRevisionOption? RevisionSelection;

		public int? SpecificRevision;
	}
	[Serializable]
	public class ExecuteCloudScriptResult : PlayFabResultCommon
	{
		public int APIRequestsIssued;

		public ScriptExecutionError Error;

		public double ExecutionTimeSeconds;

		public string FunctionName;

		public object FunctionResult;

		public bool? FunctionResultTooLarge;

		public int HttpRequestsIssued;

		public List<LogStatement> Logs;

		public bool? LogsTooLarge;

		public uint MemoryConsumedBytes;

		public double ProcessorTimeSeconds;

		public int Revision;
	}
	[Serializable]
	public class FacebookInstantGamesPlayFabIdPair : PlayFabBaseModel
	{
		public string FacebookInstantGamesId;

		public string PlayFabId;
	}
	[Serializable]
	public class FacebookPlayFabIdPair : PlayFabBaseModel
	{
		public string FacebookId;

		public string PlayFabId;
	}
	[Serializable]
	public class FriendInfo : PlayFabBaseModel
	{
		public UserFacebookInfo FacebookInfo;

		public string FriendPlayFabId;

		public UserGameCenterInfo GameCenterInfo;

		public PlayerProfileModel Profile;

		public UserPsnInfo PSNInfo;

		public UserSteamInfo SteamInfo;

		public List<string> Tags;

		public string TitleDisplayName;

		public string Username;

		public UserXboxInfo XboxInfo;
	}
	[Serializable]
	public class GameCenterPlayFabIdPair : PlayFabBaseModel
	{
		public string GameCenterId;

		public string PlayFabId;
	}
	[Serializable]
	public class GameInfo : PlayFabBaseModel
	{
		public string BuildVersion;

		public string GameMode;

		public string GameServerData;

		public GameInstanceState? GameServerStateEnum;

		public DateTime? LastHeartbeat;

		public string LobbyID;

		public int? MaxPlayers;

		public List<string> PlayerUserIds;

		public Region? Region;

		public uint RunTime;

		public string ServerIPV4Address;

		public string ServerIPV6Address;

		public int? ServerPort;

		public string ServerPublicDNSName;

		public string StatisticName;

		public Dictionary<string, string> Tags;
	}
	public enum GameInstanceState
	{
		Open,
		Closed
	}
	[Serializable]
	public class GameServerRegionsRequest : PlayFabRequestCommon
	{
		public string BuildVersion;

		public string TitleId;
	}
	[Serializable]
	public class GameServerRegionsResult : PlayFabResultCommon
	{
		public List<RegionInfo> Regions;
	}
	[Serializable]
	public class GenericPlayFabIdPair : PlayFabBaseModel
	{
		public GenericServiceId GenericId;

		public string PlayFabId;
	}
	[Serializable]
	public class GenericServiceId : PlayFabBaseModel
	{
		public string ServiceName;

		public string UserId;
	}
	[Serializable]
	public class GetAccountInfoRequest : PlayFabRequestCommon
	{
		public string Email;

		public string PlayFabId;

		public string TitleDisplayName;

		public string Username;
	}
	[Serializable]
	public class GetAccountInfoResult : PlayFabResultCommon
	{
		public UserAccountInfo AccountInfo;
	}
	[Serializable]
	public class GetCatalogItemsRequest : PlayFabRequestCommon
	{
		public string CatalogVersion;
	}
	[Serializable]
	public class GetCatalogItemsResult : PlayFabResultCommon
	{
		public List<CatalogItem> Catalog;
	}
	[Serializable]
	public class GetCharacterDataRequest : PlayFabRequestCommon
	{
		public string CharacterId;

		public uint? IfChangedFromDataVersion;

		public List<string> Keys;

		public string PlayFabId;
	}
	[Serializable]
	public class GetCharacterDataResult : PlayFabResultCommon
	{
		public string CharacterId;

		public Dictionary<string, UserDataRecord> Data;

		public uint DataVersion;
	}
	[Serializable]
	public class GetCharacterInventoryRequest : PlayFabRequestCommon
	{
		public string CatalogVersion;

		public string CharacterId;
	}
	[Serializable]
	public class GetCharacterInventoryResult : PlayFabResultCommon
	{
		public string CharacterId;

		public List<ItemInstance> Inventory;

		public Dictionary<string, int> VirtualCurrency;

		public Dictionary<string, VirtualCurrencyRechargeTime> VirtualCurrencyRechargeTimes;
	}
	[Serializable]
	public class GetCharacterLeaderboardRequest : PlayFabRequestCommon
	{
		public string CharacterType;

		public int? MaxResultsCount;

		public int StartPosition;

		public string StatisticName;
	}
	[Serializable]
	public class GetCharacterLeaderboardResult : PlayFabResultCommon
	{
		public List<CharacterLeaderboardEntry> Leaderboard;
	}
	[Serializable]
	public class GetCharacterStatisticsRequest : PlayFabRequestCommon
	{
		public string CharacterId;
	}
	[Serializable]
	public class GetCharacterStatisticsResult : PlayFabResultCommon
	{
		public Dictionary<string, int> CharacterStatistics;
	}
	[Serializable]
	public class GetContentDownloadUrlRequest : PlayFabRequestCommon
	{
		public string HttpMethod;

		public string Key;

		public bool? ThruCDN;
	}
	[Serializable]
	public class GetContentDownloadUrlResult : PlayFabResultCommon
	{
		public string URL;
	}
	[Serializable]
	public class GetFriendLeaderboardAroundPlayerRequest : PlayFabRequestCommon
	{
		public bool? IncludeFacebookFriends;

		public bool? IncludeSteamFriends;

		public int? MaxResultsCount;

		public string PlayFabId;

		public PlayerProfileViewConstraints ProfileConstraints;

		public string StatisticName;

		public int? Version;

		public string XboxToken;
	}
	[Serializable]
	public class GetFriendLeaderboardAroundPlayerResult : PlayFabResultCommon
	{
		public List<PlayerLeaderboardEntry> Leaderboard;

		public DateTime? NextReset;

		public int Version;
	}
	[Serializable]
	public class GetFriendLeaderboardRequest : PlayFabRequestCommon
	{
		public bool? IncludeFacebookFriends;

		public bool? IncludeSteamFriends;

		public int? MaxResultsCount;

		public PlayerProfileViewConstraints ProfileConstraints;

		public int StartPosition;

		public string StatisticName;

		public int? Version;

		public string XboxToken;
	}
	[Serializable]
	public class GetFriendsListRequest : PlayFabRequestCommon
	{
		public bool? IncludeFacebookFriends;

		public bool? IncludeSteamFriends;

		public PlayerProfileViewConstraints ProfileConstraints;

		public string XboxToken;
	}
	[Serializable]
	public class GetFriendsListResult : PlayFabResultCommon
	{
		public List<FriendInfo> Friends;
	}
	[Serializable]
	public class GetLeaderboardAroundCharacterRequest : PlayFabRequestCommon
	{
		public string CharacterId;

		public string CharacterType;

		public int? MaxResultsCount;

		public string StatisticName;
	}
	[Serializable]
	public class GetLeaderboardAroundCharacterResult : PlayFabResultCommon
	{
		public List<CharacterLeaderboardEntry> Leaderboard;
	}
	[Serializable]
	public class GetLeaderboardAroundPlayerRequest : PlayFabRequestCommon
	{
		public int? MaxResultsCount;

		public string PlayFabId;

		public PlayerProfileViewConstraints ProfileConstraints;

		public string StatisticName;

		public int? Version;
	}
	[Serializable]
	public class GetLeaderboardAroundPlayerResult : PlayFabResultCommon
	{
		public List<PlayerLeaderboardEntry> Leaderboard;

		public DateTime? NextReset;

		public int Version;
	}
	[Serializable]
	public class GetLeaderboardForUsersCharactersRequest : PlayFabRequestCommon
	{
		public int MaxResultsCount;

		public string StatisticName;
	}
	[Serializable]
	public class GetLeaderboardForUsersCharactersResult : PlayFabResultCommon
	{
		public List<CharacterLeaderboardEntry> Leaderboard;
	}
	[Serializable]
	public class GetLeaderboardRequest : PlayFabRequestCommon
	{
		public int? MaxResultsCount;

		public PlayerProfileViewConstraints ProfileConstraints;

		public int StartPosition;

		public string StatisticName;

		public int? Version;
	}
	[Serializable]
	public class GetLeaderboardResult : PlayFabResultCommon
	{
		public List<PlayerLeaderboardEntry> Leaderboard;

		public DateTime? NextReset;

		public int Version;
	}
	[Serializable]
	public class GetPaymentTokenRequest : PlayFabRequestCommon
	{
		public string TokenProvider;
	}
	[Serializable]
	public class GetPaymentTokenResult : PlayFabResultCommon
	{
		public string OrderId;

		public string ProviderToken;
	}
	[Serializable]
	public class GetPhotonAuthenticationTokenRequest : PlayFabRequestCommon
	{
		public string PhotonApplicationId;
	}
	[Serializable]
	public class GetPhotonAuthenticationTokenResult : PlayFabResultCommon
	{
		public string PhotonCustomAuthenticationToken;
	}
	[Serializable]
	public class GetPlayerCombinedInfoRequest : PlayFabRequestCommon
	{
		public GetPlayerCombinedInfoRequestParams InfoRequestParameters;

		public string PlayFabId;
	}
	[Serializable]
	public class GetPlayerCombinedInfoRequestParams : PlayFabBaseModel
	{
		public bool GetCharacterInventories;

		public bool GetCharacterList;

		public bool GetPlayerProfile;

		public bool GetPlayerStatistics;

		public bool GetTitleData;

		public bool GetUserAccountInfo;

		public bool GetUserData;

		public bool GetUserInventory;

		public bool GetUserReadOnlyData;

		public bool GetUserVirtualCurrency;

		public List<string> PlayerStatisticNames;

		public PlayerProfileViewConstraints ProfileConstraints;

		public List<string> TitleDataKeys;

		public List<string> UserDataKeys;

		public List<string> UserReadOnlyDataKeys;
	}
	[Serializable]
	public class GetPlayerCombinedInfoResult : PlayFabResultCommon
	{
		public GetPlayerCombinedInfoResultPayload InfoResultPayload;

		public string PlayFabId;
	}
	[Serializable]
	public class GetPlayerCombinedInfoResultPayload : PlayFabBaseModel
	{
		public UserAccountInfo AccountInfo;

		public List<CharacterInventory> CharacterInventories;

		public List<CharacterResult> CharacterList;

		public PlayerProfileModel PlayerProfile;

		public List<StatisticValue> PlayerStatistics;

		public Dictionary<string, string> TitleData;

		public Dictionary<string, UserDataRecord> UserData;

		public uint UserDataVersion;

		public List<ItemInstance> UserInventory;

		public Dictionary<string, UserDataRecord> UserReadOnlyData;

		public uint UserReadOnlyDataVersion;

		public Dictionary<string, int> UserVirtualCurrency;

		public Dictionary<string, VirtualCurrencyRechargeTime> UserVirtualCurrencyRechargeTimes;
	}
	[Serializable]
	public class GetPlayerProfileRequest : PlayFabRequestCommon
	{
		public string PlayFabId;

		public PlayerProfileViewConstraints ProfileConstraints;
	}
	[Serializable]
	public class GetPlayerProfileResult : PlayFabResultCommon
	{
		public PlayerProfileModel PlayerProfile;
	}
	[Serializable]
	public class GetPlayerSegmentsRequest : PlayFabRequestCommon
	{
	}
	[Serializable]
	public class GetPlayerSegmentsResult : PlayFabResultCommon
	{
		public List<GetSegmentResult> Segments;
	}
	[Serializable]
	public class GetPlayerStatisticsRequest : PlayFabRequestCommon
	{
		public List<string> StatisticNames;

		public List<StatisticNameVersion> StatisticNameVersions;
	}
	[Serializable]
	public class GetPlayerStatisticsResult : PlayFabResultCommon
	{
		public List<StatisticValue> Statistics;
	}
	[Serializable]
	public class GetPlayerStatisticVersionsRequest : PlayFabRequestCommon
	{
		public string StatisticName;
	}
	[Serializable]
	public class GetPlayerStatisticVersionsResult : PlayFabResultCommon
	{
		public List<PlayerStatisticVersion> StatisticVersions;
	}
	[Serializable]
	public class GetPlayerTagsRequest : PlayFabRequestCommon
	{
		public string Namespace;

		public string PlayFabId;
	}
	[Serializable]
	public class GetPlayerTagsResult : PlayFabResultCommon
	{
		public string PlayFabId;

		public List<string> Tags;
	}
	[Serializable]
	public class GetPlayerTradesRequest : PlayFabRequestCommon
	{
		public TradeStatus? StatusFilter;
	}
	[Serializable]
	public class GetPlayerTradesResponse : PlayFabResultCommon
	{
		public List<TradeInfo> AcceptedTrades;

		public List<TradeInfo> OpenedTrades;
	}
	[Serializable]
	public class GetPlayFabIDsFromFacebookIDsRequest : PlayFabRequestCommon
	{
		public List<string> FacebookIDs;
	}
	[Serializable]
	public class GetPlayFabIDsFromFacebookIDsResult : PlayFabResultCommon
	{
		public List<FacebookPlayFabIdPair> Data;
	}
	[Serializable]
	public class GetPlayFabIDsFromFacebookInstantGamesIdsRequest : PlayFabRequestCommon
	{
		public List<string> FacebookInstantGamesIds;
	}
	[Serializable]
	public class GetPlayFabIDsFromFacebookInstantGamesIdsResult : PlayFabResultCommon
	{
		public List<FacebookInstantGamesPlayFabIdPair> Data;
	}
	[Serializable]
	public class GetPlayFabIDsFromGameCenterIDsRequest : PlayFabRequestCommon
	{
		public List<string> GameCenterIDs;
	}
	[Serializable]
	public class GetPlayFabIDsFromGameCenterIDsResult : PlayFabResultCommon
	{
		public List<GameCenterPlayFabIdPair> Data;
	}
	[Serializable]
	public class GetPlayFabIDsFromGenericIDsRequest : PlayFabRequestCommon
	{
		public List<GenericServiceId> GenericIDs;
	}
	[Serializable]
	public class GetPlayFabIDsFromGenericIDsResult : PlayFabResultCommon
	{
		public List<GenericPlayFabIdPair> Data;
	}
	[Serializable]
	public class GetPlayFabIDsFromGoogleIDsRequest : PlayFabRequestCommon
	{
		public List<string> GoogleIDs;
	}
	[Serializable]
	public class GetPlayFabIDsFromGoogleIDsResult : PlayFabResultCommon
	{
		public List<GooglePlayFabIdPair> Data;
	}
	[Serializable]
	public class GetPlayFabIDsFromKongregateIDsRequest : PlayFabRequestCommon
	{
		public List<string> KongregateIDs;
	}
	[Serializable]
	public class GetPlayFabIDsFromKongregateIDsResult : PlayFabResultCommon
	{
		public List<KongregatePlayFabIdPair> Data;
	}
	[Serializable]
	public class GetPlayFabIDsFromNintendoSwitchDeviceIdsRequest : PlayFabRequestCommon
	{
		public List<string> NintendoSwitchDeviceIds;
	}
	[Serializable]
	public class GetPlayFabIDsFromNintendoSwitchDeviceIdsResult : PlayFabResultCommon
	{
		public List<NintendoSwitchPlayFabIdPair> Data;
	}
	[Serializable]
	public class GetPlayFabIDsFromPSNAccountIDsRequest : PlayFabRequestCommon
	{
		public int? IssuerId;

		public List<string> PSNAccountIDs;
	}
	[Serializable]
	public class GetPlayFabIDsFromPSNAccountIDsResult : PlayFabResultCommon
	{
		public List<PSNAccountPlayFabIdPair> Data;
	}
	[Serializable]
	public class GetPlayFabIDsFromSteamIDsRequest : PlayFabRequestCommon
	{
		public List<string> SteamStringIDs;
	}
	[Serializable]
	public class GetPlayFabIDsFromSteamIDsResult : PlayFabResultCommon
	{
		public List<SteamPlayFabIdPair> Data;
	}
	[Serializable]
	public class GetPlayFabIDsFromTwitchIDsRequest : PlayFabRequestCommon
	{
		public List<string> TwitchIds;
	}
	[Serializable]
	public class GetPlayFabIDsFromTwitchIDsResult : PlayFabResultCommon
	{
		public List<TwitchPlayFabIdPair> Data;
	}
	[Serializable]
	public class GetPlayFabIDsFromXboxLiveIDsRequest : PlayFabRequestCommon
	{
		public string Sandbox;

		public List<string> XboxLiveAccountIDs;
	}
	[Serializable]
	public class GetPlayFabIDsFromXboxLiveIDsResult : PlayFabResultCommon
	{
		public List<XboxLiveAccountPlayFabIdPair> Data;
	}
	[Serializable]
	public class GetPublisherDataRequest : PlayFabRequestCommon
	{
		public List<string> Keys;
	}
	[Serializable]
	public class GetPublisherDataResult : PlayFabResultCommon
	{
		public Dictionary<string, string> Data;
	}
	[Serializable]
	public class GetPurchaseRequest : PlayFabRequestCommon
	{
		public string OrderId;
	}
	[Serializable]
	public class GetPurchaseResult : PlayFabResultCommon
	{
		public string OrderId;

		public string PaymentProvider;

		public DateTime PurchaseDate;

		public string TransactionId;

		public string TransactionStatus;
	}
	[Serializable]
	public class GetSegmentResult : PlayFabBaseModel
	{
		public string ABTestParent;

		public string Id;

		public string Name;
	}
	[Serializable]
	public class GetSharedGroupDataRequest : PlayFabRequestCommon
	{
		public bool? GetMembers;

		public List<string> Keys;

		public string SharedGroupId;
	}
	[Serializable]
	public class GetSharedGroupDataResult : PlayFabResultCommon
	{
		public Dictionary<string, SharedGroupDataRecord> Data;

		public List<string> Members;
	}
	[Serializable]
	public class GetStoreItemsRequest : PlayFabRequestCommon
	{
		public string CatalogVersion;

		public string StoreId;
	}
	[Serializable]
	public class GetStoreItemsResult : PlayFabResultCommon
	{
		public string CatalogVersion;

		public StoreMarketingModel MarketingData;

		public SourceType? Source;

		public List<StoreItem> Store;

		public string StoreId;
	}
	[Serializable]
	public class GetTimeRequest : PlayFabRequestCommon
	{
	}
	[Serializable]
	public class GetTimeResult : PlayFabResultCommon
	{
		public DateTime Time;
	}
	[Serializable]
	public class GetTitleDataRequest : PlayFabRequestCommon
	{
		public List<string> Keys;
	}
	[Serializable]
	public class GetTitleDataResult : PlayFabResultCommon
	{
		public Dictionary<string, string> Data;
	}
	[Serializable]
	public class GetTitleNewsRequest : PlayFabRequestCommon
	{
		public int? Count;
	}
	[Serializable]
	public class GetTitleNewsResult : PlayFabResultCommon
	{
		public List<TitleNewsItem> News;
	}
	[Serializable]
	public class GetTitlePublicKeyRequest : PlayFabRequestCommon
	{
		public string TitleId;

		public string TitleSharedSecret;
	}
	[Serializable]
	public class GetTitlePublicKeyResult : PlayFabResultCommon
	{
		public string RSAPublicKey;
	}
	[Serializable]
	public class GetTradeStatusRequest : PlayFabRequestCommon
	{
		public string OfferingPlayerId;

		public string TradeId;
	}
	[Serializable]
	public class GetTradeStatusResponse : PlayFabResultCommon
	{
		public TradeInfo Trade;
	}
	[Serializable]
	public class GetUserDataRequest : PlayFabRequestCommon
	{
		public uint? IfChangedFromDataVersion;

		public List<string> Keys;

		public string PlayFabId;
	}
	[Serializable]
	public class GetUserDataResult : PlayFabResultCommon
	{
		public Dictionary<string, UserDataRecord> Data;

		public uint DataVersion;
	}
	[Serializable]
	public class GetUserInventoryRequest : PlayFabRequestCommon
	{
	}
	[Serializable]
	public class GetUserInventoryResult : PlayFabResultCommon
	{
		public List<ItemInstance> Inventory;

		public Dictionary<string, int> VirtualCurrency;

		public Dictionary<string, VirtualCurrencyRechargeTime> VirtualCurrencyRechargeTimes;
	}
	[Serializable]
	public class GetWindowsHelloChallengeRequest : PlayFabRequestCommon
	{
		public string PublicKeyHint;

		public string TitleId;
	}
	[Serializable]
	public class GetWindowsHelloChallengeResponse : PlayFabResultCommon
	{
		public string Challenge;
	}
	[Serializable]
	public class GooglePlayFabIdPair : PlayFabBaseModel
	{
		public string GoogleId;

		public string PlayFabId;
	}
	[Serializable]
	public class GrantCharacterToUserRequest : PlayFabRequestCommon
	{
		public string CatalogVersion;

		public string CharacterName;

		public string ItemId;
	}
	[Serializable]
	public class GrantCharacterToUserResult : PlayFabResultCommon
	{
		public string CharacterId;

		public string CharacterType;

		public bool Result;
	}
	[Serializable]
	public class ItemInstance : PlayFabBaseModel
	{
		public string Annotation;

		public List<string> BundleContents;

		public string BundleParent;

		public string CatalogVersion;

		public Dictionary<string, string> CustomData;

		public string DisplayName;

		public DateTime? Expiration;

		public string ItemClass;

		public string ItemId;

		public string ItemInstanceId;

		public DateTime? PurchaseDate;

		public int? RemainingUses;

		public string UnitCurrency;

		public uint UnitPrice;

		public int? UsesIncrementedBy;
	}
	[Serializable]
	public class ItemPurchaseRequest : PlayFabBaseModel
	{
		public string Annotation;

		public string ItemId;

		public uint Quantity;

		public List<string> UpgradeFromItems;
	}
	[Serializable]
	public class KongregatePlayFabIdPair : PlayFabBaseModel
	{
		public string KongregateId;

		public string PlayFabId;
	}
	[Serializable]
	public class LinkAndroidDeviceIDRequest : PlayFabRequestCommon
	{
		public string AndroidDevice;

		public string AndroidDeviceId;

		public bool? ForceLink;

		public string OS;
	}
	[Serializable]
	public class LinkAndroidDeviceIDResult : PlayFabResultCommon
	{
	}
	[Serializable]
	public class LinkCustomIDRequest : PlayFabRequestCommon
	{
		public string CustomId;

		public bool? ForceLink;
	}
	[Serializable]
	public class LinkCustomIDResult : PlayFabResultCommon
	{
	}
	[Serializable]
	public class LinkedPlatformAccountModel : PlayFabBaseModel
	{
		public string Email;

		public LoginIdentityProvider? Platform;

		public string PlatformUserId;

		public string Username;
	}
	[Serializable]
	public class LinkFacebookAccountRequest : PlayFabRequestCommon
	{
		public string AccessToken;

		public bool? ForceLink;
	}
	[Serializable]
	public class LinkFacebookAccountResult : PlayFabResultCommon
	{
	}
	[Serializable]
	public class LinkFacebookInstantGamesIdRequest : PlayFabRequestCommon
	{
		public string FacebookInstantGamesSignature;

		public bool? ForceLink;
	}
	[Serializable]
	public class LinkFacebookInstantGamesIdResult : PlayFabResultCommon
	{
	}
	[Serializable]
	public class LinkGameCenterAccountRequest : PlayFabRequestCommon
	{
		public bool? ForceLink;

		public string GameCenterId;

		public string PublicKeyUrl;

		public string Salt;

		public string Signature;

		public string Timestamp;
	}
	[Serializable]
	public class LinkGameCenterAccountResult : PlayFabResultCommon
	{
	}
	[Serializable]
	public class LinkGoogleAccountRequest : PlayFabRequestCommon
	{
		public bool? ForceLink;

		public string ServerAuthCode;
	}
	[Serializable]
	public class LinkGoogleAccountResult : PlayFabResultCommon
	{
	}
	[Serializable]
	public class LinkIOSDeviceIDRequest : PlayFabRequestCommon
	{
		public string DeviceId;

		public string DeviceModel;

		public bool? ForceLink;

		public string OS;
	}
	[Serializable]
	public class LinkIOSDeviceIDResult : PlayFabResultCommon
	{
	}
	[Serializable]
	public class LinkKongregateAccountRequest : PlayFabRequestCommon
	{
		public string AuthTicket;

		public bool? ForceLink;

		public string KongregateId;
	}
	[Serializable]
	public class LinkKongregateAccountResult : PlayFabResultCommon
	{
	}
	[Serializable]
	public class LinkNintendoSwitchDeviceIdRequest : PlayFabRequestCommon
	{
		public bool? ForceLink;

		public string NintendoSwitchDeviceId;
	}
	[Serializable]
	public class LinkNintendoSwitchDeviceIdResult : PlayFabResultCommon
	{
	}
	[Serializable]
	public class LinkOpenIdConnectRequest : PlayFabRequestCommon
	{
		public string ConnectionId;

		public bool? ForceLink;

		public string IdToken;
	}
	[Serializable]
	public class LinkPSNAccountRequest : PlayFabRequestCommon
	{
		public string AuthCode;

		public bool? ForceLink;

		public int? IssuerId;

		public string RedirectUri;
	}
	[Serializable]
	public class LinkPSNAccountResult : PlayFabResultCommon
	{
	}
	[Serializable]
	public class LinkSteamAccountRequest : PlayFabRequestCommon
	{
		public bool? ForceLink;

		public string SteamTicket;
	}
	[Serializable]
	public class LinkSteamAccountResult : PlayFabResultCommon
	{
	}
	[Serializable]
	public class LinkTwitchAccountRequest : PlayFabRequestCommon
	{
		public string AccessToken;

		public bool? ForceLink;
	}
	[Serializable]
	public class LinkTwitchAccountResult : PlayFabResultCommon
	{
	}
	[Serializable]
	public class LinkWindowsHelloAccountRequest : PlayFabRequestCommon
	{
		public string DeviceName;

		public bool? ForceLink;

		public string PublicKey;

		public string UserName;
	}
	[Serializable]
	public class LinkWindowsHelloAccountResponse : PlayFabResultCommon
	{
	}
	[Serializable]
	public class LinkXboxAccountRequest : PlayFabRequestCommon
	{
		public bool? ForceLink;

		public string XboxToken;
	}
	[Serializable]
	public class LinkXboxAccountResult : PlayFabResultCommon
	{
	}
	[Serializable]
	public class ListUsersCharactersRequest : PlayFabRequestCommon
	{
		public string PlayFabId;
	}
	[Serializable]
	public class ListUsersCharactersResult : PlayFabResultCommon
	{
		public List<CharacterResult> Characters;
	}
	[Serializable]
	public class LocationModel : PlayFabBaseModel
	{
		public string City;

		public ContinentCode? ContinentCode;

		public CountryCode? CountryCode;

		public double? Latitude;

		public double? Longitude;
	}
	public enum LoginIdentityProvider
	{
		Unknown,
		PlayFab,
		Custom,
		GameCenter,
		GooglePlay,
		Steam,
		XBoxLive,
		PSN,
		Kongregate,
		Facebook,
		IOSDevice,
		AndroidDevice,
		Twitch,
		WindowsHello,
		GameServer,
		CustomServer,
		NintendoSwitch,
		FacebookInstantGames,
		OpenIdConnect
	}
	[Serializable]
	public class LoginResult : PlayFabLoginResultCommon
	{
		public EntityTokenResponse EntityToken;

		public GetPlayerCombinedInfoResultPayload InfoResultPayload;

		public DateTime? LastLoginTime;

		public bool NewlyCreated;

		public string PlayFabId;

		public string SessionTicket;

		public UserSettings SettingsForUser;
	}
	[Serializable]
	public class LoginWithAndroidDeviceIDRequest : PlayFabRequestCommon
	{
		public string AndroidDevice;

		public string AndroidDeviceId;

		public bool? CreateAccount;

		public string EncryptedRequest;

		public GetPlayerCombinedInfoRequestParams InfoRequestParameters;

		public string OS;

		public string PlayerSecret;

		public string TitleId;
	}
	[Serializable]
	public class LoginWithCustomIDRequest : PlayFabRequestCommon
	{
		public bool? CreateAccount;

		public string CustomId;

		public string EncryptedRequest;

		public GetPlayerCombinedInfoRequestParams InfoRequestParameters;

		public string PlayerSecret;

		public string TitleId;
	}
	[Serializable]
	public class LoginWithEmailAddressRequest : PlayFabRequestCommon
	{
		public string Email;

		public GetPlayerCombinedInfoRequestParams InfoRequestParameters;

		public string Password;

		public string TitleId;
	}
	[Serializable]
	public class LoginWithFacebookInstantGamesIdRequest : PlayFabRequestCommon
	{
		public bool? CreateAccount;

		public string EncryptedRequest;

		public string FacebookInstantGamesSignature;

		public GetPlayerCombinedInfoRequestParams InfoRequestParameters;

		public string PlayerSecret;

		public string TitleId;
	}
	[Serializable]
	public class LoginWithFacebookRequest : PlayFabRequestCommon
	{
		public string AccessToken;

		public bool? CreateAccount;

		public string EncryptedRequest;

		public GetPlayerCombinedInfoRequestParams InfoRequestParameters;

		public string PlayerSecret;

		public string TitleId;
	}
	[Serializable]
	public class LoginWithGameCenterRequest : PlayFabRequestCommon
	{
		public bool? CreateAccount;

		public string EncryptedRequest;

		public GetPlayerCombinedInfoRequestParams InfoRequestParameters;

		public string PlayerId;

		public string PlayerSecret;

		public string PublicKeyUrl;

		public string Salt;

		public string Signature;

		public string Timestamp;

		public string TitleId;
	}
	[Serializable]
	public class LoginWithGoogleAccountRequest : PlayFabRequestCommon
	{
		public bool? CreateAccount;

		public string EncryptedRequest;

		public GetPlayerCombinedInfoRequestParams InfoRequestParameters;

		public string PlayerSecret;

		public string ServerAuthCode;

		public string TitleId;
	}
	[Serializable]
	public class LoginWithIOSDeviceIDRequest : PlayFabRequestCommon
	{
		public bool? CreateAccount;

		public string DeviceId;

		public string DeviceModel;

		public string EncryptedRequest;

		public GetPlayerCombinedInfoRequestParams InfoRequestParameters;

		public string OS;

		public string PlayerSecret;

		public string TitleId;
	}
	[Serializable]
	public class LoginWithKongregateRequest : PlayFabRequestCommon
	{
		public string AuthTicket;

		public bool? CreateAccount;

		public string EncryptedRequest;

		public GetPlayerCombinedInfoRequestParams InfoRequestParameters;

		public string KongregateId;

		public string PlayerSecret;

		public string TitleId;
	}
	[Serializable]
	public class LoginWithNintendoSwitchDeviceIdRequest : PlayFabRequestCommon
	{
		public bool? CreateAccount;

		public string EncryptedRequest;

		public GetPlayerCombinedInfoRequestParams InfoRequestParameters;

		public string NintendoSwitchDeviceId;

		public string PlayerSecret;

		public string TitleId;
	}
	[Serializable]
	public class LoginWithOpenIdConnectRequest : PlayFabRequestCommon
	{
		public string ConnectionId;

		public bool? CreateAccount;

		public string EncryptedRequest;

		public string IdToken;

		public GetPlayerCombinedInfoRequestParams InfoRequestParameters;

		public string PlayerSecret;

		public string TitleId;
	}
	[Serializable]
	public class LoginWithPlayFabRequest : PlayFabRequestCommon
	{
		public GetPlayerCombinedInfoRequestParams InfoRequestParameters;

		public string Password;

		public string TitleId;

		public string Username;
	}
	[Serializable]
	public class LoginWithPSNRequest : PlayFabRequestCommon
	{
		public string AuthCode;

		public bool? CreateAccount;

		public string EncryptedRequest;

		public GetPlayerCombinedInfoRequestParams InfoRequestParameters;

		public int? IssuerId;

		public string PlayerSecret;

		public string RedirectUri;

		public string TitleId;
	}
	[Serializable]
	public class LoginWithSteamRequest : PlayFabRequestCommon
	{
		public bool? CreateAccount;

		public string EncryptedRequest;

		public GetPlayerCombinedInfoRequestParams InfoRequestParameters;

		public string PlayerSecret;

		public string SteamTicket;

		public string TitleId;
	}
	[Serializable]
	public class LoginWithTwitchRequest : PlayFabRequestCommon
	{
		public string AccessToken;

		public bool? CreateAccount;

		public string EncryptedRequest;

		public GetPlayerCombinedInfoRequestParams InfoRequestParameters;

		public string PlayerSecret;

		public string TitleId;
	}
	[Serializable]
	public class LoginWithWindowsHelloRequest : PlayFabRequestCommon
	{
		public string ChallengeSignature;

		public GetPlayerCombinedInfoRequestParams InfoRequestParameters;

		public string PublicKeyHint;

		public string TitleId;
	}
	[Serializable]
	public class LoginWithXboxRequest : PlayFabRequestCommon
	{
		public bool? CreateAccount;

		public string EncryptedRequest;

		public GetPlayerCombinedInfoRequestParams InfoRequestParameters;

		public string PlayerSecret;

		public string TitleId;

		public string XboxToken;
	}
	[Serializable]
	public class LogStatement : PlayFabBaseModel
	{
		public object Data;

		public string Level;

		public string Message;
	}
	[Serializable]
	public class MatchmakeRequest : PlayFabRequestCommon
	{
		public string BuildVersion;

		public string CharacterId;

		public string GameMode;

		public string LobbyId;

		public Region? Region;

		public bool? StartNewIfNoneFound;

		public string StatisticName;

		public CollectionFilter TagFilter;
	}
	[Serializable]
	public class MatchmakeResult : PlayFabResultCommon
	{
		public string Expires;

		public string LobbyID;

		public int? PollWaitTimeMS;

		public string ServerIPV4Address;

		public string ServerIPV6Address;

		public int? ServerPort;

		public string ServerPublicDNSName;

		public MatchmakeStatus? Status;

		public string Ticket;
	}
	public enum MatchmakeStatus
	{
		Complete,
		Waiting,
		GameNotFound,
		NoAvailableSlots,
		SessionClosed
	}
	[Serializable]
	public class MembershipModel : PlayFabBaseModel
	{
		public bool IsActive;

		public DateTime MembershipExpiration;

		public string MembershipId;

		public DateTime? OverrideExpiration;

		public List<SubscriptionModel> Subscriptions;
	}
	[Serializable]
	public class ModifyUserVirtualCurrencyResult : PlayFabResultCommon
	{
		public int Balance;

		public int BalanceChange;

		public string PlayFabId;

		public string VirtualCurrency;
	}
	[Serializable]
	public class NintendoSwitchPlayFabIdPair : PlayFabBaseModel
	{
		public string NintendoSwitchDeviceId;

		public string PlayFabId;
	}
	[Serializable]
	public class OpenTradeRequest : PlayFabRequestCommon
	{
		public List<string> AllowedPlayerIds;

		public List<string> OfferedInventoryInstanceIds;

		public List<string> RequestedCatalogItemIds;
	}
	[Serializable]
	public class OpenTradeResponse : PlayFabResultCommon
	{
		public TradeInfo Trade;
	}
	[Serializable]
	public class PayForPurchaseRequest : PlayFabRequestCommon
	{
		public string Currency;

		public string OrderId;

		public string ProviderName;

		public string ProviderTransactionId;
	}
	[Serializable]
	public class PayForPurchaseResult : PlayFabResultCommon
	{
		public uint CreditApplied;

		public string OrderId;

		public string ProviderData;

		public string ProviderToken;

		public string PurchaseConfirmationPageURL;

		public string PurchaseCurrency;

		public uint PurchasePrice;

		public TransactionStatus? Status;

		public Dictionary<string, int> VCAmount;

		public Dictionary<string, int> VirtualCurrency;
	}
	[Serializable]
	public class PaymentOption : PlayFabBaseModel
	{
		public string Currency;

		public uint Price;

		public string ProviderName;

		public uint StoreCredit;
	}
	[Serializable]
	public class PlayerLeaderboardEntry : PlayFabBaseModel
	{
		public string DisplayName;

		public string PlayFabId;

		public int Position;

		public PlayerProfileModel Profile;

		public int StatValue;
	}
	[Serializable]
	public class PlayerProfileModel : PlayFabBaseModel
	{
		public List<AdCampaignAttributionModel> AdCampaignAttributions;

		public string AvatarUrl;

		public DateTime? BannedUntil;

		public List<ContactEmailInfoModel> ContactEmailAddresses;

		public DateTime? Created;

		public string DisplayName;

		public DateTime? LastLogin;

		public List<LinkedPlatformAccountModel> LinkedAccounts;

		public List<LocationModel> Locations;

		public List<MembershipModel> Memberships;

		public LoginIdentityProvider? Origination;

		public string PlayerId;

		public string PublisherId;

		public List<PushNotificationRegistrationModel> PushNotificationRegistrations;

		public List<StatisticModel> Statistics;

		public List<TagModel> Tags;

		public string TitleId;

		public uint? TotalValueToDateInUSD;

		public List<ValueToDateModel> ValuesToDate;
	}
	[Serializable]
	public class PlayerProfileViewConstraints : PlayFabBaseModel
	{
		public bool ShowAvatarUrl;

		public bool ShowBannedUntil;

		public bool ShowCampaignAttributions;

		public bool ShowContactEmailAddresses;

		public bool ShowCreated;

		public bool ShowDisplayName;

		public bool ShowLastLogin;

		public bool ShowLinkedAccounts;

		public bool ShowLocations;

		public bool ShowMemberships;

		public bool ShowOrigination;

		public bool ShowPushNotificationRegistrations;

		public bool ShowStatistics;

		public bool ShowTags;

		public bool ShowTotalValueToDateInUsd;

		public bool ShowValuesToDate;
	}
	[Serializable]
	public class PlayerStatisticVersion : PlayFabBaseModel
	{
		public DateTime ActivationTime;

		public DateTime? DeactivationTime;

		public DateTime? ScheduledActivationTime;

		public DateTime? ScheduledDeactivationTime;

		public string StatisticName;

		public uint Version;
	}
	[Serializable]
	public class PSNAccountPlayFabIdPair : PlayFabBaseModel
	{
		public string PlayFabId;

		public string PSNAccountId;
	}
	[Serializable]
	public class PurchaseItemRequest : PlayFabRequestCommon
	{
		public string CatalogVersion;

		public string CharacterId;

		public string ItemId;

		public int Price;

		public string StoreId;

		public string VirtualCurrency;
	}
	[Serializable]
	public class PurchaseItemResult : PlayFabResultCommon
	{
		public List<ItemInstance> Items;
	}
	[Serializable]
	public class PurchaseReceiptFulfillment : PlayFabBaseModel
	{
		public List<ItemInstance> FulfilledItems;

		public string RecordedPriceSource;

		public string RecordedTransactionCurrency;

		public uint? RecordedTransactionTotal;
	}
	public enum PushNotificationPlatform
	{
		ApplePushNotificationService,
		GoogleCloudMessaging
	}
	[Serializable]
	public class PushNotificationRegistrationModel : PlayFabBaseModel
	{
		public string NotificationEndpointARN;

		public PushNotificationPlatform? Platform;
	}
	[Serializable]
	public class RedeemCouponRequest : PlayFabRequestCommon
	{
		public string CatalogVersion;

		public string CharacterId;

		public string CouponCode;
	}
	[Serializable]
	public class RedeemCouponResult : PlayFabResultCommon
	{
		public List<ItemInstance> GrantedItems;
	}
	[Serializable]
	public class RefreshPSNAuthTokenRequest : PlayFabRequestCommon
	{
		public string AuthCode;

		public int? IssuerId;

		public string RedirectUri;
	}
	public enum Region
	{
		USCentral,
		USEast,
		EUWest,
		Singapore,
		Japan,
		Brazil,
		Australia
	}
	[Serializable]
	public class RegionInfo : PlayFabBaseModel
	{
		public bool Available;

		public string Name;

		public string PingUrl;

		public Region? Region;
	}
	[Serializable]
	public class RegisterForIOSPushNotificationRequest : PlayFabRequestCommon
	{
		public string ConfirmationMessage;

		public string DeviceToken;

		public bool? SendPushNotificationConfirmation;
	}
	[Serializable]
	public class RegisterForIOSPushNotificationResult : PlayFabResultCommon
	{
	}
	[Serializable]
	public class RegisterPlayFabUserRequest : PlayFabRequestCommon
	{
		public string DisplayName;

		public string Email;

		public string EncryptedRequest;

		public GetPlayerCombinedInfoRequestParams InfoRequestParameters;

		public string Password;

		public string PlayerSecret;

		public bool? RequireBothUsernameAndEmail;

		public string TitleId;

		public string Username;
	}
	[Serializable]
	public class RegisterPlayFabUserResult : PlayFabLoginResultCommon
	{
		public EntityTokenResponse EntityToken;

		public string PlayFabId;

		public string SessionTicket;

		public UserSettings SettingsForUser;

		public string Username;
	}
	[Serializable]
	public class RegisterWithWindowsHelloRequest : PlayFabRequestCommon
	{
		public string DeviceName;

		public string EncryptedRequest;

		public GetPlayerCombinedInfoRequestParams InfoRequestParameters;

		public string PlayerSecret;

		public string PublicKey;

		public string TitleId;

		public string UserName;
	}
	[Serializable]
	public class RemoveContactEmailRequest : PlayFabRequestCommon
	{
	}
	[Serializable]
	public class RemoveContactEmailResult : PlayFabResultCommon
	{
	}
	[Serializable]
	public class RemoveFriendRequest : PlayFabRequestCommon
	{
		public string FriendPlayFabId;
	}
	[Serializable]
	public class RemoveFriendResult : PlayFabResultCommon
	{
	}
	[Serializable]
	public class RemoveGenericIDRequest : PlayFabRequestCommon
	{
		public GenericServiceId GenericId;
	}
	[Serializable]
	public class RemoveGenericIDResult : PlayFabResultCommon
	{
	}
	[Serializable]
	public class RemoveSharedGroupMembersRequest : PlayFabRequestCommon
	{
		public List<string> PlayFabIds;

		public string SharedGroupId;
	}
	[Serializable]
	public class RemoveSharedGroupMembersResult : PlayFabResultCommon
	{
	}
	[Serializable]
	public class ReportPlayerClientRequest : PlayFabRequestCommon
	{
		public string Comment;

		public string ReporteeId;
	}
	[Serializable]
	public class ReportPlayerClientResult : PlayFabResultCommon
	{
		public int SubmissionsRemaining;
	}
	[Serializable]
	public class RestoreIOSPurchasesRequest : PlayFabRequestCommon
	{
		public string CatalogVersion;

		public string ReceiptData;
	}
	[Serializable]
	public class RestoreIOSPurchasesResult : PlayFabResultCommon
	{
		public List<PurchaseReceiptFulfillment> Fulfillments;
	}
	[Serializable]
	public class ScriptExecutionError : PlayFabBaseModel
	{
		public string Error;

		public string Message;

		public string StackTrace;
	}
	[Serializable]
	public class SendAccountRecoveryEmailRequest : PlayFabRequestCommon
	{
		public string Email;

		public string EmailTemplateId;

		public string TitleId;
	}
	[Serializable]
	public class SendAccountRecoveryEmailResult : PlayFabResultCommon
	{
	}
	[Serializable]
	public class SetFriendTagsRequest : PlayFabRequestCommon
	{
		public string FriendPlayFabId;

		public List<string> Tags;
	}
	[Serializable]
	public class SetFriendTagsResult : PlayFabResultCommon
	{
	}
	[Serializable]
	public class SetPlayerSecretRequest : PlayFabRequestCommon
	{
		public string EncryptedRequest;

		public string PlayerSecret;
	}
	[Serializable]
	public class SetPlayerSecretResult : PlayFabResultCommon
	{
	}
	[Serializable]
	public class SharedGroupDataRecord : PlayFabBaseModel
	{
		public DateTime LastUpdated;

		public string LastUpdatedBy;

		public UserDataPermission? Permission;

		public string Value;
	}
	public enum SourceType
	{
		Admin,
		BackEnd,
		GameClient,
		GameServer,
		Partner,
		Custom,
		API
	}
	[Serializable]
	public class StartGameRequest : PlayFabRequestCommon
	{
		public string BuildVersion;

		public string CharacterId;

		public string CustomCommandLineData;

		public string GameMode;

		public Region Region;

		public string StatisticName;
	}
	[Serializable]
	public class StartGameResult : PlayFabResultCommon
	{
		public string Expires;

		public string LobbyID;

		public string Password;

		public string ServerIPV4Address;

		public string ServerIPV6Address;

		public int? ServerPort;

		public string ServerPublicDNSName;

		public string Ticket;
	}
	[Serializable]
	public class StartPurchaseRequest : PlayFabRequestCommon
	{
		public string CatalogVersion;

		public List<ItemPurchaseRequest> Items;

		public string StoreId;
	}
	[Serializable]
	public class StartPurchaseResult : PlayFabResultCommon
	{
		public List<CartItem> Contents;

		public string OrderId;

		public List<PaymentOption> PaymentOptions;

		public Dictionary<string, int> VirtualCurrencyBalances;
	}
	[Serializable]
	public class StatisticModel : PlayFabBaseModel
	{
		public string Name;

		public int Value;

		public int Version;
	}
	[Serializable]
	public class StatisticNameVersion : PlayFabBaseModel
	{
		public string StatisticName;

		public uint Version;
	}
	[Serializable]
	public class StatisticUpdate : PlayFabBaseModel
	{
		public string StatisticName;

		public int Value;

		public uint? Version;
	}
	[Serializable]
	public class StatisticValue : PlayFabBaseModel
	{
		public string StatisticName;

		public int Value;

		public uint Version;
	}
	[Serializable]
	public class SteamPlayFabIdPair : PlayFabBaseModel
	{
		public string PlayFabId;

		public string SteamStringId;
	}
	[Serializable]
	public class StoreItem : PlayFabBaseModel
	{
		public object CustomData;

		public uint? DisplayPosition;

		public string ItemId;

		public Dictionary<string, uint> RealCurrencyPrices;

		public Dictionary<string, uint> VirtualCurrencyPrices;
	}
	[Serializable]
	public class StoreMarketingModel : PlayFabBaseModel
	{
		public string Description;

		public string DisplayName;

		public object Metadata;
	}
	[Serializable]
	public class SubscriptionModel : PlayFabBaseModel
	{
		public DateTime Expiration;

		public DateTime InitialSubscriptionTime;

		public bool IsActive;

		public SubscriptionProviderStatus? Status;

		public string SubscriptionId;

		public string SubscriptionItemId;

		public string SubscriptionProvider;
	}
	public enum SubscriptionProviderStatus
	{
		NoError,
		Cancelled,
		UnknownError,
		BillingError,
		ProductUnavailable,
		CustomerDidNotAcceptPriceChange,
		FreeTrial,
		PaymentPending
	}
	[Serializable]
	public class SubtractUserVirtualCurrencyRequest : PlayFabRequestCommon
	{
		public int Amount;

		public string VirtualCurrency;
	}
	[Serializable]
	public class TagModel : PlayFabBaseModel
	{
		public string TagValue;
	}
	public enum TitleActivationStatus
	{
		None,
		ActivatedTitleKey,
		PendingSteam,
		ActivatedSteam,
		RevokedSteam
	}
	[Serializable]
	public class TitleNewsItem : PlayFabBaseModel
	{
		public string Body;

		public string NewsId;

		public DateTime Timestamp;

		public string Title;
	}
	[Serializable]
	public class TradeInfo : PlayFabBaseModel
	{
		public List<string> AcceptedInventoryInstanceIds;

		public string AcceptedPlayerId;

		public List<string> AllowedPlayerIds;

		public DateTime? CancelledAt;

		public DateTime? FilledAt;

		public DateTime? InvalidatedAt;

		public List<string> OfferedCatalogItemIds;

		public List<string> OfferedInventoryInstanceIds;

		public string OfferingPlayerId;

		public DateTime? OpenedAt;

		public List<string> RequestedCatalogItemIds;

		public TradeStatus? Status;

		public string TradeId;
	}
	public enum TradeStatus
	{
		Invalid,
		Opening,
		Open,
		Accepting,
		Accepted,
		Filled,
		Cancelled
	}
	public enum TransactionStatus
	{
		CreateCart,
		Init,
		Approved,
		Succeeded,
		FailedByProvider,
		DisputePending,
		RefundPending,
		Refunded,
		RefundFailed,
		ChargedBack,
		FailedByUber,
		FailedByPlayFab,
		Revoked,
		TradePending,
		Traded,
		Upgraded,
		StackPending,
		Stacked,
		Other,
		Failed
	}
	[Serializable]
	public class TwitchPlayFabIdPair : PlayFabBaseModel
	{
		public string PlayFabId;

		public string TwitchId;
	}
	[Serializable]
	public class UninkOpenIdConnectRequest : PlayFabRequestCommon
	{
		public string ConnectionId;
	}
	[Serializable]
	public class UnlinkAndroidDeviceIDRequest : PlayFabRequestCommon
	{
		public string AndroidDeviceId;
	}
	[Serializable]
	public class UnlinkAndroidDeviceIDResult : PlayFabResultCommon
	{
	}
	[Serializable]
	public class UnlinkCustomIDRequest : PlayFabRequestCommon
	{
		public string CustomId;
	}
	[Serializable]
	public class UnlinkCustomIDResult : PlayFabResultCommon
	{
	}
	[Serializable]
	public class UnlinkFacebookAccountRequest : PlayFabRequestCommon
	{
	}
	[Serializable]
	public class UnlinkFacebookAccountResult : PlayFabResultCommon
	{
	}
	[Serializable]
	public class UnlinkFacebookInstantGamesIdRequest : PlayFabRequestCommon
	{
		public string FacebookInstantGamesId;
	}
	[Serializable]
	public class UnlinkFacebookInstantGamesIdResult : PlayFabResultCommon
	{
	}
	[Serializable]
	public class UnlinkGameCenterAccountRequest : PlayFabRequestCommon
	{
	}
	[Serializable]
	public class UnlinkGameCenterAccountResult : PlayFabResultCommon
	{
	}
	[Serializable]
	public class UnlinkGoogleAccountRequest : PlayFabRequestCommon
	{
	}
	[Serializable]
	public class UnlinkGoogleAccountResult : PlayFabResultCommon
	{
	}
	[Serializable]
	public class UnlinkIOSDeviceIDRequest : PlayFabRequestCommon
	{
		public string DeviceId;
	}
	[Serializable]
	public class UnlinkIOSDeviceIDResult : PlayFabResultCommon
	{
	}
	[Serializable]
	public class UnlinkKongregateAccountRequest : PlayFabRequestCommon
	{
	}
	[Serializable]
	public class UnlinkKongregateAccountResult : PlayFabResultCommon
	{
	}
	[Serializable]
	public class UnlinkNintendoSwitchDeviceIdRequest : PlayFabRequestCommon
	{
		public string NintendoSwitchDeviceId;
	}
	[Serializable]
	public class UnlinkNintendoSwitchDeviceIdResult : PlayFabResultCommon
	{
	}
	[Serializable]
	public class UnlinkPSNAccountRequest : PlayFabRequestCommon
	{
	}
	[Serializable]
	public class UnlinkPSNAccountResult : PlayFabResultCommon
	{
	}
	[Serializable]
	public class UnlinkSteamAccountRequest : PlayFabRequestCommon
	{
	}
	[Serializable]
	public class UnlinkSteamAccountResult : PlayFabResultCommon
	{
	}
	[Serializable]
	public class UnlinkTwitchAccountRequest : PlayFabRequestCommon
	{
	}
	[Serializable]
	public class UnlinkTwitchAccountResult : PlayFabResultCommon
	{
	}
	[Serializable]
	public class UnlinkWindowsHelloAccountRequest : PlayFabRequestCommon
	{
		public string PublicKeyHint;
	}
	[Serializable]
	public class UnlinkWindowsHelloAccountResponse : PlayFabResultCommon
	{
	}
	[Serializable]
	public class UnlinkXboxAccountRequest : PlayFabRequestCommon
	{
		public string XboxToken;
	}
	[Serializable]
	public class UnlinkXboxAccountResult : PlayFabResultCommon
	{
	}
	[Serializable]
	public class UnlockContainerInstanceRequest : PlayFabRequestCommon
	{
		public string CatalogVersion;

		public string CharacterId;

		public string ContainerItemInstanceId;

		public string KeyItemInstanceId;
	}
	[Serializable]
	public class UnlockContainerItemRequest : PlayFabRequestCommon
	{
		public string CatalogVersion;

		public string CharacterId;

		public string ContainerItemId;
	}
	[Serializable]
	public class UnlockContainerItemResult : PlayFabResultCommon
	{
		public List<ItemInstance> GrantedItems;

		public string UnlockedItemInstanceId;

		public string UnlockedWithItemInstanceId;

		public Dictionary<string, uint> VirtualCurrency;
	}
	[Serializable]
	public class UpdateAvatarUrlRequest : PlayFabRequestCommon
	{
		public string ImageUrl;
	}
	[Serializable]
	public class UpdateCharacterDataRequest : PlayFabRequestCommon
	{
		public string CharacterId;

		public Dictionary<string, string> Data;

		public List<string> KeysToRemove;

		public UserDataPermission? Permission;
	}
	[Serializable]
	public class UpdateCharacterDataResult : PlayFabResultCommon
	{
		public uint DataVersion;
	}
	[Serializable]
	public class UpdateCharacterStatisticsRequest : PlayFabRequestCommon
	{
		public string CharacterId;

		public Dictionary<string, int> CharacterStatistics;
	}
	[Serializable]
	public class UpdateCharacterStatisticsResult : PlayFabResultCommon
	{
	}
	[Serializable]
	public class UpdatePlayerStatisticsRequest : PlayFabRequestCommon
	{
		public List<StatisticUpdate> Statistics;
	}
	[Serializable]
	public class UpdatePlayerStatisticsResult : PlayFabResultCommon
	{
	}
	[Serializable]
	public class UpdateSharedGroupDataRequest : PlayFabRequestCommon
	{
		public Dictionary<string, string> Data;

		public List<string> KeysToRemove;

		public UserDataPermission? Permission;

		public string SharedGroupId;
	}
	[Serializable]
	public class UpdateSharedGroupDataResult : PlayFabResultCommon
	{
	}
	[Serializable]
	public class UpdateUserDataRequest : PlayFabRequestCommon
	{
		public Dictionary<string, string> Data;

		public List<string> KeysToRemove;

		public UserDataPermission? Permission;
	}
	[Serializable]
	public class UpdateUserDataResult : PlayFabResultCommon
	{
		public uint DataVersion;
	}
	[Serializable]
	public class UpdateUserTitleDisplayNameRequest : PlayFabRequestCommon
	{
		public string DisplayName;
	}
	[Serializable]
	public class UpdateUserTitleDisplayNameResult : PlayFabResultCommon
	{
		public string DisplayName;
	}
	[Serializable]
	public class UserAccountInfo : PlayFabBaseModel
	{
		public UserAndroidDeviceInfo AndroidDeviceInfo;

		public DateTime Created;

		public UserCustomIdInfo CustomIdInfo;

		public UserFacebookInfo FacebookInfo;

		public UserFacebookInstantGamesIdInfo FacebookInstantGamesIdInfo;

		public UserGameCenterInfo GameCenterInfo;

		public UserGoogleInfo GoogleInfo;

		public UserIosDeviceInfo IosDeviceInfo;

		public UserKongregateInfo KongregateInfo;

		public UserNintendoSwitchDeviceIdInfo NintendoSwitchDeviceIdInfo;

		public List<UserOpenIdInfo> OpenIdInfo;

		public string PlayFabId;

		public UserPrivateAccountInfo PrivateInfo;

		public UserPsnInfo PsnInfo;

		public UserSteamInfo SteamInfo;

		public UserTitleInfo TitleInfo;

		public UserTwitchInfo TwitchInfo;

		public string Username;

		public UserWindowsHelloInfo WindowsHelloInfo;

		public UserXboxInfo XboxInfo;
	}
	[Serializable]
	public class UserAndroidDeviceInfo : PlayFabBaseModel
	{
		public string AndroidDeviceId;
	}
	[Serializable]
	public class UserCustomIdInfo : PlayFabBaseModel
	{
		public string CustomId;
	}
	public enum UserDataPermission
	{
		Private,
		Public
	}
	[Serializable]
	public class UserDataRecord : PlayFabBaseModel
	{
		public DateTime LastUpdated;

		public UserDataPermission? Permission;

		public string Value;
	}
	[Serializable]
	public class UserFacebookInfo : PlayFabBaseModel
	{
		public string FacebookId;

		public string FullName;
	}
	[Serializable]
	public class UserFacebookInstantGamesIdInfo : PlayFabBaseModel
	{
		public string FacebookInstantGamesId;
	}
	[Serializable]
	public class UserGameCenterInfo : PlayFabBaseModel
	{
		public string GameCenterId;
	}
	[Serializable]
	public class UserGoogleInfo : PlayFabBaseModel
	{
		public string GoogleEmail;

		public string GoogleGender;

		public string GoogleId;

		public string GoogleLocale;

		public string GoogleName;
	}
	[Serializable]
	public class UserIosDeviceInfo : PlayFabBaseModel
	{
		public string IosDeviceId;
	}
	[Serializable]
	public class UserKongregateInfo : PlayFabBaseModel
	{
		public string KongregateId;

		public string KongregateName;
	}
	[Serializable]
	public class UserNintendoSwitchDeviceIdInfo : PlayFabBaseModel
	{
		public string NintendoSwitchDeviceId;
	}
	[Serializable]
	public class UserOpenIdInfo : PlayFabBaseModel
	{
		public string ConnectionId;

		public string Issuer;

		public string Subject;
	}
	public enum UserOrigination
	{
		Organic,
		Steam,
		Google,
		Amazon,
		Facebook,
		Kongregate,
		GamersFirst,
		Unknown,
		IOS,
		LoadTest,
		Android,
		PSN,
		GameCenter,
		CustomId,
		XboxLive,
		Parse,
		Twitch,
		WindowsHello,
		ServerCustomId,
		NintendoSwitchDeviceId,
		FacebookInstantGamesId,
		OpenIdConnect
	}
	[Serializable]
	public class UserPrivateAccountInfo : PlayFabBaseModel
	{
		public string Email;
	}
	[Serializable]
	public class UserPsnInfo : PlayFabBaseModel
	{
		public string PsnAccountId;

		public string PsnOnlineId;
	}
	[Serializable]
	public class UserSettings : PlayFabBaseModel
	{
		public bool GatherDeviceInfo;

		public bool GatherFocusInfo;

		public bool NeedsAttribution;
	}
	[Serializable]
	public class UserSteamInfo : PlayFabBaseModel
	{
		public TitleActivationStatus? SteamActivationStatus;

		public string SteamCountry;

		public Currency? SteamCurrency;

		public string SteamId;

		public string SteamName;
	}
	[Serializable]
	public class UserTitleInfo : PlayFabBaseModel
	{
		public string AvatarUrl;

		public DateTime Created;

		public string DisplayName;

		public DateTime? FirstLogin;

		public bool? isBanned;

		public DateTime? LastLogin;

		public UserOrigination? Origination;

		public EntityKey TitlePlayerAccount;
	}
	[Serializable]
	public class UserTwitchInfo : PlayFabBaseModel
	{
		public string TwitchId;

		public string TwitchUserName;
	}
	[Serializable]
	public class UserWindowsHelloInfo : PlayFabBaseModel
	{
		public string WindowsHelloDeviceName;

		public string WindowsHelloPublicKeyHash;
	}
	[Serializable]
	public class UserXboxInfo : PlayFabBaseModel
	{
		public string XboxUserId;
	}
	[Serializable]
	public class ValidateAmazonReceiptRequest : PlayFabRequestCommon
	{
		public string CatalogVersion;

		public string CurrencyCode;

		public int PurchasePrice;

		public string ReceiptId;

		public string UserId;
	}
	[Serializable]
	public class ValidateAmazonReceiptResult : PlayFabResultCommon
	{
		public List<PurchaseReceiptFulfillment> Fulfillments;
	}
	[Serializable]
	public class ValidateGooglePlayPurchaseRequest : PlayFabRequestCommon
	{
		public string CatalogVersion;

		public string CurrencyCode;

		public uint? PurchasePrice;

		public string ReceiptJson;

		public string Signature;
	}
	[Serializable]
	public class ValidateGooglePlayPurchaseResult : PlayFabResultCommon
	{
		public List<PurchaseReceiptFulfillment> Fulfillments;
	}
	[Serializable]
	public class ValidateIOSReceiptRequest : PlayFabRequestCommon
	{
		public string CatalogVersion;

		public string CurrencyCode;

		public int PurchasePrice;

		public string ReceiptData;
	}
	[Serializable]
	public class ValidateIOSReceiptResult : PlayFabResultCommon
	{
		public List<PurchaseReceiptFulfillment> Fulfillments;
	}
	[Serializable]
	public class ValidateWindowsReceiptRequest : PlayFabRequestCommon
	{
		public string CatalogVersion;

		public string CurrencyCode;

		public uint PurchasePrice;

		public string Receipt;
	}
	[Serializable]
	public class ValidateWindowsReceiptResult : PlayFabResultCommon
	{
		public List<PurchaseReceiptFulfillment> Fulfillments;
	}
	[Serializable]
	public class ValueToDateModel : PlayFabBaseModel
	{
		public string Currency;

		public uint TotalValue;

		public string TotalValueAsDecimal;
	}
	[Serializable]
	public class VirtualCurrencyRechargeTime : PlayFabBaseModel
	{
		public int RechargeMax;

		public DateTime RechargeTime;

		public int SecondsToRecharge;
	}
	[Serializable]
	public class WriteClientCharacterEventRequest : PlayFabRequestCommon
	{
		public Dictionary<string, object> Body;

		public string CharacterId;

		public string EventName;

		public DateTime? Timestamp;
	}
	[Serializable]
	public class WriteClientPlayerEventRequest : PlayFabRequestCommon
	{
		public Dictionary<string, object> Body;

		public string EventName;

		public DateTime? Timestamp;
	}
	[Serializable]
	public class WriteEventResponse : PlayFabResultCommon
	{
		public string EventId;
	}
	[Serializable]
	public class WriteTitleEventRequest : PlayFabRequestCommon
	{
		public Dictionary<string, object> Body;

		public string EventName;

		public DateTime? Timestamp;
	}
	[Serializable]
	public class XboxLiveAccountPlayFabIdPair : PlayFabBaseModel
	{
		public string PlayFabId;

		public string XboxLiveAccountId;
	}
}
namespace PlayFab.Events
{
	public class PlayFabEvents
	{
		public delegate void PlayFabErrorEvent(PlayFabRequestCommon request, PlayFabError error);

		public delegate void PlayFabResultEvent<in TResult>(TResult result) where TResult : PlayFabResultCommon;

		public delegate void PlayFabRequestEvent<in TRequest>(TRequest request) where TRequest : PlayFabRequestCommon;

		private static PlayFabEvents _instance;

		public event PlayFabRequestEvent<GetEntityTokenRequest> OnAuthenticationGetEntityTokenRequestEvent;

		public event PlayFabResultEvent<GetEntityTokenResponse> OnAuthenticationGetEntityTokenResultEvent;

		public event PlayFabRequestEvent<ValidateEntityTokenRequest> OnAuthenticationValidateEntityTokenRequestEvent;

		public event PlayFabResultEvent<ValidateEntityTokenResponse> OnAuthenticationValidateEntityTokenResultEvent;

		public event PlayFabResultEvent<LoginResult> OnLoginResultEvent;

		public event PlayFabRequestEvent<AcceptTradeRequest> OnAcceptTradeRequestEvent;

		public event PlayFabResultEvent<AcceptTradeResponse> OnAcceptTradeResultEvent;

		public event PlayFabRequestEvent<AddFriendRequest> OnAddFriendRequestEvent;

		public event PlayFabResultEvent<AddFriendResult> OnAddFriendResultEvent;

		public event PlayFabRequestEvent<AddGenericIDRequest> OnAddGenericIDRequestEvent;

		public event PlayFabResultEvent<AddGenericIDResult> OnAddGenericIDResultEvent;

		public event PlayFabRequestEvent<AddOrUpdateContactEmailRequest> OnAddOrUpdateContactEmailRequestEvent;

		public event PlayFabResultEvent<AddOrUpdateContactEmailResult> OnAddOrUpdateContactEmailResultEvent;

		public event PlayFabRequestEvent<AddSharedGroupMembersRequest> OnAddSharedGroupMembersRequestEvent;

		public event PlayFabResultEvent<AddSharedGroupMembersResult> OnAddSharedGroupMembersResultEvent;

		public event PlayFabRequestEvent<AddUsernamePasswordRequest> OnAddUsernamePasswordRequestEvent;

		public event PlayFabResultEvent<AddUsernamePasswordResult> OnAddUsernamePasswordResultEvent;

		public event PlayFabRequestEvent<AddUserVirtualCurrencyRequest> OnAddUserVirtualCurrencyRequestEvent;

		public event PlayFabResultEvent<ModifyUserVirtualCurrencyResult> OnAddUserVirtualCurrencyResultEvent;

		public event PlayFabRequestEvent<AndroidDevicePushNotificationRegistrationRequest> OnAndroidDevicePushNotificationRegistrationRequestEvent;

		public event PlayFabResultEvent<AndroidDevicePushNotificationRegistrationResult> OnAndroidDevicePushNotificationRegistrationResultEvent;

		public event PlayFabRequestEvent<AttributeInstallRequest> OnAttributeInstallRequestEvent;

		public event PlayFabResultEvent<AttributeInstallResult> OnAttributeInstallResultEvent;

		public event PlayFabRequestEvent<CancelTradeRequest> OnCancelTradeRequestEvent;

		public event PlayFabResultEvent<CancelTradeResponse> OnCancelTradeResultEvent;

		public event PlayFabRequestEvent<ConfirmPurchaseRequest> OnConfirmPurchaseRequestEvent;

		public event PlayFabResultEvent<ConfirmPurchaseResult> OnConfirmPurchaseResultEvent;

		public event PlayFabRequestEvent<ConsumeItemRequest> OnConsumeItemRequestEvent;

		public event PlayFabResultEvent<ConsumeItemResult> OnConsumeItemResultEvent;

		public event PlayFabRequestEvent<ConsumePSNEntitlementsRequest> OnConsumePSNEntitlementsRequestEvent;

		public event PlayFabResultEvent<ConsumePSNEntitlementsResult> OnConsumePSNEntitlementsResultEvent;

		public event PlayFabRequestEvent<ConsumeXboxEntitlementsRequest> OnConsumeXboxEntitlementsRequestEvent;

		public event PlayFabResultEvent<ConsumeXboxEntitlementsResult> OnConsumeXboxEntitlementsResultEvent;

		public event PlayFabRequestEvent<CreateSharedGroupRequest> OnCreateSharedGroupRequestEvent;

		public event PlayFabResultEvent<CreateSharedGroupResult> OnCreateSharedGroupResultEvent;

		public event PlayFabRequestEvent<ExecuteCloudScriptRequest> OnExecuteCloudScriptRequestEvent;

		public event PlayFabResultEvent<PlayFab.ClientModels.ExecuteCloudScriptResult> OnExecuteCloudScriptResultEvent;

		public event PlayFabRequestEvent<GetAccountInfoRequest> OnGetAccountInfoRequestEvent;

		public event PlayFabResultEvent<GetAccountInfoResult> OnGetAccountInfoResultEvent;

		public event PlayFabRequestEvent<ListUsersCharactersRequest> OnGetAllUsersCharactersRequestEvent;

		public event PlayFabResultEvent<ListUsersCharactersResult> OnGetAllUsersCharactersResultEvent;

		public event PlayFabRequestEvent<GetCatalogItemsRequest> OnGetCatalogItemsRequestEvent;

		public event PlayFabResultEvent<GetCatalogItemsResult> OnGetCatalogItemsResultEvent;

		public event PlayFabRequestEvent<GetCharacterDataRequest> OnGetCharacterDataRequestEvent;

		public event PlayFabResultEvent<GetCharacterDataResult> OnGetCharacterDataResultEvent;

		public event PlayFabRequestEvent<GetCharacterInventoryRequest> OnGetCharacterInventoryRequestEvent;

		public event PlayFabResultEvent<GetCharacterInventoryResult> OnGetCharacterInventoryResultEvent;

		public event PlayFabRequestEvent<GetCharacterLeaderboardRequest> OnGetCharacterLeaderboardRequestEvent;

		public event PlayFabResultEvent<GetCharacterLeaderboardResult> OnGetCharacterLeaderboardResultEvent;

		public event PlayFabRequestEvent<GetCharacterDataRequest> OnGetCharacterReadOnlyDataRequestEvent;

		public event PlayFabResultEvent<GetCharacterDataResult> OnGetCharacterReadOnlyDataResultEvent;

		public event PlayFabRequestEvent<GetCharacterStatisticsRequest> OnGetCharacterStatisticsRequestEvent;

		public event PlayFabResultEvent<GetCharacterStatisticsResult> OnGetCharacterStatisticsResultEvent;

		public event PlayFabRequestEvent<GetContentDownloadUrlRequest> OnGetContentDownloadUrlRequestEvent;

		public event PlayFabResultEvent<GetContentDownloadUrlResult> OnGetContentDownloadUrlResultEvent;

		public event PlayFabRequestEvent<CurrentGamesRequest> OnGetCurrentGamesRequestEvent;

		public event PlayFabResultEvent<CurrentGamesResult> OnGetCurrentGamesResultEvent;

		public event PlayFabRequestEvent<GetFriendLeaderboardRequest> OnGetFriendLeaderboardRequestEvent;

		public event PlayFabResultEvent<GetLeaderboardResult> OnGetFriendLeaderboardResultEvent;

		public event PlayFabRequestEvent<GetFriendLeaderboardAroundPlayerRequest> OnGetFriendLeaderboardAroundPlayerRequestEvent;

		public event PlayFabResultEvent<GetFriendLeaderboardAroundPlayerResult> OnGetFriendLeaderboardAroundPlayerResultEvent;

		public event PlayFabRequestEvent<GetFriendsListRequest> OnGetFriendsListRequestEvent;

		public event PlayFabResultEvent<GetFriendsListResult> OnGetFriendsListResultEvent;

		public event PlayFabRequestEvent<GameServerRegionsRequest> OnGetGameServerRegionsRequestEvent;

		public event PlayFabResultEvent<GameServerRegionsResult> OnGetGameServerRegionsResultEvent;

		public event PlayFabRequestEvent<GetLeaderboardRequest> OnGetLeaderboardRequestEvent;

		public event PlayFabResultEvent<GetLeaderboardResult> OnGetLeaderboardResultEvent;

		public event PlayFabRequestEvent<GetLeaderboardAroundCharacterRequest> OnGetLeaderboardAroundCharacterRequestEvent;

		public event PlayFabResultEvent<GetLeaderboardAroundCharacterResult> OnGetLeaderboardAroundCharacterResultEvent;

		public event PlayFabRequestEvent<GetLeaderboardAroundPlayerRequest> OnGetLeaderboardAroundPlayerRequestEvent;

		public event PlayFabResultEvent<GetLeaderboardAroundPlayerResult> OnGetLeaderboardAroundPlayerResultEvent;

		public event PlayFabRequestEvent<GetLeaderboardForUsersCharactersRequest> OnGetLeaderboardForUserCharactersRequestEvent;

		public event PlayFabResultEvent<GetLeaderboardForUsersCharactersResult> OnGetLeaderboardForUserCharactersResultEvent;

		public event PlayFabRequestEvent<GetPaymentTokenRequest> OnGetPaymentTokenRequestEvent;

		public event PlayFabResultEvent<GetPaymentTokenResult> OnGetPaymentTokenResultEvent;

		public event PlayFabRequestEvent<GetPhotonAuthenticationTokenRequest> OnGetPhotonAuthenticationTokenRequestEvent;

		public event PlayFabResultEvent<GetPhotonAuthenticationTokenResult> OnGetPhotonAuthenticationTokenResultEvent;

		public event PlayFabRequestEvent<GetPlayerCombinedInfoRequest> OnGetPlayerCombinedInfoRequestEvent;

		public event PlayFabResultEvent<GetPlayerCombinedInfoResult> OnGetPlayerCombinedInfoResultEvent;

		public event PlayFabRequestEvent<GetPlayerProfileRequest> OnGetPlayerProfileRequestEvent;

		public event PlayFabResultEvent<GetPlayerProfileResult> OnGetPlayerProfileResultEvent;

		public event PlayFabRequestEvent<GetPlayerSegmentsRequest> OnGetPlayerSegmentsRequestEvent;

		public event PlayFabResultEvent<GetPlayerSegmentsResult> OnGetPlayerSegmentsResultEvent;

		public event PlayFabRequestEvent<GetPlayerStatisticsRequest> OnGetPlayerStatisticsRequestEvent;

		public event PlayFabResultEvent<GetPlayerStatisticsResult> OnGetPlayerStatisticsResultEvent;

		public event PlayFabRequestEvent<GetPlayerStatisticVersionsRequest> OnGetPlayerStatisticVersionsRequestEvent;

		public event PlayFabResultEvent<GetPlayerStatisticVersionsResult> OnGetPlayerStatisticVersionsResultEvent;

		public event PlayFabRequestEvent<GetPlayerTagsRequest> OnGetPlayerTagsRequestEvent;

		public event PlayFabResultEvent<GetPlayerTagsResult> OnGetPlayerTagsResultEvent;

		public event PlayFabRequestEvent<GetPlayerTradesRequest> OnGetPlayerTradesRequestEvent;

		public event PlayFabResultEvent<GetPlayerTradesResponse> OnGetPlayerTradesResultEvent;

		public event PlayFabRequestEvent<GetPlayFabIDsFromFacebookIDsRequest> OnGetPlayFabIDsFromFacebookIDsRequestEvent;

		public event PlayFabResultEvent<GetPlayFabIDsFromFacebookIDsResult> OnGetPlayFabIDsFromFacebookIDsResultEvent;

		public event PlayFabRequestEvent<GetPlayFabIDsFromFacebookInstantGamesIdsRequest> OnGetPlayFabIDsFromFacebookInstantGamesIdsRequestEvent;

		public event PlayFabResultEvent<GetPlayFabIDsFromFacebookInstantGamesIdsResult> OnGetPlayFabIDsFromFacebookInstantGamesIdsResultEvent;

		public event PlayFabRequestEvent<GetPlayFabIDsFromGameCenterIDsRequest> OnGetPlayFabIDsFromGameCenterIDsRequestEvent;

		public event PlayFabResultEvent<GetPlayFabIDsFromGameCenterIDsResult> OnGetPlayFabIDsFromGameCenterIDsResultEvent;

		public event PlayFabRequestEvent<GetPlayFabIDsFromGenericIDsRequest> OnGetPlayFabIDsFromGenericIDsRequestEvent;

		public event PlayFabResultEvent<GetPlayFabIDsFromGenericIDsResult> OnGetPlayFabIDsFromGenericIDsResultEvent;

		public event PlayFabRequestEvent<GetPlayFabIDsFromGoogleIDsRequest> OnGetPlayFabIDsFromGoogleIDsRequestEvent;

		public event PlayFabResultEvent<GetPlayFabIDsFromGoogleIDsResult> OnGetPlayFabIDsFromGoogleIDsResultEvent;

		public event PlayFabRequestEvent<GetPlayFabIDsFromKongregateIDsRequest> OnGetPlayFabIDsFromKongregateIDsRequestEvent;

		public event PlayFabResultEvent<GetPlayFabIDsFromKongregateIDsResult> OnGetPlayFabIDsFromKongregateIDsResultEvent;

		public event PlayFabRequestEvent<GetPlayFabIDsFromNintendoSwitchDeviceIdsRequest> OnGetPlayFabIDsFromNintendoSwitchDeviceIdsRequestEvent;

		public event PlayFabResultEvent<GetPlayFabIDsFromNintendoSwitchDeviceIdsResult> OnGetPlayFabIDsFromNintendoSwitchDeviceIdsResultEvent;

		public event PlayFabRequestEvent<GetPlayFabIDsFromPSNAccountIDsRequest> OnGetPlayFabIDsFromPSNAccountIDsRequestEvent;

		public event PlayFabResultEvent<GetPlayFabIDsFromPSNAccountIDsResult> OnGetPlayFabIDsFromPSNAccountIDsResultEvent;

		public event PlayFabRequestEvent<GetPlayFabIDsFromSteamIDsRequest> OnGetPlayFabIDsFromSteamIDsRequestEvent;

		public event PlayFabResultEvent<GetPlayFabIDsFromSteamIDsResult> OnGetPlayFabIDsFromSteamIDsResultEvent;

		public event PlayFabRequestEvent<GetPlayFabIDsFromTwitchIDsRequest> OnGetPlayFabIDsFromTwitchIDsRequestEvent;

		public event PlayFabResultEvent<GetPlayFabIDsFromTwitchIDsResult> OnGetPlayFabIDsFromTwitchIDsResultEvent;

		public event PlayFabRequestEvent<GetPlayFabIDsFromXboxLiveIDsRequest> OnGetPlayFabIDsFromXboxLiveIDsRequestEvent;

		public event PlayFabResultEvent<GetPlayFabIDsFromXboxLiveIDsResult> OnGetPlayFabIDsFromXboxLiveIDsResultEvent;

		public event PlayFabRequestEvent<GetPublisherDataRequest> OnGetPublisherDataRequestEvent;

		public event PlayFabResultEvent<GetPublisherDataResult> OnGetPublisherDataResultEvent;

		public event PlayFabRequestEvent<GetPurchaseRequest> OnGetPurchaseRequestEvent;

		public event PlayFabResultEvent<GetPurchaseResult> OnGetPurchaseResultEvent;

		public event PlayFabRequestEvent<GetSharedGroupDataRequest> OnGetSharedGroupDataRequestEvent;

		public event PlayFabResultEvent<GetSharedGroupDataResult> OnGetSharedGroupDataResultEvent;

		public event PlayFabRequestEvent<GetStoreItemsRequest> OnGetStoreItemsRequestEvent;

		public event PlayFabResultEvent<GetStoreItemsResult> OnGetStoreItemsResultEvent;

		public event PlayFabRequestEvent<GetTimeRequest> OnGetTimeRequestEvent;

		public event PlayFabResultEvent<GetTimeResult> OnGetTimeResultEvent;

		public event PlayFabRequestEvent<GetTitleDataRequest> OnGetTitleDataRequestEvent;

		public event PlayFabResultEvent<GetTitleDataResult> OnGetTitleDataResultEvent;

		public event PlayFabRequestEvent<GetTitleNewsRequest> OnGetTitleNewsRequestEvent;

		public event PlayFabResultEvent<GetTitleNewsResult> OnGetTitleNewsResultEvent;

		public event PlayFabRequestEvent<GetTitlePublicKeyRequest> OnGetTitlePublicKeyRequestEvent;

		public event PlayFabResultEvent<GetTitlePublicKeyResult> OnGetTitlePublicKeyResultEvent;

		public event PlayFabRequestEvent<GetTradeStatusRequest> OnGetTradeStatusRequestEvent;

		public event PlayFabResultEvent<GetTradeStatusResponse> OnGetTradeStatusResultEvent;

		public event PlayFabRequestEvent<GetUserDataRequest> OnGetUserDataRequestEvent;

		public event PlayFabResultEvent<GetUserDataResult> OnGetUserDataResultEvent;

		public event PlayFabRequestEvent<GetUserInventoryRequest> OnGetUserInventoryRequestEvent;

		public event PlayFabResultEvent<GetUserInventoryResult> OnGetUserInventoryResultEvent;

		public event PlayFabRequestEvent<GetUserDataRequest> OnGetUserPublisherDataRequestEvent;

		public event PlayFabResultEvent<GetUserDataResult> OnGetUserPublisherDataResultEvent;

		public event PlayFabRequestEvent<GetUserDataRequest> OnGetUserPublisherReadOnlyDataRequestEvent;

		public event PlayFabResultEvent<GetUserDataResult> OnGetUserPublisherReadOnlyDataResultEvent;

		public event PlayFabRequestEvent<GetUserDataRequest> OnGetUserReadOnlyDataRequestEvent;

		public event PlayFabResultEvent<GetUserDataResult> OnGetUserReadOnlyDataResultEvent;

		public event PlayFabRequestEvent<GetWindowsHelloChallengeRequest> OnGetWindowsHelloChallengeRequestEvent;

		public event PlayFabResultEvent<GetWindowsHelloChallengeResponse> OnGetWindowsHelloChallengeResultEvent;

		public event PlayFabRequestEvent<GrantCharacterToUserRequest> OnGrantCharacterToUserRequestEvent;

		public event PlayFabResultEvent<GrantCharacterToUserResult> OnGrantCharacterToUserResultEvent;

		public event PlayFabRequestEvent<LinkAndroidDeviceIDRequest> OnLinkAndroidDeviceIDRequestEvent;

		public event PlayFabResultEvent<LinkAndroidDeviceIDResult> OnLinkAndroidDeviceIDResultEvent;

		public event PlayFabRequestEvent<LinkCustomIDRequest> OnLinkCustomIDRequestEvent;

		public event PlayFabResultEvent<LinkCustomIDResult> OnLinkCustomIDResultEvent;

		public event PlayFabRequestEvent<LinkFacebookAccountRequest> OnLinkFacebookAccountRequestEvent;

		public event PlayFabResultEvent<LinkFacebookAccountResult> OnLinkFacebookAccountResultEvent;

		public event PlayFabRequestEvent<LinkFacebookInstantGamesIdRequest> OnLinkFacebookInstantGamesIdRequestEvent;

		public event PlayFabResultEvent<LinkFacebookInstantGamesIdResult> OnLinkFacebookInstantGamesIdResultEvent;

		public event PlayFabRequestEvent<LinkGameCenterAccountRequest> OnLinkGameCenterAccountRequestEvent;

		public event PlayFabResultEvent<LinkGameCenterAccountResult> OnLinkGameCenterAccountResultEvent;

		public event PlayFabRequestEvent<LinkGoogleAccountRequest> OnLinkGoogleAccountRequestEvent;

		public event PlayFabResultEvent<LinkGoogleAccountResult> OnLinkGoogleAccountResultEvent;

		public event PlayFabRequestEvent<LinkIOSDeviceIDRequest> OnLinkIOSDeviceIDRequestEvent;

		public event PlayFabResultEvent<LinkIOSDeviceIDResult> OnLinkIOSDeviceIDResultEvent;

		public event PlayFabRequestEvent<LinkKongregateAccountRequest> OnLinkKongregateRequestEvent;

		public event PlayFabResultEvent<LinkKongregateAccountResult> OnLinkKongregateResultEvent;

		public event PlayFabRequestEvent<LinkNintendoSwitchDeviceIdRequest> OnLinkNintendoSwitchDeviceIdRequestEvent;

		public event PlayFabResultEvent<LinkNintendoSwitchDeviceIdResult> OnLinkNintendoSwitchDeviceIdResultEvent;

		public event PlayFabRequestEvent<LinkOpenIdConnectRequest> OnLinkOpenIdConnectRequestEvent;

		public event PlayFabResultEvent<EmptyResult> OnLinkOpenIdConnectResultEvent;

		public event PlayFabRequestEvent<LinkPSNAccountRequest> OnLinkPSNAccountRequestEvent;

		public event PlayFabResultEvent<LinkPSNAccountResult> OnLinkPSNAccountResultEvent;

		public event PlayFabRequestEvent<LinkSteamAccountRequest> OnLinkSteamAccountRequestEvent;

		public event PlayFabResultEvent<LinkSteamAccountResult> OnLinkSteamAccountResultEvent;

		public event PlayFabRequestEvent<LinkTwitchAccountRequest> OnLinkTwitchRequestEvent;

		public event PlayFabResultEvent<LinkTwitchAccountResult> OnLinkTwitchResultEvent;

		public event PlayFabRequestEvent<LinkWindowsHelloAccountRequest> OnLinkWindowsHelloRequestEvent;

		public event PlayFabResultEvent<LinkWindowsHelloAccountResponse> OnLinkWindowsHelloResultEvent;

		public event PlayFabRequestEvent<LinkXboxAccountRequest> OnLinkXboxAccountRequestEvent;

		public event PlayFabResultEvent<LinkXboxAccountResult> OnLinkXboxAccountResultEvent;

		public event PlayFabRequestEvent<LoginWithAndroidDeviceIDRequest> OnLoginWithAndroidDeviceIDRequestEvent;

		public event PlayFabRequestEvent<LoginWithCustomIDRequest> OnLoginWithCustomIDRequestEvent;

		public event PlayFabRequestEvent<LoginWithEmailAddressRequest> OnLoginWithEmailAddressRequestEvent;

		public event PlayFabRequestEvent<LoginWithFacebookRequest> OnLoginWithFacebookRequestEvent;

		public event PlayFabRequestEvent<LoginWithFacebookInstantGamesIdRequest> OnLoginWithFacebookInstantGamesIdRequestEvent;

		public event PlayFabRequestEvent<LoginWithGameCenterRequest> OnLoginWithGameCenterRequestEvent;

		public event PlayFabRequestEvent<LoginWithGoogleAccountRequest> OnLoginWithGoogleAccountRequestEvent;

		public event PlayFabRequestEvent<LoginWithIOSDeviceIDRequest> OnLoginWithIOSDeviceIDRequestEvent;

		public event PlayFabRequestEvent<LoginWithKongregateRequest> OnLoginWithKongregateRequestEvent;

		public event PlayFabRequestEvent<LoginWithNintendoSwitchDeviceIdRequest> OnLoginWithNintendoSwitchDeviceIdRequestEvent;

		public event PlayFabRequestEvent<LoginWithOpenIdConnectRequest> OnLoginWithOpenIdConnectRequestEvent;

		public event PlayFabRequestEvent<LoginWithPlayFabRequest> OnLoginWithPlayFabRequestEvent;

		public event PlayFabRequestEvent<LoginWithPSNRequest> OnLoginWithPSNRequestEvent;

		public event PlayFabRequestEvent<LoginWithSteamRequest> OnLoginWithSteamRequestEvent;

		public event PlayFabRequestEvent<LoginWithTwitchRequest> OnLoginWithTwitchRequestEvent;

		public event PlayFabRequestEvent<LoginWithWindowsHelloRequest> OnLoginWithWindowsHelloRequestEvent;

		public event PlayFabRequestEvent<LoginWithXboxRequest> OnLoginWithXboxRequestEvent;

		public event PlayFabRequestEvent<MatchmakeRequest> OnMatchmakeRequestEvent;

		public event PlayFabResultEvent<MatchmakeResult> OnMatchmakeResultEvent;

		public event PlayFabRequestEvent<OpenTradeRequest> OnOpenTradeRequestEvent;

		public event PlayFabResultEvent<OpenTradeResponse> OnOpenTradeResultEvent;

		public event PlayFabRequestEvent<PayForPurchaseRequest> OnPayForPurchaseRequestEvent;

		public event PlayFabResultEvent<PayForPurchaseResult> OnPayForPurchaseResultEvent;

		public event PlayFabRequestEvent<PurchaseItemRequest> OnPurchaseItemRequestEvent;

		public event PlayFabResultEvent<PurchaseItemResult> OnPurchaseItemResultEvent;

		public event PlayFabRequestEvent<RedeemCouponRequest> OnRedeemCouponRequestEvent;

		public event PlayFabResultEvent<RedeemCouponResult> OnRedeemCouponResultEvent;

		public event PlayFabRequestEvent<RefreshPSNAuthTokenRequest> OnRefreshPSNAuthTokenRequestEvent;

		public event PlayFabResultEvent<PlayFab.ClientModels.EmptyResponse> OnRefreshPSNAuthTokenResultEvent;

		public event PlayFabRequestEvent<RegisterForIOSPushNotificationRequest> OnRegisterForIOSPushNotificationRequestEvent;

		public event PlayFabResultEvent<RegisterForIOSPushNotificationResult> OnRegisterForIOSPushNotificationResultEvent;

		public event PlayFabRequestEvent<RegisterPlayFabUserRequest> OnRegisterPlayFabUserRequestEvent;

		public event PlayFabResultEvent<RegisterPlayFabUserResult> OnRegisterPlayFabUserResultEvent;

		public event PlayFabRequestEvent<RegisterWithWindowsHelloRequest> OnRegisterWithWindowsHelloRequestEvent;

		public event PlayFabRequestEvent<RemoveContactEmailRequest> OnRemoveContactEmailRequestEvent;

		public event PlayFabResultEvent<RemoveContactEmailResult> OnRemoveContactEmailResultEvent;

		public event PlayFabRequestEvent<RemoveFriendRequest> OnRemoveFriendRequestEvent;

		public event PlayFabResultEvent<RemoveFriendResult> OnRemoveFriendResultEvent;

		public event PlayFabRequestEvent<RemoveGenericIDRequest> OnRemoveGenericIDRequestEvent;

		public event PlayFabResultEvent<RemoveGenericIDResult> OnRemoveGenericIDResultEvent;

		public event PlayFabRequestEvent<RemoveSharedGroupMembersRequest> OnRemoveSharedGroupMembersRequestEvent;

		public event PlayFabResultEvent<RemoveSharedGroupMembersResult> OnRemoveSharedGroupMembersResultEvent;

		public event PlayFabRequestEvent<DeviceInfoRequest> OnReportDeviceInfoRequestEvent;

		public event PlayFabResultEvent<PlayFab.ClientModels.EmptyResponse> OnReportDeviceInfoResultEvent;

		public event PlayFabRequestEvent<ReportPlayerClientRequest> OnReportPlayerRequestEvent;

		public event PlayFabResultEvent<ReportPlayerClientResult> OnReportPlayerResultEvent;

		public event PlayFabRequestEvent<RestoreIOSPurchasesRequest> OnRestoreIOSPurchasesRequestEvent;

		public event PlayFabResultEvent<RestoreIOSPurchasesResult> OnRestoreIOSPurchasesResultEvent;

		public event PlayFabRequestEvent<SendAccountRecoveryEmailRequest> OnSendAccountRecoveryEmailRequestEvent;

		public event PlayFabResultEvent<SendAccountRecoveryEmailResult> OnSendAccountRecoveryEmailResultEvent;

		public event PlayFabRequestEvent<SetFriendTagsRequest> OnSetFriendTagsRequestEvent;

		public event PlayFabResultEvent<SetFriendTagsResult> OnSetFriendTagsResultEvent;

		public event PlayFabRequestEvent<SetPlayerSecretRequest> OnSetPlayerSecretRequestEvent;

		public event PlayFabResultEvent<SetPlayerSecretResult> OnSetPlayerSecretResultEvent;

		public event PlayFabRequestEvent<StartGameRequest> OnStartGameRequestEvent;

		public event PlayFabResultEvent<StartGameResult> OnStartGameResultEvent;

		public event PlayFabRequestEvent<StartPurchaseRequest> OnStartPurchaseRequestEvent;

		public event PlayFabResultEvent<StartPurchaseResult> OnStartPurchaseResultEvent;

		public event PlayFabRequestEvent<SubtractUserVirtualCurrencyRequest> OnSubtractUserVirtualCurrencyRequestEvent;

		public event PlayFabResultEvent<ModifyUserVirtualCurrencyResult> OnSubtractUserVirtualCurrencyResultEvent;

		public event PlayFabRequestEvent<UnlinkAndroidDeviceIDRequest> OnUnlinkAndroidDeviceIDRequestEvent;

		public event PlayFabResultEvent<UnlinkAndroidDeviceIDResult> OnUnlinkAndroidDeviceIDResultEvent;

		public event PlayFabRequestEvent<UnlinkCustomIDRequest> OnUnlinkCustomIDRequestEvent;

		public event PlayFabResultEvent<UnlinkCustomIDResult> OnUnlinkCustomIDResultEvent;

		public event PlayFabRequestEvent<UnlinkFacebookAccountRequest> OnUnlinkFacebookAccountRequestEvent;

		public event PlayFabResultEvent<UnlinkFacebookAccountResult> OnUnlinkFacebookAccountResultEvent;

		public event PlayFabRequestEvent<UnlinkFacebookInstantGamesIdRequest> OnUnlinkFacebookInstantGamesIdRequestEvent;

		public event PlayFabResultEvent<UnlinkFacebookInstantGamesIdResult> OnUnlinkFacebookInstantGamesIdResultEvent;

		public event PlayFabRequestEvent<UnlinkGameCenterAccountRequest> OnUnlinkGameCenterAccountRequestEvent;

		public event PlayFabResultEvent<UnlinkGameCenterAccountResult> OnUnlinkGameCenterAccountResultEvent;

		public event PlayFabRequestEvent<UnlinkGoogleAccountRequest> OnUnlinkGoogleAccountRequestEvent;

		public event PlayFabResultEvent<UnlinkGoogleAccountResult> OnUnlinkGoogleAccountResultEvent;

		public event PlayFabRequestEvent<UnlinkIOSDeviceIDRequest> OnUnlinkIOSDeviceIDRequestEvent;

		public event PlayFabResultEvent<UnlinkIOSDeviceIDResult> OnUnlinkIOSDeviceIDResultEvent;

		public event PlayFabRequestEvent<UnlinkKongregateAccountRequest> OnUnlinkKongregateRequestEvent;

		public event PlayFabResultEvent<UnlinkKongregateAccountResult> OnUnlinkKongregateResultEvent;

		public event PlayFabRequestEvent<UnlinkNintendoSwitchDeviceIdRequest> OnUnlinkNintendoSwitchDeviceIdRequestEvent;

		public event PlayFabResultEvent<UnlinkNintendoSwitchDeviceIdResult> OnUnlinkNintendoSwitchDeviceIdResultEvent;

		public event PlayFabRequestEvent<UninkOpenIdConnectRequest> OnUnlinkOpenIdConnectRequestEvent;

		public event PlayFabResultEvent<PlayFab.ClientModels.EmptyResponse> OnUnlinkOpenIdConnectResultEvent;

		public event PlayFabRequestEvent<UnlinkPSNAccountRequest> OnUnlinkPSNAccountRequestEvent;

		public event PlayFabResultEvent<UnlinkPSNAccountResult> OnUnlinkPSNAccountResultEvent;

		public event PlayFabRequestEvent<UnlinkSteamAccountRequest> OnUnlinkSteamAccountRequestEvent;

		public event PlayFabResultEvent<UnlinkSteamAccountResult> OnUnlinkSteamAccountResultEvent;

		public event PlayFabRequestEvent<UnlinkTwitchAccountRequest> OnUnlinkTwitchRequestEvent;

		public event PlayFabResultEvent<UnlinkTwitchAccountResult> OnUnlinkTwitchResultEvent;

		public event PlayFabRequestEvent<UnlinkWindowsHelloAccountRequest> OnUnlinkWindowsHelloRequestEvent;

		public event PlayFabResultEvent<UnlinkWindowsHelloAccountResponse> OnUnlinkWindowsHelloResultEvent;

		public event PlayFabRequestEvent<UnlinkXboxAccountRequest> OnUnlinkXboxAccountRequestEvent;

		public event PlayFabResultEvent<UnlinkXboxAccountResult> OnUnlinkXboxAccountResultEvent;

		public event PlayFabRequestEvent<UnlockContainerInstanceRequest> OnUnlockContainerInstanceRequestEvent;

		public event PlayFabResultEvent<UnlockContainerItemResult> OnUnlockContainerInstanceResultEvent;

		public event PlayFabRequestEvent<UnlockContainerItemRequest> OnUnlockContainerItemRequestEvent;

		public event PlayFabResultEvent<UnlockContainerItemResult> OnUnlockContainerItemResultEvent;

		public event PlayFabRequestEvent<UpdateAvatarUrlRequest> OnUpdateAvatarUrlRequestEvent;

		public event PlayFabResultEvent<PlayFab.ClientModels.EmptyResponse> OnUpdateAvatarUrlResultEvent;

		public event PlayFabRequestEvent<UpdateCharacterDataRequest> OnUpdateCharacterDataRequestEvent;

		public event PlayFabResultEvent<UpdateCharacterDataResult> OnUpdateCharacterDataResultEvent;

		public event PlayFabRequestEvent<UpdateCharacterStatisticsRequest> OnUpdateCharacterStatisticsRequestEvent;

		public event PlayFabResultEvent<UpdateCharacterStatisticsResult> OnUpdateCharacterStatisticsResultEvent;

		public event PlayFabRequestEvent<UpdatePlayerStatisticsRequest> OnUpdatePlayerStatisticsRequestEvent;

		public event PlayFabResultEvent<UpdatePlayerStatisticsResult> OnUpdatePlayerStatisticsResultEvent;

		public event PlayFabRequestEvent<UpdateSharedGroupDataRequest> OnUpdateSharedGroupDataRequestEvent;

		public event PlayFabResultEvent<UpdateSharedGroupDataResult> OnUpdateSharedGroupDataResultEvent;

		public event PlayFabRequestEvent<UpdateUserDataRequest> OnUpdateUserDataRequestEvent;

		public event PlayFabResultEvent<UpdateUserDataResult> OnUpdateUserDataResultEvent;

		public event PlayFabRequestEvent<UpdateUserDataRequest> OnUpdateUserPublisherDataRequestEvent;

		public event PlayFabResultEvent<UpdateUserDataResult> OnUpdateUserPublisherDataResultEvent;

		public event PlayFabRequestEvent<UpdateUserTitleDisplayNameRequest> OnUpdateUserTitleDisplayNameRequestEvent;

		public event PlayFabResultEvent<UpdateUserTitleDisplayNameResult> OnUpdateUserTitleDisplayNameResultEvent;

		public event PlayFabRequestEvent<ValidateAmazonReceiptRequest> OnValidateAmazonIAPReceiptRequestEvent;

		public event PlayFabResultEvent<ValidateAmazonReceiptResult> OnValidateAmazonIAPReceiptResultEvent;

		public event PlayFabRequestEvent<ValidateGooglePlayPurchaseRequest> OnValidateGooglePlayPurchaseRequestEvent;

		public event PlayFabResultEvent<ValidateGooglePlayPurchaseResult> OnValidateGooglePlayPurchaseResultEvent;

		public event PlayFabRequestEvent<ValidateIOSReceiptRequest> OnValidateIOSReceiptRequestEvent;

		public event PlayFabResultEvent<ValidateIOSReceiptResult> OnValidateIOSReceiptResultEvent;

		public event PlayFabRequestEvent<ValidateWindowsReceiptRequest> OnValidateWindowsStoreReceiptRequestEvent;

		public event PlayFabResultEvent<ValidateWindowsReceiptResult> OnValidateWindowsStoreReceiptResultEvent;

		public event PlayFabRequestEvent<WriteClientCharacterEventRequest> OnWriteCharacterEventRequestEvent;

		public event PlayFabResultEvent<WriteEventResponse> OnWriteCharacterEventResultEvent;

		public event PlayFabRequestEvent<WriteClientPlayerEventRequest> OnWritePlayerEventRequestEvent;

		public event PlayFabResultEvent<WriteEventResponse> OnWritePlayerEventResultEvent;

		public event PlayFabRequestEvent<WriteTitleEventRequest> OnWriteTitleEventRequestEvent;

		public event PlayFabResultEvent<WriteEventResponse> OnWriteTitleEventResultEvent;

		public event PlayFabRequestEvent<ExecuteEntityCloudScriptRequest> OnCloudScriptExecuteEntityCloudScriptRequestEvent;

		public event PlayFabResultEvent<PlayFab.CloudScriptModels.ExecuteCloudScriptResult> OnCloudScriptExecuteEntityCloudScriptResultEvent;

		public event PlayFabRequestEvent<AbortFileUploadsRequest> OnDataAbortFileUploadsRequestEvent;

		public event PlayFabResultEvent<AbortFileUploadsResponse> OnDataAbortFileUploadsResultEvent;

		public event PlayFabRequestEvent<DeleteFilesRequest> OnDataDeleteFilesRequestEvent;

		public event PlayFabResultEvent<DeleteFilesResponse> OnDataDeleteFilesResultEvent;

		public event PlayFabRequestEvent<FinalizeFileUploadsRequest> OnDataFinalizeFileUploadsRequestEvent;

		public event PlayFabResultEvent<FinalizeFileUploadsResponse> OnDataFinalizeFileUploadsResultEvent;

		public event PlayFabRequestEvent<GetFilesRequest> OnDataGetFilesRequestEvent;

		public event PlayFabResultEvent<GetFilesResponse> OnDataGetFilesResultEvent;

		public event PlayFabRequestEvent<GetObjectsRequest> OnDataGetObjectsRequestEvent;

		public event PlayFabResultEvent<GetObjectsResponse> OnDataGetObjectsResultEvent;

		public event PlayFabRequestEvent<InitiateFileUploadsRequest> OnDataInitiateFileUploadsRequestEvent;

		public event PlayFabResultEvent<InitiateFileUploadsResponse> OnDataInitiateFileUploadsResultEvent;

		public event PlayFabRequestEvent<SetObjectsRequest> OnDataSetObjectsRequestEvent;

		public event PlayFabResultEvent<SetObjectsResponse> OnDataSetObjectsResultEvent;

		public event PlayFabRequestEvent<WriteEventsRequest> OnEventsWriteEventsRequestEvent;

		public event PlayFabResultEvent<WriteEventsResponse> OnEventsWriteEventsResultEvent;

		public event PlayFabRequestEvent<WriteEventsRequest> OnEventsWriteTelemetryEventsRequestEvent;

		public event PlayFabResultEvent<WriteEventsResponse> OnEventsWriteTelemetryEventsResultEvent;

		public event PlayFabRequestEvent<AcceptGroupApplicationRequest> OnGroupsAcceptGroupApplicationRequestEvent;

		public event PlayFabResultEvent<PlayFab.GroupsModels.EmptyResponse> OnGroupsAcceptGroupApplicationResultEvent;

		public event PlayFabRequestEvent<AcceptGroupInvitationRequest> OnGroupsAcceptGroupInvitationRequestEvent;

		public event PlayFabResultEvent<PlayFab.GroupsModels.EmptyResponse> OnGroupsAcceptGroupInvitationResultEvent;

		public event PlayFabRequestEvent<AddMembersRequest> OnGroupsAddMembersRequestEvent;

		public event PlayFabResultEvent<PlayFab.GroupsModels.EmptyResponse> OnGroupsAddMembersResultEvent;

		public event PlayFabRequestEvent<ApplyToGroupRequest> OnGroupsApplyToGroupRequestEvent;

		public event PlayFabResultEvent<ApplyToGroupResponse> OnGroupsApplyToGroupResultEvent;

		public event PlayFabRequestEvent<BlockEntityRequest> OnGroupsBlockEntityRequestEvent;

		public event PlayFabResultEvent<PlayFab.GroupsModels.EmptyResponse> OnGroupsBlockEntityResultEvent;

		public event PlayFabRequestEvent<ChangeMemberRoleRequest> OnGroupsChangeMemberRoleRequestEvent;

		public event PlayFabResultEvent<PlayFab.GroupsModels.EmptyResponse> OnGroupsChangeMemberRoleResultEvent;

		public event PlayFabRequestEvent<CreateGroupRequest> OnGroupsCreateGroupRequestEvent;

		public event PlayFabResultEvent<CreateGroupResponse> OnGroupsCreateGroupResultEvent;

		public event PlayFabRequestEvent<CreateGroupRoleRequest> OnGroupsCreateRoleRequestEvent;

		public event PlayFabResultEvent<CreateGroupRoleResponse> OnGroupsCreateRoleResultEvent;

		public event PlayFabRequestEvent<DeleteGroupRequest> OnGroupsDeleteGroupRequestEvent;

		public event PlayFabResultEvent<PlayFab.GroupsModels.EmptyResponse> OnGroupsDeleteGroupResultEvent;

		public event PlayFabRequestEvent<DeleteRoleRequest> OnGroupsDeleteRoleRequestEvent;

		public event PlayFabResultEvent<PlayFab.GroupsModels.EmptyResponse> OnGroupsDeleteRoleResultEvent;

		public event PlayFabRequestEvent<GetGroupRequest> OnGroupsGetGroupRequestEvent;

		public event PlayFabResultEvent<GetGroupResponse> OnGroupsGetGroupResultEvent;

		public event PlayFabRequestEvent<InviteToGroupRequest> OnGroupsInviteToGroupRequestEvent;

		public event PlayFabResultEvent<InviteToGroupResponse> OnGroupsInviteToGroupResultEvent;

		public event PlayFabRequestEvent<IsMemberRequest> OnGroupsIsMemberRequestEvent;

		public event PlayFabResultEvent<IsMemberResponse> OnGroupsIsMemberResultEvent;

		public event PlayFabRequestEvent<ListGroupApplicationsRequest> OnGroupsListGroupApplicationsRequestEvent;

		public event PlayFabResultEvent<ListGroupApplicationsResponse> OnGroupsListGroupApplicationsResultEvent;

		public event PlayFabRequestEvent<ListGroupBlocksRequest> OnGroupsListGroupBlocksRequestEvent;

		public event PlayFabResultEvent<ListGroupBlocksResponse> OnGroupsListGroupBlocksResultEvent;

		public event PlayFabRequestEvent<ListGroupInvitationsRequest> OnGroupsListGroupInvitationsRequestEvent;

		public event PlayFabResultEvent<ListGroupInvitationsResponse> OnGroupsListGroupInvitationsResultEvent;

		public event PlayFabRequestEvent<ListGroupMembersRequest> OnGroupsListGroupMembersRequestEvent;

		public event PlayFabResultEvent<ListGroupMembersResponse> OnGroupsListGroupMembersResultEvent;

		public event PlayFabRequestEvent<ListMembershipRequest> OnGroupsListMembershipRequestEvent;

		public event PlayFabResultEvent<ListMembershipResponse> OnGroupsListMembershipResultEvent;

		public event PlayFabRequestEvent<ListMembershipOpportunitiesRequest> OnGroupsListMembershipOpportunitiesRequestEvent;

		public event PlayFabResultEvent<ListMembershipOpportunitiesResponse> OnGroupsListMembershipOpportunitiesResultEvent;

		public event PlayFabRequestEvent<RemoveGroupApplicationRequest> OnGroupsRemoveGroupApplicationRequestEvent;

		public event PlayFabResultEvent<PlayFab.GroupsModels.EmptyResponse> OnGroupsRemoveGroupApplicationResultEvent;

		public event PlayFabRequestEvent<RemoveGroupInvitationRequest> OnGroupsRemoveGroupInvitationRequestEvent;

		public event PlayFabResultEvent<PlayFab.GroupsModels.EmptyResponse> OnGroupsRemoveGroupInvitationResultEvent;

		public event PlayFabRequestEvent<RemoveMembersRequest> OnGroupsRemoveMembersRequestEvent;

		public event PlayFabResultEvent<PlayFab.GroupsModels.EmptyResponse> OnGroupsRemoveMembersResultEvent;

		public event PlayFabRequestEvent<UnblockEntityRequest> OnGroupsUnblockEntityRequestEvent;

		public event PlayFabResultEvent<PlayFab.GroupsModels.EmptyResponse> OnGroupsUnblockEntityResultEvent;

		public event PlayFabRequestEvent<UpdateGroupRequest> OnGroupsUpdateGroupRequestEvent;

		public event PlayFabResultEvent<UpdateGroupResponse> OnGroupsUpdateGroupResultEvent;

		public event PlayFabRequestEvent<UpdateGroupRoleRequest> OnGroupsUpdateRoleRequestEvent;

		public event PlayFabResultEvent<UpdateGroupRoleResponse> OnGroupsUpdateRoleResultEvent;

		public event PlayFabRequestEvent<GetLanguageListRequest> OnLocalizationGetLanguageListRequestEvent;

		public event PlayFabResultEvent<GetLanguageListResponse> OnLocalizationGetLanguageListResultEvent;

		public event PlayFabRequestEvent<CancelAllMatchmakingTicketsForPlayerRequest> OnMultiplayerCancelAllMatchmakingTicketsForPlayerRequestEvent;

		public event PlayFabResultEvent<CancelAllMatchmakingTicketsForPlayerResult> OnMultiplayerCancelAllMatchmakingTicketsForPlayerResultEvent;

		public event PlayFabRequestEvent<CancelMatchmakingTicketRequest> OnMultiplayerCancelMatchmakingTicketRequestEvent;

		public event PlayFabResultEvent<CancelMatchmakingTicketResult> OnMultiplayerCancelMatchmakingTicketResultEvent;

		public event PlayFabRequestEvent<CreateBuildWithCustomContainerRequest> OnMultiplayerCreateBuildWithCustomContainerRequestEvent;

		public event PlayFabResultEvent<CreateBuildWithCustomContainerResponse> OnMultiplayerCreateBuildWithCustomContainerResultEvent;

		public event PlayFabRequestEvent<CreateBuildWithManagedContainerRequest> OnMultiplayerCreateBuildWithManagedContainerRequestEvent;

		public event PlayFabResultEvent<CreateBuildWithManagedContainerResponse> OnMultiplayerCreateBuildWithManagedContainerResultEvent;

		public event PlayFabRequestEvent<CreateMatchmakingTicketRequest> OnMultiplayerCreateMatchmakingTicketRequestEvent;

		public event PlayFabResultEvent<CreateMatchmakingTicketResult> OnMultiplayerCreateMatchmakingTicketResultEvent;

		public event PlayFabRequestEvent<CreateRemoteUserRequest> OnMultiplayerCreateRemoteUserRequestEvent;

		public event PlayFabResultEvent<CreateRemoteUserResponse> OnMultiplayerCreateRemoteUserResultEvent;

		public event PlayFabRequestEvent<CreateServerMatchmakingTicketRequest> OnMultiplayerCreateServerMatchmakingTicketRequestEvent;

		public event PlayFabResultEvent<CreateMatchmakingTicketResult> OnMultiplayerCreateServerMatchmakingTicketResultEvent;

		public event PlayFabRequestEvent<DeleteAssetRequest> OnMultiplayerDeleteAssetRequestEvent;

		public event PlayFabResultEvent<PlayFab.MultiplayerModels.EmptyResponse> OnMultiplayerDeleteAssetResultEvent;

		public event PlayFabRequestEvent<DeleteBuildRequest> OnMultiplayerDeleteBuildRequestEvent;

		public event PlayFabResultEvent<PlayFab.MultiplayerModels.EmptyResponse> OnMultiplayerDeleteBuildResultEvent;

		public event PlayFabRequestEvent<DeleteCertificateRequest> OnMultiplayerDeleteCertificateRequestEvent;

		public event PlayFabResultEvent<PlayFab.MultiplayerModels.EmptyResponse> OnMultiplayerDeleteCertificateResultEvent;

		public event PlayFabRequestEvent<DeleteRemoteUserRequest> OnMultiplayerDeleteRemoteUserRequestEvent;

		public event PlayFabResultEvent<PlayFab.MultiplayerModels.EmptyResponse> OnMultiplayerDeleteRemoteUserResultEvent;

		public event PlayFabRequestEvent<EnableMultiplayerServersForTitleRequest> OnMultiplayerEnableMultiplayerServersForTitleRequestEvent;

		public event PlayFabResultEvent<EnableMultiplayerServersForTitleResponse> OnMultiplayerEnableMultiplayerServersForTitleResultEvent;

		public event PlayFabRequestEvent<GetAssetUploadUrlRequest> OnMultiplayerGetAssetUploadUrlRequestEvent;

		public event PlayFabResultEvent<GetAssetUploadUrlResponse> OnMultiplayerGetAssetUploadUrlResultEvent;

		public event PlayFabRequestEvent<GetBuildRequest> OnMultiplayerGetBuildRequestEvent;

		public event PlayFabResultEvent<GetBuildResponse> OnMultiplayerGetBuildResultEvent;

		public event PlayFabRequestEvent<GetContainerRegistryCredentialsRequest> OnMultiplayerGetContainerRegistryCredentialsRequestEvent;

		public event PlayFabResultEvent<GetContainerRegistryCredentialsResponse> OnMultiplayerGetContainerRegistryCredentialsResultEvent;

		public event PlayFabRequestEvent<GetMatchRequest> OnMultiplayerGetMatchRequestEvent;

		public event PlayFabResultEvent<GetMatchResult> OnMultiplayerGetMatchResultEvent;

		public event PlayFabRequestEvent<GetMatchmakingTicketRequest> OnMultiplayerGetMatchmakingTicketRequestEvent;

		public event PlayFabResultEvent<GetMatchmakingTicketResult> OnMultiplayerGetMatchmakingTicketResultEvent;

		public event PlayFabRequestEvent<GetMultiplayerServerDetailsRequest> OnMultiplayerGetMultiplayerServerDetailsRequestEvent;

		public event PlayFabResultEvent<GetMultiplayerServerDetailsResponse> OnMultiplayerGetMultiplayerServerDetailsResultEvent;

		public event PlayFabRequestEvent<GetQueueStatisticsRequest> OnMultiplayerGetQueueStatisticsRequestEvent;

		public event PlayFabResultEvent<GetQueueStatisticsResult> OnMultiplayerGetQueueStatisticsResultEvent;

		public event PlayFabRequestEvent<GetRemoteLoginEndpointRequest> OnMultiplayerGetRemoteLoginEndpointRequestEvent;

		public event PlayFabResultEvent<GetRemoteLoginEndpointResponse> OnMultiplayerGetRemoteLoginEndpointResultEvent;

		public event PlayFabRequestEvent<GetTitleEnabledForMultiplayerServersStatusRequest> OnMultiplayerGetTitleEnabledForMultiplayerServersStatusRequestEvent;

		public event PlayFabResultEvent<GetTitleEnabledForMultiplayerServersStatusResponse> OnMultiplayerGetTitleEnabledForMultiplayerServersStatusResultEvent;

		public event PlayFabRequestEvent<GetTitleMultiplayerServersQuotasRequest> OnMultiplayerGetTitleMultiplayerServersQuotasRequestEvent;

		public event PlayFabResultEvent<GetTitleMultiplayerServersQuotasResponse> OnMultiplayerGetTitleMultiplayerServersQuotasResultEvent;

		public event PlayFabRequestEvent<JoinMatchmakingTicketRequest> OnMultiplayerJoinMatchmakingTicketRequestEvent;

		public event PlayFabResultEvent<JoinMatchmakingTicketResult> OnMultiplayerJoinMatchmakingTicketResultEvent;

		public event PlayFabRequestEvent<ListMultiplayerServersRequest> OnMultiplayerListArchivedMultiplayerServersRequestEvent;

		public event PlayFabResultEvent<ListMultiplayerServersResponse> OnMultiplayerListArchivedMultiplayerServersResultEvent;

		public event PlayFabRequestEvent<ListAssetSummariesRequest> OnMultiplayerListAssetSummariesRequestEvent;

		public event PlayFabResultEvent<ListAssetSummariesResponse> OnMultiplayerListAssetSummariesResultEvent;

		public event PlayFabRequestEvent<ListBuildSummariesRequest> OnMultiplayerListBuildSummariesRequestEvent;

		public event PlayFabResultEvent<ListBuildSummariesResponse> OnMultiplayerListBuildSummariesResultEvent;

		public event PlayFabRequestEvent<ListCertificateSummariesRequest> OnMultiplayerListCertificateSummariesRequestEvent;

		public event PlayFabResultEvent<ListCertificateSummariesResponse> OnMultiplayerListCertificateSummariesResultEvent;

		public event PlayFabRequestEvent<ListContainerImagesRequest> OnMultiplayerListContainerImagesRequestEvent;

		public event PlayFabResultEvent<ListContainerImagesResponse> OnMultiplayerListContainerImagesResultEvent;

		public event PlayFabRequestEvent<ListContainerImageTagsRequest> OnMultiplayerListContainerImageTagsRequestEvent;

		public event PlayFabResultEvent<ListContainerImageTagsResponse> OnMultiplayerListContainerImageTagsResultEvent;

		public event PlayFabRequestEvent<ListMatchmakingTicketsForPlayerRequest> OnMultiplayerListMatchmakingTicketsForPlayerRequestEvent;

		public event PlayFabResultEvent<ListMatchmakingTicketsForPlayerResult> OnMultiplayerListMatchmakingTicketsForPlayerResultEvent;

		public event PlayFabRequestEvent<ListMultiplayerServersRequest> OnMultiplayerListMultiplayerServersRequestEvent;

		public event PlayFabResultEvent<ListMultiplayerServersResponse> OnMultiplayerListMultiplayerServersResultEvent;

		public event PlayFabRequestEvent<ListPartyQosServersRequest> OnMultiplayerListPartyQosServersRequestEvent;

		public event PlayFabResultEvent<ListPartyQosServersResponse> OnMultiplayerListPartyQosServersResultEvent;

		public event PlayFabRequestEvent<ListQosServersRequest> OnMultiplayerListQosServersRequestEvent;

		public event PlayFabResultEvent<ListQosServersResponse> OnMultiplayerListQosServersResultEvent;

		public event PlayFabRequestEvent<ListQosServersForTitleRequest> OnMultiplayerListQosServersForTitleRequestEvent;

		public event PlayFabResultEvent<ListQosServersForTitleResponse> OnMultiplayerListQosServersForTitleResultEvent;

		public event PlayFabRequestEvent<ListVirtualMachineSummariesRequest> OnMultiplayerListVirtualMachineSummariesRequestEvent;

		public event PlayFabResultEvent<ListVirtualMachineSummariesResponse> OnMultiplayerListVirtualMachineSummariesResultEvent;

		public event PlayFabRequestEvent<RequestMultiplayerServerRequest> OnMultiplayerRequestMultiplayerServerRequestEvent;

		public event PlayFabResultEvent<RequestMultiplayerServerResponse> OnMultiplayerRequestMultiplayerServerResultEvent;

		public event PlayFabRequestEvent<RolloverContainerRegistryCredentialsRequest> OnMultiplayerRolloverContainerRegistryCredentialsRequestEvent;

		public event PlayFabResultEvent<RolloverContainerRegistryCredentialsResponse> OnMultiplayerRolloverContainerRegistryCredentialsResultEvent;

		public event PlayFabRequestEvent<ShutdownMultiplayerServerRequest> OnMultiplayerShutdownMultiplayerServerRequestEvent;

		public event PlayFabResultEvent<PlayFab.MultiplayerModels.EmptyResponse> OnMultiplayerShutdownMultiplayerServerResultEvent;

		public event PlayFabRequestEvent<UpdateBuildRegionsRequest> OnMultiplayerUpdateBuildRegionsRequestEvent;

		public event PlayFabResultEvent<PlayFab.MultiplayerModels.EmptyResponse> OnMultiplayerUpdateBuildRegionsResultEvent;

		public event PlayFabRequestEvent<UploadCertificateRequest> OnMultiplayerUploadCertificateRequestEvent;

		public event PlayFabResultEvent<PlayFab.MultiplayerModels.EmptyResponse> OnMultiplayerUploadCertificateResultEvent;

		public event PlayFabRequestEvent<GetGlobalPolicyRequest> OnProfilesGetGlobalPolicyRequestEvent;

		public event PlayFabResultEvent<GetGlobalPolicyResponse> OnProfilesGetGlobalPolicyResultEvent;

		public event PlayFabRequestEvent<GetEntityProfileRequest> OnProfilesGetProfileRequestEvent;

		public event PlayFabResultEvent<GetEntityProfileResponse> OnProfilesGetProfileResultEvent;

		public event PlayFabRequestEvent<GetEntityProfilesRequest> OnProfilesGetProfilesRequestEvent;

		public event PlayFabResultEvent<GetEntityProfilesResponse> OnProfilesGetProfilesResultEvent;

		public event PlayFabRequestEvent<GetTitlePlayersFromMasterPlayerAccountIdsRequest> OnProfilesGetTitlePlayersFromMasterPlayerAccountIdsRequestEvent;

		public event PlayFabResultEvent<GetTitlePlayersFromMasterPlayerAccountIdsResponse> OnProfilesGetTitlePlayersFromMasterPlayerAccountIdsResultEvent;

		public event PlayFabRequestEvent<SetGlobalPolicyRequest> OnProfilesSetGlobalPolicyRequestEvent;

		public event PlayFabResultEvent<SetGlobalPolicyResponse> OnProfilesSetGlobalPolicyResultEvent;

		public event PlayFabRequestEvent<SetProfileLanguageRequest> OnProfilesSetProfileLanguageRequestEvent;

		public event PlayFabResultEvent<SetProfileLanguageResponse> OnProfilesSetProfileLanguageResultEvent;

		public event PlayFabRequestEvent<SetEntityProfilePolicyRequest> OnProfilesSetProfilePolicyRequestEvent;

		public event PlayFabResultEvent<SetEntityProfilePolicyResponse> OnProfilesSetProfilePolicyResultEvent;

		public event PlayFabErrorEvent OnGlobalErrorEvent;

		private PlayFabEvents()
		{
		}

		public static PlayFabEvents Init()
		{
			if (_instance == null)
			{
				_instance = new PlayFabEvents();
			}
			PlayFabHttp.ApiProcessingEventHandler += _instance.OnProcessingEvent;
			PlayFabHttp.ApiProcessingErrorEventHandler += _instance.OnProcessingErrorEvent;
			return _instance;
		}

		public void UnregisterInstance(object instance)
		{
			Delegate[] invocationList;
			if (this.OnLoginResultEvent != null)
			{
				invocationList = this.OnLoginResultEvent.GetInvocationList();
				foreach (Delegate @delegate in invocationList)
				{
					if (@delegate.Target == instance)
					{
						OnLoginResultEvent -= (PlayFabResultEvent<LoginResult>)@delegate;
					}
				}
			}
			if (this.OnAcceptTradeRequestEvent != null)
			{
				invocationList = this.OnAcceptTradeRequestEvent.GetInvocationList();
				foreach (Delegate delegate2 in invocationList)
				{
					if (delegate2.Target == instance)
					{
						OnAcceptTradeRequestEvent -= (PlayFabRequestEvent<AcceptTradeRequest>)delegate2;
					}
				}
			}
			if (this.OnAcceptTradeResultEvent != null)
			{
				invocationList = this.OnAcceptTradeResultEvent.GetInvocationList();
				foreach (Delegate delegate3 in invocationList)
				{
					if (delegate3.Target == instance)
					{
						OnAcceptTradeResultEvent -= (PlayFabResultEvent<AcceptTradeResponse>)delegate3;
					}
				}
			}
			if (this.OnAddFriendRequestEvent != null)
			{
				invocationList = this.OnAddFriendRequestEvent.GetInvocationList();
				foreach (Delegate delegate4 in invocationList)
				{
					if (delegate4.Target == instance)
					{
						OnAddFriendRequestEvent -= (PlayFabRequestEvent<AddFriendRequest>)delegate4;
					}
				}
			}
			if (this.OnAddFriendResultEvent != null)
			{
				invocationList = this.OnAddFriendResultEvent.GetInvocationList();
				foreach (Delegate delegate5 in invocationList)
				{
					if (delegate5.Target == instance)
					{
						OnAddFriendResultEvent -= (PlayFabResultEvent<AddFriendResult>)delegate5;
					}
				}
			}
			if (this.OnAddGenericIDRequestEvent != null)
			{
				invocationList = this.OnAddGenericIDRequestEvent.GetInvocationList();
				foreach (Delegate delegate6 in invocationList)
				{
					if (delegate6.Target == instance)
					{
						OnAddGenericIDRequestEvent -= (PlayFabRequestEvent<AddGenericIDRequest>)delegate6;
					}
				}
			}
			if (this.OnAddGenericIDResultEvent != null)
			{
				invocationList = this.OnAddGenericIDResultEvent.GetInvocationList();
				foreach (Delegate delegate7 in invocationList)
				{
					if (delegate7.Target == instance)
					{
						OnAddGenericIDResultEvent -= (PlayFabResultEvent<AddGenericIDResult>)delegate7;
					}
				}
			}
			if (this.OnAddOrUpdateContactEmailRequestEvent != null)
			{
				invocationList = this.OnAddOrUpdateContactEmailRequestEvent.GetInvocationList();
				foreach (Delegate delegate8 in invocationList)
				{
					if (delegate8.Target == instance)
					{
						OnAddOrUpdateContactEmailRequestEvent -= (PlayFabRequestEvent<AddOrUpdateContactEmailRequest>)delegate8;
					}
				}
			}
			if (this.OnAddOrUpdateContactEmailResultEvent != null)
			{
				invocationList = this.OnAddOrUpdateContactEmailResultEvent.GetInvocationList();
				foreach (Delegate delegate9 in invocationList)
				{
					if (delegate9.Target == instance)
					{
						OnAddOrUpdateContactEmailResultEvent -= (PlayFabResultEvent<AddOrUpdateContactEmailResult>)delegate9;
					}
				}
			}
			if (this.OnAddSharedGroupMembersRequestEvent != null)
			{
				invocationList = this.OnAddSharedGroupMembersRequestEvent.GetInvocationList();
				foreach (Delegate delegate10 in invocationList)
				{
					if (delegate10.Target == instance)
					{
						OnAddSharedGroupMembersRequestEvent -= (PlayFabRequestEvent<AddSharedGroupMembersRequest>)delegate10;
					}
				}
			}
			if (this.OnAddSharedGroupMembersResultEvent != null)
			{
				invocationList = this.OnAddSharedGroupMembersResultEvent.GetInvocationList();
				foreach (Delegate delegate11 in invocationList)
				{
					if (delegate11.Target == instance)
					{
						OnAddSharedGroupMembersResultEvent -= (PlayFabResultEvent<AddSharedGroupMembersResult>)delegate11;
					}
				}
			}
			if (this.OnAddUsernamePasswordRequestEvent != null)
			{
				invocationList = this.OnAddUsernamePasswordRequestEvent.GetInvocationList();
				foreach (Delegate delegate12 in invocationList)
				{
					if (delegate12.Target == instance)
					{
						OnAddUsernamePasswordRequestEvent -= (PlayFabRequestEvent<AddUsernamePasswordRequest>)delegate12;
					}
				}
			}
			if (this.OnAddUsernamePasswordResultEvent != null)
			{
				invocationList = this.OnAddUsernamePasswordResultEvent.GetInvocationList();
				foreach (Delegate delegate13 in invocationList)
				{
					if (delegate13.Target == instance)
					{
						OnAddUsernamePasswordResultEvent -= (PlayFabResultEvent<AddUsernamePasswordResult>)delegate13;
					}
				}
			}
			if (this.OnAddUserVirtualCurrencyRequestEvent != null)
			{
				invocationList = this.OnAddUserVirtualCurrencyRequestEvent.GetInvocationList();
				foreach (Delegate delegate14 in invocationList)
				{
					if (delegate14.Target == instance)
					{
						OnAddUserVirtualCurrencyRequestEvent -= (PlayFabRequestEvent<AddUserVirtualCurrencyRequest>)delegate14;
					}
				}
			}
			if (this.OnAddUserVirtualCurrencyResultEvent != null)
			{
				invocationList = this.OnAddUserVirtualCurrencyResultEvent.GetInvocationList();
				foreach (Delegate delegate15 in invocationList)
				{
					if (delegate15.Target == instance)
					{
						OnAddUserVirtualCurrencyResultEvent -= (PlayFabResultEvent<ModifyUserVirtualCurrencyResult>)delegate15;
					}
				}
			}
			if (this.OnAndroidDevicePushNotificationRegistrationRequestEvent != null)
			{
				invocationList = this.OnAndroidDevicePushNotificationRegistrationRequestEvent.GetInvocationList();
				foreach (Delegate delegate16 in invocationList)
				{
					if (delegate16.Target == instance)
					{
						OnAndroidDevicePushNotificationRegistrationRequestEvent -= (PlayFabRequestEvent<AndroidDevicePushNotificationRegistrationRequest>)delegate16;
					}
				}
			}
			if (this.OnAndroidDevicePushNotificationRegistrationResultEvent != null)
			{
				invocationList = this.OnAndroidDevicePushNotificationRegistrationResultEvent.GetInvocationList();
				foreach (Delegate delegate17 in invocationList)
				{
					if (delegate17.Target == instance)
					{
						OnAndroidDevicePushNotificationRegistrationResultEvent -= (PlayFabResultEvent<AndroidDevicePushNotificationRegistrationResult>)delegate17;
					}
				}
			}
			if (this.OnAttributeInstallRequestEvent != null)
			{
				invocationList = this.OnAttributeInstallRequestEvent.GetInvocationList();
				foreach (Delegate delegate18 in invocationList)
				{
					if (delegate18.Target == instance)
					{
						OnAttributeInstallRequestEvent -= (PlayFabRequestEvent<AttributeInstallRequest>)delegate18;
					}
				}
			}
			if (this.OnAttributeInstallResultEvent != null)
			{
				invocationList = this.OnAttributeInstallResultEvent.GetInvocationList();
				foreach (Delegate delegate19 in invocationList)
				{
					if (delegate19.Target == instance)
					{
						OnAttributeInstallResultEvent -= (PlayFabResultEvent<AttributeInstallResult>)delegate19;
					}
				}
			}
			if (this.OnCancelTradeRequestEvent != null)
			{
				invocationList = this.OnCancelTradeRequestEvent.GetInvocationList();
				foreach (Delegate delegate20 in invocationList)
				{
					if (delegate20.Target == instance)
					{
						OnCancelTradeRequestEvent -= (PlayFabRequestEvent<CancelTradeRequest>)delegate20;
					}
				}
			}
			if (this.OnCancelTradeResultEvent != null)
			{
				invocationList = this.OnCancelTradeResultEvent.GetInvocationList();
				foreach (Delegate delegate21 in invocationList)
				{
					if (delegate21.Target == instance)
					{
						OnCancelTradeResultEvent -= (PlayFabResultEvent<CancelTradeResponse>)delegate21;
					}
				}
			}
			if (this.OnConfirmPurchaseRequestEvent != null)
			{
				invocationList = this.OnConfirmPurchaseRequestEvent.GetInvocationList();
				foreach (Delegate delegate22 in invocationList)
				{
					if (delegate22.Target == instance)
					{
						OnConfirmPurchaseRequestEvent -= (PlayFabRequestEvent<ConfirmPurchaseRequest>)delegate22;
					}
				}
			}
			if (this.OnConfirmPurchaseResultEvent != null)
			{
				invocationList = this.OnConfirmPurchaseResultEvent.GetInvocationList();
				foreach (Delegate delegate23 in invocationList)
				{
					if (delegate23.Target == instance)
					{
						OnConfirmPurchaseResultEvent -= (PlayFabResultEvent<ConfirmPurchaseResult>)delegate23;
					}
				}
			}
			if (this.OnConsumeItemRequestEvent != null)
			{
				invocationList = this.OnConsumeItemRequestEvent.GetInvocationList();
				foreach (Delegate delegate24 in invocationList)
				{
					if (delegate24.Target == instance)
					{
						OnConsumeItemRequestEvent -= (PlayFabRequestEvent<ConsumeItemRequest>)delegate24;
					}
				}
			}
			if (this.OnConsumeItemResultEvent != null)
			{
				invocationList = this.OnConsumeItemResultEvent.GetInvocationList();
				foreach (Delegate delegate25 in invocationList)
				{
					if (delegate25.Target == instance)
					{
						OnConsumeItemResultEvent -= (PlayFabResultEvent<ConsumeItemResult>)delegate25;
					}
				}
			}
			if (this.OnConsumePSNEntitlementsRequestEvent != null)
			{
				invocationList = this.OnConsumePSNEntitlementsRequestEvent.GetInvocationList();
				foreach (Delegate delegate26 in invocationList)
				{
					if (delegate26.Target == instance)
					{
						OnConsumePSNEntitlementsRequestEvent -= (PlayFabRequestEvent<ConsumePSNEntitlementsRequest>)delegate26;
					}
				}
			}
			if (this.OnConsumePSNEntitlementsResultEvent != null)
			{
				invocationList = this.OnConsumePSNEntitlementsResultEvent.GetInvocationList();
				foreach (Delegate delegate27 in invocationList)
				{
					if (delegate27.Target == instance)
					{
						OnConsumePSNEntitlementsResultEvent -= (PlayFabResultEvent<ConsumePSNEntitlementsResult>)delegate27;
					}
				}
			}
			if (this.OnConsumeXboxEntitlementsRequestEvent != null)
			{
				invocationList = this.OnConsumeXboxEntitlementsRequestEvent.GetInvocationList();
				foreach (Delegate delegate28 in invocationList)
				{
					if (delegate28.Target == instance)
					{
						OnConsumeXboxEntitlementsRequestEvent -= (PlayFabRequestEvent<ConsumeXboxEntitlementsRequest>)delegate28;
					}
				}
			}
			if (this.OnConsumeXboxEntitlementsResultEvent != null)
			{
				invocationList = this.OnConsumeXboxEntitlementsResultEvent.GetInvocationList();
				foreach (Delegate delegate29 in invocationList)
				{
					if (delegate29.Target == instance)
					{
						OnConsumeXboxEntitlementsResultEvent -= (PlayFabResultEvent<ConsumeXboxEntitlementsResult>)delegate29;
					}
				}
			}
			if (this.OnCreateSharedGroupRequestEvent != null)
			{
				invocationList = this.OnCreateSharedGroupRequestEvent.GetInvocationList();
				foreach (Delegate delegate30 in invocationList)
				{
					if (delegate30.Target == instance)
					{
						OnCreateSharedGroupRequestEvent -= (PlayFabRequestEvent<CreateSharedGroupRequest>)delegate30;
					}
				}
			}
			if (this.OnCreateSharedGroupResultEvent != null)
			{
				invocationList = this.OnCreateSharedGroupResultEvent.GetInvocationList();
				foreach (Delegate delegate31 in invocationList)
				{
					if (delegate31.Target == instance)
					{
						OnCreateSharedGroupResultEvent -= (PlayFabResultEvent<CreateSharedGroupResult>)delegate31;
					}
				}
			}
			if (this.OnExecuteCloudScriptRequestEvent != null)
			{
				invocationList = this.OnExecuteCloudScriptRequestEvent.GetInvocationList();
				foreach (Delegate delegate32 in invocationList)
				{
					if (delegate32.Target == instance)
					{
						OnExecuteCloudScriptRequestEvent -= (PlayFabRequestEvent<ExecuteCloudScriptRequest>)delegate32;
					}
				}
			}
			if (this.OnExecuteCloudScriptResultEvent != null)
			{
				invocationList = this.OnExecuteCloudScriptResultEvent.GetInvocationList();
				foreach (Delegate delegate33 in invocationList)
				{
					if (delegate33.Target == instance)
					{
						OnExecuteCloudScriptResultEvent -= (PlayFabResultEvent<PlayFab.ClientModels.ExecuteCloudScriptResult>)delegate33;
					}
				}
			}
			if (this.OnGetAccountInfoRequestEvent != null)
			{
				invocationList = this.OnGetAccountInfoRequestEvent.GetInvocationList();
				foreach (Delegate delegate34 in invocationList)
				{
					if (delegate34.Target == instance)
					{
						OnGetAccountInfoRequestEvent -= (PlayFabRequestEvent<GetAccountInfoRequest>)delegate34;
					}
				}
			}
			if (this.OnGetAccountInfoResultEvent != null)
			{
				invocationList = this.OnGetAccountInfoResultEvent.GetInvocationList();
				foreach (Delegate delegate35 in invocationList)
				{
					if (delegate35.Target == instance)
					{
						OnGetAccountInfoResultEvent -= (PlayFabResultEvent<GetAccountInfoResult>)delegate35;
					}
				}
			}
			if (this.OnGetAllUsersCharactersRequestEvent != null)
			{
				invocationList = this.OnGetAllUsersCharactersRequestEvent.GetInvocationList();
				foreach (Delegate delegate36 in invocationList)
				{
					if (delegate36.Target == instance)
					{
						OnGetAllUsersCharactersRequestEvent -= (PlayFabRequestEvent<ListUsersCharactersRequest>)delegate36;
					}
				}
			}
			if (this.OnGetAllUsersCharactersResultEvent != null)
			{
				invocationList = this.OnGetAllUsersCharactersResultEvent.GetInvocationList();
				foreach (Delegate delegate37 in invocationList)
				{
					if (delegate37.Target == instance)
					{
						OnGetAllUsersCharactersResultEvent -= (PlayFabResultEvent<ListUsersCharactersResult>)delegate37;
					}
				}
			}
			if (this.OnGetCatalogItemsRequestEvent != null)
			{
				invocationList = this.OnGetCatalogItemsRequestEvent.GetInvocationList();
				foreach (Delegate delegate38 in invocationList)
				{
					if (delegate38.Target == instance)
					{
						OnGetCatalogItemsRequestEvent -= (PlayFabRequestEvent<GetCatalogItemsRequest>)delegate38;
					}
				}
			}
			if (this.OnGetCatalogItemsResultEvent != null)
			{
				invocationList = this.OnGetCatalogItemsResultEvent.GetInvocationList();
				foreach (Delegate delegate39 in invocationList)
				{
					if (delegate39.Target == instance)
					{
						OnGetCatalogItemsResultEvent -= (PlayFabResultEvent<GetCatalogItemsResult>)delegate39;
					}
				}
			}
			if (this.OnGetCharacterDataRequestEvent != null)
			{
				invocationList = this.OnGetCharacterDataRequestEvent.GetInvocationList();
				foreach (Delegate delegate40 in invocationList)
				{
					if (delegate40.Target == instance)
					{
						OnGetCharacterDataRequestEvent -= (PlayFabRequestEvent<GetCharacterDataRequest>)delegate40;
					}
				}
			}
			if (this.OnGetCharacterDataResultEvent != null)
			{
				invocationList = this.OnGetCharacterDataResultEvent.GetInvocationList();
				foreach (Delegate delegate41 in invocationList)
				{
					if (delegate41.Target == instance)
					{
						OnGetCharacterDataResultEvent -= (PlayFabResultEvent<GetCharacterDataResult>)delegate41;
					}
				}
			}
			if (this.OnGetCharacterInventoryRequestEvent != null)
			{
				invocationList = this.OnGetCharacterInventoryRequestEvent.GetInvocationList();
				foreach (Delegate delegate42 in invocationList)
				{
					if (delegate42.Target == instance)
					{
						OnGetCharacterInventoryRequestEvent -= (PlayFabRequestEvent<GetCharacterInventoryRequest>)delegate42;
					}
				}
			}
			if (this.OnGetCharacterInventoryResultEvent != null)
			{
				invocationList = this.OnGetCharacterInventoryResultEvent.GetInvocationList();
				foreach (Delegate delegate43 in invocationList)
				{
					if (delegate43.Target == instance)
					{
						OnGetCharacterInventoryResultEvent -= (PlayFabResultEvent<GetCharacterInventoryResult>)delegate43;
					}
				}
			}
			if (this.OnGetCharacterLeaderboardRequestEvent != null)
			{
				invocationList = this.OnGetCharacterLeaderboardRequestEvent.GetInvocationList();
				foreach (Delegate delegate44 in invocationList)
				{
					if (delegate44.Target == instance)
					{
						OnGetCharacterLeaderboardRequestEvent -= (PlayFabRequestEvent<GetCharacterLeaderboardRequest>)delegate44;
					}
				}
			}
			if (this.OnGetCharacterLeaderboardResultEvent != null)
			{
				invocationList = this.OnGetCharacterLeaderboardResultEvent.GetInvocationList();
				foreach (Delegate delegate45 in invocationList)
				{
					if (delegate45.Target == instance)
					{
						OnGetCharacterLeaderboardResultEvent -= (PlayFabResultEvent<GetCharacterLeaderboardResult>)delegate45;
					}
				}
			}
			if (this.OnGetCharacterReadOnlyDataRequestEvent != null)
			{
				invocationList = this.OnGetCharacterReadOnlyDataRequestEvent.GetInvocationList();
				foreach (Delegate delegate46 in invocationList)
				{
					if (delegate46.Target == instance)
					{
						OnGetCharacterReadOnlyDataRequestEvent -= (PlayFabRequestEvent<GetCharacterDataRequest>)delegate46;
					}
				}
			}
			if (this.OnGetCharacterReadOnlyDataResultEvent != null)
			{
				invocationList = this.OnGetCharacterReadOnlyDataResultEvent.GetInvocationList();
				foreach (Delegate delegate47 in invocationList)
				{
					if (delegate47.Target == instance)
					{
						OnGetCharacterReadOnlyDataResultEvent -= (PlayFabResultEvent<GetCharacterDataResult>)delegate47;
					}
				}
			}
			if (this.OnGetCharacterStatisticsRequestEvent != null)
			{
				invocationList = this.OnGetCharacterStatisticsRequestEvent.GetInvocationList();
				foreach (Delegate delegate48 in invocationList)
				{
					if (delegate48.Target == instance)
					{
						OnGetCharacterStatisticsRequestEvent -= (PlayFabRequestEvent<GetCharacterStatisticsRequest>)delegate48;
					}
				}
			}
			if (this.OnGetCharacterStatisticsResultEvent != null)
			{
				invocationList = this.OnGetCharacterStatisticsResultEvent.GetInvocationList();
				foreach (Delegate delegate49 in invocationList)
				{
					if (delegate49.Target == instance)
					{
						OnGetCharacterStatisticsResultEvent -= (PlayFabResultEvent<GetCharacterStatisticsResult>)delegate49;
					}
				}
			}
			if (this.OnGetContentDownloadUrlRequestEvent != null)
			{
				invocationList = this.OnGetContentDownloadUrlRequestEvent.GetInvocationList();
				foreach (Delegate delegate50 in invocationList)
				{
					if (delegate50.Target == instance)
					{
						OnGetContentDownloadUrlRequestEvent -= (PlayFabRequestEvent<GetContentDownloadUrlRequest>)delegate50;
					}
				}
			}
			if (this.OnGetContentDownloadUrlResultEvent != null)
			{
				invocationList = this.OnGetContentDownloadUrlResultEvent.GetInvocationList();
				foreach (Delegate delegate51 in invocationList)
				{
					if (delegate51.Target == instance)
					{
						OnGetContentDownloadUrlResultEvent -= (PlayFabResultEvent<GetContentDownloadUrlResult>)delegate51;
					}
				}
			}
			if (this.OnGetCurrentGamesRequestEvent != null)
			{
				invocationList = this.OnGetCurrentGamesRequestEvent.GetInvocationList();
				foreach (Delegate delegate52 in invocationList)
				{
					if (delegate52.Target == instance)
					{
						OnGetCurrentGamesRequestEvent -= (PlayFabRequestEvent<CurrentGamesRequest>)delegate52;
					}
				}
			}
			if (this.OnGetCurrentGamesResultEvent != null)
			{
				invocationList = this.OnGetCurrentGamesResultEvent.GetInvocationList();
				foreach (Delegate delegate53 in invocationList)
				{
					if (delegate53.Target == instance)
					{
						OnGetCurrentGamesResultEvent -= (PlayFabResultEvent<CurrentGamesResult>)delegate53;
					}
				}
			}
			if (this.OnGetFriendLeaderboardRequestEvent != null)
			{
				invocationList = this.OnGetFriendLeaderboardRequestEvent.GetInvocationList();
				foreach (Delegate delegate54 in invocationList)
				{
					if (delegate54.Target == instance)
					{
						OnGetFriendLeaderboardRequestEvent -= (PlayFabRequestEvent<GetFriendLeaderboardRequest>)delegate54;
					}
				}
			}
			if (this.OnGetFriendLeaderboardResultEvent != null)
			{
				invocationList = this.OnGetFriendLeaderboardResultEvent.GetInvocationList();
				foreach (Delegate delegate55 in invocationList)
				{
					if (delegate55.Target == instance)
					{
						OnGetFriendLeaderboardResultEvent -= (PlayFabResultEvent<GetLeaderboardResult>)delegate55;
					}
				}
			}
			if (this.OnGetFriendLeaderboardAroundPlayerRequestEvent != null)
			{
				invocationList = this.OnGetFriendLeaderboardAroundPlayerRequestEvent.GetInvocationList();
				foreach (Delegate delegate56 in invocationList)
				{
					if (delegate56.Target == instance)
					{
						OnGetFriendLeaderboardAroundPlayerRequestEvent -= (PlayFabRequestEvent<GetFriendLeaderboardAroundPlayerRequest>)delegate56;
					}
				}
			}
			if (this.OnGetFriendLeaderboardAroundPlayerResultEvent != null)
			{
				invocationList = this.OnGetFriendLeaderboardAroundPlayerResultEvent.GetInvocationList();
				foreach (Delegate delegate57 in invocationList)
				{
					if (delegate57.Target == instance)
					{
						OnGetFriendLeaderboardAroundPlayerResultEvent -= (PlayFabResultEvent<GetFriendLeaderboardAroundPlayerResult>)delegate57;
					}
				}
			}
			if (this.OnGetFriendsListRequestEvent != null)
			{
				invocationList = this.OnGetFriendsListRequestEvent.GetInvocationList();
				foreach (Delegate delegate58 in invocationList)
				{
					if (delegate58.Target == instance)
					{
						OnGetFriendsListRequestEvent -= (PlayFabRequestEvent<GetFriendsListRequest>)delegate58;
					}
				}
			}
			if (this.OnGetFriendsListResultEvent != null)
			{
				invocationList = this.OnGetFriendsListResultEvent.GetInvocationList();
				foreach (Delegate delegate59 in invocationList)
				{
					if (delegate59.Target == instance)
					{
						OnGetFriendsListResultEvent -= (PlayFabResultEvent<GetFriendsListResult>)delegate59;
					}
				}
			}
			if (this.OnGetGameServerRegionsRequestEvent != null)
			{
				invocationList = this.OnGetGameServerRegionsRequestEvent.GetInvocationList();
				foreach (Delegate delegate60 in invocationList)
				{
					if (delegate60.Target == instance)
					{
						OnGetGameServerRegionsRequestEvent -= (PlayFabRequestEvent<GameServerRegionsRequest>)delegate60;
					}
				}
			}
			if (this.OnGetGameServerRegionsResultEvent != null)
			{
				invocationList = this.OnGetGameServerRegionsResultEvent.GetInvocationList();
				foreach (Delegate delegate61 in invocationList)
				{
					if (delegate61.Target == instance)
					{
						OnGetGameServerRegionsResultEvent -= (PlayFabResultEvent<GameServerRegionsResult>)delegate61;
					}
				}
			}
			if (this.OnGetLeaderboardRequestEvent != null)
			{
				invocationList = this.OnGetLeaderboardRequestEvent.GetInvocationList();
				foreach (Delegate delegate62 in invocationList)
				{
					if (delegate62.Target == instance)
					{
						OnGetLeaderboardRequestEvent -= (PlayFabRequestEvent<GetLeaderboardRequest>)delegate62;
					}
				}
			}
			if (this.OnGetLeaderboardResultEvent != null)
			{
				invocationList = this.OnGetLeaderboardResultEvent.GetInvocationList();
				foreach (Delegate delegate63 in invocationList)
				{
					if (delegate63.Target == instance)
					{
						OnGetLeaderboardResultEvent -= (PlayFabResultEvent<GetLeaderboardResult>)delegate63;
					}
				}
			}
			if (this.OnGetLeaderboardAroundCharacterRequestEvent != null)
			{
				invocationList = this.OnGetLeaderboardAroundCharacterRequestEvent.GetInvocationList();
				foreach (Delegate delegate64 in invocationList)
				{
					if (delegate64.Target == instance)
					{
						OnGetLeaderboardAroundCharacterRequestEvent -= (PlayFabRequestEvent<GetLeaderboardAroundCharacterRequest>)delegate64;
					}
				}
			}
			if (this.OnGetLeaderboardAroundCharacterResultEvent != null)
			{
				invocationList = this.OnGetLeaderboardAroundCharacterResultEvent.GetInvocationList();
				foreach (Delegate delegate65 in invocationList)
				{
					if (delegate65.Target == instance)
					{
						OnGetLeaderboardAroundCharacterResultEvent -= (PlayFabResultEvent<GetLeaderboardAroundCharacterResult>)delegate65;
					}
				}
			}
			if (this.OnGetLeaderboardAroundPlayerRequestEvent != null)
			{
				invocationList = this.OnGetLeaderboardAroundPlayerRequestEvent.GetInvocationList();
				foreach (Delegate delegate66 in invocationList)
				{
					if (delegate66.Target == instance)
					{
						OnGetLeaderboardAroundPlayerRequestEvent -= (PlayFabRequestEvent<GetLeaderboardAroundPlayerRequest>)delegate66;
					}
				}
			}
			if (this.OnGetLeaderboardAroundPlayerResultEvent != null)
			{
				invocationList = this.OnGetLeaderboardAroundPlayerResultEvent.GetInvocationList();
				foreach (Delegate delegate67 in invocationList)
				{
					if (delegate67.Target == instance)
					{
						OnGetLeaderboardAroundPlayerResultEvent -= (PlayFabResultEvent<GetLeaderboardAroundPlayerResult>)delegate67;
					}
				}
			}
			if (this.OnGetLeaderboardForUserCharactersRequestEvent != null)
			{
				invocationList = this.OnGetLeaderboardForUserCharactersRequestEvent.GetInvocationList();
				foreach (Delegate delegate68 in invocationList)
				{
					if (delegate68.Target == instance)
					{
						OnGetLeaderboardForUserCharactersRequestEvent -= (PlayFabRequestEvent<GetLeaderboardForUsersCharactersRequest>)delegate68;
					}
				}
			}
			if (this.OnGetLeaderboardForUserCharactersResultEvent != null)
			{
				invocationList = this.OnGetLeaderboardForUserCharactersResultEvent.GetInvocationList();
				foreach (Delegate delegate69 in invocationList)
				{
					if (delegate69.Target == instance)
					{
						OnGetLeaderboardForUserCharactersResultEvent -= (PlayFabResultEvent<GetLeaderboardForUsersCharactersResult>)delegate69;
					}
				}
			}
			if (this.OnGetPaymentTokenRequestEvent != null)
			{
				invocationList = this.OnGetPaymentTokenRequestEvent.GetInvocationList();
				foreach (Delegate delegate70 in invocationList)
				{
					if (delegate70.Target == instance)
					{
						OnGetPaymentTokenRequestEvent -= (PlayFabRequestEvent<GetPaymentTokenRequest>)delegate70;
					}
				}
			}
			if (this.OnGetPaymentTokenResultEvent != null)
			{
				invocationList = this.OnGetPaymentTokenResultEvent.GetInvocationList();
				foreach (Delegate delegate71 in invocationList)
				{
					if (delegate71.Target == instance)
					{
						OnGetPaymentTokenResultEvent -= (PlayFabResultEvent<GetPaymentTokenResult>)delegate71;
					}
				}
			}
			if (this.OnGetPhotonAuthenticationTokenRequestEvent != null)
			{
				invocationList = this.OnGetPhotonAuthenticationTokenRequestEvent.GetInvocationList();
				foreach (Delegate delegate72 in invocationList)
				{
					if (delegate72.Target == instance)
					{
						OnGetPhotonAuthenticationTokenRequestEvent -= (PlayFabRequestEvent<GetPhotonAuthenticationTokenRequest>)delegate72;
					}
				}
			}
			if (this.OnGetPhotonAuthenticationTokenResultEvent != null)
			{
				invocationList = this.OnGetPhotonAuthenticationTokenResultEvent.GetInvocationList();
				foreach (Delegate delegate73 in invocationList)
				{
					if (delegate73.Target == instance)
					{
						OnGetPhotonAuthenticationTokenResultEvent -= (PlayFabResultEvent<GetPhotonAuthenticationTokenResult>)delegate73;
					}
				}
			}
			if (this.OnGetPlayerCombinedInfoRequestEvent != null)
			{
				invocationList = this.OnGetPlayerCombinedInfoRequestEvent.GetInvocationList();
				foreach (Delegate delegate74 in invocationList)
				{
					if (delegate74.Target == instance)
					{
						OnGetPlayerCombinedInfoRequestEvent -= (PlayFabRequestEvent<GetPlayerCombinedInfoRequest>)delegate74;
					}
				}
			}
			if (this.OnGetPlayerCombinedInfoResultEvent != null)
			{
				invocationList = this.OnGetPlayerCombinedInfoResultEvent.GetInvocationList();
				foreach (Delegate delegate75 in invocationList)
				{
					if (delegate75.Target == instance)
					{
						OnGetPlayerCombinedInfoResultEvent -= (PlayFabResultEvent<GetPlayerCombinedInfoResult>)delegate75;
					}
				}
			}
			if (this.OnGetPlayerProfileRequestEvent != null)
			{
				invocationList = this.OnGetPlayerProfileRequestEvent.GetInvocationList();
				foreach (Delegate delegate76 in invocationList)
				{
					if (delegate76.Target == instance)
					{
						OnGetPlayerProfileRequestEvent -= (PlayFabRequestEvent<GetPlayerProfileRequest>)delegate76;
					}
				}
			}
			if (this.OnGetPlayerProfileResultEvent != null)
			{
				invocationList = this.OnGetPlayerProfileResultEvent.GetInvocationList();
				foreach (Delegate delegate77 in invocationList)
				{
					if (delegate77.Target == instance)
					{
						OnGetPlayerProfileResultEvent -= (PlayFabResultEvent<GetPlayerProfileResult>)delegate77;
					}
				}
			}
			if (this.OnGetPlayerSegmentsRequestEvent != null)
			{
				invocationList = this.OnGetPlayerSegmentsRequestEvent.GetInvocationList();
				foreach (Delegate delegate78 in invocationList)
				{
					if (delegate78.Target == instance)
					{
						OnGetPlayerSegmentsRequestEvent -= (PlayFabRequestEvent<GetPlayerSegmentsRequest>)delegate78;
					}
				}
			}
			if (this.OnGetPlayerSegmentsResultEvent != null)
			{
				invocationList = this.OnGetPlayerSegmentsResultEvent.GetInvocationList();
				foreach (Delegate delegate79 in invocationList)
				{
					if (delegate79.Target == instance)
					{
						OnGetPlayerSegmentsResultEvent -= (PlayFabResultEvent<GetPlayerSegmentsResult>)delegate79;
					}
				}
			}
			if (this.OnGetPlayerStatisticsRequestEvent != null)
			{
				invocationList = this.OnGetPlayerStatisticsRequestEvent.GetInvocationList();
				foreach (Delegate delegate80 in invocationList)
				{
					if (delegate80.Target == instance)
					{
						OnGetPlayerStatisticsRequestEvent -= (PlayFabRequestEvent<GetPlayerStatisticsRequest>)delegate80;
					}
				}
			}
			if (this.OnGetPlayerStatisticsResultEvent != null)
			{
				invocationList = this.OnGetPlayerStatisticsResultEvent.GetInvocationList();
				foreach (Delegate delegate81 in invocationList)
				{
					if (delegate81.Target == instance)
					{
						OnGetPlayerStatisticsResultEvent -= (PlayFabResultEvent<GetPlayerStatisticsResult>)delegate81;
					}
				}
			}
			if (this.OnGetPlayerStatisticVersionsRequestEvent != null)
			{
				invocationList = this.OnGetPlayerStatisticVersionsRequestEvent.GetInvocationList();
				foreach (Delegate delegate82 in invocationList)
				{
					if (delegate82.Target == instance)
					{
						OnGetPlayerStatisticVersionsRequestEvent -= (PlayFabRequestEvent<GetPlayerStatisticVersionsRequest>)delegate82;
					}
				}
			}
			if (this.OnGetPlayerStatisticVersionsResultEvent != null)
			{
				invocationList = this.OnGetPlayerStatisticVersionsResultEvent.GetInvocationList();
				foreach (Delegate delegate83 in invocationList)
				{
					if (delegate83.Target == instance)
					{
						OnGetPlayerStatisticVersionsResultEvent -= (PlayFabResultEvent<GetPlayerStatisticVersionsResult>)delegate83;
					}
				}
			}
			if (this.OnGetPlayerTagsRequestEvent != null)
			{
				invocationList = this.OnGetPlayerTagsRequestEvent.GetInvocationList();
				foreach (Delegate delegate84 in invocationList)
				{
					if (delegate84.Target == instance)
					{
						OnGetPlayerTagsRequestEvent -= (PlayFabRequestEvent<GetPlayerTagsRequest>)delegate84;
					}
				}
			}
			if (this.OnGetPlayerTagsResultEvent != null)
			{
				invocationList = this.OnGetPlayerTagsResultEvent.GetInvocationList();
				foreach (Delegate delegate85 in invocationList)
				{
					if (delegate85.Target == instance)
					{
						OnGetPlayerTagsResultEvent -= (PlayFabResultEvent<GetPlayerTagsResult>)delegate85;
					}
				}
			}
			if (this.OnGetPlayerTradesRequestEvent != null)
			{
				invocationList = this.OnGetPlayerTradesRequestEvent.GetInvocationList();
				foreach (Delegate delegate86 in invocationList)
				{
					if (delegate86.Target == instance)
					{
						OnGetPlayerTradesRequestEvent -= (PlayFabRequestEvent<GetPlayerTradesRequest>)delegate86;
					}
				}
			}
			if (this.OnGetPlayerTradesResultEvent != null)
			{
				invocationList = this.OnGetPlayerTradesResultEvent.GetInvocationList();
				foreach (Delegate delegate87 in invocationList)
				{
					if (delegate87.Target == instance)
					{
						OnGetPlayerTradesResultEvent -= (PlayFabResultEvent<GetPlayerTradesResponse>)delegate87;
					}
				}
			}
			if (this.OnGetPlayFabIDsFromFacebookIDsRequestEvent != null)
			{
				invocationList = this.OnGetPlayFabIDsFromFacebookIDsRequestEvent.GetInvocationList();
				foreach (Delegate delegate88 in invocationList)
				{
					if (delegate88.Target == instance)
					{
						OnGetPlayFabIDsFromFacebookIDsRequestEvent -= (PlayFabRequestEvent<GetPlayFabIDsFromFacebookIDsRequest>)delegate88;
					}
				}
			}
			if (this.OnGetPlayFabIDsFromFacebookIDsResultEvent != null)
			{
				invocationList = this.OnGetPlayFabIDsFromFacebookIDsResultEvent.GetInvocationList();
				foreach (Delegate delegate89 in invocationList)
				{
					if (delegate89.Target == instance)
					{
						OnGetPlayFabIDsFromFacebookIDsResultEvent -= (PlayFabResultEvent<GetPlayFabIDsFromFacebookIDsResult>)delegate89;
					}
				}
			}
			if (this.OnGetPlayFabIDsFromFacebookInstantGamesIdsRequestEvent != null)
			{
				invocationList = this.OnGetPlayFabIDsFromFacebookInstantGamesIdsRequestEvent.GetInvocationList();
				foreach (Delegate delegate90 in invocationList)
				{
					if (delegate90.Target == instance)
					{
						OnGetPlayFabIDsFromFacebookInstantGamesIdsRequestEvent -= (PlayFabRequestEvent<GetPlayFabIDsFromFacebookInstantGamesIdsRequest>)delegate90;
					}
				}
			}
			if (this.OnGetPlayFabIDsFromFacebookInstantGamesIdsResultEvent != null)
			{
				invocationList = this.OnGetPlayFabIDsFromFacebookInstantGamesIdsResultEvent.GetInvocationList();
				foreach (Delegate delegate91 in invocationList)
				{
					if (delegate91.Target == instance)
					{
						OnGetPlayFabIDsFromFacebookInstantGamesIdsResultEvent -= (PlayFabResultEvent<GetPlayFabIDsFromFacebookInstantGamesIdsResult>)delegate91;
					}
				}
			}
			if (this.OnGetPlayFabIDsFromGameCenterIDsRequestEvent != null)
			{
				invocationList = this.OnGetPlayFabIDsFromGameCenterIDsRequestEvent.GetInvocationList();
				foreach (Delegate delegate92 in invocationList)
				{
					if (delegate92.Target == instance)
					{
						OnGetPlayFabIDsFromGameCenterIDsRequestEvent -= (PlayFabRequestEvent<GetPlayFabIDsFromGameCenterIDsRequest>)delegate92;
					}
				}
			}
			if (this.OnGetPlayFabIDsFromGameCenterIDsResultEvent != null)
			{
				invocationList = this.OnGetPlayFabIDsFromGameCenterIDsResultEvent.GetInvocationList();
				foreach (Delegate delegate93 in invocationList)
				{
					if (delegate93.Target == instance)
					{
						OnGetPlayFabIDsFromGameCenterIDsResultEvent -= (PlayFabResultEvent<GetPlayFabIDsFromGameCenterIDsResult>)delegate93;
					}
				}
			}
			if (this.OnGetPlayFabIDsFromGenericIDsRequestEvent != null)
			{
				invocationList = this.OnGetPlayFabIDsFromGenericIDsRequestEvent.GetInvocationList();
				foreach (Delegate delegate94 in invocationList)
				{
					if (delegate94.Target == instance)
					{
						OnGetPlayFabIDsFromGenericIDsRequestEvent -= (PlayFabRequestEvent<GetPlayFabIDsFromGenericIDsRequest>)delegate94;
					}
				}
			}
			if (this.OnGetPlayFabIDsFromGenericIDsResultEvent != null)
			{
				invocationList = this.OnGetPlayFabIDsFromGenericIDsResultEvent.GetInvocationList();
				foreach (Delegate delegate95 in invocationList)
				{
					if (delegate95.Target == instance)
					{
						OnGetPlayFabIDsFromGenericIDsResultEvent -= (PlayFabResultEvent<GetPlayFabIDsFromGenericIDsResult>)delegate95;
					}
				}
			}
			if (this.OnGetPlayFabIDsFromGoogleIDsRequestEvent != null)
			{
				invocationList = this.OnGetPlayFabIDsFromGoogleIDsRequestEvent.GetInvocationList();
				foreach (Delegate delegate96 in invocationList)
				{
					if (delegate96.Target == instance)
					{
						OnGetPlayFabIDsFromGoogleIDsRequestEvent -= (PlayFabRequestEvent<GetPlayFabIDsFromGoogleIDsRequest>)delegate96;
					}
				}
			}
			if (this.OnGetPlayFabIDsFromGoogleIDsResultEvent != null)
			{
				invocationList = this.OnGetPlayFabIDsFromGoogleIDsResultEvent.GetInvocationList();
				foreach (Delegate delegate97 in invocationList)
				{
					if (delegate97.Target == instance)
					{
						OnGetPlayFabIDsFromGoogleIDsResultEvent -= (PlayFabResultEvent<GetPlayFabIDsFromGoogleIDsResult>)delegate97;
					}
				}
			}
			if (this.OnGetPlayFabIDsFromKongregateIDsRequestEvent != null)
			{
				invocationList = this.OnGetPlayFabIDsFromKongregateIDsRequestEvent.GetInvocationList();
				foreach (Delegate delegate98 in invocationList)
				{
					if (delegate98.Target == instance)
					{
						OnGetPlayFabIDsFromKongregateIDsRequestEvent -= (PlayFabRequestEvent<GetPlayFabIDsFromKongregateIDsRequest>)delegate98;
					}
				}
			}
			if (this.OnGetPlayFabIDsFromKongregateIDsResultEvent != null)
			{
				invocationList = this.OnGetPlayFabIDsFromKongregateIDsResultEvent.GetInvocationList();
				foreach (Delegate delegate99 in invocationList)
				{
					if (delegate99.Target == instance)
					{
						OnGetPlayFabIDsFromKongregateIDsResultEvent -= (PlayFabResultEvent<GetPlayFabIDsFromKongregateIDsResult>)delegate99;
					}
				}
			}
			if (this.OnGetPlayFabIDsFromNintendoSwitchDeviceIdsRequestEvent != null)
			{
				invocationList = this.OnGetPlayFabIDsFromNintendoSwitchDeviceIdsRequestEvent.GetInvocationList();
				foreach (Delegate delegate100 in invocationList)
				{
					if (delegate100.Target == instance)
					{
						OnGetPlayFabIDsFromNintendoSwitchDeviceIdsRequestEvent -= (PlayFabRequestEvent<GetPlayFabIDsFromNintendoSwitchDeviceIdsRequest>)delegate100;
					}
				}
			}
			if (this.OnGetPlayFabIDsFromNintendoSwitchDeviceIdsResultEvent != null)
			{
				invocationList = this.OnGetPlayFabIDsFromNintendoSwitchDeviceIdsResultEvent.GetInvocationList();
				foreach (Delegate delegate101 in invocationList)
				{
					if (delegate101.Target == instance)
					{
						OnGetPlayFabIDsFromNintendoSwitchDeviceIdsResultEvent -= (PlayFabResultEvent<GetPlayFabIDsFromNintendoSwitchDeviceIdsResult>)delegate101;
					}
				}
			}
			if (this.OnGetPlayFabIDsFromPSNAccountIDsRequestEvent != null)
			{
				invocationList = this.OnGetPlayFabIDsFromPSNAccountIDsRequestEvent.GetInvocationList();
				foreach (Delegate delegate102 in invocationList)
				{
					if (delegate102.Target == instance)
					{
						OnGetPlayFabIDsFromPSNAccountIDsRequestEvent -= (PlayFabRequestEvent<GetPlayFabIDsFromPSNAccountIDsRequest>)delegate102;
					}
				}
			}
			if (this.OnGetPlayFabIDsFromPSNAccountIDsResultEvent != null)
			{
				invocationList = this.OnGetPlayFabIDsFromPSNAccountIDsResultEvent.GetInvocationList();
				foreach (Delegate delegate103 in invocationList)
				{
					if (delegate103.Target == instance)
					{
						OnGetPlayFabIDsFromPSNAccountIDsResultEvent -= (PlayFabResultEvent<GetPlayFabIDsFromPSNAccountIDsResult>)delegate103;
					}
				}
			}
			if (this.OnGetPlayFabIDsFromSteamIDsRequestEvent != null)
			{
				invocationList = this.OnGetPlayFabIDsFromSteamIDsRequestEvent.GetInvocationList();
				foreach (Delegate delegate104 in invocationList)
				{
					if (delegate104.Target == instance)
					{
						OnGetPlayFabIDsFromSteamIDsRequestEvent -= (PlayFabRequestEvent<GetPlayFabIDsFromSteamIDsRequest>)delegate104;
					}
				}
			}
			if (this.OnGetPlayFabIDsFromSteamIDsResultEvent != null)
			{
				invocationList = this.OnGetPlayFabIDsFromSteamIDsResultEvent.GetInvocationList();
				foreach (Delegate delegate105 in invocationList)
				{
					if (delegate105.Target == instance)
					{
						OnGetPlayFabIDsFromSteamIDsResultEvent -= (PlayFabResultEvent<GetPlayFabIDsFromSteamIDsResult>)delegate105;
					}
				}
			}
			if (this.OnGetPlayFabIDsFromTwitchIDsRequestEvent != null)
			{
				invocationList = this.OnGetPlayFabIDsFromTwitchIDsRequestEvent.GetInvocationList();
				foreach (Delegate delegate106 in invocationList)
				{
					if (delegate106.Target == instance)
					{
						OnGetPlayFabIDsFromTwitchIDsRequestEvent -= (PlayFabRequestEvent<GetPlayFabIDsFromTwitchIDsRequest>)delegate106;
					}
				}
			}
			if (this.OnGetPlayFabIDsFromTwitchIDsResultEvent != null)
			{
				invocationList = this.OnGetPlayFabIDsFromTwitchIDsResultEvent.GetInvocationList();
				foreach (Delegate delegate107 in invocationList)
				{
					if (delegate107.Target == instance)
					{
						OnGetPlayFabIDsFromTwitchIDsResultEvent -= (PlayFabResultEvent<GetPlayFabIDsFromTwitchIDsResult>)delegate107;
					}
				}
			}
			if (this.OnGetPlayFabIDsFromXboxLiveIDsRequestEvent != null)
			{
				invocationList = this.OnGetPlayFabIDsFromXboxLiveIDsRequestEvent.GetInvocationList();
				foreach (Delegate delegate108 in invocationList)
				{
					if (delegate108.Target == instance)
					{
						OnGetPlayFabIDsFromXboxLiveIDsRequestEvent -= (PlayFabRequestEvent<GetPlayFabIDsFromXboxLiveIDsRequest>)delegate108;
					}
				}
			}
			if (this.OnGetPlayFabIDsFromXboxLiveIDsResultEvent != null)
			{
				invocationList = this.OnGetPlayFabIDsFromXboxLiveIDsResultEvent.GetInvocationList();
				foreach (Delegate delegate109 in invocationList)
				{
					if (delegate109.Target == instance)
					{
						OnGetPlayFabIDsFromXboxLiveIDsResultEvent -= (PlayFabResultEvent<GetPlayFabIDsFromXboxLiveIDsResult>)delegate109;
					}
				}
			}
			if (this.OnGetPublisherDataRequestEvent != null)
			{
				invocationList = this.OnGetPublisherDataRequestEvent.GetInvocationList();
				foreach (Delegate delegate110 in invocationList)
				{
					if (delegate110.Target == instance)
					{
						OnGetPublisherDataRequestEvent -= (PlayFabRequestEvent<GetPublisherDataRequest>)delegate110;
					}
				}
			}
			if (this.OnGetPublisherDataResultEvent != null)
			{
				invocationList = this.OnGetPublisherDataResultEvent.GetInvocationList();
				foreach (Delegate delegate111 in invocationList)
				{
					if (delegate111.Target == instance)
					{
						OnGetPublisherDataResultEvent -= (PlayFabResultEvent<GetPublisherDataResult>)delegate111;
					}
				}
			}
			if (this.OnGetPurchaseRequestEvent != null)
			{
				invocationList = this.OnGetPurchaseRequestEvent.GetInvocationList();
				foreach (Delegate delegate112 in invocationList)
				{
					if (delegate112.Target == instance)
					{
						OnGetPurchaseRequestEvent -= (PlayFabRequestEvent<GetPurchaseRequest>)delegate112;
					}
				}
			}
			if (this.OnGetPurchaseResultEvent != null)
			{
				invocationList = this.OnGetPurchaseResultEvent.GetInvocationList();
				foreach (Delegate delegate113 in invocationList)
				{
					if (delegate113.Target == instance)
					{
						OnGetPurchaseResultEvent -= (PlayFabResultEvent<GetPurchaseResult>)delegate113;
					}
				}
			}
			if (this.OnGetSharedGroupDataRequestEvent != null)
			{
				invocationList = this.OnGetSharedGroupDataRequestEvent.GetInvocationList();
				foreach (Delegate delegate114 in invocationList)
				{
					if (delegate114.Target == instance)
					{
						OnGetSharedGroupDataRequestEvent -= (PlayFabRequestEvent<GetSharedGroupDataRequest>)delegate114;
					}
				}
			}
			if (this.OnGetSharedGroupDataResultEvent != null)
			{
				invocationList = this.OnGetSharedGroupDataResultEvent.GetInvocationList();
				foreach (Delegate delegate115 in invocationList)
				{
					if (delegate115.Target == instance)
					{
						OnGetSharedGroupDataResultEvent -= (PlayFabResultEvent<GetSharedGroupDataResult>)delegate115;
					}
				}
			}
			if (this.OnGetStoreItemsRequestEvent != null)
			{
				invocationList = this.OnGetStoreItemsRequestEvent.GetInvocationList();
				foreach (Delegate delegate116 in invocationList)
				{
					if (delegate116.Target == instance)
					{
						OnGetStoreItemsRequestEvent -= (PlayFabRequestEvent<GetStoreItemsRequest>)delegate116;
					}
				}
			}
			if (this.OnGetStoreItemsResultEvent != null)
			{
				invocationList = this.OnGetStoreItemsResultEvent.GetInvocationList();
				foreach (Delegate delegate117 in invocationList)
				{
					if (delegate117.Target == instance)
					{
						OnGetStoreItemsResultEvent -= (PlayFabResultEvent<GetStoreItemsResult>)delegate117;
					}
				}
			}
			if (this.OnGetTimeRequestEvent != null)
			{
				invocationList = this.OnGetTimeRequestEvent.GetInvocationList();
				foreach (Delegate delegate118 in invocationList)
				{
					if (delegate118.Target == instance)
					{
						OnGetTimeRequestEvent -= (PlayFabRequestEvent<GetTimeRequest>)delegate118;
					}
				}
			}
			if (this.OnGetTimeResultEvent != null)
			{
				invocationList = this.OnGetTimeResultEvent.GetInvocationList();
				foreach (Delegate delegate119 in invocationList)
				{
					if (delegate119.Target == instance)
					{
						OnGetTimeResultEvent -= (PlayFabResultEvent<GetTimeResult>)delegate119;
					}
				}
			}
			if (this.OnGetTitleDataRequestEvent != null)
			{
				invocationList = this.OnGetTitleDataRequestEvent.GetInvocationList();
				foreach (Delegate delegate120 in invocationList)
				{
					if (delegate120.Target == instance)
					{
						OnGetTitleDataRequestEvent -= (PlayFabRequestEvent<GetTitleDataRequest>)delegate120;
					}
				}
			}
			if (this.OnGetTitleDataResultEvent != null)
			{
				invocationList = this.OnGetTitleDataResultEvent.GetInvocationList();
				foreach (Delegate delegate121 in invocationList)
				{
					if (delegate121.Target == instance)
					{
						OnGetTitleDataResultEvent -= (PlayFabResultEvent<GetTitleDataResult>)delegate121;
					}
				}
			}
			if (this.OnGetTitleNewsRequestEvent != null)
			{
				invocationList = this.OnGetTitleNewsRequestEvent.GetInvocationList();
				foreach (Delegate delegate122 in invocationList)
				{
					if (delegate122.Target == instance)
					{
						OnGetTitleNewsRequestEvent -= (PlayFabRequestEvent<GetTitleNewsRequest>)delegate122;
					}
				}
			}
			if (this.OnGetTitleNewsResultEvent != null)
			{
				invocationList = this.OnGetTitleNewsResultEvent.GetInvocationList();
				foreach (Delegate delegate123 in invocationList)
				{
					if (delegate123.Target == instance)
					{
						OnGetTitleNewsResultEvent -= (PlayFabResultEvent<GetTitleNewsResult>)delegate123;
					}
				}
			}
			if (this.OnGetTitlePublicKeyRequestEvent != null)
			{
				invocationList = this.OnGetTitlePublicKeyRequestEvent.GetInvocationList();
				foreach (Delegate delegate124 in invocationList)
				{
					if (delegate124.Target == instance)
					{
						OnGetTitlePublicKeyRequestEvent -= (PlayFabRequestEvent<GetTitlePublicKeyRequest>)delegate124;
					}
				}
			}
			if (this.OnGetTitlePublicKeyResultEvent != null)
			{
				invocationList = this.OnGetTitlePublicKeyResultEvent.GetInvocationList();
				foreach (Delegate delegate125 in invocationList)
				{
					if (delegate125.Target == instance)
					{
						OnGetTitlePublicKeyResultEvent -= (PlayFabResultEvent<GetTitlePublicKeyResult>)delegate125;
					}
				}
			}
			if (this.OnGetTradeStatusRequestEvent != null)
			{
				invocationList = this.OnGetTradeStatusRequestEvent.GetInvocationList();
				foreach (Delegate delegate126 in invocationList)
				{
					if (delegate126.Target == instance)
					{
						OnGetTradeStatusRequestEvent -= (PlayFabRequestEvent<GetTradeStatusRequest>)delegate126;
					}
				}
			}
			if (this.OnGetTradeStatusResultEvent != null)
			{
				invocationList = this.OnGetTradeStatusResultEvent.GetInvocationList();
				foreach (Delegate delegate127 in invocationList)
				{
					if (delegate127.Target == instance)
					{
						OnGetTradeStatusResultEvent -= (PlayFabResultEvent<GetTradeStatusResponse>)delegate127;
					}
				}
			}
			if (this.OnGetUserDataRequestEvent != null)
			{
				invocationList = this.OnGetUserDataRequestEvent.GetInvocationList();
				foreach (Delegate delegate128 in invocationList)
				{
					if (delegate128.Target == instance)
					{
						OnGetUserDataRequestEvent -= (PlayFabRequestEvent<GetUserDataRequest>)delegate128;
					}
				}
			}
			if (this.OnGetUserDataResultEvent != null)
			{
				invocationList = this.OnGetUserDataResultEvent.GetInvocationList();
				foreach (Delegate delegate129 in invocationList)
				{
					if (delegate129.Target == instance)
					{
						OnGetUserDataResultEvent -= (PlayFabResultEvent<GetUserDataResult>)delegate129;
					}
				}
			}
			if (this.OnGetUserInventoryRequestEvent != null)
			{
				invocationList = this.OnGetUserInventoryRequestEvent.GetInvocationList();
				foreach (Delegate delegate130 in invocationList)
				{
					if (delegate130.Target == instance)
					{
						OnGetUserInventoryRequestEvent -= (PlayFabRequestEvent<GetUserInventoryRequest>)delegate130;
					}
				}
			}
			if (this.OnGetUserInventoryResultEvent != null)
			{
				invocationList = this.OnGetUserInventoryResultEvent.GetInvocationList();
				foreach (Delegate delegate131 in invocationList)
				{
					if (delegate131.Target == instance)
					{
						OnGetUserInventoryResultEvent -= (PlayFabResultEvent<GetUserInventoryResult>)delegate131;
					}
				}
			}
			if (this.OnGetUserPublisherDataRequestEvent != null)
			{
				invocationList = this.OnGetUserPublisherDataRequestEvent.GetInvocationList();
				foreach (Delegate delegate132 in invocationList)
				{
					if (delegate132.Target == instance)
					{
						OnGetUserPublisherDataRequestEvent -= (PlayFabRequestEvent<GetUserDataRequest>)delegate132;
					}
				}
			}
			if (this.OnGetUserPublisherDataResultEvent != null)
			{
				invocationList = this.OnGetUserPublisherDataResultEvent.GetInvocationList();
				foreach (Delegate delegate133 in invocationList)
				{
					if (delegate133.Target == instance)
					{
						OnGetUserPublisherDataResultEvent -= (PlayFabResultEvent<GetUserDataResult>)delegate133;
					}
				}
			}
			if (this.OnGetUserPublisherReadOnlyDataRequestEvent != null)
			{
				invocationList = this.OnGetUserPublisherReadOnlyDataRequestEvent.GetInvocationList();
				foreach (Delegate delegate134 in invocationList)
				{
					if (delegate134.Target == instance)
					{
						OnGetUserPublisherReadOnlyDataRequestEvent -= (PlayFabRequestEvent<GetUserDataRequest>)delegate134;
					}
				}
			}
			if (this.OnGetUserPublisherReadOnlyDataResultEvent != null)
			{
				invocationList = this.OnGetUserPublisherReadOnlyDataResultEvent.GetInvocationList();
				foreach (Delegate delegate135 in invocationList)
				{
					if (delegate135.Target == instance)
					{
						OnGetUserPublisherReadOnlyDataResultEvent -= (PlayFabResultEvent<GetUserDataResult>)delegate135;
					}
				}
			}
			if (this.OnGetUserReadOnlyDataRequestEvent != null)
			{
				invocationList = this.OnGetUserReadOnlyDataRequestEvent.GetInvocationList();
				foreach (Delegate delegate136 in invocationList)
				{
					if (delegate136.Target == instance)
					{
						OnGetUserReadOnlyDataRequestEvent -= (PlayFabRequestEvent<GetUserDataRequest>)delegate136;
					}
				}
			}
			if (this.OnGetUserReadOnlyDataResultEvent != null)
			{
				invocationList = this.OnGetUserReadOnlyDataResultEvent.GetInvocationList();
				foreach (Delegate delegate137 in invocationList)
				{
					if (delegate137.Target == instance)
					{
						OnGetUserReadOnlyDataResultEvent -= (PlayFabResultEvent<GetUserDataResult>)delegate137;
					}
				}
			}
			if (this.OnGetWindowsHelloChallengeRequestEvent != null)
			{
				invocationList = this.OnGetWindowsHelloChallengeRequestEvent.GetInvocationList();
				foreach (Delegate delegate138 in invocationList)
				{
					if (delegate138.Target == instance)
					{
						OnGetWindowsHelloChallengeRequestEvent -= (PlayFabRequestEvent<GetWindowsHelloChallengeRequest>)delegate138;
					}
				}
			}
			if (this.OnGetWindowsHelloChallengeResultEvent != null)
			{
				invocationList = this.OnGetWindowsHelloChallengeResultEvent.GetInvocationList();
				foreach (Delegate delegate139 in invocationList)
				{
					if (delegate139.Target == instance)
					{
						OnGetWindowsHelloChallengeResultEvent -= (PlayFabResultEvent<GetWindowsHelloChallengeResponse>)delegate139;
					}
				}
			}
			if (this.OnGrantCharacterToUserRequestEvent != null)
			{
				invocationList = this.OnGrantCharacterToUserRequestEvent.GetInvocationList();
				foreach (Delegate delegate140 in invocationList)
				{
					if (delegate140.Target == instance)
					{
						OnGrantCharacterToUserRequestEvent -= (PlayFabRequestEvent<GrantCharacterToUserRequest>)delegate140;
					}
				}
			}
			if (this.OnGrantCharacterToUserResultEvent != null)
			{
				invocationList = this.OnGrantCharacterToUserResultEvent.GetInvocationList();
				foreach (Delegate delegate141 in invocationList)
				{
					if (delegate141.Target == instance)
					{
						OnGrantCharacterToUserResultEvent -= (PlayFabResultEvent<GrantCharacterToUserResult>)delegate141;
					}
				}
			}
			if (this.OnLinkAndroidDeviceIDRequestEvent != null)
			{
				invocationList = this.OnLinkAndroidDeviceIDRequestEvent.GetInvocationList();
				foreach (Delegate delegate142 in invocationList)
				{
					if (delegate142.Target == instance)
					{
						OnLinkAndroidDeviceIDRequestEvent -= (PlayFabRequestEvent<LinkAndroidDeviceIDRequest>)delegate142;
					}
				}
			}
			if (this.OnLinkAndroidDeviceIDResultEvent != null)
			{
				invocationList = this.OnLinkAndroidDeviceIDResultEvent.GetInvocationList();
				foreach (Delegate delegate143 in invocationList)
				{
					if (delegate143.Target == instance)
					{
						OnLinkAndroidDeviceIDResultEvent -= (PlayFabResultEvent<LinkAndroidDeviceIDResult>)delegate143;
					}
				}
			}
			if (this.OnLinkCustomIDRequestEvent != null)
			{
				invocationList = this.OnLinkCustomIDRequestEvent.GetInvocationList();
				foreach (Delegate delegate144 in invocationList)
				{
					if (delegate144.Target == instance)
					{
						OnLinkCustomIDRequestEvent -= (PlayFabRequestEvent<LinkCustomIDRequest>)delegate144;
					}
				}
			}
			if (this.OnLinkCustomIDResultEvent != null)
			{
				invocationList = this.OnLinkCustomIDResultEvent.GetInvocationList();
				foreach (Delegate delegate145 in invocationList)
				{
					if (delegate145.Target == instance)
					{
						OnLinkCustomIDResultEvent -= (PlayFabResultEvent<LinkCustomIDResult>)delegate145;
					}
				}
			}
			if (this.OnLinkFacebookAccountRequestEvent != null)
			{
				invocationList = this.OnLinkFacebookAccountRequestEvent.GetInvocationList();
				foreach (Delegate delegate146 in invocationList)
				{
					if (delegate146.Target == instance)
					{
						OnLinkFacebookAccountRequestEvent -= (PlayFabRequestEvent<LinkFacebookAccountRequest>)delegate146;
					}
				}
			}
			if (this.OnLinkFacebookAccountResultEvent != null)
			{
				invocationList = this.OnLinkFacebookAccountResultEvent.GetInvocationList();
				foreach (Delegate delegate147 in invocationList)
				{
					if (delegate147.Target == instance)
					{
						OnLinkFacebookAccountResultEvent -= (PlayFabResultEvent<LinkFacebookAccountResult>)delegate147;
					}
				}
			}
			if (this.OnLinkFacebookInstantGamesIdRequestEvent != null)
			{
				invocationList = this.OnLinkFacebookInstantGamesIdRequestEvent.GetInvocationList();
				foreach (Delegate delegate148 in invocationList)
				{
					if (delegate148.Target == instance)
					{
						OnLinkFacebookInstantGamesIdRequestEvent -= (PlayFabRequestEvent<LinkFacebookInstantGamesIdRequest>)delegate148;
					}
				}
			}
			if (this.OnLinkFacebookInstantGamesIdResultEvent != null)
			{
				invocationList = this.OnLinkFacebookInstantGamesIdResultEvent.GetInvocationList();
				foreach (Delegate delegate149 in invocationList)
				{
					if (delegate149.Target == instance)
					{
						OnLinkFacebookInstantGamesIdResultEvent -= (PlayFabResultEvent<LinkFacebookInstantGamesIdResult>)delegate149;
					}
				}
			}
			if (this.OnLinkGameCenterAccountRequestEvent != null)
			{
				invocationList = this.OnLinkGameCenterAccountRequestEvent.GetInvocationList();
				foreach (Delegate delegate150 in invocationList)
				{
					if (delegate150.Target == instance)
					{
						OnLinkGameCenterAccountRequestEvent -= (PlayFabRequestEvent<LinkGameCenterAccountRequest>)delegate150;
					}
				}
			}
			if (this.OnLinkGameCenterAccountResultEvent != null)
			{
				invocationList = this.OnLinkGameCenterAccountResultEvent.GetInvocationList();
				foreach (Delegate delegate151 in invocationList)
				{
					if (delegate151.Target == instance)
					{
						OnLinkGameCenterAccountResultEvent -= (PlayFabResultEvent<LinkGameCenterAccountResult>)delegate151;
					}
				}
			}
			if (this.OnLinkGoogleAccountRequestEvent != null)
			{
				invocationList = this.OnLinkGoogleAccountRequestEvent.GetInvocationList();
				foreach (Delegate delegate152 in invocationList)
				{
					if (delegate152.Target == instance)
					{
						OnLinkGoogleAccountRequestEvent -= (PlayFabRequestEvent<LinkGoogleAccountRequest>)delegate152;
					}
				}
			}
			if (this.OnLinkGoogleAccountResultEvent != null)
			{
				invocationList = this.OnLinkGoogleAccountResultEvent.GetInvocationList();
				foreach (Delegate delegate153 in invocationList)
				{
					if (delegate153.Target == instance)
					{
						OnLinkGoogleAccountResultEvent -= (PlayFabResultEvent<LinkGoogleAccountResult>)delegate153;
					}
				}
			}
			if (this.OnLinkIOSDeviceIDRequestEvent != null)
			{
				invocationList = this.OnLinkIOSDeviceIDRequestEvent.GetInvocationList();
				foreach (Delegate delegate154 in invocationList)
				{
					if (delegate154.Target == instance)
					{
						OnLinkIOSDeviceIDRequestEvent -= (PlayFabRequestEvent<LinkIOSDeviceIDRequest>)delegate154;
					}
				}
			}
			if (this.OnLinkIOSDeviceIDResultEvent != null)
			{
				invocationList = this.OnLinkIOSDeviceIDResultEvent.GetInvocationList();
				foreach (Delegate delegate155 in invocationList)
				{
					if (delegate155.Target == instance)
					{
						OnLinkIOSDeviceIDResultEvent -= (PlayFabResultEvent<LinkIOSDeviceIDResult>)delegate155;
					}
				}
			}
			if (this.OnLinkKongregateRequestEvent != null)
			{
				invocationList = this.OnLinkKongregateRequestEvent.GetInvocationList();
				foreach (Delegate delegate156 in invocationList)
				{
					if (delegate156.Target == instance)
					{
						OnLinkKongregateRequestEvent -= (PlayFabRequestEvent<LinkKongregateAccountRequest>)delegate156;
					}
				}
			}
			if (this.OnLinkKongregateResultEvent != null)
			{
				invocationList = this.OnLinkKongregateResultEvent.GetInvocationList();
				foreach (Delegate delegate157 in invocationList)
				{
					if (delegate157.Target == instance)
					{
						OnLinkKongregateResultEvent -= (PlayFabResultEvent<LinkKongregateAccountResult>)delegate157;
					}
				}
			}
			if (this.OnLinkNintendoSwitchDeviceIdRequestEvent != null)
			{
				invocationList = this.OnLinkNintendoSwitchDeviceIdRequestEvent.GetInvocationList();
				foreach (Delegate delegate158 in invocationList)
				{
					if (delegate158.Target == instance)
					{
						OnLinkNintendoSwitchDeviceIdRequestEvent -= (PlayFabRequestEvent<LinkNintendoSwitchDeviceIdRequest>)delegate158;
					}
				}
			}
			if (this.OnLinkNintendoSwitchDeviceIdResultEvent != null)
			{
				invocationList = this.OnLinkNintendoSwitchDeviceIdResultEvent.GetInvocationList();
				foreach (Delegate delegate159 in invocationList)
				{
					if (delegate159.Target == instance)
					{
						OnLinkNintendoSwitchDeviceIdResultEvent -= (PlayFabResultEvent<LinkNintendoSwitchDeviceIdResult>)delegate159;
					}
				}
			}
			if (this.OnLinkOpenIdConnectRequestEvent != null)
			{
				invocationList = this.OnLinkOpenIdConnectRequestEvent.GetInvocationList();
				foreach (Delegate delegate160 in invocationList)
				{
					if (delegate160.Target == instance)
					{
						OnLinkOpenIdConnectRequestEvent -= (PlayFabRequestEvent<LinkOpenIdConnectRequest>)delegate160;
					}
				}
			}
			if (this.OnLinkOpenIdConnectResultEvent != null)
			{
				invocationList = this.OnLinkOpenIdConnectResultEvent.GetInvocationList();
				foreach (Delegate delegate161 in invocationList)
				{
					if (delegate161.Target == instance)
					{
						OnLinkOpenIdConnectResultEvent -= (PlayFabResultEvent<EmptyResult>)delegate161;
					}
				}
			}
			if (this.OnLinkPSNAccountRequestEvent != null)
			{
				invocationList = this.OnLinkPSNAccountRequestEvent.GetInvocationList();
				foreach (Delegate delegate162 in invocationList)
				{
					if (delegate162.Target == instance)
					{
						OnLinkPSNAccountRequestEvent -= (PlayFabRequestEvent<LinkPSNAccountRequest>)delegate162;
					}
				}
			}
			if (this.OnLinkPSNAccountResultEvent != null)
			{
				invocationList = this.OnLinkPSNAccountResultEvent.GetInvocationList();
				foreach (Delegate delegate163 in invocationList)
				{
					if (delegate163.Target == instance)
					{
						OnLinkPSNAccountResultEvent -= (PlayFabResultEvent<LinkPSNAccountResult>)delegate163;
					}
				}
			}
			if (this.OnLinkSteamAccountRequestEvent != null)
			{
				invocationList = this.OnLinkSteamAccountRequestEvent.GetInvocationList();
				foreach (Delegate delegate164 in invocationList)
				{
					if (delegate164.Target == instance)
					{
						OnLinkSteamAccountRequestEvent -= (PlayFabRequestEvent<LinkSteamAccountRequest>)delegate164;
					}
				}
			}
			if (this.OnLinkSteamAccountResultEvent != null)
			{
				invocationList = this.OnLinkSteamAccountResultEvent.GetInvocationList();
				foreach (Delegate delegate165 in invocationList)
				{
					if (delegate165.Target == instance)
					{
						OnLinkSteamAccountResultEvent -= (PlayFabResultEvent<LinkSteamAccountResult>)delegate165;
					}
				}
			}
			if (this.OnLinkTwitchRequestEvent != null)
			{
				invocationList = this.OnLinkTwitchRequestEvent.GetInvocationList();
				foreach (Delegate delegate166 in invocationList)
				{
					if (delegate166.Target == instance)
					{
						OnLinkTwitchRequestEvent -= (PlayFabRequestEvent<LinkTwitchAccountRequest>)delegate166;
					}
				}
			}
			if (this.OnLinkTwitchResultEvent != null)
			{
				invocationList = this.OnLinkTwitchResultEvent.GetInvocationList();
				foreach (Delegate delegate167 in invocationList)
				{
					if (delegate167.Target == instance)
					{
						OnLinkTwitchResultEvent -= (PlayFabResultEvent<LinkTwitchAccountResult>)delegate167;
					}
				}
			}
			if (this.OnLinkWindowsHelloRequestEvent != null)
			{
				invocationList = this.OnLinkWindowsHelloRequestEvent.GetInvocationList();
				foreach (Delegate delegate168 in invocationList)
				{
					if (delegate168.Target == instance)
					{
						OnLinkWindowsHelloRequestEvent -= (PlayFabRequestEvent<LinkWindowsHelloAccountRequest>)delegate168;
					}
				}
			}
			if (this.OnLinkWindowsHelloResultEvent != null)
			{
				invocationList = this.OnLinkWindowsHelloResultEvent.GetInvocationList();
				foreach (Delegate delegate169 in invocationList)
				{
					if (delegate169.Target == instance)
					{
						OnLinkWindowsHelloResultEvent -= (PlayFabResultEvent<LinkWindowsHelloAccountResponse>)delegate169;
					}
				}
			}
			if (this.OnLinkXboxAccountRequestEvent != null)
			{
				invocationList = this.OnLinkXboxAccountRequestEvent.GetInvocationList();
				foreach (Delegate delegate170 in invocationList)
				{
					if (delegate170.Target == instance)
					{
						OnLinkXboxAccountRequestEvent -= (PlayFabRequestEvent<LinkXboxAccountRequest>)delegate170;
					}
				}
			}
			if (this.OnLinkXboxAccountResultEvent != null)
			{
				invocationList = this.OnLinkXboxAccountResultEvent.GetInvocationList();
				foreach (Delegate delegate171 in invocationList)
				{
					if (delegate171.Target == instance)
					{
						OnLinkXboxAccountResultEvent -= (PlayFabResultEvent<LinkXboxAccountResult>)delegate171;
					}
				}
			}
			if (this.OnLoginWithAndroidDeviceIDRequestEvent != null)
			{
				invocationList = this.OnLoginWithAndroidDeviceIDRequestEvent.GetInvocationList();
				foreach (Delegate delegate172 in invocationList)
				{
					if (delegate172.Target == instance)
					{
						OnLoginWithAndroidDeviceIDRequestEvent -= (PlayFabRequestEvent<LoginWithAndroidDeviceIDRequest>)delegate172;
					}
				}
			}
			if (this.OnLoginWithCustomIDRequestEvent != null)
			{
				invocationList = this.OnLoginWithCustomIDRequestEvent.GetInvocationList();
				foreach (Delegate delegate173 in invocationList)
				{
					if (delegate173.Target == instance)
					{
						OnLoginWithCustomIDRequestEvent -= (PlayFabRequestEvent<LoginWithCustomIDRequest>)delegate173;
					}
				}
			}
			if (this.OnLoginWithEmailAddressRequestEvent != null)
			{
				invocationList = this.OnLoginWithEmailAddressRequestEvent.GetInvocationList();
				foreach (Delegate delegate174 in invocationList)
				{
					if (delegate174.Target == instance)
					{
						OnLoginWithEmailAddressRequestEvent -= (PlayFabRequestEvent<LoginWithEmailAddressRequest>)delegate174;
					}
				}
			}
			if (this.OnLoginWithFacebookRequestEvent != null)
			{
				invocationList = this.OnLoginWithFacebookRequestEvent.GetInvocationList();
				foreach (Delegate delegate175 in invocationList)
				{
					if (delegate175.Target == instance)
					{
						OnLoginWithFacebookRequestEvent -= (PlayFabRequestEvent<LoginWithFacebookRequest>)delegate175;
					}
				}
			}
			if (this.OnLoginWithFacebookInstantGamesIdRequestEvent != null)
			{
				invocationList = this.OnLoginWithFacebookInstantGamesIdRequestEvent.GetInvocationList();
				foreach (Delegate delegate176 in invocationList)
				{
					if (delegate176.Target == instance)
					{
						OnLoginWithFacebookInstantGamesIdRequestEvent -= (PlayFabRequestEvent<LoginWithFacebookInstantGamesIdRequest>)delegate176;
					}
				}
			}
			if (this.OnLoginWithGameCenterRequestEvent != null)
			{
				invocationList = this.OnLoginWithGameCenterRequestEvent.GetInvocationList();
				foreach (Delegate delegate177 in invocationList)
				{
					if (delegate177.Target == instance)
					{
						OnLoginWithGameCenterRequestEvent -= (PlayFabRequestEvent<LoginWithGameCenterRequest>)delegate177;
					}
				}
			}
			if (this.OnLoginWithGoogleAccountRequestEvent != null)
			{
				invocationList = this.OnLoginWithGoogleAccountRequestEvent.GetInvocationList();
				foreach (Delegate delegate178 in invocationList)
				{
					if (delegate178.Target == instance)
					{
						OnLoginWithGoogleAccountRequestEvent -= (PlayFabRequestEvent<LoginWithGoogleAccountRequest>)delegate178;
					}
				}
			}
			if (this.OnLoginWithIOSDeviceIDRequestEvent != null)
			{
				invocationList = this.OnLoginWithIOSDeviceIDRequestEvent.GetInvocationList();
				foreach (Delegate delegate179 in invocationList)
				{
					if (delegate179.Target == instance)
					{
						OnLoginWithIOSDeviceIDRequestEvent -= (PlayFabRequestEvent<LoginWithIOSDeviceIDRequest>)delegate179;
					}
				}
			}
			if (this.OnLoginWithKongregateRequestEvent != null)
			{
				invocationList = this.OnLoginWithKongregateRequestEvent.GetInvocationList();
				foreach (Delegate delegate180 in invocationList)
				{
					if (delegate180.Target == instance)
					{
						OnLoginWithKongregateRequestEvent -= (PlayFabRequestEvent<LoginWithKongregateRequest>)delegate180;
					}
				}
			}
			if (this.OnLoginWithNintendoSwitchDeviceIdRequestEvent != null)
			{
				invocationList = this.OnLoginWithNintendoSwitchDeviceIdRequestEvent.GetInvocationList();
				foreach (Delegate delegate181 in invocationList)
				{
					if (delegate181.Target == instance)
					{
						OnLoginWithNintendoSwitchDeviceIdRequestEvent -= (PlayFabRequestEvent<LoginWithNintendoSwitchDeviceIdRequest>)delegate181;
					}
				}
			}
			if (this.OnLoginWithOpenIdConnectRequestEvent != null)
			{
				invocationList = this.OnLoginWithOpenIdConnectRequestEvent.GetInvocationList();
				foreach (Delegate delegate182 in invocationList)
				{
					if (delegate182.Target == instance)
					{
						OnLoginWithOpenIdConnectRequestEvent -= (PlayFabRequestEvent<LoginWithOpenIdConnectRequest>)delegate182;
					}
				}
			}
			if (this.OnLoginWithPlayFabRequestEvent != null)
			{
				invocationList = this.OnLoginWithPlayFabRequestEvent.GetInvocationList();
				foreach (Delegate delegate183 in invocationList)
				{
					if (delegate183.Target == instance)
					{
						OnLoginWithPlayFabRequestEvent -= (PlayFabRequestEvent<LoginWithPlayFabRequest>)delegate183;
					}
				}
			}
			if (this.OnLoginWithPSNRequestEvent != null)
			{
				invocationList = this.OnLoginWithPSNRequestEvent.GetInvocationList();
				foreach (Delegate delegate184 in invocationList)
				{
					if (delegate184.Target == instance)
					{
						OnLoginWithPSNRequestEvent -= (PlayFabRequestEvent<LoginWithPSNRequest>)delegate184;
					}
				}
			}
			if (this.OnLoginWithSteamRequestEvent != null)
			{
				invocationList = this.OnLoginWithSteamRequestEvent.GetInvocationList();
				foreach (Delegate delegate185 in invocationList)
				{
					if (delegate185.Target == instance)
					{
						OnLoginWithSteamRequestEvent -= (PlayFabRequestEvent<LoginWithSteamRequest>)delegate185;
					}
				}
			}
			if (this.OnLoginWithTwitchRequestEvent != null)
			{
				invocationList = this.OnLoginWithTwitchRequestEvent.GetInvocationList();
				foreach (Delegate delegate186 in invocationList)
				{
					if (delegate186.Target == instance)
					{
						OnLoginWithTwitchRequestEvent -= (PlayFabRequestEvent<LoginWithTwitchRequest>)delegate186;
					}
				}
			}
			if (this.OnLoginWithWindowsHelloRequestEvent != null)
			{
				invocationList = this.OnLoginWithWindowsHelloRequestEvent.GetInvocationList();
				foreach (Delegate delegate187 in invocationList)
				{
					if (delegate187.Target == instance)
					{
						OnLoginWithWindowsHelloRequestEvent -= (PlayFabRequestEvent<LoginWithWindowsHelloRequest>)delegate187;
					}
				}
			}
			if (this.OnLoginWithXboxRequestEvent != null)
			{
				invocationList = this.OnLoginWithXboxRequestEvent.GetInvocationList();
				foreach (Delegate delegate188 in invocationList)
				{
					if (delegate188.Target == instance)
					{
						OnLoginWithXboxRequestEvent -= (PlayFabRequestEvent<LoginWithXboxRequest>)delegate188;
					}
				}
			}
			if (this.OnMatchmakeRequestEvent != null)
			{
				invocationList = this.OnMatchmakeRequestEvent.GetInvocationList();
				foreach (Delegate delegate189 in invocationList)
				{
					if (delegate189.Target == instance)
					{
						OnMatchmakeRequestEvent -= (PlayFabRequestEvent<MatchmakeRequest>)delegate189;
					}
				}
			}
			if (this.OnMatchmakeResultEvent != null)
			{
				invocationList = this.OnMatchmakeResultEvent.GetInvocationList();
				foreach (Delegate delegate190 in invocationList)
				{
					if (delegate190.Target == instance)
					{
						OnMatchmakeResultEvent -= (PlayFabResultEvent<MatchmakeResult>)delegate190;
					}
				}
			}
			if (this.OnOpenTradeRequestEvent != null)
			{
				invocationList = this.OnOpenTradeRequestEvent.GetInvocationList();
				foreach (Delegate delegate191 in invocationList)
				{
					if (delegate191.Target == instance)
					{
						OnOpenTradeRequestEvent -= (PlayFabRequestEvent<OpenTradeRequest>)delegate191;
					}
				}
			}
			if (this.OnOpenTradeResultEvent != null)
			{
				invocationList = this.OnOpenTradeResultEvent.GetInvocationList();
				foreach (Delegate delegate192 in invocationList)
				{
					if (delegate192.Target == instance)
					{
						OnOpenTradeResultEvent -= (PlayFabResultEvent<OpenTradeResponse>)delegate192;
					}
				}
			}
			if (this.OnPayForPurchaseRequestEvent != null)
			{
				invocationList = this.OnPayForPurchaseRequestEvent.GetInvocationList();
				foreach (Delegate delegate193 in invocationList)
				{
					if (delegate193.Target == instance)
					{
						OnPayForPurchaseRequestEvent -= (PlayFabRequestEvent<PayForPurchaseRequest>)delegate193;
					}
				}
			}
			if (this.OnPayForPurchaseResultEvent != null)
			{
				invocationList = this.OnPayForPurchaseResultEvent.GetInvocationList();
				foreach (Delegate delegate194 in invocationList)
				{
					if (delegate194.Target == instance)
					{
						OnPayForPurchaseResultEvent -= (PlayFabResultEvent<PayForPurchaseResult>)delegate194;
					}
				}
			}
			if (this.OnPurchaseItemRequestEvent != null)
			{
				invocationList = this.OnPurchaseItemRequestEvent.GetInvocationList();
				foreach (Delegate delegate195 in invocationList)
				{
					if (delegate195.Target == instance)
					{
						OnPurchaseItemRequestEvent -= (PlayFabRequestEvent<PurchaseItemRequest>)delegate195;
					}
				}
			}
			if (this.OnPurchaseItemResultEvent != null)
			{
				invocationList = this.OnPurchaseItemResultEvent.GetInvocationList();
				foreach (Delegate delegate196 in invocationList)
				{
					if (delegate196.Target == instance)
					{
						OnPurchaseItemResultEvent -= (PlayFabResultEvent<PurchaseItemResult>)delegate196;
					}
				}
			}
			if (this.OnRedeemCouponRequestEvent != null)
			{
				invocationList = this.OnRedeemCouponRequestEvent.GetInvocationList();
				foreach (Delegate delegate197 in invocationList)
				{
					if (delegate197.Target == instance)
					{
						OnRedeemCouponRequestEvent -= (PlayFabRequestEvent<RedeemCouponRequest>)delegate197;
					}
				}
			}
			if (this.OnRedeemCouponResultEvent != null)
			{
				invocationList = this.OnRedeemCouponResultEvent.GetInvocationList();
				foreach (Delegate delegate198 in invocationList)
				{
					if (delegate198.Target == instance)
					{
						OnRedeemCouponResultEvent -= (PlayFabResultEvent<RedeemCouponResult>)delegate198;
					}
				}
			}
			if (this.OnRefreshPSNAuthTokenRequestEvent != null)
			{
				invocationList = this.OnRefreshPSNAuthTokenRequestEvent.GetInvocationList();
				foreach (Delegate delegate199 in invocationList)
				{
					if (delegate199.Target == instance)
					{
						OnRefreshPSNAuthTokenRequestEvent -= (PlayFabRequestEvent<RefreshPSNAuthTokenRequest>)delegate199;
					}
				}
			}
			if (this.OnRefreshPSNAuthTokenResultEvent != null)
			{
				invocationList = this.OnRefreshPSNAuthTokenResultEvent.GetInvocationList();
				foreach (Delegate delegate200 in invocationList)
				{
					if (delegate200.Target == instance)
					{
						OnRefreshPSNAuthTokenResultEvent -= (PlayFabResultEvent<PlayFab.ClientModels.EmptyResponse>)delegate200;
					}
				}
			}
			if (this.OnRegisterForIOSPushNotificationRequestEvent != null)
			{
				invocationList = this.OnRegisterForIOSPushNotificationRequestEvent.GetInvocationList();
				foreach (Delegate delegate201 in invocationList)
				{
					if (delegate201.Target == instance)
					{
						OnRegisterForIOSPushNotificationRequestEvent -= (PlayFabRequestEvent<RegisterForIOSPushNotificationRequest>)delegate201;
					}
				}
			}
			if (this.OnRegisterForIOSPushNotificationResultEvent != null)
			{
				invocationList = this.OnRegisterForIOSPushNotificationResultEvent.GetInvocationList();
				foreach (Delegate delegate202 in invocationList)
				{
					if (delegate202.Target == instance)
					{
						OnRegisterForIOSPushNotificationResultEvent -= (PlayFabResultEvent<RegisterForIOSPushNotificationResult>)delegate202;
					}
				}
			}
			if (this.OnRegisterPlayFabUserRequestEvent != null)
			{
				invocationList = this.OnRegisterPlayFabUserRequestEvent.GetInvocationList();
				foreach (Delegate delegate203 in invocationList)
				{
					if (delegate203.Target == instance)
					{
						OnRegisterPlayFabUserRequestEvent -= (PlayFabRequestEvent<RegisterPlayFabUserRequest>)delegate203;
					}
				}
			}
			if (this.OnRegisterPlayFabUserResultEvent != null)
			{
				invocationList = this.OnRegisterPlayFabUserResultEvent.GetInvocationList();
				foreach (Delegate delegate204 in invocationList)
				{
					if (delegate204.Target == instance)
					{
						OnRegisterPlayFabUserResultEvent -= (PlayFabResultEvent<RegisterPlayFabUserResult>)delegate204;
					}
				}
			}
			if (this.OnRegisterWithWindowsHelloRequestEvent != null)
			{
				invocationList = this.OnRegisterWithWindowsHelloRequestEvent.GetInvocationList();
				foreach (Delegate delegate205 in invocationList)
				{
					if (delegate205.Target == instance)
					{
						OnRegisterWithWindowsHelloRequestEvent -= (PlayFabRequestEvent<RegisterWithWindowsHelloRequest>)delegate205;
					}
				}
			}
			if (this.OnRemoveContactEmailRequestEvent != null)
			{
				invocationList = this.OnRemoveContactEmailRequestEvent.GetInvocationList();
				foreach (Delegate delegate206 in invocationList)
				{
					if (delegate206.Target == instance)
					{
						OnRemoveContactEmailRequestEvent -= (PlayFabRequestEvent<RemoveContactEmailRequest>)delegate206;
					}
				}
			}
			if (this.OnRemoveContactEmailResultEvent != null)
			{
				invocationList = this.OnRemoveContactEmailResultEvent.GetInvocationList();
				foreach (Delegate delegate207 in invocationList)
				{
					if (delegate207.Target == instance)
					{
						OnRemoveContactEmailResultEvent -= (PlayFabResultEvent<RemoveContactEmailResult>)delegate207;
					}
				}
			}
			if (this.OnRemoveFriendRequestEvent != null)
			{
				invocationList = this.OnRemoveFriendRequestEvent.GetInvocationList();
				foreach (Delegate delegate208 in invocationList)
				{
					if (delegate208.Target == instance)
					{
						OnRemoveFriendRequestEvent -= (PlayFabRequestEvent<RemoveFriendRequest>)delegate208;
					}
				}
			}
			if (this.OnRemoveFriendResultEvent != null)
			{
				invocationList = this.OnRemoveFriendResultEvent.GetInvocationList();
				foreach (Delegate delegate209 in invocationList)
				{
					if (delegate209.Target == instance)
					{
						OnRemoveFriendResultEvent -= (PlayFabResultEvent<RemoveFriendResult>)delegate209;
					}
				}
			}
			if (this.OnRemoveGenericIDRequestEvent != null)
			{
				invocationList = this.OnRemoveGenericIDRequestEvent.GetInvocationList();
				foreach (Delegate delegate210 in invocationList)
				{
					if (delegate210.Target == instance)
					{
						OnRemoveGenericIDRequestEvent -= (PlayFabRequestEvent<RemoveGenericIDRequest>)delegate210;
					}
				}
			}
			if (this.OnRemoveGenericIDResultEvent != null)
			{
				invocationList = this.OnRemoveGenericIDResultEvent.GetInvocationList();
				foreach (Delegate delegate211 in invocationList)
				{
					if (delegate211.Target == instance)
					{
						OnRemoveGenericIDResultEvent -= (PlayFabResultEvent<RemoveGenericIDResult>)delegate211;
					}
				}
			}
			if (this.OnRemoveSharedGroupMembersRequestEvent != null)
			{
				invocationList = this.OnRemoveSharedGroupMembersRequestEvent.GetInvocationList();
				foreach (Delegate delegate212 in invocationList)
				{
					if (delegate212.Target == instance)
					{
						OnRemoveSharedGroupMembersRequestEvent -= (PlayFabRequestEvent<RemoveSharedGroupMembersRequest>)delegate212;
					}
				}
			}
			if (this.OnRemoveSharedGroupMembersResultEvent != null)
			{
				invocationList = this.OnRemoveSharedGroupMembersResultEvent.GetInvocationList();
				foreach (Delegate delegate213 in invocationList)
				{
					if (delegate213.Target == instance)
					{
						OnRemoveSharedGroupMembersResultEvent -= (PlayFabResultEvent<RemoveSharedGroupMembersResult>)delegate213;
					}
				}
			}
			if (this.OnReportDeviceInfoRequestEvent != null)
			{
				invocationList = this.OnReportDeviceInfoRequestEvent.GetInvocationList();
				foreach (Delegate delegate214 in invocationList)
				{
					if (delegate214.Target == instance)
					{
						OnReportDeviceInfoRequestEvent -= (PlayFabRequestEvent<DeviceInfoRequest>)delegate214;
					}
				}
			}
			if (this.OnReportDeviceInfoResultEvent != null)
			{
				invocationList = this.OnReportDeviceInfoResultEvent.GetInvocationList();
				foreach (Delegate delegate215 in invocationList)
				{
					if (delegate215.Target == instance)
					{
						OnReportDeviceInfoResultEvent -= (PlayFabResultEvent<PlayFab.ClientModels.EmptyResponse>)delegate215;
					}
				}
			}
			if (this.OnReportPlayerRequestEvent != null)
			{
				invocationList = this.OnReportPlayerRequestEvent.GetInvocationList();
				foreach (Delegate delegate216 in invocationList)
				{
					if (delegate216.Target == instance)
					{
						OnReportPlayerRequestEvent -= (PlayFabRequestEvent<ReportPlayerClientRequest>)delegate216;
					}
				}
			}
			if (this.OnReportPlayerResultEvent != null)
			{
				invocationList = this.OnReportPlayerResultEvent.GetInvocationList();
				foreach (Delegate delegate217 in invocationList)
				{
					if (delegate217.Target == instance)
					{
						OnReportPlayerResultEvent -= (PlayFabResultEvent<ReportPlayerClientResult>)delegate217;
					}
				}
			}
			if (this.OnRestoreIOSPurchasesRequestEvent != null)
			{
				invocationList = this.OnRestoreIOSPurchasesRequestEvent.GetInvocationList();
				foreach (Delegate delegate218 in invocationList)
				{
					if (delegate218.Target == instance)
					{
						OnRestoreIOSPurchasesRequestEvent -= (PlayFabRequestEvent<RestoreIOSPurchasesRequest>)delegate218;
					}
				}
			}
			if (this.OnRestoreIOSPurchasesResultEvent != null)
			{
				invocationList = this.OnRestoreIOSPurchasesResultEvent.GetInvocationList();
				foreach (Delegate delegate219 in invocationList)
				{
					if (delegate219.Target == instance)
					{
						OnRestoreIOSPurchasesResultEvent -= (PlayFabResultEvent<RestoreIOSPurchasesResult>)delegate219;
					}
				}
			}
			if (this.OnSendAccountRecoveryEmailRequestEvent != null)
			{
				invocationList = this.OnSendAccountRecoveryEmailRequestEvent.GetInvocationList();
				foreach (Delegate delegate220 in invocationList)
				{
					if (delegate220.Target == instance)
					{
						OnSendAccountRecoveryEmailRequestEvent -= (PlayFabRequestEvent<SendAccountRecoveryEmailRequest>)delegate220;
					}
				}
			}
			if (this.OnSendAccountRecoveryEmailResultEvent != null)
			{
				invocationList = this.OnSendAccountRecoveryEmailResultEvent.GetInvocationList();
				foreach (Delegate delegate221 in invocationList)
				{
					if (delegate221.Target == instance)
					{
						OnSendAccountRecoveryEmailResultEvent -= (PlayFabResultEvent<SendAccountRecoveryEmailResult>)delegate221;
					}
				}
			}
			if (this.OnSetFriendTagsRequestEvent != null)
			{
				invocationList = this.OnSetFriendTagsRequestEvent.GetInvocationList();
				foreach (Delegate delegate222 in invocationList)
				{
					if (delegate222.Target == instance)
					{
						OnSetFriendTagsRequestEvent -= (PlayFabRequestEvent<SetFriendTagsRequest>)delegate222;
					}
				}
			}
			if (this.OnSetFriendTagsResultEvent != null)
			{
				invocationList = this.OnSetFriendTagsResultEvent.GetInvocationList();
				foreach (Delegate delegate223 in invocationList)
				{
					if (delegate223.Target == instance)
					{
						OnSetFriendTagsResultEvent -= (PlayFabResultEvent<SetFriendTagsResult>)delegate223;
					}
				}
			}
			if (this.OnSetPlayerSecretRequestEvent != null)
			{
				invocationList = this.OnSetPlayerSecretRequestEvent.GetInvocationList();
				foreach (Delegate delegate224 in invocationList)
				{
					if (delegate224.Target == instance)
					{
						OnSetPlayerSecretRequestEvent -= (PlayFabRequestEvent<SetPlayerSecretRequest>)delegate224;
					}
				}
			}
			if (this.OnSetPlayerSecretResultEvent != null)
			{
				invocationList = this.OnSetPlayerSecretResultEvent.GetInvocationList();
				foreach (Delegate delegate225 in invocationList)
				{
					if (delegate225.Target == instance)
					{
						OnSetPlayerSecretResultEvent -= (PlayFabResultEvent<SetPlayerSecretResult>)delegate225;
					}
				}
			}
			if (this.OnStartGameRequestEvent != null)
			{
				invocationList = this.OnStartGameRequestEvent.GetInvocationList();
				foreach (Delegate delegate226 in invocationList)
				{
					if (delegate226.Target == instance)
					{
						OnStartGameRequestEvent -= (PlayFabRequestEvent<StartGameRequest>)delegate226;
					}
				}
			}
			if (this.OnStartGameResultEvent != null)
			{
				invocationList = this.OnStartGameResultEvent.GetInvocationList();
				foreach (Delegate delegate227 in invocationList)
				{
					if (delegate227.Target == instance)
					{
						OnStartGameResultEvent -= (PlayFabResultEvent<StartGameResult>)delegate227;
					}
				}
			}
			if (this.OnStartPurchaseRequestEvent != null)
			{
				invocationList = this.OnStartPurchaseRequestEvent.GetInvocationList();
				foreach (Delegate delegate228 in invocationList)
				{
					if (delegate228.Target == instance)
					{
						OnStartPurchaseRequestEvent -= (PlayFabRequestEvent<StartPurchaseRequest>)delegate228;
					}
				}
			}
			if (this.OnStartPurchaseResultEvent != null)
			{
				invocationList = this.OnStartPurchaseResultEvent.GetInvocationList();
				foreach (Delegate delegate229 in invocationList)
				{
					if (delegate229.Target == instance)
					{
						OnStartPurchaseResultEvent -= (PlayFabResultEvent<StartPurchaseResult>)delegate229;
					}
				}
			}
			if (this.OnSubtractUserVirtualCurrencyRequestEvent != null)
			{
				invocationList = this.OnSubtractUserVirtualCurrencyRequestEvent.GetInvocationList();
				foreach (Delegate delegate230 in invocationList)
				{
					if (delegate230.Target == instance)
					{
						OnSubtractUserVirtualCurrencyRequestEvent -= (PlayFabRequestEvent<SubtractUserVirtualCurrencyRequest>)delegate230;
					}
				}
			}
			if (this.OnSubtractUserVirtualCurrencyResultEvent != null)
			{
				invocationList = this.OnSubtractUserVirtualCurrencyResultEvent.GetInvocationList();
				foreach (Delegate delegate231 in invocationList)
				{
					if (delegate231.Target == instance)
					{
						OnSubtractUserVirtualCurrencyResultEvent -= (PlayFabResultEvent<ModifyUserVirtualCurrencyResult>)delegate231;
					}
				}
			}
			if (this.OnUnlinkAndroidDeviceIDRequestEvent != null)
			{
				invocationList = this.OnUnlinkAndroidDeviceIDRequestEvent.GetInvocationList();
				foreach (Delegate delegate232 in invocationList)
				{
					if (delegate232.Target == instance)
					{
						OnUnlinkAndroidDeviceIDRequestEvent -= (PlayFabRequestEvent<UnlinkAndroidDeviceIDRequest>)delegate232;
					}
				}
			}
			if (this.OnUnlinkAndroidDeviceIDResultEvent != null)
			{
				invocationList = this.OnUnlinkAndroidDeviceIDResultEvent.GetInvocationList();
				foreach (Delegate delegate233 in invocationList)
				{
					if (delegate233.Target == instance)
					{
						OnUnlinkAndroidDeviceIDResultEvent -= (PlayFabResultEvent<UnlinkAndroidDeviceIDResult>)delegate233;
					}
				}
			}
			if (this.OnUnlinkCustomIDRequestEvent != null)
			{
				invocationList = this.OnUnlinkCustomIDRequestEvent.GetInvocationList();
				foreach (Delegate delegate234 in invocationList)
				{
					if (delegate234.Target == instance)
					{
						OnUnlinkCustomIDRequestEvent -= (PlayFabRequestEvent<UnlinkCustomIDRequest>)delegate234;
					}
				}
			}
			if (this.OnUnlinkCustomIDResultEvent != null)
			{
				invocationList = this.OnUnlinkCustomIDResultEvent.GetInvocationList();
				foreach (Delegate delegate235 in invocationList)
				{
					if (delegate235.Target == instance)
					{
						OnUnlinkCustomIDResultEvent -= (PlayFabResultEvent<UnlinkCustomIDResult>)delegate235;
					}
				}
			}
			if (this.OnUnlinkFacebookAccountRequestEvent != null)
			{
				invocationList = this.OnUnlinkFacebookAccountRequestEvent.GetInvocationList();
				foreach (Delegate delegate236 in invocationList)
				{
					if (delegate236.Target == instance)
					{
						OnUnlinkFacebookAccountRequestEvent -= (PlayFabRequestEvent<UnlinkFacebookAccountRequest>)delegate236;
					}
				}
			}
			if (this.OnUnlinkFacebookAccountResultEvent != null)
			{
				invocationList = this.OnUnlinkFacebookAccountResultEvent.GetInvocationList();
				foreach (Delegate delegate237 in invocationList)
				{
					if (delegate237.Target == instance)
					{
						OnUnlinkFacebookAccountResultEvent -= (PlayFabResultEvent<UnlinkFacebookAccountResult>)delegate237;
					}
				}
			}
			if (this.OnUnlinkFacebookInstantGamesIdRequestEvent != null)
			{
				invocationList = this.OnUnlinkFacebookInstantGamesIdRequestEvent.GetInvocationList();
				foreach (Delegate delegate238 in invocationList)
				{
					if (delegate238.Target == instance)
					{
						OnUnlinkFacebookInstantGamesIdRequestEvent -= (PlayFabRequestEvent<UnlinkFacebookInstantGamesIdRequest>)delegate238;
					}
				}
			}
			if (this.OnUnlinkFacebookInstantGamesIdResultEvent != null)
			{
				invocationList = this.OnUnlinkFacebookInstantGamesIdResultEvent.GetInvocationList();
				foreach (Delegate delegate239 in invocationList)
				{
					if (delegate239.Target == instance)
					{
						OnUnlinkFacebookInstantGamesIdResultEvent -= (PlayFabResultEvent<UnlinkFacebookInstantGamesIdResult>)delegate239;
					}
				}
			}
			if (this.OnUnlinkGameCenterAccountRequestEvent != null)
			{
				invocationList = this.OnUnlinkGameCenterAccountRequestEvent.GetInvocationList();
				foreach (Delegate delegate240 in invocationList)
				{
					if (delegate240.Target == instance)
					{
						OnUnlinkGameCenterAccountRequestEvent -= (PlayFabRequestEvent<UnlinkGameCenterAccountRequest>)delegate240;
					}
				}
			}
			if (this.OnUnlinkGameCenterAccountResultEvent != null)
			{
				invocationList = this.OnUnlinkGameCenterAccountResultEvent.GetInvocationList();
				foreach (Delegate delegate241 in invocationList)
				{
					if (delegate241.Target == instance)
					{
						OnUnlinkGameCenterAccountResultEvent -= (PlayFabResultEvent<UnlinkGameCenterAccountResult>)delegate241;
					}
				}
			}
			if (this.OnUnlinkGoogleAccountRequestEvent != null)
			{
				invocationList = this.OnUnlinkGoogleAccountRequestEvent.GetInvocationList();
				foreach (Delegate delegate242 in invocationList)
				{
					if (delegate242.Target == instance)
					{
						OnUnlinkGoogleAccountRequestEvent -= (PlayFabRequestEvent<UnlinkGoogleAccountRequest>)delegate242;
					}
				}
			}
			if (this.OnUnlinkGoogleAccountResultEvent != null)
			{
				invocationList = this.OnUnlinkGoogleAccountResultEvent.GetInvocationList();
				foreach (Delegate delegate243 in invocationList)
				{
					if (delegate243.Target == instance)
					{
						OnUnlinkGoogleAccountResultEvent -= (PlayFabResultEvent<UnlinkGoogleAccountResult>)delegate243;
					}
				}
			}
			if (this.OnUnlinkIOSDeviceIDRequestEvent != null)
			{
				invocationList = this.OnUnlinkIOSDeviceIDRequestEvent.GetInvocationList();
				foreach (Delegate delegate244 in invocationList)
				{
					if (delegate244.Target == instance)
					{
						OnUnlinkIOSDeviceIDRequestEvent -= (PlayFabRequestEvent<UnlinkIOSDeviceIDRequest>)delegate244;
					}
				}
			}
			if (this.OnUnlinkIOSDeviceIDResultEvent != null)
			{
				invocationList = this.OnUnlinkIOSDeviceIDResultEvent.GetInvocationList();
				foreach (Delegate delegate245 in invocationList)
				{
					if (delegate245.Target == instance)
					{
						OnUnlinkIOSDeviceIDResultEvent -= (PlayFabResultEvent<UnlinkIOSDeviceIDResult>)delegate245;
					}
				}
			}
			if (this.OnUnlinkKongregateRequestEvent != null)
			{
				invocationList = this.OnUnlinkKongregateRequestEvent.GetInvocationList();
				foreach (Delegate delegate246 in invocationList)
				{
					if (delegate246.Target == instance)
					{
						OnUnlinkKongregateRequestEvent -= (PlayFabRequestEvent<UnlinkKongregateAccountRequest>)delegate246;
					}
				}
			}
			if (this.OnUnlinkKongregateResultEvent != null)
			{
				invocationList = this.OnUnlinkKongregateResultEvent.GetInvocationList();
				foreach (Delegate delegate247 in invocationList)
				{
					if (delegate247.Target == instance)
					{
						OnUnlinkKongregateResultEvent -= (PlayFabResultEvent<UnlinkKongregateAccountResult>)delegate247;
					}
				}
			}
			if (this.OnUnlinkNintendoSwitchDeviceIdRequestEvent != null)
			{
				invocationList = this.OnUnlinkNintendoSwitchDeviceIdRequestEvent.GetInvocationList();
				foreach (Delegate delegate248 in invocationList)
				{
					if (delegate248.Target == instance)
					{
						OnUnlinkNintendoSwitchDeviceIdRequestEvent -= (PlayFabRequestEvent<UnlinkNintendoSwitchDeviceIdRequest>)delegate248;
					}
				}
			}
			if (this.OnUnlinkNintendoSwitchDeviceIdResultEvent != null)
			{
				invocationList = this.OnUnlinkNintendoSwitchDeviceIdResultEvent.GetInvocationList();
				foreach (Delegate delegate249 in invocationList)
				{
					if (delegate249.Target == instance)
					{
						OnUnlinkNintendoSwitchDeviceIdResultEvent -= (PlayFabResultEvent<UnlinkNintendoSwitchDeviceIdResult>)delegate249;
					}
				}
			}
			if (this.OnUnlinkOpenIdConnectRequestEvent != null)
			{
				invocationList = this.OnUnlinkOpenIdConnectRequestEvent.GetInvocationList();
				foreach (Delegate delegate250 in invocationList)
				{
					if (delegate250.Target == instance)
					{
						OnUnlinkOpenIdConnectRequestEvent -= (PlayFabRequestEvent<UninkOpenIdConnectRequest>)delegate250;
					}
				}
			}
			if (this.OnUnlinkOpenIdConnectResultEvent != null)
			{
				invocationList = this.OnUnlinkOpenIdConnectResultEvent.GetInvocationList();
				foreach (Delegate delegate251 in invocationList)
				{
					if (delegate251.Target == instance)
					{
						OnUnlinkOpenIdConnectResultEvent -= (PlayFabResultEvent<PlayFab.ClientModels.EmptyResponse>)delegate251;
					}
				}
			}
			if (this.OnUnlinkPSNAccountRequestEvent != null)
			{
				invocationList = this.OnUnlinkPSNAccountRequestEvent.GetInvocationList();
				foreach (Delegate delegate252 in invocationList)
				{
					if (delegate252.Target == instance)
					{
						OnUnlinkPSNAccountRequestEvent -= (PlayFabRequestEvent<UnlinkPSNAccountRequest>)delegate252;
					}
				}
			}
			if (this.OnUnlinkPSNAccountResultEvent != null)
			{
				invocationList = this.OnUnlinkPSNAccountResultEvent.GetInvocationList();
				foreach (Delegate delegate253 in invocationList)
				{
					if (delegate253.Target == instance)
					{
						OnUnlinkPSNAccountResultEvent -= (PlayFabResultEvent<UnlinkPSNAccountResult>)delegate253;
					}
				}
			}
			if (this.OnUnlinkSteamAccountRequestEvent != null)
			{
				invocationList = this.OnUnlinkSteamAccountRequestEvent.GetInvocationList();
				foreach (Delegate delegate254 in invocationList)
				{
					if (delegate254.Target == instance)
					{
						OnUnlinkSteamAccountRequestEvent -= (PlayFabRequestEvent<UnlinkSteamAccountRequest>)delegate254;
					}
				}
			}
			if (this.OnUnlinkSteamAccountResultEvent != null)
			{
				invocationList = this.OnUnlinkSteamAccountResultEvent.GetInvocationList();
				foreach (Delegate delegate255 in invocationList)
				{
					if (delegate255.Target == instance)
					{
						OnUnlinkSteamAccountResultEvent -= (PlayFabResultEvent<UnlinkSteamAccountResult>)delegate255;
					}
				}
			}
			if (this.OnUnlinkTwitchRequestEvent != null)
			{
				invocationList = this.OnUnlinkTwitchRequestEvent.GetInvocationList();
				foreach (Delegate delegate256 in invocationList)
				{
					if (delegate256.Target == instance)
					{
						OnUnlinkTwitchRequestEvent -= (PlayFabRequestEvent<UnlinkTwitchAccountRequest>)delegate256;
					}
				}
			}
			if (this.OnUnlinkTwitchResultEvent != null)
			{
				invocationList = this.OnUnlinkTwitchResultEvent.GetInvocationList();
				foreach (Delegate delegate257 in invocationList)
				{
					if (delegate257.Target == instance)
					{
						OnUnlinkTwitchResultEvent -= (PlayFabResultEvent<UnlinkTwitchAccountResult>)delegate257;
					}
				}
			}
			if (this.OnUnlinkWindowsHelloRequestEvent != null)
			{
				invocationList = this.OnUnlinkWindowsHelloRequestEvent.GetInvocationList();
				foreach (Delegate delegate258 in invocationList)
				{
					if (delegate258.Target == instance)
					{
						OnUnlinkWindowsHelloRequestEvent -= (PlayFabRequestEvent<UnlinkWindowsHelloAccountRequest>)delegate258;
					}
				}
			}
			if (this.OnUnlinkWindowsHelloResultEvent != null)
			{
				invocationList = this.OnUnlinkWindowsHelloResultEvent.GetInvocationList();
				foreach (Delegate delegate259 in invocationList)
				{
					if (delegate259.Target == instance)
					{
						OnUnlinkWindowsHelloResultEvent -= (PlayFabResultEvent<UnlinkWindowsHelloAccountResponse>)delegate259;
					}
				}
			}
			if (this.OnUnlinkXboxAccountRequestEvent != null)
			{
				invocationList = this.OnUnlinkXboxAccountRequestEvent.GetInvocationList();
				foreach (Delegate delegate260 in invocationList)
				{
					if (delegate260.Target == instance)
					{
						OnUnlinkXboxAccountRequestEvent -= (PlayFabRequestEvent<UnlinkXboxAccountRequest>)delegate260;
					}
				}
			}
			if (this.OnUnlinkXboxAccountResultEvent != null)
			{
				invocationList = this.OnUnlinkXboxAccountResultEvent.GetInvocationList();
				foreach (Delegate delegate261 in invocationList)
				{
					if (delegate261.Target == instance)
					{
						OnUnlinkXboxAccountResultEvent -= (PlayFabResultEvent<UnlinkXboxAccountResult>)delegate261;
					}
				}
			}
			if (this.OnUnlockContainerInstanceRequestEvent != null)
			{
				invocationList = this.OnUnlockContainerInstanceRequestEvent.GetInvocationList();
				foreach (Delegate delegate262 in invocationList)
				{
					if (delegate262.Target == instance)
					{
						OnUnlockContainerInstanceRequestEvent -= (PlayFabRequestEvent<UnlockContainerInstanceRequest>)delegate262;
					}
				}
			}
			if (this.OnUnlockContainerInstanceResultEvent != null)
			{
				invocationList = this.OnUnlockContainerInstanceResultEvent.GetInvocationList();
				foreach (Delegate delegate263 in invocationList)
				{
					if (delegate263.Target == instance)
					{
						OnUnlockContainerInstanceResultEvent -= (PlayFabResultEvent<UnlockContainerItemResult>)delegate263;
					}
				}
			}
			if (this.OnUnlockContainerItemRequestEvent != null)
			{
				invocationList = this.OnUnlockContainerItemRequestEvent.GetInvocationList();
				foreach (Delegate delegate264 in invocationList)
				{
					if (delegate264.Target == instance)
					{
						OnUnlockContainerItemRequestEvent -= (PlayFabRequestEvent<UnlockContainerItemRequest>)delegate264;
					}
				}
			}
			if (this.OnUnlockContainerItemResultEvent != null)
			{
				invocationList = this.OnUnlockContainerItemResultEvent.GetInvocationList();
				foreach (Delegate delegate265 in invocationList)
				{
					if (delegate265.Target == instance)
					{
						OnUnlockContainerItemResultEvent -= (PlayFabResultEvent<UnlockContainerItemResult>)delegate265;
					}
				}
			}
			if (this.OnUpdateAvatarUrlRequestEvent != null)
			{
				invocationList = this.OnUpdateAvatarUrlRequestEvent.GetInvocationList();
				foreach (Delegate delegate266 in invocationList)
				{
					if (delegate266.Target == instance)
					{
						OnUpdateAvatarUrlRequestEvent -= (PlayFabRequestEvent<UpdateAvatarUrlRequest>)delegate266;
					}
				}
			}
			if (this.OnUpdateAvatarUrlResultEvent != null)
			{
				invocationList = this.OnUpdateAvatarUrlResultEvent.GetInvocationList();
				foreach (Delegate delegate267 in invocationList)
				{
					if (delegate267.Target == instance)
					{
						OnUpdateAvatarUrlResultEvent -= (PlayFabResultEvent<PlayFab.ClientModels.EmptyResponse>)delegate267;
					}
				}
			}
			if (this.OnUpdateCharacterDataRequestEvent != null)
			{
				invocationList = this.OnUpdateCharacterDataRequestEvent.GetInvocationList();
				foreach (Delegate delegate268 in invocationList)
				{
					if (delegate268.Target == instance)
					{
						OnUpdateCharacterDataRequestEvent -= (PlayFabRequestEvent<UpdateCharacterDataRequest>)delegate268;
					}
				}
			}
			if (this.OnUpdateCharacterDataResultEvent != null)
			{
				invocationList = this.OnUpdateCharacterDataResultEvent.GetInvocationList();
				foreach (Delegate delegate269 in invocationList)
				{
					if (delegate269.Target == instance)
					{
						OnUpdateCharacterDataResultEvent -= (PlayFabResultEvent<UpdateCharacterDataResult>)delegate269;
					}
				}
			}
			if (this.OnUpdateCharacterStatisticsRequestEvent != null)
			{
				invocationList = this.OnUpdateCharacterStatisticsRequestEvent.GetInvocationList();
				foreach (Delegate delegate270 in invocationList)
				{
					if (delegate270.Target == instance)
					{
						OnUpdateCharacterStatisticsRequestEvent -= (PlayFabRequestEvent<UpdateCharacterStatisticsRequest>)delegate270;
					}
				}
			}
			if (this.OnUpdateCharacterStatisticsResultEvent != null)
			{
				invocationList = this.OnUpdateCharacterStatisticsResultEvent.GetInvocationList();
				foreach (Delegate delegate271 in invocationList)
				{
					if (delegate271.Target == instance)
					{
						OnUpdateCharacterStatisticsResultEvent -= (PlayFabResultEvent<UpdateCharacterStatisticsResult>)delegate271;
					}
				}
			}
			if (this.OnUpdatePlayerStatisticsRequestEvent != null)
			{
				invocationList = this.OnUpdatePlayerStatisticsRequestEvent.GetInvocationList();
				foreach (Delegate delegate272 in invocationList)
				{
					if (delegate272.Target == instance)
					{
						OnUpdatePlayerStatisticsRequestEvent -= (PlayFabRequestEvent<UpdatePlayerStatisticsRequest>)delegate272;
					}
				}
			}
			if (this.OnUpdatePlayerStatisticsResultEvent != null)
			{
				invocationList = this.OnUpdatePlayerStatisticsResultEvent.GetInvocationList();
				foreach (Delegate delegate273 in invocationList)
				{
					if (delegate273.Target == instance)
					{
						OnUpdatePlayerStatisticsResultEvent -= (PlayFabResultEvent<UpdatePlayerStatisticsResult>)delegate273;
					}
				}
			}
			if (this.OnUpdateSharedGroupDataRequestEvent != null)
			{
				invocationList = this.OnUpdateSharedGroupDataRequestEvent.GetInvocationList();
				foreach (Delegate delegate274 in invocationList)
				{
					if (delegate274.Target == instance)
					{
						OnUpdateSharedGroupDataRequestEvent -= (PlayFabRequestEvent<UpdateSharedGroupDataRequest>)delegate274;
					}
				}
			}
			if (this.OnUpdateSharedGroupDataResultEvent != null)
			{
				invocationList = this.OnUpdateSharedGroupDataResultEvent.GetInvocationList();
				foreach (Delegate delegate275 in invocationList)
				{
					if (delegate275.Target == instance)
					{
						OnUpdateSharedGroupDataResultEvent -= (PlayFabResultEvent<UpdateSharedGroupDataResult>)delegate275;
					}
				}
			}
			if (this.OnUpdateUserDataRequestEvent != null)
			{
				invocationList = this.OnUpdateUserDataRequestEvent.GetInvocationList();
				foreach (Delegate delegate276 in invocationList)
				{
					if (delegate276.Target == instance)
					{
						OnUpdateUserDataRequestEvent -= (PlayFabRequestEvent<UpdateUserDataRequest>)delegate276;
					}
				}
			}
			if (this.OnUpdateUserDataResultEvent != null)
			{
				invocationList = this.OnUpdateUserDataResultEvent.GetInvocationList();
				foreach (Delegate delegate277 in invocationList)
				{
					if (delegate277.Target == instance)
					{
						OnUpdateUserDataResultEvent -= (PlayFabResultEvent<UpdateUserDataResult>)delegate277;
					}
				}
			}
			if (this.OnUpdateUserPublisherDataRequestEvent != null)
			{
				invocationList = this.OnUpdateUserPublisherDataRequestEvent.GetInvocationList();
				foreach (Delegate delegate278 in invocationList)
				{
					if (delegate278.Target == instance)
					{
						OnUpdateUserPublisherDataRequestEvent -= (PlayFabRequestEvent<UpdateUserDataRequest>)delegate278;
					}
				}
			}
			if (this.OnUpdateUserPublisherDataResultEvent != null)
			{
				invocationList = this.OnUpdateUserPublisherDataResultEvent.GetInvocationList();
				foreach (Delegate delegate279 in invocationList)
				{
					if (delegate279.Target == instance)
					{
						OnUpdateUserPublisherDataResultEvent -= (PlayFabResultEvent<UpdateUserDataResult>)delegate279;
					}
				}
			}
			if (this.OnUpdateUserTitleDisplayNameRequestEvent != null)
			{
				invocationList = this.OnUpdateUserTitleDisplayNameRequestEvent.GetInvocationList();
				foreach (Delegate delegate280 in invocationList)
				{
					if (delegate280.Target == instance)
					{
						OnUpdateUserTitleDisplayNameRequestEvent -= (PlayFabRequestEvent<UpdateUserTitleDisplayNameRequest>)delegate280;
					}
				}
			}
			if (this.OnUpdateUserTitleDisplayNameResultEvent != null)
			{
				invocationList = this.OnUpdateUserTitleDisplayNameResultEvent.GetInvocationList();
				foreach (Delegate delegate281 in invocationList)
				{
					if (delegate281.Target == instance)
					{
						OnUpdateUserTitleDisplayNameResultEvent -= (PlayFabResultEvent<UpdateUserTitleDisplayNameResult>)delegate281;
					}
				}
			}
			if (this.OnValidateAmazonIAPReceiptRequestEvent != null)
			{
				invocationList = this.OnValidateAmazonIAPReceiptRequestEvent.GetInvocationList();
				foreach (Delegate delegate282 in invocationList)
				{
					if (delegate282.Target == instance)
					{
						OnValidateAmazonIAPReceiptRequestEvent -= (PlayFabRequestEvent<ValidateAmazonReceiptRequest>)delegate282;
					}
				}
			}
			if (this.OnValidateAmazonIAPReceiptResultEvent != null)
			{
				invocationList = this.OnValidateAmazonIAPReceiptResultEvent.GetInvocationList();
				foreach (Delegate delegate283 in invocationList)
				{
					if (delegate283.Target == instance)
					{
						OnValidateAmazonIAPReceiptResultEvent -= (PlayFabResultEvent<ValidateAmazonReceiptResult>)delegate283;
					}
				}
			}
			if (this.OnValidateGooglePlayPurchaseRequestEvent != null)
			{
				invocationList = this.OnValidateGooglePlayPurchaseRequestEvent.GetInvocationList();
				foreach (Delegate delegate284 in invocationList)
				{
					if (delegate284.Target == instance)
					{
						OnValidateGooglePlayPurchaseRequestEvent -= (PlayFabRequestEvent<ValidateGooglePlayPurchaseRequest>)delegate284;
					}
				}
			}
			if (this.OnValidateGooglePlayPurchaseResultEvent != null)
			{
				invocationList = this.OnValidateGooglePlayPurchaseResultEvent.GetInvocationList();
				foreach (Delegate delegate285 in invocationList)
				{
					if (delegate285.Target == instance)
					{
						OnValidateGooglePlayPurchaseResultEvent -= (PlayFabResultEvent<ValidateGooglePlayPurchaseResult>)delegate285;
					}
				}
			}
			if (this.OnValidateIOSReceiptRequestEvent != null)
			{
				invocationList = this.OnValidateIOSReceiptRequestEvent.GetInvocationList();
				foreach (Delegate delegate286 in invocationList)
				{
					if (delegate286.Target == instance)
					{
						OnValidateIOSReceiptRequestEvent -= (PlayFabRequestEvent<ValidateIOSReceiptRequest>)delegate286;
					}
				}
			}
			if (this.OnValidateIOSReceiptResultEvent != null)
			{
				invocationList = this.OnValidateIOSReceiptResultEvent.GetInvocationList();
				foreach (Delegate delegate287 in invocationList)
				{
					if (delegate287.Target == instance)
					{
						OnValidateIOSReceiptResultEvent -= (PlayFabResultEvent<ValidateIOSReceiptResult>)delegate287;
					}
				}
			}
			if (this.OnValidateWindowsStoreReceiptRequestEvent != null)
			{
				invocationList = this.OnValidateWindowsStoreReceiptRequestEvent.GetInvocationList();
				foreach (Delegate delegate288 in invocationList)
				{
					if (delegate288.Target == instance)
					{
						OnValidateWindowsStoreReceiptRequestEvent -= (PlayFabRequestEvent<ValidateWindowsReceiptRequest>)delegate288;
					}
				}
			}
			if (this.OnValidateWindowsStoreReceiptResultEvent != null)
			{
				invocationList = this.OnValidateWindowsStoreReceiptResultEvent.GetInvocationList();
				foreach (Delegate delegate289 in invocationList)
				{
					if (delegate289.Target == instance)
					{
						OnValidateWindowsStoreReceiptResultEvent -= (PlayFabResultEvent<ValidateWindowsReceiptResult>)delegate289;
					}
				}
			}
			if (this.OnWriteCharacterEventRequestEvent != null)
			{
				invocationList = this.OnWriteCharacterEventRequestEvent.GetInvocationList();
				foreach (Delegate delegate290 in invocationList)
				{
					if (delegate290.Target == instance)
					{
						OnWriteCharacterEventRequestEvent -= (PlayFabRequestEvent<WriteClientCharacterEventRequest>)delegate290;
					}
				}
			}
			if (this.OnWriteCharacterEventResultEvent != null)
			{
				invocationList = this.OnWriteCharacterEventResultEvent.GetInvocationList();
				foreach (Delegate delegate291 in invocationList)
				{
					if (delegate291.Target == instance)
					{
						OnWriteCharacterEventResultEvent -= (PlayFabResultEvent<WriteEventResponse>)delegate291;
					}
				}
			}
			if (this.OnWritePlayerEventRequestEvent != null)
			{
				invocationList = this.OnWritePlayerEventRequestEvent.GetInvocationList();
				foreach (Delegate delegate292 in invocationList)
				{
					if (delegate292.Target == instance)
					{
						OnWritePlayerEventRequestEvent -= (PlayFabRequestEvent<WriteClientPlayerEventRequest>)delegate292;
					}
				}
			}
			if (this.OnWritePlayerEventResultEvent != null)
			{
				invocationList = this.OnWritePlayerEventResultEvent.GetInvocationList();
				foreach (Delegate delegate293 in invocationList)
				{
					if (delegate293.Target == instance)
					{
						OnWritePlayerEventResultEvent -= (PlayFabResultEvent<WriteEventResponse>)delegate293;
					}
				}
			}
			if (this.OnWriteTitleEventRequestEvent != null)
			{
				invocationList = this.OnWriteTitleEventRequestEvent.GetInvocationList();
				foreach (Delegate delegate294 in invocationList)
				{
					if (delegate294.Target == instance)
					{
						OnWriteTitleEventRequestEvent -= (PlayFabRequestEvent<WriteTitleEventRequest>)delegate294;
					}
				}
			}
			if (this.OnWriteTitleEventResultEvent != null)
			{
				invocationList = this.OnWriteTitleEventResultEvent.GetInvocationList();
				foreach (Delegate delegate295 in invocationList)
				{
					if (delegate295.Target == instance)
					{
						OnWriteTitleEventResultEvent -= (PlayFabResultEvent<WriteEventResponse>)delegate295;
					}
				}
			}
			if (this.OnAuthenticationGetEntityTokenRequestEvent != null)
			{
				invocationList = this.OnAuthenticationGetEntityTokenRequestEvent.GetInvocationList();
				foreach (Delegate delegate296 in invocationList)
				{
					if (delegate296.Target == instance)
					{
						OnAuthenticationGetEntityTokenRequestEvent -= (PlayFabRequestEvent<GetEntityTokenRequest>)delegate296;
					}
				}
			}
			if (this.OnAuthenticationGetEntityTokenResultEvent != null)
			{
				invocationList = this.OnAuthenticationGetEntityTokenResultEvent.GetInvocationList();
				foreach (Delegate delegate297 in invocationList)
				{
					if (delegate297.Target == instance)
					{
						OnAuthenticationGetEntityTokenResultEvent -= (PlayFabResultEvent<GetEntityTokenResponse>)delegate297;
					}
				}
			}
			if (this.OnAuthenticationValidateEntityTokenRequestEvent != null)
			{
				invocationList = this.OnAuthenticationValidateEntityTokenRequestEvent.GetInvocationList();
				foreach (Delegate delegate298 in invocationList)
				{
					if (delegate298.Target == instance)
					{
						OnAuthenticationValidateEntityTokenRequestEvent -= (PlayFabRequestEvent<ValidateEntityTokenRequest>)delegate298;
					}
				}
			}
			if (this.OnAuthenticationValidateEntityTokenResultEvent != null)
			{
				invocationList = this.OnAuthenticationValidateEntityTokenResultEvent.GetInvocationList();
				foreach (Delegate delegate299 in invocationList)
				{
					if (delegate299.Target == instance)
					{
						OnAuthenticationValidateEntityTokenResultEvent -= (PlayFabResultEvent<ValidateEntityTokenResponse>)delegate299;
					}
				}
			}
			if (this.OnCloudScriptExecuteEntityCloudScriptRequestEvent != null)
			{
				invocationList = this.OnCloudScriptExecuteEntityCloudScriptRequestEvent.GetInvocationList();
				foreach (Delegate delegate300 in invocationList)
				{
					if (delegate300.Target == instance)
					{
						OnCloudScriptExecuteEntityCloudScriptRequestEvent -= (PlayFabRequestEvent<ExecuteEntityCloudScriptRequest>)delegate300;
					}
				}
			}
			if (this.OnCloudScriptExecuteEntityCloudScriptResultEvent != null)
			{
				invocationList = this.OnCloudScriptExecuteEntityCloudScriptResultEvent.GetInvocationList();
				foreach (Delegate delegate301 in invocationList)
				{
					if (delegate301.Target == instance)
					{
						OnCloudScriptExecuteEntityCloudScriptResultEvent -= (PlayFabResultEvent<PlayFab.CloudScriptModels.ExecuteCloudScriptResult>)delegate301;
					}
				}
			}
			if (this.OnDataAbortFileUploadsRequestEvent != null)
			{
				invocationList = this.OnDataAbortFileUploadsRequestEvent.GetInvocationList();
				foreach (Delegate delegate302 in invocationList)
				{
					if (delegate302.Target == instance)
					{
						OnDataAbortFileUploadsRequestEvent -= (PlayFabRequestEvent<AbortFileUploadsRequest>)delegate302;
					}
				}
			}
			if (this.OnDataAbortFileUploadsResultEvent != null)
			{
				invocationList = this.OnDataAbortFileUploadsResultEvent.GetInvocationList();
				foreach (Delegate delegate303 in invocationList)
				{
					if (delegate303.Target == instance)
					{
						OnDataAbortFileUploadsResultEvent -= (PlayFabResultEvent<AbortFileUploadsResponse>)delegate303;
					}
				}
			}
			if (this.OnDataDeleteFilesRequestEvent != null)
			{
				invocationList = this.OnDataDeleteFilesRequestEvent.GetInvocationList();
				foreach (Delegate delegate304 in invocationList)
				{
					if (delegate304.Target == instance)
					{
						OnDataDeleteFilesRequestEvent -= (PlayFabRequestEvent<DeleteFilesRequest>)delegate304;
					}
				}
			}
			if (this.OnDataDeleteFilesResultEvent != null)
			{
				invocationList = this.OnDataDeleteFilesResultEvent.GetInvocationList();
				foreach (Delegate delegate305 in invocationList)
				{
					if (delegate305.Target == instance)
					{
						OnDataDeleteFilesResultEvent -= (PlayFabResultEvent<DeleteFilesResponse>)delegate305;
					}
				}
			}
			if (this.OnDataFinalizeFileUploadsRequestEvent != null)
			{
				invocationList = this.OnDataFinalizeFileUploadsRequestEvent.GetInvocationList();
				foreach (Delegate delegate306 in invocationList)
				{
					if (delegate306.Target == instance)
					{
						OnDataFinalizeFileUploadsRequestEvent -= (PlayFabRequestEvent<FinalizeFileUploadsRequest>)delegate306;
					}
				}
			}
			if (this.OnDataFinalizeFileUploadsResultEvent != null)
			{
				invocationList = this.OnDataFinalizeFileUploadsResultEvent.GetInvocationList();
				foreach (Delegate delegate307 in invocationList)
				{
					if (delegate307.Target == instance)
					{
						OnDataFinalizeFileUploadsResultEvent -= (PlayFabResultEvent<FinalizeFileUploadsResponse>)delegate307;
					}
				}
			}
			if (this.OnDataGetFilesRequestEvent != null)
			{
				invocationList = this.OnDataGetFilesRequestEvent.GetInvocationList();
				foreach (Delegate delegate308 in invocationList)
				{
					if (delegate308.Target == instance)
					{
						OnDataGetFilesRequestEvent -= (PlayFabRequestEvent<GetFilesRequest>)delegate308;
					}
				}
			}
			if (this.OnDataGetFilesResultEvent != null)
			{
				invocationList = this.OnDataGetFilesResultEvent.GetInvocationList();
				foreach (Delegate delegate309 in invocationList)
				{
					if (delegate309.Target == instance)
					{
						OnDataGetFilesResultEvent -= (PlayFabResultEvent<GetFilesResponse>)delegate309;
					}
				}
			}
			if (this.OnDataGetObjectsRequestEvent != null)
			{
				invocationList = this.OnDataGetObjectsRequestEvent.GetInvocationList();
				foreach (Delegate delegate310 in invocationList)
				{
					if (delegate310.Target == instance)
					{
						OnDataGetObjectsRequestEvent -= (PlayFabRequestEvent<GetObjectsRequest>)delegate310;
					}
				}
			}
			if (this.OnDataGetObjectsResultEvent != null)
			{
				invocationList = this.OnDataGetObjectsResultEvent.GetInvocationList();
				foreach (Delegate delegate311 in invocationList)
				{
					if (delegate311.Target == instance)
					{
						OnDataGetObjectsResultEvent -= (PlayFabResultEvent<GetObjectsResponse>)delegate311;
					}
				}
			}
			if (this.OnDataInitiateFileUploadsRequestEvent != null)
			{
				invocationList = this.OnDataInitiateFileUploadsRequestEvent.GetInvocationList();
				foreach (Delegate delegate312 in invocationList)
				{
					if (delegate312.Target == instance)
					{
						OnDataInitiateFileUploadsRequestEvent -= (PlayFabRequestEvent<InitiateFileUploadsRequest>)delegate312;
					}
				}
			}
			if (this.OnDataInitiateFileUploadsResultEvent != null)
			{
				invocationList = this.OnDataInitiateFileUploadsResultEvent.GetInvocationList();
				foreach (Delegate delegate313 in invocationList)
				{
					if (delegate313.Target == instance)
					{
						OnDataInitiateFileUploadsResultEvent -= (PlayFabResultEvent<InitiateFileUploadsResponse>)delegate313;
					}
				}
			}
			if (this.OnDataSetObjectsRequestEvent != null)
			{
				invocationList = this.OnDataSetObjectsRequestEvent.GetInvocationList();
				foreach (Delegate delegate314 in invocationList)
				{
					if (delegate314.Target == instance)
					{
						OnDataSetObjectsRequestEvent -= (PlayFabRequestEvent<SetObjectsRequest>)delegate314;
					}
				}
			}
			if (this.OnDataSetObjectsResultEvent != null)
			{
				invocationList = this.OnDataSetObjectsResultEvent.GetInvocationList();
				foreach (Delegate delegate315 in invocationList)
				{
					if (delegate315.Target == instance)
					{
						OnDataSetObjectsResultEvent -= (PlayFabResultEvent<SetObjectsResponse>)delegate315;
					}
				}
			}
			if (this.OnEventsWriteEventsRequestEvent != null)
			{
				invocationList = this.OnEventsWriteEventsRequestEvent.GetInvocationList();
				foreach (Delegate delegate316 in invocationList)
				{
					if (delegate316.Target == instance)
					{
						OnEventsWriteEventsRequestEvent -= (PlayFabRequestEvent<WriteEventsRequest>)delegate316;
					}
				}
			}
			if (this.OnEventsWriteEventsResultEvent != null)
			{
				invocationList = this.OnEventsWriteEventsResultEvent.GetInvocationList();
				foreach (Delegate delegate317 in invocationList)
				{
					if (delegate317.Target == instance)
					{
						OnEventsWriteEventsResultEvent -= (PlayFabResultEvent<WriteEventsResponse>)delegate317;
					}
				}
			}
			if (this.OnEventsWriteTelemetryEventsRequestEvent != null)
			{
				invocationList = this.OnEventsWriteTelemetryEventsRequestEvent.GetInvocationList();
				foreach (Delegate delegate318 in invocationList)
				{
					if (delegate318.Target == instance)
					{
						OnEventsWriteTelemetryEventsRequestEvent -= (PlayFabRequestEvent<WriteEventsRequest>)delegate318;
					}
				}
			}
			if (this.OnEventsWriteTelemetryEventsResultEvent != null)
			{
				invocationList = this.OnEventsWriteTelemetryEventsResultEvent.GetInvocationList();
				foreach (Delegate delegate319 in invocationList)
				{
					if (delegate319.Target == instance)
					{
						OnEventsWriteTelemetryEventsResultEvent -= (PlayFabResultEvent<WriteEventsResponse>)delegate319;
					}
				}
			}
			if (this.OnGroupsAcceptGroupApplicationRequestEvent != null)
			{
				invocationList = this.OnGroupsAcceptGroupApplicationRequestEvent.GetInvocationList();
				foreach (Delegate delegate320 in invocationList)
				{
					if (delegate320.Target == instance)
					{
						OnGroupsAcceptGroupApplicationRequestEvent -= (PlayFabRequestEvent<AcceptGroupApplicationRequest>)delegate320;
					}
				}
			}
			if (this.OnGroupsAcceptGroupApplicationResultEvent != null)
			{
				invocationList = this.OnGroupsAcceptGroupApplicationResultEvent.GetInvocationList();
				foreach (Delegate delegate321 in invocationList)
				{
					if (delegate321.Target == instance)
					{
						OnGroupsAcceptGroupApplicationResultEvent -= (PlayFabResultEvent<PlayFab.GroupsModels.EmptyResponse>)delegate321;
					}
				}
			}
			if (this.OnGroupsAcceptGroupInvitationRequestEvent != null)
			{
				invocationList = this.OnGroupsAcceptGroupInvitationRequestEvent.GetInvocationList();
				foreach (Delegate delegate322 in invocationList)
				{
					if (delegate322.Target == instance)
					{
						OnGroupsAcceptGroupInvitationRequestEvent -= (PlayFabRequestEvent<AcceptGroupInvitationRequest>)delegate322;
					}
				}
			}
			if (this.OnGroupsAcceptGroupInvitationResultEvent != null)
			{
				invocationList = this.OnGroupsAcceptGroupInvitationResultEvent.GetInvocationList();
				foreach (Delegate delegate323 in invocationList)
				{
					if (delegate323.Target == instance)
					{
						OnGroupsAcceptGroupInvitationResultEvent -= (PlayFabResultEvent<PlayFab.GroupsModels.EmptyResponse>)delegate323;
					}
				}
			}
			if (this.OnGroupsAddMembersRequestEvent != null)
			{
				invocationList = this.OnGroupsAddMembersRequestEvent.GetInvocationList();
				foreach (Delegate delegate324 in invocationList)
				{
					if (delegate324.Target == instance)
					{
						OnGroupsAddMembersRequestEvent -= (PlayFabRequestEvent<AddMembersRequest>)delegate324;
					}
				}
			}
			if (this.OnGroupsAddMembersResultEvent != null)
			{
				invocationList = this.OnGroupsAddMembersResultEvent.GetInvocationList();
				foreach (Delegate delegate325 in invocationList)
				{
					if (delegate325.Target == instance)
					{
						OnGroupsAddMembersResultEvent -= (PlayFabResultEvent<PlayFab.GroupsModels.EmptyResponse>)delegate325;
					}
				}
			}
			if (this.OnGroupsApplyToGroupRequestEvent != null)
			{
				invocationList = this.OnGroupsApplyToGroupRequestEvent.GetInvocationList();
				foreach (Delegate delegate326 in invocationList)
				{
					if (delegate326.Target == instance)
					{
						OnGroupsApplyToGroupRequestEvent -= (PlayFabRequestEvent<ApplyToGroupRequest>)delegate326;
					}
				}
			}
			if (this.OnGroupsApplyToGroupResultEvent != null)
			{
				invocationList = this.OnGroupsApplyToGroupResultEvent.GetInvocationList();
				foreach (Delegate delegate327 in invocationList)
				{
					if (delegate327.Target == instance)
					{
						OnGroupsApplyToGroupResultEvent -= (PlayFabResultEvent<ApplyToGroupResponse>)delegate327;
					}
				}
			}
			if (this.OnGroupsBlockEntityRequestEvent != null)
			{
				invocationList = this.OnGroupsBlockEntityRequestEvent.GetInvocationList();
				foreach (Delegate delegate328 in invocationList)
				{
					if (delegate328.Target == instance)
					{
						OnGroupsBlockEntityRequestEvent -= (PlayFabRequestEvent<BlockEntityRequest>)delegate328;
					}
				}
			}
			if (this.OnGroupsBlockEntityResultEvent != null)
			{
				invocationList = this.OnGroupsBlockEntityResultEvent.GetInvocationList();
				foreach (Delegate delegate329 in invocationList)
				{
					if (delegate329.Target == instance)
					{
						OnGroupsBlockEntityResultEvent -= (PlayFabResultEvent<PlayFab.GroupsModels.EmptyResponse>)delegate329;
					}
				}
			}
			if (this.OnGroupsChangeMemberRoleRequestEvent != null)
			{
				invocationList = this.OnGroupsChangeMemberRoleRequestEvent.GetInvocationList();
				foreach (Delegate delegate330 in invocationList)
				{
					if (delegate330.Target == instance)
					{
						OnGroupsChangeMemberRoleRequestEvent -= (PlayFabRequestEvent<ChangeMemberRoleRequest>)delegate330;
					}
				}
			}
			if (this.OnGroupsChangeMemberRoleResultEvent != null)
			{
				invocationList = this.OnGroupsChangeMemberRoleResultEvent.GetInvocationList();
				foreach (Delegate delegate331 in invocationList)
				{
					if (delegate331.Target == instance)
					{
						OnGroupsChangeMemberRoleResultEvent -= (PlayFabResultEvent<PlayFab.GroupsModels.EmptyResponse>)delegate331;
					}
				}
			}
			if (this.OnGroupsCreateGroupRequestEvent != null)
			{
				invocationList = this.OnGroupsCreateGroupRequestEvent.GetInvocationList();
				foreach (Delegate delegate332 in invocationList)
				{
					if (delegate332.Target == instance)
					{
						OnGroupsCreateGroupRequestEvent -= (PlayFabRequestEvent<CreateGroupRequest>)delegate332;
					}
				}
			}
			if (this.OnGroupsCreateGroupResultEvent != null)
			{
				invocationList = this.OnGroupsCreateGroupResultEvent.GetInvocationList();
				foreach (Delegate delegate333 in invocationList)
				{
					if (delegate333.Target == instance)
					{
						OnGroupsCreateGroupResultEvent -= (PlayFabResultEvent<CreateGroupResponse>)delegate333;
					}
				}
			}
			if (this.OnGroupsCreateRoleRequestEvent != null)
			{
				invocationList = this.OnGroupsCreateRoleRequestEvent.GetInvocationList();
				foreach (Delegate delegate334 in invocationList)
				{
					if (delegate334.Target == instance)
					{
						OnGroupsCreateRoleRequestEvent -= (PlayFabRequestEvent<CreateGroupRoleRequest>)delegate334;
					}
				}
			}
			if (this.OnGroupsCreateRoleResultEvent != null)
			{
				invocationList = this.OnGroupsCreateRoleResultEvent.GetInvocationList();
				foreach (Delegate delegate335 in invocationList)
				{
					if (delegate335.Target == instance)
					{
						OnGroupsCreateRoleResultEvent -= (PlayFabResultEvent<CreateGroupRoleResponse>)delegate335;
					}
				}
			}
			if (this.OnGroupsDeleteGroupRequestEvent != null)
			{
				invocationList = this.OnGroupsDeleteGroupRequestEvent.GetInvocationList();
				foreach (Delegate delegate336 in invocationList)
				{
					if (delegate336.Target == instance)
					{
						OnGroupsDeleteGroupRequestEvent -= (PlayFabRequestEvent<DeleteGroupRequest>)delegate336;
					}
				}
			}
			if (this.OnGroupsDeleteGroupResultEvent != null)
			{
				invocationList = this.OnGroupsDeleteGroupResultEvent.GetInvocationList();
				foreach (Delegate delegate337 in invocationList)
				{
					if (delegate337.Target == instance)
					{
						OnGroupsDeleteGroupResultEvent -= (PlayFabResultEvent<PlayFab.GroupsModels.EmptyResponse>)delegate337;
					}
				}
			}
			if (this.OnGroupsDeleteRoleRequestEvent != null)
			{
				invocationList = this.OnGroupsDeleteRoleRequestEvent.GetInvocationList();
				foreach (Delegate delegate338 in invocationList)
				{
					if (delegate338.Target == instance)
					{
						OnGroupsDeleteRoleRequestEvent -= (PlayFabRequestEvent<DeleteRoleRequest>)delegate338;
					}
				}
			}
			if (this.OnGroupsDeleteRoleResultEvent != null)
			{
				invocationList = this.OnGroupsDeleteRoleResultEvent.GetInvocationList();
				foreach (Delegate delegate339 in invocationList)
				{
					if (delegate339.Target == instance)
					{
						OnGroupsDeleteRoleResultEvent -= (PlayFabResultEvent<PlayFab.GroupsModels.EmptyResponse>)delegate339;
					}
				}
			}
			if (this.OnGroupsGetGroupRequestEvent != null)
			{
				invocationList = this.OnGroupsGetGroupRequestEvent.GetInvocationList();
				foreach (Delegate delegate340 in invocationList)
				{
					if (delegate340.Target == instance)
					{
						OnGroupsGetGroupRequestEvent -= (PlayFabRequestEvent<GetGroupRequest>)delegate340;
					}
				}
			}
			if (this.OnGroupsGetGroupResultEvent != null)
			{
				invocationList = this.OnGroupsGetGroupResultEvent.GetInvocationList();
				foreach (Delegate delegate341 in invocationList)
				{
					if (delegate341.Target == instance)
					{
						OnGroupsGetGroupResultEvent -= (PlayFabResultEvent<GetGroupResponse>)delegate341;
					}
				}
			}
			if (this.OnGroupsInviteToGroupRequestEvent != null)
			{
				invocationList = this.OnGroupsInviteToGroupRequestEvent.GetInvocationList();
				foreach (Delegate delegate342 in invocationList)
				{
					if (delegate342.Target == instance)
					{
						OnGroupsInviteToGroupRequestEvent -= (PlayFabRequestEvent<InviteToGroupRequest>)delegate342;
					}
				}
			}
			if (this.OnGroupsInviteToGroupResultEvent != null)
			{
				invocationList = this.OnGroupsInviteToGroupResultEvent.GetInvocationList();
				foreach (Delegate delegate343 in invocationList)
				{
					if (delegate343.Target == instance)
					{
						OnGroupsInviteToGroupResultEvent -= (PlayFabResultEvent<InviteToGroupResponse>)delegate343;
					}
				}
			}
			if (this.OnGroupsIsMemberRequestEvent != null)
			{
				invocationList = this.OnGroupsIsMemberRequestEvent.GetInvocationList();
				foreach (Delegate delegate344 in invocationList)
				{
					if (delegate344.Target == instance)
					{
						OnGroupsIsMemberRequestEvent -= (PlayFabRequestEvent<IsMemberRequest>)delegate344;
					}
				}
			}
			if (this.OnGroupsIsMemberResultEvent != null)
			{
				invocationList = this.OnGroupsIsMemberResultEvent.GetInvocationList();
				foreach (Delegate delegate345 in invocationList)
				{
					if (delegate345.Target == instance)
					{
						OnGroupsIsMemberResultEvent -= (PlayFabResultEvent<IsMemberResponse>)delegate345;
					}
				}
			}
			if (this.OnGroupsListGroupApplicationsRequestEvent != null)
			{
				invocationList = this.OnGroupsListGroupApplicationsRequestEvent.GetInvocationList();
				foreach (Delegate delegate346 in invocationList)
				{
					if (delegate346.Target == instance)
					{
						OnGroupsListGroupApplicationsRequestEvent -= (PlayFabRequestEvent<ListGroupApplicationsRequest>)delegate346;
					}
				}
			}
			if (this.OnGroupsListGroupApplicationsResultEvent != null)
			{
				invocationList = this.OnGroupsListGroupApplicationsResultEvent.GetInvocationList();
				foreach (Delegate delegate347 in invocationList)
				{
					if (delegate347.Target == instance)
					{
						OnGroupsListGroupApplicationsResultEvent -= (PlayFabResultEvent<ListGroupApplicationsResponse>)delegate347;
					}
				}
			}
			if (this.OnGroupsListGroupBlocksRequestEvent != null)
			{
				invocationList = this.OnGroupsListGroupBlocksRequestEvent.GetInvocationList();
				foreach (Delegate delegate348 in invocationList)
				{
					if (delegate348.Target == instance)
					{
						OnGroupsListGroupBlocksRequestEvent -= (PlayFabRequestEvent<ListGroupBlocksRequest>)delegate348;
					}
				}
			}
			if (this.OnGroupsListGroupBlocksResultEvent != null)
			{
				invocationList = this.OnGroupsListGroupBlocksResultEvent.GetInvocationList();
				foreach (Delegate delegate349 in invocationList)
				{
					if (delegate349.Target == instance)
					{
						OnGroupsListGroupBlocksResultEvent -= (PlayFabResultEvent<ListGroupBlocksResponse>)delegate349;
					}
				}
			}
			if (this.OnGroupsListGroupInvitationsRequestEvent != null)
			{
				invocationList = this.OnGroupsListGroupInvitationsRequestEvent.GetInvocationList();
				foreach (Delegate delegate350 in invocationList)
				{
					if (delegate350.Target == instance)
					{
						OnGroupsListGroupInvitationsRequestEvent -= (PlayFabRequestEvent<ListGroupInvitationsRequest>)delegate350;
					}
				}
			}
			if (this.OnGroupsListGroupInvitationsResultEvent != null)
			{
				invocationList = this.OnGroupsListGroupInvitationsResultEvent.GetInvocationList();
				foreach (Delegate delegate351 in invocationList)
				{
					if (delegate351.Target == instance)
					{
						OnGroupsListGroupInvitationsResultEvent -= (PlayFabResultEvent<ListGroupInvitationsResponse>)delegate351;
					}
				}
			}
			if (this.OnGroupsListGroupMembersRequestEvent != null)
			{
				invocationList = this.OnGroupsListGroupMembersRequestEvent.GetInvocationList();
				foreach (Delegate delegate352 in invocationList)
				{
					if (delegate352.Target == instance)
					{
						OnGroupsListGroupMembersRequestEvent -= (PlayFabRequestEvent<ListGroupMembersRequest>)delegate352;
					}
				}
			}
			if (this.OnGroupsListGroupMembersResultEvent != null)
			{
				invocationList = this.OnGroupsListGroupMembersResultEvent.GetInvocationList();
				foreach (Delegate delegate353 in invocationList)
				{
					if (delegate353.Target == instance)
					{
						OnGroupsListGroupMembersResultEvent -= (PlayFabResultEvent<ListGroupMembersResponse>)delegate353;
					}
				}
			}
			if (this.OnGroupsListMembershipRequestEvent != null)
			{
				invocationList = this.OnGroupsListMembershipRequestEvent.GetInvocationList();
				foreach (Delegate delegate354 in invocationList)
				{
					if (delegate354.Target == instance)
					{
						OnGroupsListMembershipRequestEvent -= (PlayFabRequestEvent<ListMembershipRequest>)delegate354;
					}
				}
			}
			if (this.OnGroupsListMembershipResultEvent != null)
			{
				invocationList = this.OnGroupsListMembershipResultEvent.GetInvocationList();
				foreach (Delegate delegate355 in invocationList)
				{
					if (delegate355.Target == instance)
					{
						OnGroupsListMembershipResultEvent -= (PlayFabResultEvent<ListMembershipResponse>)delegate355;
					}
				}
			}
			if (this.OnGroupsListMembershipOpportunitiesRequestEvent != null)
			{
				invocationList = this.OnGroupsListMembershipOpportunitiesRequestEvent.GetInvocationList();
				foreach (Delegate delegate356 in invocationList)
				{
					if (delegate356.Target == instance)
					{
						OnGroupsListMembershipOpportunitiesRequestEvent -= (PlayFabRequestEvent<ListMembershipOpportunitiesRequest>)delegate356;
					}
				}
			}
			if (this.OnGroupsListMembershipOpportunitiesResultEvent != null)
			{
				invocationList = this.OnGroupsListMembershipOpportunitiesResultEvent.GetInvocationList();
				foreach (Delegate delegate357 in invocationList)
				{
					if (delegate357.Target == instance)
					{
						OnGroupsListMembershipOpportunitiesResultEvent -= (PlayFabResultEvent<ListMembershipOpportunitiesResponse>)delegate357;
					}
				}
			}
			if (this.OnGroupsRemoveGroupApplicationRequestEvent != null)
			{
				invocationList = this.OnGroupsRemoveGroupApplicationRequestEvent.GetInvocationList();
				foreach (Delegate delegate358 in invocationList)
				{
					if (delegate358.Target == instance)
					{
						OnGroupsRemoveGroupApplicationRequestEvent -= (PlayFabRequestEvent<RemoveGroupApplicationRequest>)delegate358;
					}
				}
			}
			if (this.OnGroupsRemoveGroupApplicationResultEvent != null)
			{
				invocationList = this.OnGroupsRemoveGroupApplicationResultEvent.GetInvocationList();
				foreach (Delegate delegate359 in invocationList)
				{
					if (delegate359.Target == instance)
					{
						OnGroupsRemoveGroupApplicationResultEvent -= (PlayFabResultEvent<PlayFab.GroupsModels.EmptyResponse>)delegate359;
					}
				}
			}
			if (this.OnGroupsRemoveGroupInvitationRequestEvent != null)
			{
				invocationList = this.OnGroupsRemoveGroupInvitationRequestEvent.GetInvocationList();
				foreach (Delegate delegate360 in invocationList)
				{
					if (delegate360.Target == instance)
					{
						OnGroupsRemoveGroupInvitationRequestEvent -= (PlayFabRequestEvent<RemoveGroupInvitationRequest>)delegate360;
					}
				}
			}
			if (this.OnGroupsRemoveGroupInvitationResultEvent != null)
			{
				invocationList = this.OnGroupsRemoveGroupInvitationResultEvent.GetInvocationList();
				foreach (Delegate delegate361 in invocationList)
				{
					if (delegate361.Target == instance)
					{
						OnGroupsRemoveGroupInvitationResultEvent -= (PlayFabResultEvent<PlayFab.GroupsModels.EmptyResponse>)delegate361;
					}
				}
			}
			if (this.OnGroupsRemoveMembersRequestEvent != null)
			{
				invocationList = this.OnGroupsRemoveMembersRequestEvent.GetInvocationList();
				foreach (Delegate delegate362 in invocationList)
				{
					if (delegate362.Target == instance)
					{
						OnGroupsRemoveMembersRequestEvent -= (PlayFabRequestEvent<RemoveMembersRequest>)delegate362;
					}
				}
			}
			if (this.OnGroupsRemoveMembersResultEvent != null)
			{
				invocationList = this.OnGroupsRemoveMembersResultEvent.GetInvocationList();
				foreach (Delegate delegate363 in invocationList)
				{
					if (delegate363.Target == instance)
					{
						OnGroupsRemoveMembersResultEvent -= (PlayFabResultEvent<PlayFab.GroupsModels.EmptyResponse>)delegate363;
					}
				}
			}
			if (this.OnGroupsUnblockEntityRequestEvent != null)
			{
				invocationList = this.OnGroupsUnblockEntityRequestEvent.GetInvocationList();
				foreach (Delegate delegate364 in invocationList)
				{
					if (delegate364.Target == instance)
					{
						OnGroupsUnblockEntityRequestEvent -= (PlayFabRequestEvent<UnblockEntityRequest>)delegate364;
					}
				}
			}
			if (this.OnGroupsUnblockEntityResultEvent != null)
			{
				invocationList = this.OnGroupsUnblockEntityResultEvent.GetInvocationList();
				foreach (Delegate delegate365 in invocationList)
				{
					if (delegate365.Target == instance)
					{
						OnGroupsUnblockEntityResultEvent -= (PlayFabResultEvent<PlayFab.GroupsModels.EmptyResponse>)delegate365;
					}
				}
			}
			if (this.OnGroupsUpdateGroupRequestEvent != null)
			{
				invocationList = this.OnGroupsUpdateGroupRequestEvent.GetInvocationList();
				foreach (Delegate delegate366 in invocationList)
				{
					if (delegate366.Target == instance)
					{
						OnGroupsUpdateGroupRequestEvent -= (PlayFabRequestEvent<UpdateGroupRequest>)delegate366;
					}
				}
			}
			if (this.OnGroupsUpdateGroupResultEvent != null)
			{
				invocationList = this.OnGroupsUpdateGroupResultEvent.GetInvocationList();
				foreach (Delegate delegate367 in invocationList)
				{
					if (delegate367.Target == instance)
					{
						OnGroupsUpdateGroupResultEvent -= (PlayFabResultEvent<UpdateGroupResponse>)delegate367;
					}
				}
			}
			if (this.OnGroupsUpdateRoleRequestEvent != null)
			{
				invocationList = this.OnGroupsUpdateRoleRequestEvent.GetInvocationList();
				foreach (Delegate delegate368 in invocationList)
				{
					if (delegate368.Target == instance)
					{
						OnGroupsUpdateRoleRequestEvent -= (PlayFabRequestEvent<UpdateGroupRoleRequest>)delegate368;
					}
				}
			}
			if (this.OnGroupsUpdateRoleResultEvent != null)
			{
				invocationList = this.OnGroupsUpdateRoleResultEvent.GetInvocationList();
				foreach (Delegate delegate369 in invocationList)
				{
					if (delegate369.Target == instance)
					{
						OnGroupsUpdateRoleResultEvent -= (PlayFabResultEvent<UpdateGroupRoleResponse>)delegate369;
					}
				}
			}
			if (this.OnLocalizationGetLanguageListRequestEvent != null)
			{
				invocationList = this.OnLocalizationGetLanguageListRequestEvent.GetInvocationList();
				foreach (Delegate delegate370 in invocationList)
				{
					if (delegate370.Target == instance)
					{
						OnLocalizationGetLanguageListRequestEvent -= (PlayFabRequestEvent<GetLanguageListRequest>)delegate370;
					}
				}
			}
			if (this.OnLocalizationGetLanguageListResultEvent != null)
			{
				invocationList = this.OnLocalizationGetLanguageListResultEvent.GetInvocationList();
				foreach (Delegate delegate371 in invocationList)
				{
					if (delegate371.Target == instance)
					{
						OnLocalizationGetLanguageListResultEvent -= (PlayFabResultEvent<GetLanguageListResponse>)delegate371;
					}
				}
			}
			if (this.OnMultiplayerCancelAllMatchmakingTicketsForPlayerRequestEvent != null)
			{
				invocationList = this.OnMultiplayerCancelAllMatchmakingTicketsForPlayerRequestEvent.GetInvocationList();
				foreach (Delegate delegate372 in invocationList)
				{
					if (delegate372.Target == instance)
					{
						OnMultiplayerCancelAllMatchmakingTicketsForPlayerRequestEvent -= (PlayFabRequestEvent<CancelAllMatchmakingTicketsForPlayerRequest>)delegate372;
					}
				}
			}
			if (this.OnMultiplayerCancelAllMatchmakingTicketsForPlayerResultEvent != null)
			{
				invocationList = this.OnMultiplayerCancelAllMatchmakingTicketsForPlayerResultEvent.GetInvocationList();
				foreach (Delegate delegate373 in invocationList)
				{
					if (delegate373.Target == instance)
					{
						OnMultiplayerCancelAllMatchmakingTicketsForPlayerResultEvent -= (PlayFabResultEvent<CancelAllMatchmakingTicketsForPlayerResult>)delegate373;
					}
				}
			}
			if (this.OnMultiplayerCancelMatchmakingTicketRequestEvent != null)
			{
				invocationList = this.OnMultiplayerCancelMatchmakingTicketRequestEvent.GetInvocationList();
				foreach (Delegate delegate374 in invocationList)
				{
					if (delegate374.Target == instance)
					{
						OnMultiplayerCancelMatchmakingTicketRequestEvent -= (PlayFabRequestEvent<CancelMatchmakingTicketRequest>)delegate374;
					}
				}
			}
			if (this.OnMultiplayerCancelMatchmakingTicketResultEvent != null)
			{
				invocationList = this.OnMultiplayerCancelMatchmakingTicketResultEvent.GetInvocationList();
				foreach (Delegate delegate375 in invocationList)
				{
					if (delegate375.Target == instance)
					{
						OnMultiplayerCancelMatchmakingTicketResultEvent -= (PlayFabResultEvent<CancelMatchmakingTicketResult>)delegate375;
					}
				}
			}
			if (this.OnMultiplayerCreateBuildWithCustomContainerRequestEvent != null)
			{
				invocationList = this.OnMultiplayerCreateBuildWithCustomContainerRequestEvent.GetInvocationList();
				foreach (Delegate delegate376 in invocationList)
				{
					if (delegate376.Target == instance)
					{
						OnMultiplayerCreateBuildWithCustomContainerRequestEvent -= (PlayFabRequestEvent<CreateBuildWithCustomContainerRequest>)delegate376;
					}
				}
			}
			if (this.OnMultiplayerCreateBuildWithCustomContainerResultEvent != null)
			{
				invocationList = this.OnMultiplayerCreateBuildWithCustomContainerResultEvent.GetInvocationList();
				foreach (Delegate delegate377 in invocationList)
				{
					if (delegate377.Target == instance)
					{
						OnMultiplayerCreateBuildWithCustomContainerResultEvent -= (PlayFabResultEvent<CreateBuildWithCustomContainerResponse>)delegate377;
					}
				}
			}
			if (this.OnMultiplayerCreateBuildWithManagedContainerRequestEvent != null)
			{
				invocationList = this.OnMultiplayerCreateBuildWithManagedContainerRequestEvent.GetInvocationList();
				foreach (Delegate delegate378 in invocationList)
				{
					if (delegate378.Target == instance)
					{
						OnMultiplayerCreateBuildWithManagedContainerRequestEvent -= (PlayFabRequestEvent<CreateBuildWithManagedContainerRequest>)delegate378;
					}
				}
			}
			if (this.OnMultiplayerCreateBuildWithManagedContainerResultEvent != null)
			{
				invocationList = this.OnMultiplayerCreateBuildWithManagedContainerResultEvent.GetInvocationList();
				foreach (Delegate delegate379 in invocationList)
				{
					if (delegate379.Target == instance)
					{
						OnMultiplayerCreateBuildWithManagedContainerResultEvent -= (PlayFabResultEvent<CreateBuildWithManagedContainerResponse>)delegate379;
					}
				}
			}
			if (this.OnMultiplayerCreateMatchmakingTicketRequestEvent != null)
			{
				invocationList = this.OnMultiplayerCreateMatchmakingTicketRequestEvent.GetInvocationList();
				foreach (Delegate delegate380 in invocationList)
				{
					if (delegate380.Target == instance)
					{
						OnMultiplayerCreateMatchmakingTicketRequestEvent -= (PlayFabRequestEvent<CreateMatchmakingTicketRequest>)delegate380;
					}
				}
			}
			if (this.OnMultiplayerCreateMatchmakingTicketResultEvent != null)
			{
				invocationList = this.OnMultiplayerCreateMatchmakingTicketResultEvent.GetInvocationList();
				foreach (Delegate delegate381 in invocationList)
				{
					if (delegate381.Target == instance)
					{
						OnMultiplayerCreateMatchmakingTicketResultEvent -= (PlayFabResultEvent<CreateMatchmakingTicketResult>)delegate381;
					}
				}
			}
			if (this.OnMultiplayerCreateRemoteUserRequestEvent != null)
			{
				invocationList = this.OnMultiplayerCreateRemoteUserRequestEvent.GetInvocationList();
				foreach (Delegate delegate382 in invocationList)
				{
					if (delegate382.Target == instance)
					{
						OnMultiplayerCreateRemoteUserRequestEvent -= (PlayFabRequestEvent<CreateRemoteUserRequest>)delegate382;
					}
				}
			}
			if (this.OnMultiplayerCreateRemoteUserResultEvent != null)
			{
				invocationList = this.OnMultiplayerCreateRemoteUserResultEvent.GetInvocationList();
				foreach (Delegate delegate383 in invocationList)
				{
					if (delegate383.Target == instance)
					{
						OnMultiplayerCreateRemoteUserResultEvent -= (PlayFabResultEvent<CreateRemoteUserResponse>)delegate383;
					}
				}
			}
			if (this.OnMultiplayerCreateServerMatchmakingTicketRequestEvent != null)
			{
				invocationList = this.OnMultiplayerCreateServerMatchmakingTicketRequestEvent.GetInvocationList();
				foreach (Delegate delegate384 in invocationList)
				{
					if (delegate384.Target == instance)
					{
						OnMultiplayerCreateServerMatchmakingTicketRequestEvent -= (PlayFabRequestEvent<CreateServerMatchmakingTicketRequest>)delegate384;
					}
				}
			}
			if (this.OnMultiplayerCreateServerMatchmakingTicketResultEvent != null)
			{
				invocationList = this.OnMultiplayerCreateServerMatchmakingTicketResultEvent.GetInvocationList();
				foreach (Delegate delegate385 in invocationList)
				{
					if (delegate385.Target == instance)
					{
						OnMultiplayerCreateServerMatchmakingTicketResultEvent -= (PlayFabResultEvent<CreateMatchmakingTicketResult>)delegate385;
					}
				}
			}
			if (this.OnMultiplayerDeleteAssetRequestEvent != null)
			{
				invocationList = this.OnMultiplayerDeleteAssetRequestEvent.GetInvocationList();
				foreach (Delegate delegate386 in invocationList)
				{
					if (delegate386.Target == instance)
					{
						OnMultiplayerDeleteAssetRequestEvent -= (PlayFabRequestEvent<DeleteAssetRequest>)delegate386;
					}
				}
			}
			if (this.OnMultiplayerDeleteAssetResultEvent != null)
			{
				invocationList = this.OnMultiplayerDeleteAssetResultEvent.GetInvocationList();
				foreach (Delegate delegate387 in invocationList)
				{
					if (delegate387.Target == instance)
					{
						OnMultiplayerDeleteAssetResultEvent -= (PlayFabResultEvent<PlayFab.MultiplayerModels.EmptyResponse>)delegate387;
					}
				}
			}
			if (this.OnMultiplayerDeleteBuildRequestEvent != null)
			{
				invocationList = this.OnMultiplayerDeleteBuildRequestEvent.GetInvocationList();
				foreach (Delegate delegate388 in invocationList)
				{
					if (delegate388.Target == instance)
					{
						OnMultiplayerDeleteBuildRequestEvent -= (PlayFabRequestEvent<DeleteBuildRequest>)delegate388;
					}
				}
			}
			if (this.OnMultiplayerDeleteBuildResultEvent != null)
			{
				invocationList = this.OnMultiplayerDeleteBuildResultEvent.GetInvocationList();
				foreach (Delegate delegate389 in invocationList)
				{
					if (delegate389.Target == instance)
					{
						OnMultiplayerDeleteBuildResultEvent -= (PlayFabResultEvent<PlayFab.MultiplayerModels.EmptyResponse>)delegate389;
					}
				}
			}
			if (this.OnMultiplayerDeleteCertificateRequestEvent != null)
			{
				invocationList = this.OnMultiplayerDeleteCertificateRequestEvent.GetInvocationList();
				foreach (Delegate delegate390 in invocationList)
				{
					if (delegate390.Target == instance)
					{
						OnMultiplayerDeleteCertificateRequestEvent -= (PlayFabRequestEvent<DeleteCertificateRequest>)delegate390;
					}
				}
			}
			if (this.OnMultiplayerDeleteCertificateResultEvent != null)
			{
				invocationList = this.OnMultiplayerDeleteCertificateResultEvent.GetInvocationList();
				foreach (Delegate delegate391 in invocationList)
				{
					if (delegate391.Target == instance)
					{
						OnMultiplayerDeleteCertificateResultEvent -= (PlayFabResultEvent<PlayFab.MultiplayerModels.EmptyResponse>)delegate391;
					}
				}
			}
			if (this.OnMultiplayerDeleteRemoteUserRequestEvent != null)
			{
				invocationList = this.OnMultiplayerDeleteRemoteUserRequestEvent.GetInvocationList();
				foreach (Delegate delegate392 in invocationList)
				{
					if (delegate392.Target == instance)
					{
						OnMultiplayerDeleteRemoteUserRequestEvent -= (PlayFabRequestEvent<DeleteRemoteUserRequest>)delegate392;
					}
				}
			}
			if (this.OnMultiplayerDeleteRemoteUserResultEvent != null)
			{
				invocationList = this.OnMultiplayerDeleteRemoteUserResultEvent.GetInvocationList();
				foreach (Delegate delegate393 in invocationList)
				{
					if (delegate393.Target == instance)
					{
						OnMultiplayerDeleteRemoteUserResultEvent -= (PlayFabResultEvent<PlayFab.MultiplayerModels.EmptyResponse>)delegate393;
					}
				}
			}
			if (this.OnMultiplayerEnableMultiplayerServersForTitleRequestEvent != null)
			{
				invocationList = this.OnMultiplayerEnableMultiplayerServersForTitleRequestEvent.GetInvocationList();
				foreach (Delegate delegate394 in invocationList)
				{
					if (delegate394.Target == instance)
					{
						OnMultiplayerEnableMultiplayerServersForTitleRequestEvent -= (PlayFabRequestEvent<EnableMultiplayerServersForTitleRequest>)delegate394;
					}
				}
			}
			if (this.OnMultiplayerEnableMultiplayerServersForTitleResultEvent != null)
			{
				invocationList = this.OnMultiplayerEnableMultiplayerServersForTitleResultEvent.GetInvocationList();
				foreach (Delegate delegate395 in invocationList)
				{
					if (delegate395.Target == instance)
					{
						OnMultiplayerEnableMultiplayerServersForTitleResultEvent -= (PlayFabResultEvent<EnableMultiplayerServersForTitleResponse>)delegate395;
					}
				}
			}
			if (this.OnMultiplayerGetAssetUploadUrlRequestEvent != null)
			{
				invocationList = this.OnMultiplayerGetAssetUploadUrlRequestEvent.GetInvocationList();
				foreach (Delegate delegate396 in invocationList)
				{
					if (delegate396.Target == instance)
					{
						OnMultiplayerGetAssetUploadUrlRequestEvent -= (PlayFabRequestEvent<GetAssetUploadUrlRequest>)delegate396;
					}
				}
			}
			if (this.OnMultiplayerGetAssetUploadUrlResultEvent != null)
			{
				invocationList = this.OnMultiplayerGetAssetUploadUrlResultEvent.GetInvocationList();
				foreach (Delegate delegate397 in invocationList)
				{
					if (delegate397.Target == instance)
					{
						OnMultiplayerGetAssetUploadUrlResultEvent -= (PlayFabResultEvent<GetAssetUploadUrlResponse>)delegate397;
					}
				}
			}
			if (this.OnMultiplayerGetBuildRequestEvent != null)
			{
				invocationList = this.OnMultiplayerGetBuildRequestEvent.GetInvocationList();
				foreach (Delegate delegate398 in invocationList)
				{
					if (delegate398.Target == instance)
					{
						OnMultiplayerGetBuildRequestEvent -= (PlayFabRequestEvent<GetBuildRequest>)delegate398;
					}
				}
			}
			if (this.OnMultiplayerGetBuildResultEvent != null)
			{
				invocationList = this.OnMultiplayerGetBuildResultEvent.GetInvocationList();
				foreach (Delegate delegate399 in invocationList)
				{
					if (delegate399.Target == instance)
					{
						OnMultiplayerGetBuildResultEvent -= (PlayFabResultEvent<GetBuildResponse>)delegate399;
					}
				}
			}
			if (this.OnMultiplayerGetContainerRegistryCredentialsRequestEvent != null)
			{
				invocationList = this.OnMultiplayerGetContainerRegistryCredentialsRequestEvent.GetInvocationList();
				foreach (Delegate delegate400 in invocationList)
				{
					if (delegate400.Target == instance)
					{
						OnMultiplayerGetContainerRegistryCredentialsRequestEvent -= (PlayFabRequestEvent<GetContainerRegistryCredentialsRequest>)delegate400;
					}
				}
			}
			if (this.OnMultiplayerGetContainerRegistryCredentialsResultEvent != null)
			{
				invocationList = this.OnMultiplayerGetContainerRegistryCredentialsResultEvent.GetInvocationList();
				foreach (Delegate delegate401 in invocationList)
				{
					if (delegate401.Target == instance)
					{
						OnMultiplayerGetContainerRegistryCredentialsResultEvent -= (PlayFabResultEvent<GetContainerRegistryCredentialsResponse>)delegate401;
					}
				}
			}
			if (this.OnMultiplayerGetMatchRequestEvent != null)
			{
				invocationList = this.OnMultiplayerGetMatchRequestEvent.GetInvocationList();
				foreach (Delegate delegate402 in invocationList)
				{
					if (delegate402.Target == instance)
					{
						OnMultiplayerGetMatchRequestEvent -= (PlayFabRequestEvent<GetMatchRequest>)delegate402;
					}
				}
			}
			if (this.OnMultiplayerGetMatchResultEvent != null)
			{
				invocationList = this.OnMultiplayerGetMatchResultEvent.GetInvocationList();
				foreach (Delegate delegate403 in invocationList)
				{
					if (delegate403.Target == instance)
					{
						OnMultiplayerGetMatchResultEvent -= (PlayFabResultEvent<GetMatchResult>)delegate403;
					}
				}
			}
			if (this.OnMultiplayerGetMatchmakingTicketRequestEvent != null)
			{
				invocationList = this.OnMultiplayerGetMatchmakingTicketRequestEvent.GetInvocationList();
				foreach (Delegate delegate404 in invocationList)
				{
					if (delegate404.Target == instance)
					{
						OnMultiplayerGetMatchmakingTicketRequestEvent -= (PlayFabRequestEvent<GetMatchmakingTicketRequest>)delegate404;
					}
				}
			}
			if (this.OnMultiplayerGetMatchmakingTicketResultEvent != null)
			{
				invocationList = this.OnMultiplayerGetMatchmakingTicketResultEvent.GetInvocationList();
				foreach (Delegate delegate405 in invocationList)
				{
					if (delegate405.Target == instance)
					{
						OnMultiplayerGetMatchmakingTicketResultEvent -= (PlayFabResultEvent<GetMatchmakingTicketResult>)delegate405;
					}
				}
			}
			if (this.OnMultiplayerGetMultiplayerServerDetailsRequestEvent != null)
			{
				invocationList = this.OnMultiplayerGetMultiplayerServerDetailsRequestEvent.GetInvocationList();
				foreach (Delegate delegate406 in invocationList)
				{
					if (delegate406.Target == instance)
					{
						OnMultiplayerGetMultiplayerServerDetailsRequestEvent -= (PlayFabRequestEvent<GetMultiplayerServerDetailsRequest>)delegate406;
					}
				}
			}
			if (this.OnMultiplayerGetMultiplayerServerDetailsResultEvent != null)
			{
				invocationList = this.OnMultiplayerGetMultiplayerServerDetailsResultEvent.GetInvocationList();
				foreach (Delegate delegate407 in invocationList)
				{
					if (delegate407.Target == instance)
					{
						OnMultiplayerGetMultiplayerServerDetailsResultEvent -= (PlayFabResultEvent<GetMultiplayerServerDetailsResponse>)delegate407;
					}
				}
			}
			if (this.OnMultiplayerGetQueueStatisticsRequestEvent != null)
			{
				invocationList = this.OnMultiplayerGetQueueStatisticsRequestEvent.GetInvocationList();
				foreach (Delegate delegate408 in invocationList)
				{
					if (delegate408.Target == instance)
					{
						OnMultiplayerGetQueueStatisticsRequestEvent -= (PlayFabRequestEvent<GetQueueStatisticsRequest>)delegate408;
					}
				}
			}
			if (this.OnMultiplayerGetQueueStatisticsResultEvent != null)
			{
				invocationList = this.OnMultiplayerGetQueueStatisticsResultEvent.GetInvocationList();
				foreach (Delegate delegate409 in invocationList)
				{
					if (delegate409.Target == instance)
					{
						OnMultiplayerGetQueueStatisticsResultEvent -= (PlayFabResultEvent<GetQueueStatisticsResult>)delegate409;
					}
				}
			}
			if (this.OnMultiplayerGetRemoteLoginEndpointRequestEvent != null)
			{
				invocationList = this.OnMultiplayerGetRemoteLoginEndpointRequestEvent.GetInvocationList();
				foreach (Delegate delegate410 in invocationList)
				{
					if (delegate410.Target == instance)
					{
						OnMultiplayerGetRemoteLoginEndpointRequestEvent -= (PlayFabRequestEvent<GetRemoteLoginEndpointRequest>)delegate410;
					}
				}
			}
			if (this.OnMultiplayerGetRemoteLoginEndpointResultEvent != null)
			{
				invocationList = this.OnMultiplayerGetRemoteLoginEndpointResultEvent.GetInvocationList();
				foreach (Delegate delegate411 in invocationList)
				{
					if (delegate411.Target == instance)
					{
						OnMultiplayerGetRemoteLoginEndpointResultEvent -= (PlayFabResultEvent<GetRemoteLoginEndpointResponse>)delegate411;
					}
				}
			}
			if (this.OnMultiplayerGetTitleEnabledForMultiplayerServersStatusRequestEvent != null)
			{
				invocationList = this.OnMultiplayerGetTitleEnabledForMultiplayerServersStatusRequestEvent.GetInvocationList();
				foreach (Delegate delegate412 in invocationList)
				{
					if (delegate412.Target == instance)
					{
						OnMultiplayerGetTitleEnabledForMultiplayerServersStatusRequestEvent -= (PlayFabRequestEvent<GetTitleEnabledForMultiplayerServersStatusRequest>)delegate412;
					}
				}
			}
			if (this.OnMultiplayerGetTitleEnabledForMultiplayerServersStatusResultEvent != null)
			{
				invocationList = this.OnMultiplayerGetTitleEnabledForMultiplayerServersStatusResultEvent.GetInvocationList();
				foreach (Delegate delegate413 in invocationList)
				{
					if (delegate413.Target == instance)
					{
						OnMultiplayerGetTitleEnabledForMultiplayerServersStatusResultEvent -= (PlayFabResultEvent<GetTitleEnabledForMultiplayerServersStatusResponse>)delegate413;
					}
				}
			}
			if (this.OnMultiplayerGetTitleMultiplayerServersQuotasRequestEvent != null)
			{
				invocationList = this.OnMultiplayerGetTitleMultiplayerServersQuotasRequestEvent.GetInvocationList();
				foreach (Delegate delegate414 in invocationList)
				{
					if (delegate414.Target == instance)
					{
						OnMultiplayerGetTitleMultiplayerServersQuotasRequestEvent -= (PlayFabRequestEvent<GetTitleMultiplayerServersQuotasRequest>)delegate414;
					}
				}
			}
			if (this.OnMultiplayerGetTitleMultiplayerServersQuotasResultEvent != null)
			{
				invocationList = this.OnMultiplayerGetTitleMultiplayerServersQuotasResultEvent.GetInvocationList();
				foreach (Delegate delegate415 in invocationList)
				{
					if (delegate415.Target == instance)
					{
						OnMultiplayerGetTitleMultiplayerServersQuotasResultEvent -= (PlayFabResultEvent<GetTitleMultiplayerServersQuotasResponse>)delegate415;
					}
				}
			}
			if (this.OnMultiplayerJoinMatchmakingTicketRequestEvent != null)
			{
				invocationList = this.OnMultiplayerJoinMatchmakingTicketRequestEvent.GetInvocationList();
				foreach (Delegate delegate416 in invocationList)
				{
					if (delegate416.Target == instance)
					{
						OnMultiplayerJoinMatchmakingTicketRequestEvent -= (PlayFabRequestEvent<JoinMatchmakingTicketRequest>)delegate416;
					}
				}
			}
			if (this.OnMultiplayerJoinMatchmakingTicketResultEvent != null)
			{
				invocationList = this.OnMultiplayerJoinMatchmakingTicketResultEvent.GetInvocationList();
				foreach (Delegate delegate417 in invocationList)
				{
					if (delegate417.Target == instance)
					{
						OnMultiplayerJoinMatchmakingTicketResultEvent -= (PlayFabResultEvent<JoinMatchmakingTicketResult>)delegate417;
					}
				}
			}
			if (this.OnMultiplayerListArchivedMultiplayerServersRequestEvent != null)
			{
				invocationList = this.OnMultiplayerListArchivedMultiplayerServersRequestEvent.GetInvocationList();
				foreach (Delegate delegate418 in invocationList)
				{
					if (delegate418.Target == instance)
					{
						OnMultiplayerListArchivedMultiplayerServersRequestEvent -= (PlayFabRequestEvent<ListMultiplayerServersRequest>)delegate418;
					}
				}
			}
			if (this.OnMultiplayerListArchivedMultiplayerServersResultEvent != null)
			{
				invocationList = this.OnMultiplayerListArchivedMultiplayerServersResultEvent.GetInvocationList();
				foreach (Delegate delegate419 in invocationList)
				{
					if (delegate419.Target == instance)
					{
						OnMultiplayerListArchivedMultiplayerServersResultEvent -= (PlayFabResultEvent<ListMultiplayerServersResponse>)delegate419;
					}
				}
			}
			if (this.OnMultiplayerListAssetSummariesRequestEvent != null)
			{
				invocationList = this.OnMultiplayerListAssetSummariesRequestEvent.GetInvocationList();
				foreach (Delegate delegate420 in invocationList)
				{
					if (delegate420.Target == instance)
					{
						OnMultiplayerListAssetSummariesRequestEvent -= (PlayFabRequestEvent<ListAssetSummariesRequest>)delegate420;
					}
				}
			}
			if (this.OnMultiplayerListAssetSummariesResultEvent != null)
			{
				invocationList = this.OnMultiplayerListAssetSummariesResultEvent.GetInvocationList();
				foreach (Delegate delegate421 in invocationList)
				{
					if (delegate421.Target == instance)
					{
						OnMultiplayerListAssetSummariesResultEvent -= (PlayFabResultEvent<ListAssetSummariesResponse>)delegate421;
					}
				}
			}
			if (this.OnMultiplayerListBuildSummariesRequestEvent != null)
			{
				invocationList = this.OnMultiplayerListBuildSummariesRequestEvent.GetInvocationList();
				foreach (Delegate delegate422 in invocationList)
				{
					if (delegate422.Target == instance)
					{
						OnMultiplayerListBuildSummariesRequestEvent -= (PlayFabRequestEvent<ListBuildSummariesRequest>)delegate422;
					}
				}
			}
			if (this.OnMultiplayerListBuildSummariesResultEvent != null)
			{
				invocationList = this.OnMultiplayerListBuildSummariesResultEvent.GetInvocationList();
				foreach (Delegate delegate423 in invocationList)
				{
					if (delegate423.Target == instance)
					{
						OnMultiplayerListBuildSummariesResultEvent -= (PlayFabResultEvent<ListBuildSummariesResponse>)delegate423;
					}
				}
			}
			if (this.OnMultiplayerListCertificateSummariesRequestEvent != null)
			{
				invocationList = this.OnMultiplayerListCertificateSummariesRequestEvent.GetInvocationList();
				foreach (Delegate delegate424 in invocationList)
				{
					if (delegate424.Target == instance)
					{
						OnMultiplayerListCertificateSummariesRequestEvent -= (PlayFabRequestEvent<ListCertificateSummariesRequest>)delegate424;
					}
				}
			}
			if (this.OnMultiplayerListCertificateSummariesResultEvent != null)
			{
				invocationList = this.OnMultiplayerListCertificateSummariesResultEvent.GetInvocationList();
				foreach (Delegate delegate425 in invocationList)
				{
					if (delegate425.Target == instance)
					{
						OnMultiplayerListCertificateSummariesResultEvent -= (PlayFabResultEvent<ListCertificateSummariesResponse>)delegate425;
					}
				}
			}
			if (this.OnMultiplayerListContainerImagesRequestEvent != null)
			{
				invocationList = this.OnMultiplayerListContainerImagesRequestEvent.GetInvocationList();
				foreach (Delegate delegate426 in invocationList)
				{
					if (delegate426.Target == instance)
					{
						OnMultiplayerListContainerImagesRequestEvent -= (PlayFabRequestEvent<ListContainerImagesRequest>)delegate426;
					}
				}
			}
			if (this.OnMultiplayerListContainerImagesResultEvent != null)
			{
				invocationList = this.OnMultiplayerListContainerImagesResultEvent.GetInvocationList();
				foreach (Delegate delegate427 in invocationList)
				{
					if (delegate427.Target == instance)
					{
						OnMultiplayerListContainerImagesResultEvent -= (PlayFabResultEvent<ListContainerImagesResponse>)delegate427;
					}
				}
			}
			if (this.OnMultiplayerListContainerImageTagsRequestEvent != null)
			{
				invocationList = this.OnMultiplayerListContainerImageTagsRequestEvent.GetInvocationList();
				foreach (Delegate delegate428 in invocationList)
				{
					if (delegate428.Target == instance)
					{
						OnMultiplayerListContainerImageTagsRequestEvent -= (PlayFabRequestEvent<ListContainerImageTagsRequest>)delegate428;
					}
				}
			}
			if (this.OnMultiplayerListContainerImageTagsResultEvent != null)
			{
				invocationList = this.OnMultiplayerListContainerImageTagsResultEvent.GetInvocationList();
				foreach (Delegate delegate429 in invocationList)
				{
					if (delegate429.Target == instance)
					{
						OnMultiplayerListContainerImageTagsResultEvent -= (PlayFabResultEvent<ListContainerImageTagsResponse>)delegate429;
					}
				}
			}
			if (this.OnMultiplayerListMatchmakingTicketsForPlayerRequestEvent != null)
			{
				invocationList = this.OnMultiplayerListMatchmakingTicketsForPlayerRequestEvent.GetInvocationList();
				foreach (Delegate delegate430 in invocationList)
				{
					if (delegate430.Target == instance)
					{
						OnMultiplayerListMatchmakingTicketsForPlayerRequestEvent -= (PlayFabRequestEvent<ListMatchmakingTicketsForPlayerRequest>)delegate430;
					}
				}
			}
			if (this.OnMultiplayerListMatchmakingTicketsForPlayerResultEvent != null)
			{
				invocationList = this.OnMultiplayerListMatchmakingTicketsForPlayerResultEvent.GetInvocationList();
				foreach (Delegate delegate431 in invocationList)
				{
					if (delegate431.Target == instance)
					{
						OnMultiplayerListMatchmakingTicketsForPlayerResultEvent -= (PlayFabResultEvent<ListMatchmakingTicketsForPlayerResult>)delegate431;
					}
				}
			}
			if (this.OnMultiplayerListMultiplayerServersRequestEvent != null)
			{
				invocationList = this.OnMultiplayerListMultiplayerServersRequestEvent.GetInvocationList();
				foreach (Delegate delegate432 in invocationList)
				{
					if (delegate432.Target == instance)
					{
						OnMultiplayerListMultiplayerServersRequestEvent -= (PlayFabRequestEvent<ListMultiplayerServersRequest>)delegate432;
					}
				}
			}
			if (this.OnMultiplayerListMultiplayerServersResultEvent != null)
			{
				invocationList = this.OnMultiplayerListMultiplayerServersResultEvent.GetInvocationList();
				foreach (Delegate delegate433 in invocationList)
				{
					if (delegate433.Target == instance)
					{
						OnMultiplayerListMultiplayerServersResultEvent -= (PlayFabResultEvent<ListMultiplayerServersResponse>)delegate433;
					}
				}
			}
			if (this.OnMultiplayerListPartyQosServersRequestEvent != null)
			{
				invocationList = this.OnMultiplayerListPartyQosServersRequestEvent.GetInvocationList();
				foreach (Delegate delegate434 in invocationList)
				{
					if (delegate434.Target == instance)
					{
						OnMultiplayerListPartyQosServersRequestEvent -= (PlayFabRequestEvent<ListPartyQosServersRequest>)delegate434;
					}
				}
			}
			if (this.OnMultiplayerListPartyQosServersResultEvent != null)
			{
				invocationList = this.OnMultiplayerListPartyQosServersResultEvent.GetInvocationList();
				foreach (Delegate delegate435 in invocationList)
				{
					if (delegate435.Target == instance)
					{
						OnMultiplayerListPartyQosServersResultEvent -= (PlayFabResultEvent<ListPartyQosServersResponse>)delegate435;
					}
				}
			}
			if (this.OnMultiplayerListQosServersRequestEvent != null)
			{
				invocationList = this.OnMultiplayerListQosServersRequestEvent.GetInvocationList();
				foreach (Delegate delegate436 in invocationList)
				{
					if (delegate436.Target == instance)
					{
						OnMultiplayerListQosServersRequestEvent -= (PlayFabRequestEvent<ListQosServersRequest>)delegate436;
					}
				}
			}
			if (this.OnMultiplayerListQosServersResultEvent != null)
			{
				invocationList = this.OnMultiplayerListQosServersResultEvent.GetInvocationList();
				foreach (Delegate delegate437 in invocationList)
				{
					if (delegate437.Target == instance)
					{
						OnMultiplayerListQosServersResultEvent -= (PlayFabResultEvent<ListQosServersResponse>)delegate437;
					}
				}
			}
			if (this.OnMultiplayerListQosServersForTitleRequestEvent != null)
			{
				invocationList = this.OnMultiplayerListQosServersForTitleRequestEvent.GetInvocationList();
				foreach (Delegate delegate438 in invocationList)
				{
					if (delegate438.Target == instance)
					{
						OnMultiplayerListQosServersForTitleRequestEvent -= (PlayFabRequestEvent<ListQosServersForTitleRequest>)delegate438;
					}
				}
			}
			if (this.OnMultiplayerListQosServersForTitleResultEvent != null)
			{
				invocationList = this.OnMultiplayerListQosServersForTitleResultEvent.GetInvocationList();
				foreach (Delegate delegate439 in invocationList)
				{
					if (delegate439.Target == instance)
					{
						OnMultiplayerListQosServersForTitleResultEvent -= (PlayFabResultEvent<ListQosServersForTitleResponse>)delegate439;
					}
				}
			}
			if (this.OnMultiplayerListVirtualMachineSummariesRequestEvent != null)
			{
				invocationList = this.OnMultiplayerListVirtualMachineSummariesRequestEvent.GetInvocationList();
				foreach (Delegate delegate440 in invocationList)
				{
					if (delegate440.Target == instance)
					{
						OnMultiplayerListVirtualMachineSummariesRequestEvent -= (PlayFabRequestEvent<ListVirtualMachineSummariesRequest>)delegate440;
					}
				}
			}
			if (this.OnMultiplayerListVirtualMachineSummariesResultEvent != null)
			{
				invocationList = this.OnMultiplayerListVirtualMachineSummariesResultEvent.GetInvocationList();
				foreach (Delegate delegate441 in invocationList)
				{
					if (delegate441.Target == instance)
					{
						OnMultiplayerListVirtualMachineSummariesResultEvent -= (PlayFabResultEvent<ListVirtualMachineSummariesResponse>)delegate441;
					}
				}
			}
			if (this.OnMultiplayerRequestMultiplayerServerRequestEvent != null)
			{
				invocationList = this.OnMultiplayerRequestMultiplayerServerRequestEvent.GetInvocationList();
				foreach (Delegate delegate442 in invocationList)
				{
					if (delegate442.Target == instance)
					{
						OnMultiplayerRequestMultiplayerServerRequestEvent -= (PlayFabRequestEvent<RequestMultiplayerServerRequest>)delegate442;
					}
				}
			}
			if (this.OnMultiplayerRequestMultiplayerServerResultEvent != null)
			{
				invocationList = this.OnMultiplayerRequestMultiplayerServerResultEvent.GetInvocationList();
				foreach (Delegate delegate443 in invocationList)
				{
					if (delegate443.Target == instance)
					{
						OnMultiplayerRequestMultiplayerServerResultEvent -= (PlayFabResultEvent<RequestMultiplayerServerResponse>)delegate443;
					}
				}
			}
			if (this.OnMultiplayerRolloverContainerRegistryCredentialsRequestEvent != null)
			{
				invocationList = this.OnMultiplayerRolloverContainerRegistryCredentialsRequestEvent.GetInvocationList();
				foreach (Delegate delegate444 in invocationList)
				{
					if (delegate444.Target == instance)
					{
						OnMultiplayerRolloverContainerRegistryCredentialsRequestEvent -= (PlayFabRequestEvent<RolloverContainerRegistryCredentialsRequest>)delegate444;
					}
				}
			}
			if (this.OnMultiplayerRolloverContainerRegistryCredentialsResultEvent != null)
			{
				invocationList = this.OnMultiplayerRolloverContainerRegistryCredentialsResultEvent.GetInvocationList();
				foreach (Delegate delegate445 in invocationList)
				{
					if (delegate445.Target == instance)
					{
						OnMultiplayerRolloverContainerRegistryCredentialsResultEvent -= (PlayFabResultEvent<RolloverContainerRegistryCredentialsResponse>)delegate445;
					}
				}
			}
			if (this.OnMultiplayerShutdownMultiplayerServerRequestEvent != null)
			{
				invocationList = this.OnMultiplayerShutdownMultiplayerServerRequestEvent.GetInvocationList();
				foreach (Delegate delegate446 in invocationList)
				{
					if (delegate446.Target == instance)
					{
						OnMultiplayerShutdownMultiplayerServerRequestEvent -= (PlayFabRequestEvent<ShutdownMultiplayerServerRequest>)delegate446;
					}
				}
			}
			if (this.OnMultiplayerShutdownMultiplayerServerResultEvent != null)
			{
				invocationList = this.OnMultiplayerShutdownMultiplayerServerResultEvent.GetInvocationList();
				foreach (Delegate delegate447 in invocationList)
				{
					if (delegate447.Target == instance)
					{
						OnMultiplayerShutdownMultiplayerServerResultEvent -= (PlayFabResultEvent<PlayFab.MultiplayerModels.EmptyResponse>)delegate447;
					}
				}
			}
			if (this.OnMultiplayerUpdateBuildRegionsRequestEvent != null)
			{
				invocationList = this.OnMultiplayerUpdateBuildRegionsRequestEvent.GetInvocationList();
				foreach (Delegate delegate448 in invocationList)
				{
					if (delegate448.Target == instance)
					{
						OnMultiplayerUpdateBuildRegionsRequestEvent -= (PlayFabRequestEvent<UpdateBuildRegionsRequest>)delegate448;
					}
				}
			}
			if (this.OnMultiplayerUpdateBuildRegionsResultEvent != null)
			{
				invocationList = this.OnMultiplayerUpdateBuildRegionsResultEvent.GetInvocationList();
				foreach (Delegate delegate449 in invocationList)
				{
					if (delegate449.Target == instance)
					{
						OnMultiplayerUpdateBuildRegionsResultEvent -= (PlayFabResultEvent<PlayFab.MultiplayerModels.EmptyResponse>)delegate449;
					}
				}
			}
			if (this.OnMultiplayerUploadCertificateRequestEvent != null)
			{
				invocationList = this.OnMultiplayerUploadCertificateRequestEvent.GetInvocationList();
				foreach (Delegate delegate450 in invocationList)
				{
					if (delegate450.Target == instance)
					{
						OnMultiplayerUploadCertificateRequestEvent -= (PlayFabRequestEvent<UploadCertificateRequest>)delegate450;
					}
				}
			}
			if (this.OnMultiplayerUploadCertificateResultEvent != null)
			{
				invocationList = this.OnMultiplayerUploadCertificateResultEvent.GetInvocationList();
				foreach (Delegate delegate451 in invocationList)
				{
					if (delegate451.Target == instance)
					{
						OnMultiplayerUploadCertificateResultEvent -= (PlayFabResultEvent<PlayFab.MultiplayerModels.EmptyResponse>)delegate451;
					}
				}
			}
			if (this.OnProfilesGetGlobalPolicyRequestEvent != null)
			{
				invocationList = this.OnProfilesGetGlobalPolicyRequestEvent.GetInvocationList();
				foreach (Delegate delegate452 in invocationList)
				{
					if (delegate452.Target == instance)
					{
						OnProfilesGetGlobalPolicyRequestEvent -= (PlayFabRequestEvent<GetGlobalPolicyRequest>)delegate452;
					}
				}
			}
			if (this.OnProfilesGetGlobalPolicyResultEvent != null)
			{
				invocationList = this.OnProfilesGetGlobalPolicyResultEvent.GetInvocationList();
				foreach (Delegate delegate453 in invocationList)
				{
					if (delegate453.Target == instance)
					{
						OnProfilesGetGlobalPolicyResultEvent -= (PlayFabResultEvent<GetGlobalPolicyResponse>)delegate453;
					}
				}
			}
			if (this.OnProfilesGetProfileRequestEvent != null)
			{
				invocationList = this.OnProfilesGetProfileRequestEvent.GetInvocationList();
				foreach (Delegate delegate454 in invocationList)
				{
					if (delegate454.Target == instance)
					{
						OnProfilesGetProfileRequestEvent -= (PlayFabRequestEvent<GetEntityProfileRequest>)delegate454;
					}
				}
			}
			if (this.OnProfilesGetProfileResultEvent != null)
			{
				invocationList = this.OnProfilesGetProfileResultEvent.GetInvocationList();
				foreach (Delegate delegate455 in invocationList)
				{
					if (delegate455.Target == instance)
					{
						OnProfilesGetProfileResultEvent -= (PlayFabResultEvent<GetEntityProfileResponse>)delegate455;
					}
				}
			}
			if (this.OnProfilesGetProfilesRequestEvent != null)
			{
				invocationList = this.OnProfilesGetProfilesRequestEvent.GetInvocationList();
				foreach (Delegate delegate456 in invocationList)
				{
					if (delegate456.Target == instance)
					{
						OnProfilesGetProfilesRequestEvent -= (PlayFabRequestEvent<GetEntityProfilesRequest>)delegate456;
					}
				}
			}
			if (this.OnProfilesGetProfilesResultEvent != null)
			{
				invocationList = this.OnProfilesGetProfilesResultEvent.GetInvocationList();
				foreach (Delegate delegate457 in invocationList)
				{
					if (delegate457.Target == instance)
					{
						OnProfilesGetProfilesResultEvent -= (PlayFabResultEvent<GetEntityProfilesResponse>)delegate457;
					}
				}
			}
			if (this.OnProfilesGetTitlePlayersFromMasterPlayerAccountIdsRequestEvent != null)
			{
				invocationList = this.OnProfilesGetTitlePlayersFromMasterPlayerAccountIdsRequestEvent.GetInvocationList();
				foreach (Delegate delegate458 in invocationList)
				{
					if (delegate458.Target == instance)
					{
						OnProfilesGetTitlePlayersFromMasterPlayerAccountIdsRequestEvent -= (PlayFabRequestEvent<GetTitlePlayersFromMasterPlayerAccountIdsRequest>)delegate458;
					}
				}
			}
			if (this.OnProfilesGetTitlePlayersFromMasterPlayerAccountIdsResultEvent != null)
			{
				invocationList = this.OnProfilesGetTitlePlayersFromMasterPlayerAccountIdsResultEvent.GetInvocationList();
				foreach (Delegate delegate459 in invocationList)
				{
					if (delegate459.Target == instance)
					{
						OnProfilesGetTitlePlayersFromMasterPlayerAccountIdsResultEvent -= (PlayFabResultEvent<GetTitlePlayersFromMasterPlayerAccountIdsResponse>)delegate459;
					}
				}
			}
			if (this.OnProfilesSetGlobalPolicyRequestEvent != null)
			{
				invocationList = this.OnProfilesSetGlobalPolicyRequestEvent.GetInvocationList();
				foreach (Delegate delegate460 in invocationList)
				{
					if (delegate460.Target == instance)
					{
						OnProfilesSetGlobalPolicyRequestEvent -= (PlayFabRequestEvent<SetGlobalPolicyRequest>)delegate460;
					}
				}
			}
			if (this.OnProfilesSetGlobalPolicyResultEvent != null)
			{
				invocationList = this.OnProfilesSetGlobalPolicyResultEvent.GetInvocationList();
				foreach (Delegate delegate461 in invocationList)
				{
					if (delegate461.Target == instance)
					{
						OnProfilesSetGlobalPolicyResultEvent -= (PlayFabResultEvent<SetGlobalPolicyResponse>)delegate461;
					}
				}
			}
			if (this.OnProfilesSetProfileLanguageRequestEvent != null)
			{
				invocationList = this.OnProfilesSetProfileLanguageRequestEvent.GetInvocationList();
				foreach (Delegate delegate462 in invocationList)
				{
					if (delegate462.Target == instance)
					{
						OnProfilesSetProfileLanguageRequestEvent -= (PlayFabRequestEvent<SetProfileLanguageRequest>)delegate462;
					}
				}
			}
			if (this.OnProfilesSetProfileLanguageResultEvent != null)
			{
				invocationList = this.OnProfilesSetProfileLanguageResultEvent.GetInvocationList();
				foreach (Delegate delegate463 in invocationList)
				{
					if (delegate463.Target == instance)
					{
						OnProfilesSetProfileLanguageResultEvent -= (PlayFabResultEvent<SetProfileLanguageResponse>)delegate463;
					}
				}
			}
			if (this.OnProfilesSetProfilePolicyRequestEvent != null)
			{
				invocationList = this.OnProfilesSetProfilePolicyRequestEvent.GetInvocationList();
				foreach (Delegate delegate464 in invocationList)
				{
					if (delegate464.Target == instance)
					{
						OnProfilesSetProfilePolicyRequestEvent -= (PlayFabRequestEvent<SetEntityProfilePolicyRequest>)delegate464;
					}
				}
			}
			if (this.OnProfilesSetProfilePolicyResultEvent == null)
			{
				return;
			}
			invocationList = this.OnProfilesSetProfilePolicyResultEvent.GetInvocationList();
			foreach (Delegate delegate465 in invocationList)
			{
				if (delegate465.Target == instance)
				{
					OnProfilesSetProfilePolicyResultEvent -= (PlayFabResultEvent<SetEntityProfilePolicyResponse>)delegate465;
				}
			}
		}

		private void OnProcessingErrorEvent(PlayFabRequestCommon request, PlayFabError error)
		{
			if (_instance.OnGlobalErrorEvent != null)
			{
				_instance.OnGlobalErrorEvent(request, error);
			}
		}

		private void OnProcessingEvent(ApiProcessingEventArgs e)
		{
			if (e.EventType == ApiProcessingEventType.Pre)
			{
				Type type = e.Request.GetType();
				if (type == typeof(AcceptTradeRequest) && _instance.OnAcceptTradeRequestEvent != null)
				{
					_instance.OnAcceptTradeRequestEvent((AcceptTradeRequest)e.Request);
				}
				else if (type == typeof(AddFriendRequest) && _instance.OnAddFriendRequestEvent != null)
				{
					_instance.OnAddFriendRequestEvent((AddFriendRequest)e.Request);
				}
				else if (type == typeof(AddGenericIDRequest) && _instance.OnAddGenericIDRequestEvent != null)
				{
					_instance.OnAddGenericIDRequestEvent((AddGenericIDRequest)e.Request);
				}
				else if (type == typeof(AddOrUpdateContactEmailRequest) && _instance.OnAddOrUpdateContactEmailRequestEvent != null)
				{
					_instance.OnAddOrUpdateContactEmailRequestEvent((AddOrUpdateContactEmailRequest)e.Request);
				}
				else if (type == typeof(AddSharedGroupMembersRequest) && _instance.OnAddSharedGroupMembersRequestEvent != null)
				{
					_instance.OnAddSharedGroupMembersRequestEvent((AddSharedGroupMembersRequest)e.Request);
				}
				else if (type == typeof(AddUsernamePasswordRequest) && _instance.OnAddUsernamePasswordRequestEvent != null)
				{
					_instance.OnAddUsernamePasswordRequestEvent((AddUsernamePasswordRequest)e.Request);
				}
				else if (type == typeof(AddUserVirtualCurrencyRequest) && _instance.OnAddUserVirtualCurrencyRequestEvent != null)
				{
					_instance.OnAddUserVirtualCurrencyRequestEvent((AddUserVirtualCurrencyRequest)e.Request);
				}
				else if (type == typeof(AndroidDevicePushNotificationRegistrationRequest) && _instance.OnAndroidDevicePushNotificationRegistrationRequestEvent != null)
				{
					_instance.OnAndroidDevicePushNotificationRegistrationRequestEvent((AndroidDevicePushNotificationRegistrationRequest)e.Request);
				}
				else if (type == typeof(AttributeInstallRequest) && _instance.OnAttributeInstallRequestEvent != null)
				{
					_instance.OnAttributeInstallRequestEvent((AttributeInstallRequest)e.Request);
				}
				else if (type == typeof(CancelTradeRequest) && _instance.OnCancelTradeRequestEvent != null)
				{
					_instance.OnCancelTradeRequestEvent((CancelTradeRequest)e.Request);
				}
				else if (type == typeof(ConfirmPurchaseRequest) && _instance.OnConfirmPurchaseRequestEvent != null)
				{
					_instance.OnConfirmPurchaseRequestEvent((ConfirmPurchaseRequest)e.Request);
				}
				else if (type == typeof(ConsumeItemRequest) && _instance.OnConsumeItemRequestEvent != null)
				{
					_instance.OnConsumeItemRequestEvent((ConsumeItemRequest)e.Request);
				}
				else if (type == typeof(ConsumePSNEntitlementsRequest) && _instance.OnConsumePSNEntitlementsRequestEvent != null)
				{
					_instance.OnConsumePSNEntitlementsRequestEvent((ConsumePSNEntitlementsRequest)e.Request);
				}
				else if (type == typeof(ConsumeXboxEntitlementsRequest) && _instance.OnConsumeXboxEntitlementsRequestEvent != null)
				{
					_instance.OnConsumeXboxEntitlementsRequestEvent((ConsumeXboxEntitlementsRequest)e.Request);
				}
				else if (type == typeof(CreateSharedGroupRequest) && _instance.OnCreateSharedGroupRequestEvent != null)
				{
					_instance.OnCreateSharedGroupRequestEvent((CreateSharedGroupRequest)e.Request);
				}
				else if (type == typeof(ExecuteCloudScriptRequest) && _instance.OnExecuteCloudScriptRequestEvent != null)
				{
					_instance.OnExecuteCloudScriptRequestEvent((ExecuteCloudScriptRequest)e.Request);
				}
				else if (type == typeof(GetAccountInfoRequest) && _instance.OnGetAccountInfoRequestEvent != null)
				{
					_instance.OnGetAccountInfoRequestEvent((GetAccountInfoRequest)e.Request);
				}
				else if (type == typeof(ListUsersCharactersRequest) && _instance.OnGetAllUsersCharactersRequestEvent != null)
				{
					_instance.OnGetAllUsersCharactersRequestEvent((ListUsersCharactersRequest)e.Request);
				}
				else if (type == typeof(GetCatalogItemsRequest) && _instance.OnGetCatalogItemsRequestEvent != null)
				{
					_instance.OnGetCatalogItemsRequestEvent((GetCatalogItemsRequest)e.Request);
				}
				else if (type == typeof(GetCharacterDataRequest) && _instance.OnGetCharacterDataRequestEvent != null)
				{
					_instance.OnGetCharacterDataRequestEvent((GetCharacterDataRequest)e.Request);
				}
				else if (type == typeof(GetCharacterInventoryRequest) && _instance.OnGetCharacterInventoryRequestEvent != null)
				{
					_instance.OnGetCharacterInventoryRequestEvent((GetCharacterInventoryRequest)e.Request);
				}
				else if (type == typeof(GetCharacterLeaderboardRequest) && _instance.OnGetCharacterLeaderboardRequestEvent != null)
				{
					_instance.OnGetCharacterLeaderboardRequestEvent((GetCharacterLeaderboardRequest)e.Request);
				}
				else if (type == typeof(GetCharacterDataRequest) && _instance.OnGetCharacterReadOnlyDataRequestEvent != null)
				{
					_instance.OnGetCharacterReadOnlyDataRequestEvent((GetCharacterDataRequest)e.Request);
				}
				else if (type == typeof(GetCharacterStatisticsRequest) && _instance.OnGetCharacterStatisticsRequestEvent != null)
				{
					_instance.OnGetCharacterStatisticsRequestEvent((GetCharacterStatisticsRequest)e.Request);
				}
				else if (type == typeof(GetContentDownloadUrlRequest) && _instance.OnGetContentDownloadUrlRequestEvent != null)
				{
					_instance.OnGetContentDownloadUrlRequestEvent((GetContentDownloadUrlRequest)e.Request);
				}
				else if (type == typeof(CurrentGamesRequest) && _instance.OnGetCurrentGamesRequestEvent != null)
				{
					_instance.OnGetCurrentGamesRequestEvent((CurrentGamesRequest)e.Request);
				}
				else if (type == typeof(GetFriendLeaderboardRequest) && _instance.OnGetFriendLeaderboardRequestEvent != null)
				{
					_instance.OnGetFriendLeaderboardRequestEvent((GetFriendLeaderboardRequest)e.Request);
				}
				else if (type == typeof(GetFriendLeaderboardAroundPlayerRequest) && _instance.OnGetFriendLeaderboardAroundPlayerRequestEvent != null)
				{
					_instance.OnGetFriendLeaderboardAroundPlayerRequestEvent((GetFriendLeaderboardAroundPlayerRequest)e.Request);
				}
				else if (type == typeof(GetFriendsListRequest) && _instance.OnGetFriendsListRequestEvent != null)
				{
					_instance.OnGetFriendsListRequestEvent((GetFriendsListRequest)e.Request);
				}
				else if (type == typeof(GameServerRegionsRequest) && _instance.OnGetGameServerRegionsRequestEvent != null)
				{
					_instance.OnGetGameServerRegionsRequestEvent((GameServerRegionsRequest)e.Request);
				}
				else if (type == typeof(GetLeaderboardRequest) && _instance.OnGetLeaderboardRequestEvent != null)
				{
					_instance.OnGetLeaderboardRequestEvent((GetLeaderboardRequest)e.Request);
				}
				else if (type == typeof(GetLeaderboardAroundCharacterRequest) && _instance.OnGetLeaderboardAroundCharacterRequestEvent != null)
				{
					_instance.OnGetLeaderboardAroundCharacterRequestEvent((GetLeaderboardAroundCharacterRequest)e.Request);
				}
				else if (type == typeof(GetLeaderboardAroundPlayerRequest) && _instance.OnGetLeaderboardAroundPlayerRequestEvent != null)
				{
					_instance.OnGetLeaderboardAroundPlayerRequestEvent((GetLeaderboardAroundPlayerRequest)e.Request);
				}
				else if (type == typeof(GetLeaderboardForUsersCharactersRequest) && _instance.OnGetLeaderboardForUserCharactersRequestEvent != null)
				{
					_instance.OnGetLeaderboardForUserCharactersRequestEvent((GetLeaderboardForUsersCharactersRequest)e.Request);
				}
				else if (type == typeof(GetPaymentTokenRequest) && _instance.OnGetPaymentTokenRequestEvent != null)
				{
					_instance.OnGetPaymentTokenRequestEvent((GetPaymentTokenRequest)e.Request);
				}
				else if (type == typeof(GetPhotonAuthenticationTokenRequest) && _instance.OnGetPhotonAuthenticationTokenRequestEvent != null)
				{
					_instance.OnGetPhotonAuthenticationTokenRequestEvent((GetPhotonAuthenticationTokenRequest)e.Request);
				}
				else if (type == typeof(GetPlayerCombinedInfoRequest) && _instance.OnGetPlayerCombinedInfoRequestEvent != null)
				{
					_instance.OnGetPlayerCombinedInfoRequestEvent((GetPlayerCombinedInfoRequest)e.Request);
				}
				else if (type == typeof(GetPlayerProfileRequest) && _instance.OnGetPlayerProfileRequestEvent != null)
				{
					_instance.OnGetPlayerProfileRequestEvent((GetPlayerProfileRequest)e.Request);
				}
				else if (type == typeof(GetPlayerSegmentsRequest) && _instance.OnGetPlayerSegmentsRequestEvent != null)
				{
					_instance.OnGetPlayerSegmentsRequestEvent((GetPlayerSegmentsRequest)e.Request);
				}
				else if (type == typeof(GetPlayerStatisticsRequest) && _instance.OnGetPlayerStatisticsRequestEvent != null)
				{
					_instance.OnGetPlayerStatisticsRequestEvent((GetPlayerStatisticsRequest)e.Request);
				}
				else if (type == typeof(GetPlayerStatisticVersionsRequest) && _instance.OnGetPlayerStatisticVersionsRequestEvent != null)
				{
					_instance.OnGetPlayerStatisticVersionsRequestEvent((GetPlayerStatisticVersionsRequest)e.Request);
				}
				else if (type == typeof(GetPlayerTagsRequest) && _instance.OnGetPlayerTagsRequestEvent != null)
				{
					_instance.OnGetPlayerTagsRequestEvent((GetPlayerTagsRequest)e.Request);
				}
				else if (type == typeof(GetPlayerTradesRequest) && _instance.OnGetPlayerTradesRequestEvent != null)
				{
					_instance.OnGetPlayerTradesRequestEvent((GetPlayerTradesRequest)e.Request);
				}
				else if (type == typeof(GetPlayFabIDsFromFacebookIDsRequest) && _instance.OnGetPlayFabIDsFromFacebookIDsRequestEvent != null)
				{
					_instance.OnGetPlayFabIDsFromFacebookIDsRequestEvent((GetPlayFabIDsFromFacebookIDsRequest)e.Request);
				}
				else if (type == typeof(GetPlayFabIDsFromFacebookInstantGamesIdsRequest) && _instance.OnGetPlayFabIDsFromFacebookInstantGamesIdsRequestEvent != null)
				{
					_instance.OnGetPlayFabIDsFromFacebookInstantGamesIdsRequestEvent((GetPlayFabIDsFromFacebookInstantGamesIdsRequest)e.Request);
				}
				else if (type == typeof(GetPlayFabIDsFromGameCenterIDsRequest) && _instance.OnGetPlayFabIDsFromGameCenterIDsRequestEvent != null)
				{
					_instance.OnGetPlayFabIDsFromGameCenterIDsRequestEvent((GetPlayFabIDsFromGameCenterIDsRequest)e.Request);
				}
				else if (type == typeof(GetPlayFabIDsFromGenericIDsRequest) && _instance.OnGetPlayFabIDsFromGenericIDsRequestEvent != null)
				{
					_instance.OnGetPlayFabIDsFromGenericIDsRequestEvent((GetPlayFabIDsFromGenericIDsRequest)e.Request);
				}
				else if (type == typeof(GetPlayFabIDsFromGoogleIDsRequest) && _instance.OnGetPlayFabIDsFromGoogleIDsRequestEvent != null)
				{
					_instance.OnGetPlayFabIDsFromGoogleIDsRequestEvent((GetPlayFabIDsFromGoogleIDsRequest)e.Request);
				}
				else if (type == typeof(GetPlayFabIDsFromKongregateIDsRequest) && _instance.OnGetPlayFabIDsFromKongregateIDsRequestEvent != null)
				{
					_instance.OnGetPlayFabIDsFromKongregateIDsRequestEvent((GetPlayFabIDsFromKongregateIDsRequest)e.Request);
				}
				else if (type == typeof(GetPlayFabIDsFromNintendoSwitchDeviceIdsRequest) && _instance.OnGetPlayFabIDsFromNintendoSwitchDeviceIdsRequestEvent != null)
				{
					_instance.OnGetPlayFabIDsFromNintendoSwitchDeviceIdsRequestEvent((GetPlayFabIDsFromNintendoSwitchDeviceIdsRequest)e.Request);
				}
				else if (type == typeof(GetPlayFabIDsFromPSNAccountIDsRequest) && _instance.OnGetPlayFabIDsFromPSNAccountIDsRequestEvent != null)
				{
					_instance.OnGetPlayFabIDsFromPSNAccountIDsRequestEvent((GetPlayFabIDsFromPSNAccountIDsRequest)e.Request);
				}
				else if (type == typeof(GetPlayFabIDsFromSteamIDsRequest) && _instance.OnGetPlayFabIDsFromSteamIDsRequestEvent != null)
				{
					_instance.OnGetPlayFabIDsFromSteamIDsRequestEvent((GetPlayFabIDsFromSteamIDsRequest)e.Request);
				}
				else if (type == typeof(GetPlayFabIDsFromTwitchIDsRequest) && _instance.OnGetPlayFabIDsFromTwitchIDsRequestEvent != null)
				{
					_instance.OnGetPlayFabIDsFromTwitchIDsRequestEvent((GetPlayFabIDsFromTwitchIDsRequest)e.Request);
				}
				else if (type == typeof(GetPlayFabIDsFromXboxLiveIDsRequest) && _instance.OnGetPlayFabIDsFromXboxLiveIDsRequestEvent != null)
				{
					_instance.OnGetPlayFabIDsFromXboxLiveIDsRequestEvent((GetPlayFabIDsFromXboxLiveIDsRequest)e.Request);
				}
				else if (type == typeof(GetPublisherDataRequest) && _instance.OnGetPublisherDataRequestEvent != null)
				{
					_instance.OnGetPublisherDataRequestEvent((GetPublisherDataRequest)e.Request);
				}
				else if (type == typeof(GetPurchaseRequest) && _instance.OnGetPurchaseRequestEvent != null)
				{
					_instance.OnGetPurchaseRequestEvent((GetPurchaseRequest)e.Request);
				}
				else if (type == typeof(GetSharedGroupDataRequest) && _instance.OnGetSharedGroupDataRequestEvent != null)
				{
					_instance.OnGetSharedGroupDataRequestEvent((GetSharedGroupDataRequest)e.Request);
				}
				else if (type == typeof(GetStoreItemsRequest) && _instance.OnGetStoreItemsRequestEvent != null)
				{
					_instance.OnGetStoreItemsRequestEvent((GetStoreItemsRequest)e.Request);
				}
				else if (type == typeof(GetTimeRequest) && _instance.OnGetTimeRequestEvent != null)
				{
					_instance.OnGetTimeRequestEvent((GetTimeRequest)e.Request);
				}
				else if (type == typeof(GetTitleDataRequest) && _instance.OnGetTitleDataRequestEvent != null)
				{
					_instance.OnGetTitleDataRequestEvent((GetTitleDataRequest)e.Request);
				}
				else if (type == typeof(GetTitleNewsRequest) && _instance.OnGetTitleNewsRequestEvent != null)
				{
					_instance.OnGetTitleNewsRequestEvent((GetTitleNewsRequest)e.Request);
				}
				else if (type == typeof(GetTitlePublicKeyRequest) && _instance.OnGetTitlePublicKeyRequestEvent != null)
				{
					_instance.OnGetTitlePublicKeyRequestEvent((GetTitlePublicKeyRequest)e.Request);
				}
				else if (type == typeof(GetTradeStatusRequest) && _instance.OnGetTradeStatusRequestEvent != null)
				{
					_instance.OnGetTradeStatusRequestEvent((GetTradeStatusRequest)e.Request);
				}
				else if (type == typeof(GetUserDataRequest) && _instance.OnGetUserDataRequestEvent != null)
				{
					_instance.OnGetUserDataRequestEvent((GetUserDataRequest)e.Request);
				}
				else if (type == typeof(GetUserInventoryRequest) && _instance.OnGetUserInventoryRequestEvent != null)
				{
					_instance.OnGetUserInventoryRequestEvent((GetUserInventoryRequest)e.Request);
				}
				else if (type == typeof(GetUserDataRequest) && _instance.OnGetUserPublisherDataRequestEvent != null)
				{
					_instance.OnGetUserPublisherDataRequestEvent((GetUserDataRequest)e.Request);
				}
				else if (type == typeof(GetUserDataRequest) && _instance.OnGetUserPublisherReadOnlyDataRequestEvent != null)
				{
					_instance.OnGetUserPublisherReadOnlyDataRequestEvent((GetUserDataRequest)e.Request);
				}
				else if (type == typeof(GetUserDataRequest) && _instance.OnGetUserReadOnlyDataRequestEvent != null)
				{
					_instance.OnGetUserReadOnlyDataRequestEvent((GetUserDataRequest)e.Request);
				}
				else if (type == typeof(GetWindowsHelloChallengeRequest) && _instance.OnGetWindowsHelloChallengeRequestEvent != null)
				{
					_instance.OnGetWindowsHelloChallengeRequestEvent((GetWindowsHelloChallengeRequest)e.Request);
				}
				else if (type == typeof(GrantCharacterToUserRequest) && _instance.OnGrantCharacterToUserRequestEvent != null)
				{
					_instance.OnGrantCharacterToUserRequestEvent((GrantCharacterToUserRequest)e.Request);
				}
				else if (type == typeof(LinkAndroidDeviceIDRequest) && _instance.OnLinkAndroidDeviceIDRequestEvent != null)
				{
					_instance.OnLinkAndroidDeviceIDRequestEvent((LinkAndroidDeviceIDRequest)e.Request);
				}
				else if (type == typeof(LinkCustomIDRequest) && _instance.OnLinkCustomIDRequestEvent != null)
				{
					_instance.OnLinkCustomIDRequestEvent((LinkCustomIDRequest)e.Request);
				}
				else if (type == typeof(LinkFacebookAccountRequest) && _instance.OnLinkFacebookAccountRequestEvent != null)
				{
					_instance.OnLinkFacebookAccountRequestEvent((LinkFacebookAccountRequest)e.Request);
				}
				else if (type == typeof(LinkFacebookInstantGamesIdRequest) && _instance.OnLinkFacebookInstantGamesIdRequestEvent != null)
				{
					_instance.OnLinkFacebookInstantGamesIdRequestEvent((LinkFacebookInstantGamesIdRequest)e.Request);
				}
				else if (type == typeof(LinkGameCenterAccountRequest) && _instance.OnLinkGameCenterAccountRequestEvent != null)
				{
					_instance.OnLinkGameCenterAccountRequestEvent((LinkGameCenterAccountRequest)e.Request);
				}
				else if (type == typeof(LinkGoogleAccountRequest) && _instance.OnLinkGoogleAccountRequestEvent != null)
				{
					_instance.OnLinkGoogleAccountRequestEvent((LinkGoogleAccountRequest)e.Request);
				}
				else if (type == typeof(LinkIOSDeviceIDRequest) && _instance.OnLinkIOSDeviceIDRequestEvent != null)
				{
					_instance.OnLinkIOSDeviceIDRequestEvent((LinkIOSDeviceIDRequest)e.Request);
				}
				else if (type == typeof(LinkKongregateAccountRequest) && _instance.OnLinkKongregateRequestEvent != null)
				{
					_instance.OnLinkKongregateRequestEvent((LinkKongregateAccountRequest)e.Request);
				}
				else if (type == typeof(LinkNintendoSwitchDeviceIdRequest) && _instance.OnLinkNintendoSwitchDeviceIdRequestEvent != null)
				{
					_instance.OnLinkNintendoSwitchDeviceIdRequestEvent((LinkNintendoSwitchDeviceIdRequest)e.Request);
				}
				else if (type == typeof(LinkOpenIdConnectRequest) && _instance.OnLinkOpenIdConnectRequestEvent != null)
				{
					_instance.OnLinkOpenIdConnectRequestEvent((LinkOpenIdConnectRequest)e.Request);
				}
				else if (type == typeof(LinkPSNAccountRequest) && _instance.OnLinkPSNAccountRequestEvent != null)
				{
					_instance.OnLinkPSNAccountRequestEvent((LinkPSNAccountRequest)e.Request);
				}
				else if (type == typeof(LinkSteamAccountRequest) && _instance.OnLinkSteamAccountRequestEvent != null)
				{
					_instance.OnLinkSteamAccountRequestEvent((LinkSteamAccountRequest)e.Request);
				}
				else if (type == typeof(LinkTwitchAccountRequest) && _instance.OnLinkTwitchRequestEvent != null)
				{
					_instance.OnLinkTwitchRequestEvent((LinkTwitchAccountRequest)e.Request);
				}
				else if (type == typeof(LinkWindowsHelloAccountRequest) && _instance.OnLinkWindowsHelloRequestEvent != null)
				{
					_instance.OnLinkWindowsHelloRequestEvent((LinkWindowsHelloAccountRequest)e.Request);
				}
				else if (type == typeof(LinkXboxAccountRequest) && _instance.OnLinkXboxAccountRequestEvent != null)
				{
					_instance.OnLinkXboxAccountRequestEvent((LinkXboxAccountRequest)e.Request);
				}
				else if (type == typeof(LoginWithAndroidDeviceIDRequest) && _instance.OnLoginWithAndroidDeviceIDRequestEvent != null)
				{
					_instance.OnLoginWithAndroidDeviceIDRequestEvent((LoginWithAndroidDeviceIDRequest)e.Request);
				}
				else if (type == typeof(LoginWithCustomIDRequest) && _instance.OnLoginWithCustomIDRequestEvent != null)
				{
					_instance.OnLoginWithCustomIDRequestEvent((LoginWithCustomIDRequest)e.Request);
				}
				else if (type == typeof(LoginWithEmailAddressRequest) && _instance.OnLoginWithEmailAddressRequestEvent != null)
				{
					_instance.OnLoginWithEmailAddressRequestEvent((LoginWithEmailAddressRequest)e.Request);
				}
				else if (type == typeof(LoginWithFacebookRequest) && _instance.OnLoginWithFacebookRequestEvent != null)
				{
					_instance.OnLoginWithFacebookRequestEvent((LoginWithFacebookRequest)e.Request);
				}
				else if (type == typeof(LoginWithFacebookInstantGamesIdRequest) && _instance.OnLoginWithFacebookInstantGamesIdRequestEvent != null)
				{
					_instance.OnLoginWithFacebookInstantGamesIdRequestEvent((LoginWithFacebookInstantGamesIdRequest)e.Request);
				}
				else if (type == typeof(LoginWithGameCenterRequest) && _instance.OnLoginWithGameCenterRequestEvent != null)
				{
					_instance.OnLoginWithGameCenterRequestEvent((LoginWithGameCenterRequest)e.Request);
				}
				else if (type == typeof(LoginWithGoogleAccountRequest) && _instance.OnLoginWithGoogleAccountRequestEvent != null)
				{
					_instance.OnLoginWithGoogleAccountRequestEvent((LoginWithGoogleAccountRequest)e.Request);
				}
				else if (type == typeof(LoginWithIOSDeviceIDRequest) && _instance.OnLoginWithIOSDeviceIDRequestEvent != null)
				{
					_instance.OnLoginWithIOSDeviceIDRequestEvent((LoginWithIOSDeviceIDRequest)e.Request);
				}
				else if (type == typeof(LoginWithKongregateRequest) && _instance.OnLoginWithKongregateRequestEvent != null)
				{
					_instance.OnLoginWithKongregateRequestEvent((LoginWithKongregateRequest)e.Request);
				}
				else if (type == typeof(LoginWithNintendoSwitchDeviceIdRequest) && _instance.OnLoginWithNintendoSwitchDeviceIdRequestEvent != null)
				{
					_instance.OnLoginWithNintendoSwitchDeviceIdRequestEvent((LoginWithNintendoSwitchDeviceIdRequest)e.Request);
				}
				else if (type == typeof(LoginWithOpenIdConnectRequest) && _instance.OnLoginWithOpenIdConnectRequestEvent != null)
				{
					_instance.OnLoginWithOpenIdConnectRequestEvent((LoginWithOpenIdConnectRequest)e.Request);
				}
				else if (type == typeof(LoginWithPlayFabRequest) && _instance.OnLoginWithPlayFabRequestEvent != null)
				{
					_instance.OnLoginWithPlayFabRequestEvent((LoginWithPlayFabRequest)e.Request);
				}
				else if (type == typeof(LoginWithPSNRequest) && _instance.OnLoginWithPSNRequestEvent != null)
				{
					_instance.OnLoginWithPSNRequestEvent((LoginWithPSNRequest)e.Request);
				}
				else if (type == typeof(LoginWithSteamRequest) && _instance.OnLoginWithSteamRequestEvent != null)
				{
					_instance.OnLoginWithSteamRequestEvent((LoginWithSteamRequest)e.Request);
				}
				else if (type == typeof(LoginWithTwitchRequest) && _instance.OnLoginWithTwitchRequestEvent != null)
				{
					_instance.OnLoginWithTwitchRequestEvent((LoginWithTwitchRequest)e.Request);
				}
				else if (type == typeof(LoginWithWindowsHelloRequest) && _instance.OnLoginWithWindowsHelloRequestEvent != null)
				{
					_instance.OnLoginWithWindowsHelloRequestEvent((LoginWithWindowsHelloRequest)e.Request);
				}
				else if (type == typeof(LoginWithXboxRequest) && _instance.OnLoginWithXboxRequestEvent != null)
				{
					_instance.OnLoginWithXboxRequestEvent((LoginWithXboxRequest)e.Request);
				}
				else if (type == typeof(MatchmakeRequest) && _instance.OnMatchmakeRequestEvent != null)
				{
					_instance.OnMatchmakeRequestEvent((MatchmakeRequest)e.Request);
				}
				else if (type == typeof(OpenTradeRequest) && _instance.OnOpenTradeRequestEvent != null)
				{
					_instance.OnOpenTradeRequestEvent((OpenTradeRequest)e.Request);
				}
				else if (type == typeof(PayForPurchaseRequest) && _instance.OnPayForPurchaseRequestEvent != null)
				{
					_instance.OnPayForPurchaseRequestEvent((PayForPurchaseRequest)e.Request);
				}
				else if (type == typeof(PurchaseItemRequest) && _instance.OnPurchaseItemRequestEvent != null)
				{
					_instance.OnPurchaseItemRequestEvent((PurchaseItemRequest)e.Request);
				}
				else if (type == typeof(RedeemCouponRequest) && _instance.OnRedeemCouponRequestEvent != null)
				{
					_instance.OnRedeemCouponRequestEvent((RedeemCouponRequest)e.Request);
				}
				else if (type == typeof(RefreshPSNAuthTokenRequest) && _instance.OnRefreshPSNAuthTokenRequestEvent != null)
				{
					_instance.OnRefreshPSNAuthTokenRequestEvent((RefreshPSNAuthTokenRequest)e.Request);
				}
				else if (type == typeof(RegisterForIOSPushNotificationRequest) && _instance.OnRegisterForIOSPushNotificationRequestEvent != null)
				{
					_instance.OnRegisterForIOSPushNotificationRequestEvent((RegisterForIOSPushNotificationRequest)e.Request);
				}
				else if (type == typeof(RegisterPlayFabUserRequest) && _instance.OnRegisterPlayFabUserRequestEvent != null)
				{
					_instance.OnRegisterPlayFabUserRequestEvent((RegisterPlayFabUserRequest)e.Request);
				}
				else if (type == typeof(RegisterWithWindowsHelloRequest) && _instance.OnRegisterWithWindowsHelloRequestEvent != null)
				{
					_instance.OnRegisterWithWindowsHelloRequestEvent((RegisterWithWindowsHelloRequest)e.Request);
				}
				else if (type == typeof(RemoveContactEmailRequest) && _instance.OnRemoveContactEmailRequestEvent != null)
				{
					_instance.OnRemoveContactEmailRequestEvent((RemoveContactEmailRequest)e.Request);
				}
				else if (type == typeof(RemoveFriendRequest) && _instance.OnRemoveFriendRequestEvent != null)
				{
					_instance.OnRemoveFriendRequestEvent((RemoveFriendRequest)e.Request);
				}
				else if (type == typeof(RemoveGenericIDRequest) && _instance.OnRemoveGenericIDRequestEvent != null)
				{
					_instance.OnRemoveGenericIDRequestEvent((RemoveGenericIDRequest)e.Request);
				}
				else if (type == typeof(RemoveSharedGroupMembersRequest) && _instance.OnRemoveSharedGroupMembersRequestEvent != null)
				{
					_instance.OnRemoveSharedGroupMembersRequestEvent((RemoveSharedGroupMembersRequest)e.Request);
				}
				else if (type == typeof(DeviceInfoRequest) && _instance.OnReportDeviceInfoRequestEvent != null)
				{
					_instance.OnReportDeviceInfoRequestEvent((DeviceInfoRequest)e.Request);
				}
				else if (type == typeof(ReportPlayerClientRequest) && _instance.OnReportPlayerRequestEvent != null)
				{
					_instance.OnReportPlayerRequestEvent((ReportPlayerClientRequest)e.Request);
				}
				else if (type == typeof(RestoreIOSPurchasesRequest) && _instance.OnRestoreIOSPurchasesRequestEvent != null)
				{
					_instance.OnRestoreIOSPurchasesRequestEvent((RestoreIOSPurchasesRequest)e.Request);
				}
				else if (type == typeof(SendAccountRecoveryEmailRequest) && _instance.OnSendAccountRecoveryEmailRequestEvent != null)
				{
					_instance.OnSendAccountRecoveryEmailRequestEvent((SendAccountRecoveryEmailRequest)e.Request);
				}
				else if (type == typeof(SetFriendTagsRequest) && _instance.OnSetFriendTagsRequestEvent != null)
				{
					_instance.OnSetFriendTagsRequestEvent((SetFriendTagsRequest)e.Request);
				}
				else if (type == typeof(SetPlayerSecretRequest) && _instance.OnSetPlayerSecretRequestEvent != null)
				{
					_instance.OnSetPlayerSecretRequestEvent((SetPlayerSecretRequest)e.Request);
				}
				else if (type == typeof(StartGameRequest) && _instance.OnStartGameRequestEvent != null)
				{
					_instance.OnStartGameRequestEvent((StartGameRequest)e.Request);
				}
				else if (type == typeof(StartPurchaseRequest) && _instance.OnStartPurchaseRequestEvent != null)
				{
					_instance.OnStartPurchaseRequestEvent((StartPurchaseRequest)e.Request);
				}
				else if (type == typeof(SubtractUserVirtualCurrencyRequest) && _instance.OnSubtractUserVirtualCurrencyRequestEvent != null)
				{
					_instance.OnSubtractUserVirtualCurrencyRequestEvent((SubtractUserVirtualCurrencyRequest)e.Request);
				}
				else if (type == typeof(UnlinkAndroidDeviceIDRequest) && _instance.OnUnlinkAndroidDeviceIDRequestEvent != null)
				{
					_instance.OnUnlinkAndroidDeviceIDRequestEvent((UnlinkAndroidDeviceIDRequest)e.Request);
				}
				else if (type == typeof(UnlinkCustomIDRequest) && _instance.OnUnlinkCustomIDRequestEvent != null)
				{
					_instance.OnUnlinkCustomIDRequestEvent((UnlinkCustomIDRequest)e.Request);
				}
				else if (type == typeof(UnlinkFacebookAccountRequest) && _instance.OnUnlinkFacebookAccountRequestEvent != null)
				{
					_instance.OnUnlinkFacebookAccountRequestEvent((UnlinkFacebookAccountRequest)e.Request);
				}
				else if (type == typeof(UnlinkFacebookInstantGamesIdRequest) && _instance.OnUnlinkFacebookInstantGamesIdRequestEvent != null)
				{
					_instance.OnUnlinkFacebookInstantGamesIdRequestEvent((UnlinkFacebookInstantGamesIdRequest)e.Request);
				}
				else if (type == typeof(UnlinkGameCenterAccountRequest) && _instance.OnUnlinkGameCenterAccountRequestEvent != null)
				{
					_instance.OnUnlinkGameCenterAccountRequestEvent((UnlinkGameCenterAccountRequest)e.Request);
				}
				else if (type == typeof(UnlinkGoogleAccountRequest) && _instance.OnUnlinkGoogleAccountRequestEvent != null)
				{
					_instance.OnUnlinkGoogleAccountRequestEvent((UnlinkGoogleAccountRequest)e.Request);
				}
				else if (type == typeof(UnlinkIOSDeviceIDRequest) && _instance.OnUnlinkIOSDeviceIDRequestEvent != null)
				{
					_instance.OnUnlinkIOSDeviceIDRequestEvent((UnlinkIOSDeviceIDRequest)e.Request);
				}
				else if (type == typeof(UnlinkKongregateAccountRequest) && _instance.OnUnlinkKongregateRequestEvent != null)
				{
					_instance.OnUnlinkKongregateRequestEvent((UnlinkKongregateAccountRequest)e.Request);
				}
				else if (type == typeof(UnlinkNintendoSwitchDeviceIdRequest) && _instance.OnUnlinkNintendoSwitchDeviceIdRequestEvent != null)
				{
					_instance.OnUnlinkNintendoSwitchDeviceIdRequestEvent((UnlinkNintendoSwitchDeviceIdRequest)e.Request);
				}
				else if (type == typeof(UninkOpenIdConnectRequest) && _instance.OnUnlinkOpenIdConnectRequestEvent != null)
				{
					_instance.OnUnlinkOpenIdConnectRequestEvent((UninkOpenIdConnectRequest)e.Request);
				}
				else if (type == typeof(UnlinkPSNAccountRequest) && _instance.OnUnlinkPSNAccountRequestEvent != null)
				{
					_instance.OnUnlinkPSNAccountRequestEvent((UnlinkPSNAccountRequest)e.Request);
				}
				else if (type == typeof(UnlinkSteamAccountRequest) && _instance.OnUnlinkSteamAccountRequestEvent != null)
				{
					_instance.OnUnlinkSteamAccountRequestEvent((UnlinkSteamAccountRequest)e.Request);
				}
				else if (type == typeof(UnlinkTwitchAccountRequest) && _instance.OnUnlinkTwitchRequestEvent != null)
				{
					_instance.OnUnlinkTwitchRequestEvent((UnlinkTwitchAccountRequest)e.Request);
				}
				else if (type == typeof(UnlinkWindowsHelloAccountRequest) && _instance.OnUnlinkWindowsHelloRequestEvent != null)
				{
					_instance.OnUnlinkWindowsHelloRequestEvent((UnlinkWindowsHelloAccountRequest)e.Request);
				}
				else if (type == typeof(UnlinkXboxAccountRequest) && _instance.OnUnlinkXboxAccountRequestEvent != null)
				{
					_instance.OnUnlinkXboxAccountRequestEvent((UnlinkXboxAccountRequest)e.Request);
				}
				else if (type == typeof(UnlockContainerInstanceRequest) && _instance.OnUnlockContainerInstanceRequestEvent != null)
				{
					_instance.OnUnlockContainerInstanceRequestEvent((UnlockContainerInstanceRequest)e.Request);
				}
				else if (type == typeof(UnlockContainerItemRequest) && _instance.OnUnlockContainerItemRequestEvent != null)
				{
					_instance.OnUnlockContainerItemRequestEvent((UnlockContainerItemRequest)e.Request);
				}
				else if (type == typeof(UpdateAvatarUrlRequest) && _instance.OnUpdateAvatarUrlRequestEvent != null)
				{
					_instance.OnUpdateAvatarUrlRequestEvent((UpdateAvatarUrlRequest)e.Request);
				}
				else if (type == typeof(UpdateCharacterDataRequest) && _instance.OnUpdateCharacterDataRequestEvent != null)
				{
					_instance.OnUpdateCharacterDataRequestEvent((UpdateCharacterDataRequest)e.Request);
				}
				else if (type == typeof(UpdateCharacterStatisticsRequest) && _instance.OnUpdateCharacterStatisticsRequestEvent != null)
				{
					_instance.OnUpdateCharacterStatisticsRequestEvent((UpdateCharacterStatisticsRequest)e.Request);
				}
				else if (type == typeof(UpdatePlayerStatisticsRequest) && _instance.OnUpdatePlayerStatisticsRequestEvent != null)
				{
					_instance.OnUpdatePlayerStatisticsRequestEvent((UpdatePlayerStatisticsRequest)e.Request);
				}
				else if (type == typeof(UpdateSharedGroupDataRequest) && _instance.OnUpdateSharedGroupDataRequestEvent != null)
				{
					_instance.OnUpdateSharedGroupDataRequestEvent((UpdateSharedGroupDataRequest)e.Request);
				}
				else if (type == typeof(UpdateUserDataRequest) && _instance.OnUpdateUserDataRequestEvent != null)
				{
					_instance.OnUpdateUserDataRequestEvent((UpdateUserDataRequest)e.Request);
				}
				else if (type == typeof(UpdateUserDataRequest) && _instance.OnUpdateUserPublisherDataRequestEvent != null)
				{
					_instance.OnUpdateUserPublisherDataRequestEvent((UpdateUserDataRequest)e.Request);
				}
				else if (type == typeof(UpdateUserTitleDisplayNameRequest) && _instance.OnUpdateUserTitleDisplayNameRequestEvent != null)
				{
					_instance.OnUpdateUserTitleDisplayNameRequestEvent((UpdateUserTitleDisplayNameRequest)e.Request);
				}
				else if (type == typeof(ValidateAmazonReceiptRequest) && _instance.OnValidateAmazonIAPReceiptRequestEvent != null)
				{
					_instance.OnValidateAmazonIAPReceiptRequestEvent((ValidateAmazonReceiptRequest)e.Request);
				}
				else if (type == typeof(ValidateGooglePlayPurchaseRequest) && _instance.OnValidateGooglePlayPurchaseRequestEvent != null)
				{
					_instance.OnValidateGooglePlayPurchaseRequestEvent((ValidateGooglePlayPurchaseRequest)e.Request);
				}
				else if (type == typeof(ValidateIOSReceiptRequest) && _instance.OnValidateIOSReceiptRequestEvent != null)
				{
					_instance.OnValidateIOSReceiptRequestEvent((ValidateIOSReceiptRequest)e.Request);
				}
				else if (type == typeof(ValidateWindowsReceiptRequest) && _instance.OnValidateWindowsStoreReceiptRequestEvent != null)
				{
					_instance.OnValidateWindowsStoreReceiptRequestEvent((ValidateWindowsReceiptRequest)e.Request);
				}
				else if (type == typeof(WriteClientCharacterEventRequest) && _instance.OnWriteCharacterEventRequestEvent != null)
				{
					_instance.OnWriteCharacterEventRequestEvent((WriteClientCharacterEventRequest)e.Request);
				}
				else if (type == typeof(WriteClientPlayerEventRequest) && _instance.OnWritePlayerEventRequestEvent != null)
				{
					_instance.OnWritePlayerEventRequestEvent((WriteClientPlayerEventRequest)e.Request);
				}
				else if (type == typeof(WriteTitleEventRequest) && _instance.OnWriteTitleEventRequestEvent != null)
				{
					_instance.OnWriteTitleEventRequestEvent((WriteTitleEventRequest)e.Request);
				}
				else if (type == typeof(GetEntityTokenRequest) && _instance.OnAuthenticationGetEntityTokenRequestEvent != null)
				{
					_instance.OnAuthenticationGetEntityTokenRequestEvent((GetEntityTokenRequest)e.Request);
				}
				else if (type == typeof(ValidateEntityTokenRequest) && _instance.OnAuthenticationValidateEntityTokenRequestEvent != null)
				{
					_instance.OnAuthenticationValidateEntityTokenRequestEvent((ValidateEntityTokenRequest)e.Request);
				}
				else if (type == typeof(ExecuteEntityCloudScriptRequest) && _instance.OnCloudScriptExecuteEntityCloudScriptRequestEvent != null)
				{
					_instance.OnCloudScriptExecuteEntityCloudScriptRequestEvent((ExecuteEntityCloudScriptRequest)e.Request);
				}
				else if (type == typeof(AbortFileUploadsRequest) && _instance.OnDataAbortFileUploadsRequestEvent != null)
				{
					_instance.OnDataAbortFileUploadsRequestEvent((AbortFileUploadsRequest)e.Request);
				}
				else if (type == typeof(DeleteFilesRequest) && _instance.OnDataDeleteFilesRequestEvent != null)
				{
					_instance.OnDataDeleteFilesRequestEvent((DeleteFilesRequest)e.Request);
				}
				else if (type == typeof(FinalizeFileUploadsRequest) && _instance.OnDataFinalizeFileUploadsRequestEvent != null)
				{
					_instance.OnDataFinalizeFileUploadsRequestEvent((FinalizeFileUploadsRequest)e.Request);
				}
				else if (type == typeof(GetFilesRequest) && _instance.OnDataGetFilesRequestEvent != null)
				{
					_instance.OnDataGetFilesRequestEvent((GetFilesRequest)e.Request);
				}
				else if (type == typeof(GetObjectsRequest) && _instance.OnDataGetObjectsRequestEvent != null)
				{
					_instance.OnDataGetObjectsRequestEvent((GetObjectsRequest)e.Request);
				}
				else if (type == typeof(InitiateFileUploadsRequest) && _instance.OnDataInitiateFileUploadsRequestEvent != null)
				{
					_instance.OnDataInitiateFileUploadsRequestEvent((InitiateFileUploadsRequest)e.Request);
				}
				else if (type == typeof(SetObjectsRequest) && _instance.OnDataSetObjectsRequestEvent != null)
				{
					_instance.OnDataSetObjectsRequestEvent((SetObjectsRequest)e.Request);
				}
				else if (type == typeof(WriteEventsRequest) && _instance.OnEventsWriteEventsRequestEvent != null)
				{
					_instance.OnEventsWriteEventsRequestEvent((WriteEventsRequest)e.Request);
				}
				else if (type == typeof(WriteEventsRequest) && _instance.OnEventsWriteTelemetryEventsRequestEvent != null)
				{
					_instance.OnEventsWriteTelemetryEventsRequestEvent((WriteEventsRequest)e.Request);
				}
				else if (type == typeof(AcceptGroupApplicationRequest) && _instance.OnGroupsAcceptGroupApplicationRequestEvent != null)
				{
					_instance.OnGroupsAcceptGroupApplicationRequestEvent((AcceptGroupApplicationRequest)e.Request);
				}
				else if (type == typeof(AcceptGroupInvitationRequest) && _instance.OnGroupsAcceptGroupInvitationRequestEvent != null)
				{
					_instance.OnGroupsAcceptGroupInvitationRequestEvent((AcceptGroupInvitationRequest)e.Request);
				}
				else if (type == typeof(AddMembersRequest) && _instance.OnGroupsAddMembersRequestEvent != null)
				{
					_instance.OnGroupsAddMembersRequestEvent((AddMembersRequest)e.Request);
				}
				else if (type == typeof(ApplyToGroupRequest) && _instance.OnGroupsApplyToGroupRequestEvent != null)
				{
					_instance.OnGroupsApplyToGroupRequestEvent((ApplyToGroupRequest)e.Request);
				}
				else if (type == typeof(BlockEntityRequest) && _instance.OnGroupsBlockEntityRequestEvent != null)
				{
					_instance.OnGroupsBlockEntityRequestEvent((BlockEntityRequest)e.Request);
				}
				else if (type == typeof(ChangeMemberRoleRequest) && _instance.OnGroupsChangeMemberRoleRequestEvent != null)
				{
					_instance.OnGroupsChangeMemberRoleRequestEvent((ChangeMemberRoleRequest)e.Request);
				}
				else if (type == typeof(CreateGroupRequest) && _instance.OnGroupsCreateGroupRequestEvent != null)
				{
					_instance.OnGroupsCreateGroupRequestEvent((CreateGroupRequest)e.Request);
				}
				else if (type == typeof(CreateGroupRoleRequest) && _instance.OnGroupsCreateRoleRequestEvent != null)
				{
					_instance.OnGroupsCreateRoleRequestEvent((CreateGroupRoleRequest)e.Request);
				}
				else if (type == typeof(DeleteGroupRequest) && _instance.OnGroupsDeleteGroupRequestEvent != null)
				{
					_instance.OnGroupsDeleteGroupRequestEvent((DeleteGroupRequest)e.Request);
				}
				else if (type == typeof(DeleteRoleRequest) && _instance.OnGroupsDeleteRoleRequestEvent != null)
				{
					_instance.OnGroupsDeleteRoleRequestEvent((DeleteRoleRequest)e.Request);
				}
				else if (type == typeof(GetGroupRequest) && _instance.OnGroupsGetGroupRequestEvent != null)
				{
					_instance.OnGroupsGetGroupRequestEvent((GetGroupRequest)e.Request);
				}
				else if (type == typeof(InviteToGroupRequest) && _instance.OnGroupsInviteToGroupRequestEvent != null)
				{
					_instance.OnGroupsInviteToGroupRequestEvent((InviteToGroupRequest)e.Request);
				}
				else if (type == typeof(IsMemberRequest) && _instance.OnGroupsIsMemberRequestEvent != null)
				{
					_instance.OnGroupsIsMemberRequestEvent((IsMemberRequest)e.Request);
				}
				else if (type == typeof(ListGroupApplicationsRequest) && _instance.OnGroupsListGroupApplicationsRequestEvent != null)
				{
					_instance.OnGroupsListGroupApplicationsRequestEvent((ListGroupApplicationsRequest)e.Request);
				}
				else if (type == typeof(ListGroupBlocksRequest) && _instance.OnGroupsListGroupBlocksRequestEvent != null)
				{
					_instance.OnGroupsListGroupBlocksRequestEvent((ListGroupBlocksRequest)e.Request);
				}
				else if (type == typeof(ListGroupInvitationsRequest) && _instance.OnGroupsListGroupInvitationsRequestEvent != null)
				{
					_instance.OnGroupsListGroupInvitationsRequestEvent((ListGroupInvitationsRequest)e.Request);
				}
				else if (type == typeof(ListGroupMembersRequest) && _instance.OnGroupsListGroupMembersRequestEvent != null)
				{
					_instance.OnGroupsListGroupMembersRequestEvent((ListGroupMembersRequest)e.Request);
				}
				else if (type == typeof(ListMembershipRequest) && _instance.OnGroupsListMembershipRequestEvent != null)
				{
					_instance.OnGroupsListMembershipRequestEvent((ListMembershipRequest)e.Request);
				}
				else if (type == typeof(ListMembershipOpportunitiesRequest) && _instance.OnGroupsListMembershipOpportunitiesRequestEvent != null)
				{
					_instance.OnGroupsListMembershipOpportunitiesRequestEvent((ListMembershipOpportunitiesRequest)e.Request);
				}
				else if (type == typeof(RemoveGroupApplicationRequest) && _instance.OnGroupsRemoveGroupApplicationRequestEvent != null)
				{
					_instance.OnGroupsRemoveGroupApplicationRequestEvent((RemoveGroupApplicationRequest)e.Request);
				}
				else if (type == typeof(RemoveGroupInvitationRequest) && _instance.OnGroupsRemoveGroupInvitationRequestEvent != null)
				{
					_instance.OnGroupsRemoveGroupInvitationRequestEvent((RemoveGroupInvitationRequest)e.Request);
				}
				else if (type == typeof(RemoveMembersRequest) && _instance.OnGroupsRemoveMembersRequestEvent != null)
				{
					_instance.OnGroupsRemoveMembersRequestEvent((RemoveMembersRequest)e.Request);
				}
				else if (type == typeof(UnblockEntityRequest) && _instance.OnGroupsUnblockEntityRequestEvent != null)
				{
					_instance.OnGroupsUnblockEntityRequestEvent((UnblockEntityRequest)e.Request);
				}
				else if (type == typeof(UpdateGroupRequest) && _instance.OnGroupsUpdateGroupRequestEvent != null)
				{
					_instance.OnGroupsUpdateGroupRequestEvent((UpdateGroupRequest)e.Request);
				}
				else if (type == typeof(UpdateGroupRoleRequest) && _instance.OnGroupsUpdateRoleRequestEvent != null)
				{
					_instance.OnGroupsUpdateRoleRequestEvent((UpdateGroupRoleRequest)e.Request);
				}
				else if (type == typeof(GetLanguageListRequest) && _instance.OnLocalizationGetLanguageListRequestEvent != null)
				{
					_instance.OnLocalizationGetLanguageListRequestEvent((GetLanguageListRequest)e.Request);
				}
				else if (type == typeof(CancelAllMatchmakingTicketsForPlayerRequest) && _instance.OnMultiplayerCancelAllMatchmakingTicketsForPlayerRequestEvent != null)
				{
					_instance.OnMultiplayerCancelAllMatchmakingTicketsForPlayerRequestEvent((CancelAllMatchmakingTicketsForPlayerRequest)e.Request);
				}
				else if (type == typeof(CancelMatchmakingTicketRequest) && _instance.OnMultiplayerCancelMatchmakingTicketRequestEvent != null)
				{
					_instance.OnMultiplayerCancelMatchmakingTicketRequestEvent((CancelMatchmakingTicketRequest)e.Request);
				}
				else if (type == typeof(CreateBuildWithCustomContainerRequest) && _instance.OnMultiplayerCreateBuildWithCustomContainerRequestEvent != null)
				{
					_instance.OnMultiplayerCreateBuildWithCustomContainerRequestEvent((CreateBuildWithCustomContainerRequest)e.Request);
				}
				else if (type == typeof(CreateBuildWithManagedContainerRequest) && _instance.OnMultiplayerCreateBuildWithManagedContainerRequestEvent != null)
				{
					_instance.OnMultiplayerCreateBuildWithManagedContainerRequestEvent((CreateBuildWithManagedContainerRequest)e.Request);
				}
				else if (type == typeof(CreateMatchmakingTicketRequest) && _instance.OnMultiplayerCreateMatchmakingTicketRequestEvent != null)
				{
					_instance.OnMultiplayerCreateMatchmakingTicketRequestEvent((CreateMatchmakingTicketRequest)e.Request);
				}
				else if (type == typeof(CreateRemoteUserRequest) && _instance.OnMultiplayerCreateRemoteUserRequestEvent != null)
				{
					_instance.OnMultiplayerCreateRemoteUserRequestEvent((CreateRemoteUserRequest)e.Request);
				}
				else if (type == typeof(CreateServerMatchmakingTicketRequest) && _instance.OnMultiplayerCreateServerMatchmakingTicketRequestEvent != null)
				{
					_instance.OnMultiplayerCreateServerMatchmakingTicketRequestEvent((CreateServerMatchmakingTicketRequest)e.Request);
				}
				else if (type == typeof(DeleteAssetRequest) && _instance.OnMultiplayerDeleteAssetRequestEvent != null)
				{
					_instance.OnMultiplayerDeleteAssetRequestEvent((DeleteAssetRequest)e.Request);
				}
				else if (type == typeof(DeleteBuildRequest) && _instance.OnMultiplayerDeleteBuildRequestEvent != null)
				{
					_instance.OnMultiplayerDeleteBuildRequestEvent((DeleteBuildRequest)e.Request);
				}
				else if (type == typeof(DeleteCertificateRequest) && _instance.OnMultiplayerDeleteCertificateRequestEvent != null)
				{
					_instance.OnMultiplayerDeleteCertificateRequestEvent((DeleteCertificateRequest)e.Request);
				}
				else if (type == typeof(DeleteRemoteUserRequest) && _instance.OnMultiplayerDeleteRemoteUserRequestEvent != null)
				{
					_instance.OnMultiplayerDeleteRemoteUserRequestEvent((DeleteRemoteUserRequest)e.Request);
				}
				else if (type == typeof(EnableMultiplayerServersForTitleRequest) && _instance.OnMultiplayerEnableMultiplayerServersForTitleRequestEvent != null)
				{
					_instance.OnMultiplayerEnableMultiplayerServersForTitleRequestEvent((EnableMultiplayerServersForTitleRequest)e.Request);
				}
				else if (type == typeof(GetAssetUploadUrlRequest) && _instance.OnMultiplayerGetAssetUploadUrlRequestEvent != null)
				{
					_instance.OnMultiplayerGetAssetUploadUrlRequestEvent((GetAssetUploadUrlRequest)e.Request);
				}
				else if (type == typeof(GetBuildRequest) && _instance.OnMultiplayerGetBuildRequestEvent != null)
				{
					_instance.OnMultiplayerGetBuildRequestEvent((GetBuildRequest)e.Request);
				}
				else if (type == typeof(GetContainerRegistryCredentialsRequest) && _instance.OnMultiplayerGetContainerRegistryCredentialsRequestEvent != null)
				{
					_instance.OnMultiplayerGetContainerRegistryCredentialsRequestEvent((GetContainerRegistryCredentialsRequest)e.Request);
				}
				else if (type == typeof(GetMatchRequest) && _instance.OnMultiplayerGetMatchRequestEvent != null)
				{
					_instance.OnMultiplayerGetMatchRequestEvent((GetMatchRequest)e.Request);
				}
				else if (type == typeof(GetMatchmakingTicketRequest) && _instance.OnMultiplayerGetMatchmakingTicketRequestEvent != null)
				{
					_instance.OnMultiplayerGetMatchmakingTicketRequestEvent((GetMatchmakingTicketRequest)e.Request);
				}
				else if (type == typeof(GetMultiplayerServerDetailsRequest) && _instance.OnMultiplayerGetMultiplayerServerDetailsRequestEvent != null)
				{
					_instance.OnMultiplayerGetMultiplayerServerDetailsRequestEvent((GetMultiplayerServerDetailsRequest)e.Request);
				}
				else if (type == typeof(GetQueueStatisticsRequest) && _instance.OnMultiplayerGetQueueStatisticsRequestEvent != null)
				{
					_instance.OnMultiplayerGetQueueStatisticsRequestEvent((GetQueueStatisticsRequest)e.Request);
				}
				else if (type == typeof(GetRemoteLoginEndpointRequest) && _instance.OnMultiplayerGetRemoteLoginEndpointRequestEvent != null)
				{
					_instance.OnMultiplayerGetRemoteLoginEndpointRequestEvent((GetRemoteLoginEndpointRequest)e.Request);
				}
				else if (type == typeof(GetTitleEnabledForMultiplayerServersStatusRequest) && _instance.OnMultiplayerGetTitleEnabledForMultiplayerServersStatusRequestEvent != null)
				{
					_instance.OnMultiplayerGetTitleEnabledForMultiplayerServersStatusRequestEvent((GetTitleEnabledForMultiplayerServersStatusRequest)e.Request);
				}
				else if (type == typeof(GetTitleMultiplayerServersQuotasRequest) && _instance.OnMultiplayerGetTitleMultiplayerServersQuotasRequestEvent != null)
				{
					_instance.OnMultiplayerGetTitleMultiplayerServersQuotasRequestEvent((GetTitleMultiplayerServersQuotasRequest)e.Request);
				}
				else if (type == typeof(JoinMatchmakingTicketRequest) && _instance.OnMultiplayerJoinMatchmakingTicketRequestEvent != null)
				{
					_instance.OnMultiplayerJoinMatchmakingTicketRequestEvent((JoinMatchmakingTicketRequest)e.Request);
				}
				else if (type == typeof(ListMultiplayerServersRequest) && _instance.OnMultiplayerListArchivedMultiplayerServersRequestEvent != null)
				{
					_instance.OnMultiplayerListArchivedMultiplayerServersRequestEvent((ListMultiplayerServersRequest)e.Request);
				}
				else if (type == typeof(ListAssetSummariesRequest) && _instance.OnMultiplayerListAssetSummariesRequestEvent != null)
				{
					_instance.OnMultiplayerListAssetSummariesRequestEvent((ListAssetSummariesRequest)e.Request);
				}
				else if (type == typeof(ListBuildSummariesRequest) && _instance.OnMultiplayerListBuildSummariesRequestEvent != null)
				{
					_instance.OnMultiplayerListBuildSummariesRequestEvent((ListBuildSummariesRequest)e.Request);
				}
				else if (type == typeof(ListCertificateSummariesRequest) && _instance.OnMultiplayerListCertificateSummariesRequestEvent != null)
				{
					_instance.OnMultiplayerListCertificateSummariesRequestEvent((ListCertificateSummariesRequest)e.Request);
				}
				else if (type == typeof(ListContainerImagesRequest) && _instance.OnMultiplayerListContainerImagesRequestEvent != null)
				{
					_instance.OnMultiplayerListContainerImagesRequestEvent((ListContainerImagesRequest)e.Request);
				}
				else if (type == typeof(ListContainerImageTagsRequest) && _instance.OnMultiplayerListContainerImageTagsRequestEvent != null)
				{
					_instance.OnMultiplayerListContainerImageTagsRequestEvent((ListContainerImageTagsRequest)e.Request);
				}
				else if (type == typeof(ListMatchmakingTicketsForPlayerRequest) && _instance.OnMultiplayerListMatchmakingTicketsForPlayerRequestEvent != null)
				{
					_instance.OnMultiplayerListMatchmakingTicketsForPlayerRequestEvent((ListMatchmakingTicketsForPlayerRequest)e.Request);
				}
				else if (type == typeof(ListMultiplayerServersRequest) && _instance.OnMultiplayerListMultiplayerServersRequestEvent != null)
				{
					_instance.OnMultiplayerListMultiplayerServersRequestEvent((ListMultiplayerServersRequest)e.Request);
				}
				else if (type == typeof(ListPartyQosServersRequest) && _instance.OnMultiplayerListPartyQosServersRequestEvent != null)
				{
					_instance.OnMultiplayerListPartyQosServersRequestEvent((ListPartyQosServersRequest)e.Request);
				}
				else if (type == typeof(ListQosServersRequest) && _instance.OnMultiplayerListQosServersRequestEvent != null)
				{
					_instance.OnMultiplayerListQosServersRequestEvent((ListQosServersRequest)e.Request);
				}
				else if (type == typeof(ListQosServersForTitleRequest) && _instance.OnMultiplayerListQosServersForTitleRequestEvent != null)
				{
					_instance.OnMultiplayerListQosServersForTitleRequestEvent((ListQosServersForTitleRequest)e.Request);
				}
				else if (type == typeof(ListVirtualMachineSummariesRequest) && _instance.OnMultiplayerListVirtualMachineSummariesRequestEvent != null)
				{
					_instance.OnMultiplayerListVirtualMachineSummariesRequestEvent((ListVirtualMachineSummariesRequest)e.Request);
				}
				else if (type == typeof(RequestMultiplayerServerRequest) && _instance.OnMultiplayerRequestMultiplayerServerRequestEvent != null)
				{
					_instance.OnMultiplayerRequestMultiplayerServerRequestEvent((RequestMultiplayerServerRequest)e.Request);
				}
				else if (type == typeof(RolloverContainerRegistryCredentialsRequest) && _instance.OnMultiplayerRolloverContainerRegistryCredentialsRequestEvent != null)
				{
					_instance.OnMultiplayerRolloverContainerRegistryCredentialsRequestEvent((RolloverContainerRegistryCredentialsRequest)e.Request);
				}
				else if (type == typeof(ShutdownMultiplayerServerRequest) && _instance.OnMultiplayerShutdownMultiplayerServerRequestEvent != null)
				{
					_instance.OnMultiplayerShutdownMultiplayerServerRequestEvent((ShutdownMultiplayerServerRequest)e.Request);
				}
				else if (type == typeof(UpdateBuildRegionsRequest) && _instance.OnMultiplayerUpdateBuildRegionsRequestEvent != null)
				{
					_instance.OnMultiplayerUpdateBuildRegionsRequestEvent((UpdateBuildRegionsRequest)e.Request);
				}
				else if (type == typeof(UploadCertificateRequest) && _instance.OnMultiplayerUploadCertificateRequestEvent != null)
				{
					_instance.OnMultiplayerUploadCertificateRequestEvent((UploadCertificateRequest)e.Request);
				}
				else if (type == typeof(GetGlobalPolicyRequest) && _instance.OnProfilesGetGlobalPolicyRequestEvent != null)
				{
					_instance.OnProfilesGetGlobalPolicyRequestEvent((GetGlobalPolicyRequest)e.Request);
				}
				else if (type == typeof(GetEntityProfileRequest) && _instance.OnProfilesGetProfileRequestEvent != null)
				{
					_instance.OnProfilesGetProfileRequestEvent((GetEntityProfileRequest)e.Request);
				}
				else if (type == typeof(GetEntityProfilesRequest) && _instance.OnProfilesGetProfilesRequestEvent != null)
				{
					_instance.OnProfilesGetProfilesRequestEvent((GetEntityProfilesRequest)e.Request);
				}
				else if (type == typeof(GetTitlePlayersFromMasterPlayerAccountIdsRequest) && _instance.OnProfilesGetTitlePlayersFromMasterPlayerAccountIdsRequestEvent != null)
				{
					_instance.OnProfilesGetTitlePlayersFromMasterPlayerAccountIdsRequestEvent((GetTitlePlayersFromMasterPlayerAccountIdsRequest)e.Request);
				}
				else if (type == typeof(SetGlobalPolicyRequest) && _instance.OnProfilesSetGlobalPolicyRequestEvent != null)
				{
					_instance.OnProfilesSetGlobalPolicyRequestEvent((SetGlobalPolicyRequest)e.Request);
				}
				else if (type == typeof(SetProfileLanguageRequest) && _instance.OnProfilesSetProfileLanguageRequestEvent != null)
				{
					_instance.OnProfilesSetProfileLanguageRequestEvent((SetProfileLanguageRequest)e.Request);
				}
				else if (type == typeof(SetEntityProfilePolicyRequest) && _instance.OnProfilesSetProfilePolicyRequestEvent != null)
				{
					_instance.OnProfilesSetProfilePolicyRequestEvent((SetEntityProfilePolicyRequest)e.Request);
				}
			}
			else
			{
				Type type2 = e.Result.GetType();
				if (type2 == typeof(LoginResult) && _instance.OnLoginResultEvent != null)
				{
					_instance.OnLoginResultEvent((LoginResult)e.Result);
				}
				else if (type2 == typeof(AcceptTradeResponse) && _instance.OnAcceptTradeResultEvent != null)
				{
					_instance.OnAcceptTradeResultEvent((AcceptTradeResponse)e.Result);
				}
				else if (type2 == typeof(AddFriendResult) && _instance.OnAddFriendResultEvent != null)
				{
					_instance.OnAddFriendResultEvent((AddFriendResult)e.Result);
				}
				else if (type2 == typeof(AddGenericIDResult) && _instance.OnAddGenericIDResultEvent != null)
				{
					_instance.OnAddGenericIDResultEvent((AddGenericIDResult)e.Result);
				}
				else if (type2 == typeof(AddOrUpdateContactEmailResult) && _instance.OnAddOrUpdateContactEmailResultEvent != null)
				{
					_instance.OnAddOrUpdateContactEmailResultEvent((AddOrUpdateContactEmailResult)e.Result);
				}
				else if (type2 == typeof(AddSharedGroupMembersResult) && _instance.OnAddSharedGroupMembersResultEvent != null)
				{
					_instance.OnAddSharedGroupMembersResultEvent((AddSharedGroupMembersResult)e.Result);
				}
				else if (type2 == typeof(AddUsernamePasswordResult) && _instance.OnAddUsernamePasswordResultEvent != null)
				{
					_instance.OnAddUsernamePasswordResultEvent((AddUsernamePasswordResult)e.Result);
				}
				else if (type2 == typeof(ModifyUserVirtualCurrencyResult) && _instance.OnAddUserVirtualCurrencyResultEvent != null)
				{
					_instance.OnAddUserVirtualCurrencyResultEvent((ModifyUserVirtualCurrencyResult)e.Result);
				}
				else if (type2 == typeof(AndroidDevicePushNotificationRegistrationResult) && _instance.OnAndroidDevicePushNotificationRegistrationResultEvent != null)
				{
					_instance.OnAndroidDevicePushNotificationRegistrationResultEvent((AndroidDevicePushNotificationRegistrationResult)e.Result);
				}
				else if (type2 == typeof(AttributeInstallResult) && _instance.OnAttributeInstallResultEvent != null)
				{
					_instance.OnAttributeInstallResultEvent((AttributeInstallResult)e.Result);
				}
				else if (type2 == typeof(CancelTradeResponse) && _instance.OnCancelTradeResultEvent != null)
				{
					_instance.OnCancelTradeResultEvent((CancelTradeResponse)e.Result);
				}
				else if (type2 == typeof(ConfirmPurchaseResult) && _instance.OnConfirmPurchaseResultEvent != null)
				{
					_instance.OnConfirmPurchaseResultEvent((ConfirmPurchaseResult)e.Result);
				}
				else if (type2 == typeof(ConsumeItemResult) && _instance.OnConsumeItemResultEvent != null)
				{
					_instance.OnConsumeItemResultEvent((ConsumeItemResult)e.Result);
				}
				else if (type2 == typeof(ConsumePSNEntitlementsResult) && _instance.OnConsumePSNEntitlementsResultEvent != null)
				{
					_instance.OnConsumePSNEntitlementsResultEvent((ConsumePSNEntitlementsResult)e.Result);
				}
				else if (type2 == typeof(ConsumeXboxEntitlementsResult) && _instance.OnConsumeXboxEntitlementsResultEvent != null)
				{
					_instance.OnConsumeXboxEntitlementsResultEvent((ConsumeXboxEntitlementsResult)e.Result);
				}
				else if (type2 == typeof(CreateSharedGroupResult) && _instance.OnCreateSharedGroupResultEvent != null)
				{
					_instance.OnCreateSharedGroupResultEvent((CreateSharedGroupResult)e.Result);
				}
				else if (type2 == typeof(PlayFab.ClientModels.ExecuteCloudScriptResult) && _instance.OnExecuteCloudScriptResultEvent != null)
				{
					_instance.OnExecuteCloudScriptResultEvent((PlayFab.ClientModels.ExecuteCloudScriptResult)e.Result);
				}
				else if (type2 == typeof(GetAccountInfoResult) && _instance.OnGetAccountInfoResultEvent != null)
				{
					_instance.OnGetAccountInfoResultEvent((GetAccountInfoResult)e.Result);
				}
				else if (type2 == typeof(ListUsersCharactersResult) && _instance.OnGetAllUsersCharactersResultEvent != null)
				{
					_instance.OnGetAllUsersCharactersResultEvent((ListUsersCharactersResult)e.Result);
				}
				else if (type2 == typeof(GetCatalogItemsResult) && _instance.OnGetCatalogItemsResultEvent != null)
				{
					_instance.OnGetCatalogItemsResultEvent((GetCatalogItemsResult)e.Result);
				}
				else if (type2 == typeof(GetCharacterDataResult) && _instance.OnGetCharacterDataResultEvent != null)
				{
					_instance.OnGetCharacterDataResultEvent((GetCharacterDataResult)e.Result);
				}
				else if (type2 == typeof(GetCharacterInventoryResult) && _instance.OnGetCharacterInventoryResultEvent != null)
				{
					_instance.OnGetCharacterInventoryResultEvent((GetCharacterInventoryResult)e.Result);
				}
				else if (type2 == typeof(GetCharacterLeaderboardResult) && _instance.OnGetCharacterLeaderboardResultEvent != null)
				{
					_instance.OnGetCharacterLeaderboardResultEvent((GetCharacterLeaderboardResult)e.Result);
				}
				else if (type2 == typeof(GetCharacterDataResult) && _instance.OnGetCharacterReadOnlyDataResultEvent != null)
				{
					_instance.OnGetCharacterReadOnlyDataResultEvent((GetCharacterDataResult)e.Result);
				}
				else if (type2 == typeof(GetCharacterStatisticsResult) && _instance.OnGetCharacterStatisticsResultEvent != null)
				{
					_instance.OnGetCharacterStatisticsResultEvent((GetCharacterStatisticsResult)e.Result);
				}
				else if (type2 == typeof(GetContentDownloadUrlResult) && _instance.OnGetContentDownloadUrlResultEvent != null)
				{
					_instance.OnGetContentDownloadUrlResultEvent((GetContentDownloadUrlResult)e.Result);
				}
				else if (type2 == typeof(CurrentGamesResult) && _instance.OnGetCurrentGamesResultEvent != null)
				{
					_instance.OnGetCurrentGamesResultEvent((CurrentGamesResult)e.Result);
				}
				else if (type2 == typeof(GetLeaderboardResult) && _instance.OnGetFriendLeaderboardResultEvent != null)
				{
					_instance.OnGetFriendLeaderboardResultEvent((GetLeaderboardResult)e.Result);
				}
				else if (type2 == typeof(GetFriendLeaderboardAroundPlayerResult) && _instance.OnGetFriendLeaderboardAroundPlayerResultEvent != null)
				{
					_instance.OnGetFriendLeaderboardAroundPlayerResultEvent((GetFriendLeaderboardAroundPlayerResult)e.Result);
				}
				else if (type2 == typeof(GetFriendsListResult) && _instance.OnGetFriendsListResultEvent != null)
				{
					_instance.OnGetFriendsListResultEvent((GetFriendsListResult)e.Result);
				}
				else if (type2 == typeof(GameServerRegionsResult) && _instance.OnGetGameServerRegionsResultEvent != null)
				{
					_instance.OnGetGameServerRegionsResultEvent((GameServerRegionsResult)e.Result);
				}
				else if (type2 == typeof(GetLeaderboardResult) && _instance.OnGetLeaderboardResultEvent != null)
				{
					_instance.OnGetLeaderboardResultEvent((GetLeaderboardResult)e.Result);
				}
				else if (type2 == typeof(GetLeaderboardAroundCharacterResult) && _instance.OnGetLeaderboardAroundCharacterResultEvent != null)
				{
					_instance.OnGetLeaderboardAroundCharacterResultEvent((GetLeaderboardAroundCharacterResult)e.Result);
				}
				else if (type2 == typeof(GetLeaderboardAroundPlayerResult) && _instance.OnGetLeaderboardAroundPlayerResultEvent != null)
				{
					_instance.OnGetLeaderboardAroundPlayerResultEvent((GetLeaderboardAroundPlayerResult)e.Result);
				}
				else if (type2 == typeof(GetLeaderboardForUsersCharactersResult) && _instance.OnGetLeaderboardForUserCharactersResultEvent != null)
				{
					_instance.OnGetLeaderboardForUserCharactersResultEvent((GetLeaderboardForUsersCharactersResult)e.Result);
				}
				else if (type2 == typeof(GetPaymentTokenResult) && _instance.OnGetPaymentTokenResultEvent != null)
				{
					_instance.OnGetPaymentTokenResultEvent((GetPaymentTokenResult)e.Result);
				}
				else if (type2 == typeof(GetPhotonAuthenticationTokenResult) && _instance.OnGetPhotonAuthenticationTokenResultEvent != null)
				{
					_instance.OnGetPhotonAuthenticationTokenResultEvent((GetPhotonAuthenticationTokenResult)e.Result);
				}
				else if (type2 == typeof(GetPlayerCombinedInfoResult) && _instance.OnGetPlayerCombinedInfoResultEvent != null)
				{
					_instance.OnGetPlayerCombinedInfoResultEvent((GetPlayerCombinedInfoResult)e.Result);
				}
				else if (type2 == typeof(GetPlayerProfileResult) && _instance.OnGetPlayerProfileResultEvent != null)
				{
					_instance.OnGetPlayerProfileResultEvent((GetPlayerProfileResult)e.Result);
				}
				else if (type2 == typeof(GetPlayerSegmentsResult) && _instance.OnGetPlayerSegmentsResultEvent != null)
				{
					_instance.OnGetPlayerSegmentsResultEvent((GetPlayerSegmentsResult)e.Result);
				}
				else if (type2 == typeof(GetPlayerStatisticsResult) && _instance.OnGetPlayerStatisticsResultEvent != null)
				{
					_instance.OnGetPlayerStatisticsResultEvent((GetPlayerStatisticsResult)e.Result);
				}
				else if (type2 == typeof(GetPlayerStatisticVersionsResult) && _instance.OnGetPlayerStatisticVersionsResultEvent != null)
				{
					_instance.OnGetPlayerStatisticVersionsResultEvent((GetPlayerStatisticVersionsResult)e.Result);
				}
				else if (type2 == typeof(GetPlayerTagsResult) && _instance.OnGetPlayerTagsResultEvent != null)
				{
					_instance.OnGetPlayerTagsResultEvent((GetPlayerTagsResult)e.Result);
				}
				else if (type2 == typeof(GetPlayerTradesResponse) && _instance.OnGetPlayerTradesResultEvent != null)
				{
					_instance.OnGetPlayerTradesResultEvent((GetPlayerTradesResponse)e.Result);
				}
				else if (type2 == typeof(GetPlayFabIDsFromFacebookIDsResult) && _instance.OnGetPlayFabIDsFromFacebookIDsResultEvent != null)
				{
					_instance.OnGetPlayFabIDsFromFacebookIDsResultEvent((GetPlayFabIDsFromFacebookIDsResult)e.Result);
				}
				else if (type2 == typeof(GetPlayFabIDsFromFacebookInstantGamesIdsResult) && _instance.OnGetPlayFabIDsFromFacebookInstantGamesIdsResultEvent != null)
				{
					_instance.OnGetPlayFabIDsFromFacebookInstantGamesIdsResultEvent((GetPlayFabIDsFromFacebookInstantGamesIdsResult)e.Result);
				}
				else if (type2 == typeof(GetPlayFabIDsFromGameCenterIDsResult) && _instance.OnGetPlayFabIDsFromGameCenterIDsResultEvent != null)
				{
					_instance.OnGetPlayFabIDsFromGameCenterIDsResultEvent((GetPlayFabIDsFromGameCenterIDsResult)e.Result);
				}
				else if (type2 == typeof(GetPlayFabIDsFromGenericIDsResult) && _instance.OnGetPlayFabIDsFromGenericIDsResultEvent != null)
				{
					_instance.OnGetPlayFabIDsFromGenericIDsResultEvent((GetPlayFabIDsFromGenericIDsResult)e.Result);
				}
				else if (type2 == typeof(GetPlayFabIDsFromGoogleIDsResult) && _instance.OnGetPlayFabIDsFromGoogleIDsResultEvent != null)
				{
					_instance.OnGetPlayFabIDsFromGoogleIDsResultEvent((GetPlayFabIDsFromGoogleIDsResult)e.Result);
				}
				else if (type2 == typeof(GetPlayFabIDsFromKongregateIDsResult) && _instance.OnGetPlayFabIDsFromKongregateIDsResultEvent != null)
				{
					_instance.OnGetPlayFabIDsFromKongregateIDsResultEvent((GetPlayFabIDsFromKongregateIDsResult)e.Result);
				}
				else if (type2 == typeof(GetPlayFabIDsFromNintendoSwitchDeviceIdsResult) && _instance.OnGetPlayFabIDsFromNintendoSwitchDeviceIdsResultEvent != null)
				{
					_instance.OnGetPlayFabIDsFromNintendoSwitchDeviceIdsResultEvent((GetPlayFabIDsFromNintendoSwitchDeviceIdsResult)e.Result);
				}
				else if (type2 == typeof(GetPlayFabIDsFromPSNAccountIDsResult) && _instance.OnGetPlayFabIDsFromPSNAccountIDsResultEvent != null)
				{
					_instance.OnGetPlayFabIDsFromPSNAccountIDsResultEvent((GetPlayFabIDsFromPSNAccountIDsResult)e.Result);
				}
				else if (type2 == typeof(GetPlayFabIDsFromSteamIDsResult) && _instance.OnGetPlayFabIDsFromSteamIDsResultEvent != null)
				{
					_instance.OnGetPlayFabIDsFromSteamIDsResultEvent((GetPlayFabIDsFromSteamIDsResult)e.Result);
				}
				else if (type2 == typeof(GetPlayFabIDsFromTwitchIDsResult) && _instance.OnGetPlayFabIDsFromTwitchIDsResultEvent != null)
				{
					_instance.OnGetPlayFabIDsFromTwitchIDsResultEvent((GetPlayFabIDsFromTwitchIDsResult)e.Result);
				}
				else if (type2 == typeof(GetPlayFabIDsFromXboxLiveIDsResult) && _instance.OnGetPlayFabIDsFromXboxLiveIDsResultEvent != null)
				{
					_instance.OnGetPlayFabIDsFromXboxLiveIDsResultEvent((GetPlayFabIDsFromXboxLiveIDsResult)e.Result);
				}
				else if (type2 == typeof(GetPublisherDataResult) && _instance.OnGetPublisherDataResultEvent != null)
				{
					_instance.OnGetPublisherDataResultEvent((GetPublisherDataResult)e.Result);
				}
				else if (type2 == typeof(GetPurchaseResult) && _instance.OnGetPurchaseResultEvent != null)
				{
					_instance.OnGetPurchaseResultEvent((GetPurchaseResult)e.Result);
				}
				else if (type2 == typeof(GetSharedGroupDataResult) && _instance.OnGetSharedGroupDataResultEvent != null)
				{
					_instance.OnGetSharedGroupDataResultEvent((GetSharedGroupDataResult)e.Result);
				}
				else if (type2 == typeof(GetStoreItemsResult) && _instance.OnGetStoreItemsResultEvent != null)
				{
					_instance.OnGetStoreItemsResultEvent((GetStoreItemsResult)e.Result);
				}
				else if (type2 == typeof(GetTimeResult) && _instance.OnGetTimeResultEvent != null)
				{
					_instance.OnGetTimeResultEvent((GetTimeResult)e.Result);
				}
				else if (type2 == typeof(GetTitleDataResult) && _instance.OnGetTitleDataResultEvent != null)
				{
					_instance.OnGetTitleDataResultEvent((GetTitleDataResult)e.Result);
				}
				else if (type2 == typeof(GetTitleNewsResult) && _instance.OnGetTitleNewsResultEvent != null)
				{
					_instance.OnGetTitleNewsResultEvent((GetTitleNewsResult)e.Result);
				}
				else if (type2 == typeof(GetTitlePublicKeyResult) && _instance.OnGetTitlePublicKeyResultEvent != null)
				{
					_instance.OnGetTitlePublicKeyResultEvent((GetTitlePublicKeyResult)e.Result);
				}
				else if (type2 == typeof(GetTradeStatusResponse) && _instance.OnGetTradeStatusResultEvent != null)
				{
					_instance.OnGetTradeStatusResultEvent((GetTradeStatusResponse)e.Result);
				}
				else if (type2 == typeof(GetUserDataResult) && _instance.OnGetUserDataResultEvent != null)
				{
					_instance.OnGetUserDataResultEvent((GetUserDataResult)e.Result);
				}
				else if (type2 == typeof(GetUserInventoryResult) && _instance.OnGetUserInventoryResultEvent != null)
				{
					_instance.OnGetUserInventoryResultEvent((GetUserInventoryResult)e.Result);
				}
				else if (type2 == typeof(GetUserDataResult) && _instance.OnGetUserPublisherDataResultEvent != null)
				{
					_instance.OnGetUserPublisherDataResultEvent((GetUserDataResult)e.Result);
				}
				else if (type2 == typeof(GetUserDataResult) && _instance.OnGetUserPublisherReadOnlyDataResultEvent != null)
				{
					_instance.OnGetUserPublisherReadOnlyDataResultEvent((GetUserDataResult)e.Result);
				}
				else if (type2 == typeof(GetUserDataResult) && _instance.OnGetUserReadOnlyDataResultEvent != null)
				{
					_instance.OnGetUserReadOnlyDataResultEvent((GetUserDataResult)e.Result);
				}
				else if (type2 == typeof(GetWindowsHelloChallengeResponse) && _instance.OnGetWindowsHelloChallengeResultEvent != null)
				{
					_instance.OnGetWindowsHelloChallengeResultEvent((GetWindowsHelloChallengeResponse)e.Result);
				}
				else if (type2 == typeof(GrantCharacterToUserResult) && _instance.OnGrantCharacterToUserResultEvent != null)
				{
					_instance.OnGrantCharacterToUserResultEvent((GrantCharacterToUserResult)e.Result);
				}
				else if (type2 == typeof(LinkAndroidDeviceIDResult) && _instance.OnLinkAndroidDeviceIDResultEvent != null)
				{
					_instance.OnLinkAndroidDeviceIDResultEvent((LinkAndroidDeviceIDResult)e.Result);
				}
				else if (type2 == typeof(LinkCustomIDResult) && _instance.OnLinkCustomIDResultEvent != null)
				{
					_instance.OnLinkCustomIDResultEvent((LinkCustomIDResult)e.Result);
				}
				else if (type2 == typeof(LinkFacebookAccountResult) && _instance.OnLinkFacebookAccountResultEvent != null)
				{
					_instance.OnLinkFacebookAccountResultEvent((LinkFacebookAccountResult)e.Result);
				}
				else if (type2 == typeof(LinkFacebookInstantGamesIdResult) && _instance.OnLinkFacebookInstantGamesIdResultEvent != null)
				{
					_instance.OnLinkFacebookInstantGamesIdResultEvent((LinkFacebookInstantGamesIdResult)e.Result);
				}
				else if (type2 == typeof(LinkGameCenterAccountResult) && _instance.OnLinkGameCenterAccountResultEvent != null)
				{
					_instance.OnLinkGameCenterAccountResultEvent((LinkGameCenterAccountResult)e.Result);
				}
				else if (type2 == typeof(LinkGoogleAccountResult) && _instance.OnLinkGoogleAccountResultEvent != null)
				{
					_instance.OnLinkGoogleAccountResultEvent((LinkGoogleAccountResult)e.Result);
				}
				else if (type2 == typeof(LinkIOSDeviceIDResult) && _instance.OnLinkIOSDeviceIDResultEvent != null)
				{
					_instance.OnLinkIOSDeviceIDResultEvent((LinkIOSDeviceIDResult)e.Result);
				}
				else if (type2 == typeof(LinkKongregateAccountResult) && _instance.OnLinkKongregateResultEvent != null)
				{
					_instance.OnLinkKongregateResultEvent((LinkKongregateAccountResult)e.Result);
				}
				else if (type2 == typeof(LinkNintendoSwitchDeviceIdResult) && _instance.OnLinkNintendoSwitchDeviceIdResultEvent != null)
				{
					_instance.OnLinkNintendoSwitchDeviceIdResultEvent((LinkNintendoSwitchDeviceIdResult)e.Result);
				}
				else if (type2 == typeof(EmptyResult) && _instance.OnLinkOpenIdConnectResultEvent != null)
				{
					_instance.OnLinkOpenIdConnectResultEvent((EmptyResult)e.Result);
				}
				else if (type2 == typeof(LinkPSNAccountResult) && _instance.OnLinkPSNAccountResultEvent != null)
				{
					_instance.OnLinkPSNAccountResultEvent((LinkPSNAccountResult)e.Result);
				}
				else if (type2 == typeof(LinkSteamAccountResult) && _instance.OnLinkSteamAccountResultEvent != null)
				{
					_instance.OnLinkSteamAccountResultEvent((LinkSteamAccountResult)e.Result);
				}
				else if (type2 == typeof(LinkTwitchAccountResult) && _instance.OnLinkTwitchResultEvent != null)
				{
					_instance.OnLinkTwitchResultEvent((LinkTwitchAccountResult)e.Result);
				}
				else if (type2 == typeof(LinkWindowsHelloAccountResponse) && _instance.OnLinkWindowsHelloResultEvent != null)
				{
					_instance.OnLinkWindowsHelloResultEvent((LinkWindowsHelloAccountResponse)e.Result);
				}
				else if (type2 == typeof(LinkXboxAccountResult) && _instance.OnLinkXboxAccountResultEvent != null)
				{
					_instance.OnLinkXboxAccountResultEvent((LinkXboxAccountResult)e.Result);
				}
				else if (type2 == typeof(MatchmakeResult) && _instance.OnMatchmakeResultEvent != null)
				{
					_instance.OnMatchmakeResultEvent((MatchmakeResult)e.Result);
				}
				else if (type2 == typeof(OpenTradeResponse) && _instance.OnOpenTradeResultEvent != null)
				{
					_instance.OnOpenTradeResultEvent((OpenTradeResponse)e.Result);
				}
				else if (type2 == typeof(PayForPurchaseResult) && _instance.OnPayForPurchaseResultEvent != null)
				{
					_instance.OnPayForPurchaseResultEvent((PayForPurchaseResult)e.Result);
				}
				else if (type2 == typeof(PurchaseItemResult) && _instance.OnPurchaseItemResultEvent != null)
				{
					_instance.OnPurchaseItemResultEvent((PurchaseItemResult)e.Result);
				}
				else if (type2 == typeof(RedeemCouponResult) && _instance.OnRedeemCouponResultEvent != null)
				{
					_instance.OnRedeemCouponResultEvent((RedeemCouponResult)e.Result);
				}
				else if (type2 == typeof(PlayFab.ClientModels.EmptyResponse) && _instance.OnRefreshPSNAuthTokenResultEvent != null)
				{
					_instance.OnRefreshPSNAuthTokenResultEvent((PlayFab.ClientModels.EmptyResponse)e.Result);
				}
				else if (type2 == typeof(RegisterForIOSPushNotificationResult) && _instance.OnRegisterForIOSPushNotificationResultEvent != null)
				{
					_instance.OnRegisterForIOSPushNotificationResultEvent((RegisterForIOSPushNotificationResult)e.Result);
				}
				else if (type2 == typeof(RegisterPlayFabUserResult) && _instance.OnRegisterPlayFabUserResultEvent != null)
				{
					_instance.OnRegisterPlayFabUserResultEvent((RegisterPlayFabUserResult)e.Result);
				}
				else if (type2 == typeof(RemoveContactEmailResult) && _instance.OnRemoveContactEmailResultEvent != null)
				{
					_instance.OnRemoveContactEmailResultEvent((RemoveContactEmailResult)e.Result);
				}
				else if (type2 == typeof(RemoveFriendResult) && _instance.OnRemoveFriendResultEvent != null)
				{
					_instance.OnRemoveFriendResultEvent((RemoveFriendResult)e.Result);
				}
				else if (type2 == typeof(RemoveGenericIDResult) && _instance.OnRemoveGenericIDResultEvent != null)
				{
					_instance.OnRemoveGenericIDResultEvent((RemoveGenericIDResult)e.Result);
				}
				else if (type2 == typeof(RemoveSharedGroupMembersResult) && _instance.OnRemoveSharedGroupMembersResultEvent != null)
				{
					_instance.OnRemoveSharedGroupMembersResultEvent((RemoveSharedGroupMembersResult)e.Result);
				}
				else if (type2 == typeof(PlayFab.ClientModels.EmptyResponse) && _instance.OnReportDeviceInfoResultEvent != null)
				{
					_instance.OnReportDeviceInfoResultEvent((PlayFab.ClientModels.EmptyResponse)e.Result);
				}
				else if (type2 == typeof(ReportPlayerClientResult) && _instance.OnReportPlayerResultEvent != null)
				{
					_instance.OnReportPlayerResultEvent((ReportPlayerClientResult)e.Result);
				}
				else if (type2 == typeof(RestoreIOSPurchasesResult) && _instance.OnRestoreIOSPurchasesResultEvent != null)
				{
					_instance.OnRestoreIOSPurchasesResultEvent((RestoreIOSPurchasesResult)e.Result);
				}
				else if (type2 == typeof(SendAccountRecoveryEmailResult) && _instance.OnSendAccountRecoveryEmailResultEvent != null)
				{
					_instance.OnSendAccountRecoveryEmailResultEvent((SendAccountRecoveryEmailResult)e.Result);
				}
				else if (type2 == typeof(SetFriendTagsResult) && _instance.OnSetFriendTagsResultEvent != null)
				{
					_instance.OnSetFriendTagsResultEvent((SetFriendTagsResult)e.Result);
				}
				else if (type2 == typeof(SetPlayerSecretResult) && _instance.OnSetPlayerSecretResultEvent != null)
				{
					_instance.OnSetPlayerSecretResultEvent((SetPlayerSecretResult)e.Result);
				}
				else if (type2 == typeof(StartGameResult) && _instance.OnStartGameResultEvent != null)
				{
					_instance.OnStartGameResultEvent((StartGameResult)e.Result);
				}
				else if (type2 == typeof(StartPurchaseResult) && _instance.OnStartPurchaseResultEvent != null)
				{
					_instance.OnStartPurchaseResultEvent((StartPurchaseResult)e.Result);
				}
				else if (type2 == typeof(ModifyUserVirtualCurrencyResult) && _instance.OnSubtractUserVirtualCurrencyResultEvent != null)
				{
					_instance.OnSubtractUserVirtualCurrencyResultEvent((ModifyUserVirtualCurrencyResult)e.Result);
				}
				else if (type2 == typeof(UnlinkAndroidDeviceIDResult) && _instance.OnUnlinkAndroidDeviceIDResultEvent != null)
				{
					_instance.OnUnlinkAndroidDeviceIDResultEvent((UnlinkAndroidDeviceIDResult)e.Result);
				}
				else if (type2 == typeof(UnlinkCustomIDResult) && _instance.OnUnlinkCustomIDResultEvent != null)
				{
					_instance.OnUnlinkCustomIDResultEvent((UnlinkCustomIDResult)e.Result);
				}
				else if (type2 == typeof(UnlinkFacebookAccountResult) && _instance.OnUnlinkFacebookAccountResultEvent != null)
				{
					_instance.OnUnlinkFacebookAccountResultEvent((UnlinkFacebookAccountResult)e.Result);
				}
				else if (type2 == typeof(UnlinkFacebookInstantGamesIdResult) && _instance.OnUnlinkFacebookInstantGamesIdResultEvent != null)
				{
					_instance.OnUnlinkFacebookInstantGamesIdResultEvent((UnlinkFacebookInstantGamesIdResult)e.Result);
				}
				else if (type2 == typeof(UnlinkGameCenterAccountResult) && _instance.OnUnlinkGameCenterAccountResultEvent != null)
				{
					_instance.OnUnlinkGameCenterAccountResultEvent((UnlinkGameCenterAccountResult)e.Result);
				}
				else if (type2 == typeof(UnlinkGoogleAccountResult) && _instance.OnUnlinkGoogleAccountResultEvent != null)
				{
					_instance.OnUnlinkGoogleAccountResultEvent((UnlinkGoogleAccountResult)e.Result);
				}
				else if (type2 == typeof(UnlinkIOSDeviceIDResult) && _instance.OnUnlinkIOSDeviceIDResultEvent != null)
				{
					_instance.OnUnlinkIOSDeviceIDResultEvent((UnlinkIOSDeviceIDResult)e.Result);
				}
				else if (type2 == typeof(UnlinkKongregateAccountResult) && _instance.OnUnlinkKongregateResultEvent != null)
				{
					_instance.OnUnlinkKongregateResultEvent((UnlinkKongregateAccountResult)e.Result);
				}
				else if (type2 == typeof(UnlinkNintendoSwitchDeviceIdResult) && _instance.OnUnlinkNintendoSwitchDeviceIdResultEvent != null)
				{
					_instance.OnUnlinkNintendoSwitchDeviceIdResultEvent((UnlinkNintendoSwitchDeviceIdResult)e.Result);
				}
				else if (type2 == typeof(PlayFab.ClientModels.EmptyResponse) && _instance.OnUnlinkOpenIdConnectResultEvent != null)
				{
					_instance.OnUnlinkOpenIdConnectResultEvent((PlayFab.ClientModels.EmptyResponse)e.Result);
				}
				else if (type2 == typeof(UnlinkPSNAccountResult) && _instance.OnUnlinkPSNAccountResultEvent != null)
				{
					_instance.OnUnlinkPSNAccountResultEvent((UnlinkPSNAccountResult)e.Result);
				}
				else if (type2 == typeof(UnlinkSteamAccountResult) && _instance.OnUnlinkSteamAccountResultEvent != null)
				{
					_instance.OnUnlinkSteamAccountResultEvent((UnlinkSteamAccountResult)e.Result);
				}
				else if (type2 == typeof(UnlinkTwitchAccountResult) && _instance.OnUnlinkTwitchResultEvent != null)
				{
					_instance.OnUnlinkTwitchResultEvent((UnlinkTwitchAccountResult)e.Result);
				}
				else if (type2 == typeof(UnlinkWindowsHelloAccountResponse) && _instance.OnUnlinkWindowsHelloResultEvent != null)
				{
					_instance.OnUnlinkWindowsHelloResultEvent((UnlinkWindowsHelloAccountResponse)e.Result);
				}
				else if (type2 == typeof(UnlinkXboxAccountResult) && _instance.OnUnlinkXboxAccountResultEvent != null)
				{
					_instance.OnUnlinkXboxAccountResultEvent((UnlinkXboxAccountResult)e.Result);
				}
				else if (type2 == typeof(UnlockContainerItemResult) && _instance.OnUnlockContainerInstanceResultEvent != null)
				{
					_instance.OnUnlockContainerInstanceResultEvent((UnlockContainerItemResult)e.Result);
				}
				else if (type2 == typeof(UnlockContainerItemResult) && _instance.OnUnlockContainerItemResultEvent != null)
				{
					_instance.OnUnlockContainerItemResultEvent((UnlockContainerItemResult)e.Result);
				}
				else if (type2 == typeof(PlayFab.ClientModels.EmptyResponse) && _instance.OnUpdateAvatarUrlResultEvent != null)
				{
					_instance.OnUpdateAvatarUrlResultEvent((PlayFab.ClientModels.EmptyResponse)e.Result);
				}
				else if (type2 == typeof(UpdateCharacterDataResult) && _instance.OnUpdateCharacterDataResultEvent != null)
				{
					_instance.OnUpdateCharacterDataResultEvent((UpdateCharacterDataResult)e.Result);
				}
				else if (type2 == typeof(UpdateCharacterStatisticsResult) && _instance.OnUpdateCharacterStatisticsResultEvent != null)
				{
					_instance.OnUpdateCharacterStatisticsResultEvent((UpdateCharacterStatisticsResult)e.Result);
				}
				else if (type2 == typeof(UpdatePlayerStatisticsResult) && _instance.OnUpdatePlayerStatisticsResultEvent != null)
				{
					_instance.OnUpdatePlayerStatisticsResultEvent((UpdatePlayerStatisticsResult)e.Result);
				}
				else if (type2 == typeof(UpdateSharedGroupDataResult) && _instance.OnUpdateSharedGroupDataResultEvent != null)
				{
					_instance.OnUpdateSharedGroupDataResultEvent((UpdateSharedGroupDataResult)e.Result);
				}
				else if (type2 == typeof(UpdateUserDataResult) && _instance.OnUpdateUserDataResultEvent != null)
				{
					_instance.OnUpdateUserDataResultEvent((UpdateUserDataResult)e.Result);
				}
				else if (type2 == typeof(UpdateUserDataResult) && _instance.OnUpdateUserPublisherDataResultEvent != null)
				{
					_instance.OnUpdateUserPublisherDataResultEvent((UpdateUserDataResult)e.Result);
				}
				else if (type2 == typeof(UpdateUserTitleDisplayNameResult) && _instance.OnUpdateUserTitleDisplayNameResultEvent != null)
				{
					_instance.OnUpdateUserTitleDisplayNameResultEvent((UpdateUserTitleDisplayNameResult)e.Result);
				}
				else if (type2 == typeof(ValidateAmazonReceiptResult) && _instance.OnValidateAmazonIAPReceiptResultEvent != null)
				{
					_instance.OnValidateAmazonIAPReceiptResultEvent((ValidateAmazonReceiptResult)e.Result);
				}
				else if (type2 == typeof(ValidateGooglePlayPurchaseResult) && _instance.OnValidateGooglePlayPurchaseResultEvent != null)
				{
					_instance.OnValidateGooglePlayPurchaseResultEvent((ValidateGooglePlayPurchaseResult)e.Result);
				}
				else if (type2 == typeof(ValidateIOSReceiptResult) && _instance.OnValidateIOSReceiptResultEvent != null)
				{
					_instance.OnValidateIOSReceiptResultEvent((ValidateIOSReceiptResult)e.Result);
				}
				else if (type2 == typeof(ValidateWindowsReceiptResult) && _instance.OnValidateWindowsStoreReceiptResultEvent != null)
				{
					_instance.OnValidateWindowsStoreReceiptResultEvent((ValidateWindowsReceiptResult)e.Result);
				}
				else if (type2 == typeof(WriteEventResponse) && _instance.OnWriteCharacterEventResultEvent != null)
				{
					_instance.OnWriteCharacterEventResultEvent((WriteEventResponse)e.Result);
				}
				else if (type2 == typeof(WriteEventResponse) && _instance.OnWritePlayerEventResultEvent != null)
				{
					_instance.OnWritePlayerEventResultEvent((WriteEventResponse)e.Result);
				}
				else if (type2 == typeof(WriteEventResponse) && _instance.OnWriteTitleEventResultEvent != null)
				{
					_instance.OnWriteTitleEventResultEvent((WriteEventResponse)e.Result);
				}
				else if (type2 == typeof(GetEntityTokenResponse) && _instance.OnAuthenticationGetEntityTokenResultEvent != null)
				{
					_instance.OnAuthenticationGetEntityTokenResultEvent((GetEntityTokenResponse)e.Result);
				}
				else if (type2 == typeof(ValidateEntityTokenResponse) && _instance.OnAuthenticationValidateEntityTokenResultEvent != null)
				{
					_instance.OnAuthenticationValidateEntityTokenResultEvent((ValidateEntityTokenResponse)e.Result);
				}
				else if (type2 == typeof(PlayFab.CloudScriptModels.ExecuteCloudScriptResult) && _instance.OnCloudScriptExecuteEntityCloudScriptResultEvent != null)
				{
					_instance.OnCloudScriptExecuteEntityCloudScriptResultEvent((PlayFab.CloudScriptModels.ExecuteCloudScriptResult)e.Result);
				}
				else if (type2 == typeof(AbortFileUploadsResponse) && _instance.OnDataAbortFileUploadsResultEvent != null)
				{
					_instance.OnDataAbortFileUploadsResultEvent((AbortFileUploadsResponse)e.Result);
				}
				else if (type2 == typeof(DeleteFilesResponse) && _instance.OnDataDeleteFilesResultEvent != null)
				{
					_instance.OnDataDeleteFilesResultEvent((DeleteFilesResponse)e.Result);
				}
				else if (type2 == typeof(FinalizeFileUploadsResponse) && _instance.OnDataFinalizeFileUploadsResultEvent != null)
				{
					_instance.OnDataFinalizeFileUploadsResultEvent((FinalizeFileUploadsResponse)e.Result);
				}
				else if (type2 == typeof(GetFilesResponse) && _instance.OnDataGetFilesResultEvent != null)
				{
					_instance.OnDataGetFilesResultEvent((GetFilesResponse)e.Result);
				}
				else if (type2 == typeof(GetObjectsResponse) && _instance.OnDataGetObjectsResultEvent != null)
				{
					_instance.OnDataGetObjectsResultEvent((GetObjectsResponse)e.Result);
				}
				else if (type2 == typeof(InitiateFileUploadsResponse) && _instance.OnDataInitiateFileUploadsResultEvent != null)
				{
					_instance.OnDataInitiateFileUploadsResultEvent((InitiateFileUploadsResponse)e.Result);
				}
				else if (type2 == typeof(SetObjectsResponse) && _instance.OnDataSetObjectsResultEvent != null)
				{
					_instance.OnDataSetObjectsResultEvent((SetObjectsResponse)e.Result);
				}
				else if (type2 == typeof(WriteEventsResponse) && _instance.OnEventsWriteEventsResultEvent != null)
				{
					_instance.OnEventsWriteEventsResultEvent((WriteEventsResponse)e.Result);
				}
				else if (type2 == typeof(WriteEventsResponse) && _instance.OnEventsWriteTelemetryEventsResultEvent != null)
				{
					_instance.OnEventsWriteTelemetryEventsResultEvent((WriteEventsResponse)e.Result);
				}
				else if (type2 == typeof(PlayFab.GroupsModels.EmptyResponse) && _instance.OnGroupsAcceptGroupApplicationResultEvent != null)
				{
					_instance.OnGroupsAcceptGroupApplicationResultEvent((PlayFab.GroupsModels.EmptyResponse)e.Result);
				}
				else if (type2 == typeof(PlayFab.GroupsModels.EmptyResponse) && _instance.OnGroupsAcceptGroupInvitationResultEvent != null)
				{
					_instance.OnGroupsAcceptGroupInvitationResultEvent((PlayFab.GroupsModels.EmptyResponse)e.Result);
				}
				else if (type2 == typeof(PlayFab.GroupsModels.EmptyResponse) && _instance.OnGroupsAddMembersResultEvent != null)
				{
					_instance.OnGroupsAddMembersResultEvent((PlayFab.GroupsModels.EmptyResponse)e.Result);
				}
				else if (type2 == typeof(ApplyToGroupResponse) && _instance.OnGroupsApplyToGroupResultEvent != null)
				{
					_instance.OnGroupsApplyToGroupResultEvent((ApplyToGroupResponse)e.Result);
				}
				else if (type2 == typeof(PlayFab.GroupsModels.EmptyResponse) && _instance.OnGroupsBlockEntityResultEvent != null)
				{
					_instance.OnGroupsBlockEntityResultEvent((PlayFab.GroupsModels.EmptyResponse)e.Result);
				}
				else if (type2 == typeof(PlayFab.GroupsModels.EmptyResponse) && _instance.OnGroupsChangeMemberRoleResultEvent != null)
				{
					_instance.OnGroupsChangeMemberRoleResultEvent((PlayFab.GroupsModels.EmptyResponse)e.Result);
				}
				else if (type2 == typeof(CreateGroupResponse) && _instance.OnGroupsCreateGroupResultEvent != null)
				{
					_instance.OnGroupsCreateGroupResultEvent((CreateGroupResponse)e.Result);
				}
				else if (type2 == typeof(CreateGroupRoleResponse) && _instance.OnGroupsCreateRoleResultEvent != null)
				{
					_instance.OnGroupsCreateRoleResultEvent((CreateGroupRoleResponse)e.Result);
				}
				else if (type2 == typeof(PlayFab.GroupsModels.EmptyResponse) && _instance.OnGroupsDeleteGroupResultEvent != null)
				{
					_instance.OnGroupsDeleteGroupResultEvent((PlayFab.GroupsModels.EmptyResponse)e.Result);
				}
				else if (type2 == typeof(PlayFab.GroupsModels.EmptyResponse) && _instance.OnGroupsDeleteRoleResultEvent != null)
				{
					_instance.OnGroupsDeleteRoleResultEvent((PlayFab.GroupsModels.EmptyResponse)e.Result);
				}
				else if (type2 == typeof(GetGroupResponse) && _instance.OnGroupsGetGroupResultEvent != null)
				{
					_instance.OnGroupsGetGroupResultEvent((GetGroupResponse)e.Result);
				}
				else if (type2 == typeof(InviteToGroupResponse) && _instance.OnGroupsInviteToGroupResultEvent != null)
				{
					_instance.OnGroupsInviteToGroupResultEvent((InviteToGroupResponse)e.Result);
				}
				else if (type2 == typeof(IsMemberResponse) && _instance.OnGroupsIsMemberResultEvent != null)
				{
					_instance.OnGroupsIsMemberResultEvent((IsMemberResponse)e.Result);
				}
				else if (type2 == typeof(ListGroupApplicationsResponse) && _instance.OnGroupsListGroupApplicationsResultEvent != null)
				{
					_instance.OnGroupsListGroupApplicationsResultEvent((ListGroupApplicationsResponse)e.Result);
				}
				else if (type2 == typeof(ListGroupBlocksResponse) && _instance.OnGroupsListGroupBlocksResultEvent != null)
				{
					_instance.OnGroupsListGroupBlocksResultEvent((ListGroupBlocksResponse)e.Result);
				}
				else if (type2 == typeof(ListGroupInvitationsResponse) && _instance.OnGroupsListGroupInvitationsResultEvent != null)
				{
					_instance.OnGroupsListGroupInvitationsResultEvent((ListGroupInvitationsResponse)e.Result);
				}
				else if (type2 == typeof(ListGroupMembersResponse) && _instance.OnGroupsListGroupMembersResultEvent != null)
				{
					_instance.OnGroupsListGroupMembersResultEvent((ListGroupMembersResponse)e.Result);
				}
				else if (type2 == typeof(ListMembershipResponse) && _instance.OnGroupsListMembershipResultEvent != null)
				{
					_instance.OnGroupsListMembershipResultEvent((ListMembershipResponse)e.Result);
				}
				else if (type2 == typeof(ListMembershipOpportunitiesResponse) && _instance.OnGroupsListMembershipOpportunitiesResultEvent != null)
				{
					_instance.OnGroupsListMembershipOpportunitiesResultEvent((ListMembershipOpportunitiesResponse)e.Result);
				}
				else if (type2 == typeof(PlayFab.GroupsModels.EmptyResponse) && _instance.OnGroupsRemoveGroupApplicationResultEvent != null)
				{
					_instance.OnGroupsRemoveGroupApplicationResultEvent((PlayFab.GroupsModels.EmptyResponse)e.Result);
				}
				else if (type2 == typeof(PlayFab.GroupsModels.EmptyResponse) && _instance.OnGroupsRemoveGroupInvitationResultEvent != null)
				{
					_instance.OnGroupsRemoveGroupInvitationResultEvent((PlayFab.GroupsModels.EmptyResponse)e.Result);
				}
				else if (type2 == typeof(PlayFab.GroupsModels.EmptyResponse) && _instance.OnGroupsRemoveMembersResultEvent != null)
				{
					_instance.OnGroupsRemoveMembersResultEvent((PlayFab.GroupsModels.EmptyResponse)e.Result);
				}
				else if (type2 == typeof(PlayFab.GroupsModels.EmptyResponse) && _instance.OnGroupsUnblockEntityResultEvent != null)
				{
					_instance.OnGroupsUnblockEntityResultEvent((PlayFab.GroupsModels.EmptyResponse)e.Result);
				}
				else if (type2 == typeof(UpdateGroupResponse) && _instance.OnGroupsUpdateGroupResultEvent != null)
				{
					_instance.OnGroupsUpdateGroupResultEvent((UpdateGroupResponse)e.Result);
				}
				else if (type2 == typeof(UpdateGroupRoleResponse) && _instance.OnGroupsUpdateRoleResultEvent != null)
				{
					_instance.OnGroupsUpdateRoleResultEvent((UpdateGroupRoleResponse)e.Result);
				}
				else if (type2 == typeof(GetLanguageListResponse) && _instance.OnLocalizationGetLanguageListResultEvent != null)
				{
					_instance.OnLocalizationGetLanguageListResultEvent((GetLanguageListResponse)e.Result);
				}
				else if (type2 == typeof(CancelAllMatchmakingTicketsForPlayerResult) && _instance.OnMultiplayerCancelAllMatchmakingTicketsForPlayerResultEvent != null)
				{
					_instance.OnMultiplayerCancelAllMatchmakingTicketsForPlayerResultEvent((CancelAllMatchmakingTicketsForPlayerResult)e.Result);
				}
				else if (type2 == typeof(CancelMatchmakingTicketResult) && _instance.OnMultiplayerCancelMatchmakingTicketResultEvent != null)
				{
					_instance.OnMultiplayerCancelMatchmakingTicketResultEvent((CancelMatchmakingTicketResult)e.Result);
				}
				else if (type2 == typeof(CreateBuildWithCustomContainerResponse) && _instance.OnMultiplayerCreateBuildWithCustomContainerResultEvent != null)
				{
					_instance.OnMultiplayerCreateBuildWithCustomContainerResultEvent((CreateBuildWithCustomContainerResponse)e.Result);
				}
				else if (type2 == typeof(CreateBuildWithManagedContainerResponse) && _instance.OnMultiplayerCreateBuildWithManagedContainerResultEvent != null)
				{
					_instance.OnMultiplayerCreateBuildWithManagedContainerResultEvent((CreateBuildWithManagedContainerResponse)e.Result);
				}
				else if (type2 == typeof(CreateMatchmakingTicketResult) && _instance.OnMultiplayerCreateMatchmakingTicketResultEvent != null)
				{
					_instance.OnMultiplayerCreateMatchmakingTicketResultEvent((CreateMatchmakingTicketResult)e.Result);
				}
				else if (type2 == typeof(CreateRemoteUserResponse) && _instance.OnMultiplayerCreateRemoteUserResultEvent != null)
				{
					_instance.OnMultiplayerCreateRemoteUserResultEvent((CreateRemoteUserResponse)e.Result);
				}
				else if (type2 == typeof(CreateMatchmakingTicketResult) && _instance.OnMultiplayerCreateServerMatchmakingTicketResultEvent != null)
				{
					_instance.OnMultiplayerCreateServerMatchmakingTicketResultEvent((CreateMatchmakingTicketResult)e.Result);
				}
				else if (type2 == typeof(PlayFab.MultiplayerModels.EmptyResponse) && _instance.OnMultiplayerDeleteAssetResultEvent != null)
				{
					_instance.OnMultiplayerDeleteAssetResultEvent((PlayFab.MultiplayerModels.EmptyResponse)e.Result);
				}
				else if (type2 == typeof(PlayFab.MultiplayerModels.EmptyResponse) && _instance.OnMultiplayerDeleteBuildResultEvent != null)
				{
					_instance.OnMultiplayerDeleteBuildResultEvent((PlayFab.MultiplayerModels.EmptyResponse)e.Result);
				}
				else if (type2 == typeof(PlayFab.MultiplayerModels.EmptyResponse) && _instance.OnMultiplayerDeleteCertificateResultEvent != null)
				{
					_instance.OnMultiplayerDeleteCertificateResultEvent((PlayFab.MultiplayerModels.EmptyResponse)e.Result);
				}
				else if (type2 == typeof(PlayFab.MultiplayerModels.EmptyResponse) && _instance.OnMultiplayerDeleteRemoteUserResultEvent != null)
				{
					_instance.OnMultiplayerDeleteRemoteUserResultEvent((PlayFab.MultiplayerModels.EmptyResponse)e.Result);
				}
				else if (type2 == typeof(EnableMultiplayerServersForTitleResponse) && _instance.OnMultiplayerEnableMultiplayerServersForTitleResultEvent != null)
				{
					_instance.OnMultiplayerEnableMultiplayerServersForTitleResultEvent((EnableMultiplayerServersForTitleResponse)e.Result);
				}
				else if (type2 == typeof(GetAssetUploadUrlResponse) && _instance.OnMultiplayerGetAssetUploadUrlResultEvent != null)
				{
					_instance.OnMultiplayerGetAssetUploadUrlResultEvent((GetAssetUploadUrlResponse)e.Result);
				}
				else if (type2 == typeof(GetBuildResponse) && _instance.OnMultiplayerGetBuildResultEvent != null)
				{
					_instance.OnMultiplayerGetBuildResultEvent((GetBuildResponse)e.Result);
				}
				else if (type2 == typeof(GetContainerRegistryCredentialsResponse) && _instance.OnMultiplayerGetContainerRegistryCredentialsResultEvent != null)
				{
					_instance.OnMultiplayerGetContainerRegistryCredentialsResultEvent((GetContainerRegistryCredentialsResponse)e.Result);
				}
				else if (type2 == typeof(GetMatchResult) && _instance.OnMultiplayerGetMatchResultEvent != null)
				{
					_instance.OnMultiplayerGetMatchResultEvent((GetMatchResult)e.Result);
				}
				else if (type2 == typeof(GetMatchmakingTicketResult) && _instance.OnMultiplayerGetMatchmakingTicketResultEvent != null)
				{
					_instance.OnMultiplayerGetMatchmakingTicketResultEvent((GetMatchmakingTicketResult)e.Result);
				}
				else if (type2 == typeof(GetMultiplayerServerDetailsResponse) && _instance.OnMultiplayerGetMultiplayerServerDetailsResultEvent != null)
				{
					_instance.OnMultiplayerGetMultiplayerServerDetailsResultEvent((GetMultiplayerServerDetailsResponse)e.Result);
				}
				else if (type2 == typeof(GetQueueStatisticsResult) && _instance.OnMultiplayerGetQueueStatisticsResultEvent != null)
				{
					_instance.OnMultiplayerGetQueueStatisticsResultEvent((GetQueueStatisticsResult)e.Result);
				}
				else if (type2 == typeof(GetRemoteLoginEndpointResponse) && _instance.OnMultiplayerGetRemoteLoginEndpointResultEvent != null)
				{
					_instance.OnMultiplayerGetRemoteLoginEndpointResultEvent((GetRemoteLoginEndpointResponse)e.Result);
				}
				else if (type2 == typeof(GetTitleEnabledForMultiplayerServersStatusResponse) && _instance.OnMultiplayerGetTitleEnabledForMultiplayerServersStatusResultEvent != null)
				{
					_instance.OnMultiplayerGetTitleEnabledForMultiplayerServersStatusResultEvent((GetTitleEnabledForMultiplayerServersStatusResponse)e.Result);
				}
				else if (type2 == typeof(GetTitleMultiplayerServersQuotasResponse) && _instance.OnMultiplayerGetTitleMultiplayerServersQuotasResultEvent != null)
				{
					_instance.OnMultiplayerGetTitleMultiplayerServersQuotasResultEvent((GetTitleMultiplayerServersQuotasResponse)e.Result);
				}
				else if (type2 == typeof(JoinMatchmakingTicketResult) && _instance.OnMultiplayerJoinMatchmakingTicketResultEvent != null)
				{
					_instance.OnMultiplayerJoinMatchmakingTicketResultEvent((JoinMatchmakingTicketResult)e.Result);
				}
				else if (type2 == typeof(ListMultiplayerServersResponse) && _instance.OnMultiplayerListArchivedMultiplayerServersResultEvent != null)
				{
					_instance.OnMultiplayerListArchivedMultiplayerServersResultEvent((ListMultiplayerServersResponse)e.Result);
				}
				else if (type2 == typeof(ListAssetSummariesResponse) && _instance.OnMultiplayerListAssetSummariesResultEvent != null)
				{
					_instance.OnMultiplayerListAssetSummariesResultEvent((ListAssetSummariesResponse)e.Result);
				}
				else if (type2 == typeof(ListBuildSummariesResponse) && _instance.OnMultiplayerListBuildSummariesResultEvent != null)
				{
					_instance.OnMultiplayerListBuildSummariesResultEvent((ListBuildSummariesResponse)e.Result);
				}
				else if (type2 == typeof(ListCertificateSummariesResponse) && _instance.OnMultiplayerListCertificateSummariesResultEvent != null)
				{
					_instance.OnMultiplayerListCertificateSummariesResultEvent((ListCertificateSummariesResponse)e.Result);
				}
				else if (type2 == typeof(ListContainerImagesResponse) && _instance.OnMultiplayerListContainerImagesResultEvent != null)
				{
					_instance.OnMultiplayerListContainerImagesResultEvent((ListContainerImagesResponse)e.Result);
				}
				else if (type2 == typeof(ListContainerImageTagsResponse) && _instance.OnMultiplayerListContainerImageTagsResultEvent != null)
				{
					_instance.OnMultiplayerListContainerImageTagsResultEvent((ListContainerImageTagsResponse)e.Result);
				}
				else if (type2 == typeof(ListMatchmakingTicketsForPlayerResult) && _instance.OnMultiplayerListMatchmakingTicketsForPlayerResultEvent != null)
				{
					_instance.OnMultiplayerListMatchmakingTicketsForPlayerResultEvent((ListMatchmakingTicketsForPlayerResult)e.Result);
				}
				else if (type2 == typeof(ListMultiplayerServersResponse) && _instance.OnMultiplayerListMultiplayerServersResultEvent != null)
				{
					_instance.OnMultiplayerListMultiplayerServersResultEvent((ListMultiplayerServersResponse)e.Result);
				}
				else if (type2 == typeof(ListPartyQosServersResponse) && _instance.OnMultiplayerListPartyQosServersResultEvent != null)
				{
					_instance.OnMultiplayerListPartyQosServersResultEvent((ListPartyQosServersResponse)e.Result);
				}
				else if (type2 == typeof(ListQosServersResponse) && _instance.OnMultiplayerListQosServersResultEvent != null)
				{
					_instance.OnMultiplayerListQosServersResultEvent((ListQosServersResponse)e.Result);
				}
				else if (type2 == typeof(ListQosServersForTitleResponse) && _instance.OnMultiplayerListQosServersForTitleResultEvent != null)
				{
					_instance.OnMultiplayerListQosServersForTitleResultEvent((ListQosServersForTitleResponse)e.Result);
				}
				else if (type2 == typeof(ListVirtualMachineSummariesResponse) && _instance.OnMultiplayerListVirtualMachineSummariesResultEvent != null)
				{
					_instance.OnMultiplayerListVirtualMachineSummariesResultEvent((ListVirtualMachineSummariesResponse)e.Result);
				}
				else if (type2 == typeof(RequestMultiplayerServerResponse) && _instance.OnMultiplayerRequestMultiplayerServerResultEvent != null)
				{
					_instance.OnMultiplayerRequestMultiplayerServerResultEvent((RequestMultiplayerServerResponse)e.Result);
				}
				else if (type2 == typeof(RolloverContainerRegistryCredentialsResponse) && _instance.OnMultiplayerRolloverContainerRegistryCredentialsResultEvent != null)
				{
					_instance.OnMultiplayerRolloverContainerRegistryCredentialsResultEvent((RolloverContainerRegistryCredentialsResponse)e.Result);
				}
				else if (type2 == typeof(PlayFab.MultiplayerModels.EmptyResponse) && _instance.OnMultiplayerShutdownMultiplayerServerResultEvent != null)
				{
					_instance.OnMultiplayerShutdownMultiplayerServerResultEvent((PlayFab.MultiplayerModels.EmptyResponse)e.Result);
				}
				else if (type2 == typeof(PlayFab.MultiplayerModels.EmptyResponse) && _instance.OnMultiplayerUpdateBuildRegionsResultEvent != null)
				{
					_instance.OnMultiplayerUpdateBuildRegionsResultEvent((PlayFab.MultiplayerModels.EmptyResponse)e.Result);
				}
				else if (type2 == typeof(PlayFab.MultiplayerModels.EmptyResponse) && _instance.OnMultiplayerUploadCertificateResultEvent != null)
				{
					_instance.OnMultiplayerUploadCertificateResultEvent((PlayFab.MultiplayerModels.EmptyResponse)e.Result);
				}
				else if (type2 == typeof(GetGlobalPolicyResponse) && _instance.OnProfilesGetGlobalPolicyResultEvent != null)
				{
					_instance.OnProfilesGetGlobalPolicyResultEvent((GetGlobalPolicyResponse)e.Result);
				}
				else if (type2 == typeof(GetEntityProfileResponse) && _instance.OnProfilesGetProfileResultEvent != null)
				{
					_instance.OnProfilesGetProfileResultEvent((GetEntityProfileResponse)e.Result);
				}
				else if (type2 == typeof(GetEntityProfilesResponse) && _instance.OnProfilesGetProfilesResultEvent != null)
				{
					_instance.OnProfilesGetProfilesResultEvent((GetEntityProfilesResponse)e.Result);
				}
				else if (type2 == typeof(GetTitlePlayersFromMasterPlayerAccountIdsResponse) && _instance.OnProfilesGetTitlePlayersFromMasterPlayerAccountIdsResultEvent != null)
				{
					_instance.OnProfilesGetTitlePlayersFromMasterPlayerAccountIdsResultEvent((GetTitlePlayersFromMasterPlayerAccountIdsResponse)e.Result);
				}
				else if (type2 == typeof(SetGlobalPolicyResponse) && _instance.OnProfilesSetGlobalPolicyResultEvent != null)
				{
					_instance.OnProfilesSetGlobalPolicyResultEvent((SetGlobalPolicyResponse)e.Result);
				}
				else if (type2 == typeof(SetProfileLanguageResponse) && _instance.OnProfilesSetProfileLanguageResultEvent != null)
				{
					_instance.OnProfilesSetProfileLanguageResultEvent((SetProfileLanguageResponse)e.Result);
				}
				else if (type2 == typeof(SetEntityProfilePolicyResponse) && _instance.OnProfilesSetProfilePolicyResultEvent != null)
				{
					_instance.OnProfilesSetProfilePolicyResultEvent((SetEntityProfilePolicyResponse)e.Result);
				}
			}
		}
	}
}
namespace PlayFab.AuthenticationModels
{
	[Serializable]
	public class EntityKey : PlayFabBaseModel
	{
		public string Id;

		public string Type;
	}
	[Serializable]
	public class EntityLineage : PlayFabBaseModel
	{
		public string CharacterId;

		public string GroupId;

		public string MasterPlayerAccountId;

		public string NamespaceId;

		public string TitleId;

		public string TitlePlayerAccountId;
	}
	[Serializable]
	public class GetEntityTokenRequest : PlayFabRequestCommon
	{
		public EntityKey Entity;
	}
	[Serializable]
	public class GetEntityTokenResponse : PlayFabResultCommon
	{
		public EntityKey Entity;

		public string EntityToken;

		public DateTime? TokenExpiration;
	}
	public enum LoginIdentityProvider
	{
		Unknown,
		PlayFab,
		Custom,
		GameCenter,
		GooglePlay,
		Steam,
		XBoxLive,
		PSN,
		Kongregate,
		Facebook,
		IOSDevice,
		AndroidDevice,
		Twitch,
		WindowsHello,
		GameServer,
		CustomServer,
		NintendoSwitch,
		FacebookInstantGames,
		OpenIdConnect
	}
	[Serializable]
	public class ValidateEntityTokenRequest : PlayFabRequestCommon
	{
		public string EntityToken;
	}
	[Serializable]
	public class ValidateEntityTokenResponse : PlayFabResultCommon
	{
		public EntityKey Entity;

		public LoginIdentityProvider? IdentityProvider;

		public EntityLineage Lineage;
	}
}
namespace BoundarySystem_Ext
{
	internal static class Pvr_BoundaryAPI
	{
		private const string LibFileName = "Pvr_UnitySDK";

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern void Pvr_StartSDKBoundary();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern void Pvr_ShutdownSDKBoundary();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetMainSensorStateExt(ref float x, ref float y, ref float z, ref float w, ref float px, ref float py, ref float pz, ref float vfov, ref float hfov, ref int viewNumber);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern IntPtr Pvr_GetCameraData_Ext();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern void Pvr_ResetVrModebyForce();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_ResumeBoundaryForSTS();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_PauseBoundaryForSTS();

		public static int UPvr_GetMainSensorStateExt(ref float x, ref float y, ref float z, ref float w, ref float px, ref float py, ref float pz, ref float vfov, ref float hfov, ref int viewNumber)
		{
			return Pvr_GetMainSensorStateExt(ref x, ref y, ref z, ref w, ref px, ref py, ref pz, ref vfov, ref hfov, ref viewNumber);
		}

		public static IntPtr UPvr_GetCameraData_Ext()
		{
			_ = IntPtr.Zero;
			return Pvr_GetCameraData_Ext();
		}

		public static bool UPvr_ResumeBoundaryForSTS()
		{
			return Pvr_ResumeBoundaryForSTS();
		}

		public static void UPvr_PauseBoundaryForSTS()
		{
			Pvr_PauseBoundaryForSTS();
		}

		public static IntPtr StructToIntPtr<T>(T info)
		{
			IntPtr intPtr = Marshal.AllocHGlobal(Marshal.SizeOf(info));
			Marshal.StructureToPtr(info, intPtr, fDeleteOld: true);
			return intPtr;
		}

		public static T IntPtrToStruct<T>(IntPtr info)
		{
			return (T)Marshal.PtrToStructure(info, typeof(T));
		}
	}
	internal static class Pvr_SafeAreaAlgoAPI
	{
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		public delegate void SafeAreaCallback(IntPtr lineCollectionPtr, IntPtr safeAreaRectPtr);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		public delegate void SafeAreaCallbackShrink(IntPtr lineCollectionPtr, IntPtr safeAreaDetailRectPtr);

		public struct GSAPoint3i
		{
			public int x;

			public int y;

			public int z;
		}

		public struct GSALine
		{
			public IntPtr pointArray;

			public int pointCount;
		}

		public struct GSALineCollection
		{
			public IntPtr lineArray;

			public int lineCount;
		}

		public struct GSALegalData
		{
			public int overMaxRange;

			public int includeBigGrap;

			public int bigGapNum;

			public int centerOut;

			public int removeNarrow;

			public int overMaxRange_more;

			public int validShrinkArea;
		}

		public struct GSARect
		{
			public GSAPoint3i leftup;

			public GSAPoint3i leftdown;

			public GSAPoint3i rightup;

			public GSAPoint3i rightdown;

			public GSAPoint3i center;

			public uint width;

			public uint height;

			public int isLegal;

			public GSALegalData legalData;
		}

		private const string LibFileName = "SafetyArea";

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern int GSAInit(int width, int height);

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern int GSAShutDown();

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern int GSASetCallback(SafeAreaCallback cb);

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern int GSASetCallbackShrink(SafeAreaCallbackShrink cb);

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern int GSAUpDateData(IntPtr lineCollectionPtr);

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern int GSASetConfigFilePath(IntPtr configPath);

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool GSAGetClosedAreaUpdateFlag();

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern int GSALoadSafetyArea(IntPtr lineCollectionPtr);

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern double GSABoundaryDetector(ref GSAPoint3i pointPtr);

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern int GSALoadSafetyArea2(IntPtr lineCollectionPtr, bool isPlayArea);

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern double GSABoundaryDetector2(ref GSAPoint3i point, bool isPlayArea, ref GSAPoint3i closestPoint, ref GSAPoint3i normalDir);

		public static int Pvr_GSAInit(int width, int height)
		{
			return GSAInit(width, height);
		}

		public static int Pvr_GSASetCallback(SafeAreaCallback cb)
		{
			return GSASetCallback(cb);
		}

		public static int Pvr_GSASetCallbackShrink(SafeAreaCallbackShrink cb)
		{
			return GSASetCallbackShrink(cb);
		}

		public static int Pvr_GSAUpDateData(IntPtr lineCollectionPtr)
		{
			return GSAUpDateData(lineCollectionPtr);
		}

		public static bool Pvr_GSAGetClosedAreaUpdateFlag()
		{
			return GSAGetClosedAreaUpdateFlag();
		}

		public static int Pvr_GSASetConfigFilePath(string configPath)
		{
			int num = -1;
			IntPtr intPtr = Marshal.StringToHGlobalAnsi(configPath);
			num = GSASetConfigFilePath(intPtr);
			Marshal.FreeHGlobal(intPtr);
			return num;
		}

		public static int Pvr_GSALoadSafetyArea(IntPtr lineCollectionPtr)
		{
			return GSALoadSafetyArea(lineCollectionPtr);
		}

		public static double Pvr_GSABoundaryDetector(ref GSAPoint3i point)
		{
			return GSABoundaryDetector(ref point);
		}

		public static int Pvr_GSAShutDown()
		{
			return GSAShutDown();
		}

		public static int Pvr_GSALoadSafetyArea2(IntPtr lineCollectionPtr, bool isPlayArea)
		{
			return GSALoadSafetyArea2(lineCollectionPtr, isPlayArea);
		}

		public static double Pvr_GSABoundaryDetector2(ref GSAPoint3i point, bool isPlayArea, ref GSAPoint3i closestPoint, ref GSAPoint3i normalDir)
		{
			return GSABoundaryDetector2(ref point, isPlayArea, ref closestPoint, ref normalDir);
		}
	}
	public class Pvr_BoundarySystem
	{
		private static Pvr_BoundarySystem instance;

		public const int CameraImageWidth = 1280;

		public const int CameraImageHeight = 400;

		public IntPtr CameraFramePtr = IntPtr.Zero;

		public static Pvr_BoundarySystem Instance
		{
			get
			{
				if (instance == null)
				{
					instance = new Pvr_BoundarySystem();
				}
				return instance;
			}
		}

		public void OpenBoundary()
		{
			Pvr_BoundaryAPI.Pvr_StartSDKBoundary();
		}

		public void CloseBoundary()
		{
			Pvr_BoundaryAPI.Pvr_ShutdownSDKBoundary();
		}

		public void Reset6Dof()
		{
			Pvr_BoundaryAPI.Pvr_ResetVrModebyForce();
		}

		public float[] GetControllerFixedPoseData(int hand)
		{
			float[] result = new float[7] { 0f, 0f, 0f, 1f, 0f, 0f, 0f };
			if (Pvr_ControllerManager.controllerlink != null)
			{
				Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, Pvr_ControllerManager.controllerlink.javaCVClass, "getControllerFixedSensorState", hand);
			}
			result[2] = 0f - result[2];
			result[3] = 0f - result[3];
			return result;
		}
	}
	public class Pvr_SafeAreaAlgoModule
	{
		public struct ExtraInfo
		{
			public bool overMaxRange;

			public bool includeBigGap;

			public int bigGapNum;

			public bool centerOut;

			public bool removeNarrow;

			public bool overMaxRange_more;

			public int validShrinkArea;
		}

		public struct BoundaryPlayerArea
		{
			public Vector3 lowerleft;

			public Vector3 upperleft;

			public Vector3 upperRight;

			public Vector3 lowerRight;

			public Vector3 center;

			public uint width;

			public uint height;

			public bool isLegal;

			public ExtraInfo extraInfo;
		}

		public delegate void BoundarySystemCallback(BoundaryPlayerArea playAreaInfo, List<Vector3> boundaryPoints, List<List<Vector3>> unusedLines);

		public delegate void BoundarySystemCallbackShrink(List<Vector3> rectPoints, List<Vector3> boundaryPoints, List<List<Vector3>> unusedLines);

		private static Pvr_SafeAreaAlgoModule instance;

		private BoundarySystemCallback boundarySystemCallback;

		private BoundarySystemCallbackShrink boundarySystemCallbackShrink;

		public static Pvr_SafeAreaAlgoModule Instance
		{
			get
			{
				if (instance == null)
				{
					instance = new Pvr_SafeAreaAlgoModule();
				}
				return instance;
			}
		}

		public void RegisterCallBack(BoundarySystemCallback callback)
		{
			boundarySystemCallback = callback;
		}

		public void RegisterCallBackShrink(BoundarySystemCallbackShrink callback)
		{
			boundarySystemCallbackShrink = callback;
		}

		public bool Start()
		{
			int num = Pvr_SafeAreaAlgoAPI.Pvr_GSASetCallback(_SafeAreaCallback);
			int num2 = Pvr_SafeAreaAlgoAPI.Pvr_GSASetCallbackShrink(_SafeAreaCallbackShrink);
			if (num != 0 || num2 != 0)
			{
				UnityEngine.Debug.LogError("BoundarySystem register callback failed!");
				return false;
			}
			if (Pvr_SafeAreaAlgoAPI.Pvr_GSAInit(300, 300) != 0)
			{
				UnityEngine.Debug.LogError("BoundarySystem init failed!");
				return false;
			}
			return true;
		}

		public bool CommitNewLineData(bool isFistLine, Vector3[] points)
		{
			Pvr_SafeAreaAlgoAPI.GSALineCollection info = default(Pvr_SafeAreaAlgoAPI.GSALineCollection);
			info.lineCount = 2;
			Pvr_SafeAreaAlgoAPI.GSALine[] array = new Pvr_SafeAreaAlgoAPI.GSALine[2];
			if (isFistLine)
			{
				array[0].pointArray = IntPtr.Zero;
				array[0].pointCount = 0;
			}
			else
			{
				Pvr_SafeAreaAlgoAPI.GSAPoint3i[] arr = new Pvr_SafeAreaAlgoAPI.GSAPoint3i[1]
				{
					new Pvr_SafeAreaAlgoAPI.GSAPoint3i
					{
						x = 0,
						y = 0,
						z = 0
					}
				};
				array[0].pointArray = Marshal.UnsafeAddrOfPinnedArrayElement(arr, 0);
				array[0].pointCount = 1;
			}
			Pvr_SafeAreaAlgoAPI.GSAPoint3i[] array2 = new Pvr_SafeAreaAlgoAPI.GSAPoint3i[points.Length];
			for (int i = 0; i < points.Length; i++)
			{
				Pvr_SafeAreaAlgoAPI.GSAPoint3i gSAPoint3i = default(Pvr_SafeAreaAlgoAPI.GSAPoint3i);
				gSAPoint3i.x = (int)(points[i].x * 1000f);
				gSAPoint3i.y = (int)(points[i].y * 1000f);
				gSAPoint3i.z = (int)(points[i].z * 1000f);
				array2[i] = gSAPoint3i;
			}
			array[1].pointArray = Marshal.UnsafeAddrOfPinnedArrayElement(array2, 0);
			array[1].pointCount = array2.Length;
			info.lineArray = Marshal.UnsafeAddrOfPinnedArrayElement(array, 0);
			IntPtr intPtr = Pvr_BoundaryAPI.StructToIntPtr(info);
			int num = Pvr_SafeAreaAlgoAPI.Pvr_GSAUpDateData(intPtr);
			Marshal.FreeHGlobal(intPtr);
			if (num != 0)
			{
				UnityEngine.Debug.LogError("BoundarySystem commit new line data failed!");
				return false;
			}
			return true;
		}

		public bool Shutdown()
		{
			if (Pvr_SafeAreaAlgoAPI.Pvr_GSAShutDown() != 0)
			{
				UnityEngine.Debug.LogError("BoundarySystem shutdown failed!");
				return false;
			}
			return true;
		}

		public double QueryDistanceOfPoint(Vector3 point)
		{
			Pvr_SafeAreaAlgoAPI.GSAPoint3i point2 = default(Pvr_SafeAreaAlgoAPI.GSAPoint3i);
			point2.x = (int)(point.x * 1000f);
			point2.y = (int)(point.y * 1000f);
			point2.z = (int)(point.z * 1000f);
			return Pvr_SafeAreaAlgoAPI.Pvr_GSABoundaryDetector(ref point2) / 1000.0;
		}

		public double QueryDistanceOfPoint(Vector3 point, bool isPlayArea, ref Vector3 closestPoint, ref Vector3 normalDir)
		{
			Pvr_SafeAreaAlgoAPI.GSAPoint3i point2 = default(Pvr_SafeAreaAlgoAPI.GSAPoint3i);
			point2.x = (int)(point.x * 1000f);
			point2.y = (int)(point.y * 1000f);
			point2.z = (int)(point.z * 1000f);
			Pvr_SafeAreaAlgoAPI.GSAPoint3i closestPoint2 = default(Pvr_SafeAreaAlgoAPI.GSAPoint3i);
			Pvr_SafeAreaAlgoAPI.GSAPoint3i normalDir2 = default(Pvr_SafeAreaAlgoAPI.GSAPoint3i);
			double num = Pvr_SafeAreaAlgoAPI.Pvr_GSABoundaryDetector2(ref point2, isPlayArea, ref closestPoint2, ref normalDir2);
			closestPoint.x = (float)closestPoint2.x / 1000f;
			closestPoint.y = (float)closestPoint2.y / 1000f;
			closestPoint.z = (float)closestPoint2.z / 1000f;
			normalDir.x = (float)normalDir2.x / 1000f;
			normalDir.y = (float)normalDir2.y / 1000f;
			normalDir.z = (float)normalDir2.z / 1000f;
			return num / 1000.0;
		}

		[MonoPInvokeCallback(typeof(Pvr_SafeAreaAlgoAPI.SafeAreaCallback))]
		private static void _SafeAreaCallback(IntPtr lineCollectionPtr, IntPtr safeAreaRectPtr)
		{
			if (lineCollectionPtr == IntPtr.Zero || safeAreaRectPtr == IntPtr.Zero)
			{
				UnityEngine.Debug.LogError("BoundarySystem callback is inValid!");
			}
			else
			{
				if (instance.boundarySystemCallback == null)
				{
					return;
				}
				List<Vector3> boundaryPoints = new List<Vector3>();
				List<List<Vector3>> list = new List<List<Vector3>>();
				int num = Marshal.SizeOf(typeof(Pvr_SafeAreaAlgoAPI.GSALine));
				int num2 = Marshal.SizeOf(typeof(Pvr_SafeAreaAlgoAPI.GSAPoint3i));
				Pvr_SafeAreaAlgoAPI.GSALineCollection gSALineCollection = Pvr_BoundaryAPI.IntPtrToStruct<Pvr_SafeAreaAlgoAPI.GSALineCollection>(lineCollectionPtr);
				for (int i = 0; i < gSALineCollection.lineCount; i++)
				{
					Pvr_SafeAreaAlgoAPI.GSALine gSALine = (Pvr_SafeAreaAlgoAPI.GSALine)Marshal.PtrToStructure(new IntPtr(gSALineCollection.lineArray.ToInt64() + num * i), typeof(Pvr_SafeAreaAlgoAPI.GSALine));
					List<Vector3> list2 = new List<Vector3>();
					for (int j = 0; j < gSALine.pointCount; j++)
					{
						Pvr_SafeAreaAlgoAPI.GSAPoint3i gSAPoint3i = (Pvr_SafeAreaAlgoAPI.GSAPoint3i)Marshal.PtrToStructure(new IntPtr(gSALine.pointArray.ToInt64() + num2 * j), typeof(Pvr_SafeAreaAlgoAPI.GSAPoint3i));
						list2.Add(new Vector3((float)gSAPoint3i.x / 1000f, (float)gSAPoint3i.y / 1000f, (float)gSAPoint3i.z / 1000f));
					}
					if (i == 0)
					{
						boundaryPoints = list2;
					}
					else
					{
						list.Add(list2);
					}
				}
				Pvr_SafeAreaAlgoAPI.GSARect gSARect = Pvr_BoundaryAPI.IntPtrToStruct<Pvr_SafeAreaAlgoAPI.GSARect>(safeAreaRectPtr);
				BoundaryPlayerArea playAreaInfo = default(BoundaryPlayerArea);
				playAreaInfo.lowerleft = new Vector3((float)gSARect.leftup.x / 1000f, (float)gSARect.leftup.y / 1000f, (float)gSARect.leftup.z / 1000f);
				playAreaInfo.upperleft = new Vector3((float)gSARect.leftdown.x / 1000f, (float)gSARect.leftdown.y / 1000f, (float)gSARect.leftdown.z / 1000f);
				playAreaInfo.upperRight = new Vector3((float)gSARect.rightdown.x / 1000f, (float)gSARect.rightdown.y / 1000f, (float)gSARect.rightdown.z / 1000f);
				playAreaInfo.lowerRight = new Vector3((float)gSARect.rightup.x / 1000f, (float)gSARect.rightup.y / 1000f, (float)gSARect.rightup.z / 1000f);
				playAreaInfo.center = new Vector3((float)gSARect.center.x / 1000f, (float)gSARect.center.y / 1000f, (float)gSARect.center.z / 1000f);
				playAreaInfo.width = gSARect.width;
				playAreaInfo.height = gSARect.height;
				playAreaInfo.isLegal = ((gSARect.isLegal != 0) ? true : false);
				playAreaInfo.extraInfo.overMaxRange = ((gSARect.legalData.overMaxRange != 0) ? true : false);
				playAreaInfo.extraInfo.includeBigGap = ((gSARect.legalData.includeBigGrap != 0) ? true : false);
				playAreaInfo.extraInfo.bigGapNum = gSARect.legalData.bigGapNum;
				playAreaInfo.extraInfo.centerOut = ((gSARect.legalData.centerOut != 0) ? true : false);
				playAreaInfo.extraInfo.removeNarrow = ((gSARect.legalData.removeNarrow != 0) ? true : false);
				playAreaInfo.extraInfo.overMaxRange_more = ((gSARect.legalData.overMaxRange_more != 0) ? true : false);
				playAreaInfo.extraInfo.validShrinkArea = gSARect.legalData.validShrinkArea;
				instance.boundarySystemCallback(playAreaInfo, boundaryPoints, list);
			}
		}

		[MonoPInvokeCallback(typeof(Pvr_SafeAreaAlgoAPI.SafeAreaCallbackShrink))]
		private static void _SafeAreaCallbackShrink(IntPtr lineCollectionPtr, IntPtr safeAreaDetailRectPtr)
		{
			if (lineCollectionPtr == IntPtr.Zero || safeAreaDetailRectPtr == IntPtr.Zero)
			{
				UnityEngine.Debug.LogError("BoundarySystem callback is inValid!");
			}
			else
			{
				if (instance.boundarySystemCallbackShrink == null)
				{
					return;
				}
				List<Vector3> boundaryPoints = new List<Vector3>();
				List<List<Vector3>> list = new List<List<Vector3>>();
				int num = Marshal.SizeOf(typeof(Pvr_SafeAreaAlgoAPI.GSALine));
				int num2 = Marshal.SizeOf(typeof(Pvr_SafeAreaAlgoAPI.GSAPoint3i));
				Pvr_SafeAreaAlgoAPI.GSALineCollection gSALineCollection = Pvr_BoundaryAPI.IntPtrToStruct<Pvr_SafeAreaAlgoAPI.GSALineCollection>(lineCollectionPtr);
				for (int i = 0; i < gSALineCollection.lineCount; i++)
				{
					Pvr_SafeAreaAlgoAPI.GSALine gSALine = (Pvr_SafeAreaAlgoAPI.GSALine)Marshal.PtrToStructure(new IntPtr(gSALineCollection.lineArray.ToInt64() + num * i), typeof(Pvr_SafeAreaAlgoAPI.GSALine));
					List<Vector3> list2 = new List<Vector3>();
					for (int j = 0; j < gSALine.pointCount; j++)
					{
						Pvr_SafeAreaAlgoAPI.GSAPoint3i gSAPoint3i = (Pvr_SafeAreaAlgoAPI.GSAPoint3i)Marshal.PtrToStructure(new IntPtr(gSALine.pointArray.ToInt64() + num2 * j), typeof(Pvr_SafeAreaAlgoAPI.GSAPoint3i));
						list2.Add(new Vector3((float)gSAPoint3i.x / 1000f, (float)gSAPoint3i.y / 1000f, (float)gSAPoint3i.z / 1000f));
					}
					if (i == 0)
					{
						boundaryPoints = list2;
					}
					else
					{
						list.Add(list2);
					}
				}
				List<Vector3> list3 = new List<Vector3>();
				Pvr_SafeAreaAlgoAPI.GSALineCollection gSALineCollection2 = Pvr_BoundaryAPI.IntPtrToStruct<Pvr_SafeAreaAlgoAPI.GSALineCollection>(safeAreaDetailRectPtr);
				for (int k = 0; k < gSALineCollection2.lineCount; k++)
				{
					Pvr_SafeAreaAlgoAPI.GSALine gSALine2 = (Pvr_SafeAreaAlgoAPI.GSALine)Marshal.PtrToStructure(new IntPtr(gSALineCollection2.lineArray.ToInt64() + num * k), typeof(Pvr_SafeAreaAlgoAPI.GSALine));
					for (int l = 0; l < gSALine2.pointCount; l++)
					{
						Pvr_SafeAreaAlgoAPI.GSAPoint3i gSAPoint3i2 = (Pvr_SafeAreaAlgoAPI.GSAPoint3i)Marshal.PtrToStructure(new IntPtr(gSALine2.pointArray.ToInt64() + num2 * l), typeof(Pvr_SafeAreaAlgoAPI.GSAPoint3i));
						list3.Add(new Vector3((float)gSAPoint3i2.x / 1000f, (float)gSAPoint3i2.y / 1000f, (float)gSAPoint3i2.z / 1000f));
					}
				}
				instance.boundarySystemCallbackShrink(list3, boundaryPoints, list);
			}
		}
	}
}
namespace Pvr_UnitySDKAPI
{
	public class PvrControllerKey
	{
		public bool State;

		public bool PressedDown;

		public bool PressedUp;

		public bool LongPressed;

		public bool Click;

		public bool Touch;

		public bool TouchDown;

		public bool TouchUp;

		public PvrControllerKey()
		{
			State = false;
			PressedDown = false;
			PressedUp = false;
			LongPressed = false;
			Click = false;
			Touch = false;
			TouchDown = false;
			TouchUp = false;
		}
	}
	public class ControllerHand
	{
		public PvrControllerKey App;

		public PvrControllerKey Touch;

		public PvrControllerKey Home;

		public PvrControllerKey VolumeDown;

		public PvrControllerKey VolumeUp;

		public PvrControllerKey Trigger;

		public PvrControllerKey X;

		public PvrControllerKey Y;

		public PvrControllerKey A;

		public PvrControllerKey B;

		public PvrControllerKey Left;

		public PvrControllerKey Right;

		public PvrControllerKey Thumbrest;

		public Vector2 TouchPadPosition;

		public int TriggerNum;

		public int GripValue;

		public Quaternion Rotation;

		public Vector3 Position;

		public int Battery;

		public ControllerState ConnectState;

		public SwipeDirection SwipeDirection;

		public TouchPadClick TouchPadClick;

		public bool isShowBoundary;

		public ControllerHand()
		{
			App = new PvrControllerKey();
			Touch = new PvrControllerKey();
			Home = new PvrControllerKey();
			VolumeDown = new PvrControllerKey();
			VolumeUp = new PvrControllerKey();
			Trigger = new PvrControllerKey();
			A = new PvrControllerKey();
			B = new PvrControllerKey();
			X = new PvrControllerKey();
			Y = new PvrControllerKey();
			Left = new PvrControllerKey();
			Right = new PvrControllerKey();
			Thumbrest = new PvrControllerKey();
			TouchPadPosition = default(Vector2);
			Rotation = default(Quaternion);
			Position = default(Vector3);
			Battery = 0;
			TriggerNum = 0;
			GripValue = 0;
			ConnectState = ControllerState.Error;
			SwipeDirection = SwipeDirection.No;
			TouchPadClick = TouchPadClick.No;
			isShowBoundary = false;
		}
	}
	public enum ControllerState
	{
		Error = -1,
		DisConnected,
		Connected
	}
	public enum Pvr_KeyCode
	{
		APP = 1,
		TOUCHPAD,
		HOME,
		VOLUMEUP,
		VOLUMEDOWN,
		TRIGGER,
		A,
		B,
		X,
		Y,
		Left,
		Right,
		Thumbrest
	}
	public enum SwipeDirection
	{
		No,
		SwipeUp,
		SwipeDown,
		SwipeLeft,
		SwipeRight
	}
	public enum TouchPadClick
	{
		No,
		ClickUp,
		ClickDown,
		ClickLeft,
		ClickRight
	}
	[StructLayout(LayoutKind.Sequential, Size = 1)]
	public struct Controller
	{
		public const string LibFileName = "Pvr_UnitySDK";

		public static Vector2 UPvr_GetTouchPadPosition(int hand)
		{
			return hand switch
			{
				0 => Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition, 
				1 => Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition, 
				_ => new Vector2(0f, 0f), 
			};
		}

		public static float UPvr_GetAxis1D(int hand, Pvr_KeyCode key)
		{
			return hand switch
			{
				0 => key switch
				{
					Pvr_KeyCode.TRIGGER => (float)Pvr_ControllerManager.controllerlink.Controller0.TriggerNum / 255f, 
					Pvr_KeyCode.Left => (float)Pvr_ControllerManager.controllerlink.Controller0.GripValue / 255f, 
					_ => 0f, 
				}, 
				1 => key switch
				{
					Pvr_KeyCode.TRIGGER => (float)Pvr_ControllerManager.controllerlink.Controller1.TriggerNum / 255f, 
					Pvr_KeyCode.Right => (float)Pvr_ControllerManager.controllerlink.Controller1.GripValue / 255f, 
					_ => 0f, 
				}, 
				_ => 0f, 
			};
		}

		public static Vector2 UPvr_GetAxis2D(int hand)
		{
			switch (hand)
			{
			case 0:
				if (Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition != Vector2.zero)
				{
					return new Vector2(Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition.x / 128f - 1f, Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition.y / 128f - 1f);
				}
				return Vector2.zero;
			case 1:
				if (Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition != Vector2.zero)
				{
					return new Vector2(Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition.x / 128f - 1f, Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition.y / 128f - 1f);
				}
				return Vector2.zero;
			default:
				return Vector2.zero;
			}
		}

		public static ControllerState UPvr_GetControllerState(int hand)
		{
			return hand switch
			{
				0 => (ControllerState)Convert.ToInt16(Pvr_ControllerManager.controllerlink.controller0Connected), 
				1 => (ControllerState)Convert.ToInt16(Pvr_ControllerManager.controllerlink.controller1Connected), 
				_ => ControllerState.Error, 
			};
		}

		public static Quaternion UPvr_GetControllerQUA(int hand)
		{
			return hand switch
			{
				0 => Pvr_ControllerManager.controllerlink.Controller0.Rotation, 
				1 => Pvr_ControllerManager.controllerlink.Controller1.Rotation, 
				_ => new Quaternion(0f, 0f, 0f, 1f), 
			};
		}

		public static Vector3 UPvr_GetControllerPOS(int hand)
		{
			return hand switch
			{
				0 => Pvr_ControllerManager.controllerlink.Controller0.Position, 
				1 => Pvr_ControllerManager.controllerlink.Controller1.Position, 
				_ => new Vector3(0f, 0f, 0f), 
			};
		}

		public static int UPvr_GetControllerTriggerValue(int hand)
		{
			return hand switch
			{
				0 => Pvr_ControllerManager.controllerlink.Controller0.TriggerNum, 
				1 => Pvr_ControllerManager.controllerlink.Controller1.TriggerNum, 
				_ => 0, 
			};
		}

		public static int UPvr_GetControllerPower(int hand)
		{
			return hand switch
			{
				0 => Pvr_ControllerManager.controllerlink.Controller0.Battery, 
				1 => Pvr_ControllerManager.controllerlink.Controller1.Battery, 
				_ => 0, 
			};
		}

		public static SwipeDirection UPvr_GetSwipeDirection(int hand)
		{
			return hand switch
			{
				0 => Pvr_ControllerManager.controllerlink.Controller0.SwipeDirection, 
				1 => Pvr_ControllerManager.controllerlink.Controller1.SwipeDirection, 
				_ => SwipeDirection.No, 
			};
		}

		public static TouchPadClick UPvr_GetTouchPadClick(int hand)
		{
			return hand switch
			{
				0 => Pvr_ControllerManager.controllerlink.Controller0.TouchPadClick, 
				1 => Pvr_ControllerManager.controllerlink.Controller1.TouchPadClick, 
				_ => TouchPadClick.No, 
			};
		}

		public static bool UPvr_GetKey(int hand, Pvr_KeyCode key)
		{
			return hand switch
			{
				0 => key switch
				{
					Pvr_KeyCode.APP => Pvr_ControllerManager.controllerlink.Controller0.App.State, 
					Pvr_KeyCode.HOME => Pvr_ControllerManager.controllerlink.Controller0.Home.State, 
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller0.Touch.State, 
					Pvr_KeyCode.VOLUMEUP => Pvr_ControllerManager.controllerlink.Controller0.VolumeUp.State, 
					Pvr_KeyCode.VOLUMEDOWN => Pvr_ControllerManager.controllerlink.Controller0.VolumeDown.State, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller0.Trigger.State, 
					Pvr_KeyCode.X => Pvr_ControllerManager.controllerlink.Controller0.X.State, 
					Pvr_KeyCode.Y => Pvr_ControllerManager.controllerlink.Controller0.Y.State, 
					Pvr_KeyCode.Left => Pvr_ControllerManager.controllerlink.Controller0.Left.State, 
					_ => false, 
				}, 
				1 => key switch
				{
					Pvr_KeyCode.APP => Pvr_ControllerManager.controllerlink.Controller1.App.State, 
					Pvr_KeyCode.HOME => Pvr_ControllerManager.controllerlink.Controller1.Home.State, 
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller1.Touch.State, 
					Pvr_KeyCode.VOLUMEUP => Pvr_ControllerManager.controllerlink.Controller1.VolumeUp.State, 
					Pvr_KeyCode.VOLUMEDOWN => Pvr_ControllerManager.controllerlink.Controller1.VolumeDown.State, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller1.Trigger.State, 
					Pvr_KeyCode.A => Pvr_ControllerManager.controllerlink.Controller1.A.State, 
					Pvr_KeyCode.B => Pvr_ControllerManager.controllerlink.Controller1.B.State, 
					Pvr_KeyCode.Right => Pvr_ControllerManager.controllerlink.Controller1.Right.State, 
					_ => false, 
				}, 
				_ => false, 
			};
		}

		public static bool UPvr_GetKeyDown(int hand, Pvr_KeyCode key)
		{
			return hand switch
			{
				0 => key switch
				{
					Pvr_KeyCode.APP => Pvr_ControllerManager.controllerlink.Controller0.App.PressedDown, 
					Pvr_KeyCode.HOME => Pvr_ControllerManager.controllerlink.Controller0.Home.PressedDown, 
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller0.Touch.PressedDown, 
					Pvr_KeyCode.VOLUMEUP => Pvr_ControllerManager.controllerlink.Controller0.VolumeUp.PressedDown, 
					Pvr_KeyCode.VOLUMEDOWN => Pvr_ControllerManager.controllerlink.Controller0.VolumeDown.PressedDown, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller0.Trigger.PressedDown, 
					Pvr_KeyCode.X => Pvr_ControllerManager.controllerlink.Controller0.X.PressedDown, 
					Pvr_KeyCode.Y => Pvr_ControllerManager.controllerlink.Controller0.Y.PressedDown, 
					Pvr_KeyCode.Left => Pvr_ControllerManager.controllerlink.Controller0.Left.PressedDown, 
					_ => false, 
				}, 
				1 => key switch
				{
					Pvr_KeyCode.APP => Pvr_ControllerManager.controllerlink.Controller1.App.PressedDown, 
					Pvr_KeyCode.HOME => Pvr_ControllerManager.controllerlink.Controller1.Home.PressedDown, 
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller1.Touch.PressedDown, 
					Pvr_KeyCode.VOLUMEUP => Pvr_ControllerManager.controllerlink.Controller1.VolumeUp.PressedDown, 
					Pvr_KeyCode.VOLUMEDOWN => Pvr_ControllerManager.controllerlink.Controller1.VolumeDown.PressedDown, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller1.Trigger.PressedDown, 
					Pvr_KeyCode.A => Pvr_ControllerManager.controllerlink.Controller1.A.PressedDown, 
					Pvr_KeyCode.B => Pvr_ControllerManager.controllerlink.Controller1.B.PressedDown, 
					Pvr_KeyCode.Right => Pvr_ControllerManager.controllerlink.Controller1.Right.PressedDown, 
					_ => false, 
				}, 
				_ => false, 
			};
		}

		public static bool UPvr_GetKeyUp(int hand, Pvr_KeyCode key)
		{
			return hand switch
			{
				0 => key switch
				{
					Pvr_KeyCode.APP => Pvr_ControllerManager.controllerlink.Controller0.App.PressedUp, 
					Pvr_KeyCode.HOME => Pvr_ControllerManager.controllerlink.Controller0.Home.PressedUp, 
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller0.Touch.PressedUp, 
					Pvr_KeyCode.VOLUMEUP => Pvr_ControllerManager.controllerlink.Controller0.VolumeUp.PressedUp, 
					Pvr_KeyCode.VOLUMEDOWN => Pvr_ControllerManager.controllerlink.Controller0.VolumeDown.PressedUp, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller0.Trigger.PressedUp, 
					Pvr_KeyCode.X => Pvr_ControllerManager.controllerlink.Controller0.X.PressedUp, 
					Pvr_KeyCode.Y => Pvr_ControllerManager.controllerlink.Controller0.Y.PressedUp, 
					Pvr_KeyCode.Left => Pvr_ControllerManager.controllerlink.Controller0.Left.PressedUp, 
					_ => false, 
				}, 
				1 => key switch
				{
					Pvr_KeyCode.APP => Pvr_ControllerManager.controllerlink.Controller1.App.PressedUp, 
					Pvr_KeyCode.HOME => Pvr_ControllerManager.controllerlink.Controller1.Home.PressedUp, 
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller1.Touch.PressedUp, 
					Pvr_KeyCode.VOLUMEUP => Pvr_ControllerManager.controllerlink.Controller1.VolumeUp.PressedUp, 
					Pvr_KeyCode.VOLUMEDOWN => Pvr_ControllerManager.controllerlink.Controller1.VolumeDown.PressedUp, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller1.Trigger.PressedUp, 
					Pvr_KeyCode.A => Pvr_ControllerManager.controllerlink.Controller1.A.PressedUp, 
					Pvr_KeyCode.B => Pvr_ControllerManager.controllerlink.Controller1.B.PressedUp, 
					Pvr_KeyCode.Right => Pvr_ControllerManager.controllerlink.Controller1.Right.PressedUp, 
					_ => false, 
				}, 
				_ => false, 
			};
		}

		public static bool UPvr_GetTouch(int hand, Pvr_KeyCode key)
		{
			return hand switch
			{
				0 => key switch
				{
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller0.Touch.Touch, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller0.Trigger.Touch, 
					Pvr_KeyCode.X => Pvr_ControllerManager.controllerlink.Controller0.X.Touch, 
					Pvr_KeyCode.Y => Pvr_ControllerManager.controllerlink.Controller0.Y.Touch, 
					Pvr_KeyCode.Thumbrest => Pvr_ControllerManager.controllerlink.Controller0.Thumbrest.Touch, 
					_ => false, 
				}, 
				1 => key switch
				{
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller1.Touch.Touch, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller1.Trigger.Touch, 
					Pvr_KeyCode.A => Pvr_ControllerManager.controllerlink.Controller1.A.Touch, 
					Pvr_KeyCode.B => Pvr_ControllerManager.controllerlink.Controller1.B.Touch, 
					Pvr_KeyCode.Thumbrest => Pvr_ControllerManager.controllerlink.Controller1.Thumbrest.Touch, 
					_ => false, 
				}, 
				_ => false, 
			};
		}

		public static bool UPvr_GetTouchDown(int hand, Pvr_KeyCode key)
		{
			return hand switch
			{
				0 => key switch
				{
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller0.Touch.TouchDown, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller0.Trigger.TouchDown, 
					Pvr_KeyCode.X => Pvr_ControllerManager.controllerlink.Controller0.X.TouchDown, 
					Pvr_KeyCode.Y => Pvr_ControllerManager.controllerlink.Controller0.Y.TouchDown, 
					Pvr_KeyCode.Thumbrest => Pvr_ControllerManager.controllerlink.Controller0.Thumbrest.TouchDown, 
					_ => false, 
				}, 
				1 => key switch
				{
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller1.Touch.TouchDown, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller1.Trigger.TouchDown, 
					Pvr_KeyCode.A => Pvr_ControllerManager.controllerlink.Controller1.A.TouchDown, 
					Pvr_KeyCode.B => Pvr_ControllerManager.controllerlink.Controller1.B.TouchDown, 
					Pvr_KeyCode.Thumbrest => Pvr_ControllerManager.controllerlink.Controller1.Thumbrest.TouchDown, 
					_ => false, 
				}, 
				_ => false, 
			};
		}

		public static bool UPvr_GetTouchUp(int hand, Pvr_KeyCode key)
		{
			return hand switch
			{
				0 => key switch
				{
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller0.Touch.TouchUp, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller0.Trigger.TouchUp, 
					Pvr_KeyCode.X => Pvr_ControllerManager.controllerlink.Controller0.X.TouchUp, 
					Pvr_KeyCode.Y => Pvr_ControllerManager.controllerlink.Controller0.Y.TouchUp, 
					Pvr_KeyCode.Thumbrest => Pvr_ControllerManager.controllerlink.Controller0.Thumbrest.TouchUp, 
					_ => false, 
				}, 
				1 => key switch
				{
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller1.Touch.TouchUp, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller1.Trigger.TouchUp, 
					Pvr_KeyCode.A => Pvr_ControllerManager.controllerlink.Controller1.A.TouchUp, 
					Pvr_KeyCode.B => Pvr_ControllerManager.controllerlink.Controller1.B.TouchUp, 
					Pvr_KeyCode.Thumbrest => Pvr_ControllerManager.controllerlink.Controller1.Thumbrest.TouchUp, 
					_ => false, 
				}, 
				_ => false, 
			};
		}

		public static bool UPvr_GetKeyClick(int hand, Pvr_KeyCode key)
		{
			return hand switch
			{
				0 => key switch
				{
					Pvr_KeyCode.APP => Pvr_ControllerManager.controllerlink.Controller0.App.Click, 
					Pvr_KeyCode.HOME => Pvr_ControllerManager.controllerlink.Controller0.Home.Click, 
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller0.Touch.Click, 
					Pvr_KeyCode.VOLUMEUP => Pvr_ControllerManager.controllerlink.Controller0.VolumeUp.Click, 
					Pvr_KeyCode.VOLUMEDOWN => Pvr_ControllerManager.controllerlink.Controller0.VolumeDown.Click, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller0.Trigger.Click, 
					Pvr_KeyCode.X => Pvr_ControllerManager.controllerlink.Controller0.X.Click, 
					Pvr_KeyCode.Y => Pvr_ControllerManager.controllerlink.Controller0.Y.Click, 
					Pvr_KeyCode.Left => Pvr_ControllerManager.controllerlink.Controller0.Left.Click, 
					_ => false, 
				}, 
				1 => key switch
				{
					Pvr_KeyCode.APP => Pvr_ControllerManager.controllerlink.Controller1.App.Click, 
					Pvr_KeyCode.HOME => Pvr_ControllerManager.controllerlink.Controller1.Home.Click, 
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller1.Touch.Click, 
					Pvr_KeyCode.VOLUMEUP => Pvr_ControllerManager.controllerlink.Controller1.VolumeUp.Click, 
					Pvr_KeyCode.VOLUMEDOWN => Pvr_ControllerManager.controllerlink.Controller1.VolumeDown.Click, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller1.Trigger.Click, 
					Pvr_KeyCode.A => Pvr_ControllerManager.controllerlink.Controller1.A.Click, 
					Pvr_KeyCode.B => Pvr_ControllerManager.controllerlink.Controller1.B.Click, 
					Pvr_KeyCode.Right => Pvr_ControllerManager.controllerlink.Controller1.Right.Click, 
					_ => false, 
				}, 
				_ => false, 
			};
		}

		public static bool UPvr_GetKeyLongPressed(int hand, Pvr_KeyCode key)
		{
			return hand switch
			{
				0 => key switch
				{
					Pvr_KeyCode.APP => Pvr_ControllerManager.controllerlink.Controller0.App.LongPressed, 
					Pvr_KeyCode.HOME => Pvr_ControllerManager.controllerlink.Controller0.Home.LongPressed, 
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller0.Touch.LongPressed, 
					Pvr_KeyCode.VOLUMEUP => Pvr_ControllerManager.controllerlink.Controller0.VolumeUp.LongPressed, 
					Pvr_KeyCode.VOLUMEDOWN => Pvr_ControllerManager.controllerlink.Controller0.VolumeDown.LongPressed, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller0.Trigger.LongPressed, 
					Pvr_KeyCode.X => Pvr_ControllerManager.controllerlink.Controller0.X.LongPressed, 
					Pvr_KeyCode.Y => Pvr_ControllerManager.controllerlink.Controller0.Y.LongPressed, 
					Pvr_KeyCode.Left => Pvr_ControllerManager.controllerlink.Controller0.Left.LongPressed, 
					_ => false, 
				}, 
				1 => key switch
				{
					Pvr_KeyCode.APP => Pvr_ControllerManager.controllerlink.Controller1.App.LongPressed, 
					Pvr_KeyCode.HOME => Pvr_ControllerManager.controllerlink.Controller1.Home.LongPressed, 
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller1.Touch.LongPressed, 
					Pvr_KeyCode.VOLUMEUP => Pvr_ControllerManager.controllerlink.Controller1.VolumeUp.LongPressed, 
					Pvr_KeyCode.VOLUMEDOWN => Pvr_ControllerManager.controllerlink.Controller1.VolumeDown.LongPressed, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller1.Trigger.LongPressed, 
					Pvr_KeyCode.A => Pvr_ControllerManager.controllerlink.Controller1.A.LongPressed, 
					Pvr_KeyCode.B => Pvr_ControllerManager.controllerlink.Controller1.B.LongPressed, 
					Pvr_KeyCode.Right => Pvr_ControllerManager.controllerlink.Controller1.Right.LongPressed, 
					_ => false, 
				}, 
				_ => false, 
			};
		}

		public static bool UPvr_IsTouching(int hand)
		{
			switch (hand)
			{
			case 0:
				if (!(Math.Abs(Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition.x) > 0f))
				{
					return Math.Abs(Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition.y) > 0f;
				}
				return true;
			case 1:
				if (!(Math.Abs(Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition.x) > 0f))
				{
					return Math.Abs(Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition.y) > 0f;
				}
				return true;
			default:
				return false;
			}
		}

		public static void UPvr_SetHandNess(Pvr_Controller.UserHandNess hand)
		{
			if (Pvr_ControllerManager.controllerlink.getHandness() != (int)hand)
			{
				Pvr_ControllerManager.controllerlink.setHandness((int)hand);
			}
		}

		public static Pvr_Controller.UserHandNess UPvr_GetHandNess()
		{
			return Pvr_ControllerManager.controllerlink.handness;
		}

		public static int UPvr_GetPreferenceDevice()
		{
			int trackingmode = Pvr_ControllerManager.controllerlink.trackingmode;
			int systemProp = Pvr_ControllerManager.controllerlink.systemProp;
			if (trackingmode == 0 || trackingmode == 1 || ((trackingmode == 3 || trackingmode == 5 || trackingmode == 6) && (systemProp == 1 || systemProp == 3)))
			{
				return 1;
			}
			return 2;
		}

		public static bool UPvr_IsEnbleTrigger()
		{
			return Pvr_ControllerManager.controllerlink.IsEnbleTrigger();
		}

		public static int UPvr_GetDeviceType()
		{
			return Pvr_ControllerManager.controllerlink.controllerType;
		}

		public static int UPvr_GetMainHandNess()
		{
			return Pvr_ControllerManager.controllerlink.mainHandID;
		}

		public static void UPvr_SetMainHandNess(int hand)
		{
			Pvr_ControllerManager.controllerlink.SetMainController(hand);
		}

		public static int UPvr_GetControllerAbility(int hand)
		{
			return Pvr_ControllerManager.controllerlink.GetControllerAbility(hand);
		}

		public static void UPvr_VibrateNeo2Controller(float strength, int time, int hand)
		{
			Pvr_ControllerManager.controllerlink.VibrateNeo2Controller(strength, time, hand);
		}

		public static int UPvr_GetControllerBindingState(int hand)
		{
			return Pvr_ControllerManager.controllerlink.GetControllerBindingState(hand);
		}

		public static Vector3 UPvr_GetVelocity(int hand)
		{
			return Pvr_ControllerManager.controllerlink.GetVelocity(hand);
		}

		public static Vector3 UPvr_GetAngularVelocity(int hand)
		{
			return Pvr_ControllerManager.controllerlink.GetAngularVelocity(hand);
		}

		public static Vector3 UPvr_GetAcceleration(int hand)
		{
			return Pvr_ControllerManager.controllerlink.GetAcceleration(hand);
		}

		public static void UPvr_ScanController()
		{
			Pvr_ControllerManager.controllerlink.StartScan();
		}

		public static void UPvr_StopScanController()
		{
			Pvr_ControllerManager.controllerlink.StopScan();
		}

		public static void UPvr_ConnectController(string mac)
		{
			if (mac != "")
			{
				Pvr_ControllerManager.controllerlink.hummingBirdMac = mac;
			}
			Pvr_ControllerManager.controllerlink.ConnectBLE();
		}

		public static void UPvr_DisConnectController()
		{
			Pvr_ControllerManager.controllerlink.DisConnectBLE();
		}

		public static void UPvr_ResetController(int hand)
		{
			Pvr_ControllerManager.controllerlink.ResetController(hand);
		}

		public static string UPvr_GetControllerVersion()
		{
			return Pvr_ControllerManager.controllerlink.GetControllerVersion();
		}

		public static void UPvr_GetDeviceVersion(int deviceType)
		{
			Pvr_ControllerManager.controllerlink.GetDeviceVersion(deviceType);
		}

		public static void UPvr_GetControllerSnCode(int controllerSerialNum)
		{
			Pvr_ControllerManager.controllerlink.GetControllerSnCode(controllerSerialNum);
		}

		public static void UPvr_SetControllerUnbind(int controllerSerialNum)
		{
			Pvr_ControllerManager.controllerlink.SetControllerUnbind(controllerSerialNum);
		}

		public static void UPvr_SetStationRestart()
		{
			Pvr_ControllerManager.controllerlink.SetStationRestart();
		}

		public static void UPvr_StartStationOtaUpdate()
		{
			Pvr_ControllerManager.controllerlink.StartStationOtaUpdate();
		}

		public static void UPvr_StartControllerOtaUpdate(int mode, int controllerSerialNum)
		{
			Pvr_ControllerManager.controllerlink.StartControllerOtaUpdate(mode, controllerSerialNum);
		}

		public static void UPvr_EnterPairMode(int controllerSerialNum)
		{
			Pvr_ControllerManager.controllerlink.EnterPairMode(controllerSerialNum);
		}

		public static void UPvr_SetControllerShutdown(int controllerSerialNum)
		{
			Pvr_ControllerManager.controllerlink.SetControllerShutdown(controllerSerialNum);
		}

		public static int UPvr_GetStationPairState()
		{
			return Pvr_ControllerManager.controllerlink.GetStationPairState();
		}

		public static int UPvr_GetStationOtaUpdateProgress()
		{
			return Pvr_ControllerManager.controllerlink.GetStationOtaUpdateProgress();
		}

		public static int UPvr_GetControllerOtaUpdateProgress()
		{
			return Pvr_ControllerManager.controllerlink.GetControllerOtaUpdateProgress();
		}

		public static void UPvr_GetControllerVersionAndSN(int controllerSerialNum)
		{
			Pvr_ControllerManager.controllerlink.GetControllerVersionAndSN(controllerSerialNum);
		}

		public static void UPvr_GetControllerUniqueID()
		{
			Pvr_ControllerManager.controllerlink.GetControllerUniqueID();
		}

		public void UPvr_InterruptStationPairMode()
		{
			Pvr_ControllerManager.controllerlink.InterruptStationPairMode();
		}

		public void UPvr_StartCV2PairingMode(int deviceType)
		{
			Pvr_ControllerManager.controllerlink.StartCV2PairingMode(deviceType);
		}

		public void UPvr_StopCV2PairingMode(int deviceType)
		{
			Pvr_ControllerManager.controllerlink.StopCV2PairingMode(deviceType);
		}

		public static void UPvr_SetArmModelParameters(int hand, int gazeType, float elbowHeight, float elbowDepth, float pointerTiltAngle)
		{
			Pvr_SetArmModelParameters(hand, gazeType, elbowHeight, elbowDepth, pointerTiltAngle);
		}

		public static void UPvr_CalcArmModelParameters(float[] headOrientation, float[] controllerOrientation, float[] controllerPrimary)
		{
			Pvr_CalcArmModelParameters(headOrientation, controllerOrientation, controllerPrimary);
		}

		public static void UPvr_GetPointerPose(float[] rotation, float[] position)
		{
			Pvr_GetPointerPose(rotation, position);
		}

		public static void UPvr_GetElbowPose(float[] rotation, float[] position)
		{
			Pvr_GetElbowPose(rotation, position);
		}

		public static void UPvr_GetWristPose(float[] rotation, float[] position)
		{
			Pvr_GetWristPose(rotation, position);
		}

		public static void UPvr_GetShoulderPose(float[] rotation, float[] position)
		{
			Pvr_GetShoulderPose(rotation, position);
		}

		public static void UPvr_IsEnbleHomeKey(bool state)
		{
			Pvr_ControllerManager.controllerlink.setIsEnbleHomeKey(state);
		}

		public static void UPvr_SwitchHomeKey(bool state)
		{
			Pvr_ControllerManager.controllerlink.SwitchHomeKey(state);
		}

		public static int UPvr_GetControllerSensorStatus(int id)
		{
			return Pvr_ControllerManager.controllerlink.getControllerSensorStatus(id);
		}

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_CalcArmModelParameters(float[] headOrientation, float[] controllerOrientation, float[] gyro);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_GetPointerPose(float[] rotation, float[] position);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_GetElbowPose(float[] rotation, float[] position);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_GetWristPose(float[] rotation, float[] position);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_GetShoulderPose(float[] rotation, float[] position);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetArmModelParameters(int hand, int gazeType, float elbowHeight, float elbowDepth, float pointerTiltAngle);
	}
	public enum ControllerVariety
	{
		Controller0,
		Controller1
	}
	public enum ControllerDevice
	{
		Goblin,
		Neo,
		G2,
		Neo2,
		Neo3,
		NewController
	}
	public enum PBS_SystemInfoEnum
	{
		ELECTRIC_QUANTITY,
		PUI_VERSION,
		EQUIPMENT_MODEL,
		EQUIPMENT_SN,
		CUSTOMER_SN,
		INTERNAL_STORAGE_SPACE_OF_THE_DEVICE,
		DEVICE_BLUETOOTH_STATUS,
		BLUETOOTH_NAME_CONNECTED,
		BLUETOOTH_MAC_ADDRESS,
		DEVICE_WIFI_STATUS,
		WIFI_NAME_CONNECTED,
		WLAN_MAC_ADDRESS,
		DEVICE_IP
	}
	public enum PBS_DeviceControlEnum
	{
		DEVICE_CONTROL_REBOOT,
		DEVICE_CONTROL_SHUTDOWN
	}
	public enum PBS_PackageControlEnum
	{
		PACKAGE_SILENCE_INSTALL,
		PACKAGE_SILENCE_UNINSTALL
	}
	public enum PBS_SwitchEnum
	{
		S_ON,
		S_OFF
	}
	public enum PBS_HomeEventEnum
	{
		SINGLE_CLICK,
		DOUBLE_CLICK,
		LONG_PRESS
	}
	public enum PBS_HomeFunctionEnum
	{
		VALUE_HOME_GO_TO_SETTING,
		VALUE_HOME_BACK,
		VALUE_HOME_RECENTER,
		VALUE_HOME_OPEN_APP,
		VALUE_HOME_DISABLE,
		VALUE_HOME_GO_TO_HOME,
		VALUE_HOME_SEND_BROADCAST,
		VALUE_HOME_CLEAN_MEMORY
	}
	public enum PBS_ScreenOffDelayTimeEnum
	{
		THREE = 3,
		TEN = 10,
		THIRTY = 30,
		SIXTY = 60,
		THREE_HUNDRED = 300,
		SIX_HUNDRED = 600,
		NEVER = -1
	}
	public enum PBS_SleepDelayTimeEnum
	{
		FIFTEEN = 15,
		THIRTY = 30,
		SIXTY = 60,
		THREE_HUNDRED = 300,
		SIX_HUNDRED = 600,
		ONE_THOUSAND_AND_EIGHT_HUNDRED = 1800,
		NEVER = -1
	}
	public enum PBS_SystemFunctionSwitchEnum
	{
		SFS_USB,
		SFS_AUTOSLEEP,
		SFS_SCREENON_CHARGING,
		SFS_OTG_CHARGING,
		SFS_RETURN_MENU_IN_2DMODE,
		SFS_COMBINATION_KEY,
		SFS_CALIBRATION_WITH_POWER_ON,
		SFS_SYSTEM_UPDATE,
		SFS_CAST_SERVICE,
		SFS_EYE_PROTECTION,
		SFS_SECURITY_ZONE_PERMANENTLY,
		SFS_GLOBAL_CALIBRATION,
		SFS_Auto_Calibration,
		SFS_USB_BOOT
	}
	public enum PBS_USBConfigModeEnum
	{
		MTP,
		CHARGE
	}
	public struct ToBService
	{
		public static Action<bool> BoolCallback;

		public static Action<int> IntCallback;

		public static Action<long> LongCallback;

		private static AndroidJavaClass unityPlayer;

		private static AndroidJavaObject currentActivity;

		private static AndroidJavaObject tobHelper;

		private static AndroidJavaClass tobHelperClass;

		public static void UPvr_InitToBService()
		{
			tobHelperClass = new AndroidJavaClass("com.pvr.tobservice.ToBServiceHelper");
			tobHelper = tobHelperClass.CallStatic<AndroidJavaObject>("getInstance", Array.Empty<object>());
			unityPlayer = new AndroidJavaClass("com.unity3d.player.UnityPlayer");
			currentActivity = unityPlayer.GetStatic<AndroidJavaObject>("currentActivity");
		}

		public static void UPvr_SetUnityObjectName(string obj)
		{
			System.UPvr_CallMethod(tobHelper, "setUnityObjectName", obj);
		}

		public static void UPvr_BindToBService()
		{
			System.UPvr_CallMethod(tobHelper, "bindTobService", currentActivity);
		}

		public static void UPvr_UnBindToBService()
		{
			System.UPvr_CallMethod(tobHelper, "unBindTobService", currentActivity);
		}

		private static AndroidJavaObject GetEnumType(Enum enumType)
		{
			return new AndroidJavaClass("com.pvr.tobservice.enums" + enumType.GetType().ToString().Replace("Pvr_UnitySDKAPI", "")).GetStatic<AndroidJavaObject>(enumType.ToString());
		}

		public static string UPvr_StateGetDeviceInfo(PBS_SystemInfoEnum type)
		{
			string result = "";
			System.UPvr_CallMethod(ref result, tobHelper, "pbsStateGetDeviceInfo", GetEnumType(type), 0);
			return result;
		}

		public static void UPvr_ControlSetDeviceAction(PBS_DeviceControlEnum deviceControl, Action<int> callback)
		{
			if (callback != null)
			{
				IntCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsControlSetDeviceAction", GetEnumType(deviceControl), null);
		}

		public static void UPvr_ControlAPPManger(PBS_PackageControlEnum packageControl, string path, Action<int> callback)
		{
			if (callback != null)
			{
				IntCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsControlAPPManger", GetEnumType(packageControl), path, 0, null);
		}

		public static void UPvr_ControlSetAutoConnectWIFI(string ssid, string pwd, Action<bool> callback)
		{
			if (callback != null)
			{
				BoolCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsControlSetAutoConnectWIFI", ssid, pwd, 0, null);
		}

		public static void UPvr_ControlClearAutoConnectWIFI(Action<bool> callback)
		{
			if (callback != null)
			{
				BoolCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsControlClearAutoConnectWIFI", null);
		}

		public static void UPvr_PropertySetHomeKey(PBS_HomeEventEnum eventEnum, PBS_HomeFunctionEnum function, Action<bool> callback)
		{
			if (callback != null)
			{
				BoolCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsPropertySetHomeKey", GetEnumType(eventEnum), GetEnumType(function), null);
		}

		public static void UPvr_PropertySetHomeKeyAll(PBS_HomeEventEnum eventEnum, PBS_HomeFunctionEnum function, int timesetup, string pkg, string className, Action<bool> callback)
		{
			if (callback != null)
			{
				BoolCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsPropertySetHomeKeyAll", GetEnumType(eventEnum), GetEnumType(function), timesetup, pkg, className, null);
		}

		public static void UPvr_PropertyDisablePowerKey(bool isSingleTap, bool enable, Action<int> callback)
		{
			if (callback != null)
			{
				IntCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsPropertyDisablePowerKey", isSingleTap, enable, null);
		}

		public static void UPvr_PropertySetScreenOffDelay(PBS_ScreenOffDelayTimeEnum timeEnum, Action<int> callback)
		{
			if (callback != null)
			{
				IntCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsPropertySetScreenOffDelay", GetEnumType(timeEnum), null);
		}

		public static void UPvr_PropertySetSleepDelay(PBS_SleepDelayTimeEnum timeEnum)
		{
			System.UPvr_CallMethod(tobHelper, "pbsPropertySetSleepDelay", GetEnumType(timeEnum));
		}

		public static void UPvr_SwitchSystemFunction(PBS_SystemFunctionSwitchEnum systemFunction, PBS_SwitchEnum switchEnum)
		{
			System.UPvr_CallMethod(tobHelper, "pbsSwitchSystemFunction", GetEnumType(systemFunction), GetEnumType(switchEnum), 0);
		}

		public static void UPvr_SwitchSetUsbConfigurationOption(PBS_USBConfigModeEnum uSBConfigModeEnum)
		{
			System.UPvr_CallMethod(tobHelper, "pbsSwitchSetUsbConfigurationOption", GetEnumType(uSBConfigModeEnum), 0);
		}

		public static void UPvr_ScreenOn()
		{
			System.UPvr_CallMethod(tobHelper, "pbsScreenOn");
		}

		public static void UPvr_ScreenOff()
		{
			System.UPvr_CallMethod(tobHelper, "pbsScreenOff");
		}

		public static void UPvr_AcquireWakeLock()
		{
			System.UPvr_CallMethod(tobHelper, "pbsAcquireWakeLock");
		}

		public static void UPvr_ReleaseWakeLock()
		{
			System.UPvr_CallMethod(tobHelper, "pbsReleaseWakeLock");
		}

		public static void UPvr_EnableEnterKey()
		{
			System.UPvr_CallMethod(tobHelper, "pbsEnableEnterKey");
		}

		public static void UPvr_DisableEnterKey()
		{
			System.UPvr_CallMethod(tobHelper, "pbsDisableEnterKey");
		}

		public static void UPvr_EnableVolumeKey()
		{
			System.UPvr_CallMethod(tobHelper, "pbsEnableVolumeKey");
		}

		public static void UPvr_DisableVolumeKey()
		{
			System.UPvr_CallMethod(tobHelper, "pbsDisableVolumeKey");
		}

		public static void UPvr_EnableBackKey()
		{
			System.UPvr_CallMethod(tobHelper, "pbsEnableBackKey");
		}

		public static void UPvr_DisableBackKey()
		{
			System.UPvr_CallMethod(tobHelper, "pbsDisableBackKey");
		}

		public static void UPvr_WriteConfigFileToDataLocal(string path, string content, Action<bool> callback)
		{
			if (callback != null)
			{
				BoolCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsWriteConfigFileToDataLocal", path, content, null);
		}

		public static void UPvr_ResetAllKeyToDefault(Action<bool> callback)
		{
			if (callback != null)
			{
				BoolCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsResetAllKeyToDefault", null);
		}
	}
	public enum GlobalIntConfigs
	{
		EYE_TEXTURE_RESOLUTION0,
		EYE_TEXTURE_RESOLUTION1,
		SEENSOR_COUNT,
		ABILITY6DOF,
		PLATFORM_TYPE,
		TRACKING_MODE,
		LOG_LEVEL,
		ENBLE_HAND6DOF_BY_HEAD,
		ENBLE_6DOF_GLOBAL_TRACKING,
		TARGET_FRAME_RATE,
		iShowFPS,
		SensorMode,
		LOGICFLOW,
		EYE_TEXTURE_RES_HIGH,
		EYE_TEXTURE_RES_NORMAL,
		iCtrlModelLoadingPri,
		iPhoneHMDModeEnabled,
		isEnableBoundary,
		Enable_Activity_Rotation,
		GetDisplay_Orientation,
		GetWaitFrameNum,
		GetResetFrameNum,
		EnableFFRBYSYS,
		RotControllerMode
	}
	public enum GlobalFloatConfigs
	{
		IPD,
		VFOV,
		HFOV,
		NECK_MODEL_X,
		NECK_MODEL_Y,
		NECK_MODEL_Z,
		DISPLAY_REFRESH_RATE
	}
	public enum RenderTextureAntiAliasing
	{
		X_1 = 1,
		X_2 = 2,
		X_4 = 4,
		X_8 = 8
	}
	public enum PlatForm
	{
		Android = 1,
		IOS,
		Win,
		Notsupport
	}
	public enum RenderTextureDepth
	{
		BD_0 = 0,
		BD_16 = 16,
		BD_24 = 24
	}
	public enum RenderTextureLevel
	{
		Normal,
		High
	}
	public enum Sensorindex
	{
		Default,
		FirstSensor,
		SecondSensor
	}
	public enum Eye
	{
		LeftEye,
		RightEye,
		BothEye
	}
	public enum ResUtilsType
	{
		TYPE_TEXTSIZE,
		TYPE_COLOR,
		TYPE_TEXT,
		TYPE_FONT,
		TYPE_VALUE,
		TYPE_DRAWABLE,
		TYPE_OBJECT,
		TYPR_OBJECTARRAY
	}
	public enum TrackingOrigin
	{
		EyeLevel,
		FloorLevel,
		StageLevel
	}
	public enum EFoveationLevel
	{
		Low,
		Med,
		High,
		Top_High
	}
	public enum StereoRenderingPathPico
	{
		MultiPass,
		SinglePass
	}
	public enum pvrEyePoseStatus
	{
		kGazePointValid = 1,
		kGazeVectorValid = 2,
		kEyeOpennessValid = 4,
		kEyePupilDilationValid = 8,
		kEyePositionGuideValid = 0x10
	}
	public enum TrackingMode
	{
		PVR_TRACKING_MODE_ROTATION = 1,
		PVR_TRACKING_MODE_POSITION = 2,
		PVR_TRACKING_MODE_EYE = 4
	}
	public struct EyeTrackingData
	{
		public int leftEyePoseStatus;

		public int rightEyePoseStatus;

		public int combinedEyePoseStatus;

		public Vector3 leftEyeGazePoint;

		public Vector3 rightEyeGazePoint;

		public Vector3 combinedEyeGazePoint;

		public Vector3 leftEyeGazeVector;

		public Vector3 rightEyeGazeVector;

		public Vector3 combinedEyeGazeVector;

		public float leftEyeOpenness;

		public float rightEyeOpenness;

		public float leftEyePupilDilation;

		public float rightEyePupilDilation;

		public Vector3 leftEyePositionGuide;

		public Vector3 rightEyePositionGuide;

		public Vector3 foveatedGazeDirection;

		public int foveatedGazeTrackingState;

		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 8)]
		public byte[] reserved;
	}
	public struct EyeTrackingGazeRay
	{
		public Vector3 Direction;

		public bool IsValid;

		public Vector3 Origin;
	}
	public struct EyeDeviceInfo
	{
		public ViewFrustum targetFrustumLeft;

		public ViewFrustum targetFrustumRight;
	}
	public struct ViewFrustum
	{
		public float left;

		public float right;

		public float top;

		public float bottom;

		public float near;

		public float far;
	}
	public struct EyeSetting
	{
		public Transform eyelocalPosition;

		public Rect eyeRect;

		public float eyeFov;

		public float eyeAspect;

		public Matrix4x4 eyeProjectionMatrix;

		public Shader eyeShader;
	}
	public struct Sensor
	{
		public const string LibFileName = "Pvr_UnitySDK";

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_Enable6DofModule(bool enable);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_OptionalResetSensor(int index, int resetRot, int resetPos);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_Init(int index);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_StartSensor(int index);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_StopSensor(int index);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_ResetSensor(int index);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_ResetSensorAll(int index);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetSensorState(int index, ref float x, ref float y, ref float z, ref float w, ref float px, ref float py, ref float pz);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetMainSensorState(ref float x, ref float y, ref float z, ref float w, ref float px, ref float py, ref float pz, ref float vfov, ref float hfov, ref int viewNumber);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetPsensorState();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetHmdPSensorStatus();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetSensorGyroscope(int index, ref float x, ref float y, ref float z);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetSensorMagnet(int index, ref float x, ref float y, ref float z);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_Get6DofSensorQualityStatus();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_Get6DofSafePanelFlag();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetReinPosition(float x, float y, float z, float w, float px, float py, float pz, int hand, bool valid, int key);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_SetTrackingOriginType(TrackingOrigin trackingOriginType);

		public static bool UPvr_Pvr_Get6DofSafePanelFlag()
		{
			return Pvr_Get6DofSafePanelFlag();
		}

		public static int UPvr_Init(int index)
		{
			return Pvr_Init(index);
		}

		public static void UPvr_InitPsensor()
		{
			Pvr_InitPsensor();
		}

		public static int UPvr_GetPsensorState()
		{
			int res = -1;
			Render.UPvr_GetIntConfig(4, ref res);
			if (res == 1)
			{
				return Pvr_GetPsensorState();
			}
			int num = Pvr_GetAndroidPsensorState();
			if (num != 0 && num != -1)
			{
				num = 1;
			}
			return num;
		}

		public static int UPvr_GetPSensorStatus()
		{
			return Pvr_GetHmdPSensorStatus();
		}

		public static void UPvr_UnregisterPsensor()
		{
			Pvr_UnregisterPsensor();
		}

		public static int UPvr_StartSensor(int index)
		{
			return Pvr_StartSensor(index);
		}

		public static int UPvr_StopSensor(int index)
		{
			return Pvr_StopSensor(index);
		}

		public static int UPvr_ResetSensor(int index)
		{
			Pvr_UnitySDKManager.SDK.resetBasePos = default(Vector3);
			return Pvr_ResetSensor(index);
		}

		public static int UPvr_OptionalResetSensor(int index, int resetRot, int resetPos)
		{
			return Pvr_OptionalResetSensor(index, resetRot, resetPos);
		}

		public static int UPvr_GetSensorState(int index, ref float x, ref float y, ref float z, ref float w, ref float px, ref float py, ref float pz)
		{
			return Pvr_GetSensorState(index, ref x, ref y, ref z, ref w, ref px, ref py, ref pz);
		}

		public static int UPvr_GetMainSensorState(ref float x, ref float y, ref float z, ref float w, ref float px, ref float py, ref float pz, ref float vfov, ref float hfov, ref int viewNumber)
		{
			return Pvr_GetMainSensorState(ref x, ref y, ref z, ref w, ref px, ref py, ref pz, ref vfov, ref hfov, ref viewNumber);
		}

		public static int UPvr_GetSensorGyroscope(int index, ref float x, ref float y, ref float z)
		{
			return Pvr_GetSensorGyroscope(index, ref x, ref y, ref z);
		}

		public static int UPvr_GetSensorMagnet(int index, ref float x, ref float y, ref float z)
		{
			return Pvr_GetSensorMagnet(index, ref x, ref y, ref z);
		}

		public static int UPvr_Get6DofSensorQualityStatus()
		{
			return Pvr_Get6DofSensorQualityStatus();
		}

		public static int UPvr_Enable6DofModule(bool enable)
		{
			return Pvr_Enable6DofModule(enable);
		}

		public static void Pvr_InitPsensor()
		{
			try
			{
				System.UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaSysActivityClass, "initPsensor", Pvr_UnitySDKRender.Instance.activity);
			}
			catch (Exception ex)
			{
				PLOG.E("Error :" + ex.ToString());
			}
		}

		public static bool Pvr_IsHead6dofReset()
		{
			int res = 0;
			Render.UPvr_GetIntConfig(17, ref res);
			if (res > 0)
			{
				return false;
			}
			bool result = false;
			try
			{
				System.UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaSysActivityClass, "isHead6dofReset", Pvr_UnitySDKRender.Instance.activity);
			}
			catch (Exception ex)
			{
				PLOG.E("Error :" + ex.ToString());
			}
			return result;
		}

		public static int Pvr_GetAndroidPsensorState()
		{
			int result = -1;
			try
			{
				System.UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaSysActivityClass, "getPsensorState");
			}
			catch (Exception ex)
			{
				PLOG.E("Error :" + ex.ToString());
			}
			return result;
		}

		public static void Pvr_UnregisterPsensor()
		{
			try
			{
				System.UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaSysActivityClass, "unregisterListener");
			}
			catch (Exception ex)
			{
				PLOG.E("Error :" + ex.ToString());
			}
		}

		public static int UPvr_ResetSensorAll(int index)
		{
			return Pvr_ResetSensorAll(index);
		}

		public static void UPvr_SetReinPosition(float x, float y, float z, float w, float px, float py, float pz, int hand, bool valid, int key)
		{
			if (PLOG.logLevel > 2)
			{
				PLOG.D("PvrLog UPvr_SetReinPosition" + x + y + z + w + px + py + pz + hand + valid.ToString() + key);
			}
			Pvr_SetReinPosition(x, y, z, w, px, py, pz, hand, valid, key);
		}

		public static bool UPvr_SetTrackingOriginType(TrackingOrigin trackingOriginType)
		{
			return Pvr_SetTrackingOriginType(trackingOriginType);
		}
	}
	public struct Render
	{
		public const string LibFileName = "Pvr_UnitySDK";

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_ChangeScreenParameters(string model, int width, int height, double xppi, double yppi, double densityDpi);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_SetRatio(float midH, float midV);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_SetPupillaryPoint(bool enable);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern IntPtr Pvr_GetSupportHMDTypes();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetCurrentHMDType([MarshalAs(UnmanagedType.LPStr)] string type);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetIntConfig(int configsenum, ref int res);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetFloatConfig(int configsenum, ref float res);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetupLayerData(int layerIndex, int sideMask, int textureId, int textureType, int layerFlags, float[] colorScaleAndOffset);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetupLayerCoords(int layerIndex, int sideMask, float[] lowerLeft, float[] lowerRight, float[] upperLeft, float[] upperRight);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetOverlayModelViewMatrix(int overlayType, int overlayShape, int texId, int eyeSide, int layerIndex, bool isHeadLocked, int layerFlags, float[] mvMatrix, float[] modelS, float[] modelR, float[] modelT, float[] cameraR, float[] cameraT, float[] colorScaleAndOffset);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_EnableFoveation(bool enable);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetFoveationParameters(int textureId, int previousId, float focalPointX, float focalPointY, float foveationGainX, float foveationGainY, float foveationArea, float foveationMinimum);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetFoveationResource(int textureId, int previousId, float focalPointX, float focalPointY);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetFoveationParameters2(float foveationGainX, float foveationGainY, float foveationArea, float foveationMinimum);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetFoveationLevel(EFoveationLevel level);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern EFoveationLevel Pvr_GetFoveationLevel();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_GetIntSysProc(string property, ref int res);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetColorspaceType(int colorspaceType);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetCastingColorspaceType(int colorspaceType);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern IntPtr Pvr_CreateLayerAndroidSurface(int layerType, int layerIndex);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern IntPtr Pvr_GetLayerAndroidSurface(int layerType, int layerIndex);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetMonoMode(bool openMono);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_GetStencilMesh(int eye, ref int vertexCount, ref int triangleCount, ref IntPtr vertexData, ref IntPtr indexData);

		public static void UPvr_ChangeScreenParameters(string model, int width, int height, double xppi, double yppi, double densityDpi)
		{
			Pvr_ChangeScreenParameters(model, width, height, xppi, yppi, densityDpi);
		}

		public static int UPvr_SetRatio(float midH, float midV)
		{
			return Pvr_SetRatio(midH, midV);
		}

		public static void UPvr_EnableFoveation(bool enable)
		{
			if (Pvr_UnitySDKManager.SDK.SystemFFRLevel != -1 || Pvr_UnitySDKManager.SDK.SystemDebugFFRLevel != -1)
			{
				enable = true;
			}
			Pvr_EnableFoveation(enable);
		}

		[Obsolete("This API will be removed in later versions")]
		public static void UPvr_SetFoveationParameters(int textureId, int previousId, float focalPointX, float focalPointY, float foveationGainX, float foveationGainY, float foveationArea, float foveationMinimum)
		{
			Pvr_SetFoveationParameters(textureId, previousId, focalPointX, focalPointY, foveationGainX, foveationGainY, foveationArea, foveationMinimum);
		}

		public static void UPvr_SetFoveationResource(int textureId, int previousId, float focalPointX, float focalPointY)
		{
			Pvr_SetFoveationResource(textureId, previousId, focalPointX, focalPointY);
		}

		public static void SetFoveatedRenderingLevel(EFoveationLevel level)
		{
			if (Pvr_UnitySDKManager.SDK.SystemDebugFFRLevel != -1)
			{
				Pvr_SetFoveationLevel((EFoveationLevel)Pvr_UnitySDKManager.SDK.SystemDebugFFRLevel);
			}
			else if (Pvr_UnitySDKManager.SDK.SystemFFRLevel != -1)
			{
				Pvr_SetFoveationLevel((EFoveationLevel)Pvr_UnitySDKManager.SDK.SystemFFRLevel);
			}
			else
			{
				Pvr_SetFoveationLevel(level);
			}
		}

		public static EFoveationLevel GetFoveatedRenderingLevel()
		{
			return Pvr_GetFoveationLevel();
		}

		public static void SetFoveatedRenderingParameters(Vector2 ffrGainValue, float ffrAreaValue, float ffrMinimumValue)
		{
			if (Pvr_UnitySDKManager.SDK.SystemDebugFFRLevel != -1)
			{
				Pvr_SetFoveationLevel((EFoveationLevel)Pvr_UnitySDKManager.SDK.SystemDebugFFRLevel);
			}
			else if (Pvr_UnitySDKManager.SDK.SystemFFRLevel != -1)
			{
				Pvr_SetFoveationLevel((EFoveationLevel)Pvr_UnitySDKManager.SDK.SystemFFRLevel);
			}
			else
			{
				Pvr_SetFoveationParameters2(ffrGainValue.x, ffrGainValue.y, ffrAreaValue, ffrMinimumValue);
			}
		}

		public static bool UPvr_GetIntSysProc(string property, ref int res)
		{
			return Pvr_GetIntSysProc(property, ref res);
		}

		public static int UPvr_GetIntConfig(int configsenum, ref int res)
		{
			return Pvr_GetIntConfig(configsenum, ref res);
		}

		public static int UPvr_GetFloatConfig(int configsenum, ref float res)
		{
			return Pvr_GetFloatConfig(configsenum, ref res);
		}

		public static string UPvr_GetSupportHMDTypes()
		{
			IntPtr intPtr = Pvr_GetSupportHMDTypes();
			if (intPtr != IntPtr.Zero)
			{
				return Marshal.PtrToStringAnsi(intPtr);
			}
			return null;
		}

		public static void UPvr_SetCurrentHMDType(string type)
		{
			Pvr_SetCurrentHMDType(type);
		}

		public static void UPvr_SetupLayerData(int layerIndex, int sideMask, int textureId, int textureType, int layerFlags, Vector4 colorScale, Vector4 colorOffset)
		{
			Pvr_SetupLayerData(layerIndex, sideMask, textureId, textureType, layerFlags, new float[8] { colorScale.x, colorScale.y, colorScale.z, colorScale.w, colorOffset.x, colorOffset.y, colorOffset.z, colorOffset.w });
		}

		public static void UPvr_SetupLayerCoords(int layerIndex, int sideMask, float[] lowerLeft, float[] lowerRight, float[] upperLeft, float[] upperRight)
		{
			Pvr_SetupLayerCoords(layerIndex, sideMask, lowerLeft, lowerRight, upperLeft, upperRight);
		}

		public static void UPvr_SetOverlayModelViewMatrix(int overlayType, int overlayShape, int texId, int eyeSide, int layerIndex, bool isHeadLocked, int layerFlags, Matrix4x4 mvMatrix, Vector3 modelS, Quaternion modelR, Vector3 modelT, Quaternion cameraR, Vector3 cameraT, Vector4 colorScale, Vector4 colorOffset)
		{
			Pvr_SetOverlayModelViewMatrix(overlayType, overlayShape, texId, eyeSide, layerIndex, isHeadLocked, layerFlags, new float[16]
			{
				mvMatrix.m00, mvMatrix.m01, mvMatrix.m02, mvMatrix.m03, mvMatrix.m10, mvMatrix.m11, mvMatrix.m12, mvMatrix.m13, mvMatrix.m20, mvMatrix.m21,
				mvMatrix.m22, mvMatrix.m23, mvMatrix.m30, mvMatrix.m31, mvMatrix.m32, mvMatrix.m33
			}, new float[3] { modelS.x, modelS.y, modelS.z }, new float[4] { modelR.x, modelR.y, modelR.z, modelR.w }, new float[3] { modelT.x, modelT.y, modelT.z }, new float[4] { cameraR.x, cameraR.y, cameraR.z, cameraR.w }, new float[3] { cameraT.x, cameraT.y, cameraT.z }, new float[8] { colorScale.x, colorScale.y, colorScale.z, colorScale.w, colorOffset.x, colorOffset.y, colorOffset.z, colorOffset.w });
		}

		public static void UPvr_SetColorspaceType(int colorspaceType)
		{
			Pvr_SetColorspaceType(colorspaceType);
		}

		public static void UPvr_SetCastingColorspaceType(int colorspaceType)
		{
			Pvr_SetCastingColorspaceType(colorspaceType);
		}

		public static IntPtr UPvr_CreateLayerAndroidSurface(int layerType, int layerIndex)
		{
			return Pvr_CreateLayerAndroidSurface(layerType, layerIndex);
		}

		public static IntPtr UPvr_GetLayerAndroidSurface(int layerType, int layerIndex)
		{
			return Pvr_GetLayerAndroidSurface(layerType, layerIndex);
		}

		public static void UPvr_SetMonoMode(bool openMono)
		{
			Pvr_SetMonoMode(openMono);
		}

		public static void UPvr_GetStencilMesh(int eye, ref int vertexCount, ref int triangleCount, ref IntPtr vertexDataPtr, ref IntPtr indexDataPtr)
		{
			Pvr_GetStencilMesh(eye, ref vertexCount, ref triangleCount, ref vertexDataPtr, ref indexDataPtr);
		}
	}
	public struct System
	{
		public const string LibFileName = "Pvr_UnitySDK";

		public const string UnitySDKVersion = "2.8.9.12";

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern void Pvr_SetInitActivity(IntPtr activity, IntPtr vrActivityClass);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern IntPtr Pvr_GetSDKVersion();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern int Pvr_GetHmdHardwareVersion();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr Pvr_GetHmdFirmwareVersion();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr Pvr_GetHmdSerialNumber();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern int PVR_GetHmdBatteryStatus();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern float PVR_GetHmdBatteryTemperature();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern int PVR_SetHmdAudioStatus(bool enable);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool Pvr_GetEyeTrackingData(ref int leftEyePoseStatus, ref int rightEyePoseStatus, ref int combinedEyePoseStatus, ref float leftEyeGazePointX, ref float leftEyeGazePointY, ref float leftEyeGazePointZ, ref float rightEyeGazePointX, ref float rightEyeGazePointY, ref float rightEyeGazePointZ, ref float combinedEyeGazePointX, ref float combinedEyeGazePointY, ref float combinedEyeGazePointZ, ref float leftEyeGazeVectorX, ref float leftEyeGazeVectorY, ref float leftEyeGazeVectorZ, ref float rightEyeGazeVectorX, ref float rightEyeGazeVectorY, ref float rightEyeGazeVectorZ, ref float combinedEyeGazeVectorX, ref float combinedEyeGazeVectorY, ref float combinedEyeGazeVectorZ, ref float leftEyeOpenness, ref float rightEyeOpenness, ref float leftEyePupilDilation, ref float rightEyePupilDilation, ref float leftEyePositionGuideX, ref float leftEyePositionGuideY, ref float leftEyePositionGuideZ, ref float rightEyePositionGuideX, ref float rightEyePositionGuideY, ref float rightEyePositionGuideZ, ref float foveatedGazeDirectionX, ref float foveatedGazeDirectionY, ref float foveatedGazeDirectionZ, ref int foveatedGazeTrackingState);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool Pvr_SetTrackingMode(int trackingMode);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern int Pvr_GetTrackingMode();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr GetRenderEventFunc();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern void UnityEventData(long data);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool Pvr_EnableSinglePass(bool enable);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern void Pvr_SetAntiAliasing(int antiAliasing);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern void Pvr_SinglePassBeforeForwardOpaque();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern void Pvr_SetCurrentRenderTexture(uint textureId);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool Pvr_SetSinglePassDepthBufferWidthHeight(int width, int height);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern int PVR_setPerformanceLevels(int cpuLevel, int gpuLevel);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool Pvr_SetIPD(float distance);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern float Pvr_GetIPD();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool Pvr_SetTrackingIPDEnabled(bool enable);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool Pvr_GetTrackingIPDEnabled();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool Pvr_GetEyeTrackingAutoIPD(ref float autoIPD);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern int PVR_GetHmdAudioStatus();

		public static bool UPvr_CallStaticMethod<T>(ref T result, AndroidJavaClass jclass, string name, params object[] args)
		{
			try
			{
				result = jclass.CallStatic<T>(name, args);
				return true;
			}
			catch (AndroidJavaException ex)
			{
				PLOG.E("Exception calling static method " + name + ": " + ex);
				return false;
			}
		}

		public static bool UPvr_CallStaticMethod(AndroidJavaObject jobj, string name, params object[] args)
		{
			try
			{
				jobj.CallStatic(name, args);
				return true;
			}
			catch (AndroidJavaException ex)
			{
				PLOG.E("CallStaticMethod  Exception calling activity method " + name + ": " + ex);
				return false;
			}
		}

		public static bool UPvr_CallMethod<T>(ref T result, AndroidJavaObject jobj, string name, params object[] args)
		{
			try
			{
				result = jobj.Call<T>(name, args);
				return true;
			}
			catch (AndroidJavaException ex)
			{
				PLOG.E("Exception calling activity method " + name + ": " + ex);
				return false;
			}
		}

		public static bool UPvr_CallMethod(AndroidJavaObject jobj, string name, params object[] args)
		{
			try
			{
				jobj.Call(name, args);
				return true;
			}
			catch (AndroidJavaException ex)
			{
				PLOG.E(" Exception calling activity method " + name + ": " + ex);
				return false;
			}
		}

		public static string UPvr_GetSDKVersion()
		{
			IntPtr intPtr = Pvr_GetSDKVersion();
			if (intPtr != IntPtr.Zero)
			{
				return Marshal.PtrToStringAnsi(intPtr);
			}
			return "";
		}

		public static string UPvr_GetUnitySDKVersion()
		{
			return "2.8.9.12";
		}

		public static string UPvr_GetDeviceMode()
		{
			return SystemInfo.deviceModel;
		}

		public static string UPvr_GetDeviceModel()
		{
			return SystemInfo.deviceModel;
		}

		public static string UPvr_GetDeviceSN()
		{
			string result = "UNKONWN";
			UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaSysActivityClass, "getDeviceSN");
			return result;
		}

		public static AndroidJavaObject UPvr_GetCurrentActivity()
		{
			return new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
		}

		public static bool UPvr_SetMonoPresentation()
		{
			return UPvr_CallMethod(UPvr_GetCurrentActivity(), "Pvr_setMonoPresentation");
		}

		public static bool UPvr_IsPresentationExisted()
		{
			bool result = false;
			return UPvr_CallMethod(ref result, UPvr_GetCurrentActivity(), "Pvr_isPresentationExisted") && result;
		}

		public static bool UPvr_GetMainActivityPauseStatus()
		{
			bool result = false;
			return UPvr_CallMethod(ref result, UPvr_GetCurrentActivity(), "Pvr_getMainActivityPauseStatus") && result;
		}

		public static void UPvr_Sleep()
		{
			UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaSysActivityClass, "Pvr_Sleep");
		}

		public static bool UPvr_StartHomeKeyReceiver(string startreceivre)
		{
			try
			{
				if (Pvr_UnitySDKRender.Instance != null)
				{
					UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaVrActivityLongReceiver, "Pvr_StartReceiver", Pvr_UnitySDKRender.Instance.activity, startreceivre);
					PLOG.I("Start home key Receiver");
					return true;
				}
			}
			catch (Exception ex)
			{
				PLOG.E("Start home key  Receiver  Error :" + ex.ToString());
				return false;
			}
			return true;
		}

		public static bool UPvr_StopHomeKeyReceiver()
		{
			try
			{
				if (Pvr_UnitySDKRender.Instance != null)
				{
					UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaVrActivityLongReceiver, "Pvr_StopReceiver", Pvr_UnitySDKRender.Instance.activity);
					PLOG.I("Stop home key Receiver");
					return true;
				}
			}
			catch (Exception ex)
			{
				PLOG.E("Stop home key Receiver Error :" + ex.ToString());
				return false;
			}
			return true;
		}

		public static void UPvr_StartVRModel()
		{
			UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaVrActivityClass, "startVRModel");
		}

		public static void UPvr_RemovePlatformLogo()
		{
			UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaVrActivityClass, "removePlatformLogo");
		}

		public static void UPvr_ShowPlatformLogo()
		{
			UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaVrActivityClass, "showPlatformLogo");
		}

		public static bool UPvr_IsPicoActivity()
		{
			bool result = false;
			return UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "isPicoActivity", UPvr_GetCurrentActivity()) && result;
		}

		public static void UPvr_StopVRModel()
		{
			UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaVrActivityClass, "stopVRModel");
		}

		public static string UPvr_GetCountryCode()
		{
			string result = "";
			UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getCountryCode", UPvr_GetCurrentActivity());
			return result;
		}

		public static bool UPvr_SetIPD(float distance)
		{
			bool flag = false;
			flag = Pvr_SetIPD(distance);
			if (flag)
			{
				for (int i = 0; i < Pvr_UnitySDKEyeManager.Instance.Eyes.Length; i++)
				{
					Pvr_UnitySDKEyeManager.Instance.Eyes[i].RefreshCameraPosition(distance);
				}
			}
			return flag;
		}

		public static float UPvr_GetIPD()
		{
			float num = Pvr_GetIPD();
			UnityEngine.Debug.Log("DISFT IPD:" + num);
			return num;
		}

		public static bool UPvr_SetTrackingIPDEnabled(bool enable)
		{
			return Pvr_SetTrackingIPDEnabled(enable);
		}

		public static bool UPvr_GetTrackingIPDEnabled()
		{
			return Pvr_GetTrackingIPDEnabled();
		}

		public static bool UPvr_GetEyeTrackingAutoIPD(ref float autoipd)
		{
			return Pvr_GetEyeTrackingAutoIPD(ref autoipd);
		}

		public static void UPvr_UnityEventData(long data)
		{
			UnityEventData(data);
		}

		public static long UPvr_GetEyeBufferData(int id)
		{
			return ((long)Pvr_UnitySDKRender.Instance.RenderviewNumber << 32) | id;
		}

		public static bool UPvr_checkDevice(string packagename)
		{
			bool result = false;
			UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "checkDevice", packagename, UPvr_GetCurrentActivity());
			return result;
		}

		public static int UPvr_GetHmdHardwareVersion()
		{
			return Pvr_GetHmdHardwareVersion();
		}

		public static string UPvr_GetHmdFirmwareVersion()
		{
			IntPtr intPtr = Pvr_GetHmdFirmwareVersion();
			if (intPtr != IntPtr.Zero)
			{
				return Marshal.PtrToStringAnsi(intPtr);
			}
			return "";
		}

		public static string UPvr_GetHmdSerialNumber()
		{
			IntPtr intPtr = Pvr_GetHmdSerialNumber();
			if (intPtr != IntPtr.Zero)
			{
				return Marshal.PtrToStringAnsi(intPtr);
			}
			return "";
		}

		public static int UPvr_GetHmdBatteryStatus()
		{
			return PVR_GetHmdBatteryStatus();
		}

		public static float UPvr_GetHmdBatteryTemperature()
		{
			return PVR_GetHmdBatteryTemperature();
		}

		public static int UPvr_SetHmdAudioStatus(bool enable)
		{
			return PVR_SetHmdAudioStatus(enable);
		}

		public static int UPvr_GetTrackingMode()
		{
			return Pvr_GetTrackingMode();
		}

		public static bool UPvr_setTrackingMode(int trackingMode)
		{
			return Pvr_SetTrackingMode(trackingMode);
		}

		public static bool UPvr_getEyeTrackingData(ref EyeTrackingData trackingData)
		{
			if (!Pvr_UnitySDKEyeManager.supportEyeTracking)
			{
				PLOG.E("The device is not supported");
				return false;
			}
			if (!Pvr_UnitySDKEyeManager.Instance.EyeTracking)
			{
				PLOG.E("Please Enable \"Pvr_UnitySDK/Head/Pvr_UnitySDKEyeManager.cs/EyeTracking\"option first.");
				return false;
			}
			bool result = Pvr_GetEyeTrackingData(ref trackingData.leftEyePoseStatus, ref trackingData.rightEyePoseStatus, ref trackingData.combinedEyePoseStatus, ref trackingData.leftEyeGazePoint.x, ref trackingData.leftEyeGazePoint.y, ref trackingData.leftEyeGazePoint.z, ref trackingData.rightEyeGazePoint.x, ref trackingData.rightEyeGazePoint.y, ref trackingData.rightEyeGazePoint.z, ref trackingData.combinedEyeGazePoint.x, ref trackingData.combinedEyeGazePoint.y, ref trackingData.combinedEyeGazePoint.z, ref trackingData.leftEyeGazeVector.x, ref trackingData.leftEyeGazeVector.y, ref trackingData.leftEyeGazeVector.z, ref trackingData.rightEyeGazeVector.x, ref trackingData.rightEyeGazeVector.y, ref trackingData.rightEyeGazeVector.z, ref trackingData.combinedEyeGazeVector.x, ref trackingData.combinedEyeGazeVector.y, ref trackingData.combinedEyeGazeVector.z, ref trackingData.leftEyeOpenness, ref trackingData.rightEyeOpenness, ref trackingData.leftEyePupilDilation, ref trackingData.rightEyePupilDilation, ref trackingData.leftEyePositionGuide.x, ref trackingData.leftEyePositionGuide.y, ref trackingData.leftEyePositionGuide.z, ref trackingData.rightEyePositionGuide.x, ref trackingData.rightEyePositionGuide.y, ref trackingData.rightEyePositionGuide.z, ref trackingData.foveatedGazeDirection.x, ref trackingData.foveatedGazeDirection.y, ref trackingData.foveatedGazeDirection.z, ref trackingData.foveatedGazeTrackingState);
			trackingData.leftEyeGazeVector.z = 0f - trackingData.leftEyeGazeVector.z;
			trackingData.rightEyeGazeVector.z = 0f - trackingData.rightEyeGazeVector.z;
			trackingData.combinedEyeGazeVector.z = 0f - trackingData.combinedEyeGazeVector.z;
			trackingData.leftEyeGazePoint.z = 0f - trackingData.leftEyeGazePoint.z;
			trackingData.rightEyeGazePoint.z = 0f - trackingData.rightEyeGazePoint.z;
			trackingData.combinedEyeGazePoint.z = 0f - trackingData.combinedEyeGazePoint.z;
			trackingData.foveatedGazeDirection.z = 0f - trackingData.foveatedGazeDirection.z;
			return result;
		}

		public static bool UPvr_getEyeTrackingGazeRay(ref EyeTrackingGazeRay gazeRay)
		{
			if (!Pvr_UnitySDKEyeManager.supportEyeTracking)
			{
				PLOG.E("The device is not supported");
				return false;
			}
			if (!Pvr_UnitySDKEyeManager.Instance.EyeTracking)
			{
				PLOG.E("Please Enable \"Pvr_UnitySDK/Head/Pvr_UnitySDKEyeManager.cs/EyeTracking\"option first.");
				return false;
			}
			EyeTrackingData trackingData = default(EyeTrackingData);
			UPvr_getEyeTrackingData(ref trackingData);
			gazeRay.IsValid = ((uint)trackingData.combinedEyePoseStatus & (true ? 1u : 0u)) != 0 && (trackingData.combinedEyePoseStatus & 2) != 0;
			if (gazeRay.IsValid)
			{
				gazeRay.Direction = trackingData.combinedEyeGazeVector;
				gazeRay.Origin = trackingData.combinedEyeGazePoint;
				gazeRay.Origin = Pvr_UnitySDKSensor.Instance.HeadPose.Matrix.MultiplyPoint(gazeRay.Origin);
				gazeRay.Direction = Pvr_UnitySDKSensor.Instance.HeadPose.Matrix.MultiplyVector(gazeRay.Direction);
				return true;
			}
			return false;
		}

		public static bool UPvr_getEyeTrackingGazeRayWorld(ref EyeTrackingGazeRay gazeRay)
		{
			if (!Pvr_UnitySDKEyeManager.supportEyeTracking)
			{
				PLOG.E("The device is not supported");
				return false;
			}
			if (!Pvr_UnitySDKEyeManager.Instance.EyeTracking)
			{
				PLOG.E("Please Enable \"Pvr_UnitySDK/Head/Pvr_UnitySDKEyeManager.cs/EyeTracking\"option first.");
				return false;
			}
			Transform transform = Pvr_UnitySDKEyeManager.Instance.transform;
			Matrix4x4 matrix4x = Matrix4x4.TRS(transform.position, transform.rotation, Vector3.one);
			EyeTrackingData trackingData = default(EyeTrackingData);
			UPvr_getEyeTrackingData(ref trackingData);
			gazeRay.IsValid = ((uint)trackingData.combinedEyePoseStatus & (true ? 1u : 0u)) != 0 && (trackingData.combinedEyePoseStatus & 2) != 0;
			if (gazeRay.IsValid)
			{
				gazeRay.Direction = trackingData.combinedEyeGazeVector;
				gazeRay.Origin = trackingData.combinedEyeGazePoint;
				gazeRay.Origin = matrix4x.MultiplyPoint(gazeRay.Origin);
				gazeRay.Direction = matrix4x.MultiplyVector(gazeRay.Direction);
				return true;
			}
			return false;
		}

		public static Vector3 UPvr_getEyeTrackingPos()
		{
			if (!Pvr_UnitySDKEyeManager.supportEyeTracking)
			{
				PLOG.E("The device is not supported");
				return Vector3.zero;
			}
			if (!Pvr_UnitySDKEyeManager.Instance.EyeTracking)
			{
				PLOG.E("Please Enable \"Pvr_UnitySDK/Head/Pvr_UnitySDKEyeManager.cs/EyeTracking\"option first.");
				return Vector3.zero;
			}
			return Pvr_UnitySDKEyeManager.Instance.GetEyeTrackingPos();
		}

		public static int UPvr_GetPhoneScreenBrightness()
		{
			int result = 0;
			UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClientClass, "Pvr_GetScreen_Brightness", UPvr_GetCurrentActivity());
			return result;
		}

		public static void UPvr_SetPhoneScreenBrightness(int level)
		{
			UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaVrActivityClientClass, "Pvr_setAPPScreen_Brightness", UPvr_GetCurrentActivity(), level);
		}

		public static bool UPvr_IsPicoDefaultActivity()
		{
			using (AndroidJavaClass androidJavaClass = new AndroidJavaClass("com.unity3d.player.UnityPlayer"))
			{
				using AndroidJavaObject androidJavaObject = androidJavaClass.GetStatic<AndroidJavaObject>("currentActivity");
				if (androidJavaObject.Call<string>("getLocalClassName", Array.Empty<object>()) == "com.unity3d.player.UnityPlayerNativeActivityPico")
				{
					return true;
				}
			}
			return false;
		}

		public static bool UPvr_EnableSinglePass(bool enable)
		{
			return Pvr_EnableSinglePass(enable);
		}

		public static void UPvr_SetAntiAliasing(int antiAliasing)
		{
			Pvr_SetAntiAliasing(antiAliasing);
		}

		public static void UPvr_SinglePassBeforeForwardOpaque()
		{
			Pvr_SinglePassBeforeForwardOpaque();
		}

		public static void UPvr_SetCurrentRenderTexture(uint textureId)
		{
			Pvr_SetCurrentRenderTexture(textureId);
		}

		public static bool UPvr_SetSinglePassDepthBufferWidthHeight(int width, int height)
		{
			return Pvr_SetSinglePassDepthBufferWidthHeight(width, height);
		}

		public static int UPVR_setPerformanceLevels(int cpuLevel, int gpuLevel)
		{
			return PVR_setPerformanceLevels(cpuLevel, gpuLevel);
		}

		public static int UPvr_GetColorRes(string name)
		{
			int result = -1;
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getColorRes", name);
			}
			catch (Exception ex)
			{
				PLOG.E("GetColorResError :" + ex.ToString());
			}
			return result;
		}

		public static int UPvr_GetConfigInt(string name)
		{
			int result = -1;
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getConfigInt", name);
			}
			catch (Exception ex)
			{
				PLOG.E("GetConfigIntError :" + ex.ToString());
			}
			return result;
		}

		public static string UPvr_GetConfigString(string name)
		{
			string result = "";
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getConfigString", name);
			}
			catch (Exception ex)
			{
				PLOG.E("GetConfigStringError :" + ex.ToString());
			}
			return result;
		}

		public static string UPvr_GetDrawableLocation(string name)
		{
			string result = "";
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getDrawableLocation", name);
			}
			catch (Exception ex)
			{
				PLOG.E("GetDrawableLocationError :" + ex.ToString());
			}
			return result;
		}

		public static int UPvr_GetTextSize(string name)
		{
			int result = -1;
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getTextSize", name);
			}
			catch (Exception ex)
			{
				PLOG.E("GetTextSizeError :" + ex.ToString());
			}
			return result;
		}

		public static string UPvr_GetLangString(string name)
		{
			string result = "";
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getLangString", name);
			}
			catch (Exception ex)
			{
				PLOG.E("GetLangStringError :" + ex.ToString());
			}
			return result;
		}

		public static string UPvr_GetStringValue(string id, int type)
		{
			string result = "";
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getStringValue", id, type);
			}
			catch (Exception ex)
			{
				PLOG.E("GetStringValueError :" + ex.ToString());
			}
			return result;
		}

		public static int UPvr_GetIntValue(string id, int type)
		{
			int result = -1;
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getIntValue", id, type);
			}
			catch (Exception ex)
			{
				PLOG.E("GetIntValueError :" + ex.ToString());
			}
			return result;
		}

		public static float UPvr_GetFloatValue(string id)
		{
			float result = -1f;
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getFloatValue", id);
			}
			catch (Exception ex)
			{
				PLOG.E("GetFloatValueError :" + ex.ToString());
			}
			return result;
		}

		public static string UPvr_GetObjectOrArray(string id, int type)
		{
			string result = "";
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getObjectOrArray", id, type);
			}
			catch (Exception ex)
			{
				PLOG.E("GetObjectOrArrayError :" + ex.ToString());
			}
			return result;
		}

		public static int UPvr_GetCharSpace(string id)
		{
			int result = -1;
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getCharSpace", id);
			}
			catch (Exception ex)
			{
				PLOG.E("GetCharSpaceError :" + ex.ToString());
			}
			return result;
		}
	}
	public struct BoundarySystem
	{
		public enum BoundaryType
		{
			OuterBoundary,
			PlayArea
		}

		public struct BoundaryTestResult
		{
			public bool IsTriggering;

			public float ClosestDistance;

			public Vector3 ClosestPoint;

			public Vector3 ClosestPointNormal;
		}

		public enum BoundaryTrackingNode
		{
			HandLeft,
			HandRight,
			Head
		}

		public enum BoundaryTrackingState
		{
			PVR_NOREASON,
			PVRRELOCATION_IN_PROGRESS,
			PVRLOW_FEATURE_COUNT_ERROR,
			PVRLOW_LIGHT_ERROR,
			PVRBRIGHT_LIGHT_ERROR,
			PVRSTEREO_CAMERA_CALIBRATION_ERROR
		}

		public const string LibFileName = "Pvr_UnitySDK";

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern float Pvr_GetFloorHeight();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetSeeThroughState();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_BoundarySetSTBackground(bool value);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetTrackingState();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_GetFrameRateLimit();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_IsBoundaryEnable();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_BoundaryGetConfigured();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_BoundaryTestNode(int node, bool isPlayArea, ref bool isTriggering, ref float closestDistance, ref float px, ref float py, ref float pz, ref float nx, ref float ny, ref float nz);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_BoundaryTestPoint(float x, float y, float z, bool isPlayArea, ref bool isTriggering, ref float closestDistance, ref float px, ref float py, ref float pz, ref float nx, ref float ny, ref float nz);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_BoundaryGetGeometry(out IntPtr handle, bool isPlayArea);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_BoundaryGetDimensions(ref float x, ref float y, ref float z, bool isPlayArea);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_BoundaryGetEnabled();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_BoundarySetVisible(bool value);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_BoundaryGetVisible();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_EnableLWRP(bool enable);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_SetViewportSize(int w, int h);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_BoundarySetSeeThroughVisible(bool value);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void PVR_SetCameraImageRect(int width, int height);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetGuardianSystemDisable(bool value);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetDialogState();

		public static float UPvr_GetFloorHeight()
		{
			return Pvr_GetFloorHeight();
		}

		public static int UPvr_GetSeeThroughState()
		{
			return Pvr_GetSeeThroughState();
		}

		public static void UPvr_EnableSeeThroughManual(bool enable)
		{
			Pvr_BoundarySetSTBackground(enable);
		}

		public static BoundaryTrackingState UPvr_GetTrackingState()
		{
			return (BoundaryTrackingState)Pvr_GetTrackingState();
		}

		public static bool UPvr_GetFrameRateLimit()
		{
			return Pvr_GetFrameRateLimit();
		}

		public static bool UPvr_IsBoundaryEnable()
		{
			return Pvr_IsBoundaryEnable();
		}

		public static bool UPvr_BoundaryGetConfigured()
		{
			return Pvr_BoundaryGetConfigured();
		}

		public static BoundaryTestResult UPvr_BoundaryTestNode(BoundaryTrackingNode node, BoundaryType boundaryType)
		{
			BoundaryTestResult result = default(BoundaryTestResult);
			bool num = Pvr_BoundaryTestNode((int)node, boundaryType == BoundaryType.PlayArea, ref result.IsTriggering, ref result.ClosestDistance, ref result.ClosestPoint.x, ref result.ClosestPoint.y, ref result.ClosestPoint.z, ref result.ClosestPointNormal.x, ref result.ClosestPointNormal.y, ref result.ClosestPointNormal.z);
			result.ClosestPoint.z = 0f - result.ClosestPoint.z;
			result.ClosestPointNormal.z = 0f - result.ClosestPointNormal.z;
			if (!num)
			{
				UnityEngine.Debug.LogError($"UPvr_BoundaryTestNode({node}, {boundaryType}) API call failed!");
			}
			return result;
		}

		public static BoundaryTestResult UPvr_BoundaryTestPoint(Vector3 point, BoundaryType boundaryType)
		{
			BoundaryTestResult result = default(BoundaryTestResult);
			if (!Pvr_BoundaryTestPoint(point.x, point.y, 0f - point.z, boundaryType == BoundaryType.PlayArea, ref result.IsTriggering, ref result.ClosestDistance, ref result.ClosestPoint.x, ref result.ClosestPoint.y, ref result.ClosestPoint.z, ref result.ClosestPointNormal.x, ref result.ClosestPointNormal.y, ref result.ClosestPointNormal.z))
			{
				UnityEngine.Debug.LogError($"UPvr_BoundaryTestPoint({point}, {boundaryType}) API call failed!");
			}
			return result;
		}

		public static Vector3[] UPvr_BoundaryGetGeometry(BoundaryType boundaryType)
		{
			IntPtr handle = IntPtr.Zero;
			int num = Pvr_BoundaryGetGeometry(out handle, boundaryType == BoundaryType.PlayArea);
			if (num <= 0)
			{
				UnityEngine.Debug.LogError("Boundary geometry point count is " + num);
				return null;
			}
			int num2 = num * 3;
			float[] array = new float[num2];
			Marshal.Copy(handle, array, 0, num2);
			Vector3[] array2 = new Vector3[num];
			for (int i = 0; i < num; i++)
			{
				array2[i] = new Vector3
				{
					x = array[3 * i],
					y = array[3 * i + 1],
					z = 0f - array[3 * i + 2]
				};
			}
			return array2;
		}

		public static Vector3 UPvr_BoundaryGetDimensions(BoundaryType boundaryType)
		{
			float x = 0f;
			float y = 0f;
			float z = 0f;
			Pvr_BoundaryGetDimensions(ref x, ref y, ref z, boundaryType == BoundaryType.PlayArea);
			return new Vector3(x, y, z);
		}

		public static bool UPvr_BoundaryGetEnabled()
		{
			return Pvr_BoundaryGetEnabled();
		}

		public static void UPvr_BoundarySetVisible(bool value)
		{
			Pvr_BoundarySetVisible(value);
		}

		public static bool UPvr_BoundaryGetVisible()
		{
			return Pvr_BoundaryGetVisible();
		}

		public static bool UPvr_EnableLWRP(bool enable)
		{
			return Pvr_EnableLWRP(enable);
		}

		public static bool UPvr_SetViewportSize(int width, int height)
		{
			return Pvr_SetViewportSize(width, height);
		}

		public static void UPvr_StartCameraFrame()
		{
			try
			{
				Pvr_UnitySDKPluginEvent.Issue(RenderEventType.StartCameraFrame);
			}
			catch (Exception ex)
			{
				PLOG.E("UPvr_StartCameraFrame :" + ex.ToString());
			}
		}

		public static void UPvr_StopCameraFrame()
		{
			try
			{
				Pvr_UnitySDKPluginEvent.Issue(RenderEventType.StopCameraFrame);
			}
			catch (Exception ex)
			{
				PLOG.E("UPvr_StopCameraFrame :" + ex.ToString());
			}
		}

		public static void UPvr_BoundaryGetSeeThroughData(int cameraIndex, RenderTexture renderTexture)
		{
			try
			{
				if (renderTexture.IsCreated())
				{
					System.UPvr_UnityEventData(renderTexture.GetNativeTexturePtr().ToInt32());
					switch (cameraIndex)
					{
					case 0:
						Pvr_UnitySDKPluginEvent.Issue(RenderEventType.CameraFrameLeft);
						break;
					case 1:
						Pvr_UnitySDKPluginEvent.Issue(RenderEventType.CameraFrameRight);
						break;
					}
				}
			}
			catch (Exception ex)
			{
				PLOG.E("UPvr_BoundaryGetSeeThroughDataError :" + ex.ToString());
			}
		}

		public static void UPvr_BoundarySetCameraImageRect(int width, int height)
		{
			try
			{
				PVR_SetCameraImageRect(width, height);
			}
			catch (Exception ex)
			{
				PLOG.E("UPvr_BoundarySetCameraImageRectError :" + ex.ToString());
			}
		}

		public static void UPvr_BoundarySetSeeThroughVisible(bool value)
		{
			try
			{
				Pvr_BoundarySetSeeThroughVisible(value);
			}
			catch (Exception ex)
			{
				PLOG.E("UPvr_BoundarySetSeeThroughVisibleError :" + ex.ToString());
			}
		}

		public static void UPvr_SetGuardianSystemDisable(bool value)
		{
			try
			{
				Pvr_SetGuardianSystemDisable(value);
			}
			catch (Exception ex)
			{
				PLOG.E("UPvr_SetGuardianSystemDisableError :" + ex.ToString());
			}
		}

		public static int UPvr_GetDialogState()
		{
			int result = 0;
			try
			{
				result = Pvr_GetDialogState();
			}
			catch (Exception ex)
			{
				PLOG.E("UPvr_GetDialogStateError :" + ex.ToString());
			}
			return result;
		}
	}
	public struct PlatformSettings
	{
		public static Pvr_UnitySDKPlatformSetting.simulationType UPvr_IsCurrentDeviceValid()
		{
			if (Pvr_UnitySDKPlatformSetting.Entitlementchecksimulation)
			{
				if (Pvr_UnitySDKPlatformSetting.Instance.deviceSN.Count <= 0)
				{
					UnityEngine.Debug.Log("DISFT Entitlement Check Simulation deviceSN is Null");
					return Pvr_UnitySDKPlatformSetting.simulationType.Null;
				}
				foreach (string item in Pvr_UnitySDKPlatformSetting.Instance.deviceSN)
				{
					if (System.UPvr_GetDeviceSN() == item)
					{
						return Pvr_UnitySDKPlatformSetting.simulationType.Valid;
					}
				}
				UnityEngine.Debug.Log("DISFT Entitlement Check Simulation deviceSN is Invalid");
				return Pvr_UnitySDKPlatformSetting.simulationType.Invalid;
			}
			UnityEngine.Debug.Log("DISFT Entitlement Check Simulation DO NOT Enable");
			return Pvr_UnitySDKPlatformSetting.simulationType.Invalid;
		}

		public static bool UPvr_AppEntitlementCheck(string appid)
		{
			bool result = false;
			try
			{
				System.UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "verifyAPP", System.UPvr_GetCurrentActivity(), appid, "");
			}
			catch (Exception ex)
			{
				PLOG.E("Error :" + ex.ToString());
			}
			UnityEngine.Debug.Log("PvrLog UPvr_AppEntitlementCheck" + result);
			return result;
		}

		[Obsolete("This API will be removed in later versions")]
		public static bool UPvr_KeyEntitlementCheck(string publicKey)
		{
			bool result = false;
			try
			{
				System.UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "verifyAPP", System.UPvr_GetCurrentActivity(), "", publicKey);
			}
			catch (Exception ex)
			{
				PLOG.E("Error :" + ex.ToString());
			}
			UnityEngine.Debug.Log("PvrLog UPvr_KeyEntitlementCheck" + result);
			return result;
		}

		public static int UPvr_AppEntitlementCheckExtra(string appid)
		{
			int result = 100;
			try
			{
				System.UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "verifyAPPExt", System.UPvr_GetCurrentActivity(), appid, "");
			}
			catch (Exception ex)
			{
				PLOG.E("Error :" + ex.ToString());
			}
			UnityEngine.Debug.Log("PvrLog UPvr_AppEntitlementCheckExtra " + result);
			return result;
		}

		public static int UPvr_KeyEntitlementCheckExtra(string publicKey)
		{
			int result = -1;
			try
			{
				System.UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "verifyAPPExt", System.UPvr_GetCurrentActivity(), "", publicKey);
			}
			catch (Exception ex)
			{
				PLOG.E("Error :" + ex.ToString());
			}
			UnityEngine.Debug.Log("PvrLog UPvr_KeyEntitlementCheck" + result);
			return result;
		}

		public static int UPvr_GetHmdAudioStatus()
		{
			return System.PVR_GetHmdAudioStatus();
		}
	}
	public enum DeviceCommand
	{
		SET_PICO_NEO_HMD_BRIGHTNESS = 12,
		SET_PICO_NEO_HMD_SLEEPDELAY
	}
	public enum BrightnessLevel
	{
		VR_BRIGHTNESS_LEVEL_MIN = 1,
		VR_BRIGHTNESS_LEVEL_MAX = 100,
		VR_BRIGHTNESS_LEVEL_DOWN = 1000,
		VR_BRIGHTNESS_LEVEL_UP = 1001,
		VR_BRIGHTNESS_LEVEL_SCREEN_OFF = -100
	}
	public struct VolumePowerBrightness
	{
		public const string LibFileName = "Pvr_UnitySDK";

		public AndroidJavaObject activity;

		public static AndroidJavaClass javaSysActivityClass;

		private static AndroidJavaClass batteryjavaVrActivityClass;

		private static AndroidJavaClass volumejavaVrActivityClass;

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern void Pvr_SetInitActivity(IntPtr activity, IntPtr vrActivityClass);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_IsHmdExist();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetHmdScreenBrightness();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_SetHmdScreenBrightness(int brightness);

		public static bool UPvr_IsHmdExist()
		{
			return Pvr_IsHmdExist();
		}

		public static int UPvr_GetHmdScreenBrightness()
		{
			return Pvr_GetHmdScreenBrightness();
		}

		public static bool UPvr_SetHmdScreenBrightness(int brightness)
		{
			return Pvr_SetHmdScreenBrightness(brightness);
		}

		public static bool UPvr_SetCommonBrightness(int brightness)
		{
			bool flag = false;
			if (UPvr_IsHmdExist())
			{
				return UPvr_SetHmdScreenBrightness(brightness);
			}
			return UPvr_SetBrightness(brightness);
		}

		public static int UPvr_GetCommonBrightness()
		{
			int num = 0;
			if (UPvr_IsHmdExist())
			{
				return UPvr_GetHmdScreenBrightness();
			}
			return UPvr_GetCurrentBrightness();
		}

		public static int[] UPvr_GetScreenBrightnessLevel()
		{
			return Pvr_GetScreenBrightnessLevel();
		}

		public static void UPvr_SetScreenBrightnessLevel(int vrBrightness, int level)
		{
			Pvr_SetScreenBrightnessLevel(vrBrightness, level);
		}

		public static bool UPvr_SetDevicePropForUser(DeviceCommand deviceid, string number)
		{
			return setDevicePropForUser(deviceid, number);
		}

		public static string UPvr_GetDevicePropForUser(DeviceCommand deviceid)
		{
			return getDevicePropForUser(deviceid);
		}

		public static bool UPvr_InitBatteryClass()
		{
			try
			{
				if (javaSysActivityClass == null)
				{
					javaSysActivityClass = new AndroidJavaClass("com.psmart.aosoperation.SysActivity");
				}
				if (javaSysActivityClass != null && Pvr_UnitySDKRender.Instance.activity != null)
				{
					if (batteryjavaVrActivityClass == null)
					{
						batteryjavaVrActivityClass = new AndroidJavaClass("com.psmart.aosoperation.BatteryReceiver");
					}
					return true;
				}
				return false;
			}
			catch (Exception ex)
			{
				PLOG.E("startReceiver Error :" + ex.ToString());
				return false;
			}
		}

		public static bool UPvr_InitBatteryVolClass()
		{
			try
			{
				javaSysActivityClass = new AndroidJavaClass("com.psmart.aosoperation.SysActivity");
				if (javaSysActivityClass != null && Pvr_UnitySDKRender.Instance.activity != null)
				{
					batteryjavaVrActivityClass = new AndroidJavaClass("com.psmart.aosoperation.BatteryReceiver");
					volumejavaVrActivityClass = new AndroidJavaClass("com.psmart.aosoperation.AudioReceiver");
					System.UPvr_CallStaticMethod(javaSysActivityClass, "Pvr_InitAudioDevice", Pvr_UnitySDKRender.Instance.activity);
					return true;
				}
				return false;
			}
			catch (Exception ex)
			{
				PLOG.E("startReceiver Error :" + ex.ToString());
				return false;
			}
		}

		public static bool UPvr_StartBatteryReceiver(string startreceivre)
		{
			try
			{
				System.UPvr_CallStaticMethod(batteryjavaVrActivityClass, "Pvr_StartReceiver", Pvr_UnitySDKRender.Instance.activity, startreceivre);
				return true;
			}
			catch (Exception ex)
			{
				PLOG.E("startReceiver Error :" + ex.ToString());
				return false;
			}
		}

		public static bool UPvr_StopBatteryReceiver()
		{
			try
			{
				System.UPvr_CallStaticMethod(batteryjavaVrActivityClass, "Pvr_StopReceiver", Pvr_UnitySDKRender.Instance.activity);
				return true;
			}
			catch (Exception ex)
			{
				PLOG.E("startReceiver Error :" + ex.ToString());
				return false;
			}
		}

		public static bool UPvr_SetBrightness(int brightness)
		{
			try
			{
				System.UPvr_CallStaticMethod(javaSysActivityClass, "Pvr_SetScreen_Brightness", brightness, Pvr_UnitySDKRender.Instance.activity);
				return true;
			}
			catch (Exception ex)
			{
				PLOG.E(" Error :" + ex.ToString());
				return false;
			}
		}

		public static int UPvr_GetCurrentBrightness()
		{
			int result = 0;
			try
			{
				System.UPvr_CallStaticMethod(ref result, javaSysActivityClass, "Pvr_GetScreen_Brightness", Pvr_UnitySDKRender.Instance.activity);
			}
			catch (Exception ex)
			{
				PLOG.E(" Error :" + ex.ToString());
			}
			return result;
		}

		public static int[] Pvr_GetScreenBrightnessLevel()
		{
			int[] result = new int[1];
			try
			{
				System.UPvr_CallStaticMethod(ref result, javaSysActivityClass, "getScreenBrightnessLevel");
			}
			catch (Exception ex)
			{
				PLOG.E(" Error :" + ex.ToString());
			}
			return result;
		}

		public static void Pvr_SetScreenBrightnessLevel(int vrBrightness, int level)
		{
			try
			{
				System.UPvr_CallStaticMethod(javaSysActivityClass, "setScreenBrightnessLevel", vrBrightness, level);
			}
			catch (Exception ex)
			{
				PLOG.E(" Error :" + ex.ToString());
			}
		}

		public static bool UPvr_StartAudioReceiver(string startreceivre)
		{
			try
			{
				System.UPvr_CallStaticMethod(volumejavaVrActivityClass, "Pvr_StartReceiver", Pvr_UnitySDKRender.Instance.activity, startreceivre);
				return true;
			}
			catch (Exception ex)
			{
				PLOG.E("startReceiver Error :" + ex.ToString());
				return false;
			}
		}

		public static bool UPvr_StopAudioReceiver()
		{
			try
			{
				System.UPvr_CallStaticMethod(volumejavaVrActivityClass, "Pvr_StopReceiver", Pvr_UnitySDKRender.Instance.activity);
				return true;
			}
			catch (Exception ex)
			{
				PLOG.E("startReceiver Error :" + ex.ToString());
				return false;
			}
		}

		public static int UPvr_GetMaxVolumeNumber()
		{
			int result = 0;
			try
			{
				System.UPvr_CallStaticMethod(ref result, javaSysActivityClass, "Pvr_GetMaxAudionumber");
			}
			catch (Exception ex)
			{
				PLOG.E(" Error :" + ex.ToString());
			}
			return result;
		}

		public static int UPvr_GetCurrentVolumeNumber()
		{
			int result = 0;
			try
			{
				System.UPvr_CallStaticMethod(ref result, javaSysActivityClass, "Pvr_GetAudionumber");
			}
			catch (Exception ex)
			{
				PLOG.E(" Error :" + ex.ToString());
			}
			return result;
		}

		public static bool UPvr_VolumeUp()
		{
			try
			{
				System.UPvr_CallStaticMethod(javaSysActivityClass, "Pvr_UpAudio");
				return true;
			}
			catch (Exception ex)
			{
				PLOG.E(" Error :" + ex.ToString());
				return false;
			}
		}

		public static bool UPvr_VolumeDown()
		{
			try
			{
				System.UPvr_CallStaticMethod(javaSysActivityClass, "Pvr_DownAudio");
				return true;
			}
			catch (Exception ex)
			{
				PLOG.E(" Error :" + ex.ToString());
				return false;
			}
		}

		public static bool UPvr_SetVolumeNum(int volume)
		{
			try
			{
				System.UPvr_CallStaticMethod(javaSysActivityClass, "Pvr_ChangeAudio", volume);
				return true;
			}
			catch (Exception ex)
			{
				PLOG.E(" Error :" + ex.ToString());
				return false;
			}
		}

		public static bool UPvr_SetAudio(string s)
		{
			return false;
		}

		public static bool UPvr_SetBattery(string s)
		{
			return false;
		}

		private static string getDevicePropForUser(DeviceCommand deviceid)
		{
			string result = "0";
			System.UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getDevicePropForUser", (int)deviceid);
			return result;
		}

		private static bool setDevicePropForUser(DeviceCommand deviceid, string number)
		{
			bool result = false;
			System.UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "setDevicePropForUser", (int)deviceid, number);
			return result;
		}
	}
}
namespace Pvr_UnitySDKAPI.Achievement
{
	public class Pvr_AchievementDefinition
	{
		public readonly AchievementType Type;

		public readonly string Name;

		public readonly int BitfieldLength;

		public readonly long Target;

		public readonly string Title;

		public readonly string Description;

		public readonly string UnlockedDescription;

		public readonly string UnlockedIcon;

		public readonly string LockedIcon;

		public readonly bool IsSecrect;

		public Pvr_AchievementDefinition(AndroidJavaObject msg)
		{
			Type = Pvr_AchievementAPI.pvr_AchievementDefinition_GetType(msg);
			Name = Pvr_AchievementAPI.pvr_AchievementDefinition_GetName(msg);
			BitfieldLength = Pvr_AchievementAPI.pvr_AchievementDefinition_GetBitfieldLength(msg);
			Target = Pvr_AchievementAPI.pvr_AchievementDefinition_GetTarget(msg);
			Title = Pvr_AchievementAPI.pvr_AchievementDefinition_GetTitle(msg);
			Description = Pvr_AchievementAPI.pvr_AchievementDefinition_GetDescription(msg);
			UnlockedDescription = Pvr_AchievementAPI.pvr_AchievementDefinition_GetUnlockedDescription(msg);
			UnlockedIcon = Pvr_AchievementAPI.pvr_AchievementDefinition_GetUnlockedIcon(msg);
			LockedIcon = Pvr_AchievementAPI.pvr_AchievementDefinition_GetLockedIcon(msg);
			IsSecrect = Pvr_AchievementAPI.pvr_AchievementDefinition_GetIsSecrect(msg);
		}
	}
	public class Pvr_AchievementDefinitionList : Pvr_DeserializableList<Pvr_AchievementDefinition>
	{
		public Pvr_AchievementDefinitionList(AndroidJavaObject msg)
		{
			int num = Pvr_AchievementAPI.pvr_AchievementDefinitionArray_GetSize(msg);
			data = new List<Pvr_AchievementDefinition>(num);
			for (int i = 0; i < num; i++)
			{
				data.Add(new Pvr_AchievementDefinition(Pvr_AchievementAPI.pvr_AchievementDefinitionArray_GetElement(msg, i)));
			}
			nextUrl = Pvr_AchievementAPI.pvr_AchievementDefinitionArray_GetNextUrl(msg);
		}
	}
	public class Pvr_AchievementProgress
	{
		public readonly string Bitfield;

		public readonly long Count;

		public readonly bool IsUnlocked;

		public readonly string Name;

		public readonly DateTime UnlockTime;

		public Pvr_AchievementProgress(AndroidJavaObject msg)
		{
			Bitfield = Pvr_AchievementAPI.pvr_AchievementProgress_GetBitfield(msg);
			Count = Pvr_AchievementAPI.pvr_AchievementProgress_GetCount(msg);
			IsUnlocked = Pvr_AchievementAPI.pvr_AchievementProgress_GetIsUnlocked(msg);
			Name = Pvr_AchievementAPI.pvr_AchievementProgress_GetName(msg);
			UnlockTime = Pvr_AchievementAPI.pvr_AchievementProgress_GetUnlockTime(msg);
		}
	}
	public class Pvr_AchievementProgressList : Pvr_DeserializableList<Pvr_AchievementProgress>
	{
		public Pvr_AchievementProgressList(AndroidJavaObject msg)
		{
			int num = Pvr_AchievementAPI.pvr_AchievementProgressArray_GetSize(msg);
			data = new List<Pvr_AchievementProgress>(num);
			for (int i = 0; i < num; i++)
			{
				data.Add(new Pvr_AchievementProgress(Pvr_AchievementAPI.pvr_AchievementProgressArray_GetElement(msg, i)));
			}
			nextUrl = Pvr_AchievementAPI.pvr_AchievementProgressArray_GetNextUrl(msg);
		}
	}
	public class Pvr_AchievementUpdate
	{
		public readonly bool JustUnlocked;

		public readonly string Name;

		public Pvr_AchievementUpdate(AndroidJavaObject msg)
		{
			JustUnlocked = Pvr_AchievementAPI.pvr_AchievementUpdate_GetJustUnlocked(msg);
			Name = Pvr_AchievementAPI.pvr_AchievementUpdate_GetName(msg);
		}
	}
	public static class Pvr_Callback
	{
		private class RequestCallback
		{
			private Pvr_Message.Callback messageCallback;

			public RequestCallback()
			{
			}

			public RequestCallback(Pvr_Message.Callback callback)
			{
				messageCallback = callback;
			}

			public virtual void HandleMessage(Pvr_Message msg)
			{
				if (messageCallback != null)
				{
					messageCallback(msg);
				}
			}
		}

		private sealed class RequestCallback<T> : RequestCallback
		{
			private Pvr_Message<T>.Callback callback;

			public RequestCallback(Pvr_Message<T>.Callback callback)
			{
				this.callback = callback;
			}

			public override void HandleMessage(Pvr_Message msg)
			{
				if (callback != null)
				{
					if (msg is Pvr_Message<T>)
					{
						callback((Pvr_Message<T>)msg);
					}
					else
					{
						UnityEngine.Debug.LogError("Unable to handle message: " + msg.GetType());
					}
				}
			}
		}

		private static Dictionary<long, Request> requestIDsToRequests = new Dictionary<long, Request>();

		private static Dictionary<Pvr_Message.MessageType, RequestCallback> notificationCallbacks = new Dictionary<Pvr_Message.MessageType, RequestCallback>();

		internal static void AddRequest(Request request)
		{
			if (request.RequestID <= 2)
			{
				long requestID = request.RequestID;
				if ((ulong)requestID <= 2uL)
				{
					switch (requestID)
					{
					case 0L:
						UnityEngine.Debug.LogError("An PARAM_INVALIDE error occurred. Request failed.");
						return;
					case 1L:
						UnityEngine.Debug.LogError("An NETWORK_INVALIDE error occurred. Request failed.");
						return;
					case 2L:
						UnityEngine.Debug.LogError("An NOT_INTIALIZE error occurred. Request failed.");
						return;
					}
				}
				UnityEngine.Debug.LogError("An unknown error occurred. Request failed.");
			}
			else
			{
				requestIDsToRequests[request.RequestID] = request;
			}
		}

		internal static void RunCallbacks()
		{
			while (true)
			{
				Pvr_Message pvr_Message = Pvr_Message.PopMessage();
				if (pvr_Message != null)
				{
					HandleMessage(pvr_Message);
					continue;
				}
				break;
			}
		}

		internal static void RunLimitedCallbacks(uint limit)
		{
			for (int i = 0; i < limit; i++)
			{
				Pvr_Message pvr_Message = Pvr_Message.PopMessage();
				if (pvr_Message != null)
				{
					HandleMessage(pvr_Message);
					continue;
				}
				break;
			}
		}

		internal static void OnApplicationQuit()
		{
			requestIDsToRequests.Clear();
			notificationCallbacks.Clear();
		}

		internal static void HandleMessage(Pvr_Message msg)
		{
			if (msg.RequestID != 0L && requestIDsToRequests.TryGetValue(msg.RequestID, out var value))
			{
				try
				{
					value.HandleMessage(msg);
					return;
				}
				finally
				{
					requestIDsToRequests.Remove(msg.RequestID);
				}
			}
			if (notificationCallbacks.TryGetValue(msg.Type, out var value2))
			{
				value2.HandleMessage(msg);
			}
		}
	}
	public class Pvr_CallbackRunner : MonoBehaviour
	{
		public bool IsPersistantBetweenSceneLoads = true;

		private void Awake()
		{
			if (UnityEngine.Object.FindObjectOfType<Pvr_CallbackRunner>() != this)
			{
				UnityEngine.Debug.LogWarning("You only need one instance of CallbackRunner");
			}
			if (IsPersistantBetweenSceneLoads)
			{
				UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
			}
		}

		private void Update()
		{
			Request.RunCallbacks();
		}

		private void OnApplicationQuit()
		{
			Pvr_Callback.OnApplicationQuit();
		}
	}
	public class Pvr_DeserializableList<T> : IList<T>, ICollection<T>, IEnumerable<T>, IEnumerable
	{
		protected List<T> data;

		protected string nextUrl;

		protected string previousUrl;

		public int Count => data.Count;

		bool ICollection<T>.IsReadOnly => ((ICollection<T>)data).IsReadOnly;

		public T this[int index]
		{
			get
			{
				return data[index];
			}
			set
			{
				data[index] = value;
			}
		}

		public bool HasNextPage => !string.IsNullOrEmpty(NextUrl);

		public bool HasPreviousPage => !string.IsNullOrEmpty(PreviousUrl);

		public string NextUrl => nextUrl;

		public string PreviousUrl => previousUrl;

		public int IndexOf(T obj)
		{
			return data.IndexOf(obj);
		}

		public void Add(T item)
		{
			data.Add(item);
		}

		public void Clear()
		{
			data.Clear();
		}

		public bool Contains(T item)
		{
			return data.Contains(item);
		}

		public void CopyTo(T[] array, int arrayIndex)
		{
			data.CopyTo(array, arrayIndex);
		}

		public IEnumerator<T> GetEnumerator()
		{
			return data.GetEnumerator();
		}

		public void Insert(int index, T item)
		{
			data.Insert(index, item);
		}

		public bool Remove(T item)
		{
			return data.Remove(item);
		}

		public void RemoveAt(int index)
		{
			data.RemoveAt(index);
		}

		private IEnumerator GetEnumerator1()
		{
			return GetEnumerator();
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator1();
		}
	}
	public abstract class Pvr_Message<T> : Pvr_Message
	{
		public new delegate void Callback(Pvr_Message<T> message);

		private T data;

		public T Data => data;

		public Pvr_Message(AndroidJavaObject msg)
			: base(msg)
		{
			if (!base.IsError)
			{
				data = GetDataFromMessage(msg);
			}
		}

		protected abstract T GetDataFromMessage(AndroidJavaObject msg);
	}
	public class Pvr_Message
	{
		public delegate void Callback(Pvr_Message message);

		public enum MessageType : uint
		{
			Unknown = 0u,
			Achievements_AddCount = 65495601u,
			Achievements_AddFields = 346693929u,
			Achievements_GetAllDefinitions = 64177549u,
			Achievements_GetAllProgress = 1335877149u,
			Achievements_GetDefinitionsByName = 1653670332u,
			Achievements_GetNextAchievementDefinitionArrayPage = 712888917u,
			Achievements_GetNextAchievementProgressArrayPage = 792913703u,
			Achievements_GetProgressByName = 354837425u,
			Achievements_Unlock = 1497156573u,
			Achievements_WriteAchievementProgress = 121027549u,
			Achievements_VerifyAccessToken = 53284924u
		}

		internal delegate Pvr_Message ExtraMessageTypesHandler(AndroidJavaObject messageHandle, MessageType message_type);

		private MessageType type;

		private long requestID;

		private Error error;

		public MessageType Type => type;

		public bool IsError => error != null;

		public long RequestID => requestID;

		internal static ExtraMessageTypesHandler HandleExtraMessageTypes { private get; set; }

		public Pvr_Message(AndroidJavaObject msg)
		{
			type = (MessageType)Pvr_AchievementAPI.pvr_Message_GetType(msg);
			bool num = Pvr_AchievementAPI.pvr_Message_IsError(msg);
			requestID = Pvr_AchievementAPI.pvr_Message_GetRequestID(msg);
			if (num)
			{
				error = new Error(Pvr_AchievementAPI.pvr_Error_GetCode(msg), Pvr_AchievementAPI.pvr_Error_GetMessage(msg), Pvr_AchievementAPI.pvr_Error_GetHttpCode(msg));
			}
			else if (AchievementCore.LogMessages)
			{
				string text = Pvr_AchievementAPI.pvr_Message_GetString(msg);
				if (text != null)
				{
					UnityEngine.Debug.Log(text);
				}
				else
				{
					UnityEngine.Debug.Log($"null message string {msg}");
				}
			}
		}

		public virtual Error GetError()
		{
			return error;
		}

		public virtual Pvr_AchievementDefinitionList GetAchievementDefinitions()
		{
			return null;
		}

		public virtual Pvr_AchievementProgressList GetAchievementProgressList()
		{
			return null;
		}

		public virtual Pvr_AchievementUpdate GetAchievementUpdate()
		{
			return null;
		}

		public virtual string GetString()
		{
			return null;
		}

		internal static Pvr_Message ParseMessageHandle(AndroidJavaObject messageHandle)
		{
			if (messageHandle == null)
			{
				return null;
			}
			Pvr_Message result = null;
			switch ((MessageType)Pvr_AchievementAPI.pvr_Message_GetType(messageHandle))
			{
			case MessageType.Achievements_GetAllDefinitions:
			case MessageType.Achievements_GetNextAchievementDefinitionArrayPage:
			case MessageType.Achievements_GetDefinitionsByName:
				result = new MessageWithAchievementDefinitions(messageHandle);
				break;
			case MessageType.Achievements_GetProgressByName:
			case MessageType.Achievements_GetNextAchievementProgressArrayPage:
			case MessageType.Achievements_GetAllProgress:
				result = new MessageWithAchievementProgressList(messageHandle);
				break;
			case MessageType.Achievements_VerifyAccessToken:
			case MessageType.Achievements_AddCount:
			case MessageType.Achievements_AddFields:
			case MessageType.Achievements_Unlock:
				result = new MessageWithAchievementUpdate(messageHandle);
				break;
			}
			return result;
		}

		public static Pvr_Message PopMessage()
		{
			return ParseMessageHandle(Pvr_AchievementAPI.PopMessage());
		}
	}
	public class MessageWithAchievementDefinitions : Pvr_Message<Pvr_AchievementDefinitionList>
	{
		public MessageWithAchievementDefinitions(AndroidJavaObject msg)
			: base(msg)
		{
		}

		public override Pvr_AchievementDefinitionList GetAchievementDefinitions()
		{
			return base.Data;
		}

		protected override Pvr_AchievementDefinitionList GetDataFromMessage(AndroidJavaObject msg)
		{
			return new Pvr_AchievementDefinitionList(msg);
		}
	}
	public class MessageWithAchievementProgressList : Pvr_Message<Pvr_AchievementProgressList>
	{
		public MessageWithAchievementProgressList(AndroidJavaObject msg)
			: base(msg)
		{
		}

		public override Pvr_AchievementProgressList GetAchievementProgressList()
		{
			return base.Data;
		}

		protected override Pvr_AchievementProgressList GetDataFromMessage(AndroidJavaObject msg)
		{
			return new Pvr_AchievementProgressList(msg);
		}
	}
	public class MessageWithAchievementUpdate : Pvr_Message<Pvr_AchievementUpdate>
	{
		public MessageWithAchievementUpdate(AndroidJavaObject msg)
			: base(msg)
		{
		}

		public override Pvr_AchievementUpdate GetAchievementUpdate()
		{
			return base.Data;
		}

		protected override Pvr_AchievementUpdate GetDataFromMessage(AndroidJavaObject msg)
		{
			return new Pvr_AchievementUpdate(msg);
		}
	}
	public class MessageWithString : Pvr_Message<string>
	{
		public MessageWithString(AndroidJavaObject msg)
			: base(msg)
		{
		}

		public override string GetString()
		{
			return base.Data;
		}

		protected override string GetDataFromMessage(AndroidJavaObject msg)
		{
			return Pvr_AchievementAPI.pvr_Message_GetString(msg);
		}
	}
	public class Error
	{
		public readonly int Code;

		public readonly int HttpCode;

		public readonly string Message;

		public Error(int code, string message, int httpCode)
		{
			Message = message;
			Code = code;
			HttpCode = httpCode;
		}
	}
	public sealed class AchievementCore
	{
		private static bool IsPlatformInitialized = true;

		public static bool LogMessages = false;

		public static bool IsInitialized()
		{
			return IsPlatformInitialized;
		}

		public static void Initialize()
		{
		}

		public static void RegisterNetwork()
		{
			Pvr_AchievementAPI.RegisterNetwork();
		}

		public static void UnRegisterNetwork()
		{
			Pvr_AchievementAPI.UnRegisterNetwork();
		}
	}
	public static class Achievements
	{
		public static Pvr_Request<Pvr_AchievementUpdate> Init()
		{
			if (AchievementCore.IsInitialized())
			{
				return new Pvr_Request<Pvr_AchievementUpdate>(Pvr_AchievementAPI.Init());
			}
			return null;
		}

		public static Pvr_Request<Pvr_AchievementUpdate> AddCount(string name, long count)
		{
			if (AchievementCore.IsInitialized())
			{
				return new Pvr_Request<Pvr_AchievementUpdate>(Pvr_AchievementAPI.pvr_Achievements_AddCount(name, count));
			}
			return null;
		}

		public static Pvr_Request<Pvr_AchievementUpdate> AddFields(string name, string fields)
		{
			if (AchievementCore.IsInitialized())
			{
				return new Pvr_Request<Pvr_AchievementUpdate>(Pvr_AchievementAPI.pvr_Achievements_AddFields(name, fields));
			}
			return null;
		}

		public static Pvr_Request<Pvr_AchievementDefinitionList> GetAllDefinitions()
		{
			if (AchievementCore.IsInitialized())
			{
				return new Pvr_Request<Pvr_AchievementDefinitionList>(Pvr_AchievementAPI.pvr_Achievements_GetAllDefinitions());
			}
			return null;
		}

		public static Pvr_Request<Pvr_AchievementProgressList> GetAllProgress()
		{
			if (AchievementCore.IsInitialized())
			{
				return new Pvr_Request<Pvr_AchievementProgressList>(Pvr_AchievementAPI.pvr_Achievements_GetAllProgress());
			}
			return null;
		}

		public static Pvr_Request<Pvr_AchievementDefinitionList> GetDefinitionsByName(string[] names)
		{
			if (AchievementCore.IsInitialized())
			{
				return new Pvr_Request<Pvr_AchievementDefinitionList>(Pvr_AchievementAPI.pvr_Achievements_GetDefinitionsByName(names, (names != null) ? names.Length : 0));
			}
			return null;
		}

		public static Pvr_Request<Pvr_AchievementProgressList> GetProgressByName(string[] names)
		{
			if (AchievementCore.IsInitialized())
			{
				return new Pvr_Request<Pvr_AchievementProgressList>(Pvr_AchievementAPI.pvr_Achievements_GetProgressByName(names, (names != null) ? names.Length : 0));
			}
			return null;
		}

		public static Pvr_Request<Pvr_AchievementUpdate> Unlock(string name)
		{
			if (AchievementCore.IsInitialized())
			{
				return new Pvr_Request<Pvr_AchievementUpdate>(Pvr_AchievementAPI.pvr_Achievements_Unlock(name));
			}
			return null;
		}

		public static Pvr_Request<Pvr_AchievementDefinitionList> GetNextAchievementDefinitionListPage(Pvr_AchievementDefinitionList list)
		{
			if (!list.HasNextPage)
			{
				UnityEngine.Debug.LogWarning("Platform.GetNextAchievementDefinitionListPage: List has no next page");
				return null;
			}
			if (AchievementCore.IsInitialized())
			{
				return new Pvr_Request<Pvr_AchievementDefinitionList>(Pvr_AchievementAPI.pvr_HTTP_GetWithMessageType(list.NextUrl, Pvr_Message.MessageType.Achievements_GetNextAchievementDefinitionArrayPage));
			}
			return null;
		}

		public static Pvr_Request<Pvr_AchievementProgressList> GetNextAchievementProgressListPage(Pvr_AchievementProgressList list)
		{
			if (!list.HasNextPage)
			{
				UnityEngine.Debug.LogWarning("Platform.GetNextAchievementProgressListPage: List has no next page");
				return null;
			}
			if (AchievementCore.IsInitialized())
			{
				return new Pvr_Request<Pvr_AchievementProgressList>(Pvr_AchievementAPI.pvr_HTTP_GetWithMessageType(list.NextUrl, Pvr_Message.MessageType.Achievements_GetNextAchievementProgressArrayPage));
			}
			return null;
		}
	}
	public enum AchievementType
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("SIMPLE")]
		Simple,
		[Description("BITFIELD")]
		Bitfield,
		[Description("COUNT")]
		Count
	}
	public class Pvr_AchievementAPI
	{
		private static AndroidJavaClass achievementAPI = new AndroidJavaClass("com.pico.achievenment.AchievementAPI");

		private static AndroidJavaClass definitionArrayHandle = new AndroidJavaClass("com.picovr.achievement.utils.pvrAchievementDefinitionArrayHandle");

		private static AndroidJavaClass definitionHandle = new AndroidJavaClass("com.picovr.achievement.utils.pvrAchievementDefinitionHandle");

		private static AndroidJavaClass progressArrayHandle = new AndroidJavaClass("com.picovr.achievement.utils.pvrAchievementProgressArrayHandle");

		private static AndroidJavaClass progressHandle = new AndroidJavaClass("com.picovr.achievement.utils.pvrAchievementProgressHandle");

		private static AndroidJavaClass updateHandle = new AndroidJavaClass("com.picovr.achievement.utils.pvrAchievementUpdateHandle");

		private static AndroidJavaObject errorHandle = new AndroidJavaObject("com.picovr.achievement.utils.pvrAchievementErrorHandle");

		private static AndroidJavaObject unityInterface = new AndroidJavaObject("com.pico.loginpaysdk.UnityInterface");

		private static string openId;

		private static string accessToken;

		private static string appId = Pvr_UnitySDKPlatformSetting.Instance.appID;

		internal static long Init()
		{
			AndroidJavaObject @static = new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
			unityInterface.Call("init", @static);
			unityInterface.Call("authSSO");
			AndroidJavaObject androidJavaObject = new AndroidJavaClass("com.pico.loginpaysdk.utils.PicoAccessTokenKeeper").CallStatic<AndroidJavaObject>("readAccessToken", new object[1] { @static });
			accessToken = androidJavaObject.Call<string>("getAccessToken", Array.Empty<object>());
			openId = androidJavaObject.Call<string>("getOpenId", Array.Empty<object>());
			return achievementAPI.CallStatic<long>("init", new object[3] { accessToken, openId, @static });
		}

		internal static void RegisterNetwork()
		{
			AndroidJavaObject @static = new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
			achievementAPI.CallStatic("registerNetwork", @static);
		}

		internal static void UnRegisterNetwork()
		{
			achievementAPI.CallStatic("unregisterNetwork");
		}

		internal static AndroidJavaObject PopMessage()
		{
			return achievementAPI.CallStatic<AndroidJavaObject>("pvr_PopMessage", Array.Empty<object>());
		}

		internal static string pvr_Error_GetMessage(AndroidJavaObject popMessage)
		{
			return errorHandle.CallStatic<string>("pvr_Error_GetMessage", new object[1] { popMessage });
		}

		internal static int pvr_Error_GetHttpCode(AndroidJavaObject popMessage)
		{
			return errorHandle.CallStatic<int>("pvr_Error_GetHttpCode", new object[1] { popMessage });
		}

		internal static int pvr_Error_GetCode(AndroidJavaObject popMessage)
		{
			return errorHandle.CallStatic<int>("pvr_Error_GetCode", new object[1] { popMessage });
		}

		internal static long pvr_Achievements_AddCount(string name, long count)
		{
			return achievementAPI.CallStatic<long>("pvr_Achievements_AddCount", new object[3] { name, count, accessToken });
		}

		internal static long pvr_Achievements_AddFields(string name, string fields)
		{
			return achievementAPI.CallStatic<long>("pvr_Achievements_AddFields", new object[3] { name, fields, accessToken });
		}

		internal static long pvr_Achievements_GetAllDefinitions()
		{
			AndroidJavaObject @static = new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
			return achievementAPI.CallStatic<long>("pvr_Achievements_GetAllDefinitions", new object[2] { appId, @static });
		}

		internal static long pvr_Achievements_GetAllProgress()
		{
			return achievementAPI.CallStatic<long>("pvr_Achievements_GetAllProgress", new object[1] { accessToken });
		}

		internal static long pvr_Achievements_GetDefinitionsByName(string[] names, int v)
		{
			AndroidJavaObject @static = new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
			return achievementAPI.CallStatic<long>("pvr_Achievements_GetDefinitionsByName", new object[2] { names, @static });
		}

		internal static long pvr_Achievements_GetProgressByName(string[] names, int v)
		{
			return achievementAPI.CallStatic<long>("pvr_Achievements_GetProgressByName", new object[2] { names, accessToken });
		}

		internal static long pvr_Achievements_Unlock(string name)
		{
			return achievementAPI.CallStatic<long>("pvr_Achievements_Unlock", new object[2] { name, accessToken });
		}

		internal static long pvr_HTTP_GetWithMessageType(string nextUrl, Pvr_Message.MessageType messageType)
		{
			long result = 0L;
			switch (messageType)
			{
			case Pvr_Message.MessageType.Achievements_GetNextAchievementDefinitionArrayPage:
			{
				AndroidJavaObject @static = new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
				result = achievementAPI.CallStatic<long>("pvr_Achievements_GetAllDefinitionsByUrl", new object[2] { nextUrl, @static });
				break;
			}
			case Pvr_Message.MessageType.Achievements_GetNextAchievementProgressArrayPage:
				result = achievementAPI.CallStatic<long>("pvr_Achievements_GetAllProgressByUrl", new object[1] { nextUrl });
				break;
			}
			return result;
		}

		internal static long pvr_Message_GetType(AndroidJavaObject popMessage)
		{
			return popMessage.Call<AndroidJavaObject>("getHandleType", Array.Empty<object>()).Call<long>("getIndex", Array.Empty<object>());
		}

		internal static bool pvr_Message_IsError(AndroidJavaObject popMessage)
		{
			return popMessage.Call<bool>("isMessage_IsError", Array.Empty<object>());
		}

		internal static long pvr_Message_GetRequestID(AndroidJavaObject popMessage)
		{
			return popMessage.Call<long>("getId", Array.Empty<object>());
		}

		internal static string pvr_Message_GetString(AndroidJavaObject popMessage)
		{
			return popMessage.Call<string>("getContent", Array.Empty<object>());
		}

		internal static bool pvr_AchievementUpdate_GetJustUnlocked(AndroidJavaObject popMessage)
		{
			return updateHandle.CallStatic<bool>("pvr_AchievementUpdate_GetJustUnlocked", new object[1] { popMessage });
		}

		internal static string pvr_AchievementUpdate_GetName(AndroidJavaObject popMessage)
		{
			return updateHandle.CallStatic<string>("pvr_AchievementUpdate_GetName", new object[1] { popMessage });
		}

		internal static int pvr_AchievementProgressArray_GetSize(AndroidJavaObject msg)
		{
			return progressArrayHandle.CallStatic<int>("pvr_AchievementProgressArray_GetSize", new object[1] { msg });
		}

		internal static AndroidJavaObject pvr_AchievementProgressArray_GetElement(AndroidJavaObject msg, int index)
		{
			return progressArrayHandle.CallStatic<AndroidJavaObject>("pvr_AchievementProgressArray_GetElement", new object[2] { msg, index });
		}

		internal static string pvr_AchievementProgressArray_GetNextUrl(AndroidJavaObject msg)
		{
			return progressArrayHandle.CallStatic<string>("pvr_AchievementProgressArray_GetNextUrl", new object[1] { msg });
		}

		internal static string pvr_AchievementProgress_GetBitfield(AndroidJavaObject msg)
		{
			return progressHandle.CallStatic<string>("pvr_AchievementProgress_GetBitfield", new object[1] { msg });
		}

		internal static long pvr_AchievementProgress_GetCount(AndroidJavaObject msg)
		{
			return progressHandle.CallStatic<long>("pvr_AchievementProgress_GetCount", new object[1] { msg });
		}

		internal static bool pvr_AchievementProgress_GetIsUnlocked(AndroidJavaObject msg)
		{
			return progressHandle.CallStatic<bool>("pvr_AchievementProgress_GetIsUnlocked", new object[1] { msg });
		}

		internal static string pvr_AchievementProgress_GetName(AndroidJavaObject msg)
		{
			return progressHandle.CallStatic<string>("pvr_AchievementProgress_GetName", new object[1] { msg });
		}

		internal static DateTime pvr_AchievementProgress_GetUnlockTime(AndroidJavaObject msg)
		{
			new DateTime(1970, 1, 1, 0, 0, 0, 0);
			return DateTimeFromNative(progressHandle.CallStatic<long>("pvr_AchievementProgress_GetUnlockTime", new object[1] { msg }));
		}

		internal static DateTime DateTimeFromNative(long seconds_since_the_one_true_epoch)
		{
			return new DateTime(1970, 1, 1, 0, 0, 0, 0).AddSeconds(seconds_since_the_one_true_epoch).ToLocalTime();
		}

		internal static int pvr_AchievementDefinitionArray_GetSize(AndroidJavaObject msg)
		{
			return definitionArrayHandle.CallStatic<int>("pvr_AchievementDefinitionArray_GetSize", new object[1] { msg });
		}

		internal static AndroidJavaObject pvr_AchievementDefinitionArray_GetElement(AndroidJavaObject msg, int index)
		{
			return definitionArrayHandle.CallStatic<AndroidJavaObject>("pvr_AchievementDefinitionArray_GetElement", new object[2] { msg, index });
		}

		internal static string pvr_AchievementDefinitionArray_GetNextUrl(AndroidJavaObject msg)
		{
			return definitionArrayHandle.CallStatic<string>("pvr_AchievementDefinitionArray_GetNextUrl", new object[1] { msg });
		}

		internal static AchievementType pvr_AchievementDefinition_GetType(AndroidJavaObject msg)
		{
			return (AchievementType)definitionHandle.CallStatic<AndroidJavaObject>("pvr_AchievementDefinition_GetType", new object[1] { msg }).Call<int>("getIndex", Array.Empty<object>());
		}

		internal static string pvr_AchievementDefinition_GetName(AndroidJavaObject msg)
		{
			return definitionHandle.CallStatic<string>("pvr_AchievementDefinition_GetName", new object[1] { msg });
		}

		internal static int pvr_AchievementDefinition_GetBitfieldLength(AndroidJavaObject msg)
		{
			return definitionHandle.CallStatic<int>("pvr_AchievementDefinition_GetBitfieldLength", new object[1] { msg });
		}

		internal static long pvr_AchievementDefinition_GetTarget(AndroidJavaObject msg)
		{
			return definitionHandle.CallStatic<long>("pvr_AchievementDefinition_GetTarget", new object[1] { msg });
		}

		internal static string pvr_AchievementDefinition_GetTitle(AndroidJavaObject msg)
		{
			return definitionHandle.CallStatic<string>("pvr_AchievementDefinition_GetTitle", new object[1] { msg });
		}

		internal static string pvr_AchievementDefinition_GetUnlockedDescription(AndroidJavaObject msg)
		{
			return definitionHandle.CallStatic<string>("pvr_AchievementDefinition_GetUnlocked_description", new object[1] { msg });
		}

		internal static string pvr_AchievementDefinition_GetLockedIcon(AndroidJavaObject msg)
		{
			return definitionHandle.CallStatic<string>("pvr_AchievementDefinition_GetLocked_image", new object[1] { msg });
		}

		internal static bool pvr_AchievementDefinition_GetIsSecrect(AndroidJavaObject msg)
		{
			return definitionHandle.CallStatic<bool>("pvr_AchievementDefinition_GetIs_secret", new object[1] { msg });
		}

		internal static string pvr_AchievementDefinition_GetUnlockedIcon(AndroidJavaObject msg)
		{
			return definitionHandle.CallStatic<string>("pvr_AchievementDefinition_GetUnlocked_image", new object[1] { msg });
		}

		internal static string pvr_AchievementDefinition_GetDescription(AndroidJavaObject msg)
		{
			return definitionHandle.CallStatic<string>("pvr_AchievementDefinition_GetDescription", new object[1] { msg });
		}
	}
	public sealed class Pvr_Request<T> : Request
	{
		private Pvr_Message<T>.Callback callback_;

		public Pvr_Request(long requestID)
			: base(requestID)
		{
		}

		public Pvr_Request<T> OnComplete(Pvr_Message<T>.Callback callback)
		{
			if (callback_ != null)
			{
				throw new UnityException("Attempted to attach multiple handlers to a Request.  This is not allowed.");
			}
			callback_ = callback;
			Pvr_Callback.AddRequest(this);
			return this;
		}

		public override void HandleMessage(Pvr_Message msg)
		{
			if (!(msg is Pvr_Message<T>))
			{
				UnityEngine.Debug.LogError("Unable to handle message: " + msg.GetType());
				return;
			}
			if (callback_ != null)
			{
				callback_((Pvr_Message<T>)msg);
				return;
			}
			throw new UnityException("Request with no handler.  This should never happen.");
		}
	}
	public class Request
	{
		private Pvr_Message.Callback callback_;

		public long RequestID { get; set; }

		public Request(long requestID)
		{
			RequestID = requestID;
		}

		public Request OnComplete(Pvr_Message.Callback callback)
		{
			callback_ = callback;
			Pvr_Callback.AddRequest(this);
			return this;
		}

		public virtual void HandleMessage(Pvr_Message msg)
		{
			if (callback_ != null)
			{
				callback_(msg);
				return;
			}
			throw new UnityException("Request with no handler.  This should never happen.");
		}

		public static void RunCallbacks(uint limit = 0u)
		{
			if (limit == 0)
			{
				Pvr_Callback.RunCallbacks();
			}
			else
			{
				Pvr_Callback.RunLimitedCallbacks(limit);
			}
		}
	}
}
namespace Oculus.Spatializer.Propagation
{
	public enum FaceType : uint
	{
		TRIANGLES,
		QUADS
	}
	public enum MaterialProperty : uint
	{
		ABSORPTION,
		TRANSMISSION,
		SCATTERING
	}
	[StructLayout(LayoutKind.Sequential, Pack = 1)]
	public struct MeshGroup
	{
		public UIntPtr indexOffset;

		public UIntPtr faceCount;

		[MarshalAs(UnmanagedType.U4)]
		public FaceType faceType;

		public IntPtr material;
	}
}
namespace OVR
{
	public class TestScript : MonoBehaviour
	{
		[InspectorNote("Sound Setup", "Press '1' to play testSound1 and '2' to play testSound2")]
		public SoundFXRef testSound1;

		public SoundFXRef testSound2;

		private void Start()
		{
		}

		private void Update()
		{
			if (Input.GetKeyDown(KeyCode.Alpha1))
			{
				testSound1.PlaySoundAt(base.transform.position);
			}
			if (Input.GetKeyDown(KeyCode.Alpha2))
			{
				testSound2.PlaySoundAt(new Vector3(5f, 0f, 0f));
			}
		}
	}
	public class AmbienceEmitter : MonoBehaviour
	{
		public SoundFXRef[] ambientSounds = new SoundFXRef[0];

		public bool autoActivate = true;

		[Tooltip("Automatically play the sound randomly again when checked.  Should be OFF for looping sounds")]
		public bool autoRetrigger = true;

		[MinMax(2f, 4f, 0.1f, 10f)]
		public Vector2 randomRetriggerDelaySecs = new Vector2(2f, 4f);

		[Tooltip("If defined, the sounds will randomly play from these transform positions, otherwise the sound will play from this transform")]
		public Transform[] playPositions = new Transform[0];

		private bool activated;

		private int playingIdx = -1;

		private float nextPlayTime;

		private float fadeTime = 0.25f;

		private int lastPosIdx = -1;

		private void Awake()
		{
			if (autoActivate)
			{
				activated = true;
				nextPlayTime = Time.time + UnityEngine.Random.Range(randomRetriggerDelaySecs.x, randomRetriggerDelaySecs.y);
			}
			Transform[] array = playPositions;
			for (int i = 0; i < array.Length; i++)
			{
				if (array[i] == null)
				{
					UnityEngine.Debug.LogWarning("[AmbienceEmitter] Invalid play positions in " + base.name);
					playPositions = new Transform[0];
					break;
				}
			}
		}

		private void Update()
		{
			if (activated && (playingIdx == -1 || autoRetrigger) && Time.time >= nextPlayTime)
			{
				Play();
				if (!autoRetrigger)
				{
					activated = false;
				}
			}
		}

		public void OnTriggerEnter(Collider col)
		{
			activated = !activated;
		}

		public void Play()
		{
			Transform transform = base.transform;
			if (playPositions.Length != 0)
			{
				int num = UnityEngine.Random.Range(0, playPositions.Length);
				while (playPositions.Length > 1 && num == lastPosIdx)
				{
					num = UnityEngine.Random.Range(0, playPositions.Length);
				}
				transform = playPositions[num];
				lastPosIdx = num;
			}
			playingIdx = ambientSounds[UnityEngine.Random.Range(0, ambientSounds.Length)].PlaySoundAt(transform.position);
			if (playingIdx != -1)
			{
				AudioManager.FadeInSound(playingIdx, fadeTime);
				nextPlayTime = Time.time + UnityEngine.Random.Range(randomRetriggerDelaySecs.x, randomRetriggerDelaySecs.y);
			}
		}

		public void EnableEmitter(bool enable)
		{
			activated = enable;
			if (enable)
			{
				Play();
			}
			else if (playingIdx != -1)
			{
				AudioManager.FadeOutSound(playingIdx, fadeTime);
			}
		}
	}
	public enum PreloadSounds
	{
		Default,
		Preload,
		ManualPreload
	}
	public enum Fade
	{
		In,
		Out
	}
	[Serializable]
	public class SoundGroup
	{
		public string name = string.Empty;

		public SoundFX[] soundList = new SoundFX[0];

		public AudioMixerGroup mixerGroup;

		[Range(0f, 64f)]
		public int maxPlayingSounds;

		public PreloadSounds preloadAudio;

		public float volumeOverride = 1f;

		[HideInInspector]
		public int playingSoundCount;

		public SoundGroup(string name)
		{
			this.name = name;
		}

		public SoundGroup()
		{
			mixerGroup = null;
			maxPlayingSounds = 0;
			preloadAudio = PreloadSounds.Default;
			volumeOverride = 1f;
		}

		public void IncrementPlayCount()
		{
			playingSoundCount = Mathf.Clamp(++playingSoundCount, 0, maxPlayingSounds);
		}

		public void DecrementPlayCount()
		{
			playingSoundCount = Mathf.Clamp(--playingSoundCount, 0, maxPlayingSounds);
		}

		public bool CanPlaySound()
		{
			if (maxPlayingSounds != 0)
			{
				return playingSoundCount < maxPlayingSounds;
			}
			return true;
		}
	}
	public class AudioManager : MonoBehaviour
	{
		public enum Fade
		{
			In,
			Out
		}

		[Tooltip("Make the audio manager persistent across all scene loads")]
		public bool makePersistent = true;

		[Tooltip("Enable the OSP audio plugin features")]
		public bool enableSpatializedAudio = true;

		[Tooltip("Always play spatialized sounds with no reflections (Default)")]
		public bool enableSpatializedFastOverride;

		[Tooltip("The audio mixer asset used for snapshot blends, etc.")]
		public AudioMixer audioMixer;

		[Tooltip("The audio mixer group used for the pooled emitters")]
		public AudioMixerGroup defaultMixerGroup;

		[Tooltip("The audio mixer group used for the reserved pool emitter")]
		public AudioMixerGroup reservedMixerGroup;

		[Tooltip("The audio mixer group used for voice chat")]
		public AudioMixerGroup voiceChatMixerGroup;

		[Tooltip("Log all PlaySound calls to the Unity console")]
		public bool verboseLogging;

		[Tooltip("Maximum sound emitters")]
		public int maxSoundEmitters = 32;

		[Tooltip("Default volume for all sounds modulated by individual sound FX volumes")]
		public float volumeSoundFX = 1f;

		[Tooltip("Sound FX fade time")]
		public float soundFxFadeSecs = 1f;

		public float audioMinFallOffDistance = 1f;

		public float audioMaxFallOffDistance = 25f;

		public SoundGroup[] soundGroupings = new SoundGroup[0];

		private Dictionary<string, SoundFX> soundFXCache;

		private static AudioManager theAudioManager = null;

		private static FastList<string> names = new FastList<string>();

		private static string[] defaultSound = new string[1] { "Default Sound" };

		private static SoundFX nullSound = new SoundFX();

		private static bool hideWarnings = false;

		private float audioMaxFallOffDistanceSqr = 625f;

		private SoundEmitter[] soundEmitters;

		private FastList<SoundEmitter> playingEmitters = new FastList<SoundEmitter>();

		private FastList<SoundEmitter> nextFreeEmitters = new FastList<SoundEmitter>();

		private MixerSnapshot currentSnapshot;

		private static GameObject soundEmitterParent = null;

		private static Transform staticListenerPosition = null;

		private static bool showPlayingEmitterCount = false;

		private static bool forceShowEmitterCount = false;

		private static bool soundEnabled = true;

		private static readonly AnimationCurve defaultReverbZoneMix = new AnimationCurve(new Keyframe(0f, 1f), new Keyframe(1f, 1f));

		public static bool enableSpatialization
		{
			get
			{
				if (!(theAudioManager != null))
				{
					return false;
				}
				return theAudioManager.enableSpatializedAudio;
			}
		}

		public static AudioManager Instance => theAudioManager;

		public static float NearFallOff => theAudioManager.audioMinFallOffDistance;

		public static float FarFallOff => theAudioManager.audioMaxFallOffDistance;

		public static AudioMixerGroup EmitterGroup => theAudioManager.defaultMixerGroup;

		public static AudioMixerGroup ReservedGroup => theAudioManager.reservedMixerGroup;

		public static AudioMixerGroup VoipGroup => theAudioManager.voiceChatMixerGroup;

		public static bool SoundEnabled => soundEnabled;

		private void Awake()
		{
			Init();
		}

		private void OnDestroy()
		{
			if (theAudioManager == this && soundEmitterParent != null)
			{
				UnityEngine.Object.Destroy(soundEmitterParent);
			}
		}

		private void Init()
		{
			if (theAudioManager != null)
			{
				if (UnityEngine.Application.isPlaying && theAudioManager != this)
				{
					base.enabled = false;
				}
				return;
			}
			theAudioManager = this;
			nullSound.name = "Default Sound";
			RebuildSoundFXCache();
			if (UnityEngine.Application.isPlaying)
			{
				InitializeSoundSystem();
				if (makePersistent && base.transform.parent == null)
				{
					UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
				}
			}
		}

		private void Update()
		{
			UpdateFreeEmitters();
		}

		private void RebuildSoundFXCache()
		{
			int num = 0;
			for (int i = 0; i < soundGroupings.Length; i++)
			{
				num += soundGroupings[i].soundList.Length;
			}
			soundFXCache = new Dictionary<string, SoundFX>(num + 1);
			soundFXCache.Add(nullSound.name, nullSound);
			for (int j = 0; j < soundGroupings.Length; j++)
			{
				for (int k = 0; k < soundGroupings[j].soundList.Length; k++)
				{
					if (soundFXCache.ContainsKey(soundGroupings[j].soundList[k].name))
					{
						UnityEngine.Debug.LogError("ERROR: Duplicate Sound FX name in the audio manager: '" + soundGroupings[j].name + "' > '" + soundGroupings[j].soundList[k].name + "'");
					}
					else
					{
						soundGroupings[j].soundList[k].Group = soundGroupings[j];
						soundFXCache.Add(soundGroupings[j].soundList[k].name, soundGroupings[j].soundList[k]);
					}
				}
				soundGroupings[j].playingSoundCount = 0;
			}
		}

		public static SoundFX FindSoundFX(string name, bool rebuildCache = false)
		{
			if (string.IsNullOrEmpty(name))
			{
				return nullSound;
			}
			if (rebuildCache)
			{
				theAudioManager.RebuildSoundFXCache();
			}
			if (!theAudioManager.soundFXCache.ContainsKey(name))
			{
				return nullSound;
			}
			return theAudioManager.soundFXCache[name];
		}

		private static bool FindAudioManager()
		{
			GameObject gameObject = GameObject.Find("AudioManager");
			if (gameObject == null || gameObject.GetComponent<AudioManager>() == null)
			{
				if (!hideWarnings)
				{
					UnityEngine.Debug.LogError("[ERROR] AudioManager object missing from hierarchy!");
					hideWarnings = true;
				}
				return false;
			}
			gameObject.GetComponent<AudioManager>().Init();
			return true;
		}

		public static GameObject GetGameObject()
		{
			if (theAudioManager == null && !FindAudioManager())
			{
				return null;
			}
			return theAudioManager.gameObject;
		}

		public static string NameMinusGroup(string name)
		{
			if (name.IndexOf("/") > -1)
			{
				return name.Substring(name.IndexOf("/") + 1);
			}
			return name;
		}

		public static string[] GetSoundFXNames(string currentValue, out int currentIdx)
		{
			currentIdx = 0;
			names.Clear();
			if (theAudioManager == null && !FindAudioManager())
			{
				return defaultSound;
			}
			names.Add(nullSound.name);
			for (int i = 0; i < theAudioManager.soundGroupings.Length; i++)
			{
				for (int j = 0; j < theAudioManager.soundGroupings[i].soundList.Length; j++)
				{
					if (string.Compare(currentValue, theAudioManager.soundGroupings[i].soundList[j].name, ignoreCase: true) == 0)
					{
						currentIdx = names.Count;
					}
					names.Add(theAudioManager.soundGroupings[i].name + "/" + theAudioManager.soundGroupings[i].soundList[j].name);
				}
			}
			return names.ToArray();
		}

		private static int CalculateMaxEmittersSize()
		{
			return theAudioManager.maxSoundEmitters + 1;
		}

		private static bool ValidateEmitterIndex(int index)
		{
			if (index > -1)
			{
				return index < CalculateMaxEmittersSize();
			}
			return false;
		}

		private void InitializeSoundSystem()
		{
			int bufferLength = 960;
			int numBuffers = 4;
			AudioSettings.GetDSPBufferSize(out bufferLength, out numBuffers);
			if (UnityEngine.Application.isPlaying)
			{
				UnityEngine.Debug.Log("[AudioManager] Audio Sample Rate: " + AudioSettings.outputSampleRate);
				UnityEngine.Debug.Log("[AudioManager] Audio Buffer Length: " + bufferLength + " Size: " + numBuffers);
			}
			AudioListener audioListener = UnityEngine.Object.FindObjectOfType<AudioListener>();
			if (audioListener == null)
			{
				UnityEngine.Debug.LogError("[AudioManager] Missing AudioListener object!  Add one to the scene.");
			}
			else
			{
				staticListenerPosition = audioListener.transform;
			}
			soundEmitters = new SoundEmitter[CalculateMaxEmittersSize()];
			soundEmitterParent = GameObject.Find("__SoundEmitters__");
			if (soundEmitterParent != null)
			{
				UnityEngine.Object.Destroy(soundEmitterParent);
			}
			soundEmitterParent = new GameObject("__SoundEmitters__");
			for (int i = 0; i < CalculateMaxEmittersSize(); i++)
			{
				GameObject gameObject = new GameObject("SoundEmitter_" + i);
				gameObject.transform.parent = soundEmitterParent.transform;
				gameObject.transform.position = Vector3.zero;
				gameObject.hideFlags = HideFlags.DontSaveInEditor;
				soundEmitters[i] = gameObject.AddComponent<SoundEmitter>();
				soundEmitters[i].SetDefaultParent(soundEmitterParent.transform);
				soundEmitters[i].SetChannel(i);
				soundEmitters[i].Stop();
				soundEmitters[i].originalIdx = i;
			}
			ResetFreeEmitters();
			soundEmitterParent.hideFlags = HideFlags.DontSaveInEditor;
			audioMaxFallOffDistanceSqr = audioMaxFallOffDistance * audioMaxFallOffDistance;
		}

		private void UpdateFreeEmitters()
		{
			if (verboseLogging)
			{
				if (Input.GetKeyDown(KeyCode.A))
				{
					forceShowEmitterCount = !forceShowEmitterCount;
				}
				if (forceShowEmitterCount)
				{
					showPlayingEmitterCount = true;
				}
			}
			int num = 0;
			int num2 = 0;
			int num3 = 0;
			int num4 = 0;
			int num5 = 0;
			int num6 = 0;
			int num7 = 0;
			while (num7 < playingEmitters.size)
			{
				if (playingEmitters[num7] == null)
				{
					UnityEngine.Debug.LogError("[AudioManager] ERROR: playingEmitters list had a null emitter! Something nuked a sound emitter!!!");
					playingEmitters.RemoveAtFast(num7);
					return;
				}
				if (!playingEmitters[num7].IsPlaying())
				{
					if (verboseLogging && nextFreeEmitters.Contains(playingEmitters[num7]))
					{
						UnityEngine.Debug.LogError("[AudioManager] ERROR: playing sound emitter already in the free emitters list!");
					}
					playingEmitters[num7].Stop();
					nextFreeEmitters.Add(playingEmitters[num7]);
					playingEmitters.RemoveAtFast(num7);
					continue;
				}
				if (verboseLogging && showPlayingEmitterCount)
				{
					num++;
					switch (playingEmitters[num7].priority)
					{
					case SoundPriority.VeryLow:
						num2++;
						break;
					case SoundPriority.Low:
						num3++;
						break;
					case SoundPriority.Default:
						num4++;
						break;
					case SoundPriority.High:
						num5++;
						break;
					case SoundPriority.VeryHigh:
						num6++;
						break;
					}
				}
				num7++;
			}
			if (verboseLogging && showPlayingEmitterCount)
			{
				UnityEngine.Debug.LogWarning($"[AudioManager] Playing sounds: Total {Fmt(num)} | VeryLow {Fmt(num2)} | Low {Fmt(num3)} | Default {Fmt(num4)} | High {Fmt(num5)} | VeryHigh {Fmt(num6)} | Free {FmtFree(nextFreeEmitters.Count)}");
				showPlayingEmitterCount = false;
			}
		}

		private string Fmt(int count)
		{
			float num = (float)count / (float)theAudioManager.maxSoundEmitters;
			if (num < 0.5f)
			{
				return "<color=green>" + count + "</color>";
			}
			if ((double)num < 0.7)
			{
				return "<color=yellow>" + count + "</color>";
			}
			return "<color=red>" + count + "</color>";
		}

		private string FmtFree(int count)
		{
			float num = (float)count / (float)theAudioManager.maxSoundEmitters;
			if (num < 0.2f)
			{
				return "<color=red>" + count + "</color>";
			}
			if ((double)num < 0.3)
			{
				return "<color=yellow>" + count + "</color>";
			}
			return "<color=green>" + count + "</color>";
		}

		private void OnPreSceneLoad()
		{
			UnityEngine.Debug.Log("[AudioManager] OnPreSceneLoad cleanup");
			for (int i = 0; i < soundEmitters.Length; i++)
			{
				soundEmitters[i].Stop();
				soundEmitters[i].ResetParent(soundEmitterParent.transform);
			}
			ResetFreeEmitters();
		}

		private void ResetFreeEmitters()
		{
			nextFreeEmitters.Clear();
			playingEmitters.Clear();
			for (int i = 1; i < soundEmitters.Length; i++)
			{
				nextFreeEmitters.Add(soundEmitters[i]);
			}
		}

		public static void FadeOutSoundChannel(int channel, float delaySecs, float fadeTime)
		{
			theAudioManager.soundEmitters[channel].FadeOutDelayed(delaySecs, fadeTime);
		}

		public static bool StopSound(int idx, bool fadeOut = true, bool stopReserved = false)
		{
			if (!stopReserved && idx == 0)
			{
				return false;
			}
			if (!fadeOut)
			{
				theAudioManager.soundEmitters[idx].Stop();
			}
			else
			{
				theAudioManager.soundEmitters[idx].FadeOut(theAudioManager.soundFxFadeSecs);
			}
			return true;
		}

		public static void FadeInSound(int idx, float fadeTime, float volume)
		{
			theAudioManager.soundEmitters[idx].FadeIn(fadeTime, volume);
		}

		public static void FadeInSound(int idx, float fadeTime)
		{
			theAudioManager.soundEmitters[idx].FadeIn(fadeTime);
		}

		public static void FadeOutSound(int idx, float fadeTime)
		{
			theAudioManager.soundEmitters[idx].FadeOut(fadeTime);
		}

		public static void StopAllSounds(bool fadeOut, bool stopReserved = false)
		{
			for (int i = 0; i < theAudioManager.soundEmitters.Length; i++)
			{
				StopSound(i, fadeOut, stopReserved);
			}
		}

		public void MuteAllSounds(bool mute, bool muteReserved = false)
		{
			for (int i = 0; i < soundEmitters.Length; i++)
			{
				if (muteReserved || i != 0)
				{
					soundEmitters[i].audioSource.mute = true;
				}
			}
		}

		public void UnMuteAllSounds(bool unmute, bool unmuteReserved = false)
		{
			for (int i = 0; i < soundEmitters.Length; i++)
			{
				if ((unmuteReserved || i != 0) && soundEmitters[i].audioSource.isPlaying)
				{
					soundEmitters[i].audioSource.mute = false;
				}
			}
		}

		public static float GetEmitterEndTime(int idx)
		{
			return theAudioManager.soundEmitters[idx].endPlayTime;
		}

		public static float SetEmitterTime(int idx, float time)
		{
			return theAudioManager.soundEmitters[idx].time = time;
		}

		public static int PlaySound(AudioClip clip, float volume, EmitterChannel src = EmitterChannel.Any, float delay = 0f, float pitchVariance = 1f, bool loop = false)
		{
			if (!SoundEnabled)
			{
				return -1;
			}
			return PlaySoundAt((staticListenerPosition != null) ? staticListenerPosition.position : Vector3.zero, clip, volume, src, delay, pitchVariance, loop);
		}

		private static int FindFreeEmitter(EmitterChannel src, SoundPriority priority)
		{
			SoundEmitter soundEmitter = theAudioManager.soundEmitters[0];
			if (src == EmitterChannel.Any)
			{
				if (theAudioManager.nextFreeEmitters.size > 0)
				{
					soundEmitter = theAudioManager.nextFreeEmitters[0];
					theAudioManager.nextFreeEmitters.RemoveAtFast(0);
				}
				else
				{
					if (priority == SoundPriority.VeryLow)
					{
						return -1;
					}
					soundEmitter = theAudioManager.playingEmitters.Find((SoundEmitter item) => item != null && item.priority < priority);
					if (soundEmitter == null)
					{
						if (priority < SoundPriority.Default)
						{
							if (theAudioManager.verboseLogging)
							{
								UnityEngine.Debug.LogWarning("[AudioManager] skipping sound " + priority);
							}
							return -1;
						}
						soundEmitter = theAudioManager.playingEmitters.Find((SoundEmitter item) => item != null && item.priority <= SoundPriority.Default);
					}
					if (soundEmitter != null)
					{
						if (theAudioManager.verboseLogging)
						{
							UnityEngine.Debug.LogWarning("[AudioManager] cannabalizing " + soundEmitter.originalIdx + " Time: " + Time.time);
						}
						soundEmitter.Stop();
						theAudioManager.playingEmitters.RemoveFast(soundEmitter);
					}
				}
			}
			if (soundEmitter == null)
			{
				UnityEngine.Debug.LogError(string.Concat("[AudioManager] ERROR - absolutely couldn't find a free emitter! Priority = ", priority, " TOO MANY PlaySound* calls!"));
				showPlayingEmitterCount = true;
				return -1;
			}
			return soundEmitter.originalIdx;
		}

		public static int PlaySound(SoundFX soundFX, EmitterChannel src = EmitterChannel.Any, float delay = 0f)
		{
			if (!SoundEnabled)
			{
				return -1;
			}
			return PlaySoundAt((staticListenerPosition != null) ? staticListenerPosition.position : Vector3.zero, soundFX, src, delay);
		}

		public static int PlaySoundAt(Vector3 position, SoundFX soundFX, EmitterChannel src = EmitterChannel.Any, float delay = 0f, float volumeOverride = 1f, float pitchMultiplier = 1f)
		{
			if (!SoundEnabled)
			{
				return -1;
			}
			AudioClip clip = soundFX.GetClip();
			if (clip == null)
			{
				return -1;
			}
			if (staticListenerPosition != null)
			{
				float sqrMagnitude = (staticListenerPosition.position - position).sqrMagnitude;
				if (sqrMagnitude > theAudioManager.audioMaxFallOffDistanceSqr)
				{
					return -1;
				}
				if (sqrMagnitude > soundFX.MaxFalloffDistSquared)
				{
					return -1;
				}
			}
			if (soundFX.ReachedGroupPlayLimit())
			{
				if (theAudioManager.verboseLogging)
				{
					UnityEngine.Debug.Log("[AudioManager] PlaySoundAt() with " + soundFX.name + " skipped due to group play limit");
				}
				return -1;
			}
			int num = FindFreeEmitter(src, soundFX.priority);
			if (num == -1)
			{
				return -1;
			}
			SoundEmitter soundEmitter = theAudioManager.soundEmitters[num];
			soundEmitter.ResetParent(soundEmitterParent.transform);
			soundEmitter.gameObject.SetActive(value: true);
			AudioSource source = soundEmitter.audioSource;
			ONSPAudioSource osp = soundEmitter.osp;
			source.enabled = true;
			source.volume = Mathf.Clamp01(Mathf.Clamp01(theAudioManager.volumeSoundFX * soundFX.volume) * volumeOverride * soundFX.GroupVolumeOverride);
			source.pitch = soundFX.GetPitch() * pitchMultiplier;
			source.time = 0f;
			source.spatialBlend = 1f;
			source.rolloffMode = soundFX.falloffCurve;
			if (soundFX.falloffCurve == AudioRolloffMode.Custom)
			{
				source.SetCustomCurve(AudioSourceCurveType.CustomRolloff, soundFX.volumeFalloffCurve);
			}
			source.SetCustomCurve(AudioSourceCurveType.ReverbZoneMix, soundFX.reverbZoneMix);
			source.dopplerLevel = 0f;
			source.clip = clip;
			source.spread = soundFX.spread;
			source.loop = soundFX.looping;
			source.mute = false;
			source.minDistance = soundFX.falloffDistance.x;
			source.maxDistance = soundFX.falloffDistance.y;
			source.outputAudioMixerGroup = soundFX.GetMixerGroup(EmitterGroup);
			soundEmitter.endPlayTime = Time.time + clip.length + delay;
			soundEmitter.defaultVolume = source.volume;
			soundEmitter.priority = soundFX.priority;
			soundEmitter.onFinished = null;
			soundEmitter.SetPlayingSoundGroup(soundFX.Group);
			if (src == EmitterChannel.Any)
			{
				theAudioManager.playingEmitters.AddUnique(soundEmitter);
			}
			if (osp != null)
			{
				osp.EnableSpatialization = soundFX.ospProps.enableSpatialization;
				osp.EnableRfl = ((theAudioManager.enableSpatializedFastOverride || soundFX.ospProps.useFastOverride) ? true : false);
				osp.Gain = soundFX.ospProps.gain;
				osp.UseInvSqr = soundFX.ospProps.enableInvSquare;
				osp.Near = soundFX.ospProps.invSquareFalloff.x;
				osp.Far = soundFX.ospProps.invSquareFalloff.y;
				source.spatialBlend = (soundFX.ospProps.enableSpatialization ? 1f : 0.8f);
				osp.SetParameters(ref source);
			}
			source.transform.position = position;
			if (theAudioManager.verboseLogging)
			{
				UnityEngine.Debug.Log("[AudioManager] PlaySoundAt() channel = " + num + " soundFX = " + soundFX.name + " volume = " + soundEmitter.volume + " Delay = " + delay + " time = " + Time.time + "\n");
			}
			if (delay > 0f)
			{
				source.PlayDelayed(delay);
			}
			else
			{
				source.Play();
			}
			return num;
		}

		public static int PlayRandomSoundAt(Vector3 position, AudioClip[] clips, float volume, EmitterChannel src = EmitterChannel.Any, float delay = 0f, float pitch = 1f, bool loop = false)
		{
			if (clips == null || clips.Length == 0)
			{
				return -1;
			}
			int num = UnityEngine.Random.Range(0, clips.Length);
			return PlaySoundAt(position, clips[num], volume, src, delay, pitch, loop);
		}

		public static int PlaySoundAt(Vector3 position, AudioClip clip, float volume = 1f, EmitterChannel src = EmitterChannel.Any, float delay = 0f, float pitch = 1f, bool loop = false)
		{
			if (!SoundEnabled)
			{
				return -1;
			}
			if (clip == null)
			{
				return -1;
			}
			if (staticListenerPosition != null && (staticListenerPosition.position - position).sqrMagnitude > theAudioManager.audioMaxFallOffDistanceSqr)
			{
				return -1;
			}
			int num = FindFreeEmitter(src, SoundPriority.Default);
			if (num == -1)
			{
				return -1;
			}
			SoundEmitter soundEmitter = theAudioManager.soundEmitters[num];
			soundEmitter.ResetParent(soundEmitterParent.transform);
			soundEmitter.gameObject.SetActive(value: true);
			AudioSource audioSource = soundEmitter.audioSource;
			ONSPAudioSource osp = soundEmitter.osp;
			audioSource.enabled = true;
			audioSource.volume = Mathf.Clamp01(theAudioManager.volumeSoundFX * volume);
			audioSource.pitch = pitch;
			audioSource.spatialBlend = 0.8f;
			audioSource.rolloffMode = AudioRolloffMode.Linear;
			audioSource.SetCustomCurve(AudioSourceCurveType.ReverbZoneMix, defaultReverbZoneMix);
			audioSource.dopplerLevel = 0f;
			audioSource.clip = clip;
			audioSource.spread = 0f;
			audioSource.loop = loop;
			audioSource.mute = false;
			audioSource.minDistance = theAudioManager.audioMinFallOffDistance;
			audioSource.maxDistance = theAudioManager.audioMaxFallOffDistance;
			audioSource.outputAudioMixerGroup = EmitterGroup;
			soundEmitter.endPlayTime = Time.time + clip.length + delay;
			soundEmitter.defaultVolume = audioSource.volume;
			soundEmitter.priority = SoundPriority.Default;
			soundEmitter.onFinished = null;
			soundEmitter.SetPlayingSoundGroup(null);
			if (src == EmitterChannel.Any)
			{
				theAudioManager.playingEmitters.AddUnique(soundEmitter);
			}
			if (osp != null)
			{
				osp.EnableSpatialization = false;
			}
			audioSource.transform.position = position;
			if (theAudioManager.verboseLogging)
			{
				UnityEngine.Debug.Log("[AudioManager] PlaySoundAt() channel = " + num + " clip = " + clip.name + " volume = " + soundEmitter.volume + " Delay = " + delay + " time = " + Time.time + "\n");
			}
			if (delay > 0f)
			{
				audioSource.PlayDelayed(delay);
			}
			else
			{
				audioSource.Play();
			}
			return num;
		}

		public static void SetOnFinished(int emitterIdx, Action onFinished)
		{
			if (ValidateEmitterIndex(emitterIdx))
			{
				theAudioManager.soundEmitters[emitterIdx].SetOnFinished(onFinished);
			}
		}

		public static void SetOnFinished(int emitterIdx, Action<object> onFinished, object obj)
		{
			if (ValidateEmitterIndex(emitterIdx))
			{
				theAudioManager.soundEmitters[emitterIdx].SetOnFinished(onFinished, obj);
			}
		}

		public static void AttachSoundToParent(int idx, Transform parent)
		{
			if (theAudioManager.verboseLogging)
			{
				string text = parent.name;
				if (parent.parent != null)
				{
					text = parent.parent.name + "/" + text;
				}
				UnityEngine.Debug.Log("[AudioManager] ATTACHING INDEX " + idx + " to " + text);
			}
			theAudioManager.soundEmitters[idx].ParentTo(parent);
		}

		public static void DetachSoundFromParent(int idx)
		{
			if (theAudioManager.verboseLogging)
			{
				UnityEngine.Debug.Log("[AudioManager] DETACHING INDEX " + idx);
			}
			theAudioManager.soundEmitters[idx].DetachFromParent();
		}

		public static void DetachSoundsFromParent(SoundEmitter[] emitters, bool stopSounds = true)
		{
			if (emitters == null)
			{
				return;
			}
			foreach (SoundEmitter soundEmitter in emitters)
			{
				if (soundEmitter.defaultParent != null)
				{
					if (stopSounds)
					{
						soundEmitter.Stop();
					}
					soundEmitter.DetachFromParent();
					soundEmitter.gameObject.SetActive(value: true);
				}
				else if (stopSounds)
				{
					soundEmitter.Stop();
				}
			}
		}

		public static void SetEmitterMixerGroup(int idx, AudioMixerGroup mixerGroup)
		{
			if (theAudioManager != null && idx > -1)
			{
				theAudioManager.soundEmitters[idx].SetAudioMixer(mixerGroup);
			}
		}

		public static MixerSnapshot GetActiveSnapshot()
		{
			if (!(theAudioManager != null))
			{
				return null;
			}
			return theAudioManager.currentSnapshot;
		}

		public static void SetCurrentSnapshot(MixerSnapshot mixerSnapshot)
		{
			if (theAudioManager != null)
			{
				if (mixerSnapshot != null && mixerSnapshot.snapshot != null)
				{
					mixerSnapshot.snapshot.TransitionTo(mixerSnapshot.transitionTime);
				}
				else
				{
					mixerSnapshot = null;
				}
				theAudioManager.currentSnapshot = mixerSnapshot;
			}
		}

		public static void BlendWithCurrentSnapshot(MixerSnapshot blendSnapshot, float weight, float blendTime = 0f)
		{
			if (!(theAudioManager != null))
			{
				return;
			}
			if (theAudioManager.audioMixer == null)
			{
				UnityEngine.Debug.LogWarning("[AudioManager] can't call BlendWithCurrentSnapshot if the audio mixer is not set!");
				return;
			}
			if (blendTime == 0f)
			{
				blendTime = Time.deltaTime;
			}
			if (theAudioManager.currentSnapshot != null && theAudioManager.currentSnapshot.snapshot != null && blendSnapshot != null && blendSnapshot.snapshot != null)
			{
				weight = Mathf.Clamp01(weight);
				if (weight == 0f)
				{
					theAudioManager.currentSnapshot.snapshot.TransitionTo(blendTime);
					return;
				}
				AudioMixerSnapshot[] snapshots = new AudioMixerSnapshot[2]
				{
					theAudioManager.currentSnapshot.snapshot,
					blendSnapshot.snapshot
				};
				float[] weights = new float[2]
				{
					1f - weight,
					weight
				};
				theAudioManager.audioMixer.TransitionToSnapshots(snapshots, weights, blendTime);
			}
		}
	}
	public enum EmitterChannel
	{
		None = -1,
		Reserved,
		Any
	}
	[Serializable]
	public class MixerSnapshot
	{
		public AudioMixerSnapshot snapshot;

		public float transitionTime = 0.25f;
	}
	public class MinMaxAttribute : PropertyAttribute
	{
		public float minDefaultVal = 1f;

		public float maxDefaultVal = 1f;

		public float min;

		public float max = 1f;

		public MinMaxAttribute(float minDefaultVal, float maxDefaultVal, float min, float max)
		{
			this.minDefaultVal = minDefaultVal;
			this.maxDefaultVal = maxDefaultVal;
			this.min = min;
			this.max = max;
		}
	}
	public class SoundEmitter : MonoBehaviour
	{
		public enum FadeState
		{
			Null,
			FadingIn,
			FadingOut,
			Ducking
		}

		public EmitterChannel channel;

		public bool disableSpatialization;

		private FadeState state;

		[NonSerialized]
		[HideInInspector]
		public AudioSource audioSource;

		[NonSerialized]
		[HideInInspector]
		public SoundPriority priority;

		[NonSerialized]
		[HideInInspector]
		public ONSPAudioSource osp;

		[NonSerialized]
		[HideInInspector]
		public float endPlayTime;

		private Transform lastParentTransform;

		[NonSerialized]
		[HideInInspector]
		public float defaultVolume = 1f;

		[NonSerialized]
		[HideInInspector]
		public Transform defaultParent;

		[NonSerialized]
		[HideInInspector]
		public int originalIdx = -1;

		[NonSerialized]
		[HideInInspector]
		public Action onFinished;

		[NonSerialized]
		[HideInInspector]
		public Action<object> onFinishedObject;

		[NonSerialized]
		[HideInInspector]
		public object onFinishedParam;

		[NonSerialized]
		[HideInInspector]
		public SoundGroup playingSoundGroup;

		public float volume
		{
			get
			{
				return audioSource.volume;
			}
			set
			{
				audioSource.volume = value;
			}
		}

		public float pitch
		{
			get
			{
				return audioSource.pitch;
			}
			set
			{
				audioSource.pitch = value;
			}
		}

		public AudioClip clip
		{
			get
			{
				return audioSource.clip;
			}
			set
			{
				audioSource.clip = value;
			}
		}

		public float time
		{
			get
			{
				return audioSource.time;
			}
			set
			{
				audioSource.time = value;
			}
		}

		public float length
		{
			get
			{
				if (!(audioSource.clip != null))
				{
					return 0f;
				}
				return audioSource.clip.length;
			}
		}

		public bool loop
		{
			get
			{
				return audioSource.loop;
			}
			set
			{
				audioSource.loop = value;
			}
		}

		public bool mute
		{
			get
			{
				return audioSource.mute;
			}
			set
			{
				audioSource.mute = value;
			}
		}

		public AudioVelocityUpdateMode velocityUpdateMode
		{
			get
			{
				return audioSource.velocityUpdateMode;
			}
			set
			{
				audioSource.velocityUpdateMode = value;
			}
		}

		public bool isPlaying => audioSource.isPlaying;

		private void Awake()
		{
			audioSource = GetComponent<AudioSource>();
			if (audioSource == null)
			{
				audioSource = base.gameObject.AddComponent<AudioSource>();
			}
			if (AudioManager.enableSpatialization && !disableSpatialization)
			{
				osp = GetComponent<ONSPAudioSource>();
				if (osp == null)
				{
					osp = base.gameObject.AddComponent<ONSPAudioSource>();
				}
			}
			audioSource.playOnAwake = false;
			audioSource.Stop();
		}

		public void SetPlayingSoundGroup(SoundGroup soundGroup)
		{
			playingSoundGroup = soundGroup;
			soundGroup?.IncrementPlayCount();
		}

		public void SetOnFinished(Action onFinished)
		{
			this.onFinished = onFinished;
		}

		public void SetOnFinished(Action<object> onFinished, object obj)
		{
			onFinishedObject = onFinished;
			onFinishedParam = obj;
		}

		public void SetChannel(int _channel)
		{
			channel = (EmitterChannel)_channel;
		}

		public void SetDefaultParent(Transform parent)
		{
			defaultParent = parent;
		}

		public void SetAudioMixer(AudioMixerGroup _mixer)
		{
			if (audioSource != null)
			{
				audioSource.outputAudioMixerGroup = _mixer;
			}
		}

		public bool IsPlaying()
		{
			if (loop && audioSource.isPlaying)
			{
				return true;
			}
			return endPlayTime > Time.time;
		}

		public void Play()
		{
			state = FadeState.Null;
			endPlayTime = Time.time + length;
			StopAllCoroutines();
			audioSource.Play();
		}

		public void Pause()
		{
			state = FadeState.Null;
			StopAllCoroutines();
			audioSource.Pause();
		}

		public void Stop()
		{
			state = FadeState.Null;
			StopAllCoroutines();
			if (audioSource != null)
			{
				audioSource.Stop();
			}
			if (onFinished != null)
			{
				onFinished();
				onFinished = null;
			}
			if (onFinishedObject != null)
			{
				onFinishedObject(onFinishedParam);
				onFinishedObject = null;
			}
			if (playingSoundGroup != null)
			{
				playingSoundGroup.DecrementPlayCount();
				playingSoundGroup = null;
			}
		}

		private int GetSampleTime()
		{
			return audioSource.clip.samples - audioSource.timeSamples;
		}

		public void ParentTo(Transform parent)
		{
			if (lastParentTransform != null)
			{
				UnityEngine.Debug.LogError("[SoundEmitter] You must detach the sound emitter before parenting to another object!");
				return;
			}
			lastParentTransform = base.transform.parent;
			base.transform.parent = parent;
		}

		public void DetachFromParent()
		{
			if (lastParentTransform == null)
			{
				base.transform.parent = defaultParent;
				return;
			}
			base.transform.parent = lastParentTransform;
			lastParentTransform = null;
		}

		public void ResetParent(Transform parent)
		{
			base.transform.parent = parent;
			lastParentTransform = null;
		}

		public void SyncTo(SoundEmitter other, float fadeTime, float toVolume)
		{
			StartCoroutine(DelayedSyncTo(other, fadeTime, toVolume));
		}

		private IEnumerator DelayedSyncTo(SoundEmitter other, float fadeTime, float toVolume)
		{
			yield return new WaitForEndOfFrame();
			audioSource.time = other.time;
			audioSource.Play();
			FadeTo(fadeTime, toVolume);
		}

		public void FadeTo(float fadeTime, float toVolume)
		{
			if (state != FadeState.FadingOut)
			{
				state = FadeState.Ducking;
				StopAllCoroutines();
				StartCoroutine(FadeSoundChannelTo(fadeTime, toVolume));
			}
		}

		public void FadeIn(float fadeTime, float defaultVolume)
		{
			audioSource.volume = 0f;
			state = FadeState.FadingIn;
			StopAllCoroutines();
			StartCoroutine(FadeSoundChannel(0f, fadeTime, Fade.In, defaultVolume));
		}

		public void FadeIn(float fadeTime)
		{
			audioSource.volume = 0f;
			state = FadeState.FadingIn;
			StopAllCoroutines();
			StartCoroutine(FadeSoundChannel(0f, fadeTime, Fade.In, defaultVolume));
		}

		public void FadeOut(float fadeTime)
		{
			if (audioSource.isPlaying)
			{
				state = FadeState.FadingOut;
				StopAllCoroutines();
				StartCoroutine(FadeSoundChannel(0f, fadeTime, Fade.Out, audioSource.volume));
			}
		}

		public void FadeOutDelayed(float delayedSecs, float fadeTime)
		{
			if (audioSource.isPlaying)
			{
				state = FadeState.FadingOut;
				StopAllCoroutines();
				StartCoroutine(FadeSoundChannel(delayedSecs, fadeTime, Fade.Out, audioSource.volume));
			}
		}

		private IEnumerator FadeSoundChannelTo(float fadeTime, float toVolume)
		{
			float start = audioSource.volume;
			float startTime = Time.realtimeSinceStartup;
			float elapsedTime = 0f;
			while (elapsedTime < fadeTime)
			{
				elapsedTime = Time.realtimeSinceStartup - startTime;
				float t = elapsedTime / fadeTime;
				audioSource.volume = Mathf.Lerp(start, toVolume, t);
				yield return 0;
			}
			state = FadeState.Null;
		}

		private IEnumerator FadeSoundChannel(float delaySecs, float fadeTime, Fade fadeType, float defaultVolume)
		{
			if (delaySecs > 0f)
			{
				yield return new WaitForSeconds(delaySecs);
			}
			float start = ((fadeType == Fade.In) ? 0f : defaultVolume);
			float end = ((fadeType == Fade.In) ? defaultVolume : 0f);
			bool restartPlay = false;
			if (fadeType == Fade.In)
			{
				if (Time.time == 0f)
				{
					restartPlay = true;
				}
				audioSource.volume = 0f;
				audioSource.Play();
			}
			float startTime = Time.realtimeSinceStartup;
			float elapsedTime = 0f;
			while (elapsedTime < fadeTime)
			{
				elapsedTime = Time.realtimeSinceStartup - startTime;
				float t = elapsedTime / fadeTime;
				audioSource.volume = Mathf.Lerp(start, end, t);
				yield return 0;
				if (restartPlay && Time.time > 0f)
				{
					audioSource.Play();
					restartPlay = false;
				}
				if (!audioSource.isPlaying)
				{
					break;
				}
			}
			if (fadeType == Fade.Out)
			{
				Stop();
			}
			state = FadeState.Null;
		}
	}
	public enum SoundFXNext
	{
		Random,
		Sequential
	}
	public enum FreqHint
	{
		None,
		Wide,
		Narrow
	}
	public enum SoundPriority
	{
		VeryLow = -2,
		Low,
		Default,
		High,
		VeryHigh
	}
	[Serializable]
	public class OSPProps
	{
		[Tooltip("Set to true to play the sound FX spatialized with binaural HRTF, default = false")]
		public bool enableSpatialization;

		[Tooltip("Play the sound FX with reflections, default = false")]
		public bool useFastOverride;

		[Tooltip("Boost the gain on the spatialized sound FX, default = 0.0")]
		[Range(0f, 24f)]
		public float gain;

		[Tooltip("Enable Inverse Square attenuation curve, default = false")]
		public bool enableInvSquare;

		[Tooltip("Change the sound from point source (0.0f) to a spherical volume, default = 0.0")]
		[Range(0f, 1000f)]
		public float volumetric;

		[Tooltip("Set the near and far falloff value for the OSP attenuation curve, default = 1.0")]
		[MinMax(1f, 25f, 0f, 250f)]
		public Vector2 invSquareFalloff = new Vector2(1f, 25f);

		public OSPProps()
		{
			enableSpatialization = false;
			useFastOverride = false;
			gain = 0f;
			enableInvSquare = false;
			volumetric = 0f;
			invSquareFalloff = new Vector2(1f, 25f);
		}
	}
	[Serializable]
	public class SoundFX
	{
		[Tooltip("Each sound FX should have a unique name")]
		public string name = string.Empty;

		[Tooltip("Sound diversity playback option when multiple audio clips are defined, default = Random")]
		public SoundFXNext playback;

		[Tooltip("Default volume for this sound FX, default = 1.0")]
		[Range(0f, 1f)]
		public float volume = 1f;

		[Tooltip("Random pitch variance each time a sound FX is played, default = 1.0 (none)")]
		[MinMax(1f, 1f, 0f, 2f)]
		public Vector2 pitchVariance = Vector2.one;

		[Tooltip("Falloff distance for the sound FX, default = 1m min to 25m max")]
		[MinMax(1f, 25f, 0f, 250f)]
		public Vector2 falloffDistance = new Vector2(1f, 25f);

		[Tooltip("Volume falloff curve - sets how the sound FX attenuates over distance, default = Linear")]
		public AudioRolloffMode falloffCurve = AudioRolloffMode.Linear;

		[Tooltip("Defines the custom volume falloff curve")]
		public AnimationCurve volumeFalloffCurve = new AnimationCurve(new Keyframe(0f, 1f), new Keyframe(1f, 1f));

		[Tooltip("The amount by which the signal from the AudioSource will be mixed into the global reverb associated with the Reverb Zones | Valid range is 0.0 - 1.1, default = 1.0")]
		public AnimationCurve reverbZoneMix = new AnimationCurve(new Keyframe(0f, 1f), new Keyframe(1f, 1f));

		[Tooltip("Sets the spread angle (in degrees) of a 3d stereo or multichannel sound in speaker space, default = 0")]
		[Range(0f, 360f)]
		public float spread;

		[Tooltip("The percentage chance that this sound FX will play | 0.0 = none, 1.0 = 100%, default = 1.0")]
		[Range(0f, 1f)]
		public float pctChanceToPlay = 1f;

		[Tooltip("Sets the priority for this sound to play and/or to override a currently playing sound FX, default = Default")]
		public SoundPriority priority;

		[Tooltip("Specifies the default delay when this sound FX is played, default = 0.0 secs")]
		[MinMax(0f, 0f, 0f, 2f)]
		public Vector2 delay = Vector2.zero;

		[Tooltip("Set to true for the sound to loop continuously, default = false")]
		public bool looping;

		public OSPProps ospProps = new OSPProps();

		[Tooltip("List of the audio clips assigned to this sound FX")]
		public AudioClip[] soundClips = new AudioClip[1];

		public bool visibilityToggle;

		[NonSerialized]
		private SoundGroup soundGroup;

		private int lastIdx = -1;

		private int playingIdx = -1;

		public int Length => soundClips.Length;

		public bool IsValid
		{
			get
			{
				if (soundClips.Length != 0)
				{
					return soundClips[0] != null;
				}
				return false;
			}
		}

		public SoundGroup Group
		{
			get
			{
				return soundGroup;
			}
			set
			{
				soundGroup = value;
			}
		}

		public float MaxFalloffDistSquared => falloffDistance.y * falloffDistance.y;

		public float GroupVolumeOverride
		{
			get
			{
				if (soundGroup == null)
				{
					return 1f;
				}
				return soundGroup.volumeOverride;
			}
		}

		public SoundFX()
		{
			playback = SoundFXNext.Random;
			volume = 1f;
			pitchVariance = Vector2.one;
			falloffDistance = new Vector2(1f, 25f);
			falloffCurve = AudioRolloffMode.Linear;
			volumeFalloffCurve = new AnimationCurve(new Keyframe(0f, 1f), new Keyframe(1f, 1f));
			reverbZoneMix = new AnimationCurve(new Keyframe(0f, 1f), new Keyframe(1f, 1f));
			spread = 0f;
			pctChanceToPlay = 1f;
			priority = SoundPriority.Default;
			delay = Vector2.zero;
			looping = false;
			ospProps = new OSPProps();
		}

		public AudioClip GetClip()
		{
			if (soundClips.Length == 0)
			{
				return null;
			}
			if (soundClips.Length == 1)
			{
				return soundClips[0];
			}
			if (playback == SoundFXNext.Random)
			{
				int num;
				for (num = UnityEngine.Random.Range(0, soundClips.Length); num == lastIdx; num = UnityEngine.Random.Range(0, soundClips.Length))
				{
				}
				lastIdx = num;
				return soundClips[num];
			}
			if (++lastIdx >= soundClips.Length)
			{
				lastIdx = 0;
			}
			return soundClips[lastIdx];
		}

		public AudioMixerGroup GetMixerGroup(AudioMixerGroup defaultMixerGroup)
		{
			if (soundGroup != null)
			{
				if (!(soundGroup.mixerGroup != null))
				{
					return defaultMixerGroup;
				}
				return soundGroup.mixerGroup;
			}
			return defaultMixerGroup;
		}

		public bool ReachedGroupPlayLimit()
		{
			if (soundGroup != null)
			{
				return !soundGroup.CanPlaySound();
			}
			return false;
		}

		public float GetClipLength(int idx)
		{
			if (idx == -1 || soundClips.Length == 0 || idx >= soundClips.Length || soundClips[idx] == null)
			{
				return 0f;
			}
			return soundClips[idx].length;
		}

		public float GetPitch()
		{
			return UnityEngine.Random.Range(pitchVariance.x, pitchVariance.y);
		}

		public int PlaySound(float delaySecs = 0f)
		{
			playingIdx = -1;
			if (!IsValid)
			{
				return playingIdx;
			}
			if (pctChanceToPlay > 0.99f || UnityEngine.Random.value < pctChanceToPlay)
			{
				if (delay.y > 0f)
				{
					delaySecs = UnityEngine.Random.Range(delay.x, delay.y);
				}
				playingIdx = AudioManager.PlaySound(this, EmitterChannel.Any, delaySecs);
			}
			return playingIdx;
		}

		public int PlaySoundAt(Vector3 pos, float delaySecs = 0f, float volumeOverride = 1f, float pitchMultiplier = 1f)
		{
			playingIdx = -1;
			if (!IsValid)
			{
				return playingIdx;
			}
			if (pctChanceToPlay > 0.99f || UnityEngine.Random.value < pctChanceToPlay)
			{
				if (delay.y > 0f)
				{
					delaySecs = UnityEngine.Random.Range(delay.x, delay.y);
				}
				playingIdx = AudioManager.PlaySoundAt(pos, this, EmitterChannel.Any, delaySecs, volumeOverride, pitchMultiplier);
			}
			return playingIdx;
		}

		public void SetOnFinished(Action onFinished)
		{
			if (playingIdx > -1)
			{
				AudioManager.SetOnFinished(playingIdx, onFinished);
			}
		}

		public void SetOnFinished(Action<object> onFinished, object obj)
		{
			if (playingIdx > -1)
			{
				AudioManager.SetOnFinished(playingIdx, onFinished, obj);
			}
		}

		public bool StopSound()
		{
			bool result = false;
			if (playingIdx > -1)
			{
				result = AudioManager.StopSound(playingIdx);
				playingIdx = -1;
			}
			return result;
		}

		public void AttachToParent(Transform parent)
		{
			if (playingIdx > -1)
			{
				AudioManager.AttachSoundToParent(playingIdx, parent);
			}
		}

		public void DetachFromParent()
		{
			if (playingIdx > -1)
			{
				AudioManager.DetachSoundFromParent(playingIdx);
			}
		}
	}
	[Serializable]
	public class SoundFXRef
	{
		public string soundFXName = string.Empty;

		private bool initialized;

		private SoundFX soundFXCached;

		public SoundFX soundFX
		{
			get
			{
				if (!initialized)
				{
					Init();
				}
				return soundFXCached;
			}
		}

		public string name
		{
			get
			{
				return soundFXName;
			}
			set
			{
				soundFXName = value;
				Init();
			}
		}

		public int Length => soundFX.Length;

		public bool IsValid => soundFX.IsValid;

		private void Init()
		{
			soundFXCached = AudioManager.FindSoundFX(soundFXName);
			if (soundFXCached == null)
			{
				soundFXCached = AudioManager.FindSoundFX(string.Empty);
			}
			initialized = true;
		}

		public AudioClip GetClip()
		{
			return soundFX.GetClip();
		}

		public float GetClipLength(int idx)
		{
			return soundFX.GetClipLength(idx);
		}

		public int PlaySound(float delaySecs = 0f)
		{
			return soundFX.PlaySound(delaySecs);
		}

		public int PlaySoundAt(Vector3 pos, float delaySecs = 0f, float volume = 1f, float pitchMultiplier = 1f)
		{
			return soundFX.PlaySoundAt(pos, delaySecs, volume, pitchMultiplier);
		}

		public void SetOnFinished(Action onFinished)
		{
			soundFX.SetOnFinished(onFinished);
		}

		public void SetOnFinished(Action<object> onFinished, object obj)
		{
			soundFX.SetOnFinished(onFinished, obj);
		}

		public bool StopSound()
		{
			return soundFX.StopSound();
		}

		public void AttachToParent(Transform parent)
		{
			soundFX.AttachToParent(parent);
		}

		public void DetachFromParent()
		{
			soundFX.DetachFromParent();
		}
	}
}
namespace MalbersAnimations
{
	[CreateAssetMenu(menuName = "Malbers Animations/Actions")]
	public class Action : ScriptableObject
	{
		[Tooltip("Value for the transitions IDAction on the Animator in order to Execute the desirable animation clip")]
		public int ID;

		public static implicit operator int(Action reference)
		{
			return reference.ID;
		}
	}
	[RequireComponent(typeof(BoxCollider))]
	public class ActionZone : MonoBehaviour, IWayPoint
	{
		private static Keyframe[] K = new Keyframe[2]
		{
			new Keyframe(0f, 0f),
			new Keyframe(1f, 1f)
		};

		public Action ID;

		public bool automatic;

		public int index;

		public float AutomaticDisabled = 10f;

		public bool HeadOnly;

		public bool ActiveOnJump;

		public bool MoveToExitAction;

		public bool Align;

		public bool AlignWithWidth;

		public Transform AlingPoint;

		public Transform AlingPoint2;

		public float AlignTime = 0.5f;

		public AnimationCurve AlignCurve = new AnimationCurve(K);

		public bool AlignPos = true;

		public bool AlignRot = true;

		public bool AlignLookAt;

		protected List<Collider> animal_Colliders = new List<Collider>();

		protected Animal oldAnimal;

		public float ActionDelay;

		public AnimalEvent OnEnter = new AnimalEvent();

		public AnimalEvent OnExit = new AnimalEvent();

		public AnimalEvent OnAction = new AnimalEvent();

		[MinMaxRange(0f, 60f)]
		[SerializeField]
		private RangedFloat waitTime = new RangedFloat(0f, 5f);

		public WayPointType pointType;

		public static List<ActionZone> ActionZones;

		[SerializeField]
		private List<Transform> nextTargets;

		[SerializeField]
		private float stoppingDistance = 0.5f;

		private Collider ZoneCollider;

		[HideInInspector]
		public bool EditorShowEvents = true;

		[HideInInspector]
		public bool EditorAI = true;

		public List<Transform> NextTargets
		{
			get
			{
				return nextTargets;
			}
			set
			{
				nextTargets = value;
			}
		}

		public Transform NextTarget
		{
			get
			{
				if (NextTargets.Count > 0)
				{
					return NextTargets[UnityEngine.Random.Range(0, NextTargets.Count)];
				}
				return null;
			}
		}

		public WayPointType PointType => pointType;

		public float WaitTime => waitTime.RandomValue;

		public float StoppingDistance
		{
			get
			{
				return stoppingDistance;
			}
			set
			{
				stoppingDistance = value;
			}
		}

		private void OnTriggerEnter(Collider other)
		{
			if (!MalbersTools.CollidersLayer(other, LayerMask.GetMask("Animal")) || (HeadOnly && !other.name.ToLower().Contains("head")))
			{
				return;
			}
			Animal componentInParent = other.GetComponentInParent<Animal>();
			if (!componentInParent)
			{
				return;
			}
			componentInParent.ActionID = ID;
			if (animal_Colliders.Find((Collider coll) => coll == other) == null)
			{
				animal_Colliders.Add(other);
			}
			if (!(componentInParent == oldAnimal))
			{
				if ((bool)oldAnimal)
				{
					oldAnimal.ActionID = -1;
					animal_Colliders = new List<Collider>();
				}
				oldAnimal = componentInParent;
				componentInParent.OnAction.AddListener(OnActionListener);
				OnEnter.Invoke(componentInParent);
				if (automatic && (componentInParent.AnimState != AnimTag.Jump || ActiveOnJump))
				{
					componentInParent.SetAction(ID);
					StartCoroutine(ReEnable(componentInParent));
				}
			}
		}

		private void OnTriggerExit(Collider other)
		{
			if (HeadOnly && !other.name.ToLower().Contains("head"))
			{
				return;
			}
			Animal componentInParent = other.GetComponentInParent<Animal>();
			if (!componentInParent || componentInParent != oldAnimal)
			{
				return;
			}
			if ((bool)animal_Colliders.Find((Collider item) => item == other))
			{
				animal_Colliders.Remove(other);
			}
			if (animal_Colliders.Count == 0)
			{
				OnExit.Invoke(oldAnimal);
				if (oldAnimal.ActionID == (int)ID)
				{
					oldAnimal.ActionID = -1;
				}
				oldAnimal = null;
			}
		}

		private IEnumerator ReEnable(Animal animal)
		{
			if (AutomaticDisabled > 0f)
			{
				ZoneCollider.enabled = false;
				yield return null;
				yield return null;
				animal.ActionID = -1;
				yield return new WaitForSeconds(AutomaticDisabled);
				ZoneCollider.enabled = true;
			}
			oldAnimal = null;
			animal_Colliders = new List<Collider>();
			yield return null;
		}

		public virtual void _DestroyActionZone(float time)
		{
			UnityEngine.Object.Destroy(base.gameObject, time);
		}

		private void OnActionListener()
		{
			if (!oldAnimal)
			{
				return;
			}
			StartCoroutine(OnActionDelay(ActionDelay, oldAnimal));
			if (Align && (bool)AlingPoint)
			{
				IEnumerator enumerator = null;
				Vector3 newPosition = AlingPoint.position;
				if ((bool)AlingPoint2)
				{
					newPosition = MalbersTools.ClosestPointOnLine(AlingPoint.position, AlingPoint2.position, oldAnimal.transform.position);
				}
				if (AlignLookAt)
				{
					enumerator = MalbersTools.AlignLookAtTransform(oldAnimal.transform, AlingPoint, AlignTime, AlignCurve);
					StartCoroutine(enumerator);
				}
				else
				{
					if (AlignPos)
					{
						StartCoroutine(MalbersTools.AlignTransform_Position(oldAnimal.transform, newPosition, AlignTime, AlignCurve));
					}
					if (AlignRot)
					{
						StartCoroutine(MalbersTools.AlignTransform_Rotation(oldAnimal.transform, AlingPoint.rotation, AlignTime, AlignCurve));
					}
				}
			}
			StartCoroutine(CheckForCollidersOff());
		}

		private IEnumerator OnActionDelay(float time, Animal animal)
		{
			if (time > 0f)
			{
				yield return new WaitForSeconds(time);
			}
			OnAction.Invoke(animal);
			yield return null;
		}

		private IEnumerator CheckForCollidersOff()
		{
			yield return null;
			yield return null;
			if ((bool)oldAnimal && !oldAnimal.ActiveColliders)
			{
				oldAnimal.OnAction.RemoveListener(OnActionListener);
				oldAnimal.ActionID = -1;
				oldAnimal = null;
				animal_Colliders = new List<Collider>();
			}
		}

		public virtual void _WakeAnimal(Animal animal)
		{
			if ((bool)animal)
			{
				animal.MovementAxis = Vector3.forward * 3f;
			}
		}

		private void OnEnable()
		{
			if (ActionZones == null)
			{
				ActionZones = new List<ActionZone>();
			}
			ZoneCollider = GetComponent<Collider>();
			ActionZones.Add(this);
		}

		private void OnDisable()
		{
			ActionZones.Remove(this);
			if ((bool)oldAnimal)
			{
				oldAnimal.OnAction.RemoveListener(OnActionListener);
				oldAnimal.ActionID = -1;
			}
		}
	}
	[RequireComponent(typeof(Animator))]
	[RequireComponent(typeof(Rigidbody))]
	public class Animal : MonoBehaviour, IAnimatorListener, IMDamagable, IMCharacter, ICharacterMove
	{
		public enum Ground
		{
			walk = 1,
			trot,
			run
		}

		private int ToogleAmount = 4;

		private IEnumerator StunC;

		public Dictionary<string, BoolEvent> Inputs;

		private float YFix;

		protected float FixDistance;

		public static List<Animal> Animals;

		protected Animator anim;

		protected Rigidbody _rigidbody;

		private Renderer animalMesh;

		protected Vector3 movementAxis;

		protected Vector3 rawDirection;

		[HideInInspector]
		internal Vector3 T_Up;

		[HideInInspector]
		internal Vector3 T_Right;

		[HideInInspector]
		internal Vector3 T_Forward;

		public static readonly float LowWaterLevel = -1000f;

		protected bool speed1;

		protected bool speed2;

		protected bool speed3;

		protected bool movementReleased;

		protected bool jump;

		protected bool fly;

		protected bool shift;

		protected bool down;

		protected bool up;

		protected bool dodge;

		protected bool fall;

		protected bool fallback;

		protected bool isInWater;

		protected bool isInAir;

		protected bool swim;

		protected bool underwater;

		protected bool stun;

		protected bool action;

		protected bool stand = true;

		protected bool backray;

		protected bool frontray;

		private float waterLevel = -10f;

		private bool directionalMovement;

		protected float vertical;

		protected float horizontal;

		private float stateTime;

		protected float groundSpeed = 1f;

		protected float slope;

		protected float idfloat;

		protected float _Height;

		protected int idInt;

		protected int actionID = -1;

		protected int tired;

		protected int loops = 1;

		public int animalTypeID;

		[SerializeField]
		private int stance;

		internal Vector3 FixedDeltaPos = Vector3.zero;

		internal Vector3 DeltaPosition = Vector3.zero;

		internal Vector3 LastPosition = Vector3.zero;

		internal Quaternion DeltaRotation = Quaternion.identity;

		public bool JumpPress;

		public float JumpHeightMultiplier;

		public float AirForwardMultiplier;

		public LayerMask GroundLayer = 1;

		public Ground StartSpeed = Ground.walk;

		public float height = 1f;

		internal Speeds currentSpeed;

		public Speeds walkSpeed = new Speeds(8f, 4f, 6f);

		public Speeds trotSpeed = new Speeds(4f, 4f, 6f);

		public Speeds runSpeed = new Speeds(2f, 4f, 6f);

		protected float CurrentAnimatorSpeed = 1f;

		protected Transform platform;

		protected Vector3 platform_Pos;

		protected float platform_formAngle;

		public string m_Vertical = "Vertical";

		public string m_Horizontal = "Horizontal";

		public string m_UpDown = "UpDown";

		public string m_Stand = "Stand";

		public string m_Jump = "_Jump";

		public string m_Fly = "Fly";

		public string m_Fall = "Fall";

		public string m_Attack1 = "Attack1";

		public string m_Attack2 = "Attack2";

		public string m_Stunned = "Stunned";

		public string m_Damaged = "Damaged";

		public string m_Shift = "Shift";

		public string m_Death = "Death";

		public string m_Dodge = "Dodge";

		public string m_Underwater = "Underwater";

		public string m_Swim = "Swim";

		public string m_Action = "Action";

		public string m_IDAction = "IDAction";

		public string m_IDFloat = "IDFloat";

		public string m_IDInt = "IDInt";

		public string m_Slope = "Slope";

		public string m_Type = "Type";

		public string m_SpeedMultiplier = "SpeedMultiplier";

		public string m_StateTime = "StateTime";

		public string m_Stance = "Stance";

		internal int hash_Vertical;

		internal int hash_Horizontal;

		internal int hash_UpDown;

		internal int hash_Stand;

		internal int hash_Jump;

		internal int hash_Dodge;

		internal int hash_Fall;

		internal int hash_Type;

		internal int hash_Slope;

		internal int hash_Shift;

		internal int hash_Fly;

		internal int hash_Attack1;

		internal int hash_Attack2;

		internal int hash_Death;

		internal int hash_Damaged;

		internal int hash_Stunned;

		internal int hash_IDInt;

		internal int hash_IDFloat;

		internal int hash_Swim;

		internal int hash_Underwater;

		internal int hash_IDAction;

		internal int hash_Action;

		internal int hash_StateTime;

		internal int hash_Stance;

		[HideInInspector]
		private bool hasFly;

		[HideInInspector]
		private bool hasDodge;

		[HideInInspector]
		private bool hasSlope;

		[HideInInspector]
		private bool hasStun;

		[HideInInspector]
		private bool hasAttack2;

		[HideInInspector]
		private bool hasUpDown;

		[HideInInspector]
		private bool hasUnderwater;

		[HideInInspector]
		private bool hasSwim;

		[HideInInspector]
		private bool hasStateTime;

		[HideInInspector]
		private bool hasStance;

		public float airRotation = 100f;

		public bool AirControl;

		public float airMaxSpeed = 1f;

		public float airSmoothness = 2f;

		internal Vector3 AirControlDir;

		public float movementS1 = 1f;

		public float movementS2 = 2f;

		public float movementS3 = 3f;

		[Range(0f, 90f)]
		public float maxAngleSlope = 45f;

		public bool SlowSlopes = true;

		[Range(0f, 100f)]
		public int GotoSleep;

		public float SnapToGround = 20f;

		public float AlingToGround = 30f;

		public float FallRayDistance = 0.1f;

		public float BackFallRayDistance = 0.5f;

		public float FallRayMultiplier = 1f;

		public bool SmoothVertical = true;

		public bool IgnoreYDir;

		public float TurnMultiplier = 100f;

		public float waterLine;

		public Speeds swimSpeed = new Speeds(8f, 4f, 6f);

		internal int WaterLayer;

		public bool canSwim = true;

		public bool CanGoUnderWater;

		[Range(0f, 90f)]
		public float bank;

		public Speeds underWaterSpeed = new Speeds(8f, 4f, 6f);

		public Speeds flySpeed;

		public bool StartFlying;

		public bool canFly;

		public bool land = true;

		protected float LastGroundSpeed;

		public bool LockUp;

		public float life = 100f;

		public float defense;

		public float damageDelay = 0.5f;

		public float damageInterrupt = 0.2f;

		public int TotalAttacks = 3;

		public int activeAttack = -1;

		public float attackStrength = 10f;

		public float attackDelay = 0.5f;

		public bool inmune;

		protected bool attack1;

		protected bool attack2;

		protected bool isAttacking;

		protected bool isTakingDamage;

		protected bool damaged;

		protected bool death;

		protected List<AttackTrigger> Attack_Triggers;

		public float animatorSpeed = 1f;

		public float upDownSmoothness = 2f;

		public bool debug = true;

		protected RaycastHit hit_Hip;

		protected RaycastHit hit_Chest;

		protected RaycastHit WaterHitCenter;

		protected RaycastHit FallHit;

		protected Vector3 fall_Point;

		protected Vector3 _hitDirection;

		protected Vector3 UpVector = Vector3.up;

		protected float scaleFactor = 1f;

		protected List<Pivots> pivots = new List<Pivots>();

		protected Pivots pivot_Chest;

		protected Pivots pivot_Hip;

		protected Pivots pivot_Water;

		public int PivotsRayInterval = 1;

		public int FallRayInterval = 3;

		public int WaterRayInterval = 5;

		public UnityEvent OnJump;

		public UnityEvent OnAttack;

		public FloatEvent OnGetDamaged;

		public UnityEvent OnDeathE;

		public UnityEvent OnAction;

		public UnityEvent OnSwim;

		public BoolEvent OnFly;

		public UnityEvent OnUnderWater;

		public IntEvent OnAnimationChange;

		public IntEvent OnStanceChange;

		public UnityEvent OnSyncAnimator;

		private static RaycastHit NULLRayCast = default(RaycastHit);

		private List<Collider> _col_ = new List<Collider>();

		[HideInInspector]
		public int FrameCounter;

		public BoolEvent OnMovementReleased = new BoolEvent();

		private float swimChanged;

		[SerializeField]
		private bool useShift = true;

		public int CurrentAnimState;

		private int lastAnimTag;

		private Transform _transform;

		public int NextAnimState;

		private int lastStance;

		[HideInInspector]
		public bool EditorGeneral = true;

		[HideInInspector]
		public bool EditorGround = true;

		[HideInInspector]
		public bool EditorWater = true;

		[HideInInspector]
		public bool EditorAir = true;

		[HideInInspector]
		public bool EditorAdvanced = true;

		[HideInInspector]
		public bool EditorAirControl = true;

		[HideInInspector]
		public bool EditorAttributes = true;

		[HideInInspector]
		public bool EditorEvents;

		[HideInInspector]
		public bool EditorAnimatorParameters;

		public bool IsJumping => AnimState == AnimTag.Jump;

		public bool ActiveColliders { get; private set; }

		public virtual bool Gravity
		{
			get
			{
				return _RigidBody.useGravity;
			}
			set
			{
				_RigidBody.useGravity = value;
			}
		}

		public Vector3 T_ForwardNoY => new Vector3(T_Forward.x, 0f, T_Forward.z).normalized;

		public Rigidbody _RigidBody
		{
			get
			{
				if (_rigidbody == null)
				{
					_rigidbody = GetComponentInChildren<Rigidbody>();
				}
				return _rigidbody;
			}
		}

		public virtual float GroundSpeed
		{
			get
			{
				return groundSpeed;
			}
			set
			{
				groundSpeed = value;
			}
		}

		public virtual float Speed
		{
			get
			{
				return vertical;
			}
			set
			{
				vertical = value;
			}
		}

		public float Slope
		{
			get
			{
				slope = 0f;
				if ((bool)pivot_Chest && (bool)pivot_Hip)
				{
					float num = Vector3.Angle(SurfaceNormal, UpVector);
					float num2 = 1f;
					num2 = ((pivot_Chest.Y > pivot_Hip.Y) ? 1 : (-1));
					slope = num / maxAngleSlope * (float)((!(num2 <= 0f)) ? 1 : (-1));
					return slope;
				}
				return 0f;
			}
		}

		public virtual bool MovementReleased
		{
			get
			{
				return movementReleased;
			}
			private set
			{
				if (movementReleased != value)
				{
					movementReleased = value;
					OnMovementReleased.Invoke(value);
				}
			}
		}

		public virtual bool Swim
		{
			get
			{
				return swim;
			}
			set
			{
				if (swim != value && Time.time - swimChanged >= 0.8f)
				{
					swim = value;
					swimChanged = Time.time;
					currentSpeed = swimSpeed;
					if (swim)
					{
						fall = (isInAir = (fly = false));
						OnSwim.Invoke();
						_RigidBody.constraints = Still_Constraints;
						currentSpeed = swimSpeed;
					}
				}
			}
		}

		public float Direction => horizontal;

		public int Loops
		{
			get
			{
				return loops;
			}
			set
			{
				loops = value;
			}
		}

		public int IDInt
		{
			get
			{
				return idInt;
			}
			set
			{
				idInt = value;
			}
		}

		public float IDFloat
		{
			get
			{
				return idfloat;
			}
			set
			{
				idfloat = value;
			}
		}

		public int Tired
		{
			get
			{
				return tired;
			}
			set
			{
				tired = value;
			}
		}

		public bool IsInWater => isInWater;

		public bool SpeedUp
		{
			set
			{
				if (value)
				{
					if (groundSpeed == movementS1)
					{
						Speed2 = true;
					}
					else if (groundSpeed == movementS2)
					{
						Speed3 = true;
					}
				}
			}
		}

		public bool SpeedDown
		{
			set
			{
				if (value)
				{
					if (groundSpeed == movementS3)
					{
						Speed2 = true;
					}
					else if (groundSpeed == movementS2)
					{
						Speed1 = true;
					}
				}
			}
		}

		public bool Speed1
		{
			get
			{
				return speed1;
			}
			set
			{
				if (value)
				{
					speed1 = value;
					speed2 = (speed3 = false);
					groundSpeed = movementS1;
				}
			}
		}

		public bool Speed2
		{
			get
			{
				return speed2;
			}
			set
			{
				if (value)
				{
					speed2 = value;
					speed1 = (speed3 = false);
					groundSpeed = movementS2;
				}
			}
		}

		public bool Speed3
		{
			get
			{
				return speed3;
			}
			set
			{
				if (value)
				{
					speed3 = value;
					speed2 = (speed1 = false);
					groundSpeed = movementS3;
				}
			}
		}

		public bool Jump
		{
			get
			{
				return jump;
			}
			set
			{
				jump = value;
			}
		}

		public bool Underwater
		{
			get
			{
				return underwater;
			}
			set
			{
				if (CanGoUnderWater)
				{
					underwater = value;
				}
			}
		}

		public bool Shift
		{
			get
			{
				return shift;
			}
			set
			{
				shift = value;
			}
		}

		public bool Down
		{
			get
			{
				return down;
			}
			set
			{
				down = value;
			}
		}

		public bool Up
		{
			get
			{
				return up;
			}
			set
			{
				up = value;
			}
		}

		public bool Dodge
		{
			get
			{
				return dodge;
			}
			set
			{
				dodge = value;
			}
		}

		public bool Damaged
		{
			get
			{
				return damaged;
			}
			set
			{
				damaged = value;
			}
		}

		public bool Fly
		{
			get
			{
				if (!canFly)
				{
					fly = false;
				}
				return fly;
			}
			set
			{
				if (canFly && value)
				{
					fly = !fly;
					if (fly)
					{
						_RigidBody.useGravity = false;
						LastGroundSpeed = groundSpeed;
						groundSpeed = 1f;
						IsInAir = true;
						currentSpeed = flySpeed;
						Quaternion rotation = Quaternion.FromToRotation(T_Up, UpVector) * _transform.rotation;
						StartCoroutine(MalbersTools.AlignTransformsC(_transform, rotation, 0.3f));
					}
					else
					{
						groundSpeed = LastGroundSpeed;
					}
					OnFly.Invoke(fly);
				}
			}
		}

		public bool Death
		{
			get
			{
				return death;
			}
			set
			{
				death = value;
				if (death)
				{
					Anim.SetTrigger(Hash.Death);
					Anim.SetBool(Hash.Attack1, value: false);
					if (hasAttack2)
					{
						Anim.SetBool(Hash.Attack2, value: false);
					}
					Anim.SetBool(Hash.Action, value: false);
					OnDeathE.Invoke();
					if (Animals.Count > 0)
					{
						Animals.Remove(this);
					}
				}
			}
		}

		public bool Attack1
		{
			get
			{
				return attack1;
			}
			set
			{
				if (!value)
				{
					attack1 = value;
				}
				if (!death && AnimState != AnimTag.Action && !isAttacking && value)
				{
					attack1 = value;
					IDInt = activeAttack;
					if (IDInt <= 0)
					{
						SetIntIDRandom(TotalAttacks);
					}
					OnAttack.Invoke();
				}
			}
		}

		public bool Attack2
		{
			get
			{
				return attack2;
			}
			set
			{
				if (!death && (!value || AnimState != AnimTag.Action))
				{
					attack2 = value;
				}
			}
		}

		public bool Stun
		{
			get
			{
				return stun;
			}
			set
			{
				stun = value;
			}
		}

		public bool Action
		{
			get
			{
				return action;
			}
			set
			{
				if (ActionID != -1 && !death && action != value)
				{
					action = value;
					if (action)
					{
						StartCoroutine(ToggleAction());
					}
				}
			}
		}

		public int ActionID
		{
			get
			{
				return actionID;
			}
			set
			{
				actionID = value;
			}
		}

		public bool IsAttacking
		{
			get
			{
				return isAttacking;
			}
			set
			{
				isAttacking = value;
			}
		}

		public bool RootMotion
		{
			get
			{
				return Anim.applyRootMotion;
			}
			set
			{
				Anim.applyRootMotion = value;
			}
		}

		public bool IsInAir
		{
			get
			{
				return isInAir;
			}
			set
			{
				isInAir = value;
				StillConstraints(!IsInAir);
			}
		}

		public bool Stand => stand;

		public Vector3 HitDirection
		{
			get
			{
				return _hitDirection;
			}
			set
			{
				_hitDirection = value;
			}
		}

		public float ScaleFactor => scaleFactor;

		public Pivots Pivot_Hip => pivot_Hip;

		public Pivots Pivot_Chest => pivot_Chest;

		public int AnimState
		{
			get
			{
				if (NextAnimState == 0)
				{
					return CurrentAnimState;
				}
				return NextAnimState;
			}
		}

		public int LastAnimationTag
		{
			get
			{
				return lastAnimTag;
			}
			private set
			{
				lastAnimTag = value;
				OnAnimationChange.Invoke(value);
			}
		}

		public Animator Anim
		{
			get
			{
				if (anim == null)
				{
					anim = GetComponent<Animator>();
				}
				return anim;
			}
		}

		public Vector3 Pivot_fall => fall_Point;

		public float Pivot_Multiplier => (Pivot_Chest ? Pivot_Chest.multiplier : (Pivot_Hip ? Pivot_Hip.multiplier : 1f)) * scaleFactor;

		public Vector3 Main_Pivot_Point
		{
			get
			{
				if ((bool)pivot_Chest)
				{
					return pivot_Chest.GetPivot;
				}
				if ((bool)pivot_Hip)
				{
					return pivot_Hip.GetPivot;
				}
				Vector3 position = _transform.position;
				position.y += height;
				return position;
			}
		}

		public static RigidbodyConstraints Still_Constraints => (RigidbodyConstraints)116;

		public Vector3 MovementAxis
		{
			get
			{
				return movementAxis;
			}
			set
			{
				movementAxis = value;
			}
		}

		public float MovementForward
		{
			get
			{
				return movementAxis.z;
			}
			set
			{
				movementAxis.z = value;
				MovementReleased = value == 0f;
			}
		}

		public float MovementRight
		{
			get
			{
				return movementAxis.x;
			}
			set
			{
				movementAxis.x = value;
				MovementReleased = value == 0f;
			}
		}

		public float MovementUp
		{
			get
			{
				return movementAxis.y;
			}
			set
			{
				movementAxis.y = value;
				MovementReleased = value == 0f;
			}
		}

		public Vector3 SurfaceNormal
		{
			get
			{
				if ((bool)pivot_Hip && hit_Hip.transform != null)
				{
					if ((bool)Pivot_Chest && hit_Chest.transform != null)
					{
						Vector3 normalized = (hit_Chest.point - hit_Hip.point).normalized;
						Vector3 normalized2 = Vector3.Cross(UpVector, normalized).normalized;
						return Vector3.Cross(normalized, normalized2).normalized;
					}
					return hit_Hip.normal;
				}
				return Vector3.up;
			}
		}

		public Renderer AnimalMesh
		{
			get
			{
				return animalMesh;
			}
			set
			{
				animalMesh = value;
			}
		}

		public float Waterlevel
		{
			get
			{
				return waterLevel;
			}
			set
			{
				waterLevel = value;
			}
		}

		public bool DirectionalMovement => directionalMovement;

		public Vector3 RawDirection
		{
			get
			{
				return rawDirection;
			}
			set
			{
				rawDirection = value;
			}
		}

		public bool Land
		{
			get
			{
				return land;
			}
			set
			{
				land = value;
			}
		}

		public float StateTime
		{
			get
			{
				return stateTime;
			}
			set
			{
				stateTime = value;
			}
		}

		public int Stance
		{
			get
			{
				return stance;
			}
			set
			{
				if (stance != value)
				{
					lastStance = stance;
					stance = value;
					OnStanceChange.Invoke(value);
				}
				if (hasStance)
				{
					Anim.SetInteger(Hash.Stance, stance);
				}
			}
		}

		public int LastStance => lastStance;

		public bool UseShift
		{
			get
			{
				return useShift;
			}
			set
			{
				useShift = value;
			}
		}

		public virtual void OnAnimatorBehaviourMessage(string message, object value)
		{
			this.InvokeWithParams(message, value);
		}

		public virtual void WakeAnimal()
		{
			MovementAxis = Vector3.forward * 3f;
			ActionID = -2;
		}

		public virtual void ToggleStance(int NewStance)
		{
			Stance = ((Stance != NewStance) ? NewStance : 0);
		}

		public virtual void ResetInputs()
		{
			Attack1 = false;
			Attack2 = false;
			Shift = false;
			Jump = false;
			Action = false;
			ActionID = 0;
			MovementAxis = Vector3.zero;
			RawDirection = Vector3.zero;
		}

		public virtual void ToggleStance(IntVar NewStance)
		{
			Stance = ((Stance != (int)NewStance) ? ((int)NewStance) : 0);
		}

		public virtual void ToggleTurnSpeed(float speeds)
		{
			if (walkSpeed.rotation != speeds)
			{
				walkSpeed.rotation = (trotSpeed.rotation = (runSpeed.rotation = speeds));
			}
			else
			{
				walkSpeed.rotation = (trotSpeed.rotation = (runSpeed.rotation = 0f));
			}
		}

		public virtual void InterruptAction()
		{
			MovementAxis = Vector3.forward * 3f;
			ActionID = -2;
		}

		public virtual void getDamaged(DamageValues DV)
		{
			if (!Death && !isTakingDamage && !inmune)
			{
				float num = DV.Amount - defense;
				OnGetDamaged.Invoke(num);
				life -= num;
				ActionID = -2;
				if (life > 0f)
				{
					damaged = true;
					StartCoroutine(IsTakingDamageTime(damageDelay));
					_hitDirection = DV.Direction;
				}
				else
				{
					Death = true;
				}
			}
		}

		public virtual void Stop()
		{
			movementAxis = Vector3.zero;
			RawDirection = Vector3.zero;
		}

		public virtual void getDamaged(Vector3 Mycenter, Vector3 Theircenter, float Amount = 0f)
		{
			DamageValues dV = new DamageValues(Mycenter - Theircenter, Amount);
			getDamaged(dV);
		}

		private IEnumerator IsTakingDamageTime(float time)
		{
			isTakingDamage = true;
			yield return new WaitForSeconds(time);
			isTakingDamage = false;
		}

		public virtual void AttackTrigger(int triggerIndex)
		{
			if (triggerIndex == -1)
			{
				foreach (AttackTrigger attack_Trigger in Attack_Triggers)
				{
					attack_Trigger.Collider.enabled = true;
					attack_Trigger.gameObject.SetActive(value: true);
				}
				return;
			}
			if (triggerIndex == 0)
			{
				foreach (AttackTrigger attack_Trigger2 in Attack_Triggers)
				{
					attack_Trigger2.Collider.enabled = false;
					attack_Trigger2.gameObject.SetActive(value: false);
				}
				return;
			}
			List<AttackTrigger> list = Attack_Triggers.FindAll((AttackTrigger item) => item.index == triggerIndex);
			if (list == null)
			{
				return;
			}
			foreach (AttackTrigger item in list)
			{
				item.Collider.enabled = true;
				item.gameObject.SetActive(value: true);
			}
		}

		public virtual void SetAttack()
		{
			activeAttack = -1;
			Attack1 = true;
		}

		public virtual void SetLoop(int cycles)
		{
			Loops = cycles;
		}

		public virtual void SetAttack(int attackID)
		{
			activeAttack = attackID;
			Attack1 = true;
		}

		public virtual void SetAttack(bool value)
		{
			Attack1 = value;
		}

		public virtual void SetSecondaryAttack()
		{
			if (hasAttack2)
			{
				StartCoroutine(ToogleAttack2());
			}
		}

		public virtual void RigidDrag(float amount)
		{
			_RigidBody.drag = amount;
		}

		private IEnumerator ToogleAttack2()
		{
			for (int i = 0; i < ToogleAmount; i++)
			{
				Attack2 = true;
				yield return null;
			}
			Attack2 = false;
		}

		public virtual bool CurrentAnimation(params int[] AnimsTags)
		{
			for (int i = 0; i < AnimsTags.Length; i++)
			{
				if (AnimState == AnimsTags[i])
				{
					return true;
				}
			}
			return false;
		}

		public void SetIntID(int value)
		{
			IDInt = value;
			Anim.SetInteger(Hash.IDInt, IDInt);
		}

		public void SetFloatID(float value)
		{
			IDFloat = value;
			Anim.SetFloat(Hash.IDFloat, IDFloat);
		}

		protected void SetIntIDRandom(int range)
		{
			IDInt = UnityEngine.Random.Range(1, range + 1);
		}

		public virtual void StillConstraints(bool active)
		{
			_RigidBody.constraints = (active ? Still_Constraints : RigidbodyConstraints.FreezeRotation);
		}

		public virtual void EnableColliders(bool active)
		{
			ActiveColliders = active;
			if (!active)
			{
				_col_ = GetComponentsInChildren<Collider>(includeInactive: false).ToList();
				List<Collider> list = new List<Collider>();
				foreach (Collider item in _col_)
				{
					if (!item.isTrigger && item.enabled)
					{
						list.Add(item);
					}
				}
				_col_ = list;
			}
			foreach (Collider item2 in _col_)
			{
				item2.enabled = active;
			}
			if (active)
			{
				_col_ = new List<Collider>();
			}
		}

		public virtual void InAir(bool active)
		{
			IsInAir = active;
			StillConstraints(!active);
		}

		public virtual void SetJump()
		{
			StartCoroutine(ToggleJump());
		}

		public virtual void SetAction(int ID)
		{
			ActionID = ID;
			Action = true;
		}

		public virtual void SetAction(Action ID)
		{
			ActionID = ID;
			Action = true;
		}

		public virtual void SetAction(string actionName)
		{
			if (Anim.HasState(0, Animator.StringToHash(actionName)))
			{
				if (AnimState != AnimTag.Action && ActionID <= 0)
				{
					Anim.CrossFade(actionName, 0.1f, 0);
				}
			}
			else
			{
				UnityEngine.Debug.LogWarning("The animal does not have an action called " + actionName);
			}
		}

		public virtual void ResetAnimal()
		{
			fly = false;
			swim = false;
			fall = false;
			action = false;
			attack1 = false;
			damaged = false;
			attack2 = false;
			anim.Rebind();
		}

		public virtual void SetStun(float time)
		{
			if (StunC != null)
			{
				StopCoroutine(StunC);
			}
			StunC = null;
			StunC = ToggleStun(time);
			StartCoroutine(StunC);
		}

		public virtual void DisableAnimal()
		{
			base.enabled = false;
			MalbersInput component = GetComponent<MalbersInput>();
			if ((bool)component)
			{
				component.enabled = false;
			}
		}

		public virtual void SetFly(bool value)
		{
			if (canFly && hasFly)
			{
				fly = !value;
				Fly = true;
			}
		}

		public virtual void SetToGlide(float value)
		{
			if (fly && fall)
			{
				StartCoroutine(GravityDrag(value));
			}
		}

		internal IEnumerator GravityDrag(float value)
		{
			while (AnimState != AnimTag.Fly)
			{
				yield return null;
			}
			groundSpeed = 2f;
			if ((bool)_RigidBody)
			{
				_RigidBody.useGravity = true;
				_RigidBody.drag = value;
			}
		}

		internal IEnumerator ToggleJump()
		{
			for (int i = 0; i < ToogleAmount; i++)
			{
				Jump = true;
				yield return null;
			}
			Jump = false;
		}

		internal IEnumerator ToggleAction()
		{
			for (int i = 0; i < ToogleAmount; i++)
			{
				action = true;
				if (AnimState == AnimTag.Action)
				{
					OnAction.Invoke();
					SetFloatID(-1f);
					break;
				}
				yield return null;
			}
			action = false;
			if (AnimState != AnimTag.Action)
			{
				ActionID = -1;
				SetFloatID(0f);
			}
		}

		internal IEnumerator ToggleStun(float time)
		{
			Stun = true;
			yield return new WaitForSeconds(time);
			stun = false;
		}

		public void InitializeInputs(Dictionary<string, BoolEvent> keys)
		{
			if (Inputs == null)
			{
				Inputs = new Dictionary<string, BoolEvent>();
			}
			Inputs = keys;
			CharacterConnect();
		}

		public void SetInput(string key, bool value)
		{
			if (Inputs.TryGetValue(key, out var value2))
			{
				value2.Invoke(value);
			}
		}

		public void AddInput(string key, BoolEvent NewBool)
		{
			if (!Inputs.ContainsKey(key))
			{
				Inputs.Add(key, NewBool);
			}
		}

		private void CharacterConnect()
		{
			if (Inputs.TryGetValue("Attack1", out var value2))
			{
				value2.AddListener(delegate(bool value)
				{
					Attack1 = value;
				});
			}
			if (Inputs.TryGetValue("Attack2", out var value3))
			{
				value3.AddListener(delegate(bool value)
				{
					Attack2 = value;
				});
			}
			if (Inputs.TryGetValue("Action", out var value4))
			{
				value4.AddListener(delegate(bool value)
				{
					Action = value;
				});
			}
			if (Inputs.TryGetValue("Jump", out var value5))
			{
				value5.AddListener(delegate(bool value)
				{
					Jump = value;
				});
			}
			if (Inputs.TryGetValue("Shift", out var value6))
			{
				value6.AddListener(delegate(bool value)
				{
					Shift = value;
				});
			}
			if (Inputs.TryGetValue("Fly", out var value7))
			{
				value7.AddListener(delegate(bool value)
				{
					Fly = value;
				});
			}
			if (Inputs.TryGetValue("Down", out var value8))
			{
				value8.AddListener(delegate(bool value)
				{
					Down = value;
				});
			}
			if (Inputs.TryGetValue("Up", out var value9))
			{
				value9.AddListener(delegate(bool value)
				{
					Up = value;
				});
			}
			if (Inputs.TryGetValue("Dodge", out var value10))
			{
				value10.AddListener(delegate(bool value)
				{
					Dodge = value;
				});
			}
			if (Inputs.TryGetValue("Death", out var value11))
			{
				value11.AddListener(delegate(bool value)
				{
					Death = value;
				});
			}
			if (Inputs.TryGetValue("Stun", out var value12))
			{
				value12.AddListener(delegate(bool value)
				{
					Stun = value;
				});
			}
			if (Inputs.TryGetValue("Damaged", out var value13))
			{
				value13.AddListener(delegate(bool value)
				{
					Damaged = value;
				});
			}
			if (Inputs.TryGetValue("Speed1", out var value14))
			{
				value14.AddListener(delegate(bool value)
				{
					Speed1 = value;
				});
			}
			if (Inputs.TryGetValue("Speed2", out var value15))
			{
				value15.AddListener(delegate(bool value)
				{
					Speed2 = value;
				});
			}
			if (Inputs.TryGetValue("Speed3", out var value16))
			{
				value16.AddListener(delegate(bool value)
				{
					Speed3 = value;
				});
			}
			if (Inputs.TryGetValue("SpeedUp", out var value17))
			{
				value17.AddListener(delegate(bool value)
				{
					SpeedUp = value;
				});
			}
			if (Inputs.TryGetValue("SpeedDown", out var value18))
			{
				value18.AddListener(delegate(bool value)
				{
					SpeedDown = value;
				});
			}
		}

		private void Reset()
		{
			MalbersTools.SetLayer(base.transform, 20);
			base.gameObject.tag = "Animal";
		}

		protected virtual void GetHashIDs()
		{
			hash_Vertical = Animator.StringToHash(m_Vertical);
			hash_Horizontal = Animator.StringToHash(m_Horizontal);
			hash_UpDown = Animator.StringToHash(m_UpDown);
			hash_Stand = Animator.StringToHash(m_Stand);
			hash_Jump = Animator.StringToHash(m_Jump);
			hash_Dodge = Animator.StringToHash(m_Dodge);
			hash_Fall = Animator.StringToHash(m_Fall);
			hash_Type = Animator.StringToHash(m_Type);
			hash_Slope = Animator.StringToHash(m_Slope);
			hash_Shift = Animator.StringToHash(m_Shift);
			hash_Fly = Animator.StringToHash(m_Fly);
			hash_Attack1 = Animator.StringToHash(m_Attack1);
			hash_Attack2 = Animator.StringToHash(m_Attack2);
			hash_Death = Animator.StringToHash(m_Death);
			hash_Damaged = Animator.StringToHash(m_Damaged);
			hash_Stunned = Animator.StringToHash(m_Stunned);
			hash_IDInt = Animator.StringToHash(m_IDInt);
			hash_IDFloat = Animator.StringToHash(m_IDFloat);
			hash_Swim = Animator.StringToHash(m_Swim);
			hash_Underwater = Animator.StringToHash(m_Underwater);
			hash_Action = Animator.StringToHash(m_Action);
			hash_IDAction = Animator.StringToHash(m_IDAction);
			hash_StateTime = Animator.StringToHash(m_StateTime);
			hash_Stance = Animator.StringToHash(m_Stance);
		}

		private void Awake()
		{
			AnimalMesh = GetComponentInChildren<Renderer>();
			anim = GetComponent<Animator>();
			GetHashIDs();
			_transform = base.transform;
			if (MalbersTools.FindAnimatorParameter(Anim, AnimatorControllerParameterType.Int, hash_Type))
			{
				Anim.SetInteger(hash_Type, animalTypeID);
			}
			WaterLayer = LayerMask.GetMask("Water");
			anim.applyRootMotion = true;
		}

		private void Start()
		{
			SetStart();
		}

		protected virtual void SetStart()
		{
			DeltaPosition = Vector3.zero;
			_RigidBody.isKinematic = false;
			Anim.updateMode = AnimatorUpdateMode.Normal;
			isInAir = false;
			scaleFactor = _transform.localScale.y;
			MovementReleased = true;
			SetPivots();
			ActiveColliders = true;
			switch (StartSpeed)
			{
			case Ground.walk:
				Speed1 = true;
				break;
			case Ground.trot:
				Speed2 = true;
				break;
			case Ground.run:
				Speed3 = true;
				break;
			}
			Attack_Triggers = GetComponentsInChildren<AttackTrigger>(includeInactive: true).ToList();
			OptionalAnimatorParameters();
			Start_Flying();
			FrameCounter = UnityEngine.Random.Range(0, 10000);
			OnAnimationChange.AddListener(OnAnimationStateEnter);
		}

		public virtual void SetPivots()
		{
			pivots = GetComponentsInChildren<Pivots>().ToList();
			if (pivots != null)
			{
				pivot_Hip = pivots.Find((Pivots p) => p.name.ToUpper().Contains("HIP"));
				pivot_Chest = pivots.Find((Pivots p) => p.name.ToUpper().Contains("CHEST"));
				pivot_Water = pivots.Find((Pivots p) => p.name.ToUpper().Contains("WATER"));
			}
		}

		protected virtual void Start_Flying()
		{
			if (hasFly && StartFlying && canFly)
			{
				stand = false;
				Fly = true;
				Anim.Play("Fly", 0);
				IsInAir = true;
				_RigidBody.useGravity = false;
			}
		}

		protected void OptionalAnimatorParameters()
		{
			if (MalbersTools.FindAnimatorParameter(Anim, AnimatorControllerParameterType.Bool, hash_Swim))
			{
				hasSwim = true;
			}
			if (MalbersTools.FindAnimatorParameter(Anim, AnimatorControllerParameterType.Bool, hash_Dodge))
			{
				hasDodge = true;
			}
			if (MalbersTools.FindAnimatorParameter(Anim, AnimatorControllerParameterType.Bool, hash_Fly))
			{
				hasFly = true;
			}
			if (MalbersTools.FindAnimatorParameter(Anim, AnimatorControllerParameterType.Bool, hash_Attack2))
			{
				hasAttack2 = true;
			}
			if (MalbersTools.FindAnimatorParameter(Anim, AnimatorControllerParameterType.Bool, hash_Stunned))
			{
				hasStun = true;
			}
			if (MalbersTools.FindAnimatorParameter(Anim, AnimatorControllerParameterType.Bool, hash_Underwater))
			{
				hasUnderwater = true;
			}
			if (MalbersTools.FindAnimatorParameter(Anim, AnimatorControllerParameterType.Float, hash_UpDown))
			{
				hasUpDown = true;
			}
			if (MalbersTools.FindAnimatorParameter(Anim, AnimatorControllerParameterType.Float, hash_Slope))
			{
				hasSlope = true;
			}
			if (MalbersTools.FindAnimatorParameter(Anim, AnimatorControllerParameterType.Float, hash_StateTime))
			{
				hasStateTime = true;
			}
			if (MalbersTools.FindAnimatorParameter(Anim, AnimatorControllerParameterType.Int, hash_Stance))
			{
				hasStance = true;
			}
		}

		public virtual void LinkingAnimator()
		{
			if (!Death)
			{
				Anim.SetFloat(hash_Vertical, vertical);
				Anim.SetFloat(hash_Horizontal, horizontal);
				Anim.SetBool(hash_Stand, stand);
				Anim.SetBool(hash_Shift, Shift);
				Anim.SetBool(hash_Jump, jump);
				Anim.SetBool(hash_Attack1, attack1);
				Anim.SetBool(hash_Damaged, damaged);
				Anim.SetBool(hash_Action, action);
				Anim.SetInteger(hash_IDAction, ActionID);
				Anim.SetInteger(hash_IDInt, IDInt);
				if (hasSlope)
				{
					Anim.SetFloat(hash_Slope, Slope);
				}
				if (hasStun)
				{
					Anim.SetBool(hash_Stunned, stun);
				}
				if (hasAttack2)
				{
					Anim.SetBool(hash_Attack2, attack2);
				}
				if (hasUpDown)
				{
					Anim.SetFloat(hash_UpDown, movementAxis.y);
				}
				if (hasStateTime)
				{
					Anim.SetFloat(hash_StateTime, StateTime);
				}
				if (hasDodge)
				{
					Anim.SetBool(hash_Dodge, dodge);
				}
				if (hasFly && canFly)
				{
					Anim.SetBool(hash_Fly, Fly);
				}
				if (hasSwim && canSwim)
				{
					Anim.SetBool(hash_Swim, swim);
				}
				if (hasUnderwater && CanGoUnderWater)
				{
					Anim.SetBool(hash_Underwater, underwater);
				}
			}
			Anim.SetBool(hash_Fall, fall);
			OnSyncAnimator.Invoke();
		}

		public virtual void Move(Vector3 move, bool active = true)
		{
			MovementReleased = move.x == 0f && move.z == 0f;
			directionalMovement = active;
			float deltaTime = Time.deltaTime;
			RawDirection = move.normalized;
			if (LockUp && move.y > 0f)
			{
				move.y = 0f;
			}
			if (active)
			{
				if (move.magnitude > 1f)
				{
					move.Normalize();
				}
				RawDirection = Vector3.Lerp(RawDirection, move, deltaTime * upDownSmoothness * 5f);
				move = _transform.InverseTransformDirection(move);
				if (!Fly && !underwater)
				{
					move = Vector3.ProjectOnPlane(move, SurfaceNormal).normalized;
				}
				float x = Mathf.Atan2(move.x, move.z);
				float num = move.z;
				if (!SmoothVertical)
				{
					if (num > 0f)
					{
						num = 1f;
					}
					if (num < 0f)
					{
						num = -1f;
					}
				}
				movementAxis = new Vector3(x, IgnoreYDir ? movementAxis.y : RawDirection.y, Mathf.Abs(num));
				if ((Fly || underwater) && !Up && !Down && IgnoreYDir)
				{
					movementAxis.y = Mathf.Lerp(movementAxis.y, 0f, deltaTime * upDownSmoothness * 3f);
				}
				if (!stand && AnimState != AnimTag.Action && AnimState != AnimTag.Sleep)
				{
					DeltaRotation *= Quaternion.Euler(0f, movementAxis.x * deltaTime * TurnMultiplier, 0f);
					DeltaPosition += _transform.DeltaPositionFromRotate(AnimalMesh.bounds.center, UpVector, movementAxis.x * deltaTime * TurnMultiplier);
				}
				if (AnimState == AnimTag.Action)
				{
					movementAxis = Vector3.zero;
				}
			}
			else
			{
				movementAxis = new Vector3(move.x, movementAxis.y, move.z);
			}
		}

		protected virtual void AdditionalTurn(float time)
		{
			float rotation = currentSpeed.rotation;
			float num = Mathf.Clamp(horizontal, -1f, 1f) * (float)((movementAxis.z >= 0f) ? 1 : (-1));
			Vector3 euler = _transform.InverseTransformDirection(0f, rotation * 2f * num * time, 0f);
			DeltaRotation *= Quaternion.Euler(euler);
			if (!Fly && !swim && !stun && AnimState != AnimTag.Action && (AnimState == AnimTag.Jump || AnimState == AnimTag.Fall))
			{
				float num2 = airRotation * horizontal * time * (float)((movementAxis.z >= 0f) ? 1 : (-1));
				DeltaRotation *= Quaternion.Euler(_transform.InverseTransformDirection(0f, num2, 0f));
				DeltaPosition += _transform.DeltaPositionFromRotate(AnimalMesh.bounds.center, T_Up, num2);
			}
		}

		protected virtual void AdditionalSpeed(float time)
		{
			currentSpeed = new Speeds(1);
			if (hasUnderwater && underwater && CurrentAnimState == AnimTag.Underwater)
			{
				currentSpeed = underWaterSpeed;
			}
			else if (hasSwim && swim && CurrentAnimState == AnimTag.Swim)
			{
				currentSpeed = swimSpeed;
			}
			else if (hasFly && fly && CurrentAnimState == AnimTag.Fly)
			{
				currentSpeed = flySpeed;
			}
			else if (IsJumping || fall || CurrentAnimState == AnimTag.Fall)
			{
				currentSpeed = new Speeds(1);
			}
			else if (Speed3 || (Speed2 && Shift))
			{
				currentSpeed = runSpeed;
			}
			else if (Speed2 || (Speed1 && Shift))
			{
				currentSpeed = trotSpeed;
			}
			else if (Speed1)
			{
				currentSpeed = walkSpeed;
			}
			if (vertical < 0f)
			{
				currentSpeed.position = walkSpeed.position;
			}
			currentSpeed.position *= ScaleFactor;
			Vector3 vector = T_Forward * vertical;
			if (vector.magnitude > 1f)
			{
				vector.Normalize();
			}
			DeltaPosition += vector * currentSpeed.position / 5f * time;
			Anim.speed = Mathf.Lerp(Anim.speed, currentSpeed.animator * animatorSpeed, time * currentSpeed.lerpAnimator);
		}

		public virtual void YAxisMovement(float smoothness, float time)
		{
			if (Up)
			{
				Down = false;
			}
			float num = MovementAxis.y;
			if (Up)
			{
				num = Mathf.Lerp(num, LockUp ? 0f : ((MovementForward > 0f) ? 0.7f : 1f), time * smoothness);
			}
			else if (Down)
			{
				num = Mathf.Lerp(num, (MovementForward > 0f) ? (-0.7f) : (-1f), time * smoothness);
			}
			else if (!DirectionalMovement)
			{
				num = Mathf.Lerp(num, 0f, time * smoothness);
			}
			if (Mathf.Abs(num) < 0.001f)
			{
				num = 0f;
			}
			movementAxis.y = num;
		}

		private void UpdatePlatformMovement(bool update)
		{
			if (platform == null)
			{
				return;
			}
			if (AnimState == AnimTag.Jump || AnimState == AnimTag.NoAlign || underwater || fly)
			{
				platform = null;
				return;
			}
			if (!update)
			{
				FixedDeltaPos = platform.position - platform_Pos;
				platform_Pos = platform.position;
				return;
			}
			float num = platform.eulerAngles.y - platform_formAngle;
			if (num != 0f)
			{
				DeltaRotation *= Quaternion.Euler(0f, num, 0f);
				DeltaPosition += _transform.DeltaPositionFromRotate(platform.position, Vector3.up, num);
				platform_formAngle = platform.eulerAngles.y;
			}
		}

		protected void RayCasting()
		{
			if ((AnimState != AnimTag.Jump && AnimState != AnimTag.JumpEnd && AnimState != AnimTag.Recover && AnimState != AnimTag.Fall && FrameCounter % PivotsRayInterval != 0) || underwater)
			{
				return;
			}
			UpVector = -Physics.gravity;
			scaleFactor = _transform.localScale.y;
			_Height = height * scaleFactor;
			backray = (frontray = false);
			hit_Chest = NULLRayCast;
			hit_Hip = NULLRayCast;
			ref RaycastHit reference = ref hit_Chest;
			float distance = (hit_Hip.distance = _Height);
			reference.distance = distance;
			if (Pivot_Hip != null)
			{
				if (Physics.Raycast(Pivot_Hip.GetPivot, -T_Up, out hit_Hip, scaleFactor * Pivot_Hip.multiplier, GroundLayer))
				{
					if (debug)
					{
						UnityEngine.Debug.DrawRay(hit_Hip.point, hit_Hip.normal * 0.2f, Color.blue);
					}
					backray = true;
					if (platform == null && AnimState != AnimTag.Jump)
					{
						platform = hit_Hip.transform;
						platform_Pos = platform.position;
						platform_formAngle = platform.eulerAngles.y;
					}
				}
				else
				{
					platform = null;
				}
			}
			if (Physics.Raycast(Main_Pivot_Point, -T_Up, out hit_Chest, Pivot_Multiplier, GroundLayer))
			{
				if (debug)
				{
					UnityEngine.Debug.DrawRay(hit_Chest.point, hit_Chest.normal * 0.2f, Color.red);
				}
				if (Vector3.Angle(hit_Chest.normal, Vector3.up) < maxAngleSlope)
				{
					frontray = true;
				}
			}
			if (debug && frontray && backray)
			{
				UnityEngine.Debug.DrawLine(hit_Hip.point, hit_Chest.point, Color.yellow);
			}
			if (!frontray && Stand)
			{
				fall = true;
				if ((bool)pivot_Hip && backray)
				{
					fall = false;
				}
			}
			FixDistance = hit_Hip.distance;
			if (!backray)
			{
				FixDistance = hit_Chest.distance;
			}
			if (!Pivot_Hip)
			{
				backray = frontray;
			}
			if (!Pivot_Chest)
			{
				frontray = backray;
			}
		}

		public virtual void AlignRotation(bool align, float time, float smoothness)
		{
			Quaternion quaternion = Quaternion.FromToRotation(T_Up, SurfaceNormal) * _transform.rotation;
			Quaternion quaternion2 = Quaternion.Inverse(_transform.rotation);
			Quaternion quaternion3;
			if (align)
			{
				quaternion3 = Quaternion.Inverse(_transform.rotation) * quaternion;
			}
			else
			{
				Quaternion quaternion4 = Quaternion.FromToRotation(T_Up, UpVector) * _transform.rotation;
				quaternion3 = quaternion2 * quaternion4;
			}
			quaternion3 = Quaternion.Slerp(DeltaRotation, DeltaRotation * quaternion3, time * smoothness / 2f);
			DeltaRotation *= quaternion3;
		}

		protected virtual void FixRotation(float time)
		{
			if (swim || fly || underwater)
			{
				return;
			}
			if (IsInAir || slope < -1f || AnimState == AnimTag.NoAlign || !backray || (backray && !frontray))
			{
				if (slope < 0f || AnimState == AnimTag.Fall)
				{
					AlignRotation(align: false, time, AlingToGround);
				}
			}
			else
			{
				AlignRotation(align: true, time, AlingToGround);
			}
		}

		internal virtual void RaycastWater()
		{
			if ((bool)pivot_Water)
			{
				if (Physics.Raycast(pivot_Water.transform.position, -T_Up, out WaterHitCenter, scaleFactor * pivot_Water.multiplier * 1.5f, WaterLayer))
				{
					waterLevel = WaterHitCenter.point.y;
					isInWater = true;
				}
				else if (isInWater && AnimState != AnimTag.SwimJump)
				{
					isInWater = false;
				}
			}
		}

		protected virtual void Swimming(float time)
		{
			if (!hasSwim || !canSwim || underwater || Stand || !pivot_Water)
			{
				return;
			}
			if (FrameCounter % WaterRayInterval == 0)
			{
				RaycastWater();
			}
			if (isInWater)
			{
				if (((hit_Chest.distance < _Height * 0.8f && movementAxis.z > 0f && hit_Chest.transform != null) || (hit_Hip.distance < _Height * 0.8f && movementAxis.z < 0f && hit_Hip.transform != null)) && AnimState != AnimTag.Recover)
				{
					Swim = false;
					return;
				}
				if (!swim && Pivot_Chest.Y <= Waterlevel)
				{
					Swim = true;
				}
			}
			if (swim)
			{
				float num = Vector3.Angle(T_Up, WaterHitCenter.normal);
				Quaternion quaternion = Quaternion.FromToRotation(T_Up, WaterHitCenter.normal) * _transform.rotation;
				Quaternion quaternion2 = Quaternion.Inverse(_transform.rotation) * quaternion;
				if (num > 0.5f)
				{
					quaternion2 = Quaternion.Slerp(DeltaRotation, DeltaRotation * quaternion2, time * 10f);
				}
				DeltaRotation *= quaternion2;
				if (CanGoUnderWater && Down && !IsJumping && AnimState != AnimTag.SwimJump)
				{
					underwater = true;
				}
			}
		}

		protected virtual void FixPosition(float time)
		{
			if (swim)
			{
				return;
			}
			float num = _Height - FixDistance;
			if (FixDistance > _Height)
			{
				if (!isInAir && !swim)
				{
					YFix += (((AnimState == AnimTag.Locomotion || Stand) && num > 0.01f) ? num : (num * time * SnapToGround));
				}
			}
			else if (!fall && !IsInAir)
			{
				YFix += ((num < 0.01f || Stand) ? num : (num * time * SnapToGround));
			}
			FixDistance += YFix;
		}

		protected virtual void Falling()
		{
			fall_Point = Main_Pivot_Point + T_Forward * (Shift ? (GroundSpeed + 1f) : GroundSpeed) * FallRayDistance * ScaleFactor;
			if (FrameCounter % FallRayInterval != 0 || AnimState == AnimTag.Sleep || AnimState == AnimTag.Action || AnimState == AnimTag.Swim || AnimState == AnimTag.Idle || swim || underwater)
			{
				return;
			}
			float num = Pivot_Multiplier;
			if (AnimState == AnimTag.Jump || AnimState == AnimTag.Fall || AnimState == AnimTag.Fly)
			{
				num *= FallRayMultiplier;
			}
			if (Physics.Raycast(fall_Point, -T_Up, out FallHit, num, GroundLayer))
			{
				if (debug)
				{
					UnityEngine.Debug.DrawRay(fall_Point, -T_Up * num, Color.magenta);
					MalbersTools.DebugPlane(FallHit.point, 0.1f, Color.magenta, cross: true);
				}
				if (Vector3.Angle(FallHit.normal, Vector3.up) * (float)((Vector3.Dot(T_ForwardNoY, FallHit.normal) > 0f) ? 1 : (-1)) > maxAngleSlope || (!frontray && !backray))
				{
					fall = true;
					return;
				}
				fall = false;
				if (AnimState == AnimTag.Fly && Land)
				{
					SetFly(value: false);
					IsInAir = false;
					groundSpeed = LastGroundSpeed;
				}
				if (AnimState == AnimTag.SwimJump)
				{
					Swim = false;
				}
			}
			else
			{
				fall = true;
				if (debug)
				{
					MalbersTools.DebugPlane(fall_Point + -T_Up * num, 0.1f, Color.gray, cross: true);
					UnityEngine.Debug.DrawRay(fall_Point, -T_Up * num, Color.gray);
				}
			}
		}

		protected virtual bool IsFallingBackwards(float ammount)
		{
			if (FrameCounter % FallRayInterval != 0)
			{
				return false;
			}
			RaycastHit hitInfo = default(RaycastHit);
			Vector3 obj = (Pivot_Hip ? Pivot_Hip.transform.position : (_transform.position + new Vector3(0f, _Height, 0f)));
			float num = (Pivot_Hip ? (Pivot_Hip.multiplier * FallRayMultiplier) : FallRayMultiplier);
			Vector3 vector = obj + T_Forward * -1f * ammount;
			if (debug)
			{
				UnityEngine.Debug.DrawRay(vector, -T_Up * num * scaleFactor, Color.white);
			}
			if (Physics.Raycast(vector, -T_Up, out hitInfo, scaleFactor * num, GroundLayer))
			{
				if ((double)hitInfo.normal.y < 0.6)
				{
					return true;
				}
				return false;
			}
			if (!swim && movementAxis.z < 0f)
			{
				return true;
			}
			return false;
		}

		protected virtual void MovementSystem(float s1 = 1f, float s2 = 2f, float s3 = 3f)
		{
			float num = groundSpeed;
			float num2 = 1f + currentSpeed.lerpRotation;
			float num3 = 1f + currentSpeed.lerpPosition;
			num = ((swim || underwater) ? 1f : num);
			if (Shift && UseShift)
			{
				num += 1f;
			}
			if (!Fly && !Swim && !IsJumping)
			{
				if (SlowSlopes && (double)slope >= 0.5 && num > 1f)
				{
					num -= 1f;
				}
				if (slope >= 1f)
				{
					num = 0f;
					num3 = 10f;
				}
			}
			if (Fly || Underwater)
			{
				YAxisMovement(upDownSmoothness, Time.deltaTime);
			}
			if (movementAxis.z < 0f && !swim && !Fly && !fall && IsFallingBackwards(BackFallRayDistance))
			{
				num = 0f;
				num3 = 10f;
			}
			vertical = Mathf.Lerp(vertical, movementAxis.z * num, Time.deltaTime * num3);
			horizontal = Mathf.Lerp(horizontal, movementAxis.x * (float)((!Shift || !UseShift) ? 1 : 2), Time.deltaTime * num2);
			if (Mathf.Abs(horizontal) > 0.1f || Mathf.Abs(vertical) > 0.2f)
			{
				stand = false;
			}
			else
			{
				stand = true;
			}
			if (!MovementReleased)
			{
				stand = false;
			}
			if (jump || damaged || stun || fall || swim || fly || isInAir || (tired >= GotoSleep && GotoSleep != 0))
			{
				stand = false;
			}
			if (tired >= GotoSleep)
			{
				tired = 0;
			}
			if (!stand)
			{
				tired = 0;
			}
			if (!swim && !fly)
			{
				movementAxis.y = 0f;
			}
		}

		private void FixedUpdate()
		{
			if (!fly && !underwater)
			{
				float fixedDeltaTime = Time.fixedDeltaTime;
				if (swim && AnimState != AnimTag.SwimJump)
				{
					YFix = (Waterlevel - _Height + waterLine - _transform.position.y) * fixedDeltaTime * 5f;
				}
				FixPosition(fixedDeltaTime);
				UpdatePlatformMovement(update: false);
				FixedDeltaPos.y += YFix;
				_transform.position += FixedDeltaPos;
				YFix = 0f;
				FixedDeltaPos = Vector3.zero;
			}
		}

		private void Update()
		{
			float deltaTime = Time.deltaTime;
			UpdateSettings();
			AdditionalSpeed(deltaTime);
			AdditionalTurn(deltaTime);
			RayCasting();
			Swimming(deltaTime);
			FixRotation(deltaTime);
			UpdatePlatformMovement(update: true);
			Falling();
		}

		public virtual void UpdateSettings()
		{
			CurrentAnimState = Anim.GetCurrentAnimatorStateInfo(0).tagHash;
			NextAnimState = Anim.GetNextAnimatorStateInfo(0).tagHash;
			StateTime = Anim.GetCurrentAnimatorStateInfo(0).normalizedTime;
			if (LastAnimationTag != AnimState)
			{
				LastAnimationTag = AnimState;
			}
			T_Up = _transform.up;
			T_Right = _transform.right;
			T_Forward = _transform.forward;
			FrameCounter++;
			FrameCounter %= 100000;
		}

		private void LateUpdate()
		{
			MovementSystem(movementS1, movementS2, movementS3);
			LinkingAnimator();
		}

		private void OnAnimatorMove()
		{
			if (!(Time.timeScale <= float.Epsilon))
			{
				if (Anim.applyRootMotion && Time.deltaTime > 0f)
				{
					_RigidBody.velocity = (Anim.deltaPosition + DeltaPosition) / Time.deltaTime;
				}
				_transform.rotation *= Anim.deltaRotation * DeltaRotation;
				DeltaPosition = Vector3.zero;
				DeltaRotation = Quaternion.identity;
				LastPosition = _transform.position;
			}
		}

		protected virtual void OnAnimationStateEnter(int animTag)
		{
			if (animTag == AnimTag.Locomotion || animTag == AnimTag.Idle)
			{
				IsInAir = false;
				Anim.applyRootMotion = true;
			}
			if (animTag == AnimTag.Swim)
			{
				Anim.applyRootMotion = true;
			}
		}

		private void OnEnable()
		{
			if (Animals == null)
			{
				Animals = new List<Animal>();
			}
			Animals.Add(this);
		}

		private void OnDisable()
		{
			Animals.Remove(this);
		}
	}
	public class DamageValues
	{
		public Vector3 Direction;

		public float Amount;

		public DamageValues(Vector3 dir, float amount = 0f)
		{
			Direction = dir;
			Amount = amount;
		}
	}
	[Serializable]
	public struct Speeds
	{
		public string name;

		public float position;

		public float animator;

		public float lerpPosition;

		public float lerpAnimator;

		public float rotation;

		public float lerpRotation;

		public Speeds(int defaultt)
		{
			position = 0f;
			animator = 1f;
			lerpPosition = 2f;
			lerpAnimator = 2f;
			rotation = 0f;
			lerpRotation = 2f;
			name = string.Empty;
		}

		public Speeds(float lerpPos, float lerpanim, float lerpTurn)
		{
			position = 0f;
			animator = 1f;
			rotation = 0f;
			lerpPosition = lerpPos;
			lerpAnimator = lerpanim;
			lerpRotation = lerpTurn;
			name = string.Empty;
		}
	}
	[Serializable]
	public class AnimalEvent : UnityEvent<Animal>
	{
	}
	[RequireComponent(typeof(Animal))]
	public class AnimalAIControl : MonoBehaviour
	{
		private NavMeshAgent agent;

		protected Animal animal;

		protected ActionZone isActionZone;

		protected MWayPoint isWayPoint;

		protected static Vector3 NullVector = MalbersTools.NullVector;

		protected Vector3 targetPosition = NullVector;

		protected Vector3 TargetLastPosition = NullVector;

		protected float RemainingDistance;

		protected float DefaultStopDistance;

		protected bool EnterOFFMESH;

		protected bool DoingAnAction;

		protected bool EnterAction;

		protected bool Stopped;

		private bool isFlyingOffMesh;

		internal IWayPoint NextWayPoint;

		protected bool flyPending;

		[SerializeField]
		protected float stoppingDistance = 0.6f;

		[SerializeField]
		protected Transform target;

		public bool AutoSpeed = true;

		public float ToTrot = 6f;

		public float ToRun = 8f;

		public bool debug;

		[Space]
		public Vector3Event OnTargetPositionArrived = new Vector3Event();

		public TransformEvent OnTargetArrived = new TransformEvent();

		public UnityEvent OnActionStart = new UnityEvent();

		public UnityEvent OnActionEnd = new UnityEvent();

		public StringEvent OnDebug = new StringEvent();

		private IEnumerator WaitToNextTargetC;

		[HideInInspector]
		public bool showevents;

		public NavMeshAgent Agent
		{
			get
			{
				if (agent == null)
				{
					agent = GetComponentInChildren<NavMeshAgent>();
				}
				return agent;
			}
		}

		public float StoppingDistance
		{
			get
			{
				return stoppingDistance;
			}
			set
			{
				Agent.stoppingDistance = (stoppingDistance = value);
			}
		}

		public bool TargetisMoving
		{
			get
			{
				if (target != null)
				{
					return (target.position - TargetLastPosition).magnitude > 0.001f;
				}
				return false;
			}
		}

		public bool AgentActive
		{
			get
			{
				if (Agent.isOnNavMesh)
				{
					return Agent.enabled;
				}
				return false;
			}
		}

		public bool IsWaiting { get; protected set; }

		private void Start()
		{
			StartAgent();
		}

		protected virtual void StartAgent()
		{
			animal = GetComponent<Animal>();
			animal.OnAnimationChange.AddListener(OnAnimationChanged);
			DoingAnAction = (isFlyingOffMesh = false);
			Agent.updateRotation = false;
			Agent.updatePosition = false;
			DefaultStopDistance = StoppingDistance;
			Agent.stoppingDistance = StoppingDistance;
			SetTarget(target);
			IsWaiting = false;
		}

		private void Update()
		{
			if (isFlyingOffMesh || Stopped)
			{
				return;
			}
			if (animal.Fly || animal.Swim)
			{
				FreeMovement();
			}
			else if (AgentActive)
			{
				Agent.nextPosition = agent.transform.position;
				if (IsWaiting)
				{
					return;
				}
				if (targetPosition == NullVector)
				{
					StopAnimal();
				}
				else
				{
					UpdateAgent();
				}
			}
			if ((bool)target)
			{
				if (TargetisMoving)
				{
					UpdateTargetTransform();
				}
				TargetLastPosition = target.position;
			}
		}

		private void FreeMovement()
		{
			if (IsWaiting || target == null || targetPosition == NullVector)
			{
				return;
			}
			RemainingDistance = (target ? Vector3.Distance(animal.transform.position, target.position) : 0f);
			Vector3 move = target.position - animal.transform.position;
			animal.Move(move);
			UnityEngine.Debug.DrawRay(animal.transform.position, move.normalized, Color.white);
			if (RemainingDistance < StoppingDistance)
			{
				if (NextWayPoint != null && NextWayPoint.PointType != WayPointType.Air && animal.Fly)
				{
					animal.SetFly(value: false);
				}
				CheckNextTarget();
			}
		}

		private void CheckNextTarget()
		{
			if ((bool)isActionZone && !DoingAnAction)
			{
				animal.Action = true;
				animal.Stop();
				if (isActionZone.MoveToExitAction)
				{
					float waitTime = isActionZone.WaitTime;
					Debuging(base.name + "is Waiting " + waitTime + " seconds to finish a 'Move to Exit' Action");
					animal.Invoke("WakeAnimal", waitTime);
				}
			}
			else
			{
				SetNextTarget();
			}
		}

		protected virtual void OnAnimationChanged(int animTag)
		{
			bool flag = animTag == AnimTag.Action;
			if (flag != DoingAnAction)
			{
				DoingAnAction = flag;
				if (DoingAnAction)
				{
					OnActionStart.Invoke();
					Debuging(base.name + " has started an ACTION");
					IsWaiting = true;
				}
				else
				{
					OnActionEnd.Invoke();
					Debuging(base.name + " has ended an ACTION");
					if (!EnterOFFMESH)
					{
						SetNextTarget();
					}
					else
					{
						IsWaiting = false;
					}
				}
			}
			if (animTag == AnimTag.Jump)
			{
				animal.MovementRight = 0f;
			}
			if (animTag == AnimTag.Locomotion || animTag == AnimTag.Idle)
			{
				if (animal.canFly && flyPending && !animal.Fly && NextWayPoint.PointType == WayPointType.Air)
				{
					animal.SetFly(value: true);
					flyPending = false;
				}
				else if (!Agent.enabled)
				{
					Agent.enabled = true;
					Agent.ResetPath();
					EnterOFFMESH = false;
					if (targetPosition != NullVector)
					{
						Agent.SetDestination(targetPosition);
						Agent.isStopped = false;
					}
				}
			}
			else if (Agent.enabled)
			{
				Agent.enabled = false;
				string text = "not on Locomotion or Idle";
				if (animTag == AnimTag.Action)
				{
					text = "doing an Action";
				}
				if (animTag == AnimTag.Jump)
				{
					text = "Jumping";
				}
				if (animTag == AnimTag.Fall)
				{
					text = "Falling";
				}
				if (animTag == AnimTag.Recover)
				{
					text = "Recovering";
				}
				Debuging("Disable Agent. " + base.name + " is " + text);
			}
		}

		private void SetNextTarget()
		{
			if (WaitToNextTargetC != null)
			{
				StopCoroutine(WaitToNextTargetC);
			}
			if (NextWayPoint != null)
			{
				WaitToNextTargetC = WaitToNextTarget(NextWayPoint.WaitTime, NextWayPoint.NextTarget);
				StartCoroutine(WaitToNextTargetC);
			}
		}

		protected virtual void UpdateAgent()
		{
			Vector3 move = Vector3.zero;
			RemainingDistance = Agent.remainingDistance;
			if (Agent.pathPending || Mathf.Abs(RemainingDistance) <= 0.1f)
			{
				RemainingDistance = float.PositiveInfinity;
				UpdateTargetTransform();
			}
			if (RemainingDistance > StoppingDistance)
			{
				move = Agent.desiredVelocity;
				DoingAnAction = false;
			}
			else
			{
				OnTargetPositionArrived.Invoke(targetPosition);
				if ((bool)target)
				{
					OnTargetArrived.Invoke(target);
					if ((bool)isWayPoint)
					{
						isWayPoint.TargetArrived(this);
					}
				}
				targetPosition = NullVector;
				agent.isStopped = true;
				CheckNextTarget();
			}
			animal.Move(move);
			if (AutoSpeed)
			{
				AutomaticSpeed();
			}
			CheckOffMeshLinks();
		}

		protected virtual void WakeAnimal()
		{
			animal.WakeAnimal();
			IsWaiting = false;
		}

		protected virtual void CheckOffMeshLinks()
		{
			if (!Agent.isOnOffMeshLink || EnterOFFMESH)
			{
				return;
			}
			EnterOFFMESH = true;
			OffMeshLinkData currentOffMeshLinkData = Agent.currentOffMeshLinkData;
			if (currentOffMeshLinkData.linkType == OffMeshLinkType.LinkTypeManual)
			{
				OffMeshLink offMeshLink = currentOffMeshLinkData.offMeshLink;
				if ((bool)offMeshLink.GetComponentInParent<ActionZone>() && !DoingAnAction)
				{
					animal.Action = (DoingAnAction = true);
					return;
				}
				float sqrMagnitude = (base.transform.position - offMeshLink.endTransform.position).sqrMagnitude;
				float sqrMagnitude2 = (base.transform.position - offMeshLink.startTransform.position).sqrMagnitude;
				Transform transform = ((sqrMagnitude < sqrMagnitude2) ? offMeshLink.endTransform : offMeshLink.startTransform);
				Transform transform2 = ((sqrMagnitude > sqrMagnitude2) ? offMeshLink.endTransform : offMeshLink.startTransform);
				StartCoroutine(MalbersTools.AlignTransform_Rotation(base.transform, transform.rotation, 0.15f));
				if (animal.canFly && offMeshLink.CompareTag("Fly"))
				{
					Debuging(base.name + ": Fly OffMesh");
					StartCoroutine(CFlyOffMesh(transform2));
				}
				else if (offMeshLink.area == 2)
				{
					animal.SetJump();
				}
			}
			else if (currentOffMeshLinkData.linkType == OffMeshLinkType.LinkTypeJumpAcross)
			{
				animal.SetJump();
			}
		}

		protected virtual IEnumerator WaitToNextTarget(float time, Transform NextTarget)
		{
			if ((bool)isActionZone && isActionZone.MoveToExitAction)
			{
				time = 0f;
			}
			if (time > 0f)
			{
				IsWaiting = true;
				Debuging(base.name + " is waiting " + time.ToString("F2") + " seconds");
				animal.Move(Vector3.zero);
				yield return new WaitForSeconds(time);
			}
			IsWaiting = false;
			SetTarget(NextTarget);
			yield return null;
		}

		protected virtual void AutomaticSpeed()
		{
			if (RemainingDistance < ToTrot)
			{
				animal.Speed1 = true;
			}
			else if (RemainingDistance < ToRun)
			{
				animal.Speed2 = true;
			}
			else if (RemainingDistance > ToRun)
			{
				animal.Speed3 = true;
			}
		}

		public virtual void SetTarget(Transform target)
		{
			if (target == null)
			{
				StopAnimal();
				return;
			}
			this.target = target;
			targetPosition = target.position;
			isActionZone = target.GetComponent<ActionZone>();
			isWayPoint = target.GetComponent<MWayPoint>();
			NextWayPoint = target.GetComponent<IWayPoint>();
			Stopped = false;
			StoppingDistance = ((NextWayPoint != null) ? NextWayPoint.StoppingDistance : DefaultStopDistance);
			CheckAirTarget();
			Debuging(base.name + " is travelling to : " + target.name);
			if (Agent.isOnNavMesh)
			{
				Agent.enabled = true;
				Agent.SetDestination(targetPosition);
				Agent.isStopped = false;
			}
		}

		private void CheckAirTarget()
		{
			if (NextWayPoint != null && NextWayPoint.PointType == WayPointType.Air && animal.canFly)
			{
				int currentAnimState = animal.CurrentAnimState;
				if (currentAnimState == AnimTag.Locomotion || currentAnimState == AnimTag.Idle)
				{
					animal.SetFly(value: true);
					flyPending = false;
				}
				else
				{
					flyPending = true;
				}
			}
		}

		public virtual void UpdateTargetTransform()
		{
			if (Agent.isOnNavMesh && !(target == null))
			{
				targetPosition = target.position;
				Agent.SetDestination(targetPosition);
				if (Agent.isStopped)
				{
					Agent.isStopped = false;
				}
			}
		}

		public virtual void StopAnimal()
		{
			if ((bool)Agent && Agent.isOnNavMesh)
			{
				Agent.isStopped = true;
			}
			targetPosition = NullVector;
			StopAllCoroutines();
			DoingAnAction = false;
			animal.InterruptAction();
			if ((bool)animal)
			{
				animal.Stop();
			}
			IsWaiting = (isFlyingOffMesh = false);
			Stopped = true;
		}

		public virtual void SetDestination(Vector3 point)
		{
			targetPosition = point;
			target = null;
			StoppingDistance = DefaultStopDistance;
			if (Agent.isOnNavMesh && Agent.enabled)
			{
				Agent.SetDestination(targetPosition);
				Agent.isStopped = false;
				Stopped = false;
				Debuging(base.name + " is travelling to : " + point);
			}
		}

		protected void Debuging(string Log)
		{
			if (debug)
			{
				UnityEngine.Debug.Log(Log);
			}
			OnDebug.Invoke(Log);
		}

		internal IEnumerator CFlyOffMesh(Transform target)
		{
			animal.SetFly(value: true);
			flyPending = false;
			isFlyingOffMesh = true;
			float distance = float.MaxValue;
			agent.enabled = false;
			while (distance > agent.stoppingDistance)
			{
				animal.Move(target.position - animal.transform.position);
				distance = Vector3.Distance(animal.transform.position, target.position);
				yield return null;
			}
			animal.Stop();
			animal.SetFly(value: false);
			isFlyingOffMesh = false;
		}
	}
	[CreateAssetMenu(menuName = "Malbers Animations/Animal Proxy")]
	public class AnimalProxy : ScriptableObject
	{
		protected Animal animal;

		[Tooltip("Since the Animal Proxy is a Scriptable Object... After Stoping the Editor an animal can get stored.. you can clean the reference on the next Editor Play enabling this option ")]
		public bool CleanAnimalOnEnable;

		public virtual Animal Animal => animal;

		public virtual float GroundSpeed
		{
			set
			{
				animal.GroundSpeed = value;
			}
		}

		public virtual float Vertical
		{
			get
			{
				return animal.Speed;
			}
			set
			{
				animal.Speed = value;
			}
		}

		public int Loops
		{
			get
			{
				return animal.Loops;
			}
			set
			{
				animal.Loops = value;
			}
		}

		public int IDInt
		{
			get
			{
				return animal.IDInt;
			}
			set
			{
				animal.IDInt = value;
			}
		}

		public float IDFloat
		{
			get
			{
				return animal.IDFloat;
			}
			set
			{
				animal.IDFloat = value;
			}
		}

		public int Tired
		{
			get
			{
				return animal.Tired;
			}
			set
			{
				animal.Tired = value;
			}
		}

		public bool SpeedUp
		{
			set
			{
				animal.SpeedUp = value;
			}
		}

		public bool SpeedDown
		{
			set
			{
				animal.SpeedDown = value;
			}
		}

		public bool Speed1
		{
			get
			{
				return animal.Speed1;
			}
			set
			{
				animal.Speed1 = value;
			}
		}

		public bool Speed2
		{
			get
			{
				return animal.Speed2;
			}
			set
			{
				animal.Speed2 = value;
			}
		}

		public bool Speed3
		{
			get
			{
				return animal.Speed3;
			}
			set
			{
				animal.Speed3 = value;
			}
		}

		public bool Jump
		{
			get
			{
				return animal.Jump;
			}
			set
			{
				animal.Jump = value;
			}
		}

		public bool Underwater
		{
			get
			{
				return animal.Underwater;
			}
			set
			{
				animal.Underwater = value;
			}
		}

		public bool UseShift
		{
			get
			{
				return animal.UseShift;
			}
			set
			{
				animal.UseShift = value;
			}
		}

		public bool Shift
		{
			get
			{
				return animal.Shift;
			}
			set
			{
				animal.Shift = value;
			}
		}

		public bool Down
		{
			get
			{
				return animal.Down;
			}
			set
			{
				animal.Down = value;
			}
		}

		public bool Up
		{
			get
			{
				return animal.Up;
			}
			set
			{
				animal.Up = value;
			}
		}

		public bool Dodge
		{
			get
			{
				return animal.Dodge;
			}
			set
			{
				animal.Dodge = value;
			}
		}

		public bool Damaged
		{
			get
			{
				return animal.Dodge;
			}
			set
			{
				animal.Damaged = value;
			}
		}

		public bool Fly
		{
			get
			{
				return animal.Fly;
			}
			set
			{
				animal.SetFly(value);
			}
		}

		public bool Death
		{
			get
			{
				return animal.Death;
			}
			set
			{
				animal.Death = value;
			}
		}

		public bool Attack1
		{
			get
			{
				if (!animal)
				{
					return false;
				}
				return animal.Attack1;
			}
			set
			{
				animal.Attack1 = value;
			}
		}

		public bool Attack2
		{
			get
			{
				if (!animal)
				{
					return false;
				}
				return animal.Attack2;
			}
			set
			{
				animal.Attack2 = value;
			}
		}

		public bool Stun
		{
			get
			{
				return animal.Stun;
			}
			set
			{
				animal.Stun = value;
			}
		}

		public bool Action
		{
			get
			{
				return animal.Action;
			}
			set
			{
				animal.Action = value;
			}
		}

		public int ActionID
		{
			get
			{
				return animal.ActionID;
			}
			set
			{
				animal.ActionID = value;
			}
		}

		public bool IsInAir
		{
			get
			{
				return animal.IsInAir;
			}
			set
			{
				animal.IsInAir = value;
			}
		}

		public bool Stand => animal.Stand;

		public Vector3 HitDirection
		{
			get
			{
				return animal.HitDirection;
			}
			set
			{
				animal.HitDirection = value;
			}
		}

		public float ScaleFactor => animal.ScaleFactor;

		public Pivots Pivot_Hip => animal.Pivot_Hip;

		public Pivots Pivot_Chest => animal.Pivot_Chest;

		public int AnimState => animal.AnimState;

		public int LastAnimationTag => animal.LastAnimationTag;

		public Vector3 MovementAxis
		{
			get
			{
				return animal.MovementAxis;
			}
			set
			{
				animal.MovementAxis = value;
			}
		}

		public float MovementForward
		{
			get
			{
				return animal.MovementForward;
			}
			set
			{
				animal.MovementForward = value;
			}
		}

		public float MovementRight
		{
			get
			{
				return animal.MovementRight;
			}
			set
			{
				animal.MovementRight = value;
			}
		}

		public float MovementUp
		{
			get
			{
				return animal.MovementUp;
			}
			set
			{
				animal.MovementUp = value;
			}
		}

		public Vector3 SurfaceNormal => animal.SurfaceNormal;

		public float Waterlevel
		{
			get
			{
				return animal.Waterlevel;
			}
			set
			{
				animal.Waterlevel = value;
			}
		}

		public bool Land
		{
			get
			{
				return animal.Land;
			}
			set
			{
				animal.Land = value;
			}
		}

		public virtual bool Gravity
		{
			get
			{
				if ((bool)animal)
				{
					return animal.Gravity;
				}
				return false;
			}
			set
			{
				if ((bool)animal)
				{
					animal.Gravity = value;
				}
			}
		}

		private void OnEnable()
		{
			if (CleanAnimalOnEnable)
			{
				animal = null;
			}
		}

		public void ToogleFly()
		{
			animal.Fly = true;
		}

		public virtual void SetAnimal(Animal newAnimal)
		{
			animal = newAnimal;
		}

		public virtual void getDamaged(DamageValues DV)
		{
			if ((bool)animal)
			{
				animal.getDamaged(DV);
			}
		}

		public virtual void Stop()
		{
			if ((bool)animal)
			{
				animal.Stop();
			}
		}

		public virtual void getDamaged(Vector3 Mycenter, Vector3 Theircenter, float Amount = 0f)
		{
			DamageValues dV = new DamageValues(Mycenter - Theircenter, Amount);
			getDamaged(dV);
		}

		public virtual void AttackTrigger(int triggerIndex)
		{
			if ((bool)animal)
			{
				animal.AttackTrigger(triggerIndex);
			}
		}

		public virtual void SetAttack()
		{
			if ((bool)animal)
			{
				animal.SetAttack();
			}
		}

		public virtual void SetLoop(int cycles)
		{
			if ((bool)animal)
			{
				animal.Loops = cycles;
			}
		}

		public virtual void SetAttack(int attackID)
		{
			if ((bool)animal)
			{
				animal.SetAttack(attackID);
			}
		}

		public virtual void SetAttack(bool value)
		{
			Attack1 = value;
		}

		public virtual void SetSecondaryAttack()
		{
			if ((bool)animal)
			{
				animal.SetSecondaryAttack();
			}
		}

		public virtual void RigidDrag(float amount)
		{
			if ((bool)animal)
			{
				animal.RigidDrag(amount);
			}
		}

		public void SetIntID(int value)
		{
			if ((bool)animal)
			{
				animal.SetIntID(value);
			}
		}

		public void SetFloatID(float value)
		{
			if ((bool)animal)
			{
				animal.SetFloatID(value);
			}
		}

		public virtual void StillConstraints(bool active)
		{
			if ((bool)animal)
			{
				animal.StillConstraints(active);
			}
		}

		public virtual void EnableColliders(bool active)
		{
			if ((bool)animal)
			{
				animal.EnableColliders(active);
			}
		}

		public virtual void InAir(bool active)
		{
			if ((bool)animal)
			{
				animal.InAir(active);
			}
		}

		public virtual void SetJump()
		{
			if ((bool)animal)
			{
				animal.SetJump();
			}
		}

		public virtual void SetAction(int ID)
		{
			if ((bool)animal)
			{
				animal.SetAction(ID);
			}
		}

		public virtual void SetAction(string actionName)
		{
			if ((bool)animal)
			{
				animal.SetAction(actionName);
			}
		}

		public virtual void ResetAnimal()
		{
			if ((bool)animal)
			{
				animal.ResetAnimal();
			}
		}

		public virtual void SetStun(float time)
		{
			if ((bool)animal)
			{
				animal.SetStun(time);
			}
		}

		public virtual void DisableAnimal()
		{
			if ((bool)animal)
			{
				animal.DisableAnimal();
			}
		}

		public virtual void SetToGlide(float value)
		{
			if ((bool)animal)
			{
				animal.SetToGlide(value);
			}
		}
	}
	public class AttackTrigger : MonoBehaviour
	{
		public int index = 1;

		public float damageMultiplier = 1f;

		public float PushForce;

		private Animal myAnimal;

		private IMDamagable enemy;

		private Collider _collider;

		public bool debug = true;

		public Color DebugColor = new Color(1f, 0.25f, 0f, 0.15f);

		public Collider Collider
		{
			get
			{
				if (!_collider)
				{
					_collider = GetComponent<Collider>();
				}
				return _collider;
			}
		}

		public void Start()
		{
			myAnimal = base.transform.GetComponentInParent<Animal>();
			if ((bool)Collider)
			{
				Collider.isTrigger = true;
				Collider.enabled = false;
			}
			else
			{
				UnityEngine.Debug.LogWarning(base.name + " needs a Collider so 'AttackTrigger' can function correctly");
			}
			base.gameObject.SetActive(value: false);
		}

		private void OnTriggerEnter(Collider other)
		{
			if (other.isTrigger)
			{
				return;
			}
			enemy = other.GetComponentInParent<IMDamagable>();
			if (enemy != null)
			{
				if (myAnimal.GetComponent<IMDamagable>() != enemy)
				{
					DamageValues dV = new DamageValues(myAnimal.transform.position - other.bounds.center, damageMultiplier * (myAnimal ? myAnimal.attackStrength : 1f));
					enemy.getDamaged(dV);
				}
			}
			else if ((bool)other.attachedRigidbody && PushForce != 0f)
			{
				other.attachedRigidbody.AddForce((other.transform.position - base.transform.position).normalized * PushForce, ForceMode.VelocityChange);
			}
		}

		private void OnDrawGizmos()
		{
			if (!UnityEngine.Application.isPlaying)
			{
				return;
			}
			Gizmos.color = DebugColor;
			Gizmos.matrix = base.transform.localToWorldMatrix;
			if (!Collider || !Collider.enabled)
			{
				return;
			}
			if (Collider is BoxCollider)
			{
				BoxCollider boxCollider = Collider as BoxCollider;
				if (boxCollider.enabled)
				{
					float x = base.transform.lossyScale.x * boxCollider.size.x;
					float y = base.transform.lossyScale.y * boxCollider.size.y;
					float z = base.transform.lossyScale.z * boxCollider.size.z;
					Gizmos.matrix = Matrix4x4.TRS(boxCollider.bounds.center, base.transform.rotation, new Vector3(x, y, z));
					Gizmos.DrawCube(Vector3.zero, Vector3.one);
					Gizmos.color = new Color(DebugColor.r, DebugColor.g, DebugColor.b, 1f);
					Gizmos.DrawWireCube(Vector3.zero, Vector3.one);
				}
			}
			else if (Collider is SphereCollider)
			{
				SphereCollider sphereCollider = Collider as SphereCollider;
				if (sphereCollider.enabled)
				{
					Gizmos.matrix = base.transform.localToWorldMatrix;
					Gizmos.DrawSphere(Vector3.zero + sphereCollider.center, sphereCollider.radius);
					Gizmos.color = new Color(DebugColor.r, DebugColor.g, DebugColor.b, 1f);
					Gizmos.DrawWireSphere(Vector3.zero + sphereCollider.center, sphereCollider.radius);
				}
			}
		}
	}
	public class FollowTarget : MonoBehaviour
	{
		public Transform target;

		public float stopDistance = 3f;

		private Animal animal;

		private void Start()
		{
			animal = GetComponentInParent<Animal>();
		}

		private void Update()
		{
			Vector3 vector = target.position - base.transform.position;
			float num = Vector3.Distance(base.transform.position, target.position);
			animal.Move((num > stopDistance) ? vector : Vector3.zero);
		}

		private void OnDisable()
		{
			animal.Move(Vector3.zero);
		}
	}
	public static class Hash
	{
		public static readonly int Vertical = Animator.StringToHash("Vertical");

		public static readonly int Horizontal = Animator.StringToHash("Horizontal");

		public static readonly int UpDown = Animator.StringToHash("UpDown");

		public static readonly int Stand = Animator.StringToHash("Stand");

		public static readonly int Grounded = Animator.StringToHash("Grounded");

		public static readonly int _Jump = Animator.StringToHash("_Jump");

		public static readonly int Dodge = Animator.StringToHash("Dodge");

		public static readonly int Fall = Animator.StringToHash("Fall");

		public static readonly int Type = Animator.StringToHash("Type");

		public static readonly int Slope = Animator.StringToHash("Slope");

		public static readonly int Shift = Animator.StringToHash("Shift");

		public static readonly int Fly = Animator.StringToHash("Fly");

		public static readonly int Attack1 = Animator.StringToHash("Attack1");

		public static readonly int Attack2 = Animator.StringToHash("Attack2");

		public static readonly int Death = Animator.StringToHash("Death");

		public static readonly int Damaged = Animator.StringToHash("Damaged");

		public static readonly int Stunned = Animator.StringToHash("Stunned");

		public static readonly int IDInt = Animator.StringToHash("IDInt");

		public static readonly int IDFloat = Animator.StringToHash("IDFloat");

		public static readonly int Swim = Animator.StringToHash("Swim");

		public static readonly int Underwater = Animator.StringToHash("Underwater");

		public static readonly int IDAction = Animator.StringToHash("IDAction");

		public static readonly int Action = Animator.StringToHash("Action");

		public static readonly int Null = Animator.StringToHash("Null");

		public static readonly int Empty = Animator.StringToHash("Empty");

		public static readonly int State = Animator.StringToHash("State");

		public static readonly int Stance = Animator.StringToHash("Stance");

		public static readonly int Mode = Animator.StringToHash("Mode");

		public static readonly int StateTime = Animator.StringToHash("StateTime");

		public static readonly int IKLeftFoot = Animator.StringToHash("IKLeftFoot");

		public static readonly int IKRightFoot = Animator.StringToHash("IKRightFoot");

		public static readonly int Mount = Animator.StringToHash("Mount");

		public static readonly int MountSide = Animator.StringToHash("MountSide");

		public static readonly int Tag_Mounting = Animator.StringToHash("Mounting");

		public static readonly int Tag_Unmounting = Animator.StringToHash("Unmounting");
	}
	public static class AnimTag
	{
		public static readonly int Locomotion = Animator.StringToHash("Locomotion");

		public static readonly int Idle = Animator.StringToHash("Idle");

		public static readonly int Recover = Animator.StringToHash("Recover");

		public static readonly int Sleep = Animator.StringToHash("Sleep");

		public static readonly int Attack = Animator.StringToHash("Attack");

		public static readonly int Attack2 = Animator.StringToHash("Attack2");

		public static readonly int JumpEnd = Animator.StringToHash("JumpEnd");

		public static readonly int JumpStart = Animator.StringToHash("JumpStart");

		public static readonly int Jump = Animator.StringToHash("Jump");

		public static readonly int SwimJump = Animator.StringToHash("SwimJump");

		public static readonly int NoAlign = Animator.StringToHash("NoAlign");

		public static readonly int Action = Animator.StringToHash("Action");

		public static readonly int Swim = Animator.StringToHash("Swim");

		public static readonly int Underwater = Animator.StringToHash("Underwater");

		public static readonly int Fly = Animator.StringToHash("Fly");

		public static readonly int Dodge = Animator.StringToHash("Dodge");

		public static readonly int Fall = Animator.StringToHash("Fall");

		public static readonly int Mounting = Animator.StringToHash("Mounting");

		public static readonly int Unmounting = Animator.StringToHash("Unmounting");
	}
	public static class States
	{
		public static readonly int Unknown = -1;

		public static readonly int Idle = 0;

		public static readonly int Locomotion = 1;

		public static readonly int Jump = 2;

		public static readonly int Climb = 3;

		public static readonly int Fall = 4;

		public static readonly int Recover = 5;

		public static readonly int Action = 6;

		public static readonly int Swim = 7;

		public static readonly int UnderWater = 8;

		public static readonly int Fly = 10;

		public static readonly int Stun = 11;

		public static readonly int Death = 12;

		public static readonly int Rebirth = 13;
	}
	public static class Mode
	{
		public static readonly int None = 0;

		public static readonly int Shift = 1;

		public static readonly int Attack1 = 2;

		public static readonly int Attack2 = 3;

		public static readonly int Damaged = 4;

		public static readonly int Dodge = 5;

		public static readonly int Block = 6;

		public static readonly int Parry = 7;

		public static readonly int isAttacking1 = 11;

		public static readonly int isAttacking2 = 12;

		public static readonly int isTakingDamage = 13;

		public static readonly int isDodging = 14;

		public static readonly int isDefending = 15;
	}
	public static class Stance
	{
		public static readonly int Default = 0;

		public static readonly int Sneak = 1;

		public static readonly int Combat = 2;

		public static readonly int Injured = 3;

		public static readonly int Strafe = 4;
	}
	public class MakeDamage : MonoBehaviour
	{
		public float damageMultiplier = 1f;

		private Collider _collider;

		public Collider Collider
		{
			get
			{
				if (!_collider)
				{
					_collider = GetComponent<Collider>();
				}
				return _collider;
			}
		}

		private void Start()
		{
			if ((bool)Collider)
			{
				Collider.isTrigger = true;
			}
			else
			{
				UnityEngine.Debug.LogWarning(base.name + " needs a Collider so 'AttackTrigger' can function correctly");
			}
		}

		private void OnTriggerEnter(Collider other)
		{
			if (!(other.transform.root == base.transform.root))
			{
				DamageValues dV = new DamageValues(-other.bounds.center + Collider.bounds.center, damageMultiplier);
				if (!other.isTrigger)
				{
					other.GetComponentInParent<IMDamagable>()?.getDamaged(dV);
				}
			}
		}
	}
	public class AttackBehaviour : StateMachineBehaviour
	{
		public int AttackTrigger = 1;

		[Range(0f, 1f)]
		public float On = 0.3f;

		[Range(0f, 1f)]
		public float Off = 0.6f;

		private bool isOn;

		private bool isOff;

		private Animal animal;

		private float startAttackTime;

		private float attackDelay;

		public override void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
		{
			animal = animator.GetComponent<Animal>();
			animal.IsAttacking = true;
			animal.Attack1 = false;
			isOn = (isOff = false);
			attackDelay = animal.attackDelay;
			startAttackTime = Time.time;
		}

		public override void OnStateUpdate(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
		{
			animal.IsAttacking = true;
			if (!isOn && stateInfo.normalizedTime % 1f >= On)
			{
				animal.AttackTrigger(AttackTrigger);
				isOn = true;
			}
			if (!isOff && stateInfo.normalizedTime % 1f >= Off)
			{
				animal.AttackTrigger(0);
				isOff = true;
			}
			if (attackDelay > 0f && Time.time - startAttackTime >= attackDelay)
			{
				animal.IsAttacking = false;
			}
		}

		public override void OnStateExit(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
		{
			animal.AttackTrigger(0);
			isOn = (isOff = false);
			animal.IsAttacking = false;
		}
	}
	public class AutoGlideBehaviour : StateMachineBehaviour
	{
		[MinMaxRange(0f, 10f)]
		public RangedFloat GlideChance = new RangedFloat(0.8f, 4f);

		[MinMaxRange(0f, 10f)]
		public RangedFloat FlapChange = new RangedFloat(0.5f, 4f);

		protected bool isGliding;

		protected float FlyStyleTime = 1f;

		protected float currentTime = 1f;

		protected bool Default_UseShift;

		protected Animal animal;

		public override void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
		{
			animal = animator.GetComponent<Animal>();
			Default_UseShift = animal.UseShift;
			animal.UseShift = false;
			FlyStyleTime = GlideChance.RandomValue;
			currentTime = Time.time;
		}

		public override void OnStateUpdate(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
		{
			if (Time.time - FlyStyleTime >= currentTime)
			{
				currentTime = Time.time;
				isGliding = !isGliding;
				FlyStyleTime = (isGliding ? GlideChance.RandomValue : FlapChange.RandomValue);
				animal.GroundSpeed = (isGliding ? 2f : UnityEngine.Random.Range(1f, 1.5f));
			}
		}

		public override void OnStateExit(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
		{
			animal.UseShift = Default_UseShift;
		}
	}
	public class FlySprintBehaviour1 : StateMachineBehaviour
	{
		public bool UseSprint = true;

		[Tooltip("Float Parameter on the Animator to Modify When Sprint is Enabled, if this value is null it will not change the multiplier")]
		public string Speed_Param = "SpeedMultiplier";

		public float ShiftMultiplier = 2f;

		public float AnimSpeedDefault = 1f;

		[Tooltip("Amount of Speed Multiplier  to use on the Speed Multiplier Animator parameter when 'UseSprint' is Enabled\n if this value is null it will not change the multiplier")]
		public float AnimSprintSpeed = 2f;

		[Tooltip("Smoothness to use when the SpeedMultiplier changes")]
		public float AnimSprintLerp = 2f;

		protected int SpeedHash = Animator.StringToHash("SpeedMultiplier");

		protected float CurrentSpeedMultiplier;

		protected float Shift;

		protected Animal animal;

		protected Speeds BehaviourSpeed;

		public override void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
		{
			animal = animator.GetComponent<Animal>();
			BehaviourSpeed = animal.flySpeed;
			if (Speed_Param != string.Empty)
			{
				SpeedHash = Animator.StringToHash(Speed_Param);
				animator.SetFloat(SpeedHash, AnimSpeedDefault);
			}
			CurrentSpeedMultiplier = AnimSpeedDefault;
		}

		public override void OnStateUpdate(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
		{
			float deltaTime = Time.deltaTime;
			Shift = Mathf.Lerp(Shift, animal.Shift ? ShiftMultiplier : 1f, BehaviourSpeed.lerpPosition * deltaTime);
			CurrentSpeedMultiplier = Mathf.Lerp(CurrentSpeedMultiplier, animal.Shift ? AnimSprintSpeed : AnimSpeedDefault, deltaTime * AnimSprintLerp);
			if (Speed_Param != string.Empty)
			{
				animal.Anim.SetFloat(SpeedHash, CurrentSpeedMultiplier);
			}
			animal.DeltaPosition += animal.T_Forward * Shift * deltaTime;
		}
	}
	public class DamagedBehavior : StateMachineBehaviour
	{
		private int Side;

		public bool DirectionalDamage = true;

		public override void OnStateMachineEnter(Animator animator, int stateMachinePathHash)
		{
			Animal component = animator.GetComponent<Animal>();
			component.Damaged = false;
			animator.SetBool(Hash.Damaged, value: false);
			if (!DirectionalDamage)
			{
				return;
			}
			Vector3 hitDirection = component.HitDirection;
			Vector3 forward = animator.transform.forward;
			hitDirection.y = 0f;
			forward.y = 0f;
			float num = Vector3.Angle(forward, hitDirection);
			if (Vector3.Dot(component.T_Right, component.HitDirection) < 0f)
			{
				if (num > 0f && num <= 60f)
				{
					Side = 3;
				}
				else if (num > 60f && num <= 120f)
				{
					Side = 2;
				}
				else if (num > 120f && num <= 180f)
				{
					Side = 1;
				}
			}
			else if (num > 0f && num <= 60f)
			{
				Side = -3;
			}
			else if (num > 60f && num <= 120f)
			{
				Side = -2;
			}
			else if (num > 120f && num <= 180f)
			{
				Side = -1;
			}
			animator.SetInteger(Hash.IDInt, Side);
		}
	}
	public class FallBehavior : StateMachineBehaviour
	{
		private RaycastHit FallRay;

		[Tooltip("The Lower Fall animation will set to 1 if this distance the current distance to the ground")]
		public float LowerDistance;

		private Animal animal;

		private Rigidbody rb;

		private float MaxHeight;

		private float FallBlend;

		private bool check_Water;

		private int PivotsRayInterval;

		private int FallRayInterval;

		private int WaterRayInterval;

		private int GroundLayer;

		private Vector3 IncomingSpeed;

		private float waterlevel;

		public override void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
		{
			animal = animator.GetComponent<Animal>();
			rb = animator.GetComponent<Rigidbody>();
			GroundLayer = animal.GroundLayer;
			IncomingSpeed = rb.velocity;
			IncomingSpeed.y = 0f;
			animal.SetIntID(1);
			animal.IsInAir = true;
			animator.SetFloat(Hash.IDFloat, 1f);
			MaxHeight = float.MinValue;
			animator.applyRootMotion = false;
			rb.drag = 0f;
			rb.useGravity = true;
			FallBlend = 1f;
			check_Water = false;
			animal.Waterlevel = Animal.LowWaterLevel;
			waterlevel = Animal.LowWaterLevel;
			animal.RaycastWater();
			PivotsRayInterval = animal.PivotsRayInterval;
			FallRayInterval = animal.FallRayInterval;
			WaterRayInterval = animal.WaterRayInterval;
			animal.PivotsRayInterval = (animal.FallRayInterval = (animal.WaterRayInterval = 1));
		}

		public override void OnStateUpdate(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
		{
			if (animal.debug)
			{
				UnityEngine.Debug.DrawRay(animal.Main_Pivot_Point, -animal.transform.up * 50f, Color.magenta);
			}
			if (Physics.Raycast(animal.Main_Pivot_Point, -animal.transform.up, out FallRay, 50f, GroundLayer))
			{
				if (MaxHeight < FallRay.distance)
				{
					MaxHeight = FallRay.distance;
				}
				FallBlend = Mathf.Lerp(FallBlend, (FallRay.distance - LowerDistance) / (MaxHeight - LowerDistance), Time.deltaTime * 20f);
				animator.SetFloat(Hash.IDFloat, FallBlend);
			}
			CheckforWater();
		}

		private void CheckforWater()
		{
			if (waterlevel != animal.Waterlevel && animal.Waterlevel != Animal.LowWaterLevel)
			{
				waterlevel = animal.Waterlevel;
			}
			if (!check_Water && waterlevel > animal.Main_Pivot_Point.y)
			{
				rb.velocity = new Vector3(rb.velocity.x, 0f, rb.velocity.z);
				check_Water = true;
				animal.Swim = true;
				animal.Waterlevel = waterlevel;
			}
		}

		public override void OnStateMove(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
		{
			if (animal.AirControl)
			{
				AirControl();
			}
		}

		public override void OnStateExit(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
		{
			animal.PivotsRayInterval = PivotsRayInterval;
			animal.FallRayInterval = FallRayInterval;
			animal.WaterRayInterval = WaterRayInterval;
			animal.AirControlDir = Vector3.zero;
		}

		private void AirControl()
		{
			float deltaTime = Time.deltaTime;
			float y = rb.velocity.y;
			Vector3 rawDirection = animal.RawDirection;
			rawDirection.y = 0f;
			animal.AirControlDir = Vector3.Lerp(animal.AirControlDir, rawDirection, deltaTime * animal.airSmoothness);
			UnityEngine.Debug.DrawRay(animal.transform.position, animal.AirControlDir, Color.yellow);
			Vector3 vector = animal.AirControlDir * animal.airMaxSpeed;
			if (!animal.DirectionalMovement)
			{
				vector = animal.transform.TransformDirection(vector);
			}
			vector.y = y;
			rb.velocity = vector;
		}
	}
	public class Fly_NoRoot_Behavior : StateMachineBehaviour
	{
		[Range(0f, 90f)]
		[Tooltip("Adds Banking to the Fly animation when turning")]
		public float Bank = 30f;

		[Range(0f, 90f)]
		[Tooltip("Top Angle the Animal Can go UP or Down ")]
		public float Ylimit = 80f;

		public float Drag = 5f;

		[Space]
		public bool UseDownAcceleration = true;

		public float DownAcceleration = 3f;

		public float FallRecovery = 1.5f;

		[Space]
		public bool CanNotSwim;

		protected float acceleration;

		protected Rigidbody rb;

		protected Animal animal;

		protected Transform transform;

		protected Quaternion DeltaRotation;

		protected float Shift;

		protected float Direction;

		protected float deltaTime;

		private Vector3 FallVector;

		protected float forwardAceleration;

		protected Speeds BehaviourSpeed;

		private float PitchAngle;

		private float vertical;

		private bool foundWater;

		public override void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
		{
			ResetAllValues();
			rb = animator.GetComponent<Rigidbody>();
			animal = animator.GetComponent<Animal>();
			BehaviourSpeed = animal.flySpeed;
			animator.applyRootMotion = true;
			transform = animator.transform;
			DeltaRotation = transform.rotation;
			acceleration = 0f;
			vertical = animal.Speed;
			FallVector = ((animal.CurrentAnimState == AnimTag.Fall || animal.CurrentAnimState == AnimTag.Jump) ? rb.velocity : Vector3.zero);
			rb.constraints = RigidbodyConstraints.FreezeRotation;
			rb.useGravity = false;
			rb.drag = Drag;
		}

		public override void OnStateUpdate(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
		{
			float num = 1f;
			if (animator.IsInTransition(layerIndex) && stateInfo.normalizedTime < 0.5f)
			{
				num = animator.GetAnimatorTransitionInfo(layerIndex).normalizedTime;
			}
			if (animator.IsInTransition(layerIndex) && stateInfo.normalizedTime > 0.5f)
			{
				num = 1f - animator.GetAnimatorTransitionInfo(layerIndex).normalizedTime;
			}
			deltaTime = Time.deltaTime;
			transform.rotation = DeltaRotation;
			float num2 = ((animal.MovementAxis.z >= 0f) ? 1 : (-1));
			Direction = Mathf.Lerp(Direction, Mathf.Clamp(animal.Direction, -1f, 1f), deltaTime * BehaviourSpeed.lerpRotation);
			Quaternion quaternion = Quaternion.Euler(transform.InverseTransformDirection(0f, Direction * BehaviourSpeed.rotation * num2, 0f));
			DeltaRotation = Quaternion.FromToRotation(transform.up, Vector3.up) * rb.rotation * quaternion;
			float movementUp = animal.MovementUp;
			vertical = Mathf.Lerp(vertical, Mathf.Clamp(animal.Speed, -1f, 1f), deltaTime * 6f);
			Vector3 zero = Vector3.zero;
			Vector3 vector = animal.T_Forward;
			if (animal.DirectionalMovement)
			{
				zero = animal.RawDirection;
				if (animal.IgnoreYDir)
				{
					zero.y = 0f;
				}
				zero.Normalize();
				zero += transform.up * movementUp;
				if (zero.magnitude > 1f)
				{
					zero.Normalize();
				}
			}
			else
			{
				zero = transform.forward * vertical + transform.up * movementUp;
				if (zero.magnitude > 1f)
				{
					zero.Normalize();
				}
				if (animal.MovementAxis.z < 0f)
				{
					movementUp = 0f;
				}
				vector = zero;
			}
			forwardAceleration = Mathf.Lerp(forwardAceleration, zero.magnitude, deltaTime * BehaviourSpeed.lerpPosition);
			Vector3 b = vector * forwardAceleration * BehaviourSpeed.position * ((animal.Speed < 0f) ? 0.5f : 1f) * deltaTime;
			b = Vector3.Lerp(Vector3.zero, b, num);
			if (CanNotSwim)
			{
				if (Physics.Raycast(animal.Main_Pivot_Point, -Vector2.up, out var _, animal.Pivot_Multiplier * animal.ScaleFactor * animal.FallRayMultiplier, 16))
				{
					foundWater = true;
				}
				else
				{
					foundWater = false;
				}
			}
			if (foundWater && b.y < 0f)
			{
				b.y = 0.001f;
				animal.DeltaPosition.y = 0f;
				animal.MovementUp = 0f;
			}
			animal.DeltaPosition += b;
			if (animal.debug)
			{
				UnityEngine.Debug.DrawRay(transform.position, zero * 2f, Color.yellow);
			}
			if ((double)zero.magnitude > 0.001)
			{
				float num3 = 90f - Vector3.Angle(Vector3.up, zero);
				float num4 = Mathf.Max(Mathf.Abs(animal.MovementAxis.y), Mathf.Abs(vertical));
				num3 = Mathf.Clamp(0f - num3, 0f - Ylimit, Ylimit);
				PitchAngle = Mathf.Lerp(PitchAngle, num3, deltaTime * animal.upDownSmoothness * 2f);
				animal.DeltaRotation *= Quaternion.Euler(PitchAngle * num4 * num, 0f, 0f);
			}
			animal.DeltaRotation *= Quaternion.Euler(0f, 0f, (0f - Bank) * Direction);
			if (!foundWater)
			{
				if (FallVector != Vector3.zero)
				{
					animal.DeltaPosition += FallVector * deltaTime;
					FallVector = Vector3.Lerp(FallVector, Vector3.zero, deltaTime * FallRecovery);
				}
				if (UseDownAcceleration)
				{
					GravityAcceleration(zero);
				}
			}
		}

		private void GravityAcceleration(Vector3 DirectionVector)
		{
			if ((double)animal.MovementAxis.y < -0.1)
			{
				acceleration = Mathf.Lerp(acceleration, acceleration + DownAcceleration, deltaTime);
			}
			else
			{
				float num = acceleration - DownAcceleration;
				if (num < 0f)
				{
					num = 0f;
				}
				acceleration = Mathf.Lerp(acceleration, num, deltaTime);
			}
			animal.DeltaPosition += DirectionVector * (acceleration * deltaTime);
		}

		private void ResetAllValues()
		{
			deltaTime = (acceleration = (forwardAceleration = (PitchAngle = (Direction = 0f))));
		}
	}
	public class FlyBehavior : StateMachineBehaviour
	{
		public float Drag = 5f;

		public float DownAcceleration = 4f;

		[Tooltip("If is changing from ")]
		public float DownInertia = 2f;

		[Tooltip("If is changing from fall to fly this will smoothly ")]
		public float FallRecovery = 1.5f;

		[Tooltip("If Lock up is Enabled this apply to the dragon an extra Down Force")]
		public float LockUpDownForce = 4f;

		private float acceleration;

		private Rigidbody rb;

		private Animal animal;

		private float deltaTime;

		private Vector3 FallVector;

		public override void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
		{
			rb = animator.GetComponent<Rigidbody>();
			animal = animator.GetComponent<Animal>();
			acceleration = 0f;
			animal.IsInAir = true;
			animator.applyRootMotion = true;
			FallVector = ((animal.CurrentAnimState == AnimTag.Fall) ? rb.velocity : Vector3.zero);
			rb.constraints = RigidbodyConstraints.FreezeRotation;
			rb.velocity = new Vector3(rb.velocity.x, 0f, rb.velocity.z);
			rb.useGravity = false;
			rb.drag = Drag;
		}

		public override void OnStateUpdate(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
		{
			deltaTime = Time.deltaTime;
			if (FallVector != Vector3.zero)
			{
				animal.DeltaPosition += FallVector * deltaTime;
				FallVector = Vector3.Lerp(FallVector, Vector3.zero, deltaTime * FallRecovery);
			}
			if ((double)animal.MovementAxis.y < -0.1)
			{
				acceleration = Mathf.Lerp(acceleration, acceleration + DownAcceleration, deltaTime);
			}
			else if ((double)animal.MovementAxis.y > -0.1 || animal.MovementReleased)
			{
				float num = acceleration - DownInertia;
				if (num < 0f)
				{
					num = 0f;
				}
				acceleration = Mathf.Lerp(acceleration, num, deltaTime * 2f);
			}
			animal.DeltaPosition += animator.velocity * (acceleration / 2f) * deltaTime;
			if (animal.LockUp)
			{
				animal.DeltaPosition += Physics.gravity * LockUpDownForce * deltaTime * deltaTime;
			}
		}
	}
	public class FlyDodgeBehaviour : StateMachineBehaviour
	{
		public bool InPlace;

		private Vector3 momentum;

		private Rigidbody rb;

		private Animal animal;

		private float time;

		public override void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
		{
			rb = animator.GetComponent<Rigidbody>();
			animal = animator.GetComponent<Animal>();
			momentum = (InPlace ? rb.velocity : animator.velocity);
		}

		public override void OnStateUpdate(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
		{
			time = ((animator.updateMode == AnimatorUpdateMode.AnimatePhysics) ? Time.fixedDeltaTime : Time.deltaTime);
			animal.DeltaPosition += momentum * time;
		}
	}
	public class FlySprintBehaviour : StateMachineBehaviour
	{
		public bool IsRootMotion;

		[Tooltip("Float Parameter on the Animator to Modify When Sprint is Enabled, if this value is null it will not change the multiplier")]
		public string Speed_Param = "SpeedMultiplier";

		public float ShiftMultiplier = 2f;

		public float AnimSpeedDefault = 1f;

		[Tooltip("Amount of Speed Multiplier  to use on the Speed Multiplier Animator parameter when 'UseSprint' is Enabled\n if this value is null it will not change the multiplier")]
		public float AnimSprintSpeed = 2f;

		[Tooltip("Smoothness to use when the SpeedMultiplier changes")]
		public float AnimSprintLerp = 2f;

		[Tooltip("Do not Glide while pressing shift")]
		public bool NoGliding = true;

		protected int SpeedHash = Animator.StringToHash("SpeedMultiplier");

		protected float CurrentSpeedMultiplier;

		protected float Shift;

		protected Animal animal;

		protected Speeds BehaviourSpeed;

		public override void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
		{
			animal = animator.GetComponent<Animal>();
			BehaviourSpeed = animal.flySpeed;
			Shift = 0f;
			if (Speed_Param != string.Empty)
			{
				SpeedHash = Animator.StringToHash(Speed_Param);
				animator.SetFloat(SpeedHash, AnimSpeedDefault);
			}
			CurrentSpeedMultiplier = AnimSpeedDefault;
		}

		public override void OnStateUpdate(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
		{
			float deltaTime = Time.deltaTime;
			Shift = Mathf.Lerp(Shift, animal.Shift ? ShiftMultiplier : 1f, BehaviourSpeed.lerpPosition * deltaTime);
			CurrentSpeedMultiplier = Mathf.Lerp(CurrentSpeedMultiplier, (animal.Shift && animal.MovementForward > 0f) ? AnimSprintSpeed : AnimSpeedDefault, deltaTime * AnimSprintLerp);
			if (Speed_Param != string.Empty)
			{
				animal.Anim.SetFloat(SpeedHash, CurrentSpeedMultiplier);
			}
			if (IsRootMotion)
			{
				animal.DeltaPosition += animator.velocity * Shift * deltaTime;
			}
			else
			{
				animal.DeltaPosition += animal.T_Forward * Shift * Mathf.Clamp(animal.Speed, 0f, 1f) * deltaTime;
			}
			if (animal.Shift && NoGliding)
			{
				animal.Speed = Mathf.Lerp(animal.Speed, 1f, deltaTime * 6f);
			}
		}
	}
	public class JumpBehaviour : StateMachineBehaviour
	{
		[Header("Checking Fall")]
		[Tooltip("Ray Length to check if the ground is at the same level all the time")]
		public float fallRay = 1.7f;

		[Tooltip("Terrain difference to be sure the animal will fall ")]
		public float stepHeight = 0.1f;

		[Tooltip("Animation normalized time to change to fall animation if the ray checks if the animal is falling ")]
		[Range(0f, 1f)]
		public float willFall = 0.7f;

		[Header("Jump on Higher Ground")]
		[Tooltip("Range to Calcultate if we can land on Higher ground")]
		[MinMaxRange(0f, 1f)]
		public RangedFloat Cliff = new RangedFloat(0.5f, 0.65f);

		public float CliffRay = 0.6f;

		[Space]
		[Header("Add more Height and Distance to the Jump")]
		public float JumpMultiplier = 1f;

		public float ForwardMultiplier = 1f;

		private Animal animal;

		private Rigidbody rb;

		private bool Can_Add_ExtraJump;

		private Vector3 ExtraJump;

		private bool JumpPressed;

		private float jumpPoint;

		private float Rb_Y_Speed;

		private RaycastHit JumpRay;

		private float JumpSmoothPressed = 1f;

		private bool JumpEnd;

		public override void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
		{
			animal = animator.GetComponent<Animal>();
			rb = animator.GetComponent<Rigidbody>();
			animator.applyRootMotion = true;
			rb.constraints = RigidbodyConstraints.FreezeRotation;
			jumpPoint = animator.transform.position.y;
			animal.InAir(active: true);
			animal.SetIntID(0);
			animal.OnJump.Invoke();
			Rb_Y_Speed = 0f;
			Vector3 rawDirection = animal.RawDirection;
			rawDirection.y = 0f;
			animal.AirControlDir = rawDirection;
			Can_Add_ExtraJump = (JumpMultiplier > 0f && animal.JumpHeightMultiplier > 0f) || (ForwardMultiplier > 0f && animal.AirForwardMultiplier > 0f);
			ExtraJump = Vector3.up * JumpMultiplier * animal.JumpHeightMultiplier + animator.transform.forward * ForwardMultiplier * animal.AirForwardMultiplier;
			JumpSmoothPressed = 1f;
			JumpPressed = true;
			if (animal.JumpPress)
			{
				Can_Add_ExtraJump = (JumpPressed = animal.Jump);
			}
			JumpEnd = false;
			animator.SetFloat(animal.hash_IDFloat, 1f);
		}

		public override void OnStateUpdate(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
		{
			bool num = animator.IsInTransition(layerIndex);
			bool flag = num && stateInfo.normalizedTime > 0.5f;
			if (JumpPressed)
			{
				JumpPressed = animal.Jump;
			}
			if (!num && Can_Add_ExtraJump && !JumpEnd)
			{
				if (animal.JumpPress)
				{
					int num2 = (JumpPressed ? 1 : 0);
					JumpSmoothPressed = Mathf.Lerp(JumpSmoothPressed, num2, Time.deltaTime * 5f);
				}
				animal.DeltaPosition += ExtraJump * Time.deltaTime * JumpSmoothPressed;
			}
			if (animal.FrameCounter % animal.FallRayInterval == 0)
			{
				Can_Fall(stateInfo.normalizedTime);
				Can_Jump_on_Cliff(stateInfo.normalizedTime);
			}
			if ((bool)rb && flag && animator.GetNextAnimatorStateInfo(layerIndex).tagHash == AnimTag.Fly)
			{
				float normalizedTime = animator.GetAnimatorTransitionInfo(layerIndex).normalizedTime;
				Vector3 velocity = rb.velocity;
				if (Rb_Y_Speed < velocity.y)
				{
					Rb_Y_Speed = velocity.y;
				}
				velocity.y = Mathf.Lerp(Rb_Y_Speed, 0f, normalizedTime);
				rb.velocity = velocity;
			}
		}

		public override void OnStateMove(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
		{
			if (animal.AirControl)
			{
				AirControl();
			}
		}

		public override void OnStateExit(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
		{
			animal.SetIntID(0);
			AnimatorStateInfo currentAnimatorStateInfo = animator.GetCurrentAnimatorStateInfo(layerIndex);
			if (currentAnimatorStateInfo.tagHash == AnimTag.Fly)
			{
				rb.velocity = new Vector3(rb.velocity.x, 0f, rb.velocity.z);
			}
			else if (currentAnimatorStateInfo.tagHash != AnimTag.Fall)
			{
				animal.IsInAir = false;
			}
			JumpEnd = true;
		}

		private void Can_Fall(float normalizedTime)
		{
			UnityEngine.Debug.DrawRay(animal.Pivot_fall, -animal.transform.up * animal.Pivot_Multiplier * fallRay, Color.red);
			if (Physics.Raycast(animal.Pivot_fall, -animal.transform.up, out JumpRay, animal.Pivot_Multiplier * fallRay, animal.GroundLayer))
			{
				if (jumpPoint - JumpRay.point.y <= stepHeight * animal.ScaleFactor && Vector3.Angle(JumpRay.normal, Vector3.up) < animal.maxAngleSlope)
				{
					animal.SetIntID(0);
					MalbersTools.DebugTriangle(JumpRay.point, 0.1f, Color.red);
					return;
				}
				if (normalizedTime > willFall)
				{
					animal.SetIntID(111);
				}
				MalbersTools.DebugTriangle(JumpRay.point, 0.1f, Color.yellow);
			}
			else
			{
				if (normalizedTime > willFall)
				{
					animal.SetIntID(111);
				}
				MalbersTools.DebugPlane(animal.Pivot_fall - animal.transform.up * animal.Pivot_Multiplier * fallRay, 0.1f, Color.red);
			}
		}

		private void Can_Jump_on_Cliff(float normalizedTime)
		{
			if (!(normalizedTime >= Cliff.minValue) || !(normalizedTime <= Cliff.maxValue))
			{
				return;
			}
			if (Physics.Raycast(animal.Main_Pivot_Point, -animal.transform.up, out JumpRay, CliffRay * animal.ScaleFactor, animal.GroundLayer))
			{
				if (Vector3.Angle(JumpRay.normal, Vector3.up) < animal.maxAngleSlope)
				{
					if (animal.debug)
					{
						UnityEngine.Debug.DrawLine(animal.Main_Pivot_Point, JumpRay.point, Color.black);
						MalbersTools.DebugTriangle(JumpRay.point, 0.1f, Color.black);
					}
					animal.SetIntID(110);
				}
			}
			else if (animal.debug)
			{
				UnityEngine.Debug.DrawRay(animal.Main_Pivot_Point, -animal.transform.up * CliffRay * animal.ScaleFactor, Color.black);
				MalbersTools.DebugPlane(animal.Main_Pivot_Point - animal.transform.up * CliffRay * animal.ScaleFactor, 0.1f, Color.black);
			}
		}

		private void AirControl()
		{
			float deltaTime = Time.deltaTime;
			float y = rb.velocity.y;
			Vector3 rawDirection = animal.RawDirection;
			rawDirection.y = 0f;
			animal.AirControlDir = Vector3.Lerp(animal.AirControlDir, rawDirection * ForwardMultiplier, deltaTime * animal.airSmoothness);
			UnityEngine.Debug.DrawRay(animal.transform.position, animal.AirControlDir, Color.yellow);
			Vector3 vector = animal.AirControlDir * animal.airMaxSpeed;
			if (!animal.DirectionalMovement)
			{
				vector = animal.transform.TransformDirection(vector);
			}
			vector.y = y;
			rb.velocity = vector;
		}
	}
	public class JumpNoRootBehaviour : StateMachineBehaviour
	{
		public float JumpMultiplier = 1f;

		public float ForwardMultiplier;

		private Animal animal;

		private Rigidbody rb;

		public override void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
		{
			animal = animator.GetComponent<Animal>();
			rb = animator.GetComponent<Rigidbody>();
			animal.InAir(active: true);
			animal.SetIntID(0);
			animal.OnJump.Invoke();
			animator.applyRootMotion = false;
			Vector3 force = Vector3.up * JumpMultiplier * animal.JumpHeightMultiplier + animator.transform.forward * ForwardMultiplier * animal.AirForwardMultiplier;
			rb.AddForce(force, ForceMode.VelocityChange);
		}

		public override void OnStateExit(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
		{
			animal.SetIntID(0);
			AnimatorStateInfo currentAnimatorStateInfo = animator.GetCurrentAnimatorStateInfo(layerIndex);
			if ((bool)rb && currentAnimatorStateInfo.tagHash == AnimTag.Fly)
			{
				Vector3 velocity = new Vector3(rb.velocity.x, 0f, rb.velocity.z);
				rb.velocity = velocity;
			}
			if (currentAnimatorStateInfo.tagHash != AnimTag.Fall && currentAnimatorStateInfo.tagHash != AnimTag.Fly)
			{
				animal.IsInAir = false;
			}
		}
	}
	[Serializable]
	public class LayersActivation
	{
		public string layer;

		public bool activate;

		public StateTransition transA;

		public bool deactivate;

		public StateTransition transD;
	}
	public class LayersBehavior : StateMachineBehaviour
	{
		public LayersActivation[] layers;

		private AnimatorTransitionInfo transition;

		public override void OnStateUpdate(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
		{
			LayersActivation[] array = layers;
			foreach (LayersActivation layersActivation in array)
			{
				int layerIndex2 = animator.GetLayerIndex(layersActivation.layer);
				transition = animator.GetAnimatorTransitionInfo(layerIndex);
				if (animator.IsInTransition(layerIndex))
				{
					if (layersActivation.activate)
					{
						if (layersActivation.transA == StateTransition.First && stateInfo.normalizedTime <= 0.5f)
						{
							animator.SetLayerWeight(layerIndex2, transition.normalizedTime);
						}
						if (layersActivation.transA == StateTransition.Last && stateInfo.normalizedTime >= 0.5f)
						{
							animator.SetLayerWeight(layerIndex2, transition.normalizedTime);
						}
					}
					if (layersActivation.deactivate)
					{
						if (layersActivation.transD == StateTransition.First && stateInfo.normalizedTime <= 0.5f)
						{
							animator.SetLayerWeight(layerIndex2, 1f - transition.normalizedTime);
						}
						if (layersActivation.transD == StateTransition.Last && stateInfo.normalizedTime >= 0.5f)
						{
							animator.SetLayerWeight(layerIndex2, 1f - transition.normalizedTime);
						}
					}
				}
				else
				{
					if (layersActivation.activate && layersActivation.transA == StateTransition.First)
					{
						animator.SetLayerWeight(layerIndex2, 1f);
					}
					if (layersActivation.deactivate && layersActivation.transD == StateTransition.First)
					{
						animator.SetLayerWeight(layerIndex2, 0f);
					}
				}
			}
		}

		public override void OnStateExit(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
		{
			LayersActivation[] array = layers;
			foreach (LayersActivation layersActivation in array)
			{
				int layerIndex2 = animator.GetLayerIndex(layersActivation.layer);
				if (layersActivation.activate && layersActivation.transA == StateTransition.Last)
				{
					animator.SetLayerWeight(layerIndex2, 1f);
				}
				if (layersActivation.deactivate && layersActivation.transD == StateTransition.Last)
				{
					animator.SetLayerWeight(layerIndex2, 0f);
				}
			}
		}
	}
	public class LoopBehaviour : StateMachineBehaviour
	{
		[Header("This behaviour requires a transition to itself")]
		[Header("With the contidion 'IntID' != -1")]
		public int IntIDExitValue = -1;

		[Header("")]
		protected int CurrentLoop;

		protected int loop;

		private bool hasEntered;

		private Animal animal;

		public override void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
		{
			animal = animator.GetComponent<Animal>();
			if (!(animal == null))
			{
				if (!hasEntered)
				{
					hasEntered = true;
					CurrentLoop = 1;
					animal.SetIntID(0);
				}
				else
				{
					CurrentLoop++;
				}
				if (CurrentLoop >= animal.Loops)
				{
					hasEntered = false;
					animal.SetIntID(IntIDExitValue);
				}
			}
		}
	}
	public interface IAnimatorListener
	{
		void OnAnimatorBehaviourMessage(string message, object value);
	}
	public class MessagesBehavior : StateMachineBehaviour
	{
		public bool UseSendMessage;

		public MesssageItem[] onEnterMessage;

		public MesssageItem[] onExitMessage;

		public MesssageItem[] onTimeMessage;

		private IAnimatorListener[] listeners;

		public override void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
		{
			listeners = animator.GetComponents<IAnimatorListener>();
			MesssageItem[] array = onTimeMessage;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].sent = false;
			}
			array = onEnterMessage;
			foreach (MesssageItem messsageItem in array)
			{
				if (!messsageItem.Active || !(messsageItem.message != string.Empty))
				{
					continue;
				}
				if (UseSendMessage)
				{
					DeliverMessage(messsageItem, animator);
					continue;
				}
				IAnimatorListener[] array2 = listeners;
				foreach (IAnimatorListener listener in array2)
				{
					DeliverListener(messsageItem, listener);
				}
			}
		}

		public override void OnStateExit(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
		{
			MesssageItem[] array = onExitMessage;
			foreach (MesssageItem messsageItem in array)
			{
				if (!messsageItem.Active || !(messsageItem.message != string.Empty))
				{
					continue;
				}
				if (UseSendMessage)
				{
					DeliverMessage(messsageItem, animator);
					continue;
				}
				IAnimatorListener[] array2 = listeners;
				foreach (IAnimatorListener listener in array2)
				{
					DeliverListener(messsageItem, listener);
				}
			}
		}

		public override void OnStateUpdate(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
		{
			MesssageItem[] array = onTimeMessage;
			foreach (MesssageItem messsageItem in array)
			{
				if (!messsageItem.Active || !(messsageItem.message != string.Empty) || messsageItem.sent || !(stateInfo.normalizedTime % 1f >= messsageItem.time))
				{
					continue;
				}
				messsageItem.sent = true;
				if (UseSendMessage)
				{
					DeliverMessage(messsageItem, animator);
					continue;
				}
				IAnimatorListener[] array2 = listeners;
				foreach (IAnimatorListener listener in array2)
				{
					DeliverListener(messsageItem, listener);
				}
			}
		}

		private void DeliverMessage(MesssageItem m, Animator anim)
		{
			switch (m.typeM)
			{
			case TypeMessage.Bool:
				anim.SendMessage(m.message, m.boolValue, SendMessageOptions.DontRequireReceiver);
				break;
			case TypeMessage.Int:
				anim.SendMessage(m.message, m.intValue, SendMessageOptions.DontRequireReceiver);
				break;
			case TypeMessage.Float:
				anim.SendMessage(m.message, m.floatValue, SendMessageOptions.DontRequireReceiver);
				break;
			case TypeMessage.String:
				anim.SendMessage(m.message, m.stringValue, SendMessageOptions.DontRequireReceiver);
				break;
			case TypeMessage.Void:
				anim.SendMessage(m.message, SendMessageOptions.DontRequireReceiver);
				break;
			case TypeMessage.IntVar:
				anim.SendMessage(m.message, (int)m.intVarValue, SendMessageOptions.DontRequireReceiver);
				break;
			}
		}

		private void DeliverListener(MesssageItem m, IAnimatorListener listener)
		{
			switch (m.typeM)
			{
			case TypeMessage.Bool:
				listener.OnAnimatorBehaviourMessage(m.message, m.boolValue);
				break;
			case TypeMessage.Int:
				listener.OnAnimatorBehaviourMessage(m.message, m.intValue);
				break;
			case TypeMessage.Float:
				listener.OnAnimatorBehaviourMessage(m.message, m.floatValue);
				break;
			case TypeMessage.String:
				listener.OnAnimatorBehaviourMessage(m.message, m.stringValue);
				break;
			case TypeMessage.Void:
				listener.OnAnimatorBehaviourMessage(m.message, null);
				break;
			case TypeMessage.IntVar:
				listener.OnAnimatorBehaviourMessage(m.message, (int)m.intVarValue);
				break;
			}
		}
	}
	[Serializable]
	public class MesssageItem
	{
		public string message;

		public TypeMessage typeM;

		public bool boolValue;

		public int intValue;

		public float floatValue;

		public string stringValue;

		public IntVar intVarValue;

		public float time;

		public bool sent;

		public bool Active = true;

		public MesssageItem()
		{
			message = string.Empty;
			Active = true;
		}
	}
	public class RandomBehavior : StateMachineBehaviour
	{
		public string Parameter = "IDInt";

		public int Range;

		public override void OnStateMachineEnter(Animator animator, int stateMachinePathHash)
		{
			int num = UnityEngine.Random.Range(1, Range + 1);
			animator.SetInteger(Parameter, num);
			Animal component = animator.GetComponent<Animal>();
			if ((bool)component && Parameter == "IDInt")
			{
				component.SetIntID(num);
			}
		}
	}
	public class RecoverBehavior : StateMachineBehaviour
	{
		public float smoothness = 10f;

		public float MaxDrag = 3f;

		public bool stillContraints = true;

		public bool Landing = true;

		public bool RigidY = true;

		private Animal animal;

		private Rigidbody rb;

		private float deltatime;

		public override void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
		{
			animal = animator.GetComponent<Animal>();
			rb = animator.GetComponent<Rigidbody>();
			animator.applyRootMotion = false;
			if (RigidY)
			{
				rb.constraints = Animal.Still_Constraints;
			}
			if (Landing)
			{
				animal.IsInAir = false;
			}
			else
			{
				rb.useGravity = false;
			}
		}

		public override void OnStateUpdate(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
		{
			rb.drag = Mathf.Lerp(rb.drag, MaxDrag, Time.deltaTime * smoothness);
		}

		public override void OnStateExit(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
		{
			rb.drag = 0f;
		}
	}
	public class RigidConstraintsB : StateMachineBehaviour
	{
		public bool PosX;

		public bool PosY = true;

		public bool PosZ;

		public bool RotX = true;

		public bool RotY = true;

		public bool RotZ = true;

		public bool OnEnter = true;

		public bool OnExit;

		protected int Amount;

		private Rigidbody rb;

		private bool ExitTime;

		public float OnEnterDrag;

		public override void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
		{
			Amount = 0;
			rb = animator.GetComponent<Rigidbody>();
			if (PosX)
			{
				Amount += 2;
			}
			if (PosY)
			{
				Amount += 4;
			}
			if (PosZ)
			{
				Amount += 8;
			}
			if (RotX)
			{
				Amount += 16;
			}
			if (RotY)
			{
				Amount += 32;
			}
			if (RotZ)
			{
				Amount += 64;
			}
			if (OnEnter && (bool)rb)
			{
				rb.constraints = (RigidbodyConstraints)Amount;
			}
			ExitTime = false;
			rb.drag = OnEnterDrag;
		}

		public override void OnStateUpdate(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
		{
			if (!ExitTime && OnExit && stateInfo.normalizedTime > 1f)
			{
				rb.constraints = (RigidbodyConstraints)Amount;
				ExitTime = true;
			}
		}

		public override void OnStateExit(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
		{
			if (OnExit && (bool)rb)
			{
				rb.constraints = (RigidbodyConstraints)Amount;
			}
		}
	}
	public class SleepBehavior : StateMachineBehaviour
	{
		public bool CyclesFromController;

		public int Cycles;

		public int transitionID;

		private int currentCycle;

		private Animal animal;

		public override void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
		{
			if (animal == null)
			{
				animal = animator.GetComponent<Animal>();
			}
			if (!animal || animal.GotoSleep == 0)
			{
				return;
			}
			if (animator.GetCurrentAnimatorStateInfo(layerIndex).tagHash == AnimTag.Idle)
			{
				animal.Tired++;
				if (animal.Tired >= animal.GotoSleep)
				{
					animal.SetIntID(transitionID);
					animal.Tired = 0;
				}
			}
			else
			{
				CyclesToSleep();
			}
		}

		private void CyclesToSleep()
		{
			if (CyclesFromController)
			{
				Cycles = animal.GotoSleep;
				if (Cycles == 0)
				{
					return;
				}
			}
			currentCycle++;
			if (currentCycle >= Cycles)
			{
				animal.SetIntID(transitionID);
				currentCycle = 0;
			}
		}
	}
	public class SoundBehavior : StateMachineBehaviour
	{
		public AudioClip[] sounds;

		public bool playOnEnter = true;

		public bool playOnTime;

		[Range(0f, 1f)]
		public float NormalizedTime = 0.5f;

		[Space]
		[Range(-0.5f, 3f)]
		public float pitch = 1f;

		[Range(0f, 1f)]
		public float volume = 1f;

		private AudioSource _audio;

		public override void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
		{
			_audio = animator.GetComponent<AudioSource>();
			if (!_audio)
			{
				_audio = animator.gameObject.AddComponent<AudioSource>();
			}
			_audio.spatialBlend = 1f;
			if (playOnEnter && (bool)_audio)
			{
				PlaySound();
			}
		}

		public override void OnStateUpdate(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
		{
			if (playOnTime && (bool)_audio && stateInfo.normalizedTime > NormalizedTime && !_audio.isPlaying && !animator.IsInTransition(layerIndex))
			{
				PlaySound();
			}
		}

		public override void OnStateExit(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
		{
		}

		public virtual void PlaySound()
		{
			if ((bool)_audio && sounds.Length != 0 && _audio.enabled)
			{
				_audio.clip = sounds[UnityEngine.Random.Range(0, sounds.Length)];
				_audio.pitch = pitch;
				_audio.volume = volume;
				_audio.Play();
			}
		}
	}
	public class UnderWaterBehaviour : StateMachineBehaviour
	{
		[Range(0f, 90f)]
		public float Bank;

		[Range(0f, 90f)]
		public float Ylimit = 87f;

		[Space]
		public bool useShift = true;

		public float ShiftMultiplier = 2f;

		[Space]
		protected Rigidbody rb;

		protected Animal animal;

		protected Transform transform;

		protected Quaternion DeltaRotation;

		protected float Shift;

		protected float deltaTime;

		private Speeds BehaviourSpeed;

		private int WaterLayer;

		private float Direction;

		private float forwardAceleration;

		public float PitchAngle { get; private set; }

		public bool Default_UseShift { get; private set; }

		public override void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
		{
			rb = animator.GetComponent<Rigidbody>();
			animal = animator.GetComponent<Animal>();
			animator.applyRootMotion = true;
			transform = animator.transform;
			DeltaRotation = transform.rotation;
			rb.constraints = RigidbodyConstraints.FreezeRotation;
			rb.useGravity = false;
			Default_UseShift = animal.UseShift;
			animal.UseShift = false;
			WaterLayer = LayerMask.GetMask("Water");
			BehaviourSpeed = animal.underWaterSpeed;
		}

		public override void OnStateMove(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
		{
			if (!animal.CanGoUnderWater || !animal.Underwater)
			{
				return;
			}
			float t = 1f;
			if (animator.IsInTransition(layerIndex) && stateInfo.normalizedTime < 0.5f)
			{
				t = animator.GetAnimatorTransitionInfo(layerIndex).normalizedTime;
			}
			if (animator.IsInTransition(layerIndex) && stateInfo.normalizedTime > 0.5f)
			{
				t = 1f - animator.GetAnimatorTransitionInfo(layerIndex).normalizedTime;
			}
			deltaTime = Time.deltaTime;
			if (useShift)
			{
				Shift = Mathf.Lerp(Shift, animal.Shift ? ShiftMultiplier : 1f, BehaviourSpeed.lerpPosition * deltaTime);
			}
			if (animal.Up)
			{
				animal.Down = false;
			}
			transform.rotation = DeltaRotation;
			float num = ((animal.MovementAxis.z >= 0f) ? 1 : (-1));
			Direction = Mathf.Lerp(Direction, Mathf.Clamp(animal.Direction, -1f, 1f), deltaTime * BehaviourSpeed.lerpRotation);
			Quaternion quaternion = Quaternion.Euler(transform.InverseTransformDirection(0f, Direction * BehaviourSpeed.rotation * num, 0f));
			animal.DeltaRotation *= quaternion;
			DeltaRotation = Quaternion.FromToRotation(transform.up, Vector3.up) * rb.rotation * quaternion;
			float movementUp = animal.MovementUp;
			float num2 = Mathf.Clamp(animal.Speed, -1f, 1f);
			Vector3 zero = Vector3.zero;
			Vector3 vector = animal.T_Forward;
			if (animal.DirectionalMovement)
			{
				zero = animal.RawDirection;
				zero += transform.up * movementUp;
			}
			else
			{
				zero = transform.forward * num2 + transform.up * movementUp;
				if (zero.magnitude > 1f)
				{
					zero.Normalize();
				}
				if (animal.MovementAxis.z < 0f)
				{
					movementUp = 0f;
				}
				vector = zero;
			}
			forwardAceleration = Mathf.Lerp(forwardAceleration, zero.magnitude, deltaTime * BehaviourSpeed.lerpPosition);
			Vector3 b = vector * forwardAceleration * BehaviourSpeed.position * Shift * ((animal.Speed < 0f) ? 0.5f : 1f) * deltaTime;
			b = Vector3.Lerp(Vector3.zero, b, t);
			animal.DeltaPosition += b;
			if ((double)zero.magnitude > 0.001)
			{
				float num3 = 90f - Vector3.Angle(Vector3.up, zero);
				float num4 = Mathf.Max(Mathf.Abs(animal.MovementAxis.y), Mathf.Abs(num2));
				num3 = Mathf.Clamp(0f - num3, 0f - Ylimit, Ylimit);
				PitchAngle = Mathf.Lerp(PitchAngle, num3, deltaTime * animal.upDownSmoothness * 2f);
				transform.Rotate(Mathf.Clamp(PitchAngle, 0f - Ylimit, Ylimit) * num4, 0f, 0f, Space.Self);
			}
			if (animal.debug)
			{
				UnityEngine.Debug.DrawRay(transform.position, zero * 2f, Color.yellow);
			}
			transform.Rotate(0f, 0f, (0f - Bank) * Mathf.Clamp(Direction, -1f, 1f), Space.Self);
			CheckExitUnderWater();
		}

		public override void OnStateExit(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
		{
			animal.UseShift = Default_UseShift;
		}

		protected void CheckExitUnderWater()
		{
			if (Physics.Raycast(transform.position + new Vector3(0f, (animal.height - animal.waterLine) * animal.ScaleFactor, 0f), -Vector3.up, out var _, animal.ScaleFactor, WaterLayer) && !animal.Down)
			{
				animal.Underwater = false;
				animal.Anim.applyRootMotion = true;
				rb.useGravity = true;
				rb.drag = 0f;
				rb.constraints = Animal.Still_Constraints;
				animal.MovementAxis = new Vector3(animal.MovementAxis.x, 0f, animal.MovementAxis.z);
			}
		}
	}
	public class CameraWallStop : MonoBehaviour
	{
		public class RayHitComparer : IComparer
		{
			public int Compare(object x, object y)
			{
				return ((RaycastHit)x).distance.CompareTo(((RaycastHit)y).distance);
			}
		}

		public float clipMoveTime = 0.05f;

		public float returnTime = 0.4f;

		public float sphereCastRadius = 0.15f;

		public bool visualiseInEditor;

		public float closestDistance = 0.5f;

		public LayerMask dontClip = 1048576;

		private Transform m_Cam;

		private Transform m_Pivot;

		private float m_OriginalDist;

		private float m_MoveVelocity;

		private float m_CurrentDist;

		private Ray m_Ray;

		private RaycastHit[] hits;

		private RayHitComparer m_RayHitComparer;

		public bool protecting { get; private set; }

		private void Start()
		{
			m_Cam = GetComponentInChildren<Camera>().transform;
			m_Pivot = m_Cam.parent;
			m_OriginalDist = m_Cam.localPosition.magnitude;
			m_CurrentDist = m_OriginalDist;
			m_RayHitComparer = new RayHitComparer();
		}

		private void LateUpdate()
		{
			float num = m_OriginalDist;
			m_Ray.origin = m_Pivot.position + m_Pivot.forward * sphereCastRadius;
			m_Ray.direction = -m_Pivot.forward;
			Collider[] array = Physics.OverlapSphere(m_Ray.origin, sphereCastRadius);
			bool flag = false;
			bool flag2 = false;
			for (int i = 0; i < array.Length; i++)
			{
				if (!array[i].isTrigger && !MalbersTools.CollidersLayer(array[i], dontClip))
				{
					flag = true;
					break;
				}
			}
			if (flag)
			{
				m_Ray.origin += m_Pivot.forward * sphereCastRadius;
				hits = Physics.RaycastAll(m_Ray, m_OriginalDist - sphereCastRadius);
			}
			else
			{
				hits = Physics.SphereCastAll(m_Ray, sphereCastRadius, m_OriginalDist + sphereCastRadius);
			}
			Array.Sort(hits, m_RayHitComparer);
			float num2 = float.PositiveInfinity;
			for (int j = 0; j < hits.Length; j++)
			{
				if (hits[j].distance < num2 && !hits[j].collider.isTrigger && !MalbersTools.CollidersLayer(hits[j].collider, dontClip))
				{
					num2 = hits[j].distance;
					num = 0f - m_Pivot.InverseTransformPoint(hits[j].point).z;
					flag2 = true;
				}
			}
			if (flag2)
			{
				UnityEngine.Debug.DrawRay(m_Ray.origin, -m_Pivot.forward * (num + sphereCastRadius), Color.red);
			}
			protecting = flag2;
			m_CurrentDist = Mathf.SmoothDamp(m_CurrentDist, num, ref m_MoveVelocity, (m_CurrentDist > num) ? clipMoveTime : returnTime);
			m_CurrentDist = Mathf.Clamp(m_CurrentDist, closestDistance, m_OriginalDist);
			m_Cam.localPosition = -Vector3.forward * m_CurrentDist;
		}
	}
	public class ChangeTarget : MonoBehaviour
	{
		public Transform[] targets;

		public KeyCode key = KeyCode.T;

		private int current;

		[Tooltip("Deactivate the Inputs of the other targets to keep them from moving")]
		public bool NoInputs;

		private MFreeLookCamera m;

		private void Start()
		{
			if (!NoInputs)
			{
				return;
			}
			MalbersInput malbersInput = null;
			for (int i = 0; i < targets.Length; i++)
			{
				if ((bool)targets[i])
				{
					malbersInput = targets[i].GetComponent<MalbersInput>();
					if ((bool)malbersInput)
					{
						malbersInput.enabled = false;
					}
				}
			}
			m = GetComponent<MFreeLookCamera>();
			if (!m)
			{
				return;
			}
			malbersInput = m.Target.GetComponent<MalbersInput>();
			if ((bool)malbersInput)
			{
				malbersInput.enabled = true;
			}
			for (int j = 0; j < targets.Length; j++)
			{
				if (targets[j] == m.Target)
				{
					current = j;
					break;
				}
			}
		}

		private void Update()
		{
			if (targets.Length == 0 || (targets.Length > current && targets[current] == null) || !Input.GetKeyDown(key))
			{
				return;
			}
			if (NoInputs)
			{
				MalbersInput component = targets[current].GetComponent<MalbersInput>();
				if ((bool)component)
				{
					component.enabled = false;
				}
			}
			current++;
			current %= targets.Length;
			SendMessage("SetTarget", targets[current]);
			if (NoInputs)
			{
				MalbersInput component2 = targets[current].GetComponent<MalbersInput>();
				if ((bool)component2)
				{
					component2.enabled = true;
				}
			}
		}
	}
	[CreateAssetMenu(menuName = "Malbers Animations/Camera/FreeLook Camera Manager")]
	public class FreeLockCameraManager : ScriptableObject
	{
		public float transition = 1f;

		public FreeLookCameraState Default;

		public FreeLookCameraState AimRight;

		public FreeLookCameraState AimLeft;

		public FreeLookCameraState Mounted;

		private MFreeLookCamera mCamera;

		private Camera cam;

		private FreeLookCameraState NextState;

		protected FreeLookCameraState currentState;

		private IEnumerator ChangeStates;

		protected Transform MountedTarget;

		protected Transform RiderTarget;

		public void SetCamera(MFreeLookCamera Freecamera)
		{
			mCamera = Freecamera;
			if ((bool)mCamera)
			{
				cam = mCamera.Cam.GetComponent<Camera>();
			}
			ChangeStates = StateTransition(transition);
			currentState = null;
			NextState = null;
			Mounted = null;
			MountedTarget = null;
		}

		public void ChangeTarget(Transform tranform)
		{
			if (!(mCamera == null))
			{
				mCamera.SetTarget(tranform);
			}
		}

		public void SetRiderTarget(Transform tranform)
		{
			RiderTarget = tranform;
		}

		public void SetMountedTarget(Transform tranform)
		{
			MountedTarget = tranform;
			if (!(mCamera == null))
			{
				ChangeTarget(tranform);
			}
		}

		public void SetMountedState(FreeLookCameraState state)
		{
			Mounted = state;
			SetCameraState(state);
		}

		private void UpdateState(FreeLookCameraState state)
		{
			if (!(mCamera == null) && !(state == null))
			{
				mCamera.Pivot.localPosition = state.PivotPos;
				mCamera.Cam.localPosition = state.CamPos;
				cam.fieldOfView = state.CamFOV;
			}
		}

		public void SetAim(int ID)
		{
			if (mCamera == null)
			{
				return;
			}
			if (ID == -1 && (bool)AimLeft)
			{
				SetCameraState(AimLeft);
				mCamera.SetTarget(RiderTarget);
				return;
			}
			if (ID == 1 && (bool)AimRight)
			{
				SetCameraState(AimRight);
				mCamera.SetTarget(RiderTarget);
				return;
			}
			SetCameraState(Mounted ?? Default);
			if ((bool)MountedTarget)
			{
				mCamera.SetTarget(MountedTarget);
			}
		}

		public void SetCameraState(FreeLookCameraState state)
		{
			if (!(mCamera == null) && !(state == null))
			{
				NextState = state;
				if (!currentState || !(NextState == currentState))
				{
					mCamera.StopCoroutine(ChangeStates);
					ChangeStates = StateTransition(transition);
					mCamera.StartCoroutine(ChangeStates);
				}
			}
		}

		private IEnumerator StateTransition(float time)
		{
			float elapsedTime = 0f;
			currentState = NextState;
			while (elapsedTime < time)
			{
				mCamera.Pivot.localPosition = Vector3.Lerp(mCamera.Pivot.localPosition, NextState.PivotPos, Mathf.SmoothStep(0f, 1f, elapsedTime / time));
				mCamera.Cam.localPosition = Vector3.Lerp(mCamera.Cam.localPosition, NextState.CamPos, Mathf.SmoothStep(0f, 1f, elapsedTime / time));
				cam.fieldOfView = Mathf.Lerp(cam.fieldOfView, NextState.CamFOV, Mathf.SmoothStep(0f, 1f, elapsedTime / time));
				elapsedTime += Time.deltaTime;
				yield return null;
			}
			UpdateState(NextState);
			NextState = null;
		}
	}
	[CreateAssetMenu(menuName = "Malbers Animations/Camera/FreeLook Camera State")]
	public class FreeLookCameraState : ScriptableObject
	{
		public Vector3 PivotPos;

		public Vector3 CamPos;

		public float CamFOV = 45f;

		public FreeLookCameraState()
		{
			CamFOV = 45f;
			PivotPos = new Vector3(0f, 1f, 0f);
			CamPos = new Vector3(0f, 0f, -4.45f);
		}
	}
	public class MFreeLookCamera : MonoBehaviour
	{
		public enum UpdateType
		{
			FixedUpdate,
			LateUpdate,
			Update
		}

		[HideInInspector]
		public string PlayerID = "Player0";

		[Space]
		public Transform m_Target;

		public UpdateType updateType;

		private Transform cam;

		private Transform pivot;

		public float m_MoveSpeed = 10f;

		[Range(0f, 10f)]
		public float m_TurnSpeed = 10f;

		public float m_TurnSmoothing = 10f;

		public float m_TiltMax = 75f;

		public float m_TiltMin = 45f;

		public InputAxis Vertical = new InputAxis("Mouse Y", active: true, isRaw: false);

		public InputAxis Horizontal = new InputAxis("Mouse X", active: true, isRaw: false);

		[Space]
		public bool m_LockCursor;

		[Space]
		public FreeLockCameraManager manager;

		public FreeLookCameraState startState;

		private float m_LookAngle;

		private float m_TiltAngle;

		private const float k_LookDistance = 100f;

		private Vector3 m_PivotEulers;

		private Quaternion m_PivotTargetRot;

		private Quaternion m_TransformTargetRot;

		private float x;

		private float y;

		private IInputSystem inputSystem;

		public Transform Target => m_Target;

		public Transform Cam
		{
			get
			{
				return cam;
			}
			set
			{
				cam = value;
			}
		}

		public Transform Pivot
		{
			get
			{
				return pivot;
			}
			set
			{
				pivot = value;
			}
		}

		protected void Awake()
		{
			Cam = GetComponentInChildren<Camera>().transform;
			Pivot = Cam.parent;
			if ((bool)manager)
			{
				manager.SetCamera(this);
			}
			if ((bool)startState)
			{
				SetState(startState);
			}
			Cursor.lockState = (m_LockCursor ? CursorLockMode.Locked : CursorLockMode.None);
			Cursor.visible = !m_LockCursor;
			m_PivotEulers = Pivot.rotation.eulerAngles;
			m_PivotTargetRot = Pivot.transform.localRotation;
			m_TransformTargetRot = base.transform.localRotation;
			this.inputSystem = DefaultInput.GetInputSystem(PlayerID);
			InputAxis horizontal = Horizontal;
			IInputSystem inputSystem2 = (Vertical.InputSystem = this.inputSystem);
			horizontal.InputSystem = inputSystem2;
		}

		public virtual void SetState(FreeLookCameraState profile)
		{
			Pivot.localPosition = profile.PivotPos;
			Cam.localPosition = profile.CamPos;
			Cam.GetComponent<Camera>().fieldOfView = profile.CamFOV;
		}

		protected void FollowTarget(float deltaTime)
		{
			if (!(m_Target == null))
			{
				base.transform.position = Vector3.Lerp(base.transform.position, m_Target.position, deltaTime * m_MoveSpeed);
			}
		}

		private void HandleRotationMovement()
		{
			if (!(Time.timeScale < float.Epsilon))
			{
				x = Horizontal.GetAxis;
				y = Vertical.GetAxis;
				m_LookAngle += x * m_TurnSpeed;
				m_TransformTargetRot = Quaternion.Euler(0f, m_LookAngle, 0f);
				m_TiltAngle -= y * m_TurnSpeed;
				m_TiltAngle = Mathf.Clamp(m_TiltAngle, 0f - m_TiltMin, m_TiltMax);
				m_PivotTargetRot = Quaternion.Euler(m_TiltAngle, m_PivotEulers.y, m_PivotEulers.z);
				if (m_TurnSmoothing > 0f)
				{
					Pivot.localRotation = Quaternion.Slerp(Pivot.localRotation, m_PivotTargetRot, m_TurnSmoothing * Time.deltaTime);
					base.transform.localRotation = Quaternion.Slerp(base.transform.localRotation, m_TransformTargetRot, m_TurnSmoothing * Time.deltaTime);
				}
				else
				{
					Pivot.localRotation = m_PivotTargetRot;
					base.transform.localRotation = m_TransformTargetRot;
				}
			}
		}

		private void Update()
		{
			HandleRotationMovement();
			if (updateType == UpdateType.Update)
			{
				FollowTarget(Time.deltaTime);
			}
		}

		private void FixedUpdate()
		{
			if (updateType == UpdateType.FixedUpdate)
			{
				FollowTarget(Time.fixedDeltaTime);
			}
		}

		private void LateUpdate()
		{
			if (updateType == UpdateType.LateUpdate)
			{
				FollowTarget(Time.deltaTime);
			}
		}

		public virtual void SetTarget(Transform newTransform)
		{
			m_Target = newTransform;
		}

		public virtual void SetTarget(GameObject newGO)
		{
			m_Target = newGO.transform;
		}
	}
	[ExecuteInEditMode]
	public class MWater : MonoBehaviour
	{
		public enum WaterMode
		{
			Simple,
			Reflective,
			Refractive
		}

		public WaterMode waterMode = WaterMode.Refractive;

		public bool disablePixelLights = true;

		public int textureSize = 256;

		public float clipPlaneOffset = 0.07f;

		public LayerMask reflectLayers = -1;

		public LayerMask refractLayers = -1;

		private Dictionary<Camera, Camera> m_ReflectionCameras = new Dictionary<Camera, Camera>();

		private Dictionary<Camera, Camera> m_RefractionCameras = new Dictionary<Camera, Camera>();

		private RenderTexture m_ReflectionTexture;

		private RenderTexture m_RefractionTexture;

		private WaterMode m_HardwareWaterSupport = WaterMode.Refractive;

		private int m_OldReflectionTextureSize;

		private int m_OldRefractionTextureSize;

		private static bool s_InsideWater;

		public void OnWillRenderObject()
		{
			if (!base.enabled || !GetComponent<Renderer>() || !GetComponent<Renderer>().sharedMaterial || !GetComponent<Renderer>().enabled)
			{
				return;
			}
			Camera current = Camera.current;
			if (!current || s_InsideWater)
			{
				return;
			}
			s_InsideWater = true;
			m_HardwareWaterSupport = FindHardwareWaterSupport();
			WaterMode waterMode = GetWaterMode();
			CreateWaterObjects(current, out var reflectionCamera, out var refractionCamera);
			Vector3 position = base.transform.position;
			Vector3 up = base.transform.up;
			int pixelLightCount = QualitySettings.pixelLightCount;
			if (disablePixelLights)
			{
				QualitySettings.pixelLightCount = 0;
			}
			UpdateCameraModes(current, reflectionCamera);
			UpdateCameraModes(current, refractionCamera);
			if (waterMode >= WaterMode.Reflective)
			{
				float w = 0f - Vector3.Dot(up, position) - clipPlaneOffset;
				Vector4 plane = new Vector4(up.x, up.y, up.z, w);
				Matrix4x4 reflectionMat = Matrix4x4.zero;
				CalculateReflectionMatrix(ref reflectionMat, plane);
				Vector3 position2 = current.transform.position;
				Vector3 position3 = reflectionMat.MultiplyPoint(position2);
				reflectionCamera.worldToCameraMatrix = current.worldToCameraMatrix * reflectionMat;
				Vector4 clipPlane = CameraSpacePlane(reflectionCamera, position, up, 1f);
				reflectionCamera.projectionMatrix = current.CalculateObliqueMatrix(clipPlane);
				reflectionCamera.cullingMatrix = current.projectionMatrix * current.worldToCameraMatrix;
				reflectionCamera.cullingMask = -17 & reflectLayers.value;
				reflectionCamera.targetTexture = m_ReflectionTexture;
				bool invertCulling = GL.invertCulling;
				GL.invertCulling = !invertCulling;
				reflectionCamera.transform.position = position3;
				Vector3 eulerAngles = current.transform.eulerAngles;
				reflectionCamera.transform.eulerAngles = new Vector3(0f - eulerAngles.x, eulerAngles.y, eulerAngles.z);
				try
				{
					reflectionCamera.Render();
				}
				catch
				{
				}
				reflectionCamera.transform.position = position2;
				GL.invertCulling = invertCulling;
				GetComponent<Renderer>().sharedMaterial.SetTexture("_ReflectionTex", m_ReflectionTexture);
			}
			if (waterMode >= WaterMode.Refractive)
			{
				refractionCamera.worldToCameraMatrix = current.worldToCameraMatrix;
				Vector4 clipPlane2 = CameraSpacePlane(refractionCamera, position, up, -1f);
				refractionCamera.projectionMatrix = current.CalculateObliqueMatrix(clipPlane2);
				refractionCamera.cullingMatrix = current.projectionMatrix * current.worldToCameraMatrix;
				refractionCamera.cullingMask = -17 & refractLayers.value;
				refractionCamera.targetTexture = m_RefractionTexture;
				refractionCamera.transform.position = current.transform.position;
				refractionCamera.transform.rotation = current.transform.rotation;
				try
				{
					refractionCamera.Render();
				}
				catch
				{
					throw new Exception("");
				}
				GetComponent<Renderer>().sharedMaterial.SetTexture("_RefractionTex", m_RefractionTexture);
			}
			if (disablePixelLights)
			{
				QualitySettings.pixelLightCount = pixelLightCount;
			}
			switch (waterMode)
			{
			case WaterMode.Simple:
				Shader.EnableKeyword("WATER_SIMPLE");
				Shader.DisableKeyword("WATER_REFLECTIVE");
				Shader.DisableKeyword("WATER_REFRACTIVE");
				break;
			case WaterMode.Reflective:
				Shader.DisableKeyword("WATER_SIMPLE");
				Shader.EnableKeyword("WATER_REFLECTIVE");
				Shader.DisableKeyword("WATER_REFRACTIVE");
				break;
			case WaterMode.Refractive:
				Shader.DisableKeyword("WATER_SIMPLE");
				Shader.DisableKeyword("WATER_REFLECTIVE");
				Shader.EnableKeyword("WATER_REFRACTIVE");
				break;
			}
			s_InsideWater = false;
		}

		private void OnDisable()
		{
			if ((bool)m_ReflectionTexture)
			{
				UnityEngine.Object.DestroyImmediate(m_ReflectionTexture);
				m_ReflectionTexture = null;
			}
			if ((bool)m_RefractionTexture)
			{
				UnityEngine.Object.DestroyImmediate(m_RefractionTexture);
				m_RefractionTexture = null;
			}
			foreach (KeyValuePair<Camera, Camera> reflectionCamera in m_ReflectionCameras)
			{
				UnityEngine.Object.DestroyImmediate(reflectionCamera.Value.gameObject);
			}
			m_ReflectionCameras.Clear();
			foreach (KeyValuePair<Camera, Camera> refractionCamera in m_RefractionCameras)
			{
				UnityEngine.Object.DestroyImmediate(refractionCamera.Value.gameObject);
			}
			m_RefractionCameras.Clear();
		}

		private void Update()
		{
			if ((bool)GetComponent<Renderer>())
			{
				Material sharedMaterial = GetComponent<Renderer>().sharedMaterial;
				if ((bool)sharedMaterial)
				{
					Vector4 vector = sharedMaterial.GetVector("WaveSpeed");
					float @float = sharedMaterial.GetFloat("_WaveScale");
					Vector4 value = new Vector4(@float, @float, @float * 0.4f, @float * 0.45f);
					double num = (double)Time.timeSinceLevelLoad / 20.0;
					Vector4 value2 = new Vector4((float)Math.IEEERemainder((double)(vector.x * value.x) * num, 1.0), (float)Math.IEEERemainder((double)(vector.y * value.y) * num, 1.0), (float)Math.IEEERemainder((double)(vector.z * value.z) * num, 1.0), (float)Math.IEEERemainder((double)(vector.w * value.w) * num, 1.0));
					sharedMaterial.SetVector("_WaveOffset", value2);
					sharedMaterial.SetVector("_WaveScale4", value);
				}
			}
		}

		private void UpdateCameraModes(Camera src, Camera dest)
		{
			if (dest == null)
			{
				return;
			}
			dest.clearFlags = src.clearFlags;
			dest.backgroundColor = src.backgroundColor;
			if (src.clearFlags == CameraClearFlags.Skybox)
			{
				Skybox component = src.GetComponent<Skybox>();
				Skybox component2 = dest.GetComponent<Skybox>();
				if (!component || !component.material)
				{
					component2.enabled = false;
				}
				else
				{
					component2.enabled = true;
					component2.material = component.material;
				}
			}
			dest.farClipPlane = src.farClipPlane;
			dest.nearClipPlane = src.nearClipPlane;
			dest.orthographic = src.orthographic;
			dest.fieldOfView = src.fieldOfView;
			dest.aspect = src.aspect;
			dest.orthographicSize = src.orthographicSize;
		}

		private void CreateWaterObjects(Camera currentCamera, out Camera reflectionCamera, out Camera refractionCamera)
		{
			WaterMode waterMode = GetWaterMode();
			reflectionCamera = null;
			refractionCamera = null;
			if (waterMode >= WaterMode.Reflective)
			{
				if (!m_ReflectionTexture || m_OldReflectionTextureSize != textureSize)
				{
					if ((bool)m_ReflectionTexture)
					{
						UnityEngine.Object.DestroyImmediate(m_ReflectionTexture);
					}
					m_ReflectionTexture = new RenderTexture(textureSize, textureSize, 16);
					m_ReflectionTexture.name = "__WaterReflection" + GetInstanceID();
					m_ReflectionTexture.isPowerOfTwo = true;
					m_ReflectionTexture.hideFlags = HideFlags.DontSave;
					m_OldReflectionTextureSize = textureSize;
				}
				m_ReflectionCameras.TryGetValue(currentCamera, out reflectionCamera);
				if (!reflectionCamera)
				{
					GameObject gameObject = new GameObject("Water Refl Camera id" + GetInstanceID() + " for " + currentCamera.GetInstanceID(), typeof(Camera), typeof(Skybox));
					reflectionCamera = gameObject.GetComponent<Camera>();
					reflectionCamera.enabled = false;
					reflectionCamera.transform.position = base.transform.position;
					reflectionCamera.transform.rotation = base.transform.rotation;
					reflectionCamera.gameObject.AddComponent<FlareLayer>();
					gameObject.hideFlags = HideFlags.HideAndDontSave;
					m_ReflectionCameras[currentCamera] = reflectionCamera;
				}
			}
			if (waterMode < WaterMode.Refractive)
			{
				return;
			}
			if (!m_RefractionTexture || m_OldRefractionTextureSize != textureSize)
			{
				if ((bool)m_RefractionTexture)
				{
					UnityEngine.Object.DestroyImmediate(m_RefractionTexture);
				}
				m_RefractionTexture = new RenderTexture(textureSize, textureSize, 16);
				m_RefractionTexture.name = "__WaterRefraction" + GetInstanceID();
				m_RefractionTexture.isPowerOfTwo = true;
				m_RefractionTexture.hideFlags = HideFlags.DontSave;
				m_OldRefractionTextureSize = textureSize;
			}
			m_RefractionCameras.TryGetValue(currentCamera, out refractionCamera);
			if (!refractionCamera)
			{
				GameObject gameObject2 = new GameObject("Water Refr Camera id" + GetInstanceID() + " for " + currentCamera.GetInstanceID(), typeof(Camera), typeof(Skybox));
				refractionCamera = gameObject2.GetComponent<Camera>();
				refractionCamera.enabled = false;
				refractionCamera.transform.position = base.transform.position;
				refractionCamera.transform.rotation = base.transform.rotation;
				refractionCamera.gameObject.AddComponent<FlareLayer>();
				gameObject2.hideFlags = HideFlags.HideAndDontSave;
				m_RefractionCameras[currentCamera] = refractionCamera;
			}
		}

		private WaterMode GetWaterMode()
		{
			if (m_HardwareWaterSupport < waterMode)
			{
				return m_HardwareWaterSupport;
			}
			return waterMode;
		}

		private WaterMode FindHardwareWaterSupport()
		{
			if (!GetComponent<Renderer>())
			{
				return WaterMode.Simple;
			}
			Material sharedMaterial = GetComponent<Renderer>().sharedMaterial;
			if (!sharedMaterial)
			{
				return WaterMode.Simple;
			}
			string text = sharedMaterial.GetTag("WATERMODE", searchFallbacks: false);
			if (text == "Refractive")
			{
				return WaterMode.Refractive;
			}
			if (text == "Reflective")
			{
				return WaterMode.Reflective;
			}
			return WaterMode.Simple;
		}

		private Vector4 CameraSpacePlane(Camera cam, Vector3 pos, Vector3 normal, float sideSign)
		{
			Vector3 point = pos + normal * clipPlaneOffset;
			Matrix4x4 worldToCameraMatrix = cam.worldToCameraMatrix;
			Vector3 lhs = worldToCameraMatrix.MultiplyPoint(point);
			Vector3 rhs = worldToCameraMatrix.MultiplyVector(normal).normalized * sideSign;
			return new Vector4(rhs.x, rhs.y, rhs.z, 0f - Vector3.Dot(lhs, rhs));
		}

		private static void CalculateReflectionMatrix(ref Matrix4x4 reflectionMat, Vector4 plane)
		{
			reflectionMat.m00 = 1f - 2f * plane[0] * plane[0];
			reflectionMat.m01 = -2f * plane[0] * plane[1];
			reflectionMat.m02 = -2f * plane[0] * plane[2];
			reflectionMat.m03 = -2f * plane[3] * plane[0];
			reflectionMat.m10 = -2f * plane[1] * plane[0];
			reflectionMat.m11 = 1f - 2f * plane[1] * plane[1];
			reflectionMat.m12 = -2f * plane[1] * plane[2];
			reflectionMat.m13 = -2f * plane[3] * plane[1];
			reflectionMat.m20 = -2f * plane[2] * plane[0];
			reflectionMat.m21 = -2f * plane[2] * plane[1];
			reflectionMat.m22 = 1f - 2f * plane[2] * plane[2];
			reflectionMat.m23 = -2f * plane[3] * plane[2];
			reflectionMat.m30 = 0f;
			reflectionMat.m31 = 0f;
			reflectionMat.m32 = 0f;
			reflectionMat.m33 = 1f;
		}
	}
	public interface IInputSource
	{
	}
	public interface IInputSystem
	{
		float GetAxis(string Axis);

		float GetAxisRaw(string Axis);

		bool GetButtonDown(string button);

		bool GetButtonUp(string button);

		bool GetButton(string button);
	}
	public interface IMCharacter
	{
		void Move(Vector3 move, bool direction = true);

		void SetInput(string key, bool inputvalue);

		void AddInput(string key, BoolEvent NewBool);

		void InitializeInputs(Dictionary<string, BoolEvent> keys);
	}
	public interface ICharacterMove
	{
		void Move(Vector3 move, bool direction = true);
	}
	public class DefaultInput : IInputSystem
	{
		public float GetAxis(string Axis)
		{
			return Input.GetAxis(Axis);
		}

		public float GetAxisRaw(string Axis)
		{
			return Input.GetAxisRaw(Axis);
		}

		public bool GetButton(string button)
		{
			return Input.GetButton(button);
		}

		public bool GetButtonDown(string button)
		{
			return Input.GetButtonDown(button);
		}

		public bool GetButtonUp(string button)
		{
			return Input.GetButtonUp(button);
		}

		public static IInputSystem GetInputSystem(string PlayerID = "")
		{
			return new DefaultInput();
		}
	}
	public class MalbersInput : MonoBehaviour, IInputSource
	{
		private IMCharacter mCharacter;

		private ICharacterMove mCharacterMove;

		private IInputSystem Input_System;

		private Vector3 m_CamForward;

		private Vector3 m_Move;

		private Transform m_Cam;

		public List<InputRow> inputs = new List<InputRow>();

		protected Dictionary<string, InputRow> DInputs = new Dictionary<string, InputRow>();

		public InputAxis Horizontal = new InputAxis("Horizontal", active: true, isRaw: true);

		public InputAxis Vertical = new InputAxis("Vertical", active: true, isRaw: true);

		[SerializeField]
		private bool cameraBaseInput;

		[SerializeField]
		private bool alwaysForward;

		public bool showInputEvents;

		public UnityEvent OnInputEnabled = new UnityEvent();

		public UnityEvent OnInputDisabled = new UnityEvent();

		private float h;

		private float v;

		public string PlayerID = "Player0";

		public bool MoveCharacter { get; set; }

		public bool CameraBaseInput
		{
			get
			{
				return cameraBaseInput;
			}
			set
			{
				cameraBaseInput = value;
			}
		}

		public bool AlwaysForward
		{
			get
			{
				return alwaysForward;
			}
			set
			{
				alwaysForward = value;
			}
		}

		private void Awake()
		{
			Input_System = DefaultInput.GetInputSystem(PlayerID);
			InputAxis horizontal = Horizontal;
			IInputSystem inputSystem = (Vertical.InputSystem = Input_System);
			horizontal.InputSystem = inputSystem;
			foreach (InputRow input in inputs)
			{
				input.InputSystem = Input_System;
			}
			List_to_Dictionary();
			InitializeCharacter();
			MoveCharacter = true;
		}

		private void InitializeCharacter()
		{
			mCharacter = GetComponent<IMCharacter>();
			mCharacterMove = GetComponent<ICharacterMove>();
			if (mCharacter == null)
			{
				return;
			}
			Dictionary<string, BoolEvent> dictionary = new Dictionary<string, BoolEvent>();
			foreach (KeyValuePair<string, InputRow> dInput in DInputs)
			{
				dictionary.Add(dInput.Key, dInput.Value.OnInputChanged);
			}
			mCharacter.InitializeInputs(dictionary);
		}

		private void OnEnable()
		{
			OnInputEnabled.Invoke();
		}

		public virtual void EnableMovement(bool value)
		{
			MoveCharacter = value;
		}

		private void OnDisable()
		{
			if (mCharacterMove != null)
			{
				mCharacterMove.Move(Vector3.zero);
			}
			OnInputDisabled.Invoke();
		}

		private void Start()
		{
			if (Camera.main != null)
			{
				m_Cam = Camera.main.transform;
			}
			else
			{
				m_Cam = UnityEngine.Object.FindObjectOfType<Camera>().transform;
			}
		}

		private void Update()
		{
			SetInput();
		}

		protected virtual void SetInput()
		{
			h = Horizontal.GetAxis;
			v = (alwaysForward ? 1f : Vertical.GetAxis);
			CharacterMove();
			foreach (InputRow input in inputs)
			{
				_ = input.GetInput;
			}
		}

		private void CharacterMove()
		{
			if (MoveCharacter && mCharacterMove != null)
			{
				if (cameraBaseInput)
				{
					mCharacterMove.Move(CameraInputBased());
				}
				else
				{
					mCharacterMove.Move(new Vector3(h, 0f, v), direction: false);
				}
			}
		}

		protected Vector3 CameraInputBased()
		{
			if (m_Cam != null)
			{
				m_CamForward = Vector3.Scale(m_Cam.forward, Vector3.one).normalized;
				m_Move = v * m_CamForward + h * m_Cam.right;
			}
			else
			{
				m_Move = v * Vector3.forward + h * Vector3.right;
			}
			return m_Move;
		}

		public virtual void EnableInput(string inputName, bool value)
		{
			InputRow inputRow = inputs.Find((InputRow item) => item.name == inputName);
			if (inputRow != null)
			{
				inputRow.active = value;
			}
		}

		public virtual void EnableInput(string inputName)
		{
			InputRow inputRow = inputs.Find((InputRow item) => item.name == inputName);
			if (inputRow != null)
			{
				inputRow.active = true;
			}
		}

		public virtual void DisableInput(string inputName)
		{
			InputRow inputRow = inputs.Find((InputRow item) => item.name == inputName);
			if (inputRow != null)
			{
				inputRow.active = false;
			}
		}

		public virtual bool IsActive(string name)
		{
			if (DInputs.TryGetValue(name, out var value))
			{
				return value.active;
			}
			return false;
		}

		public virtual InputRow FindInput(string name)
		{
			InputRow inputRow = inputs.Find((InputRow item) => item.name.ToUpper() == name.ToUpper());
			if (inputRow != null)
			{
				return inputRow;
			}
			return null;
		}

		private void Reset()
		{
			inputs = new List<InputRow>
			{
				new InputRow("Jump", "Jump", KeyCode.Space, InputButton.Press, InputType.Input),
				new InputRow("Shift", "Fire3", KeyCode.LeftShift, InputButton.Press, InputType.Input),
				new InputRow("Attack1", "Fire1", KeyCode.Mouse0, InputButton.Press, InputType.Input),
				new InputRow("Attack2", "Fire2", KeyCode.Mouse1, InputButton.Press, InputType.Input),
				new InputRow(active: false, "SpeedDown", "SpeedDown", KeyCode.Alpha1, InputButton.Down, InputType.Key),
				new InputRow(active: false, "SpeedUp", "SpeedUp", KeyCode.Alpha2, InputButton.Down, InputType.Key),
				new InputRow("Speed1", "Speed1", KeyCode.Alpha1, InputButton.Down, InputType.Key),
				new InputRow("Speed2", "Speed2", KeyCode.Alpha2, InputButton.Down, InputType.Key),
				new InputRow("Speed3", "Speed3", KeyCode.Alpha3, InputButton.Down, InputType.Key),
				new InputRow("Action", "Action", KeyCode.E, InputButton.Down, InputType.Key),
				new InputRow("Fly", "Fly", KeyCode.Q, InputButton.Down, InputType.Key),
				new InputRow("Dodge", "Dodge", KeyCode.R, InputButton.Down, InputType.Key),
				new InputRow("Down", "Down", KeyCode.C, InputButton.Press, InputType.Key),
				new InputRow("Up", "Jump", KeyCode.Space, InputButton.Press, InputType.Input),
				new InputRow("Stun", "Stun", KeyCode.H, InputButton.Press, InputType.Key),
				new InputRow("Damaged", "Damaged", KeyCode.J, InputButton.Down, InputType.Key),
				new InputRow("Death", "Death", KeyCode.K, InputButton.Down, InputType.Key)
			};
		}

		private void List_to_Dictionary()
		{
			DInputs = new Dictionary<string, InputRow>();
			foreach (InputRow input in inputs)
			{
				DInputs.Add(input.name, input);
			}
		}
	}
	[Serializable]
	public class InputRow
	{
		public bool active = true;

		public string name = "InputName";

		public InputType type;

		public string input = "Value";

		public KeyCode key = KeyCode.A;

		public InputButton GetPressed;

		public bool InputValue;

		public UnityEvent OnInputDown = new UnityEvent();

		public UnityEvent OnInputUp = new UnityEvent();

		public UnityEvent OnLongPress = new UnityEvent();

		public UnityEvent OnDoubleTap = new UnityEvent();

		public BoolEvent OnInputChanged = new BoolEvent();

		protected IInputSystem inputSystem = new DefaultInput();

		public bool ShowEvents;

		public float DoubleTapTime = 0.3f;

		public float LongPressTime = 0.5f;

		private bool FirstInputPress;

		private bool InputCompleted;

		private float InputCurrentTime;

		public UnityEvent OnInputPressed = new UnityEvent();

		public FloatEvent OnPressedNormalized = new FloatEvent();

		public virtual bool GetInput
		{
			get
			{
				if (!active)
				{
					return false;
				}
				if (inputSystem == null)
				{
					return false;
				}
				bool inputValue = InputValue;
				switch (GetPressed)
				{
				case InputButton.Press:
					InputValue = ((type == InputType.Input) ? InputSystem.GetButton(input) : Input.GetKey(key));
					if (inputValue != InputValue)
					{
						if (InputValue)
						{
							OnInputDown.Invoke();
						}
						else
						{
							OnInputUp.Invoke();
						}
						OnInputChanged.Invoke(InputValue);
					}
					if (InputValue)
					{
						OnInputPressed.Invoke();
					}
					return InputValue;
				case InputButton.Down:
					InputValue = ((type == InputType.Input) ? InputSystem.GetButtonDown(input) : Input.GetKeyDown(key));
					if (inputValue != InputValue)
					{
						if (InputValue)
						{
							OnInputDown.Invoke();
						}
						OnInputChanged.Invoke(InputValue);
					}
					return InputValue;
				case InputButton.Up:
					InputValue = ((type == InputType.Input) ? InputSystem.GetButtonUp(input) : Input.GetKeyUp(key));
					if (inputValue != InputValue)
					{
						if (InputValue)
						{
							OnInputUp.Invoke();
						}
						OnInputChanged.Invoke(InputValue);
					}
					return InputValue;
				case InputButton.LongPress:
					InputValue = ((type == InputType.Input) ? InputSystem.GetButton(input) : Input.GetKey(key));
					if (InputValue)
					{
						if (!InputCompleted)
						{
							if (!FirstInputPress)
							{
								InputCurrentTime = Time.time;
								FirstInputPress = true;
								OnInputDown.Invoke();
							}
							else
							{
								if (Time.time - InputCurrentTime >= LongPressTime)
								{
									OnLongPress.Invoke();
									OnPressedNormalized.Invoke(1f);
									InputCompleted = true;
									return InputValue = true;
								}
								OnPressedNormalized.Invoke((Time.time - InputCurrentTime) / LongPressTime);
							}
						}
					}
					else
					{
						if (!InputCompleted && FirstInputPress)
						{
							OnInputUp.Invoke();
						}
						FirstInputPress = (InputCompleted = false);
					}
					return InputValue = false;
				case InputButton.DoubleTap:
					InputValue = ((type == InputType.Input) ? InputSystem.GetButtonDown(input) : Input.GetKeyDown(key));
					if (InputValue)
					{
						if (InputCurrentTime != 0f && Time.time - InputCurrentTime > DoubleTapTime)
						{
							FirstInputPress = false;
						}
						if (!FirstInputPress)
						{
							OnInputDown.Invoke();
							InputCurrentTime = Time.time;
							FirstInputPress = true;
						}
						else
						{
							if (Time.time - InputCurrentTime <= DoubleTapTime)
							{
								FirstInputPress = false;
								InputCurrentTime = 0f;
								OnDoubleTap.Invoke();
								return InputValue = true;
							}
							FirstInputPress = false;
						}
					}
					return InputValue = false;
				default:
					return false;
				}
			}
		}

		public IInputSystem InputSystem
		{
			get
			{
				return inputSystem;
			}
			set
			{
				inputSystem = value;
			}
		}

		public InputRow(KeyCode k)
		{
			active = true;
			type = InputType.Key;
			key = k;
			GetPressed = InputButton.Down;
			inputSystem = new DefaultInput();
		}

		public InputRow(string input, KeyCode key)
		{
			active = true;
			type = InputType.Key;
			this.key = key;
			this.input = input;
			GetPressed = InputButton.Down;
			inputSystem = new DefaultInput();
		}

		public InputRow(string unityInput, KeyCode k, InputButton pressed)
		{
			active = true;
			type = InputType.Key;
			key = k;
			input = unityInput;
			GetPressed = InputButton.Down;
			inputSystem = new DefaultInput();
		}

		public InputRow(string name, string unityInput, KeyCode k, InputButton pressed, InputType itype)
		{
			this.name = name;
			active = true;
			type = itype;
			key = k;
			input = unityInput;
			GetPressed = pressed;
			inputSystem = new DefaultInput();
		}

		public InputRow(bool active, string name, string unityInput, KeyCode k, InputButton pressed, InputType itype)
		{
			this.name = name;
			this.active = active;
			type = itype;
			key = k;
			input = unityInput;
			GetPressed = pressed;
			inputSystem = new DefaultInput();
		}

		public InputRow()
		{
			active = true;
			name = "InputName";
			type = InputType.Input;
			input = "Value";
			key = KeyCode.A;
			GetPressed = InputButton.Press;
			inputSystem = new DefaultInput();
		}
	}
	[Serializable]
	public class InputAxis
	{
		public bool active = true;

		public string name = "NewAxis";

		public bool raw = true;

		public string input = "Value";

		private IInputSystem inputSystem = new DefaultInput();

		public FloatEvent OnAxisValueChanged = new FloatEvent();

		private float currentAxisValue;

		public float GetAxis
		{
			get
			{
				if (inputSystem == null || !active)
				{
					return 0f;
				}
				currentAxisValue = (raw ? inputSystem.GetAxisRaw(input) : inputSystem.GetAxis(input));
				return currentAxisValue;
			}
		}

		public IInputSystem InputSystem
		{
			get
			{
				return inputSystem;
			}
			set
			{
				inputSystem = value;
			}
		}

		public InputAxis()
		{
			active = true;
			raw = true;
			input = "Value";
			name = "NewAxis";
			inputSystem = new DefaultInput();
		}

		public InputAxis(string value)
		{
			active = true;
			raw = false;
			input = value;
			name = "NewAxis";
			inputSystem = new DefaultInput();
		}

		public InputAxis(string InputValue, bool active, bool isRaw)
		{
			this.active = active;
			raw = isRaw;
			input = InputValue;
			name = "NewAxis";
			inputSystem = new DefaultInput();
		}

		public InputAxis(string name, string InputValue, bool active, bool raw)
		{
			this.active = active;
			this.raw = raw;
			input = InputValue;
			this.name = name;
			inputSystem = new DefaultInput();
		}
	}
	public interface IAnimatorBehaviour
	{
		void OnStateEnter(int ID, AnimatorStateInfo stateInfo, int layerIndex);

		void OnStateExit(int ID, AnimatorStateInfo stateInfo, int layerIndex);

		void OnStateMove(int ID, AnimatorStateInfo stateInfo, int layerIndex);

		void OnStateUpdate(int ID, AnimatorStateInfo stateInfo, int layerIndex);
	}
	public interface IMDamagable
	{
		void getDamaged(DamageValues DV);
	}
	internal interface IWayPoint
	{
		float StoppingDistance { get; }

		Transform NextTarget { get; }

		float WaitTime { get; }

		WayPointType PointType { get; }
	}
	public class Readme : ScriptableObject
	{
		[Serializable]
		public class Section
		{
			public string heading;

			public string text;

			public string linkText;

			public string url;
		}

		public Texture2D icon;

		public string title;

		public Section[] sections;
	}
	public class Stats : MonoBehaviour
	{
		public List<Stat> stats = new List<Stat>();

		[SerializeField]
		private Stat PinnedStat;

		private void Start()
		{
			StopAllCoroutines();
			foreach (Stat stat in stats)
			{
				stat.InitializeStat(this);
			}
		}

		private void OnDisable()
		{
			StopAllCoroutines();
			foreach (Stat stat in stats)
			{
				stat.Clean();
			}
		}

		public virtual void _PinStat(string name)
		{
			PinnedStat = GetStat(name);
		}

		public virtual void _PinStat(int ID)
		{
			PinnedStat = GetStat(ID);
		}

		public virtual void _PinStat(IntVar ID)
		{
			PinnedStat = GetStat(ID);
		}

		public virtual Stat GetStat(string name)
		{
			PinnedStat = stats.Find((Stat item) => item.name == name);
			return PinnedStat;
		}

		public virtual Stat GetStat(int ID)
		{
			PinnedStat = stats.Find((Stat item) => (int)item.ID == ID);
			return PinnedStat;
		}

		public virtual Stat GetStat(IntVar ID)
		{
			PinnedStat = stats.Find((Stat item) => (int)item.ID == (int)ID);
			return PinnedStat;
		}

		public virtual void _PinStatModifyValue(float value)
		{
			if (PinnedStat != null)
			{
				PinnedStat.Modify(value);
			}
			else
			{
				UnityEngine.Debug.Log("There's no Pinned Stat");
			}
		}

		public virtual void _PinStatModifyValue(float value, float time)
		{
			if (PinnedStat != null)
			{
				PinnedStat.Modify(value, time);
			}
			else
			{
				UnityEngine.Debug.Log("There's no Pinned Stat");
			}
		}

		public virtual void _PinStatModifyValue1Sec(float value)
		{
			if (PinnedStat != null)
			{
				PinnedStat.Modify(value, 1f);
			}
			else
			{
				UnityEngine.Debug.Log("There's no Pinned Stat");
			}
		}

		public virtual void _PinStatSetValue(float value)
		{
			if (PinnedStat != null)
			{
				PinnedStat.Value = value;
			}
			else
			{
				UnityEngine.Debug.Log("There's no Pinned Stat");
			}
		}

		public virtual void _PinStatModifyMaxValue(float value)
		{
			if (PinnedStat != null)
			{
				PinnedStat.ModifyMAX(value);
			}
			else
			{
				UnityEngine.Debug.Log("There's no Pinned Stat");
			}
		}

		public virtual void _PinStatSetMaxValue(float value)
		{
			if (PinnedStat != null)
			{
				PinnedStat.MaxValue = value;
			}
			else
			{
				UnityEngine.Debug.Log("There's no Pinned Stat");
			}
		}

		public virtual void _PinStatModifyRegenerationRate(float value)
		{
			if (PinnedStat != null)
			{
				PinnedStat.ModifyRegenerationRate(value);
			}
			else
			{
				UnityEngine.Debug.Log("There's no Active Stat or the Stat you are trying to modify does not exist");
			}
		}

		public virtual void _PinStatDegenerate(bool value)
		{
			if (PinnedStat != null)
			{
				PinnedStat.Degenerate = value;
			}
			else
			{
				UnityEngine.Debug.Log("There's no Active Stat or the Stat you are trying to modify does not exist");
			}
		}

		public virtual void _PinStatRegenerate(bool value)
		{
			if (PinnedStat != null)
			{
				PinnedStat.Regenerate = value;
			}
			else
			{
				UnityEngine.Debug.Log("There's no Active Stat or the Stat you are trying to modify does not exist");
			}
		}

		public virtual void _PinStatEnable(bool value)
		{
			if (PinnedStat != null)
			{
				PinnedStat.Active = value;
			}
			else
			{
				UnityEngine.Debug.Log("There's no Active Stat or the Stat you are trying to modify does not exist");
			}
		}

		public virtual void _PinStatModifyValue(float newValue, int ticks, float timeBetweenTicks)
		{
			if (PinnedStat != null)
			{
				PinnedStat.Modify(newValue, ticks, timeBetweenTicks);
			}
			else
			{
				UnityEngine.Debug.Log("There's no Active Stat or the Stat you are trying to modify does not exist");
			}
		}

		public virtual void _PinStatCLEAN()
		{
			if (PinnedStat != null)
			{
				PinnedStat.Clean();
			}
			else
			{
				UnityEngine.Debug.Log("There's no Active Stat or the Stat you are trying to modify does not exist");
			}
		}
	}
	[Serializable]
	public class Stat
	{
		public string name;

		[SerializeField]
		private bool active = true;

		public IntReference ID;

		[SerializeField]
		private FloatReference value;

		[SerializeField]
		private FloatReference maxValue;

		[SerializeField]
		private FloatReference minValue;

		[SerializeField]
		private bool regenerate;

		public FloatReference RegenRate;

		public FloatReference RegenWaitTime;

		[SerializeField]
		private bool degenerate;

		public FloatReference DegenRate;

		private bool isBelow;

		private bool isAbove;

		public bool ShowEvents;

		public UnityEvent OnStatFull = new UnityEvent();

		public UnityEvent OnStatEmpty = new UnityEvent();

		[SerializeField]
		public float Below;

		[SerializeField]
		public float Above;

		public UnityEvent OnStatBelow = new UnityEvent();

		public UnityEvent OnStatAbove = new UnityEvent();

		public FloatEvent OnValueChangeNormalized = new FloatEvent();

		public FloatEvent OnValueChange = new FloatEvent();

		public BoolEvent OnDegenereate = new BoolEvent();

		private bool Regenerate_OldValue;

		internal MonoBehaviour Coroutine;

		public IEnumerator Regeneration;

		public IEnumerator Degeneration;

		public IEnumerator ModifyPerTicks;

		public IEnumerator ModifySlow;

		public bool Active
		{
			get
			{
				return active;
			}
			set
			{
				active = value;
				if (value)
				{
					StartRegeneration();
				}
				else
				{
					StopRegeneration();
				}
			}
		}

		public float Value
		{
			get
			{
				return value.Value;
			}
			set
			{
				if (!Active)
				{
					return;
				}
				if (value < 0f)
				{
					value = 0f;
				}
				if (this.value.Value != value)
				{
					this.value.Value = value;
					if (value == 0f)
					{
						OnStatEmpty.Invoke();
					}
					OnValueChangeNormalized.Invoke(value / MaxValue);
					OnValueChange.Invoke(value);
					if (value > Above && !isAbove)
					{
						OnStatAbove.Invoke();
						isAbove = true;
						isBelow = false;
					}
					else if (value < Below && !isBelow)
					{
						OnStatBelow.Invoke();
						isBelow = true;
						isAbove = false;
					}
				}
			}
		}

		public float MaxValue
		{
			get
			{
				return maxValue;
			}
			set
			{
				maxValue.Value = value;
			}
		}

		public float MinValue
		{
			get
			{
				return minValue;
			}
			set
			{
				minValue.Value = value;
			}
		}

		public bool Regenerate
		{
			get
			{
				return regenerate;
			}
			set
			{
				regenerate = value;
				Regenerate_OldValue = regenerate;
				StartRegeneration();
			}
		}

		public bool Degenerate
		{
			get
			{
				return degenerate;
			}
			set
			{
				if (degenerate != value)
				{
					degenerate = value;
					OnDegenereate.Invoke(value);
					if (degenerate)
					{
						regenerate = false;
						StartDegeneration();
						StopRegeneration();
					}
					else
					{
						regenerate = Regenerate_OldValue;
						StopDegeneration();
						StartRegeneration();
					}
				}
			}
		}

		internal void InitializeStat(MonoBehaviour holder)
		{
			isAbove = (isBelow = false);
			Coroutine = holder;
			if (value.Value > Above)
			{
				isAbove = true;
			}
			else if (value.Value < Below)
			{
				isBelow = true;
			}
			Regenerate_OldValue = Regenerate;
			if (MaxValue < Value)
			{
				MaxValue = Value;
			}
			Regeneration = null;
			Degeneration = null;
			ModifyPerTicks = null;
			StartRegeneration();
		}

		public virtual void Modify(float newValue)
		{
			if (Active)
			{
				Value += newValue;
				StartRegeneration();
			}
		}

		public virtual void Modify(float newValue, float time)
		{
			if (Active)
			{
				StopSlowModification();
				ModifySlow = C_SmoothChangeValue(newValue, time);
				Coroutine.StartCoroutine(ModifySlow);
			}
		}

		public virtual void Modify(float newValue, int ticks, float timeBetweenTicks)
		{
			if (Active)
			{
				if (ModifyPerTicks != null)
				{
					Coroutine.StopCoroutine(ModifyPerTicks);
				}
				ModifyPerTicks = C_ModifyTicksValue(newValue, ticks, timeBetweenTicks);
				Coroutine.StartCoroutine(ModifyPerTicks);
			}
		}

		public virtual void ModifyMAX(float newValue)
		{
			if (Active)
			{
				MaxValue += newValue;
				StartRegeneration();
			}
		}

		public virtual void ModifyRegenerationRate(float newValue)
		{
			if (Active)
			{
				RegenRate.Value += newValue;
				StartRegeneration();
			}
		}

		public virtual void ModifyRegenerationWait(float newValue)
		{
			if (Active)
			{
				RegenWaitTime.Value += newValue;
				if ((float)RegenWaitTime < 0f)
				{
					RegenWaitTime.Value = 0f;
				}
			}
		}

		public virtual void SetRegenerationRate(float newValue)
		{
			if (Active)
			{
				RegenRate.Value = newValue;
			}
		}

		public virtual void Reset()
		{
			Value = MaxValue;
		}

		public virtual void Clean()
		{
			StopDegeneration();
			StopRegeneration();
			StopTickDamage();
			StopSlowModification();
		}

		protected virtual void StartRegeneration()
		{
			StopRegeneration();
			if ((float)RegenRate != 0f && Regenerate)
			{
				Regeneration = C_Regenerate();
				Coroutine.StartCoroutine(Regeneration);
			}
		}

		protected virtual void StartDegeneration()
		{
			if ((float)DegenRate != 0f)
			{
				StopDegeneration();
				Degeneration = C_Degenerate();
				Coroutine.StartCoroutine(Degeneration);
			}
		}

		protected virtual void StopRegeneration()
		{
			if (Regeneration != null)
			{
				Coroutine.StopCoroutine(Regeneration);
			}
			Regeneration = null;
		}

		protected virtual void StopDegeneration()
		{
			if (Degeneration != null)
			{
				Coroutine.StopCoroutine(Degeneration);
			}
			Degeneration = null;
		}

		protected virtual void StopTickDamage()
		{
			if (ModifyPerTicks != null)
			{
				Coroutine.StopCoroutine(ModifyPerTicks);
			}
			ModifyPerTicks = null;
		}

		protected virtual void StopSlowModification()
		{
			if (ModifySlow != null)
			{
				Coroutine.StopCoroutine(ModifySlow);
			}
			ModifySlow = null;
		}

		protected virtual IEnumerator C_Regenerate()
		{
			if ((float)RegenWaitTime > 0f)
			{
				yield return new WaitForSeconds(RegenWaitTime);
			}
			float ReachValue = (((float)RegenRate > 0f) ? MaxValue : 0f);
			bool Positive = (float)RegenRate > 0f;
			while (Value != ReachValue)
			{
				Value += (float)RegenRate * Time.deltaTime;
				if (Positive && Value > MaxValue)
				{
					Reset();
					OnStatFull.Invoke();
				}
				else if (!Positive && Value < 0f)
				{
					Value = MinValue;
					OnStatEmpty.Invoke();
				}
				yield return null;
			}
			yield return null;
		}

		protected virtual IEnumerator C_Degenerate()
		{
			while (Degenerate || Value <= MinValue)
			{
				Value -= (float)DegenRate * Time.deltaTime;
				yield return null;
			}
			yield return null;
		}

		protected virtual IEnumerator C_ModifyTicksValue(float value, int Ticks, float time)
		{
			WaitForSeconds WaitForTicks = new WaitForSeconds(time);
			for (int i = 0; i < Ticks; i++)
			{
				Value += value;
				if (Value <= MinValue)
				{
					Value = MinValue;
					break;
				}
				yield return WaitForTicks;
			}
			yield return null;
			StartRegeneration();
		}

		protected virtual IEnumerator C_SmoothChangeValue(float newvalue, float smoothChangeValueTime)
		{
			StopRegeneration();
			UnityEngine.Debug.Log(newvalue);
			float currentTime = 0f;
			float currentValue = Value;
			newvalue = Value + newvalue;
			while (currentTime <= smoothChangeValueTime)
			{
				Value = Mathf.Lerp(currentValue, newvalue, currentTime / smoothChangeValueTime);
				currentTime += Time.deltaTime;
				yield return null;
			}
			Value = newvalue;
			yield return null;
			StartRegeneration();
		}
	}
	[CreateAssetMenu(menuName = "Malbers Animations/Tag")]
	public class Tag : ScriptableObject
	{
		[SerializeField]
		private int id;

		public int ID => id;

		public static implicit operator int(Tag reference)
		{
			return reference.ID;
		}

		private void OnEnable()
		{
			id = base.name.GetHashCode();
		}
	}
	public class Tags : MonoBehaviour
	{
		public List<Tag> tags = new List<Tag>();

		protected Dictionary<int, Tag> tags_Dic;

		private void Start()
		{
			tags_Dic = new Dictionary<int, Tag>();
			foreach (Tag tag in tags)
			{
				if (!tags_Dic.ContainsValue(tag))
				{
					tags_Dic.Add(tag.ID, tag);
				}
			}
			tags = new List<Tag>();
			foreach (KeyValuePair<int, Tag> item in tags_Dic)
			{
				tags.Add(item.Value);
			}
		}

		public bool HasTag(Tag tag)
		{
			return tags_Dic.ContainsValue(tag);
		}

		public bool HasTag(int key)
		{
			return tags_Dic.ContainsKey(key);
		}
	}
	public class DodgeKeys : MonoBehaviour
	{
		private Animal animal;

		public float DoubleKeyTime = 0.3f;

		private bool DodgePressOne;

		private void Start()
		{
			animal = GetComponent<Animal>();
			animal.OnMovementReleased.AddListener(OnMovementReleased);
		}

		private void OnMovementReleased(bool released)
		{
			if (!released)
			{
				if (animal.Direction != 0f && !DodgePressOne)
				{
					DodgePressOne = true;
					Invoke("ResetDodgeKeys", DoubleKeyTime);
				}
				else if (animal.Direction != 0f && DodgePressOne)
				{
					animal.Dodge = true;
					Invoke("ResetDodgeKeys", 0.1f);
				}
			}
		}

		private void ResetDodgeKeys()
		{
			DodgePressOne = false;
			animal.Dodge = false;
		}

		private void OnDisable()
		{
			animal.OnMovementReleased.RemoveListener(OnMovementReleased);
		}
	}
	public class EnterWater : MonoBehaviour
	{
		private void OnTriggerEnter(Collider other)
		{
			other.transform.root.SendMessage("EnterWater", true, SendMessageOptions.DontRequireReceiver);
		}

		private void OnTriggerExit(Collider other)
		{
			other.transform.root.SendMessage("EnterWater", false, SendMessageOptions.DontRequireReceiver);
		}
	}
	public class LookAtCamera : MonoBehaviour
	{
		public bool justY = true;

		public Vector3 Offset;

		private Transform cam;

		private void Start()
		{
			cam = Camera.main.transform;
		}

		private void Update()
		{
			Vector3 forward = cam.position - base.transform.position;
			forward.y = 0f;
			Quaternion quaternion = Quaternion.LookRotation(forward);
			base.transform.eulerAngles = new Vector3(justY ? 0f : quaternion.eulerAngles.x, quaternion.eulerAngles.y, 0f) + Offset;
		}
	}
	public class MinMaxRangeAttribute : Attribute
	{
		public float Min { get; private set; }

		public float Max { get; private set; }

		public MinMaxRangeAttribute(float min, float max)
		{
			Min = min;
			Max = max;
		}
	}
	[AttributeUsage(AttributeTargets.Field, Inherited = true, AllowMultiple = true)]
	public sealed class LineAttribute : Attribute
	{
		public readonly float height;

		public LineAttribute()
		{
			height = 8f;
		}

		public LineAttribute(float height)
		{
			this.height = height;
		}
	}
	public class Pivots : MonoBehaviour
	{
		public float multiplier = 1f;

		public bool debug = true;

		public float debugSize = 0.03f;

		public Color DebugColor = Color.blue;

		public bool drawRay = true;

		public Vector3 GetPivot => base.transform.position;

		public float Y => base.transform.position.y;

		private void OnDrawGizmos()
		{
			if (debug)
			{
				Gizmos.color = DebugColor;
				Gizmos.DrawWireSphere(GetPivot, debugSize);
				if (drawRay)
				{
					Gizmos.DrawRay(GetPivot, -base.transform.up * multiplier * base.transform.root.localScale.y);
				}
			}
		}
	}
	public enum InputType
	{
		Input,
		Key
	}
	public enum WayPointType
	{
		Ground,
		Air,
		Water
	}
	public enum InputButton
	{
		Press,
		Down,
		Up,
		LongPress,
		DoubleTap
	}
	public enum StateTransition
	{
		First,
		Last
	}
	public enum TypeMessage
	{
		Bool,
		Int,
		Float,
		String,
		Void,
		IntVar
	}
	public enum WeaponType
	{
		None,
		Melee,
		Bow,
		Spear,
		Pistol,
		Rifle
	}
	public enum WeaponHolder
	{
		None,
		Left,
		Right,
		Back
	}
	public enum AxisDirection
	{
		None,
		Right,
		Left,
		Up,
		Down,
		Forward,
		Backward
	}
	public enum WeaponActions
	{
		None = 0,
		DrawFromRight = -1,
		DrawFromLeft = -2,
		StoreToRight = -3,
		StoreToLeft = -7,
		Idle = -4,
		AimRight = -5,
		AimLeft = -6,
		ReloadRight = -8,
		ReloadLeft = -9,
		Hold = -10,
		Equip = -100,
		Unequip = -101,
		Atk_RSide_RHand_Forward = 1,
		Atk_RSide_RHand_Backward = 2,
		Atk_LSide_RHand_Forward = 3,
		Atk_LSide_RHand_Backward = 4,
		Atk_RSide_LHand_Forward = 5,
		Atk_RSide_LHand_Backward = 6,
		Atk_LSide_LHand_Forward = 7,
		Atk_LSide_LHand_Backward = 8,
		Fire_Proyectile = 9
	}
	[Serializable]
	public struct RangedFloat
	{
		public float minValue;

		public float maxValue;

		public float RandomValue => UnityEngine.Random.Range(minValue, maxValue);

		public RangedFloat(float minValue, float maxValue)
		{
			this.minValue = minValue;
			this.maxValue = maxValue;
		}

		public bool IsInRange(float value)
		{
			if (value >= minValue)
			{
				return value <= maxValue;
			}
			return false;
		}
	}
	public class ScaleBonesFix : MonoBehaviour, IAnimatorListener
	{
		public Transform fixGameObject;

		public Vector3 Offset;

		public float duration;

		public void FixHeight(bool active)
		{
			StartCoroutine(SmoothFix(active));
		}

		public virtual void OnAnimatorBehaviourMessage(string message, object value)
		{
			this.InvokeWithParams(message, value);
		}

		public IEnumerator SmoothFix(bool active)
		{
			float t = 0f;
			Vector3 startpos = fixGameObject.localPosition;
			Vector3 endpos = startpos + (active ? Offset : (-Offset));
			while (t < duration)
			{
				fixGameObject.localPosition = Vector3.Lerp(startpos, endpos, t / duration);
				t += Time.deltaTime;
				yield return null;
			}
		}
	}
	public class SlowMotion : MonoBehaviour
	{
		[Space]
		public InputRow ISlowMotion = new InputRow("Fire2", KeyCode.Mouse2, InputButton.Down);

		[Space]
		[Range(0.05f, 1f)]
		[SerializeField]
		private float slowMoTimeScale = 0.25f;

		[Range(0.1f, 10f)]
		[SerializeField]
		private float slowMoSpeed = 0.2f;

		private void Update()
		{
			if (ISlowMotion.GetInput)
			{
				if (Time.timeScale == 1f)
				{
					StartCoroutine(SlowTime());
				}
				else
				{
					StartCoroutine(RestartTime());
				}
				Time.fixedDeltaTime = 0.02f * Time.timeScale;
			}
		}

		private IEnumerator SlowTime()
		{
			while (Time.timeScale > slowMoTimeScale)
			{
				Time.timeScale = Mathf.Clamp(Time.timeScale - 1f / slowMoSpeed * Time.unscaledDeltaTime, 0f, 100f);
				Time.fixedDeltaTime = 0.02f * Time.timeScale;
				yield return null;
			}
			Time.timeScale = slowMoTimeScale;
		}

		private IEnumerator RestartTime()
		{
			while (Time.timeScale < 1f)
			{
				Time.timeScale += 1f / slowMoSpeed * Time.unscaledDeltaTime;
				yield return null;
			}
			Time.timeScale = 1f;
		}
	}
	public class StepsManager : MonoBehaviour
	{
		public bool Active = true;

		public LayerMask GroundLayer = 1;

		public ParticleSystem Tracks;

		public ParticleSystem Dust;

		public float StepsVolume = 0.2f;

		public int DustParticles = 30;

		[Tooltip("Scale of the dust and track particles")]
		public Vector3 Scale = Vector3.one;

		public AudioClip[] clips;

		[Tooltip("Distance to Instantiate the tracks on a terrain")]
		public float trackOffset = 0.0085f;

		protected bool active = true;

		public void EnterStep(StepTrigger foot)
		{
			if ((bool)Tracks && !Tracks.gameObject.activeInHierarchy)
			{
				Tracks = UnityEngine.Object.Instantiate(Tracks, base.transform, worldPositionStays: false);
				Tracks.transform.localScale = Scale;
			}
			if ((bool)Dust && !Dust.gameObject.activeInHierarchy)
			{
				Dust = UnityEngine.Object.Instantiate(Dust, base.transform, worldPositionStays: false);
				Dust.transform.localScale = Scale;
			}
			if (!active)
			{
				return;
			}
			if ((bool)foot.StepAudio && clips.Length != 0)
			{
				foot.StepAudio.clip = clips[UnityEngine.Random.Range(0, clips.Length)];
				foot.StepAudio.Play();
			}
			if (!foot.HasTrack && Physics.Raycast(foot.transform.position, -base.transform.up, out var hitInfo, 1f, GroundLayer))
			{
				if ((bool)Tracks)
				{
					ParticleSystem.EmitParams emitParams = default(ParticleSystem.EmitParams);
					emitParams.rotation3D = (Quaternion.FromToRotation(-foot.transform.forward, hitInfo.normal) * foot.transform.rotation).eulerAngles;
					emitParams.position = new Vector3(foot.transform.position.x, hitInfo.point.y + trackOffset, foot.transform.position.z);
					Tracks.Emit(emitParams, 1);
				}
				if ((bool)Dust)
				{
					Dust.transform.position = new Vector3(foot.transform.position.x, hitInfo.point.y + trackOffset, foot.transform.position.z);
					Dust.transform.rotation = Quaternion.FromToRotation(-foot.transform.forward, hitInfo.normal) * foot.transform.rotation;
					Dust.transform.Rotate(-90f, 0f, 0f);
					Dust.Emit(DustParticles);
				}
			}
		}

		public virtual void EnableSteps(bool value)
		{
			active = value;
		}
	}
	public class StepTrigger : MonoBehaviour
	{
		private StepsManager _StepsManager;

		public float WaitNextStep = 0.2f;

		[HideInInspector]
		public AudioSource StepAudio;

		private WaitForSeconds wait;

		private bool hastrack;

		private bool waitrack;

		public bool HasTrack
		{
			get
			{
				return hastrack;
			}
			set
			{
				hastrack = value;
			}
		}

		private void Awake()
		{
			_StepsManager = GetComponentInParent<StepsManager>();
			if (_StepsManager == null)
			{
				UnityEngine.Object.Destroy(base.gameObject);
				return;
			}
			if (!_StepsManager.Active)
			{
				base.gameObject.SetActive(value: false);
				return;
			}
			StepAudio = GetComponent<AudioSource>();
			if (StepAudio == null)
			{
				StepAudio = base.gameObject.AddComponent<AudioSource>();
			}
			StepAudio.spatialBlend = 1f;
			if ((bool)_StepsManager)
			{
				StepAudio.volume = _StepsManager.StepsVolume;
			}
			wait = new WaitForSeconds(WaitNextStep);
		}

		private void OnTriggerEnter(Collider other)
		{
			if (!waitrack && (bool)_StepsManager)
			{
				StartCoroutine(WaitForStep());
				_StepsManager.EnterStep(this);
				hastrack = true;
			}
		}

		private void OnTriggerExit(Collider other)
		{
			hastrack = false;
		}

		private IEnumerator WaitForStep()
		{
			waitrack = true;
			yield return wait;
			waitrack = false;
		}
	}
	public enum AnimCycle
	{
		None,
		Loop,
		Repeat,
		PingPong
	}
	[CreateAssetMenu(menuName = "Malbers Animations/Anim Transform")]
	public class TransformAnimation : ScriptableObject
	{
		public enum AnimTransType
		{
			TransformAnimation,
			MountTriggerAdjustment
		}

		public AnimTransType animTrans;

		private static Keyframe[] K = new Keyframe[2]
		{
			new Keyframe(0f, 0f),
			new Keyframe(1f, 1f)
		};

		public float time = 1f;

		public float delay = 1f;

		public bool UsePosition;

		public Vector3 Position;

		public AnimationCurve PosCurve = new AnimationCurve(K);

		public bool SeparateAxisPos;

		public AnimationCurve PosXCurve = new AnimationCurve(K);

		public AnimationCurve PosYCurve = new AnimationCurve(K);

		public AnimationCurve PosZCurve = new AnimationCurve(K);

		public bool UseRotation;

		public Vector3 Rotation;

		public AnimationCurve RotCurve = new AnimationCurve(K);

		public bool SeparateAxisRot;

		public AnimationCurve RotXCurve = new AnimationCurve(K);

		public AnimationCurve RotYCurve = new AnimationCurve(K);

		public AnimationCurve RotZCurve = new AnimationCurve(K);

		public bool UseScale;

		public Vector3 Scale = Vector3.one;

		public AnimationCurve ScaleCurve = new AnimationCurve(K);
	}
	public class UIFollowTransform : MonoBehaviour
	{
		private Camera main;

		public Transform WorldTransform;

		public Color FadeOut;

		public Color FadeIn;

		public float time = 0.3f;

		private Graphic graphic;

		private Graphic Graph
		{
			get
			{
				if (graphic == null)
				{
					graphic = GetComponent<Graphic>();
				}
				return graphic;
			}
		}

		private void OnEnable()
		{
			Aling();
		}

		public void SetTransform(Transform newTarget)
		{
			WorldTransform = newTarget;
		}

		private void Start()
		{
			Aling();
		}

		private void Awake()
		{
			main = Camera.main;
			graphic = GetComponent<Graphic>();
		}

		private void Update()
		{
			Aling();
		}

		public void Aling()
		{
			if ((bool)main && (bool)WorldTransform)
			{
				base.transform.position = main.WorldToScreenPoint(WorldTransform.position);
			}
		}

		public virtual void Fade_In_Out(bool value)
		{
			Graph.CrossFadeColor(value ? FadeIn : FadeOut, time, ignoreTimeScale: false, useAlpha: true);
		}

		public virtual void Fade_In(float time)
		{
			graphic.CrossFadeColor(FadeIn, time, ignoreTimeScale: false, useAlpha: true);
		}

		public virtual void Fade_Out(float time)
		{
			graphic.CrossFadeColor(FadeOut, time, ignoreTimeScale: false, useAlpha: true);
		}
	}
	public class UseTransform : MonoBehaviour
	{
		public enum UpdateMode
		{
			Update,
			LateUpdate,
			FixedUpdate
		}

		public Transform Reference;

		public UpdateMode updateMode = UpdateMode.LateUpdate;

		private void Update()
		{
			if (updateMode == UpdateMode.Update)
			{
				SetTransformReference();
			}
		}

		private void LateUpdate()
		{
			if (updateMode == UpdateMode.LateUpdate)
			{
				SetTransformReference();
			}
		}

		private void FixedUpdate()
		{
			if (updateMode == UpdateMode.FixedUpdate)
			{
				SetTransformReference();
			}
		}

		private void SetTransformReference()
		{
			if ((bool)Reference)
			{
				base.transform.position = Reference.position;
				base.transform.rotation = Reference.rotation;
			}
		}
	}
	[Serializable]
	public class InventorySlot
	{
		public GameObject item;

		public InputRow input;
	}
	public class MInventory : MonoBehaviour
	{
		public InventorySlot[] Inventory;

		public GameObjectEvent OnEquipItem;

		private void Update()
		{
			for (int i = 0; i < Inventory.Length; i++)
			{
				if (Inventory[i].input.GetInput)
				{
					EquipItem(i);
					break;
				}
			}
		}

		public virtual void EquipItem(int Slot)
		{
			OnEquipItem.Invoke(Inventory[Slot].item);
		}
	}
	public class FadeInOutGraphic : MonoBehaviour
	{
		public Graphic graphic;

		public Color FadeIn;

		public Color FadeOut;

		public float time = 0.25f;

		public virtual void Fade_In_Out(GameObject fade)
		{
			Fade_In_Out(fade != null);
		}

		public virtual void Fade_In_Out(bool fade)
		{
			graphic.CrossFadeColor(fade ? FadeIn : FadeOut, time, ignoreTimeScale: false, useAlpha: true);
		}

		public virtual void Fade_In(float time)
		{
			graphic.CrossFadeColor(FadeIn, time, ignoreTimeScale: false, useAlpha: true);
		}

		public virtual void Fade_Out(float time)
		{
			graphic.CrossFadeColor(FadeOut, time, ignoreTimeScale: false, useAlpha: true);
		}
	}
	public class MountAI : AnimalAIControl, IMountAI
	{
		public bool canBeCalled;

		protected Mountable animalMount;

		protected bool isBeingCalled;

		public bool CanBeCalled
		{
			get
			{
				return canBeCalled;
			}
			set
			{
				canBeCalled = value;
			}
		}

		private void Start()
		{
			animalMount = GetComponent<Mountable>();
			StartAgent();
		}

		private void Update()
		{
			if (animalMount.Mounted)
			{
				base.Agent.enabled = false;
				return;
			}
			base.Agent.nextPosition = base.Agent.transform.position;
			if (base.Agent.isOnNavMesh && base.Agent.enabled)
			{
				if (isBeingCalled)
				{
					base.Agent.SetDestination(target.position);
				}
				UpdateAgent();
			}
		}

		protected override void OnAnimationChanged(int animTag)
		{
			if (!animalMount.Mounted)
			{
				base.OnAnimationChanged(animTag);
			}
		}

		public virtual void CallAnimal(Transform target, bool call)
		{
			if (CanBeCalled && (bool)base.Agent && base.Agent.isOnNavMesh)
			{
				isBeingCalled = call;
				if (isBeingCalled)
				{
					base.Agent.enabled = true;
					SetTarget(target);
					base.Agent.isStopped = false;
				}
				else
				{
					base.Agent.enabled = true;
					base.Agent.isStopped = true;
				}
			}
		}
	}
}
namespace MalbersAnimations.Weapons
{
	public interface IMWeapon
	{
		bool Active { get; set; }

		int WeaponID { get; }

		WeaponHolder Holder { get; set; }

		Vector3 PositionOffset { get; }

		Vector3 RotationOffset { get; }

		bool RightHand { get; }

		float MinDamage { get; }

		float MaxDamage { get; }

		float MinForce { get; set; }

		float MaxForce { get; set; }

		LayerMask HitMask { get; set; }

		bool IsEquiped { get; set; }

		Rider Owner { get; set; }

		void PlaySound(int ID);
	}
	public interface IMelee : IMWeapon
	{
		bool CanCauseDamage { get; set; }

		void CanDoDamage(bool value);
	}
	public interface IBow : IMWeapon
	{
		GameObject ArrowInstance { get; set; }

		Transform KNot { get; }

		Transform ArrowPoint { get; }

		float HoldTime { get; }

		void ReleaseArrow(Vector3 Direction);

		void EquipArrow();

		void DestroyArrow();

		void BendBow(float normalizedTime);

		void RestoreKnot();
	}
	public interface IArrow
	{
		LayerMask HitMask { get; set; }

		float TailOffset { get; set; }

		float Damage { get; set; }

		void ShootArrow(float force, Vector3 Direction);
	}
	public interface IGun : IMWeapon
	{
		bool IsAutomatic { get; set; }

		bool IsAiming { get; set; }

		int TotalAmmo { get; set; }

		int AmmoInChamber { get; set; }

		void FireProyectile(RaycastHit Direction);

		bool Reload();
	}
	[AddComponentMenu("Malbers/Weapons/MArrow")]
	public class MArrow : MonoBehaviour, IArrow
	{
		[Space]
		[Tooltip("Damage this Arrow Causes")]
		public float damage = 1f;

		[Tooltip("Penetration to the hitted mesh")]
		public float Penetration = 0.2f;

		[Tooltip("How long the arrow is stay alive after hit Something")]
		public float AgeAfterImpact = 10f;

		[Tooltip("How long the arrow is alive flying (Used for removing arrows shooted off the map)")]
		public float AgeFlying = 30f;

		[Tooltip("Damage this Arrow Causes")]
		public float tailOffset = 1f;

		public bool useGravity = true;

		public bool AffectRigidBodies = true;

		[Space]
		[Header("Events")]
		public UnityEvent OnFireArrow;

		public RayCastHitEvent OnHitTarget;

		public float timeAfterImpact;

		public UnityEvent AfterImpact;

		protected LayerMask hitmask;

		protected float force;

		private Vector3 direction;

		protected Rigidbody _rigidbody;

		protected Vector3 DeltaPos;

		protected bool isflying;

		[HideInInspector]
		public RaycastHit HitPoint;

		private WaitForEndOfFrame WfeoF = new WaitForEndOfFrame();

		private Rigidbody _Rigidbody
		{
			get
			{
				if (_rigidbody == null)
				{
					_rigidbody = GetComponent<Rigidbody>();
				}
				return _rigidbody;
			}
		}

		public LayerMask HitMask
		{
			get
			{
				return hitmask;
			}
			set
			{
				hitmask = value;
			}
		}

		public float TailOffset
		{
			get
			{
				return tailOffset;
			}
			set
			{
				tailOffset = value;
			}
		}

		public float Damage
		{
			get
			{
				return damage;
			}
			set
			{
				damage = value;
			}
		}

		public bool isFlying => isflying;

		public virtual void ShootArrow(float force, Vector3 direction)
		{
			this.force = force;
			this.direction = direction;
			if ((bool)_Rigidbody)
			{
				_Rigidbody.constraints = RigidbodyConstraints.None;
				_Rigidbody.isKinematic = false;
				if (useGravity)
				{
					_Rigidbody.useGravity = true;
				}
				else
				{
					_Rigidbody.useGravity = false;
				}
				_Rigidbody.AddForce(direction * force);
				isflying = true;
				StartCoroutine(FlyingArrow());
			}
			StartCoroutine(FlyingAge());
			OnFireArrow.Invoke();
		}

		private IEnumerator FlyingAge()
		{
			yield return new WaitForSeconds(AgeFlying);
			if (isflying)
			{
				isflying = false;
				UnityEngine.Object.Destroy(base.gameObject);
				StopAllCoroutines();
			}
		}

		public virtual void TestFlyingArrow()
		{
			StopAllCoroutines();
			StartCoroutine(TestFly());
			StartCoroutine(FlyingAge());
		}

		private IEnumerator TestFly()
		{
			isflying = true;
			DeltaPos = base.transform.position;
			RaycastHit hit = default(RaycastHit);
			while (isflying)
			{
				float num = Mathf.Abs((base.transform.position - DeltaPos).magnitude) + 0.3f;
				if (Physics.Raycast(base.transform.position, _Rigidbody.velocity.normalized, out hit, num, hitmask))
				{
					isflying = false;
				}
				else
				{
					UnityEngine.Debug.DrawRay(base.transform.position, _Rigidbody.velocity.normalized * num, Color.red);
					DeltaPos = base.transform.position;
				}
				yield return null;
			}
			TestHit(hit);
		}

		private IEnumerator FlyingArrow()
		{
			float num = force / _rigidbody.mass * Time.fixedDeltaTime * Time.fixedDeltaTime;
			UnityEngine.Debug.DrawRay(base.transform.position, direction * num, Color.red);
			if (Physics.Raycast(base.transform.position, direction, out var hitInfo, num, hitmask))
			{
				OnHit(hitInfo);
				isflying = false;
			}
			yield return new WaitForEndOfFrame();
			while (isflying)
			{
				num = Mathf.Abs((base.transform.position - DeltaPos).magnitude) + 0.3f;
				if (Physics.Raycast(base.transform.position, _Rigidbody.velocity, out hitInfo, num, hitmask))
				{
					OnHit(hitInfo);
					isflying = false;
					continue;
				}
				UnityEngine.Debug.DrawRay(base.transform.position, _Rigidbody.velocity.normalized * num, Color.red);
				if (_Rigidbody.velocity.magnitude > 0f)
				{
					base.transform.rotation = Quaternion.LookRotation(_Rigidbody.velocity.normalized, base.transform.up);
				}
				yield return WfeoF;
				DeltaPos = base.transform.position;
				yield return null;
			}
		}

		public virtual void TestHit(RaycastHit other)
		{
			DamageValues value = new DamageValues(-base.transform.forward, damage);
			if ((bool)other.transform)
			{
				other.transform.SendMessageUpwards("getDamaged", value, SendMessageOptions.DontRequireReceiver);
				if ((bool)other.rigidbody && AffectRigidBodies)
				{
					other.rigidbody.AddForceAtPosition(base.transform.forward * force, other.point);
				}
			}
			OnHitTarget.Invoke(other);
		}

		public virtual void OnHit(RaycastHit other)
		{
			DamageValues value = new DamageValues(-base.transform.forward, damage);
			if ((bool)other.transform)
			{
				other.transform.SendMessageUpwards("getDamaged", value, SendMessageOptions.DontRequireReceiver);
				if ((bool)other.rigidbody && AffectRigidBodies)
				{
					other.rigidbody.AddForceAtPosition(base.transform.forward * force, other.point);
				}
			}
			_Rigidbody.isKinematic = true;
			_Rigidbody.constraints = RigidbodyConstraints.FreezeAll;
			Vector3 lossyScale = other.transform.lossyScale;
			lossyScale.x = 1f / Mathf.Max(lossyScale.x, 0.0001f);
			lossyScale.y = 1f / Mathf.Max(lossyScale.y, 0.0001f);
			lossyScale.z = 1f / Mathf.Max(lossyScale.z, 0.0001f);
			GameObject gameObject = new GameObject();
			gameObject.name = base.name + "Link";
			gameObject.transform.parent = other.collider.transform;
			gameObject.transform.localScale = lossyScale;
			gameObject.transform.position = other.point;
			gameObject.transform.localRotation = Quaternion.identity;
			base.transform.parent = gameObject.transform;
			base.transform.localScale = Vector3.one;
			base.transform.localPosition = Vector3.zero;
			base.transform.position += base.transform.forward * Penetration;
			UnityEngine.Object.Destroy(gameObject, AgeAfterImpact);
			UnityEngine.Object.Destroy(base.gameObject, AgeAfterImpact);
			OnHitTarget.Invoke(other);
			if (timeAfterImpact > 0f)
			{
				Invoke("InvokeAfterImpact", timeAfterImpact);
			}
			else
			{
				AfterImpact.Invoke();
			}
		}

		private void InvokeAfterImpact()
		{
			AfterImpact.Invoke();
		}
	}
	[AddComponentMenu("Malbers/Weapons/MBow")]
	public class MBow : MWeapon, IBow, IMWeapon
	{
		public Transform knot;

		public Transform arrowPoint;

		public Transform[] UpperBn;

		public Transform[] LowerBn;

		public GameObject arrow;

		protected GameObject arrowInstance;

		public float MaxTension;

		public float holdTime = 2f;

		[Range(0f, 1f)]
		public float BowTension;

		private Quaternion[] UpperBnInitRotation;

		private Quaternion[] LowerBnInitRotation;

		private Vector3 InitPosKnot;

		public Vector3 RotUpperDir = -Vector3.forward;

		public Vector3 RotLowerDir = Vector3.forward;

		public GameObjectEvent OnLoadArrow;

		public FloatEvent OnHold;

		public GameObjectEvent OnReleaseArrow;

		[Tooltip(" Does not shoot arrows when is false, useful for other controllers like Invector and ootii to let them shoot the arrow instead")]
		public bool releaseArrow = true;

		public bool BowIsSet;

		[HideInInspector]
		public bool BonesFoldout;

		[HideInInspector]
		public bool proceduralfoldout;

		[HideInInspector]
		public int LowerIndex;

		[HideInInspector]
		public int UpperIndex;

		public Transform KNot
		{
			get
			{
				knot.rotation = Quaternion.LookRotation((arrowPoint.position - knot.position).normalized, -Physics.gravity);
				return knot;
			}
		}

		public Transform ArrowPoint => arrowPoint;

		public float HoldTime => holdTime;

		public GameObject Arrow
		{
			get
			{
				return arrow;
			}
			set
			{
				arrow = value;
			}
		}

		public GameObject ArrowInstance
		{
			get
			{
				return arrowInstance;
			}
			set
			{
				arrowInstance = value;
			}
		}

		private void Start()
		{
			InitializeWeapon();
		}

		public override void InitializeWeapon()
		{
			base.InitializeWeapon();
			InitializeBow();
		}

		public virtual void InitializeBow()
		{
			if (UpperBn == null || LowerBn == null)
			{
				BowIsSet = false;
				return;
			}
			if (UpperBn.Length == 0 || LowerBn.Length == 0)
			{
				BowIsSet = false;
				return;
			}
			BowTension = 0f;
			UpperBnInitRotation = new Quaternion[UpperBn.Length];
			LowerBnInitRotation = new Quaternion[LowerBn.Length];
			if ((bool)knot)
			{
				InitPosKnot = knot.localPosition;
			}
			for (int i = 0; i < UpperBn.Length; i++)
			{
				if (UpperBn[i] == null)
				{
					BowIsSet = false;
					return;
				}
				UpperBnInitRotation[i] = UpperBn[i].localRotation;
			}
			for (int j = 0; j < LowerBn.Length; j++)
			{
				if (LowerBn[j] == null)
				{
					BowIsSet = false;
					return;
				}
				LowerBnInitRotation[j] = LowerBn[j].localRotation;
			}
			BowIsSet = true;
		}

		public virtual void EquipArrow()
		{
			if (ArrowInstance != null)
			{
				UnityEngine.Object.Destroy(ArrowInstance.gameObject);
			}
			ArrowInstance = UnityEngine.Object.Instantiate(Arrow, KNot);
			ArrowInstance.transform.localPosition = Vector3.zero;
			ArrowInstance.transform.localRotation = Quaternion.identity;
			IArrow component = ArrowInstance.GetComponent<IArrow>();
			if (component != null)
			{
				ArrowInstance.transform.Translate(0f, 0f, component.TailOffset, Space.Self);
			}
			OnLoadArrow.Invoke(ArrowInstance);
		}

		public virtual void DestroyArrow()
		{
			if (ArrowInstance != null)
			{
				UnityEngine.Object.Destroy(ArrowInstance.gameObject);
			}
			ArrowInstance = null;
		}

		public virtual void BendBow(float normalizedTime)
		{
			if (!BowIsSet)
			{
				return;
			}
			BowTension = Mathf.Clamp01(normalizedTime);
			OnHold.Invoke(BowTension);
			for (int i = 0; i < UpperBn.Length; i++)
			{
				if (UpperBn[i] != null)
				{
					UpperBn[i].localRotation = Quaternion.Lerp(UpperBnInitRotation[i], Quaternion.Euler(RotUpperDir * MaxTension) * UpperBnInitRotation[i], BowTension);
				}
			}
			for (int j = 0; j < LowerBn.Length; j++)
			{
				if (LowerBn[j] != null)
				{
					LowerBn[j].localRotation = Quaternion.Lerp(LowerBnInitRotation[j], Quaternion.Euler(RotLowerDir * MaxTension) * LowerBnInitRotation[j], BowTension);
				}
			}
			if ((bool)knot && (bool)arrowPoint)
			{
				UnityEngine.Debug.DrawRay(KNot.position, KNot.forward, Color.red);
			}
		}

		public virtual void ReleaseArrow(Vector3 direction)
		{
			if (!releaseArrow)
			{
				DestroyArrow();
			}
			else if (!(ArrowInstance == null))
			{
				ArrowInstance.transform.parent = null;
				IArrow component = ArrowInstance.GetComponent<IArrow>();
				component.HitMask = base.HitMask;
				component.ShootArrow(Mathf.Lerp(base.MinForce, base.MaxForce, BowTension), direction);
				component.Damage = Mathf.Lerp(base.MinDamage, base.MaxDamage, BowTension);
				OnReleaseArrow.Invoke(ArrowInstance);
				ArrowInstance = null;
			}
		}

		public virtual void RestoreKnot()
		{
			KNot.localPosition = InitPosKnot;
			DestroyArrow();
		}

		public override void PlaySound(int ID)
		{
			if (ID <= Sounds.Length - 1 && Sounds[ID] != null && WeaponSound != null)
			{
				if (WeaponSound.isPlaying)
				{
					WeaponSound.Stop();
				}
				if (ID == 2)
				{
					WeaponSound.pitch = 1.03f / HoldTime;
					StartCoroutine(BowHoldTimePlay(ID));
				}
				else
				{
					WeaponSound.pitch = 1f;
					WeaponSound.PlayOneShot(Sounds[ID]);
				}
			}
		}

		private IEnumerator BowHoldTimePlay(int ID)
		{
			while (BowTension == 0f)
			{
				yield return null;
			}
			WeaponSound.PlayOneShot(Sounds[ID]);
		}
	}
	public class MGun : MWeapon, IGun, IMWeapon
	{
		public int Ammo;

		public int ammoInChamber;

		public int ClipSize;

		public bool isAutomatic;

		public GameObject bulletHole;

		public float BulletHoleTime = 10f;

		public Vector3Event OnFire;

		public UnityEvent OnReload;

		public TransformEvent OnHit;

		public BoolEvent OnAiming;

		protected bool isAiming;

		public int TotalAmmo
		{
			get
			{
				return Ammo;
			}
			set
			{
				Ammo = value;
			}
		}

		public int AmmoInChamber
		{
			get
			{
				return ammoInChamber;
			}
			set
			{
				ammoInChamber = value;
			}
		}

		public bool IsAutomatic
		{
			get
			{
				return isAutomatic;
			}
			set
			{
				isAutomatic = value;
			}
		}

		public bool IsAiming
		{
			get
			{
				return isAiming;
			}
			set
			{
				if (isAiming != value)
				{
					isAiming = value;
					OnAiming.Invoke(IsAiming);
				}
			}
		}

		public void SetTotalAmmo(int value)
		{
			Ammo = value;
		}

		private void Awake()
		{
			InitializeWeapon();
		}

		public virtual void ReduceAmmo(int amount)
		{
			ammoInChamber -= amount;
		}

		public virtual void FireProyectile(RaycastHit AimRay)
		{
			float t = UnityEngine.Random.Range(0, 1);
			Vector3 normalized = (AimRay.point - base.transform.position).normalized;
			ReduceAmmo(1);
			OnFire.Invoke(normalized);
			DamageValues value = new DamageValues(AimRay.normal, Mathf.Lerp(base.MinDamage, base.MaxDamage, t));
			if ((bool)AimRay.transform)
			{
				AimRay.transform.root.SendMessage("getDamaged", value, SendMessageOptions.DontRequireReceiver);
				if ((bool)AimRay.rigidbody)
				{
					AimRay.rigidbody.AddForceAtPosition(normalized * Mathf.Lerp(base.MinForce, base.MaxForce, t), AimRay.point);
				}
				BulletHole(AimRay);
				OnHit.Invoke(AimRay.transform);
			}
		}

		public virtual bool Reload()
		{
			if (Ammo == 0)
			{
				return false;
			}
			int num = ClipSize - ammoInChamber;
			if (num == 0)
			{
				return false;
			}
			int num2 = TotalAmmo - num;
			if (num2 >= 0)
			{
				ammoInChamber += num;
				TotalAmmo = num2;
			}
			else
			{
				ammoInChamber += TotalAmmo;
				TotalAmmo = 0;
			}
			OnReload.Invoke();
			return true;
		}

		public virtual void BulletHole(RaycastHit hit)
		{
			if ((bool)bulletHole)
			{
				Vector3 lossyScale = hit.transform.lossyScale;
				lossyScale.x = 1f / Mathf.Max(lossyScale.x, 0.0001f);
				lossyScale.y = 1f / Mathf.Max(lossyScale.y, 0.0001f);
				lossyScale.z = 1f / Mathf.Max(lossyScale.z, 0.0001f);
				GameObject gameObject = new GameObject();
				gameObject.transform.parent = hit.collider.transform;
				gameObject.transform.localScale = lossyScale;
				gameObject.transform.localPosition = hit.collider.transform.InverseTransformPoint(hit.point);
				gameObject.transform.localRotation = Quaternion.identity;
				GameObject gameObject2 = UnityEngine.Object.Instantiate(bulletHole);
				gameObject2.transform.parent = gameObject.transform;
				gameObject2.transform.localScale = Vector3.one;
				gameObject2.transform.localPosition = Vector3.zero;
				gameObject2.transform.rotation = Quaternion.FromToRotation(Vector3.up, hit.normal);
				gameObject2.transform.localRotation = gameObject2.transform.localRotation * Quaternion.Euler(0f, UnityEngine.Random.Range(-90, 90), 0f);
				UnityEngine.Object.Destroy(gameObject, BulletHoleTime);
				UnityEngine.Object.Destroy(gameObject, BulletHoleTime);
			}
		}
	}
	public class MMelee : MWeapon, IMelee, IMWeapon
	{
		protected bool isOnAtackingState;

		protected bool canCauseDamage;

		public Collider meleeCollider;

		protected List<Transform> AlreadyHitted = new List<Transform>();

		public GameObjectEvent OnHit;

		public BoolEvent OnCauseDamage;

		protected TriggerProxy meleeColliderProxy;

		public bool CanCauseDamage
		{
			get
			{
				return canCauseDamage;
			}
			set
			{
				if (base.IsEquiped)
				{
					canCauseDamage = value;
					AlreadyHitted = new List<Transform>();
					if (!meleeCollider.isTrigger)
					{
						meleeCollider.enabled = canCauseDamage;
					}
				}
			}
		}

		public virtual void CanDoDamage(bool value)
		{
			CanCauseDamage = value;
			OnCauseDamage.Invoke(value);
			meleeCollider.enabled = value;
		}

		private void Start()
		{
			Invoke("InitializeWeapon", 0.01f);
		}

		public override void InitializeWeapon()
		{
			base.InitializeWeapon();
			if ((bool)meleeCollider)
			{
				meleeColliderProxy = meleeCollider.gameObject.AddComponent<TriggerProxy>();
				if (meleeCollider.isTrigger)
				{
					meleeColliderProxy.OnTrigger_Stay.AddListener(WeaponTriggerStay);
				}
				else
				{
					meleeColliderProxy.OnCollision_Enter.AddListener(WeaponCollisionEnter);
				}
				meleeCollider.enabled = false;
			}
		}

		protected virtual void WeaponCollisionEnter(Collision other)
		{
			if (base.IsEquiped && other.contacts.Length != 0)
			{
				SetDamageStuff(other.contacts[0].point, other.transform);
			}
		}

		protected virtual void WeaponTriggerStay(Collider other)
		{
			if (base.IsEquiped)
			{
				SetDamageStuff(other.ClosestPointOnBounds(meleeCollider.bounds.center), other.transform);
			}
		}

		internal void SetDamageStuff(Vector3 OtherHitPoint, Transform other)
		{
			if (other.root == base.transform.root || other.GetComponentInParent<Mountable>() == base.Owner.Montura || !MalbersTools.Layer_in_LayerMask(other.gameObject.layer, base.HitMask))
			{
				return;
			}
			DV = new DamageValues(meleeCollider.bounds.center - OtherHitPoint, UnityEngine.Random.Range(base.MinDamage, base.MaxDamage));
			UnityEngine.Debug.DrawLine(OtherHitPoint, meleeCollider.bounds.center, Color.red, 3f);
			if (canCauseDamage && !AlreadyHitted.Find((Transform item) => item == other.transform.root))
			{
				AlreadyHitted.Add(other.transform.root);
				other.transform.root.SendMessage("getDamaged", DV, SendMessageOptions.DontRequireReceiver);
				Rigidbody component = other.transform.root.GetComponent<Rigidbody>();
				if ((bool)component && other.gameObject.layer != 20)
				{
					component.AddExplosionForce(base.MinForce * 50f, OtherHitPoint, 20f);
				}
				PlaySound(3);
				OnHit.Invoke(other.gameObject);
				if (!meleeCollider.isTrigger)
				{
					meleeCollider.enabled = false;
				}
			}
		}

		private void OnDisable()
		{
			if ((bool)meleeColliderProxy)
			{
				if (meleeCollider.isTrigger)
				{
					meleeColliderProxy.OnTrigger_Stay.RemoveListener(WeaponTriggerStay);
				}
				else
				{
					meleeColliderProxy.OnCollision_Enter.RemoveListener(WeaponCollisionEnter);
				}
			}
		}
	}
	[Serializable]
	public class WeaponEvent : UnityEvent<IMWeapon>
	{
	}
	[Serializable]
	public class WeaponActionEvent : UnityEvent<WeaponActions>
	{
	}
	public abstract class MWeapon : MonoBehaviour, IMWeapon
	{
		public int weaponID;

		[SerializeField]
		private bool active = true;

		[SerializeField]
		private float minDamage = 10f;

		[SerializeField]
		private float maxDamage = 20f;

		[SerializeField]
		private float minForce = 500f;

		[SerializeField]
		private float maxForce = 1000f;

		private bool isEquiped;

		public bool rightHand = true;

		public WeaponHolder holder;

		public Vector3 positionOffset;

		public Vector3 rotationOffset;

		protected DamageValues DV;

		public AudioClip[] Sounds;

		public AudioSource WeaponSound;

		public WeaponEvent OnEquiped = new WeaponEvent();

		public WeaponEvent OnUnequiped = new WeaponEvent();

		[HideInInspector]
		public bool ShowEventEditor;

		public int WeaponID => weaponID;

		public WeaponHolder Holder
		{
			get
			{
				return holder;
			}
			set
			{
				holder = value;
			}
		}

		public bool IsEquiped
		{
			get
			{
				return isEquiped;
			}
			set
			{
				isEquiped = value;
				if (isEquiped)
				{
					OnEquiped.Invoke(this);
					return;
				}
				Owner = null;
				HitMask = default(LayerMask);
				OnUnequiped.Invoke(this);
			}
		}

		public float MinDamage
		{
			get
			{
				return minDamage;
			}
			set
			{
				minDamage = value;
			}
		}

		public float MaxDamage
		{
			get
			{
				return maxDamage;
			}
			set
			{
				maxDamage = value;
			}
		}

		public bool RightHand
		{
			get
			{
				return rightHand;
			}
			set
			{
				rightHand = value;
			}
		}

		public Vector3 PositionOffset => positionOffset;

		public Vector3 RotationOffset => rotationOffset;

		public float MinForce
		{
			get
			{
				return minForce;
			}
			set
			{
				minForce = value;
			}
		}

		public float MaxForce
		{
			get
			{
				return maxForce;
			}
			set
			{
				maxForce = value;
			}
		}

		public Rider Owner { get; set; }

		public LayerMask HitMask { get; set; }

		public bool Active
		{
			get
			{
				return active;
			}
			set
			{
				active = value;
			}
		}

		public override bool Equals(object a)
		{
			if (a is IMWeapon && weaponID == (a as IMWeapon).WeaponID)
			{
				return true;
			}
			return false;
		}

		public override int GetHashCode()
		{
			return base.GetHashCode();
		}

		public virtual void Equiped()
		{
			UnityEngine.Debug.Log(base.name + Owner);
			OnEquiped.Invoke(this);
		}

		public virtual void Unequiped()
		{
			OnUnequiped.Invoke(this);
			Owner = null;
			UnityEngine.Debug.Log(base.name + Owner);
		}

		public virtual void InitializeWeapon()
		{
			WeaponSound = GetComponent<AudioSource>();
			isEquiped = false;
			if (!WeaponSound)
			{
				WeaponSound = base.gameObject.AddComponent<AudioSource>();
			}
			WeaponSound.spatialBlend = 1f;
		}

		public virtual void PlaySound(int ID)
		{
			if (ID <= Sounds.Length - 1 && Sounds[ID] != null && (bool)WeaponSound)
			{
				WeaponSound.PlayOneShot(Sounds[ID]);
			}
		}
	}
	public class AimIKBehaviour : StateMachineBehaviour
	{
		[Header("This is Link to the GunCombatIKMode")]
		public bool active = true;

		private float Weight;

		private RiderCombat RC;

		private GunCombatIK IkMode;

		public override void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
		{
			RC = animator.GetComponent<RiderCombat>();
			IkMode = RC.ActiveAbility as GunCombatIK;
			active = false;
			if ((bool)IkMode)
			{
				active = true;
			}
		}

		public override void OnStateIK(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
		{
			if (!active)
			{
				return;
			}
			bool rightHand = RC.Active_IMWeapon.RightHand;
			Vector3 origin = (rightHand ? RC.RightShoulder.position : RC.LeftShoulder.position);
			float distance = (rightHand ? IkMode.HandIKDistance.Evaluate(1f + RC.HorizontalAngle) : IkMode.HandIKDistance.Evaluate(1f - RC.HorizontalAngle));
			Vector3 vector = (RC.Target ? RC.AimDirection : (RC.AimDot ? MalbersTools.DirectionFromCameraNoRayCast(RC.AimDot.position) : Camera.main.transform.forward));
			Ray ray = new Ray(origin, vector);
			Vector3 point = ray.GetPoint(distance);
			_ = (RC.AimRayCastHit.point - (rightHand ? RC.RightHand.position : RC.LeftHand.position)).normalized;
			if (RC.IsAiming)
			{
				Weight = Mathf.Lerp(Weight, 1f, Time.deltaTime * 10f);
				Quaternion goalRotation = Quaternion.LookRotation(vector) * Quaternion.Euler(rightHand ? IkMode.RightHandOffset : IkMode.LeftHandOffset);
				AvatarIKGoal goal = (rightHand ? AvatarIKGoal.RightHand : AvatarIKGoal.LeftHand);
				animator.SetIKPosition(goal, point);
				animator.SetIKPositionWeight(goal, Weight);
				if (RC.WeaponAction != WeaponActions.Fire_Proyectile)
				{
					animator.SetIKRotation(goal, goalRotation);
					animator.SetIKRotationWeight(goal, Weight);
				}
				animator.SetLookAtWeight(1f * Weight, 0.3f * Weight);
				animator.SetLookAtPosition(ray.GetPoint(10f));
			}
		}
	}
}
namespace MalbersAnimations.HAP
{
	public class CurrentWeaponUI : MonoBehaviour
	{
		public Text WeaponName;

		public void UIWeaponName(GameObject weaponName)
		{
			WeaponName.text = ((WeaponName != null) ? weaponName.name.Replace("(Clone)", "") : "None");
		}
	}
	public class DismountBehavior : StateMachineBehaviour
	{
		private Rider3rdPerson rider;

		private Vector3 HipPosition;

		private Vector3 BottomPosition;

		private Transform transform;

		private Transform MountPoint;

		private Vector3 LastRelativeRiderPosition;

		private TransformAnimation Fix;

		private float ScaleFactor;

		private Transform LeftFoot;

		private Transform RightFoot;

		private IAnimatorBehaviour animatorListener;

		public override void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
		{
			animator.SetInteger(Hash.MountSide, 0);
			rider = animator.GetComponent<Rider3rdPerson>();
			ScaleFactor = rider.Montura.Animal.ScaleFactor;
			LeftFoot = animator.GetBoneTransform(HumanBodyBones.LeftFoot);
			RightFoot = animator.GetBoneTransform(HumanBodyBones.RightFoot);
			MountPoint = rider.Montura.MountPoint;
			BottomPosition = MountPoint.InverseTransformPoint((LeftFoot.position + RightFoot.position) / 2f);
			HipPosition = MountPoint.InverseTransformPoint(animator.rootPosition);
			Fix = rider.MountTrigger.Adjustment;
			transform = animator.transform;
			rider.Start_Dismounting();
			transform.position = rider.Montura.MountPoint.position;
			transform.rotation = rider.Montura.MountPoint.rotation;
			LastRelativeRiderPosition = MountPoint.InverseTransformPoint(transform.position);
		}

		public override void OnStateExit(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
		{
			rider.End_Dismounting();
		}

		public override void OnStateMove(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
		{
			float normalizedTime = animator.GetAnimatorTransitionInfo(layerIndex).normalizedTime;
			float deltaTime = Time.deltaTime;
			transform.rotation = animator.rootRotation;
			transform.position = MountPoint.TransformPoint(LastRelativeRiderPosition);
			if (animator.IsInTransition(layerIndex) && stateInfo.normalizedTime < 0.5f)
			{
				Vector3 position = MountPoint.position;
				position.y = MountPoint.TransformPoint(Vector3.Lerp(HipPosition, BottomPosition, normalizedTime)).y;
				transform.position = position;
				transform.rotation = Quaternion.Lerp(transform.rotation, Quaternion.FromToRotation(transform.up, Vector3.up) * transform.rotation, normalizedTime);
			}
			else
			{
				transform.position += animator.velocity * Time.deltaTime * ScaleFactor * (Fix ? Fix.delay : 1f);
			}
			if ((bool)rider.Montura)
			{
				rider.Montura.Animal.MovementAxis = rider.Montura.Animal.MovementAxis * (1f - stateInfo.normalizedTime);
				if ((bool)rider.MountTrigger && transform.position.y < rider.MountTrigger.transform.position.y)
				{
					transform.position = new Vector3(transform.position.x, rider.MountTrigger.transform.position.y, transform.position.z);
				}
				if (stateInfo.normalizedTime > 0.8f)
				{
					transform.rotation = Quaternion.Lerp(transform.rotation, Quaternion.FromToRotation(transform.up, Vector3.up) * transform.rotation, normalizedTime);
					transform.position = Vector3.Lerp(transform.position, new Vector3(transform.position.x, rider.MountTrigger.transform.position.y, transform.position.z), deltaTime * 5f);
				}
			}
			animator.rootPosition = transform.position;
			LastRelativeRiderPosition = MountPoint.InverseTransformPoint(transform.position);
		}
	}
	public class MountBehavior : StateMachineBehaviour
	{
		public AnimationCurve MovetoMountPoint;

		protected Rider3rdPerson rider;

		protected Transform MountTrigger;

		protected Transform transform;

		protected Transform hip;

		private const float toMountPoint = 0.2f;

		private float AnimalScaleFactor;

		private TransformAnimation Fix;

		public override void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
		{
			animator.SetInteger(Hash.MountSide, 0);
			rider = animator.GetComponent<Rider3rdPerson>();
			transform = animator.transform;
			AnimalScaleFactor = rider.Montura.Animal.ScaleFactor;
			ResetFloatParameters(animator);
			MountTrigger = rider.MountTrigger.transform;
			Fix = rider.MountTrigger.Adjustment;
			rider.Start_Mounting();
		}

		public override void OnStateMove(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
		{
			transform.position += animator.velocity * Time.deltaTime * AnimalScaleFactor * (Fix ? Fix.time : 1f);
			transform.rotation = animator.rootRotation;
			Vector3 position = rider.Montura.MountPoint.position;
			if (stateInfo.normalizedTime < 0.2f)
			{
				Vector3 b = new Vector3(MountTrigger.position.x, transform.position.y, MountTrigger.position.z);
				transform.position = Vector3.Lerp(transform.position, b, stateInfo.normalizedTime / 0.2f);
				transform.rotation = Quaternion.Lerp(transform.rotation, Quaternion.LookRotation(MountTrigger.forward), stateInfo.normalizedTime / 0.2f);
			}
			if ((bool)Fix)
			{
				if (Fix.UsePosition)
				{
					if (!Fix.SeparateAxisPos)
					{
						transform.position = Vector3.LerpUnclamped(transform.position, position, Fix.PosCurve.Evaluate(stateInfo.normalizedTime));
					}
					else
					{
						float x = Mathf.LerpUnclamped(transform.position.x, position.x, Fix.PosXCurve.Evaluate(stateInfo.normalizedTime) * Fix.Position.x);
						float y = Mathf.LerpUnclamped(transform.position.y, position.y, Fix.PosYCurve.Evaluate(stateInfo.normalizedTime) * Fix.Position.y);
						float z = Mathf.LerpUnclamped(transform.position.z, position.z, Fix.PosZCurve.Evaluate(stateInfo.normalizedTime) * Fix.Position.z);
						Vector3 position2 = new Vector3(x, y, z);
						transform.position = position2;
					}
				}
				else
				{
					transform.position = Vector3.Lerp(transform.position, rider.Montura.MountPoint.position, MovetoMountPoint.Evaluate(stateInfo.normalizedTime));
				}
				if (Fix.UseRotation)
				{
					transform.rotation = Quaternion.Lerp(transform.rotation, rider.Montura.MountPoint.rotation, Fix.RotCurve.Evaluate(stateInfo.normalizedTime));
				}
				else
				{
					transform.rotation = Quaternion.Lerp(transform.rotation, rider.Montura.MountPoint.rotation, MovetoMountPoint.Evaluate(stateInfo.normalizedTime));
				}
			}
			else
			{
				transform.position = Vector3.Lerp(transform.position, rider.Montura.MountPoint.position, MovetoMountPoint.Evaluate(stateInfo.normalizedTime));
				transform.rotation = Quaternion.Lerp(transform.rotation, rider.Montura.MountPoint.rotation, MovetoMountPoint.Evaluate(stateInfo.normalizedTime));
			}
		}

		public override void OnStateExit(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
		{
			rider.End_Mounting();
		}

		private static void ResetFloatParameters(Animator animator)
		{
			AnimatorControllerParameter[] parameters = animator.parameters;
			foreach (AnimatorControllerParameter animatorControllerParameter in parameters)
			{
				if (animatorControllerParameter.type == AnimatorControllerParameterType.Float)
				{
					if (animatorControllerParameter.nameHash == Hash.IKLeftFoot || animatorControllerParameter.nameHash == Hash.IKRightFoot)
					{
						break;
					}
					animator.SetFloat(animatorControllerParameter.nameHash, animatorControllerParameter.defaultFloat);
				}
			}
		}
	}
	[RequireComponent(typeof(WagonController))]
	public class MountableCarriage : Mountable
	{
		protected Transform hip;

		public override Animal Animal
		{
			get
			{
				if (!_animal)
				{
					WagonController component = GetComponent<WagonController>();
					if (component.HorseRigidBody == null)
					{
						return null;
					}
					PullingHorses component2 = component.HorseRigidBody.GetComponent<PullingHorses>();
					if ((bool)component2)
					{
						_animal = component2.RightHorse.GetComponent<Animal>();
					}
					else
					{
						_animal = component.HorseRigidBody.GetComponent<Animal>();
					}
				}
				return _animal;
			}
		}

		public override bool CanDismount
		{
			get
			{
				if (Animal != null)
				{
					return Animal.Stand;
				}
				return true;
			}
		}

		public override void EnableControls(bool value)
		{
			WagonController component = GetComponent<WagonController>();
			if (component.HorseRigidBody == null)
			{
				return;
			}
			PullingHorses component2 = component.HorseRigidBody.GetComponent<PullingHorses>();
			if ((bool)component2)
			{
				if ((bool)component2.RightHorse)
				{
					component2.RightHorse.MovementAxis = Vector3.zero;
					component2.RightHorse.GetComponent<MalbersInput>().enabled = value;
				}
				if ((bool)component2.LeftHorse)
				{
					component2.RightHorse.MovementAxis = Vector3.zero;
					component2.LeftHorse.GetComponent<MalbersInput>().enabled = value;
				}
			}
			else
			{
				component.HorseRigidBody.GetComponent<Animal>().GetComponent<MalbersInput>().enabled = value;
			}
		}
	}
	public class PullingHorses : MonoBehaviour
	{
		[Header("Horses")]
		public Animal RightHorse;

		public Animal LeftHorse;

		[Header("Turn Speed")]
		public float TurnSpeed0 = 10f;

		public float TurnSpeed1 = 25f;

		public float TurnSpeed2 = 25f;

		public float TurnSpeed3 = 35f;

		[HideInInspector]
		public float CurrentTurnSpeed = 25f;

		protected Rigidbody _rigidbody;

		[HideInInspector]
		public Vector3 PullingDirection;

		[HideInInspector]
		public bool CurrentAngleSide;

		[HideInInspector]
		public bool CanRotateInPlace;

		public Transform RotationPivot;

		private Vector3 RHorseInitialPos;

		private Vector3 LHorseInitialPos;

		private void Start()
		{
			if ((bool)RightHorse)
			{
				if (!LeftHorse)
				{
					LeftHorse = RightHorse;
				}
				RHorseInitialPos = RightHorse.transform.localPosition;
				_rigidbody = GetComponent<Rigidbody>();
				RightHorse.transform.parent = base.transform;
				LeftHorse.transform.parent = base.transform;
				LeftHorse.GetComponent<Rigidbody>().isKinematic = true;
				RightHorse.GetComponent<Rigidbody>().isKinematic = true;
				LeftHorse.Anim.applyRootMotion = false;
				RightHorse.Anim.applyRootMotion = false;
				switch (RightHorse.StartSpeed)
				{
				case Animal.Ground.walk:
					CurrentTurnSpeed = TurnSpeed1;
					break;
				case Animal.Ground.trot:
					CurrentTurnSpeed = TurnSpeed2;
					break;
				case Animal.Ground.run:
					CurrentTurnSpeed = TurnSpeed3;
					break;
				}
			}
		}

		private void FixedUpdate()
		{
			float fixedDeltaTime = Time.fixedDeltaTime;
			if (!RightHorse)
			{
				return;
			}
			if (RightHorse.Speed1)
			{
				CurrentTurnSpeed = TurnSpeed1;
			}
			else if (RightHorse.Speed2)
			{
				CurrentTurnSpeed = TurnSpeed2;
			}
			else if (RightHorse.Speed3)
			{
				CurrentTurnSpeed = TurnSpeed3;
			}
			LeftHorse.Anim.applyRootMotion = false;
			RightHorse.Anim.applyRootMotion = false;
			if (RightHorse.Speed == 0f)
			{
				RightHorse.MovementAxis = new Vector3(RightHorse.MovementAxis.x * 2f, RightHorse.MovementAxis.y, RightHorse.MovementAxis.z);
				if (CanRotateInPlace)
				{
					base.transform.RotateAround(RotationPivot.position, Vector3.up, RightHorse.MovementAxis.x * fixedDeltaTime * TurnSpeed0);
				}
				else if ((CurrentAngleSide && RightHorse.MovementAxis.x < 0f) || (!CurrentAngleSide && RightHorse.MovementAxis.x > 0f))
				{
					Animal rightHorse = RightHorse;
					Vector3 movementAxis = (LeftHorse.MovementAxis = Vector3.zero);
					rightHorse.MovementAxis = movementAxis;
				}
				PullingDirection = Vector3.Lerp(_rigidbody.velocity, Vector3.zero, fixedDeltaTime * 25f);
				_rigidbody.velocity = Vector3.Lerp(_rigidbody.velocity, Vector3.zero, fixedDeltaTime * 5f);
			}
			else
			{
				base.transform.RotateAround(RotationPivot.position, Vector3.up, RightHorse.MovementAxis.x * fixedDeltaTime * CurrentTurnSpeed);
				PullingDirection = Vector3.Lerp(PullingDirection, base.transform.forward * RightHorse.Anim.velocity.magnitude * ((RightHorse.Speed >= 0f) ? 1 : (-1)), fixedDeltaTime * 15f);
				_rigidbody.velocity = PullingDirection;
			}
			base.transform.position = new Vector3(base.transform.position.x, (RightHorse.transform.position.y + LeftHorse.transform.position.y) / 2f, base.transform.position.z);
			if ((bool)RightHorse)
			{
				RightHorse.transform.rotation = base.transform.rotation;
				RightHorse.transform.rotation = Quaternion.FromToRotation(RightHorse.transform.up, RightHorse.SurfaceNormal) * RightHorse.transform.rotation;
			}
			if ((bool)LeftHorse)
			{
				LeftHorse.transform.rotation = base.transform.rotation;
				LeftHorse.transform.rotation = Quaternion.FromToRotation(LeftHorse.transform.up, LeftHorse.SurfaceNormal) * LeftHorse.transform.rotation;
			}
			if ((bool)LeftHorse && LeftHorse != RightHorse)
			{
				LeftHorse.MovementAxis = RightHorse.MovementAxis;
				LeftHorse.GroundSpeed = RightHorse.GroundSpeed;
				LeftHorse.SetIntID(RightHorse.IDInt);
			}
			RightHorse.transform.localPosition = new Vector3(RHorseInitialPos.x, RightHorse.transform.localPosition.y, RHorseInitialPos.z);
		}
	}
	public class WagonController : MonoBehaviour
	{
		[Header("Horse")]
		public Rigidbody HorseRigidBody;

		public ConfigurableJoint HorseJoint;

		public float MaxTurnAngle = 45f;

		protected PullingHorses DHorses;

		[Header("Colliders")]
		public Transform BodyCollider;

		public Transform StearCollider;

		[Space]
		public WheelCollider[] WheelColliders;

		[Space]
		[Header("Meshes")]
		public Transform Body;

		public Transform StearMesh;

		public Transform[] WheelMeshes;

		protected Rigidbody _rigidbody;

		protected float currentAngle;

		[Space]
		public bool debug;

		public Color DebugColor;

		private void Start()
		{
			_rigidbody = GetComponent<Rigidbody>();
			if ((bool)HorseRigidBody)
			{
				DHorses = HorseRigidBody.transform.GetComponent<PullingHorses>();
			}
			if ((bool)Body && (bool)BodyCollider)
			{
				Body.parent = BodyCollider;
			}
			if ((bool)StearMesh && (bool)StearCollider)
			{
				StearMesh.parent = StearCollider;
			}
			if ((bool)HorseRigidBody && (bool)HorseJoint)
			{
				HorseJoint.connectedBody = HorseRigidBody;
			}
		}

		private void UpdateWheelMeshes()
		{
			for (int i = 0; i < WheelColliders.Length; i++)
			{
				if ((bool)WheelColliders[i])
				{
					if ((bool)DHorses)
					{
						StopWheels(DHorses.RightHorse.Stand, i);
					}
					WheelColliders[i].GetWorldPose(out var pos, out var quat);
					WheelMeshes[i].position = pos;
					WheelMeshes[i].rotation = quat;
				}
			}
		}

		private void StopWheels(bool stop, int Index)
		{
			if (stop)
			{
				WheelColliders[Index].brakeTorque = 1f;
			}
			else
			{
				WheelColliders[Index].brakeTorque = 0f;
			}
		}

		private void Update()
		{
			UpdateWheelMeshes();
			GetStearAngle();
		}

		protected virtual void GetStearAngle()
		{
			if (!DHorses || !StearCollider || !BodyCollider)
			{
				return;
			}
			Vector3 forward = BodyCollider.forward;
			Vector3 forward2 = StearCollider.forward;
			forward.y = (forward2.y = 0f);
			currentAngle = Vector3.Angle(forward, forward2);
			float num = Vector3.Dot(forward, StearCollider.right);
			currentAngle *= ((num > 0f) ? 1 : (-1));
			DHorses.CurrentAngleSide = num > 0f;
			if ((bool)DHorses)
			{
				if ((currentAngle >= MaxTurnAngle && DHorses.RightHorse.MovementAxis.x <= 0f) || (currentAngle <= 0f - MaxTurnAngle && DHorses.RightHorse.MovementAxis.x >= 0f))
				{
					DHorses.CanRotateInPlace = false;
				}
				else
				{
					DHorses.CanRotateInPlace = true;
				}
				if (_rigidbody.velocity.magnitude < 0.01f)
				{
					_rigidbody.velocity = DHorses.PullingDirection;
				}
			}
		}
	}
	[RequireComponent(typeof(Mountable))]
	public class IKReins : MonoBehaviour
	{
		public Transform ReinLeftHand;

		public Transform ReinRightHand;

		protected Vector3 LocalStride_L;

		protected Vector3 LocalStride_R;

		protected Transform riderHand_L;

		protected Transform riderHand_R;

		protected Mountable Montura;

		protected bool freeRightHand = true;

		protected bool freeLeftHand = true;

		private void Awake()
		{
			Montura = GetComponent<Mountable>();
		}

		private void Start()
		{
			if ((bool)ReinLeftHand && (bool)ReinRightHand)
			{
				LocalStride_L = ReinLeftHand.localPosition;
				LocalStride_R = ReinRightHand.localPosition;
			}
			else
			{
				UnityEngine.Debug.LogWarning("Some of the Reins has not been set on the inspector. Please fill the values");
			}
		}

		private void OnEnable()
		{
			Montura.OnMounted.AddListener(OnRiderMounted);
			Montura.OnDismounted.AddListener(OnRiderDismounted);
		}

		private void OnDisable()
		{
			Montura.OnMounted.RemoveListener(OnRiderMounted);
			Montura.OnDismounted.RemoveListener(OnRiderDismounted);
		}

		public void RightHand_is_Free(bool value)
		{
			freeRightHand = value;
			if (!value && (bool)ReinRightHand)
			{
				ReinRightHand.localPosition = LocalStride_R;
			}
		}

		public void LeftHand_is_Free(bool value)
		{
			freeLeftHand = value;
			if (!value && (bool)ReinLeftHand)
			{
				ReinLeftHand.localPosition = LocalStride_L;
			}
		}

		private void OnRiderMounted()
		{
			Animator anim = Montura.ActiveRider.Anim;
			riderHand_L = anim.GetBoneTransform(HumanBodyBones.LeftHand);
			riderHand_R = anim.GetBoneTransform(HumanBodyBones.RightHand);
		}

		private void OnRiderDismounted()
		{
			riderHand_L = null;
			riderHand_R = null;
		}

		private void LateUpdate()
		{
			if (!ReinLeftHand || !ReinRightHand)
			{
				return;
			}
			if ((bool)Montura.ActiveRider && Montura.ActiveRider.IsRiding)
			{
				if (freeLeftHand)
				{
					ReinLeftHand.position = Vector3.Lerp(riderHand_L.position, riderHand_L.GetChild(1).position, 0.5f);
				}
				else if (freeRightHand)
				{
					ReinLeftHand.position = Vector3.Lerp(riderHand_R.position, riderHand_R.GetChild(1).position, 0.5f);
				}
				if (freeRightHand)
				{
					ReinRightHand.position = Vector3.Lerp(riderHand_R.position, riderHand_R.GetChild(1).position, 0.5f);
				}
				else if (freeLeftHand)
				{
					ReinRightHand.position = Vector3.Lerp(riderHand_L.position, riderHand_L.GetChild(1).position, 0.5f);
				}
			}
			else
			{
				ReinLeftHand.localPosition = LocalStride_L;
				ReinRightHand.localPosition = LocalStride_R;
			}
		}
	}
	public interface IMount
	{
		Transform MountPoint { get; }

		Transform FootLeftIK { get; }

		Transform FootRightIK { get; }

		Transform KneeLeftIK { get; }

		Transform KneeRightIK { get; }

		Animal Animal { get; }

		Rider ActiveRider { get; set; }

		Transform transform { get; }

		bool StraightSpine { get; }

		Quaternion SpineOffset { get; }

		bool Mounted { get; set; }

		bool CanBeMounted { get; set; }

		bool CanDismount { get; }

		string MountLayer { get; set; }

		string MountIdle { get; set; }

		void EnableControls(bool value);
	}
	public interface IMountAI
	{
		bool CanBeCalled { get; }

		void CallAnimal(Transform target, bool call = true);
	}
	public class Mountable : MonoBehaviour, IAnimatorListener
	{
		protected Rider _rider;

		protected RiderCombat _ridercombat;

		protected Animal _animal;

		public bool active = true;

		public string mountLayer = "Mounted";

		public bool instantMount;

		public string mountIdle = "Idle01";

		protected bool mounted;

		private bool isOnCoroutine;

		internal bool NearbyRider;

		public bool straightSpine;

		public Vector3 pointOffset = new Vector3(0f, 0f, 0f);

		public float LowLimit = 45f;

		public float HighLimit = 135f;

		public float smoothSM = 0.5f;

		protected Quaternion InitialRotation;

		private Quaternion straightRotation;

		private Quaternion currentRotation;

		public bool syncAnimators = true;

		public float WalkASpeed = 1f;

		public float TrotASpeed = 1f;

		public float RunASpeed = 1f;

		public float FlyASpeed = 1f;

		public float SwimASpeed = 1f;

		protected float AnimatorSpeed = 1f;

		public bool DebugSync;

		public Transform ridersLink;

		public Transform leftIK;

		public Transform rightIK;

		public Transform leftKnee;

		public Transform rightKnee;

		protected Vector3 LocalStride_L;

		protected Vector3 LocalStride_R;

		protected bool freeRightHand = true;

		protected bool freeLeftHand = true;

		public UnityEvent OnMounted = new UnityEvent();

		public UnityEvent OnDismounted = new UnityEvent();

		public BoolEvent OnCanBeMounted = new BoolEvent();

		private bool changed;

		private bool straightAim;

		[HideInInspector]
		public bool ShowLinks = true;

		[HideInInspector]
		public bool ShowAnimatorSpeeds;

		[HideInInspector]
		public bool ShowEvents;

		public Transform MountPoint => ridersLink;

		public Transform FootLeftIK => leftIK;

		public Transform FootRightIK => rightIK;

		public Transform KneeLeftIK => leftKnee;

		public Transform KneeRightIK => rightKnee;

		public bool StraightSpine => straightSpine;

		public Quaternion PointOffset => Quaternion.Euler(pointOffset);

		public bool Mounted
		{
			get
			{
				return mounted;
			}
			set
			{
				if (value != mounted)
				{
					mounted = value;
					if (mounted)
					{
						OnMounted.Invoke();
					}
					else
					{
						OnDismounted.Invoke();
					}
				}
			}
		}

		public virtual Animal Animal
		{
			get
			{
				if (_animal == null)
				{
					_animal = GetComponent<Animal>();
				}
				return _animal;
			}
		}

		public virtual bool CanDismount => Mounted;

		public virtual string MountLayer
		{
			get
			{
				return mountLayer;
			}
			set
			{
				mountLayer = value;
			}
		}

		public virtual string MountIdle
		{
			get
			{
				return mountIdle;
			}
			set
			{
				mountIdle = value;
			}
		}

		public virtual bool CanBeMounted
		{
			get
			{
				return active;
			}
			set
			{
				active = value;
			}
		}

		public Rider ActiveRider
		{
			get
			{
				return _rider;
			}
			set
			{
				_rider = value;
			}
		}

		public RiderCombat ActiveRiderCombat
		{
			get
			{
				return _ridercombat;
			}
			set
			{
				_ridercombat = value;
			}
		}

		public bool InstantMount
		{
			get
			{
				return instantMount;
			}
			set
			{
				instantMount = value;
			}
		}

		public Quaternion StraightRotation => straightRotation;

		public virtual void EnableControls(bool value)
		{
			if ((bool)Animal)
			{
				MalbersInput component = Animal.GetComponent<MalbersInput>();
				if ((bool)component)
				{
					component.enabled = value;
				}
				Animal.ResetInputs();
			}
		}

		private void OnValidate()
		{
		}

		private void Start()
		{
			InitialRotation = MountPoint.localRotation;
		}

		private void Update()
		{
			if ((bool)ActiveRider && ActiveRider.IsRiding)
			{
				if (syncAnimators)
				{
					SetAnimatorSpeed(Time.deltaTime * 2f);
				}
				SolveStraightMount();
			}
		}

		private void SolveStraightMount()
		{
			currentRotation = MountPoint.localRotation;
			MountPoint.localRotation = InitialRotation;
			straightRotation = Quaternion.FromToRotation(MountPoint.up, Vector3.up) * MountPoint.rotation;
			float num = Vector3.Angle(Vector3.up, MountPoint.forward);
			if (num < LowLimit)
			{
				straightRotation *= Quaternion.Euler(new Vector3(num - LowLimit, 0f));
			}
			else if (num > HighLimit)
			{
				straightRotation *= Quaternion.Euler(new Vector3(num - HighLimit, 0f));
			}
			if (pointOffset != Vector3.zero)
			{
				straightRotation *= PointOffset;
			}
			MountPoint.localRotation = currentRotation;
			if (straightAim)
			{
				MountPoint.rotation = straightRotation;
				return;
			}
			if (straightSpine && !changed)
			{
				changed = true;
				StopAllCoroutines();
				StartCoroutine(I_to_StraightMount(1f));
			}
			if (!straightSpine && changed)
			{
				changed = false;
				StopAllCoroutines();
				StartCoroutine(I_from_StraightMount(1f));
			}
			if (!isOnCoroutine)
			{
				if (straightSpine)
				{
					MountPoint.rotation = straightRotation;
				}
				else
				{
					MountPoint.localRotation = InitialRotation;
				}
			}
		}

		private IEnumerator I_to_StraightMount(float time)
		{
			float currentTime = 0f;
			Quaternion startRotation = MountPoint.rotation;
			isOnCoroutine = true;
			while (currentTime <= time)
			{
				currentTime += Time.deltaTime;
				MountPoint.rotation = Quaternion.Slerp(startRotation, straightRotation, currentTime / time);
				yield return null;
			}
			MountPoint.rotation = straightRotation;
			isOnCoroutine = false;
		}

		private IEnumerator I_from_StraightMount(float time)
		{
			float currentTime = 0f;
			Quaternion startRotation = MountPoint.localRotation;
			isOnCoroutine = true;
			while (currentTime <= time)
			{
				currentTime += Time.deltaTime;
				MountPoint.localRotation = Quaternion.Slerp(startRotation, InitialRotation, currentTime / time);
				yield return null;
			}
			MountPoint.localRotation = InitialRotation;
			isOnCoroutine = false;
		}

		private void SetAnimatorSpeed(float time)
		{
			AnimatorSpeed = 1f;
			if (Animal.AnimState == AnimTag.Locomotion)
			{
				if (Animal.Speed1)
				{
					AnimatorSpeed = WalkASpeed * Animal.walkSpeed.animator;
				}
				else if (Animal.Speed2)
				{
					AnimatorSpeed = TrotASpeed * Animal.trotSpeed.animator;
				}
				else if (Animal.Speed3)
				{
					AnimatorSpeed = RunASpeed * Animal.runSpeed.animator;
				}
			}
			else if (Animal.canSwim && Animal.Swim)
			{
				AnimatorSpeed = SwimASpeed * Animal.swimSpeed.animator;
			}
			else if (Animal.canFly && Animal.Fly)
			{
				AnimatorSpeed = FlyASpeed * Animal.flySpeed.animator;
			}
			AnimatorSpeed *= Animal.animatorSpeed;
			if (ActiveRider is Rider3rdPerson)
			{
				ActiveRider.Anim.speed = Mathf.Lerp(ActiveRider.Anim.speed, AnimatorSpeed, time);
			}
		}

		public virtual void StraightMount(bool value)
		{
			straightSpine = value;
		}

		public virtual void StraightAim(bool value)
		{
			straightAim = value;
		}

		public virtual void OnAnimatorBehaviourMessage(string message, object value)
		{
			this.InvokeWithParams(message, value);
		}
	}
	public class MountTriggers : MonoBehaviour
	{
		public string MountAnimation = "Mount";

		[Tooltip("the Transition ID value to dismount this kind of Montura.. (is Located on the Animator)")]
		public int DismountID = 1;

		public TransformAnimation Adjustment;

		private Mountable Montura;

		private Rider rider;

		private void Awake()
		{
			Montura = GetComponentInParent<Mountable>();
		}

		private void OnTriggerEnter(Collider other)
		{
			GetAnimal(other);
		}

		private void GetAnimal(Collider other)
		{
			if (!Montura)
			{
				UnityEngine.Debug.LogError("No Mountable Script Found... please add one");
			}
			else if (!Montura.Mounted && Montura.CanBeMounted)
			{
				rider = other.GetComponentInChildren<Rider>();
				if (rider == null)
				{
					rider = other.GetComponentInParent<Rider>();
				}
				if (rider != null && !rider.IsRiding)
				{
					rider.Montura = Montura;
					rider.MountTrigger = this;
					rider.OnFindMount.Invoke(base.transform.root.gameObject);
					Montura.OnCanBeMounted.Invoke(arg0: true);
					Montura.NearbyRider = true;
				}
			}
		}

		private void OnTriggerExit(Collider other)
		{
			rider = other.GetComponentInChildren<Rider>();
			if (rider == null)
			{
				rider = other.GetComponentInParent<Rider>();
			}
			if (!(rider != null) || rider.IsRiding)
			{
				return;
			}
			if (rider.MountTrigger == this && !Montura.Mounted)
			{
				rider.MountTrigger = null;
				if ((bool)rider.Montura)
				{
					rider.Montura.EnableControls(value: false);
				}
				rider.Montura = null;
				rider.OnFindMount.Invoke(null);
				Montura.OnCanBeMounted.Invoke(arg0: false);
				Montura.NearbyRider = false;
			}
			rider = null;
		}
	}
	[CreateAssetMenu(menuName = "Malbers Animations/HAP/Bow Combat")]
	public class BowCombat : RiderCombatAbility
	{
		private bool isHolding;

		private float HoldTime;

		private static Keyframe[] KeyFrames = new Keyframe[4]
		{
			new Keyframe(0f, 1f),
			new Keyframe(1.25f, 1f),
			new Keyframe(1.5f, 0f),
			new Keyframe(2f, 0f)
		};

		[Header("Right Handed Bow Offsets")]
		public Vector3 ChestRight = new Vector3(25f, 0f, 0f);

		public Vector3 ShoulderRight = new Vector3(5f, 0f, 0f);

		public Vector3 HandRight;

		[Header("Left Handed Bow Offsets")]
		public Vector3 ChestLeft = new Vector3(-25f, 0f, 0f);

		public Vector3 ShoulderLeft = new Vector3(-5f, 0f, 0f);

		public Vector3 HandLeft;

		[Space]
		[Tooltip("This Curve is for straightening the aiming Arm while is on the Aiming State")]
		public AnimationCurve AimWeight = new AnimationCurve(KeyFrames);

		protected bool KnotToHand;

		protected Quaternion Delta_Hand;

		private IBow Bow;

		public override WeaponType Type => MalbersAnimations.WeaponType.Bow;

		public override bool TypeOfAbility(IMWeapon weapon)
		{
			return weapon is IBow;
		}

		public override WeaponType WeaponType()
		{
			return MalbersAnimations.WeaponType.Bow;
		}

		public override void StartAbility(RiderCombat ridercombat)
		{
			base.StartAbility(ridercombat);
			KnotToHand = false;
		}

		public override void ActivateAbility()
		{
			Bow = RC.Active_IMWeapon as IBow;
		}

		public override void UpdateAbility()
		{
			if (!RC.IsAiming && isHolding)
			{
				isHolding = false;
				HoldTime = 0f;
				RC.Anim.SetFloat(Hash.IDFloat, 0f);
				Bow.BendBow(0f);
			}
			BowKnotInHand();
		}

		public override void PrimaryAttack()
		{
			BowAttack();
		}

		public override void PrimaryAttackReleased()
		{
			ReleaseArrow();
		}

		public override void LateUpdateAbility()
		{
			FixAimPoseBow();
		}

		protected virtual void BowAttack()
		{
			if (RC.IsAiming && RC.WeaponAction != WeaponActions.Fire_Proyectile)
			{
				if (!(RC.Active_IMWeapon.RightHand ? (RC.HorizontalAngle < 0.5f) : (RC.HorizontalAngle > -0.5f)))
				{
					isHolding = false;
					HoldTime = 0f;
				}
				else if (!isHolding)
				{
					RC.SetAction(WeaponActions.Hold);
					isHolding = true;
					HoldTime = 0f;
				}
				else
				{
					HoldBow();
				}
			}
		}

		private void ReleaseArrow()
		{
			if (RC.IsAiming && RC.WeaponAction != WeaponActions.Fire_Proyectile && isHolding)
			{
				Bow.KNot.rotation = Quaternion.LookRotation(RC.AimDirection);
				RC.SetAction(WeaponActions.Fire_Proyectile);
				isHolding = false;
				HoldTime = 0f;
				RC.Anim.SetFloat(Hash.IDFloat, 0f);
				Bow.ReleaseArrow(RC.AimDirection);
				Bow.BendBow(0f);
				RC.OnAttack.Invoke(RC.Active_IMWeapon);
			}
		}

		private void HoldBow()
		{
			HoldTime += Time.deltaTime;
			if (HoldTime <= Bow.HoldTime + Time.deltaTime)
			{
				Bow.BendBow(HoldTime / Bow.HoldTime);
			}
			RC.Anim.SetFloat(Hash.IDFloat, HoldTime / Bow.HoldTime);
		}

		public virtual void EquipArrow()
		{
			Bow.EquipArrow();
		}

		public override bool ChangeAimCameraSide()
		{
			return false;
		}

		public override void ResetAbility()
		{
			KnotToHand = false;
			Bow = null;
		}

		protected virtual void FixAimPoseBow()
		{
			if (RC.IsAiming)
			{
				float num = (RC.Active_IMWeapon.RightHand ? AimWeight.Evaluate(1f + RC.HorizontalAngle) : AimWeight.Evaluate(1f - RC.HorizontalAngle));
				Vector3 vector = (RC.Target ? RC.AimDirection : (RC.AimDot ? MalbersTools.DirectionFromCameraNoRayCast(RC.AimDot.position) : cam.forward));
				Quaternion quaternion = Quaternion.LookRotation(vector, RC.Target ? Vector3.up : cam.up);
				Vector3 axis = (RC.Target ? Vector3.Cross(Vector3.up, vector).normalized : cam.right);
				RC.Chest.RotateAround(RC.Chest.position, axis, (Vector3.Angle(Vector3.up, vector) - 90f) * num);
				if (RC.Active_IMWeapon.RightHand)
				{
					RC.Chest.rotation *= Quaternion.Euler(ChestRight);
					RC.RightHand.rotation *= Quaternion.Euler(HandRight);
					RC.RightShoulder.rotation = Quaternion.Lerp(RC.RightShoulder.rotation, quaternion * Quaternion.Euler(ShoulderRight), num);
				}
				else
				{
					RC.Chest.rotation *= Quaternion.Euler(ChestLeft);
					RC.LeftHand.rotation *= Quaternion.Euler(HandLeft);
					RC.LeftShoulder.rotation = Quaternion.Lerp(RC.LeftShoulder.rotation, quaternion * Quaternion.Euler(ShoulderLeft), num);
				}
			}
		}

		public virtual void BowKnotToHand(bool enabled)
		{
			KnotToHand = enabled;
			IBow bow = RC.Active_IMWeapon as IBow;
			if (!KnotToHand)
			{
				bow?.RestoreKnot();
			}
		}

		protected void BowKnotInHand()
		{
			if (KnotToHand)
			{
				IBow bow = RC.Active_IMWeapon as IBow;
				bow.KNot.position = (RC.Anim.GetBoneTransform(RC.Active_IMWeapon.RightHand ? HumanBodyBones.LeftMiddleDistal : HumanBodyBones.RightMiddleDistal).position + RC.Anim.GetBoneTransform(RC.Active_IMWeapon.RightHand ? HumanBodyBones.LeftThumbDistal : HumanBodyBones.RightThumbDistal).position) / 2f;
				bow.KNot.position = bow.KNot.position;
			}
		}

		public override Transform AimRayOrigin()
		{
			return (RC.Active_IMWeapon as IBow).KNot;
		}
	}
	public abstract class GunCombat : RiderCombatAbility
	{
		private IGun Gun;

		protected bool isReloading;

		protected float currentFireRateTime;

		protected InputButton DefaultInputType;

		public override WeaponType Type => MalbersAnimations.WeaponType.Pistol;

		public override bool TypeOfAbility(IMWeapon weapon)
		{
			return weapon is IGun;
		}

		public override WeaponType WeaponType()
		{
			return MalbersAnimations.WeaponType.Pistol;
		}

		public override void StartAbility(RiderCombat ridercombat)
		{
			base.StartAbility(ridercombat);
			DefaultInputType = RC.InputAttack1.GetPressed;
		}

		public override void ActivateAbility()
		{
			Gun = RC.Active_IMWeapon as IGun;
			isReloading = false;
			if (Gun != null)
			{
				if (!Gun.IsAutomatic)
				{
					RC.InputAttack1.GetPressed = InputButton.Down;
				}
				currentFireRateTime = 0f;
			}
		}

		public override void UpdateAbility()
		{
			if (Gun != null && Gun.IsAiming != RC.IsAiming)
			{
				Gun.IsAiming = RC.IsAiming;
			}
		}

		public override void ReloadWeapon()
		{
			PistolReload();
		}

		public override void PrimaryAttack()
		{
			if (RC.IsAiming && RC.WeaponAction != WeaponActions.Fire_Proyectile)
			{
				PistolAttack();
			}
		}

		protected virtual void PistolAttack()
		{
			if (!isReloading)
			{
				if (Gun.AmmoInChamber > 0)
				{
					_ = RC.WeaponAction;
					_ = 9;
					RC.SetAction(WeaponActions.Fire_Proyectile);
					Gun.FireProyectile(RC.AimRayCastHit);
					RC.OnAttack.Invoke(RC.Active_IMWeapon);
					currentFireRateTime = Time.time;
				}
				else if (Time.time - currentFireRateTime > 0.5f)
				{
					Gun.PlaySound(4);
					currentFireRateTime = Time.time;
				}
			}
		}

		public virtual void PistolReload()
		{
			if (Gun.Reload())
			{
				RC.SetAction(RC.Active_IMWeapon.RightHand ? WeaponActions.ReloadRight : WeaponActions.ReloadLeft);
			}
			else
			{
				RC.SetAction(WeaponActions.Idle);
			}
		}

		public override void ResetAbility()
		{
			base.ResetAbility();
			if (Gun != null)
			{
				isReloading = false;
				if (!Gun.IsAutomatic)
				{
					RC.InputAttack1.GetPressed = DefaultInputType;
				}
				EnableAimIKBehaviour(value: false);
				Gun = null;
			}
		}

		public virtual void FinishReload()
		{
			RC.SetAction((!RC.IsAiming) ? WeaponActions.Idle : (RC.Active_IMWeapon.RightHand ? WeaponActions.AimRight : WeaponActions.AimLeft));
		}

		public void IsReloading(bool value)
		{
			isReloading = value;
		}

		public void ResetDoubleShoot()
		{
			Anim.SetInteger(Hash.IDInt, 0);
		}

		protected void EnableAimIKBehaviour(bool value)
		{
			AimIKBehaviour[] behaviours = Anim.GetBehaviours<AimIKBehaviour>();
			for (int i = 0; i < behaviours.Length; i++)
			{
				behaviours[i].active = value;
			}
		}
	}
	[CreateAssetMenu(menuName = "Malbers Animations/HAP/Gun Combat FK")]
	public class GunCombatFK : GunCombat
	{
		public float AimHorizontalOffset = 20f;

		[Header("Right Offsets")]
		public Vector3 RightShoulderOffset = new Vector3(-90f, 90f, 0f);

		public Vector3 RightHandOffset = new Vector3(-90f, 90f, 0f);

		[Header("Right Offsets")]
		public Vector3 LeftShoulderOffset = new Vector3(90f, 90f, 0f);

		public Vector3 LeftHandOffset = new Vector3(90f, 90f, 0f);

		[Space]
		public Vector3 HeadOffset = new Vector3(0f, -90f, -90f);

		[Range(0f, 1f)]
		public float headLookWeight = 0.7f;

		protected Quaternion Delta_Rotation;

		public override void ActivateAbility()
		{
			base.ActivateAbility();
			EnableAimIKBehaviour(value: false);
		}

		public override void LateUpdateAbility()
		{
			FixAimPoseFK();
		}

		protected virtual void FixAimPoseFK()
		{
			if (!RC.IsAiming || !RC.IsAiming || RC.WeaponAction == WeaponActions.ReloadRight || RC.WeaponAction == WeaponActions.ReloadLeft)
			{
				return;
			}
			Quaternion b = Quaternion.LookRotation(RC.AimDirection, Vector3.up);
			Quaternion quaternion = Quaternion.LookRotation(RC.AimDirection);
			Vector3 normalized = Vector3.Cross(Vector3.up, RC.AimDirection).normalized;
			float angle = Vector3.Angle(Vector3.up, RC.AimDirection) - 90f;
			UnityEngine.Debug.DrawRay(RC.Active_IMWeapon.RightHand ? RC.RightShoulder.position : RC.LeftShoulder.position, normalized, Color.green);
			if (RC.Active_IMWeapon.RightHand)
			{
				RC.RightShoulder.RotateAround(RC.RightShoulder.position, normalized, angle);
				RC.RightShoulder.rotation *= Quaternion.Euler(RightShoulderOffset);
				if (!RC.Target)
				{
					RC.RightShoulder.RotateAround(RC.RightShoulder.position, Vector3.up, RC.IsCamRightSide ? 0f : (0f - AimHorizontalOffset));
				}
			}
			else
			{
				RC.LeftShoulder.RotateAround(RC.LeftShoulder.position, normalized, angle);
				RC.LeftShoulder.rotation *= Quaternion.Euler(LeftShoulderOffset);
				if (!RC.Target)
				{
					RC.LeftShoulder.RotateAround(RC.LeftShoulder.position, Vector3.up, RC.IsCamRightSide ? AimHorizontalOffset : 0f);
				}
			}
			RC.Head.rotation = Quaternion.Slerp(RC.Head.rotation, quaternion * Quaternion.Euler(HeadOffset), headLookWeight);
			if (RC.WeaponAction != WeaponActions.Fire_Proyectile)
			{
				if (RC.Active_IMWeapon.RightHand)
				{
					RC.RightHand.rotation = Delta_Rotation * Quaternion.Euler(RightHandOffset);
				}
				else
				{
					RC.LeftHand.rotation = Delta_Rotation * Quaternion.Euler(LeftHandOffset);
				}
				Delta_Rotation = Quaternion.Lerp(Delta_Rotation, b, Time.deltaTime * 20f);
			}
		}
	}
	[CreateAssetMenu(menuName = "Malbers Animations/HAP/Gun Combat IK")]
	public class GunCombatIK : GunCombat
	{
		private static Keyframe[] KeyFrames = new Keyframe[3]
		{
			new Keyframe(0f, 0.61f),
			new Keyframe(1.25f, 0.61f),
			new Keyframe(2f, 0.4f)
		};

		[Space]
		public Vector3 RightHandOffset;

		public Vector3 LeftHandOffset;

		public AnimationCurve HandIKDistance = new AnimationCurve(KeyFrames);

		public override void ActivateAbility()
		{
			base.ActivateAbility();
			EnableAimIKBehaviour(value: true);
		}
	}
	[CreateAssetMenu(menuName = "Malbers Animations/HAP/MeleeCombat")]
	public class MeleeCombat : RiderCombatAbility
	{
		[Tooltip("Time before attacking again with melee")]
		public float meleeAttackDelay = 0.5f;

		private bool isAttacking;

		private float timeOnAttack;

		public override WeaponType Type => MalbersAnimations.WeaponType.Melee;

		public override bool TypeOfAbility(IMWeapon weapon)
		{
			return weapon is IMelee;
		}

		public override WeaponType WeaponType()
		{
			return MalbersAnimations.WeaponType.Melee;
		}

		public override void ActivateAbility()
		{
			timeOnAttack = 0f;
			isAttacking = false;
		}

		private void CheckAttacking()
		{
			if (isAttacking && Time.time - timeOnAttack > meleeAttackDelay)
			{
				isAttacking = false;
			}
		}

		public override void PrimaryAttack()
		{
			CheckAttacking();
			if (!isAttacking)
			{
				RiderMeleeAttack(rightSide: false);
			}
		}

		public override void SecondaryAttack()
		{
			CheckAttacking();
			if (!isAttacking)
			{
				RiderMeleeAttack(rightSide: true);
			}
		}

		protected virtual void RiderMeleeAttack(bool rightSide)
		{
			RC.Anim.SetInteger(Hash.IDInt, -99);
			if (rightSide)
			{
				RC.Anim.SetBool(Hash.Attack2, value: true);
			}
			else
			{
				RC.Anim.SetBool(Hash.Attack1, value: true);
			}
			int value = (RC.Active_IMWeapon.RightHand ? ((!rightSide) ? UnityEngine.Random.Range(3, 5) : UnityEngine.Random.Range(1, 3)) : ((!rightSide) ? UnityEngine.Random.Range(5, 7) : UnityEngine.Random.Range(7, 9)));
			RC.Anim.SetInteger(RiderCombat.Hash_WeaponAction, value);
			isAttacking = true;
			timeOnAttack = Time.time;
			RC.OnAttack.Invoke(RC.Active_IMWeapon);
		}

		public virtual void OnCauseDamage(bool value)
		{
			(RC.Active_IMWeapon as IMelee).CanDoDamage(value);
		}

		public override bool CanAim()
		{
			return false;
		}
	}
	public abstract class RiderCombatAbility : ScriptableObject
	{
		protected RiderCombat RC;

		protected Transform cam;

		protected Animator Anim;

		protected IMWeapon weapon;

		public abstract WeaponType Type { get; }

		public abstract bool TypeOfAbility(IMWeapon weapon);

		public abstract WeaponType WeaponType();

		public virtual void StartAbility(RiderCombat ridercombat)
		{
			RC = ridercombat;
			Camera mainCamera = RC.rider.MainCamera;
			if ((bool)mainCamera)
			{
				cam = mainCamera.transform;
			}
			Anim = RC.Anim;
		}

		public virtual void ActivateAbility()
		{
		}

		public virtual void FixedUpdateAbility()
		{
		}

		public virtual void PrimaryAttack()
		{
		}

		public virtual void PrimaryAttackReleased()
		{
		}

		public virtual void SecondaryAttack()
		{
		}

		public virtual void SecondaryAttackReleased()
		{
		}

		public virtual void ReloadWeapon()
		{
		}

		public virtual void UpdateAbility()
		{
		}

		public virtual void LateUpdateAbility()
		{
		}

		public virtual void ResetAbility()
		{
			if (RC.Active_IMWeapon != null && RC.debug)
			{
				UnityEngine.Debug.Log("Ability Reseted");
			}
		}

		public virtual void ListenAnimator(string Method, object value)
		{
			this.Invoke(Method, value);
		}

		public virtual bool ChangeAimCameraSide()
		{
			return true;
		}

		public virtual void IK()
		{
		}

		public virtual bool CanAim()
		{
			return true;
		}

		public virtual Transform AimRayOrigin()
		{
			if (!RC.Active_IMWeapon.RightHand)
			{
				return RC.LeftShoulder;
			}
			return RC.RightShoulder;
		}

		public virtual void OnActionChange()
		{
		}
	}
	[Serializable]
	public class MountEvent : UnityEvent<Mountable>
	{
	}
	[Serializable]
	public class RiderEvent : UnityEvent<Rider>
	{
	}
	public abstract class Rider : MonoBehaviour, IAnimatorListener
	{
		public enum UpdateType
		{
			Update = 1,
			FixedUpdate = 2,
			LateUpdate = 4
		}

		protected bool mounted;

		protected bool isOnHorse;

		protected bool isInMountTrigger;

		protected Mountable montura;

		protected bool toogleCall;

		protected MalbersInput animalControls;

		protected MountTriggers mountTrigger;

		protected MonoBehaviour[] allComponents;

		public Animator Anim;

		protected Transform _transform;

		protected Rigidbody _rigidbody;

		protected Collider[] _collider;

		protected CapsuleCollider mountedCollider;

		public bool StartMounted;

		[Tooltip("Parent the Rider to the Mount Point")]
		public bool Parent;

		[Flag]
		public UpdateType LinkUpdate = (UpdateType)3;

		public Mountable AnimalStored;

		public InputRow MountInput = new InputRow("Mount", KeyCode.F, InputButton.Down);

		public InputRow DismountInput = new InputRow("Mount", KeyCode.F, InputButton.LongPress);

		public InputRow CallAnimalInput = new InputRow("Call", KeyCode.F, InputButton.Down);

		internal IInputSystem inputSystem;

		public bool CreateColliderMounted;

		public float Col_radius = 0.25f;

		public bool Col_Trigger = true;

		public float Col_height = 0.8f;

		public float Col_Center = 0.48f;

		public bool DisableComponents;

		public MonoBehaviour[] DisableList;

		public AudioClip CallAnimalA;

		public AudioClip StopAnimalA;

		public AudioSource RiderAudio;

		public string PlayerID = "Player0";

		public GameObjectEvent OnFindMount = new GameObjectEvent();

		public BoolEvent OnCanMount = new BoolEvent();

		public BoolEvent OnCanDismount = new BoolEvent();

		public BoolEvent OnCallMount = new BoolEvent();

		protected Camera cam;

		[HideInInspector]
		public bool Editor_RiderCallAnimal;

		[HideInInspector]
		public bool Editor_Events;

		[HideInInspector]
		public bool Editor_Inputs;

		private RigidbodyConstraints DefaultConstraints;

		protected MonoBehaviour[] AllComponents
		{
			get
			{
				if (allComponents == null)
				{
					allComponents = GetComponents<MonoBehaviour>();
				}
				return allComponents;
			}
		}

		public virtual Mountable Montura
		{
			get
			{
				return montura;
			}
			set
			{
				montura = value;
			}
		}

		public MountTriggers MountTrigger
		{
			get
			{
				return mountTrigger;
			}
			set
			{
				mountTrigger = value;
			}
		}

		public bool CanMount
		{
			get
			{
				if ((bool)MountTrigger && !Mounted)
				{
					return !IsOnHorse;
				}
				return false;
			}
		}

		public virtual bool CanDismount => IsRiding;

		public virtual bool CanCallAnimal
		{
			get
			{
				if (!MountTrigger && !Mounted)
				{
					return !IsOnHorse;
				}
				return false;
			}
		}

		public bool Mounted
		{
			get
			{
				return mounted;
			}
			set
			{
				mounted = value;
			}
		}

		public bool IsRiding
		{
			get
			{
				if (IsOnHorse)
				{
					return mounted;
				}
				return false;
			}
		}

		public bool IsOnHorse
		{
			get
			{
				return isOnHorse;
			}
			protected set
			{
				isOnHorse = value;
			}
		}

		public virtual MalbersInput AnimalControl
		{
			get
			{
				if (animalControls == null && (bool)Montura.Animal)
				{
					animalControls = Montura.Animal.GetComponent<MalbersInput>();
				}
				return animalControls;
			}
			set
			{
				animalControls = value;
			}
		}

		public Camera MainCamera
		{
			get
			{
				if (Camera.main != null)
				{
					cam = Camera.main;
				}
				else
				{
					cam = null;
				}
				return cam;
			}
		}

		public virtual void Start_Mounting()
		{
			Montura.ActiveRider = this;
			Mountable mountable = Montura;
			bool flag2 = (Mounted = true);
			mountable.Mounted = flag2;
			if ((bool)_rigidbody)
			{
				_rigidbody.useGravity = false;
				_rigidbody.isKinematic = true;
				DefaultConstraints = _rigidbody.constraints;
				_rigidbody.constraints = RigidbodyConstraints.FreezeAll;
			}
			ToogleColliders(active: false);
			toogleCall = true;
			CallAnimal(playWistle: false);
			if ((bool)Montura.Animal)
			{
				AnimalStored = Montura.Animal.GetComponent<Mountable>();
			}
			if (Parent)
			{
				base.transform.parent = Montura.MountPoint;
			}
		}

		public virtual void End_Mounting()
		{
			IsOnHorse = true;
			Mountable mountable = Montura;
			bool flag2 = (Mounted = true);
			mountable.Mounted = flag2;
			base.transform.localPosition = Vector3.zero;
			base.transform.localRotation = Quaternion.identity;
			Montura.EnableControls(value: true);
			if (CreateColliderMounted)
			{
				MountingCollider(create: true);
			}
		}

		public virtual void Start_Dismounting()
		{
			MountingCollider(create: false);
			if (CreateColliderMounted)
			{
				MountingCollider(create: false);
			}
			base.transform.parent = null;
			Montura.ActiveRider = null;
			Montura.ActiveRiderCombat = null;
			Montura.Mounted = (mounted = false);
			if (!Anim)
			{
				End_Dismounting();
			}
		}

		public virtual void End_Dismounting()
		{
			IsOnHorse = false;
			if ((bool)Montura)
			{
				Montura.EnableControls(value: false);
			}
			Montura = null;
			toogleCall = false;
			if ((bool)_rigidbody)
			{
				_rigidbody.useGravity = true;
				_rigidbody.isKinematic = false;
				_rigidbody.constraints = DefaultConstraints;
			}
			if ((bool)Anim)
			{
				Anim.speed = 1f;
			}
			_transform.rotation = Quaternion.FromToRotation(_transform.up, -Physics.gravity) * _transform.rotation;
			ToogleColliders(active: true);
		}

		public virtual void LinkRider()
		{
			if (IsRiding)
			{
				base.transform.position = Montura.MountPoint.position;
				base.transform.rotation = Montura.MountPoint.rotation;
			}
		}

		public virtual void MountingCollider(bool create)
		{
			if (create)
			{
				mountedCollider = base.gameObject.AddComponent<CapsuleCollider>();
				mountedCollider.center = new Vector3(0f, Col_Center);
				mountedCollider.radius = Col_radius;
				mountedCollider.height = Col_height;
				mountedCollider.isTrigger = Col_Trigger;
			}
			else
			{
				UnityEngine.Object.Destroy(mountedCollider);
			}
		}

		public virtual void SetAnimalStored(Mountable MAnimal)
		{
			AnimalStored = MAnimal;
		}

		public virtual void KillMountura()
		{
			if ((bool)Montura)
			{
				Montura.Animal.Death = true;
			}
		}

		public virtual void CallAnimal(bool playWistle = true)
		{
			if (!CanCallAnimal || !AnimalStored)
			{
				return;
			}
			IMountAI component = AnimalStored.GetComponent<IMountAI>();
			if (component != null)
			{
				toogleCall = !toogleCall;
				component.CallAnimal(_transform, toogleCall);
				if ((bool)CallAnimalA && (bool)StopAnimalA && playWistle)
				{
					RiderAudio.PlayOneShot(toogleCall ? CallAnimalA : StopAnimalA);
				}
			}
		}

		protected virtual void ToogleColliders(bool active)
		{
			if (_collider.Length != 0)
			{
				Collider[] collider = _collider;
				for (int i = 0; i < collider.Length; i++)
				{
					collider[i].enabled = active;
				}
			}
		}

		protected virtual void ToggleComponents(bool enabled)
		{
			MonoBehaviour[] array;
			if (DisableList.Length == 0)
			{
				array = AllComponents;
				foreach (MonoBehaviour monoBehaviour in array)
				{
					if (!(monoBehaviour is Rider) && !(monoBehaviour is RiderCombat))
					{
						monoBehaviour.enabled = enabled;
					}
				}
				return;
			}
			array = DisableList;
			foreach (MonoBehaviour monoBehaviour2 in array)
			{
				if (monoBehaviour2 != null)
				{
					monoBehaviour2.enabled = enabled;
				}
			}
		}

		public virtual void OnAnimatorBehaviourMessage(string message, object value)
		{
			this.InvokeWithParams(message, value);
		}
	}
	public class Rider3rdPerson : Rider
	{
		protected float L_IKFootWeight;

		protected float R_IKFootWeight;

		public UnityEvent OnStartMounting = new UnityEvent();

		public UnityEvent OnEndMounting = new UnityEvent();

		public UnityEvent OnStartDismounting = new UnityEvent();

		public UnityEvent OnEndDismounting = new UnityEvent();

		public UnityEvent OnAlreadyMounted = new UnityEvent();

		public int MountLayerIndex = -1;

		protected AnimatorUpdateMode Initial_UpdateMode;

		private float RiderNormalizedTime;

		private float HorseNormalizedTime;

		private float LastSyncTime;

		private bool syncronize;

		[SerializeField]
		public bool Editor_Advanced;

		public bool debug;

		public override Mountable Montura
		{
			get
			{
				return montura;
			}
			set
			{
				montura = value;
				MountLayerIndex = ((value != null) ? Anim.GetLayerIndex(Montura.MountLayer) : (-1));
			}
		}

		private void Reset()
		{
			DismountInput.GetPressed = InputButton.LongPress;
		}

		private void Awake()
		{
			_transform = base.transform;
			if (!Anim)
			{
				Anim = GetComponentInChildren<Animator>();
			}
			_rigidbody = GetComponent<Rigidbody>();
			_collider = GetComponents<Collider>();
			MountLayerIndex = -1;
		}

		private void Start()
		{
			base.inputSystem = DefaultInput.GetInputSystem(PlayerID);
			InputRow mountInput = MountInput;
			InputRow dismountInput = DismountInput;
			IInputSystem inputSystem2 = (CallAnimalInput.InputSystem = base.inputSystem);
			IInputSystem inputSystem4 = (dismountInput.InputSystem = inputSystem2);
			mountInput.InputSystem = inputSystem4;
			bool flag2 = (base.Mounted = false);
			base.IsOnHorse = flag2;
			if ((bool)Anim)
			{
				Initial_UpdateMode = Anim.updateMode;
			}
			if (StartMounted)
			{
				AlreadyMounted();
			}
		}

		public void AlreadyMounted()
		{
			StartCoroutine(AlreadyMountedC());
		}

		private IEnumerator AlreadyMountedC()
		{
			yield return null;
			if (AnimalStored != null && StartMounted)
			{
				Montura = AnimalStored;
				Montura.ActiveRider = this;
				if (base.MountTrigger == null)
				{
					Montura.transform.GetComponentInChildren<MountTriggers>();
				}
				Start_Mounting();
				End_Mounting();
				if ((bool)Anim)
				{
					Anim.Play(Montura.MountIdle, MountLayerIndex);
				}
				toogleCall = true;
				Mountable mountable = Montura;
				Rider3rdPerson rider3rdPerson = this;
				bool flag = true;
				rider3rdPerson.Mounted = true;
				mountable.Mounted = flag;
				Anim.SetBool(Hash.Mount, mounted);
			}
			Montura.Animal.OnSyncAnimator.AddListener(SyncAnimator);
			OnAlreadyMounted.Invoke();
		}

		public override void Start_Mounting()
		{
			if ((bool)Anim)
			{
				Anim.SetLayerWeight(MountLayerIndex, 1f);
				Anim.SetBool(Hash.Mount, base.Mounted);
				Vector3 position = base.transform.position;
				position.y = Anim.GetBoneTransform(HumanBodyBones.Hips).position.y;
				base.transform.position = position;
			}
			if (!base.MountTrigger)
			{
				base.MountTrigger = Montura.GetComponentInChildren<MountTriggers>();
			}
			if (DisableComponents)
			{
				ToggleComponents(enabled: false);
			}
			base.Start_Mounting();
			OnStartMounting.Invoke();
			if (!Anim)
			{
				End_Dismounting();
			}
		}

		public override void End_Mounting()
		{
			base.End_Mounting();
			if ((bool)Anim)
			{
				Anim.updateMode = AnimatorUpdateMode.Normal;
			}
			OnEndMounting.Invoke();
		}

		public override void Start_Dismounting()
		{
			base.Start_Dismounting();
			if ((bool)Anim)
			{
				Anim.updateMode = Initial_UpdateMode;
			}
			OnStartDismounting.Invoke();
		}

		public override void End_Dismounting()
		{
			if ((bool)Anim && MountLayerIndex != -1)
			{
				Anim.SetLayerWeight(MountLayerIndex, 0f);
			}
			base.End_Dismounting();
			if (DisableComponents)
			{
				ToggleComponents(enabled: true);
			}
			OnEndDismounting.Invoke();
		}

		protected virtual void Animators_ReSync()
		{
			if (!Anim || !Montura.syncAnimators)
			{
				return;
			}
			if (Montura.Animal.AnimState == AnimTag.Locomotion)
			{
				RiderNormalizedTime = Anim.GetCurrentAnimatorStateInfo(MountLayerIndex).normalizedTime;
				HorseNormalizedTime = Montura.Animal.Anim.GetCurrentAnimatorStateInfo(0).normalizedTime;
				syncronize = true;
				if (Mathf.Abs(RiderNormalizedTime - HorseNormalizedTime) > 0.1f && Time.time - LastSyncTime > 1f)
				{
					Anim.CrossFade(AnimTag.Locomotion, 0.2f, MountLayerIndex, HorseNormalizedTime);
					LastSyncTime = Time.time;
				}
			}
			else
			{
				syncronize = false;
				RiderNormalizedTime = (HorseNormalizedTime = 0f);
			}
		}

		private void Update()
		{
			SetMounting();
			if (base.IsRiding && (bool)Montura)
			{
				WhileIsMounted();
			}
			if ((LinkUpdate & UpdateType.Update) == UpdateType.Update)
			{
				LinkRider();
			}
		}

		private void LateUpdate()
		{
			if ((LinkUpdate & UpdateType.LateUpdate) == UpdateType.LateUpdate)
			{
				LinkRider();
			}
		}

		private void FixedUpdate()
		{
			if ((LinkUpdate & UpdateType.FixedUpdate) == UpdateType.FixedUpdate)
			{
				LinkRider();
			}
		}

		public virtual void SetMounting()
		{
			if (base.CanMount)
			{
				if (MountInput.GetInput)
				{
					MountAnimal();
				}
			}
			else if (CanDismount)
			{
				if (DismountInput.GetInput)
				{
					DismountAnimal();
				}
			}
			else if (CanCallAnimal && CallAnimalInput.GetInput)
			{
				CallAnimal();
			}
		}

		public virtual void CheckMountDismount()
		{
			if (base.CanMount)
			{
				MountAnimal();
			}
			else if (CanDismount)
			{
				DismountAnimal();
			}
			else if (CanCallAnimal)
			{
				CallAnimal();
			}
		}

		protected virtual void WhileIsMounted()
		{
			Animators_ReSync();
		}

		protected virtual void SyncAnimator()
		{
			Animal animal = Montura.Animal;
			float num = animal.Speed;
			if (animal.Fly)
			{
				num = Mathf.Clamp(num * 2f, 0f, 2f);
			}
			Anim.SetFloat(animal.hash_Vertical, num);
			Anim.SetFloat(animal.hash_Horizontal, Montura.Animal.Direction);
			Anim.SetFloat(animal.hash_Slope, Montura.Animal.Slope);
			Anim.SetBool(animal.hash_Stand, Montura.Animal.Stand);
			Anim.SetBool(animal.hash_Jump, !Montura.Animal.Fly && Montura.Animal.Jump);
			Anim.SetBool(animal.hash_Attack1, Montura.Animal.Attack1);
			Anim.SetBool(animal.hash_Shift, !Montura.Animal.Attack2 && Montura.Animal.Shift);
			Anim.SetBool(animal.hash_Damaged, Montura.Animal.Damaged);
			Anim.SetBool(animal.hash_Stunned, Montura.Animal.Stun);
			Anim.SetBool(animal.hash_Action, Montura.Animal.Action);
			Anim.SetInteger(animal.hash_IDAction, Montura.Animal.ActionID);
			Anim.SetInteger(animal.hash_IDInt, Montura.Animal.IDInt);
			Anim.SetFloat(animal.hash_IDFloat, Montura.Animal.IDFloat);
			if (Montura.Animal.canSwim)
			{
				Anim.SetBool(animal.hash_Swim, Montura.Animal.Swim);
			}
		}

		public virtual void MountAnimal()
		{
			if (!base.CanMount || Montura == null)
			{
				return;
			}
			Montura.Animal.OnSyncAnimator.AddListener(SyncAnimator);
			if ((bool)Anim)
			{
				Anim.SetLayerWeight(MountLayerIndex, 1f);
				Anim.SetBool(Hash.Mount, base.Mounted);
			}
			if (!Montura.InstantMount)
			{
				if ((bool)Anim)
				{
					Anim.Play(base.MountTrigger.MountAnimation, MountLayerIndex);
				}
				return;
			}
			Start_Mounting();
			End_Mounting();
			if ((bool)Anim)
			{
				Anim.Play(Montura.MountIdle, MountLayerIndex);
			}
		}

		public virtual void DismountAnimal()
		{
			if (CanDismount)
			{
				Mountable mountable = Montura;
				bool flag2 = (base.Mounted = false);
				mountable.Mounted = flag2;
				Montura.Animal.OnSyncAnimator.RemoveListener(SyncAnimator);
				if ((bool)Anim)
				{
					Anim.SetBool(Hash.Mount, base.Mounted);
					Anim.SetInteger(Hash.MountSide, base.MountTrigger.DismountID);
				}
				if (Montura.InstantMount)
				{
					Anim.Play(Hash.Null, MountLayerIndex);
					Anim.SetInteger(Hash.MountSide, 0);
					Start_Dismounting();
					End_Dismounting();
					_transform.position = base.MountTrigger.transform.position + base.MountTrigger.transform.forward * -0.2f;
				}
			}
		}

		private void OnAnimatorIK()
		{
			if (Anim == null || !(Montura != null) || Montura.FootLeftIK == null || Montura.FootRightIK == null || Montura.KneeLeftIK == null || Montura.KneeRightIK == null)
			{
				return;
			}
			if (base.Mounted || base.IsOnHorse)
			{
				L_IKFootWeight = 1f;
				R_IKFootWeight = 1f;
				int tagHash = Anim.GetCurrentAnimatorStateInfo(MountLayerIndex).tagHash;
				if (tagHash == Hash.Tag_Mounting || tagHash == Hash.Tag_Unmounting)
				{
					L_IKFootWeight = Anim.GetFloat(Hash.IKLeftFoot);
					R_IKFootWeight = Anim.GetFloat(Hash.IKRightFoot);
				}
				Anim.SetIKPositionWeight(AvatarIKGoal.LeftFoot, L_IKFootWeight);
				Anim.SetIKPositionWeight(AvatarIKGoal.RightFoot, R_IKFootWeight);
				Anim.SetIKHintPositionWeight(AvatarIKHint.LeftKnee, L_IKFootWeight);
				Anim.SetIKHintPositionWeight(AvatarIKHint.RightKnee, R_IKFootWeight);
				Anim.SetIKRotationWeight(AvatarIKGoal.LeftFoot, L_IKFootWeight);
				Anim.SetIKRotationWeight(AvatarIKGoal.RightFoot, R_IKFootWeight);
				Anim.SetIKPosition(AvatarIKGoal.LeftFoot, Montura.FootLeftIK.position);
				Anim.SetIKPosition(AvatarIKGoal.RightFoot, Montura.FootRightIK.position);
				Anim.SetIKHintPosition(AvatarIKHint.LeftKnee, Montura.KneeLeftIK.position);
				Anim.SetIKHintPosition(AvatarIKHint.RightKnee, Montura.KneeRightIK.position);
				Anim.SetIKHintPositionWeight(AvatarIKHint.LeftKnee, L_IKFootWeight);
				Anim.SetIKHintPositionWeight(AvatarIKHint.RightKnee, R_IKFootWeight);
				Anim.SetIKRotation(AvatarIKGoal.LeftFoot, Montura.FootLeftIK.rotation);
				Anim.SetIKRotation(AvatarIKGoal.RightFoot, Montura.FootRightIK.rotation);
			}
			else
			{
				Anim.SetIKPositionWeight(AvatarIKGoal.LeftFoot, 0f);
				Anim.SetIKPositionWeight(AvatarIKGoal.RightFoot, 0f);
				Anim.SetIKRotationWeight(AvatarIKGoal.LeftFoot, 0f);
				Anim.SetIKRotationWeight(AvatarIKGoal.RightFoot, 0f);
			}
		}

		private void OnDrawGizmos()
		{
			if (debug && (bool)Anim && syncronize)
			{
				Transform boneTransform = Anim.GetBoneTransform(HumanBodyBones.Head);
				if ((int)RiderNormalizedTime % 2 == 0)
				{
					Gizmos.color = Color.red;
				}
				else
				{
					Gizmos.color = Color.white;
				}
				Gizmos.DrawSphere(boneTransform.position - base.transform.root.right * 0.2f, 0.05f);
				if ((int)HorseNormalizedTime % 2 == 0)
				{
					Gizmos.color = Color.red;
				}
				else
				{
					Gizmos.color = Color.white;
				}
				Gizmos.DrawSphere(boneTransform.position + base.transform.root.right * 0.2f, 0.05f);
			}
		}
	}
	[RequireComponent(typeof(Rider3rdPerson))]
	public class RiderCombat : MonoBehaviour, IAnimatorListener
	{
		public LayerMask HitMask;

		public InputRow InputWeapon = new InputRow(KeyCode.E);

		public InputRow InputAttack1 = new InputRow("Fire1", KeyCode.Mouse0, InputButton.Press);

		public InputRow InputAttack2 = new InputRow("Fire2", KeyCode.Mouse1, InputButton.Press);

		public InputRow InputAim = new InputRow("Fire2", KeyCode.Mouse1, InputButton.Press);

		public bool UseInventory = true;

		public bool AlreadyInstantiated = true;

		public bool UseHolders;

		public bool StrafeOnTarget;

		public WeaponHolder ActiveHolderSide = WeaponHolder.Back;

		public Transform LeftHandEquipPoint;

		public Transform RightHandEquipPoint;

		public Transform HolderLeft;

		public Transform HolderRight;

		public Transform HolderBack;

		public Transform ActiveHolderTransform;

		public InputRow HBack = new InputRow(KeyCode.Alpha4);

		public InputRow HLeft = new InputRow(KeyCode.Alpha5);

		public InputRow HRight = new InputRow(KeyCode.Alpha6);

		public InputRow Reload = new InputRow("Reload", "Reload", KeyCode.R, InputButton.Down, InputType.Key);

		public List<RiderCombatAbility> CombatAbilities;

		public bool debug;

		public RiderCombatAbility ActiveAbility;

		protected Rider3rdPerson _rider;

		protected Animator _anim;

		protected GameObject activeWeapon;

		protected WeaponType _weaponType;

		protected WeaponActions _weaponAction;

		protected bool lockCombat;

		protected bool isInCombatMode;

		protected bool aimSent;

		protected bool TargetSide;

		protected bool CameraSide;

		protected bool CurrentCameraSide;

		protected int Layer_RiderArmRight;

		protected int Layer_RiderArmLeft;

		protected int Layer_RiderCombat;

		protected Transform _cam;

		public RectTransform AimDot;

		public Transform Target;

		internal Transform lastTarget;

		private float horizontalAngle;

		protected Vector3 aimDirection;

		protected RaycastHit aimRayHit;

		protected Quaternion MountStartRotation;

		public static readonly int Hash_AimSide = Animator.StringToHash("WeaponAim");

		public static readonly int Hash_WeaponType = Animator.StringToHash("WeaponType");

		public static readonly int Hash_WeaponHolder = Animator.StringToHash("WeaponHolder");

		public static readonly int Hash_WeaponAction = Animator.StringToHash("WeaponAction");

		public GameObjectEvent OnEquipWeapon = new GameObjectEvent();

		public GameObjectEvent OnUnequipWeapon = new GameObjectEvent();

		public WeaponActionEvent OnWeaponAction = new WeaponActionEvent();

		public WeaponEvent OnAttack = new WeaponEvent();

		public IntEvent OnAimSide = new IntEvent();

		public TransformEvent OnTarget = new TransformEvent();

		protected Transform _RightShoulder;

		protected Transform _LeftShoulder;

		protected Transform _RightHand;

		protected Transform _LeftHand;

		protected Transform _Head;

		protected Transform _Chest;

		protected Transform _transform;

		protected Transform mountPoint;

		private bool DefaultMonturaInputCamBaseInput;

		private bool isAiming;

		[HideInInspector]
		public bool Editor_ShowHolders;

		[HideInInspector]
		public bool Editor_ShowInputs;

		[HideInInspector]
		public bool Editor_ShowHoldersInput;

		[HideInInspector]
		public bool Editor_ShowAdvanced;

		[HideInInspector]
		public bool Editor_ShowEvents;

		[HideInInspector]
		public bool Editor_ShowEquipPoints;

		[HideInInspector]
		public bool Editor_ShowAbilities = true;

		public bool LockCombat
		{
			get
			{
				return lockCombat;
			}
			set
			{
				lockCombat = value;
			}
		}

		public Rider3rdPerson rider
		{
			get
			{
				if (_rider == null)
				{
					_rider = GetComponent<Rider3rdPerson>();
				}
				return _rider;
			}
		}

		public bool CombatMode
		{
			get
			{
				return isInCombatMode;
			}
			set
			{
				isInCombatMode = value;
			}
		}

		public bool IsInCombatMode
		{
			get
			{
				return isInCombatMode;
			}
			set
			{
				isInCombatMode = value;
			}
		}

		public WeaponActions WeaponAction
		{
			get
			{
				return _weaponAction;
			}
			set
			{
				_weaponAction = value;
			}
		}

		public IMWeapon Active_IMWeapon
		{
			get
			{
				if ((bool)ActiveWeapon)
				{
					return ActiveWeapon.GetComponent<IMWeapon>();
				}
				return null;
			}
		}

		public Transform MountPoint
		{
			get
			{
				if (mountPoint == null)
				{
					mountPoint = rider.Montura.MountPoint;
				}
				return mountPoint;
			}
		}

		public Animator Anim => _anim;

		public bool IsAiming
		{
			get
			{
				return isAiming;
			}
			set
			{
				isAiming = value;
				if (!isAiming)
				{
					SetAction(CombatMode ? WeaponActions.Idle : WeaponActions.None);
				}
			}
		}

		public bool IsCamRightSide => CameraSide;

		public float HorizontalAngle => horizontalAngle;

		public Transform RightShoulder => _RightShoulder;

		public Transform LeftShoulder => _LeftShoulder;

		public Transform RightHand => _RightHand;

		public Transform LeftHand => _LeftHand;

		public Transform Head => _Head;

		public Transform Chest => _Chest;

		public Vector3 AimDirection => aimDirection;

		public RaycastHit AimRayCastHit => aimRayHit;

		public GameObject ActiveWeapon => activeWeapon;

		public virtual void OnAnimatorBehaviourMessage(string message, object value)
		{
			this.InvokeWithParams(message, value);
			if ((bool)ActiveAbility)
			{
				ActiveAbility.ListenAnimator(message, value);
			}
		}

		public virtual void AddAbility(RiderCombatAbility newAbility)
		{
			newAbility.StartAbility(this);
			CombatAbilities.Add(newAbility);
		}

		public virtual void RightHand_is_Free(bool value)
		{
			if (rider.Montura != null)
			{
				IKReins component = rider.Montura.transform.GetComponent<IKReins>();
				if ((bool)component)
				{
					component.RightHand_is_Free(value);
				}
			}
		}

		public virtual void LeftHand_is_Free(bool value)
		{
			if (rider.Montura != null)
			{
				IKReins component = rider.Montura.transform.GetComponent<IKReins>();
				if ((bool)component)
				{
					component.LeftHand_is_Free(value);
				}
			}
		}

		public virtual void SetActiveWeapon(GameObject weapon)
		{
			activeWeapon = weapon;
		}

		public virtual void ResetAiming()
		{
			if (IsAiming)
			{
				IsAiming = false;
				OnAimSide.Invoke(0);
				SetAction(CombatMode ? WeaponActions.Idle : WeaponActions.None);
			}
		}

		public virtual void ResetRiderCombat(bool storeWeapon)
		{
			ResetRiderCombat();
			SetAction(WeaponActions.None);
			if (storeWeapon)
			{
				Store_Weapon();
			}
			LinkAnimator();
		}

		public virtual void ResetRiderCombat()
		{
			CombatMode = false;
			SetWeaponType(WeaponType.None);
			ResetActiveAbility();
			ResetAiming();
		}

		public virtual void Draw_Weapon(WeaponHolder holder, WeaponType weaponType, bool isRightHand = true)
		{
			ResetRiderCombat();
			SetAction(isRightHand ? WeaponActions.DrawFromRight : WeaponActions.DrawFromLeft);
			SetWeaponIdleAnimState(weaponType, isRightHand);
			_weaponType = weaponType;
			LinkAnimator();
			if (debug)
			{
				UnityEngine.Debug.Log("Draw with No Active Weapon");
			}
		}

		public virtual void Store_Weapon(WeaponHolder holder, bool isRightHand = true)
		{
			_weaponType = WeaponType.None;
			ActiveHolderSide = holder;
			SetAction(isRightHand ? WeaponActions.StoreToRight : WeaponActions.StoreToLeft);
			LinkAnimator();
			ResetRiderCombat();
			if (debug)
			{
				UnityEngine.Debug.Log("Store with No Active Weapon");
			}
		}

		public virtual void SetWeaponIdleAnimState(bool IsRightHand)
		{
			string text = " Idle " + (IsRightHand ? "Right" : "Left") + " Hand";
			text = _weaponType switch
			{
				WeaponType.Melee => "Melee" + text, 
				WeaponType.Bow => "Bow" + text, 
				WeaponType.Pistol => "Pistol" + text, 
				WeaponType.Rifle => "Rifle" + text, 
				_ => "Melee" + text, 
			};
			_anim.CrossFade(text, 0.25f, Active_IMWeapon.RightHand ? Layer_RiderArmRight : Layer_RiderArmLeft);
		}

		public virtual void SetWeaponIdleAnimState(WeaponType weapon, bool isRightHand)
		{
			SetWeaponType(weapon);
			SetWeaponIdleAnimState(isRightHand);
		}

		public virtual WeaponType GetWeaponType()
		{
			if (Active_IMWeapon != null)
			{
				if (Active_IMWeapon is IMelee)
				{
					return WeaponType.Melee;
				}
				if (Active_IMWeapon is IBow)
				{
					return WeaponType.Bow;
				}
				if (Active_IMWeapon is IGun)
				{
					return WeaponType.Pistol;
				}
			}
			return WeaponType.None;
		}

		public virtual void SetWeaponType(WeaponType weapon)
		{
			_weaponType = weapon;
			_anim.SetInteger(Hash_WeaponType, (int)_weaponType);
		}

		public virtual void WeaponSound(int SoundID)
		{
			if (Active_IMWeapon != null)
			{
				Active_IMWeapon.PlaySound(SoundID);
			}
		}

		public virtual void Action(int value)
		{
			SetAction((WeaponActions)value);
		}

		public virtual void SetAction(WeaponActions action)
		{
			_weaponAction = action;
			_anim.SetInteger(Hash_WeaponAction, (int)action);
			OnWeaponAction.Invoke(_weaponAction);
		}

		public void Attack1(bool v)
		{
			_anim.SetBool(Hash.Attack1, v);
		}

		public void Attack2(bool v)
		{
			_anim.SetBool(Hash.Attack2, v);
		}

		public virtual void EnableMountInput(string input)
		{
			MalbersInput component = rider.Montura.GetComponent<MalbersInput>();
			if ((bool)component)
			{
				component.EnableInput(input);
			}
		}

		public virtual void DisableMountInput(string input)
		{
			MalbersInput component = rider.Montura.GetComponent<MalbersInput>();
			if ((bool)component)
			{
				component.DisableInput(input);
			}
		}

		private void Reset()
		{
		}

		private void Start()
		{
			InitRiderCombat();
		}

		private void Update()
		{
			if (!LockCombat)
			{
				CombatLogicUpdate();
			}
		}

		private void FixedUpdate()
		{
			if (!LockCombat && (bool)ActiveAbility)
			{
				ActiveAbility.FixedUpdateAbility();
			}
		}

		private void LateUpdate()
		{
			if (!LockCombat)
			{
				if ((bool)ActiveAbility)
				{
					ActiveAbility.LateUpdateAbility();
				}
				if (CombatMode)
				{
					Anim.SetInteger(Hash.IDInt, -1);
				}
			}
		}

		protected virtual void InitRiderCombat()
		{
			_transform = base.transform;
			_anim = GetComponent<Animator>();
			_Head = _anim.GetBoneTransform(HumanBodyBones.Head);
			_Chest = _anim.GetBoneTransform(HumanBodyBones.Chest);
			_RightHand = _anim.GetBoneTransform(HumanBodyBones.RightHand);
			_LeftHand = _anim.GetBoneTransform(HumanBodyBones.LeftHand);
			_RightShoulder = _anim.GetBoneTransform(HumanBodyBones.RightUpperArm);
			_LeftShoulder = _anim.GetBoneTransform(HumanBodyBones.LeftUpperArm);
			SetActiveHolder(ActiveHolderSide);
			Layer_RiderArmLeft = _anim.GetLayerIndex("Rider Arm Left");
			Layer_RiderArmRight = _anim.GetLayerIndex("Rider Arm Right");
			Layer_RiderCombat = _anim.GetLayerIndex("Rider Combat");
			if ((bool)rider.MainCamera)
			{
				_cam = rider.MainCamera.transform;
			}
			aimSent = true;
			if ((bool)AimDot)
			{
				AimDot.gameObject.SetActive(value: false);
			}
			foreach (RiderCombatAbility combatAbility in CombatAbilities)
			{
				combatAbility.StartAbility(this);
			}
			rider.OnStartMounting.AddListener(OnStartMounting);
			InputRow inputAim = InputAim;
			InputRow inputWeapon = InputWeapon;
			InputRow inputAttack = InputAttack1;
			InputRow inputAttack2 = InputAttack2;
			InputRow hBack = HBack;
			InputRow hLeft = HLeft;
			InputRow hRight = HRight;
			IInputSystem inputSystem2 = (Reload.InputSystem = rider.inputSystem);
			IInputSystem inputSystem4 = (hRight.InputSystem = inputSystem2);
			IInputSystem inputSystem6 = (hLeft.InputSystem = inputSystem4);
			IInputSystem inputSystem8 = (hBack.InputSystem = inputSystem6);
			IInputSystem inputSystem10 = (inputAttack2.InputSystem = inputSystem8);
			IInputSystem inputSystem12 = (inputAttack.InputSystem = inputSystem10);
			IInputSystem inputSystem14 = (inputWeapon.InputSystem = inputSystem12);
			inputAim.InputSystem = inputSystem14;
			InputAim.OnInputChanged.AddListener(GetAimInput);
			InputAttack1.OnInputChanged.AddListener(GetAttack1Input);
			InputAttack1.OnInputPressed.AddListener(delegate
			{
				GetAttack1Input(inputValue: true);
			});
			InputAttack2.OnInputChanged.AddListener(GetAttack2Input);
			InputAttack2.OnInputPressed.AddListener(delegate
			{
				GetAttack2Input(inputValue: true);
			});
			Reload.OnInputChanged.AddListener(GetReloadInput);
		}

		public virtual void OnStartMounting()
		{
			if ((bool)rider.AnimalControl)
			{
				DefaultMonturaInputCamBaseInput = rider.AnimalControl.CameraBaseInput;
			}
			rider.Montura.ActiveRiderCombat = this;
		}

		protected virtual void CombatLogicUpdate()
		{
			if (!rider.IsRiding)
			{
				return;
			}
			if (!IsAiming)
			{
				MountStartRotation = MountPoint.localRotation;
			}
			CalculateCameraTargetSide();
			if (UseHolders)
			{
				Toogle_Weapon();
			}
			if (isInCombatMode)
			{
				Anim.speed = 1f;
				Anim.SetInteger(Hash.IDInt, -1);
				if ((bool)ActiveAbility)
				{
					if (Active_IMWeapon != null && Active_IMWeapon.Active && ActiveAbility.WeaponType() != GetWeaponType())
					{
						ActiveAbility = CombatAbilities.Find((RiderCombatAbility ability) => ability.WeaponType() == GetWeaponType());
					}
					if (ActiveAbility.CanAim())
					{
						AimMode();
					}
					_ = InputAttack1.GetInput;
					_ = InputAttack2.GetInput;
					_ = Reload.GetInput;
					ActiveAbility.UpdateAbility();
				}
			}
			if (Target != lastTarget)
			{
				OnTarget.Invoke(Target);
				lastTarget = Target;
				if ((bool)rider.AnimalControl && StrafeOnTarget)
				{
					rider.AnimalControl.CameraBaseInput = (bool)Target || DefaultMonturaInputCamBaseInput;
				}
			}
		}

		private void CalculateCameraTargetSide()
		{
			float num = 0f;
			float num2 = 0f;
			if ((bool)Target)
			{
				num = Vector3.Dot((_transform.position - Target.position).normalized, _transform.right);
			}
			if ((bool)_cam)
			{
				num2 = Vector3.Dot(_cam.transform.right, _transform.forward);
			}
			TargetSide = num > 0f;
			CameraSide = num2 > 0f;
		}

		public virtual void MainAttack()
		{
			if ((bool)ActiveAbility)
			{
				ActiveAbility.PrimaryAttack();
			}
		}

		public virtual void MainAttackReleased()
		{
			if ((bool)ActiveAbility)
			{
				ActiveAbility.PrimaryAttackReleased();
			}
		}

		public virtual void SecondAttack()
		{
			if ((bool)ActiveAbility)
			{
				ActiveAbility.SecondaryAttack();
			}
		}

		public virtual void SecondAttackReleased()
		{
			if ((bool)ActiveAbility)
			{
				ActiveAbility.SecondaryAttackReleased();
			}
		}

		public virtual void ReloadWeapon()
		{
			if ((bool)ActiveAbility)
			{
				ActiveAbility.ReloadWeapon();
			}
		}

		public virtual void LinkAnimator()
		{
			_anim.SetInteger(Hash_WeaponHolder, (int)ActiveHolderSide);
			_anim.SetInteger(Hash_WeaponType, (int)_weaponType);
			_anim.SetInteger(Hash_WeaponAction, (int)_weaponAction);
		}

		protected void GetAimInput(bool inputValue)
		{
			if (InputAim.GetPressed != 0)
			{
				if (inputValue)
				{
					IsAiming = !IsAiming;
					aimSent = false;
					CurrentCameraSide = !CameraSide;
				}
			}
			else if (InputAim.GetPressed == InputButton.Press && IsAiming != inputValue)
			{
				IsAiming = inputValue;
				aimSent = false;
			}
		}

		protected void GetAttack1Input(bool inputValue)
		{
			if (inputValue)
			{
				MainAttack();
			}
			else
			{
				MainAttackReleased();
			}
		}

		protected void GetAttack2Input(bool inputValue)
		{
			if (inputValue)
			{
				SecondAttack();
			}
			else
			{
				SecondAttackReleased();
			}
		}

		protected void GetReloadInput(bool inputValue)
		{
			if (inputValue)
			{
				ReloadWeapon();
			}
		}

		public virtual void AimMode()
		{
			LookDirection();
			_ = InputAim.GetInput;
			if (IsAiming)
			{
				if ((bool)AimDot)
				{
					AimDot.gameObject.SetActive(value: true);
				}
				SetAimDirection();
				if (CurrentCameraSide != CameraSide)
				{
					aimSent = false;
				}
				if (CameraSide && !aimSent)
				{
					if (ActiveAbility.ChangeAimCameraSide() || !Active_IMWeapon.RightHand)
					{
						SetAim(Side: true);
					}
					else
					{
						SetAim(Side: false);
					}
				}
				else if (!CameraSide && !aimSent)
				{
					if (ActiveAbility.ChangeAimCameraSide() || Active_IMWeapon.RightHand)
					{
						SetAim(Side: false);
					}
					else
					{
						SetAim(Side: true);
					}
				}
				if (rider.Montura != null)
				{
					rider.Montura.StraightAim(value: true);
				}
			}
			else if (!aimSent)
			{
				aimSent = true;
				CurrentCameraSide = !CameraSide;
				SetAction(WeaponActions.Idle);
				OnAimSide.Invoke(0);
				if ((bool)AimDot)
				{
					AimDot.gameObject.SetActive(value: false);
				}
				rider.Montura.StraightAim(value: false);
				if (_weaponAction == WeaponActions.AimLeft || _weaponAction == WeaponActions.AimRight || WeaponAction == WeaponActions.Hold || WeaponAction == WeaponActions.Fire_Proyectile)
				{
					SetAction(CombatMode ? WeaponActions.Idle : WeaponActions.None);
				}
			}
		}

		public virtual void SetAimDirection()
		{
			Transform transform = ActiveAbility.AimRayOrigin();
			if ((bool)Target)
			{
				aimDirection = MalbersTools.DirectionTarget(transform, Target);
			}
			else
			{
				Vector3 screenPoint = ((AimDot != null) ? AimDot.position : new Vector3((float)Screen.width * 0.5f, (float)Screen.height * 0.5f));
				aimDirection = MalbersTools.DirectionFromCamera(transform, screenPoint, out aimRayHit, HitMask);
			}
			if (debug)
			{
				UnityEngine.Debug.DrawLine(transform.position, AimRayCastHit.point, Color.red);
			}
		}

		protected void SetAim(bool Side)
		{
			aimSent = true;
			CurrentCameraSide = CameraSide;
			if (_weaponAction != WeaponActions.Hold && _weaponAction != WeaponActions.ReloadLeft && _weaponAction != WeaponActions.ReloadRight)
			{
				SetAction(Active_IMWeapon.RightHand ? WeaponActions.AimRight : WeaponActions.AimLeft);
			}
			OnAimSide.Invoke(Side ? 1 : (-1));
		}

		protected virtual void LookDirection()
		{
			Vector3 from = (Target ? aimDirection : (AimDot ? MalbersTools.DirectionFromCameraNoRayCast(AimDot.position) : Camera.main.transform.forward));
			from.y = 0f;
			float b = Vector3.Angle(from, base.transform.root.forward) * (float)((Target ? TargetSide : CameraSide) ? 1 : (-1)) / 180f;
			horizontalAngle = Mathf.Lerp(HorizontalAngle, b, Time.deltaTime * 15f);
			_anim.SetFloat(Hash_AimSide, HorizontalAngle);
		}

		public virtual void SetActiveHolder(WeaponHolder holder)
		{
			ActiveHolderSide = holder;
			switch (ActiveHolderSide)
			{
			case WeaponHolder.None:
				ActiveHolderTransform = HolderBack;
				break;
			case WeaponHolder.Left:
				ActiveHolderTransform = (HolderLeft ? HolderLeft : HolderBack);
				break;
			case WeaponHolder.Right:
				ActiveHolderTransform = (HolderRight ? HolderRight : HolderBack);
				break;
			case WeaponHolder.Back:
				ActiveHolderTransform = HolderBack;
				break;
			}
		}

		public virtual void SetWeaponBeforeMounting(GameObject weapon)
		{
			if (!(weapon == null) && weapon.GetComponent<IMWeapon>() != null)
			{
				SetActiveWeapon(weapon);
				CombatMode = true;
				Active_IMWeapon.Owner = rider;
				Active_IMWeapon.IsEquiped = true;
				Active_IMWeapon.HitMask = HitMask;
				SetActiveHolder(Active_IMWeapon.Holder);
				_weaponType = GetWeaponType();
				SetAction(WeaponActions.Idle);
				SetWeaponIdleAnimState(Active_IMWeapon.RightHand);
				ActiveAbility = CombatAbilities.Find((RiderCombatAbility ability) => ability.WeaponType() == GetWeaponType());
				if ((bool)ActiveAbility)
				{
					ActiveAbility.ActivateAbility();
				}
				else
				{
					UnityEngine.Debug.LogWarning("The Weapon is combatible but there's no Combat Ability available for it, please Add the matching ability it on the list of Combat Abilities");
				}
				OnEquipWeapon.Invoke(ActiveWeapon);
				LinkAnimator();
			}
		}

		protected virtual void Toogle_Weapon()
		{
			if (_weaponAction != 0 && _weaponAction != WeaponActions.Idle && _weaponAction != WeaponActions.AimLeft && _weaponAction != WeaponActions.AimRight)
			{
				return;
			}
			if (InputWeapon.GetInput)
			{
				ToggleActiveHolderWeapon();
			}
			if (!UseHolders)
			{
				return;
			}
			if (HBack.GetInput)
			{
				Change_Weapon_Holder_Inputs(WeaponHolder.Back);
				if (debug)
				{
					UnityEngine.Debug.Log("Change Holder to 'Back'. ");
				}
			}
			if (HLeft.GetInput)
			{
				Change_Weapon_Holder_Inputs(WeaponHolder.Left);
				if (debug)
				{
					UnityEngine.Debug.Log("Change Holder to 'Left'. ");
				}
			}
			if (HRight.GetInput)
			{
				Change_Weapon_Holder_Inputs(WeaponHolder.Right);
				if (debug)
				{
					UnityEngine.Debug.Log("Change Holder to 'Right'. ");
				}
			}
		}

		public virtual void ToggleActiveHolderWeapon()
		{
			if ((bool)ActiveWeapon)
			{
				if (_weaponAction == WeaponActions.Idle)
				{
					Store_Weapon();
				}
			}
			else
			{
				Draw_Weapon();
			}
		}

		public virtual void Change_Weapon_Holder_Inputs(WeaponHolder holder)
		{
			if (ActiveHolderSide != holder && _weaponAction == WeaponActions.Idle)
			{
				StartCoroutine(SwapWeaponsHolder(holder));
				return;
			}
			if (ActiveHolderSide != holder && _weaponAction == WeaponActions.None)
			{
				SetActiveHolder(holder);
				Draw_Weapon();
				LinkAnimator();
				return;
			}
			if (!isInCombatMode)
			{
				if (_weaponAction == WeaponActions.None)
				{
					Draw_Weapon();
				}
			}
			else if (_weaponAction == WeaponActions.Idle)
			{
				Store_Weapon();
			}
			LinkAnimator();
		}

		private IEnumerator SwapWeaponsHolder(WeaponHolder HoldertoSwap)
		{
			Store_Weapon();
			LinkAnimator();
			while (_weaponAction == WeaponActions.StoreToLeft || _weaponAction == WeaponActions.StoreToRight)
			{
				yield return null;
			}
			SetActiveHolder(HoldertoSwap);
			Draw_Weapon();
		}

		public virtual void SetWeaponByInventory(GameObject Next_Weapon)
		{
			StopAllCoroutines();
			if (!rider.IsRiding)
			{
				return;
			}
			if (Next_Weapon == null)
			{
				if ((bool)ActiveWeapon)
				{
					Store_Weapon();
				}
				return;
			}
			IMWeapon component = Next_Weapon.GetComponent<IMWeapon>();
			if (component == null)
			{
				if ((bool)ActiveWeapon)
				{
					Store_Weapon();
				}
			}
			else if (Active_IMWeapon == null)
			{
				if (!AlreadyInstantiated)
				{
					Next_Weapon = UnityEngine.Object.Instantiate(Next_Weapon, rider.transform);
					Next_Weapon.SetActive(value: false);
				}
				SetActiveWeapon(Next_Weapon);
				Draw_Weapon();
			}
			else if (Active_IMWeapon.Equals(component))
			{
				if (!CombatMode)
				{
					Draw_Weapon();
				}
				else
				{
					Store_Weapon();
				}
			}
			else
			{
				StartCoroutine(SwapWeaponsInventory(Next_Weapon));
			}
		}

		private IEnumerator SwapWeaponsInventory(GameObject nextWeapon)
		{
			Store_Weapon();
			while (_weaponAction == WeaponActions.StoreToLeft || _weaponAction == WeaponActions.StoreToRight)
			{
				yield return null;
			}
			if (!AlreadyInstantiated)
			{
				nextWeapon = UnityEngine.Object.Instantiate(nextWeapon, rider.transform);
				nextWeapon.SetActive(value: false);
			}
			SetActiveWeapon(nextWeapon);
			SetActiveHolder(Active_IMWeapon.Holder);
			Draw_Weapon();
		}

		public virtual void Equip_Weapon()
		{
			SetAction(WeaponActions.Equip);
			isInCombatMode = true;
			if (Active_IMWeapon == null)
			{
				return;
			}
			if (debug)
			{
				UnityEngine.Debug.Log("Equip_Weapon");
			}
			Active_IMWeapon.HitMask = HitMask;
			if (UseHolders)
			{
				if (ActiveHolderTransform.transform.childCount > 0)
				{
					SetActiveWeapon(ActiveHolderTransform.GetChild(0).gameObject);
					ActiveWeapon.transform.parent = (Active_IMWeapon.RightHand ? RightHandEquipPoint : LeftHandEquipPoint);
					Active_IMWeapon.Holder = ActiveHolderSide;
					StartCoroutine(SmoothWeaponTransition(ActiveWeapon.transform, Active_IMWeapon.PositionOffset, Active_IMWeapon.RotationOffset, 0.3f));
				}
			}
			else if (UseInventory)
			{
				if (!AlreadyInstantiated)
				{
					ActiveWeapon.transform.parent = (Active_IMWeapon.RightHand ? RightHandEquipPoint : LeftHandEquipPoint);
					ActiveWeapon.transform.localPosition = Active_IMWeapon.PositionOffset;
					ActiveWeapon.transform.localEulerAngles = Active_IMWeapon.RotationOffset;
				}
				ActiveWeapon.gameObject.SetActive(value: true);
			}
			Active_IMWeapon.Owner = rider;
			Active_IMWeapon.IsEquiped = true;
			OnEquipWeapon.Invoke(ActiveWeapon);
			if ((bool)ActiveAbility)
			{
				ActiveAbility.ActivateAbility();
			}
		}

		public virtual void Unequip_Weapon()
		{
			_weaponType = WeaponType.None;
			SetAction(WeaponActions.Unequip);
			LinkAnimator();
			if (Active_IMWeapon != null)
			{
				if (debug)
				{
					UnityEngine.Debug.Log("Unequip_Weapon");
				}
				Active_IMWeapon.IsEquiped = false;
				OnUnequipWeapon.Invoke(ActiveWeapon);
				if (UseHolders)
				{
					ActiveWeapon.transform.parent = ActiveHolderTransform.transform;
					StartCoroutine(SmoothWeaponTransition(ActiveWeapon.transform, Vector3.zero, Vector3.zero, 0.3f));
				}
				else if (UseInventory && !AlreadyInstantiated && (bool)ActiveWeapon)
				{
					UnityEngine.Object.Destroy(ActiveWeapon);
				}
				activeWeapon = null;
			}
		}

		public virtual void Draw_Weapon()
		{
			ResetRiderCombat();
			if (UseInventory)
			{
				if (Active_IMWeapon != null)
				{
					SetActiveHolder(Active_IMWeapon.Holder);
				}
			}
			else
			{
				if (ActiveHolderTransform.childCount == 0 || ActiveHolderTransform.GetChild(0).GetComponent<IMWeapon>() == null)
				{
					return;
				}
				SetActiveWeapon(ActiveHolderTransform.GetChild(0).gameObject);
			}
			_weaponType = GetWeaponType();
			SetAction(Active_IMWeapon.RightHand ? WeaponActions.DrawFromRight : WeaponActions.DrawFromLeft);
			SetWeaponIdleAnimState(Active_IMWeapon.RightHand);
			ActiveAbility = CombatAbilities.Find((RiderCombatAbility ability) => ability.TypeOfAbility(Active_IMWeapon));
			LinkAnimator();
			if (debug)
			{
				UnityEngine.Debug.Log("Draw: " + ActiveWeapon.name);
			}
		}

		public virtual void Store_Weapon()
		{
			if (Active_IMWeapon != null && isInCombatMode)
			{
				ResetRiderCombat();
				_weaponType = WeaponType.None;
				SetActiveHolder(Active_IMWeapon.Holder);
				SetAction(Active_IMWeapon.RightHand ? WeaponActions.StoreToRight : WeaponActions.StoreToLeft);
				LinkAnimator();
				if (debug)
				{
					UnityEngine.Debug.Log("Store: " + ActiveWeapon.name);
				}
			}
		}

		protected virtual void ResetActiveAbility()
		{
			if (ActiveAbility != null)
			{
				ActiveAbility.ResetAbility();
				ActiveAbility = null;
			}
		}

		private IEnumerator SmoothWeaponTransition(Transform obj, Vector3 posOfsset, Vector3 rotOffset, float time)
		{
			float elapsedtime = 0f;
			Vector3 startPos = obj.localPosition;
			Quaternion startRot = obj.localRotation;
			while (elapsedtime < time)
			{
				obj.localPosition = Vector3.Slerp(startPos, posOfsset, Mathf.SmoothStep(0f, 1f, elapsedtime / time));
				obj.localRotation = Quaternion.Slerp(startRot, Quaternion.Euler(rotOffset), elapsedtime / time);
				elapsedtime += Time.deltaTime;
				yield return null;
			}
			obj.localPosition = posOfsset;
			obj.localEulerAngles = rotOffset;
		}
	}
	public class RiderFPC : Rider
	{
		public UnityEvent OnMount = new UnityEvent();

		public UnityEvent OnDismount = new UnityEvent();

		private void Awake()
		{
			_transform = base.transform;
			_collider = GetComponents<Collider>();
			_rigidbody = GetComponent<Rigidbody>();
			inputSystem = DefaultInput.GetInputSystem(PlayerID);
			MountInput.InputSystem = inputSystem;
			DismountInput.InputSystem = inputSystem;
			CallAnimalInput.InputSystem = inputSystem;
		}

		private void Start()
		{
			if (StartMounted)
			{
				AlreadyMounted();
			}
		}

		public void AlreadyMounted()
		{
			if (AnimalStored != null)
			{
				StartCoroutine(AlreadyMountedC());
			}
		}

		private IEnumerator AlreadyMountedC()
		{
			yield return null;
			Mounting();
		}

		public void Mounting()
		{
			base.Start_Mounting();
			base.IsOnHorse = true;
			Montura.EnableControls(value: true);
			if (CreateColliderMounted)
			{
				MountingCollider(create: true);
			}
			Montura.ActiveRider = this;
			Vector3 forward = Montura.transform.forward;
			forward.y = 0f;
			forward.Normalize();
			base.transform.rotation = Quaternion.LookRotation(forward, -Physics.gravity);
			OnMount.Invoke();
		}

		public void Dismounting()
		{
			base.Start_Dismounting();
			base.End_Dismounting();
			base.transform.position = new Vector3(base.MountTrigger.transform.position.x, base.transform.position.y, base.MountTrigger.transform.position.z);
			if ((bool)_rigidbody)
			{
				_rigidbody.velocity = Vector3.zero;
			}
			OnDismount.Invoke();
		}

		private void Update()
		{
			if (base.IsRiding)
			{
				base.transform.position = Montura.MountPoint.position;
			}
			if (base.transform.parent != null && base.IsOnHorse)
			{
				mounted = true;
			}
			if (MountInput.GetInput)
			{
				SetMounting();
			}
		}

		public virtual void SetMounting()
		{
			if (base.CanMount)
			{
				Mounting();
			}
			else if (CanDismount)
			{
				Dismounting();
			}
			else if (!base.MountTrigger && !base.IsRiding)
			{
				CallAnimal();
			}
		}
	}
}
namespace MalbersAnimations.Scriptables
{
	[Serializable]
	public class BoolReference
	{
		public bool UseConstant = true;

		public bool ConstantValue;

		public bool DefaultValue;

		public BoolVar Variable;

		public bool Value
		{
			get
			{
				if (!UseConstant)
				{
					return Variable.Value;
				}
				return ConstantValue;
			}
			set
			{
				if (UseConstant)
				{
					ConstantValue = value;
				}
				else
				{
					Variable.Value = value;
				}
			}
		}

		public BoolReference()
		{
			UseConstant = true;
			ConstantValue = false;
			DefaultValue = false;
		}

		public BoolReference(bool value)
		{
			Value = value;
		}

		public static implicit operator bool(BoolReference reference)
		{
			return reference.Value;
		}
	}
	[CreateAssetMenu(menuName = "Malbers Animations/Scriptable Variables/Bool Var")]
	public class BoolVar : ScriptableObject
	{
		[SerializeField]
		private bool value;

		public bool UseEvent = true;

		public BoolEvent OnValueChanged = new BoolEvent();

		public virtual bool Value
		{
			get
			{
				return value;
			}
			set
			{
				if (this.value != value)
				{
					this.value = value;
					if (UseEvent)
					{
						OnValueChanged.Invoke(value);
					}
				}
			}
		}

		public virtual void SetValue(BoolVar var)
		{
			Value = var.Value;
		}

		public static implicit operator bool(BoolVar reference)
		{
			return reference.Value;
		}
	}
	[Serializable]
	public class FloatReference
	{
		public bool UseConstant = true;

		public float ConstantValue;

		public FloatVar Variable;

		public float Value
		{
			get
			{
				if (!UseConstant)
				{
					return Variable.Value;
				}
				return ConstantValue;
			}
			set
			{
				if (UseConstant)
				{
					ConstantValue = value;
				}
				else
				{
					Variable.Value = value;
				}
			}
		}

		public FloatReference()
		{
			UseConstant = true;
			ConstantValue = 0f;
		}

		public FloatReference(bool variable = false)
		{
			UseConstant = !variable;
			if (!variable)
			{
				ConstantValue = 0f;
				return;
			}
			Variable = ScriptableObject.CreateInstance<FloatVar>();
			Variable.Value = 0f;
		}

		public FloatReference(float value)
		{
			Value = value;
		}

		public static implicit operator float(FloatReference reference)
		{
			return reference.Value;
		}
	}
	[CreateAssetMenu(menuName = "Malbers Animations/Scriptable Variables/Float Var")]
	public class FloatVar : ScriptableObject
	{
		[SerializeField]
		private float value;

		public bool UseEvent;

		public FloatEvent OnValueChanged = new FloatEvent();

		public virtual float Value
		{
			get
			{
				return value;
			}
			set
			{
				if (this.value != value)
				{
					this.value = value;
					if (UseEvent)
					{
						OnValueChanged.Invoke(value);
					}
				}
			}
		}

		public static implicit operator float(FloatVar reference)
		{
			return reference.Value;
		}
	}
	[Serializable]
	public class IntReference
	{
		public bool UseConstant = true;

		public int ConstantValue;

		public int ResetValue;

		public IntVar Variable;

		public int Value
		{
			get
			{
				if (!UseConstant)
				{
					return Variable.Value;
				}
				return ConstantValue;
			}
			set
			{
				if (UseConstant)
				{
					ConstantValue = value;
				}
				else
				{
					Variable.Value = value;
				}
			}
		}

		public IntReference()
		{
			UseConstant = true;
			ConstantValue = 0;
		}

		public IntReference(bool variable = false)
		{
			UseConstant = !variable;
			if (!variable)
			{
				ConstantValue = 0;
				return;
			}
			Variable = ScriptableObject.CreateInstance<IntVar>();
			Variable.Value = 0;
		}

		public IntReference(int value)
		{
			Value = value;
		}

		public static implicit operator int(IntReference reference)
		{
			return reference.Value;
		}
	}
	[CreateAssetMenu(menuName = "Malbers Animations/Scriptable Variables/Int Var")]
	public class IntVar : ScriptableObject
	{
		[SerializeField]
		private int value;

		public bool UseEvent;

		public IntEvent OnValueChanged = new IntEvent();

		public virtual int Value
		{
			get
			{
				return value;
			}
			set
			{
				if (this.value != value)
				{
					this.value = value;
					if (UseEvent)
					{
						OnValueChanged.Invoke(value);
					}
				}
			}
		}

		public virtual void SetValue(IntVar var)
		{
			Value = var.Value;
		}

		public static implicit operator int(IntVar reference)
		{
			return reference.Value;
		}
	}
	[Serializable]
	public class StringReference
	{
		public bool UseConstant = true;

		public string ConstantValue;

		public StringVar Variable;

		public string Value
		{
			get
			{
				if (!UseConstant)
				{
					return Variable.Value;
				}
				return ConstantValue;
			}
			set
			{
				if (UseConstant)
				{
					ConstantValue = value;
				}
				else
				{
					Variable.Value = value;
				}
			}
		}

		public StringReference()
		{
			UseConstant = true;
			ConstantValue = string.Empty;
		}

		public StringReference(bool variable = false)
		{
			UseConstant = !variable;
			if (!variable)
			{
				ConstantValue = string.Empty;
				return;
			}
			Variable = ScriptableObject.CreateInstance<StringVar>();
			Variable.Value = string.Empty;
			Variable.DefaultValue = string.Empty;
		}

		public StringReference(string value)
		{
			Value = value;
		}

		public static implicit operator string(StringReference reference)
		{
			return reference.Value;
		}
	}
	[CreateAssetMenu(menuName = "Malbers Animations/Scriptable Variables/String Var")]
	public class StringVar : ScriptableObject
	{
		[SerializeField]
		private string value = "";

		[SerializeField]
		private string defaultValue = "";

		public bool UseEvent = true;

		public StringEvent OnValueChanged = new StringEvent();

		public virtual string Value
		{
			get
			{
				return value;
			}
			set
			{
				if (this.value != value)
				{
					this.value = value;
					if (UseEvent)
					{
						OnValueChanged.Invoke(value);
					}
				}
			}
		}

		public virtual string DefaultValue
		{
			get
			{
				return defaultValue;
			}
			set
			{
				defaultValue = value;
			}
		}

		public virtual void ResetValue()
		{
			Value = DefaultValue;
		}

		public virtual void SetValue(StringVar var)
		{
			Value = var.Value;
			DefaultValue = var.DefaultValue;
		}

		public static implicit operator string(StringVar reference)
		{
			return reference.Value;
		}
	}
	[Serializable]
	public class Vector3Reference
	{
		public bool UseConstant = true;

		public Vector3 ConstantValue = Vector3.zero;

		public Vector3 DefaultValue;

		public Vector3Var Variable;

		public Vector3 Value
		{
			get
			{
				if (!UseConstant)
				{
					return Variable.Value;
				}
				return ConstantValue;
			}
			set
			{
				if (UseConstant)
				{
					ConstantValue = value;
				}
				else
				{
					Variable.Value = value;
				}
			}
		}

		public Vector3Reference()
		{
			UseConstant = true;
			ConstantValue = Vector3.zero;
			DefaultValue = Vector3.zero;
		}

		public Vector3Reference(bool variable = false)
		{
			UseConstant = !variable;
			if (!variable)
			{
				ConstantValue = Vector3.zero;
				return;
			}
			Variable = ScriptableObject.CreateInstance<Vector3Var>();
			Variable.Value = Vector3.zero;
		}

		public Vector3Reference(Vector3 value)
		{
			Value = value;
		}

		public static implicit operator Vector3(Vector3Reference reference)
		{
			return reference.Value;
		}

		public static implicit operator Vector2(Vector3Reference reference)
		{
			return reference.Value;
		}
	}
	[CreateAssetMenu(menuName = "Malbers Animations/Scriptable Variables/Vector3 Var")]
	public class Vector3Var : ScriptableObject
	{
		[SerializeField]
		private Vector3 value = Vector3.zero;

		public bool UseEvent = true;

		public Vector3Event OnValueChanged = new Vector3Event();

		public virtual Vector3 Value
		{
			get
			{
				return value;
			}
			set
			{
				if (this.value != value)
				{
					this.value = value;
					if (UseEvent)
					{
						OnValueChanged.Invoke(value);
					}
				}
			}
		}

		public virtual void SetValue(Vector3Var var)
		{
			Value = var.Value;
		}

		public static implicit operator Vector3(Vector3Var reference)
		{
			return reference.Value;
		}

		public static implicit operator Vector2(Vector3Var reference)
		{
			return reference.Value;
		}
	}
}
namespace MalbersAnimations.Events
{
	[Serializable]
	public class GameObjectEvent : UnityEvent<GameObject>
	{
	}
	[Serializable]
	public class TransformEvent : UnityEvent<Transform>
	{
	}
	[Serializable]
	public class RayCastHitEvent : UnityEvent<RaycastHit>
	{
	}
	[Serializable]
	public class Vector3Event : UnityEvent<Vector3>
	{
	}
	[Serializable]
	public class IntEvent : UnityEvent<int>
	{
	}
	[Serializable]
	public class FloatEvent : UnityEvent<float>
	{
	}
	[Serializable]
	public class BoolEvent : UnityEvent<bool>
	{
	}
	[Serializable]
	public class StringEvent : UnityEvent<string>
	{
	}
	[Serializable]
	public class ColliderEvent : UnityEvent<Collider>
	{
	}
	[Serializable]
	public class CollisionEvent : UnityEvent<Collision>
	{
	}
	[Serializable]
	public class ComponentEvent : UnityEvent<UnityEngine.Component>
	{
	}
	[CreateAssetMenu(menuName = "Malbers Animations/Event", fileName = "New Event Asset")]
	public class MEvent : ScriptableObject
	{
		private readonly List<MEventItemListener> eventListeners = new List<MEventItemListener>();

		public virtual void Invoke()
		{
			for (int num = eventListeners.Count - 1; num >= 0; num--)
			{
				eventListeners[num].OnEventInvoked();
			}
		}

		public virtual void Invoke(float value)
		{
			for (int num = eventListeners.Count - 1; num >= 0; num--)
			{
				eventListeners[num].OnEventInvoked(value);
			}
		}

		public virtual void Invoke(bool value)
		{
			for (int num = eventListeners.Count - 1; num >= 0; num--)
			{
				eventListeners[num].OnEventInvoked(value);
			}
		}

		public virtual void Invoke(string value)
		{
			for (int num = eventListeners.Count - 1; num >= 0; num--)
			{
				eventListeners[num].OnEventInvoked(value);
			}
		}

		public virtual void Invoke(int value)
		{
			for (int num = eventListeners.Count - 1; num >= 0; num--)
			{
				eventListeners[num].OnEventInvoked(value);
			}
		}

		public virtual void Invoke(GameObject value)
		{
			for (int num = eventListeners.Count - 1; num >= 0; num--)
			{
				eventListeners[num].OnEventInvoked(value);
			}
		}

		public virtual void Invoke(Transform value)
		{
			for (int num = eventListeners.Count - 1; num >= 0; num--)
			{
				eventListeners[num].OnEventInvoked(value);
			}
		}

		public virtual void Invoke(Vector3 value)
		{
			for (int num = eventListeners.Count - 1; num >= 0; num--)
			{
				eventListeners[num].OnEventInvoked(value);
			}
		}

		public virtual void RegisterListener(MEventItemListener listener)
		{
			if (!eventListeners.Contains(listener))
			{
				eventListeners.Add(listener);
			}
		}

		public virtual void UnregisterListener(MEventItemListener listener)
		{
			if (eventListeners.Contains(listener))
			{
				eventListeners.Remove(listener);
			}
		}

		public virtual void DebugLog(string text)
		{
			UnityEngine.Debug.Log(text);
		}
	}
	[Serializable]
	public class MEventItemListener
	{
		public MEvent Event;

		[HideInInspector]
		public bool useInt;

		[HideInInspector]
		public bool useFloat;

		[HideInInspector]
		public bool useVoid = true;

		[HideInInspector]
		public bool useString;

		[HideInInspector]
		public bool useBool;

		[HideInInspector]
		public bool useGO;

		[HideInInspector]
		public bool useTransform;

		[HideInInspector]
		public bool useVector;

		public UnityEvent Response = new UnityEvent();

		public FloatEvent ResponseFloat = new FloatEvent();

		public IntEvent ResponseInt = new IntEvent();

		public BoolEvent ResponseBool = new BoolEvent();

		public StringEvent ResponseString = new StringEvent();

		public GameObjectEvent ResponseGO = new GameObjectEvent();

		public TransformEvent ResponseTransform = new TransformEvent();

		public Vector3Event ResponseVector = new Vector3Event();

		public virtual void OnEventInvoked()
		{
			Response.Invoke();
		}

		public virtual void OnEventInvoked(string value)
		{
			ResponseString.Invoke(value);
		}

		public virtual void OnEventInvoked(float value)
		{
			ResponseFloat.Invoke(value);
		}

		public virtual void OnEventInvoked(int value)
		{
			ResponseInt.Invoke(value);
		}

		public virtual void OnEventInvoked(bool value)
		{
			ResponseBool.Invoke(value);
		}

		public virtual void OnEventInvoked(GameObject value)
		{
			ResponseGO.Invoke(value);
		}

		public virtual void OnEventInvoked(Transform value)
		{
			ResponseTransform.Invoke(value);
		}

		public virtual void OnEventInvoked(Vector3 value)
		{
			ResponseVector.Invoke(value);
		}

		public MEventItemListener()
		{
			useVoid = true;
			useInt = (useFloat = (useString = (useBool = (useGO = (useTransform = (useVector = false))))));
		}
	}
	public class MEventListener : MonoBehaviour
	{
		public List<MEventItemListener> Events = new List<MEventItemListener>();

		private void OnEnable()
		{
			foreach (MEventItemListener @event in Events)
			{
				if ((bool)@event.Event)
				{
					@event.Event.RegisterListener(@event);
				}
			}
		}

		private void OnDisable()
		{
			foreach (MEventItemListener @event in Events)
			{
				if ((bool)@event.Event)
				{
					@event.Event.UnregisterListener(@event);
				}
			}
		}
	}
	public class UnityEventRaiser : MonoBehaviour
	{
		public UnityEvent OnEnableEvent;

		public void OnEnable()
		{
			OnEnableEvent.Invoke();
		}
	}
}
namespace MalbersAnimations.SA
{
	public class MProtectCameraFromWallClip : MonoBehaviour
	{
		public class RayHitComparer : IComparer
		{
			public int Compare(object x, object y)
			{
				return ((RaycastHit)x).distance.CompareTo(((RaycastHit)y).distance);
			}
		}

		public float clipMoveTime = 0.05f;

		public float returnTime = 0.4f;

		public float sphereCastRadius = 0.1f;

		public bool visualiseInEditor;

		public float closestDistance = 0.5f;

		public string dontClipTag = "Player";

		private Transform m_Cam;

		private Transform m_Pivot;

		private float m_OriginalDist;

		private float m_MoveVelocity;

		private float m_CurrentDist;

		private Ray m_Ray;

		private RaycastHit[] m_Hits;

		private RayHitComparer m_RayHitComparer;

		public bool protecting { get; private set; }

		private void Start()
		{
			m_Cam = GetComponentInChildren<Camera>().transform;
			m_Pivot = m_Cam.parent;
			m_OriginalDist = m_Cam.localPosition.magnitude;
			m_CurrentDist = m_OriginalDist;
			m_RayHitComparer = new RayHitComparer();
		}

		private void LateUpdate()
		{
			float num = m_OriginalDist;
			m_Ray.origin = m_Pivot.position + m_Pivot.forward * sphereCastRadius;
			m_Ray.direction = -m_Pivot.forward;
			Collider[] array = Physics.OverlapSphere(m_Ray.origin, sphereCastRadius);
			bool flag = false;
			bool flag2 = false;
			for (int i = 0; i < array.Length; i++)
			{
				if (!array[i].isTrigger && (!(array[i].attachedRigidbody != null) || !array[i].attachedRigidbody.CompareTag(dontClipTag)))
				{
					flag = true;
					break;
				}
			}
			if (flag)
			{
				m_Ray.origin += m_Pivot.forward * sphereCastRadius;
				m_Hits = Physics.RaycastAll(m_Ray, m_OriginalDist - sphereCastRadius);
			}
			else
			{
				m_Hits = Physics.SphereCastAll(m_Ray, sphereCastRadius, m_OriginalDist + sphereCastRadius);
			}
			Array.Sort(m_Hits, m_RayHitComparer);
			float num2 = float.PositiveInfinity;
			for (int j = 0; j < m_Hits.Length; j++)
			{
				if (m_Hits[j].distance < num2 && !m_Hits[j].collider.isTrigger && (!(m_Hits[j].collider.attachedRigidbody != null) || !m_Hits[j].collider.attachedRigidbody.CompareTag(dontClipTag)))
				{
					num2 = m_Hits[j].distance;
					num = 0f - m_Pivot.InverseTransformPoint(m_Hits[j].point).z;
					flag2 = true;
				}
			}
			if (flag2)
			{
				UnityEngine.Debug.DrawRay(m_Ray.origin, -m_Pivot.forward * (num + sphereCastRadius), Color.red);
			}
			protecting = flag2;
			m_CurrentDist = Mathf.SmoothDamp(m_CurrentDist, num, ref m_MoveVelocity, (m_CurrentDist > num) ? clipMoveTime : returnTime);
			m_CurrentDist = Mathf.Clamp(m_CurrentDist, closestDistance, m_OriginalDist);
			m_Cam.localPosition = -Vector3.forward * m_CurrentDist;
		}
	}
	[Serializable]
	public class MLerpControlledBob
	{
		public float BobDuration;

		public float BobAmount;

		private float m_Offset;

		public float Offset()
		{
			return m_Offset;
		}

		public IEnumerator DoBobCycle()
		{
			float t2 = 0f;
			while (t2 < BobDuration)
			{
				m_Offset = Mathf.Lerp(0f, BobAmount, t2 / BobDuration);
				t2 += Time.deltaTime;
				yield return new WaitForFixedUpdate();
			}
			t2 = 0f;
			while (t2 < BobDuration)
			{
				m_Offset = Mathf.Lerp(BobAmount, 0f, t2 / BobDuration);
				t2 += Time.deltaTime;
				yield return new WaitForFixedUpdate();
			}
			m_Offset = 0f;
		}
	}
	[Serializable]
	public class MCurveControlledBob
	{
		public float HorizontalBobRange = 0.33f;

		public float VerticalBobRange = 0.33f;

		public AnimationCurve Bobcurve = new AnimationCurve(new Keyframe(0f, 0f), new Keyframe(0.5f, 1f), new Keyframe(1f, 0f), new Keyframe(1.5f, -1f), new Keyframe(2f, 0f));

		public float VerticaltoHorizontalRatio = 1f;

		private float m_CyclePositionX;

		private float m_CyclePositionY;

		private float m_BobBaseInterval;

		private Vector3 m_OriginalCameraPosition;

		private float m_Time;

		public void Setup(Camera camera, float bobBaseInterval)
		{
			m_BobBaseInterval = bobBaseInterval;
			m_OriginalCameraPosition = camera.transform.localPosition;
			m_Time = Bobcurve[Bobcurve.length - 1].time;
		}

		public Vector3 DoHeadBob(float speed)
		{
			float x = m_OriginalCameraPosition.x + Bobcurve.Evaluate(m_CyclePositionX) * HorizontalBobRange;
			float y = m_OriginalCameraPosition.y + Bobcurve.Evaluate(m_CyclePositionY) * VerticalBobRange;
			m_CyclePositionX += speed * Time.deltaTime / m_BobBaseInterval;
			m_CyclePositionY += speed * Time.deltaTime / m_BobBaseInterval * VerticaltoHorizontalRatio;
			if (m_CyclePositionX > m_Time)
			{
				m_CyclePositionX -= m_Time;
			}
			if (m_CyclePositionY > m_Time)
			{
				m_CyclePositionY -= m_Time;
			}
			return new Vector3(x, y, 0f);
		}
	}
	public class MHeadBob : MonoBehaviour
	{
		public Camera Camera;

		public MCurveControlledBob motionBob = new MCurveControlledBob();

		public MLerpControlledBob jumpAndLandingBob = new MLerpControlledBob();

		public MRigidbodyFPSController rigidbodyFirstPersonController;

		public float StrideInterval;

		[Range(0f, 1f)]
		public float RunningStrideLengthen;

		private bool m_PreviouslyGrounded;

		private Vector3 m_OriginalCameraPosition;

		private void Start()
		{
			motionBob.Setup(Camera, StrideInterval);
			m_OriginalCameraPosition = Camera.transform.localPosition;
		}

		private void Update()
		{
			Vector3 localPosition;
			if (rigidbodyFirstPersonController.Velocity.magnitude > 0f && rigidbodyFirstPersonController.Grounded)
			{
				Camera.transform.localPosition = motionBob.DoHeadBob(rigidbodyFirstPersonController.Velocity.magnitude * (rigidbodyFirstPersonController.Running ? RunningStrideLengthen : 1f));
				localPosition = Camera.transform.localPosition;
				localPosition.y = Camera.transform.localPosition.y - jumpAndLandingBob.Offset();
			}
			else
			{
				localPosition = Camera.transform.localPosition;
				localPosition.y = m_OriginalCameraPosition.y - jumpAndLandingBob.Offset();
			}
			Camera.transform.localPosition = localPosition;
			if (!m_PreviouslyGrounded && rigidbodyFirstPersonController.Grounded)
			{
				StartCoroutine(jumpAndLandingBob.DoBobCycle());
			}
			m_PreviouslyGrounded = rigidbodyFirstPersonController.Grounded;
		}
	}
	[Serializable]
	public class MMouseLook
	{
		public float XSensitivity = 2f;

		public float YSensitivity = 2f;

		public bool clampVerticalRotation = true;

		public float MinimumX = -90f;

		public float MaximumX = 90f;

		public bool smooth;

		public float smoothTime = 5f;

		private Quaternion m_CharacterTargetRot;

		private Quaternion m_CameraTargetRot;

		public void Init(Transform character, Transform camera)
		{
			m_CharacterTargetRot = character.localRotation;
			m_CameraTargetRot = camera.localRotation;
		}

		public void LookRotation(Transform character, Transform camera)
		{
			float y = Input.GetAxis("Mouse X") * XSensitivity;
			float num = Input.GetAxis("Mouse Y") * YSensitivity;
			m_CharacterTargetRot *= Quaternion.Euler(0f, y, 0f);
			m_CameraTargetRot *= Quaternion.Euler(0f - num, 0f, 0f);
			if (clampVerticalRotation)
			{
				m_CameraTargetRot = ClampRotationAroundXAxis(m_CameraTargetRot);
			}
			if (smooth)
			{
				character.localRotation = Quaternion.Slerp(character.localRotation, m_CharacterTargetRot, smoothTime * Time.deltaTime);
				camera.localRotation = Quaternion.Slerp(camera.localRotation, m_CameraTargetRot, smoothTime * Time.deltaTime);
			}
			else
			{
				character.localRotation = m_CharacterTargetRot;
				camera.localRotation = m_CameraTargetRot;
			}
		}

		private Quaternion ClampRotationAroundXAxis(Quaternion q)
		{
			q.x /= q.w;
			q.y /= q.w;
			q.z /= q.w;
			q.w = 1f;
			float value = 114.59156f * Mathf.Atan(q.x);
			value = Mathf.Clamp(value, MinimumX, MaximumX);
			q.x = Mathf.Tan((float)Math.PI / 360f * value);
			return q;
		}
	}
	[RequireComponent(typeof(Rigidbody))]
	[RequireComponent(typeof(CapsuleCollider))]
	public class MRigidbodyFPSController : MonoBehaviour
	{
		public Camera cam;

		public bool LockCursor;

		[SerializeField]
		public bool lockMovement;

		public MMovementSettings movementSettings = new MMovementSettings();

		public MMouseLook mouseLook = new MMouseLook();

		public MAdvancedSettings advancedSettings = new MAdvancedSettings();

		private Rigidbody m_RigidBody;

		private CapsuleCollider m_Capsule;

		private Vector3 m_GroundContactNormal;

		private bool m_Jump;

		private bool m_PreviouslyGrounded;

		private bool m_Jumping;

		private bool m_IsGrounded;

		public bool LockMovement
		{
			get
			{
				return lockMovement;
			}
			set
			{
				lockMovement = value;
			}
		}

		public Vector3 Velocity => m_RigidBody.velocity;

		public bool Grounded => m_IsGrounded;

		public bool Jumping => m_Jumping;

		public bool Running => movementSettings.Running;

		private void Start()
		{
			m_RigidBody = GetComponent<Rigidbody>();
			m_Capsule = GetComponent<CapsuleCollider>();
			Cursor.lockState = (LockCursor ? CursorLockMode.Locked : CursorLockMode.None);
			Cursor.visible = !LockCursor;
			RestartMouseLook();
		}

		private void Update()
		{
			RotateView();
			if (Input.GetButtonDown("Jump") && !m_Jump)
			{
				m_Jump = true;
			}
		}

		public void RestartMouseLook()
		{
			mouseLook.Init(base.transform, cam.transform);
		}

		private void FixedUpdate()
		{
			if (lockMovement)
			{
				return;
			}
			GroundCheck();
			Vector2 input = GetInput();
			if ((Mathf.Abs(input.x) > float.Epsilon || Mathf.Abs(input.y) > float.Epsilon) && (advancedSettings.airControl || m_IsGrounded))
			{
				Vector3 vector = cam.transform.forward * input.y + cam.transform.right * input.x;
				vector = Vector3.ProjectOnPlane(vector, m_GroundContactNormal).normalized;
				vector.x *= movementSettings.CurrentTargetSpeed;
				vector.z *= movementSettings.CurrentTargetSpeed;
				vector.y *= movementSettings.CurrentTargetSpeed;
				if (m_RigidBody.velocity.sqrMagnitude < movementSettings.CurrentTargetSpeed * movementSettings.CurrentTargetSpeed)
				{
					m_RigidBody.AddForce(vector * SlopeMultiplier(), ForceMode.Impulse);
				}
			}
			if (m_IsGrounded)
			{
				m_RigidBody.drag = 5f;
				if (m_Jump)
				{
					m_RigidBody.drag = 0f;
					m_RigidBody.velocity = new Vector3(m_RigidBody.velocity.x, 0f, m_RigidBody.velocity.z);
					m_RigidBody.AddForce(new Vector3(0f, movementSettings.JumpForce, 0f), ForceMode.Impulse);
					m_Jumping = true;
				}
				if (!m_Jumping && Mathf.Abs(input.x) < float.Epsilon && Mathf.Abs(input.y) < float.Epsilon && m_RigidBody.velocity.magnitude < 1f)
				{
					m_RigidBody.Sleep();
				}
			}
			else
			{
				m_RigidBody.drag = 0f;
				if (m_PreviouslyGrounded && !m_Jumping)
				{
					StickToGroundHelper();
				}
			}
			m_Jump = false;
		}

		private float SlopeMultiplier()
		{
			float time = Vector3.Angle(m_GroundContactNormal, Vector3.up);
			return movementSettings.SlopeCurveModifier.Evaluate(time);
		}

		private void StickToGroundHelper()
		{
			if (Physics.SphereCast(base.transform.position, m_Capsule.radius, Vector3.down, out var hitInfo, m_Capsule.height / 2f - m_Capsule.radius + advancedSettings.stickToGroundHelperDistance) && Mathf.Abs(Vector3.Angle(hitInfo.normal, Vector3.up)) < 85f)
			{
				m_RigidBody.velocity = Vector3.ProjectOnPlane(m_RigidBody.velocity, hitInfo.normal);
			}
		}

		private Vector2 GetInput()
		{
			Vector2 vector = default(Vector2);
			vector.x = Input.GetAxis("Horizontal");
			vector.y = Input.GetAxis("Vertical");
			Vector2 vector2 = vector;
			movementSettings.UpdateDesiredTargetSpeed(vector2);
			return vector2;
		}

		public virtual void RotateView()
		{
			if (!(Mathf.Abs(Time.timeScale) < float.Epsilon))
			{
				float y = base.transform.eulerAngles.y;
				mouseLook.LookRotation(base.transform, cam.transform);
				if (m_IsGrounded || advancedSettings.airControl)
				{
					Quaternion quaternion = Quaternion.AngleAxis(base.transform.eulerAngles.y - y, Vector3.up);
					m_RigidBody.velocity = quaternion * m_RigidBody.velocity;
				}
			}
		}

		private void GroundCheck()
		{
			m_PreviouslyGrounded = m_IsGrounded;
			if (Physics.SphereCast(base.transform.position, m_Capsule.radius, Vector3.down, out var hitInfo, m_Capsule.height / 2f - m_Capsule.radius + advancedSettings.groundCheckDistance))
			{
				m_IsGrounded = true;
				m_GroundContactNormal = hitInfo.normal;
			}
			else
			{
				m_IsGrounded = false;
				m_GroundContactNormal = Vector3.up;
			}
			if (!m_PreviouslyGrounded && m_IsGrounded && m_Jumping)
			{
				m_Jumping = false;
			}
		}
	}
	[Serializable]
	public class MMovementSettings
	{
		public float ForwardSpeed = 8f;

		public float BackwardSpeed = 4f;

		public float StrafeSpeed = 4f;

		public float RunMultiplier = 2f;

		public InputRow RunKey = new InputRow("Shift", KeyCode.LeftShift, InputButton.Press);

		public float JumpForce = 30f;

		public AnimationCurve SlopeCurveModifier = new AnimationCurve(new Keyframe(-90f, 1f), new Keyframe(0f, 1f), new Keyframe(90f, 0f));

		[HideInInspector]
		public float CurrentTargetSpeed = 8f;

		private bool m_Running;

		public bool Running => m_Running;

		public void UpdateDesiredTargetSpeed(Vector2 input)
		{
			if (!(input == Vector2.zero))
			{
				if (input.x > 0f || input.x < 0f)
				{
					CurrentTargetSpeed = StrafeSpeed;
				}
				if (input.y < 0f)
				{
					CurrentTargetSpeed = BackwardSpeed;
				}
				if (input.y > 0f)
				{
					CurrentTargetSpeed = ForwardSpeed;
				}
				if (RunKey.GetInput)
				{
					CurrentTargetSpeed *= RunMultiplier;
					m_Running = true;
				}
				else
				{
					m_Running = false;
				}
			}
		}
	}
	[Serializable]
	public class MAdvancedSettings
	{
		public float groundCheckDistance = 0.01f;

		public float stickToGroundHelperDistance = 0.5f;

		public float slowDownRate = 20f;

		public bool airControl;
	}
	[RequireComponent(typeof(Rigidbody))]
	[RequireComponent(typeof(CapsuleCollider))]
	public class MRigidFPS : MonoBehaviour
	{
		public Camera cam;

		public bool LockCursor;

		[SerializeField]
		public bool lockMovement;

		public MMovementSettings movementSettings = new MMovementSettings();

		public MMouseLook mouseLook = new MMouseLook();

		public MAdvancedSettings advancedSettings = new MAdvancedSettings();

		private Rigidbody m_RigidBody;

		private CapsuleCollider m_Capsule;

		private Vector3 m_GroundContactNormal;

		private bool m_Jump;

		private bool m_PreviouslyGrounded;

		private bool m_Jumping;

		private bool m_IsGrounded;

		public bool LockMovement
		{
			get
			{
				return lockMovement;
			}
			set
			{
				lockMovement = value;
			}
		}

		public Vector3 Velocity => m_RigidBody.velocity;

		public bool Grounded => m_IsGrounded;

		public bool Jumping => m_Jumping;

		public bool Running => movementSettings.Running;

		private void Start()
		{
			m_RigidBody = GetComponent<Rigidbody>();
			m_Capsule = GetComponent<CapsuleCollider>();
			Cursor.lockState = (LockCursor ? CursorLockMode.Locked : CursorLockMode.None);
			Cursor.visible = !LockCursor;
			RestartMouseLook();
		}

		private void Update()
		{
			RotateView();
			if (Input.GetButtonDown("Jump") && !m_Jump)
			{
				m_Jump = true;
			}
		}

		public void RestartMouseLook()
		{
			mouseLook.Init(base.transform, cam.transform);
		}

		private void FixedUpdate()
		{
			if (lockMovement)
			{
				return;
			}
			GroundCheck();
			Vector2 input = GetInput();
			if ((Mathf.Abs(input.x) > float.Epsilon || Mathf.Abs(input.y) > float.Epsilon) && (advancedSettings.airControl || m_IsGrounded))
			{
				Vector3 vector = cam.transform.forward * input.y + cam.transform.right * input.x;
				vector = Vector3.ProjectOnPlane(vector, m_GroundContactNormal).normalized;
				vector.x *= movementSettings.CurrentTargetSpeed;
				vector.z *= movementSettings.CurrentTargetSpeed;
				vector.y *= movementSettings.CurrentTargetSpeed;
				if (m_RigidBody.velocity.sqrMagnitude < movementSettings.CurrentTargetSpeed * movementSettings.CurrentTargetSpeed)
				{
					m_RigidBody.AddForce(vector * SlopeMultiplier(), ForceMode.Impulse);
				}
			}
			if (m_IsGrounded)
			{
				m_RigidBody.drag = 5f;
				if (m_Jump)
				{
					m_RigidBody.drag = 0f;
					m_RigidBody.velocity = new Vector3(m_RigidBody.velocity.x, 0f, m_RigidBody.velocity.z);
					m_RigidBody.AddForce(new Vector3(0f, movementSettings.JumpForce, 0f), ForceMode.Impulse);
					m_Jumping = true;
				}
				if (!m_Jumping && Mathf.Abs(input.x) < float.Epsilon && Mathf.Abs(input.y) < float.Epsilon && m_RigidBody.velocity.magnitude < 1f)
				{
					m_RigidBody.Sleep();
				}
			}
			else
			{
				m_RigidBody.drag = 0f;
				if (m_PreviouslyGrounded && !m_Jumping)
				{
					StickToGroundHelper();
				}
			}
			m_Jump = false;
		}

		private float SlopeMultiplier()
		{
			float time = Vector3.Angle(m_GroundContactNormal, Vector3.up);
			return movementSettings.SlopeCurveModifier.Evaluate(time);
		}

		private void StickToGroundHelper()
		{
			if (Physics.SphereCast(base.transform.position, m_Capsule.radius, Vector3.down, out var hitInfo, m_Capsule.height / 2f - m_Capsule.radius + advancedSettings.stickToGroundHelperDistance) && Mathf.Abs(Vector3.Angle(hitInfo.normal, Vector3.up)) < 85f)
			{
				m_RigidBody.velocity = Vector3.ProjectOnPlane(m_RigidBody.velocity, hitInfo.normal);
			}
		}

		private Vector2 GetInput()
		{
			Vector2 vector = default(Vector2);
			vector.x = Input.GetAxis("Horizontal");
			vector.y = Input.GetAxis("Vertical");
			Vector2 vector2 = vector;
			movementSettings.UpdateDesiredTargetSpeed(vector2);
			return vector2;
		}

		public virtual void RotateView()
		{
			if (!(Mathf.Abs(Time.timeScale) < float.Epsilon))
			{
				float y = base.transform.eulerAngles.y;
				mouseLook.LookRotation(base.transform, cam.transform);
				if (m_IsGrounded || advancedSettings.airControl)
				{
					Quaternion quaternion = Quaternion.AngleAxis(base.transform.eulerAngles.y - y, Vector3.up);
					m_RigidBody.velocity = quaternion * m_RigidBody.velocity;
				}
			}
		}

		private void GroundCheck()
		{
			m_PreviouslyGrounded = m_IsGrounded;
			if (Physics.SphereCast(base.transform.position, m_Capsule.radius, Vector3.down, out var hitInfo, m_Capsule.height / 2f - m_Capsule.radius + advancedSettings.groundCheckDistance))
			{
				m_IsGrounded = true;
				m_GroundContactNormal = hitInfo.normal;
			}
			else
			{
				m_IsGrounded = false;
				m_GroundContactNormal = Vector3.up;
			}
			if (!m_PreviouslyGrounded && m_IsGrounded && m_Jumping)
			{
				m_Jumping = false;
			}
		}
	}
	[Serializable]
	public class MMMovementSettings
	{
		public float ForwardSpeed = 8f;

		public float BackwardSpeed = 4f;

		public float StrafeSpeed = 4f;

		public float RunMultiplier = 2f;

		public InputRow RunKey = new InputRow("Shift", KeyCode.LeftShift, InputButton.Press);

		public float JumpForce = 30f;

		public AnimationCurve SlopeCurveModifier = new AnimationCurve(new Keyframe(-90f, 1f), new Keyframe(0f, 1f), new Keyframe(90f, 0f));

		[HideInInspector]
		public float CurrentTargetSpeed = 8f;

		private bool m_Running;

		public bool Running => m_Running;

		public void UpdateDesiredTargetSpeed(Vector2 input)
		{
			if (!(input == Vector2.zero))
			{
				if (input.x > 0f || input.x < 0f)
				{
					CurrentTargetSpeed = StrafeSpeed;
				}
				if (input.y < 0f)
				{
					CurrentTargetSpeed = BackwardSpeed;
				}
				if (input.y > 0f)
				{
					CurrentTargetSpeed = ForwardSpeed;
				}
				if (RunKey.GetInput)
				{
					CurrentTargetSpeed *= RunMultiplier;
					m_Running = true;
				}
				else
				{
					m_Running = false;
				}
			}
		}
	}
	[Serializable]
	public class MMAdvancedSettings
	{
		public float groundCheckDistance = 0.01f;

		public float stickToGroundHelperDistance = 0.5f;

		public float slowDownRate = 20f;

		public bool airControl;
	}
	[RequireComponent(typeof(Rigidbody))]
	[RequireComponent(typeof(Animator))]
	public class MThirdPersonCharacter : MonoBehaviour, ICharacterMove
	{
		[SerializeField]
		private float m_MovingTurnSpeed = 360f;

		[SerializeField]
		private float m_StationaryTurnSpeed = 180f;

		[SerializeField]
		private float m_JumpPower = 12f;

		[Range(1f, 4f)]
		[SerializeField]
		private float m_GravityMultiplier = 2f;

		[SerializeField]
		private float m_RunCycleLegOffset = 0.2f;

		[SerializeField]
		private float m_MoveSpeedMultiplier = 1f;

		[SerializeField]
		private float m_AnimSpeedMultiplier = 1f;

		[SerializeField]
		private float m_GroundCheckDistance = 0.1f;

		private Rigidbody m_Rigidbody;

		private Animator m_Animator;

		private bool m_IsGrounded;

		private float m_OrigGroundCheckDistance;

		private const float k_Half = 0.5f;

		private float m_TurnAmount;

		private float m_ForwardAmount;

		private Vector3 m_GroundNormal;

		public bool Jump { get; set; }

		public bool Shift { get; set; }

		private void Start()
		{
			m_Animator = GetComponent<Animator>();
			m_Rigidbody = GetComponent<Rigidbody>();
			m_Rigidbody.constraints = RigidbodyConstraints.FreezeRotation;
			m_OrigGroundCheckDistance = m_GroundCheckDistance;
		}

		public void Move(Vector3 move, bool directional)
		{
			if (base.isActiveAndEnabled)
			{
				if (Shift)
				{
					move *= 0.5f;
				}
				if (move.magnitude > 1f)
				{
					move.Normalize();
				}
				move = base.transform.InverseTransformDirection(move);
				CheckGroundStatus();
				move = Vector3.ProjectOnPlane(move, m_GroundNormal);
				m_TurnAmount = Mathf.Atan2(move.x, move.z);
				m_ForwardAmount = move.z;
				ApplyExtraTurnRotation();
				if (m_IsGrounded)
				{
					HandleGroundedMovement(Jump);
				}
				else
				{
					HandleAirborneMovement();
				}
				UpdateAnimator(move);
			}
		}

		private void UpdateAnimator(Vector3 move)
		{
			if (m_Animator.isActiveAndEnabled)
			{
				m_Animator.SetFloat("Forward", m_ForwardAmount, 0.1f, Time.deltaTime);
				m_Animator.SetFloat("Turn", m_TurnAmount, 0.1f, Time.deltaTime);
				m_Animator.SetBool("OnGround", m_IsGrounded);
				if (!m_IsGrounded)
				{
					m_Animator.SetFloat("Jump", m_Rigidbody.velocity.y);
				}
				float value = (float)((Mathf.Repeat(m_Animator.GetCurrentAnimatorStateInfo(0).normalizedTime + m_RunCycleLegOffset, 1f) < 0.5f) ? 1 : (-1)) * m_ForwardAmount;
				if (m_IsGrounded)
				{
					m_Animator.SetFloat("JumpLeg", value);
				}
				if (m_IsGrounded && move.magnitude > 0f)
				{
					m_Animator.speed = m_AnimSpeedMultiplier;
				}
				else
				{
					m_Animator.speed = 1f;
				}
			}
		}

		private void HandleAirborneMovement()
		{
			Vector3 force = Physics.gravity * m_GravityMultiplier - Physics.gravity;
			m_Rigidbody.AddForce(force);
			m_GroundCheckDistance = ((m_Rigidbody.velocity.y < 0f) ? m_OrigGroundCheckDistance : 0.01f);
		}

		private void HandleGroundedMovement(bool jump)
		{
			if (jump && m_Animator.GetCurrentAnimatorStateInfo(0).IsName("Grounded"))
			{
				m_Rigidbody.velocity = new Vector3(m_Rigidbody.velocity.x, m_JumpPower, m_Rigidbody.velocity.z);
				m_IsGrounded = false;
				m_Animator.applyRootMotion = false;
				m_GroundCheckDistance = 0.1f;
			}
		}

		private void ApplyExtraTurnRotation()
		{
			float num = Mathf.Lerp(m_StationaryTurnSpeed, m_MovingTurnSpeed, m_ForwardAmount);
			base.transform.Rotate(0f, m_TurnAmount * num * Time.deltaTime, 0f);
		}

		public void OnAnimatorMove()
		{
			if (m_IsGrounded && Time.deltaTime > 0f)
			{
				Vector3 velocity = m_Animator.deltaPosition * m_MoveSpeedMultiplier / Time.deltaTime;
				velocity.y = m_Rigidbody.velocity.y;
				m_Rigidbody.velocity = velocity;
			}
		}

		private void CheckGroundStatus()
		{
			if (Physics.Raycast(base.transform.position + Vector3.up * 0.1f, Vector3.down, out var hitInfo, m_GroundCheckDistance))
			{
				m_GroundNormal = hitInfo.normal;
				m_IsGrounded = true;
				m_Animator.applyRootMotion = true;
			}
			else
			{
				m_IsGrounded = false;
				m_GroundNormal = Vector3.up;
				m_Animator.applyRootMotion = false;
			}
		}
	}
}
namespace MalbersAnimations.Utilities
{
	public class CommentB : StateMachineBehaviour
	{
		[Multiline]
		public string text;
	}
	public class EffectManager : MonoBehaviour, IAnimatorListener
	{
		public List<Effect> Effects;

		private void Awake()
		{
			foreach (Effect effect in Effects)
			{
				effect.Owner = base.transform;
				if (!effect.instantiate && (bool)effect.effect)
				{
					effect.Instance = effect.effect;
				}
			}
		}

		public virtual void PlayEffect(int ID)
		{
			List<Effect> list = Effects.FindAll((Effect effect) => effect.ID == ID && effect.active);
			if (list == null)
			{
				return;
			}
			foreach (Effect item in list)
			{
				Play(item);
			}
		}

		private IEnumerator IPlayEffect(Effect e)
		{
			if (e.delay > 0f)
			{
				yield return new WaitForSeconds(e.delay);
			}
			yield return new WaitForEndOfFrame();
			if (e.instantiate)
			{
				e.Instance = UnityEngine.Object.Instantiate(e.effect);
				e.effect.gameObject.SetActive(value: false);
			}
			else
			{
				e.Instance = e.effect;
			}
			if ((bool)e.Instance && (bool)e.root)
			{
				e.Instance.transform.position = e.root.position;
				e.Instance.gameObject.SetActive(value: true);
			}
			TrailRenderer componentInChildren = e.Instance.GetComponentInChildren<TrailRenderer>();
			if ((bool)componentInChildren)
			{
				componentInChildren.Clear();
			}
			e.Instance.transform.localScale = Vector3.Scale(e.Instance.transform.localScale, e.ScaleMultiplier);
			e.OnPlay.Invoke();
			if ((bool)e.root)
			{
				if (e.isChild)
				{
					e.Instance.transform.parent = e.root;
				}
				if (e.useRootRotation)
				{
					e.Instance.transform.rotation = e.root.rotation;
				}
			}
			e.Instance.transform.localPosition += e.PositionOffset;
			e.Instance.transform.localRotation *= Quaternion.Euler(e.RotationOffset);
			if ((bool)e.Modifier)
			{
				e.Modifier.StartEffect(e);
			}
			StartCoroutine(Life(e));
			yield return null;
		}

		private IEnumerator Life(Effect e)
		{
			if (e.life > 0f)
			{
				yield return new WaitForSeconds(e.life);
				if ((bool)e.Modifier)
				{
					e.Modifier.StopEffect(e);
				}
				e.OnStop.Invoke();
				if (e.instantiate)
				{
					UnityEngine.Object.Destroy(e.Instance);
				}
			}
			yield return null;
		}

		protected virtual void Play(Effect effect)
		{
			if (effect.effect == null)
			{
				return;
			}
			if ((bool)effect.Modifier)
			{
				effect.Modifier.AwakeEffect(effect);
			}
			if (effect.toggleable)
			{
				effect.On = !effect.On;
				if (effect.On)
				{
					StartCoroutine(IPlayEffect(effect));
				}
				else
				{
					effect.OnStop.Invoke();
				}
			}
			else
			{
				StartCoroutine(IPlayEffect(effect));
			}
		}

		public virtual void OnAnimatorBehaviourMessage(string message, object value)
		{
			this.InvokeWithParams(message, value);
		}

		public virtual void _DisableEffect(string name)
		{
			List<Effect> list = Effects.FindAll((Effect effect) => effect.Name.ToUpper() == name.ToUpper());
			if (list != null)
			{
				foreach (Effect item in list)
				{
					item.active = false;
				}
				return;
			}
			UnityEngine.Debug.LogWarning("No effect with the name: " + name + " was found");
		}

		public virtual void _DisableEffect(int ID)
		{
			List<Effect> list = Effects.FindAll((Effect effect) => effect.ID == ID);
			if (list != null)
			{
				foreach (Effect item in list)
				{
					item.active = false;
				}
				return;
			}
			UnityEngine.Debug.LogWarning("No effect with the ID: " + ID + " was found");
		}

		public virtual void _EnableEffect(string name)
		{
			List<Effect> list = Effects.FindAll((Effect effect) => effect.Name.ToUpper() == name.ToUpper());
			if (list != null)
			{
				foreach (Effect item in list)
				{
					item.active = true;
				}
				return;
			}
			UnityEngine.Debug.LogWarning("No effect with the name: " + name + " was found");
		}

		public virtual void _EnableEffect(int ID)
		{
			List<Effect> list = Effects.FindAll((Effect effect) => effect.ID == ID);
			if (list != null)
			{
				foreach (Effect item in list)
				{
					item.active = true;
				}
				return;
			}
			UnityEngine.Debug.LogWarning("No effect with the ID: " + ID + " was found");
		}

		public virtual void _EnableEffectPrefab(int ID)
		{
			Effects.Find((Effect item) => item.ID == ID)?.Instance.SetActive(value: true);
		}

		public virtual void _DisableEffectPrefab(int ID)
		{
			Effects.Find((Effect item) => item.ID == ID)?.Instance.SetActive(value: false);
		}
	}
	[Serializable]
	public class Effect
	{
		public string Name = "EffectName";

		public int ID;

		public bool active = true;

		public Transform root;

		public bool isChild;

		public bool useRootRotation = true;

		public GameObject effect;

		public Vector3 RotationOffset;

		public Vector3 PositionOffset;

		public Vector3 ScaleMultiplier = Vector3.one;

		public float life = 10f;

		public float delay;

		public bool instantiate = true;

		public bool toggleable;

		public bool On;

		public EffectModifier Modifier;

		public UnityEvent OnPlay;

		public UnityEvent OnStop;

		protected Transform owner;

		protected GameObject instance;

		public Transform Owner
		{
			get
			{
				return owner;
			}
			set
			{
				owner = value;
			}
		}

		public GameObject Instance
		{
			get
			{
				return instance;
			}
			set
			{
				instance = value;
			}
		}
	}
	public class EffectModifier : ScriptableObject
	{
		[TextArea]
		public string Description = string.Empty;

		public virtual void AwakeEffect(Effect effect)
		{
		}

		public virtual void StartEffect(Effect effect)
		{
		}

		public virtual void StopEffect(Effect effect)
		{
		}
	}
	[CreateAssetMenu(menuName = "Malbers Animations/Effect Modifiers/FireBall")]
	public class FireBallEffectM : EffectModifier
	{
		public float velocity = 300f;

		private Rigidbody rb;

		private LookAt hasLookAt;

		public override void AwakeEffect(Effect effect)
		{
		}

		public override void StartEffect(Effect effect)
		{
			rb = effect.Instance.GetComponent<Rigidbody>();
			hasLookAt = effect.Owner.GetComponent<LookAt>();
			effect.Instance.SendMessage("SetOwner", effect.Owner.gameObject, SendMessageOptions.DontRequireReceiver);
			if ((bool)hasLookAt && hasLookAt.Active && hasLookAt.IsAiming)
			{
				rb.AddForce(hasLookAt.Direction.normalized * velocity);
				return;
			}
			Animator component = effect.Owner.GetComponent<Animator>();
			Vector3 vector = component.velocity.normalized;
			if ((double)component.velocity.magnitude < 0.1)
			{
				vector = effect.Owner.transform.forward;
			}
			rb.AddForce(vector * velocity);
		}
	}
	public class ActiveMeshes : MonoBehaviour
	{
		[SerializeField]
		public List<ActiveSMesh> Meshes = new List<ActiveSMesh>();

		[HideInInspector]
		[SerializeField]
		public bool showMeshesList = true;

		public bool random;

		public string AllIndex
		{
			get
			{
				string text = "";
				for (int i = 0; i < Meshes.Count; i++)
				{
					text = text + Meshes[i].Current + " ";
				}
				text.Remove(text.Length - 1);
				return text;
			}
			set
			{
				string[] array = value.Split(' ');
				for (int i = 0; i < Meshes.Count; i++)
				{
					if (array.Length > i && int.TryParse(array[i], out var result) && result != -1)
					{
						Meshes[i].ChangeMesh(result);
					}
				}
			}
		}

		private void Awake()
		{
			if (!random)
			{
				return;
			}
			foreach (ActiveSMesh mesh in Meshes)
			{
				mesh.ChangeMesh(UnityEngine.Random.Range(0, mesh.meshes.Length));
			}
		}

		public void SetActiveMeshesIndex(int[] MeshesIndex)
		{
			if (MeshesIndex.Length != Meshes.Count)
			{
				UnityEngine.Debug.LogError("Meshes Index array Lenghts don't match");
				return;
			}
			for (int i = 0; i < MeshesIndex.Length; i++)
			{
				Meshes[i].ChangeMesh(MeshesIndex[i]);
			}
		}

		public virtual void ChangeMesh(int index)
		{
			if (Meshes.Count > index)
			{
				Meshes[index].ChangeMesh();
			}
		}

		public virtual void ChangeMesh(int indexList, int IndexMesh)
		{
			if (indexList < 0)
			{
				indexList = 0;
			}
			indexList %= Meshes.Count;
			if (Meshes[indexList] != null)
			{
				Meshes[indexList].ChangeMesh(IndexMesh);
			}
		}

		public virtual void ChangeMesh(string name, bool next)
		{
			Meshes.Find((ActiveSMesh item) => item.Name == name)?.ChangeMesh(next);
		}

		public virtual void ChangeMesh(string name)
		{
			ChangeMesh(name, next: true);
		}

		public virtual void ChangeMesh(string name, int CurrentIndex)
		{
			Meshes.Find((ActiveSMesh item) => item.Name == name)?.ChangeMesh(CurrentIndex);
		}

		public virtual void ChangeMesh(int index, bool next)
		{
			Meshes[index].ChangeMesh(next);
		}

		public virtual void ChangeMesh(bool next = true)
		{
			foreach (ActiveSMesh mesh in Meshes)
			{
				mesh.ChangeMesh(next);
			}
		}

		public virtual ActiveSMesh GetActiveMesh(string name)
		{
			if (Meshes.Count == 0)
			{
				return null;
			}
			return Meshes.Find((ActiveSMesh item) => item.Name == name);
		}

		public virtual ActiveSMesh GetActiveMesh(int index)
		{
			if (Meshes.Count == 0)
			{
				return null;
			}
			if (index >= Meshes.Count)
			{
				index = 0;
			}
			if (index < 0)
			{
				index = Meshes.Count - 1;
			}
			return Meshes[index];
		}
	}
	[Serializable]
	public class ActiveSMesh
	{
		[HideInInspector]
		public string Name = "NameHere";

		public Transform[] meshes;

		[HideInInspector]
		[SerializeField]
		public int Current;

		[Space]
		[Header("Invoked when the Active mesh is changed")]
		public TransformEvent OnActiveMesh = new TransformEvent();

		public virtual void ChangeMesh(bool next = true)
		{
			if (next)
			{
				Current++;
			}
			else
			{
				Current--;
			}
			if (Current >= meshes.Length)
			{
				Current = 0;
			}
			if (Current < 0)
			{
				Current = meshes.Length - 1;
			}
			Transform[] array = meshes;
			foreach (Transform transform in array)
			{
				if ((bool)transform)
				{
					transform.gameObject.SetActive(value: false);
				}
			}
			if ((bool)meshes[Current])
			{
				meshes[Current].gameObject.SetActive(value: true);
				OnActiveMesh.Invoke(meshes[Current]);
			}
		}

		public virtual Transform GetCurrentActiveMesh()
		{
			return meshes[Current];
		}

		public virtual void ChangeMesh(int Index)
		{
			Current = Index - 1;
			ChangeMesh();
		}

		public void Set_by_BinaryIndex(int binaryCurrent)
		{
			int index = 0;
			for (int i = 0; i < meshes.Length; i++)
			{
				if (MalbersTools.IsBitActive(binaryCurrent, i))
				{
					index = i;
					break;
				}
			}
			ChangeMesh(index);
		}
	}
	public class AnimatorEventSounds : MonoBehaviour
	{
		public List<EventSound> m_EventSound;

		public AudioSource _audioSource;

		protected Animator anim;

		private void Start()
		{
			anim = GetComponent<Animator>();
			if (_audioSource == null)
			{
				_audioSource = base.gameObject.AddComponent<AudioSource>();
			}
			_audioSource.volume = 0f;
		}

		public virtual void PlaySound(AnimationEvent e)
		{
			if ((double)e.animatorClipInfo.weight < 0.1)
			{
				return;
			}
			EventSound eventSound = m_EventSound.Find((EventSound item) => item.name == e.stringParameter);
			if (eventSound == null)
			{
				return;
			}
			eventSound.VolumeWeight = e.animatorClipInfo.weight;
			if ((bool)anim)
			{
				_audioSource.pitch = anim.speed;
			}
			if (_audioSource.isPlaying)
			{
				if (eventSound.VolumeWeight * eventSound.volume > _audioSource.volume)
				{
					eventSound.PlayAudio(_audioSource);
				}
			}
			else
			{
				eventSound.PlayAudio(_audioSource);
			}
		}
	}
	[Serializable]
	public class EventSound
	{
		public string name = "Name Here";

		public AudioClip[] Clips;

		public float volume = 1f;

		public float pitch = 1f;

		protected float volumeWeight = 1f;

		public float VolumeWeight
		{
			get
			{
				return volumeWeight;
			}
			set
			{
				volumeWeight = value;
			}
		}

		public void PlayAudio(AudioSource audio)
		{
			if (!(audio == null) && Clips != null && Clips.Length != 0)
			{
				audio.spatialBlend = 1f;
				audio.clip = Clips[UnityEngine.Random.Range(0, Clips.Length)];
				audio.pitch *= pitch;
				audio.volume = Mathf.Clamp01(volume * VolumeWeight);
				audio.Play();
			}
		}
	}
	public class BlendShape : MonoBehaviour
	{
		public SkinnedMeshRenderer mesh;

		public SkinnedMeshRenderer[] LODs;

		[Range(0f, 100f)]
		public float[] blendShapes;

		public bool random;

		public int PinnedShape;

		public bool HasBlendShapes
		{
			get
			{
				if ((bool)mesh)
				{
					return mesh.sharedMesh.blendShapeCount > 0;
				}
				return false;
			}
		}

		public virtual float[] GetBlendShapeValues()
		{
			if (HasBlendShapes)
			{
				float[] array = new float[mesh.sharedMesh.blendShapeCount];
				for (int i = 0; i < array.Length; i++)
				{
					array[i] = mesh.GetBlendShapeWeight(i);
				}
				return array;
			}
			return null;
		}

		private void Awake()
		{
			if (random)
			{
				RandomizeShapes();
			}
		}

		private void Reset()
		{
			mesh = GetComponentInChildren<SkinnedMeshRenderer>();
			if ((bool)mesh)
			{
				blendShapes = new float[mesh.sharedMesh.blendShapeCount];
				for (int i = 0; i < blendShapes.Length; i++)
				{
					blendShapes[i] = mesh.GetBlendShapeWeight(i);
				}
			}
		}

		public virtual void RandomizeShapes()
		{
			if (HasBlendShapes)
			{
				for (int i = 0; i < blendShapes.Length; i++)
				{
					blendShapes[i] = UnityEngine.Random.Range(0, 100);
					mesh.SetBlendShapeWeight(i, blendShapes[i]);
				}
				UpdateLODs();
			}
		}

		public virtual void SetBlendShape(string name, float value)
		{
			if (HasBlendShapes)
			{
				PinnedShape = mesh.sharedMesh.GetBlendShapeIndex(name);
				if (PinnedShape != -1)
				{
					mesh.SetBlendShapeWeight(PinnedShape, value);
				}
			}
		}

		public virtual void SetBlendShape(int index, float value)
		{
			if (HasBlendShapes)
			{
				mesh.SetBlendShapeWeight(PinnedShape = index, value);
			}
		}

		public virtual void _PinShape(string name)
		{
			PinnedShape = mesh.sharedMesh.GetBlendShapeIndex(name);
		}

		public virtual void _PinShape(int index)
		{
			PinnedShape = index;
		}

		public virtual void _PinnedShapeSetValue(float value)
		{
			if (PinnedShape != -1)
			{
				value = Mathf.Clamp(value, 0f, 100f);
				blendShapes[PinnedShape] = value;
				mesh.SetBlendShapeWeight(PinnedShape, value);
				UpdateLODs(PinnedShape);
			}
		}

		public virtual void UpdateBlendShapes()
		{
			if ((bool)mesh && blendShapes != null)
			{
				if (blendShapes.Length != mesh.sharedMesh.blendShapeCount)
				{
					blendShapes = new float[mesh.sharedMesh.blendShapeCount];
				}
				for (int i = 0; i < blendShapes.Length; i++)
				{
					mesh.SetBlendShapeWeight(i, blendShapes[i]);
				}
				UpdateLODs();
			}
		}

		protected virtual void UpdateLODs()
		{
			for (int i = 0; i < blendShapes.Length; i++)
			{
				UpdateLODs(i);
			}
		}

		protected virtual void UpdateLODs(int index)
		{
			if (LODs != null)
			{
				SkinnedMeshRenderer[] lODs = LODs;
				for (int i = 0; i < lODs.Length; i++)
				{
					lODs[i].SetBlendShapeWeight(index, blendShapes[index]);
				}
			}
		}
	}
	[Serializable]
	public class MeshBlendShapes
	{
		public string NameID;

		public SkinnedMeshRenderer mesh;

		[Range(0f, 100f)]
		public float[] blendShapes;

		public bool HasBlendShapes
		{
			get
			{
				if ((bool)mesh)
				{
					return mesh.sharedMesh.blendShapeCount > 0;
				}
				return false;
			}
		}

		public virtual void UpdateBlendShapes()
		{
			if (mesh != null && blendShapes != null)
			{
				if (NameID == string.Empty)
				{
					NameID = mesh.name;
				}
				if (blendShapes.Length != mesh.sharedMesh.blendShapeCount)
				{
					blendShapes = new float[mesh.sharedMesh.blendShapeCount];
				}
				for (int i = 0; i < blendShapes.Length; i++)
				{
					mesh.SetBlendShapeWeight(i, blendShapes[i]);
				}
			}
		}

		public virtual float[] GetBlendShapeValues()
		{
			if (HasBlendShapes)
			{
				float[] array = new float[mesh.sharedMesh.blendShapeCount];
				for (int i = 0; i < array.Length; i++)
				{
					array[i] = mesh.GetBlendShapeWeight(i);
				}
				return array;
			}
			return null;
		}

		public void SetRandom()
		{
			if (HasBlendShapes)
			{
				for (int i = 0; i < blendShapes.Length; i++)
				{
					blendShapes[i] = UnityEngine.Random.Range(0, 100);
					mesh.SetBlendShapeWeight(i, blendShapes[i]);
				}
			}
		}

		public void SetBlendShape(string name, float value)
		{
			if (HasBlendShapes)
			{
				int blendShapeIndex = mesh.sharedMesh.GetBlendShapeIndex(name);
				if (blendShapeIndex != -1)
				{
					mesh.SetBlendShapeWeight(blendShapeIndex, value);
				}
			}
		}

		public void SetBlendShape(int index, float value)
		{
			if (HasBlendShapes)
			{
				mesh.SetBlendShapeWeight(index, value);
			}
		}
	}
	public class BlendShapes : MonoBehaviour
	{
		[SerializeField]
		public List<MeshBlendShapes> Shapes;

		public bool random;

		private void Awake()
		{
			if (random)
			{
				RandomShapes();
			}
		}

		public virtual void RandomShapes()
		{
			foreach (MeshBlendShapes shape in Shapes)
			{
				shape.SetRandom();
			}
		}

		public virtual void UpdateBlendShapes()
		{
			foreach (MeshBlendShapes shape in Shapes)
			{
				shape.UpdateBlendShapes();
			}
		}

		public virtual void SetBlendShape(string name, float value)
		{
			foreach (MeshBlendShapes shape in Shapes)
			{
				shape.SetBlendShape(name, value);
			}
		}

		public virtual void SetBlendShape(int index, float value)
		{
			foreach (MeshBlendShapes shape in Shapes)
			{
				shape.SetBlendShape(base.name, value);
			}
		}
	}
	public class BlinkEyes : MonoBehaviour, IAnimatorListener
	{
		public Animator animator;

		public string parameter;

		public virtual void Eyes(int ID)
		{
			if ((bool)animator)
			{
				animator.SetInteger(parameter, ID);
			}
		}

		public virtual void OnAnimatorBehaviourMessage(string message, object value)
		{
			this.InvokeWithParams(message, value);
		}
	}
	public class Comment : MonoBehaviour
	{
		[Multiline]
		public string text;
	}
	[Serializable]
	public struct DeltaTransform
	{
		public Vector3 LocalPosition;

		public Vector3 LocalEulerAngles;

		public Vector3 Position;

		public Vector3 EulerAngles;

		public Quaternion Rotation;

		public Quaternion LocalRotation;

		public Vector3 lossyScale;

		public Vector3 LocalScale;

		public void StoreTransform(Transform transform)
		{
			if (!(transform == null))
			{
				Position = transform.position;
				LocalPosition = transform.localPosition;
				EulerAngles = transform.eulerAngles;
				Rotation = transform.rotation;
				LocalEulerAngles = transform.localEulerAngles;
				LocalRotation = transform.localRotation;
				lossyScale = transform.lossyScale;
				LocalScale = transform.localScale;
			}
		}

		public void RestoreTransform(Transform transform)
		{
			transform.position = Position;
			transform.rotation = Rotation;
			transform.localScale = LocalScale;
		}

		public void RestoreLocalTransform(Transform transform)
		{
			transform.localPosition = LocalPosition;
			transform.localRotation = LocalRotation;
			transform.localScale = LocalScale;
		}
	}
	[AttributeUsage(AttributeTargets.Field, AllowMultiple = true, Inherited = true)]
	public class FlagAttribute : PropertyAttribute
	{
		public string enumName;

		public FlagAttribute()
		{
		}

		public FlagAttribute(string name)
		{
			enumName = name;
		}
	}
	[ExecuteInEditMode]
	public class LinkedBlendShapes : MonoBehaviour
	{
		public SkinnedMeshRenderer master;

		public SkinnedMeshRenderer slave;

		private void Start()
		{
			base.enabled = false;
		}

		private void Update()
		{
			UpdateSlaveBlendShapes();
		}

		public virtual void UpdateSlaveBlendShapes()
		{
			if ((bool)master && (bool)slave && (bool)slave.sharedMesh)
			{
				for (int i = 0; i < slave.sharedMesh.blendShapeCount; i++)
				{
					slave.SetBlendShapeWeight(i, master.GetBlendShapeWeight(i));
				}
			}
		}
	}
	[Serializable]
	public class BoneRotation
	{
		public Transform bone;

		public Vector3 offset = new Vector3(0f, -90f, -90f);

		[Range(0f, 1f)]
		public float weight = 1f;

		internal Quaternion initialRotation;
	}
	public class LookAt : MonoBehaviour, IAnimatorListener
	{
		[Tooltip("Global LookAt Activation")]
		[SerializeField]
		private bool active = true;

		[Tooltip("The Animations allows the LookAt to be enable/disabled")]
		public bool AnimationActive = true;

		[Space]
		[Tooltip("What layers the Look At Rays should ignore")]
		public LayerMask Ignore = 4;

		public bool UseCamera;

		public Transform Target;

		[Space]
		public float LimitAngle = 80f;

		public float Smoothness = 5f;

		public Vector3 UpVector = Vector3.up;

		private float currentSmoothness;

		[Space]
		public BoneRotation[] Bones;

		private Transform cam;

		protected float angle;

		protected Vector3 direction;

		public bool debug = true;

		private bool hasTarget;

		private RaycastHit aimHit;

		private bool AnimatorOnAnimatePhysics;

		public Vector3 Direction
		{
			get
			{
				return direction;
			}
			set
			{
				direction = value;
			}
		}

		public bool IsAiming
		{
			get
			{
				if (angle < LimitAngle && Active && AnimationActive)
				{
					return hasTarget;
				}
				return false;
			}
		}

		public RaycastHit AimHit
		{
			get
			{
				return aimHit;
			}
			set
			{
				aimHit = value;
			}
		}

		public bool Active
		{
			get
			{
				return active;
			}
			set
			{
				active = value;
			}
		}

		private void Awake()
		{
			if (Camera.main != null)
			{
				cam = Camera.main.transform;
			}
			Animator component = GetComponent<Animator>();
			AnimatorOnAnimatePhysics = (bool)component && component.updateMode == AnimatorUpdateMode.AnimatePhysics;
			if (!AnimatorOnAnimatePhysics)
			{
				BoneRotation[] bones = Bones;
				foreach (BoneRotation obj in bones)
				{
					obj.initialRotation = obj.bone.transform.localRotation;
				}
			}
		}

		private void LateUpdate()
		{
			BoneRotation[] bones = Bones;
			foreach (BoneRotation obj in bones)
			{
				obj.initialRotation = obj.bone.transform.localRotation;
			}
			LookAtBoneSet();
		}

		public void EnableLookAt(bool value)
		{
			AnimationActive = value;
		}

		private void LookAtBoneSet()
		{
			if (!Target && !cam)
			{
				return;
			}
			hasTarget = false;
			if (UseCamera || (bool)Target)
			{
				hasTarget = true;
			}
			angle = Vector3.Angle(base.transform.forward, direction);
			currentSmoothness = Mathf.Lerp(currentSmoothness, IsAiming ? 1 : 0, Time.deltaTime * Smoothness);
			if (currentSmoothness > 0.9999f)
			{
				currentSmoothness = 1f;
			}
			if (currentSmoothness < 0.0001f)
			{
				currentSmoothness = 0f;
			}
			for (int i = 0; i < Bones.Length; i++)
			{
				BoneRotation boneRotation = Bones[i];
				if (!boneRotation.bone)
				{
					continue;
				}
				Vector3 b = base.transform.forward;
				if (UseCamera && (bool)cam)
				{
					b = cam.forward;
					aimHit = MalbersTools.RayCastHitToCenter(boneRotation.bone, ~(int)Ignore);
					if ((bool)aimHit.collider)
					{
						b = MalbersTools.DirectionTarget(boneRotation.bone.position, aimHit.point);
					}
				}
				if ((bool)Target)
				{
					b = MalbersTools.DirectionTarget(boneRotation.bone, Target);
				}
				direction = Vector3.Lerp(direction, b, Time.deltaTime * Smoothness);
				if (currentSmoothness == 0f)
				{
					break;
				}
				if (debug && i == Bones.Length - 1)
				{
					UnityEngine.Debug.DrawRay(boneRotation.bone.position, direction * 15f, Color.green);
				}
				Quaternion b2 = Quaternion.LookRotation(direction, UpVector) * Quaternion.Euler(boneRotation.offset);
				Quaternion rotation = Quaternion.Lerp(boneRotation.bone.rotation, b2, boneRotation.weight * currentSmoothness);
				boneRotation.bone.rotation = rotation;
			}
		}

		public virtual void NoTarget()
		{
			Target = null;
		}

		public virtual void OnAnimatorBehaviourMessage(string message, object value)
		{
			this.InvokeWithParams(message, value);
		}

		private void OnDrawGizmos()
		{
			if (UnityEngine.Application.isPlaying && IsAiming)
			{
				Gizmos.color = Color.red;
				Gizmos.DrawSphere(aimHit.point, 0.1f);
			}
		}
	}
	public class LookAtTrigger : MonoBehaviour
	{
		private void OnTriggerEnter(Collider other)
		{
			if (!other.isTrigger)
			{
				LookAt componentInParent = other.GetComponentInParent<LookAt>();
				if ((bool)componentInParent)
				{
					componentInParent.Active = true;
					componentInParent.Target = base.transform;
				}
			}
		}

		private void OnTriggerExit(Collider other)
		{
			if (!other.isTrigger)
			{
				LookAt componentInParent = other.GetComponentInParent<LookAt>();
				if ((bool)componentInParent)
				{
					componentInParent.Target = null;
				}
			}
		}
	}
	public static class MalbersTools
	{
		public static Vector3 NullVector = new Vector3(float.MinValue, float.MinValue, float.MinValue);

		public static bool CollidersLayer(Collider collider, LayerMask layerMask)
		{
			return (int)layerMask == ((int)layerMask | (1 << collider.gameObject.layer));
		}

		public static bool Layer_in_LayerMask(int layer, LayerMask layerMask)
		{
			return (int)layerMask == ((int)layerMask | (1 << layer));
		}

		public static T GetInstance<T>(string name) where T : ScriptableObject
		{
			return null;
		}

		public static void DebugCross(Vector3 center, float radius, Color color)
		{
			UnityEngine.Debug.DrawLine(center - new Vector3(0f, radius, 0f), center + new Vector3(0f, radius, 0f), color);
			UnityEngine.Debug.DrawLine(center - new Vector3(radius, 0f, 0f), center + new Vector3(radius, 0f, 0f), color);
			UnityEngine.Debug.DrawLine(center - new Vector3(0f, 0f, radius), center + new Vector3(0f, 0f, radius), color);
		}

		public static void DebugPlane(Vector3 center, float radius, Color color, bool cross = false)
		{
			UnityEngine.Debug.DrawLine(center - new Vector3(radius, 0f, 0f), center + new Vector3(0f, 0f, 0f - radius), color);
			UnityEngine.Debug.DrawLine(center - new Vector3(radius, 0f, 0f), center + new Vector3(0f, 0f, radius), color);
			UnityEngine.Debug.DrawLine(center + new Vector3(0f, 0f, radius), center - new Vector3(0f - radius, 0f, 0f), color);
			UnityEngine.Debug.DrawLine(center - new Vector3(0f, 0f, radius), center + new Vector3(radius, 0f, 0f), color);
			if (cross)
			{
				UnityEngine.Debug.DrawLine(center - new Vector3(radius, 0f, 0f), center + new Vector3(radius, 0f, 0f), color);
				UnityEngine.Debug.DrawLine(center - new Vector3(0f, 0f, radius), center + new Vector3(0f, 0f, radius), color);
			}
		}

		public static void DebugTriangle(Vector3 center, float radius, Color color)
		{
			UnityEngine.Debug.DrawLine(center - new Vector3(radius, 0f, 0f), center + new Vector3(radius, 0f, 0f), color);
			UnityEngine.Debug.DrawLine(center - new Vector3(0f, 0f, radius), center + new Vector3(0f, 0f, radius), color);
			UnityEngine.Debug.DrawLine(center - new Vector3(0f, 0f - radius, 0f), center + new Vector3(radius, 0f, 0f), color);
			UnityEngine.Debug.DrawLine(center - new Vector3(0f, 0f - radius, 0f), center + new Vector3(0f - radius, 0f, 0f), color);
			UnityEngine.Debug.DrawLine(center - new Vector3(0f, 0f - radius, 0f), center + new Vector3(0f, 0f, radius), color);
			UnityEngine.Debug.DrawLine(center - new Vector3(0f, 0f - radius, 0f), center + new Vector3(0f, 0f, 0f - radius), color);
			UnityEngine.Debug.DrawLine(center - new Vector3(radius, 0f, 0f), center + new Vector3(0f, 0f, 0f - radius), color);
			UnityEngine.Debug.DrawLine(center - new Vector3(radius, 0f, 0f), center + new Vector3(0f, 0f, radius), color);
			UnityEngine.Debug.DrawLine(center + new Vector3(0f, 0f, radius), center - new Vector3(0f - radius, 0f, 0f), color);
			UnityEngine.Debug.DrawLine(center - new Vector3(0f, 0f, radius), center + new Vector3(radius, 0f, 0f), color);
		}

		public static void SetLayer(Transform root, int layer)
		{
			root.gameObject.layer = layer;
			foreach (Transform item in root)
			{
				SetLayer(item, layer);
			}
		}

		public static Vector3 DirectionTarget(Transform origin, Transform Target, bool normalized = true)
		{
			if (normalized)
			{
				return (Target.position - origin.position).normalized;
			}
			return Target.position - origin.position;
		}

		public static string Serialize<T>(this T toSerialize)
		{
			XmlSerializer xmlSerializer = new XmlSerializer(typeof(T));
			StringWriter stringWriter = new StringWriter();
			xmlSerializer.Serialize(stringWriter, toSerialize);
			return stringWriter.ToString();
		}

		public static bool IsBitActive(int IntValue, int index)
		{
			return (IntValue & (1 << index)) != 0;
		}

		public static T Deserialize<T>(this string toDeserialize)
		{
			XmlSerializer xmlSerializer = new XmlSerializer(typeof(T));
			StringReader textReader = new StringReader(toDeserialize);
			return (T)xmlSerializer.Deserialize(textReader);
		}

		public static Vector3 DirectionTarget(Vector3 origin, Vector3 Target, bool normalized = true)
		{
			if (normalized)
			{
				return (Target - origin).normalized;
			}
			return Target - origin;
		}

		public static float HorizontalAngle(Vector3 From, Vector3 To, Vector3 Up)
		{
			float num = Mathf.Atan2(Vector3.Dot(Up, Vector3.Cross(From, To)), Vector3.Dot(From, To));
			num *= 57.29578f;
			if (Mathf.Abs(num) < 0.0001f)
			{
				num = 0f;
			}
			return num;
		}

		public static Vector3 DirectionFromCamera(Transform origin, float x, float y, out RaycastHit hit, LayerMask hitmask)
		{
			Camera main = Camera.main;
			hit = default(RaycastHit);
			Ray ray = main.ScreenPointToRay(new Vector2(x * (float)main.pixelWidth, y * (float)main.pixelHeight));
			Vector3 result = ray.direction;
			hit.distance = float.MaxValue;
			RaycastHit[] array = Physics.RaycastAll(ray, 100f, hitmask);
			for (int i = 0; i < array.Length; i++)
			{
				RaycastHit raycastHit = array[i];
				if (!(raycastHit.transform.root == origin.transform.root) && !(Vector3.Distance(main.transform.position, raycastHit.point) < Vector3.Distance(main.transform.position, origin.position)) && hit.distance > raycastHit.distance)
				{
					hit = raycastHit;
				}
			}
			if (hit.distance != float.MaxValue)
			{
				result = (hit.point - origin.position).normalized;
			}
			return result;
		}

		public static Vector3 DirectionFromCamera(Transform origin, Vector3 ScreenPoint, out RaycastHit hit, LayerMask hitmask)
		{
			Camera main = Camera.main;
			Ray ray = main.ScreenPointToRay(ScreenPoint);
			Vector3 result = ray.direction;
			hit = new RaycastHit
			{
				distance = float.MaxValue,
				point = ray.GetPoint(100f)
			};
			RaycastHit[] array = Physics.RaycastAll(ray, 100f, hitmask);
			for (int i = 0; i < array.Length; i++)
			{
				RaycastHit raycastHit = array[i];
				if (!(raycastHit.transform.root == origin.transform.root) && !(Vector3.Distance(main.transform.position, raycastHit.point) < Vector3.Distance(main.transform.position, origin.position)) && hit.distance > raycastHit.distance)
				{
					hit = raycastHit;
				}
			}
			if (hit.distance != float.MaxValue)
			{
				result = (hit.point - origin.position).normalized;
			}
			return result;
		}

		public static Vector3 DirectionFromCamera(Transform origin)
		{
			RaycastHit hit;
			return DirectionFromCamera(origin, 0.5f * (float)Screen.width, 0.5f * (float)Screen.height, out hit, -1);
		}

		public static Vector3 DirectionFromCamera(Transform origin, LayerMask layerMask)
		{
			RaycastHit hit;
			return DirectionFromCamera(origin, 0.5f * (float)Screen.width, 0.5f * (float)Screen.height, out hit, layerMask);
		}

		public static Vector3 DirectionFromCamera(Transform origin, Vector3 ScreenCenter)
		{
			RaycastHit hit;
			return DirectionFromCamera(origin, ScreenCenter, out hit, -1);
		}

		public static RaycastHit RayCastHitToCenter(Transform origin, Vector3 ScreenCenter, int layerMask = -1)
		{
			Camera main = Camera.main;
			RaycastHit result = default(RaycastHit);
			Ray ray = main.ScreenPointToRay(ScreenCenter);
			_ = ray.direction;
			result.distance = float.MaxValue;
			RaycastHit[] array = Physics.RaycastAll(ray, 100f, layerMask);
			for (int i = 0; i < array.Length; i++)
			{
				RaycastHit raycastHit = array[i];
				if (!(raycastHit.transform.root == origin.transform.root) && !(Vector3.Distance(main.transform.position, raycastHit.point) < Vector3.Distance(main.transform.position, origin.position)) && result.distance > raycastHit.distance)
				{
					result = raycastHit;
				}
			}
			return result;
		}

		public static Vector3 DirectionFromCameraNoRayCast(Vector3 ScreenCenter)
		{
			return Camera.main.ScreenPointToRay(ScreenCenter).direction;
		}

		public static RaycastHit RayCastHitToCenter(Transform origin)
		{
			return RayCastHitToCenter(origin, new Vector3(0.5f * (float)Screen.width, 0.5f * (float)Screen.height));
		}

		public static RaycastHit RayCastHitToCenter(Transform origin, LayerMask layerMask)
		{
			return RayCastHitToCenter(origin, new Vector3(0.5f * (float)Screen.width, 0.5f * (float)Screen.height), layerMask);
		}

		public static RaycastHit RayCastHitToCenter(Transform origin, int layerMask)
		{
			return RayCastHitToCenter(origin, new Vector3(0.5f * (float)Screen.width, 0.5f * (float)Screen.height), layerMask);
		}

		public static float AngleAroundAxis(Vector3 dirA, Vector3 dirB, Vector3 axis)
		{
			dirA -= Vector3.Project(dirA, axis);
			dirB -= Vector3.Project(dirB, axis);
			return Vector3.Angle(dirA, dirB) * (float)((!(Vector3.Dot(axis, Vector3.Cross(dirA, dirB)) < 0f)) ? 1 : (-1));
		}

		public static Vector3 ClosestPointOnLine(Vector3 vA, Vector3 vB, Vector3 vPoint)
		{
			Vector3 rhs = vPoint - vA;
			Vector3 normalized = (vB - vA).normalized;
			float num = Vector3.Distance(vA, vB);
			float num2 = Vector3.Dot(normalized, rhs);
			if (num2 <= 0f)
			{
				return vA;
			}
			if (num2 >= num)
			{
				return vB;
			}
			Vector3 vector = normalized * num2;
			return vA + vector;
		}

		public static IEnumerator AlignTransform_Position(Transform t1, Vector3 NewPosition, float time, AnimationCurve curve = null)
		{
			float elapsedTime = 0f;
			Vector3 CurrentPos = t1.position;
			while (time > 0f && elapsedTime <= time)
			{
				float t2 = curve?.Evaluate(elapsedTime / time) ?? (elapsedTime / time);
				t1.position = Vector3.LerpUnclamped(CurrentPos, NewPosition, t2);
				elapsedTime += Time.deltaTime;
				yield return null;
			}
			t1.position = NewPosition;
		}

		public static IEnumerator AlignTransform_Rotation(Transform t1, Quaternion NewRotation, float time, AnimationCurve curve = null)
		{
			float elapsedTime = 0f;
			Quaternion CurrentRot = t1.rotation;
			while (time > 0f && elapsedTime <= time)
			{
				float t2 = curve?.Evaluate(elapsedTime / time) ?? (elapsedTime / time);
				t1.rotation = Quaternion.LerpUnclamped(CurrentRot, NewRotation, t2);
				elapsedTime += Time.deltaTime;
				yield return null;
			}
			t1.rotation = NewRotation;
		}

		public static Vector3 Quaternion_to_AngularVelocity(Quaternion quaternion)
		{
			quaternion.ToAngleAxis(out var angle, out var axis);
			return axis * angle * ((float)Math.PI / 180f) / Time.deltaTime;
		}

		public static IEnumerator AlignTransformsC(Transform t1, Transform t2, float time, bool Position = true, bool Rotation = true, AnimationCurve curve = null)
		{
			float elapsedTime = 0f;
			Vector3 CurrentPos = t1.position;
			Quaternion CurrentRot = t1.rotation;
			while (time > 0f && elapsedTime <= time)
			{
				float t3 = curve?.Evaluate(elapsedTime / time) ?? (elapsedTime / time);
				if (Position)
				{
					t1.position = Vector3.LerpUnclamped(CurrentPos, t2.position, t3);
				}
				if (Rotation)
				{
					t1.rotation = Quaternion.SlerpUnclamped(CurrentRot, t2.rotation, t3);
				}
				elapsedTime += Time.deltaTime;
				yield return null;
			}
			if (Position)
			{
				t1.position = t2.position;
			}
			if (Rotation)
			{
				t1.rotation = t2.rotation;
			}
		}

		public static IEnumerator AlignTransformsC(Transform t1, Quaternion rotation, float time, AnimationCurve curve = null)
		{
			float elapsedTime = 0f;
			Quaternion CurrentRot = t1.rotation;
			while (time > 0f && elapsedTime <= time)
			{
				float t2 = curve?.Evaluate(elapsedTime / time) ?? (elapsedTime / time);
				t1.rotation = Quaternion.SlerpUnclamped(CurrentRot, rotation, t2);
				elapsedTime += Time.deltaTime;
				yield return null;
			}
			t1.rotation = rotation;
		}

		public static IEnumerator AlignLookAtTransform(Transform t1, Transform t2, float time, AnimationCurve curve = null)
		{
			float elapsedTime = 0f;
			Quaternion CurrentRot = t1.rotation;
			Vector3 normalized = (t2.position - t1.position).normalized;
			normalized.y = t1.forward.y;
			Quaternion FinalRot = Quaternion.LookRotation(normalized);
			while (time > 0f && elapsedTime <= time)
			{
				float t3 = curve?.Evaluate(elapsedTime / time) ?? (elapsedTime / time);
				t1.rotation = Quaternion.SlerpUnclamped(CurrentRot, FinalRot, t3);
				elapsedTime += Time.deltaTime;
				yield return null;
			}
			t1.rotation = FinalRot;
		}

		public static bool FindAnimatorParameter(Animator animator, AnimatorControllerParameterType type, string ParameterName)
		{
			AnimatorControllerParameter[] parameters = animator.parameters;
			foreach (AnimatorControllerParameter animatorControllerParameter in parameters)
			{
				if (animatorControllerParameter.type == type && animatorControllerParameter.name == ParameterName)
				{
					return true;
				}
			}
			return false;
		}

		public static bool FindAnimatorParameter(Animator animator, AnimatorControllerParameterType type, int hash)
		{
			AnimatorControllerParameter[] parameters = animator.parameters;
			foreach (AnimatorControllerParameter animatorControllerParameter in parameters)
			{
				if (animatorControllerParameter.type == type && animatorControllerParameter.nameHash == hash)
				{
					return true;
				}
			}
			return false;
		}
	}
	public class MaterialChanger : MonoBehaviour
	{
		[SerializeField]
		public List<MaterialItem> materialList = new List<MaterialItem>();

		[HideInInspector]
		[SerializeField]
		public bool showMeshesList = true;

		public bool random;

		private MaterialItem Active;

		public string AllIndex
		{
			get
			{
				string text = "";
				for (int i = 0; i < materialList.Count; i++)
				{
					text = text + materialList[i].current + " ";
				}
				text.Remove(text.Length - 1);
				return text;
			}
			set
			{
				string[] array = value.Split(' ');
				for (int i = 0; i < materialList.Count; i++)
				{
					if (array.Length > i && int.TryParse(array[i], out var result) && result != -1)
					{
						materialList[i].ChangeMaterial(result);
					}
				}
			}
		}

		private void Awake()
		{
			foreach (MaterialItem material in materialList)
			{
				if (material.Linked && material.Master >= 0 && material.Master < materialList.Count)
				{
					materialList[material.Master].OnMaterialChanged.AddListener(material.ChangeMaterial);
				}
			}
			if (random)
			{
				Randomize();
			}
		}

		public virtual void Randomize()
		{
			foreach (MaterialItem material in materialList)
			{
				material.ChangeMaterial(UnityEngine.Random.Range(0, material.materials.Length));
			}
		}

		public virtual void SetAllMaterials(bool Next = true)
		{
			foreach (MaterialItem material in materialList)
			{
				material.ChangeMaterial(Next);
			}
		}

		public virtual void SetAllMaterials(int index)
		{
			foreach (MaterialItem material in materialList)
			{
				material.ChangeMaterial(index);
			}
		}

		public virtual void SetMaterial(int indexList, int indexCurrent)
		{
			if (indexList < 0)
			{
				indexList = 0;
			}
			indexList %= materialList.Count;
			if (materialList[indexList] != null)
			{
				materialList[indexList].ChangeMaterial(indexCurrent);
			}
		}

		public virtual void SetMaterial(int index, bool next = true)
		{
			if (index < 0)
			{
				index = 0;
			}
			index %= materialList.Count;
			if (materialList[index] != null)
			{
				materialList[index].ChangeMaterial(next);
			}
		}

		public virtual void SetMaterial(string name, int Index)
		{
			MaterialItem materialItem = materialList.Find((MaterialItem item) => item.Name == name);
			if (materialItem != null)
			{
				materialItem.ChangeMaterial(Index);
			}
			else
			{
				UnityEngine.Debug.LogWarning("No material Item Found with the name: " + name);
			}
		}

		public virtual void SetMaterial(string name, bool next = true)
		{
			MaterialItem materialItem = materialList.Find((MaterialItem item) => item.Name == name);
			if (materialItem != null)
			{
				materialItem.ChangeMaterial(next);
			}
			else
			{
				UnityEngine.Debug.LogWarning("No material Item Found with the name: " + name);
			}
		}

		public virtual void SetAllMaterials(Material mat)
		{
			foreach (MaterialItem material in materialList)
			{
				material.ChangeMaterial(mat);
			}
		}

		public virtual void NextMaterialItem(int index)
		{
			if (index < 0)
			{
				index = 0;
			}
			index %= materialList.Count;
			materialList[index].NextMaterial();
		}

		public virtual void NextMaterialItem(string name)
		{
			materialList.Find((MaterialItem item) => item.Name.ToUpper() == name.ToUpper())?.NextMaterial();
		}

		public virtual int CurrentMaterialIndex(int index)
		{
			return materialList[index].current;
		}

		public virtual int CurrentMaterialIndex(string name)
		{
			int index = materialList.FindIndex((MaterialItem item) => item.Name == name);
			return materialList[index].current;
		}
	}
	[Serializable]
	public class MaterialItem
	{
		[SerializeField]
		[HideInInspector]
		public string Name;

		public Renderer mesh;

		public Material[] materials;

		public bool Linked;

		[Range(0f, 100f)]
		public int Master;

		[HideInInspector]
		[SerializeField]
		public int current;

		public bool HasLODs;

		public Renderer[] LODs;

		[Tooltip("Material ID")]
		public int indexM;

		public IntEvent OnMaterialChanged = new IntEvent();

		public MaterialItem()
		{
			Name = "NameHere";
			mesh = null;
			materials = new Material[0];
		}

		public MaterialItem(MeshRenderer MR)
		{
			Name = "NameHere";
			mesh = MR;
			materials = new Material[0];
		}

		public MaterialItem(string name, MeshRenderer MR, Material[] mats)
		{
			Name = name;
			mesh = MR;
			materials = mats;
		}

		public MaterialItem(string name, MeshRenderer MR)
		{
			Name = name;
			mesh = MR;
			materials = new Material[0];
		}

		public virtual void ChangeMaterial()
		{
			current++;
			if (current < 0)
			{
				current = 0;
			}
			current %= materials.Length;
			Material[] sharedMaterials = mesh.sharedMaterials;
			if (materials[current] != null)
			{
				sharedMaterials[indexM] = materials[current];
				mesh.sharedMaterials = sharedMaterials;
				ChangeLOD(current);
				OnMaterialChanged.Invoke(current);
			}
			else
			{
				UnityEngine.Debug.LogWarning("The Material on the Slot: " + current + " is empty");
			}
		}

		public virtual void Set_by_BinaryIndex(int binaryCurrent)
		{
			int index = 0;
			for (int i = 0; i < materials.Length; i++)
			{
				if (MalbersTools.IsBitActive(binaryCurrent, i))
				{
					index = i;
					break;
				}
			}
			ChangeMaterial(index);
		}

		internal void ChangeLOD(int index)
		{
			if (!HasLODs)
			{
				return;
			}
			Renderer[] lODs = LODs;
			foreach (Renderer renderer in lODs)
			{
				if (!(renderer == null))
				{
					Material[] sharedMaterials = renderer.sharedMaterials;
					sharedMaterials[indexM] = materials[current];
					if (materials[current] != null)
					{
						renderer.sharedMaterials = sharedMaterials;
					}
					continue;
				}
				break;
			}
		}

		internal void ChangeLOD(Material mat)
		{
			if (HasLODs)
			{
				Material[] sharedMaterials = mesh.sharedMaterials;
				sharedMaterials[indexM] = mat;
				Renderer[] lODs = LODs;
				for (int i = 0; i < lODs.Length; i++)
				{
					lODs[i].sharedMaterials = sharedMaterials;
				}
			}
		}

		public virtual void NextMaterial()
		{
			ChangeMaterial();
		}

		public virtual void ChangeMaterial(int index)
		{
			if (index < 0)
			{
				index = 0;
			}
			index %= materials.Length;
			if (materials[index] != null)
			{
				Material[] sharedMaterials = mesh.sharedMaterials;
				if (sharedMaterials.Length - 1 < indexM)
				{
					UnityEngine.Debug.LogWarning("The Meshes on the " + Name + " Material Item, does not have " + (indexM + 1) + " Materials, please change the ID parameter to value lower than " + sharedMaterials.Length);
				}
				else
				{
					sharedMaterials[indexM] = materials[index];
					mesh.sharedMaterials = sharedMaterials;
					current = index;
					ChangeLOD(index);
					OnMaterialChanged.Invoke(current);
				}
			}
			else
			{
				UnityEngine.Debug.LogWarning("The material on the Slot: " + index + "  is empty");
			}
		}

		public virtual void PreviousMaterial()
		{
			current--;
			if (current < 0)
			{
				current = materials.Length - 1;
			}
			if (materials[current] != null)
			{
				Material[] sharedMaterials = mesh.sharedMaterials;
				sharedMaterials[indexM] = materials[current];
				mesh.sharedMaterials = sharedMaterials;
				ChangeLOD(current);
				OnMaterialChanged.Invoke(current);
			}
			else
			{
				UnityEngine.Debug.LogWarning("The Material on the Slot: " + current + " is empty");
			}
		}

		public virtual void ChangeMaterial(Material mat)
		{
			Material[] sharedMaterials = mesh.sharedMaterials;
			sharedMaterials[indexM] = mat;
			mesh.sharedMaterials = sharedMaterials;
			ChangeLOD(mat);
		}

		public virtual void ChangeMaterial(bool Next = true)
		{
			if (Next)
			{
				NextMaterial();
			}
			else
			{
				PreviousMaterial();
			}
		}
	}
	public class Messages : MonoBehaviour
	{
		public MesssageItem[] messages;

		public bool UseSendMessage;

		public UnityEngine.Component component;

		public virtual void SendMessage(UnityEngine.Component component)
		{
			MesssageItem[] array = messages;
			foreach (MesssageItem messsageItem in array)
			{
				if (messsageItem.message == string.Empty || !messsageItem.Active)
				{
					break;
				}
				if (UseSendMessage)
				{
					DeliverMessage(messsageItem, component.transform.root);
					continue;
				}
				IAnimatorListener componentInParent = component.GetComponentInParent<IAnimatorListener>();
				if (componentInParent != null)
				{
					DeliverListener(messsageItem, componentInParent);
				}
			}
		}

		private void DeliverMessage(MesssageItem m, UnityEngine.Component component)
		{
			switch (m.typeM)
			{
			case TypeMessage.Bool:
				component.SendMessage(m.message, m.boolValue, SendMessageOptions.DontRequireReceiver);
				break;
			case TypeMessage.Int:
				component.SendMessage(m.message, m.intValue, SendMessageOptions.DontRequireReceiver);
				break;
			case TypeMessage.Float:
				component.SendMessage(m.message, m.floatValue, SendMessageOptions.DontRequireReceiver);
				break;
			case TypeMessage.String:
				component.SendMessage(m.message, m.stringValue, SendMessageOptions.DontRequireReceiver);
				break;
			case TypeMessage.Void:
				component.SendMessage(m.message, SendMessageOptions.DontRequireReceiver);
				break;
			case TypeMessage.IntVar:
				component.SendMessage(m.message, (int)m.intVarValue, SendMessageOptions.DontRequireReceiver);
				break;
			}
		}

		private void DeliverListener(MesssageItem m, IAnimatorListener listener)
		{
			switch (m.typeM)
			{
			case TypeMessage.Bool:
				listener.OnAnimatorBehaviourMessage(m.message, m.boolValue);
				break;
			case TypeMessage.Int:
				listener.OnAnimatorBehaviourMessage(m.message, m.intValue);
				break;
			case TypeMessage.Float:
				listener.OnAnimatorBehaviourMessage(m.message, m.floatValue);
				break;
			case TypeMessage.String:
				listener.OnAnimatorBehaviourMessage(m.message, m.stringValue);
				break;
			case TypeMessage.Void:
				listener.OnAnimatorBehaviourMessage(m.message, null);
				break;
			case TypeMessage.IntVar:
				listener.OnAnimatorBehaviourMessage(m.message, (int)m.intVarValue);
				break;
			}
		}
	}
	public class MWayPoint : MonoBehaviour, IWayPoint
	{
		public static List<MWayPoint> WayPoints;

		[SerializeField]
		private float stoppingDistance = 1f;

		[MinMaxRange(0f, 60f)]
		public RangedFloat waitTime = new RangedFloat(0f, 15f);

		public WayPointType pointType;

		[SerializeField]
		private List<Transform> nextWayPoints;

		[Space]
		[Space]
		public ComponentEvent OnTargetArrived = new ComponentEvent();

		public bool debug = true;

		public float StoppingDistance
		{
			get
			{
				return stoppingDistance;
			}
			set
			{
				stoppingDistance = value;
			}
		}

		public float WaitTime => waitTime.RandomValue;

		public List<Transform> NextTargets
		{
			get
			{
				return nextWayPoints;
			}
			set
			{
				nextWayPoints = value;
			}
		}

		public Transform NextTarget
		{
			get
			{
				if (NextTargets.Count > 0)
				{
					return NextTargets[UnityEngine.Random.Range(0, NextTargets.Count)];
				}
				return null;
			}
		}

		public WayPointType PointType => pointType;

		private void OnEnable()
		{
			if (WayPoints == null)
			{
				WayPoints = new List<MWayPoint>();
			}
			WayPoints.Add(this);
		}

		private void OnDisable()
		{
			WayPoints.Remove(this);
		}

		public void TargetArrived(UnityEngine.Component target)
		{
			OnTargetArrived.Invoke(target);
		}

		public static Transform GetWaypoint()
		{
			if (WayPoints != null && WayPoints.Count > 1)
			{
				return WayPoints[UnityEngine.Random.Range(0, WayPoints.Count)].transform;
			}
			return null;
		}

		public static Transform GetWaypoint(WayPointType pointType)
		{
			if (WayPoints != null && WayPoints.Count > 1)
			{
				MWayPoint mWayPoint = WayPoints.Find((MWayPoint item) => item.pointType == pointType);
				if (!mWayPoint)
				{
					return null;
				}
				return mWayPoint.transform;
			}
			return null;
		}
	}
	public class PointClick : MonoBehaviour
	{
		private const float navMeshSampleDistance = 4f;

		public Vector3Event OnPointClick = new Vector3Event();

		public GameObjectEvent OnInteractableClick = new GameObjectEvent();

		private Vector3 destinationPosition;

		public void OnGroundClick(BaseEventData data)
		{
			PointerEventData pointerEventData = (PointerEventData)data;
			if (NavMesh.SamplePosition(pointerEventData.pointerCurrentRaycast.worldPosition, out var hit, 4f, -1))
			{
				destinationPosition = hit.position;
			}
			else
			{
				destinationPosition = pointerEventData.pointerCurrentRaycast.worldPosition;
			}
			OnPointClick.Invoke(destinationPosition);
		}

		private void OnDrawGizmos()
		{
			if (UnityEngine.Application.isPlaying)
			{
				Gizmos.color = Color.green;
				Gizmos.DrawWireSphere(destinationPosition, 0.1f);
				Gizmos.DrawSphere(destinationPosition, 0.1f);
			}
		}
	}
	[Serializable]
	public class MaterialSound
	{
		public AudioClip[] Sounds;

		public PhysicMaterial material;
	}
	public class SoundByMaterial : MonoBehaviour
	{
		public AudioClip DefaultSound;

		public List<MaterialSound> materialSounds;

		private AudioSource audioSource;

		protected AudioSource Audio_Source
		{
			get
			{
				if (!audioSource)
				{
					audioSource = GetComponent<AudioSource>();
				}
				return audioSource;
			}
			set
			{
				audioSource = value;
			}
		}

		public virtual void PlayMaterialSound(RaycastHit hitSurface)
		{
			Collider collider = hitSurface.collider;
			if ((bool)collider)
			{
				PlayMaterialSound(collider.sharedMaterial);
			}
		}

		public virtual void PlayMaterialSound(GameObject hitSurface)
		{
			Collider component = hitSurface.GetComponent<Collider>();
			if ((bool)component)
			{
				PlayMaterialSound(component.sharedMaterial);
			}
		}

		public virtual void PlayMaterialSound(Collider hitSurface)
		{
			PlayMaterialSound(hitSurface.sharedMaterial);
		}

		public virtual void PlayMaterialSound(PhysicMaterial hitSurface)
		{
			if (!Audio_Source)
			{
				Audio_Source = base.gameObject.AddComponent<AudioSource>();
				Audio_Source.spatialBlend = 1f;
			}
			MaterialSound materialSound = materialSounds.Find((MaterialSound item) => item.material == hitSurface);
			if (materialSound != null)
			{
				AudioClip clip = materialSound.Sounds[UnityEngine.Random.Range(0, materialSound.Sounds.Length)];
				Audio_Source.clip = clip;
				audioSource.Play();
			}
			else if ((bool)DefaultSound)
			{
				Audio_Source.clip = DefaultSound;
				audioSource.Play();
			}
		}
	}
	public class TriggerProxy : MonoBehaviour
	{
		[Tooltip("Ignore this Objects with this layers")]
		public LayerMask Ignore;

		[SerializeField]
		private bool active = true;

		public ColliderEvent OnTrigger_Enter = new ColliderEvent();

		public ColliderEvent OnTrigger_Stay = new ColliderEvent();

		public ColliderEvent OnTrigger_Exit = new ColliderEvent();

		public CollisionEvent OnCollision_Enter = new CollisionEvent();

		public bool Active
		{
			get
			{
				return active;
			}
			set
			{
				active = value;
			}
		}

		private void OnTriggerStay(Collider other)
		{
			if (active && !MalbersTools.Layer_in_LayerMask(other.gameObject.layer, Ignore))
			{
				OnTrigger_Stay.Invoke(other);
			}
		}

		private void OnTriggerEnter(Collider other)
		{
			if (active && !MalbersTools.Layer_in_LayerMask(other.gameObject.layer, Ignore))
			{
				OnTrigger_Enter.Invoke(other);
			}
		}

		private void OnTriggerExit(Collider other)
		{
			if (active && !MalbersTools.Layer_in_LayerMask(other.gameObject.layer, Ignore))
			{
				OnTrigger_Exit.Invoke(other);
			}
		}

		private void Reset()
		{
			Collider component = GetComponent<Collider>();
			Active = true;
			if ((bool)component)
			{
				component.isTrigger = true;
			}
			else
			{
				UnityEngine.Debug.LogError("This Script requires a Collider, please add any type of collider");
			}
		}
	}
}
